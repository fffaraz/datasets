Lisp!
Lithp!
(defmacro LISP nil `(LISP)) ; oops.
"posted 6 days ago"??? I checked this subreddit yesterday and got lots of "no results here". WFT?
\***laugh**\* CL-USER 11 &gt; (defmacro lisp () '(lisp)) LISP CL-USER 12 &gt; (lisp) Stack overflow (stack size 16000). 1 (continue) Extend stack by 50%. 2 Extend stack by 300%. 3 (abort) Return to level 0. 4 Return to top loop level 0. Type :b for backtrace, :c &lt;option number&gt; to proceed, or :? for other options
How odd. It has no downvotes, so it hasn't been hidden.
hee hee. Oh the stupid people.
Well, it's sort of sad. It's mostly kids posting there. It does remind me, though... Back in November 2000 I was on a (non-computer-related) mailing list with John McCarthy. The question came up about [whether Al Gore has a lisp](http://www.isteve.com/2000_Does_Al_Gore_Lisp.htm). I replied: &gt; I hadn't noticed it before, but now I can hear Gore's lisp when he says words like "access". &gt; Still I think that we should defer to jmc@... on that, John McCarthy is THE lisp expert on this list. But nobody replied, not even jmc :-( Anyway, I think I'm indirectly responsible for On Lisp being put on-line (which was what started [that blog post](http://lemonodor.com/archives/2002/02/on_lisp_on_line.html)\) . I wrote Graham back in April 2001, complaining I couldn't find the book anywhere and asking if it could be an e-book or print-on-demand or something and he replied saying he just sent an e-mail to Prentice Hall to see if that could be done. I actually managed to find a physical copy, shipped from a book store in England, just a few weeks later!
I don't get it. Whatth ttha big deal?
I haven't read it whole, but [this](http://www.lisperati.com/casting.html) seems nice. At least, I can guarantee it's a nice reading.
Some good books free online out there: On Lisp and Practical Common Lisp. Then learn CLOS from Object Oriented Programming in COMMON LISP by Sonja e. Keene (bought it off Amazon a few years ago). 
 Beginner * [A Gentle Introduction](http://www.cs.cmu.edu/~dst/LispBook/index.html) * [Successful Lisp](http://www.psg.com/~dlamkins/sl/cover.html) (See chap. 3 for a "nutshell" summary) Most popular * [Practical Common Lisp](http://www.gigamonkeys.com/book/) Advanced * [On Lisp](http://paulgraham.com/onlisptext.html?asdf) * [PAIP](http://norvig.com/paip.html)
And there is also a [Lisp Cookbook](http://cl-cookbook.sourceforge.net/) on sourceforge, and some [Wiki Books](http://en.wikibooks.org/wiki/Programming:Common_Lisp) and this [SFU tutorial](http://www.cs.sfu.ca/CC/310/pwfong/Lisp/) which I've been using lately. But for me, the best place to start was trying to solve the [Euler Project](http://projecteuler.net) problems and the [L99](http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html) problems in lisp.
The parentheses! (hurr, hurr, no.) But in all seriousness, I can't really think of anything - but then again, I'm far from being a CL guru. As for the argument in the article, I think that a lot of CL users _do_ program as if rplaca and rplacd don't exist - but from what I understand, they are desirable in some situations - at the very least choosing not to use them in some situations would be purely a matter of taste. 
I agree with the suggestion in one of the comments to remove pathnames.
After reading nearly all the introductory texts, I believe "ANSI common lisp" by paul graham is the best one (if you already are a programmer). It is short (that is a plus, unless you judge books by their weight), extremely clear, and progressive, in the sense that you encounter the topics exactly in the right order, with no "I will explain this in later chapters". The only drawback is that it's only available as a printed book, and rather pricey (about $65). ISBN 0133708756. Then you can read Seibel's "Practical Common Lisp" (for a more modern view), Graham's "On lisp" (for reaching illumination), and Keene's "Object Oriented Programming in Common Lisp" (for CLOS, i.e. OOP in lisp). 
I often convince myself that macros are the only way to do something, but I'm usually wrong. Here's how I implemented his dotimes macro in Perl: http://blog.jrock.us/articles/Macros%20are%20probably%20not%20necessary.pod Macros are mostly useful for deferred evaluation, not for doing things that functions could do just as well.
Macros work just fine in FORTH, too. 
Deferred evaluation can be achieved by wrapping a lambda (sub { } in perl) around the code to be evaluated and then calling the thunk in the function: In perl: sub my_if { my ($predicate, $true_case, $false_case) = @_; # need if for conditional aspect only, not deferred eval if($predicate-&gt;()) { $true_case-&gt;(); else { $false_case-&gt;(); } } I think macros are primarily useful for: - boilerplate reduction e.g. adding those lambdas for delayed eval is annoying - manipulating the passed in code as code, rather than just evaluating it (lazily or not) e.g. a debug macro which prints the passed-in form and the evaluated value (not my example, see this [this thread](http://reddit.com/r/programming/info/ujj3/comments/cuokv) for more examples.) 
I tried to post this to your site, but the captcha didn't work. The first poster is right that it's best to keep all your iteration variables local. This is a more standard functional implementation: sub dmt_helper(\@\@$); sub dmt_helper(\@\@$) { my ($oldtimes,$oldargs,$code) = @_; return &amp;$code(@$oldargs) if !@$oldtimes; my @newtimes = @$oldtimes; my $nmax = shift @newtimes; for my $n (1..$nmax) { my @newargs = @$oldargs; push @newargs, $n; dmt_helper(@newtimes,@newargs, $code) } } sub do_many_times ($&amp;) { my ($nref,$code) = @_; my @args = (); dmt_helper @$nref,@args,$code; } do_many_times [3,2], sub { my ($x,$y) = @_; print "$x * $y = ", ($x * $y), "\n"; }; output: 1 * 1 = 1 1 * 2 = 2 2 * 1 = 2 2 * 2 = 4 3 * 1 = 3 3 * 2 = 6 Macros are executed at compile time, so where they're hardest to replace is for compile-time actions like defining functions and data structures. 
http://mitpress.mit.edu/sicp
It is not very publicised, but in my opinion this is by far, the best introductory Lisp book ever written: http://www.cse.buffalo.edu/~shapiro/Commonlisp/
Reaching illumination requires to also read AMOP, "The Art of the Meta-Object Protocol" (Kiczales etal.). You should know about CLOS, though.
Read the text, read the example problems, watch the lectures. I'm working through all three sort of at the same time. They're splendiferous.
some more: http://www.computer-books.us/lisp.php
No SICP? Is the person who compiled this list from the "Scheme isn't a Lisp" camp, or did they just search for the word "Lisp" in the title?
SICP isn't a language book.
My feelings are that Lisp-n for n &gt; 1 are a horrible, nasty thing (nothing against hygienic macros though), and that something a good Lisp needs is a good object system such as Python's. I think to be able to regard everything as an object which has a dictionary of properties upon which you're guaranteed universal polymorphism is one of the most powerful, useful programming features ever. It's the important thing about OOP. Classes? Visibility? Syntax? Those things I can live without (and I particularly want to live without some of them; visibility in particular), but it's not at all easy to do the same kinds of thing you do when you have parametric polymorphism at your disposal. I always thought it'd be awesome to have a Lisp with Python object semantics. I'm aware of Lython, but Lython is unfortunately abandoned, unsupported and kinda broken IIRC.
someone doesn't know how to program in lisp...
Lisp uses [symbolic expressions](http://en.wikipedia.org/wiki/S-expression), also called s-expressions, as the code.
Because they have a data type called a 'symbol', and most function and data lookups operate on it. Just my 2c.
Thanks for the answers, but they don't seem to (fundamentally) distinguish Lisp from other languages... I thought it might be to do with late binding, and referring to everything by a name ("symbolic"), instead of compiling it away. I did a fair bit of googling on this a while back, and the only conclusion I reached was that everybody described lisp as "symbolic" (eg. Symbolic machines), and everybody else already knew what it meant.
It's just a description of Lisp syntax? That seems... a surface sort of thing (to me), not something to name Lisp after. Or, is it fundamental because S-exp are so close to ASTs, that you can easily treat data as code?
A better way to get a feel for the effect that symbols have on programming (it is more then 'mere' syntax) is to actually make heavy use of them. If you have a copy of PAIP I strongly recommend trying out that chapter on building ELIZA. It uses symbols where most other programming languages would have used strings, it gives a real feel for how they are different. The fact that symbols can be used very much like strings, but also be used to call functions and name variables (without needing to do anything like .send("methodName")) allows you to do some very powerful things (and also does make a significant difference in how you look at some problems). note: damnit now you've gotten me wanting to start reading PAIP again, rather then focusing on learning smalltalk!
Check out Paul Graham's article [The Roots of Lisp](http://www.paulgraham.com/rootsoflisp.html). In particular, look at McCarthy's original implementation for Lisp (source code in CL by Paul Graham is [here](http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp)). You'll notice that the original interpreter did not have any support for characters or even numbers! The only primitive types were symbols and lists. 
&gt; It's just a description of Lisp syntax? That seems... a surface sort of thing (to me), not something to name Lisp after. How many other languages from 1958 did you compare it to?
you're saying the name isn't relevant today? that it no longer says anything particular to lisp? That would explain a lot.
Not exactly. I'm just trying to make sure you're remembering when it was named. For one, "Lisp" stands for "List Processing Language", so "Lisp" isn't named after "symbols". The original paper, "Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I", was published in 1960 (after inventing it in 1958). Is that what you're asking about?
If it helps, Lisp code can be viewed as trees(well directed graphs in common lisp) of symbols and literal expressions. This means that whenever you use macros you are performing a transformation over symbolic expressions. It's very much a part of what makes lisp special, it's not enough for code to be data, there also needs to be a good way to manipulate this data and symbolic programing was chosen/found to do this.
lisp is often described as being "symbolic". I was wondering why.
So, symbolic programming doesn't mean programming with symbols, but has a technical meaning, to do with the specific "symbolic expressions" and "tree transformation" of lisp? Would it be called "symbolic programming" if in another language (e.g. java), you manipulated ASTs of that language? (even though more awkward). Or is "symbolic" specific to lisp - in contrast to general terms like *dynamic*, *garbage collection*, *functional PL*, *declarative PL*, *late binding*? 
Well, I see it more as symbolic programs being programs that manipulate symbols or collections of symbols, and the standard method of manipulating the AST, in lisp, is to use a symbolic program. You don't need to do it this way; you could take large strings mess them about, and then drop them back into your code body using READ-FROM-STRING, but it is much more convenient to treat them as trees of symbols, and it allows you to write macros that just do the right thing with out having to worry about corner cases. I don't think it's symbolic programming, unless you use a symbol data type, or something broadly equivalent. 
The feature of symbolic programming in Lisp wasn't simply a unique feature of the language in 1958, otherwise nobody would have written a [gentle introduction](http://www.cs.cmu.edu/~dst/LispBook/index.html) to it in 1990. I am curious xzxzzx as to what contemporary languages make use of symbols in the same way that Lisp does? Ruby has things called 'symbols' but they're actually closer to Lisp 'keyword symbols' and aren't used nearly as heavily as symbols are in lisp. Symbols are interesting, for example they also act somewhat as mini-objects since you can associate properties with them, symbols don't have to have a value, etc. Reading the [clhs](http://www.lisp.org/HyperSpec/Body/syscla_symbol.html) on them also provides a lot of good information. edit: I mean that 'I am curious' in a sincere, not snide way, there is a lot I don't know so if I am misunderstanding something I would love to know more.
Well, objects give you much of what symbols give you in terms of ways of storing related data (particularly dynamic objects like the ones in Python). Nothing has something exactly like Lisp's symbols, of course, because if it did, we'd just call it "a Lisp". The big difference, I would say, is that Lisp's data lists are exactly like its program lists, and the program itself is "composed of" symbols you can do operations on, which other languages sometimes get semi-right (at least, it's no longer *totally* weird in every way ;).
I think the term has more intuitive meaning than technical. And it is fairly loaded and doesn't carry a lot of weight by itself. But at any rate, there are only a few other languages with symbols as a fundamental data type (Scheme, Smalltalk and Ruby are the only ones that come to mind). For one thing, as someone else said before me, the whole syntax of the language is represented in symbolic expressions (sexp's). You mention elsewhere that this seems like a superficial interpretation, but the fact is that Lisp's syntax, or lack thereof, has very deep ramifications for Lisp programming. Macros and the tree structure of the code, while very important, undermine the point. There is nothing between the programmer and the compiler with Lisp. You can interact with the process at any level and it goes all the way down. Secondly, Lisp and Scheme encourage a programming style using symbols to convey meaning. Someone else mentioned that this has very deep applications in _Principles of AI Programming_. Lisp's heterogenous lists and the existence of symbols permit a kind of polymorphism where functions at the top can load different data into the lists and functions at the bottom can look for it, without functions between having to know about it. A kind of cheap polymorphism is possible. This kind of programming in languages with only strings would be highly discouraged, even though it is quite flexible. This seat-of-the-pants kind of flexibility was treasured by AI researchers and dabblers because quick results did not conflict with flexibility later. Things didn't have to be rewritten from scratch as much. The clincher really is that the same tools you can use to program quickly and elegantly with symbols in your own programs apply just as well to the program you are writing itself. Lisp is very organic: you can modify the way it parses tokens in your code, you can modify the trees generated, you can step in and create new syntactic structures, and it is all elegant and powerful because you are not using backdoors, preprocessors or obscure libraries, but the very machinery which makes Lisp itself executable. You are a peer with the implementor of the language, not just a user. This is largely because the types which the language itself uses to implement itself are the same types you are using to do your work. This is a key difference between Lisp and OCaml, which has something akin to the backquote operator, but has its own strongly-typed AST you have to build to create a macro, rather than just a list of symbols and values. And most languages don't let you get that cozy with the parser. Forth is the only one I can think of. This seems like a large departure from the question of 'symbolic programming' but I hope this ties things together for you a little.
&gt; In particular, look at McCarthy's original implementation for Lisp Not to be picky, but McCarthy didn't implement Lisp. He actually invented Lisp as an attempt at denotational semantics; it was invented as mathematics, not a programming language. Steve Russell wrote the first Lisp implementation after reading (the first version of) McCarthy's paper "Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I" and realizing that the `eval` construct could be implemented as a Lisp interpreter. From [Wikipedia](http://en.wikipedia.org/wiki/Lisp_\(programming_language\)#cite_note-2): &gt; According to what reported by Paul Graham in Hackers &amp; Painters, p. 185, McCarthy said: "Steve Russell said, look, why don't I program this eval..., and I said to him, ho, ho, you're confusing theory with practice, this eval is intended for reading, not for computing. But he went ahead and did it. That is, he compiled the eval in my paper into IBM 704 machine code, fixing bug , and then advertised this as a Lisp interpreter, which it certainly was. So at that point Lisp had essentially the form that it has today..." McCarthy also favored M-expressions, e.g., `car[cons[A,B]]`, and it was the first Lisp programmers that decided to go with S-expressions. The operations `car` and `cdr` got their names from two assembly language macros for the [IBM 704](http://en.wikipedia.org/wiki/IBM_704).
There are a couple of related uses of symbols that end up with lisp being called a symbolic language. In the strictest sense symbols are simply interned strings. If you have written a translater in C you have will have interned strings and assigned them a number. (eg. if=1 while=2 etc) In most languages you have symbols, but these are created by the compiler during compilation and are not available to the end user. In lisp the symbol is available throughout the life time of the program. Earlier you alluded to the fact that lisp represents all of its code as an abstract syntax tree, that is then manipulated. If you had a AST in java and were manipulating it you would be doing some amount of symbolic programming, but the language has not been built around this concept, so you wouldnt call java a symbolic programming language. For example: you might have a recursive decent parser that has a function named "if" that you call when you encounter the symbol 'if in your AST. This is essentially using symbols for function dispatch. One of the first places where I "got" symbolic programming was when I first encountered pattern matching. I might have a clause that reads: (Russ is a _). If I have a list of possible other clauses in a database such as: * (Ryan is a male) * (Shelly is a female) * (Russ is a male) I could then simply match the correct one and find out that Russ is a male. Here we have done computation on the symbols themselves. They are expressing meaning. Using the same database I could ask (_ is a male) and it could return (Russ Ryan) as the result. To answer, of course all of this stuff could be accomplished with regexs and a ton of string manipulation, but that is essentially a [Turing Tarpit](http://en.wikipedia.org/wiki/Turing_tarpit) argument. Lisp is a symbolic language because the symbols that make up the expressions of the language are readily available and manipulated throughout the programs lifecycle.
Indeed. McCarthy did not actually implement it. What I meant was his original specification.
Symbols are used for macros and symbolic-manipulation applications. They're faster than strings, because symbols are compared based on integer equality of memory addresses or other numerical indexes, instead of having to do character-based string comparisons. The data structure (symbol) that represents an idea can also store properties associated with the idea in a field that in Lisp is implemented as a list of properties called the plist. The arguments passed to a macro are typically symbols and (nested) lists of symbols, which often represent executable code. The macro will typically reshape the symbol trees from a compact, user-friendly form to an expanded form that the computer understands. Knowledge-representation systems, symbolic-math applications like Mathematica, and other AI programs use symbols to handle thoughts or concepts as first-class objects. When a user of a symbolic-math program enters a mathematical expression to be simplified or expanded, a Lisp-based application will usually represent the expression as a tree of symbols. The application will have rules that look inside the tree and reshape it into the desired form. That's symbolic manipulation. Doing computation with symbols that represent ideas instead of numbers that represent quantities.
[Lectures 7a and 7b of the Structure and Interpretation of Computer Programs video lectures](http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/) were real eye-openers for me. That's where I had the elusive aha! moment people talk about where you suddenly "get" Lisp. If your background doesn't include Lisp watch the preceding lectures to understand the terminology and syntax. They introduce the meta-circular evaluator which makes explicit the magic behind the use of symbolic expressions (basically lists) which results in code / data equivalence. Gerald Sussman actually writes it in concrete skeletal form on the board during the lecture. Actually if you haven't why not watch them all anyway they contain a whole swathe of excellent ideas and thinking about programs. 
The author does not follow the advice of his title, and seems to miss SOME, EVERY and IDENTITY. It's a big language. The best way to learn to code in lisp is to read lisp code. Study the code of great lispers and absorb their idioms and patterns. Read the hyperspec constantly. Then you will begin to 'know your idioms'. 
Thank you. I think I'm getting it now. Being symbolic is an important feature of Lisp, but it how it is combined with other aspects of Lisp that make it so powerful. A language can be symbolic without being a lisp dialect (such as Ruby). BTW: Erlang has "atoms", which seem to conform to your definition of symbols in how they are used for polymorphism. Erlang is a functional language, but I don't think it is a "lisp". 
from your prolog-like example, I would guess that prolog would be called "symbolic" too. It seems that "lexemic" would have a similar meaning to symbolic, in that the interpreter/parser does the string lookup to get the symbol (i.e. the code for it). Then you can compute with the symbol directly, which is convenient, esp when there is support built-in (such as pattern matching) - otherwise, you'd have to manage the hashtable yourself, and the support for symbols. As someone else was saying, perhaps it's not so much the "symbols" themselves, but the approach to programming that it enables. 
I think you get it. And you're correct about Erlang.
That is what I was trying to convey. It is not the symbols, but the way you program when they are available. And yes I would consider logic languages (prolog, clips, lisa etc) to be symbol manipulation languages. Many of these are, or at one point were written in lisp.
I think my reply to you might have seemed a bit snide, and I just wanted to clarify that I appreciate you going to the trouble of communicating the information you did. Thanks! :-) 
Not a problem, no offense taken (or intended, for that matter!). It occurs to me that I never really answered your original question, at least not ina direct way. I think we call Lisp "symbolic" because Lisp works on lists of symbols without getting tied down too much on what the symbols represent (data is code is data). Of course, eventually Lisp works on the actual data that the symbol represents (= 2 (+ 1 1)), but think about what a macro does -- it processes the symbols of the language itself rather than the data those symbols represent.
Wow, outstanding idea. I'm going to have to try this...
Before work and life got incredibly hectic I started writing my own roguelike (using GURPs instead of D&amp;D) in Lisp. It was coming along pretty well, too. Kinda fun to run around the map whacking monsters.
Rogue, or re-implement things in Lisp? I think re-implementing things in other languages is brilliant.
The re-implementing part, I'm not interested in Rogue. I actually regularly re-implement my *own* software in several languages, but I hadn't thought of trying to re-implement someone *else's* software in a more interesting language. 
The Lisp-2-ness. This is what has been keeping me from learning Common Lisp and using it.
[Learning Lisp Fast](http://cs.gmu.edu/~sean/lisp/LispTutorial.html) is a nice quickstart tutorial one can go through before reading an introductory book.
Of course, Perl's 'regular expressions' are actually not regular and can support (at least some) context-free grammars, IIRC. And since CL-PPCRE is based on Perl (the name stands for Common Lisp Portable Perl-compatible Regular Expressions)...
You know, this reminds me of a problem I had once, where I couldn't find a function that would convert a single numeric character into the actual number. That functionality does exist, in digit-char-p, but I didn't find it until it was pointed out to me. I don't suppose there's a resource that lists these clever, semi-hidden bits of functionality?
I think this happens in any language. In my first bigger Scheme program I reinvented at least 3 of ~8 functions, because I did not know they existed at all.
Yeah, this is one of the things that I like in Scheme. Oh, can we mix Scheme with all the CL niceties like portable code (across implementations), CLOS, comprehensive standard library and combine the userbases? :)
Dead link is dead. See http://zwizwa.be/darcs/staapl/www/ Also, it's intended for embedded processors (the PIC18).
Step 1: Switch to Common Lisp ; Step 2: Switch to Postgresql. Problem Solved. 
Oh yes, I have always felt that interfacing with C libraries in Common Lisp is such a pleasure :)
it _is_ quite simple via CFFI, but why bother? postgres has a wonderful socket API. Cheers, drewc
See also: http://www.physorg.com/news136022928.html Biology enters 'The Matrix' through new computer language
ack, too bad it's also eye-gougingly unattractive :P Why is it that cool technologies and cool design so rarely go together?
I've seen people mention it, but I have never played with it; how fast is it compared to using native libs?
Which part is unattractive? If its the parens you are missing vital info about how cool they are.
It is complete in terms of Common Lisp's defined symbols.
The design of their website (gainesville-green.com). Parens don't bother me, though I'd much rather use a sugared syntax.
Ouch! Sorry to have made you gouge your eyes... (It was my design rechanneled through a couple other programmers.) The designers have been very busy. We have been assured that they will make it look nice once they get a chance
Oh, it's okay, I can't design to save my life either, and I'm working on finding a decent designer as well. Just commenting on the 'emblematic of the technology with middling terrible design' trend.
W O W ! This is one useful QR card. Thanks.
in addition to the text, the contents of the [course](http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-001Spring-2005/CourseHome/index.htm) it was written for are also available, so there's some other material there. &gt;watch the lectures Where are the lecture vids?
Pretty neat wiki snippet on the topic: http://en.wikipedia.org/wiki/Regular_expression#Patterns_for_non-regular_languages Some other features that make Perl regular expressions not regular are look-ahead/look-back. I &lt;3 language nerdiness 
They used to be easier to Google. Had to resort to advanced Google usage to weed out all the discussion of the video lectures just to find the actual lectures. http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/
Depends on just about everything.. implementation, operating system, etc.. but it's plenty fast, or fast enough, or faster.
As an emacs user, I vote we rename slime to "stiff". 
hmm, How many Lispers use vi(m)? Doesn't seem to be a promising project. If you want sth. like slime on vi(m) than just use slime on emacs in vim-mode. 
Staapl home page is http://zwizwa.be/staapl I just added a tutorial for the interactive part: http://zwizwa.be/archive/pic18-interaction.html The general idea: http://zwizwa.be/archive/staapl.html It's part of PLaneT too. 
Alas, Viper-mode isn't at all the same thing. Now, if I could just get ECL into the official Vim tree...
I think it does, but with what I'd like it to have, it'd cease to be Common Lisp. I'd love to have a Lisp with Python's type system. First of all it should be a Lisp-1. This is essential; it feels ugly and nasty to have several value namespaces and not be able to treat functions exactly like any other value. Second, I would like to have CLOS or a similar object system built-in. (I feel "everything is a" is a criterion of purity, which is a criterion of good and beauty.)
This worked fine so I put the code into the package and declared my work done.
Joswig's comment is worth reading. It has some good advice for writing libraries in general. 
Ranier Joswig says it all. 
While I love the strengths of Lisp, I also love the purity of a *real* object-oriented language (by real I mean not Java nor C++; it has to be something like Python or Smalltalk). It seems OOP is not as big in Lisp. While I'm not by any means an object-obsessed terrorist, the idea of everything being an object, having class, and a more uniform interface attracts me. (To me, "everything is a ..." is a criterion of purity, and purity is a criterion of good. I like Lisp because I like purity (which means - yes, Scheme over Common Lisp for me).) I've reading this: http://t-a-w.blogspot.com/2007/06/object-oriented-dialects-of-lisp.html and e7 looks pretty interesting, though the site seems to be dead. Reddit, what would you recommend for an object-oriented Lisp? I value the following attributes or features specially: - Everything an object - Lisp-1 (as in Scheme) - All methods are, thus, properties, and all properties are, thus, public (as in Python) - Some macro for comfortable property access would be nice, though not absolutely essential - No bizarre scoping, just lexical scoping please (with perhaps dynamically scoped variables as an option) Classes are not necessary (though not at all unwanted); I'm willing to try different OO approaches such as prototype-based OOP.
&gt;I also love the purity of a real object-oriented language The perceived "purity" of object-oriented approach is bollocks, but i'll leave that to you. &gt;It seems OOP is not as big in Lisp. You are misinformed here. There's nothing more powerful than CLOS (Common Lisp Object System), not even a smalltalk. I would recommend you CL (sbcl would be a good candidate). If you are afraid to part with familiar world, then clojure. Clojure will give you seamless access to java libraries. 
Everything is an object under CLOS, even the built-in types. And you're not likely to find another OOP language with multiple dispatch. And it has a nice macro `with-slots`, for accessing properties. If you absolutely must have a Lisp-1, take a look at TinyCLOS + scheme, probably MzScheme. Anything else, you're probably going to be stuck in some tiny ghetto with no other programmers, unless it's like Qi or Clojure, but I think you're a little misinformed about what Lisp has to offer.
Common Lisp was the first OOP Language to get standardised! CLOS with its MOP is probably one of the most flexible Object Systems. So stop yapping about OOP not being valued in Lisp. 
Try Common Lisp, learn CLOS and then the MOP. CL Has 1 and 5, the rest (save for lisp-1) are either not-needed or unfounded, or disappear in proper CLOS code. CLOS is a really well designed extensible OO system that is a superset of almost all other OO systems i know. Give it a try, you'll likely be pleasantly surprised, then amazed :).
&gt; The perceived "purity" of object-oriented approach is bollocks I'm not object-obsessed in the sense that everything I do has to be an instance of a class hierarchy longer than European monarchies (I don't even consider classes to be essential); I don't give three bits a damn about "design patterns" (mostly glorified copypasta you require when your language doesn't have decent abstraction power), and I'm aware of the power of generic abstractions such as lists and dictionaries. It's just that, even if I'm dealing with just lists of generic objects (i.e. hash tables with hacks), I like generics, I like to be able to tell the type of anything and introspect into its properties (even if it doesn't have any), and to be able to customize and redefine the behaviour of generics for anything I please, and to do this properly, I need everything to be an object. Coupled with first-class functions, another feature I love, I want functions to be object values as regular as an int, hence my love for Lisp-1s. I don't think there's anything wrong with this approach, but if you see so, please let me know. Thanks for the reference on Clojure. Lisp-1, reader syntax for maps, and I'll have to study how objects work but it looks good. Plus access to a big standard library (not my favourite, but it's better than most Lisps'). Definitely worth a look!
Yes, I had heard about CLOS' features; it's just that the "weirdness" of Common Lisp (as opposed to something I'm far more used to such as Scheme) and the comments I've heard about its libraries (mostly regarding inconsistency) make me think twice before investing time on it. I saw MzScheme adopted TinyCLOS, but the documentation about how to use it is scarce to say the least (either that or I failed at finding it); otherwise I was pretty interested. As I said in my reply to Vagif Clojure looks very interesting. Qi does as well; it goes well beyond most Lisp's I've had a look at, and yum, Lisp-1-ness. Thanks for the information.
Dylan is a multiple-dispatch objects-all-the-way-down lisp with an ALGOL syntax. It was originally designed with S-expression syntax, but the designers at Apple changed the syntax to something more mainstream later. You may be interested. However, Dylan is not receiving enough love at the moment so the available tools are somewhat rough.
Dylan has both a Lisp-style &amp; Algol-style (implemented as reader macros per the DRM); ISLISP is OO from the ground up, and there are also things like T &amp; OakLisp. RScheme is built in a similar vein. 
&gt; The perceived "purity" of object-oriented approach is bollocks, but i'll leave that to you. To me? Why, it's due to Russell's Paradox. An object's type is its interface. An interface is an object. An object's type is its interface. An interface is an object. An object's type is its interface. ... &gt; This solution to Russell's paradox is motivated in large part by the so-called vicious circle principle, a principle which, in effect, states that no propositional function can be defined prior to specifying the function's range. In other words, before a function can be defined, one first has to specify exactly those objects to which the function will apply. (For example, before defining the predicate "is a prime number," one first needs to define the range of objects that this predicate might be said to satisfy, namely the set, N, of natural numbers.) From this it follows that no function's range will ever be able to include any object defined in terms of the function itself. As a result, propositional functions (along with their corresponding propositions) will end up being arranged in a hierarchy of exactly the kind Russell proposes. http://plato.stanford.edu/entries/russell-paradox/
Actually, per the DRM (Dylan Reference Manual) the algol-syntax is reader macros; see chapter 14 in the DRM: http://www.opendylan.org/books/drm/Built-In_Macros_and_Special_Definitions So, most Dylan systems I know of (Marlais, Open/Gwydion Dylan, &amp;c.) have both (they have to if they support the spec). Actually, Marlais doesn't do it via macros yet, iirc. You are correct about Dylan not receiving the appropriate level of love, which is unfortunate for a language that would be great to use atop Cocoa (one thing I'd like to do is make a F-Script-like system that uses Dylan for Mac OS X &lt;sigh /&gt;).
&gt; Classes are not necessary (though not at all unwanted); I'm willing to try different OO approaches such as prototype-based OOP. I have a soft spot for the [protobj](http://www.neilvandyke.org/protobj/) prototype "example" library for Scheme. First class functions and dictionaries with prototypical inheritance are a good match because the nuts and bolts of the object are available for reflection and extension of the language. See also: ECMAScript.
&gt; I need everything to be an object. Be careful what you wish for. If everything is an object then properties are objects. When you send for the type of a property you get another object. And when you inquire the type of that object you get yet another object. If you send for the behavior of an object you get an object whose behavior is defined by more objects. When you press CTRL-D in frustration the interpreter will return a quit object with a destroy method that returns a nil object responding to an nil? message that returns a true object ... If everything is an object then your computer will implode into a black hole and turn the universe inside out, and provably so.
Why not have everything be a list? I mean, that provides even better purity, and is much simpler to implement well.
Because I like hash tables of properties, and objects in a proper OO language ought to be that. Essentially, it's like making everything a dictionary instead of a list.
That was a nice read. In practice, it works. The interpreter or compiler is smart enough to special-case behind the scenes, but I don't have to do it myself.
If you're already using PLT scheme, then the class system that comes with that (class.ss) is pretty neat. Coming from a C++ background, I found it a much cleaner way of doing OO.
Okay, so why bother with all the other stuff? Just do dicts.
AFAIK, they ditched the S-expression support in Dylan when the project started to run into trouble at apple and never got round to replacing it. Things might have changed since I last looked.
&gt; it's just that the "weirdness" of Common Lisp (as opposed to something I'm far more used to such as Scheme) and the comments I've heard about its libraries (mostly regarding inconsistency) make me think twice before investing time on it. As my friend likes to say, "It's better to have a feature in your language and not use it than to not have it and miss it." That is one of the most important philosophies of CL. You should definitely consider it in your decision. As someone who has been down the "I love Lisp-1-ness and simple, clean, consistent languages" road, I urge you to choose CL. When you study it more carefully you will find it's not as inconsistent as people make out. Take it from me, Lisp-1 vs Lisp-2 (or Lisp-n) is not a big deal, certainly not enough to make you reject CL. You will see why having multiple namespaces makes sense for CL. You will see that CL is so organic and flexible that these concerns hardly matter. You can view CL as a set of language building blocks. (Just look at Qi, for example.) You could create your own perfect Lisp on top of CL, but you will find that it's a waste of time when CL itself has everything you need. As others have said, CLOS is an extremely good object system. It goes to the core of what a dynamically-typed object system should be about. You can see how the flexibility of Lisp influenced its design, as the designers were able to incorporate almost any feature that you could possibly need. If you really want to change or extend the object system (and mostly you don't), there is the MOP, which allows you to do so in an object oriented way. At the moment, if you go the Scheme route, you must stick to a single implementation in order to preserve your sanity. Trying to write portable Scheme code while the community and the implementors don't agree on which of R5RS and R6RS (and ERR5RS) is the de facto standard is a nightmare. And sticking to one implementation is where your problems start, even if that implementation is full-featured, like PLT Scheme. You'll find that there is some useful library that uses a different macro system or requires non-standard features, or that some other Schemers you want to work with prefer Meroon to TinyCLOS, or that your code really needs to run as fast as it would in Larceny or Ikarus. (In any case, if performance is a concern to you, you should know that the fastest Schemes are usually outperformed by most native-compiled CLs, thanks to type declarations. SBCL is [particularly good](http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=sbcl&amp;lang2=ikarus) in this area.) Clojure is a much better alternative at the moment, in my opinion. If you like the Java world, then this is possibly the way to go. But objects with mutable state go against the pure functional philosophy of Clojure: "Clojure eschews the traditional object-oriented approach of creating a new data type for each new situation, instead preferring to build a large library of functions on a small set of types." ([http://clojure.org/multimethods](http://clojure.org/multimethods)). Its object system is a reduction of CLOS to its bare essentials, namely multimethods. If you're an OO guy you will want the full power of CLOS sooner or later. In summary, do yourself a favour, save yourself a lot of time and frustration and go with Common Lisp.
At the very least, I want *everything* to have an associated dictionary, in a Lisp.
The documentation for PLT Scheme's native objects system is available here: [http://docs.plt-scheme.org/guide/classes.html](http://docs.plt-scheme.org/guide/classes.html) The documentation for Swindle, PLT Scheme's version of TinyCLOS is available here: [http://docs.plt-scheme.org/swindle/](http://docs.plt-scheme.org/swindle/)
Plenty of others have pointed out that Common Lisp should meet all of your requirements. Also, you might consider looking at Goo: http://people.csail.mit.edu/jrb/goo/ although I haven't heard anything from the project in a while.
Yup, those are the ones I found, but is that... all? The Swindle page is barely a readme, which points to a nice looking but outdated and more or less incomplete reference of it. Is there any tutorial available, or at least a good example demonstrating its features? Something like the documentation for native classes. The problem with PLT's native classes is that, at least as far as I've seen, there's no introspection, and they're just yet another completely different Scheme type. Everything else stays as it is, so you get a type system like PHP's where the most commonly used values are not objects and do not support method calls, inheritance or other features, and you can't fully exploit the abstraction because you have a dozen types to check that are not objects - symbol, number, string, box, cons, struct, procedure, promise and company - before you can rely on object features. Standard Scheme has some desirable features, such as the fact that any symbol can refer to any value and that all values are treated equally, but without any introspection, constructors, and company, you can't abstract types because you have to keep checking whether what you receive is this or that before you attempt to send a generic message or do anything with it.
So you want PHP?
I see what you did there :p . Of course not; a list should have an associated dictionary of properties (some of which could be executable and known as methods), but not be the dictionary itself.
Thanks for your insight. I won't take CL completely out of the question, and will try to explore it, perhaps together with Clojure. I'm aware of the unfortunate state of Scheme, that's what's keeping me from starting a big project with it. As for Clojure, I don't particularly like the Java world (esp. the Java language; I don't do Java without getting paid, very well paid), but if it allows it to run on a fast virtual machine (though I bet the lack of tail-call optimization is because of the JVM) and it gives it access to a huge (albeit overengineered, sometimes just ugly) standard library, it doesn't look bad at all (at least I know they won't get bored and abandon it because they have to implement everything). &gt; Clojure eschews the traditional object-oriented approach of creating a new data type for each new situation, instead preferring to build a large library of functions on a small set of types And I completely agree for most cases. I think Abelson and Sussman said something like that in SICP; 10 types with 100 functions to handle each are more useful than 100 types with 10 functions to handle each. I model with lists and dictionaries as much as I can, but for more complex behaviour (e.g. when I need to attach lots of closures to data), I like objects, and I like to have a powerful, consistent object system, e.g. one that makes everything an object even if I'm not using it all the time. That's how I write Python; I define far less classes than most people, yet I love its object system and that's what's keeping me writing Python, mostly.
Meh, it's just Scheme.
One thing which I think turns off a lot of newcomers to Lisp is all the trade-offs which are possible: 'well, you could use REDUCE and LENGTH, but if you care about efficiency and deal with lists, then you'll want different code' is a great example, as I believe a lot of programmers get upset that they can tweak things this way. They perceive that they _have_ to tweak things. What they don't realise is that in other languages they still have to tweak things to get good performance but they _can't_. Python offers two sequence types: lists and tuples. If one needs more then one is pretty much stuck, as nothing built atop objects is going to approach the speed of lists and tuples. But Common Lisp offers a wide variety of options to solve many different problems, and worst-case one can roll one's own solutions--and with some tweaking they will be _highly_ efficient. It's nice to have options.
What is different? How hard do you think it would be to fix?
&gt; I think Abelson and Sussman said something like that in SICP; 10 types with 100 functions to handle each are more useful than 100 types with 10 functions to handle each. Minor correction: It was Alan Perlis, in the foreword to SICP. Here's the quote: &gt; It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures. As an aside, this is an interesting statement, and I have thought about it many times without really understanding it. It's my personal zen koan, and one day I hope to be able to tell the ghost of Perlis that I fully understand what he meant, or that it's complete nonsense :) PS. When you try CLOS, don't be put off by the fact that methods need to have congruent lamba lists. 
I believe it stands for Emitter Coupled Logic.
How exactly is that different than PHP? Or JavaScript for that matter?
PHP? null, bool, int, float, string, array and resource are not objects. null, bool, int, float, string, resource and object are not arrays, so I can't crank my own object system arrays either. On top of that, it doesn't have first-class functions. JavaScript has a terribly broken type system. Almost pretty much sort of everything is an object, for the most part, often. undefined, null, and other values are not quite objects and bite. in, .constructor and other things don't always work; typeof does pretty funny things, etc.. The way almost every single operator works is broken in an amusing way, and there's no way to fix it or overload them in your own classes. JavaScript has good ideas and intent, but its type system seems to be implemented by drunken 12 year olds who had been practiced a lobotomy.
Drats... I was hoping for a lisp that was usable on a microcontroller or other embedded design. Well, hopefully google will consider lisp for the next GAE supported language.
Yes &amp; No; the DRM (chapter 14) lays out defining the Algol-syntax using macros atop the Scheme-y system. However, you are correct that it was done only when the project ran into trouble. 
I didn't say everything was an object; I said that in PHP arrays have an associated dictionary of properties where some of which can be executable (sortof), but is not the dictionary itself. This property is also held by Javascript. It's also held by Self. You'll note that this property you describe is not held by Python (`TypeError: can't set attributes of built-in/extension type 'list'`) or Smalltalk (except by way of `at:put:`, and that abstraction fails for proxy objects), both of which were described previously as [pure object oriented](http://www.reddit.com/comments/6uzi8/best_objectoriented_lisp/c04xqvh). Oddly enough, Perl has lists like this (because of tie), and I've never heard anyone praise it's object-orientedness... However, I don't think such lists make sense in a lisp; would the `cdr` of a list (which is also a list) share a property list (dictionary, whatever)? If not, how would you change the class/prototype pointer of the list such that cdr-recursive operations (such as are common in scheme) would be implemented? If so, how would you handle sharing tails of a list?
Huge list of unsupported features. Moreover, since many have tried improving it without really getting anywhere (i.e., rewriting Vim in Emacs), I'll trust their judgement and simply won't do that again.
In Python, you can't set attributes on builtin or instances of them, but that's because of the underlying more efficient implementation in C. If you subclass them you can, and you don't lose absolutely anything by doing so. Just do something such as class alist(list): pass and use alist instead of list. I agree, though, that they should allow you to modify just any object, including the builtin ones. And regardless of if you actually can add attributes to these objects, you can introspect into them, obtain their class and data dictionary, subclass them, get a constructor for them and copy them by calling it, etc. Languages such as PHP doesn't allow this. On a side note, you'd have trouble when trying to implement your own object system with PHP like that, because of the lack of closures, lack of syntax for creating its sort-of-anonymous (more like "nonymous") functions, lack of first-class functions allowing you to tell a function from a text string, and lack of garbage collection for functions. Regarding lists: Lisp lists aren't a list object, but a chain of cons objects. Each cons cell ought to have its own dictionary of associated properties (which may very well be optimized away when it's unused). '(1 2 3) is equivalent to (1, (2, (3, ()))) in Python. If you want to associate properties to collections of elements, you should look for classes such as vectors (#(1 2 3) is equivalent to [1, 2, 3] in Python, though Python's list is more flexible than the Lisp vectors I've seen).
Good article. But i would be much more interested on what support Franz offered for Weblocks. Any details ? 
You keep talking about objects instead of about arrays. You were interested in having a property list (or dictionary) associated with a list, and I was very interested in how you would manage that in lisp. &gt; Each cons cell ought to have its own dictionary of associated properties (which may very well be optimized away when it's unused). So then how would you implement a cdr-recursive operation on those lists? Since the property-list is an element of the cons, how would you have this work: (defun foo (list) (or (something-with-proplist list) (foo (cdr list)))) How useful would property lists actually be in such an environment? What kinds of things would they make easier? &gt; '(1 2 3) is equivalent to (1, (2, (3, ()))) in Python. That's not right. `(1 2 3)` is roughly equivalent to `(1,(2,(3,None)))` however I wouldn't ordinarily quibble about that. Python has absolutely nothing like `'(1 2 3)` - i.e. Python has nothing like `(*quote* (1 2 3))` &gt; though Python's list is more flexible than the Lisp vectors I've seen). Odd. I've always found the distinct lack of a fill-pointer in python to be very annoying. 
no screenshot?
must log in...
The nice thing about a CL window manager is that one has an entire Common Lisp running all the time. That could be the key to getting more Lisp software running &amp; available. Who knows, after thirty years the Lisp Machine dream might finally come true...
I see Costanza is being snotty on c.l.l. again. I hadn't been keeping up over the holidays.
&gt; Not a whole lot new with this release. Good thing I have so much context, coming from Reddit.
I've been using StumpWM for a week, and it is great. Getting CL installed is trivial these days on linux, so deploying CL apps on linux should no longer be any issue whatsoever (since you can just have SBCL or CLISP or whatever as a dependency and the pkg manager will take care of it for you.)
That has got to be the saddest thing I've heard all day. I'd love to know how much they need to get. I bet a lot of people would be willing to chip in some money to get it Open Sourced.
That super-flexibility in CLOS sounds like a recipe for horrible, horrible inefficiency. How on earth would you optimize dynamic splice-and-dice of the class hierarchy?
Sometimes, efficiency matters, and you're willing to contort an algorithm into a bizarre coding style for a few extra cycles. Sometimes, it doesn't, and you can favor a succinct and easy to work with workflow that emphesizes your own productivity. Better to have the choice, than to not.
It tends to work out just fine in practise. Most generic functions--like methods in other languages--specialise on only one argument, and so there's no efficiency breakdown there. If you need to specialise on multiple arguments, then in any other language you'd end up with a big case statement--Common Lisp can get it down to that, or it can do things behind the scenes because the implementation knows what's going on. It might even be able to use compile-time analysis to hard-code the method call. And of course if you really, really need to mess with things yourself you always can. It all works out in the wash. Compiled Lisp runs within an order of magnitude of the speed of compiled C, sometimes faster, sometimes slower. CL-PPCRE (a portable Perl-compatible regular expression library) is faster than Perl--and perl's regexp engine is written in C.
One main idea behind Common Lisp is that an language implementor must make many "arbitrary" choices. Some choices will speed up your particular program. Others will slow it down. Only you might know. Therefore, one solution is to make a default choice for common use-cases (which the language implementor optimizes heavily), but give the user enough power to override the decision. Take objects. Maybe slot values shouldn't be stored in arrays (as might be default) -- but rather in a sparse table, or backed by a database, or lazily calculated. Straying from the default may result in far better performance for your program. The metaobject protocol allows you to make such choices. Further, when you observe Common Lisp, you'll see some redundancy. For example, you not only have plain functions, but also generic functions. In the end, a programming language implementation is just a program. There's many ways to offer optimized features, and let the user figure out where she wants to sit in the power/performance specturm. 
That's exactly what I was thinking. I wonder how we could propose this? Who was the previous owner? How can this be confirmed?
Would it be better/easier to reverse-engineer this? Are there projects already underway that are reverse engineering Symbolics' systems/software. I seem to recall someone doing something like this recently and posting about it.
I think what you really want to do here is slurp the entire file (or a specific size chunk if you think it might be too big), split it by newlines and iterate over the resulting sequence.
&gt; design flaw of being in Emacs Ummm...what? Emacs is a far, far, _far_ better editor than anything Eclipse can support.
Discussed here: http://xach.livejournal.com/186930.html
Xach is the man!
Scheme has nonhygenic macros... EDIT: Let me clarify that nonhygenic macros are usually nonstandard additions to scheme.
http://en.wikipedia.org/wiki/Hygienic_macro &gt; They are a feature of programming languages such as Scheme and Dylan.
The link he gives to the project page is incorrect. You can find the real thing at http://common-lisp.net/projects/cl-openid/
Sorry, I didn't see your comment earlier. [I've posted one.](http://roerd.wordpress.com/2008/09/03/screenshot-of-the-sudoku-ltk-gui/)
zb didn't say that scheme lacks hygenic macros. Don't presume the contrapositive.
Ripped: http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html
&gt; Don't presume... how ironic. 
He even left at the bottom: &gt; Posted by Steve Yegge at 2:47 PM
Sounds like you might like Clojure's meta values. 
No arrays, lambda expressions (!!!), or CLOS. Why would we pick this over ABCL?
Anyone care to differentiate this from Clojure?
I propose that the main reason people use libraries is *not* to reuse code, but rather, to reuse coders. When LaTeX is rendering my document, Mr Knuth is driving. I can only look on in awe. Could I write a once-off perfectly task focused layout engine? Yes. Could I do as well as Mr Knuth? ROFL So: when a Java monkey is stringing together frameworks, what he's actually doing is reusing the minds of people who took comp sci at university. Boilerplate, he can do. Red-black trees? Um, something to do with gardening? And when said simian says "Lisp lacks libraries", he means that he took one look and the icy void of infinite freedom froze his soul. How on earth to begin?
Programming in anything but lisp is a premature optimization.
I think reader macros are best treated as an exotic feature, equivalent to shouting "black magic starts here", rather than as something to add for minor conveniences. An example of a good use of reader macros is Kent Pitman's (I think it was Kent) for parsing Fortran into Lisp. Using a reader macro for something FORMAT, a single function, or even a macro could do almost as cleanly isn't worth it.
Conrad is really awesome.
*shrugs* `mzc --exe my_scheme_program.scm` has been there for a long time, I'm pretty sure that there are native compilers for CL as well.
Why do people keep writing new editors? Unless you have some theory about how to completely revolutionize editing, there are much more sensible things to work on.
As much as I don't like reinvention of the wheel, an editor is more complex than it first seems, and can teach it's author a fair bit about programming. That said, I wouldn't release the finished product, and probably wouldn't even use it myself.
Nothing wrong with Lisp history, but all this does is say "Lisp history is important", with a couple of hyperlinks. "Give lisp algol-like syntax" is a very misguided critique, and it's mis-representative of the criticism of Common Lisp to present it alone. A more appropriate criticism is "Why did CL get the loop macro?". The loop macro is, considering the architecture and design of CL, makes no sense. Putting something like ITERATE into the standard would have made more sense than giving a relatively important part of CL a syntax that is infix, misleadingly modelled after English, poorly defined and even more poorly described.
"Noble Experiment or Fabulous Failure"??? The two are not mutually exclusive.
[Why don't you try it and see for yourself?](http://www.unlambda.com/cadr/index.html)
Was it a good thing to try, or did it fail? Uhhm, how stupid do you have to be to think in those terms? False choice doesn't even begin to describe it.
It would seem that the two choices offered here suggest that the opinion of the author has already been formed.
I always read these Clojure blogs and wonder why the language designers decided to use multiple types of brackets. Can anyone tell me the answer so I can understand the reasoning without having to learn the language?
i think the biggest problem is that it's hard for a person coming to lisp for the first time to install lisp, load some libraries, and make a simple web page in lisp.
Same for java. You have to download and install web server AFTER you downloaded and installed JVM. And then play with classpaths etc. Did not stop millions of java web developers. Lisp is easy to download, install, get hunchentoot library and run it. Voila! you have a running web server with examples.
The Lisp infrastructure seems way easier than the JEE stuff, where I *still* have no idea what is what and which thing to use.
I have to agree with Dan, I haven't found the community on comp.lang.lisp so bad, but that said I mostly read comp.lang.scheme which is quite ok and the plt-scheme mailing list which is *very* useful and the people are both friendly and helpful (PLT is definitely one of the best Schemes out there and for a reason). I'm not yet sure about #scheme, but someone got kicked for being unfriendly to beginners (that is, me) lately, so it looks like they try to keep an athmosfere that beginner comfortable. Calling these people thorny and uninspired does not seem appropriate to me. That said, I don't know about the Haskell community.
i don't do java, but it was a whole lot easier for me to get a stable and simple website running with clojure than with common lisp. Scheme has some easy web servers. Btw, when I finally got hunchentoot running, and it was harder than you let on, it was using a whooping 70+MB. I'm a rails guy and was looking for something lighter on the memory usage and was shocked that it was nearly twice the ram of a default rails setup.
this is like saying that the american economy isn't so bad, I mean I wouldn't want to be in afghanistan. Why compare lisp to the worst thing you can think of? 
Anyone else get this error when running (ccl:rebuild-ccl :full t)? &gt; Error: Unbound variable: *ISTRUCT-CELLS* &gt; While executing: OPTIMIZE-TYPEP, in process listener(1). EDIT: Let me change the question into a bug report: Upgrading from r10018 (to r10808) seems to cause the rebuilding to fail with a bunch of errors about ISTRUCT-CELLS. A clean svn checkout of the 1.2 release builds fine. Leopard.
Very nice. I started toying around with it just earlier this week and it's very nice to deal with. I am a bit confused on how the licensing would work though. Can someone give a breakdown on LLGPL and if I can use it in a commercial close sourced app? Even if that app is on a signed disc and the base image cannot be "relinked" (in C terms).
Actually, especially web-deployment tends to be hairy about anywhere except for PHP.
Swank uses a lot of memory, and you only need that during development. A fresh sbcl with hunchentoot and its dependencies loaded uses about 40 megs.
That would include spelling lessons as well, I trust
i've found it very easy to get up and running with ruby, python, and a few schemes. Hunchentoot wasn't bad either, but I was surprised by the memory usage, but someone pointed out that it was swank. 
Depends on what you want to do. If you're using Python with CherryPy its easy, but setting up Django on Lighttpd with FastCGI+suexec (actually execwrap) so that it automatically starts and stop servers can be quite challenging. Especially when lighttpd keeps on crashing without error message on invalid config files or you later find out that execwrap is incomplete.
it's pretty easy to setup nginx to proxy to a few rails mongrels. I'm guessing it's equally easy for django. The days of setting up fastcgi are over in the rails world which is a big improvement. However, I'm just talking about a simple dev environment. How fast can I get something running to play with it?
They need do way instain begginer&gt; who mispel thier babbys.
How are S-espressions formed?
&gt; it's pretty easy to setup nginx to proxy to a few rails mongrels. I'm guessing it's equally easy for django. For production setup it is considered a very bad idea to run the web server included in Django. &gt; However, I'm just talking about a simple dev environment. For a simple dev environment one can use the included server, just like WEBrick. I don't know how hard that is in CL, but at least Lisp ships it's own server and there are also some libraries that build on it.
Different data structures. list = (a b c) vector = [a b c] map = {:a 1 :b 2 :c 3} set = #{a b c}
i'm not familiar with the server your talking about. Can you link me to something about it?
Perhaps punctuation lessons, too?
You mean [the PLT web server](http://docs.plt-scheme.org/continue/index.html) or the [Django development server](http://docs.djangoproject.com/en/dev/ref/django-admin/#runserver-optional-port-number-or-ipaddr-port)?
I like my S-espresso with milk please. 
i thought you were talking about common lisp when you said, "For a simple dev environment one can use the included server, just like WEBrick."
Shouldn't that forum logo be: (defun lispforum (people) (apply #'fun people '(ideas))) Hmm I guess they wanted to avoid #'
Lisp should try and catch up with Haskell and Erlang in supporting millions of very lightweight concurrent processes, automatically distributed across CPUs.
On Safari, that web page looks like total crap. Like someone smeared some kind of fuzziness-inducing gel over the top of it. EDIT: figured it out. The idiot who made this website has added a very slight shadow to all his text. In css: /* Safari text-shadow fix */ * { text-shadow: #39434d 0 0 1px; } Man, that is one awful looking website. 
Scheme does not have a `for`-loop. Who cares.
People who find continuations &amp; TCO difficult to understand? 
Lisp is for nerds. 
Continuations don't need to be used, and TCO.. well, they can either use CL or define (or even let someone define) them `for` macros. There was a posting lately on c.l.s with some Python control structure-emulationg macros. I wouldn't go that way in Scheme, but if you want imperative Lisp, you do have CL. And you have Clojure, which does not support TCO at all, so recursion instead of looping is not a good idea.
Programming is for nerds, then.
Programming maketh the nerd.
My eyes, the goggles do nothing! Seriously, [this website developer](http://www.reddit.com/r/lisp/comments/72tim/pcl_clojure_chapter_11/c05j791) needs to be taken out behind the barn and shot.
Some time ago, I remember seeing a parallel evaluation library for CL posted on reddit. There were parallel versions of several sequence operations (map and such). After half an hour of searching, I still can't find it so I thought I'd ask here. I believe the post was a link to a blog entry that described the library. It seems like it was similar to what was described [in this CLL thread](http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/21750d020a157706/3cf8e26e0e5378cc).
Zak's reference is the one I remember too.
This? http://marijn.haverbeke.nl/pcall/ They implement a parallel version of mapcar in the blog from library primitives. 
Yes! That was it. Thank you.
This is the common problem with all of Lisp. Until [Practical Common Lisp](http://www.amazon.com/gp/search?ie=UTF8&amp;keywords=practical%20common%20lisp&amp;tag=eadmund-20&amp;index=books&amp;linkCode=ur2&amp;camp=1789&amp;creative=9325), there simply wasn't a good reference available for a programmer to learn Lisp--and to see why it's a useful (practical, even) language. I think the thing is that once one has finally grokked Lisp, one doesn't really see a _need_ for tutorials anymore. The thing is, that doesn't mean that they aren't needed anyway.
At the risc of being redundant I'll link to the [Practical Common Lisp](http://www.gigamonkeys.com/book/) site. It has a nice tutorial.
The first time I used Lisp (in a programming languages class), it was a revelation. Once I understood how the prefix notation and paretheses worked, I remember thinking, "This is what programming is *supposed* to be like."
The lisp syntax is wonderfully consistent, logical, and simple. The only thing that bugs me about the parentheses is that there are no visual queues to identify blocks of code - everything looks the same. Like most things, you get used to it after a while.
A good editor would help you there. Not having the visual cues in the language but in the editor is better IMHO.
There's an interesting simple observation in all that blog post struggling to get out. - Lisp syntax is *unambiguous*. - That means you can dare use it in complicated ways. People tend to use other languages in staccato, non-nested ways precisely because you can't easily be sure what complicated syntax will mean.
One of the big ugly failures of Common Lisp is that there are a huge number of functions which *should* be generic functions but aren't. And a "genericizer", replacing the symbols as appropriate, doesn't work in many systems because they're constant.
&gt; Until Practical Common Lisp, there simply wasn't a good reference available for a programmer to learn Lisp Um, [what?](http://www.paulgraham.com/acl.html)
Well, it's probably because CLOS is really an add-on to Lisp and in fact can be implemented in Lisp. If there were an updated standardisation effort today, I like to think they'd fix some of the little warts like that.
Meh, ANSI Common Lisp is a decent way to teach a particular sort of computer science, but it's not a good reference for a programmer who wants to learn a new language. Too many 'add a series of numbers' exercises and not enough 'here are some features to make your programs stabler.'
I picked up on the term "good reference". I think ANSI Common Lisp still has the best back-of-the-book Lisp reference in the business.
&gt;If there were an updated standardisation effort today, I like to think they'd fix some of the little warts like that. I doubt it. Standardization by committee seems to lead to an obsesion with backwards compatibility and ever more cruft. 
As long as Clojure is licensed under the CPL, it's not going to get very far. They need to relicense that sucker under an academic license. 
Just out of curiosity, what is it that you find problematic about CPL?
seriously, WTF are you talking about? Xach uses no macros, and the 'irritating' version is longer and more irritating.. no question about it. Did you read the article or are you just some random lisp troll? 
To me it looks like the "irritating" version he started with was just more readable. Also macros add the overhead of a second level of parsing before execution. Maybe I'm wrong and if so I'd like to know but it seems a function could read the data structure just fine and no macro was really needed. 
It's all part of the compilation process -- the macro is only executed once. So it adds less than a function call. What it does add is conceptual overhead. Someone else coming along is going to have to be able to understand your new language construct. Which means they're going to have to be well-designed and explained, otherwise you just make that code less maintainable. Like a function, only moreso. Other than that, all your points are valid in this case. Not in the general case, though. I mean, (let ((x 5)) (+ x 1)) is pretty much always going to make more sense than ((lambda (x) (+ x 1)) 5) But yeah, in this case, it's not a great trade-off.
Yes, a function could of course read the datastructure. But you can't bind variables and execute arbitrary code within the lexical scope of these bindings with a function.
I just happened to have that code lying around and figured it'd be useful for others. As has been pointed out though, a macro is code that is run at *compile-time*, with the added twist that they can call any *ordinary* function or macro as they please! A macro isn't more than a fancy filter, taking some arguments, applying some transformations and then feeding the compiler the resulting s-exps. Basically, it lets you write your code in verbs that can be found in the problem domain, instead of low-level primitives from the language! As a silly example, consider the following (if ``when`` wasn't already a built-in):: (defmacro my-when (test &amp;rest body) `(if ,test (progn ,@body))) ``if`` is a built-in primitive that will only let you execute *one* form in the branches, and if you want to have more than one, well, you need to use ``progn``: (if (numberp 1) (print "yay, a number")) (if (numberp 1) (progn (assert-world-is-sane t) (print "phew!")))) With our new friend, my-when, we could both a) use the more appropriate verb if we don't have a false branch, and b) add an implicit sequencing operator, i.e. ``progn``: (my-when (numberp 1) (assert-world-is-sane t) (print "phew!")) The compiled code will never contain ``my-when``, though, because in the first pass, all macros are expanded so there is *no runtime penalty* involved! (macroexpand-1 '(my-when (numberp 1) (print "yay!"))) (if (numberp 1) (progn (print "yay!"))) Note that ``macroexpand-1`` only does one level of expansions; it's possible (most likely, in fact!) that the expansions continues further down. However, eventually you'll hit the compiler-specific implementation details which are often not very interesting. But continuing expanding the result will eventually either get you more details, or just your input s-exp back. Hope that clarifies things. 
Great, just great! Thank you. When you step through the code though, does the debugger/stepper show the macro syntax or the post-compilation sexps? Seems the latter would make debugging a little more challenging - maybe offset by good commenting.
I've never used the debugger, so I can unfortunately not answer your question. My guess is that you see the expansion.
Its strength is that it targets JVM. Its weakness is that it targets JVM.
Why is clojure prefered to [armed bear lisp](http://common-lisp.net/project/armedbear/)? Is it just a hype, because it is kind of a new language? If I would need lisp and java bytecode, I would add bytecode as a target to an existing compiler. What makes clojure sexy meanwhile armedbear seems to be starving to death?
Can someone explain &gt; He specifies a reader, yet his reader does not intern symbols. That is a big win, as it allows the reader to actually work with arbitary Clojure source files. In Common Lisp, one needs to re-implement a full reader which does not intern symbols if one wants to read Common Lisp source files. to me?
Well, clojure is the real thing. That's it :) ABCL is very cool, but it's really an unsupported, incomplete halfway implementation of CL (and doesn't hide it either, like i said, it's cool enough as it is). Clojure is a real-world, full lisp implementation, useful in production environments and with a lot of extra stuff. 
&gt; Its weakness is that it targets JVM. Can you elucidate on this weakness. 
&gt; Why is clojure prefered to armed bear lisp? The first ten or fifteen minutes of the video go a long way to answering this question, and worth watching if you are really interested in the answer. Rich provides a good rationale on the Clojure site as well: http://clojure.org/rationale 
ABCL is incomplete, but recently the project got a new maintainer and seems to be moving foward again.
Yeah, I heard about the new maintainter. Don't know yet how it's doing. It would be great to have two lisps on JVM, especially since clojure is not CL and it'll never run CL code. 
As clojure also has macros, can't it get a compatibility layer to run CL?
I wasn't all that interested in Clojure when I went to the presentation. New Lisps are a dime a dozen. Most of the time they're vanity projects that are poorly thought-out and demonstrate little knowledge of history and ignorantly stumble into the same problems Lisp and Scheme implementations dealt with ages ago. Clojure is different. Rich Hickey knows his stuff. He had a bullet point about how Clojure is a Lisp-1 with CL-style macros. That sent up a red flag for me (and doubtless many of the other, smarter members of the audience), but Rich went on to explain that he knows it's a danger zone and showed how he felt he worked around it. That's just one example; there were many other cases where I thought to myself "Hey wait..." just seconds before Rich demonstrated he was thinking along the same lines and had worked on and worked out the issues. I think Common Lisp is a great language, and I'm going to use it wherever I can. If I ever have to use Java, I'm extremely happy there's a tool out there like Clojure. Rich Hickey completely sold me on its viability at this presentation. YMMV.
I will check it out later. Meanwhile, can you tell me if I can create java classes/libraries with clojure? To use clojure as a substitute for java, java programs have to access clojure code, too. I read somewhere that clojure can't do it.
i doubt it, clojure and CL are both of the lisp family but they are radically different in many aspects.
You can create Java classes with Clojure. You can pass Clojure closures to Java code as Java callbacks. Clojure is also evolving. What might have been true in the past might not be true today.
When is software ever done?
&gt;-[massive](http://steve-yegge.blogspot.com/2006/04/lisp-is-not-acceptable-lisp.html) The way to find out the set of all methods for any given object is: (specializer-methods (class-of object)) Now I can start coding lisp. 
I had to do (mapcar #'method-generic-function (specializer-direct-methods (class-of object))) to get the names in Clisp.
Done is when you get somewhere. When it runs, when it works, when it's useful for something, it's done. Metaphors abound in evolution (which he mentions). We're pretty screwy apes, but we got culture first, so from here on out it's us. 
&gt; We're pretty screwy apes, but we got culture first, so from here on out it's us. Great synopsis of humanity's ascent with respect to our evolutionary cousins. It makes culture seem like an atomic weapon of sorts, and it kind of is.
What syntax?
How am I supposed to play a G? I only have five fingers on each hand. The diagram shows six places where I must press.
Clearly you're supposed to use both hands. Attach the pick to your tongue. 
I know it's possible since playaz play Gs in da hood. This particular G is made with three fingers but I wouldn't try making it on the subway.
The diagram would never tell you the two up top are your index finger barring.
SBCL does it, but the binaries it generates are 20MB at a minimum, as it embeds a CL runtime. Not sure what Cusp does.
20MB sounded like *a lot* some years ago and while not being exactly a big fan of huge compiled blobs, the 20MB aren't really an issue, most of the time. For people who care about size, one can use the source.
True, it's definitely not as much of a problem as it used to be. I still wouldn't mind a solution that produced smaller binaries though.
I like the picture of john mccarthy
Hey Mark, That's a barre (or bar) form chord, you would play it with your index finger holding down all strings on the 3rd fret. This (fairly standard) approach shows you where the notes are but leaves you to figure out how to finger it. I did say `half-assed' ... one of the things missing is notation for barres. Also, an alternate mode to show fingering could be useful. I have no time at the moment, but may revisit this, and I'll post if I do.
SBCL has a brilliant compilier, and some really good included internal libraries.
doesn't indentation give some hints? also editor helps with highlighting symbols it considers important (let, if, loop..), so it is easier to see the structure.
Good to see a Clojure book on the way
I hope so. I want an excuse to learn a lisp for real :P
SUBSCRIBE! http://reddit.com/r/clojure
I hope so. Clojure is my new favorite language. It makes concurrency sane, and that's going to matter more and more as time goes on; I think I saw an 8-core chip on Intel's short-term roadmap. The fact that it's a lisp, and really well thought-out in its design makes it even better.
Good to see Reddittors provide for me when I demand it. Subscribed.
The closest I've come to semi-regular use is messing around with elisp in emacs for repetitive tasks. Not sure if that's a "lisp for real" or not though...
Exactly the same situation here.
Exactly. I was thinking my next project was going to be in Erlang due to good concurrency, but now that I've found Clojure I've changed my mind. Lisp syntax is much nicer than Erlang syntax, and Agents+Refs seem to fit the problem a bit better than Actors.
I've just started messing around with lisp, and pressing shift so much is already annoying me. I assume a lot of lisp people have remapped their parentheses. Where to? I'm considering switching them with [], but I'm using clojure, and it likes [] as well. EDIT: This is what I ended up doing: (global-set-key (kbd "[") (lambda () (interactive) (insert "("))) (global-set-key (kbd "]") (lambda () (interactive) (insert ")"))) (global-set-key (kbd "(") (lambda () (interactive) (insert "["))) (global-set-key (kbd ")") (lambda () (interactive) (insert "]"))) 
Whew, that will really help thin out the MASSIVE VOLUME of traffic we get here in the lisp subreddit, thanks! ;-)
I think actors are more appropriate for distributed systems. Concurrent systems will be a more common environment for most programmers in the near future, and the set of agents, refs and thread-local vars solves that problem much better. I really like Clojure's pragmatism. It may not be PG's hundred-year language, but I think it's a great ten-year language.
I'm too lazy to learn Dvorak, but I recently saw [this Dvorak programming layout](http://www.kaufmann.no/roland/dvorak/) and thought it was interesting. If I ever get off my ass, I might try learning it. 
I'd definitely want to change that one a bit, but it looks like a nice starting point. Probably the nicest layout I've seen. I have no idea why he felt a need to rearrange the numbers, though. Might as well have kept them left to right... The thing that always keeps me from switching to dvorak is emacs keybindings. Either I have to deal with completely non-ergonomic bindings, or translate everything, neither of which is ideal. If dvorak was global, it would be amazing, but honestly, I think it's more effort than it's worth for most people.
/dons flame-retardant pants. 
Love Clojure because it makes you feel good about opening and closing files. Right. Clojure needs better supporters than those who would condemn a language because a book (SCIP) didn't meet their mundane needs by holding their hand. 
SICP is a bit over-rated[*] and also, well, often used wrong. It is not a Scheme tutorial as many expect. If you want to learn Scheme, there's the The Scheme Programming Language as well as How to design Programs. [*] While SICP is surely an useful book for many, it is also quite unhelpful for others. As about any book.
IMHO, SICP is only bad if you expect it to teach you Scheme. It's not a learn-a-language book; it's a learn-a-shitload-of-concepts book.
http://reddit.com/r/clojure
Well, Clojure is a lisp. While it's nice to have submissions to the Clojure reddit, it's probably a little too specific for now. 
I'm starting to think reddit should have some kind of community process like some usenet hierarchies have where approval of a new group is primarily based on whether there's enough traffic about the subject.
I'm actually the creator of the Clojure reddit; I made it awhile back when the "make your own reddit" thing was around, and I was really interested in Clojure. I was hoping that it would collect more links, but it really is more convenient to just post in the Lisp reddit. I'll admit, I'm a terrible custodian of it as a subreddit, I added people who I knew to be active in the Clojure community as moderators and then I kind of forgot about it, to be honest. 
It appears the [lisp] subreddit *is* the clojure subreddit, in practice, if not in name.
Well, that's sort of my point. Is the [lisp] subreddit for Common Lisp? Or is it for any Lisp? (i.e. Scheme, Qi, Dylan, etc)
There seem to be plenty of people paying attention to Clojure other than the "Oh NOES! Parens Suck! Lambda Sucks!" crowd. I DO worry though about the rapid growth/attention Clojure is receiving -- I worry about Clojure getting bogged down as new place the "cool kids" want to play--I think Rich can handle this though. I haven't met him, but it seems his ambitions are more hacker than rock star. As far as SICP, it's a hard call -- a lot of people have been turned off by it being listed as the best place to learn scheme. I usually suggest [Dybvig](http://www.scheme.com/tspl3/) Chapters 1 and 2 to get a feel for the language before starting SICP, then use chapters 3+ for cool down while your brain wraps around the ideas and exercises in SICP. 
Lovely - time to dig out those lisp books again.
asdf-install uses asdf, but asdf knows nothing about asdf-install. They're separate programs. (I tried to leave this comment on the blog, but it said "That's a duplicate comment so I'm ignoring it.")
Is 5am really not asdf-install-able? I think I have installed it from its debian-package (cl-fiveam), but I don't see why there should be a problem with asdf-install.
It's clbuild-able at least.
I installed it via asdf-install some time ago. It pulled in a snapshot of swank and the kitchen sink that is Arnesi, but it worked.
Why? Are they running out of bytes?
It gets confusing. Should you submit Clojure-specific links to the programming, Lisp or Clojure reddit? Do you have to subscribe to all of these if you're interested in Clojure?
If you're looking for a concise, quite practical tutorial [Teach Yourself Scheme in Fixnum Days](http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html) is a good choice.
I also liked [schintro](http://community.schemewiki.org/?schintro) and [The Scheme programming language](http://www.scheme.com/tspl/).
The article forgets to mention the main reason why iterate is clearly better. (More parentheses.)
narrowest column evar EDIT: Seriously 426px wide for all your content. What screen are you formatting for?
Hear hear. If you don't like parentheses, why are you coding in Lisp?
[Reading the paper](http://p-cos.net/documents/contextl-overview.pdf) makes this make much more sense.
"Considered Harmful" meme considered harmful.
&gt; "Considered Harmful" meme considered harmful. '"Considered Harmful" meme considered harmful.' meme considered harmful.
Downvoted for the author being too lazy to use the shift key. Blocks of all-lowercase text border on unreadable.
http://lists.tunes.org/archives/lispos/1998-November/002484.html
via: http://en.wikibooks.org/wiki/Clojure_Programming
What does Lisp do in CUDA-like department?
No word about thread support it seems... or at least none I can find with a brief skim.
Except it's not really like SLIME at all. The beauty of SLIME is that the REPL is running *inside your editor*, so you have all the power of your editor available. As a trivial example...say you want to put the output of a function call into another file. You can send stuff TO screen, but you don't have an easy way to select some stuff in the screen session and slurp it back. This is a glorious hack, and is great for vim users who can't/won't try Emacs...but it's nothing like SLIME.
The freemind page doesn't seem to work for me.
oh my freaking brain!
Bleah, show me anonymous interrecursive functions first.
Coming from a C++/C# background. SICP or Practical Common Lisp? People seem to swear by SICP, but I noticed it's all about Scheme. Does your first Lisp dialect make a big difference in how you learn, or is moving between dialects super easy? Alternatively, Clojure seems to be the next big thing, but from what I've seen, it also doesn't look like something that I should dive into directly (since I don't know the Java libraries). Is that about right, or would it be a good idea to try to ride the Clojure wave just as it's forming? I'm taking an intro to AI course starting in January and I would like to be able to have enough Lisp skills to do projects in Lisp (projects can be done in the language of your choice). Doable, or totally unrealistic? Any words of wisdom would be greatly appreciated. Edit: Thanks for all the advice, guys. I think the road I'm going to take is to read PCL then PAIP.
I think your goal is very doable. C++ is way more complex than Common Lisp at its worst. You'll be up and running in no time. I think your intuition is correct with respect to Clojure. I also don't know the Java libraries and have been holding off for that reason. But it does look like the next big wave in Lisp. I'll wait for some books. Moving between dialects is not trivial. I thought it was for a long time, while I was learning Common Lisp and then I decided to pick up Scheme. Scheme is much closer to the modern FP traditions, mostly by association and by virtue of being a small, simple language with exceedingly powerful constructs. In spirit, they're not much alike. They're both appropriate for different tasks (or maybe the same tasks), but the question of implementation really will come down to a comparison of Common Lisp to _specific implementations_ of Scheme. The Scheme standard is quite small. From what I understand, most people wind up using DrScheme for the wonderful editor and wide library support. If you're going to learn Scheme or follow a book on Scheme, you're going to want to get DrScheme. Other implementations of Scheme have specific upsides and downsides, especially Bigloo, Chicken, Ypsilon, Stalin, Guile and several others. On the Lisp side, there is more commonality of implementation even when the standard is not being followed, such as with metaobject protocol, Gray streams and networking. Portability seems to happen more easily with Lisp than Scheme; choosing a specific implementation of Lisp isn't as big of a deal (though I recommend SBCL or Clozure if you can run it). If you just want the bare minimum of the language and more on the thought process, I'd strongly recommend _The Little Schemer_. It's hardly a comprehensive tutorial though, and neither is SICP, which is really an introductory CS text. It's a great book by all accounts, I haven't made much headway into my copy. By far the most practical introduction to any member of the Lisp family is _Practical Common Lisp_. I have read it cover to cover and consult it with some frequency when using Lisp. I have many other CL books, including Common Lisp the Language, Art of Metaobject Protocol, Paradigms of AI Programming, and Object-Oriented Programming in Common Lisp. They're all valuable but PCL is absolutely the most accessible text on Lisp, and it will definitely make you excited about using Lisp. If you have any specific questions or thoughts please share them too, that would probably help narrow things down a little better.
I would reading SICP while learning Clojure. That would be a fairly quick way to get into Clojure, which is probably going to become another successful dialect. Both SICP and Clojure also have pretty good video lectures and online presences (irc+reddit+etc) which are significant boons for independent learning. Once you know one of the Lisps, and also the functional style, most of the skills are transferable. I would spend time on Clojure, rather than CL, at this point, because it has most of the advantages, good concurrency, few of the disadvantages.
[Programming Clojure](http://www.pragprog.com/titles/shcloj/programming-clojure) recently came out in beta. I'm not sure it is particularly usable for learning yet (still missing some important chapters), but should be good.
SBCL has a brilliant compiler - but even this will reach a limit on code that needs to be fast. CLISP is a waste of time, unless you're using windows.
&gt; Does your first Lisp dialect make a big difference in how you learn Yes, I think so. I did the scheme/SICP route (using mzscheme - the scheme underyling DrScheme) and found it rewarding, but it means that some of the common lisp design choices/warts bug me. (Basically the non-uniform names and the difference between a lisp-1 and lisp-2. As a second system, scheme is a bit more uniform and 'pure'). My impression (perhaps wrongly) is that Common Lisp is better suited to production work. DrScheme is very good though. I'd like to work through PCL with a common lisp (probably SBCL or perhaps clojure since it seems to be an interesting development) the next time I'm playing with languages.
Free book: http://gigamonkeys.com/book/
it's up to your taste, SICP is more computer-science-theoretic thing, PCL is more practical :). personally, i find that computer-theoretic stuff somewhat boring.. &gt; or is moving between dialects super easy? no, it's not -- you might get used to some idioms, then switching would be not pleasant &gt; I'm taking an intro to AI course starting in then maybe PAIP (_Paradigms of Artifical Intelligence Programming_ by Peter Norvig) is a book for you? it has very smooth introduction into Common Lisp, then desribes good practices, style and standard idioms. and examples are AI-related. author is a known AI expert and a very good programmer, so learning stuff from him would be valuable. &gt; Doable, or totally unrealistic? learning language itself is pretty easy -- you just need to get some concepts and common idioms. this could be done in a few weeks or so. but there might be some technical problems with different implementations, libraries, encodings etc. (if your project is of complex nature), that could be sometimes frustrating and time-consuming, but nothing impossible for a brave hacker :) 
Switching Lisp dialects is a bit like moving between Ruby, Python and Lua. The syntax is similar, as are many of the semantics but there are major differences in culture, idioms and certain semantics. As an example, Scheme always supports tail call elimination, so you can use recursion for all your loops. Most Common Lisps do if you put in the appropriate optimize space declaration. Clojure does not (a limitation of the JVM).
There are certainly Schemes that are well-suited to production work. [Ypsilon](http://code.google.com/p/ypsilon/) comes to mind. The reason why I can't come down solidly on the side of CL or Scheme is that there are CL systems which are better designed and implemented than the ad-hoc ones you get to choose from with Scheme. Primarily the condition system, but also the package system and CLOS. It's not that certain Scheme implementations don't have these things, it's that the versions of these things that they do have tend not to be as comprehensive. R6RS's exception system just isn't as comprehensive and good as CL's condition system. So I find myself torn, because I don't understand why Lisp has to have packages *and* be a Lisp-2, or why it has to have `#'mapcar` instead of just `map`, or a thousand other little things, but I also don't understand why Scheme is unwilling to take the good things from Lisp.
Clojure certainly seems to have the support of the community. But I think it would be frustrating and futile to try and learn it with SICP. That sounds to me like trying to learn Java by reading a book on C++.
SBCL + annotations seems to be fast enough for just about anyone's needs. There's always the FFI if you want to hand tweak some assembler. I've used CLISP, mostly for learning purposes, on machines that otherwise I wouldn't be able to install a beefier Lisp on, and it was fine. Production work, not so much, though apparently it's what PG used for Y! whatever.
Boxing and unboxing of array items, and arguments. I'm already using ffi and it's 10x slower than C.
Can we look at the code?
lots of (deref array i) and (declaim inline myqsort) and (declaim (type (simple-array fixnum) \*query-array\*) proceeds (loop with idx = 0 for i below *array-size* do (unless (= 0.0 (deref *result-array* i)) (setf (deref *rank-array* idx) i) (incf idx)) finally (progn (myqsort *rank-array* idx) (return (list *rank-array* idx))))) (deref array i) itself is too fucking slow.
Maybe I am too attached to SICP, but there aren't many good tutorials for Clojure yet, so I suggested SICP because it's mostly applicable. 
Wow. That sucks. Thanks for attaching some code. I hope someone working on SBCL will fix that. Have you tried it on CMUCL? It's probably the same story but I have heard that CMUCL has some optimizations that SBCL doesn't.
Not really that useful, as the book seems to be very incomplete.
The article is wrong. $ svn co http:\//svn.clozure.com/publicsvn/openmcl/release/1.2/darwinx86/ccl Should be: $ svn co http:\//svn.clozure.com/publicsvn/openmcl/trunk/darwinx8632/ccl/ EDIT: backslashes introduced to work around reddit deficiencies...
Thanks. Next time, leave it on my blog and I'll find it faster.
I had technical difficulties with your comment device.
I'm sorry to hear that. Do you mind helping me diagnose and fix it? What browser/OS are you using, and do you have any plugins installed that might be out of the ordinary? What did it do to you?
Blackberry. I get HTTP Error 400: Bad Request.
Wow. OK. I think I can try to replicate that at home. Thanks!
[re: complex numbers] " In short, have it in Clojure out of the box soon, or be assured Clojure won't have a future." I stopped reading after that. No wonder Lisp, despite its popularity, is stuck in the background.
I'm disappointed that not many people comment on its lack of tail call elimination. To me, Clojure looks like a great achievement, but its biggest shortcome is by far the lack of tail call elimination.
I do not see what is the big deal about not having TCO. It is not like every recursive function is automatically TCO. You have to follow specific rule to make your functions TCO. And if that's the case what is the difference between following that rule, and simply writing recur ? I have my own grips with clojure, but i definitely do not give a second thought about lack of TCO. No big deal. I want to introduce clojure into my java web application. Unfortunately the only clojure web framework compojure works only on jetty. No tomcat support. So i'll wait. 
Yes, because you should definitely listen to what Xah Lee says. Always.
Hey a working cross platform gui for cl would be wikked.
&gt; I do not see what is the big deal about not having TCO. Functional programming becomes more difficult without TCO. And I enjoy developing iterative algorithms as tail-recursive functions. &gt; what is the difference between following that rule, and simply writing recur ? It's not as beautiful, and it doesn't support mutual recursion.
&gt;Functional programming becomes more difficult without TCO Um, what ? You mean recursion, not TCO. TCO has nothing to do with functional programming, it is a technique to avoid stack overflow, and in that regard is no different than the operator recur. Both have to be dealt with explicitly. &gt;And I enjoy developing iterative algorithms as tail-recursive functions. That's weird, because in most cases you would be reinventing the wheel. Map, reduce, filter cover like 99% of the iterative algorithms. I do not even remember when was the last time i had to use recursion, and mind you i practically never use for loops in my lisp code. &gt; It's not as beautiful. Please, TCO is just as ugly as a recur, because you have to pass an accumulating value down the road, instead of using simple and beautiful recursion. As for the mutual recursion, Rick just announced trampolines.
&gt; TCO has nothing to do with functional programming, it is a technique to avoid stack overflow Which is why I said it's more difficult to do without it. &gt; in that regard is no different than the operator recur. Both have to be dealt with explicitly. TCO is automatic when supported, and it's different from recur in that it supports mutual recursion. &gt; That's weird, because in most cases you would be reinventing the wheel. Map, reduce, filter cover like 99% of the iterative algorithms. I won't loop myself when I can use map, filter and reduce, but they won't fit all problems nicely.
Simple but interesting. The path towards clojure on tomcat.
&gt; Clojure could be to Concurrency-Oriented Programming what Java was to OOP A crappy attempt with an overdone toy model (also misunderstood and initially broken), that got tremendously popular due to marketing aimed at retarded bosses who started asking for everything to be written with it in order to be more "enterprise"?
IMHO Clojure is over-hyped -- it is interesting project to some extent, but it doesn't deserve attention it gets as "next big thing", saviour for all concurrency problems and best thing since sliced bread..
Minor thing about clojure `recur` is that clojure apparently also still insists on it being in tail position. `java.lang.UnsupportedOperationException: Can only recur from tail position` However, once you have an explicit form signalling the recursion, there's no real reason to worry about it being in tail position anymore (apart from maybe a "suppressable style warning" in CL terms), as it's a just a control flow special op, as Paul Donnelly [pointed out a while back](http://coding.derkeiler.com/Archive/Lisp/comp.lang.lisp/2008-04/msg01578.html) when I proposed the introduction of a somewhat similar op (for general case, no self-recursion-only restrictions, since it was for CL, not JVM). as a common lisp extension (no, no implementation as yet, sorry). 
&gt; Crap! Around 85% of the readers just left the site in disgust ... as soon as they saw the word lisp. And the other 15% at the mention of something related to Java... Except that Clojure is awesome.
Maybe it is, but I'm glad to see that there are attempts to find the best ways to write parallel programs. Consider Ruby on Rails: clearly overhyped (it might be not bad, though), but it inspired many other frameworks which fit me better than what was available before RoR. So overall, a good thing.
&gt; But if you take a language and put it on top of JVM you now have double the amount of power. what? This s a pretty poorly written blog post.
Anyone used this? How does it compare to ASDF and clbuild?
It's brand new. If I had to guess, it probably has more bugs and you probably can't install as much with it. I like ASDF quite a bit, but now that I have to interact with Lispers on Windows sometimes I wish they could use it. I think this is going to be a step in the right direction, if it preserves the declarative nature of ASDF, and it looks like it does.
Is it really necessary to post releases mostly composed of bugfixes to reddit? I mean most of us have package managers to handle updating for us.
But SBCL is our pride. Look at all the upvotes :)) Besides lately lisp reddit is flooded with silly "WOW Clojure" posts. I for one welcome news from CL land. 
Please don't mistake my post as anti-SBCL, it is still my favourite CL implementation and I thought the same thing about most of the other "minor version x of software y released" posts, it was just that I cared enough about SBCL to try to check the changelog and there doesn't seem to be much of one for this release.
gst is sort of robot, as far as i understand. blame people who upmod this
FTA: &gt; As it currently stands it is not ASDF compatible (not ideal, I know) but ASDF support is planned for the future. 
I've launched the Common Lisp Weekly News project and your help is needed: * If you know something that you think would interest the rest of the community, * If you would like to announce software release, * Or anything else Common Lisp related, Then drop me a mail: (reverse '("com" "." "yahoo" "@" "anyakinvictor")) Thanks!
stupid windows users...
Very interesting. Seeing what the old timers had to go through just to get Lisp running, they always seem pretty satisfied if they can just get to the REPL. I've never heard of OpenLisp or ISLISP before today. Very interesting stuff.
Not to defend Java or anything, but its sorting algorithms and related data structures certainly do accept arbitrary [comparators](http://java.sun.com/j2se/1.5.0/docs/api/java/util/Comparator.html). Granted, typing out the anonymous interface implementation is a tad more verbose than an anonymous function, but that's obviously not the point. My gripe with this rant is just that specifically calling out Java users, saying "betcha can't do this easily!" and then starting your discussion with something they have, in fact, been able to do easily for quite some time seems like a good way to lose their attention fast. A similar pass-in-a-function example solving a problem for which a ready-made interface does not already exist in the Java library probably would have been better.
Wow, what a horrible article. Why does it need OO? Not using version control makes the language bad? Also, he could be using a DVCS, like git or bzr, which don't require you to be online when you commit. Test-driven-development seems to be the antithesis of what pg is -- extra busy work to do anything. *Weird versioning* is a deadly sin? Who cares? I actually like the *no* instead of *not*. Imagine this function: (def add (nums) (if (no nums) 0 (+ (car nums) (add (cdr nums))))) *no* works pretty well there. And no, it's not English -- it's Arc. You're using a programming language because English can't get you what you want. Why are you expecting it to be English? It's pretty readable to me.
I've had a good amount of experience in Java, and was just starting to dabble in lisp when I heard about Clojure, it really is about 1000x more accessible and useful than either of the languages. I'm still in the transition phase of learning the basics of the lisp syntax, but I've had a good experience overall, and hopefully it will get better as the community support increases.
That's not the sieve of eratosthenes...
I don't think `comp.lang.lisp` is bad. I could name at least two groups which are far worse than `cll` could ever become and I'm not even that much of a big news-reader. That said, the Scheme subforum is a bit underpopulated still.
This is awesome. Thank you for sharing. Who keeps voting down any submission containing original work or personal projects? 
Lisp haters?
in a Lisp subreddit?
Maybe they're downvoting it because it has already been [submitted](http://www.reddit.com/r/programming/comments/7jjqb/yet_another_lisp_related_screencast/) to the programming subreddit.
I know that something like this could be done with a combination of scheme, macros and libraries. The point is, a programming language is basically an interface. As in good interface design practice, it should have programmability (for power users) and good defaults (for beginners and those who just want to get things done). Lisp is great in being programmable, but imho many implementations lack in the "defaults" department, being bound to a spec (CL) or minimal by design (scheme). I think people were so excited to the idea of arc because they hoped for the possibility of a lisp distribution similar to that of python: a modern language, good libraries, documentation, tutorials, small ide, all in one package, ready to go.
Frankly, a self-described newbie simply doesn't have perspective necessary to define their (or anyone elses') ideal lisp. In writing lisp long enough, you may have the opportunity to come up with a genuinely new operator, or discover a new idiom. However this list is a list of things *other people* have discovered and *other people* think are good. Notably absent is evidence of comprehension (locks are most certainly necessary even in the absence of mutable state), and justification for these things (people don't type `#'` because they like extra typing, but because `defmacro` sucks in a lisp1- look at arcforum for the number of bugs discovered in arc that are the result of this problem) Eventually though, that will change. If any one of these things you listed is important to your lisp programming, you'll write it *in the course of your lisp programming*. If you then publish it, you'll be saving the you *that you are now* the trouble of writing it. But writing defaults is hard. When you've got a language with a lot of defaults, you either get at least some bad defaults, or you get perl. Some corrections: "CL" isn't "bound to a spec" like you say; it grew out of many existing and competing implementations. It wasn't a mere intersection of common functionality (like islisp), nor a gross oversimplification of need. "arc" is (right now) an experiment with huffman coding a language into existence. It shares similar goals to "scheme", but proposes a way (and code) to find new language-level expressions and axioms. It however, hasn't produced many beyond those described in [acl](http://www.paulgraham.com/acl.html), which is probably why many people have lost excitement.
I want to start playing around with LISP on OS X, but I'm not sure what the right way is to go about it. I see blog posts about installing macports, then installing an emacs over the default emacs that already comes with OS X, and more, but that seems hackish. Advice?
Clozure CL comes with a Mac native REPL application, but if you want to spend any time at all using Lisp, you should probably bite the bullet and figure out Emacs. It doesn't much matter which one, except to say that the one that comes with the OS only runs in the terminal. Aquamacs tries to make Emacs behave more like a normal Mac application. Carbon Emacs (I think that's what it's called at least) is more of a straight port of Emacs to run on the Mac. If you don't mind building from source, the current CVS version of plain old GNU Emacs has a cocoa backend that works quite well (that's my preferred option right now -- I like its font rendering better than the others). You don't need macports for any of that, by the way. Well, if you build your own CVS Emacs you probably would, but otherwise not. Clozure distributes a normal dmg file, as does Aquamacs and probably Carbon Emacs as well. You will need to install and configure SLIME on your own, but the directions are really simple. Note that SBCL is another very good Lisp implementation that runs on the Mac, but it's not as slickly integrated. From the tone of your question, I think you probably want to get started with Clozure first.
This is my fast/easy way: 1) install carbon emacs package: http://homepage.mac.com/zenitani/emacs-e.html 2) download SBCL binary: http://www.sbcl.org/platform-table.html 3) install SBCL binary: http://www.sbcl.org/getting.html 4) create in your home a directory for lisp stuff (e.g., /Users/&lt;username&gt;/lisp) 5) install slime from CVS on your lisp directory (step 4): cvs -d :pserver:anonymous:anonymous@common-lisp.net:/project/slime/cvsroot co slime (see http://common-lisp.net/project/slime/) 6) edit .emacs file: see http://common-lisp.net/project/slime/doc/html/Installation.html#Installation 7) run Emacs and start slime (M-x slime) and it's done! Later you might want to compile your own SBCL but for a pure beginning, this is more than enough I guess. 
LispWorks has a free personal license if you want to avoid the emacs + SLIME route, but frankly, you shouldn't because that's where the OS X Lisp community hangs out. You will find this endeavor to be decidedly old school but rewarding, even if you ultimately abandon it for inferior languages sporting modern libraries or IDEs. I recommend starting with Practical Common Lisp: http://www.gigamonkeys.com/book/
Clozure is pretty interesting I have installed it and am playing with it. Thanks!
Sweet. I was sorta frightened by the complexity of the various components on OS X, but this list makes it a lot clearer. Thanks!
It's worth telling you now: Common Lisp is a relatively difficult language to learn: it's large, quite different, and has some concepts that will be pretty unique. Even though CLOS and the macroes are the only totally unique parts (IIRC + AFAIK), the normal person is unlikely to have covered much of it before. It's further complicated for most people that you really have to learn emacs at the same time. This is pretty important, long term, but if emacs starts to be a barrier, you can start writing CL in your normal editor and using CLISP to evaluate it (CLISP uses libreadline, so it's still got some of the things SLIME has). It's also worth knowing that CL is unlikely to stage a massive comeback any time soon. If Lisp comes back into vogue (and I really hope it does), it will probably be through Clojure. Good luck, anyway!
I installed it using your method. It worked well! Thanks again!
&gt; 27182818284 That 4 should be a 5. 2.7 1828 1828 45 90 45 :^)
only if you are actually rounding. Since I had to drop the decimal anyway, I didn't care about the rounding. Thanks for noticing though! I think you are the first person to ever comment on that!
Glad to help :-)
&gt; It's further complicated for most people that you really have to learn emacs at the same time. I think [ABLE](http://phil.nullable.eu/) could help here. It's quite nice.
If you would like to try Scheme (it ia also a Lisp), download [DrScheme](http://www.plt-scheme.org/), they have a version for Mac available and it includes the documentation, the editor/debugger/profiler etc. and you can use "How to Design Programs" directly as it was written with DrScheme in mind.
And here's the obligatory [Clojure](http://clojure.org/) link. You can get it as just a java jar, so it is easy to "install".
You can also try out Ready Lisp. &gt;Ready Lisp is a binding together of several popular Common Lisp packages especially for Mac OS X, including: Aquamacs, SBCL and SLIME. Once downloaded, youll have a single application bundle which you can double-click  and find yourself in a fully configured Common Lisp REPL. &gt;Its ideal for OS X users who want to try out the beauty of Common Lisp with a minimum of hassle. It could also be used by teachers to give their Mac students a free, complete Common Lisp environment to take home with them. http://www.newartisans.com/software/readylisp.html
uhh, actually Beta 4 is out.
First, my head hurts after reading this and I dont fully understand it. Second, what exactly is this good for? How might this be useful in practical applications? Has anyone here used a Y Combinator in any of their production code?
Whoa! Erlanger migrating to Common Lisp. You won't see that often.
I use CMUCL with emacs and SLIME. http://www.cons.org/cmucl/ http://www.gnu.org/software/emacs/ http://common-lisp.net/project/slime/ Practical common LISP (free online version): http://www.gigamonkeys.com/book/ 
One small bug. With Aquamacs, there was a reserved *slime-repl* buffer. I followed the above instructions and found only *inferior-lisp* which is nearly as good, except in one regard: - Aquamacs' *slime-repl* did completions and showed hints on function arguments. - These are not shown in the Carbon Emacs *inferior-lisp* Any ideas? thanks! Tim Menzies
Well, I don't use Aquamacs (that's why I specifically say in 1) Carbon Emacs) but I have the same behavior with Carbon Emacs and Aquamacs. If you don't have the slime-repl in Carbon Emacs (just the inferior-lisp) then you must have done something wrong.
I blogged about [how to set up ClozureCL](http://storytotell.org/articles/2008/11/18/notes-on-setting-up-clozure-common-lisp) on a 32-bit Intel Mac recently. It's mostly the same story if you have a better (or worse) Mac, you just change directories. I personally use MacPorts often and I rely on software installed by it every day. MacPorts is great for anyone who migrated to a Mac from a more traditional Unix or clone such as Linux. My login shell, for example, comes from MacPorts, as well as my database servers and several programming languages. Fortunately or unfortunately, MacPorts doesn't track CVS versions of Lisp implementations so I wind up installing those by hand. One advantage to using MacPorts over finding random packages online is that you can use it to keep your software up-to-date. I have had to do a lot of manual fiddling with the upgrade process over the years, but I was an early adopter of MacPorts and I don't do the update procedure all that often. MacPorts is completely non-destructive and likes to install things in /opt/local, so it doesn't actually overwrite any system software. If you change your `$PATH` to put `/opt/local/bin` at the beginning, you get MacPorts software; if you put it an the end, you get system software by default, then MacPorts. If you don't change your path at all, you can run things out of /opt/local if you choose to, but otherwise there is no effect on your system. As for Emacs, I recommend manually building the Cocoa version from source. It works more like real Emacs than Aquamacs does, which tries to replicate other Mac apps a bit too much for my taste. Often, reading about dealing with Emacs, you go to try it with Aquamacs only to find that the functionality is already there, or an older version is preinstalled, or there is some glitch due to the patches. This doesn't happen very much with the Cocoa build.
It's not your fault. This results from a change made by the slime developers right around Christmas. It's easy to get the REPL back; see http://article.gmane.org/gmane.lisp.slime.devel/8055 for an simple fix and a discussion of the change. 
This is a good sign. I think clojure will be quite a bit more approachable once the PragProg book is out.
This list of "quirks" reminds me of Erik Naggum's sometime sig: "If this is not what you expected, change your expectations."
slime?
Jline. It's pretty well documented everywhere you could possibly hope to read about clojure.
One of the things I've found boring about comp.lang.lisp is the defensiveness when people want to talk about flaws/quirks of lisp. (This is not directed at you.) Because that really interests me. When I look back at really old discussions, back when you had species like Interlisp, the critical thinking seemed a lot more vigorous. By "quirk," I think he means that the tool doesn't act as abstractly as one would expect -- there's a computational layer that rears its complex head. (Just today I was reading Allen's _Anatomy of Lisp_, and I think his discussion of abstract vs. computational levels applies here.) rand-int's behavior is surprising enough to be a bug. Recently discussed on the Clojure forum. Needing to flush streams surprises people all the time, even when they've learned that streams often buffer. Clojure's documentation should say something about needinging to flush. Locking down on the classpath is probably a rite of passage for Java users. 
[Dupe](http://www.reddit.com/r/lisp/comments/7hwxw/common_lisp_weekly_news_laucnhed/).
Including Clojure's very own [Getting Started](http://clojure.org/getting_started) page.
via: http://wildermuth.com/2009/01/05/What_is_all_the_fuss_about_how_you_can_write_DSLs_in_Lisp
What Is All the Fuss About How You Can Write DSLs in Lisp? via: http://www.reddit.com/r/programming/comments/7ne8y/what_is_all_the_fuss_about_how_you_can_write_dsls/ With 125 comments.
&gt; A problem with the code above is that the closure is going to get re-allocated with every call: if I call (doit #'test-0 2) a 100,000 times, Ill need make space for the closure every time and Ill cons more than necessary and take extra time at that. "sufficiently smart compiler" could notice that closure's environment does not change, so it could optimize it allocating closure only once.
What if the compiler doesn't know what doit is? What if doit changes later on? I suppose a sufficiently smart compiler could keep the source of test-0 around and recompile it when needed, but even that could be undesirable behavior...
&gt; What if the compiler doesn't know what doit is? it does not matter -- all writes to "other" variable are only possible within its lexical context. since there are no writes there, it is possible to optimize it, possibly even inlining it into the code so there would be no such variable at all and closure won't need any environment to keep. 
...what? That sort of optimization has nothing to do with the dynamic-extent declaration. Presumably this code is meant to illustrate a situation where "other" may not always have the same value, else it's far more obtuse than it needs to be, and would be much simpler to optimize. Okay, now that I reread your original post, I see that you're indeed talking about an optimization completely different from what the article talked about. Technically, you're right, but it's not related to the article's point and it's not going to be much use in most real-world situations.
I get a 404 for the project page http://common-lisp.net/project/qrita/ :( But: Good news everybody :)
Interesting, three dead links...
Either a typo or they changed the name since the post was published, for the project name seems to be [qitab](http://common-lisp.net/project/qitab/), not qrita. Edit: Right, it says right at bottom of the page that they did change the name.
Based on IRC activity last night, streams are coming. Many functions that operate on seqs will be changed to operate on a new unifying abstraction, which will probably be called series.
Hamburg, Germany Seid herzlich eingeladen zum ersten Stammtisch des neuen Jahres, wie gehabt im http://www.ristorante-marilu.de/. Termin: Mittwoch, der 28. Januar 2009 Zeit : 19h 
Blogspam? http://www.librarything.com/catalog_bottom.php?tag=lisp&amp;view=lispm
[non-linkjacked version](http://www.librarything.com/catalog_bottom.php?tag=lisp&amp;view=lispm)
And who says Lisp has no libraries?
The little schemer http://www.ccs.neu.edu/home/matthias/BTLS/ thats where I started.
[Practical Common Lisp](http://www.gigamonkeys.com/book/)
That depends on the Lisp. If it's CL, then I can recommend [ANSI Common Lisp](http://www.paulgraham.com/acl.html).
(Best call it Lisp or lisp. LISP is considered archaic.) It really depends on how you learn and what you already know, and of course which lisp. I'll presume you mean common lisp. [Practical Common Lisp](http://www.gigamonkeys.com/book/) isn't a bad starting point for "mainstream programmers" who might know some java or php or whatever. It's not exhaustive (common lisp is a big language on its own, never mind all the add-ons), and as per the name doesn't emphasise the more academic/hifalutin' lisp topics that for all I know might be what interest you. 
For Common Lisp, two good places to start would be Practical Common Lisp (freely available) or ANSI Common Lisp (great book, but not free). Next, I would go with On Lisp (also free). For Scheme, you might want to start with How to Design Programs (free html version). It starts with the assumption that you are not a programmer. (though, you didn't say if you had experience) But, if you are experienced, you should be able to fly through that book. It is complemented by DrScheme which is really helpful when learning. The Little Schemer (not free) is a fantastic book, but I would use that as a second book. The format of the book is a hypothetical student/teacher discussion. Its an ok starting point, but I think it really shines at helping the concepts to sink in after you have your feet wet.
http://www.cs.cmu.edu/~dst/LispBook/index.html Common Lisp: A Gentle Introduction to Symbolic Computation David S. Touretzky 
I like Common Lisp. Two very good books for learning it are Practical Common Lisp by Peter Seibel and Paradigms of AI Programming by Peter Norvig. Object Oriented Programming in Common Lisp by Sonya Keene is also a good tutorial introduction to CLOS. ANSI Common Lisp is not a very good book for learning ANSI Common Lisp.
There's an interactive tutorial called [Lists and Lists](http://www.eblong.com/zarf/if.html#lists) where a genie (really!) poses a series of programming problems to you and you solve them in Scheme. It was the first Scheme code I ever wrote, and it delves quite deeply (if narrowly) into the concepts that make Lisp unique.
Practical Common Lisp is a great book. It has real world examples and doesn't bother with "exercises" at the end of each chapter. You write useful, functional code, and that's always the best way to learn.
Structure and Interpretation of Computer Programs (http://mitpress.mit.edu/sicp/) Yes, I know its scheme. Flame away.
Decide on common lisp or scheme. (How? Not sure, sorry. Maybe play with both. Be wary of online evangelicals though, a lot of the criticisms of both aren't really relevant). If you choose common lisp, grab SBCL, slime + emacs + Practical common lisp (and the HyperSpec as a reference - and/or work out how emacs+slime lets you view/search the hyperspec). If you choose scheme, grab DrScheme and one of 'The Little Schemer'/'How to Design Programs'/'the Structure and Interpretation of Computer Programs' (and note the DrScheme help acts as a language reference). Find a source of problems (Project Euler is good - but you might prefer to set yourself a real-world problem like writing a web site, etc) and then start producing code. Hit your references to help, and mix up working on the exercises in your book with solving non-book problems from your problem source. Or...you could go and join the arc people. They're over [there](http://arclanguage.com/).
Why flame? It's a great book. Also: http://www.scheme.com/tspl2d/ The Scheme Programming Language
I second this, slightly different from some of the others listed here, especially good for getting one's head around cons cells &amp; car/cdr functions. Like you I'm a very newbie beginner to lisp, I've found reading ALL the commonly suggested titles alongside each other is useful since they all come at the subject from a different angle. A bit like Rashomon, multiple perspectives help arrive at a better understanding. For instance, understanding cons cells quite intimately from Tourestzy's book helped understand code from Practical Common Lisp a LOT more easily (since I wasn't trying to get my head around two concepts at the same time). Obviously YMMV. Best of luck.
Clojure is good. Ok... CL is bad.. because I can't do this easily and had to write a utility function for that .. Never heard a programmer complaining about having to write utility functions before. Troll. 
For Common Lisp, you could start with, in no particular order: * [Practical Common Lisp](http://www.gigamonkeys.com/book/) * [Gentle Introduction to Common Lisp](http://www.cs.cmu.edu/~dst/LispBook/index.html) * [Paradigms of Artificial Intelligence Programming](http://www.norvig.com/paip.html) * [The Common Lisp Hyperspec](http://www.lispworks.com/documentation/HyperSpec/Front/) * [On Lisp](http://www.paulgraham.com/onlisp.html) * [Common Lisp Quick Reference](http://clqr.berlios.de/) And you could look up video tutorials by * Eric Normand re: [Reddit Clone](http://www.lispcast.com/drupal/node/3) * Marco Baringer re: [Slime](http://common-lisp.net/project/movies/movies/slime.mov)
Well, -someone- here is a troll. His point boils down to this, and I agree: 1) CL is outdated and will remain so because not enough people use it 2) Clojure is a little fresher and can leverage the mountains of java libraries out there. ergo) Clojure gets things done faster. 
Because we all know what a shining example Java is as a language, and how super wonderful the JVM is.
Really? The JVM is pretty amazing nowadays. The Java syntax, on the other hand, is terrible, but Clojure conveniently avoids it.
http://news.ycombinator.com/item?id=342828
Based on the comments to Brian's post, it appears Lars Nstdal is determined to singlehandedly eliminate any hope for a future for Common Lisp.
I wouldn't classify (.method arg) as a clever. The dot preceding the method name is very ugly, and adds unnecessary punctuation.
Learn to type parentheses fast.
Seriously, reading the comments thread I couldn't actually believe that guy (Lars) was actually an *advocate* for CL.
Would you shit on the namespace in order to provide generics for everything? Or just do ((get-method 'method obj)) which is much worse than (.method obj)?
* The JVM is good, though I'm enraged at its lack of support for tail recursion. * The Java syntax is acceptable. * The Java language semantics are south of terrible; it's a toy static language with shitty features and a half-assed object system that's shoven up your ass even when it sucks terribly for an object system. * The standard library is comprehensive, but it's terribly overcomplicated, overengineered and overdone; in other words, enterprise professional best-practices business solutions.
Neither are particularly grand solutions.
What's the particularly grand solution?
I don't know. But that's irrelevant. One need not have an alternate proposal to find another to be less than optimal.
Prove it's not optimal. All you need is an example that's better. Otherwise STFU, you have no base to claim it's less than optimal.
Some would breathe a sigh of relief over that....
&gt;Sure it's just a couple of utility functions (and learning the magic, cryptic FORMAT language) away, but multiply a couple of utility functions by the dozens upon dozens of times I have to do this kind of crap for a simple 300-line website.... Hits the nail on the head. In theory, CL might be the most powerful language ever invented, but actually getting work done with it results in a series of annoyances. Every single one of them can be overcome with a couple simple utility functions or a library that I may or may not be able to asdf-install that may or may not work with the implementation of CL I happen to be using. As PG [puts it](http://www.paulgraham.com/langdes.html), programming languages are for people; they're tools for thinking in. Clojure feels better than CL for me because trivial stuff like string concatenation is trivial.
&gt;The JVM is good, though I'm enraged at its lack of support for tail recursion. Not that this isn't a valid point, but Clojure has a nice workaround. The `recur` form converts tail calls in to iteration behind the scenes and throws an exception if used outside of the tail position. Recursion via self-calls is allowed anywhere and always consumes stack space. This seemed like a hack at first, but after using it for a while, I actually prefer it.
+ Learning to use GNU Emacs + SLIME + Learning LISP + Writing something in CL --&gt; 2 monthes + Writing the same thing in Clojure --&gt; 8 hours ========================= Has he forgotten something while counting ?
Excellent generic post, right down to the characteristic spelling, grammar, and punctuation.
Umm... isn't this exactly indicative of the problem with a certain segment of the Lisp community? i.e., snarky and condescending responses to the naivety of people new to Lisp, who nonetheless have some initial passion for the language, but who are turned away by the negative and antagonistic attitude they encounter? Some prospering language communities have a greater compassion towards newbies, and realize we are all learners at some point, that programming can be fun and exciting, and that ultimately we are all in this together. Why all the anger? 
&gt; Umm... isn't this exactly indicative of the problem with a certain segment of the Lisp community? Yes. &gt; Why all the anger? Well, don't judge the entire community based on comp.lang.lisp. (As you say, it's just "a certain segment".) The bad apples just have the I-get-off-on-attacking-"newbies"-on-Usenet/IRC/web-forums gene. **Edit**: I meant to say "don't judge the entire community based on *the bad apples* of comp.lang.lisp." I didn't mean to target the entire c.l.l community.
&gt; don't judge the entire community based on comp.lang.lisp. I've had very negative experiences on both c.l.l and #lisp. So far, lispforum.com has been friendlier. As for other communities, they can also be unfriendly if you're not sufficiently fanboyish.
&gt; snarky and condescending responses to the naivety of people new to Lisp, who nonetheless have some initial passion for the language, but who are turned away by the negative and antagonistic attitude they encounter? These people come around, and decide to fix Common Lisp instead of using it and then they vanish. Usually they are out of touch with reality and don't see the valid problems which their solutions introduce. See for example the [sweet-expressions](http://www.dwheeler.com/readable/sweet-expressions.html) which want to replace S-Expressions by some strange, ad-hoc syntax which besides being incompatible with all Lisp code doesn't introduce any advantage that other languages haven't yet. If you find out that you don't like it, don't use it and don't try to 'fix' it. If you like it use it and if after some years you still want to change it (most people don't want to, because they find out that it's not that bad, really) get in touch with implementors. &gt; I-get-off-on-attacking-"newbies"-on-Usenet/IRC/web-forums gene. It's not newbies who are valid questions are attacked but the newbie who hasn't got a clue yet and still knows that he knows the ultimate way of 'fixing' the language. Imagine a thread every day on `comp.lang.python` on how to fix Python not to suck so badly. I doubt that there would by any friendlier reponses. That said, I'm more a Schemer and as Scheme happens to attract less of these "I-know-best-and-fix-everything" folks I'm quite comfortable with the atmosphere on `comp.lang.scheme` and `#scheme`. By the way: these people who 'fix' stuff are usually also these who rate the regulars with one Star on Google Groups.
I've never had issues on C.l.l., or #lisp although I only went on a couple of times. I guess this is one of those Y.M.M.V. things.
&gt; These people come around, and decide to fix Common Lisp instead of using it and then they vanish. Usually they are out of touch with reality and don't see the valid problems which their solutions introduce. But this language experimentation is a *very good thing*! Its a wonderful way to learn, even if the initial efforts turn out to have been naive in the extreme. These people begin to think more deeply about the language through their efforts to "improve" it, and if they were supported by the community, they would either eventually come back to pure Lisp, or possibly even add something new and worthwhile. &gt;See for example the [sweet-expressions](http://www.dwheeler.com/readable/sweet-expressions.html) which want to replace S-Expressions by some strange, ad-hoc syntax which besides being incompatible with all Lisp code doesn't introduce any advantage that other languages haven't yet. Its seems the author is trying to add the advantage of *readability* for the broader development community. People do tend to more easily understand infix expressions in particular contexts. &gt; If you find out that you don't like it, don't use it and don't try to 'fix' it. But isn't progress sometimes made by people who perceive a weakness, rightly or wrongly, then head out in new directions and discover something interesting, something that would never be found by those who adhere religiously to an unchanging language dogma? &gt; I'm quite comfortable with the atmosphere on comp.lang.scheme and #scheme That's been my impression too. The #scheme culture seems allot more forgiving and experimental, embracing more of a "its ok to hack it" culture. Now, what do you think of Arc?? :-) 
I have lurked in c.l.l for years. Every time I had question or problem, I had it answered in c.l.l politely and comprehensively. Few times from old time CL guru (one of the creators of Common Lisp standard made follow ups by private mail and made sure that I had figured things out). If you look at the people who get put down in c.l.l, they usually have some agenda or grave misconceptions they are not willing to give up despite being corrected. 
&gt; But this language experimentation is a very good thing! Its a wonderful way to learn, even if the initial efforts turn out to have been naive in the extreme. Absolutely, but for experimentation they could first experiment with the existing language before coming to the conclusion that if even needs to be fixed. &gt; Its seems the author is trying to add the advantage of readability for the broader development community. People do tend to more easily understand infix expressions in particular contexts. Ultimately it leads to a quirky syntax nobody else but the author will understand. For him it is logical, but most of these people who want to improve stuff don't understand that their proposal only helps them but rarely someone else. Lisp is Lisp exactly because of the S-Expressions and prefix syntax. Removing that would complicate macros to such a considerable amount that it would be hard to call such a language Lisp at all. &gt; But isn't progress sometimes made by people who perceive a weakness, rightly or wrongly, then head out in new directions and discover something interesting, something that would never be found by those who adhere religiously to an unchanging language dogma? Like newLisp, re-discovering dynamic scopes? Lately there was a discussion on LtU, where the scoping discussion was said to be "solved". At first, it sounds ok, but then you find out that it's an awesomely stupid idea. An CL supports it too, so no improvement there. &gt; Now, what do you think of Arc?? :-) Not that much, Vapourware that didn't meet expectations. I do not really see the problem which Arc is trying to solve, so it feels like a solution looking for a problem. Clojure got much more popular exactly because it is solving a particular problem. So Rich Hikey *did* improve things and not by complaining but rather by doing his stuff and saying "hey, this is my 'fixed' version of Lisp which is better in this and that regard, go and check it out". So, 'fixed' Lisps *are* useful, but for that they should really fix some real, non-imagined problem.
Many newbies learn, improve, change, and become gurus. This has even happened on CLL. Some, however, neither learn nor change, but they do stick around and continue to annoy. Interestingly, CLL welcomes people that *really* want to fix things, *and do*. Witness the reaction to Clojure (JVM-based Lisp dialect) and Qi (strongly typed Lisp dialect, I think). Those guys have given papers at Lisp meetings and are generally held in high regard, as near as I can tell. It's the nine hundred thousandth newbie that complains for the tenth time about the () as if it's something they, personally, just discovered, that gets flamed. "When people complain about the () in Lisp I ask them if they get annoyed by all the spaces in the newspaper." -- Paraphrased from Kenny Tilton On the other hand, I haven't been a regular on CLL for several years. So who knows. But frankly I doubt it's changed much. :)
Make sure you see the example [here](http://github.com/bakkdoor/defpage/blob/ae79b6bb5c73efcd19629e65bb5e4605324ca45f/examples/example1.lisp). I love how Lisp's syntax caters both to CSS and HTML and manages to keep them both readable and understandable all the same. Makes me want to try it out asap. Though I'd be wary if, as the comments in the code suggest, it imposes a particular directory hierarchy on me. Beautiful, though. 
you can make this kind of "framework" in like a hour or so. there are HTML and CSS generators you can use, so you only need some dispatchn job
it'th thimply the etheth that are the problem.
Fucking thing thucks!
Clojure user=&gt; {:a 1} {:a 1} user=&gt; {:a 1 :b 2} {:a 1, :b 2} user=&gt; (:a {:a 1 :b 2}) 1 user=&gt; (conj {:c 3} {:a 1 :b 2 }) {:b 2, :a 1, :c 3} user=&gt; 
Lisp is a meta-language for writing domain-specific languages. If don't like the hash table syntax and/or semantics, change it.
&gt; One of the first complaint people have with CLs hash tables is that they have no reader syntax. the idea of Lisp is that you have common syntax for everything. you can fix lack of "special syntax" with a mere function or macro. or just use one of existing libraries. e.g. with Arnesi, this: oldest({"Vincent": 25, "Lincoln": 200}) becomes this: (oldest (build-hash-table () '((:Vincent 25) (:Lincoln 200)))) pretty much the same, i'd say, especially if you don't write that dumb code every day. if you want something simple, can just use alists &gt; I think most people find them inconvenient to use. mostly people who do not use CL find CL hash tables inconvenient. people who use CL find using them just fine. &gt; The idioms of recursion that you learned with lists can be transposed easily. however, this nice recursive function won't work on large hash tables because it is not using tail calls and Java does not allow tail calls anyway. i don't think that not supporting thing that does not anyway work good is anyhow bad. this comment is utterly stupid
&gt; mostly people who do not use CL find CL hash tables inconvenient. people who use CL find using them just fine. With all due respect, I don't think you're speaking for us. In fact, probably the most popular looping construct (and my favorite), LOOP, is particularly bad with hashes: (loop for k being the hash-keys of hash using (hash-value v) ...) It probably started as a joke, but some jokes get really old. It is true that CL gives unusual power in correcting such problems, with SETF expanders, an open reader, and so forth. (If opensource is so powerful, consider the power of open design, where the user has enormous power to change the rules.) However, defaults are still powerful things in the Lisp world.
STM and all that Terracotta stuff for something with 2,000 transactions per hour? I don't get it.
Meh. I just ["invented"](http://mikael.jansson.be/journal/2009/01/hash-tables-and-a-wee-bit-of-sugar-in-common-lisp) the following function ({} "Vincent" 25 "Lincoln" 200) Does it make people feel happier? Of course, you could just use regular a-lists as well ``(:vincent 25 :lincoln 200)``
Article would be a lot better if it explained what it means for a language to be extensible vs. merely supporting libraries. What type of functionality, what extensions require the language to be extensible? When is the overall benefit positive? Lisp has certainly suffered from a lack of standards with regard to object systems and libraries; in this case, a less powerful standard might be better than flexibility which brings isolation.
&gt; Lisp has certainly suffered from a lack of standards with regard to object systems Huh? Common Lisp was the first Object Oriented Language with a published recognized standard. CLOS, the common lisp object system, is a major part of the ANSI standard. &gt; a less powerful standard might be better than flexibility which brings isolation. That doesn't make much sense either ... what is it you are trying to articulate?
Just because `define-fexpr` is called `define-macro` doesn't mean it defines a macro.
context: http://groups.google.it/group/comp.lang.lisp/browse_thread/thread/39a9e50aa548637f
&gt; The first and most important, CL macro is not the first-class on the other hand, in Newlisp lexical variables are not first class, that is, they do not exist. this is much worse problem, because most (normal) people do not write macros each day, but they use closures and lexical variables each day and hour. &gt; object, so Cavallaro cannot, for example, map or apply his at-least. and why one would like to map a macro? if macro should work in this way, it should be a function. it is trivial to wrap macro as a function with closures, but macro will lose its _macroness_ then. it doesn't seem to work in Newlisp either, for example, when I call it as a macro: &gt; (at-least 2 (print "a") (print "b") (print "c")) abtrue only first two forms would be executed, great. but if i call it via apply: &gt; (apply at-least (list 2 (print "a") (print "b") (print "c"))) abctrue all three are executed. if i quote them, they are interpreted as lists, none are executed: &gt; (apply at-least (list 2 '(print "a") '(print "b") '(print "c"))) true so, in no language you can call macro as a function, because macros are conceptually different from functions, by definition, and it's not a problem of a language.
Processing and Clojure?
Maybe [fluxus](http://www.pawfal.org/Software/fluxus/)?
lispbuilder-sdl? link: http://lispbuilder.sourceforge.net/lispbuilder-sdl.html
"In Newlisp, functions are lists and you can store any kind of data on any way in those. So, if you need closures, you can have it." *facepalm*
pygame with python?
&gt;&gt; a less powerful standard might be better than flexibility which brings isolation. &gt; ... what is it you are trying to articulate? When a language permits "flexibility" in certain areas, that makes it much more likely that different libraries will use the flexibility in different ways, and thus become incompatible. The "less powerful standard" I refer to is a language without this flexibility, but with standardized support for the feature in question. Perhaps the Lisp object system was a bad example; how about the Scheme object system or module system? The overall utility (and, if you believe in market principles, success) of a language is dependent on the overall state of the ecosystem. Compared to a language like Java where all libraries use the same module and object system, I am hypothesizing that a language like Scheme is actually disadvantaged by giving users the flexibility to build their own object/module systems; the reason being that the flexibility itself isn't worth *that much*, but the overall impact of incompatible libraries on the general user is huge. That's what I'm trying to articulate. I suspect that, to some extent, languages like Perl, Ruby, Python suffer from this phenomenon. In Java, there is a very limited set of "weird things" a library can do when you call it. In the dynamic languages like those just mentioned, a library might modify the core behavior of the system or its libraries in a way that is not immediately apparent. I believe this also has "negative externalities"; while the library creator might benefit from increased productivity, I predict that the overall impact on that language's community (from things like monkeypatching) is negative. OTOH, in languages like Java and C#, and to a lesser extent (well-written) C and C++, you can throw a bunch of libraries together and be reasonably certain they will interact only through their defined interfaces. In general, static semantics (i.e., type systems) and well-defined standards (e.g., module system) bring about reliability and predictability on the large scale. Dynamic semantics and flexibility might make any individual's life easier, but actually make it harder to assemble huge software systems from thousands of components (involving hundreds of people). I am articulating that flexibility has both advantages and disadvantages.
Yeah we get it. It sucks to write a book about a language that changes so much. Stop posting your innumerous Betas, and come back when you have a final version. 
I haven't tried it, but (didn't work out of the box on linux) [pal](http://common-lisp.net/project/pal/) maybe?
If you click through you'll see that there is a blog post detailing information and changes about the upcoming book. It's not like he's just linking straight to a beta PDF. 
Clojure considered harmfull.
Please explain why you think that
Sorry for teh downvoted. I get enough of Xah's negativity lurking c.l.l; I wish he'd go away and just start using a different language already.
'Lisp' on its own typically means Common Lisp, not other members of the Lisp family. To refer to generic Lisps, 'a Lisp' is preferred.
I'll add two links that might be of use for those who are interested enough in the subject to make their own opinion: * Newlisp lexical scope support, adviced by Newlisp author: http://www.newlisp.org/downloads/newlisp_manual.html#contexts * My own texts explaining how dynamic scope can be used on a safe way, if one uses language without lexical scope or he doesn't want to use lexical scope. (Again, NL has lexical scope.) http://kazimirmajorinc.blogspot.com 
If you left off a parenthesis you would have a syntax error...
Non-linkjacked: http://www.international-lisp-conference.org/2009/index 
I always find it odd when something called "Open X" is a proprietary implementation of X.
Different meaning of open, which I would say is the original "corporate software" meaning of open, which is: "runs on multiple platforms". VMS -&gt; OpenVMS when DEC/Alpha entered the mix. OpenLisp started in 1988, so this version of "open" would have been in the corporate nomenklatura, instead of the one people use today. Still, I agree, it always did strike me as odd when "open" was used when they really meant "portable". *sigh*
If it weren't for airfare, I'd definitely go. $75 for students is cheap like borscht.
The news were actually spanning two weeks since the editor was away on vacation.
"Hay guyz downmod plz."
You may check the "related" tab to see other planet feeds as well.
You wish.
&gt; Get 3 bytes at a time (if you can't, just pad with a character, typically =), munge them together (making 24 **bits**). We then split this 24 bytes into 4 lots of 6 **bits** which allows us to pick one of the 64 allowable characters. Fixed for you.
D'oh, I updated the post.
Glad I could help.
Does that exclude spam or not ?
It is Google archive, it includes some spam, but very little. Most of spam is deleted, and few messages that left didn't generate response. The largest number of messages are in the long threads. In few months I checked manually, I've seen something like 0.3-0.6% spam in archive of comp.lang.lisp. 
&gt; The name lisp is a general name for the lisp family of languages as per John McCarthy wish, the inventor of lisp, lisp should be used as label for the whole family of lisp languages instead of describing just one language. Something like c, c++, c# and java are family of c language &amp; its descendants. That wouldn't be such a huge problem if the ruling patriarch of lisp family, common lisp had it's own newsgroup. Something like comp.lang.common-lisp , but (for unknown reasons) it doesn't. So all the common lisp users, the majority of lispers, dwell on comp.lang.lisp which is generic groups for all lisp family of languages. The thing is, Common Lisp _is_ the generic Lisp, the 'common' Lisp as it were. It's the product of decades of experience. That's why comp.lang.lisp is full of Common Lisp stuff: because Lisp is Common Lisp and Common Lisp is Lisp. No, CL is not perfect. Yes, it could be improved. However, it's fairly likely that the things which make no sense to you or me (and there are many) actually _do_ make sense.
Scheme is still a very good choice to begin with, especially if you start with the DrScheme programming environment. 
Common Lisp is a unification of several competing older Lisps. It's no more generic than C++ is relative to the C family of languages. The more things a language has that don't make sense to you, the programmer, the harder it is for you to get something done with that language. Often, the solution is simply to learn the language, but sometimes little mismatches are annoying. As an example, the CL `concatenate` function is more powerful than most because it can concatenate arbitrary sequence types and produce the type you specify. Despite that, nearly everyone writes a `concat` function that selects the output type in a predictable way (often the type of the first argument). More generic isn't always better in the real world. There's something to be said for flexibility, but there's also an advantage to not having to think.
Lately lots of beginners (me included) end up with Clojure, after about a year of shopping around. It has its strong points, but most important it has a lack of defects: it's easy to install/deploy and you won't have issues with lack of libraries. Plus it's growing incredibly fast, so it's a safe bet whatever shortcomings you may find they'll be solved within months. 
Clojure is currently my language of choice. I do feel it necessary to warn beginners that working with the Java libraries can be infuriating due to their design for anyone not used to Java-style OO.
In my case a major shortcoming was solved in a day and a half. Clojure is pretty amazing, and its community is still small and very receptive.
Java libraries can be infuriating, period. It's amazing how so much wisdom and good intentions gave birth to this monster. 
&gt; munge them together (making 24 bytes) Forgot to update the first occurrence.
Interesting that the last line says "source code GENERATION", which is *quite* different from source code *transformation*. The headline is oddly correct, even though the original article is not. It's probably what he meant though.
Ah! It had been a long time since I had read this. This article always reminds me how elegant and simple the core of lisp is.
All this talk of macro safety and no mention of hygiene? 
There's xml/xslt if you feel sick of toenail clippings and prefer angle grinding.
We're talking about programmers here. What do you expect?
I should proof read more, thanks for pointing it out!
XSLT is only the answer when the question is "XSLT or death by anal dynamiting?". Even then it may be worth first contemplating your answer. 
The answer would depend on whether the dynamite is lubricated.
he's right, but his code has bugs. example: `(defmacro set-sqrt (place v) `(setf ,place (* v v)))` this needs commas in front of the each v. also, there's a multiple-evaluation bug on the same line. `(setf (sq x) (incf x))` sets x to 12 if it was 2, because it expands into code that calls `(incf x)` twice. macros in lisp can be tricky too. it's the price you pay for all the awesome.
1 - he's not right. lisp macros are unreliable. see comments elsewhere on hygiene. also, in (most) lisp there's no type information so you can easily change the code so that the syntax is correct but the semantics are completely screwed. 2 - when it comes to source generation there are several strongly typed systems that give stronger guarantees than lisp. eg metaml (although it may have been developed after 2005 i guess).
Well, I'd say the most direct way to translate the example into Common Lisp is this: (map 'vector (lambda (x) (* x x)) #(1 2 3 4 5)) That's not lovely, but it's a lot lovelier than the given example, which is execrable. That's not to detract from the niceness of the reader macro syntax he comes up with.
That would be *trivial* cryptanalysis.
[A quick example](http://gist.github.com/62946).
The critical response to the library announcement is funny. &gt; You've made lisp weaker within your particular library and this might be harmful for CL. I love that someone writes a library, and this person says that he's harmed the language. I kind of like the construction of this criticism though. Let me try it with something else. "You've made Mac OS X weaker with your particular application and this might be harmful for the OS."
Trivial only in the sense of already solved.
You don't seem to know a lot about cryptanalysis.
It's amazing how negative the CL community is. The poster is right that those arrows are unLispy and there are already pattern matchers out there, but it's disappointing how unsupportive CLers are of new contributions. One guy criticizes the OP with little or no encouragement, and no one else says anything at all.
So, you did 'support' him? The OP also asked for email responses. Did you send email? I kind of missed your response, other than blaming the entire Lisp community (how about those who don't read cll) here, for others not posting responses? Why blame others when you seem to read that, but don't post anything.
I haven't been hanging out on cll. Between the spammers and the abrasive culture, I've given up on it for now. If the OP would post on lispforum.com -&gt; Common Lisp, I would respond supportively, even though I agree with the technical criticisms of the code. I try to be helpful there, and I did likewise when I was on cll. I've been flamed on both cll and #lisp, despite trying to write good code and always being friendly. As for whether I blame the "entire" community, what other forums are there? Where do nonabusive Lispers hang out to e-chat? 
Usenet generally tends to be more nasty nowadays. The Lisp forums were much more friendly in the 80s when there were only research groups online. But that is long ago. Today the Lisp community is split up in many different camps (the free software guys, the commercial users, the scheme users, the common Lisp users, the Emacs Lisp users, the application developers, the vendors and their users, the academics, the hobbyists, the amateurs, the old farts with grey beards, the new blood, ...). It is REALLY REALLY hard to see them as a SINGLE community. Plus there are lots of people using Lisp who never use anything like #lisp, lispforum or cll - you may find occasional email messages on mailing lists. For chatting there is #lispcafe on IRC for example. For specific information exchange their are the various mailing lists (see http://dir.gmane.org/index.php?prefix=gmane.lisp for a subset ). Since these mailing lists are much more focused on their topic, they have a higher signal to noise ratio.
I don't think the existence of local or narrow subcommunities automatically rules out the possibility of wider groupings. If it did, cities and countries wouldn't exist, and we would still be using MacLisp and ZetaLisp. I think the main cause of fragmentation in the Lisp world is that it's been marginalized in most of the software industry. Ron Garret's article about NASA migrating to C++ is a good example, and everyone knows how popular Java, VB, and PHP are these days. Anyway, I would settle for a decent CL community, or even an OCaml community with a decent job market. Otherwise, I'll stick with LF.com and Reddit. I only like irc for real-time advice when I get stuck in the middle of working on something.
Sure, larger groupings exist. In the Lisp community this is cll and the Lisp conferences. Still the larger groupings mean that it is likely that people will not like each others positions on some topics. That diversity. We learn to live with it... Fragmentation because of being marginalized? I thought it is fragmented because there are widely different users and their uses of Lisp. An academic teaching Scheme to students wants another Lisp than a windows user programming a factory simulation in a manufacturing company. I don't care about embedded uses of Lisp (because I don't work in that area), but others may use that even in industrial projects like iRobot. Like the Algol world was fragmented into extremes like Ada users in military and Oberon users in Zrich. Like the C world fragmented into C, C++, Objective C, C# and others. You have mentioned lispforum.com . Why not use it?
&gt; I thought it is fragmented because there are widely different users and their uses of Lisp.... You have mentioned lispforum.com. Why not use it? I already said "I don't think the existence of local or narrow subcommunities automatically rules out the possibility of wider groupings" and "I'll stick with LF.com ...", so I'm not sure what new point you're trying to make. Anyway, the issue of an overall Lisp community is somewhat off topic here, and my question about other forums was mostly rhetorical. (a) cll and #lisp don't seem very friendly to me, (b) I don't think there's anything wrong with avoiding forums one doesn't enjoy, and (c) I do think I'm doing my part to contribute to a healthy Lisp community. 
I can't follow you.
1. I know there are different kinds of Lisp and different kinds of Lispers, but I'm not convinced that explains the lack of a wider group. I think there might be more cohesion among Lispers in general if Lisp were more prominent and successful in the software industry. 2. I already indicated that I hang out on lispforum, so I don't understand why you asked "Why not use it?" 3. You criticized me for complaining about a lack of support on cll for the OP of the thread we're discussing, even though I didn't post anything myself. I explained that I don't think that's my responsibility when I haven't been hanging out there in general. 4. You don't need to explain the Usenet or list areas of programming for me. I've spent a lot of time on many internet forums, and I've never received as negative a reaction as I did on cll and #lisp. The combination of a weak job market and a less-than-friendly community has been a big disappointment for me, because I like Lisp a lot and I think the software industry would be more productive if Lisp and/or other functional languages were used more. It would be nice if we could promote them a little better.
1. which Lisp? 2. great 3. you are complaining that nobody was encouraging that guy and you were not encouraging him either. I find that strange. 4. Are you sure cll and #lisp are the problem? I think your expectations lead to your disappointment. A vague concept like 'promoting' is not enough. Either one has to show off cool things that are interesting to a lot of developers (which Lisp hasn't) or one has one or more huge sponsors (SUN, IBM, Apple, Google, ... - which Lisp hasn't). Companies like SUN, IBM, Oracle, etc. have invested billions into Java. Lisp does not have such a sponsor. Why isn't there a sponsor? Lisp does not fit in well and is too complicated. It is too different to be applied widely and too different to die - at the same time. System-level things are still done in C (or C++). Enterprise software is written in Java. Web stuff in easy to use languages like Python and Javascript. Then there are dozens and even hundreds other solutions to develop things. Often the flexibility of Lisp is just not needed or even not wanted. Symbolic computing? Used by only very few and for some domains there are special solutions available. The last big sponsor for Lisp was the US government and the government stopped investing into Lisp technology in the late 80s/early 90s. So the weak (job) market is long known and nothing new. Specialists and/or people with domain knowledge still might find work (see the lisp jobs mailing list). Functional languages today mostly look different from Lisp. But both Lisp and functional languages are too complicated for average programmers and don't fit well into the current system landscape. For me it is not surprising at all that it looks like it is. Some people see that there is a problem, but even somebody like Alan Kay hasn't been able to improve things substantially (though he has made huge contributions, is constantly advocating against the 'state of the art' and is working on alternatives). 
C.f. Scheme's [SRFI](http://srfi.schemers.org/) process, and its success in the instances of 'srfi' on, for just one example, [this page](http://chicken.wiki.br/Eggs%20Unlimited%203). People who complain that CL doesn't have [extensible hash tables](http://cdr.eurolisp.org/document/2/index.html) can at least *specify* what they want, right?
Though it is more common (and easier) to use the macro defpackage than make-package
It gets to that.
It's buggy with respect to the assumption that a missing USE list implies using COMMON-LISP. You can't make any assumptions; the default USE list for SBCL is empty, for example.
Thanks for pointing that out. I'll fix that in the next revision (assuming I find time to make a next revision).
You can ASDF-Install it, or get it from [the SourceForge page](http://series.sourceforge.net/). 
Why not just have one form that does _everything_?. Oh Yeah .. cause it's a silly idea ;).
Oh, that's called EVAL
Actually, it's called LAMBDA, but you've missed the point. That's ok, it wasn't made well. 
Edi's CL-INTERPOL does this and a lot more. 
I'm glad Arc has been rescued from pg's cold, intellectually dead hands.
Lisp is fun as hell
That is the general convention, mainly for historical reasons.
Very nice. I have to say I avoid destructuring-bind and multiple-value-bind sometimes partly just because their names are so long, so bind is a win for me.
&gt; "$(\"#content\")" what's about "$('#content')"?
Looks like my quote file gets a brand new entry today
Interesting that the cl-cont continuations didn't work for that (presumably because cl-cont does macro transformations of some-but-not-all code?) It does work in scheme: (define (looper k) (let ((i 0)) (map (lambda (x) (display (string-append "looping: " (number-&gt;string i) "\n")) (set! i (+ 1 i)) (when (= i 3) (k))) '(a b c d e)))) (begin (display "running\n") (call/cc looper) (display "after\n")) displays: running looping: 0 looping: 1 looping: 2 after 
No, it's really not. I am part of the lisp community myself, so I have a say. 'lisp' is a family of programming languages, and as a result could refer to anything derived from the original. This usually means any language in s expressions, unfortunately, but that's the way it is. Anywho, clojure is most definitely lisp, along with scheme, GOAL, and my uncle billy's pet lisp project.
wow. this was downvoted why? fucking lisp weenies.
You're both right. Lisp is definitely a family of programming languages, and Clojure and Scheme are definitely members of that family. In addition, if using 'Lisp' to refer to a concrete language without qualifier, the person is almost certainly referring to Common Lisp. Think about the following (and not in the typically pedantic reddit way of only trying to analyze the propositional content rather than the apparent intended meaning): * 'I'm a Lisp hacker' * 'I wrote it in Lisp' * 'The Lisp implementation of that is (defun ...)' and so on and so forth. In cases like this, the person is probably not talking about Scheme.
With carbon nanotubes, you can knit whole systems.
You mean as in "Give me XSLT or give me death by anal dynamiting!!" ? That's rather curious.
I guess rule 34 is invoked again ...
I hope someday I create a game, and have the honor of posting it to TPB myself.
&gt; We can't use single quotes here either because Hunchentoot will delimited the onclick part with them.
Doesn't actually appear to have been touched in a while...
Quite a long way to [Genera](http://en.wikipedia.org/wiki/Genera_(operating_system%29) still
1) Program PDF reader in lisp. 2) ???
Good read. Now for a little ad; i myself am working on a lisp with a better typing system. Also where macros can access what types things have. Another big thing is modularity, as much as possible should be (standard)library, rather then language specification, as common lisp currently has it. I wish i had a better website at this point, and note that it is early in development; not usuable at this point. Feel free to leave me some suggestions/comments. The website of [lang-lisp](http://lang-lisp.berlios.de/main.html)(working title) And the [forums](https://developer.berlios.de/forum/forum.php?forum_id=32043) (But you can just reply here)
ECL is pretty cool and deserves more attention. Something like luabind (auto binding with boost C++ library) will be extremely useful. 
I want to try this out! Being able to generate a native executable, able to intermix C and lisp makes it very practical for application delivery.
Wow, so clunky.
[ecl-examples](http://github.com/ayrnieu/ecl-examples/tree/master) shows off C interop and two ways of building executables.
It was - years ago. The dark night of SBCL-less OpenBSD began with a series of added protective features to OpenBSD: randomized memory, W^X, severe (for SBCL) memory limitations, etc. I haven't followed all of the problems. Even this SBCL port is i386-only.
Very nice implementation, maybe the one with the biggest potential to be the CL implementation. Too bad it only have one (although excellent) maintainer.
Why is it not more popular? Bad marketing? Unusable from slime? Everybody seems to suggest SBCL or ACL or LispWorks...
Maybe it needs better community? Porting couple of libs to it will do much to its acceptance.
I do think it is a good thing to let common lisp know higher order functions rather then macros where possible. And macros that could function with functions below, should and should also allow for them to take functions instead of just code as arguments. That way, the distinction fades, and you have both the ease of use of macros, the idea that used functions, and you can use the actual functional version with the information you have. I should really try [iterate](http://common-lisp.net/project/iterate/) but i don't think it has the 'easy to use functions instead of code' part. So instead of, can also: (iterate-i-imagine (var i 0 (+ i 1)) (in el list) (collect (list i el)) (iterate-i-imagine (var-fun i 0 (lambda (i) (+ i 1))) (in el list) (collect-fun (lambda (&amp;key el i) (list i el)))) I guess collect-fun wouldn't be able to set el this way, that is one dislike i have of lisp, no references. Thanks for making me think about this, i will need some kind of loop/iterate macro, as a library for [my lisp project](http://lang-lisp.berlios.de).
hmm, but ecl and clisp were and are there. I guess it's time to check out sbcl on openbsd.
Too... much.. text.. please.. make.. abstract..
Four paragraphs on how this guy thinks the jvm is "slow" because of the performance of certain applications that happen to be written in java. *sigh*
Yep. Here's the thing. Clojure is slow. Even with various tricks, Clojure is slow. And it's not because it's on the JVM. But people will assume that. :-( 
I'll suggest [Newlisp](http://www.newlisp.org) for start, because it is maybe the simplest general purpose Lisp dialect, with good support for various internet protocols - but although author's emphasis was on simplicity, it is also very abstract and powerful dialect. There is manual on that site, with lot of example, one free book, and helpful community. My second choice is PLT Scheme - there is free literature with implementation and great IDE, and also very helpful community. Whatever one chose, I suggest not reading much, but writing much. I have find that I benefit from reading programming language books only if I already understand some solid part of the language.
Illiterate titles for literate programming. Fuck yes.
I was going to make that obvious joke!
Please use a permalink instead of linking to the front page.
i was experimenting with ABCL + Terracota once. seems to be possible, but requires some work
http://cdrinpeace.wordpress.com/2009/02/22/writing-a-read-macro/
Clojure -- the first programming that doesn't support neither recursion nor iteration properly. i'd call that a dysfunctional programming languge..
It's talking about CL, which doesn't have a problem with hygiene.
Even in a Lisp-2, you still encounter problems with unintended variable capture. Examples: http://community.schemewiki.org/?hygiene-versus-gensym Unless there's some CL macro feature I'm unaware of...
That page does not describe CL problems with gensym, but Scheme problems with it. CL does not have problems with gensym. &gt; some CL macro feature There are autogensyms, once-only evaluation, order of occurrence =&gt; order of evaluation, but these only make macros easier to write. They do not make macros any safer to write. The basic tools are enough. EDIT: [Here's](http://groups.google.com/group/comp.lang.lisp/msg/07b915645de0cec7) an entertaining summary of the situation.
&gt; Java has more power than many people realize. On the other hand, the Java code is ugly and bulky; a Lisp-like language is a much more natural fit. This observation is a sad consequence of the FP hype. *Java* is powerful, and Lisp's advantage here is one that ranks it below *Haskell*. The real advantage of a 'lisp-like language' is not that one happens to express a particular concept naturally, but that expressions that would be ugly and bulky can be *made* natural. Now that you've found this solution in Java, you can stop - or else take this feature and make it a property of your new incompatible java-like language with its own name, compiler, website, etc. If you find an ugly and bulky solution in CL, you're a hop and a skip away from a pleasant solution.
Can you explain why CL doesn't have problems with gensym? Your link seemed to focus more on the psychology of scheme programmers than technical issues. 
Why, because it's a lisp-2. Here's the see-gensym-is-bad example from your link: (let ((set! display)) (cl-swap! a b)) which expands to (let ((value a)) (display a b) (display b value)) *in Scheme*. This just doesn't happen in CL. Even if you write a `swapf` macro in one package and then export it to another that has its own definition of some function that `swapf` macro makes use of, this won't happen -- because the symbols in `swapf` still refer to the original, intended functions. You'd have to *try* to have the problems that Scheme has even with gensym.
ABCL, too, although getting the JDK is a hassle. ABCL has threads on OpenBSD, which I can't get with clisp or SBCL. [And I can't get ECL to build, but this is surely a temporary problem.]
Ah, if I could get java on openbsd I would go for clojure for sure.
Clojure's decent, but read Let Over Lambda if you want some antibodies against a language that sells its soul for a mess of porridge -- in Clojure's case, a language that throws out read macros, symbol macros, macrolet, and that makes the surving basic macro facility harder to use by having more syntax and fewer puns. And... check back at [disclojure](http://github.com/ayrnieu/disclojure/tree/master) in a few weeks :-)
I'm totally guilty of posting a link after just skimming it. You're right, the macro problems on my link are only issues for a Lisp-1. 
inb4 [Xach's review](http://www.reddit.com/r/programming/comments/6kc4p/new_book_about_common_lisp_let_over_lambda/c043ego). Certainly many people found this a very compelling review, but it's so personally shameful that, when I think that someone may read it and then LOL without knowing who Xach is, I'm tempted, almost, to apologize on his behalf. "This guy actually does cool things with Lisp, isn't some kind of Haskell troll, ...". I don't want to spend too much time speculating about the kind of blinders he must've had on. To come to my dim opinion of this review, you need only to read the first three chapters of LOL with Xach's 'review' of them in mind. You'll see exactly where each point comes from, and your WTFs will rapidly snowball. The only point that bears mention is the one about (function '(lambda ...)) Hoyt obviously checked this with CMUCL. Some other people who've 'read' LOL have opinions of it that are amazingly detached from the text itself - such that, again, reading LOL is all you need to begin to get personally irritated. You have someone disparage the book for promoting Scheme over CL and then you read and it and-- this is not merely *mistaken*. It's a view that nobody could possibly take from the text. You have someone suppose that Hoyt must be a kind of Arc person, and quip that he should just use perl, and then you read [this](http://paste.lisp.org/display/75921), which is only the drumroll up to LOL's massive injection of antibodies against the kind of thinking it's alleged to exhibit!
From the first section of the first chapter, this is what LOL is about: --- If when considering macros you find yourself relying on stylistic aphorisms like * Macros change the syntax of lisp code. * Macros work on the parse tree of your program. * Only use macros when a function won't do. you are probably missing the big picture when it comes to macro programming. That is what this book hopes to fix. --- Or, as someone just advised in #Emacs: --- the first rule of writing a lisp macro is: 1. don't. 2. take a deep breath, and don't. 3. Maybe think about it, if there's no other way. 
thanks - will do
You could just call it a Clitorial
I don't know. I started skimming through the first chapters and discovered, apart from what has so far been noted in the reviews, strange remarks, idiosyncratic terminology, puzzling examples, and buggy code. An example of a puzzling example: (defun environment-with-indefinite-extent (input) (cons input nil)) The environment here has dynamic extent (for some reason the author uses the term "temporary extent", which doesn't make much sense). An example of buggy code (the code is also inefficient and does not suit my taste): (defun block-scanner (trigger-string) (let* ((trig (coerce trigger-string 'list)) (curr trig)) (lambda (data-string) (let ((data (coerce data-string 'list))) (dolist (c data) (if curr (setq curr (if (char= (car curr) c) (cdr curr) ; next char trig)))) ; start over (not curr))))) ; return t if found Try this: CL-USER&gt; (funcall (block-scanner "ob") "foobar") NIL I would expect the scanner to return true here. Still, it is possible that the book does contain interesting and well-considered parts. If you did find such parts, I would like to hear about them.
&gt;the first rule of writing a lisp macro is: don't. I disagree. If you know what you're doing, macros can be very useful. I write Lisp at work, and we use a *lot* of macros, because you can get better performance if you use them right. For example, a macro which loops over a particular kind of collection can run faster than a general-purpose iterator, cons less than converting the collection to a list, and be more reliable than requiring people to write the loop by hand. Now, it is certainly possible to write macros that get you into trouble. My rule of thumb is, I don't write macros unless they're analogous to existing macros. So, a specialized loop is fine; a pattern matching system (like Haskell or ML) is dubious; a coroutine system is so far from fine you can't see it with a telescope.
I am curious. If its not too much trouble would you kindly answer these questions? 1. Where do you work? 2. Which implementation of lisp are you using? 3. which libraries do you use and how have they worked out for you? Thanks!
Macros should not be used for performance, they are for syntactic abstraction. If you need performance, use an inline function, or a compiler macro. Having said that, if you have some sort of collection and LOOP is not enough, and MAP-MY-COLLECTION isn't what you need, then a DO-MY-COLLECTION might be warranted. Still, i'd write it in terms of a MAP-MY-COLLECTION with a return type of NIL, 'cause we ain't afraid of no LAMBDAs, and probably never use the macro, because there is no need for it. 
Incidentally, I saw that exchange, and that's where I found out about the book.
(Good one. I also learned some programming with a line printer. Then VAX assembly was nice.) I had a similar reaction when I first looked at the Smalltalk 80 source using the Smalltalk browser. Smalltalk had this totally cool reputation and I read quite a bit of it. But when I looked at the sources, never was anything done. All it did was sending messages around. Each implementation of some message was just sending more messages to the object itself or other objects or even new objects. No work done, it was all talking and chatting. I was really puzzled.
"No work done, it was all talking and chatting." Truly Smalltalk is the reddit of programming languages.
&gt;'cause we ain't afraid of no LAMBDAs We are. Our search space consists of billions of possible solutions; closures are too expensive to use in our inner loops.
1. ITA. 2. SBCL. 3. I probably shouldn't say. More senior people than I have already said publicly that we use SBCL, and that we use macros; I don't feel free to say anything more. [An old message from our founder](http://www.paulgraham.com/carl.html) [A somewhat newer message from Dan Weinreb](http://www.lispforum.com/viewtopic.php?f=2&amp;t=140&amp;start=30#p1494)
I was expecting him to discuss some lisp-related epiphany. I guess he didn't have one.
&gt; for some reason the author uses the term "temporary extent" He uses the term "indefinite extent" for that [does so even in the name of the function, there]; "temporary extent" describes what it is not. If you're skimming in the sense that you're jumping from code example to code example, expecting insight there (I've seen people go straight to the code examples in their own file, and then express disappointment), maybe that you do this offers defense for someone who comes away from the book with bizarre ideas about it. I've read the code in PCL a few times more than I have the text (the `loop` chapter: many times more), but I only glanced at `block-scanner`: it's just an illustration. &gt; If you did find such parts Try not skimming one of the chapters :-) But here's something that I was just going back to: suppose that you wanted a macro that would turn a tail-recursive function into an iterative one that wouldn't rely on the implementation having TCO. Probably you haven't wanted to write this exact macro, but you've wanted to do things for which the objection would be the same: no, that would require a code-walker. You have to find all the places where the function tail-calls, and only those places, and replace them. So you can think about all the ways that this would be fragile and bad and hard, and do something else. Or you can write a macro that spits out a `macrolet`. It turns out that a problem that seemed to require a code-walker is actually very easy. *I* think this is interesting.
&gt; He uses the term "indefinite extent" for that [does so even in the name of the function, there]; "temporary extent" describes what it is not. My parenthetical remark followed my use of the term "dynamic extent", and it served as an attempt to contrast that term with the author's term for the same concept. &gt; If you're skimming in the sense that you're jumping from code example to code example [...] No, I was skimming both text and code, and I wasn't expecting insight, I was looking to decide whether the book was worth my while. &gt; block-scanner: it's just an illustration. Yes, it is supposed to be an illustration of the use of closures, but that doesn't change the fact that it is defective with regards to the problem the author claims it solves. The author also claimed that it was a "realistic example". I hope that this wasn't the humour the author was hinting at in the introduction chapter, as that would be one sad joke. Your mention of a tail-recursion macro reminds me of Kaz Kylheku's ARGTAGS, which may also be interesting to you.
More middle aged computer scientists waxing about the bad old days...*yawn*
Thank you.
Who said anything about closures? Not all anonymous functions have to capture their environment, and if your complier can't optimize/inline a thunk, no macro in the world is going to do you any good :) EDIT: I suppose i should have added that if your product is QPX, you _have_ to break these rules. That said, unless your program is something like QPX, i'd prefer readable and idiomatic lisp over just about anything. The QPX code scared me :) 
Actually, i think he did. You can't stick your tongue that far in your cheek without knowing what you're talking about.
Dman kids with their guis and Ghzs! I our day, we only had 1 kilobyte and we had to write our programs directly in binary, and we liked it! And 100 of us had to share the same seat for the terminal. And the computer center was uphill.. BOTH WAYS. And the road was always snowed to the gills... But you know us, we're not ones to complain about that. The newer generations however... BAH...
Not sure if you're aware, but Joe is an expert Lisp &amp; Scheme hacker.
I like Visual Studio because it auto completes my function calls and keywords.
Yes, it's QPX. Inlining helps, but it tends to be fragile in the long run, since compilers change over time. (QPX is over ten years old now, and we're on our third compiler that I know of.)
But can it create a GUI interface in Visual Basic to track an IP address?
[clojure-lambda-transformer](http://github.com/ayrnieu/disclojure/blob/9da2713c7b76550a942b4b387651a3fc0f4b477f/syntax.lisp#L54). &gt; There is curly but I am not a big fan of reader macros. This is just NIH. 1. Curly lets you toggle the syntax. 2. It's a simple syntax, not reader wizardry. It might take you a whole minute to change it to expand the syntax to a normal macro that does the same thing -- leaving you the macro to use exclusively. I wanted to end with "anyway, it's cute", but then I saw this: &gt; (mapcar (flip #'/) '(1 1 1) (1 2 3)) =&gt; '(1/2 1 3/2) This path leads to madness.
I use curry, rcurry and compose from [arnesi](http://common-lisp.net/project/bese/docs/arnesi/html/Higher_0020order_0020functions.html) 
* How do you figure out how many arguments the resulting lambda takes? Is it hard-coded to add exactly one arg implicitly? * How are you going to nest those things when they all use the same argument symbol in subforms? * Just for completeness, have you seen the c.l.l thread on [How to simulate currying](http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/77eeec8cec8b2529/a57a6a0fdd8c139c)?
This looks cool, but it's for windows only. If ABLE (from http://phil.nullable.eu) would support Scheme, it would be perfect, really. This looks good for windows-only hacking though...
note that the PDF for the paper is available from that page. Multilisp is a parallel Scheme and introduced 'futures' as a programming language construct.
Please, if you read it, add a little summary/what you learned from it in comment?
I've always wondered why a schemer could possibly want any IDE that is not DrScheme.. i mean, that thing is perfect. I could maybe understand wanting SLIME .. i love slime.. but this over DrScheme? why?
Simply because I don't use PLT Scheme for my work, but STKlos, Scheme48 &amp; Gambit-C. DrScheme is great, don't get me wrong, but it's just not what I use. 
Makes sense to me :).
NESL might also be interesting, because it implements a parallel language that is based on ML in Common Lisp.
I used to hack code on a connection machine -- I did preliminary development on my Mac with Coral Lisp + Start Lisp emulator -- fun stuff.
Nice! I did not know that there is a NESL implementation in CL. I was always wondering why Lisps (including Schemes) are not used more often for language prototyping, you get a runtime with quite some features for free. Or Prolog, for that matter. Besides NESL, there's [Yale Haskell](http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/code/syntax/haskell/0.html) implemented on top of Lisp and more recently [Qi](http://code.google.com/p/qilang/), Perl and Python (but the latter two were done after the fact). The first [Erlang](http://www.erlang.org/) versions were prototyped with Prolog.
Every _ marks a new argument. You can't nest them ATM (I suppose it would be possible to not process any enclosed ops).
... madness or poor QA. :) The first list should have been '(2 2 2). I fixed the error, thanks. @curly: the problem is curly doesn't export the helper functions that do most of the work and since it is such simple functionality I really don't see the point in trying to reuse it. Besides curly doesn't do any optimisations like invariant lifting
There are lots of languages implemented in Lisp, but less so in recent years. Even most of the implementations that are surviving are relatively old. Maxima for example implements a language for symbolic algebra. It is one of the oldest Lisp programs around. It also uses a Fortran-to-CL converter. But there are some newer examples and you mentioned Qi (which is not that new), Perl and Python. The last two are relatively recent. Then there are a some 'exotic' ones. Take PWGL for example - that's a (great) Lisp app for music composition and sound synthesis. It implements a graphical programming language - one where you 'draw' your programs with a graphical user interface.
How can I setup slime to connect to already running clojure instead of running a new instance of it ?
Guy L. Steele when he was working with Thinking Machines. Daniel Hillis was the founder and he had the idea for the Connection Machine. The Connection Machine was a computer with up to 2^16 processors. As a SIMD computer (serial instruction, multiple data), the CM works in parallel controlled from a host computer (for example a VAX or Symbolics Lisp Machine). Notable is the CM also for its flexible communication network between the processors. Usually the Connection Machine was program in *Lisp or *C. Connection Machine Lisp was a slightly different approach. Some Common Lisp users will notice the 'xappings' that are mentioned in CLtL2 (Common Lisp the Language, 2nd Edition) to give a longer example for the FORMAT instruction in Common Lisp.
It's probably a nice article, but today I just found ClojureBox exists :p http://clojure.bighugh.com/
It seems unusual that they choose to advertise the machine with such a heavily hardware based advert.
There is a separate document describing the [software](http://www.bitsavers.org/pdf/symbolics/LM-2/Symbolics_Software_1981.pdf).
I love the Commodore 64 form factor.
ha ;-) with a slight difference: the CPU is not displayed. You see only the console. The CPU is a 20 amps / 1700 kwh monster. Note also that the price tag had six digits. dollar digits. not cent digits.
I'm only a casual Schemer, and use DrScheme and sometimes VIM. Are there any better alternatives that the pros use?
I have ten digits, but only one figure.
Look at the power requiredments on the last page... If you configured it with the 80MB hard drive, you're using 41.5 amps! That's pretty close to 5000 watts... At the US's current average rate of $0.11 per kilowatt hour, this machine would cost $.50/hour to run... 
Cool, I like the explanation of a "window system".
http://www.franz.com/success/customer_apps/animation_graphics/naughtydog.lhtml
Not only is that game programming in lisp, it's game programming in lisp _on the ps2_, which was one of the first consumer machines to offer serious simd, which you need to take full advantage of since the mimd core is only 200mhz.
Well, GOAL is sort of like Lisp, but much more low level. It was made using Common Lisp, I still think it's a stretch to say they were running Lisp on the PS2. 
They were running _a_ lisp on the ps2. Just because it's not common lisp doesn't mean it's not a lisp.
http://www.reddit.com/r/programming/comments/69qny/naughty_dogs_used_scheme_to_create_their_latest/
Not really, they wrote an assembler in Common Lisp. From what I understood, there was no lisp at runtime, it "just" created position independent code to be streamed in and was very good to compose game object behaviours. There is some GOAL-code floating around on the net, and it's very low level and static and just inherits lisp syntax. But it's really cool and good application of how to use lisp (writing a compiler and a language =) Scheme (PLT) was used as a content compiler and C/C++ generator on Uncharted.
GOAL code includes inline assembler. How does that make it not a Lisp? Several Lisp implementations support inline assembler - usually called LAP, for example in Macintosh Common Lisp. Is MCL no Lisp because it supports inline assembler? My Lisp Machine has everything written in Lisp. Including the system-level code for keyboard, network, disk, graphics, interrupt handling, the process scheduler, garbage collection and more. Lots of that may not look like code you have seen - for example the network package objects are 'wired' to memory, parts of the memory is not GCed (but with 'manual' memory management), etc. But it is still Lisp. It talks directly with expansion boards, SCSI chips, ethernet interfaces, etc. Just because it is a system-level language and can access hardware directly does not mean it is no Lisp.
If I write an compiler in lisp that compiles a language with s expression syntax to machine code, is that language a lisp? I'm not saying this is the way GOAL worked, just the way I understood it.
s-expressions are not enough, not even necessary. There are Lisp dialects without s-expression syntax. But GOAL is a Lisp. It even has it in its name: Game oriented assembly Lisp. It is derived from Scheme.
Well then I stand corrected =)
I believe [this](http://lisp-qix.blogspot.com/2009/03/i-took-some-time-last-night-and-got-my.html) is what the submitter meant to have as a link. The article on generalised state machines is no longer the latest post on that blog. Just leads to confusion.
Click on [Topics for the conference](http://ilc2009.scheming.org/forum/1)
That's the first time I've ever seen that done. It's a good idea.
Why is the code so complicated? Just put a '(' in front and a ')' on the back, 'identity variable' can be used to get what variables mean. I guess i have never messed with the (REPL) reader, though.
...for rather large values of "not much".
lol, pjb ftw!
It is because he is explaning underlying theory ([lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus)). Something that is nice to know but not nessesary in order to program lisp. I was planning to learn [typed lambda calculus](http://en.wikipedia.org/wiki/Typed_lambda_calculus). I wonder whether common lisp has something to learn from it. I have a project, [lang-lisp](http://lang-lisp.berlios.de), with the underlying idea that lisps type system is not advanced enough. I am unsure whether the type system is similar to the theory of typed lambda calculus though. I also seem to be a little stuck at developping lately. (But not that badly.)
Basically, it's about knowing how bindings in Common Lisp work. It's a lisp-2, so #'x is not the same as x. Secondly, bindings can overwrite each other - the last assignment is current: so the second z is the return value. I haven't seen these two functions in any tutorials, does anyone know where it's from?
The key here is that in Common Lisp function names are bound in a different namespace from variables, and as calp says bindings within the same namespace can overwrite each other. The examples from the OPs tutorial are demonstrating that in a needlessly confusing way (assuming that the context in which they appear don't make this distinction clear.) 
I'm looking forward to try this language if it comes to fruition.
First of all: if there are no S-exp, lists or lambda-style prefix notation, it is not a lisp (it doesn't matter if it's garbage collected and dynamically typed). This is basically a new scripting language, with no new features. It's not like he goes out of his way to even solve current problems: there seems to be no facility for concurrency or verification. I'm sure it's nice for him, but it is minimally interesting for anyone else.
Dave says (btw. Dave Moon worked on the first Lisp Machines at MIT, later was CTO at Symbolics and then worked at Apple on the Dylan language): I say it is a dialect of Lisp because it uses a fully dynamic memory model, fully dynamic typing, a resident program semantics (although separate compilation is possible), fully powerful macros (but hygienic!), and because (almost) everything about the language is defined in the language itself. It has the same extreme flexibility and extensibility, and the same minimum of nonsense that gets in your way, that have always been hallmarks of Lisp. It has the important things about Lisp while jettisoning the things that in my opinion were mistakes from the beginning. Obviously this language owes a lot to Scheme, Dylan, Common Lisp, Python, Java, and a few others. There is a remarkable amount of convergence with Ruby, considering that I hadn't seen Ruby when I first did this. But as compared with Ruby, PLOT has macros, has my preferred non-class-centric model of methods, and is designed to be compiled.
I know he said that, I did read that far. EDIT: In fact, it was exactly that paragraph I was commenting on.
&gt; I'm sure it's nice for him, but it is minimally interesting for anyone else. I beg to differ. If nothing else, it contains valuable lessons in language design. You may find one or the other lesson in other languages, but combining them all into a single usable language requires extra care. FWIW, this is obviously work in progress, but I am more excited about Dave's design document that I ever was about Arc.
I was at the talk, and someone asked if it would be released. Moon said "The implementation's so bad, it doesn't even suck. Someone 30 years younger would have to finish it."
The interesting part to Moon was making real macros work in a language with non-sexp syntax. I also found it interesting, YMMV.
See also Dylan's [Dexprs](http://people.csail.mit.edu/jrb/Projects/dexprs.pdf). However, it seems they were a little more limited than what Moon proposed in PLOT.
Did he talk about what it's implemented on? By "finish it", did he mean the language, or the implementation?
how about comparing it to existing CL for JVM implementation, ABCL? i really hate when people start doing something without learning what was done before
The project goes on for several years now. The idea is that this is an educational project running over several years with many different students. The implementation of CL on top of 'Java' is broken up into many smaller projects that are implemented in some student course. The goal is to produce an ANSI CL implementation over the years - but the main goal is to educate students implementing parts of a programming language using Java and Lisp. Here is a presentation from the ILC2005 that gives some more technical background: http://clforjava.org/Documents/ILC%202005%20CLforJava%202%20col.pdf I find that pretty cool.
I don't think he talked about what it's implemented on. I got the impression that he is mostly done with the language design, with minor possible changes in the futue. I took "finish it" to mean improviing the implementation to be not embarrassingly bad. I also got the impression that he has little interest in further work, now that he's worked through all the macro issues.
&gt; The idea is that this is an educational project running over several years with many different students. i understand that education is good and everything, but usually these kind of efforts produce half-assed solutions. &gt; but the main goal is to educate students why not to educate them to learn about existing implementation and compare to it? i think that learning about existing solutions is very important both in science and in industry. thanks for posting it; but i remember similar project, CL for .net ended with nothing -- as soon as work on grants from Microsoft ended authors have completely forgot about it -- hence my skepticism with this "academic" work
&gt; "Macros allow me to create a new language inside of Lisp. This is *so* useful for writing "Domain Specific Languages." The reply here was to go the whole way and write a compiler for the new language. Fantastic argumentation! Cars considered dangerous because they can run over children. How do you get to your home in the middle of nowhere? Go the whole way and walk. No. Macros have their uses. And the fact this guy can't find use for them in a language as shamefully powerless and verbose as Java somewhat discredits him from this discussion because he (and maybe Steele?) seems to have caught the Java disease of making a language simple and unadvanced enough so that idiots can code (which will only yield idiotic code in idiotic projects most of which fail - pretty much the world of enterprise software development today). In fact, Steele intrigues me. How can one of the guys who worked on Common Lisp be working on Java now and feel any gratification? That's like majoring on something then going straight back to kindergarten. If them enterprise motherfuckers want to have that kind of party, I'm going to put my dick in the mashed potatoes.
Dynamite is considered harmful too, but how am I gonna move that mountain fast without it? Macros are useful because you don't have to rewrite the lexing and parsing part of a compiler and can concentrate on the code generation stage. Is it difficult? Yes. But that doesn't mean that it is a bad idea to have them. It should be easier to read and reason about them though. And that is maybe not a problem of macros as such but whether macros fit into the whole system. That challenge needs to be taken on. AFAIK the scheme standard has not standardized macros for a long time because of the hygiene issues, but I haven't studied the details. Have I been trolled here?
The author probably writes most of his Java in frameworks, way *way* above the metal. I write a fair amount of Java that ends up being invoked from the command line and does basic file I/O. I long for macros in Java every time I write: BufferedInputStream bis = null; try { bis = new BufferedInputStream(new FileInputStream(pfile)); // Do stuff with file } finally { if(bis != null) bis.close(); } instead of: (with-open-file (s pfile) ;; do stuff with file ) 
Agreed. Macros are essentially language design level abstractions. Languages like Common Lisp that gives the most unrestricted macros, give huge amount of power to the program writer. It is unreasonable to assume that using macros is as safe to use as writing normal libraries. Macros expand the language towards the problem. Programmers without access to macros build frameworks to do the things that macros are useful for. Resulting framework design is also more complicated than straight forward programming.
&gt;Fantastic argumentation! The debate was more involved than that. In particular, the person who said "just build a compiler" was making the point that, if you want to build a DSL, and do it *right*, then you're going to do most of the work work of making a language from scratch. There's some truth to that, but the argument wasn't strong enough to convince anybody. &gt;How can one of the guys who worked on Common Lisp be working on Java now He's not. Remember, Guy Steele didn't create Java; James Gosling did, and then asked Steele to help with the specification. Today, GLS is working on Fortress, which takes a much more Lispy [grow-a-language](http://www.brics.dk/~hosc/local/HOSC-12-3-pp221-236.pdf) approach.
Well, you could do it with Clojure, Sisc or any other lispy language implemented on JVM. 
&gt; How can one of the guys who worked on Common Lisp be working on Java now and feel any gratification? In addition to metageek's response, I'll point out that Steele's claim about Java was, "We were not out to win over the Lisp programmers; we were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp. Aren't you happy?"
I'm surprised that the author has used Lisp but never wanted a macro in Java. Every time I write code like (pseudocode): file = Open(fileName) try { // work with file } finally { Close(file) } I wish I could use macros. (This particular pain can also be addressed with higher order functions, but you need at least function pointers for that, and anonymous functions for it to not have its own share of pain.)
&gt; Macros are useful because you don't have to rewrite the lexing and parsing part of a compiler and can concentrate on the code generation stage. um, i think cases when you write wholy new language are rare, mostly macros help dealing with boilerplate and abstracting out some stuff. &gt; Dynamite is considered harmful too, but how am I gonna move that mountain fast without it? yep, so far i don't know a better solution. some people say that when you have higher-order functions and stuff like that (like in Haskell) you can live without macros. but i've tried some Haskell programming recently and ended up with some weird boilerplate code. i dunno, maybe my problem is too weird, or my Haskell skills are poor, but if i was programming in Lisp instead i'd hack it with macros without thinking much. so i think that macros are unparalleled as affordably and easy, yet unsafe metaprogramming tool.
You call that halfway? Oh yes because automatic memory management is about the only feature of Lisp we were missing in C++. That's not even 10% the way.
If you want a language that doesn't do macro's, why use lisp?
And suddenly, Lisp fades into history, permanently placed as a language of the past. I love lisp, but seriously. We need to stick to our Macros. Otherwise, we really *are* users of a dead idea. 
that's the author's point.
also there is Liskell, haven't tried it yet though
The slides sound like the talk was really fun. Is there a recording of it?
Macros? Harmful? You're kidding, right? You can hardly do *any* real damage with macros. I mean, other lisp coders can read macro definitions as well as code that makes heavy use of macros, and still retain their sanity. Where's the fun in that? Now [read-macros](http://www.jasondunsmore.com/lisp/onlisp/onlisp_21.html#SEC114), those things are *dangerous*. It's fun to hook into the parser at the character-stream level and define your own syntax, but anyone trying to maintain your code is in for a very *interesting* experiance. 
&gt; and today I still occasionally write some maze-related code when I need a simple project to test out new languages or techniques. I do exactly the same thing and have written very simple maze solving programs in Haskell (to play with MonadPlus and StateT), Perl (to play with Moose) and C++ (for an assignment I did at university which gave me the idea of writing maze solving programs to test). Glad there's one more person out there like me :p
Micromanagement game? I am to interpret this as a, "you are a boss of terrible irresponsible underlings. Check their status often if you want to have the appearance of any progress to report to higher-ups" kind of game?
http://www.gamasutra.com/view/feature/3094/1500_archers_on_a_288_network_.php If it's real-time at least. If it's not real-time, then you don't have to bother with fixing the turn length, and you can probably send the world state over the wire. "micromanagement" seems to be more likely to occur in the context of real-time games though. The secret here is that a real-time game is just a turn-based game with really, really fast turns. Think about how multithreading is implemented on a monoprocessor. Now extend that so that the aggregate set of computers the players are playing on acts as a monoprocessor.
IOlib has the async stuff you're looking for. I've used it with SBCL to great success.
That and eventually devising clever scripts to use the power indirectly.
It's supposed to be kind of real-time, based on tasks that take some amount of time to be completed.
Looks pretty good after a couple days of mingling with built-in stuff and much confusion. File-orientated standard streams seem to not take the incomplete nature (e.g. there may not be any more data now, but it's not EOF) of socket streams into account at all, or if they do, it's never said out loud. Addendum: Oh well, dependency hell here I came. I wish things would sometimes just work without mysterious missing symbols.
Then the linked article tells you pretty much all you need to know: separate the command input from the game process and put commands in a virtual queue, schedule commands to actually be processed some time after the command is received, tell everyone on the game the commands of everyone else *before* those commands should be processed (or else drop them rather than desynch!), and be very, very careful of gratuitous randomness - make use of a monadic random number generator, which accepts a seed and returns a tuple of random number and seed (the seed can be fine by itself, you can just modulo it into range). But if all computations are done centrally by the server, than you don't need all that; just be aware that for a large and big enough game, you can DDoS the server just by playing.
use clbuild to avoid dependency hell :)
clbuild is awesome!
That's why you should use a truck instead. Trucks don't have dependency problems.
**Guy 1:** My car's pretty nice, but it makes a lot of noise. **Guy 2:** _(sarcastically)_ That's why you should drive a truck. Trucks don't have noise problems. How does the snide remark solve the first guy's problem?
I'm assuming you are being sarcastic. If Dan had used a closed source library and ran into these problems, he wouldn't have been able to work around them. Closed source is not an answer here, by any stretch of the imagination. 
Commercial vendors provide support. Just contact them, email, telephone, surface mail, fax, whatever. Just that something is 'closed source' does not mean that problems can't be solved. In Lisp it is also often that vendors send a patch that can be loaded into a running program, if necessary.
I'm not trying to solve his problem. I'm just saying it has nothing to do with open or closed source. If he wants me to solve his problem he can pay me, then I will gladly help him. Open source and paying for help are not incompatible.
That's a very utopian view. I've been on both sides of the fence on this one, and a vendor is unlikely to be very sympathetic to the fact you are running hacked versions of some libraries or on an old Linux distribution. And I didn't say in my response that the problems cannot be solved, rather he would have been unlikely to work around them himself and would have had to wait for the vendor to get around to his problems. Close source is not a panacea.
Timely response is part of the business model of Lisp vendors. And, yes, they support even ancient Lisp on old hardware if that is what the customer has. LispWorks (the company) for example supports the old Liquid CL (aka Lucid CL) which does run on old hardware/software anyway. I should also mention that some of the vendors provide source code. So it is not 'open source', still the customer has access to the vendor's source code and the customer can possibly fix problems.
Nice, but no support for PLT.. *sigh* I hate the imcompatibilities.
ECL is slowly but steady becoming THE Common Lisp implementation. It has great performance (which still improves), native threads on all major platforms, app deliverables, unicode, ... The onty thing it is lacking is mose developers, maintainers, and need to port some random CL library here and there, but once that happen, it will take over the (lisp) world.
I had a lot of fun building a concurrent multiplayer text adventure in Clojure. Since it's designed from the ground-up with concurrency in mind and encourages immutability by default, it ends up being a lot easier to write parallel code that doesn't stomp on other threads. Of course, if you've already firmly decided on SBCL ignore this, but you should at least give it some consideration. http://github.com/technomancy/mire/tree/master
No mention to CL being a Lisp-2?
Does CL being a Lisp-2 actually create any significant problems? The biggest issue I've encountered so far is needing to occasionally type funcall.
Kent Pitman [says](http://www.nhplace.com/kent/Papers/Technical-Issues.html) it is a good thing.
No, but it is a popular complaint.
I say it is a bad thing.
it is your own problem. Common Lisp is not a Scheme, it does not do everything via functional programming, you have LOOP and stuff like that. so it is not like you constantly need to write function/funcall. on the other hand, having multiple namespaces actually helps avoiding clashes and eliminates need for funny names: if thing is a list, name variable list, not lst or something else. if you like Scheme stlye of programming more, use Scheme, huh? i don't say that it is a bad thing that Scheme is Lisp-1 -- Scheme and CL are different languages with different styles.
It compromises simplicity and beauty in favour of nothing actually, because giving different things the same name is actually detrimental to code clarity, documentation and inspection. On top of that you need additional quoting and ugly funcall. Lisp should be beautiful, not ugly and hackish, and CL sometimes looks like the Perl of Lisps. So I reverse your question: would a Lisp-1 create any significant problems that make the Lisp-2 associated caveats and uglyness worth it?
&gt; if thing is a list, name variable list, not lst or something else. This is a bad name. First of all, it clashes with an existing object. Even if the language will make an arbitrary distinction between values of certain kind and values of a different kind (don't know why making functions different and not numbers, though; I prefer to treat all my citizens equally), the clash exists within one's mind and at first sight, as well as in communication (e.g. "Mark, use list -- what list?"). But most importantly, list is a terrible name, just like "variable" is a terrible name. You shouldn't name things based on what they are, but based on their purpose or content. Just like I don't name my integers "integer" or "variable" or "value", but "price", "total" or "weight", I don't name my lists "list", but "files", "names" or "customers". Even if I used a Lisp-2, I would never allow two different of my values to be referenced by variables with the same name. Also note that you seem to imply that a Lisp-2 is more comfortable for mixed-style programming. I disagree. I've been working a lot with Python, which is like a Lisp-1, mixing functional and imperative object-oriented programming seamlessly, and naming has never been an issue, and of course, it's great when you can do simply i()().
&gt; the clash exists within one's mind and at first sight only if you're braindead schemer. in English, most of nouns are also verbs. and it makes sense, and nobody is confused. in Russian, for example, verbs are typically different from nouns, and this makes langauge more complex -- one needs more words to memorize, also it is less terse than English (remember Graham's "succinctness is power"?). &gt; But most importantly, list is a terrible name, just like "variable" is a terrible name. uh-huh, how about thinking a little? (defun member (item list) ... pick a better name. files, customers, weight? if you're writing some high-level functions, you need them to work with abstract data, not with concrete customers, files or weights. &gt; I've been working a lot with Python, which is like a Lisp-1, mixing functional and imperative object-oriented programming seamlessly Python solves this by being object-centric, you use dot for easy member access, each object is essentially a namespace, and thus there is no clashes. Lisp is function-centric, functions are not attached to object but are members of a global namespace, hence the need for multiple namespaces to avoid clashes.
Personally I find that FUNCALL makes my code clearer. Additionally I like that in function namespace there are only functions - nothing else. In a Lisp-1 calls has to somehow check if something is a function before calling it. If I call (foo 'bar), there is the chance that the value of FOO is 42 and not a function. If code runs either there must be an error generated somehow by the machinery (the CPU, the virtual CPU) or the code must first check if the value is a function and signal an error if not. In Common Lisp this is not necessary, since in (FOO 'bar) FOO will always name a function if it has a functional binding. There is no way to FLET it to 42.
&gt; It compromises simplicity and beauty in favour of nothing actually, because giving different things the same name is actually detrimental to code clarity, documentation and inspection. It is always clear what are functions and what are variables. I don't see how a few funcalls make it look worse. And if it looks 'perlish' because of it you should certainly refactor.
&gt; Personally I find that FUNCALL makes my code clearer You find (funcall f) is clearer than (f)? &gt; Additionally I like that in function namespace there are only functions - nothing else. Why make that distinction between functions and everything else, as if they weren't equal class citizens and were somehow special? Why not make a namespace for each data type then? &gt; In a Lisp-1 calls has to somehow check if something is a function before calling it. In any dynamic programming language you have to somehow check if something you want to is going to be supported by the value you're using to do it. You have to somehow check that car and cdr get conses, and you have to somehow check that something you want to apply is applicable. Even in CL, one would have to check whether what you want to call has a function value or not. It may be unbound.
A good read, I'd like to add: * Slapped on type system.(Which has part in causing optimization problems, imo) * Not modular enough; a lot of stuff should be libraries, instead of part of the language. Hell, who says that a Lisp even has to have lists after compilation? After all the macros are run, you don't need them anymore. I am working on a project to fix a lot of stuff, [Lang-lisp](http://lang-lisp.berlios.de/), it is far from ready to be used though.(And the site has to be better too) Still Common Lisp is an awesome language, and i recommend learning it.
&gt; only if you're braindead schemer. Heh, I have a strong OCD around that. &gt; in English, most of nouns are also verbs. and it makes sense, and nobody is confused. Programming, however, is not English, and it shouldn't be, even if it could. This has been discussed to death in other circles such as Perl vs. anything else. In the end Python got the upper hand despite Perl being loaded with "DWIM" magic and being supposedly more comfortable to work with (spoiler: it actually isn't). &gt; if you're writing some high-level functions, you need them to work with abstract data, not with concrete customers, files or weights. Very true, got me there. Even so, I'd rather use something like (define member? (needle haystack) [...]). It's more descriptive of the purpose of each argument. &gt; Python solves this by being object-centric, you use dot for easy member access, each object is essentially a namespace, and thus there is no clashes. Lisp is function-centric, functions are not attached to object but are members of a global namespace, hence the need for multiple namespaces to avoid clashes. Good point. However, I'll argue that if namespace clashing is a problem, having just an extra namespace for a particular data type just delays this problem from happening but doesn't solve it; it will still not scale, so either there's a name clashing problem or there isn't. On top of that, there's the philosophical issue I have with choosing functions over any other data type to make a distinction and give them a separate namespace - I hate special treatment.
It's not Lisp-2, it's Lisp-n, where n is arbitrary. Even in CL standard, without user code n&gt;5 (if I counted correctly). Symbol is just name object and it can have infinite number of different bindings. And yes, it fits to CL philosophy and programs better than Lisp-1. Lisp-1 fits to Scheme. 
You see simplicity and beauty differently than most CL users. I can see your viewpoint. Can you see ours?
&gt; Programming, however, is not English, and it shouldn't be, even if it could. nobody says it should be, but you're making argument that somehow having same name for both noun and verb is confusing, but if it is not confusing in English, probably it shouldn't be confusing for code as well. also, if you care how one keeps a piece of code in his mind and communicates it, it should be easier to do so when language is close to English, a natural language programmer is used to. &gt; Even so, I'd rather use something like (define member? (needle haystack) [...]). It's more descriptive of the purpose of each argument. i'd say it is just as descriptive about purpose of arguments, but `member (item list)` is better because it describes type of collection it expects, if it was just haystack, i'd expect it to work on generic sequences and probably would need to refer to documentation. &gt; just delays this problem from happening but doesn't solve it; it will still not scale, so either there's a name clashing problem or there isn't for practical programming it is enough, because typically functions are global and variables are lexical. you do not have occasional clashes between variables (because you see them all in a code fragment) and clashes between function names is something one have to deal with if he wants global functions (generic function aleviate this problem). so the only issue is clash between functions and variables, and it is solved in Common Lisp by having different namespaces. so from practical side it is quite nice -- when i'm programming in CL i do not worry about any clashes most of time. &gt; I have with choosing functions over any other data type to make a distinction and give them a separate namespace - I hate special treatment. i've described reasons for treatment of functions in a special way above. besides that, functions recieve some special treatment anyway -- you see, in form (f x y) f should be a function, otherwise it won't work. also, if you write (x f y), it won't work too, because only first item is special.
&gt;Why not make a namespace for each data type then? Because CL does not create new namespaces for different data types. It creates them for different ways the use of name affects the program flow. Using data as function and using it as data are different ways of using it. ;;; three namespaces in action: ;;; 1. function foo ;;; 2. variable foo ;;; 3. block name foo (defun foo (foo) (return-from foo foo) 
&gt; You find (funcall f) is clearer than (f)? Sometimes. Especially I find (funcall (funcall (f))) better to read than (((f))). &gt; Why make that distinction between functions and everything else ... True, that's why CL is a Lisp-n for some fixnum value of n. &gt; Even in CL, one would have to check whether what you want to call has a function value or not. It may be unbound. (flet ((foo () ...)) (foo)) &lt;-in the call to FOO, FOO can't be unbound. There is no way to unbind FOO or bind it to something other than a function. Also in a file: (defun foo () ...) (defun bar () (foo)) The compiler is allowed to assume that FOO is the function FOO and not unbound.
&gt;There is no "intuitive" when it comes to programming. There's only what we're used to and what we aren't. This is really good point. 
The same could be said for machine code. There is a point where intuitive *is* a feature.
Machine code isn't bad because it is structured the way it is but simply because we aren't good at remembering lots of numbers. The argument you are trying to make works actually better against C++ or Haskell (languages where you need to remember lots of stuff about operator precedences and what which special character combination does) than against Lisp where virtually all code uses named functions and precedences do not matter.
&gt; Machine code isn't bad because it is structured the way it is but simply because we aren't good at remembering lots of numbers. Like he said, it's what you're used to and aren't used to. Most people aren't used to numbers but I'm sure those who enjoy memorizing Pi could get all frothy at the mouth about inputting raw codes if there was some benefit to it.
That is not 'what you are used to', that is rote memorization, which is again entirely different from the ability to memorize number/meaning pairs in a way that allows efficient working with them (i.e. training your eyes to recognize this number as that command, write them when you think the command, basically training the part of the brain we usually call 'muscle memory' to work with them). Lisp has no parts that are hard to remember and even if you count all of them there are not many. Anyone can learn to work with Lisp easily without special talents (well, besides those required to program in any language), the syntax just looks scary at first because it is unfamiliar to people used to C, C++, Java or Pascal,... and similar language families.
It seems like you're getting bogged down in the details. So here's what I'm trying to say: If something is unintuitive then that is a barrier to learning. It is a cost. If something is intuitive, that makes it easier to learn. It's a benefit. Nothing you say can change that fact though it may help people cope with the pain of the transition. That's all...
*The only "intuitive" interface is the nipple. After that it's all learned.*
Forget about nipples and interfaces. Infix syntax is intrinsically intuitive because the operator and arguments look like a connection between physical objects. THAT is intuitive. The surface syntax of Lisp **does** suck, and denying that fact doesn't help. As for Sweet expressions: **Curly infix:** This is very good. It's similar to something I call "2-fix" syntax, where the CADR of a form is always the operator: [my-list is-empty] [[a + b] * [c + d]] [my-object -&gt; method arg1 arg2 arg3] **prefixed grouping symbols:** This may be helpful for some beginners, but makes no sense technically. Haskell and ML do just fine with s-expressions. Traditional function notation, on the other hand, is ambiguous, which is why languages like Ruby have white-space rules for calling functions. **indentation:** No comment. Haskell indentation is nice, but I'm not sure it needs to be part of this discussion.
But the standard algebraic operators doesn't *connect* any objects. They are functions of 2 or more arguments. The expression "2 + 3" doesn't connect 2 with 3 in any way. "+" is a function that takes 2 (in lisp more) arguments and return a result. It doesn't establish any connection between the arguments. 
&gt; But the standard algebraic operators doesn't connect any objects. That doesn't matter. The operator obviously does something with its arguments, and the object-connector-object model\* helps the viewer tell which part of the expression is which. &gt; They are functions of 2 or more arguments. Infix operators take exactly two arguments. &gt; The expression "2 + 3" doesn't connect 2 with 3 in any way. You're intellectualizing too much. Remember, we're talking about intuition, not logic. The plus sign connects the two numbers into a larger expresion. &gt; "+" is a function that takes 2 (in lisp more) arguments and return a result. It doesn't matter what the plus sign does. The point is that placing it between its arguments creates an intuitive picture of the overall expression. &gt; It doesn't establish any connection between the arguments. The plus sign establishes a connection between the expressions on either side of it, namely that they're going to be added together. --- \* BTW, the word-hyphen-word pattern in English and other languages is another classic example of the connector model.
Your argument for infix notation was that it creates a connection between the arguments. I see that you edited your comment after I answered it. That will make this discussion very confusing and forces me to save your old posts before answering. Now the only argument you have left is that infix notation is "more intuitive". That only means that you are more used to it, thus it doesn't carry much weight. It will only take you a couple of hours working with another notation to get used to it, and make it feel more intuitive. In the end, logic and practicality carries more weight than your habits and prejudices. 
The special syntax of lisp, or lack of syntax, makes it actually easier to pick up than any other language. So, you have to overcome the hurdle of writing "(+ 2 3)" instead of "2 + 3;", but then there is much less syntax to remember. 
&gt; Your argument for infix notation was that it creates a connection between the arguments. Notation doesn't create anything. It's only a visual cue that indicates syntactic structure. &gt; I see that you edited your comment after I answered it. I didn't see your answer. I was just trying to make my post better. &gt; That will make this discussion very confusing I'm done now. &gt; Now the only argument you have left is that infix notation is "more intuitive". That only means that you are more used to it, thus it doesn't carry much weight. My argument is that the geometric object-connection model is so pervasive to human life, in fact to almost all animal life in general, that it's instinctively intuitive to every human being on the planet, including infants. I'd say that carries more weight than just about any other argument. Who knows, maybe it's even built into the genetic structure of our brains. The only entity that's not naturally and intimately aware of physical space and physical objects is the computer itself. That's the real reason prefix notation dominates Lisp syntax. Lispers don't worry much about parsing code, because most of that is done by the compiler, thanks to Lisp's macro system. &gt; It will only take you a couple of hours working with another notation to get used to it First of all, that doesn't mean it's better. And second, I still prefer infix syntax for some things after using Lisp for three years. &gt; In the end, logic and practicality carries more weight than your habits and prejudices. Logic and practically are two separate things. The main habits and prejudices I see are the slavish dedication of some Lispers to prefix syntax. 
&gt; If something is unintuitive then that is a barrier to learning. It is a cost. If something is intuitive, that makes it easier to learn. It's a benefit. First of all, there is no such thing as intuitive, just things more or less similar to things we already know. And you aren't seriously suggesting that Java's or C++'s syntax is easier to pick up than Lisp's? If you are then you haven't tried at least one of those.
As I've [previously wondered](http://www.reddit.com/r/programming/comments/840n0/lisp_after_python_after_lisp/c087frp): Maybe some people who learn lisp "later" have a problem with the parens _because_ of what they have learned - that a bunch of parens (in a C-like language) means "here comes horrible complex expression that also overrides normal language precedence rules", so they have a subconscious dread of them, that "bleeds" across. In lisp, it _doesn't_ mean that. They're just delimiters of lists. That's it. {define {factorial n} {if {&lt;= n 1} 1 {* n {factorial {- n 1}}}}} If you find that easier to read, it may be your brain has decided to dislike () in particular... (yes, I know {} is also in use in C, but in a manner slightly closer to the use of () in lisp). or could try some asian quotation marks that most reddit readers probably don't see much at all: define factorial n if &lt;= n 1 1 * n factorial - n 1 
You are not the only one. See: http://groups.google.com/group/comp.lang.lisp/msg/6f52a3ddc61d6028 &gt;In the Algol family, parentehses signal pain. In the Lisp family, they signal comfort. Since most people are highly emotional believers, even programmers, it is very hard for them to relinquish their beliefs in their associations of parentheses with pain and suffering. This has nothing to do with aesthetics, design rationales, ease of use, the value of the code-as-data paradigm, etc. This has everything to do with the deeply ingrained "knowledge" that you do not need parentheses unless you want to transcend the (overly simple) rules of the language. The psychology of programming has taught programmers in the Algol family that parentheses are to be minimized and that any large number of parentheses is a good sign that the code, or worse, the thinking behind it, is too complex. Lisp programmers use only one or two most inner parens to signal preference. All the rest is handled with indention just like with Python. The problem with Lisp is that you have to learn how to read the code. People who don't realize this and can't figure it out by themselves, will suffer from pain. 
***NOPE.*** when you spell a math expression, you say "add two and three". or "a product of a sum of a and b and a sum of c and d". (at least that's how i was taught, i dunno, maybe they you say it like "opening parenthesis a plus b closing ...") so, the prefix way is the way people pronounce expressions. but programming is not only math expressions, it is also about commands and predicates. "send this there". "check if x equals to 0". in English prefix form is natural. thus, prefix form is natural BOTH for commands and for expressions, so it is totally intuitive -- i mean it is pretty close to natural language which is aquired in childhood. &gt; Curly infix is a weird hack. ok, it works in your examples. but there are lots of cases where it does not: [message send destination-address source-address] like, i have a function of three arguments, none of them is special, what should i do? why first second argument is special? it works for your -&gt; thing but it is good only for object oriented language with simple calls. what's about CLOS which has multimethods which can be specialized by any parameter? what's about [a + b + c] ??? you're stupid troll
&gt; Lisp programmers use only one or two most &gt; inner parens to signal preference. You probably meant precedence - but strictly that's still a bad (misleading) way to think of it: Parens delimit lists in lisp external textual format syntax. Again, that's pretty much it (well, modulo complications in some lisps once you move on to consider textual syntaxes for other composite object literals). Text in that syntax is READ in, and the lisp READer constructs an in-core lisp list structure out of conses, with symbols and other lisp data objects embedded in it. That "live lisp object" list structure is then EVALuated (glossing over a bunch of stuff like macroexpansion and compilation). A once-commonplace (well, not all that commonplace) thing to do to implement DSLs was to reuse the standard lisp READ, but a different EVAL, though macros reduce the incentive to bother in the first place a lot of the time, since you can just have a macro implement your intended DSL as a translator at macroexpansion time (lisp macros working on the aforementioned "live" list structure) - macros are therefore a bit like being able to rework EVAL piecemeal rather than in a big-bang fashion. &gt; All the rest is handled with indention just &gt; like with Python. certainly, indentation is used by most lispers to speed understanding. But indentation is _not_ part of the standard syntax. &gt; The problem with Lisp is that you have to &gt; learn how to read the code. People who don't &gt; realize this and can't figure it out by &gt; themselves, will suffer from pain. Well, that's pretty much true of any language, but yes, it's important to bear in mind in the lisp case.
&gt; But indentation is not part of the standard syntax. Do you think it should be? I think it should not. I think the most important part of Lisp is that you can add semantics without adding new machine readable low level syntax. I think there is something fundamentally right in current way of doing things. Making program readable is something that editor and programmer care about. Editor does most of it by using indentation rules. 
&gt; Do you think it should be? Not particularly, no, on the whole I prefer the parens - However, indentation-sensitive syntax certainly doesn't mean you can't add semantics without adding new low level syntax in the manner you mean - straightforward indentation-instead-of-parens alternative readers for lisps have Been Done, the most famous being the scheme [SRFI-49](http://srfi.schemers.org/srfi-49/srfi-49.html) The most popular current indentation-sensitive languages, I guess python and haskell, have a bunch of complicated syntax beyond indentation sensitivity, you see, that *just* indentation-sensitivity could still avoid. 
Nope. Nipples are learned too.
That's quite cool.
What is he using to color and rubber-band highlight the code?
&gt; First of all, there is no such thing as intuitive, just things more or less similar to things we already know. I fail to see the distinction. Isn't something intuitive something that is more or less similar to things we already know? &gt; And you aren't seriously suggesting that Java's or C++'s syntax is easier to pick up than Lisp's? I'm saying if you're used to java or c syntax then they're going to be easier to pick up than lisp. 
The distinction is that there is no objectively intuitive thing, it all depends on previous experiences. &gt; I'm saying if you're used to java or c syntax then they're going to be easier to pick up than lisp. Of course something you already know is easier to pick up than something you do not yet know, that is a tautology. The question is which is easier to pick up for someone who knows neither.
Well I think this thread has sufficiently dissolved into silliness. Shall we adjourn?
I never understood the draw to live programming generated music. I've seen it done now in python, perl, and lisp. The results are mostly atonal noise and bizarre visualizations that make me about as uncomfortable as a salvia trip. While technically cool, the code usually looks inelegant, and the end product is awful. There seems to be a cult following of this scene, can anybody explain to me what redeeming qualities it has?
Can't the same be said about most unconventional forms of art?
Edi mentioned that he especially liked talks by Jerry Sussman and [Shriram Krishnamurthi](http://weitz.zenfolio.com/ilc2009/h26faa540#h26faa540).
I saw Edi snapping away with his Leica (I think), I'm glad these made it online. 
Misleading title, DrScheme has a REPL.
Any groups in Raleigh, NC, USA?
Good stuff: they actually do releases. New is the support for Micro$oft Windows in 32bit and 64bit. Clozure CL compiles by default to native code and its compiler works very fast. It supports concurrent execution on multiple cores. The precise ephemeral GC also is excellent - though not concurrent. Some users are providing financial support for improving the development environment on the Mac - thought there is still a lot to do to match MCL (from which the core of CCL was forked years ago).
Have they ported the IDE to Windows yet? 
Can anyone give an informed comparison to sbcl ? I'm on sbcl right now, but would really like to use it on windows. 
No.
There is some Clozure CL blurb: [Clozure CL](http://www.clozure.com/clozurecl.html). Since CCL is very new on Windows, I would expect some rough edges and little support for Windows technology. * SBCL's compiler is slower, generates larger code. * SBCL's compiler generates faster code, gives optimization hints, does some amount of type inference. I'd say that SBCL code is in many cases faster and needs less effort to tune. * SBCL's base saved executable image and its fasl files are much larger than CCLs. It might be interesting to find out what the state of threading and GC is of SBCL under Windows. 
It makes it necessary that every file corresponds to a package? It uses the used packages to encode the dependencies? I don't like that. Why not just have a new DEFINE-DEPENDENCY form that describes what this file requires. This can be parsed and the information can be used for building/loading/compiling/whatever. 
It does support another way of specifying dependencies, so one is not bound by the defpackage use list. Either way, I think that having one package per file is not necessarily a bad thing. I suppose it's largely a matter of taste and coding style.
&gt; I think that having one package per file is not necessarily a bad thing. I doubt it will be an effective way of structuring. You'd probably have to USE many of these "file" packages. In addition, since CL does not provide good means to reexport complete packages, you could just as well put them all in one big package from the start. In my opinion, one of the (perhaps few) really nice things of the CL package system is that it keeps packages and files separate. It allows me to organize code much better than I can with other namespace systems. For what it's worth, [XCVB](http://common-lisp.net/project/xcvb/) goes with the suggestion of lispm above: it introduces a new form describing the dependencies. And this comes from people who have experience in building big systems in CL.
Another way is to use CL:REQUIRE forms and read those.
I should probably have added that faslpath *doesn't* require one package per file. You are free to have several files belong to the same namespace.
Interesting article. Message Signaled Interrupts: Ur Doing Them Wrong.
It's not stated on the page, but if you download the tar it has a bochsrc.txt all there. I'm just about to try it out. Edit: it lives! http://i58.photobucket.com/albums/g269/bob-appleyard/dream.png Sweet!
It's time to port Emacs to it
[Phil Greenspun](http://philip.greenspun.com/careers/acm-women-in-computing) has a partial explanation, I think.
Being several days at a conference with extreme nerds is probably not high in their list of interesting things to do.
Using Lisp and attending Lisp conferences will not grant them social status, allow them to talk to big shot guys with expensive cars and lots of money and power, and nobody will compliment their shoes. On top of that, nobody wants to hear about Mary's new boyfriend, or her neighbour's cousin's mother's dress. Lisp is hard, let's go shopping! That said, there are a few (too few, unfortunately) smart women who know something other than ch(sh)it-chat and clothes, some of them being even geeks (which is awesome - they are the best women for many reasons), but, like TFA, I wonder why aren't they going to Lisp conferences. I doubt only 1 in 200 women are geeky.
Assholes like you assuming they can just label most women as 'ditsy marriage machines' are probably the reason. Who the fuck would go to a conference where everyone else alternates between staring at your tits, trying stupid ass pick up lines and other mating strategies of the barely pubescent, and being all butthurt when you show you actually know something they don't? And fuck, you don't have to be a geek or have the social habits of a male lisptard to be proficient in these fields. I think the gender ratios at most mathematics/CS symposia are a lot better. It's probably just all you lisp monkeys being snobbish
I once went to a lisp conference and noticed women -- serving us lunch. The almost nonexistent female/male ratio was pretty striking. It's usually the Lispworks salesperson, and a member of a married couple who IIRC both use Lisp. Though in the last conference in Amsterdam, there were somewhat more females, IIRC.
dude... you're lucky you were able to find 200 lisp nerds in one place. Who fscking cares what sex they are. When you play in the shallow ends of the bell curve, weird numbers don't mean anything.
Women know better than to use lisp? /troll
um, hello? conferences like this are attended by people who are very enthusiastic about the matter, especially as Lisp itself is used mostly by people who are enthusiastic about it. it is highly more likely for a male to be a technical enthusiast than female, it is like toys for boys. same thing about war games -- i see absolutely no females playing 4X space strategies. is it unhealthy that girls do not like games like this?
I counted 10 women there. Still, 1 in 20 isn't much better.
There's no reason women can't be "extreme nerds" too. Spending several days at a conference full of people who love Lisp sounds great to me. Spending several days at a conference full of people who will think I'm there for different reasons than they are, and likely being looked down upon by a number of them, not so much. Yes, I am a woman.
Sometimes the vendors have women as sales persons on the conferences. The other women were mostly software developers. I haven't yet met women that were at Lisp conferences/meetings for other reasons. What is even worse than the relatively low number of women attending conferences is that very very few are presenting and giving a talk. Lisp is out of fashion and not in the mainstream. The academic attraction is not that great (that's more on the side of Functional Programming and related) - though this has improved a bit in the last few years - and the industrial attraction is also not that great - compared to say larger development companies developing mainly with Java/J2EE/whatever. I would think that the relatively few women working in software development don't want to work in an 'obscure' niche. Are you a Lisp developer? 
It seems that while many mental bell curves of men and women might have have same location parameter () they have different variance (^2). Women seem to be more homogeneous group than men. I assume that even if nerd distribution between men and women would have same location, the chances to get women into uber-nerd conference like Lisp conference is close to nil.
&gt; I would think that the relatively few women working in software development don't want to work in an 'obscure' niche. Hah, if that's true, I'm an exception. I like finding obscure niches and relatively unexplored ground, no matter what I'm doing. I'm not a professional software developer, at least not currently. Maybe I will be someday; I'm kind of between things and unsure of where I want to go, right now. I do have some interest in game development, so I might end up as an indie game developer; I'd like to work on all parts of a game, not just programming. Mostly, I use Lisp for whatever crosses my mind that seems like fun. I'm currently putting together a basic system for writing Actionscript with sexprs and macros; it's still at the exploratory stages, but it seems to be working out well so far, and I'm learning a lot. Maybe I'll be writing Flash games with Lisp before too much longer.
Lisp may be somewhat obscure, but it doesn't require remarkable intelligence to use. (At least, I don't think it does; I'm not always very good at judging these things.) Secondly, I think that much of the "women are more homogeneous" thing arises from cultural constructs rather than innate tendencies. Studies have shown that reminding women of their gender before an intelligence test tends to lower their score. I even recall one study where a group of women were told that a particular math test had shown no difference between women and men - in actuality, it had been administered to groups of each gender, and the men had scored higher... but this group of women, unaware of the previous women's scores, did as well as the men. So, while differences certainly have been observed, and while the "homogeneity" effect may serve to lower both the variance in women's IQ and the likelihood of women being involved in obscure "geeky" subjects, I think it would be a mistake to assume that the current state of things is natural and innate. A few Lispers aren't going to be able to change the whole culture that keeps women away, but each of us can have some effect, however small.
&gt;I think it would be a mistake to assume that those differences are natural and innate. What you say is generally accepted as truth, but I don't buy it (I have many nerd friends who are women and had girlfriend who was extremely intelligent and successful in hard sciences, so I know how good they can be). The way men relate to things is different from women (in general). Even if you are skeptical, I think we can agree that testosterone level is one undeniable difference between men and women and it creates natural and innate differences in behavior, interests, and motivation. I live in Scandinavia (Finland) where equality of women has gone really long way compared to many other countries. I have observed that women speak in lower voice and how they move and act more self assuredly compared to women in U.S. for example. I admit that there is clearly some deep cultural constructs that affect gender behavior, but I think biology is also involved. 
And the thing was *heavy*. CPU+300MB hard drive was just shy of 1/3 of a metric ton. 
I recognize only a few folks (Costanza, Herth, Lieberman, Levine, Weitz, Hickey, KMP, GLS, Shap?, etc.) on the pictures. Who can put names to the rest of them? Image [#46](http://www.flickr.com/photos/90204102@N00/3454016237/in/set-72157616928718721/) probably causes sleepless nights to RMS. :)
http://www.flickr.com/photos/90204102@N00/3455023730/in/set-72157616928718721/ is me!
Clearly all the ILC people are [great hackers](http://www.paulgraham.com/mac.html).
everybody looks so serious...
It was the same at PyCon.
Think Different!
And I somehow suspect that you're not even allowed to go on a RubyConf without a Mac.
&gt; I remember telling my father back in 1986 that there was a new kind of computer called a Sun that was a serious Unix machine, but so small and cheap that you could have one of your own to sit in front of, instead of sitting in front of a VT100 connected to a single central Vax. Maybe, I suggested, he should buy some stock in this company. I think he really wishes he'd listened. Heh. I don't think that's really accurate, today.
you mean Sun's stock is cheap now? it is cheap comparing to 2000s price, but still much higher than it was in 1986
If they don't find a buyer, fast, that stock will get very cheap indeed.
[Olin Shivers](http://www.flickr.com/photos/90204102@N00/3456045290/) [Gerald Sussman](http://www.flickr.com/photos/90204102@N00/3456000596/) [many](http://www.flickr.com/photos/90204102@N00/3455990690/) [many](http://www.flickr.com/photos/90204102@N00/3455163051/in/photostream/) [many](http://www.flickr.com/photos/90204102@N00/3455157871/in/photostream/) more of him... [Dimitry Gashinsky](http://www.flickr.com/photos/90204102@N00/3455960520/) [Daniel Weinreb](http://www.flickr.com/photos/90204102@N00/3455936042/in/photostream/) [Shriram Krishnamurthi](http://www.flickr.com/photos/90204102@N00/3455090285/in/photostream/) [Andy Wingo](http://www.flickr.com/photos/90204102@N00/3455882980/in/photostream/) [Edi Weitz](http://www.flickr.com/photos/90204102@N00/3455799932/in/photostream/) [Alexei Radul](http://www.flickr.com/photos/90204102@N00/3454674573/in/photostream/) 
I don't understand why women would have more of a problem with something being "obscure" than men. 
Be the same as everyone else in the room? How is that thinking different?
I see tons of PCs. Oh wait, you mean _windows_ PCs? Hah; yeah right.
Sarcasm propagates through the internet the way radio waves propagate through water.
[not just the download page](http://www.stripedgazelle.org/joey/dream.html)
You can go, there's just no guarantee of your return.
&gt; I've read opinions that Clojure isn't a Real Lisp because a lot of Clojure is written in Java and isn't extensible in Clojure itself, but that's generally not true. The reader code for Clojure was all written in Java, but above I modify it from Clojure. There is no line separating Java-land and Clojure-land. It's all one big happy family.
[The original paper.](http://eprints.kfupm.edu.sa/59670/1/59670.pdf)
There are a few nonconformists. At the first RailsConf we were even awarded Certificates of Nonconformity: http://www.flickr.com/photos/mintchaos/174356973/
If you try extremely functional programming in CL - eg. you've defined flip, curry, and compose, and use them lots - you soon start to notice just how verbose `#'(lambda () ...)` and `(funcall #'fn)` are. Common Lisp makes this style ugly, and it doesn't have to be. How significant this is depends on how you use the language. However, having to work with variables called lst just because list is a function is also ugly, in a different way. There's advantages either way.
I want this to be fascinating, but McCarthy doesn't seem to like to answer these questions. `EDIT:` It does get better as it goes along.
The transcript could be better -- it mispells "Gdel number" as "girdle number" (question at 4:51) and "Turing machine" as "touring machine" (question at 34:18). I guess the transcriber isn't a computer scientist.
...and frequently replaces "list" with "Lisp." Also leaves out some highly important words in sentences, like "cons" in the first answer. Edit: And did they just think Guy Steele has some speech impediment causing him to unintentionally say "ess" before "expression?" Edit2: Heh. I can't help reading the transcript even though I'm watching/listening to it. I was really puzzled by "consoles" until Steele said "cons cells."
$50 is quite expensive. Okay, in Euros it looks less. Though usually Lisp books are a good investment. At least from looking at the prices for used Lisp books. On Lisp in 'acceptable' condition is already at $100. And then, I know already Lisp. Why should I buy it? A comic book about Lisp? What would be to learn from it? With these ridiculous aliens? It might be a good book to have laying around on my office desk. Hmm, I will have to buy Conrad's book. ;-) 
&gt;On Lisp in 'acceptable' condition is already at $100. [On Lisp](http://www.paulgraham.com/onlisp.html) ...or you could just [download it for free](http://www.paulgraham.com/onlisptext.html), because it's out of print, and Graham is a cool guy and/or has just decided he has enough money.
Yes, even though the PDF has been available for some time, the used printed On Lisp is expensive.
If it is like his lisp wizard game tutorial it migth very well be fun and worthy read.
If you like this you might like http://ssax.sourceforge.net/#Documentation which has a scheme based xslt transformer.
it is missing a few diagrams, but... yeah, I don't get it. Although, I think there is a huge discrepancy between what people *are asking* for the dead tree version, and what people *are willing* to pay / *are actually paying*. I bet very few copies, if any, have actually been sold at that price.
That could be. There are also only very few available. Maybe it is just 'cool' to have the printed version? But there are other examples: Anatomy of Lisp is not available as PDF. Lisp Style and Design also not.
A while ago I was going through my old DVD collection looking for stuff to sell on Amazon. Most stuff was selling used for $5-$15, but then I got to _Baraka_ and it was listed on Amazon for $399. It's not even a special edition or anything! Unbelievable! So I quickly listed mine for "only" $200, and just as quickly the high seller undercut me by $5, and then it quickly got into normal price ranges. I don't know if that's happening with On Lisp, but it certainly happens with other products.
Am I the only one who don't cares about clojure ?
&gt;Am I the only one who don't cares about clojure ? Nor grammer, apparently.
[Muphry's law in effect](http://en.wikipedia.org/wiki/Gaudere%27s_Law)
I started making a serious effort to learn lisp about four months ago, after being exposed to it in school and not getting it. I got it. To my surprise, I also 'got' emacs. I am now a fully committed cult member. I am amazed that an environment of such power and elegance has been available to me for most of the time I have been using computers, and I missed it. 
Welcome to the Lisp community! Make sure that you have the correct pictures to worship: [John McCarthy](http://archive.computerhistory.org/resources/still-image/Chess_temporary/still-images/2-4a.Stanford_University.McCarthy-John.c1967.L062302006.STANFORD_UNIVERSITY.src.jpg) and [Greenblatt and Knight with a CADR](http://archive.computerhistory.org/projects/chess/related_materials/still-image/2-4.Greenblatt-Richard_Knight.1978.L02645385.MIT.lg.jpg). For your desktop background: [Symbolics LM2 Console](http://lispm.dyndns.org/desktops-1/lm-2a.png). Have fun! ;-)
&gt; The language splintered into dozens of dialects as its practitioners dispersed across the Net. Afaik Its the other way around, there were multiple lisps and they were sort-of joined into Common Lisp, which is very good and partly a compromise between the different lisps. (Although i definitely see room for improvement.) Also often-used is scheme, which is more focussed on simplicity. Now there are only a few lisps commonly used. Mostly scheme and common lisp. (Emacs has elisp but that seems to be used for emacs only.) The newer ones don't have too much following, afaik. There is newlisp, dunno if it really is good. Suspect there are some zealots that ignore criticisms about it.(Not informed enough to really make an assessment) There is [lush](http://lush.sourceforge.net/), but i don't see what the point of that is, really.(It also seems largely unknown.) Edit: forgot clojure! relatively new too, and afaik good. (although i wont get over the java thing, and the silly use of other stuff like {}) Edit: I might be wrong. Other people here know better.
You forgot Clojure!
What would you suggest as a route to 'getting it'? I'm an Emacs believer, and have written my own elisp, but it's pretty much like what a c-to-lisp translator program might produce.
That part of the article is referring to the late 1970s, well before Common Lisp was created. I'm not familiar enough with the history of Lisp to say whether or not it's correct that that was a time of dispersion, but it seems reasonable.
Practice, practice, practice. Also, read a lot more than you write. There are oceans of code out there.
saying lisp is a cult is kind of like saying science is a cult. I don't know that it's really a cult when it's just "right". (ok being dogmatic is bad, but most lispers i know aren't dogmatic, they may sound like it, but it's because there really isn't anything better than lisp right now to even think about using) 
&gt; silly use of other stuff like {} Lisp is all about coding in data structures instead of grammar, so why limit ourselves to lists? 
A lot of my code is pretty procedural, but I've found macros (and finding the right place for them) to really start getting something out of lisp.
I think you might be taking a light-hearted article slightly to seriously :)
CTRL-META-HYPER-AWESOME!
I'll never admit that my keyboard lacks an Awesome key... :'(
Not to discredit your enlightenment but I don't think that's the kind of enlightenment they are talking about...Or are they?. If they are, please let me know so that I can retroactively enjoy my enlightenment too. Here is my story. When I started computer science at a graduate school about 17 years ago, I didn't even know how to log in, not to mention how to program. One of the first course I took was called "Concept of Programming Language", in which we learned the concept of the programming languages and ended up writing an interpreter for a subset of prolog-like language in scheme, using CPS style and macros. I did struggle a lot to learn scheme but managed to learn it within a month or so and survived the course. Since then I have been using scheme for prototyping many projects. I always thought the difficulty I had at the beginning was simply because it was my first programming language/experience. Most of my classmates managed to learn scheme in a short period of time too and survived the course. And that's why I always thought the enlightenment expert lispers are talking about is something much higher level than getting the language and being able to use it freely. Am I wrong or did we go through the enlightenment without noticing? 
My experience from some years back - would be interesting to see how it is now - is that about 10 percent really understood the Lisp parts they were supposed to learn in one or two semesters. More students managed to get a basic idea. For me this always was kind of a filter. Students who really understand stuff like that are the ones to hire for software development. Today I see that some students learn Haskell, maybe that is also a good filter to find good potential software developers. Part of the enlightenment is the experience of enhanced creativity. There are other models where some benevolent dictator decides what programming constructs are good for you. Not so in Lisp. In Lisp you learn that the programming language itself is programmable and that you can change it in various ways, so that the programming language itself gets shaped in the direction of the problem domain. So you learn a new type of problem solving: WE can create the necessary linguistic and semantic environment to make expressing the solution easier. **That's what Lisp is about: implement new ways of thinking** - unconstrained by syntax, types, people that tell you that there is only one obvious way and all that stuff that gets in the way. This means that the nature of Lisp is fundamentally opposed to people who want to put programmers in little boxes , clone them, outsource them, constrain them, make them replaceable, dumb them down. Lisp is un-industrial. You can also see the problems that this brings with it.
FOONLY!!! OMG Dude, CIA renderings were so much cooler when you were doing them.
Wrong foonly, sorry. I get that a lot because we wear the same fez.
Its OK, you are still TOPS in my book.
Eh, it was something like Lisp 1.5 -&gt; MACLisp -&gt; [InterLisp, FranzLisp, ZetaLisp], Lisp 1.6 -&gt; BBN Lisp (it might have been Lisp 2), Plus one-offs like QA4, Planner, &amp;c. Scheme was originally implemented in MACLisp, but is obviously not a descendant . CL was a design by committee, and smashed the MACLisp systems together (with ZetaLisp being a huge influence). On top of that, you have systems like LeLisp (simplified CL), EuLisp (everything is an object), ISLISP (CL + Scheme + LeLisp + EuLisp), XLISP, InterLisp-D &amp;c. This is not including all the research lisps &amp;c. It's not really a '70s problem; LeLisp &amp; al were all '80s products. Even saying "CommonLisp" isn't great, since there are many different "standards" (CLtL1/2, ANSI CL, &amp;c) to adhere to, and Scheme is, well, Scheme. The Lisp space is getting much more unified though.
Eh, it was something like Lisp 1.5 -&gt; MACLisp -&gt; [InterLisp, FranzLisp, ZetaLisp], Lisp 1.6 -&gt; BBN Lisp (it might have been Lisp 2), Plus one-offs like QA4, Planner, &amp;c. Scheme was originally implemented in MACLisp, but is obviously not a descendant . CL was a design by committee, and smashed the MACLisp systems together (with ZetaLisp being a huge influence). On top of that, you have systems like LeLisp (simplified CL), EuLisp (everything is an object), ISLISP (CL + Scheme + LeLisp + EuLisp), XLISP, InterLisp-D &amp;c. This is not including all the research lisps &amp;c. It's not really a '70s problem; LeLisp &amp; al were all '80s products. Even saying "CommonLisp" isn't great, since there are many different "standards" (CLtL1/2, ANSI CL, &amp;c) to adhere to, and Scheme is, well, Scheme. The Lisp space is getting much more unified though.
See here: [HOPL2 Slides](http://www.dreamsongs.com/NewFiles/Hopl2Slides.pdf)
Because everything you do with other types of brackets can be done with a symbol at the start too. I guess that it is a little minor. Looking at it, the {} brackets are fine, since they will actually mean something for their use; either sets or maps. The [] brackets, though are arrays, which are, just as lists sequences, and indistinguishable from lists from a use perspective. (Other then cpu usage and such, and which functions *happen* to be given to use them.) It might be confusion whether to use [] or (), it might be a distraction which one to choose. On the other hand, it can be a handy visual indication. I also wonder whether these things are used applied before or after macroexpansion? I'd do it before; for sets and maps, people aught not to be able to peek into them to get in which order they are entered.(Then they would just be lists, anyway, people making macros can use them as lists.) 
Well, maybe i got ~1990 in my head [due to this](http://en.wikipedia.org/wiki/AI_winter#The_collapse_of_the_Lisp_machine_market_in_1987), which is relatively calm in these [head-explode-diagrams](http://www.dreamsongs.com/NewFiles/Hopl2Slides.pdf). The article does say AI winter, and that is about the time i thought of with AI winter. I am no historian, however, and i was playing with little cars (vroom vroom) and in diapers around that time..
(make-joke) C-M-x &gt; The function MAKE-JOKE is undefined. [Condition of type UNDEFINED-FUNCTION] &gt; Restarts: 0: [ABORT] Return to SLIME's top level. 1: [TERMINATE-THREAD] Terminate this thread (#&lt;THREAD "worker" {ADF0931}&gt;) &gt; Backtrace: 0: ("bogus stack frame") 1: (SB-INT:SIMPLE-EVAL-IN-LEXENV (MAKE-JOKE) #&lt;NULL-LEXENV&gt;) 2: ((LAMBDA ())) ... Shit.
ner nee ner nee ner ner * (make-joke) TAKE MY REPL, PLEASE! NIL 
I thought O'Reilly does not publish Lisp books "http://oreilly.com/oreilly/author/writeforus_1101.html"
It used to be worse. The wording was more anti-Lisp before. But they were somehow [sponsoring the last ILC](http://www.international-lisp-conference.org/2009/sponsors) (selling their books). They were looking for a Lisp book project. 
In 2005, RubyConf was about the same size as ILC 2009. There were zero women in attendance.
XML is a lisp without a built-in compiler, instead with just the parsing/DOM part. Given XML is reasonably useful for interoperating between detached systems as is, there might be room for a logic-less s-exp compiler for a multitude of languages. It might as well compile down to verbose XML, as they'd trivially map to each other and there's certainly some benefit to be had with actually being XML. If the s-exp data suddenly could really use logic, switching to a fully featured lisp seems to be a natural choice. Then the whole app gets gradually reimplemented in that lisp. Oops. Cue exclamations of "You did *what* with XML?".
in other news, Clojure's compiler is totally retarded
Use (zero? n) in favour of = of ==. The compiler doesn't seem to have a peephole optimizer.
Why was this posted in the Lisp subreddit when there's a [Clojure subreddit](http://www.reddit.com/r/clojure)?
While we're at it, there's lots of Common Lisp articles here while there's absolutely nothing in the [Common Lisp subreddit](http://www.reddit.com/r/Common_Lisp/). What's up with that? 
Because people subscribed to the lisp subreddit are also interested in Clojure.
Micro-benchmarks are crap; this all the more true given the various runtime optimizations that can be made to long-lived programs. For example, on my mac: `(time (dotimes [_ 1e7] (zero? 0) ))` : ~173 ms `(time (dotimes [_ 1e7] (= 0 0) ))` : ~88 ms `(time (dotimes [_ 1e7] (== 0 0) ))` : ~394 ms ---- `(time (dotimes [_ 1e7] (zero? 1) ))` : ~176 ms `(time (dotimes [_ 1e7] (= 0 1) ))` : ~495 ms `(time (dotimes [_ 1e7] (== 0 1) ))` : ~395 ms ---- The only valid optimizations are the ones that make your application -- in its entirety -- run noticeably faster, and even then only when it outweighs the cost (e.g., money, comprehensibility, maintainability) of putting them in.
This. 
Yes, I mention that in the post. Also, the majority of those tips did help improve clj-starcraft's performance. Using == instead of = didn't have a large effect, but I threw it in there anyway.
Hey we could use DSSSL... oh.
&gt; 1 Garbage collection is triggered when you run out of memory. This one really implemented this way in a lot of often-used implementations of languages? Because if so, it really sucks donkey cock.. Seriously, isn't it obvious the time for garbage collection should be determined in a way other then 'when you run out of memory'? How about 'when you have time to garbage collect'. (Although this might be a little harder to determine; there might be other processes.)
Well back in the day, it made sense to do it when you ran out of memory, since you hit the limit pretty often. Nowadays, you don't usually hit your maximum amount of memory, and GCs are a lot more sophisticated. Generational GCs split memory into "young" and "old", and the "young" memory is collected pretty often, because these are typically small and since they are young, more likely to be killed, whereas the "old" memory has lived longer, and will probably continue living, so collection is done less often. 
Documentation for setting up cl-opengl doesn't seem to exist. I've retrieved it using darcs, but I don't know what to do next. I'd like to reach the point where I can load and run one of the examples featured here: http://common-lisp.net/project/cl-opengl/darcs/cl-opengl/examples/ Please help. 
Hey
If you just want to see common lisp opengl code, in SBCL on linux (asdf-install:install :cl-opengl) will download and install the library and demos, I think. Maybe SBCL on windows will do the same. Good luck. I am a lisp newbie, and figuring out how to use libraries was tricky. But I'm using linux, and can do 'apt-get install cl-opengl' and that installs the library and points all installed lisps at it. On windows it'll be more difficult. You might want to google ASDF (Another System Definition Facility), which appears to be the emerging standard way to manage libraries, but doesn't come with clisp. 
Seconding ASDF. Read on how to install libraries using it and you'll know how to set up CL-OPENGL. It requires setting up symlinks in ASDF's folder, but turns out Windows .lnk files are recognized too, so ASDF with Windows CLISP works fine. Also, you need to install (again, using ASDF) CFFI.
After reading your comments, I focussed on ASDF. I have been using Lispbox. I did a darcs get of cl-opengl, cffi, babel, alexandria, and trivial-features. When I tried to run (oos 'load-op :cl-glut-examples), it churns away on those packages until it reaches the example code, at which point it fails to compile most of them. Thank you very much for your help. I'll keep trying. Is there nobody running clisp+opengl on windows? 
In the context of Joe's post: 'LMI had the first commercial generational GC' - in the early/mid 80s. LMI's machines were not frequently running out of memory, AFAIK. Generational GCs can have any number of generations, not just 'young' and 'old'. The LMI GC offers more features than that and that is what Joe writes about. Quote: 'The implementation was fairly straightforward, but it had some features that I haven't seen in other garbage collectors. There is nothing special that would prevent these from being implemented in another GC, it just seems that no one does it.' It seems that LMI did not have the EGC (hardware assisted ephemeral generational GC) of the Symbolics, though.
'running out of memory' in a generational GC means that the generation where new objects are allocated is full. This generation will be GCed then. If there is still not enough memory, more can be allocated for the youngest generation. Since the youngest generation is not that large, the GC time is quite low. Several GCs don't delay garbage collection until the allocation generation is full, but are doing a certain amount of incremental collection based on for example the current allocation rate (that's also what Joe mentions in his post).
In my experience free Lisp implementations on Win32 is the least supported platform, as much more Lisp hackers are using Linux rather than Win32 with free implementations, and ones who use Win32 often use commercial implementations like Lispworks. So I recommend either switching to Linux/SBCL (even if your computer runs Windows, it is not a problem: you can run Linux in a virtual machine) or using free personal version of commercial implementation like Lispworks. (Both in version of Lispworks and ACL I have here there are some OpenGL examples, not based on cl-opengl though, but I can't be sure they are still present in newer versions.) 
I'm using clisp 2.47 on windows. I haven't used cl-opengl, but I just installed it and tried running the examples - it stopped compiling once asking for the freeglut.dll file, but after I hunted that down, it worked fine. Whatever your problem is, I can't reproduce it. What exactly does it fail on?
I'm using Lispbox, which comes with clisp 2.37. I think that could be the problem. I have freeglut.dll, and the compilation errors only occur when compiling the examples. On further investigation, it looks like a version issue, I'm using the latest cl-opengl with an older clisp. I'll switch to clisp 2.47 and stop using lispbox. It sounds like you got cl-opengl going just recently. Can you describe the steps you took? 
&gt; I'm using Lispbox, which comes with clisp 2.37. I think that could be the problem... &gt; I'll switch to clisp 2.47 and stop using lispbox. I did that a while back; it was a bit tricky getting emacs and everything else set up, but learning how to do so was time well spent. &gt; It sounds like you got cl-opengl going just recently. Can you describe the steps you took? `darcs get` make shortcuts to .asd files in asdf directory `(asdf:oos 'asdf:load-op 'cl-glut-examples)` see "can't find freeglut.dll" error message, install freeglut.dll, select appropriate restart run examples
Thank you.
Have you tried [able](http://phil.nullable.eu/)? (I have only tried it for linux tho') And i still use emacs because of the stuff i am used to and isn't in able at this point. (Maybe i should dev it a little, so far i can see the code is good, although aimed at simplicity rather then generality a little more that i'd like.)
How do you play fullscreen on a mac?
Thank you for this! Adding cl-opengl to this set of packages worked well - calling (asdf:oos 'asdf:load-op 'cl-glut-examples) compiles the examples. Now at least I have a base. 
Thank you to everyone who replied. The solution I'm using now is a modified lispbox with Able's version of CLISP (2.42) and all its libraries replacing those in lispbox (2.37). It works beautifully, including being able to break within opengl and tk code. Before I heard of Able, I tried replacing Lispbox's CLISP with the latest version, but SLIME barfed. When I tried Able, I was impressed that: 1) The opengl library works perfectly 2) Its all written using the ltk package, so its completely customisable 3) I could use what comes with it to update lispbox very easily Thanks [Jasper1984](http://www.reddit.com/user/Jasper1984/) for mentioning [Able](http://phil.nullable.eu/). For anyone who is interested, to substitute the CLISP in lispbox with any other one, add the file **lispbox-register.el** to the clisp directory, and update the directory name that is quoted in there. 
you can't really - it's flash embedded in html page
Maybe you should try [lispbuilderSDL](http://code.google.com/p/lispbuilder/wiki/LispbuilderSDL). It does some of the macros you'd make anyway out of tedium. (with sdl:with-init, sdl:with-events, gl:with-primitive, sdl:load-image, etcetera.) There is [Pal](http://common-lisp.net/project/pal/) does the same.(But it seems like a less collaborative, and i myself was slightly annoyed by it exporting it's vector stuff, and not from a separate package. (I was already using that namespace :/) [Cliki](http://www.cliki.net/index) lists a tonnes of libraries.(Of varying quality, though.)
On the tutorial video, F11 enabled fullscreen. And consider youtube, you can go fullscreen with it and it's using flash. 
Pal is/was more meant to be a pure 2d game OpenGL/SDL library built mostly for my own use, which leads to some of the deficiencys you mentioned. I haven't touched it for a while so if somebody tries it and bumps into a bit rot just report it in the mailing list, I'd like to keep it in a working state. I still have some plans for an 2.0 version which might happen someday.
Please don't use asdf-install. clbuild is currently the better solution, and most people do not update asdf-install packages. If i could remove asdf-install support from cliki without causing an uproar, i would :).
Baloney. When something doesn't work with asdf-install, most authors I know consider it a bug and try to fix it. clbuild is not a substitute, it's a different approach with its own problems and advantages.
I agree that clbuild-like random snapshots are not the way to go for reliable software (distribution), but unfortunately, the general lack of releases of some key packages pretty much makes it the least painful option (in comparison to asdf-install)...
real men use neither. if you're serious about using some library, get a darcs/git/whatever repo. this way you can track changes, both local and from library authors. clbuild and asdf-install are for suckers who are downloading only to look at, not use.
I spend a significant amount of my time supporting 'new' lisp developers, and almost all of them have tried asdf-install and failed at using it to bring a decent world together. It's easy to say that asdf-install is a working solution when you don't have to support the poor bastards that use it and don't know any better. I agree to clbuild is not a substitute, but it causes my users less headaches than asdf-install, and i will continue to suggest it until a better solution presents itself. The real problem, imo, is the lack of a 'release culture' in the CL 'community'. You yourself are an excellent counter example, but xachs are few and far between (and i'm not one to talk). The climacs on asdf-install is over a year old. Is that a bug or a feature? 
bullshit.
The new user experience could be upgraded in many, many ways, including asdf-install. That climacs is old on cliki is a sign that few people who aren't hacking on climacs care about climacs (which is true for many projects, not just climacs).
Or vice versa?
But not as happy as Perl users. 
Horrible title. Lisp is hardly mentioned. Perl comes out as having the happiest users. 
I am happy even with the second place.
My next language will use :) as the statement terminator instead of ; That should bring a smile to the programmers faces, or atleast mess up the :) statistics :)
if it will also use parentheses like Lisp.. (defun fact (i :) (if (= i 1 :) 1 (* i (fact (- i 1 :) :) :) :) :) gets very happy at the end of a function.. 
I use both, I'm extra happy.
That isn't so much happy, as that 'crazed smile' you see on the faces of patients in mental hospitals that are doped to the eyeballs. That's just what programming perl is like.
:)))))) &lt;- this is a Russian wide smile. 
Just syntactic sugar for :) :) :) :) :) :)
I thought happiness was an end in itself, so the means to get there doesn't really matter.
"Sifting through the data, unlike other languages, there seem to be a surprising number of people that just felt like giving Perl shoutouts." That is the key right there. For some reason, when people do something bad for them they can't be quiet about it. They have to try and get others to do it too (I guess so they don't feel so stupid). No other language has such rabid advocates. This is the thing that I hate most about this language. The constant US-politics-style advocacy. "Wow! Look how powerful Perl is!" they say as they do some task in 5 lines that any modern language can do in 3 or 4.
presentation was pretty interesting, but this guy's code is totally insane
Yeah I cant read it
This is really cool. I've long been unhappy with hunchentoot, so this is very welcome.
Anything in particular causing problems?
a comment from time to time would be useful. especially the macros should be commented
After slashdot had a story, now we are greeted with Service Temporarily Unavailable The server is temporarily unable to service your request due to maintenance downtime or capacity problems. Please try again later. Apache/2.2.4 (Ubuntu) mod_fastcgi/2.4.2 PHP/5.2.3-1ubuntu6.5 Server at john.freml.in Port 80
Ah well, I misunderstood that.
For at least two other Common Lisp based web servers there are claims of architecture oriented towards good performance: http://www.scieneer.com/scl/http.html http://hoytech.com/antiweb/manual.awp/design.html
Slashdot had the story before I submitted it here. I don't think it is the cause of any problems.
I'd like to see comparison with example code between arc and clojure. 
Nice.
It will be interesting to see how well this works. Although this is aimed at education, I have been thinking that something like a smart notebook would be helpful even at the research level (where I work). The answers are not known there, but basic CAS functionality can be used to check work/find stupid errors as you go. This is GPL software so it could have some useful parts.
Nice, but is this really lisp-related? It's Franz Inc., and it has a lisp binding. But thats all, isnt it?
If I were Franz I would hide this list immediately. Almost very single customer was one of: 1. Major corporation known for bungling and dumb decisions, on the verge of financial collapse (Kodak, Ford, Citi, Sun). 2. Defense contractor (IE someone who gets paid in proportion to the number of man-hours necessary to complete a project, and who has absolutely no relationship between project success and profitability, in fact often making far more money by hiring cheap but incompetent workers and accomplishing nothing because they can charge the same per hour for a bungling moron as a genius. They will often have 15 Big Iron servers all running Oracle to do something that could be accomplished on an old laptop and grep, and I wish I were exaggerating at all.) (BAE, Boeing, General Dynamics, GITI(I assume), Los Alamos (same diff), Northrup Grumman, Raytheon, SPADAC(assume), SRI, MITRE, Lockheed Martin, DERI(assume), and the DOD itself. 3. Companies nobody has ever heard of. 4. Universities (I will bet dollars to donuts that all the universities listed are using this product on some kind of military or intelligence agency sponsored research). The only notable exceptions seem to be in bioinfometrics. So that might be a hot area for Franz that isn't just government waste.
It is a list of 'users' of an application written in Lisp. It would give an answer to the question who is using (and possibly extending) such commercial Lisp applications.
Well, isn't that the fate of quite a lot 'high-tech' in the US? Much of it is related to defense (aka aggression) and other government activities. Lisp got during its history most of its research money from DARPA. 
Where do NASA, Cisco and Adobe fit in?
I would be very happy if someone here can confirm that this is the list of most commonly used functions (or at least a very decent one). Finding the standard functions for doing something has been the worst stumbling block for me in learning Lisp. 
That's an interesting idea. I wonder who is in the intended audience? I looked over a program I wrote yesterday and it's full of things not in the simplified reference, like packages, classes, full LOOP, let*, multiple values, dolist, dotimes, etc. And it's really quite a small (but, for me, typical) program! I'm not sure I would include RPLACA or RPLACD in any modern reference, personally.
It omits many things I use personally (see my "That's an interesting idea..." comment), and includes a couple things I never use. When I was learning Common Lisp, I found it quite helpful to read a lot of other CL source code. CL-PPCRE in particular is eye-opening because it uses a lot of different aspects of Common Lisp in a single project. I also enjoyed reading the hardcopy of Common Lisp: The Language, 2nd ed, because while it isn't up to date with respect to the final specification, it exhaustively describes almost everything with readable, sometimes entertaining prose.
Do you know the Common Lisp Quick Reference from Bert Burgemeister? http://clqr.berlios.de/ The book 'Ansi Common Lisp' by Paul Graham also contains a short Common Lisp reference. I don't think the list here (Simplified Common Lisp reference) is really THE small subset, for example, to write the solutions to the Euler contest or similar tasks. But it looks like a useful start for a beginner. I would add for example something like WITH-OPEN-FILE and possibly a few others. Why not contact the author and ask him if he adds your favorite function: http://jtra.cz/
Wouldn't it be nice to be on the forefront of an Internet phenom (for a change)?
It's missing DEFMACRO and DEFVAR, but has EVAL... i'm not sure who the reference is intended for, but i wouldn't want them on my team! :)
Reading through the hyperspec and reading other people's lisp code are the two best ways to learn the functions in the language, IMO. It does take a while to learn which tool to use when, but that's half the fun :)
I wonder what a _Simplified CL Reference For Someone I Would Want To Work With_ would look like. Maybe that's just the CLHS.
Heh .. it's the CLHS + CLtL2 + AMOP + threads n sockets, and there's nothing simple about it. Actually, if such a thing could exist, i suspect it would look a lot like L1sp.org. 
From a user perspective I found CLtL1 to be better. CLtL2 was kind of useful, but suffers from that it contains both CLtL1 and the changes. It makes it useful, because one can see the evolution - but nowadays I would take the language as it is and not how it was and how it was changed and why. I find the CLHS (as good as it is) only good as a reference - not something I would read like a book - like I could with CLtLX. I would wish for a reference that is more user-focused and less implementor-focused.
I encourage you to do it!
It looks like a good reference for simple things, like arithmetic and... arithmetic. It's a decent reference for sequences, but omits stuff like loop and dolist that you'll use a lot (unless you want to use map and its variants for everything), and mixes together common and uncommon functions. There's little or nothing in there dealing with types, objects, methods, macros, packages, symbols, and debugging/program analysis, all of which I use frequenly.