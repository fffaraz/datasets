Ha, that's some clever code! Maybe that's the implementation the author of the Symbol#call example was thinking of, but didn't actually implement? Ha, look at this, the facet source committing that `Symbol#call` says "CREDIT: Ilya Vorontsov, Nobuyoshi Nakada". Googling those names, I find this: https://bugs.ruby-lang.org/issues/6483 Where Ilya Vorontsov writes: &gt; Thank you for much more elegant code. It works with all of my specs except one: &gt; ['abc','cdef','xy','z','wwww'].select(&amp;:size.() == 4) # ==&gt; ['cdef', 'wwww'] &gt; It looks that one cannot make this work without proxy object. Ain't the internet grand for this kind of historical inquiry into code! It looks like the facets library took that "simpler" implementation, which can not do that, over Vorontsov's original implementation, but left that no longer working example in the docs (and has _zero_ tests for this `Symbol#call`, so no actual confidence that it does anything at all). But the `uberscore` gem took something much like Vorontsov's original implementation. At any rate, yeah, don't do this in real code, please. Not even with refinements. The IMO tiny increase in 'neatness' of the code does not justify the far too clever magic that will confuse any future readers. 
I want to say it was just introduced as part of Ruby 2.4.
What kinds of queries do you use it for? The example shown is loading a blog post and comments, which doesn't seem like something that really stretches a graph query system. Does it work well for more elaborate graph queries like shortest path, or other graph operations like triangulation or something like that?
I think so.
Great find! For posterity's sake, the uberscore gem was put together by a fellow who kindly requested my permission to use the name and overarching approach. I vaguely recall a conversation wherein he and I discussed making it even more Ã¼ber by having it approximate Clojure's `%n` argument syntax, but [the repo](https://github.com/vshatskyi/uberscore#uberscore) indicates that idea never came to fruition. Almost as interesting, though, is [this facsimile (improvement?)](https://eval.in/699203) of some of the simpler things NumPy arrays can be made to do.
Ah, thanks!
I'm still curious how database design is done under graph ql and did it require some sort of translation layer, to make all the queries and then to "massage" the results to fit the query.
You design your database the same as you always have; this library is the translation layer that converts your objects into types per the GraphQL spec.
I have to echo this sentiment. Your gem seems well documented and well structured, but I will never pull in a `acts_as` anything gem again. Rails-style macro methods are generally hard to follow (every newbie I've ever seen look at one of these methods has just given up and taken it as magic). Their source is usually filled with all sorts of macro context management nonsense (`class_eval`, `define_singleton_method`, etc.) and generally feel like an abuse of the language. I'd much rather see something use vanilla language constructs like `extend` which feels much less magical and more flexible to me. In fact, I don't know why I don't see more projects using things like `extend`. Probably because it got added late in Ruby's life
This is how I generally do it. The thing is, if I'm testing an instance method, I'm not able to do it without also creating an encapsulating class because it will be a private method. What I'm wondering is how to test that. So that I don't have to make a throwaway encapsulating class every time just to test a method. EDIT: in what you've written I would need to have #reverse in some class right?
I use CGI to process events (sales) that only occur a few times per day. There's no need to run puma/unicorn 24/7 for my simple needs. Here's how I do it with Apache: http://www.mikeperham.com/2015/01/05/cgi-rubys-bare-metal/
We use it over at GitHub as well. The maintainer is great person and very open to suggestions for the gem.
We use it to power large portions of GitHub. Most of the schema is public. Documentation is available [here](https://developer.github.com/early-access/graphql/) and you can play around with queries in this [GraphiQL instance](https://developer.github.com/early-access/graphql/explorer/). It's also worth pointing out that GraphQL isn't as much of a formal graph as the name would suggest. While there are `node`s and `edge`s, I wouldn't say that the query language itself optimizes for things like shortest path.
We use it! 
There have been a few iterations to make it possible (including having separate schemas altogether), but right now we're using graphql-ruby's [Wardens](https://rmosolgo.github.io/graphql-ruby/schema/limiting_visibility) paired with some custom "metadata" to build a DSL in our schema that toggles visibility between public and things we're not ready or not willing to expose (like say, personal user data).
u/jsearls wrote it but I'd be happy to pass along feedback
That is awesome - these folks move fast! Last time we looked at it was v0.18.0
There's GDBM, although you can't query it like SQLite: http://ruby-doc.org/stdlib-2.3.3/libdoc/gdbm/rdoc/GDBM.html
looking at what it can do, it's it basically the same thing as just serializing hash into file and than reading it?
SQLite is not part of the stdlib in ruby, and there's no rdbms implementation that's part of stdlib in ruby. 
dual boot. You will stay more on linux when working with ruby and you will also learn linux :) enjoy the ride
I don't know if you are new to Ruby or not, so I offer this advice just in case you are; feel free to disregard it. Dependencies are a huge part of Ruby development. The Ruby standard library is fairly rich but it is deeper than it is broad. The classes it ships with do a lot, but it doesn't have as expansive of a standard library as Python, and that's a feature not a bug. If you are going to get into Ruby you should probably go all in and get comfortable with dependencies and dependency management. You'll be a better Rubyist for it. As an aside, I recommend Sequel for working with databases.
Unfortunately I am too tired to reply properly. I hope to do that later. But please keep in mind that we are discussing the question whether public methods should be added to a class *solely for testing purposes*. If *barked?* was designed into the class because it is part of the way a *Dog* is modeled, fine. If it is just added to exhibit some state that otherwise cannot be publicly noticed then I say it's wrong to do that.
I never tried bash for Windows but I would definitely go for dual boot. I switched from Windows to Linux almost 10 years ago and even though I had my share of pain I would never go back.
I program almost exclusively in Linux and dual boot my laptop. In my experience, the server's you'll be running on are Linux anyway so programming natively helps avoid hiccups. Programming Ruby in Windows isn't impossible, I just found it annoying to get set up. Best of luck!
yep, I'm pretty new to ruby (1 month?), so thanks for the advice and for the tip, will check Sequel out
Like [this](https://eval.in/699784), or [this](https://eval.in/699789). **Edit**: Or [this!](https://eval.in/699788)
How do you do web work without Rails? I've never seen Ruby used without Rails, can't even wrap my head around it. To answer your question, it's a worthwhile investment if you plan on sticking with Ruby and potentially jumping jobs. Rails is a whole lot of separate libraries and magic working together, there's a lot there to get acquainted with -- picking up some hours with it can't hurt.
I use Sinatra running on Passenger for my web apps. The Ruby side of it is pretty much all business logic. The Sinatra routes handle REST requests via JSON. All of the UI is handled by Javascript. 
NOTE: Being able to do something like that does not mean that we should do something like that.
Code like that disclaims itself, but your efforts are appreciated all the same.
It's not built-in, but here's the Ruby equivalent of the sqlite interface that comes with Python: https://github.com/sparklemotion/sqlite3-ruby
If you want to stay in (mostly) Ruby I would at least get familiar with it. If you leave your current job it would be way easier to utilize your Ruby skills with Rails familiarity at least
Or [this](https://eval.in/699825)!
What does edit the class mean? The actual file or opening the class? class Test def foobar end ebd
Why do you need a database? Is using a simple hash enough for what you need? Serialize and deserialize. Profit. Not stdlib, but in gems; If you really need it, you can pull in sqlite. For generic databasey stuff: sequel
Y'all are trying way too hard! `puts Test.instance_methods.first` ðŸ˜‡ 
RTFM https://github.com/rbenv/rbenv/blob/master/README.md#uninstalling-rbenv
Native Ruby on Windows is definitely not the way to go, that's for sure. I've had nothing but trouble with it, for many many reasons. However, and I can't remember the exact issues I was having but [Ubuntu on Windows](https://msdn.microsoft.com/en-us/commandline/wsl/about) wasn't working for me either. Bundler didn't want to work on any of my projects and it was too much trouble than it's worth. This should be the ideal solution, but when I tried it several months ago it wasn't there yet. "Something" was wrong, it's been too long, I can't remember and I can't elaborate. Currently I run Linux in a VM more or less just for Ruby. It works, it's a bit slow (X in particular, it's kind of a shame to have your editor lag) but everything works as if it would on native Linux. I think it's currently the most stable, convenient (dual boot is always inconvenient) and reliable way to go about this right now. But keep your eye on Ubuntu on Windows, because that really should be the best way once they work out the kinks.
It will make you **far** more marketable if you're looking to stick w/ruby jobs. I stepped away from rails after 5 years for sinatra. Preferring a simpler stack with less DSL magic in it. But when I was job hunting 6 months ago, just about every ruby opening mentioned Rails in the first bullet. Build one or two toy apps, toss 'em on a public repo (github, bitbucket). Do that every year. Use the time to prototype an idea. But that will keep you in the loop re: the Rails ecosystem, toolchain, etc. Unrelated: I ended up taking a python gig and there are definitely some gems I miss.
How is the speedtest embedded? If it is iframe or javascript widget from third party, you can only get things from it with javascript, and it will be tricky or event impossible.
going along with your *edit*/subclass solution(and this is utilizes more of the `Test` class...): class MyTest &lt; Test # foobar becomes noop def foobar end end MyTest.new.foo # =&gt; 'foo'
So what you need is: 1. select items with correct second item 2. gather scores from those items 3. calculate average right? rankings = [[3, "Level 1"],[1, "Level 2"],[3, "Level 1"],[1, "Level 2"],[9, "Level 1"],[1, "Level 2"]] rankings .select{|item| item.last == 'Level 1'} # select items with correct second item .map{|item| item.first} # gather scores from those items .reduce(:+) / rankings.size # calculate average 
 $stdout = StringIO.new; Test.new.foobar; STDOUT.puts $stdout.string[0,3]
HOLY SMOKES. Thanks dude, this is exactly what I needed. You're right a hash may make more sense but I'm working with SQL and was trying to keep the confusion minimal.
actually i do have another question if you're still here. I'm iterating through an array where I call .to_f in the loop however some spots contain a NIL value, which then affects my numbers because calling .to_f on NIL returns 0. Is there a way to execute the loop only on those index values IF they contain an integer?
whoops it's not NIL it's a string...hmm. now what...
Vagrant is a ruby project, puppet is a ruby project, homebrew as well. Not everything needs to be a website, you know?
I'm kind of lost, do you still have a question? :P
lol, no i had an existential crisis for a minute and then i realized i can fix my problem with one line IF statement. derp.
The more you know! Ruby isn't my main language, hadn't heard of Sinatra before. Thanks for the knowledge.
As a person who has done hiring, I have a hard time imagining turning you down because you know Ruby but not Rails. That seems preposterous. Job listings have more lies than resumÃ©s, anyway. For me, your specific experience with Rails is immaterial if you're a good programmer and a culture fit. A client recently hired a senior Python developer to do Rails work! Don't sweat Rails experience. (But be prepared to answer questions about why you haven't used Rails. People will be curious.)
The results show up in the webpage: http://imgur.com/a/YMMYd
 t = Test.new def t.foobar; end t.foo https://eval.in/700032 DATA.seek(0, 0) data = DATA.read data.gsub!("Test", "Foo") data.gsub!(" foobar", "") data.gsub!(/DATA.*/m, "") eval(data) t.foo https://eval.in/700058 
tbh at that point I can just do RoR and `http://localhost`, correct? Well... that's maybe that bad of an idea.. At least I'll have a reason to learn RoR
If for iOS/Apple TV/macOS/Android, I would use RubyMotion. 
Whoops should have read that question better. &gt;.&lt;
+1. If a company assesses my ability to pile hacks onto code in order to work around issues, I'm probably not going to like that job.
If you're familiar with the java gui toolkits, you can use them very easily from jruby. But pretty much everything I make can either be a command-line app for personal use or a web-based app. Unless you're trying to visualise stuff on the local filesystem or mess with local peripherals there's not much reason to go gui. 
JQL is not supported yet, Is jql actually usable?! If it is, I consider to add new feature
First of all, this is a gem that specifically provides patches, it's like active support. So for it to use patches internally might be a little more acceptable than in other cases. But more generally, I'm not sold on this notion that patches make code no-maintainable. If I say `using MyGem::StringPatch::InstanceMethods::Foo` it's saying pretty clearly that I'm adding the `String#foo` instance method. I just don't see this as being much more complicated than the alternative (to write a non-patch method which does the same thing).
The alternative -- disabling the autoloader and putting your files where you want, and naming the classed defined therein whatever you want them to be named -- is looking more and more attractive every day.
i did. easily that was the first thing i tried. i'm here bc i can't figure it out. i totally don't get how ruby is entrenched in macos. all i'm trying to do is install 2.3.1, and it just doesn't work.
This is called "operator overloading". Here's a blog post that goes into more detail: http://strugglingwithruby.blogspot.com/2010/04/operator-overloading.html
Fair enough, time will tell one way or another, or people will continue to have different opinions, also possible!
Definitely a good read for understanding how Ruby works.
Jira-CLI stores your API key in a file, for future reference. (You just run `jira install` once.) It also has CLI commands that run with an interactive mode _or_ command line args. I suggest you take a closer look at what that gem does, as honestly it's very similar. 
Try [FXRuby](https://github.com/larskanis/fxruby). Nothing too fancy, but is very easy to install in both windows and linux and just gets the job done. (I've use it mostly for simple GUIs). PS: You could also try [gtk3](https://ruby-gnome2.osdn.jp/#ruby-gtk3+package) for ruby I heard is quite up to date but I haven't use it myself.
A tiny serverless computing platform. It hosts single-purpose, stand-alone scripts on a REST endpoint ( currently Ruby, will have support for JS, Python and Go). It is as simple as pushing the code to github with travis.yml file or POST the code-file over http to http://serverlessly.io/rubyfile. That code will be hosted on a REST endpoint. You can invoke that code with either GET or POST request. Invoke by GET request just runs the code and with the assumption it finishes in couple of minutes and returns json or null. Invoke by POST request, you can pass input and also specify if the code should run as long running job or schedule time at which it should start. Each long running or scheduled job returns job ID, you can use it to track logs. Let me know your views on it
In the words of Terry Pratchett, "give a man a fire and he's warm for a night, but set fire to him and he's warm for the rest of his life".
[Chef](https://www.chef.io/) is also a Ruby project.
Well, what if my script download entire Wikipedia dump, unpack it, parse, convert to PDFs and send to 100k random emails? It is extreme example, but probably some (at least ad-hoc) limitations should exist? Less extreme example: some "JSON API", which in fact downloads large NASA DB and selects part of it to render some star facts into JSON, all on the fly?
I just started delving into ES so this would a great overview for me. I'm a bit confused about the need for the Node.js middleman server. Isn't that just adding another dependency and codebase to manage? Does that connect to the same db that the Rails application is using? 
I'm not certain why exactly they chose to use Node.js, but running microservice definitely makes sense for application load reduction. In this setup, when a user runs a search, the request hits the Node.js server rather than the main Rails app, reducing the load on the main app. Node.js microservice translates the request for the Elastisearch server, which then runs the query on the db. So, no, the Node.js server does not communicate directly with the db. 
 ruby -r ./foobar.rb -e 'Test.new.foo' | head -c 4
They mentioned that they could hit the nodejs server directly from the frontend, which would be significantly faster than going through Rails. Also ES objects tend to get real heavy (in my experience) in rails, because you either index everything and build an object from the ES response, or you have an intermediary step of grabbing all objects with matching IDs in the ES response. In either case, it's a bunch of weighty objects to create. 
I've used Electron and Traveling Ruby together to create a GUI for a CLI utility written in Ruby.
As @Bartboy011 and @manfrin rightly mentioned, going through the rails stack adds a significant amount of time to the search latency, and weâ€™d like to remove this unnecessary dependency. Also, the micro-service behavior is good for quick fixes and ultimately for the flexibility. Why we chose Node.js was mainly because of its non-blocking IO and we thought this is a good use case. Also as web developers, itâ€™s much easy to couple Rails + JS than going with something like Go.
Do anybody have similar behavior?
In case it gets boring, shuffle [these](https://github.com/jhass/DeBot/tree/master/bot/res)... shuffle both the wordlists and the lines as [zty.pe](http://zty.pe) doesn't shuffle 'em for us.
How much latency does it add?
Here is the link to PStore in the latest ruby version http://ruby-doc.org/stdlib-2.3.2/libdoc/pstore/rdoc/PStore.html
if you are hardcore and have a year: https://www.amazon.com/Computer-Programming-Volumes-1-4A-Boxed/dp/0321751043
I wanted to keep my comment brief (*"in a nutshell..."*) - because one could easily write a long blog post about this subject, and whatever I write is bound to be opinionated and disagreed with by some. My point really was just that the Rails core team have recognised the growing trend of JSON API back-ends, and have included support for this cut-back behaviour in the core framework. Of course there are many other factors to consider for each specific application; there is no "golden bullet" that is the best choice for all systems.
Haha funny to see this here as it was actually my suggestion :)
According to the Wikipedia article, it does not seem to be. &gt;The standard defines five exceptions, each of which returns a default value and has a corresponding status flag that (except in certain cases of underflow) is raised when the exception occurs. No other exception handling is required, but additional non-default alternatives are recommended (see below). &gt; &gt;The five possible exceptions are: &gt; &gt; * Invalid operation (e.g., square root of a negative number) (returns qNaN by default). &gt; * Division by zero (an operation on finite operands gives an exact infinite result, e.g., 1/0 or log(0)) (returns Â±infinity by default). &gt; * Overflow (a result is too large to be represented correctly) (returns Â±infinity by default (for round-to-nearest mode)). &gt; * Underflow (a result is very small (outside the normal range) and is inexact) (returns a denormalized value by default). &gt; * Inexact (returns correctly rounded result by default). 
From a math perspective, I'd assume it returns `nil`because computers cannot easily (read: quickly) calculate whether some given numbers are infinite. Consider `PI.infinite?` as an example. It may seem like common sense to us, but it's likely that the implementation takes some shortcuts in logic to avoid taking too much time calculating all the edge cases. Additionally, `5.0` can represent an infinitely repeating decimal that's been rounded. (This is all guesswork and under the assumption that the `nil` return value is intentional.)
Pretty sure the computer knows really easily whether or not `PI` is infinite, because it's not `Float::INFINITY` or `-Float::INFINITY`, which are the only infinite values.
I agree on the point of those two values being the only infinite ones in actuality. If it's me, anything but those would return true. Merely throwing out postulations on why that specific design decision was made.
Thanks that's more clear. Although of course `Integer` and `NilClass` are already two different data types.
Excellent. Answered a few of my questions that have been lingering since I had to debug a rough "backport" of sprockets onto a rails 2x app. If you had infinite time, energy, and money, would you ever consider changing sprockets to work more like Grunt/Gulp/Webpack, or even HTML Pipeline, in more of a step-based process?
Ok, but in that case why mention that 5.0 can represent an infinitely repeating decimal that's been rounded. That doesn't matter at all for the question "is it finite?". In addition to which the question "is a number between 3 and 4 finite" is not a question where a computer would need any shortcuts. I'm really trying to understand what your guesswork is based on, and the only reasonable explanation is that you think it matters whether the decimal expansion of a number is infinite or not. Which doesn't actually matter (and anyway, would make the question impossible to answer for computers)
Sorry if it wasn't clearer. My point was that if `infinite?` is actually calculating whether a number is infinite, they may have just taken the quick "let's just not check if it isn't `INFINITE` or `-INFINITE` and return `nil` rather than return any false negatives".
Awesome. I'm not particularly wedded to any particular asset compilation methodology, its just the transformation pipelines are far easier for a developer to customize. With [HTML Pipeline](https://github.com/jch/html-pipeline), for example, I don't need to go to great lengths to enhance the output of, say, markdown, with things like username mentions, emoji, stuff like that. While this isn't really an "asset" compilation system, it does transform one type of content into another, and can have different processors loaded much like Rack middleware. As for sprockets, reading through the docs and notes you've been writing lately is incredibly useful. I wish i'd had some of them 2-3 years ago
Nice, I'm glad you've (sort of) taken it over. If you don't have gem push rights, you'll want to start trying to get the maintainer to give that to you now, so you can push a release not just commit to the repo. :) Of course I notice that open PR you point to is just over two years old, which doesn't exactly inspire confidence either! Such is volunteer open source, I guess! But I like to keep a sense of the maintenance stories for my dependencies. In this case, maybe "code red", heh. 
that really doesn't make sense if you understand how floating point numbers are implemented, but I guess it makes some sort of sense if you don't realize the actual reason (given in a comment elsewhere in this thread)
As I said, it was postulation to promote discussion. Now that there is a valid answer, no reason to worry about it.
Oh boy, at first I was worried this was going to be a self-post question, and I was thinking "Nobody's gonna be able to tell you, it's A Mystery!" Thanks /u/schneems for telling us! Although I'm not sure I really wanted to see the inside of that sausage factory...
PS: Hey /u/schneems, if your RSS feed uses `https`, but you insist on posting the `http` version to /r/ruby, then my http://rubyland.news is unable to link the aggregated entry from the feed to the reddit comments, cause they aren't the same URL! 
Nope, your guess is totally irrelevant, see below discussion of the IEEE spec from people who aren't just guessing. 
This is a "but wait, there's more" kinda a project. Whenever I think I understand how things work, I always discover something new.
ugh. I looked into forcing SSL on the site. But it seemed hard. I'll try again soon. Any experience with getting Jekyll to force SSL?
Abschminkey patching
See above for discussion that came to the same conclusion.
Super exciting and thanks for using tty-prompt, tty-spinner &amp; tty-table gems!!! Much appreciated.
I don't understand this comment.
Have used go in production with over 500K parallel connections. Memory usage very much depends upon what is your use case and how are you writing your code. I was able to easily handle 50K connections on a RPi 512MB. If 3GB is supposed to be a less memory usage for Ruby land I can only offer my condolences and if I was a ruby developer I would rather write an external pub/sub system. One can use nginx with nchan extension (it's very very efficient for such tasks) for out of box solutions. Disclaimer: I have been ruby dev in the past and I gave up on it for very much same reason and GIL issues. 
Nice work! I've heard about `iodine`, but I haven't tried it yet. I should definitely compare AnyCable with Plezi. Follow [@any_cable](https://twitter.com/any_cable) to stay in tune)
it seems the site itself is server less ;) 
Cool :)
Would go with yard. Rdoc is older
And to run it... rake yard I chuckle every time.
Great work as always guys!
I think your expectation of how to use Ruby is incorrect. You are causing an immediate break down of the [Liskov substitution principal](https://en.wikipedia.org/wiki/Liskov_substitution_principle) when you check type. Bignum is a subclass of Integer, any Ruby code that takes an Integer should be able to take a Bignum as well. Instead of thinking about type, think about interface. don't use #is_a? use #respond_to? So now think about what part of the interface for Integer you specifically need is. Use #respond_to? to check that the object will respond to that method. Fundamentally, if a user wants to pass the wrong thing in, they will do it regardless of what checks you put in place. I can monkey patch Integer class to be completely different or I can implement my own Integer class and overload the one included in the standard library. **Some hopefully helpful examples:** If I want to verify that something is Array-like: thing.respond_to?('each') or perhaps you really care that it implements Enumerable. thing.class.included_modules.include?(Enumerable) (note - no quotes around Enumerable) Ironically, to check if something is Integer-like: thing.to_i is probably your best bet, as #to_i is a method of the Integer class. So anything that implements #to_i ought to return you something that is reliably integer-like. IN this circumstance an Integer returns itself. The same can be said for Float, just use #to_f on it. Likewise for Date, call #to_date on whatever your input value is. #to_date is part of the Date class, and is thus a part of all it's children. Also, any other class that may be date-like should implement #to_date. For #to_i, #to_f, and #to_date you could just call it and let it raise method missing. Or you could guard by checking for the obj.respond_to?('#to_i') and throw on a false. You are probably on the right track with your enums. You could get more power for cheap by adding in a gem, like [ruby-enum](https://github.com/dblock/ruby-enum)
To create a graphical user interface. With menus, buttons etc.
Maybe this? https://github.com/larskanis/fxruby
You almost certainly can. The project I work on does this -- we have 10 services, mostly using Ruby and some web framework (either Sinatra or Rails). One of those services is responsible for authentication, and takes an API key, then returns a user record as JSON to the requesting service. But that's not the only way to do it.
Wow thanks for a prompt reply. I'm considering learning ruby for this purpose and plan on using JWT if possible. However the main goal is user accounts, roles, login logout, and authorization of other servers within AWS. Would you be able to point me in the right direction as to what my options are regarding framework and gem combinations and their pros and cons?
I think the [devise gem](https://github.com/plataformatec/devise) would fit the bill for a decent chunk of identity management, but I'm not sure what your business needs for identity management are. If you need the service to act as an oauth 2 provider for other microservices, there are plenty of choices like [this one](https://github.com/intridea/oauth2). It is likely ruby would be good choice for building your service.
Glad to hear it! Thanks!
YARD is nice. Easy to learn the syntax, and it'll link constant and method names automatically if you follow conventions. 
What's the current hold up on this big "rewrite" getting merged/pushed? If there is significant work still to do, would you be able to summarise the issues so that others could perhaps chip in? 
Yes, you can use any general-purpose programming language to solve general programming problems. Why would you think you couldn't?
Nope, I have huge number of servers :)
If you don't know then you don't know. They are just asking if there's a gotcha or maybe advice. Turning complete isn't really the deciding criteria. For example, maybe they discover through discussion that reacting to events is a theme. Then ruby wouldn't be great because events aren't necessarily native unless a gem does it out of the box or you write your own reactor. So maybe other languages work organically for this (node because functions, elixir because language features)? Idm is super complicated so a whole language community would be more on the pile. I'm not asserting you were mean. I'm just asking everyone to be kind.
You don't know how excited I am about AnyCable. I read it a while ago just before going to sleep, and tonight I'll sleep better.
@mperham , I think this "wondering" isn't totally fair. They did a great job with AnyCable, allowing easy integration with ActiveCable, but this isn't the first Open Source Server for Wabsockets. Faye was running and EventMachine based websocket server (open source) for a while now and `iodine` is an open source websocket / rack server that utilizes [the Rack Websocket specification draft](https://github.com/boazsegev/iodine/blob/master/SPEC-Websocket-Draft.md) (this allows HTTP and Websockets to share the same server and reactor without the need for any socket "hijacking")... The options are there. Go ahead and test them all, choose the best fit for your project and enjoy. P.S. Faye's websocket server and design were a big influence on the ActiveCable design (which uses hijacking) and `iodine`'s design is very different, although it allows a fallback to the older design used by ActionCable (at the obvious expense of performance, sinceActionCable's IO reactor takes over, creating two reactor loops).
3GB memory isn't supposed to be a less memory, and Rails don't eat memory that fast if it's a tipical website/app, but with the realtime capabilities added it eats memory faster, that's why people are trying to create solutions like this. BTW I'm interested in using NChan with rails, do you know about some tutorial on that? I'm a slow learner, and I need tutorials to learn things.
Idm is closer to the enterprise space. Generally, I'd say that Java would give you more libraries and more alignment. Of course, starting out is going to be slower. It's been a while since I've been there. Dropwizard, Spring Boot and Spark (not the streams one) look interesting but I have zero real experience. I just don't know what IdM libs there are in ruby. I did an IdM project in Ruby and used JRuby for interoperability / deployment. Wasn't super great overall, I felt like an edge case. Advice is tricky. It's a lot better to be there for the person but that's hard to do over the Internet.
Don't get too cute. Just write a decorator class.
It's just a strange question coming from someone who asserts themselves to be a programmer (but not familiar with Ruby). If I wanted to write an authentication service in, say, Rust (which I know practically nothing about), I would start with the assumption that I could do that, because, well, it can manipulate text, and HTTP is just text. I would probably search around a little to find out what web frameworks it has, and see if there are any libraries for whatever authentication protocol I was thinking about using. And so if I was looking for some recommendations, I'd make a post along the lines of "I'm not familiar with Rust, but I'm looking into using it to make an authentication service for reasons X, Y and Z. I see that I could use library A with framework B to write a little http service to do this; does that sound reasonable?". But this post is not that.
That's pretty presumptive.
My friend Karl made this a year ago, I haven't had a chance to use it yet but it looks like exactly what you want? https://github.com/karlhigley/alder
[removed]
[Parslet::Transform](https://kschiess.github.io/parslet/transform.html) supports pattern matching of Hashes/Arrays.
Well, the example in my post is pretty simplistic. When you think of nested hashes, and nested arrays inside nested hashes, and different levels of renaming on nesting (like `new_hash[:name] = old_hash['results'][0]['users'][0]['username']['value']` or something)... I am not even sure that reasonable declarative DSL to describe all of this, but I definitely felt a need for one, several times. (But my cases are pretty unusual.)
Looks suspiciously close to what I had in mind! Thanks!
Thanks, it is interesting, but seems to target a bit different mindset.
Since you wrote the Gem. I find the syntax quite clean digging into some examples. Its a cool project. My brain is just having trouble wrapping around a use-case, you know? Like what would this be suited for, a small project? Would it make larger ones easier to manage? Cheers!
&gt; Your advice sounds good, only think I'm not sure about is the #to_i thing mainly because of You're correct, you really don't want to use `to_i` if you care about correctness. `Integer` is the way to go.
I imagine a lot of people had the same questions about node.js Why use javascript on the backend?
I could not get it to work on my side. The gem looks pretty old too. Maybe try [rest client](https://github.com/rest-client/rest-client)?
http://i.imgur.com/RG0BS1U.gifv I can't believe it was that simple! I was going down weird Google and Stackoverflow paths and it was just a goofy old gem the whole time. Thank you, /u/tacit7, rest-client is working perfectly. I feel free now.
What you're really talking about is validating an XML document against its XSD, which is a completely reasonable thing to do. What you need to do is obtain (or write) the schema for your XML and use a two-line check to ensure the XML is valid: http://nokogiri.rubyforge.org/nokogiri/Nokogiri/XML/Schema.html xsd = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE)) doc = Nokogiri::XML(File.read(PO_XML_FILE)) xsd.validate(doc).each do |error| puts error.message end 
There's no reason a gem wouldn't work from any code in the project at all. The gem may be broken, or you aren't `require`ing the right files it needs to be required. `cannot load such file -- unirest` means either the gem is not really in your gemfile, or the gem is not providing a file `unirest.rb` as would indeed be the expected convention for a gem called `unirest`. I've never heard of `unirest` before. 
Side note: I wouldn't use require within methods like that. While I get the impulse to defer loading until it's necessary, the reality is that requiring a file in ruby can change the behavior of your program by extending already existent classes. You want class modification to happen deterministically, when the server starts, rather than when some user hits an infrequently used endpoint. I've had bugs that were a nightmare to reproduce because they only occurred after some 'require' was triggered deep within an infrequently used code path. The require might make modifications to, say, 'net/http', and suddenly rest requests are failing in an entirely unrelated part of the application.
I'm not against it just curious is all how I could use it.
Is this a static generator type of thing? Can I take the result and just throw into github for hosting?
I don't know about having a Ruby DSL for the DOM, those chains of `end`s aren't so great. With JSX/HTML you at least know what tag is being closed at a glance, and with Vue you have the option of using Jade templates which are nicer.
I'll use that instead of the monkey-patch, thank you.
Also, why is it that def singleton # x is an unused local variable x = *self end works yet def singleton *self end raises an error? SyntaxError: (irb):3: Can't change the value of self (irb):3: syntax error, unexpected '\n', expecting '='
Sorry, I meant learning not mastering, just corrected. I know its a lifetime learning process!
IdM Can be a pretty complicated space. Some folks have suggested services. That might be a good idea if there is not room to goof up. It is probably worth understanding the difference between AuthN and AuthZ. There are gems that can help you with both, but particularly on authZ, it is worth doing a bunch of research to see what is out there in many places to get a sense of the solution space.
How about `golang`? Is it something that seem to have a future potential?
Ruby has a potential to show how good looking your code can be, and how short and elegant you can express what you want. In my opinion ruby is more friendly and usable for programmer than python. It is worth learning even if you know python. And also it is easy, so you can learn it quick with that background.
OP, nobody learned python, php and most mainstream languages in school.
These are all languages *designed* to compile to JavaScript, while Ruby and JavaScript are *wildly* dissimilar. I'm not sure if you're seriously arguing this, or just playing devils advocate.
This was true 5 years ago, but I believe it is no longer true. A lot of introduction classes are now taught in Python.
Learning Ruby completely changed the way I think about functions and functional programming and it made me a much more efficient programmer. I've been programming for 20 years now and didn't start seriously Rubying until 2012. Let me tell you, it took my efficiency game to a whole 'nother level. I am now extremely productive in Ruby. Try Ruby! btw, once you know Ruby, you also can use the used-throughout Rails web programming framework 
Ruby is like Python, Sinatra is like Flask and Rails is a lot like Django. There's very little benefit in learning both stacks. Try something conceptually different instead like go or elixir. Compiled languages for the web are a safer bet in the long run.
I dont and ill let you know next time i boot the server.
Ruby is my first love, but during the past year I've been very polyglot, and use a even distribution of Ruby, JS, and Elixir, and sprinkles of things like Python and Clojure. I've used these all interchangeably for a wide array of tasks, from web applications to raw one-off scripting, and I must say that absolutely nothing beats Ruby for me when it comes to writing powerful scripts and tools to use. The quantity and quality of ruby gems out there leaves little to be desired, and filling in the gaps is an extreme pleasure in Ruby. I also must say it is the language I have the most fun with; it's APIs and syntax are heart-warming to say the least. I can't imagine ever abondoning Ruby, and I really don't see any competition for the reasons why I love it.
Ruby and python still different, and use different approach. I would say ruby does it in elegant and beauty way, while python just does its job. Ruby is heavily more into metaprogramming than python, just my imo. After python and php, ruby became language of my choice, it is much more friendly and easier to use. Learning elixir means learning erlang, can you really afford learning two languages at once?
Nice
Ruby and by extension Rails is a very nice language for the programmer but not so much for the system it's running on. 
By virtue of Google's support, golang will always have a future. I have ignored it largely because the language as a whole is offputting. However, it has popularized the channel metaphor for concurrency, which has been adopted by Crystal. Given that Crystal has near Ruby syntax, it's a language i am keenly tracking.
Yes, but remember, Rails has the problem of coupling with the gems, you can do it with it, is more harder than sinatra but isn't impossible. Sinatra in my view is more efficient for microservices architecture than Rails.
Fixnum is deprecated, wow. My `sinatra` keeps popping up these.
good to know! What gems would work with Sinatra to achieve this?
No, if you already know Python Ruby is not worth it. While Rails is better than Django it's not that much better. I'd suggest learning Scala, Clojure or Erlang.
Oh come on, no one has mentioned `Comparable#clamp`?!
Frankly, there isn't too much of a difference between 1.9 and newer releases. Just jump in and get to know it.
It's a fun language to learn and use
Built in functions are generally okay as long as you understand the implementation and run time (like say you need to sort something to solve a problem). However, the built in function .uniq here is the implementation that the interviewer is looking for, so just using it is not helping him or her understand if you're a good programmer. Remember that the interviews are typically not there to discover how much of a language's built-in library you have committed to memory (or even to write 100% bug free code that will compile and run), but rather to get signal on if you can code, think out a simple algorithm, and be thoughtful about your solutions.
Thanks, I didn't think of that family of test cases. It's ok, I'm not using this implementation anymore. I'm going with just using `[x]`.
Moving fast is a luxury of languages not being used very much. That could have been the case for Ruby 10 years ago. Now there's too much built with it to really go too crazy with releases, imo. Stability is the name of the game.
Will go against the flow here and say there are differences (small) between older and newer versions of Ruby. What I recommend is learning to use Rubocop (wire it in any project you use) and pay attention to the style warnings it emits. You will use the latest/recommended way of doing things and you will (more or less) write idiomatic ruby. 
I mentally hedge my bets: if I know the standard library can do something elegantly, I'll use that, but know they probably want me to do it for real. So I'll say something like, "ok, I've got one way to do this but can do it another way if you'd like". Then write out the one line standard way. I do however start with the elegant / std way first. I figure maybe they're testing how well I know the standard library, OR maybe they're Rubyists and I've scored a point teaching them something new they didn't know. And if they're seriously looking to see if I can do it by hand, because they're reading straight from a programming interview book, well we've made a one minute diversion into something fun.
Even when my only job was Ruby on a daily basis, this was the best advice I was given. Style really is something you can learn well by seeing how it would apply to your own code. 
With such background you can learn Ruby with ease and open wide area of job opportunities. Unlike niche languages like Elixir, where I've found no single offer. Learn industry proven language of different paradigm like pure functional Haskell can improve your effectivenes in mixed paradigm languages like Ruby, Python or Scala. There are some high-reward contracts for Haskell, but hard to fit demands, usually in financial sw area.
They typically want you to build out the algorithms yourself and avoid using the standard library. For example, in my last interview I was asked to reverse an array without using the reverse method. 
Rubocop is kinda like having a pair programmer on your side. I recommend you scan the Ruby style guide from where Rubocop implements its rules here [Batsov's Ruby style guide](https://github.com/bbatsov/ruby-style-guide) 
As others have mentioned, there really isn't much difference between 1.9 and 2.x that you need to worry about. But I also wanted to point out that the pickaxe book (Programming Ruby) and Well Grounded Rubyist have both been updated for Ruby 2.0. :)
My first interview, first question: reverse a string. I wrote `str.reverse!` and we had a good laugh and then I actually did it. Edit: if I am interviewing, I will mercilessly push you down to the lowest level I can, because I want to know how much you know. 
1.9 actually introduced the biggest change to any modern ruby, with character encoding tags on strings. I don't think we've seen as big a change since then, but keyword args in 2.0 are worth mentioning. I'm not even sure what you mean by increased Symbol use in 1.9, you mean in some stdlib api or something? I hadn't noticed. 
IMO, this is the problem that Ruby moving slowly tries to avoid. I'm not a python developer either, but what I understand of the problem is that they changed too much too fast when people were already using the language quite extensively. 
The thing is, you will never want the latest version of a library *without your knowledge*. You want the latest version of the library at the time you choose to install that library. After that you will be writing code that works with that version of the library, consciously update the library during the development. In the future, you may want to install your application and run it again. This time, you rarely want the latest version of all its dependencies, you want it to be like the last time it works. This is why lock file is important. Your version range *specification* is stored in package.json (like `*`, or `~1.0.0`. But the actual version that is installed at the time is kept in the lock file.
Link: http://ruby-doc.org/core-2.4.0/String.html#method-i-tr
inject: http://apidock.com/ruby/Enumerable/inject It's a fairly useful enumerable that I see a lot of younger devs avoid. Also, despite our love for duck typing, there are times when you just need to know, so stuff like this can come in handy: is_a? String nil? We actually type check for nil or empty collections like all the time without mentioning it, so in Rails, you'll often see blank?, empty?, exists? try(:some_method), and so on. I got chewed out for using `try` the other day in a PR review as a 'code smell'. But realistically, there's nothing wrong with using it if you expect some object to be nil in some cases. Short of implementing a null-object pattern (which no one wants to do where I work), I do not see a way to get around writing conditional logic around nothingness in Ruby and in fact, most rails apps are either full of that kind of logic of full of NoMethodErrors in production. Also, relating to this, law of demeter: http://www.virtuouscode.com/2011/07/05/demeter-its-not-just-a-good-idea-its-the-law/ But again, I had a PR recently shot down for use of the `delegate` macro as it "adds hidden complexity" ;) 
This is way too broad to meaningfully answer, but reading the [bbatsov style guide](https://github.com/bbatsov/ruby-style-guide) all the way through will almost certainly expose a novice Ruby programmer to a lot of new things. --- Edit: *All* Rubyists will probably find a lot of value in periodically rereading it too, I know I do.
- `reduce/inject` - `map/collect` - `select/find_all`, `reject` - `with_index`
Good point. But it yeah, we are still probably a year out from updating to rails 5 and a recent enough version of Ruby to have safe navigator. The lonely operator is still new enough that there aren't many 'in production' apps that could make use of it, around these parts at least. Keep in mind, I still get job offers for rails 3 environments even now. 
That's right. I should have mentioned that it's equivalent to calling reduce with default value 0. [1, 2].sum #=&gt; 3 [1, 2].reduce(:+, 0) #=&gt; 3 Enumerable#sum has been part of ActiveSupport, although that method works for strings and arrays as well. http://apidock.com/rails/Enumerable/sum
&gt; But realistically, there's nothing wrong with using it if you expect some object to be nil in some cases. Uhm, didn't your coworker tell you _why_ it's considered a code smell? irb(main):001:0&gt; 2.try(:nonexisting_method) =&gt; nil
I don't see why you're adding this method, since you can already call `.singleton_class` and get the ... singleton class. What you're defining here is more like Array.wrap, which already exists in Rails. 
openstruct can make your code remarkably pretty
No, I want to learn something with said conditions to make some money. "It would be good if I could make game servers with it."
Anything from Enumerable. String.split.
Again if you want to build a game server you need to use a language which is specifically suitable for such a task. As for making money you can do that with any language so choose the one that you have the most fun with.
Elixir is not nearly as productive as Ruby because it lacks the vast ecosystem. In ruby no matter what you are trying to do chances are you don't have to start from zero. Just today I was trying to write some code against the reddit API. There is a ruby gem which works great. There is an Elixir lib which has terrible instructions and doesn't work as described. 
And vulnerable to typos: `OpenStruct.new.foo # =&gt; nil` It has also pretty bad performance compared to doing it right (by defining a class with getters) because it uses `method_missing` under the hood.
Agreed, there is nothing for Elixir which can currently compete with RubyGems, but that's more to do with the newness of the language than a fault in the language itself. Don't get me wrong, RoR is what I use in my day job and it has some major advantages in the amount of work it is necessary to do (i.e. for any complex functionality there's usually a Gem which lets me avoid writing something from scratch), but for anything I do outside of work I tend to use Go or Elixir because they're more performant and (for me, obviously this is *opinion only*) more fun to write. If the ecosystem was the only thing which mattered, NodeJS would be an excellent choice - it's faster than Ruby in many cases, the NPM ecosystem is mature and vast (albeit godawful) and JS is used everywhere.
`Enumerable#each_cons` for a sort of moving window function.
We use it in a few places for default indexes: foo&amp;.bar.to_i versus foo.try(:bar) || 0
Yes. I was pointing out that just because you are popular and heavily used doesn't stop you from making mistakes like this. 
&gt; Comparable#clamp I am very excited for this.
I think there's value in knowing JS, even if you're writing in a language that targets it. I have lots of syntax gripes, but there's no excuse for not knowing JS semantics. I would never hire a front-end dev who only knew abstractions over CSS and JavaScript. 
I don't think I'll have time to learn both, since each of them consists of several frameworks that you also need to know in order to be able to utilize them like MEAN stack.
There are some other posts on the new ruby features, this is much more than that. It goes into the depths of the new changes and explains the why and how behind the changes. I loved the section explaining the new hashing. I knew it was faster before, but didn't know why until this post. Hope Jonan keeps up the good work and writes more of these. 
I don't think that's true, but if you do, pick Node. Your UX is going to feel antiquated if you only learn backend tech.
This is a great insight into the performance optimizations that are in 2.4. And really cool to learn about how hashes work internally.
yes, that's a fair point. I like it for smaller scripts where that doesn't make much difference.
Great suggestion. I think periodic refreshers on the style guide works to everyone's benefit.
I have read that it is faster.
Jekyll is very flexible, so you can build not just blogs, but all kinds of statically generated sites using markdown and liquid template tags to customize the generation. However, your store is still going to be static, meaning: - it won't be able to track inventory as there is no backend interaction. - Payment processing will be quite limited. The most you can do is setup a paypal link or html button. But you won't be able to process verification IPN POST notifications sent by paypal to your backend since there is no backend in a static site. - It won't be able to allow customer feedback for products like reviews, rating, etc. since a scripting language and backend database is needed for it. - Similarly, you cannot allow filtering, sorting, etc. of products (unless you maintain a static json file containing all the product details and process the filters using javascript which is extremely cubersome and tedious). tldr; Jekyll is a great piece of engineering, but a store or ecommerce app isn't a problem it was built to solve.
Yeah, in 1.8.7, things like `Module#methods` returned an array of `String`s; now it returns an array of `Symbol`s.
`each_with_index`, `send`, `class_eval`, `extend`, `call`, `method`, `lazy`, and `to_enum` all come to mind as very useful and misunderstood or underused
how about using https://ruby-doc.org/stdlib-1.9.3/libdoc/singleton/rdoc/Singleton.html ?
how about reading more than just the thread title?
Yes, those come in very handy sometimes as well.
I agree. But my team look at me like I'm an alien whenever I bring it up. 
What about `params.fetch(:page) { 1 }.to_i`? I don't think there's a good reason to use `[].try` instead of `fetch` when accessing a Hash. Both versions fail if the user sends you garbage (e.g. `"a"`), though. Because then the "default" is suddenly `0` instead of `1`. It would also allow negative numbers. Since consistently converting user input into the proper types was such a pain point (especially since we have to work with untyped XML), we recently abstracted it away. Getting the current page looks like this: NaturalNumber = Coercer.integer.then { |i| i &lt; 1 ? Coercer.fail("#{i} must be positive") : Coercer.succeed(i) } page = Coercer.pair(:page, NaturalNumber).default(1).run(params)
Really enjoyed reading this post. Hope he writes more blog posts like this.
Is that always a bad thing? No up side?
Awesome, sounds great! Given the scale of this change however, I think it may be a good idea to at least release a `2.0.0.beta1` (or similar) gem version, to help track any backward incompatibilities/provide an upgrade guide, before the big release. &gt; Another thing what I need to do is change TimezoneParser's storage backend from Ruby Marshal to SQLite ... Have you considered using something like [`PStore`](https://ruby-doc.org/stdlib-2.4.0/libdoc/pstore/rdoc/PStore.html) or [`YAML::Store`](https://ruby-doc.org/stdlib-2.4.0/libdoc/yaml/rdoc/YAML/Store.html) from the standard library instead, rather than introducing `SQLite` as a dependency?
I think I copied that `config.to_prepare` approach from [spree](https://github.com/spree/spree) / [solidus](https://github.com/solidusio/solidus) I think using `to_prepare` is as close as it gets to "officially supported" Rails way of integrating with dev-mode auto-reloading properly, so it _should_ work right, which doesn't always mean it will. :)
At least the design is responsive.
Used minitest, untill i realized rspec got much more gems and better toolkit.
MiniTest. I don't like the RSpec DSL, it's an aesthetic / simplicity thing for me personally. MiniTest does everything I need it to do.
Minitest - built into Ruby's stdlib, no dependencies, works great in unit test or spec form, many useful plugins (e.g. minitest-proveit, minitest-gcstats, minitest-profile, ...)
What's "the especially DSL"?
I used to not like rspec. i used minitest for a while. I was missing a bunch of things that were in rspec, that could be added to minitest sometimes, with some poorly supported third-party gem that conflicted with some other third-party plugin adding a different thing... yeah. I went back to rspec. And found rspec had gotten a lot better, more reliable, removed/deprecated some of the worst parts of it's API. If I were you, I'd use one on one project, then another on the next, and see what you think. :) But I no longer think it's so bad to use rspec, and it does seem to be the most popular choice in open source. 
I'm extremely biased, but I prefer to use neither. Instead, I use [test-bench](https://github.com/ntl/test-bench). Now I know that doesn't _technically_ answer your question :)
Domain Specific Language 
http://zverok.github.io/blog/2016-10-09-minitest.html
I know what a DSL is. I didn't know what "the especially DSL" was. The post has been edited, I guess it was a typo -- it wasn't clear before which one the author was saying they preferred.
I don't understand why you'd ever want to do this, and don't understand what Hash#fetch has to do with it. 
I remember Perl 4-5 very much like Python 2-3. Over time people migrated, but some from Perl to Python / Ruby. &amp;nbsp; I kinda like what Matz is doing with mruby, and the guys down south are doing with Crystal. The syntax for ruby and the "everything is an object" are what do it for me. &amp;nbsp; I look forward to some framework of the future where you write code in Ruby and the back end is compiled and super fast with something like Crystal, and the Javascript is complied using Opal(ish) something... in a sinatra / rails(ish) kinda way...
While it's not Rails 5 specifically, I once made a ruby on rails poster for a Kickstarter project: http://theautomatedstore.com/ Let me know if you're interested in it, I think I may still have some around. 
Ooo! I'm interested if you have extras!
I'd be interested as well if you have any :)
You should look at minispec. It's rspec style with minitest, built in
Used RSpec for years; converted over to MiniTest::Spec and not looking back. 99% of the readability of RSpec, 1% of the magic, and 2000% of the speed. If RSpec is a rifle shell, then MiniTest is an RPG.
Will do, thanks for the reference. 
Ha! The flag variable is clever. Nice post. My use case was some kind of parser which should either fail loudly or return a default value. I ended up passing a Hash with `default: x` around in order to figure out whether a default was provided, but I could've used a block instead just like `Hash#fetch`. Sometimes the most obvious solution is the hardest to see...
Ok, an infographic is doable. MVC, mailer, helpers, action cable and the likes... I'll see what I can do in the weekends, you can wait and/or give me feedback right? 
Okay man, best of luck!
As per the announcement, it is already compatible with the latest, although bytebuffers aren't used internally yet. I guess celluloid io tcp socket buffer operations are a good candidate for use. 
Hey, thanks for sharing this technique! We can't just extract the env vars, but we need to keep the reference to ENV, because when a Hanami project starts, it sets up env vars. Eg. `HANAMI_ENV`.
But that having `ENV` outside of `Environment` exposes the code to the same testing problems described at the beginning of my article.
Right, but you can apply the same principles behind extracting configuration settings out of ENV towards setting up ENV at load time. Modifications to ENV are actually a separate concern from controlling the components of the framework using settings derived from ENV. You only need to manipulate ENV _precisely once_, whereas the values of ENV need to influence many different components. This is what is lost, in my view, when you design one interface that allows for the querying _and_ the modification of ENV.
I pretty much figured. Just didn't know if this would be considered bad practice. Thanks for the input!
how about being polite ? I'm not harassing you for your post I'm just pointing relevant information to extend the topic knowledge base. If not for your benefit, then for someone who is reading the topic. Chill dude.
sorry dude
definitelly RSpec, due to the fact that you can do shared examples http://www.relishapp.com/rspec/rspec-core/v/3-5/docs/example-groups/shared-examples which comes a huge benefit in once developer is more advanced with the tool and he wants to clean up the test code base. Yes you can achieve the same thing with some Ruby plain object/ module inside Mini Test but usually these things end up a huge mess 
https://twitter.com/equivalent8/status/748218060016918528
You should try codewars
Rspec is an rpg, because it got a lot of useful gems. Meanwhile a lot of gems for minitest are not working, outdated, or poor in any sort. Sometimes riffle shell works, but often you need rpg to destroy the whole house.
If you're serious about landing a job at the sort of company that hires the kind of programmer that knows his algorithms, you should take a data structures course like the one at MIT (which is free). There's a quora answer on it here: https://www.quora.com/Which-is-the-best-online-course-to-learn-data-structures
https://github.com/rails/rails/pull/27494
i just discovered this and ruby koans and im hooked. ive only touched on ruby via puppet and more lately chef (im ops background) but im hooked on the katas in codewars, did 3 easy ones today but the testing thing got me so intrigued that i sat reading ruby the hardway until i could write my own tests
I don't know that TDD would ever really get you from merge sort to quick sort, or from straight BSTs to Red/Black or AVLs. Not knocking TDD at all, but once something is sorted TDD won't really push you for improving the sort.
It's a small library which helps with decoding values. It's just a glorified function from some input (mostly strings) to either a decoded value or an error message. &gt; I would expect the conversion of environment variable values into ruby primitives would need to be code that is special purposed Yeah, boolean encoding is all over the place. In case you need to map `0` and `1` to booleans you can combine smaller decoders like so: ENV_BOOL = (Coercer.const("0") &gt; Coercer.succeed(false)) | (Coercer.const("1") &gt; Coercer.succeed(true)) `&gt;` means: If left decoder succeeds, run the one on the right. `|` (read "or") means: If left decoder fails, try the one on the right. I plan to open-source it at one point, but I'm still changing the API on a weekly basis.
Jekyll is a very good solution for static websites, I have built quite few commercial and side project sites in it. For example, you can checkout [finite_machine site](https://piotrmurach.github.io/finite_machine/) and [code](https://github.com/piotrmurach/finite_machine.github.io). There is a plugin called *jekyll-assets* that adds Rails like asset pipeline capabilities. Alternatively, I have also used [Middleman](https://middlemanapp.com/) with great success which by default doesn't include any blogging capabilities. Middleman encourages webpack as a solution for assets bundling which works really well if you understand JavaScript build tooling like grunt/gulp. If you decide to go with any of these and have any questions, you can always ping me on twitter. 
Cool stuff. I'm interested to take a look whenever you get around to publishing it!
It's very natural to learn as a programming language. Usually you can just call a function with out knowing if it's there in the core lib, and it'll usually be there. Python feels like the opposite in fact, it tries to have syntax that look like English so it doesn't feel natural to program in. As a consequence it actually complicates things e.g. `[thing for thing in list_of_things if 'foo' in thing]` is cumbersome to understand and write, when the equivalent ruby is just `list_of_things.keep_if {|thing| thing.contains('foo')}`. I don't even know how I'd write the python snippet if I had a `else` clause. Mind you, C is my #1 programming language and a lot of concepts in python literally feel satanic (indents etc., which matter when copy/pasting code in the retarded interpreter).
Sedgwick's courses are the best. They're interesting, just humorous enough not to be totally dull, and information packed. Highly recommended if you can learn basic Java.
&gt; You can monkey patch things like crazy [Sinatra is the best example of this](https://github.com/sinatra/sinatra/blob/master/README.md#routes). It's very confusing at first because it doesn't even look like ruby, but the simplicity is unmatched. Another reason: 5\. A less annoying package system. You don't need a `__all__` in `__init__.py` (TBF, I can't decide if this is a good thing or a bad thing) 6\. Being able to call IRB from inside your program. ðŸ’–ðŸ’–ðŸ’–ðŸ’–
Thank you for emphasizing that it's 100% a personal choice which is "better". I meant to say that but I forgot to make the point.
Per the sidenotes in the blog post, Sidekiq 4.2.x had some painful issues getting it right but 4.2.7 has proven to be stable and Rails 5 seems to work well with it. It took 7 patch releases but we got it there eventually. *sigh*
Nice, thanks! Coincidentally you made this PR just hours before I started writing this blog post, unaware of it, what coincidence. I would have held off writing until I had read and assimilated this first, I'll try to do so and write another! (I've updated my blog post to direct people to the guide in the PR before, after, or instead of my discussion.)
yep if it's of any interest, I posted [a more comprehensive explanation of the situation](http://stackoverflow.com/questions/41390772/requiring-gems-with-bundler-require-actually-breaks-dependencies) in a Q on SO.
&gt; Metaprogramming yes yes yes a thousand times yes Not that Python isn't without its charm. I worked as a Python dev for 3 or 4 years before making the jump to Ruby. I still use python, just not for everything. If I'm writing an API or a server side web app I go straight to Ruby but I still love python for libraries like scikit-learn that ruby really just doesn't have an answer to yet. I firmly believe in trying to use languages where they work best and both have places they excel.
The whole "ruby way vs rails way" argument is petty. I don't resonate well with any of their examples, and the author seems to have an axe to grind over the simple tag line. The parts about "oooh no magic here, but wait?" really get me. Frankly when you compare a test written in plain minitest vs plain rspec, someone who understands ruby without a lot of knowledge of the underlying testing frameworks will have a much easier time understanding what the test does. A state is set up, and then things are asserted or refuted using regular, everyday base ruby expressions (or whatever libraries you may have included). Sure, you do need to know a few small bits about the minitest library, such as assert and refute. You might be forgetful of which argument for assert goes on which side, but even then, your test still successfully fails, and you are alerted to something being amiss, with a backwards message. The test file still starts off with requiring a framework. Just as with anything being included into your code, you should have a basic understanding of what it does. Minitest has far fewer visible things to wonder about. The article's main point seems to be to drag minitest through the mud for claiming to be more rubyish. They don't. They claim that rspec is a testing dsl, and that minitest is just plain ruby. I agree with this sentiment from the perspective that reading a test file is usually a matter of reading everyday ruby. It's true that the structure that allows spec syntax to work is ruby in its most beautiful ways. It is very rubyish in that ruby is what allows such incredibly expressive spec dsl. But reading and writing a test file requires much more knowledge of the underlying test frameworks to get cooking -- is it `expect(thing).to eq stuff` or `expect(thing) to.eq stuff`, or wait was it `thing.should be stuff` and does that space go here, or there, etc etc. vs a basic `assert thing == stuff`. And what's the point of the section talking about rails people hating blocks? That just seemed petty. One of Ruby's big high fives if that there are many correct ways to solve the same problem. I don't see the issue with using a lambda vs a block. It accomplishes the same thing. But more importantly, none of these points seem to be important in any meaningful way that convinces me that minitest is just as magical and perplexing as rspec. 
I love both Python and Ruby. You probably would instead want to use [filter](https://docs.python.org/2/library/functions.html#filter) for your Python example though if you don't like that list comp
One thing I love in Ruby is how blocks give a neat syntax to get rid of boilerplate. Let's say we want to go over every element of a two dimensional array and print out each element nested_array = [[1, 2, 3], [7, 8, 9], [13, 14, 15]] If we do this with each, it's a little unwieldy. nested_array.each do |row| row.each do |item| puts item end end And if we need access to the position in terms of columns and rows, it gets even uglier. nested_array.each_with_index do |row, row_number| row.each_with_index do |item, column_number| puts "#{item} is located at [#{row_number}, #{column_number}]" end end 1 is located at [0, 0] 2 is located at [0, 1] ... and so on We can clean this up very easily by writing a method that expects a block, and yielding each item along with its coordinate in the grid.^1 class Array def each_in_grid self.each_with_index do |row, y| row.each do |item, x| yield item, [x, y] end end end end And now iterating through the grid is clean, intuitive, and readable. nested_array.each_in_grid do |item, (x, y)| puts "#{item} is located at [#{x}, #{y}]" end This has use cases in file reading/writing, database connections, http requests, resource allocation, batch processing, device connections, general configuration, and much more. The other big reason I love Ruby is using ranges to sanely select substrings. my_str = "hello world" my_str[0..2] #=&gt; "hel" my_str[1..-1] #=&gt; "ello world" my_str[-3..-2] #=&gt; "rl" No more `my_str.length - 1` floating around, or making sure the `substr` function needs a length as the second parameter, or an index or anything else that is slightly annoying. This is due to a mixture of thoughtful string API and a neat syntax for range object literals. Range literals are almost always the first thing I miss when going to other languages. __________________________________ ^(1. It is ill-advised to "monkey patch" core classes like this, and even if you did, you'd want to add some exception handling like making sure the object is a rectangular grid)
Oh yeah, but I don't think it's idiomatic python?
In this case, I could have left off the `self.`. When Ruby sees an identifier (variable name/method name), it looks around for a local variable of the same name, and then for methods. This is why when you misspell a variable, Ruby says pust NameError: undefined local variable or method `pust' for main:Object Of course, if you try and use it like a method, Ruby will recognize that: pust("hello") NoMethodError: undefined method `pust' for main:Object Here, Ruby saw that you passed a parameter just like a method call, so it skipped right to looking for a method. I don't like to think about the difference, so I almost always put `self.` so that it's clear to future me that I'm calling another method defined for this kind of object. It also helps for the `[]` method, since `[3]` is ambiguously an array literal.
yep, ill be diving int chef in depth again soon, i put pause on it to get a better handle on ruby itself first as im hoping that will make me a lot quicker in writing recipes, but the whole kitchen/vagrant bit is very nice and a little more coherent than puppet so far im finding
&gt; &gt; You can monkey patch things like crazy &gt; Sinatra is the best example of this. It's very confusing at first because it doesn't even look like ruby, but the simplicity is unmatched. How is this monkey-patching? All I see are ordinary method calls.
You're right. Not sure what I was thinking when I quoted that.
I know several languages but Ruby was the first language I've used where I could guess the syntax and be right most of the time. On the other hand I would describe python as a decent scripting language with awkward syntax, so to each their own.
So is the deadlocks only an issue if you have class reloading on (e.g. in development) or would it happen in production if you forgot to use the new incantations?
Ruby is a very adaptive langue. You can write very concise code with functional paradigms or you can write code that reads almost like English. For example, Let's pretend we want to loop through an array that is defined like this: array = [1, 2, 8, 15] You could achieve that by doing this: array.each { |i| print i } or this: for i in array print i end or even this: (0...array.size).each do |i| print array[i] end All these are equivalent, and it's up to the programmer to chose which approach he wants to take, and this is just a basic example; there are many more throughout the language. The fact that you're not restricted to difficult syntax is really a plus. --- Ruby has return values everywhere! This means that it makes it easier to chain function calls to anything. For example, even a simple `if` statement has a return. This means you could do something like this: require 'date' greeting = if DateTime.now.hour &lt; 12 'morning' else 'evening' end puts "Good #{greeting}" --- Ruby focuses on simplicity over performance (but this doesn't mean the language is not performant by any means!), there are tons of aliases to make it easier for you to switch from another language, there is a lot of syntactic sugar which means it's really easy to make readable code, for example, if you have no arguments to pass to a function call, you can simply remove the parentheses, for example: Let's pretend we have a function def super_awesome_function() 'hello world' end The usual way to call that function would be to type `super_awesome_function()`, but Ruby allows you to do this instead: `super_awesome_function` and it just works. You can also chain function calls like so: `super_awesome_function.another_one.and_another_one` and so on. --- We're only scratching the surface here but I hope this enlightened you as to why so many people love to program in Ruby.
I personally wouldn't see that as a disadvantage. Ruby with python style indented blocks would be even cooler
Also take an operating systems class - a lot of it ends up being about algorithms for managing limited resources, which is quite applicable to all sorts of web work.
also `list(filter(lambda thing: 'foo' in thing, list_of_things))` is pretty horrible to write out
Classes are instances of the 'Class' class, man. Imagine that.
The deadlock occurs if a constant needs to be autoloaded, and it can't be determined that it's (thread-)safe to do so. Production has `eager_load` on by default (and explicitly disables autoloading), so it won't hit the first half of that condition. If omitted on long-running threads, you'd still leak database connections in production, leading to connection timeout errors. But that was already true on 4.2.
False. 
I wouldn't call them similar, i wouldn't. They look just a bit similar but sort of different when it comes to implementation.
https://www.youtube.com/playlist?list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb 
to me python is a decent scripting language with awkward syntax.
Given I have this list a = [42, 23, 3.50, 420] , I wonder how many things are in this list... In Ruby I'll just ask that object: 2.3.3 :001 &gt; a = [42, 23, 3.50, 420] =&gt; [42, 23, 3.5, 420] 2.3.3 :002 &gt; a.length =&gt; 4 2.3.3 :003 &gt; a.count =&gt; 4 2.3.3 :004 &gt; a.size =&gt; 4 I find that easy to remember, because yeah, thats just objects. It doesn't really matter which method I use in this case. I'd use the one thats English name answers my question the best, like "count". in Python, because "that's what programmers expect", I'd call a global(!) function called 'len()' with my object, which in most cases calls another method on my object called '\_\_len\_\_()': &gt;&gt;&gt; a = [42, 23, 3.50, 420] &gt;&gt;&gt; len(a) 4 &gt;&gt;&gt; a.__len__() 4 that is my example of how Ruby compares to Python. If you come from a C like (or whatever really) programming background you'll easily get python... but there a lots of people not with that kind of expectation on how a programming language should be. 
Awesome. Hacker Rank seems really cool. Thanks!
I'll have to try that method out. Thank you sincerely for the advice.
Wow, very helpful link. Sweet, thanks.
Indeed; I was assuming the alternative was "no incantations", not "other/legacy incantations"
Just tried it. This kicks ass.
**SSO is ruby 2.1.3p on rails4.1.4 with postgres on the backend** * gem 'omniauth' * gem 'omniauth-google-oauth2' * gem 'omniauth-oauth2', '1.1.1' * gem 'google-id-token' * gem 'jwt', '0.1.13' * and some stuff we wrote that i cant share :( **Permissions Services: same stack as above basically** * gem 'active_model_serializers' * gem 'activerecord-jdbcpostgresql-adapter', :platforms =&gt; [:jruby] * gem 'pg', :platforms =&gt; [:ruby] * gem 'foreigner' * gem 'lumber' * gem 'lograge' * gem 'rake' * gem 'paper_trail' * gem 'foreman', require: false * and of course some stuff i cant share here on private repos
I find metaprogramming fun and interesting, but it is a bit like masturbation, OK when you are alone, but unless everybody else on your team agrees, don't expose them to it. In all seriousness, the biggest cost of coding is the developers time. And on any project of any significant size, it is not writing the original code, but maintaining the code. If the average developer has to spend any significant time figuring out what you are doing, you are losing money or adding to your expenses. Many developers love meta programming because it is so cool. As you describe it, they love the magic. But in the long run, unless it is isolated in an area that you are not going to change (and then stick it in a gem) that nobody has to search for and understand, and I would say 9 times out of 10, that is NOT the case, don't use metaprogramming. Just code it out, even it if it is more code. There are exceptions, and when there are, document the hell out of it, remind people about it, etc. "Magic" is a nightmare in the long run on a project of any size other than "just me and my buddy".
I mostly agree. It's a very powerful tool, and therefore easy to abuse. Like that scene from Fantasia where Mickey tries to magic the brooms into doing his work for him but creates a mess that spirals out of his control immediately. When he should have just swept himself. Anecdotally, when I was a lead on a client project for a consultancy, whenever I'd take a sick day I would come back to find one of my bosses took a big metaprogramming shit in my client's codebase to solve a minor problem because they loved to "masturbate" with MP. They took it as an opportunity to tool around with some cheesy idea they've had for a while. And then a big piece of the application became a scary, untouchable 'legacy' morass in the same day it was introduced. It's worth noting they often bypassed our extensive code review process to do this, i.e. exactly the business procedure which ensures "everyone agrees" and understands it, as you say. I'm intimately familiar with the pain of maintaining an application like this. That said, I stand by my main point, which is that the metaprogramming facilities **can** act like a lever in creating minimal, **expressive** code. In the context of the question, I believe my answer was appropriate, but with respect to your comment I agree with your caveats. If you need to create an interface (e.g. DSL) or model some more abstract domain logic, then carefully applied metaprogramming may be on the table. Of course moreso than metaprogramming directly in a Rails controller method or view template (which I have seen).
While I loved foreach loops in Java and C#, the Java way does not read like English. Case in point, you had to write an inline comment explaining the syntax.
1. Probably 95+% of them are original. I have taken over a few projects (e.g. ffi-clang), or provided complete refactors of other open source projects where it was feasible (e.g. celluloid/timers). 2. I started writing open source software during my under-graduate degree, from about the age of 16, around the year 2000, but most of that was in subversion so I don't have many public records of this code, except a backup from my original SVN server which worked a bit like a crappy version of GitHub :) 3. This question is pretty hard to answer with a generalisation. I'll break it into categories; some projects are: (a) code which supports my work as a consultant (e.g. utopia, teapot) OR (b) code which I developed to solve a technical problem which I found interesting at the time, and continued to use/maintain (e.g. RubyDNS, Synco) OR (c) code which was developed as part of an academic endeavour/research (e.g. transform-flow, teapot). I'd say most of my projects fall into one of those categories, or (D) support one of the previous categories (e.g. jquery-syntax, trenni). 4. The day I stop writing code will be the day I die :) i.e. writing code to me feels like breathing and has been so since about the age of 10 when I first started writing code using GW Basic. I'm not always productive and especially now with several children it's a lot harder. 4a. The reason why I write code in the first place, is a combination of the above reasons + when I see an opportunity to write code, such that it will significantly improve upon what I'm already using or trying to do. I have no reservations against reinventing the wheel except when it's clearly not pragmatic given a set of business requirements. As a general statement, abandoned code makes me frustrated and sad, because for me I have an affinity towards code, on an almost personal level. So, I feel obliged to make code beautiful* because it makes me happy. (*) of course this is subjective but after 20+ years of coding and thinking about these issues I think I have a reasonable basis for objectivity.
&gt; Being able to call IRB from inside your program. how?
A better way to think about this is through asking a better question than "is this considered bad practice?" Suppose at your orginazation you've got 1 million lines of code. Would "don't nest namespaces more than two deep" have helped or hurt? I think the answer is obviously that it would _hurt_. If the rule cannot be helpful when there is lots of code, it doesn't make sense at all. It had been suggested that rails _routes_ don't nest more than two deep. This is because of the way it's router inherently works. A four deep nested route would include four IDs and the link methods would be huge. Thankfully, namespacing of code has nothing to do with rails anything, let alone routes.
I'ts finished now: https://github.com/ManuelArno/log_magic
You can use the block form of permutation and a swap object to perform the map, group, and uniq portions of that call with a single loop. ex: h = {} self.chars.permutation do |a| h[a.first] ||= Set.new h[a.first] &lt;&lt; a.join end
Monkey patching should be used as a last resort. But it's nice to have as an option. It's about having power when you need it - with great power comes great responsibility. I think ruby is more powerful than python. Power can be hard to define, but it's easy to see - compare python to basic. It's easy to say python is more powerful. Looking from ruby, that's how python looks - but not to the same extent. for me, I find pry to be the main drawcard. It is miles better than the python shell, and with it I develop applications a lot quicker. If some code isn't doing what I expect I put require 'pry' at the top of the file, and binding.pry in the problematic place. This drops me into the shell. So then I start experimenting with lines of code to do the next thing I want - I don't have to wait for the whole program to execute again - I can just keep tweaking stuff until it works. Even if you don't adopt ruby, it would be worth while getting to know your REPL. 
I have read some chaptersï¼Œlike the title implied it is a well written and fundamental bookã€‚If I had started with this one would have saved me a lot of timeã€‚Even though I have already know most of the aspects of rubyï¼ŒI still like to read itã€‚ If you wanna get quick solutionsï¼ŒI suggest The Ruby Wayï¼Œit reads like a cookbook. There sure is a cookbook by OReilly by the way. And the â€œEffective Ruby 48 tips...â€ is another good resource that talks about the best practice of rubyã€‚I like this bookã€‚ 
Alright this has 15 chapters,which is kind of doable,I will get to the Effective Ruby 48 tips after that,I guess its enough for me to become a amateur.
&gt;Things have changed Can you mention those changes in mere sentence?
Kinda hard. I could pull up the latest couple of Ruby changelogs. The point is, the syntax still works, the ideas are still the same, and Ruby is still as much fun to write.
If you want to try to beat the built-in, I'd suggest reading up on https://en.wikipedia.org/wiki/Heap%27s_algorithm which is thought to be the fastest permutation algorithm. Fair warning: you're racing C code in MRI, so it may not be easy. I don't know what algorithm Ruby's native implementation is using.
If you're going to learn Ruby, I suggest Well-Grounded Ruby-ist and Eloquent Ruby. I used those two to pick up Ruby in a couple weeks for an interview and job, and I still get compliments on writing very idiomatic Ruby. They teach the language and the good habits.
I went through the change logs recently as I restarted using Ruby after a long break. Mostly rough edges are gone and it is faster. Some things are in core that were extras before. Most changes are in the ecosystem as far as I can tell.
I think you will get about 10x speedup if you make a unique_permutation that operates on String directly instead of on Array. However, the permutations for 10 letters are gigantic, so there's nothing you can really do about that. Here's the code: https://gist.github.com/jawheeler/10a7417891610b06c7227d148ff4e24d 
alas. Seems like the performance hit is in the permutation and not the other stuff
I'm guessing that it's searching for possible words in a dictionary?
[This](http://patshaughnessy.net/2012/1/4/never-create-ruby-strings-longer-than-23-characters) might interest you, if you're looking to optimise strings.
I think the problem might be that permutation produces duplicates if self has the same character more than once. There's something on stackoverflow about [Cartesian Products,](http://stackoverflow.com/questions/15737065/unique-permutations-for-large-sets) but I'm not sure it would be any quicker than uniq. Otherwise, I wonder if uniq would be quicker against many smaller arrays rather than one large one (I guess it depends on how long the word is). In which case you could try... a = self.chars.permutation.map(&amp;:join).group_by(&amp;:chr) a.keys.each { |x| a[x] = a[x].uniq } Is uniq better at parsing strings or arrays of strings? self.chars.permutation.to_a.uniq.map(&amp;:join).group_by(&amp;:chr)
Congrats,can you share how did you began? the scheduling and time management?
[PDF](http://686d29de99549914971.c.it-ebooks.directory/e-books/manning/Manning.The.Well.Grounded.Rubyist.May.2009.ISBN.1933988657.pdf?l=kh_zpzGpX1wD9N_Tni-lxw&amp;t=1483361160) 
is this the latest version? Disclaimer- Sorry for pirating Mr Publisher I will send the money once I am hired with this skill.
Most people will list more advanced topics, bot for me there are 3 main points: * easy and well understood syntax * lot of developers argue that that syntax is not important. That maybe true if you building pet project for 2 hours over weekennd. But if you are stuck for 8 hours a day with a language then syntax is important * it's relatively easy to read the code you wrote (any syntax) but once you have to read and understand someone else code syntax is important * everything is an object * by everything I mean everything. String instance is a object ("a".upcase), Integer instance is an object (1.odd?) even class is an object ( MyModelName.model_name ) * explaining why this is awesome would take a long blog post. If you understand why "object composition" and "duck-typing" is more important than "class inheritance" then you understand the impotence of this point. If not it's worth looking into it. * really easy to test your code (yes that is important) * look at RSpec http://rspec.info/ 
Yeah, checking if anagrams of a string are in a dictionary 
Over 8 years as a ruby dev, I read the book for the first time in 2016 and it is still very relevant. You may want to augment it with meta-programming ruby, I forget the author, but those two are my current favorite ruby books.
What language syntax do you like then? I'm genuinely curious to see what you find more readable. Can you make a concrete example? And you can stay away from monkey patching. Ruby it's still tremendously productive without it. It's just a useful feature that must not be abused. Like every other feature in every other language. 
&gt;I personally don't think it is readable. I recently taught Ruby to a guy at work and this was his same complaint. It came down to it being a new thing. He loves it after some time to get acclimated.
Sorry, I should have been more specific. It is still true, but handling of string longer than 23 characters has been sped up such that it's not _quite_ as big a hit as it was circa 1.9.
 Dir['/some/path/**/*']
The start/end points aren't clear. The start should really be at the top left, it's more natural
How about "find" and "inspect/modify"? Model.find is the key ActiveRecord method, and inspect/modify is what the controller does with the models it finds...
By "server" I assume you mean something like nginx, right?
&gt; server Web Server, like nginx, puma or passenger, yes.
Goddamn beautiful! Great job Abhishek.
Good point, "find" and "get" sounds better?
There wasn't really any particular scheduling or time management. I read a few chapters of the books a night, started a rails project to familiarize myself a bit. I came in from perl, which is about 90% the same as ruby. Mine was just familiarizing myself with Ruby more than learning to program. 
Thanks PS: It's Abishek, common Indian mistake :P
You're already grouping by the first character. Grouping by all of the characters in the string instead shouldn't add significant overhead. You'll have a larger hash with smaller arrays instead of a small hash with large arrays. Additionally, that puts your overhead on app load vs on test case run, which is preferable in a real world scenario (because most of the time, you're going to be preloading your application, so the first time it's run will take some time, but additional runs will take almost no time at all). Real world, you'd probably also offload the storage of the dictionary to a database or a key:value store like Redis, which makes the optimization on the dictionary make even more sense. e: if you want to "cheat" subsequent loads of this application after the first, write out the hash as dictionary.yml that you can optionally load from if it exists. That's almost like using an external store.
nasty
Yeah, nice catch
I think they mean it from a written English (or other similar language) perspective. They're expecting the beginning of the flow chart to be in the same spot they would begin reading other content: the upper left corner.
I really like it! To me, the starting point is bit unclear. I think it would make much more clear for beginners if it would show the first action coming from user's browser and setting up everything else in motion. That is, if you want to show the actions in chronologic order, make this infographic about a "story of a http request".
I can show a person click on a link to start it off
I would look at how the twitter gem or facebook gem solves this problem and follow in their footsteps
1. I just developed my first app with action cable and it is new, so I only included the basics. Don't want to copy stuff I don't have any idea about 2. Again pub/sub is a redis function. So that thing will need a whole rewrite 3. I was going for CRUD and D stands for delete (maybe destroy too, but I've heard delete a lot) 4. I remembered redirect_back using a call to HTTP_REFERER. I believe it doesn't need to check the table. correct me if I'm wrong 5. The web servers like nginx use rack. will label it as such. Maybe another rails blobby to show rack :D 6. I am going to experiment with gradients. The thing in my mind is beautiful and I am not able to get it. Need to check design sites. I am gonna do another updated one in a week's time, as I have got a lot of comments. Prepare to have some of your ideas ignored even though I appreciate every one of them, time + space constraints
Different kind of response. Gonna use a different name 
Give the redditor the xbox! 
Thank you! I tried taking a look into specifically GitHub's API Wrapper but it was rather verbose with the problem so I wasn't quite sure exactly what I was going through until I hit a high level of abstraction.
[deleted] ^^^^^^^^^^^^^^^^0.7007 &gt; [What is this?](https://pastebin.com/64GuVi2F/08636)
I still think it's easiest to understand like that as a flow chart of where a request starts, what it causes, and the round trip where it returns as a response. regardless, awesome job!
Hey u/jrochkind! Thanks for the comment! It won't do anything different from the ordinary `rake db:migrate` if you have all your migrations in the same folder, but if you separate the migrations in different folders (the `data` and the `migration` folders) you can't run the normal `rake db:migrate`. As for your second question, you can run this in a non-Rails app but it won't run in a non activerecord one.
So the point of this gem is just to let you split migrations between `./db/data` and `./db/migrate` that's the only thing it does? OK, I'd suggest you make that clear in your write up, it wasn't clear what the gem actually did from the writeup. 
&gt; I still think it's easiest to understand like that as a flow chart of where a request starts, what it causes, and the round trip where it returns as a response. &gt; Where do you think I took inspiration for this info-graphic? :D
We could race 2008 MacBooks if you want :p I don't think there's a race condition for LiveReload; write to disk =&gt; middleman filesystem watcher receives event =&gt; middleman recompiles the necessary items =&gt; pushes refresh signal to pages Even in cases where the last step doesn't occur, requires a manual refresh, it's always been pretty on the ball for me. The time needed to switch over from editor to browser and hit refresh is sufficient that the new content will be delivered. If you start the refresh immediately on filesystem event, such as what I think you're describing (between phone and old conversation, my context memory here is not top notch), then it's certainly possible to complete the request before middleman finishes the rebuild. So I would advise not having both LiveReload pushes *and* an external refresher going. Regardless of how you refresh the browser, though, the compilation stage is the bottleneck. So you may be fine just putting a half-second delay on your plugin. &gt;RVM I ran brew upgrade, realized it broke, filed a bug report with Ruby, and then I went home for Christmas and didn't look at it for a week. I am not using RVM, but if it's not patched by now I will shortly.
A lot of suggestions to topple the image, I will look into that. Don't wanna include a cloud because I feel the server does the job (local or internet whichever) lovely tips regarding the labels I will make sure the next version doesn't disappoint (may take me a week now that I have so many suggestions) Thanks for the kind words. PS: I don't wanna label the start and end as this is not meant to force you to follow along, rather get an idea of how the things you use are connected together
redditor for 11 years and only 120 karma, I feel proud that I made a lurker like you take your valuable time out to help me :D
I'm not saying you have to put an objective starting and ending point, just that the part where the request gets generated and response gets returned should be the first point the reader sees. If you're not going to put a logical start and end point, why set it up like a flow chart?
:)
Ok and Ok 
You're right, fetch is the better option for working with hashes. I had forgotten that somehow. I wish I pr reviews like this comment :)
Try Clojure and Elixir. Macros make Ruby metaprogramming look contorted.
The same goes for Scala's implicits which hold me back from learning what is an otherwise excellent language. I can't imagine keeping track of a large project within a decent sized team where everyone is allowed to pepper their code with implicits.
Although Ruby is an OOP language this live repl feature of Pry is possible because of Ruby's lisp heritage. Try Clojure and you'll see how deeply live coding is embedded in the culture. Both languages are based on everything being an expression, as also with Elixir, which differentiates them from Python where an explicit return is always required.
Wow this is pretty good ðŸ˜‚
X-Post referenced from [/r/freeebooks](http://np.reddit.com/r/freeebooks) by /u/jarglue [[pdf, epub, kindle] "Ruby Web Dev: The Other Way" by Ievgen Kuzminov](http://np.reddit.com/r/FreeEBOOKS/comments/5lpc5x/pdf_epub_kindle_ruby_web_dev_the_other_way_by/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
The most frustrating thing about the Ruby community for me is the fracturing. MRI is desperately in need of a makeover regarding concurrency and performance and another group just goes and makes a "Ruby-like" language - Crystal - which solves all the performance problems but which is incompatible with MRI. For ****'s sake, why didn't they think to join forces with Matz and solve Ruby's problems together instead of producing what is basically another fork? Rubinius was another excellent project but damned into insignificance simply because it doesn't connect with MRI. JRuby is different in that it measures itself with MRI compatibility. Ruby at least has a very active JVM implementation which has greater adoption than Python's equivalent, Jython.
It would be interesting to test this with larger files, perhaps ones that exceed RAM.
/r/rails seems to have turned into nothing but stack overflow style self post questions from newbies. 
There is periodic tasks within enterprise version of Sidekiq. https://github.com/mperham/sidekiq/wiki/Ent-Periodic-Jobs#definition It does seem that the configuration is somewhat similar to `sidekiq-cron`. However, I've not looked into the enterprise version to really see how the two differ.
ruby is already on your mac. download the script, open your Terminal app and run this: ruby ~/Downloads/emoji-extractor-master/emoji_extractor.rb &amp;&amp; open ~/images 
In the grand scheme of things? Compared to Haskell, Scheme, C++, Javascript, Elixir, Go, Rust, or even Java? They're pretty similar.
The ongoing popularity of the feature led me to build it into the Enterprise version. While I like the simplicity/robustness of Unix cron, my version does have a nice advantage: it scales across many machines. With cron, you need to designate a single machine to run periodic tasks which is a SPOF.
Will do
I've been using sidekiq-cron in [LibHunt](https://www.libhunt.com) since its beginning, and so far it's served me flawlessly. To be honest, I've faced one issue. If you rename or remove a class used by sidekiq-cron, you should remove its relevant entry in advance - before deployment. Otherwise, the whole sidekiq-cron would be broken. 
The main difference between sidekiq-cron and whenever is that the second one relies on CRON to trigger execution and the first one emulates it.
No, not too long. Interesting take. I'd no idea Matz contributed anything to Crystal. Kudos. Crystals is awesome, it has to be said. Just a shame it couldn't have been the New Ruby without MRI having to die.
Perl killed itself in many ways. Endless bickering about meta-object protocols and keeping OO out of the core, Perl 6 next Xmas, version boilerplate at the top of every file (still in Perl 6), "my $var" and Catalyst - the 10-ton abomination which had no chance of competing with Rails. Mojolicious was nice but the damage was done by then.
Thanks a lot!
DDD has always felt bloated to me. I agree with a lot of the underlying principles, but do you really need another slew of patterns?
if you read the file, why the "w+" mode?
&gt; Did you use something like IO.read(file, length, offset) or even gets(limit)? I used File#read(length) in combination with File#pos &gt; I'm curious to know what did you use then? What I mean is, you can't use stuff like File.open('large.txt','r').each { |line| line } when reading in reverse as that will end up reading the whole thing into memory. You will have to do the line extraction manually.
Get it from [Leanpub](https://leanpub.com/rwdtow), as it's the site where the author originally published the book.
I just want to be picky and add that, while comments are useful, cluttering your code with them isn't. You don't need to comment on every method call, if it's explicit enough, the code explains itself, that's the Ruby philosophy. Also you might want to read the Ruby style guide (Google it), it'll help you make self-explanatory code. Otherwise, not much to say. Great work.
`acc1.withdraw(-50)` this will add 50 to your account instead of withdrawing it.
&gt; Is ruby/ruby on rails the right language for me? There is a vast spectrum between completely right and absolutely wrong. It is in that spectrum, as is everything else. What you are describing is really agnostic of language. You have described a set of business requirements, not technical ones, which can be fulfilled by any language. There are some details that need to be thought through before you make a language choice. Why push pins? I'm guessing thats the current real solution, but you can do more when you go into software solutions. Like scale polygons that represent themselves and the space needed to work with them on the scale floor plan of the shop. How will users use this? Will only managers use this? Could the scrappers enter data on the pieces as they scrap them? They could even do barcode or rfid tagging as they scrap them, so you can do better inventory management; but this isn't something that scales if only the manager uses the application. How will they use this application? Is this an app on the manager's iPhone? Is this on the manager's Android tablet? Both? What about a web browser on the manager's desktop? Where can they use it? Can they only use it in shop? Can they use it from home to review inventory, etc?
Damn, this seems way more complicated that I was expecting. Maybe I'm not even ready for this project. Or maybe I'm just thinking about doing it the wrong way. All I want to do is be able to make a site where I can input data, and have a ruby program do stuff with that data once I submit it. Am I making that too complicated by storing the input in a javascript variable? Is there an easier way to do it? Here's my project if you're interested: https://github.com/idynkydnk/speed_sheets
Not possible because ruby and js are run in completely different places. Ruby (or some other server language) is used to return html pages in response to a browser request. when the browser renders the document your js is run in this context and only has access to the html document, not your server context. You can get ruby data down to your js by embedding it in the document and parsing it when the document renders (like gon does), but you cant pass data back up to the server without making another request somehow (Ajax)
Dont get overwhelmed, you are off to a good start. You have the beginnings of a webpage there, but if you want to do stuff with your data using ruby you need to build an application that will live on the server and not just in the browser. Then use AJAX to send the data to your application where ruby can save it to the database or manipulate it somehow Check out Ruby on Rails, or Sinatra for this purpose. They are both web application frameworks built with ruby that will allow you to accomplish this. Also you may want to brush up on some basics if you are feeling lost. I always thought [bentobox](https://bento.io/tracks) was a good resource. Start with fundamentals and work your way up.
Depends on the audience. For some really entry-level reader, this might be a nice albeit misleading read. For everyone with a bit of background in the topic, the extreme over-simplifications and errors are a sign that the author has problems understanding the topic.
Yes it's definitely geared toward beginners and is intended to be extremely simple. Like I stated this is my first attempt at writing anything about Ruby or programming in general. What errors did make so I can correct them?
I would start with some tutorials to learn the basics. Rails is great, although it can be a bit overwhelming at the start when you don't know about the driving concepts behind it. I'd suggest to checkout sinatra, another web framework for Ruby. Specifically, I found this tutorial here (https://code.tutsplus.com/tutorials/singing-with-sinatra--net-18965) which posts a basic form. Sounds a lot like what you wanna do.
Nice job, the only thing I can add is that "speed" is good, but "theoretical speed" is better. 
nice blog - congrats on your first post. I like the blog formatting. how did you make it: jekyll? and what else?
&gt; Big O Notation is a metric to measure the speed it takes to compute an algorithm. It's not about measuring speed. It's for classifying algorithms with regards to their behavior for changing input sizes. Example: an algorithm that is twice as fast as another algorithm has the same Big O. Further in, you give a good example yourself: &gt; The hash could have a thousand items or ten thousand items in it and the speed will remain constant. That depends a lot on the hash implementation but in general is not true. A hash with more entries (e.g., enough to over-fill some used slots but not yet enought to expand and rehash) will perform slower than a smaller hash. Albeit there is an impact on speed (and it can be quite large), it's still O(1) since it's usually implemented so that it doesn't depend on the input size on a large scale. Its limiting behavior remains constant. &gt; O(n) mean the algorithm will increase linearly depending on the size of the data structure. If 10 elements are added onto the data structure it will take 10 times longer to compute. If 100 elements are added it will take 100 times longer and so on. That's not correct at all. Example: linear search in a linked list. If you add 10 items to a list of lenght 200, it certainly doesn't take 10 times longer to search. &gt; O(n^2) is very similar to O(n). Except for every element added to the dataset the amount of time increases exponentially instead of linearly. Apart from being just as wrong as the O(n) case, the sentence itself isn't very helpful. What exactly would "exponentially instead if linearly" mean to someone who has nothing but your article? I add 10 and it increases 100? But what if I add 1? What happens if I add 1 ten times? It's a very theoretical subject and discussing it casually without making factual errors is kinda hard. 
Thank you. Yes I realized I made quite a few errors, that part has been taken out. 
What does big O have to do with any particular language? edit: typing on phones
i feel postgres is overkill here. sqlite could easily handle this kind of internal need. 
I learned a lot from this comment. So thank you. This comment should be at the top of this post. It's too bad you came off as so harsh and condescending in your parent comment. Maybe next time don't do that
You could use account_number = (@@last_assigned_account_number = @@last_assigned_account_number.next) but as yefrem pointed out, the assignment is important. "foo += 1" is a conventional shortening of "foo = foo + 1". 
One pedantic nit: Hash-based maps are *best-case* O(1) for accesses. Most implementations use tombstoning or bucket-chaining, which result in O(n) accesses during a hash collision. Array insertion is a good example of a uniformly O(1) operation. Great work on the post!
Nothing,the big O notation thing is inherent to all programming languages. OP is telling us that the blog article has ruby examples.
similar school of thought as /u/montas -- I put service objects into something like /app/services, but i name the classes and files as actions: send_notifications.rb, etc. However, i'd suggest not treating everything as 'business logic', and distinguish services from queries, representers, and so on. Here's a great overview of how to organize these different types of functions: http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/ Hit me up if you want to know of gems that implement many of these patterns for you. 
just saw this post after i gave the same link! its really changed the way i organize code now.
Understood, but who can't identify a loop
Thanks for sharing. I'm a begintermediate rails developer, but come from a very manual, tsql background. I've often read about people complaining that ActiveRecord is horribly slow. It gives wonder to how much of this sentiment stems from not paying attention to and respecting the database level, and allowing the db to do the things it does best. 
Is Postgres really not smart enough to store a "count" metadata field or jump directly to a row offset? Those seem like seriously low hanging fruit for optimization
A count field is somewhat difficult to keep track of in the presence of transactions (also, since 9.2 it can use indexes to do a count). How would you keep track of a row offset, except in the simplest of case? The query could be a join, could be sorted in a non-default order (in particular it's always bad idea to ask for limit/offset without specifying an order, you really don't want to depend on what the DB decides to send you back) and the state is not kept between queries (even if postgres could do that, there is nothing guaranteeing that the results won't change between now and the next query and it would be unlikely that ActiveRecord would support it as that is rather DB specific).
&gt;The query could be a join, could be sorted in a non-default order In case it doesn't have joins and complex conditions and orders, I assume it can use indexes for counting and limit/offset also (didn't try). But here's another thing I found in docs: &gt;PostgreSQL will take advantage of available indexes against the restricted field(s) to limit how many records must be counted, which can greatly accelerate such queries. PostgreSQL will still need to read the resulting rows to verify that they exist; other database systems may only need to reference the index in this situation. Sounds like "index-only search will help but not much"
I can't say I've ever personally used it but I think it catches most of those cases. The guideline it uses is this one https://github.com/bbatsov/ruby-style-guide but can be tweaked to your liking. You should also be able to tie it into whatever editor you use so it automatically checks every save as well.
[httparty](https://github.com/jnunemaker/httparty) is also a popular HTTP client gem.
Postgres tries to give you a count of the records visible to the transaction you are in. That means it has to visit all the rows. It sucks. If you are willing to put up with some fuzziness there are other ways see this article https://www.citusdata.com/blog/2016/10/12/count-performance/ 
This is more about postgres than AR in general. 
I've [written about this before](http://gavinmiller.io/2013/active-records-dirty-little-secret/) and there are some techniques like using `pluck` &amp; `select` to get your data which reduces some of the instantiation &amp; allocation costs. Unless you're hitting ridiculous scales, or writing queries poorly, ActiveRecord's slow spots shouldn't be noticeable.
Amen on rubocop
Somone make an issue on the pg repo.
and it there any linter which would catch it? I'm mostly interested in typos like `service` x `sevrice`. I understand that in something like ruby this can never be 100%, but at least partial must be possible.
If you have a main entry point to your program you could put it there, but... If you put it in each file that requires the behaviour, your test suite can still (possibly) test those classes without loading your entire app - this isolation can be a good thing design-wise if you can pull it off.
Only using it once or twice, I'll require it at the top of the file I need it from. If I end up using a library throughout most of the codebase, I'll require it in my main project file (lib/foo.rb or something). If you're using Bundler and/or writing a gem, you can auto-require all of the gems in your Gemfile (or dependencies in your gemspec) by calling `Bundler.require(:default)` early on in your codebase (probably at the top of lib/foo.rb): require 'bundler' Bundler.require(:default) See here for more information on `Bundler.require`: http://bundler.io/groups.html
If a simple `select count(*) from table` query is actually expensive (and _more_ expensive than `select count(*) from table where column = something`??) -- that seems like a pg problem. Is this really true? I think of that as being a very cheap query, have I been wrong?
&gt; That's true everywhere, but very few people hit deep pages. Except robots, you need to tell robots not to do that. I've run into this before. How do you tell the robots not to that (without eliminating the possibility for -anyone ever- to do it, which is fine if that's acceptable, it was not in my context). I hadn't figured anything out. 
Sure, there are probably some settings to make it not totally retarded - as currently it actively enforces really dumb things. Then again, does anybody really need style enforcement? It's not C++.
`rel="nofollow"` on all pagination links comes to mind as the first thing to try.
&gt; The place where you'll probably want to disable/modify a lot of the rules are the "Style" cops. I did quick search how to do that, and I should use `.rubocop.yml` for that, correct? Is there a way to override default values? So I can write one (e.g. `~/.rubocop.yml`) with my preferences and just override some for specific projects? I didn't found anything like that :/ &gt; FWIW, I usually agree with bbatsov even on the style cops but quite often it isn't practical for us to follow them. I agree most of them seem reasonable, first I don't agree with that comes to mind is whole `spaces x tabs` thing, I use tabs.
The problem is that 90% (I'm exaggerating) of Rails goes through `method_missing`. Until you run the program you can't know that `sevrice` won't do something sensible. It may be obvious in that little example, but I don't think it would scale up to real Rails applications.
I don't remember if I actually tried that one. I may not have, becuase in general `rel="nofollow"` is _not_ reliable for preventing bots from following to crawl. It is fairly reliable to prevent bots from _indexing/exposing_, but they crawl anyway. Google promises nofollow links won't influence pagerank; they don't say they won't crawl them. But I guess it would probably reduce the crawling anyway. i wish robots.txt was more expressive than it is. 
&gt; Then again, does anybody really need style enforcement? It's not C++. Style enforcement is important in every language. Obviously if it is just you working on the code it is less important but teams should always have style guidelines and it is much easier if they are enforced by a linter.
&gt; Rubyists in general use two spaces. oh I know and I don't mean to push tabs on anyone. I just wonder if I can change defaults of rubocop (this should be useful for bunch of things beside space/tabs), I find it hard to believe it cannot be done
&gt; Style enforcement is important in every language. And the research proving this is... It's not. It's total waste of everybody's time. People switch between five languages in a single program, check twenty gems written by different people, and nobody has any problems with that. It's mindblowing to believe that it matters if one person on the team uses `''` and another `""`, or other such nonsense tier stuff style enforcers check.
If it were so simple to get right, someone would've done it in Pg's 20 year history, don't you think? It's the price they pay for MVCC. 
I tend to think about dependencies as I think about function parameters. When a function uses a parameter, you have two options: either you add the parameter in the function declaration, or you use an upvalue (a variable which is available on the function's method - this might be a global variable, or something else) def doSomethingWithParam(x) x + 1 end ... doSomethingWithParam(1) # =&gt; 2 y = 0 def doSomethingWithUpValue() y + 1 end doSomethingWithUpValue() # =&gt; 1 My main argument is that the second option, `doSomethingWithUpValue`, is worse. First of all, `doSomethingWithParam` is a [pure function](https://en.wikipedia.org/wiki/Pure_function), while the other isn't. Pure functions come with their own set of advantages. The other reason is *explicitness*. The examples I used are sort and trivial, but if they were longer and more complex it would actually be difficult to "catch" that `doSomethingWithUpValue` depends on `y`. I think the same happens with files. If a file uses something defined in another place, it should be explicit about it. When they do this, you can know what depends on what just by reading the top lines of the files (just like you know what params a function has just by reading its declaration). You don't have to "hunt down" your dependencies across the source code. So my advice would be: if you use something inside `lib/foo/bar.rb`, you should require it there. If you use it several times, in several files, my advice is to require it several times in several files. There are exceptions to this rule; for example if you are developing a rails project with a Gemfile, all gems included in that gemfile are available as globals, so it is idiomatic to not require them (I'd prefer that they were- for the reasons stated above. But advocating for that would be swimming against the tide).
always this - you want each file to be able to test in isolation where possible that might mean creating some empty test class to test a concern but you'll almost always get benefits later of not having everything mixed in together
Yeah, I used to think it was cool to build rubocop into the CI path. To be fair, it did identify a PR or so that used tab indents or something. But it broke like four times with new cops that suddenly half the codebase didn't comply with. I'd make a one line commit fixing a comment and suddenly half the codebase would fail CI.
I think it's always best to `require` what you need in the file that needs it, so in your case if `lib/foo/bar.rb` needs `CGI.escape`, it is the one that should `require 'cgi'`. I know Rails has the idiom of requiring everything in `config/application.rb`, but I think that's more lazy than a useful convention. E.g. one downside is that all gems will always be required on startup, even if some gems are required by specific files that aren't yet autoloaded on startup, adding to the app boot time in development. I tried to explain the advantages in "[Require only what you require](https://twin.github.io/require-only-what-you-require/)".
I don't see any value in using shared examples here. (I don't see any value in using them ever, actually). Rather than focus on test framework features and idioms, it's more useful to take a step back and think about testing from an interface perspective, not an implementation perspective. It feels good when our test file that was unruly seems to snap into place with deduplication, but in this case I promise that test features like shared examples are not going to improve this test file. What is different between CA and OR? The sales tax _rate_ varies. If the sales tax rate is a concern of `Invoice`, then I might have a test permutation per state. It actually gets much worse in real life. Income taxes can vary regionally within states. The items that are or are not subject to sales taxes can also vary. And, really, are Invoices the _only_ part of your software system that are prone to needing to apply sales tax? For both those reasons, I think you want to invoices to deal with the concept of sales tax in abstract. To put it in concrete terms, you want a test of an Invoice to check that sales tax is _applied_ to the line items, but you _don't_ want it to test that it got the right amount. If you were introduce an abstraction for calculating sales tax, you could test that abstraction in isolation. Feed that object a location and an amount, and it spits out a number. Here's an example (note that I do not use RSpec nor do I use FactoryGirl so I am doing my best to approximate their syntax): describe "Sales tax calculation" do amount = 100 apply_sales_tax = SalesTax::Apply.new context "CA" do location = FactoryGirl.build :location, :ca specify "Amount is 8.75%" do amount = apply_sales_tax.(amount, location) expect(amount).to_equal(108.75) end end context "OR" do ... end end Now you just need to to pass in an instance of `SalesTax::Apply` to `Invoice` and you can test that invoices apply sales tax without getting into any of the permutations of state tax rates. Better yet, because you can control the particular implementation of the sales tax calculator into `Invoice`, you can pass one in that always applies a flat rate, no matter the location. All of this ends up reducing duplication far _more_ than shared examples, simplifies the implementation of `Invoice`, and allows sales tax calculation to be used elsewhere.
Would you ever just require the module in each file that requires it and also in your `test_heper.rb`?
Can you present your current best solution?
An Alternative for multitenancy could be the apartment gem. I use this for some time now and quite happy about it. I'll give this gem a try for the next project. 
&gt; If you have one left at the end then that is your answer. I'd double check your logic here, as well as revisiting the instructions on what the method should return. 
Fails for me?
Not just low-budget. They should be used even when paying lots of money for someone to check. (Fixing these issues prevents them coming back with lots of things to fix and then having to pay them to recheck once you've fixed the first round.)
Are you running in Windows too?
rubocop --auto-gen-config will do that to a certain extent. It creates a configuration that excludes files that fail each cop. Basically resetting things to where everything should pass, after which you can go through and enable/disable anything you want. I -think- we still ended up having to hand generate a file to disable the ones we just didn't want at all though.
Ruby sounds like a great choice for your project. The projects I wouldn't choose it for would be very large systems or very performance-critical systems. Note that you could always start with Ruby for those pieces and optimize later too. That, in my opinion, is the best reason to pick Ruby - get from zero to running quickly and then you can figure out bottlenecks later. The Ruby ecosystem is extremely good for learning, 3rd party gems, and community support. Plus Ruby is just a joy to code in
&gt; a configuration that excludes files that fail each cop Yeah... that doesn't really solve the problem at all (for large projects). I'd just end up with 1000s of files being excluded, which sweeps all of the problems under a rug. &gt; I -think- we still ended up having to hand generate a file I've heard people claim this many times before (and how "easy" it is), but unfortunately I'm yet to actually see a sensible, complete, baseline configuration :(
One approach is to require everything in each file that needs it. This hypothetically means that every file can be independently loaded without hitting an error. The problem is this is hard to do in Ruby because it doesn't have compile-time checks for this sort of thing. So you could have one file `require 'cgi'` and another file not and as long as the first is loaded first then you'll never have know that it's missing in the second. A second train of thought is to do everything up front. This has the advantage of having one place where all dependencies are loaded. As long as that entry point is loaded first then you'll always be fine. It also avoids the possibility of missing a `require` and getting an error based on the order things are loaded Neither is strictly correct. I prefer the first approach because I sometimes like to do crazy things like explicitly require only single files from libraries, it helps me manage my dependencies better, and I'm (probably overly) dogmatic about loading as little as possible into my run-time as possible. In a real production app though, you tend to just load entire libraries a lot of the time and it tends to not matter 90% of the time
I'm the CTO of nVisium, and we specialize in Ruby on Rails assessments - https://www.nvisium.com. Although we're not as large as some of the consultancies mentioned on this thread, we've done a lot of these assessments and been immersed in the Ruby/Rails community for years. We typically use what we call a "Hybrid" approach where we both review source but also have the application running locally. This approach allows us to trace interactions (into the gems if need be which, seems to be the case fairly often) and get a granular view with regards to the application's behavior. Most importantly though, we can provide very specific fixes (code snippets) in our reports. One thing we can speak to, from experience, is that finding issues isn't enough. There is just as much value in helping understand the actionable resolution of the problem (and not in some generic, high level summary fashion). https://nvisium.com/blog/2016/01/26/rails-dynamic-render-to-rce-cve-2016-0752/ https://nvisium.com/blog/2014/03/28/reflected-xss-vulnerability-in-twitter/ We've also led the OWASP Railsgoat project for several years (although, this project needs a bit of an update): https://github.com/OWASP/railsgoat Also, we have some Rails security content up on our YouTube channel - https://www.youtube.com/c/nvisium. Whoever you choose, I'd suggest obtaining references, and having them explain - in a detailed way - exactly what they are going to do for you (and ask about how they help with resolution, make them be specific). If it feels like you're getting a sales pitch and they are purposefully shying away from answering your question then walk away. My .02 cents.
Thank you. Any recommendations for further study after "Learning Ruby the hard way"?
Thank you. I have really enjoyed it so far. Any recommendations for further study after "Learning Ruby the hard way"? 
Check out [Agile Web Development with Rails](https://pragprog.com/book/rails5/agile-web-development-with-rails-5) -- I haven't read it since version one, but it was great then, and I bet it's still great. :)
Is there a reason you are trying to build Ruby yourself instead of using Rubyinstaller? https://github.com/oneclick/rubyinstaller
You're better off trying to help rubyinstaller get 2.4 working. It's a non-trivial process and even if you get Ruby to build you'll have a whole other can of worms to fight with to get gem C extensions to build. Ruby is not well supported on windows, most users work on linux or OSX. 
Check out the Rails section of [The Odin Project](http://www.theodinproject.com)!
So your attendance is growing but you feel like it's dying? How does that make any sense.
Excellent response, thank you for pointing out FP issues. I've been bitten by them before so, OP, do please take this consideration seriously. This subreddit does have a tendency to be biased towards rails, but hey, can you blame us? 
&gt; A count field is somewhat difficult to keep track of in the presence of transactions (also, since 9.2 it can use indexes to do a count). I don't understand. Why can't the count field be part of the transaction machinery? Why can't `count(*)` be implemented as `count_when_transaction_started + count_of_new_rows_in_transaction` or something like that?
Conferences tend to be cyclical. I have volunteered and help run a few. I don't think the conference scene is dying, nor is the Ruby space saturated (IMHO). To get back the feeling of newness or thrill, you might try mixing things up a bit. I don't know the format of your conference, but good luck! PS: whatever you do, don't jump over a shark while on water skis :-)
&gt; I'm trying to build ruby on windows A fool's errand that is. I'm sorry that I don't haven anything helpful to contribute but I advise you to save your time. Even if you managed to build it, I bet you would run into some annoying and very hard to track down bugs. Native gem extensions? Forget about it. Ruby actually works decently when installed with rubyinstaller and used via mingw, though I advise you to install it somewhere that doesn't require administrator privileges.
I'm curious too, the only Ruby conf I went was RubyconfPT as well and I left with the same feeling, this didn't leave me with much will for other ruby confs
thats what I said...
Oh, duh, sorry, a bit too sleepy.
Well last conference I was at was RubyConf in Cincinatti and I had a blast. It was plenty packed and a good array of talks.
Me too! Looking forward to New Orleans!
Did you try emailing him before you put this post up? If dude decided to reduce his public footprint on the internet, you've done him no favors Edit: damnit, curiosity got the best of me. I googled and found some pics in the news of him. He appears to be well.
Nice try, _why.
I can't speak to this year, but the RubyConf in San Antonio 2015 was great. Good talks, good times. I didn't go this year because my Co. wouldn't pay for it. Personally, I wont go to another RailsConf. Not a huge fan of the Rails way and the DHH cultists and I don't think there is anything there (other than finding a job, great place to network and recruit) that you can't get on line, later. I feel like it doesn't have the real spark of "Joie de vive" that Ruby has. Bit of a nonsequitor, but I think for Ruby to really grow it has to move in more of an FP (FOOP? along the lines of dry.rb) and add multiprocessing, which I believe is coming soon. That will reinvigorate some of the people that are leaning toward Elixir 
shit like this is the reason i publish all my code pseudonymously
Shit like what?
&gt; He appears to be well. I'm glad that is the case, thanks for digging.
Magic. That's the problem with Ruby. The developers rely on it and become too accustomed to it.
Same here,! I was talking to Michael Hartl at RubyConf and he told me his favorite one so far has been at New Orleans a couple years back. Should be fun!
How do you volunteer for a conference?
I'm not sure about this specific case, I'd have to spend a lot more time reading the code and algorithm to suggest a name, but I can tell you that in all my years coding there's never been an exception to the rule. Comments are always inferior to well-written code. I think what might help this scenario, though, is documentation through test coverage. I often refer to specs to get a better understanding of code. They have English descriptions and expected behavior written in, and are usually guaranteed to be accurate because tests aren't allowed to be red.
&gt; Isn't there interesting stuff to talk about anymore ? [Ruby 3x3](https://blog.heroku.com/ruby-3-by-3/) Maybe the community could focus on making Ruby more performant.
 Array.new(plenty){ Talk.new } Excuse me.
Right, thank you for the help! I came to reddit because I had been struggling, and definitely failing, with this for quite some time, and was hoping to get a response unlike that of the instructors lol, but you're keeping me honest! It looks like I'll need an IF statement so that if a WIN_COMBO isn't present, it will return NIL because of the ELSE portion. What I don't understand is how to iterate over the WIN_COMBO function to see if each element within each array has matching characters "X" || "O" to see if it is a winning combo. Thank you again for the help!
There is [ObjectSpace._id2ref](https://ruby-doc.org/core-2.2.0/ObjectSpace.html#method-c-_id2ref). I'm not sure if that will help you in your specific situation, but it's for sure fun to know! :)
There might be a way, but that definitely isn't the way most people debug, and I'm not sure how helpful a debugging strategy it will be. Use the stack trace instead. And a debugger, like `byebug`. 
Well said, as is that that you are responding to. When new to ruby, it was one of the most impressive and powerful features of ruby. At the same time, it took me a long time to figure out what the hell attr_* was. &amp;nbsp; I can only imagine that if in ruby, meta was treated more like it is in crystal, it would help not only the newbie, but also the backend of ruby performance wise. &amp;nbsp; I personally fell deep into the meta trap by relying on ORM's for too long... looking for the perfect one, I have gone thru sequel, active, datamapper, etc. Only much later, do I start going back to plain ole SQL for doing updates in seconds instead of minutes or hours. &amp;nbsp; One of the best things a rails / orm user can do IMHO is to take one of the MySQL / Postgres tutorials, and keep pushing until your SQL chops are off the chart. Understand all the joins, subqueries, and the like. SQL was created to make working with SETS OF DATA easier. ORMs were created to make working with A SINGLE RECORD easier. Seems like splitting hairs at first, but once you get there, you are a better developer.
You have a few options. What does a board object look like? This will give you clues as to how you can best iterate through it. Ruby has a lot of enumerators that will allow you to go through a collection and return items based on whether or not conditions are met.
Honestly, i think your comments are rather useful. I agree with others that they have overhead to keep up to date. But I find tests as documentation to be just terrible. Tests are for ensuring the code does what you expect it to do. Having someone read a suite of unit tests to understand it is just bad, when a couple short sentences are faster to read, and can explain it even better. One can always work on making more single purpose methods that are well named. But sometimes you just have complex logic that needs to be commented. I would just say don't worry about commenting every function or every line. Do ones that you feel need a bit more explanation than what a method name can provide.
def position_taken?(board, index) !(board[index].nil? || board[index] == " ") end board = [" ", " ", " ", " ", " ", " ", " ", " ", " ",] # Define your WIN_COMBINATIONS constant WIN_COMBINATIONS = [ [0,1,2], # top row win [3,4,5], # middle row win [6,7,8], # bottom row win [0,3,6], # left column win [1,4,7], # mid column win [2,5,8], # right col win [0,4,8], # diagonal [2,4,6] # diagonal ] def won?(board) win_index_1 = WIN_COMBINATIONS[0] win_index_2 = WIN_COMBINATIONS[1] win_index_3 = WIN_COMBINATIONS[2] win_index_4 = WIN_COMBINATIONS[3] win_index_5 = WIN_COMBINATIONS[4] win_index_6 = WIN_COMBINATIONS[5] win_index_7 = WIN_COMBINATIONS[6] win_index_8 = WIN_COMBINATIONS[7] win_index_9 = WIN_COMBINATIONS[8] if (board[win_index_1[0]]) == "X" &amp;&amp; (board[win_index_1[1]]) == "X" &amp;&amp; (board[win_index_1[2]]) == "X" return WIN_COMBINATIONS[0] elsif (board[win_index_1[0]]) == "O" &amp;&amp; (board[win_index_1[1]]) == "O" &amp;&amp; (board[win_index_1[2]]) == "O" return WIN_COMBINATIONS[0] else end WIN_COMBINATIONS.each do |wincombo| WIN_COMBINATIONS[0] += 1 { } end
Switch to rbenv and ruby-build. You'll have a much easier time.
An excellent description, thank you for educating me about Vulnerability Assessments, I hadn't known there was a name for that type of analysis.
Yeah, I can't really disagree with you. I think I'm just so much more familiar with Rails that I would try that first. Sinatra should be just as good for something so simple.
What do you have currently? Are you able to write/read from a database? 
What's the function of "visibility"? To ensure that only users with a specific role can see certain data?
Yes. Ie. Public, Private, Unlisted.
A login shell will source a few extra files, like ~/.bash_profile and things like this. RVM installer hooks into this process to load and configure RVM for your session. I think this has to do with the intent that RVM is installed per user. I think in general usage, you are almost always in a login shell when you expect to be. Places you might not be are if you are running automated tasks, or scripting. Also, I believe running the default c:/windows/system32/bash.exe does not drop you into a login shell by default when using Windows Subsytem for Linux. I always have to load `bash -l` (or rather, have cmder load that for me).
Check out the free online book at railstutorial.org. I believe it discusses how to do this.
I really don't know how deep your skills are re: web development or Ruby, but an excellent starting point would be [Learn Ruby The Hard Way](https://learnrubythehardway.org/). The tutorial is focused to people with no prior programming knowledge and goes not only about the language itself, but the command line, text editors, TDD (Test-driven development), OOP (Object-oriented programming) as well as basic web development with [Sinatra](http://www.sinatrarb.com/). It also comes with study drills to do by yourself so you can reinforce the lesson's content. You can either get it for free at the website or buy it to get a downloadable version, video lessons and other treats. Don't hesitate to PM me or reply to this if you need anything else :) Good luck!
Please keep commenting like that ! While other comments make good points about code styles, what really is important is that you are talking about your intent, which is gold to others who have to look at your code later. Aptly named variable and methods can only take one so far. All other things being equal, I would hire someone who regularly comments like this over a someone who is better at code style any day. And remember coding style can be taught to the most obtuse programmer, commenting is an art Edit: I have read hundreds of thousands of lines of other people's code over two decades, a lot of it done by people more clever than me, and most of it un-commented, or sparsely commented ; and I really do appreciate commenting style like yours. You may not realize it, and the other comments either don't either, or ignore it, but you have a gift for stately clearly what you are doing. A lot of really smart people in the industry fail at this seemingly simple task, or stopped doing it, and it has cost the companies I have worked at millions of dollars **Extra Edit**: I realize this is going to be at the bottom of the thread, but hopefully I can reach out to younger programmers and future project managers, why its important to comment like you do (and not just good code style). I mean besides being irritating to read code where you have to play twenty questions. Say that you run a small shop, and you employ three very good programmers who work on a group project. Each day they take about an hour to go through all the code changes the previous day written by everyone, as the shop has a rule that everyone needs to know all the code in case someone gets sick or quits. There are two ways I would loose money to bad commenting (and this includes being clever with the variable names in lieu of taking about intent) : 1) the first one is with the original group of programmers. Bad commenting can make them each spend ten extra minutes looking at the others' code each day. That is 1/48 of their paid time each year, total, but more realistically most work gets done in 4 hours a day with the other 4 hours in non coding tasks, or getting into flow, or getting back into work flow about an interruption. which means I am paying them about an two weeks every year to go through sparsely commented code. This is not too bad, although I just lost about two thousand to six thousand dollars a year in salary and other. This is manageable 2) Where this really hurts, and I loose a lot of money, is a few years later when all those hot shot guys and girls are elsewhere, and other people need to go through their code for maintenance or to include parts of it in another project but part of the code just does not fit right and it has to be tweaked. It takes up to ten times longer to understand the code now. And what if a majority of the work is using the old code still? Sometimes this has could affect estimations, and deadlines. And suddenly that 4k/year leak just raised to 40k or more a year (for three people at a time working) Now take these estimates of a team of three and extrapolate to a larger team over ten years. For three people this loss can be about $400K over ten years, for a team of twenty its about 8 million dollars or more, because these things do not linear progress but rises on a curve. If I am a grunt programmer I do not care, but if I am a manager who has been there for years or even an owner, this eats into profits. Well, I hope every one who has read this far a good day. I don't know if I changed any habits of future managers today, but I feel slightly better now, and I do not have so much of an urge to reach out and strangle the next person who suggests good coding style can mean less comments 
I'm with you on this one. That first method is extremely long. Sandi Metz's "[All The Small Things](https://www.youtube.com/watch?v=8bZh5LMaSmE)" conference is worth watching to understand why 10+ lines long methods should be avoided whatsoever.
I do not. And the controversy rages over how much testing is the right amount. Seems to be a personal thing with most programmers. I can tell you that any amount of tests are good. Tests also help greatly when you have to do a big refactor.
I've just covered reading my database with the Hirb gem installed. I have not learned how to display my database so I guess that's the direction I need to research more. Thanks for your help and everyone else that gave good suggestions. I know I have a long way to go so I'm appreciative of having such a positive community to learn from.
Start using rubocop. It will force you to refactor your code into much smaller chunks (methods, essentially). The names of these chunks will be your comments. You can get away with almost no "real" comments if you "label" your code this way.
Is your code on github or anything? Maybe that gem provides the writing functionality you need.
Original Infographic [here](https://www.reddit.com/r/ruby/comments/5lfxy0/a_simple_rails_architecture_infographic/). Took as many suggestions as I could but College and my projects took most of my time this week. As before, Constructive criticisms welcome.
I shall wear this dissenting opinion as a little feather in my cap.
Can you explain why class variables are not a good idea? (im also new to ruby like OP)
I don't know, depends if you want to pay yourself for progress. JS community moves forward with huge speed, but consider how everything is constantly changes and on the bleeding edge, your code probably gonna be mess. 
This is how I can explain to everyone how what I'm doing is different then them using Squarespace! This is also how I can explain to myself what the hell I trying to do. Thanks!
Nice! Do you offer any endpoint on the Internet where customers can purchase these services since you call it SAAS?
Welcome :D
I'm completely stuck on this one too. I'm struggling to wrap my brain around how to do it. :(
Super cool guy. He talked with a group of us for about 1 hour after the conference ended and he basically gave us rundown of how the rails tutorial book was made and also what projects he's working on at the moment, as well as what he has planned for the future. He even followed me on twitter which was pretty cool!
Writing tests is a fantastic way of documenting behavior. Tests are code which is frequently executed and maintained, which means they are up to date, and as such are much more reliable than static documentation. However, do not fall into the trap of having poor code quality in the tests themselves. The actual code and it's tests should all be clean code. After all, future developers will have to read and maintain the tests as well.
I'm pretty sure RubyMine VCS supports SVN Also - switch to git. It takes about five seconds. 
I basically need like a "winapi memories manager"
It does, it works fine. I'm just wondering if there's a way to see a list of files that are different on the remote copy compared to the local copy. With regards to git, not my decision, but yes I agree.
Ah, thank you.
Just wild guess: if you are showing an example from the live site, and then receive HTML from this site, check this HTML really contains something inside `.in-play-odds`. Site can fill this block dynamically with JS.
Thanks for the new video. Really love the screencast you are making.
Thank you. I will give it a shot next time I get the chance.
Not bad, I'm guessing this is not your first language. 
I don't see how ruby is inherently easy to maintain. You can easily write completely nonsensical shit in ruby. I'd argue it's harder to maintain because it's untyped, uncompiled and has opaque side effects as a core feature. Elixir and other functional languages use self contained side effect free functions which are super easy to maintain. Dependency injection is not just a good idea, it's enforced. 
That is a solid step forward over active record. Another big improvement, IMO, would be to distinguish query repositories -- ones where you restructure the data in arbitrary ways to for presenting the GUI, and entity state repositories -- ones where you can load and store entities. I bet that can be achieved through code organization practices, also, but I don't even think the concern of constructing arbitrary queries belongs anywhere near where entities are loaded and stored as part of the application logic. Good stuff, though. I am going to look at Hanami over rails next time I am building a web frontend.
Thanks for this screencast! You can find more resources about security and code analysis here: - https://github.com/markets/awesome-ruby#code-analysis-and-metrics - https://github.com/markets/awesome-ruby#security
I'm +1 with this, just wanted to check where you've got the convention from. [Rails?](http://guides.rubyonrails.org/plugins.html#extending-core-classes)
Personally, I don't think that def some_method arg1, arg2 = :val, test: :val, *rest looks very readable. Also, by using parentheses it is easy to differentiate the method name from the arguments, even without proper syntax highlighting.
That is excellent. Thanks, Piotr! Sounds like the right way to go next time I need a relational database.
[Ruby.](https://github.com/ruby/ruby/tree/trunk/lib/rubygems/core_ext)
I used to, but not anymore. Thanks for pointing that out - I will change the text on my site.
I agree with you on both points, and want to add that having AWS skills is also useful these days. It's worth becoming familiar with both services if you really want to dive in to secondary skills that mesh well with knowing ruby.
Data in == expected data out. It's the same for everything
Under WSL, yes. I guess Microsoft prefers to call it that, (Windows Subsystem for Linux). Because if there's one thing the Windows ecosystem has a shortage of, it's acronyms :)
I desperately wanted this to work. I tried it when it was first released. The first iteration wouldn't even untar a tarball to install ruby with rvm. After they fixed that, it wouldn't compile ruby. After that... you get the idea. After a couple months of participating on the project's github issues tracker, I just gave up and decided to wait till someone said it all worked like it should. I subsequently went back to Windows 7 on my gaming rig, so I don't even have something to test with at the moment. I'd like to see someone say, "Yeah, I'm using it to do Rails development every day (with rbenv or rvm), just like on Mac or Linux," before I try again.
I tried to use Ubuntu Bash to develop a Rails API. The backend worked great by itself, but communicating with the frontend (Ember app) didn't. I think I had no trouble with gems with native extensions. I'd say is worth a try, at least.
To provide more information: - This was around 5 months ago, on a Thinkpad 13. - The only problems I found were related to networking. It was not a bug, but I think simply non-working at the time (Found an open issue on Github) I managed to install Rbenv, Rails, Node.js, etc with no problem, and was very happy with it until i found those networking problems. If you do try, please inform us of the results, maybe I can give it another try. It looks like they have progressed a lot regarding networking, though: https://github.com/Microsoft/BashOnWindows/issues/69
One more thing re: &gt; I don't even think the concern of constructing arbitrary queries belongs anywhere near where entities are loaded and stored as part of the application logic Actually, because of that, I always recommend defining explicit Relation classes to properly encapsulate query logic. So ie you wouldn't do `users.where(...).order(...)` in your repos (even if they are read-only) and instead you'd use a relation view defined in your relation class so ie `users.index`. This looks odd in the beginning, but this separation is very clean and powerful too, as you can freely change query logic without changing repos too much. Over time repos start building all kinds of data structures while remaining simple, as the query logic is hidden behind relations.
IMO, a Ubuntu VM with mounted directories via NFS/SMB can be just as effective. Vagrant is a great tool for this if you want to standardize the setup. I've done it at almost every company I've worked at and also includes Windows based developers.
Trying to write something with Python (2.7) I can confirm. Grass ain't all that greener on the other side.
You've probably already seen but this here goes through the setup pretty well (I checked it) and it works: https://gorails.com/setup/windows/10 I set up my project from work in wsl and it worked great, with a couple of caveats. As gorails mentions, Postgres will have an issue creating the cluster. There are workarounds which I did manage to get working by setting up Postgres outside of wsl in Windows using the Postgres Windows installer. You can see more info about the Postgres issue and some of the workarounds on the GitHub issue. https://github.com/Microsoft/BashOnWindows/issues/61 Keep in mind that if you keep your project located within WSL, you can work on it with an editor such as Vim, or visual studio code, or whatever, but make sure you use an editor that is installed within WSL and not on the windows side, such as aliasing vs code from Windows to edit within WSL. You can, however, setup the project in Windows and access from WSL for example setup in windows Documents directory and access at /mnt/c/users/username/documents or what have you. My personal take on all this is while it's entirely possible and has been tremendous progress on Microsoft's side, you could accidentally come across a lib or gem that gets stuck and then you'll spend too long getting it to work. They have been incredibly responsive and active on this project and I think within the next 6 months - year it could be a perfectly viable option for day to day Ruby development work. It could be now, depending on your needs, YMMV. I would love to use it 100% on my Dell XPS, but for the time being I'm running a dual boot of Arch Linux.
Given the clusterfuck that is the new Macbook Pro, I'm very, very interested in how this goes, OP. Please post a new thread once you've given it a shot - there are a lot of folks who would be very interested in your experience.
With little grain of sarcasm, there was no ground-breaking new language in ~ 60 years, since invention of LISP. All what matter if it (still) serves the purpose and current demands or not. Use and success thus depend more on existing widespread, based often on historical reasons, not language's potential "qualities". And prevailing *implementation* of that language, of course. Performant and reliable runtime, backed by trustworthy development. There are lot of niche languages, which do some things better (more elegant or effective) then their mainstream counterparts, but not enough better or are not pushed by billion $ company, they may break the barrier of insignificance. But dreamers which failed with expectations in one language need another one, so they can dream on. 
Hmm, usually I've seen the developers come up with their own workaround for that, it's just that you night have to search to find it. Which gem is it?
Thank you for your books and engagement!
To be fair Python and Ruby are very, very similar and suitable for similar problems. I'd suggest looking at something like Elixir which has a completely different paradigm and target problem set (disclaimer: I'm a long time Rubyist who is rewriting part of an app in Elixir). Not saying there's anything wrong with any language of course, but I do think some are easier to use for certain things
Tech usually moves in cycles, so probably will be at some point.
It just doesn't have the support necessary to be used for development. It's a good start but after trying to get a stable rails project running for about 5 hours I just decided it wasn't worth it. Dual boot. SSH. VM. Anything but bash on Windows. 
Pure Ruby will run pretty well on Windows, but as you've discovered, gems with native extensions frequently have problems, or as I've also run into, gems that require *nix executables for things like image processing, will also be difficult. I think the best option will be Vagrant/Docker/etc, which all really run an Ubuntu VM (usually with VirtualBox) under the hood, then figure out how to have a shared directory between the Windows host and Ubuntu client.
I also want to say, you are doing a fantastic job of asking these questions, and taking advice. I would recommend archiving your recent threads in /r/ruby and link those on your resume. Writing code that works is 1/3 of the job. Writing code that is clean and communicates clearly to other developers is another 1/3 of the job. Working well with your peers in a professional manner is the last 1/3 of the job, and your recent threads in /r/ruby demonstrate this. If I were looking for an entry to mid level Ruby dev, and came across your 2 recent threads, your resume would go to the top of the pile =).
Have you considered separating state manipulation from query generation entirely? E.g. rom-repository and rom-view? Seems like they could be entirely separate mixins. They don't seem to be all that similar when the separation is taken to this extreme :)
I'm starting a project now. And I've been looking into SPA and react. I'm still trying to find out the benefit of them. I'm playing with react now, and it's properties and states are kinda neat. 
I'm a big fan of Sandi Metz. She wrote POODR(Practical Object-Oriented Design in Ruby). The last chapter was a real hit(Designing Cost Effective Tests). In it she talks about not testing private methods. Not sure it applies here but her discussion involved temporarily hiding messy code in a private method and not wanting to advertise it lest it be discovered and used by someone else in its messy state. You should read POODR. And watch every talk of hers that you can find. In an case, algorithms tend to be stable reducing the need for tests. Behavior and message passing is where you want to apply your tests. It's all about the messages.
Ah I see, thanks for the clarification.
That's definitely true. C-extensions are hard to keep updated and they are bloaty. JRuby is probably fast enough to be able to rewrite some of those extensions in pure Ruby but they will probably never be done. Rails is the elephant in the room, that both drives people away from and to the Ruby community. Which kind of sucks, but other web frameworks are being built that don't have the same ethos and history that Rails does.
Websockets work great.
Elixir looks *a lot* like Ruby but targeting the BEAM. It has a couple syntax differences, but is very similar. I like that about it, mostly.
Yes, /u/jrochkind posted an excellent talk of hers that motivated me to go back and overhaul (and write tests for) the two methods from my last post. It was surprisingly fun to watch!
Python 2.7 vs Ruby isn't a fair comparison. Ruby's Object Model is much more robust (i.e. not having to specify a `self` argument all the freaking time, and `super()`). Python 3.0 added some much needed syntactic sugar, it's a shame so many shops are still on Python 2.7. The Ruby community really shined when we made sure everything worked on 1.9 and 2.0, allowing a painless migration off of 1.8.
FYI: See a live demo @ [`henrythemes.github.io/jekyll-talks-theme` Â»](http://henrythemes.github.io/jekyll-talks-theme) Sample talks include: - Dr Jekyll and Mr Hyde - Build Static (Web) Sites w/ Ruby - [(Slides)](https://henrythemes.github.io/jekyll-talks-theme/talks/drjekyll.html), [(Source: `drjekyll.md`)](https://github.com/henrythemes/jekyll-talks-theme/blob/master/_talks/drjekyll.md) - Stay Static - Jekyll vs Middleman - Build Static (Web) Sites w/ Ruby - [(Slides)](https://henrythemes.github.io/jekyll-talks-theme/talks/jekyll_vs_middleman.html), [(Source: `jekyll_vs_middleman.md`)](https://github.com/henrythemes/jekyll-talks-theme/blob/master/_talks/jekyll_vs_middleman.md) and - Starter Sample (Blank Theme) - Habits - [(Slides)](https://henrythemes.github.io/jekyll-talks-theme/talks/starter.html), [(Source: `starter.md`)](https://github.com/henrythemes/jekyll-talks-theme/blob/master/_talks/starter.md) - Starter Sample (Blank5 Theme) - Habits - [(Slides)](https://henrythemes.github.io/jekyll-talks-theme/talks/starter5.html), [(Source: `starter5.md`)](https://github.com/henrythemes/jekyll-talks-theme/blob/master/_talks/starter5.md)
Still the first tool I reach for.
I am *amazed* at Rails as an ecosystem and as a feat of continuing project management and coordination. The [GitHub repo](https://github.com/rails/rails) lists *3,217 contributors* as I type this; how many other projects, in *any* language, can match that? That, as you say, is at least a two-edged sword. It's amazing that it works as well as it does *for its target use case* but, like everybody else, DHH and crew figured things out as they went along, and now those 60.867 commits form a *formidable* legacy of past decisions, good and otherwise. Rails is great for spinning up a quick demo, and by the time people were screaming for more maintainability (e.g., through proper separation of concerns and decoupling), the ship had sailed over the horizon and onto the next planet. That leads to teams with people like me, where for years, I described my main job function as "mitigating Rails". That's not a happy place to be â€” for the mitigator, his team, or the communities that team interacts with. We're fortunate as Rubyists to have had an "explosion" of different tool stacks, frameworks, libraries, and so on, Rails finally got around to *reacting* to that in Rails 5 with ActionCable and Rails API. That's a beautiful new barn door you've put on, guys; you'll find your horses over yonder in the next time zone.
Learning to use Ruby's `File` class specifically is not, in itself, critical. It's not some kind of gatekeeping competency without which you won't be able to progress to the next step of your programming journey. However, learning it _will_ help you gain a deeper understanding of things like I/O streams, or why you might want to pass a block to a method, or how data can be abstracted in a language. You could develop this understanding a dozen other ways, and each new one will grow your understanding a little more. Most things in programming are like this. The journey is not linear, but each piece of the puzzle makes the whole picture a little clearer. Some of the puzzle pieces will require something of a side mission to obtain â€“ should you learn the command line just to complete this chapter on reading files? should you learn ruby, or just dive straight into rails? should you learn how to set up a mail dispatch agent to learn how to send mail with Ruby? â€“ and if you shy away from all the side missions because they're inconvenient or technically challenging in their own right, your picture is going to have a lot of gaps in the end. Some side missions are more time-consuming or have a steeper learning curve unto themselves than others, and the payoff is hard to predict before you go into it. Programming (and software engineering generally) requires a problem-solving mindset. When you encounter these obstacles, you simply have to get to the other side of them, or else you'll find yourself drowning in half-finished projects (or worse, half-finished tutorials). Sometimes that means finding another (usually dirtier) way around, and sometimes that means accepting a setback and spending time to see what's going on under the hood. This early on in your journey, you should _always_ take the latter option. As for the question of Ruby vs. JavaScript: don't try to learn both at the same time. Knowledge builds on knowledge, and the two don't intersect at the level you're working at. If you want to do any web development, you'll need a passing knowledge HTML, JavaScript, and CSS, but that can be developed on the side regardless of your main language. Ruby is far more intuitive and expressive than JS, so start there and good luck!
Everything between &lt;% and %&gt; is interpreted as ruby code so you would NOT want to place your HTML inside.
&gt; it's a shame so many shops are still on Python 2.7. Google is probably ditching their 2.7 codebase for Go soon. At least, [that transpiler](https://github.com/google/grumpy) they've made gives that impression.
I started an SPA project with Ember and Rails-API but now I'm kinda thinking about dropping it in favor of React-spiced mostly-on-the-server rendering.
- What do you know already? - What are you trying to achieve? (Technically, that is - we don't care if it's a wallhack or a webserver, we want to know what you want to *do* not what the end user sees) - What prior art have you examined? Blog links, Github repos... - You dropped these: H I . I , I . e a s e e . We might be able to help, but your post gave us really no useful data at all about what you're after, why you chose Ruby, what your coding experience is or what work you've already done researching the subject for yourself. 
What would you say is the biggest benefit of SPA? Is it worthwhile? 
Thanks dude. I've done some poking around online, so I have an idea of why people choose SPA. I'm more wondering why you went that route. I'm going to be building an app that handles a lot of information, which I think would benefit from SPA as it might also require an API. Thank you.
Not that. I'm talking about DOS attacks, such as [the DOS vulterability](https://blog.phusion.nl/2016/12/21/actioncable-under-stress-protecting-your-application-against-slow-clients-using-passenger/) in rails 5.0.0.x caused by slow client attacks + websockets + Puma (even with Nginx as a reverse proxy). The fundamental difference in how websockets behave compared to the more traditional "stateless" web connection opens the door to such vulnerabilities.
The #step method takes a range operator to iterate in steps of its parameter: (0..myArray.size - 1).step(2) do |index| myArray[index] = #something end
This is a start [awesome_print](https://github.com/awesome-print/awesome_print).
Can confirm. awesome_print is the best gem for terminal coloring of ruby apps. (imo)
I got it (only after an instructor screenshared with me), here's the code, the other methods after that are way easier because you simply call the other ones within it.: def won?(board) WIN_COMBINATIONS.each do |wincombo| if (board[wincombo[0]]) == "X" &amp;&amp; (board[wincombo[1]]) == "X" &amp;&amp; (board[wincombo[2]]) == "X" return wincombo elsif (board[wincombo[0]]) == "O" &amp;&amp; (board[wincombo[1]]) == "O" &amp;&amp; (board[wincombo[2]]) == "O" return wincombo end end false end
Thank you for the help/tips, fortunately I was able to get it and (finally) move on
Really happy to hear that - sorry I wasn't as available later on, but it seemed as though you were moving very much in the right direction.
https://youtu.be/zEmMJuamSNc?t=1m31s
Hey thanks man. So basically when I do stuff[0] = 1234 It's still referring to the same object. Is there a way to clone the values and put it on another object?
Thanks man! Better than what I came up with which was to put every value in the array to another variable. 
no worries dude â€“ if you stick with it, you're gonna pass it on one day yourself. As for a technical solution to your question, a lot of people are suggesting you rent a server and SSH into it â€“ which is totally adequate, if you're on a UNIX machine with SSH already (I've found some Windows implementations of SSH to behave strangely; _e.g.,_ to not accept [basic UNIX control-key commands](http://web.cecs.pdx.edu/~rootd/catdoc/guide/TheGuide_38.html)). This is, to be sure, the shortest version of the side-mission â€“ BUT it also requires that you learn a command-line text editor like vim or emacs, which are lifelong side-missions unto themselves (even just getting to the point where you can work comfortably in vim without backing yourself into a corner you don't know how to get out of could take a week of full-time documentation-reading and practice.) Or I guess you could just use nano. An alternative roll-your-own solution, which may or may not be above your current abilities, is to run ubuntu inside a virtual machine (like VirtualBox). Startup may be slow (third-party servers are always on, whereas you might want to shut down and re-boot a local virtual machine on occasion to free up system resources when you're not using it), but latency will be zero, since you're not sending every command over the Internet.
No. Compact removes nil values
Sorry for the delay. Some people say not to use class variables, as they are not thread safe, and so can cause weird side effects when used in a rails application. But I think it's simpler than that. You can think of class variables as the same as global variables, but restricted to a particular class tree. The problem is that, if you have class variables with different values in different subclasses, and one in the parent class, and each class assigns a unique value, then the value of the variable can be determined by the order in which you load the class (via the require method). That's one example of how it can catch you out. If you want a variable that all subclasses of a class can access and that will be constant, then use a constant variable in the main ruby script file. If you want a variable that is shared across a class's subclasses, but can be changed by each instance, then use an instance variable. If you want a value that is only shared by a subclass's instances, then you could add a class method to that subclass, and have instances call it like `my_instance.class.shared_constant`. TLDR: There really isn't a use case that would have you choose a class variable over a constant or instance variable. And class variables result in weird behaviour anyway. **Edit** Here's another way to get class variable behaviour without the funky side effects. class MyClass @my_default = 314 class &lt;&lt; self attr_accessor :my_default end attr_accessor :my_default def initialize @my_default = MyClass.my_default end end So that... MyClass.my_default =&gt; 314 a = MyClass.new a.my_default =&gt; 314 a.my_default = 123 MyClass.my_default =&gt; 314 a.my_default =&gt; 123 b = MyClass.new b.my_default =&gt; 314 MyClass.my_default = 999 b.my_default =&gt; 314 c = MyClass.new c.my_default =&gt; 999 
Am I crazy remembering that there once were Ruby bindings for GTK?
Nothing official or stable. Your best bet is probably JRuby and use JavaFX. 
Is this an _encryption_ story or a story about why you should be extremely careful trusting critical tasks to gems with 45 stars and no activity in three years?
Both the readme and the code quite clearly show that it's meant to be using hex encoded keys, not passwords. It should have detected invalid keys and thrown an error though.
There are some contexts where you might want this. I've mostly run into it when formating numbers or in general relying on the special string format characters. For instance: def with_cents(amount) '%.2f' % amount end with_cents 29.2 =&gt; "29.20"
Try Stephanie Morillo http://portfolio.stephaniemorillo.com ðŸ‘
Why not using the standard library like everybody would do ? OpenSSL::Cipher::AES ?
shhh! you are ruining this scary encryption story. 
Ugh, how is it that a self titled "Senior Ruby Developer" is saying "We rarely verify external libraries at all". Maybe they have learned their lesson, but this would be a huge black mark against hiring them if they were interviewing with me. Always always always verify any external libraries you will use. You don't have to do a full code audit (that'd be impossibly expensive) but you should at least do what this blog post did: do some simple tests and verify reputation. 45 stars is not enough reputation to give it a pass so with a smallish gem like that the next step definitely should have been a code audit. To the author's credit, they figured all this out before finishing a feature and putting it in production at least. P.S. As others have mentioned, OpenSSL::Cipher::AES exists.
To be fair though, Elixir is very nice. It's got amazing support for Erlang libraries, has a fast VM built in, the IRB equivalent offers actual error messages that are helpful, testing is a breeze, and Elixir is fun. It isn't something I dedicate *a ton* of time to learning, but I absolutely see the benefit in learning it for the future.
Eh, it's not like it's a commercial project or anything, it's just a pet. And I've already started my backend as an API-only app. It'd be silly to exterminate everything just to not use Ember. 
I definitely like pulling the actual business logic out into a class that is not tied into a worker (the example `Process` class). I fully endorse that first step, the `Process` class that is _not_ tied to bg processing, it's logic you could use from anywhere. But for that reason, I'm not sure I like I like adding a `deliver_later` class to the business logic `Process` class. It knows too much about the particular mechanism of enqueing (in this case `Que`). If your change your mind about that, you have to change it in all workers. This could be remediated by using a mixin, and/or using ActiveJob semantics instead of the particular adapter (like `Que`) -- but really, I prefer keeping this business logic `Process` in a class that is _just_ about business logic (so easy to test!), and just making a worker for every one I want to execute in bg. It's a three-line worker that does nothing but call the business logic, just a wrapper. If I was going to abstract, I might abstract _that_, so I didn't even need to write the wrapper, but I wouldn't do it by putting bg-queue-speciifc code in the business logic `Process` class. And really, I think it works out best to still have this three-line worker wrapper. Sometimes it does need logic that is both specific to being a bg worker (a custom queue?), and specific to the particular task (custom ways to handle errors when it's run in the bg?). 
There are some super hacky ways to try that work in within some limited constraints, but there really isn't any way to do this reliably. Just not how ruby works. I hadn't heard of `mathn` before, but looking it up, I do see why you'd want to do this. My first reaction is it's sort of a design flaw in `mathn` that it changes the way standard Math methods work, and there's no way to get old behavior back. I'd find a way to get `mathn` behavior without actually requiring `mathn`, unless you are writing a script that really does want `mathn` behavior everywhere. But I don't entirely understand what mathn is doing or why you'd want it. 
I don't really need it (at least at the moment), I'm more interested in what happens when some gem 3 layers deep does include it..
http://zetcode.com/gui/rubygtk/ There are also a lot of results in Debian stable for "apt-cache search ruby gtk" FWIW
Yeah, it seems like they really ought not to. I'd say it's a poorly designed architecture (the idea that you can change how built-in Math stuff works, globally, with a `require`), from the original days of ruby stdlib, that doesn't hold up well. The use cases the designer was thinking of were probably one-off command line scripts, without a lot of dependencies. Someone now would probably do that either with the newer "refinements" feature, or even just with a design that does something like: Math.mathn do # functions work differently only within this block end Which is also something it would be possible to do in ruby (although you have to be very careful to do it thread-safely!) Or, of course, just with a different set of method names that behave differently. And someone writing a gem now would probably know _not_ to `require 'mathn'`, precisely because of what you point out, it suddenly changes semantics in distant unrelated parts of the running program. 
Yeah. I agree. I actually use this technique but use a library to handle the backgrounding. I wrote it all inside the class because it's just a blog post introducing the idea. My main goal is to just be able to make the decision about foreground or background as easy as I can.
'.' and '..', the current directory and the current directory's parent, are both returned when listing a directory. Dir.foreach(path) do |i| next if i == '.' || i == '..' # foo the bar end What you're trying to accomplish would be much better done with tools like `sed` or `awk`, however.
So every directory contains "hidden" directories . and .. The issue is that you're assuming that every item in a directory is a file, but it's that true. I suggest adding code to determine if an item is a file or directory before executing the ready of your logic.
Further, ``item`` already includes the extension (.txt). Also, that second parameter to IO::write is horrible style.
&gt; suddenly changes semantics in distant unrelated parts of the running program. on the other hand, making gem like this and waiting if someone notices **what** is wrong has some appealing *evil* vibe.. :D
/u/jrochkind is quite right to point out that `mathn` really ought to have made it possible to opt in locally, but [opting out](https://eval.in/715218) isn't *too* complicated in this particular case.
We have a really good way to judge how good open source libraries are -- read the source.
I view it as a critique of a language which does not have good, simple documentation on how to use the stdlib to encrypt/decrypt data. This feature is table stakes for modern languages but where's the documentation with working example code?
RbNaCl gets it right: "here's five simple usecases and how to implement them" instead of 100 pages of RDoc: https://github.com/cryptosphere/rbnacl#documentation
I use Ruby in my day to day work, and one of the books I have written is on Ruby. My wife is my copy + structural editor. Message me if you want our help. Our rates are fairly inexpensive.
This is my mental model for this stuff, someone correct me if I'm wrong it would be very appreciated: `stuff = ['a', 'b', 'c']` assigns the `stuff` variable to point at the newly created array object. When you pass `stuff` as an argument to `do_another_thing` Ruby COPIES the `stuff` variable's value, assigning it to `other`. Here's the catch, `stuff`'s value is a reference to the array, not the array itself. So, when you assign the `other` variable inside `do_another_thing` to another new array, it doesn't effect `stuff` at all, you're just changing what `other` is looking at. In the `other[0] = 1234` example, both `other` and `stuff` are still referencing the same object. So any modification to the object `other` is referencing is also a modification to what `stuff` is referencing.
My pleasure, I totally get the reverse-engineering approach and figured I'd save someone else the same frustration I had by posting the answer.
To be fair, even if that weren't prohibitively expensive for every third party library you use, you have to realize that for someone without domain knowledge, it would be a completely false sense of security. Imagine your average dev. Pretty smart lady, maybe newish to ruby but whatever. She thinks to herself "I need to encrypt this data. I know that AES is the way to do it, and I'm way too smart to consider writing my own algorithm. I know ruby uses gems to package libraries. Let's see what Google's got for 'ruby AES gem'." 4 minutes pass. "Ah sweet," she thinks to herself, "here's a gem even *called* `aes`. It's not very popular though. Better do a quick code audit." Starts reading code, gets to the absolutely cryptic unpack line and thinks "huh, looks like some kind of string unpacking to a byte buffer or whatever" and moves on. ... As a rubyist with some experience, *you* know that `OpenSSL` is in stdlib, but how's she supposed to know? "Always know the stdlib" isn't wrong, but it's unhelpful. So as a community, I totally feel like better library discovery is important, and more so, it makes some sort of other quality metric important. What that is, who knows, but that's why it's a problem. My 2c at least, cheers. 
 Dir.glob('/Volumes/VIAL/Emily/*.txt').each do |path| File.write(path, File.read(path).gsub(/Ã¢/, '')) end
FYI: As a more "advanced" sample I've added the [Hello, Pages! V2](https://henrythemes.github.io/hello-pages-theme-v2/) [(Source)](https://github.com/henrythemes/hello-pages-theme-v2) sample w/ custom layout, github banner, footer (w/ build time) and more.
I hear what you're saying, but probably 70% of the things I know (because of my "experience") is because I went digging through source.
`5`. Is there an online community (Gitter/Slack) that is friendly/welcoming to n00bs and good at helping people come up to scratch? More specifically on Item 4, is the documentation clearly written in reasonably good English so that a non-domain expert can come up to speed more quickly than just "use the source, Luke"? Software is the written record of a conversation between at least two people (one of whom may be your future self). As such, clarity, precision, and tone aren't simply nice-to-have, they're essential. It's almost incidental that that written record happens to be executable by a computer.
Shit man, `OpenSSL::Cipher::AES` is really long. 21 characters. `AES` is so much easier to type, its only 3 characters. Just think of all the optimizations you get by using 18 fewer characters.
what is simple and terrifying is that the author of the article thinks themself competent to implement a secure solution; they don't even know how to pick an encryption library, nor do they know the core libraries in ruby. we should all be terrified.
I mean, they even got the gender of *passion* wrong ... 
The author's name appears at the very bottom of the post.
Mmm. Cancan. That's a great example if only because it's so out of date and has so many different forks out there. Lol.
For me at least cancancan doesn't meet rule #3 since I normally don't utilize activerecord.
You can use a ternary operator for this ``` &lt;input type="checkbox" name= "active[]" value=&lt;%= checked ? "t" : "f" %&gt; checked&gt; ``` If you are using Rails, you may also want to look into the built-in `check_box_tag` helper that it provides to make things even simpler. ``` &lt;%= check_box_tag :active, "t", checked %&gt; ``` Documentation: http://apidock.com/rails/ActionView/Helpers/FormTagHelper/check_box_tag
I guess it doesn't for me because I run with JavaScript disabled by default.
I must have misunderstood your question. I was assuming you had a variable or helper method `checked` which you wanted to use to set the value of the checkbox. 
Interestingly, half of the listed libraries have bus/truck factor = 1, i.e., they are basically single-man projects.
Why isnt pry on this list? It has 4500 stars 
CarrierWave is on the first page. But yeah, no others that you've mentioned.
Constants, private methods, and more specialized classes will all help. If I write a method longer than about 3 lines, there's a very good chance there's a FIXME comment right above it. Red, green, *refactor*. As a general rule, an instance variable is a code smell (for me). If I'm remembering correctly, Sandi Metz did a talk about rescue projects/bringing code under test coverage a few years ago. In it, she breaks a huge method into manageable pieces. Worth watching, if you can find it based on my crumby description. Edit: I might have been thinking of [this talk by Katrina Owen](http://confreaks.tv/videos/cascadiaruby2012-therapeutic-refactoring). I dunno.
You're probably thinking of [All the Little Things](https://youtube.com/watch?v=8bZh5LMaSmE), which is excellent.
Keep in mind that your example is a "lower level method" (it only calls standard library methods). Sandi's rule makes more sense for higher level methods (methods that call others than the standard library's). Typically business logic methods. 
Naming is very important. If you extract methods and give them poor names, then you're right, it will be harder to understand. But extracting with good names helps to increase your understanding and discover better abstractions.
Why would one arbitrary limit have more (or less) value than another arbitrary limit? If it makes sense to break off a chunk of code, then do it, if it doesn't, then don't. I've never run into a case where the # of lines had any impact on that choice. 
Rubocop, which I use daily, is absolutely ridiculous. When I start a new Ruby project, I spend more time configuring insane shit than i do designing the project. If you look at the rational behind most of the settings it's because Avi said this or Weirich said that. I swear the setting for prefering and/or over &amp;&amp;/|| references a blog post but came to the exact opposite conclusion (as of 1-2 years ago).
Because newbies don't know when is the right time. Its learned through trial and error. When working in the codebase, with other devs, small changes are easier to read and manage. Smaller methods are also easier to unit test. Like all great artists or craftspeople. Its those who know and have practiced the rules well, who can break them with the best results.5 lines may be small for some languages but ruby is pretty flexible with under 8 lines.
I'd rather the newbies leave me a single long function to refactor than 15 poorly named half obfuscated 5 liners, it's much easier to deal with. 
They results are filtered, to consider just Web libraries. To see the complete list, remove the filter (just click on Filter, on the right top of the page) 
&gt; What am I missing? * Returning from the middle of a method will make life difficult for you. * case statements are a smell. * Whenever you see `min` and `max` it's probably a `Range` * /u/bhrgunatha has the right idea about abstraction levels. * You're trying to do too many different things at once. With all that in mind, here is a solution: def bin_search(array,target) range_history = [(0...array.size)] until range_history_stable?(range_history) do range_history &lt;&lt; range_refine(array,target,range_history.last) end range_history.last.max || -1 end def range_refine(array,target,range) guess = (range.min + range.max) / 2 return (guess + 1..range.max) if array[guess] &lt; target return (range.min..guess - 1) if array[guess] &gt; target (guess..guess) end def range_history_stable?(range_history) range_history.last == range_history[-2] || range_history.last.size == 0 end There are two potential classes in there that I've not extracted. (`range_history` and `binary_search_range` (although it's called `range` in the code above)) 
https://github.com/seattlerb/flog
Most replies here are saying they don't agree with this rule outright. I like the idea behind this rule, but not necessarily the rule itself. To me, this rule is saying to have each method be as simple as possible. Ideally, each of your methods will do exactly one thing, and the name of that method will describe that one thing well. Many times, I've found that complex functions are the result of doing too many things, so I take step back and try and find something that can be broken out into its own function, which can be called within the original.
Yeah my memory sucks. You're right. 
You're right, it is somewhat arbitrary, in the sense that it's a personal choice (or if you're in a team, it's what the team feels is too long). But that doesn't mean it's not helpful. Don't treat RuboCop's warnings as absolute. Think of them suggestions, like someone saying "hmm, this method is getting quite large, should we refactor some behaviour out or leave it as is?". If you find yourself often disagreeing with RuboCop's defaults, then tweak it to your taste. But it will never be perfect.
&gt; Don't treat RuboCop's warnings as absolute. We fail our build if any rubocop rules fail, so they are absolute. If you don't enforce your coding standards then they won't be followed. &gt; "hmm, this method is getting quite large, should we refactor some behaviour out or leave it as is?" We don't need an automated rule to tell us code is getting difficult to follow, that is what PRs are for. At least one other programmer is going to read that function before it gets merged which is the best (and only meaningful) litmus test for it's clarity. 
&gt; We fail our build if any rubocop rules fail, so they are absolute. I used to do the same, but I now feel it's the wrong approach. I now prefer to use Rubocop via Code Climate along with its Chrome extension (https://codeclimate.com/browser-extension). This shows the warnings inline on the the PR, so the reviewer can make a decision on whether the warnings are justified or not. I agree that it should be a person who makes the final decision, but automated tools can make the process easier.
&gt; * case statements are a smell. Why would `case` be any more or less of a smell than `if`?
That's how I have always done. 
I would say it's not. instance state is an integral part of object oriented programming. then again, some say OO is bad and functional is the only truth. if you do functional programming, mutable instance state is evil. 
Having an enforced code style is *huge* for teams of any size. It elements a whole class of problems when dealing with code reviews and bike-shed arguments. Once, you get that agreed "style", it's pure gold. You get the occasional weirdness from Rubocop, but aside from that, it's a great way to eliminate arguments about "style."
that's exactly the idea. it is hard to write only 5 line functions. It's not meant as a hard limit, never write longer than 5! that will cause you to write a lot of horrible code. it's instead meant as a marker or smell. if your method is longer than 5 lines, there is probably a better way to do it. so you are new and you couldn't come up with a better way, so what. your code works and its fine. you know now though, that there could be a better way, and you know it's worthwhile to look for it. 
If I were doing a code review, I'd remove the `@min` and `@max` by changing `guess` to `guess(min, max)` and changing `found?` (which is doing two things by updating the state of min and max). /#nitpick
Thank you for the welcome! And yes, guilty as charged haha, I am coming from the Java world. It's the only language I've completely immersed myself into. I actually picked up Ruby a few days ago and I suppose this is something of a learning project. I guess I'm a few years late to board the hype train that surrounds Ruby. I'm finding that the Ruby syntax is everything they say it is. It's like a refreshing drink of water for a parched man. The ability to implement OOP while being so dynamic while also being functional enough to act as a scripting language is just amazing! I love the syntax too! So simple and elegant, especially after experiencing the verbosity of Java. I just wish that so much of Ruby isn't shrouded by web development. It should have its own general purpose identity like Java does.
RuboCop follows the community-driven [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide). If you feel it can be improved, then open a PR to have it changed.
You know what else eliminates bike-shed arguments? Prohibiting bike-shed arguments.
either raise, or use behavior 2
I think that's where code review comes in though. One can help show them how to better split up a function, and why, as opposed to a static checker saying it's too long.
What if it's something the end user creates and the programmer just forwards that string to your library
Things will become much more clear after you learn arrays. But yes, that's pretty accurate. 
The "rule" is not intended as such. Sandi resisted framing it in such rigid terms. You should occasionally find it too restrictive to be reasonable. If you find yourself struggling with it often, though, that'd be an indication of not breaking methods down sufficiently.
I remember the scramble to get off mainframes to "client server" and now we are into the scramble to "get things into the cloud". Decentralize then Recentralize. The same with the web frameworks. &amp;nbsp; I remember looking into Erlang and loving the backend. Same with Go. They just really have cool things about them. I just think better in Ruby. I have coded in Assemblers for different archs, C / C++ , Python, Basic, Shell, Java, Python, PHP, etc... &amp;nbsp; I am excited about mruby / Crystal for the future. I am excited that people are writing things like the Caddy web server in Go. If I had some low level project to do today, I think I would use Rust. &amp;nbsp; I guess my point is, as I get older and grow, I pay less attention to the fads and my inner 5 year old says "why, why, why" enough that if it is not really solving a problem in a compelling way, I just smile and wave.
I used to have that avatar pic as a poster in my room growing up. Nice. 
As something of a counterpoint, while bhrgunatha's 5 line example is a good demonstration of what Sandi Metz is talking about, I think your original 11 line implementation is better. Spreading such a simple algorithm across 4 methods is unnecessary, and also makes it harder to understand. The "5 lines" rule is just a guideline, and I'm sure Sandi herself would agree, because I've heard her say as much in various podcasts and talks. Usually you will want to make small methods, where "usually" could be something like 90% of the time. So if 90% of your methods adhere to the rule, that means 1 out of every 10 methods will break the rule, and that's OK. I think this particular case is a 1/10 situation, because adhering to the rule will actually make your code worse.
You might check out jruby. You write Ruby, run it in a JVM, and can call into Java libraries from it. I'm a huge fan of it. Ruby syntax with access to all the Java ecosystem is really powerful.
Uhhh bro? This is Ruby... The programming language. 
**Here's a sneak peek of /r/vim using the [top posts](https://np.reddit.com/r/vim/top/?sort=top&amp;t=all) of all time!** \#1: [I am Tim Pope, crafter of plugins. AMA.](https://np.reddit.com/r/vim/comments/267vrv/i_am_tim_pope_crafter_of_plugins_ama/) \#2: [Today is the 25th birthday of vim. Happy editing everyone.](https://np.reddit.com/r/vim/comments/5aptdq/today_is_the_25th_birthday_of_vim_happy_editing/) \#3: [Vim 8 Release](https://github.com/vim/vim/releases/tag/v8.0.0000) | [100 comments](https://np.reddit.com/r/vim/comments/52e393/vim_8_release/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/)
That's a possibility. Not a particularly good one, but possible. The performance of searching for the indices in the master file comes to mind. Anyway, be sure to make clear what a key can consist of or - if everything goes - to escape what is necessary. Example: if your master file uses the character "|" to separate key and filename, then you must take care of "|"s in keys. An easy way to get hash-like, short-term persistence is to use dbm.
Hashing the key without handling collisions is also bad. In your current implementation, an MD5 collision (accidental or malicious) will give out the value / overwrite the value for another key. Possibility of wrong data and data loss ... that's a showstopper. Also, you just assume that value implements `to_s` and - even more problematic - you return that as value. That assumption doesn't hold in general.
I added some precautions for assuming that its a string. It raises an exception [now](https://github.com/silk8192/libcache/commit/5d04173f31019f842a22688a12abfdb7d68b65f1) I've also attempted to [fix collisions](https://github.com/silk8192/libcache/commit/e1ad6f4ab7799c948efaab38078ee58f84ada84f) by appending the current time to the file hash. This should make collisions very very very unlikely.
Agreed. OP's code is much more readable and understandable. Arbitrary line count limits are dumb, especially one as absurd as 5 lines.
Check out their [motion-provisioning](https://github.com/HipByte/motion-provisioning) and the related [blog post](http://www.rubymotion.com/news/2016/08/08/announcing-motion-provisioning-simplified-provisioning-for-rubymotion-ios-tvos-and-macos-apps.html) about it. I had a legacy app from two years ago that I had written in earlier days of RubyMotion. It had a lot of issues with getting my certificates and code signing. I updated the app with minimal efforts to the latest version of RubyMotion and used the `motion-provisioning`. It made a huge difference and found RubyMotion enjoyable again. From what I've found, most headaches around RubyMotion are environment related. However, unless you do a lot of research on the issue, it would be hard to pinpoint that it was something else that causing the errors and not the app or RubyMotion. 
Thanks for the reply. I installed [bundler](http://bundler.io), then used that to install *motion-provisioning* (and it installed a bunch of other stuff too), then configured it for a free account. Running *rake* is giving me an error: &gt; Faraday::ConnectionFailed: Connection reset by peer - SSL_connect But this looks more promising than anything else I've seen, so I'll come back to this as soon as I have a chance. Thanks again! 
Hey I tried to develop for RubyMotion but it was very difficult because the documentation wasn't very strong. I highly recommend React Native.
I just use what windows provide
https://github.com/ksss/epoll
So my guess is that you'll have a hard time finding something like that specifically for ruby. I'm not sure what your skill level is, but I'm going to go out on a limb and say you're a novice programmer (passe correct me if I'm wrong). If that's the case I would recommend a more general book on data structures. Such a book would teach you fundamental constructs that would help you learn ruby concepts more easily. The benefit to learning from a data structures book first is that data structures books are often filled with visual aids by virtue of their topic. Personally, I learned this stuff from [Data Structures and Other Objects Using Java (4th Edition)](https://www.amazon.com/dp/0132576244/ref=cm_sw_r_cp_apa_3PnFybTG3FJXS). But that requires a basic understanding of Java which is maybe not in the cards here. There are other fantastic books on the topic. Secondarily, if you're visually inclined, maybe an online course would be best. Especially the courses with high production value like [Code School](https://www.codeschool.com) often have tons of visual aids and in depth explanations of the more complex topics. Admittedly Code School is typically frowned upon because the library they have doesn't really justify their asking price, but that was just one example. Other excellent online resources exist, some of them are even free. I'll use this opportunity to name drop one of my favorite resources: [Learn Ruby The Hard Way](https://learnrubythehardway.org/book/). He takes a bottom up approach building new concepts on top of old ones in a step-by-step fashion which I think is excellent for a lot of novices. The book is free to read online but if you pay for it, you also get a bunch of video lectures which many find helpful. Lastly, I'll leave you with some food for thought. I am reminded here of one of my math professor's from college. She was teaching us how to read a math textbook when she said (paraphrased): &gt;What matters is not that you understand the proof right away but rather that you understand the theorem. Understand what something does first, then later understand why it works that way. I am reminded by this because you don't always grasp something perfectly the first time around. However if you first just gain a working understanding of the topic and then give it some time and revisit the topic when you're older and wiser, you'll be able to understand it perfectly. 
Interested in your feedback
It hasn't been touched in 2 years, bombs on anything but linux and is marked by the author as experimental. Why would you use it over other implementations that are production ready on multiple platforms and used in several high volume projects, e.g. nio4r which is used in Rails and Celluloid? 
I've never watched the videos so I can't speak for them but I did use it as one of my resources when I was first learning Ruby and I found it to be invaluable. 
["Your scientists were so preoccupied with whether or not they could, they didnâ€™t stop to think if they should."](https://eval.in/717293)
Hah, Ruby never disappoints. 
Unless I'm missing something this adds little to no security at all. If your SSL connection is MITM'd then I can just grab the encrypted password and use it for future auth since there is nothing session specific in the crypto. 
As mentioned before, Ruby is platform agnostic (as much as possible) while `epoll` is platform specific (works only on linux). To make matters worst, emulating `epoll` on Windows is like driving against traffic, since the IO signaling approach is **very** different (`epoll` and `kqueue` signal on readiness while Windows signals on task completion)... ... Hence, `epoll` and friends are unsupported by the standard library and it's left to the community to extend Ruby in system specific ways. However, a number of solutions exists. In addition to [`nio4r`](https://github.com/socketry/nio4r) and [`EventMachine`](http://rubyeventmachine.com) which both fallback on `select`, you use the [`iodine`](https://github.com/boazsegev/iodine) gem which forces either `epoll` or `kqueue`, without allowing any fallback to `select`. This approach (not allowing a `select` fallback) is mostly relevant for high concurrency and it's used (to good effect) with the `Iodine::Rack` server to support high concurrency for both HTTP and native Websocket connections. In `EventMachine` you will need to set either `kqueue` or `epoll` manually. i.e.: if EventMachine.kqueue? EventMachine.kqueue = true puts "using Kqueue." end if EventMachine.epoll? EventMachine.epoll = true puts "using epoll." end In `nio4r`, the engine is selected automatically. On macOS the "engine" will be `select`(!), not `kqueue`, due to `libev`'s design. You should be able to check `nio4r`'s backend engine using the new version's`Selector#backend` method (assuming the feature was released yet), you can see [a discussion about this question here](https://github.com/socketry/nio4r/issues/109#issuecomment-268184552). 
It can also be spelled `END`, and that one has an inverse called `BEGIN`. These *keywords* were inherited from Perl, incidentally.
thank you!
As it stands, you are correct. However, let's assume that a bulk number of your users are not very tech savvy. These users use the same password for everything with no regards to security. If the user was on a malicious hotspot or similar, and logged into your application, there could be an instance where your application would be vulnerable to the attacker to re-authenticate with the encrypted password. However, the encrypted password would be useless to log on to other sites that the user may have accounts to. I've even played around with a rolling keys where they are regenerated on the server side. A history is kept of X last generated codes. If an old code is used, it would be for one of three reasons; - information captured from attacker - user did not refresh page from last visit and time passed - someone tried to make a login portal with an old public key. In any event, it would be beneficial to keep the end user's best interest in mind. In the second case, it would be one of those "It's an older code sir, but it checks out" deals. You could implement a recheck of the password or a security question if the latest public key was not being used to encrypt the password. Similar you could have a bank of public/private keys that are one time uses and they get rotated out upon usage. (just spitballing some thoughts)
Very cool! And I hope it worked out well for your family member and they are grateful. 
I freely concede that it would create an unholy mess of waste, but simply [doing the cleanup in a `Mutex#synchronize` block](https://eval.in/717909) seems like it'd be enough to prevent contamination. The global state would have to be swept under some rug, but I've largely convinced myself not to pursue this `unrequire` insanity beyond the limits of thought experimentation. I do maintain that `TracePoint` is sufficiently thorough as to provide the necessary means to completely undo any world-visible operation, but that way lies proper madness.
Yeah, the TracePoint undoing would need to be thread-safe too -- unless it's intended to just globally reverse the world-change forever I guess (well, would still need to be thread-safe, but more straightforward to make it so). Ah, synchronize block meaning that nobody else can be using `Math` at once? Yeah, maybe, obviously not ideal. Trickier than it first appears to do this kind of "change the meaning of methods" API in a sane way. 
I'm excited for the 5.1 release, but bummed that the 5.0.x .debs were removed. Is there any archive package server somewhere?
Passenger developer here. Thanks for publishing AUR packages!
The 5.0.x debs shouldn't have been removed. As a rule we don't remove any old debs until we run out of disk space. What makes you conclude that the 5.0.x debs were gone? In any case, we have a repeatable, automated system in place for building Debian packages that anybody can run. You should git clone Passenger at the desired tag, checkout all submodules, then check packaging/debian. There is a README in there that teaches you how to build packages.
Looking quickly at SciTe's feature set: https://www.gnu.org/software/emacs/, http://www.vim.org/, https://www.jetbrains.com/ruby/ (costs money), http://macromates.com/, https://atom.io/, and basically any other code editor.
Thank you. I just found out that SciTe for Linux is free. Installed it on Kali (VM), and I am good to go. Being a complete newbie, wish me luck. Take care
Cool usage of Ruby. Shouldn't you close `@decrypted_file` here? https://github.com/robacarp/nemucod_decrypt/blob/master/uncrypt_nemucod/decrypt.rb#L32
Will i be able to build out smart contracts for ethereum using this?
I've never used ethereum, but if it doesn't rely on native extensions, we likely run it. If not, please feel free to file an issue at https://github.com/graalvm/truffleruby/issues and we'll be happy to look at it. Native extensions is something we're still actively working on.
This looks like it could be like a magical fairyland for Ruby performance and is super exciting in that regard! But honestly, given the corporate / community stewardship history of Oracle - how likely is it that the community would put even an ounce of faith in a platform owned by such a notorious company? edit: hmm..a bit of digging reveals that [the license as it stands](https://github.com/graalvm/truffleruby#licence) looks pretty good actually. (Though the[ license file in the repo](https://github.com/graalvm/truffleruby/blob/truffle-head/LICENSE.RUBY) remains unchanged from the Jruby fork)
Thanks, perhaps you can send me some swag :)
Great work. Can't wait until it's in an easy to use state. Easily the most innovative project in dynamic languages I've seen in my career.
I didn't know select was limited like that. That seems like a pretty limiting factor. Thanks for explaining it and your use cases. It's interesting how many OS primitives are broken by design. Apparently file locking is also horrendously broken. But, I guess they have to maintain user space compatibility? Or something?
Going off on a tangent, npm bragging about how explosive their growth of libraries is does not impress me given the JavaScript community's penchant for micro libraries. For every regular-sized library in JS, people have broken out small pieces into standalone libs because of the way JavaScript is packaged. Maybe that will diminish with tree shaking, but I think for years it has artificially inflated the numbers. Anyway, Ruby is maturing. And that's a good thing. 
I know... It's like they're trying to deter us from getting to close to the metal. Maybe it's a file system issue. I mean, the HFS+ file system isn't young and they are working on [a replacement](https://en.wikipedia.org/wiki/Apple_File_System). If this is the case, there will be some things that just can't be resolved until the new file system is implemented and the kinks are worked out of it (by god, I hope they get it right). 
Write a class that you initialize with the board and a starting location that can give you the valid moves and can return a new chessboard after moving to a given place. Test the methods on that class ignoring how you're getting that information. `gets` is already tested, so you just need to wire it up. If you really want to test `gets` then mock out the return value with your mocking library of choice, but only test that you can turn the string into a location. Split up your input handling from your data processing.
It's good to hear that Ruby is alive and well, it is one of my favorite languages and I hope it will continue to thrive. I believe there was a report from early 2016 that also concludes that Ruby is far from dead, just mature. I think the stats for application servers are heavily skewed though. Thin hasn't seen active improvements for years, so why would it be on top? And Passenger actually recommends using the Debian and RPM packages in their installation tutorial, at the expensive of gem download stats.
I think it's a good thing there are less gems being created. There are a ton of gems released 2010-2014 which are now abandoned, consuming namespace, creating confusion. There should be a way to tidy them up.
It stands for [Early access program](https://www.jetbrains.com/support/eap/), which basically allows you to try pre-release versions of their software for free.
[StringIO](https://ruby-doc.org/stdlib-2.4.0/libdoc/stringio/rdoc/StringIO.html) test_stdin = -&gt; { Array.new(2) { gets.chomp } } $stdin = StringIO.new("first input\nsecond input\n") expect(test_stdin.call).to eq ["first input", "second input"]
Agreed. It's very hard to gain conclusive data from publication stats. Having said that, I've attended a number of Node.js conferences last year and the atmosphere was great. I felt that there is a lot of excitement in the community, and a lot of active effort to improve things not only in the ecosystem (NPM packages) but also in core. In fact the Node.js core is nowadays split into many different working groups that each focus on improving a small part of Node.js (e.g. debugging, HTTP, etc). It really feels like a community. I haven't visited Ruby conferences for a while now so I don't know whether this amount of activity and whether this feeling exists in the Ruby community. I just want to say that the Node.js community (not speaking for the wider JS community) is not just bullshit.
&gt; There should be a way to tidy them up. kinda hard to think of any though... well.. actually, gems require you mail? so ping every package owner and if activity not confirmed (withing month?) move gem named gem into abbandoned/gem; that could work maybe?
What exactly are you trying to achieve? Can you give a little more context? You can specify multiple conditions in a case ("switch") statement by simply separating them with a comma, if that helps: x = 2 case x when 1, 2 puts "foo" when 3 puts "bar" end # =&gt; foo Regarding the "Why not allow fall through?", I'm not sure. I think that fall through *by default* is disabled because the ruby language heavily emphasises simplicity, elegance and non-'boilerplate' code - such as writing lots of `break` statements. But I don't see why ruby couldn't take a leaf out of, say, Perl's book and allow opt-in fall throughs via some keyword. (I believe they use `continue` for this.) The only real argument I'd pitch against the feature is that "complex" switch statements should be considered a code smell in ruby; there's probably a much better, object oriented abstraction to be made than writing large `switch` statements.
You are right, it's a hard problem. Emailing the authors might be a good idea. Another option would be to make abandonment easier, and perhaps even automated. For me personally, I think there are two main issues: 1/ for new gems, finding a good name is increasingly difficult and 2/ for users trying to find a gem, sifting through the cruft is becoming increasingly more difficult. So, something which supports both 1 and 2 above could be great. My proposal, a long time ago, to RubyGems, was to allow anyone to publish a gem release for a given gem name. I know this idea has flaws, but I don't think they are unsolvable.
What do you want to achieve exactly?
This is not really a gotcha, this is just how map works. Map evaluates the given block for every item in a list and puts the evaluation result of the last expression into a new list. In your first map case, there is no expression that yields a value, therefore all items of the resulting list are nil. 
I guess if the checked value has `.replace` method, you can change its value and call `redo`
I don't know why people are so quick to declare anything and everything dead.
I think so. If you want to avoid mutating it, then you _need_ to create a new copy somehow (there's no 'copy on write' or partially-shared-memory in stdlib hash), so yeah, dup and delete. The `reject` method will just do a `dup` under the hood anyway. 
Just because I, apparently, HATE getting work done... 2.3.1 :047 &gt; def timeit 2.3.1 :048?&gt; start = Time.now 2.3.1 :049?&gt; yield 2.3.1 :050?&gt; stop = Time.now 2.3.1 :051?&gt; puts "It took #{stop - start} seconds." 2.3.1 :052?&gt; end =&gt; :timeit For a Hash with 100k elements: 2.3.1 :054 &gt; timeit { x.dup.tap { |h| h.delete(333) } } It took 0.037131 seconds. =&gt; nil 2.3.1 :056 &gt; timeit {x.reject { |k,_v| k == 333 } } It took 0.030753 seconds. =&gt; nil 2.3.1 :059 &gt; timeit { x.select { |k,_v| k == 333 } } It took 0.029912 seconds. =&gt; nil Although it should be noted my hash is just an integer key, with the same integer as a value, so the copy operation is fairly cheap. If we had a copy operation that was more computationally expensive, I think the differences would be far greater. Edit: changed keep_if to select, per comments below.
I agree, the Node.js community is not just bullshit! There are a lot of people doing good work in there.
Not really a dup, more like a reduce. Same difference. But, assuming dup is optimized, perhaps to copy memory, dup/delete might be faster than iterating. 
most of the client-side application development tooling is migrating to node.js, and rightfully so, because it supports the same programming language/runtime. Download numbers and library LOC's won't tell you that. Whether Ruby matured, it's hard to tell. It's still subject to random breakage. Rack 2.0, for instance, broke support for ruby &lt; 2.2, and it's hard to see the reason why judging by the diff with 1.x tags. This meant that I can't mount a Sinatra app anymore if I'm using rack 2.0, like for instance, if I need to /want to /can migrate to Rails 5, at least until they release the next major version officially, which has been in beta for almost 1 year. And if I have Sidekiq around, that's another upgrade train to put on the rails. I don't want to sound like ranting, I'm just describing a particular issue I had. I get why rails forced rack 2.2, but rails is a "leaf" dependency. rack branches out to other sub-dependencies which should inter-operate, and this has consequences. The ruby ecosystem has a lot of useful tools, and I'd say most of them don't have the luxury of a "core team". 
I know that you asked about vanilla Ruby, but ActiveSupport (Rails) adds an `#except` method to hashes: &gt; require 'active_support/core_ext/hash' = true &gt; { a: 1, b: 2, c: 3 }.except(:c) = {:a=&gt;1, :b=&gt;2} The implementation of which is a `dup` and then iterating over each key given to delete them: https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/hash/except.rb ActiveSupport also provides `Enumerable#without`, which works on both Arrays and Hashes: https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/enumerable.rb#L67-L76 &gt; require 'active_support/core_ext/enumerable' = true &gt; { a: 1, b: 2, c: 3 }.without(:c) = {:a=&gt;1, :b=&gt;2} &gt; [:a, :b, :c].without(:c) = [:a, :b]
Write it so that it makes sense to read. The amount of time you "save" by shaving off a few milliseconds on the call will, at this point, never add up to the time it took you to figure out which way you want to do it. hash.reject { |k,v| k == :b } Is the most idiomatic way. Use that.
I think the article hits on why http/2 isn't a terribly high priority for Ruby/Rails: most of the advantages of http/2 can be achieved outside the app via a supporting CDN and reverse proxy. Server push is the major app server impacting feature and is going to require fairly fundamental re-thinking of how web frameworks operate. This will be a fairly long process to get right even after rack supports it. Not to mention that server push is a bit of an unknown all around, it's at the brower's discretion what, if anything, it actually does with the pushed data. Additionally the most obvious case for server push, sending js/css along with an html request, probably isn't something you want to be doing in the app server anyway. 
Sinatra won't work on ruby &gt;= 2.2? That's odd, and seems like Sinatra's problem to me. But yeah, rubyland doesn't always care about backwards compat as much as I'd like either -- although it's way better than it was a few years ago already. (And my impression is node.js general community is even worse with backwards compat, if it's not as painful it's just cause node.js has less back to compat). 
Fuck, [I got sniped](https://eval.in/719381)
This is pretty awesome. Sounds like when JDK 9 is released we'll have an alternative to MRI that a big two advantage over jruby in that startup time will be low enough that programmers will just use it in their development environments. This is pretty critical for adoption, imo. The performance is also super exciting. Paging /u/headius -- will TruffleRuby eventually become merged with jruby?
I mean, really, I'm as annoyed about lack of backwards compat as you... but if a project as complex as Sinatra is basically receiving no maintenance, or not enough maintenance, or a period of no maintenance followed by a single brand new maintainer.... I would not be surprised when it breaks, when it 'loses market share'. It's not like this is a plot by the Rails or rack maintainers to 'steal market share' from Sinatra. If Sinatra doesn't have enough maintenance, it's gonna start falling behind. That's just how it is, isn't it? Now, this is another problem, that the ruby ecosystem is (at least compared to something like Java) disproportionately maintained by volunteer "side project" labor, and when something is new (whether rails, ruby, or just a particular gem in question) it's easier to get that kind of labor then it is for the boring and more difficult task of maintaining an existing thing. That various projects are starting to go unmaintained is in some sense a _sign_ of the ruby ecosystem's "maturity". It's also a problem, and also frustrating for us to see the ecosystem in some way seem to be 'shrinking' as projects that used to be exciting start going without sufficient maintenance. Short of Java levels of backwards compat concerns, if something isn't getting maintained, it's gonna start slipping. I do _not_ think the node.js ecosystem is any better than the ruby one for backwards compat concerns. I'm not really sure it's even any better for maintenance labor -- although it's new enough and there are still enough new things to build in it that it has an easier time attracing volunteer side-project labor. Again, that's not a sign of the ecosystem being 'mature', but the reverse. I'm guessing you come from Java? While Java is arguably a 'mature' ecosystem, I think some things relatively unusual about it are: 1) the Java community tends to put a higher priority on backwards compat then almost any others at all, and 2) the Java open source community seems to have more "I get paid to do this" maintainers than many other platform open source communities (probably joined by C# and other MS tech). 
I took a little longer looking through your project. If this were a large software projectâ€”if this is practice for larger, real future projectsâ€”then your structure looks pretty good. I can only offer a few small pieces of advice (beyond "beware over-OOP" minimalism): 1. Try to find ways to procedurally test your code without as much typing. Consider what I did above, where you store your tests and expectations in a data structure that can be iterated, instead of creating lots of explicit custom variables. 2. Beware over-testing. You have unit tests for various types of invalid input. In Ruby, it is usually idiomatic to expect that a method will be passed proper data. It is idiomatic to neither (a) write code in each method to valid the input, nor (b) to write unit tests that the code explodes in the "right" way when bad input is supplied. This is true for most methods. When you interact with humans or other unpredictable input sources, it is reasonable to specify and test that bad input is properly handled. 3. When using string interpolation, `to_s` is automatically called on the result of your expression for you. There is no need to write `#{"foo".class.to_s}` when you can just write `#{"foo".class}`.
Less words, more pictures (by yours truly, a gazillion years ago): http://phrogz.net/RubyLibs/RubyMethodLookupFlow.png Note that this diagram is no longer law, given the advent of [`Module#prepend`](http://ruby-doc.org/core-2.4.0/Module.html#method-i-prepend) in Ruby 2 (allowing a module to be searched for methods before the class that includes it).
Which is easier? The one where you type two fewer characters, of course. I'm with /u/some_kind_of_rob: if the key is a symbol, I always use the `a: b` syntax. I only use the hash rocket when creating a literal whose keys are not symbols.
So, you're just framing the problem in a way where it obviously won't work, which, to be frank, is a bit disingenuous. How about you have a primary namespace, which is what you get if you first register a gem, and other users can publish to the same name but with a different implicit namespace (e.g. similar to a username prefix) so it's not installed by default unless you explicitly request it. If a gem is updated by someone else, and some set of criteria is met, that new release could then be promoted to the primary namespace. It might be that such changes require a major version number increment, for example - or it might be that the original author has a 30-day right of refusal via email, or use a popular vote, etc, etc. This kind of system would be more democratic as namespace would no longer be an intrinsically valuable/limited supply.
If there are _any_ criteria for making the same gem name that used to refer to one gem refer to some completely different gem that was 'automatically promoted', it seems to me the same danger is there. It's just a question of how often it happens. And of course, if there is no 'automatic promotion to default namespace', then it's essentially just a lot of baggage to give you the same thing you can do now by supplying an explicit manual namespace yourself, eg `ioquatix-rails`
great link. but it is easier to understand (and appears very obvious) to those of us who have enough experience banging our heads in the workplace. It appears however pretty daunting for those who are just starting out or are learning to get the first job/internship. words are better (in some cases) for beginners since they force use to understand the meaning behind them. 
I didn't want to imply a plot, just a small byproduct of a complex-but-fairly-standard dep tree which I had to fight against a while back when trying (and later giving up) to migrate a ruby2.3/rails4.2/sidekiq4.1 combo to "latest greatest", which made me research the changelogs of related projects. I didn't say that sinatra was unmaintained. I've been using it for years and it has mostly been a single-maintainer project, also at the height of adoption, and can't be called complex (basically a 1-file lib) when compared to rails or hanami. I'm sure that there was a checklist of todo's for an eventual v2 long before rack 2 came along, and this is the steady road it must take to get there. But just to put my "losing market" remark into context, let's just remember that this thread is for analysing rubygems download stats, and its questionability as metric (see comments about passenger) has already been discussed somewhere in this page. The fact that most of the ruby ecosystem is volunteer work should really put these changes into perspective. Nothing (euphenism alarm) burns out more a maintainer than being forced to tasks he didn't plan for, specially when you can only plan 4 hours a week, and you have to deal with an inbox full of "I upgraded dep X and now Y complains. Please fix tomorrow!". This is something that the ruby core team got very right, because since the dreaded days of 1.9, their strict back-compat in the 2.x series is the reason why it's so easy to migrate (+ they give me reasons to). See above app stack remark, I'm using (not anymore) "latest greatest". I used rack as just an outlier, I didn't mean to single it out. For ex., at the place where I work we've had some issues with rubygems. Some non-major versions which couldn't be downgraded (having 2.6.6 installed and "update" to 2.6.4, if I remember correctly), API breaking changes which made bundler not compatible anymore, just the ones I remember. And we take it all because there have been huge performance improvements for our use case (people that use rubygems with NFSs know what I mean), but we say a prayer every time we upgrade in production. I haven't done Java for a while. But it's a fact, they are the definition of maturity. They have a good combination of enterprise/OS, market adoption and buzz (.NET doesn't). And they really hate to break your build. The ruby ecosystem could "mature" that way. Latest greatest "sequel" still runs in ruby 1.8 . Rails 5 does force me to migrate to ruby 2.2, but at least they gave me a reason to: removal of non-GC'd symbols DDoS attack vector. In the end, this is all "what do I get from porting my legacy to python 3?"
I just noticed that I miswrote "rack 2" with "ruby 2". apologies for the misinterpretation. 
If it's a simple one-file library, that implies it wouldn't take much effort for it to be updated to work fine with rack2. Why do you think it hasn't succeeded in attracting that effort? Paragraphs make long text easier to read, friend. For whatever reasons, ruby has succesfully avoided losing anyone on something similar to the python 2-&gt;3 split. And maintainers of ruby itself and popular community projects seem lately to understand the needs of backwards compat and avoiding a python3-like-thing even more than they used to, so I'm optimistic things will continue moving in good directions (as they have). I'm not nearly as frustrated with backwards compat issues in ruby as I used to be, although certainly I'm sometimes still frustrated. But there's always a trade-off between improvement and backwards compat, and I think ruby community culturally will probably never be at the Java end. I think Java was always 'culturally' more focused on backwards compat, for whatever reason, it's not like they got there only when they got 'mature', they started there -- and arguably were too far in that direction, hampering improvement/innovation. The way the ruby ecosystem/culture values these things, I would never advocate trying to stay on old versions of software forever. If that's how you want to do things, I'm not sure ruby open source will ever make you happy. But keeping up with upgrades has, in general, gotten easier than it used to be for me, although still plenty of room for improvement. And again, I suspect you'd find node even worse. Since the top of this thread was about node. 
Good points. I think HTTP2's biggest value will be for non-web use cases. For instance, you could operate a database over HTTP2. The value of HTTP in such scenarios is the opportunity for generalization that HTTP provides -- no need to manage connections, deal with re-establishing connections, synchronization, etc. when your client library is doing it. If we ever get around as an industry to buying into REST (not rails "rest"), we could eventually arrive at even _better_ generalizations.
The text editor thing seems like a significant one to me. I use RubyMine and I frequently notice obvious stuff like dead code, unused params, inaccurate YARD docs, etc., in other people's code because the editor points them out for me. And navigating the code to find where something is defined is way easier than it'd be if I had to do a global text search. Yet seemingly everyone insists on just using a text editor anyway.
The reject approach is going to happen in linear time; how could you beat that if you need to copy the hash?
&gt; Most efficient way to remove a key/value from a hash in vanilla Ruby is to rewrite the application in assembly. This case is a bad example but there are plenty of cases where you can make Ruby code much, much faster by reducing runtime complexity, and doing so will make bigger gains than simply translating the same algorithm into a different language. For instance, given insertion sort written in Ruby, insertion sort written in ASM, and quicksort written in Ruby, the latter is definitely going to perform better on very large inputs.
Ruby on rails with puma or unicorn running rails and nginx as the frontend server. Postgresql database. You don't need a JavaScript framework unless you want one.
Ubuntu or CentOS, nginx with passenger, unicorn, or thin as the application server. Varnish for a caching layer. Database of choice, Postgres is a popular and robust choice. Redis for cache/kv store. Or just start with heroku and avoid the ops overhead while you build your MVP.
When you're talking about web development, you have to parts to a site. The server, and the client. The client is what gets rendered by the user's browser (i.e. HTML, CSS, JavaScript). The client side is the "front-end". The server is where all the secret sauce code that makes your app "special" can't be viewed by the client side. This server side is the "back-end". The stack is everything. From the database, to the back-end to the web server to the front-end. The entire thing is your stack.
On every OS, I've always just done `gem push whatever`, and the first time I do this on a new machine, it asks me to enter my rubygems login (email) and password, and I do so, and it saves resultant credentials somewhere and never asks me again. I've never paid attention to where it saves (or how to 'log out'), although I guess that would probably be a good thing to know...
Oddly enough when I try this method it asks for 5he credentials, then immediately errors saying they are invalid 
@Phrogz, thank you so much for the feedback and for taking a look through the project. Especially the tip about not needing `to_s` [when interpolating](https://github.com/mbigras/spiralify/commit/9eb2820f4a455227a94df20435592ccc38cc7ede) :) Can you elaborate on what you mean by over OOP minimialism? I've been trying to wrap my mind around object oriented design and sometimes I feel like it's just too much and would much rather just have a pipeline of functions shaving down my data, but I've been trying to embrace object-oriented code. I feel like alot of my time on this project was spent pondering what I should name my objects and what interface I should present. Would be curious if this is the over OOP that you're talking about and how you avoid it. Also, even though I like the simplicity an organization of your tests I wonder if you see value in having a bunch of tests running automatically with guard. I really love writing tons of tests that automatically run because I feel like it helps me stay focused. 
"less is more". You can rotate the array simply. snail : snail = -&gt;(arr) { arr[0] ? arr.shift + snail[arr.transpose.reverse] : [] } array = [[1,2,3],[4,5,6],[7,8,9]] snail[array] #=&gt; [1,2,3,6,9,8,7,4,5] spiralify : def spiralify(arr) snail = -&gt;(arr) { arr[0] ? arr.shift + snail[arr.transpose.reverse] : [] } snailed = snail[arr.dup] arr.map {|row| row.map {|e| snailed.index(e) + 1 } } end array = [[1,2,3],[4,5,6],[7,8,9]] spiralify(array) #=&gt; [[1, 2, 3], [8, 9, 4], [7, 6, 5]]
I want to buy a new pair of shoes, so I go to a shoe store. When I get through the door I see shoes lining the walls of the store, I know I'm looking for a pair of nikes so I go to the trainer section and pick out a pair. I take this pair to the counter and ask one of the people working there to get me this pair in a size 10. The assistant notes what I want and goes to the back of the store where all the shoes are kept and gets me a pair of nikes in size 10. He then brings it out to me in the front end of the store for me to try on. In this analogy, the store front is the front end. Its the website that the end user or customer sees with their eyes. The back end was the back of the store where the shoes are kept. In web development the back end is a server with a database, the customer on the front end clicks something, or inputs something and that is then sent to the backend for the server to deal with and respond to. Hope this helps.
Urgh, I see gems dropping support for older versions all the time. Dropping support for &lt; 2.2 is a bit extreme even in 2017. Sometimes I wonder whether we at Phusion are the odd ducks out there, still (theoretically) supporting Ruby 1.8.5. ;)
https://www.unionstationapp.com
With our workloads (25-50k rpm, multiple apps) skylight pricing would be even more expensive than NewRelic. 
If you think it can be done cheaper that both New Relic and Skylight then you've identified a gap in the market!
Then tell them about it?
Stupid question, but have you logged in with them on rubygems.org itself to verify that they are indeed valid?
Have you looked at http://opentracing.io/ - I'm not sure if it covers all the use cases, but it's an open standard with a few self-hosted implementations.
Roughly $2,000 for 2 billion requests per month does not sound unreasonable to me. What sort of amount are you expecting to have to pay?
I figured out what it was! For some reason running the command in RubyMine caused the timeout, but running it via console ran fine. It only needs run once so ran it in the console and switched back to push. Thanks for the help!
No, I meant... what makes that "the standard"
Most people get this slightly wrong. A front end is an application interface, including an HTTP server running rails, for instance. A back end system does not face the public, but receives instructions from front end systems. Applications that are written entirely within a web server like Rails (plus background jobs) are entirely front end systems. Backend systems are comprised of software that is not dispositioned for any particular interface. Working on backend systems is the job of any ole computer programmer. Web frontends are the work of web developers.
Ah so it was standard for your last job... ok
appsignal looks pretty nice. Do you have experience with it yourself?
Using `.transpose.reverse` to "rotate" the array is brilliant! Well done, sir-or-madam!
Do you know of any other self-hosted projects that can intake, index and display structured data? If not, ELK does seem to be the standard. 
Yeah, but I wouldn't consider ELK as a replacement for NewRelic... from all the answers here, Skylight seems to be the closest one... And yeah, there are many other options that put together serve the same purpose... i.e: fluentd + influxdb + grafana 
break? loop { break if condition }
Generally, you don't want to modify an enumerable while you're looping over it. The more idiomatic way to accomplish this is as a recursive function. def reject(array) new_array = # do rejection logic here if array.length == new_array.length # We're done here array else # Recurse with the shorter array reject(new_array) end end
Just have 1 paid server with detailed monitoring and put the rest of the servers on a separate free account.
Skylight is another hosted service, not roll your own. There are definitely a bunch, Scout is another one which wasn't mentioned. ELK is not a replacement for NewRelic, but it is probably the closest thing. Grafana is focused on time series data. I don't think it can answer the questions the OP posted, whereas Kibana should be able to.
Not much with the product itself, but the team making it is great.
Can confirm. Puma and serve static assets with nginx via reverse proxy.
At your scale (you're talking over 1B requests/month) you should either be doing it in house or sucking up the cost of NewRelic. Surely it's a drop in the bucket compared to your other infrastructure costs?
Yeah, but self-hosted is not really what's being asked for. I think for the price the OP is already paying, Skylight would be a nice option... compared to the time you'd have to spend setting up the ELK stack and all it's surrounding components, Skylight becomes really attractive... My point really was that I don't think there's really a standard for this or that you could state ELK as "the standard", it all depends on time/money/effectiveness for whatever is being asked, and from what the OP asked, I'd stay with Skylight, but meh... to each it's own.
It's a fine line between telling people about a better way to do things and being condescending. 
How much do you pay for it?
I am the CEO of Instana (www.instana.com) - we are a new APM vendor with powerful capabilities also for Ruby. Our pricing is different - you pay us per host, independently from the load, size etc on the machine - the list price is $50 per host/month for full features, including Tracing, EUM, Infrastructure monitoring, Service Management, etc. Discounts on higher volumes available. No extra or hidden cost for sure! Shoot me an email if you want a free trial - we offer SAAS and OnPrem. (mirko.novakovic at instana.com)
You could use something like `nil while array.reject! { |element| logic }` Even if that seems like an abuse of the while loop, I think the intent is pretty clear: Do nothing until `array.reject!` stops returning a truthy value.
I've used it across several businesses. It is easy to deploy and customize, and the price is right. The hardware requirements and running costs are a fraction of the managed solutions offered by NewRelic, StackDriver, CloudWatch, Skylight, DataDog, etc.
Librato offers something similar. I think datadog do too but haven't seen their's in action yet
not a ruby guy, but this sounds like a job for a map/reduce type construct.
Can you post a more detailed example of the input you want to pass to the method, and what the collection contains?
There doesn't seem to be a tremendous amount of information about SubstrateVM at the moment. Is it related to jlink in any way? Seems to be a similar concept.
super cool
What makes this a draper substitute, or draper-style?
&gt; Note that an array is always 'truthy', even an empty array, so I think as you've written it I think the while condition will always be true, which seems not so useful? [`#reject!` returns `nil` if no changes were made](https://ruby-doc.org/core-2.2.0/Array.html#method-i-reject-21). Though I'm beginning to think that if it confuses so many people, I should take a hint and find another way.
Recursion! Why didn't I think of that?
So this totally works! But only for curly braces and not `do...end` (due to precedence), and of course it's a multi-line block, and of course the style guide mandates `do...end` on multi-line blocks. Thanks for the idea though.
What do you mean by "that's no patch on QT/GTK" ? 
See [my response](https://www.reddit.com/r/ruby/comments/5ox7t0/an_empty_while_loop_where_all_the_logic_is_in_the/dcnlizc/) to /u/JustinCampbell.
There are 2 answers to this question, choose the one that you like the best: 1. They are not. (Ifs are also a smell.) 2. Case statements have a tendency to grow, the easy option is to always add another case. Ifs are more likely to get refactored away because once you have a bunch of them you you end up with nested if/elses you are more likely to notice there is a problem. 
Very useful! I think I'll do it myself :) Thanks for sharing
You might want to take a look at GitHub's solution for this: https://github.com/blog/1345-introducing-boxen
I'm not an expert, but relying on ActiveRecord without rails seems a bit overwhelming and painful. Why don't you try other ORMs like Sequel ? I have a little project which uses it: https://github.com/estebanz01/uwrrugby It's not perfect code 'cause it's an MVP, but it can be a start if you decide to move to Sequel. Now, regarding your question, checking this: https://stackoverflow.com/questions/38212305/cant-access-localhost-on-ruby-on-rails it seems an issue with the gem. Check that your env is loading the SQLite3 gem as expected. You can use bundler and a Gemfile for that.
What would be the benefit of using Puppet? I found some limitations with brew and cask if you want to install specific version of an application. It is not really meant for it. But also, it is a very simple solution.
Happy to help :)
You should check out http://www.theodinproject.com.
Have you thought of joining a free online course? There should be some at Coursera or similar websites. They have the benefit of often being free, to have a specific course load designed to teach you gradually, and finally they bring you in contact with other students, and give you a way to talk to them and discuss problems and assignments (usually a forum). A lot of the courses I found with a cursory search teach you Ruby On Rails, and I'm not sure that's what you want, but you should be able to find a course for pure Ruby if you look a little harder. 
Try `RAILS_ENV=test bundle exec rails db:create db:migrate`
This is paid but a decent resouce: https://www.codeplace.com/ You could also look at Upcase once you get more comfortable: https://thoughtbot.com/upcase
While finding places to learn online are more than plenty, I offer answering any questions you have via chat for free. I prefer using slack, so I'd recommend joining the rubydevelopers slack as a common place (https://rubydevelopers.typeform.com/to/l7WVWl) I'd offer more, but my spare time is already taken between life and RailsGirls... plus I live in EU... Hope it helps.
Plus content is almost exactly the same...
I use this. In the Ruby codebase I work on a command +r and fuzzy name of what I want. Works fine for me. Go has Oracle and my editor integration uses it to jump to what I want. The choice of editor or IDE is really just how much setup you want out of the box. Also rubocop handles detecting a lot of those. 
Rubykoans are also great. They teach you alittle bit about testing also which is a plus. Theyre on github if anyone wants to help with a link
Feel free to DM me. I write Ruby for a living and am happy to help someone learn, no money required.
Oh... That sucks... Well nevermind then!
TruffleRuby has the potential to be transformative technology for Ruby. It aims to move Ruby from the slow dynamic language class to V8 (JavaScript) / JVM (Java) levels of performance. It can NOT be understated, that will be HUGE!! Less need to move to Node.js, Elixir or Go if TruffleRuby is just as fast (or even sometimes faster than those technologies). optcarrot already runs 9 times faster on TruffleRuby than MRI, Ruby 9x9? I really like that the TruffleRuby crew are aiming for a drop-in replacement for MRI rather than chasing Java compatibility (JRuby already does that). The C-extensions work will interesting as well as SubstrateVM. In my opinion to be an MRI replacement SubstrateVM will be necessary. P.S. There are more developers working on core TruffleRuby than there are core developers working on MRI. This is a serious effort.
Of course it "works," but it's slower and more error-prone, and the extra cognitive effort janitoring it is energy you could be putting toward your main task. If Rubocop detects the things I'm talking about then ours is set up wrong.
Tealeaf academy (now launch school) is paid but was completely worth it for me. Guided lessons and periodic chat sessions going over miscellaneous topics.
Ops, sorry for the confusion. Really, it hasn't been intentional...
I have had no issues in my career using a text editor. If you find them hard to use, don't try to project that on the editors themselves. If you work better with an IDE then go for it. I'm not saying editors are superior. I'm saying they aren't inherently unproductive just because they don't run a truckload of analysis in the background it off the box. I started with an IDE and as I grew as an engineer I migrated to the editor when I was capable of seeing the issues your relying on the editor for. I also moved away from the IDE to prevent my dependence on then like they are "required" to write software. Because they most definitely are not. 
No, it's basically a whole new JVM that compiles all your code AOT and has no external runtime. https://youtu.be/FJY96_6Y3a4?t=10023
I have to give you credit for the simplicity of your setup. To be honest, I still do things the same way. And having an extra server for puppet is a hassle, of course. But I plan on changing to the puppet way for the following reasons. Imagine the following: you have at least 2 machines you develop on or want to have the same packages and configs on. (If not local, let's say your MacBook and a server.) They do not have the same Distribution or not the same release of one distribution. Still, you want them to have the same packages that you need for doing stuff (e.g. ruby, maybe Vim or the likes + config). Puppet lets you setup exactly that. Now imagine you change let's say your Vim config and add another ruby version. Puppet can now push the changes to both machines instead of you doing both manually or changing your script and rerunning that on both machines, which is, essentially, no automation at all anymore.
Oh, I didn't know that, thanks. 
for me codecademy -&gt; ruby koans -&gt; codewars has been a great way to learn (in that order) codecademy is like a tour of the syntax and functions, koans reinforces that knowledge and codewars lets you solve progressively harder problems
Actually the guy is just reposting Hot Weekly Posts from /r/ruby
git gud m8. 
That's not the logical conclusion of my thinking. I never advocated against those tools. I don't see your point at all. 
You could try something like [swagger](http://petstore.swagger.io/#!/pet/addPet) or [raml](http://raml.org/) 
You claim the tools of the IDE aren't strictly necessary so if you're sufficiently experienced there is no benefit to using them. If that is true then the same logic should apply other nonessentials, like syntax highlighting, that many text editors provide.
Not quite. I claim that _some_ of the tools are not strictly necessary. I never say there is no more benefit using an IDE and I never say using an editor is better. You were quick to dismiss editors because they don't tell you all the things an IDE tells you. Fair enough. That's your preference. But I was pointing out that your preference doesn't inherently make IDEs the best and only tool. And just because someone uses an editor doesn't mean they cannot identify these problems that you can. You should stop trying to dismiss me with Notepad. I'm not talking about Notepad I'm taking about extensible editors designed for code like Sublime Text, Atom, Visual Studio Code, Vim, Emacs and to a lesser degree Notepad++. **edit** But you aren't wrong. All you need to write code is a way to store encoded text in a file. All the fancy tools are just additions that help out in varying ways. 
Taking an argument to a ridiculous extreme is a logical fallacy, it's referred to as a "straw man" attack. You have successfully proven that IDEs are logically superior to Notepad. Nobody was arguing that though. I would not blame the tools for the work of an engineer. I think I've written maybe 2 infinite loops accidentally in the last two years and neither would have been caught by static analysis so that feature would have not "made me better." From what it sounds like you just haven't had the opportunities with highly talented people. I've definitely worked with some mediocre engineers where opening a file was a nightmare of broken shit. I still do (at least they were at the company at some point, don't really know if the original authors are still around). My point here is that the tools do not make the developer. You can't give an IDE to a mediocre developer and watch then write good coffee with no glaring flaws. You just fix a few minor issues. If your only argument for piles of tools is to prevent "bad" work, I'm sorry to say, your theory is wrong. 
^Hi! ^Here's ^a ^summary ^of ^the ^term ^"Strawman": ---- ^^A [^^straw ^^man](http://rationalwiki.org/wiki/Straw_man) ^^is ^^logical ^^fallacy ^^that ^^occurs ^^when ^^a ^^debater [^^intentionally ^^misrepresents](http://rationalwiki.org/wiki/Red_herring) ^^their ^^opponent's ^^argument ^^as ^^a ^^weaker ^^version ^^and ^^rebuts ^^that ^^weak ^^&amp; ^^fake ^^version ^^rather ^^than ^^their ^^opponent's ^^genuine ^^argument. ^^Intentional ^^strawmanning ^^usually ^^has ^^the ^^goal ^^of ^^[1] ^^avoiding ^^real ^^debate ^^against ^^their ^^opponent's ^^real ^^argument, ^^because ^^the ^^misrepresenter ^^risks ^^losing ^^in ^^a ^^fair ^^debate, ^^or ^^[2] ^^making ^^the ^^opponent's ^^position ^^appear ^^ridiculous ^^and ^^thus ^^win ^^over ^^bystanders. ^^Unintentional ^^misrepresentations ^^are ^^also ^^possible, ^^but ^^in ^^this ^^case, ^^the ^^misrepresenter ^^would ^^only ^^be ^^guilty ^^of ^^simple ^^ignorance. ^^While ^^their ^^argument ^^would ^^still ^^be ^^fallacious, ^^they ^^can ^^be ^^at ^^least [^^excused ^^of ^^malice.](http://rationalwiki.org/wiki/Hanlon%27s_Razor)
You should know that all of your concerns have been addressed now. I've also included tests to demonstrate the correctness of the approach.
It's a strawman if your argument is misrepresented and then this weaker argument is refuted. If your argument is used accurately to an absurd conclusion it's reductio ad absurdum, which is not a logical fallacy. What you're saying is an ego-driven fallacy, in my opinion. Everyone makes mistakes writing software sometimes. 
Check out Gosu for a super simple game lib, and Ruby GTK for making apps.
I've made no ego-driven fallacy. &gt; Everyone makes mistakes writing software sometimes. I admitted to making mistakes. &gt; I think I've written maybe 2 infinite loops accidentally... Which part of that is me claiming superiority over _anyone_. I'm talking specifically about infinite loops here, which I find rather easy to avoid. This is a callback to a point you specifically make in your original comment. I'm not saying I made "two mistakes" I'm talking about a very specific _kind_ of mistake. FWIW the language I primarily use offer functional style iteration, it's nigh impossible to write an infinite loop with combinations of "for each" and "map" executions. The language I use where functional iteration isn't a very useful option offers another controlled looping construct that effectively mimics the "for each" approach. So I don't really think it's my "skill" or "ego" that makes me believe that I've only made a couple of infinite loops in the past. It's my actual experience. If you actually want to me to list off _every_ mistake I've ever made then sit back, we'll be counting for a long time (and yes, I'm just referring to writing software). Some of them date back to a whole 24 hours ago. As to everything else I said, not sure who saying that the tools don't make bad developers better reflects on my ego at all. If I was a bad developer, I'd be saying that tools won't make me any better. If I was a good developer, I'd not be talking about myself as I specifically pointed out the issues you run across are more attributed to who wrote them then what editing utility they used to write them with. You did misrepresent my argument. Maybe you didn't think you were, but you did. I was pointing out that the use of an editor in place of an IDE did not imply the output code would be worse or that work would be slower. You argued against me claiming that no tools are necessary to write code. I did not claim that, that's not a reduction of my point it's a misrepresentation. But your "absurd" reduction isn't absurd. It's perfectly plausible. Coding without static analysis, syntax highlighting and a variety of other tools is plausible. It has been done before, and there are still studies that take place in relatively recent times trying to determine how much, if any, syntax highlighting _really_ improves code clarity.
Computer programs? Yes! Ruby is a very nice scripting language. You can build CLI tools quite easily with it. Games? Yes! For instance, RPG Maker used Ruby for the game engine. Web? Yes! Look at Rack, Sinatra or Ruby on Rails.
The tradeoff that ruby makes is that it runs slowly, but it is easy to program. &gt; Can you make useful computer programs? Are you asking about desktop applications? Ruby is not a great fit, because users will complain about how slow your application is. &gt; Can you make games? Games are the most speed-intensive programs, and so are the worst fit for a slow language like Ruby. &gt; Can you program web with it and how? Web applications are an excellent fit for Ruby because they have very low speed requirements. Most users would be extremely happy with a web page that loads in 1 second (as opposed to a game, when the character moved 1 second after you pressed a button). Ruby on Rails is the most popular web framework and is the main reason that Ruby is popular today. Try running through this very simple tutorial: http://guides.rubyonrails.org/getting_started.html 
Concurrent and parallel are exactly the same thing... they mean running at the same time...
Huh! That wrinkled my brain. I've been meaning to learn more Go, too; thanks for the link!
When looping through each line, you can use regex to extract the number. This will get the first number from each line. Instead of the string, you would pass in the line. Once you have all of the numbers, you can get the max. "There are 4 cats in my 1 house."[/\d+/].to_i =&gt; 4 And on lines where there is not a numerical value, it would return zero. "Number of dogs in Mark's house"[/\d+/].to_i =&gt; 0 
While that statement is certainly not even close to correct, the reasons are also not what you're leading to. First off, uniting C/C++ and C# under one banner makes no sense. They're wildly used for different reasons. C/C++ Is dominant because it's old as balls and lowlevel as hell. It's the only option for a subset of optimization problems, but these days, that subset is shrinking. C# is wildly popular because of the ecosystem MS has build around it, and it basically being a slightly better java. It also happens to be the hooking to a few popular engines, making it common in games aswell. That does not in any way make them the best option for all intends and purposes. A nice hearthstone card tracker overlay was recently implemented in rubymotion (and later ported to swift to allow more contributors). If you're a one man army, taking on writing fullfledged GUI desktop app in C++ will very rarely be the right decision. 
Thanks!
&gt; GIL (Global Interpreter Lock) which doesn't let you have "real threads" which its creator promised we would look into it in ruby 3x3 (which has a ETA until 2030 :v ) This is limitation of MRI, not Ruby. If you want parallelism today you can use Rubinus or JRuby. 
I think this may be what you're looking for: https://github.com/razum2um/lurker/blob/master/README.md
No problem!
You can't sort variables - you can only sort values. And an array doesn't contain variables - it contains values, which in this case were read from a variable, but by the time you sort the array the variables have been read and forgotten about. Are you familiar with any other programming languages I could relate this to? It sounds like you may be making a classic beginner mistake of misunderstanding the relationship between variables and values.
As I already said twice in this sub (I'll just quote): --- * programming contests * ACM * A.I. * artificial intelligence * game bots * social moderation * social network analysis * graphs * ratings * game tools * ratings * Quake configs generation * WinAPI/Applescript autoclicking * Sinatra hosted games, multiplayer * graphics * pixel formats * SVG * procedural generation * chat clients * prototyping before other languages seems like just **everything** --- And the coolest thing at my current job I did is a 98%-correct prediction of whether the advertisment image is gonna pass FB moderation.
The reason is just that Borland made a C++ Builder and Microsoft made a Visual Studio.
Java Swing also exists. Why hasn't that become the dominant way of writing desktop apps?
What are you trying to accomplish? Sorting variables isn't possible, only sorting values.
Windows: C# macOS: Swift Linux-based: I don't do GUI... CLI apps mainly here 
What is your goal with programming? What are you like? Most of the reasons for picking a language are going to be cultural. If you want to get a job as fast as possible, then Java's great because tons of companies use Java. If you want to make games, what kind of games do you want to make? How? Game engines are usually written in C, but you can write a game engine in any language. Blender is completely decent and written in Python, which is very similar to Ruby. If you want to write games on your own with an engine already built for you, Realm Crafter uses Ruby for scripting. RPG Maker uses Javascript. Unity let's you program games in C#, and Stardew Valley is written in C# and has made a ton of money. If you just want a job though, and it has to be primarily Ruby, then your job will probably be doing work in Rails, a web backend framework. The truth is, if you're just getting started, Ruby is a great language to get started with that gives you a lot of flexibility and gets a lot of details out of the way. It gives you a look at procedural, functional and object oriented programming. But if you're serious about programming, you probably won't get away with knowing just one language, and you won't be stuck with it forever. You aren't getting married to Ruby. Besides, I had my eye on her first. :P
Well, I've spent a number of years at a Ruby-on-Rails shop and wrote a video game in Ruby during grad school, so I do like Ruby quite a bit. And honestly, it comes down to what you are trying to do. I basically only write scripts using dynamic languages. (I'm now at a Python shop, so currently switching to that). Automating interacting with APIs or something that I can run on the command line. If I need a UI in that situation I'll reach for Sinatra (now Flask) and just interact via the browser. (Side note: Rails/Django are really popular and there are a ton of articles talking about them so I'll leave them out) If I am making a native app (one that cannot run while interacting in a browser), I'll go for the OS's native language of choice. Microsoft and Apple have spent _a lot_ of time hooking C# and Swift into their systems. It's definitely the easy path. Java/Swing is a more generalized solution. I haven't spent a lot of time with it, but it's not the "blessed" solution for either OS. If you want all those swanky animations in macOS, you'll have a much easier time in Swift. Another thing to consider is deployment. Is the app for you and you alone? Use whatever you want! Learn new cool things and hack stuff together! ... Or do you want to distribute it? Asking anyone who isn't a Ruby developer to install RVM/Bundler (or even just as a gem) is going to be a _huge_ impediment. C# and Swift have a ton of tooling around packaging (MSI/DMG) and distribution (each App Store). That was a bit long-winded... Sorry if there are typos, I'm on my phone. 
Not at all; that was the type of answer I was looking for. Much appreciated!
I was afraid I might have to. Not quite sure how to do that. Could you point me in the right direction?
* Find the one with the most stars * Check the outstanding issues and pull requests. Make sure there's not a lot of people saying that it's broken. Install the gem and test it out. If it doesn't work, check out some of the other options. Don't worry so much about the commit activity. I was writing web apps that use the Reddit API over two years ago, and they worked just fine. Nothing has really changed with the Reddit API, and there haven't been any big changes in the Ruby language, so I think you'll be fine. There probably just hasn't been any reason to update the gem, because it still works perfectly fine. I'm starting to see a lot of gems like this. Rails is now getting very mature and stable, so there's a lot of code out there that just works and doesn't need regular updates.
If you care about single line tests then you have already thrown this care out the window. My humble opinion at least. 
Agreed. Try and use it, if it doesn't work out of the box, try another and so on. After spending a little time trying them, resort to forking and updating.
Why would you have floats for the amounts? Why are timestamps not beginning every hour? Why are some amounts greater than 10? I would think that every time a request comes in you just need the IP address and you can calculate the Time.now and use this info to look up and add clicks if it's under 10 class ClickTracker def initialize @clicks = [] end def &lt;&lt;(ip_address) time = Time.now beginning_of_hour = Time.new(time.year, time.month, time.day, time.hour) click = clicks.find { |click| click[:ip] == ip_address &amp;&amp; click[:amount] &lt; 10 &amp;&amp; beginning_of_hour == click[:timestamp] } if click click[:amount] += 1 else clicks &lt;&lt; { ip: ip_address, timestamp: beginning_of_hour, amount: 1 } end end private attr_reader :clicks end
In postgres, ILIKE with leading wildcard can be matched by [Trigram indexes](https://www.postgresql.org/docs/9.6/static/pgtrgm.html).
[TIL `===` binds more tightly than unary `*`.](https://eval.in/721837) By the way, is [this](https://eval.in/721888) the sort of thing you have in mind when you say "[t]riple equals in conjunction with Hash and Procs"?
There are good reasons why `its` was removed from rspec-core: https://gist.github.com/myronmarston/4503509
Migration code will be like ```ruby enable_extension "pg_trgm" add_index( :table_name, :column_name, using: :gin, # order option is required, # otherwise operations with ILIKE will NOT use the index # # References: # - https://niallburkley.com/blog/index-columns-for-like-in-postgres/ order: { column_name: :gin_trgm_ops, }, ) ```
Personally, anything to do with Ruby and GTK. There's spec docs out there but no tutorials or simple examples.
Well, there are "good reasons if you use RSpec as a documentation tool" -- the only real argument there is "documentation will not be clear", with preferred replacement "don't use one-liners at all", as far as I can understand. But when you need to just write a lot of expressive, terse, easy-to-refactor specs for complicated codebase, then its(:name) { is_expected.to eq 'Bob' } is waaaay superior (for me) than it 'should have the correct name' do expect(user.name).to eq 'Bob' end The same things could be said about my additions.
Nope! You can definitely add things to arrays. Adding a new element to the end of an array is typically called "appending" or in ruby "pushing". One great thing about Ruby is that the official docs are pretty good, so while they won't have answers to higher level things like "how do I sort variables", they *do* have answers to things like "how do I do x with an array". Since the docs are the first place you usually go for things like this, instead of answering directly I'm going to link you to this: http://ruby-doc.org/core-2.4.0/Array.html Those are the docs for the Array class in Ruby. Learn to love them, because you'll see that page alot, even after you've been programming for years. CMD-F/CTRL-F and search for "append" or "push" on that page and see what you find! There are actually a few different places there that will give you what you need. I guarantee that once you learn how to navigate the docs you'll feel like you "leveled up." Then you won't get stuck on things like "how do I do this single thing" and can focus on getting stuck on things like "how do I combine all these single things to do a thing?" which is way more fun.
I am interested in articles related with making ruby fast. Either by writing it more efficiently, or by not making it do what it shouldn't do (i.e. SQL instead of ActiveRecord + each).
 it { expect(user.name).to eq 'Bob' } Or, since `specify` is an alias for `it`: specify { expect(user.name).to eq 'Bob' }
Nice post. You could simplify: let(:resolver) do resolver = instance_double('resolver') expect(resolver).to receive(:fetch_net_request).and_return(service_result) resolver end to let(:resolver) { instance_double('resolver', fetch_net_request: service_result) } Also, one thing I found a little strange: The first argument to `Fetcher`'s initializer is `limit_data_items`, but if a `resolver` is injected then this is never used.
On the surface, Elixir and Ruby share a similar syntax. This familiarity may at first hide the striking differences between the two languages. Read my gentle introduction for Ruby developers intrigued to learn more about Elixir. Discover the language, created by JosÃ© Valim, that took the Erlang virtual machine (BEAM) and put a sensible face on it.
Well, the point against `rspec/its` is "it generates wrong docs!" Now, try this: class User &lt; Struct.new(:name) end require 'rspec/its' describe User do subject(:user) { User.new('Bob') } it { expect(user.name).to eq 'Bob' } its(:name) { is_expected.to eq 'Bob' } end That's how RSpec outputs those two: User should eq "Bob" # it is for your it name should eq "Bob" # it is for its So, `it { expect(user.name).to eq 'Bob' }` is worse by any means: less DRY, less readable, wrong docs. Therefore, I assume the author of the [gist](https://gist.github.com/myronmarston/4503509) meant that you MUST write it 'should have the correct name' do expect(user.name).to eq 'Bob' end to have output like User should have the correct name E.g. his point was "description-less `it` is EVIL!" But what is YOUR point now?
More of things like this: https://gist.github.com/baweaver/f259116b6734e0c8ea8a4a24fb62512f https://gist.github.com/baweaver/3273c626cc96a6959843beadb721d0b5 and other evil that utilizes the fact that hashes and procs have a shared accessor style ( [] )
Probably, the community needs those reminders on difference between implicit and explicit conversions every now and again ([guilty](http://zverok.github.io/blog/2016-01-18-implicit-vs-expicit.html) myself!) But probably it would be a bit better to mention that `to_s`/`to_str` is not the only case ;)
 Object.constants.map { |c| Object.const_get(c) }.grep(Class).select { |c| c.instance_methods.include?(:to_str) } # =&gt; [String] :philosoraptor: (ok, it is only for core classes, but stdlib could be checked with `grep "def to_str" lib`, and also has nothing) Probably, it was meant for "custom String-alike object implementation"
&gt; its creator promised we would look into it in ruby 3x3 (which has a ETA until 2030 :v ) Ruby 3x3 is intended to be fully ready for 2020, and new features are going to be coming step by step. https://blog.heroku.com/ruby-3-by-3/ If I remember correctly (someone correct me please if I'm wrong), in one of his latest conferences Matz said that guilds might be available during 2017.
To what everyone has said, I'll add cross-platform app development using [RubyMotion](http://www.rubymotion.com/).
Wow, I feel like my whole conception of the universe is slipping out from underneath me. I tested this over the weekend because I was considering using `to_str` for something, and it worked fine on any `Integer`. I must have been doing something wrong, or had some monkeypatch activated. Well, that makes `to_str` even less interesting.
I wouldn't try to 'vendor' your gems between different OS versions, and don't really see any purpose to it anyway. The Gemfile.lock is already specifying _exact_ versions of gems to be used, that's enough. Just bundle install on the proper OS. 
the bundle install part is what I don't want to do in production -- what would you do if a certain gem just wasn't available? [It's happened before](http://arstechnica.com/information-technology/2016/03/rage-quit-coder-unpublished-17-lines-of-javascript-and-broke-the-internet/)
Thanks, looking forward to your feedback.
Fwiw elixir is _divine_. I stopped programming as much so I didn't make full use of it, but the function definition variability that erlang offers is so fun to use in lexer/parser programs. It truly is a wonderful marriage of what makes both so great.
TL;DR: Dependency injection
I'm not sure of Travis supports this but here is my solution that I built on GitLab CI. Since CI has different runners for its builds, I have an Amazon instance that is spun up in the first part of the build which runs from a different runner. That Amazon instance will be running a CI runner that actual builds the release artifact and it runs the same architecture as my production instance. Then another runner will shut down and destroy the build instance. There are other steps to run tests and deploy the artifact but that's besides the point. Again, I don't know if Travis supports this but I know that GitLab is somewhat similar to Travis. 
Oh wow thank you, I won't make that mistake again!
`my_name.length = sisters_name.length` is attempting to set the value of my_name.length to that of sisters_name. You're using the assignment operator (=) when you really meant to use the equality operator (==). The error message is (rightly) telling you there is no method `length=` in the String class. If you look at the String documentation (https://ruby-doc.org/core-2.4.0/String.html#method-i-length for example), you can see length is a getter, and that there is no setter (good thing, you don't want your string length being set arbitrarily and away from the actual string length).
/u/0x0dea has it right, you're sorting them as `String` rather than `Integer`. Remove the quotes around the numbers in the `Feline.new` lines and it'll work. I've got a few other pointers, about general Ruby style. - Variable names should usually be snake_case, rather than how you've written them. So `cat_one` and `cat_two` instead of `catone` and `cattwo`. Much easier to read! - Don't use `attr_accessor` if you don't need to change the value later on. Since I imagine these cats won't be changing the number of spots they have, you're safe using `attr_reader`. This makes it a bit clearer for anyone reading your code that they shouldn't be changing these variables, and it'll warn you (by failing) if you try and change them later on. - I hardly ever see `Array#push` in the wild. The more common syntax is to use `&lt;&lt;`. Instead of `data.push(catone)`, use `data &lt;&lt; catone`. I don't know that there's a concrete reason for this, but it's definitely the "Ruby Way". - Following up that last point, rather than creating, filling, and sorting the `data` array over seven lines, you can tidy it up by using an array literal and doing it all at once. For example: ``` data = [catone, cattwo, catthree, catfour, catfive].sort { |a, b| a.cat_spots &lt;=&gt; b.cat_spots } ``` - There's also a bit of wonkiness going on with your indentation inside the `Feline` class, but I'll chalk that up to the dangers of copying things to the internet! Cheers!
&gt;you are technically setting my_name.length to a new value which is sisters_name.length; which is not wrong &gt;which is not wrong Isn't it though? Any .length is an objective value. Bob has 3 letters, so Bob.length will always == 3, even if I say it equals kate.length, because that's impossible. 
Have your own repo of gems? We use a local mirror instead of rubygems. 
sorry my explanation was a bit fuzzy (should had structured it correctly). Yup, its impossible to a variable that is already defined. What I meant is that you can change that variable if there was no ".length" in front of it. 
Ok gotcha, thanks for the help.
[removed]
Light gray on white makes that page rather hard to read.
Thanks for the feedback. I've changed the text to a darker grey to increase the contrast.
Thank you, and thank you for writing.
`foo = bar` is pretty human-friendly shorthand for `foo=(bar)` In the same way, `bar + baz` is human friendly shorthand for `bar.+(baz)` in ruby, `=` and `+` are methods like any other, with a bit of syntactic sugar that allows you to use them as operators. remembering this can often help with cryptic error messages, and you can define these yourself too! class Foo def &lt;(n) n == 'bar' end end Foo.new &lt; 5 =&gt; false Foo.new &lt; 'bar' =&gt; true do this only responsibly, of course. Can and should are different things. 
I did not know about `to_int`, but I did know about `Integer`. Nice article. I also didn't know about `coerce`. It's very interesting that it's possible.
Castaway sounds really cool!
Ahh couldn't you say improvement or update right from the start.. why call it patch, it's not a bug or something like that.. thanks for explaining though...
To start learning Elixir, you'll have a great intro from the following two books: - [The Little Elixir &amp; OTP Guidebook](https://startlearningelixir.com/r/the-little-elixir-and-otp-guidebook) - [Elixir in Action](https://startlearningelixir.com/r/elixir-in-action) [Programming Phoenix](https://startlearningelixir.com/r/programming-phoenix) is your best option to learn the Phoenix web framework. Once you're comfortable with Elixir, then take a look at [Designing for Scalability with Erlang/OTP](https://startlearningelixir.com/r/designing-for-scalability-with-erlang-and-otp) for more in-depth guidance.
It's just a saying. Ask your grandparents.
https://en.wikipedia.org/wiki/Rubber_duck_debugging
Don't just assume everyone is a native English speaker... but thanks for explaining.
Love this. 
This implies you're going to deploy a compiler to your production server. Not a good idea IMO. Not the right deployment topology either.
&gt; `Integer(23)` &gt; &gt; [...] &gt; &gt;In this case, Kernel invokes #to_int on the received argument (23 or "foo"). In our example, 23 works because Integer implements #to_int, while "foo" raises an error because String doesn't implement that method. This can't be true since then `Integer("2")` would raise a `NoMethodError`, but it works just fine. &gt;We have seen that Ruby is a great language. Okay.
Personally, I think using Rails 5 in API mode works really great with Angular2. Throw material design on top of that, and you can really hit the ground running.
I'm working on a small web application serving up JSON using Flask. There's so much Rails gives you right off the bat, you really don't appreciate it until you don't have it. I love Flask, but Rails has far less boilerplate.
That and the class.methods to list out all available methods of a given class quickly were the biggest help I had in learning Ruby.
That's kind of the point of flask though. 
What makes Rails 5 + API mode preferable to something simpler and arguably more powerful for that purpose like Roda + Sequel?
And sinatra
About 12 years worth of already solved problems.
Right, but when those Flask apps wind up growing into bog-standard HTTP CRUD apps, suddenly you have your own hacked together version of half of Rails. I do love Flask but I've seen it used in ways where Django (or Rails) would have been a better fit. Even if you don't use 40% of Rails, it's better than having to write 60% of it over again
Part of that is due to the fact that Python requires you to be more explicit than Ruby does, probably, but yes, Rails is very opinionated. The trade-off with using Flask, or even other Ruby web frameworks like Sinatra, Padrino, or Hanami is that you have much more control over individual components.
&gt;when those Flask apps wind up growing into bog-standard HTTP CRUD apps, suddenly you have your own hacked together version of half of Rails. Any sufficiently advanced ~~Sinatra~~ Flask app is indistinguishable from Rails?
As a fairly new web developer, I am still really surprised that no one offers a "ruby on rails" in JavaScript. I love the ideology behind RoR, let's standardize some stuff so that anyone can pick up your code and get to work immediately, let's create tooling that gives time back to developer to write code and not set things up, etc. JavaScript is the only language I know so far, and it feels like a lot to have to learn Ruby just for this ideology. MEAN stack started coming close, but even then, there are so many different ways to structure and build node and angular apps that it doesn't quite have the same level of convention that rails does
Just think of something to build: -tic tac toe -yahtzee -file encryptor -menu based shopping program (think Command line) -postfix calculator -a Q and A game -user input and file i/o program. Maybe let the user specify how many numbers they want to enter, then allow them to enter that amount. Maybe take those numbers, find the mean/mode/median, and write them to a file. Or maybe no user input and read from a file, find mean/mode/median, and write to a file. Just a few ideas. Feel free to PM. 
The first problem is that you're mutating the path after it has been stored in `path_collection`, which is why all the results are the same (they are in fact the exact same array object). You just need to copy `path` array before you store it. So `path_collection &lt;&lt; path.dup` instead of `path_collection &lt;&lt; path`. The second problem is that you're never removing nodes from `path` as you traverse the tree. For example, you recurse into node `3`, add `3` to `path`, but the `3` stays in the path permanently, even after the method returns. You just need to pop the last value off the path, after the recursion but before the method returns. A simple `path.pop` will do the trick.
Part (not all) of the reason why Rails is so powerful is because Ruby is a great language for creating DSLs. There are meta-programming features of Ruby that allow it to be great for expressing quite complex ideas without having to write a lot of actual Ruby code. I've seen a bunch of Javascript based frameworks (Sails for example) which give you MVC and other goodies like ORM, but because Javascript doesn't have the meta-programability of Ruby, a lot of the apps read very verbosely (e.g. https://github.com/sails101/basic-login/blob/master/api/models/User.js). I'm a fan of Javascript for my front end work, but comparing that User model to a Rails User model is really no contest in terms of readability etc.
`to_s` is explicit (the object can be represented as a string) `to_str` is implicit (the object is meant to be string like)
Good ideas. Also, if you want to go crazy with Ruby, do these programs without using the keywords "class", "def", "new". Use metaprogramming to define your objects or classes instead. I did this when I was picking up Ruby and it helped me understand how things like dynamic finder methods (ex, find_by_classroom_name(str)) in activerecord are generated.
I'm definitely curious! What framework is matured enough to provide better solutions to problems solved by Rails? (gems like Devise, activerecord ORM, turbolinks) 
&gt; Right, but when those Flask apps wind up growing into bog-standard HTTP CRUD apps, suddenly you have your own hacked together version of half of Rails. Then the feeling of regret slowly creeps in.
A lot of the rails ideology exists in emberJS. 
Isn't Ember exactly that?
Sorry, I made a mistake in the article. Now it's fixed. Thanks.
There is [Sails.js...](http://sailsjs.com/) I haven't used it personally but I heard it was more Rails-like.
**THIS.** Twice with me now. I'm just sticking with "big guys" now (mostly Rails &amp; Django) for my personal projects. I'm not the kind of person who enjoys building boilerplate.
I'm now digging into Django... Could you please tell me what did you not like so much about it? I thought the idea behind the two was more or less similar, providing a big toolbox for solving problems.
Or alternatively, there's "greenspun's rule," about common lisp. (Any complex program will eventually contain a bug-ridden implementation of half of common lisp).
Looking at purely the ORM side of things I found that Sequel is much better than ActiveRecord (based on using both for several years for serious internet business). Sequel in particular shines at providing a Ruby interface for almost every SQL construct, whereas ActiveRecord didn't even support `OR` until Rails 5. Ecosystem wise ActiveRecord is definitely ahead, but this is mostly because it has been the default Rails ORM ever since the beginning (if I'm not mistaken). A lot of the popular Gems however work with both ActiveRecord and Sequel, sometimes also supporting the likes of MongoDB.
It's all [quite simple](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.cc3qqqadg), really. :)
Do I need to install some additional gem or whatever (i.e. core language docs) to get this working? I just tried as you described: &gt; irb 2.3.1 :001 &gt; help 'Hash#reduce' Nothing known about Hash#reduce
Problems already solved in a _certain way._ Devise is a suboptimal approach to authentication. ActiveRecord is a suboptimal approach to maintaining application state. MVC is a suboptimal approach to building web GUIs. Most rails apps more than a year old suffer from those very same 12 year old "solutions." Hell, by not using rails, I already get one big problem lifted -- that damnable autoloader. Sometimes we have to take a few steps back in order to make progress again. Rails did some things very well, and it brought some useful innovations, but it's not for everyone.
As someone who has worked in both rails and Django extensively, Ruby itself allows metaprogramming constructs to make code look cleaner as a baseline, but convention over configuration is something I really wish Django picked up from rails. I end up writing more Django code to achieve the same functionality. 
Isn't it the issue of Python and Django being generally more descriptive and verbose? Like the lack of automagic module loading?
I read through all the hanami documentation and I can't see any reason why I'd use it over rails. It appears to be largely the same thing just rewritten a little differently (and in particular, a class per action? Why?) rails still looks cleaner to me overall. 
I assure you that people use Rails significantly less for JSON APIs than for full-stack apps. One example is GitHub: even though they use Rails for their main app, their JSON API is on Sinatra. One really nice advantage of web frameworks like Sinatra is that it allows you to keep endpoint declaration and request handling code side-by-side. For APIs this is really convenient, because your endpoints are your main point of reference. Rails mandates that you split those into routes and controllers. Also, just by the fact that Rails exists for 12 years, doesn't mean it's more advanced than everything else. For example, Roda has much more advanced, simpler, and just natural way of routing requests, which allows you to easily do things which would be a PITA in Rails. It also has proper HTTP streaming (along with Sinatra). In general it's loaded with useful features, many of which Rails doesn't have.
&gt; I am still really surprised that no one offers a "ruby on rails" in JavaScript. I think that is/was basically the intent of Ember. It doesn't seem to have captured the mindshare though. 
&gt; Any sufficiently advanced Sinatra Flask app is indistinguishable from Rails? Well, a custom bespoke version of Rails. Which I guess could be great and well-fitted to your exact problem space, or could be a hacky mess that's not nearly as good as Rails which has after all had thousands of developer hours put into it. 
&gt; rubygems does not currently allow gems to be removed so they can't be installed, I think. Nope, [the policy changed in April 2015](http://blog.rubygems.org/2015/04/13/permadelete-on-yank.html). Unlike before, "yanking" a gem really does remove it from RubyGems.
It reminds me of when I think "Oh, this little automation script is simple enough, no reason not to just do it in bash." I _always_ regret it, then I always forget next time. I think next time I might really remember and just start with ruby. 
My reading comprehension: -1 Good catch.
Oh, thanks for the correction. hmm. There's no great solution here, either allowing true yank or not both cause or can cause serious problems for some people sometimes. There is an open PR/discussion on disallowing yank for gems with a certain number of downloads. https://github.com/rubygems/rubygems.org/pull/1396
I thinks it's because all the Isomorphic JavaScript/SPA/Universal web app stuff is still somewhat new and it is not yet clear what kind of architectures and tools will be useful. There's a new hot JS build tool every few weeks. When rails came out, it built on concepts like MVC or the active record pattern, that had proven to be useful, but were far from seamlessly implemented in most frameworks. Also it was the very first code that many had seen in Ruby ever, so it kind of built on a greenfield land. 
Yeah. Or "Come on, it's a simple blog, I can totally abandon an ORM and just do PostgreSQL queries!"
Have you seen the drawers gem? Really good solving this in rails
FYI [Pry][2] with the [pry-doc][1] gem can do this too: $ pry [1] pry(main)&gt; ? Hash#reduce From: enum.c (C Method): Owner: Enumerable Visibility: public Signature: reduce(*arg1) Number of lines: 30 [1]: https://rubygems.org/gems/pry-doc [2]: http://pryrepl.org/
it's debatable to say if rodauth is superior to devise feature-wise, but it got (at least) one thing right: authentication is a framework add-on, not an http stack feature. devise is based on warden, which builds the authentication layer as a rack middleware. Messing up the ordering and the place at which this middleware is introduced in the stack is a source of bugs. Also, devise is a rails-only authentication framework, which means that it could build it's toolchain of add-on features on top of the rails request handling stack and completely ditch the rack middleware abstraction IMO. This could actually be the prospect of a new rails feature: route-related "middleware stacks" (or rails internal request/response processors). 
I would like this feature. It would make me consider switching from Puma.
If passenger could do Procfile management that would be amazing. It's annoying every time I build a new server for an app that uses Sidekiq I have to: 1. find/write an init/upstart/systemd or whatever the current init system is. 2. Build rules so that capistrano can restart Sidekiq. 3. Ensure a custom rule is in sudoers so that the deploy user can actually restart Sidekiq.
&gt; Why are threads kicking off even though I don't call thread.join? That's not what `thread.join` does. `Thread.new` starts the thread. I was going to quote you the documentation but having read it myself now it is correct but unfortunately worded so that I can see it would be confusing in this case. For example it says "we are able to pause the execution of the main thread and allow our new thread to finish, using join". It allows it to finish, but it had already started. "If we don't call thr.join before the main thread terminates, then all other threads including thr will be killed" - they'll be killed, but they already will have started.
Yep, second this. Removing this process would be incredibly nice.
[This should be a good start](https://docs.djangoproject.com/en/1.10/topics/db/managers/)
Ahha, thank you very much!
&gt; Can anyone tell me why the first one works and the second one doesn't? `=` vs `==`. First is assignment, second is equality check. &gt; I've tried a dozen different things and none work. What have you tried?
The thread "kicks off" as soon as you call Thread.new -- it's executing. It may or may not still be executing, or have finished, at any future point in the code. There's really no way to tell or determine. Maybe the thread is still going on, maybe it's finished. Depends on how much work it was doing, and depends on how the OS chooses to schedule it. _except_ calling `join` to wait for the thread to complete. When you call `join`, your program (on that 'main' thread) won't resume execution after the `join` until the thread it's `join`ing on has completed. In general, I would very much recommend using the tools from [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby) instead of trying to use the stdlib primitives yourself. Concurrency is tricky either way though. 
I'm all for this as well. This would save a lot of time and configuration.
OK sorry about the formatting! I'll try that next time. What your saying is still over my head. The whole idea of needing a stand-in word for the ".each" command is still confusing, but I'll get there. I think that's a big flaw with Code Academy. They let you jump through the hoops so you can do stuff, but with all the handholding you're not given a great understanding of WHY things work or don't work.
Actually, it does, but if you don't seriously consider any other approaches as valid then I suppose it would seem like it doesn't. Relating routing to resources, which in Rails literally implies tables in your database, is a ridiculous abstraction that does nothing for productivity or good design.
Coming from a Django background, I can't say that there's much of any boilerplate at all. Views are either functions, in which case they're a request-response cycle that's as naked as you want, or it's a class-based view, in which case the implicit complexity is relatively visible when overriding default behavior and, believe me, when your codebase gets big you'll be *glad* that it's there to see in plain sight.
I don't know. I've worked on massive rails apps. Over 90 models, 100,000 lines of code and I'd much rather be in rails. 
&gt; About github, that's a really nice info to have, I didn't know that. Do you know if they run sinatra standalone or they just mount the API in the rails app? I have to say I don't know. I imagine they would host the Sinatra app standalone, so that they can scale the API individually from the main app. &gt; With roda or sinatra, a vulnerability can be introduced depending of the component you use to validate params or write to the db. It requires at least more overhead in analysing. This is an interesting point. Yes, if you're using Roda and Sinatra, they don't automatically take care of things like mass assignment. However, you know that you have to validate request parameters, whichever web framework you use, so if you use dry-validation it will automatically take the role of strong_parameters. That's just an example, but I'm interested, could you point to some security issues that Rails solves *because* the components are part of the same framework? &gt; Doesn't the HTTP streaming only work with eventmachine? This was something I've always found suboptimal in rack frameworks. You can stream contents by returning a response body that responds to `#each`, and then dynamically retrieve the part of the response body on each iteration. Then web servers can react to this by transforming it into a chunked response. Roda/Sinatra have a simple API that transform the streaming block into an object that responds to `#each`. [This](https://www.reddit.com/r/ruby/comments/4r9alo/the_sad_state_of_streaming_support_in_ruby_web/) is a good post and discussion of differences between Rails and Roda/Sinatra. I imagine EventMachine makes streaming better, but I'm definitely not an expert on this topic (like people in the linked discussion).
$ruby your_file_name.rb
What do you mean by "needing a stand in word for `.each`?"
Any questions, reply or PM me. Things are different in Windows vs a Unix environment.
Did you know that everything in that list, except for server push, can currently already be achieved by putting your app behind Nginx (maybe Nginx + Passenger) and enabling HTTP 2 in Nginx? If you already knew, what is unsatisfactory about the current method, except for lack of server push?
I've tried to simplify this process in [Programming for Beginners](http://www.programmingforbeginnersbook.com/). The [first chapter](http://samples.leanpub.com/programming-for-beginners-sample.pdf) contains steps for getting everything set up. If you have any problems, feel free to hit me up here, on Twitter, or via email.
I'm not sure where it came from originally, but it's certainly old, so RDoc is probably a safe bet.
Read books. watch tutorials. build stuff.
I should buy a rubber duck. 
I went to the terminal. I have ruby 2.2.3x64 installed. I used Notepad++ to write a simple test piece of code. I saved this code to a file in .rb form. I went to the terminal typed with the $, without it &amp; tried cb followed by the location (I did this because on a previous project I did this helped to find a separate ruby download). All of these trials give " not reconqnized as an internal or external command, operable program or batch file. 
You either have to: A. Navigate to the folder the file is located in using terminal commands (cd /myfiles/code/), then run the file (ruby myrubyfiles.rb). Or B. Add the path to the command (ruby /myfiles/code/myrubyfile.rb).
Well, no practical course is enough by itself. Being a mentor myself, I expect that, besides just "performing exercises one-by-one", the student also: * reads the "theory" -- not some huge tome with The Theory Of Programming (though it could be helpful too), but the book like "Programming Ruby" and, at least, official docs for everything you try to do, until you feel you understand what is `.each`, how it is used and why; * experiments on each concept until grasps it; you can do it in `irb` console, or by creating small experimental files which print results of each statement you try, until you, for ex., understand how `word == redact || redact.upcase` is evaluated in different contexts, and what the entire statement do.
1. Navigate to the file you want to execute 2. Shift+Right-Click on an empty space inside the folder. You should see an "Open Command Window Here" option. Select it. If you don't see it, you've inadvertently right-clicked a file. 3. In the cmd prompt, type `ruby -v`. If you see the ruby version output you know ruby's working. If anything else happens, your installation is incomplete somehow. Maybe try restarting? Fix this first. 4. If all is well, type `ruby [filename.rb]` and your program should execute. Just as a precaution, your file encoding should be utf-8. I also prefer to use unix line-endings ("\n") instead of windows ("\r\n") but that really won't be a problem.
The reason for HexaPDF being AGPL is that HexaPDF represents a rather large investment of time on my behalf and the AGPL allows me * to make the source code for HexaPDF public under an open source license, * to create a freely usable, featureful CLI application for handling all needs in regards to PDF processing, and * it keeps my options open in regard to commercializing HexaPDF at a later date. As I have stated on my [Patreon page](https://www.patreon.com/gettalong), if I can find enough backers I will release HexaPDF under the MIT license. This will certainly benefit more people (and is better for companies in the long run) than if I went with, for example, a dual-licensing scheme. You might not know but my Markdown library kramdown was a GPL library initially which I also [changed to MIT]((https://github.com/gettalong/kramdown/commit/b9f220c4a6fd3e1845f03d2b97e18bebfe30eeb3) later, for various reasons. So I'm open to using a license that fits the project, and license choices may certainly change over time.
You almost got there. You want something like `['approach', 'walk to'].include?(move)`.
RabbitMQ, IMO, is overly complex but if you want to connect many different applications together, messaging with an MQ is the way to go. I wrote a blog post a few years ago about the difference between a message queue and a background job system. It pairs well with this blog post: http://www.mikeperham.com/2011/05/04/background-processing-vs-message-queueing/
You are of course completely right - some people may think that all Ruby libraries are MIT or similarily licensed because the majority is. I just wanted to point out the reason behind choosing the AGPL.
Thanks. I looked into documentation on regex and my head exploded. I don't think I'm quite there yet. 
The monk temporarily found enlightenment and ascended from our world, but was subsequently ejected from the heavens when his test suite failed.
No. Not that either. It creates an instance of the original method with the UnboundMethod object and wraps/redefines the original method with some reporting hook and rebinds that UnboundMethod object and calls it. So the method literally gets wrapped. The original method is saved in a hash on that object and can be restored at any time. The method defining code is here in this file: [state_inspector/lib/state_inspector/state_inspector.rb](https://github.com/danielpclark/state_inspector/blob/7af51444dfe9f5b453db5478da348474c921ddcc/lib/state_inspector/state_inspector.rb)
I agree that RabbitMQ is not necessary. Kafka seems like a much better choice for a message broker. I have to disagree about background jobs. Background jobs are the most straightforward means of being able to lift code out of a request/response cycle, but they bring with them every bit of complexity that is inherent to distributed messaging. You need job handlers to be be idempotent. You need the GUI to be designed in a way that assumes that application state hasn't yet been updated simply because a POST request succeeded. Background jobs often unintentionally lead to distributed transactions -- I.E. a single background job interacts with multiple consistency boundaries. The result is the kind of code that appears to work great during initial testing but isn't robust enough to be relied upon long term. Not saying the pattern is wrong, but I do disagree with you about messaging being more complex than background jobs. I think background jobs have the same complexity, they just defer the team from having to deal with it until long after the code was written. Not really a win, IMO.
After words.each you put a bracket { and then a stand in word between two lines like this: |stand-in word here| then you write your if statement calling back to the stand in word. In my example you see, there's a variable I declared called "words" but after words.each there's |word| without the s. I could have written anything there. I don't get why it's necessary though. 
FYI, as an alternative you can also do: moves = Regexp.union("approach", "walk to", "walk over") moves.match?(command) Although *match?* is only present in Ruby 2.4 use *=~* or *match* otherwise
Sure, I'm not saying messaging is more complex, I'm saying the RabbitMQ and AMQP implementation is overly complex. Look at this set of attributes, should the developer have to understand all of these? from_queue QUEUE_NAME, durable: true, ack: true, prefetch: 100, exchange: :campaign_events, exchange_type: :topic, routing_key: 'ended', arguments: { :'x-dead-letter-exchange' =&gt; "#{QUEUE_NAME}-retry" }
Yeah, I just can't recommend heavyweight message brokers for anyone. Stream oriented messaging, ala kafka, offers a much simpler approach. Messages are always presumed to be handled at least once, and the application logic has to ensure message handlers are idempotent. Idempotent handlers certainly require certain techniques that are not obvious to web developers that have not yet been exposed to them, but teams that aren't familiar with distributed messaging run into troubles all the time with background jobs, too. I guess my larger point is that stream oriented messaging is a superior alternative to both background jobs _and_ traditional message brokers. Those using background job libraries who are already ensuring their jobs are idempotent are choosing between distributed messaging _across_ software components vs. distributed messaging _within_ components. I don't love the latter, because it becomes too easy to naively entagle consistency boundaries when you've got the entire application's OLTP at your fingertips.
That is what I thought you meant. Okay, so here we go for a wild ride (that Code Academy should have taken you on before introducing you to these things). First, lets tackle the concept of looping in a list, which is really what is happening here. Ruby provides a for loop, it's a little less clear than I want to be for my example so I'm going to use `loop` which is an infinite loop by default. But we're going to fix that. So if I have a list of words, let's say, generated from `"Holy Moly"` with `words = "Holy Moly".split(" ")`. To start iterating, we need a "counter" that we use to determine when we're done and where we are at. If you aren't already aware, lists in (most) programming languages start at `0`, not `1`. So if we break the list down by index you get: ["Holy", "Moly"] # 0 1 So if I accessed #0 I'd get `"Holy"` back. Okay, so let's start our loop here by declaring an index: index = 0 Next, we need to create the looping body. Without too much detail, just discussion, we'll do that with `loop` and `end`. loop do # we'll put work in here end Okay. Next we need to put our work. First, let's get a list of steps of things we want to do. 1. We want to get the word we're looking at, 2. Test it against `redacted` to replace it 3. Print either `"REDACTED "` or the word. 4. Increase our loop counter 5. Check to see if we're done looking at words and end the loop if so, 6. Otherwise start back at 1 So let's do that. # step 1, we use :[] to access items in a list with the given index # since index is 0 right now, we're getting the first item in the list word = words[index] # step 2 &amp; 3, test it against redacted and print the correct result if word == redacted print("REDACTED ") else print(word + " ") end # step 4, increase our loop counter index = index + 1 # step 5 check to see if we're done with the list if index &gt;= words.length # * break # ** end # step 7, is automatic, at the end of the loop body, if no # break was issued, we then continue from the start of # the loop body. So now if we look at our code in a complete state (with no comments): print("Enter a sentence &gt;&gt; ") words = gets.chomp print("Enter redacted word &gt;&gt; ") redacted = gets.chomp words = words.split(" ") index = 0 loop do word = words[index] if word == redacted print("REDACTED ") else print(word + " ") end index = index + 1 if index &gt;= words.length break end end (lets see that execute [here](http://ideone.com/I3TAyV)) So cool, we got it work without the call to `.each`, what's my point you may be asking? Well, we're getting there. Next I'm going to take a quick detour into methods. A method is a reusable segment of code that can be called from anywhere (with some limitations that aren't important for this example) and even be given data. Methods look this: def method_name(param1, param2) # method body end The `param1, param2` are **parameters** (what you're referring to as "stand-in words") and they contain the data that was given to a method. So let's look at a really simple method: def add(a, b) a + b end This is pretty obvious, it takes two values and adds them together. We can tell this because it's called `add`, and it has to parameters -- `a` and `b`. We call it with a line like: add(1, 2) This will return `3` which is the result of adding 1 and 2. This is called a "method call" because it's "calling" (or executing) the code defined in the method add. And the `1, 2` here are called **arguments** and they map directly to the **parameters** defined in the method. So `a` is assigned the value of `1` and `b` is assigned the value of `2`. If we reversed the **arguments**: add(2, 1) Then `a` is assigned the value of `2` and `b` is assigned the value of `1`. Methods can do anything we want, we just have to define the body to do what we want. So let's take the code we have in the loop body and make a method to determine if the word should be redacted or not. The first thing we do is go over the loop body and determine what data we would want to send to the method. I can see what we're using the `words` list to extract a `word` at the given `index` and we test against `redacted`. We could make a method like `get_word(words, index, redacted)` and let it do the work, but that seems bulky. The method itself doesn't care about the `index`, just the `word` and `redacted` values. So we'll pass in the current word. We have a plan of attack, let's write our method. def get_word(word, redacted) if word == redacted "REDACTED" else word end end And our new loop body looks like this: word = words[index] word = get_word(word, redacted) print(word + " ") index = index + 1 if index &gt;= words.length break end (working sample [here](http://ideone.com/B455bB)) Things have gotten a little simpler. But now that we've taken that detour, we can finally come full circle and answer your question (I'm long winded, sorry). Okay, so let's get your last example up here (I'm writing it from memory, it may not be exact): print("Enter a sentence &gt;&gt; ") words = gets.chomp print("Enter redacted word &gt;&gt; ") redacted = gets.chomp words = words.split(" ") words.each { |word| if word == redacted print("REDACTED ") else print(word + " ") end } So the `{...}` part after `words.each` is a special way to define a method as an argument to a method. You see, `#each` is a method you can call on lists. What it does, is that it looks at every item in the list and passes each item (in order) to the method you provide for it. This method you define, the only way it can know what the current item is, is by taking it as a **parameter**. So that `{ |word| ... }` part is saying "Here is a method, it takes one parameter and that parameters name is 'word.'" You are correct in that you can make it whatever you want, because it's just a name. The value is coming from `#each` as it looks at every word. Without it, you can't see the current word, and you can't perform your test against `redacted` to get the result you want. So it's a very important notation in order for you to achieve your goal. As an aside, let's make our own `#each` method to see how one might work. Let's list out the steps again: 1. start an index for the list 2. begin looping over the list 3. get the current word in the list 4. pass the current word in a method call to the block provided 5. increment our loop counter 6. to to see if we continue looping So now, let's implement it. # special syntax here, the &amp;block. Don't worry to # much about it's specifics, this is purely for # illustration purposes def my_each(list, &amp;block) index = 0 loop do item = list[index] # this is a method call! you could think of it like # block(item) it's just Ruby expects us to use it's # #call method to actual make the call on _this_ # kind of method. block.call(item) index = index + 1 if index &gt;= list.length break end end end print("Enter sentence &gt;&gt; ") words = gets.chomp print("Enter redacted word &gt;&gt; ") redacted = gets.chomp words = words.split(" ") my_each(words) { |word| if word == redacted print("REDACTED ") else print(word + " ") end } (example [here](http://ideone.com/5MrDMI)) So BAM. We just realized the magic of `#each` and why that **parameter** is necessary in order to access the current word in the list. And in the process we learned (maybe) about looping and we learned (maybe) about methods and **arguments** and **parameters**. I hope that's clear. I know some things are a bit advanced, and where the advanced bits weren't relevant I omitted them. \* The `#length` value of a list returns how many items are in it. In our list, `["Holy", "Moly"]` we have 2 items. You access these items at index 0 (`"Holy"`) and index 1 (`"Moly"`) but there are 2 words. This is why we test `&gt;=` so if index is greater than (it shouldn't be, but we're not going to take chances) or equal to it's length, so if it's `&gt;= 2` we stop looping. That's because there is nothing at index 2, or 3, or 4. So at some point we need to stop looking. \*\* `break` is a command that stops execution of a loop (at that point) and exits the loop. You may not use it a lot, and you may not see it for a while in your studies. But it exists. Since `loop do ... end` is infinite (it will keep looping until the program crashes), we have to have some other way to quit when we've done our work. So we use `break` to issue that instruction. Once a `break` is encountered the program continues with the next line directly _after_ the loop that just ended. **BONUS** I have ~1000 characters left over, so I'll keep it brief. Your other question about how to compare it to other variations: if word == redacted || redacted.upcase || redacted.downcase || redacted (you have redacted twice, FYI) Doesn't work, and has already been explained. But if you really think about, you're going to compare the word to `redacted.upcase` or to `redacted.downcase` or just to `redacted`? Well, you can see a potential pattern. If word is `"HoLy"` and redacted is `"holY"` but you want to see if they're the same "word" then transform _both_ of them. if word.downcase == redacted.downcase Done, and done. Using the previous values, this would compare `"holy"` to `"holy"` which _is a match!_ Sorry for the verbosity, best of luck in your learnings.
about the formatting of your code this might help https://github.com/bbatsov/ruby-style-guide
I would use a case statement: case move when "approach", "walk to", "walk over" # do stuff end Based on your example, It sounds like you might need to first parse the user input into parts (action/target, etc) to achieve this though.