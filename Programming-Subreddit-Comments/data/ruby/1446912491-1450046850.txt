Generally 32 ms, which is already *quite* a lot.
i dunno how you get your shell to load so magically quick with gems. your black magic is beyond me
One goal for chitin is to always be able to accept any valid ruby code. But I think there's a middle ground where I can make regular shell commands easier.
I'll check it out, thanks! 
If you can derive what his problem is, and how well his constructed solution solves that problem to respond go for it. I am very familiar with message queues, rabbitmq and even nagios -- I don't understand the problems he is trying to solve nor his solution based on his post (because he does not actually state them). Just realized that you were the OP. The fact that the only response you received was one saying that you have not given enough information to respond could, in some people, trigger understanding that the question they have posed is malformed. 
elegant as fuck yo
Generally I've had spectacular luck with [RVM.](http://rvm.io) 
why not just use eruby then? Or I guess erubis now :). 
[removed]
The title didn't really specify that requirement so I guess you're right :). 
Really cool project!
üëåüëÄüëåüëÄüëåüëÄüëåüëÄüëåüëÄ good shit go‡±¶‘Å sHitüëå thats ‚úî some goodüëåüëåshit rightüëåüëåthereüëåüëåüëå right‚úîthere ‚úî‚úîif i do ∆Ωa“Ø so my self üíØ i say so üíØ thats what im talking about right there right there (chorus:  ≥·∂¶·µç ∞·µó ·µó ∞·µâ ≥·µâ) mMMMM·é∑–úüíØ üëåüëå üëå–ùO0–û‡¨†OOOOO–û‡¨†‡¨†Oooo·µí·µí·µí·µí·µí·µí·µí·µí·µíüëå üëåüëå üëå üíØ üëå üëÄ üëÄ üëÄ üëåüëåGood shit
Maybe I'm being over ambitious with what I'm looking for. Minimum I just want to be able to navigate through my codes. Ie navigate me to implementation of my methods and view locations of usage. Don't really need it to go beyond re factoring etc
Pull requests consisting of only one character? Good luck! My personal opinion is that I think there is no chance this will work, but I would love (and hope) to be proven wrong!
That the "single character" can actually be an [insertion, deletion, or substitution](https://en.wikipedia.org/wiki/Levenshtein_distance) gives me hope for the thing, if only because it makes it easier to combat vandalism. That "simultaneous" edits won't conflict so long as they occur on separate lines might also prove to be a boon. We'll see how it goes.
Quick, let's finish it before everybody wakes up!
does a newline count as a second character? My commit isn't merging..
Sorry about that; I was eager to get it live and went a little too YOLO on testing the edge cases. :P It's fixed now.
Bash is crap? Your shell is crap!
I proved my claim, your turn
I guess the difference is in hardware, my notebook has SSD, and everything is faster with it, for example. doom_Oo7 gave me an idea about client-server architecture and I think it makes sense, but I'm worried about several commands launch simultaneously. Ruby does system calls asynchronously, doesn't it?
Not exactly, I set it up by hand with a shell script and some wmctrl
Or [Roda](http://roda.jeremyevans.net/) (awesomesauce!), [Ramaze](http://ramaze.net/), [Cuba](http://cuba.is/), or [Camping](http://camping.io/); and that's not even considering less lightweight non-Rails frameworks like [Padrino](http://www.padrinorb.com/) or [Lotus](http://lotusrb.org/). It's never been a better time to be a Rubyist looking for good tools, or one looking for alternatives to The Great Marketing Phenomenon.
chitin launches commands via `fork` and `exec`, so those are already done simultaneously. I assume you do the same. Can you explain your worry about launching commands simultaneously?
Oh dude, I just looked at the Rush code ‚Äî you're using `system` underneath, which I REALLY think is lame. It's not too hard to find the executable on the user's path and use fork and exec, and then YOU are in control and you don't have to worry about running multiple system commands. Like you said: use ruby.
&gt; The queue can not be just a file, because multiple threads sending notifications would mess it up Writes to files with `O_APPEND` should be atomic on POSIX-ish systems, they are on linux up to a certain size, usually 4k. &gt; Whaddayathink?? Why not just have a daemon that accepts the nagios notifications through a socket. Don't need RabbitMQ nor a multi-writer log file this way and it's a lot more flexible.
&gt; Yeah but it will not need appending only, at the same time, the sender needs to prune/purge messages too. Moving (renaming) a file is atomic also, it's all you should need to purge the queue. &gt; That is a valid point and a principal design question, not that of the implementation. Most wonky implementation problems can be solved with a better design. &gt; like dying and not being available when needed You have the same problem with RabbitMQ anyway, presumably you already have process monitoring on this server anyway, `God`, `monit`, whatever. RabbitMQ also isn't the simplest service to manage.
&gt; You have the same problem with RabbitMQ anyway, presumably you already have process monitoring on this server anyway, God, monit, whatever. RabbitMQ also isn't the simplest service to manage. Yes, yes, you are correct. But this is the sysadmin land, the least thing you want is for us to start writing our whole own software and assume it's better than actual software like RabbitMQ. I know one should never made any assumptions, but indeed with this I assume that software written by software folks works and I don't put in more glue than is needed to stick the pieces together :) About the file vs RabbitMQ thing, well, those queues would not even be persistent, so disk access could be avoided. A diskless queuing thus becomes down to this: wither one script and one daemon or two scripts with RabbitMQ connecting them together. But this is a very good discussion, don't take it as argument. I will consider everything you say, even if I'm not readily willing to change my choice immediately. 
It has initialize method because I believe all other objects who going to inherit from that module going to use the same initialize method. But perhaps that's a bad concept. 
Ermm, interesting. I wasn't aware of Factory Girl. I will check it out, thanks!
As I understood, the thing is to show how you can build your own sinatra/roda.
Kinda hard to say without being able to see the code. If they wrote it as a gem, you'd install the gem and `require` it. If it's a rack app, you could run it with any rack server (webrick, thin, etc).
No, it does not. Author is most likely running in development mode which is orders of magnitude slower than production.
If you want, you can take a look at how chitin does it for inspiration. Hopefully the comments are good enough. https://bitbucket.org/seydar/chitin/src/62b6a21aecef6ce35cec086729bd5aafebdfb90c/lib/chitin/commands/pipe.rb https://bitbucket.org/seydar/chitin/src/62b6a21aecef6ce35cec086729bd5aafebdfb90c/lib/chitin/commands/executable.rb and just that whole directory in general
I'm going to try this one when I get back home.
In that case share a listing of the root of the directory for the project and people will be able to tell you what type of project it is. My gut would be a rails app or a gem. Based on that info you would need to invest some time to understand each layout and how they work (and I would suggest that would be an important baseline understanding before applying to any ruby/rails job even as an intern).
So it's a gem. `lib/active_merchant.rb` is basically the "entry point" which handles the loading of all the other dependencies. However, if you just `require './lib/active_merchant.rb'` you'll get errors because the additional `require` statements within that file are not absolute paths, they are relying on everything under `lib` being in Ruby's load path. So what you need to do is add the lib folder to the load path, then you can simply `require 'active_merchant'` and it should resolve everything. For a hint on how to do this, take a look at the Rakefile in that repo: https://github.com/activemerchant/active_merchant/blob/master/Rakefile#L1
As andyw8 mentioned, `bundle console` is the easiest way to load all the code in a console session. This will make all the classes defined in the gem available in the same way they would be if the gem was added in the `Gemfile` of another app. For example: [vagrant] ~/src/rails/active_merchant (master) bundle console Resolving dependencies... irb(main):001:0&gt; card = ActiveMerchant::Billing::CreditCard.new( irb(main):002:1* first_name: 'Bob', irb(main):003:1* last_name: 'Bobsen', irb(main):004:1* number: '4242424242424242', irb(main):005:1* month: '8', irb(main):006:1* year: '2016', irb(main):007:1* verification_value: '123') =&gt; #&lt;ActiveMerchant::Billing::CreditCard:0x007fe20e342248 @first_name="Bob", @last_name="Bobsen", @number="4242424242424242", @month=8, @year=2016, @verification_value="123"&gt; irb(main):008:0&gt; card.validate =&gt; {} irb(main):009:0&gt; card.brand =&gt; "visa" irb(main):010:0&gt; If you're looking to get more familiar with programming in ruby, why not take a crack at solving one of [the issues](https://github.com/activemerchant/active_merchant/issues) on the project? Some of them may be simple.
I saw you linked to the source above. It's a gem -- you can tell because it has a gemspec and it is clearly documented as such. the README.md (and other doc files) have very clear documentation on how to use the gem, it also has a decent test suite that has decent coverage. Topics to read up on: * Gems * Creating Gems * Ruby testing (in this case Test::Unit) * Git * bundler Overall, I consider this stuff to be basic entry level knowledge. Without knowing what their actual request was, my assumption is that to add a new payment provider would be fairly trivial to anyone that could say "I am a ruby developer" in an interview. 
Doesnt hurt
It was one of the first books I read about Ruby... Complete waste of time, really.
This was really helpful. Thanks.
Why was that?
Just about any open source project ever. If you find a bug, or want a certain feature, send them a patch. That's it. Congratz, you're now a contributor. You don't need permission first.
I just noticed that a lot of projects aren't actively maintained. 
I guess I'll kinda echo what other's have said that it depends mostly on you. It will still teach you the basic concepts that still apply in programming. I read half of it, and just didn't like it. I found the whimsy to be more distracting. The ruby language itself was enough to keep my attention, so I prefered Chris Pine's [Learning to Program](https://pine.fm/LearnToProgram/chap_00.html), then [the Pickaxe](https://pragprog.com/book/ruby/programming-ruby), and after that Michael Hartl's [Rails Tutorial Book](https://www.railstutorial.org/book). Now that I have the language down pretty well, at this point I just look up the [api documentation](http://ruby-doc.org/) when I need to, or google for what I want to do. If you want something up to date but still "fun" you might consider [Ruby Wizardry](https://www.nostarch.com/rubywizardry) (no free version of this one), which I glanced through and looks good although it is geared towards kids.
Thanks.
Well then here's your time to shine. Just fork and maintain. If the original author is gone, you can just carry on. If he's not, and just busy, he might just "give" you the project.
It's one of my favorite books. It's also not as good as the pickaxe if you are just looking for a straightforward programming manual.
No, it just might not be useful.
I don't know that I'd call myself a newcomer, but I've thoroughly enjoyed what I've read so far. It's kind of cute.
Active model seriolizers needs help :-)
If you're asking whether the material you'll learn in it is still relevant from a technical standpoint, it is. There are several new goodies in the Ruby language since the guide was written, but you'll still learn how to Ruby code that is still valid today. It's not at all like, say, cracking open a Swift book from 2014, where the code examples often won't even work anymore because Swift is under such rapid development.
You can invoke `#include` directly on an object; it'll bring in the appropriate methods and return the receiver. subject { Class.new.include(described_class).new }
I use Atom on Windows and it does code completion and syntax highlighting for ruby. Just make sure the filename ends with ".rb" extension.
Personally, I'd write a spec like this: RSpec.describe Under::Test do describe 'methods included in module' do let(:class_with_inclusion) { Class.new.include(described_class) } describe '#some_behavior' do subject { class_with_inclusion.new.some_behavior) } it 'does something' do is_expected.to eq 1 end end end end So that you would get documentation from the "--format d" command that looks like this: Under::Test behavior included in module #some_behavior does something I personally find the above to be a faster way to understand the usage if the Rspec descriptions are written properly. If I really want to dive into the details of a particular feature I can look at the setup of that test. Usually, unless the spec author is super diligent about being DRY and having very clear setup, the documentation command is quicker. So I would favor well written 'describe', 'context', and 'it' messages. Quick side note: Also I'm using a convention that my team and others that I've seen use: '#' for instance_methods '.' for class methods. That adds even more context IMHO to the above. 
Yup use atom too. But it doesn't have links to code definition and implementations. 
Yup i'm tinkering with that atm. Just when files get too big it seems to timeout alot and it has crashed on me. 
Hi, To know if you have to choose between an instance method or a class method, it depends if the implementation of the method will use the instance of the class. For instance, if you have an instance variable and you will use the value in the method, the method should be an instance method. Otherwise, it's a class method. Easily, try to implement as class method and when you need to interact with the instance, you convert as instance method.
I recently read through it as a brush-up on Ruby. Because I already had a familiarity it was a great way to keep the rehash interesting.
So, if a method is about "state", it should be an instance method, else - a class method? 
I often use class methods to construct an instance. This is certainly not the only case where class methods are the proper tool, though. But one that does clarify the difference: class Report def self.duplicate(other_report_id) other_report = find(other_report_id) new( name: "Copy of #{other_report.name}" records: other_report.records, from: other_report.from, to: other_report.to) end end You would call this e.g.: @duplicate = Report.duplicate_from(id) In Rails code, written by developers with less Ruby experience you'd see a controller like this, which does the same (But if anything, it certainly is not the reposibility of a controller to "duplicate" a report): other_report = Report.find(id) @duplicate = Report.new(name: "Copy of #{other_report.name}" records: other_report.records, from: other_report.from, to: other_report.to) An alternative, with instance methods would be: class Report def duplicate Report.new( name: "Copy of #{name}" records: records, from: from, to: to) end end @duplicate = Report.find(id).duplicate As you can see, both are possible. And one is not better then the other. It really is all about *responsibility*. Ask yourself the question: * Is it a single report that is resposible for copying itself into another report? * Is it the conceptual "report" that is reponsible for copying a single report into another report? My answer would be the latter: I don't think, in this case, a single report should know how to copy itself into another report. So this is clearly a class method. However, the example here is simply. But might grow quickly: the "copy of..." has to be transatable, or templateble, the list of params that should be passed along grows, you find that not only Reports need to be duplicated, but Messages, Addresses and so on too. In that case, you probably want to move all this into a `ReportXerox`, or even abstract the copying into a `Xerox` class with some smart inheritance to make `ReportXerox` easy: class Report def self.duplicate(other_report_id) other_report = find(other_report_id) ReportXerox.new(other_report).xerox end end **TL;DR*: it's all about reponsibility: if the instance (i.e. a single user of all Users) is reponsible for doing what the method does, then instance-method. But if the group-of-things (the group User) then it should be a class-method. In all other cases, a third class or instance are probably the proper place. 
I know about that already, I was asking if Erubis also featured its own web server interface component or if it's a template engine and just that. 
I'm an extremely big fan of having a visual debugger. Being able to step through stack frames and see surrounding context is far more productive for me that adding print statements. Command-line debuggers can work, of course, but I find them generally too terse to be useful for more than trivial expressions.
Aka web kit is broken especially considering the server isnt returning a cache header. 
By default, prefer instance methods. Class methods can be painful to test as you often will need to modify some global state.
Crystal has been on the radar of all the Ruby devs at work, including me. It still has a long way to go before it can be professionally used, but it will make a great addition to the toolbox when/if it does. Worth looking into for all Ruby devs, IMO.
First, don't use $. Second 'for index in...' isn't really proper ruby syntax. personally, you might have better luck with: ary.map(|num| *your conditional logic* } this will return an array of what you need
Require relative paths are relative to the location of the source file they appear in. But file reading paths are relative to the process "working directory". Which by default is whatever directory the process was started from. No idea how that works on windows. I think rails apps automatically set their working directory on boot to the project base directory.
yeah... really love atom's environment. but there's still lotsa hiccups. In their defence, i guess its still a young editor.
Off the top of my head, something like this should work in postgres: def after_notice_time joins(:venue).where("start_time &gt;= now() + venue.notice_time * '1 hour'::interval") end
If you want to achieve the same behaviour with `File.read`, you can use the `__dir__` method: File.read("#{__dir__}/../thing_i_want") The `__dir__` method returns the absolute path to the directory of the file `__dir__` has been called from (so, similar to `__FILE__`).
It's going to depend on the community. If it attracts enough people I think it could very well replace ruby. It's a great language.
You can check awesome-crystal https://github.com/veelenga/awesome-crystal
Yep, Rush is a nice tool, I also write clone of it :) http://alexeypetrushin.github.io/vfs/basics.html
Thank you very much! I will watch it tonight :)
The entire talk is great, most things apply to Ruby. Although the time-stamp I linked talk about just this question you will get a better understanding if you watch it all and get the context of his presentation.
&gt; [Crystal] tries to be much more efficient, at the cost of disallowing certain dynamic aspects of Ruby. It can only replace Ruby in those cases, where you don't need the dynamic aspects. That could be in a lot of applications, but it simply isn't the same thing any more. Ruby's dynamic aspects come at a cost and if they are worth it or not is up to the user to decide. It's cool to have an alternative, though. 
That seemed to have done the trick! Just to make sure I understand, you're basically doing exactly what I was trying to do but just using SQL statements, taking the notice_time integer and casting it as a time interval by multiplying it by 1 and adding it to the current time. Then for each availability you're checking if start_time is great then the calculated result. I've basically spent a day trying to get this working, thanks a lot for that. 
This is a good summary. Most of the examples posted in the thread sum up to what you said. If you use #new/#find in a method - it should be a class method. Thanks!
I'm not very fluent in Rails code, but this nevertheless makes sense. Thank you for a very detailed answer :)
This would be a great project and would probably help Crystal adoption a lot. That said, we changed the suffixes on some simple-ish scripts, added some minor type annotations, compiled, and got a 10x increase in speed. It's not perfectly source code compatible, but pretty damn close.
Be aware however that if you use map, as it cycles through each element, the new value will be the return value of your logic. So something like this works fine: irb(main):001:0&gt; x = [1,2,3,4,5,6] =&gt; [1, 2, 3, 4, 5, 6] irb(main):003:0&gt; x.map { |e| e += 2 } =&gt; [3, 4, 5, 6, 7, 8] But something like this is probably not going to behave like you want: irb(main):005:0&gt; x.map { |e| e += 2 if e &gt; 4 } =&gt; [nil, nil, nil, nil, 7, 8] For this type of logic you need to make sure the value for e is returned: irb(main):007:0&gt; x.map { |e| e += 2 if e &gt; 4; e } =&gt; [1, 2, 3, 4, 7, 8] 
Thanks I will try that,an update. you guys are awsome!!
Under what circumstances would someone circumvent the command layer and persist data models directly? That seems like a bad idea.
X-Post referenced from /r/rails by /u/_kulte [A Big Ball of Mud | Laurel &amp; Wolf Engineering Blog](https://www.reddit.com/r/rails/comments/3saojv/a_big_ball_of_mud_laurel_wolf_engineering_blog/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
In postgres you could, but I guess I get what you're saying.
Architectures based on the underlying principles that drove trailblazer seem to share a common characteristic -- the underlying data is encapsulated. This will generally yield better results than the ORM approach, where the information architecture leaks into the application architecture as a matter of preference.
Because I am stupid... :S
&gt; Since you have a has_one relationship here you should be able to calculate the last_notice_time for each Availability and store this value in the database as a datetime. With that in place you a much simpler query and with an index on that column, a much, much, faster query. How would you calculate the last_notice_time and store this in the db? I suppose on availability create I could do a lookup to the associated Venue and get the `notice_limit` and use that to populate a new column on availability? Then just do a search on that column. Is that how you'd do it? I would also need to find a way to update all associated availabilities if the `Venue.notice_time` were changed right
[removed]
Exactly right, Schrockwell! :) In a TRB architecture, every function of your application (which is something you/your users want to trigger) is modeled as an operation (that may be composed of other components, etc.). So, you basically never use a model directly, which is why you don't need validations. Re-reading your comments, I see you already understood all that and my comment is kinda useless.
The man himself! Thanks, always good to clarify. I assume TRB is for Trailblazer? I'm on the cusp of starting a new, big rails project so I find your ideas intriguing and wish to subscribe to your newsletter (or purchase your book, as the case may be :) ). Definitely will explore your concepts.
5 millions requests to mysql per second from single thread? 100 millions requests to handler socket per second from single thread? IT IS FAKE!!!! There is simply no way to send "several millions blocking queries" from single thread regardless of protocol/client/server/hardware. Even asynchronouse queries are limited by several millions per seconds (from one thread, with highly optimized C or C++ code), not hundred millions. Edit: i assumed, results are "iterations per second"
A valid point, verydefunctional, but most users of Trailblazer (TRB) use it in "hardcore" legacy applications to refactor 4000+ LoC models. That is what TRB is designed for: integrating it into existing code-bases. Its new layers are well-defined and have been around for years (example: Reform, Roar, or Cells). They can be used to solve different problems (e.g. shop, community, analytics tool, JSON API backend, and so on). I do understand the blog post (and the first book) do not cover how to refactor to TRB, but we have a "Trailblazer Field Guide" planned that shows the real refactoring of a real, existing app! ;)
I just came up with a new question about this. Where are the objects stored. I've been making class instances lately and for the first time wondered... where do those live?
It seems that ActiveInteraction does a subset of what Trailblazer aims to do. Interesting gem thou
Considering your inexperience with Ruby, I think your code is decently structured. However, my criticism would be that the parser is quite verbose. I don't think they should hold that aspect of Ruby style against you though. Some nitpicky criticism: 1. ParserApp sort methods and comments are repetitive, more concise implementation may just be a Ruby-familiarity thing though 2. FieldMapper is pretty repetitive, essentially doing the same thing three times, three slightly different ways. 3. FieldMapper is half closely coupled with Person and half closely coupled with DelimiterSniffer.
Absolutely, here is their feedback: Developer 1 wrote: Pros: * The README file and code comments provided useful context on why certain decisions were made. * Good isolated testing of the Person class. * Useful CLI providing expected output. Cons: * Tests involving expected raising of errors used generic (and implicit) exceptions instead of particular meaningful ones explicitly raised, and they failed:testdelimitersniffer.rb:27, testfieldmapper.rb:68, and test_person.b36. * Consider using nested describe or contextblocks to group tests (instead of comments) in the FieldMapper tests. * The ParserApp class is untested. * Consider making methods never invoked by an external caller private (for example, all of the ParserApp methods are public, even though the CLI only invokes the initializemethod). Developer 2 wrote: Pros: * Excellent readme * Error catching for invalid arguments *Separates implementation from execution (bin/parser.rb) * Freezing constants is good practice * Delimiter is determine by inspecting the data * Person class encapsulates data object * Good test coverage Cons: * Some initialize logic in ParserApp probably belongs in other methods (e.g. load input files, sort, print output) * Instead of creating a new ParserApp instance for each command line argument (and reloading input files), you could probably reuse the same instance and just re-sort * Sorting methods should not also be responsible for formatting output * DelimiterSniffer comments states that explicit return for "|" should be removed. Why wasn't this done? Delimiter could be determined via include (datarow.include?(delim) or using regex (datarow.scan(/\w#{delim}/).size) along with the current sorting approach. This challenge is not significant enough to leave unsolved. * If delimiter is passed into FieldMapper.new, it probably makes sense to set that as an instance variable and use it in the data_mapper methods, instead of the string literals. * Person dateofbirth method will sometimes double format a birthdate that is already in correct format. * Existing tests are very good, but there are no tests for sorting methods. Edit: Formatting. 
Awesome, thank you for your feedback. As far as the arguments for the command line, they wanted three different outputs, so I figured for their requirements, just have them see each output by passing in 1,2, and/or 3. Thank you for letting me know about OptionParser, btw. Can you provide an example of your last bullet point?
* Yes, totally agree, as I get more familiar, I'm sure I can do better. * How would this be done to make it less repetitive? The difference between each of the files and how they are mapped is each individual attribute placement (e.g. lastname being in position [0] in one case, and lastname being in position [2] in another.) * I agree here, it shouldn't have been coupled like that. Thank you for your feedback. 
 FORMAT = [:first_name, :age, :last_name, :gender] row_of_data = ['Bob', 45, 'Smith', 'Male'] FORMAT.zip(row_of_data).to_h =&gt; {:first_name=&gt;"Bob", :age=&gt;45, :last_name=&gt;"Smith", :gender=&gt;"Male"} For each other format you need to support, you just need to define the `FORMAT` array with the proper field ordering. You can build your `Person` model from the hash or convert it to an `OpenStruct` which is what I would probably do. This avoids all the awkward duplication of the form `person.first_name = row[3]`, etc.
Oh wow, that is so concise... I like it, and it makes so much sense. Thanks!
Oh, in terms of reformatting. I don't agree with the other developers feedback. The most general solution to this problem is to parse the date to a standardized format (a `Date`) and reformat as requested on output. But if for some strange reason they really wanted to avoid the work then `date_string.gsub(/-/, '/')` would work, for these cases only.
to_s is supposed to return a string, not print stuff. your method is returning an array, and when you try to print the output of that to_s call you're printing an array. It's doing exactly what you told it to do. You probably meant entries.join("\n"). Don't use to_s this way though, this should be a separate method, maybe formatted_entries.
To add to this, `#to_s` *must* return a `String` (or a subclass thereof) or `#puts` and `#print` will ignore the custom implementation entirely: class C def to_s; 42; end end c = C.new puts c #&lt;C:0x0055ff9f85ba48&gt; print c #&lt;C:0x0055ff9f85ba48&gt;
seems like redis would work better than a ruby hash. you could set "user:&lt;ip address&gt;" and expire on the keys for 5 min. Then `keys user:*` would give you all of your current users.
/u/Thalagyrt's advice is sound and I can only recommend that you heed it: `PhoneBook#to_s` simply should not exist.
Like you I like some of the concepts of the gem, but otherwise it's really overkill IMO. I have posted a long comment in the original post comments section about why.
That'd be amazing to read how you tackle a problem like that. I mean we cannot put out feature implementation on hold but have dependencies that might take days to rewrite :)
Could you give a specific example of what it can't do 
Was going to suggest something very similar. Also this is a standard thing in Google Analytics as well.
glad I can help. If you have any questions about these feel free to ping me.
I don't currently use it, but [Cuba](https://github.com/soveran/cuba) is nice,a nd If you like the whole isomorphic thing, [Volt](http://voltframework.com/) is amazing!
That wouldn't scale very well, but luckily Redis has a HyperLogLog datatype which is perfect for this. Create a new HLL key every 5 minutes or whatever and just `PFADD` the IP address to the current key (based on time). `PFCOUNT` gets you the count of IP addresses and `PFMERGE` can merge multiple HLLs' into a single one, incase you wanted to get something like 'daily unique IPs'.
I've started playing with Volt just recently, but haven't gotten too far with it. Are you using it anywhere in production?
Oh, cool, I hadn't come across that one yet. I've used Grape with Rails before. What's the benefit of using Napa, just a reduced footprint?
Great love letter! And great book (clojure for the brave and true). We're switching from ruby to clojure now, it seemd a little strange first to replace rails with a couple of files, but now I'm feeling great, especially about tools and ideology (like "write libs, not frameworks").
Try http://lotusrb.org/ it seems to be well-designed set of libraries.
* I do it by "concept" :-) So for instance I'm changing everything that has to do with Return Authorizations right now. The cool thing is - for some parts you can have TRB &amp; older Rails-way - running side by side. For instance my RmaController, has several Operatons based actions (index, show) and some older style (new, create, destroy) - as I'm setting up a reform right now to handle the form. * As far as models - you don't have to remove anything from your model, while you are working on the reform form that will interact with it. You can clean up your model after you are done. This way if you have a dependency on some functionality somewhere else - it should be transparent. For instance I'm refactoring by Product model ( huge fat thing) - and it's called from a lot of places. So I'm stripping functionality from model one method at a time - as I'm replacing them with operations. * Keep in mind that certain things still stay where they used to be. For instance I have a bunch of analytics based methods in my models - that gather certain stats. It could be moved into an Operation, but since all I'm doing - just reading/aggregating data - I'm going to leave all of it in model for now. * As far as validations - you can leave all of them in model as you are moving them into your Reform / contract layer . All the errors will "bubble up" to reform, if they happen on underlying model. You can also "copy validations" from your model From ReadMe https://github.com/apotonick/reform &gt; Sometimes when you still want to keep validations in your models (which you shouldn't) copying them to a form might not feel right. In that case, you can let Reform automatically copy them. class SongForm &lt; Reform::Form property :title extend ActiveModel::ModelValidations copy_validations_from Song end &gt; Note how copy_validations_from copies over the validations allowing you to stay DRY. 
Awesome, thank you for your advice. I agree with you, I think the init method needed some more love. I will checkout Sandi Metz.
I'd love it if you could share a screenshot
Padrino, JekyII and Rack only Apps.
At first I figured he actually considered [insano-alignment](http://imgur.com/c2pBdNm) to be pretty, you know being a lisp developer and all, but then I realized it was just a poorly coded template. Firefox/firefox developer/safari = broken spacing, chrome looks like spacing is ok. Not going to boot up a vm to test IE variants but I assume they are batshit.
See that your code has "puts" in it three times? That should be a clue.
you are calling puts on the method puts print_list(grocery_list) change it to print_list(grocery_list) and you wont see the second set that is being printed.
If it's a gem and the link is simple like that, it's better not to bundle up a large dependency like action view. Just make a html img tag string and move on. That said, you'll need an extend or include inside the module. Not sure which off the top of my head.
That's awesome, thanks a lot for your help. 
The important lesson here is that a Ruby method will always return the last value evaluated within it, when there is no explicit 'return' command. In your case, it is 'x' which is the grocery_list array. So, "puts print_list(grocery_list)" 'puts' the array; if you 'puts' an Array, its members will be listed.
Not GP, but am going in the same direction: 1. My god the JVM start up is slow 2. learning to read code inside out is hard at first 3. a lot of code ends up looking like/is gnarly spaghetti. you spend a lot of time trying to decipher the shape of the data structure you're passing around 4. the stacktraces seem to be crappy 5. I don't quite understand all the rules for on the fly code eval, so occasionally i end up with code that works in my current repl but fails the CI tests. It's easy to dwell on the negatives. The positives: the lack of side effects is really cool. Between that and everything being nested functions or lists, when refactoring you can almost always just cut out any pair of ()s and call it a new function. It also means that as you build a program up you kind of feel more confident about it. I recently wrote a bunch of Go, and I found myself having to change the design so I could expose details I thought were worth testing. In Clojure‚Ä¶ almost everything is explicit, so so far things have been easy to mock out. Still getting my sea legs. Definitely influencing how I write ruby.
Clojurescript is a major plus.
A prototype put into production stays in production. 
You Aren't Gonna Need It. These days I hate few things more than unnecessary complexity.
Crystal is a great next language for Rubyists.
Do you have the benchmark numbers?
How do I simplify this.
No problem, the way she steps through it I see as a good way for you to refactor your code. So based on status you'll initialize a different type of object and make all the calculations in the object, extracting common code into modules to include, or maybe inheritance.
Vim until I die!
This is a good place to use [state_objects](https://rubygems.org/gems/state_objects), which is a classic GoF Design pattern. Examples are available at [github](https://github.com/mwindholtz/state_objects)
why?
Can someone explain the last sentence: You cannot create a hybrid solution where you have controllers inheriting from ActionController::Base and others inheriting from ActionController::API, in the same application.
\+ " Stupid"
Can you please tell me the advantage or use-case scenarios? Because I have now created new classes and moved the logics and calculation to those classes. I have updated the thread with my implementation. 
Usage of factory methods here is a band-aid solution to a smelly underlying design. All this could be avoided if 'reason' lived in the response object where it belongs. Leaving us with a consistent initializer: class ArticleReview def initialize(article, reviewer, response) # ... end Then the factory methods can still be used, but for the right reason - giving them intention revealing names. def self.create_approval_review_for(article, by:) response = Response.create_approval new(article, by, response) end def self.create_rejection_review_for(article, by:, reason:) response = Response.create_rejection( reason ) new(article, by, response) end end 
"Remember you will forget this shit in two months"
Clojure is such a beautiful language it's not even funny. The power of macros to bend the language puts any "dsl" you can write in Ruby to shame.
Figaro and dotenv are both commonly used. I tend to prefer dotenv. More info at https://www.ruby-toolbox.com/categories/Configuration_Management
So essentially, because of the config.api_only flag in application.rb. Its value can either be true or false. Thus, the rails app can either be a RAILS API app or a regular Rails APP. Not both at the same time. So, if in a regular application you want to build API's, they will still inherit from ActionController::Base
git branch -D master
Active_attr is also in a stable-but-not-maintained state with its creator. Hopefully one of these projects can distribute leadership to maintain and accept community contributions. 
quality is doing it right when no one looking
Speaking as someone who has given up many OSS projects, I welcome anyone who shows an interest and wants to take over maintenance on a stalled project. Generally the process is: 1. Declare your interest to the owner 2. Get commit access 3. Prove your credibility by triaging issues, review / merge PRs, answer questions 4. If owner is impressed with (3), they'll generally make you the new owner. Sometimes 3 is bypassed for minor projects.
Yeah, not really surprised. I got pretty deep into the internals of Virtus last year on a project and then started seriously questioning whether what Virtus was doing was the right approach. @solnic is usually pretty self aware about this kind of stuff, so really not surprised to hear he's opted to walk away from it. But there's clearly a real need that Virtus is trying to solve. I just don't think it takes the right approach. It might be OK for some projects, but I don't think I'll be using it again myself. If nothing else, it's nearly impossible to trace through in a debugger, and far too often, you need to.
Your gem says that it &gt; It lets you ignore and extract files and directories using .gitignore in your current git repository. If that's what the gem is going to do, then it shouldn't no anything else. No tool, class, or method should have a side affect of doing something unexpected. I should be able to do: $ git status . . . Untracked files: nope.txt change.md john.cena passwords.txt $ peacock nope.txt john.cena added nope.txt to .gitignore added john.cena to .gitignore $ git status Untracked files: change.md passwords.txt $ peacock passwords.txt added passwords.txt to .gitignore This is because i might have missed `passwords.txt`, or forgot about it. If peacock git committed after the first call, I would have committed a list of super secret passwords into the repo, and might not have noticed.
 ("0010".to_i(2) + "0001".to_i(2)).to_s(2) (0b0010 + 0b0001).to_s(2) You will got "11". The operator + works on Integer. A number is a number. Binary or Decimal are just a "representation". 0b1 == 0x1 == 1 . They are the same value.
You need to implement [adder](https://en.wikipedia.org/wiki/Adder_(electronics\)). You have diagrams and truth tables here so it should be quite easy.
No, not without using adders, see [wikipedia](https://en.wikipedia.org/wiki/Adder_%28electronics%29) for the theory, and [rosettacode](http://rosettacode.org/wiki/Four_bit_adder#Ruby) for the ruby code (it's ugly). Alternatively, simply use `to_i` and `to_s`: ('0010'.to_i(2)+'0001'.to_i(2)).to_s(2).rjust(4, '0') =&gt; "0011"
No. You convert String to Integer and then back to String. Binary Number is a non sens.
&gt; when making a new app, why does bundle install --local run instead of bundle install? What do you mean by 'a new app'? Rails? `rails new ...` doesn't use `--local` as far as I know. 
&gt; Binary Number is a non sens. All `FixNum` values in Ruby, including `Integer` are 'Binary Numbers', that's why you can easily perform bitwise operations on them. `10 &lt;&lt; 2 == 40` More over, binary numbers are really the only thing computers operate on, integers are a twos-compliment representation of the number and floats are a binary representation of floating point numbers, usually IEEE-754. 
You are the best question answerer. Where are those slots though? I'll take to the article to try to find out.
For me, at least, part of wanting to do an API in rails is because my app is a hybrid. Some things are pre rendered, others are fetched via API calls. Unfortunately, the performance of Rails for API stuff is, quite frankly, awful. Sinatra + raw SQL is several hundred times faster. So I'm now thinking of a solution where we have a read-only API made with Sinatra and raw SQL, but direct anything that needs to render HTML or create DB entries to Rails, since our persistence and authentication logic is already built. Now I'm concerned that this is going to get too complicated too fast. I'm sort of at a loss for what to do, really. Which is pretty annoying. 
He posted and it got voted up top, since you've posted this. I wouldn't use it as its behavior looks nondeterministic in corner cases and would be a nightmare to debug. This is aside the fact that OO people are beginning to realize that stashing mutable autocoercing state everywhere and then passing it around everywhere creates a clusterfuck-over-time, which is a lesson taken from FP
I've been thinking a lot about coercion and validation of params recently, and I can relate to everything you've mentioned. I just had a quick look at dry-validation and dry-data, and they look like a step in the right direction, so thanks for that! As you have a lot of experience in this area, I was hoping I could ask you a question about displaying validation/coercion errors to the user. So the typical form submission process in Rails looks like this: 1. User submits a form 2. The params/model gets validated 2.1 If _valid_, do whatever the form is supposed to do 2.2 Else (_invalid_) re-render the form with the errors In my own gem ([Rschema](https://github.com/tomdalling/rschema)), I'm kind of stuck on the last part: rendering errors to the user. The errors look like: &gt; Value at key path [:user] is missing required keys: [:password]. or &gt; Value at key path [:user, :password] fails predicate. That's not an error message that should be shown to the user. They should see something like this: &gt; Password must not be blank. or &gt; Password must be between 6 and 64 characters long. So how do you handle generating error messages for the front-end, taking into consideration i18n and arbitrarily deep nesting? Is this implemented in dryrb somewhere I can look at? It's even tricker, considering that the error could come from a failed coercion _or_ a failed validation. I would really like to ditch ActiveModel validation/coercion, but the error messages are just too good.
I sent you a PM, but for anyone else finding this, I offered some info in [this thread](https://www.reddit.com/r/ruby/comments/3seqoz/which_ruby_web_frameworks_are_you_using_in/cwxbxox) around different frameworks and finding performance.
Soooooo nobody is excited about the maybe pattern?
for non-rails users, checkout: https://github.com/SergXIIIth/config_env it handles your env variables and even pushes them to Heroku for you. 
On point 3: abstract more. Put some more functions in.
That first refactoring is a step in the right direction. I think there is still a lot of duplication that can be extracted. Also read: https://github.com/bbatsov/ruby-style-guide#no-semicolon 
is that the "safe navigation operator"? the thing that's like try? If it is, then hell yes I'm excited about it.
This isn't *quite* a Maybe pattern, though... At best, it's a "poor man's Maybe". For example, consider the following: "Example".nil? # =&gt; false ## Good "Example"&amp;.nil? # =&gt; false ## Good nil.nil? # =&gt; true ## Good nil&amp;.nil? # =&gt; nil ## ?????
`dry-data` looks nice! I recently built something similar just for one controller in Rails, because a) I needed fine control about the coercion rules and b) I wanted to show coercion errors to the user. The API looks like this: parser = object_parser(Foo, a: iso8601_date_parser, b: integer_parser) foo_object = parser[a: "2014-01-02", b: "123"] parser.unwrap.a == Date.new(2014, 1, 2) #=&gt; true parser.unwrap.b #=&gt; 12 foo_object = parser[a: "2", b: "123"] foo_object.unwrap_err #=&gt; {a: "Can't coerce '2' to a date"} So, the idea seems pretty similar, but your API is way nicer. Great job so far! I especially like the use of `|` for union types.
nil&amp;.nil? correctly returns nil, that's not what makes it a poor man's maybe, that's exactly what you would expect from a proper Maybe.
As I understood it, `nil` *responds to the method* `#nil?`, and therefore `nil&amp;.nil?` should return `true`? Perhaps I'm missing something, though - I don't have much experience in writing "real" Maybe monads, in other languages.
That's not what the safe navigation operator does, and that's not what the maybe pattern does. What Maybe does is to wrap something that is of type A in something of type Maybe(A), where it can be either a valid value of A or Nothing. Now, things don't work exactly like that in Ruby, because (nearly) everything is of type Object, including nil, but bear with me. The Maybe monad takes a method that transforms something from A to B and makes it a method that transforms something from Maybe(A) to Maybe(B), where it applies the method if there is a value of A and just returns Nothing if there was no value of A. What the safe navigation operator does is exactly the same, it sends the message (`nil?` in this case), but only if there is a value to send it to (where nil is the only way to not have a value), if there is nothing to send it to it returns nil. You can still have errors where the object doesn't understand the message you're trying to send (e.g. `"test"&amp;.map {|a| a }` will still raise a NoMethodError edit: actually the Maybe monad takes a method from A -&gt; Maybe(B) and will also return Nothing if that method returns Nothing, I was thinking of the Maybe functor, but `&amp;.` will also return nil if the called method returns nil, so it still works as expected.
&gt; maybe pattern I've heard about maybe/option types in other languages, about the null object pattern and about the safe navigation operator. What is meant by "maybe pattern" in this context? I feel like some of the discussion could've been avoided if you would've explained it here.
It sounds like they're going to try it out for a possible future feature. There's some expectation that immutable string literals (as a default) won't drop until 3.0.
Oooh, that could be handy! Thanks Link for reference: https://middlemanapp.com/
I feel like I looked this before, but it was at least a year ago, possibly more. Certainly worth a second look. Are you using it in production?
I would really appreciate some opinions from the group on my new library. The idea is pretty simple, some users would probably enjoy more details than the standard error messages provide. The dictionary that applies the messages is fully abstracted, so it is trivial to write new dictionaries in other languages, or with silly themes. Thanks for taking a look!
You should look at "method wrappers", for example: http://stackoverflow.com/questions/4219277/how-do-i-wrap-the-invocation-of-a-ruby-method-by-including-a-module
Write this so someone else can read it in two months, because you will read it in two months.
I'm not claiming it results in a proper monad, because it doesn't. However the cheating takes place in a different place (assuming the intent was to create a monad, which I don't think anyone is claiming). Nothing in Haskell is very much not "nothing", but an actual value, the fact that the literal `Nothing` is not of a concrete type is not really relevant, because all actual instances of it will have a concrete type. In the same way that in Haskell the literal `[]` has no concrete type (it could be an empty list of Integers or it could be an empty list of Strings), but every actual empty list will have a concrete type. You can even compare values of `Nothing` to other values of `Maybe a` (assuming that they have the same concrete type and that type can be compared in Haskell, which is not a given), `Nothing` will equal other equals of the same type and differ from maybes that wrap an actual value. Prelude&gt; let a = Nothing :: Maybe String Prelude&gt; let b = Nothing :: Maybe String Prelude&gt; a == b True Prelude&gt; let c = Nothing :: Maybe Integer Prelude&gt; a == c &lt;interactive&gt;:10:6: Couldn't match type ‚ÄòInteger‚Äô with ‚Äò[Char]‚Äô Expected type: Maybe String Actual type: Maybe Integer In the second argument of ‚Äò(==)‚Äô, namely ‚Äòc‚Äô In the expression: a == c Prelude&gt; let d = Just "text" Prelude&gt; a == d False What is different from an actual monad is that the "actual" values aren't wrapped. To make `&amp;.` a monadic operator you would only be able to use it with methods that always return either an instance of a new class `Maybe` or `nil` (technically the nothing that it returned would also need to be of type Maybe, but that's really less of a problem in a dynamically typed language than the fact that normal values aren't wrapped). Of course that would be a huge breaking change to the standard library of Ruby, for example `Hash#[]` would need to return the value wrapped in Maybe or nil, instead of the value or nil as it does now, the advantage would be that currently if you get back nil it could actually be the value of the hash at that point, and you have no way to know without using `Hash#key?`.
Better than this though IMHO: foo.?bar.?baz
Those are both extremely old versions. 
Looks like you screwed up your `rbenv` setup. You have gems built for Ruby 1.9.1 in a 1.9.3 environment, that usually won't work. Kill your `rbenv` install and set it up again. 
might not be connecting to your server?
Using cuba.is for an ad serving platform
I suspect that your Gemfile is indicating an older version of the mysql2 gem that is not compatible with the version of the MySQL client (or headers) installed on your new laptop. Can you show us the output of `mysql_config --version` and `bundle show mysql2`? 
In general, yes, `puts` calls `.to_s` on the thing being output. However, there is one exception: if the argument to `puts` is an array, it iterates through the array and calls `puts` on each element of the array. In other words, `puts my_array` is actually doing `my_array.each { |element| puts element }`, which is different than `puts my_array.to_s`. 
So then what *is* 'puts my_array.to_s' doing, if it outputs your array, in what looks like array form??
`Array#to_s` just builds a string representation of the array, suitable for printing or including in other strings. It looks like an array, because it's intended to look like an array, but it's just a string. Don't overthink this. :-) http://docs.ruby-lang.org/en/2.0.0/Array.html#method-i-inspect
Same. I'm glad to see it arrive.
I thought this at first, but mwpastore is correct I believe
I've always thought hashes/dictionaries should be subclasses of sets and have the same methods available. I'm glad to see Ruby taking a step in that direction.
I ran apt-get upgrade and apt-get update
It's sort of idiomatic though, right? It echoes the current pattern of "object &amp;&amp; object.one &amp;&amp; object.one.two"
Another way to do this in the future (just to help you out for future reference!) might be... puts myArray.to_s.class =&gt; String So you can call `#class` on any object in Ruby and it'll tell you what class that object is an instance of. Useful for checking yourself if you're not sure about the inheritance of an object for some reason.
I often drop my name into the ring as an available mentor in many places on reddit. So, do feel free to send questions my way and contact me any time you need help.
I like it, but am disappointed they didn't use **?.** I just got used to that it in Coffeescript!
What about foo?&amp;.baz!&amp;.bar?
This worked for me, but I wouldn't recommend it :) require 'action_view' module TwitterImageTag include ActionView::Helpers::AssetTagHelper def show_me(username, size) image_tag("https://twitter.com/#{username}/profile_image?size=#{size}") end end include TwitterImageTag show_me('Boz', 'Large') 
According to Matz: https://bugs.ruby-lang.org/issues/11537 &gt; I like the idea. My remaining concern is ".?" is too similar to "?." which is chosen by other languages. We cannot use "?." since it conflicts with a method call with a "*?" predicate method.
 module EnumUtils def self.get_by_chain(hash, chain) chain.inject(hash){|hsh, part| hsh[part] rescue nil} end end h = { 'foo' =&gt; { 'bar' =&gt; 'baz'} } EnumUtils.get_by_chain h, 'foo.bar'.split('.') #=&gt; "baz"
Nice post! short and sweet with a lot of good info. I'm pretty new to Ruby, as one of my first projects I wrote a little twitter bot that has a mess of nested if statements, this gives me some good ideas on how to simplify it.
It's probably a matter of taste but I would do this: def student_class(level) [:freshman, :sophomore].include?(level) &amp;&amp; Student::Underclassman || [:junior, :senior].include?(level) &amp;&amp; Student::Upperclassman || [:graduate].include?(level) &amp;&amp; Student::Graduate || Student::Unregistered end klass = student_class(params[:student_level]) student = klass.new(name, birthdate, address, phone)
&gt; That's not what the safe navigation operator does, and that's not what the maybe pattern does. Unfortunately. It would be much more useful if it would correspond to the original feature proposal. This is not a coincidence, Rails implemented (in ActiveSupport) just `#try` and `#try!` methods and not an equivalent of the forthcoming `&amp;.` nil shortcircuit operator. Ruby's type system is quite different from Haskell or Groovy so there is no point implant foreign idioms. Ruby methods calling chain is not analogous to Maybe monad. There is no type affinity between object method is sent to and the resulting value, so monadic transformations like `m a ‚Üí (a ‚Üí m b) ‚Üí m b`are meaningless here. It did showed up with `nil` example, where unlike `Nothing` data constructor, *applied methods can result in a non-nil values*.
I never claimed it was the same, but the person I replied to seemed to think that this was what made it a poor man's maybe pattern, and that's simply not true. Also, `nil.try(:nil?)` returns `nil`, unless I'm missing something `#try` is exactly equivalent to `&amp;.`. If it's not I'd like to know what the differences are.
...does this code actually work? Won't student_class return true/false?
If you ever not sure about something try it out in irb. In Ruby, logical operators short circuit as soon as possible and returns the actual value, because values are either truthy or falsey. Despite the downvotes there's totally nothing wrong with using logical operators as control structures. They're explicitly designed to behave this way.
You're right, it works! Good to know. 
Don't want to be super negative, but ".ninja"? Cmon man we don't really like the sales speak...
not knowing javascript hasn't stopped thousands of developers from using react...
If you're interested in rails, learn rails, it's nice to know ruby before.. In fact, since rails using ruby, you'll learn ruby while you learn rails.. so yes, you can now try rails..
You might be interested in the discussion about it: https://bugs.ruby-lang.org/issues/11537
Agreed. No piece of code should need to invoke five methods in a chain. That the code breaks on nils is it trying to tell you that you've got responsibilities in the wrong places, not that you need a special operator to avoid invoking methods on nil. 
That seems like an appropriate way to structure things. I agree with you that passing around class objects as variables makes it a lot harder to keep track of usage. Note that the example in the blog didn't say where this code lived, so it could actually be handled in much the way you describe. 
A couple of things: If you're using bundled gems from before upgrading, you'll have to rebuild them. You may want to install the apple developer tools. El Capitan completely removed OpenSSL from the system. If MySQL was trying to dynamically load it in some way you might be hitting errors there. Install OpenSSL through home brew and rebuild the gem with options to point it at homebrew's mysql
Thanks for posting this! 
Welp...I missed it; is there a cache of the video somewhere?
Yes
Hah. That link is awesome. Although I'd want to filter out a couple of the more... *interesting* subreddits before writing any language AI out of it. I think a couple of those would trigger any sufficiently advanced AI's "humanity is a virus and I'm the answer" threshold. ;)
Erm...thank you for the reply, but I did mean netmask. Also called a subnet mask. For example, 255.255.255.0 is a common subnet mask for the private network 192.168.0.0. The Socket library gives access to the system's IP addresses but not their subnet masks. The IPAddr library gives tools to properly format and manipulate IP addresses and subnet masks, but gives you no way to determine what they are on your local machine. That's where I'm stuck. :\
Thanks for the additional details, I updated the post. Re-reading that part I didn't make the RubySec db clear.
I've not had a chance to use Gemnasium, what do you like about it?
I laughed too much at the jack about the stack trace.
I use [bundler-audit](https://github.com/rubysec/bundler-audit) via the [codeclimate-engine](https://github.com/codeclimate/codeclimate-bundler-audit). It manages to catch a lot of common mistakes
I think you can use the *Socket.getifaddrs* function for that.
You can try Rails when you are mentally ready for it. Knowing ruby before starting rails development is not mandatory. Use [Michael Hartl's rails tutorial](https://www.railstutorial.org/book) to get started. Use [Railscasts videos by ryan bates](http://railscasts.com/) to really get to the next stage. Use [Rails Guides](http://guides.rubyonrails.org/) to really get into the framework. And use [sample github projects](http://github.com/) to really see how others approach specific coding tasks. 
We had fastri looong time ago. It's been abandoned for a while now, but looks like there's a more recent fork [here](https://github.com/dakrone/fastri). https://rubygems.org/gems/fastri/versions/0.3.1.1 I think google won in the end - it's just faster to "google it" nowadays :) 
Looks like it's different not only between Windows and Linux, but OS X as well - even though for the latter two the command is `ifconfig`, all three seem to require different code to parse subnet masks from the output.
chiquito +1000
sorry oschebel, didn't mean to put you off. Allow me to explain: 1. attr_reader and the other accessors are what we call a 'class macro', i.e. a class method that's only used within the class. Is a common meta-programming technique. You can read more about that and other meta techniques at https://gist.github.com/Integralist/a29212a8eb10bc8154b7. Meta-programming is used a lot in Rails. 2. Modules are heavily used in Ruby and especially Rails. Knowing how they're used will make learning Rails much, much easier. 3. "link_to "Profile", @profile'" link_to is just a method call, receiving two arguments. It's called on the 'self' object, i.e. usually the view object you're in, but its defined further up the stack (hint: Modules come into play here again). I suppose the point I was trying to make is that once you comprehend that everything is Ruby is an object and most 'magical' statements are just method calls on objects, then Rails will become much easier to understand, use and debug. I advise people to be comfortable with Ruby before starting Rails. But don't let that stop you delving into Rails. I'm sure you'll pick up a lot of Ruby's idioms and structure along the way. If you need any help along the way don't hesitate to ping me and I'll help if I can.
What's wrong with using a begin..rescue block for each statement that is known to raise RecordNotFound? It looks like more code, but it's better to use standard Rails and Ruby features than add gem dependencies IMO.
Exactly. You can access the record through the exception even. And if one action updates more than one record and therefore needs by model exception handling it smells already :). Maybe for some edge cases I cannot think of now
¬°Siete caballos vienen de Bonanzaaaaarl! xD
Just to be clear, El Capitan _does_ ship with OpenSSL 0.9.8zf, just not with its development headers (to build things against it). 
I use pry so much that I set a vim macro to insert require 'pry';binding.pry
Which then leads to the inevitable git hook to check for binding.pry in your code https://gist.github.com/alexbevi/3436040
It's built-in to rubygems: $ gem server Server started at http://0.0.0.0:8808 It can be run as a daemon so it's always available, see `gem help server`.
BINGO!
Socket.getifaddrs returns an array of Socket::Ifaddr objects -- netmask is a method available to those objects.
I don't think it's sustainable at all. A lot of it depends on your family situation. I'm married but have no kids, so I still have a lot of free time. I know that once kids happen, my free time will be scarce. I'll have to be more careful planning my 'training time'.
I tried that before, but it doesn't actually contain the netmask. It's always nil. I have no idea why its even a method if it isn't implemented.
Also check out [pry-rescue](https://github.com/ConradIrwin/pry-rescue)
This is huge for the ruby community. He's a big contributor. It's unfortunate that it's come to this. 
Excellent, thank you Mike for all your great work.
Works for me. Seems to put `?` for whole host octets for some reason though. `#&lt;Socket::Ifaddr en0 UP,BROADCAST,RUNNING,NOTRAILERS,SIMPLEX,MULTICAST 10.100.41.50 netmask=255.255.254.? (7 bytes for 16 bytes sockaddr_in) broadcast=10.100.41.255&gt;` 
I signed up, but later got an email that they had to move (part of?) it. Anyone know if it's still going to be live streamed somewhere?
Might be because I'm on windows? Because I called .netmask for Socket.getifaddrs for every adapter and it returned nil on all of them for both of my computers.
Very exciting! Appreciate the absence of changes for the API - something you don't see very often.
Thanks for posting! In my project (1) &amp; (2) are least used 
Nice dude. Keep it up!
It's actually gonna be fine, this has happened many times before and those projects will get picked up by people invested in making them continue or they will just die. In the case of the latter that's not necessarily a bad thing.
In addition to alerting on gem versions impacted by security issues, Gemnasium has a fairly useful auto-update feature. Basically it will attempt to find a fully updated set of dependencies based on your `Gemfile` by running your test suite against the updates. If tests pass, it can either alert you or automatically open a pull request on Github with the changes. If tests fail, it tries several combinations of versions to find one that passes tests. You can schedule this to run on CI nightly. 
Nope, because I don't like to use the mouse. My entire workflow is based on this principle.
1 is an antipattern. Subqueries are frequently far less efficient than joins for non-trivial data sets.
Ryan was a very active contributor to Spree Commerce project. [This](https://spreecommerce.com/blog/future-of-spree-oss) may also be related to the announcement.
This is a pretty decent set up, but if using the vim+tmux combo I would recommend checking out tim pope's [vim-dispatch](https://github.com/tpope/vim-dispatch) which will run tests in a pop up tmux and then pulls the test data into a split in vim (quickfix) window. This is great because it will actually give you line-jumps to failing tests if you are running multiple tests. Also, It automatically closes the window if all your tests pass. You can pair this with something like vim-rspec or vim-test and you get a very nice flow without every really switching out of vim
Aside from having no idea why you're posting this here, I have to ask: Why are you bothering to add comments like `# Return an error`, `# Create an empty array`, `# If its a zero`, `# If its a one`, and on and on. They're useless. I actually don't see one useful comment, and I'm not sure the code needs any.
To the point that @srnull made, there is no explanation as to why you are posting this. Are you just sharing what you wrote, or are you looking for people to critique your implementation? Or is it something else? Also, there is such a thing as "overdocumenting" your code which @srnull alluded to. Many of the comments that you provided are things that anyone with some programming experience would be able to interpret from the code itself. That said, I find the comments make the code harder to read. A final note is about code stylism. I would suggest taking a look at [Github's Ruby Style Guide](https://github.com/styleguide/ruby). Indentation should be two spaces and not four, comments should generally be placed *above* the line being documented, etc. Hopefully that is a bit more constructive. I will not bother evaluating the code itself without knowing whether you want the criticism. **EDIT:** formatting
To add to the commenting comments, I find it a bit funny that the only two non-commented lines are the most complicated line in the whole function and an `else`.
So take this for example: book_1 = "A Wrinkle in Time" book_2 = "A Brief History of Time" book_1 &lt;=&gt; book_2 When you compare them, is it looking at them alphabetically? Wouldn't this result in a -1 since B comes before W in the 2nd word of the 2nd book? Also when sorting this : books = ["Charlie and the Chocolate Factory", "War and Peace", "Utopia", "A Brief History of Time", "A Wrinkle in Time"] books.sort! { |firstBook, secondBook| firstBook &lt;=&gt; secondBook } Why are we just using firstBook &amp; secondBook when there's 4 strings/books in there? So confused :\ 
So starting with what you said about the block and taking 2 books at a time, wouldn't that mean it's only sorting them 2 at a time and the next time it calls the next 2 books it's only sorting those 2? Meaning, after you look at it as a whole, it's still not sorted because it has just been alphabetizing 2 at a time oppose to the whole thing as one? Did that just make any sense at all? Sorry :\ So just to clear up the return part. This is what i've read : " 1 if first operand is greater than the second, and -1 if the first operand is less than the second. " So i guess i was just confused on how it weighs which one is greater or less than with strings. Judging by what you said, the book with "A B" is greater since it comes before the "A W"? 
The block passed to sort will be used until *all* the books have been sorted, 2 at a time. To clarify your understanding, try the comparison yourself: "A B" &lt; "A W" #=&gt; true "A B" &gt; "A W" # =&gt; false I think of the spaceship operator (&lt;=&gt;) like a scale that tips to whichever side comes first. In the case of strings: "A B" comes before "A W". If you were to rank the letters of the alphabet, A would be 1 and Z would be 26. 1 &lt; 26 # =&gt; true 1 &lt;=&gt; 26 #=&gt; -1 The value -1 means the left side comes first.
I thought maybe you were trying to avoid `String#to_i(2)` and `Integer#to_s(2)`, but there it is at the end there, so why not do this? def twos_complement(b) fail 'Invalid Input' unless b.respond_to? :match and b !~ /[^01]/ (2 ** b.length - b.to_i(2)).to_s(2) end
Yeah, I was. Thanks for this!
Thanks!
Not related at all. I stopped working at Spree middle of last year because Spree Commerce (the company) was obviously no longer interested in maintaining Spree. I asked for feedback on the admin backend redesign and then two months passed with promise after promise... and nothing. There were other features I was also working on which didn't get any feedback either. I'm very glad that Solidus (https://github.com/solidusio/solidus) is now a thing and that it has a very active community around it.
I'd love for more companies to invest more time into training their staff. There's the old adage where the CEO and CFO are talking and the CEO says that we should train people, and then the CFO asks "What if they leave?" and the CEO responds with "What if they stay?" I'm happy to work for a company that funds (and in some cases even sponsors) events like RailsCamp in Australia where I can go and learn new things and share ideas with others. More companies should be doing that, definitely.
Also: I've not been contributing _that much_ in the past year, maybe two years. My past contributions (like some of the Rails guides) are really what stands out there. I'm happy for them to stand on their own and other people to update those as required. I'd really to be spending more of my time writing books as I get a nice little thrill out of the good comments that come out of that _and_ people show their appreciation by buying my work. Double win.
use `require_relative` instead of `require`. Or use `require './string_extensions'`. Read [http://stackoverflow.com/a/9750732](http://stackoverflow.com/a/9750732) for more information.
require also only loads code once. good for using variables or methods from other code. If you cant the code's "main" to load then you must use load. load will reload every time the load is run, but require will only load once.
I guess question was: why don't you use "classic" model of Either monad? When you have two classes (left and right, but in our case let's call them Ok and Error) and use them. Now you seems to have objects of class Result that wrap objects of class either Ok or Error.
Fugitive is amazing BTW, assuming you are using git, it will make you use it better and things like vim for merging are awesome. 
It has when it comes to chaining, unless you figure out how to cut unneded execution branches (example with 'map' in topic).
Fugitive is indeed awesome. Well, all of tpope's plugins are ridiculously great.
in the pipe five by five ^sorry^couldn't^resist^&gt;_&lt;
Your involvement has been a consistent thread through the gems that were important to the ecosystem, like spree, state_machine etc. I, and others, have used gems because you were a maintainer or contributor. Not trying to blow smoke here, just appreciative. Your life, your decision and you got to stick with what gets you up in the morning. 
[Ready for dust-off!](https://www.youtube.com/watch?v=avN7vICX208)
Meet Hyde sounds really neat. Even as someone who can read code, Sublime Text and a Console just don't make it easy to put new content onto Jekyll-hosted blogs. I'll have to give it a try.
The reasoning behind me not caring for webhooks is that we use a lot of third party service i.e. Github, Wercker, etc to facilitate our development cycle and in order for say github to communicate to our server when a deploy event has been created I would need to expose a server which are currently inside an protected network. So the thought was well If you can't tell the servers when to update why not have the server ask if it needs to update. As for tarball this is a nice way to package all of the different types of applications as we have projects in a bunch of different languages and using tarballs allows to standardize the way we construct "build artifacts"
For those curious, you can use postgres for geospacial querying with http://postgis.net and https://github.com/rgeo/activerecord-postgis-adapter 
They should be on the confreaks youtube page when available: https://www.youtube.com/user/Confreaks/videos
`MiniTest`s built in mock / stub capabilities are very basic and can't do what your asking. If you want more advanced mocking then use another mocking library like `mocha` or `rspec-mocks`. Alternatively you can restructure your code such that this isn't needed, e.g. pass the class to use for `@external_lib` into the `initializer` of `MyObject`, then you can pass a mock in for that class.
Ah thanks for reminding me, I in fact did pass the class into the initializer object, i just forgot to annotate that. i will update my post now to reflect that 
`self.id=` references the _method_ `id=`. If this is a regular setter method defined by `attr_writer` or `attr_accessor`, then it's the same as using `@id`, but not necessarily.
what you said makes sense to me and answers my last question on my post. I guess what I am trying to figure out is why i get errors like `expected method() :execute =&gt; got []`
Pry under Ruby 2.x really kinda sucks compared to Pry under 1.9. I've had all kinds of stupid issues.
Well, you pass a block to map, and the block doesn't get executed if the previous fails. A block/proc/lambda doesn't do anything until called.
We (or at least I right now) don't know what sort algorithm the `sort` method uses. But any sort algorithm will rely on comparing two items to each other, over and over again for lots of combinations of two items. Don't assume your block is only called once when you call `sort` -- it's called many times. irb(main):004:0&gt; i = [10, 5, 6, 3, 4, 2, 1000, -5, 5] =&gt; [10, 5, 6, 3, 4, 2, 1000, -5, 5] irb(main):005:0&gt; count = 0 =&gt; 0 irb(main):006:0&gt; i.sort! {|a, b| count += 1 ; a &lt;=&gt; b } =&gt; [-5, 2, 3, 4, 5, 5, 6, 10, 1000] irb(main):007:0&gt; count =&gt; 20 irb(main):008:0&gt; See, the block was actually called **20** times, with that one call to `sort!`. If I wanted to think harder and remember things I don't right now about math, and maybe look up what sort algorithm it's using, I could tell you exactly why sorting an array of 9 items takes 20 individual comparisons. But I don't. Also note in that example using integers, it's clear that the _lowest_ values come first. That's true with strings too. So: " Judging by what you said, the book with "A B" is greater since it comes before the "A W"?" -- No, the one that's greater comes *last*, just like with integers. `sort` and `sort!` will sort from least to greatest, because that's generally what people mean by "in sorted order" by default, from least to greatest. I think you may enjoy some intro to computer science texts. 
it is defined by attr_accessor, so the same, so why does it behave differently?
 #!/usr/bin/env ruby require 'json' open('Marvel Week checklist.txt').each_line do |line| line.strip! next if line.empty? title, number = line.split('#', 2) puts JSON.generate({ title: title.strip, issueNumber: number.to_i }) end
looks like there's an issue with your current version of ruby 2.2.1 and where it's looking for the jekyll gem (ruby 2.0.0) try doing rvm use 2.2.1 then gem install jekyll make sure that your path is set up correctly... Typically rvm has it's own user, and is not installed as root. You might want to look into setting up a separate user for rvm.
&gt;but I have never seen a method called within a method? When you are in a method you may call another method or the same method. You may want to check out: https://en.wikipedia.org/wiki/Recursion_%28computer_science%29 If you are confused about methods calling other methods you probably shouldn't look into methods calling itself. It is more complex. ---- I'm not the best at explaining things, but hopefully this helps. 1. The first thing that runs is puts fact(5) 2. 5 does not equal 0 so it does the line n * fact(n - 1) 3. The first thing it does is fact(n-1). This means it calls the fact method again with 4 instead of 5 (since 5-1 is 4). Remember you have not completed the n * part of that line. You only completed the the fact(5-1) portion of the line. 4. You continue calling the fact(n-1) until you do fact(1-1). When that happens you return 1. 5. This means you completed fact(1-1) part of the line but you still have the n * portion of the line to do. n is 1 and 1 * 1 is 1. You return 1 once again 6. You are now back at the line n * fact(2-1). n is 2 and fact(2-1) is 1 (what we returned above). 2 * fact(2-1) is 2. You return then return 2. 7. You are now at the line n * fact(3-1). 3 * 2 is 6. You return 6 8. You are now at the line n * fact(4-1). 4 * 6 is 24. You return 24 9. You are now at the line n * fact(5-1). 5 * 24 is 120. You return 120. 10. You print the number 120.
That is so beautiful . Thank you for the suggestion. Worked like a charm 
What you're seeing a recursive method. Basically what happens is that you have a base case( n == 0) and you're constantly working towards that case (n is decremented each time fact is called) so you can think of calling fact as fact(5) = 5 * fact(4) = 5 * 4 * fact(3) = 5 * 4 * 3 * fact(2) = 5 * 4 * 3 * 2 * fact(1) = 5 * 4 *3 * 2 * 1 * fact(0) = 5 * 4 * 3 *2 * 1 * 1 Not sure if that's a good enough explanation, but if you google recursion, you might be able to find a better explanation. 
&gt; I have never seen a method called within a method You will: most complex programs involve methods that call methods that call methods and so on. This particular method is "recursive". It calls itself using a variation of the input it was passed. 
now try fact(-1)
This is my first attempt at an API wrapper in Ruby. The API is in beta, so I wouldn't use it in production... Was hoping to get some feedback, particularly regarding testing/stubbing external services more effectivey.
Go find a copy of *The Little Schemer* and you'll understand recursion.
Thanks for spelling it out for me- I get it now. Thanks a ton
They are not the same, but they will have the same effect (because you used attr_accessor with `id`). `@id =` sets the instance variable directly `self.id = arg` will call the `id=` method on the `self` object with the argument `arg`. Since you used `attr_accessor :id`, it created a simple `id=(arg)` method that will do `@id = arg`. That's why it has the same effect. If you don't use `attr_accessor` and define your own `id=(arg)` method, you can implement additional logic. For example, a check if `arg` is indeed worthy to be the new `id` or not. That's why it may be useful to call `self.id=` from another method instead of accessing `@id` directly.
Not using `sudo` will resolve your issue. Try `sudo gem list` and `gem list` You will see those are two different rubygems.
Hahahaha will you buy me a beer if I make it before 2016?
Don't worry OP. Recursion is a difficult concept to understand - you just need to see/write 50 examples of it to 'get it'. As the old saying goes, the trouble with recursion is recursion...
And to boot few languages support tail recursion anyway. It's not uncommon to get by perfectly well without running out of stack.
This gave me the mental image of each Fiesta splitting into two smaller Fiestas, which then repeated the process indefinitely.
Thanks!
This gem has made my life so wonderful thanks so much!
look into the vcr gem to record and playback traffic from external sites. much easier than stubbing everything yourself. I can advice a bit about using it: I wrote a simple web scraper that provides an api to codecademy using it. 
Given the following: if some_var.nil? binding.pry else puts some_var end In Ruby 1.9 you would break on the binding.pry line. In 2.x you'll break at the puts some_var line. We've adopted a strategy of using "binding.pry;2" which leaves you where you want to be since the '2' becomes the next line of code. reload-code also seems to have some wonkiness.
This, OP. Most programmers/developers would tell you that recursion is one of the hardest concepts to execute properly. It just takes some time and practice to wrap your head around it.
I personally really enjoyed http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104 It's targeted for people that know how to program, but is supposed to show them idiomatic Ruby
Grab "Eloquent Ruby" by Russ Olsen. It's a great way for someone with programming experience to learn how to write Ruby that looks and feel like Ruby.
You're right, but so what? It's just a general advisory for someone just learning about recursion. 
Looks like other people helped you out, great! In the future, a screenshot is not a very good way to share your problems. Especially when you're sharing a screenshot whose only pertinent part is a Terminal screen -- you know you can just copy and paste the actual text in the Terminal screen, right?
Gotcha.....
Assuming you know how functions work but are just learning about recursion then why would you already know about tail call optimization?
If someone tells me to be careful of something because of X and I don't know what X is, I mash buttons into google.com and find out.
The last spec ('it "should use the local cache" ') does not have an associated block, so RSpec will flag it as "pending".
I'm interested in reading this book too - I'm also fairly new to Ruby. The book is a few years old, though (2011) - has a lot changed since then with Ruby to make the book out of date? Another recommendation for OP is *The Well-Grounded Rubyist* by David A. Black.
Great work, a couple ideas for code cleanliness First attr_reader/attr_accessor is your friend when exposing stuff to the outside, your vars attempted and the like should be converted to attr_readers. Style-wise you should consider removing the parens at the end of method declarations if that method takers no arguments. (def blah() -&gt; def blah) In try_candidates, you should really refactor the break out, try using a conditional while instead, it will save you a lot of headache and simplify your code. Do the same with the loop in compare as well, a general rule is to refactor loop specific conditionals to the beginning of the loop, so that way people know what we are looping to do. For compare you could also change the loop to a times loop (@text_length.times do |i|) Consider using the += operator instead of x = x + 1 style increment. That should put you into a better place for now, hit me back with a PM or comment if you update further and want another review.
Oh Ok, I understand. What i need to do now is figure out how to check if the book exists in the local cache.
run this on it for some style tips: https://github.com/bbatsov/rubocop
Not bad. Here's an [example](https://gist.github.com/tenderlove/f6d47e25c7cf8a7d5216) of how a seasoned ruby developer solved it.
Not much has changed in Ruby in the past ten years, at least not in the language. It's pre-Ruby2, but it's after 1.9 so it'll lack some newer sugar but not all of it. That's not relevant though, since the books description says it doesn't focus on syntax or the latest gems. Ruby doesn't move very quickly, most changes have been small extra-comfort type things. Matz has announced Ruby 3.0 will have some big changes, it'll be the first time to my knowledge and it'll be years from now if he does settle on something.
Who would have thought ;) I'm guessing you removed a lot of object allocations and simplified run-time logic too, hence the speed boost :) Anyway, congrats on the new release, happy to see more people embracing FP patterns in Ruby.
That's a good point.
Rubymine is where it's at. Love that IDE.
Unlike a lot of people have been recommending books, I'd like to suggest using a coding-challenge website like [codewars](http://www.codewars.com/). I like them because they're coding-interactive and because you can see other (popular) solutions. Interactiveness means forcing yourself to really use the language, and reading other solutions means getting a feel for idiomatic ruby style and methodology.
Nice summary! It's somewhat unfortunate that Set and SortedSet in Ruby are just Ruby wrappers around Hash. We've considered making them fully native (practically zero code needed) but we'd also like to get it closer to raw Hash performance. It might be interesting to see whether a Hash used as a Set performs better; that would tell us how much the Ruby wrapper is costing us. In any case, these numbers are about what I'd expect. We'll continue pulling away from Ruby and toward Java performance over the next year.
JRuby is fantastic. It provides a smooth path from Ruby to Java, and is perfect for optimizing sections of code exactly like you describe. Good candidates for transition from Ruby to JRuby to Java: any bottlenecks in code caused by significant searching, sorting, filtering, networking, calculating, or parsing. 
I'm a longtime (20+ years) Perl programmer and just started learning Ruby about three or four months ago. It took me about two months to really feel comfortable, but I was learning Ember.js at the same time so three weeks isn't a completely unreasonable goal. You won't have time to play around as much with different Rubies (e.g. MRI/YARV, JRuby, Rubinius), frameworks, application servers, ORMs, etc., but you'll be literate. I did the first two or three Ruby Monk lessons (https://rubymonk.com) and then read Metaprogramming Ruby 2. MR2 is absolutely fantastic and I highly recommend it. It may seem strange to jump into metaprogramming when you are just getting started with the language but as you will soon learn Ruby and metaprogramming are tightly coupled. Do you know what framework and libraries you'll be working with? Web front-end or back-end or other? If you can narrow in on a few gems that will greatly speed you along. If it's things I'm familiar with I can provide additional suggestions. The hardest part for me, especially coming from a Perl background, is the state of the documentation. I frequently find myself having to dive into gem source code to understand how to do basic things. A lot of the GitHub READMEs are woefully inadequate and the API documentation at RubyDoc.info doesn't tell you much more than the method signatures. 
https://github.com/bbatsov/ruby-style-guide http://awesome-ruby.com https://github.com/franzejr/ruby-tricks (https://www.youtube.com/watch?v=aBgnlBoIkVM) http://eli.thegreenplace.net/2006/04/18/understanding-ruby-blocks-procs-and-methods/ https://www.youtube.com/watch?v=NlPxvRSUVQI
I'm more interested in how you convinced someone to let you run Elixir in production. It's a cool language/BEAM VM but it seems like it is still rather unknown to a lot of people. 
&gt; Why would it say nil? Chances are `JSON.parse` threw an exception and you didn't notice it. Make sure your input is valid JSON, the snippet you linked to isn't. 
gotcha, i'll look into it. thanks for all the help!!
Great post! I'm glad you discussed compatibility at the beginning, I think this is part of why JRuby's been overlooked (and also why it's an incredible option now). We've been extracting part of our MRI Rails app into a JRuby Roda app lately, and it's been a lot of fun. I'd be interested in hearing more about your deployment progress, I've been working on that lately myself.
All the suggestions so far are great, but I just wanted to add a different perspective. I wouldn't be worried about "burdening" the pro Rubyists that you'll be working with, for a couple different reasons. First, I doubt that you'll be the only non-expert among them. There's a wide range within every company, and if this is web/Rails related, then you'll definitely witness that range. Secondly, even with the much more advanced devs, I'd expect most won't mind helping you out. Most want to help others and share knowledge, and there's the added benefit of ensuring that a newer person learns good habits and also knows what not to do. At least this has been my experience, both as that newer person and nowadays as the one frequently helping others.
Learn the basics of Ruby syntax (which will be easy for you), then dive into one of the intermediate-level books. I'm biased towards [Effective Ruby](http://www.effectiveruby.com), since I'm the author ;) That said, any resource that shows you how to write code in Ruby style will go a long way. And don't be afraid to bring your functional knowledge to Ruby. Things like immutability can go a long way. And congratulations on your new job!
Is that really a 16 line program that solves this with even better logic? Now I have to reverse engineer this thing and figure out what all the little parts do.
Ruby has all sorts of perks, doesn't it? I have never heard of inject before. More homework!
I don't know if I misunderstood your question but, considering your variable is a string, you shouldn't have any problems using it as is or interpolating it in a String. What problem are you having?
That's handy.
Here's a really raw and overly simple way using JSON to turn the json into a Ruby object and the [Hashie](https://github.com/intridea/hashie) gem for searching the object (stubbed_json_response is just a method to add some sample json). This will deeply search the entire hash for a match: 2.1.2 :168 &gt; require 'json' =&gt; true 2.1.2 :169 &gt; require 'hashie' =&gt; true 2.1.2 :170 &gt; def stubbed_json_response 2.1.2 :171?&gt; '[ 2.1.2 :172'&gt; { 2.1.2 :173'&gt; "blog_name": "sad-poems-about-cats", 2.1.2 :174'&gt; "id": "39316333303", 2.1.2 :175'&gt; "type": "post", 2.1.2 :176'&gt; "tags": [ 2.1.2 :177'&gt; "poem", 2.1.2 :178'&gt; "poems", 2.1.2 :179'&gt; { 2.1.2 :180'&gt; "one": "1", 2.1.2 :181'&gt; "two": "2" 2.1.2 :182'&gt; } 2.1.2 :183'&gt; ] 2.1.2 :184'&gt; }, 2.1.2 :185'&gt; { 2.1.2 :186'&gt; "blog_name": "whatever", 2.1.2 :187'&gt; "id": "555", 2.1.2 :188'&gt; "type": "post", 2.1.2 :189'&gt; "tags": [ 2.1.2 :190'&gt; "poem", 2.1.2 :191'&gt; "poems", 2.1.2 :192'&gt; { 2.1.2 :193'&gt; "one": "1", 2.1.2 :194'&gt; "two": "2" 2.1.2 :195'&gt; } 2.1.2 :196'&gt; ] 2.1.2 :197'&gt; } 2.1.2 :198'&gt; ]' 2.1.2 :199?&gt; end =&gt; :stubbed_json_response 2.1.2 :200 &gt; parsed_json = JSON.parse stubbed_json_response 2.1.2 :201 &gt; parsed_json.extend(Hashie::Extensions::DeepLocate) 2.1.2 :203 &gt; parsed_json.deep_locate -&gt; (key, value, object) { key == "blog_name" &amp;&amp; value.include?("cat") } =&gt; [{"blog_name"=&gt;"sad-poems-about-cats", "id"=&gt;"39316333303", "type"=&gt;"post", "tags"=&gt;["poem", "poems", {"one"=&gt;"1", "two"=&gt;"2"}]}]
Thanks for the link, that style guide will definitely be useful.
sorry to be a buzzkill but 3 times faster Ruby would still be an order of magnitude slower than fast languages. it won't boost its adoption. I'd love for the short term discussion of Ruby3 to be around concurrency and support for libraries relating to analytics and machine learning. or longer term plans to champion web assembly. 
Will be vs aiming to be. They're quite different things,
That's what they used to say about javascript. And an order of magnitude is a stretch, Ruby is currently just as fast or faster than Python. And is not 30 times slower than Java in most benchmarks. http://benchmarksgame.alioth.debian.org/u64q/ruby.html http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=yarv&amp;lang2=java
If you want 3x faster Ruby today, just use JRuby :-D Seriously though, best of luck to MRI on this goal. We all want to see a faster standard impl.
Thanks for sharing. JRuby continues to impress. I wonder if the Java parts could be even faster when written in Clojure or at least as fast but with prettier code (which Rubyists generally appreciate). Enriching Ruby apps with dabs of Clojure sounds quite appealing.
Thanks for the input!
Thanks alot for writing this up, and sharing your experience. Elixir docs can a little thin sometimes too so I'm definitely used to digging into source code.
I'll check your book out. Yes, on the immutability part, as part of the interview process I walked thier devs and cto through a production SaaS app I wrote in elixir. The processes and concurrent stuff they liked, but I thing they really liked all the elegant recursions you end up seeing in functional programming. I gather that while this is run of the mill in fp, in ruby its a different way to code. Pattern matching is another thing they noted- in elixir it is essentially the elixir way, but idk how much of that can translate to ruby.
There are many apps out there using JRuby and Clojure together, usually via some integration layer like REST or a message bus. Integrating directly should work fine too, but both Ruby and Clojure are a little quirky to call from outside the lang.
Adds `require_glob` and `stub_glob`. These were already in the Sprockets repo as a commented example, but we've used them enough to warrant gemifying them
Would love to know how they packaged it all up for distribution
Ruby can still be very, very productive and useful without being as fast as Go or C or assembly. Since pretty much the dawn of computing we've had different languages for different things. The goal isn't for you to be able to write an operating system kernel in Ruby, or to replace C++. The goal is for Ruby to be a highly productive and expressive language.
Or better yet, actually benchmark and see which one's faster. You might be surprised.
3x may not be that much of a stretch - according to [this article](https://cube3x.com/javascript-performance-since-2008/) javascript performance jumped 10X when Google introduced V8, and has continued to increase since then.
&gt; I'd be interested in hearing more about your deployment progress. Right now I'm using plain LXCs (Linux Containers) on my server. It was what I knew back then. When I finally will deploy that service though (Still a long road ahead), I'm planning on using Docker. Decouples it more from the host system (The LXC stuff is also decoupled, but my scripts may not be?). And quite easy to start *after* you managed to build proper Docker images ;) At work (Which is unrelated to this project, the project in the OP is my personal one) we're building a clustering solution built upon Docker, DockerSwarm and Consul (And a bunch of other tools). With a bit of luck we'll be allowed to OSS it ‚Äì In which case I'd probably use that. (The company is not IT focused and has no prior experience with publishing (F)OS software themselves)
[Citation needed]. Somehow Headius seems a bit more credible when it comes to claims like that..
Maybe you can convince them to let you write Elixir ;) As you suspect, the two things you pointed out (recursion and pattern matching) work much differently (or not at all) in Ruby. Very few imperative languages are optimized for recursion. Each time a function is called the runtime needs to allocate memory to store some bookkeeping information so that it can restore the state of the invoking function. If you recur too deeply then Ruby will raise an exception: SystemStackError: stack level too deep This doesn't mean that you can't use recursion. It just means you have to be more careful and understand the costs involved. Pattern matching is something different. Ruby doesn't have pattern matching, but we can sort-of fake it in a limited context. Clearly the reason Ruby doesn't have pattern matching is because it doesn't have types. Another way of thinking about it is to say that Ruby is unityped. That is, there is a single type in Ruby and all values are instances of that type. (This is rather easy to see in the source code to the Ruby interpreter.) The closest we can come to pattern matching is using a `case` expression to match the subtype of a value: case x when Integer puts("it's a number!") when Array puts("it's an array") # and so on ... end Keeping in mind that the `case` expression de-sugars to something like this: if Integer === x puts("it's a number!") elsif Array === x puts("it's an array") # and so on ... end Which shows more clearly that the fake, very minimal pattern matching is thanks to the `===` operator. (Specifically, the implementation of the operator in the `Class` class.) 
&gt; It might be interesting to see whether a Hash used as a Set performs better; that would tell us how much the Ruby wrapper is costing us. Just tried it, and updated the Gist with the Hash test added. Hash completely blows the other methods away, being even faster than my native Java implementation **on MRI**. Wow. ruby 2.2.3 x86_64-linux Array 5.630000 0.000000 5.630000 ( 5.642463) SortedSet 5.530000 0.000000 5.530000 ( 5.539046) Hash 0.110000 0.000000 0.110000 ( 0.110676) jruby 2.2.2 java Array 1.270000 0.010000 1.280000 ( 1.098917) SortedSet 1.120000 0.000000 1.120000 ( 1.065251) Hash 0.100000 0.000000 0.100000 ( 0.067120) Test machine: * Intel i5 6600K (Skylake), 4x 3.5GHz * 16GiB DDR-4 memory @ 2666 MHz 
V8 was implemented from scratch to be JIT-friendly. MRI has a great deal of baggage to carry along in its current implementation. If it were implemented from scratch, it could easily get to 10x faster...but that might not be feasible in only 5 years of work, and that's not the current plan.
If we're not faster, report an issue. It can probably be fixed.
No problem!
Also see Jerry D'Antonio's excellent RubyConf 2015 talk "Everything You Know About The GIL Is Wrong", which should get posted online by Confreaks very soon.
Totally agree with Confident Ruby...one of the best books I've ever read in terms of how it changed how I program...I think it's applicable to good programming in general, but yeah, if you're new to Ruby but are already a good developer, Confident Ruby might work well as it is mindful of particular Ruby conventions.
+1 this is one of the best in-depth Ruby books out there. It will really teach you how to write good Ruby
The IBM work on J9+ruby seems promising, even without really spending any time optimizing the JIT path or specializations they were able to get a 1.4-2x speed improvement on mri by incorporating the VM toolkit. I can't imagine that if they just attacked low hanging fruit they could get 3x -- and if they actually reworked some of the core to be more jit friendly they could get much much more. 
The IBM work on J9 seems like it could be a great basis for finally killing off GIL -- they have pulled out thead support from jvm into a poly vm that is meant to support just about any language. I am sure it will be a huge lift but with that support it may just become possible to take most of those GIL protections down to a sensible non thread blocking system.
We seem to be missing a good set of macro benchmarks for Ruby (and Rails). We have isrubyfastyet.com, which tries to benchmark simple Rails application but doesn't track JRuby / RBX very well and it's benchmarks could be improved. We have http://jruby.org/bench9000/ which is a set of micro benchmark. I am excited about https://rubybench.org/ and the support for it by RubyTogether.org. @headius, are you guys involved in this effort as well?
Go through the exercises at https://github.com/JoshCheek/ruby-kickstart In two weeks you'll have a great practical understanding of almost all aspects of the language and experience solving frequently encountered patterns with it. This is what got me started. Then you can look into Russ Olsen's eloquent ruby and patterns in ruby book
I think the days of single threaded event loops are numbered, to be honest. They are far too prone to introduce undesirable coupling.
I'd really like to see a rock-solid real-life example of this being the preferred way of doing things.
I mean I could do that, but I need all of it to be with variables the to part, the subject part and the text part because I'm sending 1000+ emails and they're all to different people.
It is doing that.
If your nit-picking which methods you take from a module then clearly you haven't defined your module boundaries well. I can't think of many other use cases for this approach. 
https://gist.github.com/ilovemysillybanana/abc87147d694d03fc08d I posted a gist that will show you more of what I'm talking about, please take a look. EDIT: I just posted the full code, maybe the problem is with my initialize method and I don't know it?
Also: http://www.madebymarket.com/blog/dev/ruby-web-benchmark-report.html
This was the original intent of the feature, and I don't despair that we'll eventually get methods with proper semantics: https://bugs.ruby-lang.org/issues/10984
Now that you know how to do this, please don't.
What is that you're referring to as current plan?
JRuby comes pretty close to Ruby compatibility-wise. There can be some quirks however, like this one [where the ENV variable was slightly different](https://www.fedux.org/articles/2015/07/22/using-env-in-mri-ruby-and-jruby.html). The next thing is that JRuby does not support C extensions. There is a catch however: Gems which use the `ffi` gem to interact with C libraries *do* work fine. Popular gems which require C extensions are `redcarpet` and `hiredis`. Some other gems have JRuby "ports": `Nokogiri` uses some Java XML reader/writer instead of its C extension. Same name, different back-end, works great. Third, you're now in the realm of real multi-threading. Some gems have been adapted to work fine with concurrent access. Most are fine to use as long you only use them from a single thread at once (And you have to make sure yourself you don't otherwise). Many gems tell you their threading behaviour in their README file, so you'll need to check that.
You seem to be immune to help. You have been told by numerous people more knowledgeable about Ruby than yourself that the problem is the scope in which your instance variables are being evaluated.
Thanks for the tip. But I'd rather deploy JRuby with Passenger. ;)
 require 'delegate' class MyString &lt; DelegateClass(String); end Your use case isn't clear to me but the above sample should work
 a = MyString.new "foo" =&gt; "foo" This can be easily done using Ruby's [SimpleDelgator](http://ruby-doc.org/stdlib-2.2.0/libdoc/delegate/rdoc/SimpleDelegator.html). Although, this might feel like cheating too, as the only code you'd have to write is: class MyString &lt; SimpleDelegator; end - a = "bar" =&gt; "bar a =&gt; "bar" This will always work but not how I expect you want it to. You're redefining `a` to be a brand new String object with the value `"bar"`, however you design MyString (even if you use subclassing), a will be a String object. You could do one of the following instead: a.__setobj__ "bar" if you use SimpleDelegator, or a = MyString.new "bar"
So I went back to those old JavaScript programs in the benchmarks game repository and re-ran them with current V8, on the same computer. Improvement V8 1.3.10 (2009) to V8 4.6.0 (2015) 1.3x fasta 1.3x revcomp 2.5x binarytrees 5.6x spectralnorm 6.1x nbody 15.4x fannkuch Improvement TraceMonkey (2008) to V8 4.6.0 (2015) 3.4x revcomp 6.4x partialsums 8.5x fasta 10.0x fannkuch 16.8x recursive 36.7x nsieve 38.2x spectralnorm 52.0x binarytrees 60.6x nbody
You could do basically /u/bendy_chip's answer but without leaning on the SimpleDelegator code. Have an instance variable called "delegate" or something that you set to be the first argument of the initializer. Then, all you need to do is define a method_missing method that just uses `.send` to pass the method off to the delegate. I'm not sure how to get the functionality where a returns "bar"
irb and pry print `"bar"` there because that's what `"bar".inspect` returns.
Ah! So this should work, then, because `.inspect` should pass to the delegate, right?
 MyString = String Constant referencing the orginal class. $ irb irb(main):001:0&gt; MyString = String =&gt; String irb(main):002:0&gt; String.ancestors =&gt; [String, Comparable, Object, Kernel, BasicObject] irb(main):003:0&gt; MyString.ancestors =&gt; [String, Comparable, Object, Kernel, BasicObject] irb(main):005:0&gt; String.instance_methods.length =&gt; 164 irb(main):006:0&gt; MyString.instance_methods.length =&gt; 164 irb(main):007:0&gt; MyString.instance_methods - String.instance_methods =&gt; [] irb(main):008:0&gt; If you then want to add additional methods to MyString, just reopen it class MyString def donkey_kong ... end end Big problem you'll have is you cant overload the = operator. Maybe consider adding methods to just the strings you're interested in, rather than a bulk class. x = "here" def x.donkey_kong ... end x.donkey_kong # does whatever "abc".donkey_kong # NoMethodError
Check out *vedeu*. It's a gui in the terminal with a pretty good api. Puts curses, nwcurses, etc to shame
Worth noting that, although the code for running those benchmarks is open and we can totally go fix it, the Rails implementations could totally be optimized much further. I don't think they're even properly utilizing all of the available cores.
My top three, http://confreaks.tv/videos/rubyconf2015-how-to-stop-hating-your-test-suite http://confreaks.tv/videos/rubyconf2015-how-to-performance and misconceptions about the gil which is not posted yet
Class scopes in Ruby are evaluated line-by-line just like all other scopes. When Ruby runs your first example, it does the `each` loop before it even looks at the `self.attributes` method definition, so how could it be anything but a `NoMethodError`? The reason why it might seem like things aren't chronological otherwise is because Ruby doesn't really look inside a method definition when it evaluates it; it just adds the method. The method body is only run when the method is actually called. So this works fine def self.def_accessors self.attributes.each do |attribute| attr_accessor attribute end end def self.attributes ATTRIBUTES.keys end def_accessors because wrapping the code in a method prevents it from being evaluated until the method is actually called.
I...uh...think you're confused...
You can also take a look at other people's code and try to understand why they wrote it that way. I love [sinatra's code](https://github.com/sinatra/sinatra/blob/master/lib/sinatra/base.rb). It's simple and very "ruby".
There is a part about [autovification](http://best-ruby.com/tricks/autovivification.html) that has an ampersand. Hash.new { |hash, key| hash[key] = Hash.new(&amp;hash.default_proc) } Can anyone explain what thats about? When I try to use an ampersand somewhere else in some code to experiment with it i get an error. EDIT: There is another ampersand on the next page about [blocks taking block](http://best-ruby.com/tricks/blocks-can-take-blocks.html). Are both ampersands doing the same thing?
That looks like a cool framework, but it doesn't really give any info as to where the info is for a start.
Website doesn't even work. I'm disappointed. 
It sounds like you are looking for more design oriented resources. I'm guessing you know the classes/APIs/etc. you need to know, but just want to write higher quality code. With that being said, I'd recommend Eloquent Ruby and Practical Object Oriented Design in Ruby.
I want to know the tricks with moving around the cursor and such. I know about colors and blinking, but what there else is there of things you can do :)
Thanks for this reply, /u/saturnflyer. I just finished reading a few articles on using DelegatClass. My understanding is that using DelegateClass instead of inheritance would allow me to "selectively inherit" through a process of delegating to a String object's methods. Although this may work, it is still borrowing from the String class. The purpose of my question is to further my own understanding of the programming language. I understand that everything in Ruby is an object, and that there are no primitives. However, I cannot seem to mimic the behaviour of the String, such as the example in the code above, without some sort of inheritance (ie without typing the word 'String' somewhere). This leaves me to believe I am either missing something in my knowledge of the language, or have a knowledge gap in how to use the language to create the behaviour I am specifying. 
Thanks for this /u/bendy_chip. You are correct though, using SimpleDelegator really just exposes the methods of the String class to my object. I'm especially interested in whether, for lack of better wording, all classes in Ruby are created equal. Does the String class have behaviours that cannot be defined using Ruby?
This could work, however I'd like to create the behaviour without using a String object in any way. Also, I'm curious how would invoke a `method_missing` method? For example, how could this code be adjusted to work: class MyClass def method_missing puts "foo" end end m = MyClass.new.hello =&gt; "foo" 
What's the output of: `which convert` `which gem` `ls -l /usr/local/lib | grep libMagick` `brew doctor` By the sounds of it, you installed `imagemagick` as root. There is no good reason to ever use `sudo` with either `brew` or `gem`. If you see permission problems don't just throw a `sudo` in front and move on, you'll create more problems than you'll fix.
I think this is answer I was looking for. I simply didn't know you could use `inspect` this way. Are there more "special" method names in Ruby, other than `initialize` and `inspect`? Any idea where I could learn more on this? Also, any idea why `inspect` returns a string with no quotations? Such as: class MyClass attr_accessor :name def inspect @name end end a = Myclass.new a.name = "ChangingHats" a =&gt; ChangingHats &lt;---- No Quotations # Strange behavior: a.name + " is here" =&gt; "ChangingHats is here" a + " is here" =&gt; NoMethodError: undefined method `+' for a:MyClass
Would love to read the blog as well. Could you post a link?
Here's the article I was reading: http://www.saturnflyer.com/blog/jim/2013/03/21/ruby-delegate-rb-secrets/ Jim Gay's whole blog is fuckin awesome though so definitely read it!
Without using the string object in any way, you're probably going to have to basically rewrite the whole class. To be clear, I have absolutely no idea why you'd want to do this. It won't be educational; it'll largely be you copying and pasting classes from Ruby's source or else rewriting all of the string library functions. And, honestly, I'm not sure you can do all that you want to do without using Ruby strings. They're built into the language. As for the `method missing`, it would really be class MyClass def initialize(delegate) # could check if it's a string here @delegate = delegate end def method_missing(name, *args, &amp;block) if @delegate.respond_to?(name) @delegate.send(name, *args, &amp;block) else super end end Now, `Myclass.new.hello` will throw an exception because strings *shouldn't* respond to `.hello`. I think you'd also want to do a handful of other things to make the class less rough around the edges. [This documentation on BasicObject](http://ruby-doc.org/core-2.1.0/BasicObject.html) may be enlightening.
You might want to checkout [the String implementation in Rubinius](https://github.com/rubinius/rubinius/blob/master/kernel/common/string.rb). In MRI, which is probably the ruby you are using, most of the standard library is written in C. Rubinius is another Ruby implementation where the standard library is written in Ruby. Ofcourse, even in Rubinius, String has some behaviour that you cannot replicate in other classes, which is basically the syntactic sugar that converts `"a string"` into a String object. Also, checkout the [Ruby docs](http://ruby-doc.org/core-2.2.3/String.html) if you haven't already.
+1 on http://confreaks.tv/videos/rubyconf2015-how-to-stop-hating-your-test-suite 
While I agree that there's a lack of good how to documentation, I do not like this particular approach. Why teach the Rack like code, then the actual Rack code? The difference is negligible in terms of difficulty - maybe one more sentence explaining the actual Rack code. You might as well save the time and space by teaching the Rack code. I also think it's better to start from the perspective of a basic `app` and work your way out to the middleware, then the other way around. IMO, the tutorials listed on the Rack Github page are better.
The runtime isn't the baggage...it's the thousands of lines of C code using object pointers directly and manipulating object internals directly.
ok. wow. In that case, you need to implement all 113 String methods, if you really mean 'exactly like String' irb(main):005:0&gt; String.instance_methods(false).count =&gt; 113 irb(main):006:0&gt; 
As far as I understand the IBM j9 guys have done a lot of work pulling the jumps back to a real heap but nothing twords dealing with the fiddles.
Without spending a lot of time researching it, I think String is the only way to do certain things in I/O. I think you could re-implement all the operations of MyString as long as you allow yourself to "cheat" by returning a String from `MyString#to_s`. You shouldn't need to call this method anywhere in MyString, just make it available for IO.
&gt;I'm guessing you know the classes/APIs/etc. you need to know, but just want to write higher quality code. I started to read Practical Object Oriented Design in Ruby, but I never finished it. I think I came to it a little too early and if I would get a lot more out of it now. The one thing I remember is it explaining the practical application of dependency injection and encapsulation.
I didn't realize that Thoughbot had come out with an educational program. I will have to check out the Martin Fowler book. I've heard good things. 
Yeah, I read gem code and other open source stuff to look for how other people do things and try to figure out why. The issue is that I was dropped into projects with my first job and only now am I not working on pure legacy code.
Is this from the live-code session at Rubyconf?
Not that I'm aware of, but the author is a speaker at rubyconf, so it wouldn't surprise me.
Can't you do git checkout -b &lt;&lt;branch name&gt;&gt;?
You're right! Thanks for the idea. 
I've been hearing rumblings about Rack 2 but haven't seen anything in a while. I'll have to check that video out.
I don't know if this is real, but it sure is entertaining!
I don't think that's how we'd like to portray "hackers". Think twice before sharing/upvoting this. This is just rude and offensive. I also feel sorry for his wife.
 GMAIL_PASSWORD=password Now *that* is a great idea for things to store in environment variables in the cloud. ;)
Yes, having `git remote` in, but not `git log` or `git diff` seems really strange. `rebase` and `stash` are also useful, but `log` and `diff` are essential to see what you are actually doing.
Thanks for this. To answer your question, I'm not trying to override any `inspect` method, or avoid using inheritance in my code base. The question I asked was motivated by a knowledge gap I experienced recently when using `dup` and `clone`. After that, I realized there were components of the String class I didn't understand which motivated this question. I'm aspiring to be a great developer, but still have much to learn. Diving into the documentation of the basic Ruby classes was clearly something I needed to do. 
I would have been well served to make more clear that it's only the behaviours described in the question stem that I'm looking to replicate, not necessarily all 113 instance methods. These were the ones I was struggling to replicate.
It's not a common practice for something that potentially provides account recovery access to everything in your digital life. That was my point.
As long as you don't check them into source control, which this thing is *not* advocating, I don't see any problem with it. Do you have a better solution? Simply storing the environment variables outside the repository, e.g. in `~/.bashrc`?
I assume you mean ["Everything you know about the GIL is wrong"](http://confreaks.tv/videos/rubyconf2015-everything-you-know-about-the-gil-is-wrong), which is online now.
It would probably be good for the repo to have a .gitignore included that's already ignoring .env, to protect against accidental committing.
hey at least you admit it! 
I think everybody knows a Kumar. Although the code there doesn't actually do the database rollback it describes.
Also watch sandi's talks
awesome, ty
The way we've been using mocks in Ruby is *still wrong*. RSpec's verified doubles is an improvement but it still couples your tests to specific dependencies rather than making it possible to rely on abstractions. The first mistake we make is that we still tend to mock what we don't own. The second mistake that we still do is that even if we mock what we own, we still have no way to properly verify if the mocked interfaces are actually being tested against the real dependency. Bogus comes very close to this with its contract tests but it hasn't gained much adoption, unfortunately. My personal bet is on the usage of ioc/di containers which makes managing dependencies very explicit. It comes with great benefits like being able to track what is being mocked in the tests and simplify implementation of contract testing. I'd love to experiment with an rspec plugin that would introduce mocking API that works with a container-based setup so that we can get *real* confidence and still be able to easily mock dependencies in unit tests. Personally I've been burned by extensive usage of mocks so many times (including verified doubles, due to test&lt;=&gt;dependency coupling, which makes test maintenance a bigger burden than it should be) that I avoid using mocks completely with the exception of dependencies that perform heavy operations (talking to dbs extensively, http apis, etc.).
Its rude and offensive to you. Remember that offence is taken not given. What is rude and offensive to you might not be rude and offensive to me or anyone else for that matter. Its all a matter of upbringing, cultural background and other factors. 
Your comment actually hints at exactly the kind of design problems that plague ruby test suites today. None of the ruby HTTP libraries I've seen allow you to control the underlying connection sufficiently to test HTTP gateways without mocking libraries. I eventually took to writing my own for exactly this reason (not ready for prime time). Now, I don't use webmock or any of those elaborate tools. When I want to test what I sent over the wire, I pass in a `StringIO` substitute and assert on the string inside of it. Objects should never "know" they are being tested. Test suites should never alter the object space around an object to make it testable.
Hear, hear. When the ruby community (specifically rspec, but not limited to it) ran head first against the common design problems surfaced by automated testing, they had a choice. They could improve the design of their test subject, or they could build elaborate tooling designed to shift the gravitational constant of the universe around their stubborn test subject. They chose the latter, sadly.
You're missing the point. I'm an open-minded, tolerant person who doesn't take things personally even when something is offensive from my pov. The way this "true story" is being shared everywhere with great excitement how funny and awesome it is while missing the fact it represents the exact hacker stereotype that so many people are trying to fight with is just sad. OK, he hacked coffee-machine, that's cool, but it doesn't really matter in the context of scripts named using offensive language (*at work*). This is not contributing to the way people perceive hackers in any positive way. It only solidifies the hacker stereotype of *a dude* hacking stuff in his basement, who disrespects his wife, co-workers and basically not giving a damn because all that matters is being smart in his vim. Spend some time trying to understand this.
This is really great and well explain. It needs a bit of proofreading, though. Good job!
Thank you for your feedback. I definitely agree that the official Rails Asset Guide still worth to take a look. So i already added it in further reading section. Thank for pointing out.
I voted on twitter but for the reddit record - Jekyll.
Yes, it does. If you replace rspec with minitest, fix or even r_spec, you'll see that "üí©" is no longer equal to 42. I would say _just don't use rspec if the code to be tested is monkeypatching some core methods_.
He also talks about how every other "major" language has a niche. Javascript is king of the browser, Java is the Android language, and Python seems to be the language for robotics and the go-to language for utility scripts to accompany big projects. He made it seem like ruby is only used for web. Not my opinion, just what it sounded like.
No need to do trial-and-error. There are formulas for that. But this particular situation kind of turns the standard equations on their heads. If you assume the "random" numbers in the array will be unique, then the probability of a random array being sorted is 1/n!, where n is the size of the array. (This is derived from the formula for permutations without repetition. Permutations rather than combinations because order is significant.) So for example, for a 20-element array the probability is a very small number: approximately 4.11 x 10^-19 Here's the thing. Normally, the number of permutations without repetition would be n! / (n-r)!, where n is the size of the array, and r is the number of elements you select from it. But since you are using the **whole** array, r = n, and the equation is reduced to n! / 1! = n! That's total permutations. Since the sorted order is just one of them, the probability is 1/n! If your "random" array can contain repeated numbers, the situation changes. Let's say you have an array A = [1, 2, 3, 4]. Obviously this will sort only one way out of the 24 (i.e., n!) possibilities. But what if the array is [1, 2, 2, 3] ?? There are 2 different ways to sort it. So this brings in the equation that would normally be used for "select r elements from n choices": n! / (n-r)! but in this case r is the number of duplicates. In the above example, that's 2. So n = 4, r = 2, yielding 4! / (4-2)! = 12. There are 24 possible combinations, and the probability of the array being sorted is 2 out of that = 2/24 = 1/12. So if the integers in the array are not unique, the equation for the **probability** of the array being sorted is: 1 / ( n! / (n-r)! ), where n is the array size and r is the number of duplicates. Exercise: [1, 2, 2, 2, 3] n = 5 r = 3 1 / ( 5! / (5 - 3)! ) = 1 / ( 120 / 2) = 1 / 60.
cool! thanks for all that :-) I barely remember combinatorics :-(
chuckles. yes...login!=user...its been a long day. thank you.
Probably the most confusing name ever given to a project. The thing doesn't even concern itself with read-only memory.
Probably because I haven't heard of this gem yet. Thanks for the link. 
Nor range of motion, nor risk of mortality, nor a Swiss river, nor the Ferengi Alliance. Your point? &amp;lt;/snark&gt; &amp;#x1f609;
^ patiently waiting...
require_relative doesn't need './' at the start of the path.
See https://github.com/datacentred/deliverhq for an example, specifically: https://github.com/datacentred/deliverhq/blob/master/lib/deliverhq.rb
The problem is almost certainly the upper-case file names. Windows' file system is case insensitive, so it's able to find the files even though you require them with lower-case. Linux, by default, has a car-sensitive file system, so "popcorn" and "Popcorn" are actually two separate paths. Like another commenter said, going all-lowercase is probably the safest bet. I don't think I work in any projects that have upper-case letters in any file name. 
Quietly ignoring things like "smack-my-bitch-up.sh" because "lol cool hacks" is exactly what's wrong with this industry.
I had a look at how I do it in my gems, I've never used `spec.load_paths`, but instead use `spec.require_paths`. I usually have a stanza like this: gem.require_paths = %w[lib] gem.files = `git ls-files -z`.split("\x0") gem.executables = gem.files.grep(%r{^bin/}) { |f| File.basename(f) } gem.test_files = gem.files.grep(%r{^spec/}) gem.extra_rdoc_files = %w[README.md] * add `lib` to `$LOAD_PATH` so you can `require` files from it * make sure everything that is tracked by git is added to the final gem * list everything in `bin` as executable so Rubygems will make binstubs * tell rubygems which are my test files. Not sure what this does actually, I guess it's just metadata * make sure that when generating RDoc for the lib, it also includes the README Your `Gemfile` should look like this source "https://rubygems.org" gemspec Now in your tests you can require 'tomato' and provided that you run your tests with `bundle exec`, it will be able to find that `tomato.rb` looked up in `lib`. From `tomato.rb` you would load the other files require 'tomato/Popcorn' although as pointed out it's recommended to just stick to lowercase. Most gems use snake case file names (define `NodeBuilder` in `node_builder.rb`), which I would recommend. Ruby standard lib has the convention to leave out the underscores, so `SecureRandom` goes in `securerandom.rb`. While on the topic of Gem layout, what I typically have in `tomato.rb` will look like this # load stdlib stuff require 'stringio' require 'securerandom' # load gems require 'nokogiri' # setup main namespace module Tomato # not usually a lot here, maybe a class method as main entry points, or some constants end # require the rest of your lib in the right order require 'tomato/foo' require 'tomato/bar' 
YUP :D Still just taken. Because my response would be in line of something like [from THE DUDE himself.](https://www.youtube.com/watch?v=pWdd6_ZxX8c)
[Sorry it might be a bit late but Steve Hughes explains this exactly as I see the world.](https://www.youtube.com/watch?v=fHMoDt3nSHs&amp;t=3m23s)
Where does the FeatureToggle instance live? Since it doesn't persist to the DB, this won't work for any Rails apps that are configured to run as multiple processes on a single server, or any load-balanced app across multiple servers. You might want to add a helper function so this can be used in views, too. I get that this is supposed to be simple, but it seems overly simplistic for many use cases.
You can greatly improve speed by not sorting arrays and comparing them to sources, but by checking if array elements are in order and abort as soon as you find first element not in order. `Array.sort` uses Quick sort algorithm with is O(n log(n)) on average. While checking array "sortedness" would be O(n/2) on average. Your script (without output) on my machine takes about 6.353s to finish. num_sorted = 0 num_total = 1000000 num_elements = 10 max_random_integer = num_elements num_total.times do |i| array = Array.new(num_elements){ rand(max_random_integer) } if array == array.sort num_sorted += 1 end end Compare with modified version: num_sorted = 0 num_total = 1000000 num_elements = 10 max_random_integer = num_elements def sorted?(array) 0.upto(array.length - 2) do |i| if array[i] &gt; array[i + 1] return false end end true end num_total.times do |i| array = Array.new(num_elements){ rand(max_random_integer) } if sorted? array num_sorted += 1 end end Which takes 4.749s. That's ~25% speed up. The difference is only going to increase with the increase of the sampled array. For example if you flip dimensions (10 iterations for 1m-element arrays) I get 5.507s for sorting version and 2.960s for checking version. That's over 46% speed up.
Elixir is left out again :-((
FYI: Thanks for voting (24 hours). The results (32 votes): - #1 Jekyll - 53% - #2 Middleman - 41% - #3 Nanoc - 3% - Other - 3% 
There is no reason to use `require_relative` here. Use the $LOAD_PATH as ruby intended. In a gem, `lib` is automatically on the load path, and the OP lays out the structure of files the way `require` expects inside `lib`. Just use `require` here, don't switch to `require_relative`. I think the problem is likely the uppercase names, as others have suggested. 
 File.open("my/file/path", "r").each_line do |line| Etc.
Here's what I came up with. It's a little obfuscated, but I feel it's more Ruby-like because it takes advantage of functional operations like `#gsub`. It only works for ASCII strings, and converts all characters to lowercase. def caesar_cipher(string, key) string.downcase.gsub(/[a-z]/) { |m| ((m.ord - 'a'.ord + key) % 26 + 'a'.ord).chr } end s = 'hello, world' puts caesar_cipher(s, 1) # =&gt; ifmmp, xpsme puts caesar_cipher(s, 26) # =&gt; hello, world What it does is use `String#gsub` to do a regular expression pattern match on characters a-z. Then it passes each match `m` into the block, where it does a little math to basically increment the character's ASCII value, modulo 26, by the `key` value. `String#ord` is used to get the ASCII value, and `String#chr` turns that integer back into a single-character string.
Thanks! The reason I was asking is that I quite dislike the fairly common notion in Rails projects to swap out simple yet opinionated parts with complex non-standard parts. I'm glad to hear that Lotus, by default chooses the (MHO) simplest, leanest and easiest to understand testing infra. Rspec is really nice, I use it often, but if I have to debug that one `let(:user) {}` which somehow, when run through spring, using mocka, extending shoulda, running through guard, monkeypatching Object, fails to be reloaded after each test,I am lost. In those cases I am really happy to simply read the 300+ lines of Ruby that minitest is, and apply my ruby knowledge to fix the issue. Rather then wading through several layers of abststraction and poorly documented DSLs /rant.
I'm not 100% on this, but I don't think sort_by modifies the object that calls it. It's like doing a = 2 a + 2 And expecting a to hold the value 4. There might be more problems in your code though, bit of a hurry.
Thanks for the great answers! I guess there's a long way ahead of me with learning Ruby as I don't think I would come up with any of those solutions at the moment.
Yup, should work.
Nothing to do with Hashes, but the ruby way to split strings into n-length substrings: string = "candidate" n = 4 string.split("").each_cons(n) do |substring_array| substring = substring_array.join("") #do something with substring end
IMO, you're giving yourself a red herring. Quick question before I give a longer reply: what's the final output? Everything into a two-column csv file?
I think a text file would be fine, csv would be nicer, but anything that allows the 'sequences' and 'words' columns to be two separate columns and also that the proper 4-letter sequence corresponds to the word it came from.
By correspond I simply mean "on the same line".
If it were me doing this, I'd use a hash of arrays with the keys being the original word and the value array as an array of each 4 letter part. 
This is pretty cool. I tried it, but what if I wanted to create one array from the elements from "substring"? I'm feeding a file into my code that's basically a column of thousands of words, which would be the "candidate" part of your code. But then when I feed that file through your code, it still creates thousands of individual arrays rather than one array with thousands of elements.
 def get_four_letter_sequences word word = word.dup # preserve original word string, which we'll need later sequences = [] while word.length &gt; 3 # now you'll see why we wanted to preserve the original word. four_letter_seq = word[0..3] sequences &lt;&lt; four_letter_seq word = word[1..-1] end return sequences end def format_output sequence, word "\"#{ sequence }\",\"#{ word }\"" end File.open "output.csv", "w" do |csv_file| File.readlines("testdict").each do |line| word = line.strip # remove trailing newline character (all trailing whitespace, actually) get_four_letter_sequences(word) .each do |seq| csv_file.puts format_output seq, word end end end
You don't need to sort! That was the red herring. I don't usually provide whole solutions, but I couldn't think of a way to socratic-dialogue this one, so please ask any question you can think of, no matter how trivial. I intentionally wrote the code a little differently than you might expect. Try it out! It does work.
Interesting, but the single `&amp;` may confuse some for bitwise functions, _or_ they will still try `&amp;&amp;`. However, I'm interested and like the overall DSL
If you start with the big, huge search space, you save steps but not time. This will be more apparent if you break things out further. Tbh, I don't think you need the Pal class. Item #1 would be a function which defines the search space. def search_space factor_length #stuff end I think if you try a few different implementations of that function, you'll see what I mean. All of encryption is based in the fact that finding a number's factors is harder than producing a number given factors.
Why not? The caesar cipher takes an arbitrary alphabet. ROT13 would require rotating the capitals and lower case separately but that is a special case of the caesar cipher.
Because it's cheating, that's why. Jeez.
Fine: def cipher(text, val = 13, alphabet = [[*'A'..'Z'], [*'a'..'z']]) text.tr alphabet.map(&amp;:join).join, alphabet.flat_map { |s| s.rotate(val) }.join end
You could do something like: larger_array = [] File.open("filename.txt").each_line do |line| string = line.strip larger_array = [] n = 4 string.split("").each_cons(n) do |substring_array| substring = substring_array.join("") larger_array &lt;&lt; [string,substring] end end
Please don't use tabs when spacing. If that's not the case, make sure your editor auto spacing is set to 2 and not 4. 
It sounds like your trying to build an n-gram index. You can do this easily like so: words = [&lt;your input of words&gt;] ngram_index = Hash.new { |hash,k| hash[k] = [] } words.each do |word| word.chomp.chars.each_cons(4) { |ngram| ngram_index[ngram.join] &lt;&lt; word } end `ngram_index` will look something like this: { "hell" =&gt; ['hello'], "ello" =&gt; ['hello', 'jello'], "worl" =&gt; ['world', 'worlam'], ... } If you want it printed as two columns, sorted by the ngram: ngram_index.sort.each do |ngram, words| words.each { |word| puts "#{ngram}, #{word}" } end Which outputs something like: ello, hello ello, jello hell, hello worl, world worl, worlam ... 
https://github.com/Andrewsh86/largest_palindrome/tree/computes_factors_first I took your idea and ran with it. It now only defines the search space for numbers that have valid factors. Unfortunately, this implementation is even slower. I'm getting killed by the combination method and subsequently the map method. Any ideas?
&gt; assessments = [assessments(:good), assessments(:bad)] &gt; ... &gt; assert_equals 46, assessments(:good).reload.score What the hell kind of object/method is assessments? You might want to 1. stop writing overly clever code like that 2. stop including clever code in examples of other structures 3. not have magic numbers in your tests.* *:where does the number 46 come from? is 47 really an error? Tests should be self-explanatory as to what they test. They don't need to explain how the tested functionality works, but they should really explain what the tested functionality is supposed to do. Why is the score supposed to be exactly 46 in this test case? the test setup explains nothing. Other than this nitpicking though, your ideas about jobs and testing them are good. :) 
There it is a real world example: `Lotus::Utils::String`. https://github.com/lotus/utils/blob/master/lib/lotus/utils/string.rb https://github.com/lotus/utils/blob/master/test/string_test.rb
Thanks for the feedback. The assessments method is supplied by Rails as an accessor for fixture data, and this is a pretty standard use case. As for the overall code snippet, you're right that there's a lot of context missing, but as it was taken from a much larger file in a real application, I had to cut lines from somewhere. It just wouldn't have been reasonable to include everything in a blog post.
One improvement you could make is to only generate palindromes rather than creating a huge list and checking if a number in the list is a palindrome. So how would you do that? (1...10).map { |x| " 0123456789".split('').map {|y| "#{x}#{y.strip}#{x.to_s.reverse}".to_i } }.flatten =&gt; [11, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 22, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 33, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 44, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 55, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 66, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 77, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 88, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 99, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999] and a quick sort: (1...10).map { |x| " 0123456789".split('').map {|y| "#{x}#{y.strip}#{x.to_s.reverse}".to_i } }.flatten.sort =&gt; [11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999] The inner " 0123456789".split is required to generate odd length palindromes. I'm pretty sure this generates them all... 
This was an approach I was going to try, but I was going to do it a bit differently. I'll check this out.
Great read! /r/dataisbeautiful
I want to make his laugh my ringtone. 
Would you still use "instance_double", when the "verify_partial_doubles" option is enabled? https://relishapp.com/rspec/rspec-mocks/docs/verifying-doubles/partial-doubles
because the contents of `test` are interpolated at the point `sample` is defined. Pretty obvious, really?
Okay I think I have wrapped my head around it, what I should be doing is; test = "once" def sample puts test end sample test = "twice" sample &gt;&gt; once &gt;&gt; twice
So this is what I had / was doing; @board = " #{@position_values[:a1]} | #{@position_values[:b1]} | #{@position_values[:c1]} --+---+-- #{@position_values[:a2]} | #{@position_values[:b2]} | #{@position_values[:c2]} --+---+-- #{@position_values[:a3]} | #{@position_values[:b3]} | #{@position_values[:c3]}\n\n" This was a Tic Tac Toe board, and I wanted to be able to update the `@position_values` Hash and even when I updated the Hash and tried to print `@board` I was getting a blank board. [This is where I am now with the whole thing.](https://github.com/diarmuid-murphy/tic-tac-toe/blob/master/tic_tac_toe.rb)
Instead of `shuffle`, which only works on arrays, you can also use `Enumerable#sort_by` (on any `Enumerable`, including sets, ActiveRecord relations, or even your own iterable collection types) with a block that returns a random number: (1..10).sort_by { SecureRandom.random_number } # =&gt; [2, 7, 9, 1, 10, 4, 3, 8, 5, 6] _Edit: Fixed code formatting_
Thank you. The problem with using `Enumerable#sort_by` with a non-deterministic sort function, I think, is that gives less of a random distribution than what `Array#shuffle`, which uses the Fisher-Yates algorithm, should. Here's what I'm going off: http://www.robweir.com/blog/2010/02/microsoft-random-browser-ballot.html
Actually, an unstable sort (MRI's sorting is unstable, although the Ruby spec does not define whether or not it should be) is desired when doing shuffling this way, because tiebreakers could sort the slots that got assigned the same value differently each time. Fisher-Yates is more efficient, though.
In our case, toggles are defined in an initializer, so you got instance of FeatureToggle per application instance, with the same data and available via FT constant. No need to create any helper functions to use it in the views, since it's assigned to constant as /u/dmke already said. You said that it's &gt; overly simplistic for many use cases. However, it's good enough for multi million dollar business, so I will keep it.
Thank you. I'm actually not sure why I wrote "well known validation solutions" instead of pointing directly to `ActiveModel::Validations`, because that's what I had in mind. FWIW Reform may use `dry-validation` soon, but it's a secret so don't tell anybody.
You could just use the securerandom-array if you want to have it: https://libraries.io/rubygems/securerandom-array no need to reinvent everything :)
That doesn't work either (as you've probably discovered by now), test will not be in scope in the sample method. If you want to do something like your original idea then you could do it by making sample a block. (you'd still have to call it each time by `.()`, `[]` or `.call` or something like it) test = "once" sample = proc { "#{test}" } puts sample[] test = "twice" puts sample[] &gt;&gt; once &gt;&gt; twice It's probably not a good idea though, making it a method with a parameter like /u/amalagg is going to result in cleaner and easier to understand code in the long term.
Extend &amp; Include in **2 words**. Yeah... And I think this teaches using oversimplified examples instead of highlighting the actual, not so complicated, differences.
You can generally assume unless something is called "SecureRandom" or better yet CSPRNGRandom, it probably isn't. PHP's [rand_mt](http://php.net/manual/en/function.mt-rand.php) is a well known source of repeated vulnerabilities, despite the somewhat humorous description of the function on the PHP website linked. I'm going to assume it's as secure as the [Random class](http://ruby-doc.org/core-2.2.0/Random.html), which is a completely deterministic Mersenne Twister. 
Replace h = Hash[sequence_array.zip candidate_array] h.sort_by { |k, v| k } With h = Hash[sequence_array.zip(candidate_array).sort_by { |k,v| k } ] For example &gt;&gt;&gt; sequence_array = %w{ t h e q u i c k b r o w n f x j m p d v l a z y g } =&gt; ["t", "h", "e", "q", "u", "i", "c", "k", "b", "r", "o", "w", "n", "f", "x", "j", "m", "p", "d", "v", "l", "a", "z", "y", "g"] &gt;&gt;&gt; Hash[ sequence_array.zip(0..25) ] =&gt; {"t"=&gt;0, "h"=&gt;1, "e"=&gt;2, "q"=&gt;3, "u"=&gt;4, "i"=&gt;5, "c"=&gt;6, "k"=&gt;7, "b"=&gt;8, "r"=&gt;9, "o"=&gt;10, "w"=&gt;11, "n"=&gt;12, "f"=&gt;13, "x"=&gt;14, "j"=&gt;15, "m"=&gt;16, "p"=&gt;17, "d"=&gt;18, "v"=&gt;19, "l"=&gt;20, "a"=&gt;21, "z"=&gt;22, "y"=&gt;23, "g"=&gt;24} &gt;&gt;&gt; Hash[ sequence_array.zip(0..25).sort_by { |k,v| k } ] =&gt; {"a"=&gt;21, "b"=&gt;8, "c"=&gt;6, "d"=&gt;18, "e"=&gt;2, "f"=&gt;13, "g"=&gt;24, "h"=&gt;1, "i"=&gt;5, "j"=&gt;15, "k"=&gt;7, "l"=&gt;20, "m"=&gt;16, "n"=&gt;12, "o"=&gt;10, "p"=&gt;17, "q"=&gt;3, "r"=&gt;9, "t"=&gt;0, "u"=&gt;4, "v"=&gt;19, "w"=&gt;11, "x"=&gt;14, "y"=&gt;23, "z"=&gt;22} 
Thanks :)
TIL. Thanks!
The way the question is phrased: "if it is necessary to be able to learn algorithms and data structures to be a good ruby programmer." Yes, you should "be able to learn" algorithms and data structures. If you are learning Ruby on Rails, you benefit from the framework and standard Ruby libraries. They provide data structures and algorithms for you. You don't need to understand how the Hash and Array work to use them. But it would behoove you to eventually understand them. Same with Array#sort. You don't need to understand how the sort algorithm works now, but eventually you should try to understand it. Don't take advice from people who say "Algorithms and Data Structures are only for other languages". That is completely false. Also, efficiency always matters. Rails is a great way to get started. You can quickly prototype CRUD web applications. But eventually, you'll want to solve more difficult problems. Understanding how common algorithms and data structures will provide a basis for you. Lastly, most technical interviews include an algorithm question. To help prepare, I recommend you get a copy of Cracking the Coding Interview by Gayle Laakmann McDowell 
Ruby is optimized for easy of development, but at some level you'll always care about efficiency -- number of network round trips or SQL queries, for instance, often matter even when you're not counting CPU cycles. You'll need to understand algorithms and data structures even when optimizing at that level, because you can easily wind up with O(n^2) network round trips instead of O(n^2) cycles when using REST calls. And even in Ruby, you care about that. There's a difference between "Ruby burns a lot of RAM and CPU" (true) and "you don't care about performance" (false.)
"completely random" is a tricky concept. what's even trickier is, to create random numbers with deterministic algorithms. If you want to know more about it, I'd start with reading the wikipedia article for Randomness. .sample and .shuffle have a degree of randomness. But they use something called a PRNG: Pseudo random number generator. disclosure5 mentions a CSPRNG, which is a: Cryptographically secure pseudo random number generator. Both are not truly random. But few applications really need it. If you want to pick 1 in 5 people to wash the dishes, .sample is fine. If you want to pick 1 in 5 people to wash the dishes a gazillion times per day and let people bet on the outcome, .sample is not fine - people will find a predictable component, which is enough to beat the odds with betting and use it against you. securerandom-arrays .sample is probably fine for that though. If you want to pull this off even 200 years in the future where massive quantum-calculation are a dime a dozen, you probably want to find a truly secure random number. btw: There are actual hardware devices out there that generate random numbers based on physical observations of a piece of the analogue world. I still don't get why not every computer has one of those built in right from the start.
This is so cool. I'm trying to figure it out what's going on... I think my biggest question is how does the final output print the 4-letter-extracted word alongside the original word? I'm trying to understand how the original word moves through this code, or just rather, how it gets to the end, printed next to the extracted word. Also, I tried running it, but it does need to be sorted apparently? I'm trying to sort the 4-letter words.
I'm glad you like it. I've think I've made the main decisions right, but I'm not personally using it in production yet (I wanted to use it in an app that I was working on, but the app's been currently put on hold), so I think Shrine is still going to need some live testing. However, Shrine is much more powerful, flexible and secure than other solutions, and if you care about good UX (which is ultimately our goal as developers) I would highly recommend Shrine. And Shrine is currently much better maintained than some solutions (e.g. CarrierWave's maintainers sometimes close issues which haven't been resolved, simply because no PR has been made). I wrote guides on the website that should make it easier for Paperclip and CarrierWave users to switch.
Okay I think I understand everything you just explained. I'm clear on the path the 4-letter-sequences take, from the moment the original word is inputted, to the point it's printed. What's nebulous to me is how the original word finds its way into the csv file, and I guess more broadly, the path of the original word from the moment it's inputted all the way to the moment it's printed at the end. I think I have a decent understanding of most of the code; I can trace things backward and see how things are connected. But I can't seem to do that for the original word, and how it makes it to the end.
A single ampersand in this context is the bitwise AND operation. If you convert a couple example numbers to binary and then perform the operation by hand, you will see why n &amp; (n -1) == 0 if and only if n is an even power of two. EDIT: A worked example: 8 is a power of two, and is represented as 1000 in binary. 1000 - 1 = 0111 in binary. 1000 &amp; 0111 = 0000. 9 is not a power of two, and is represented as 1001 in binary. 1001 - 1 = 1000 1001 &amp; 1000 = 1000, not 0000
Alright, let's treat the things we need to fix as a second problem. This will actually turn out to be a great learning opportunity. You see how I split things up in my code? I'm employing an idea called Divide &amp; Conquer. Every programmer divides and conquers. There's not a right or wrong way to do it; it's just an idea: break problems into smaller problems. We're not going to touch the code above. Instead, we are going to call my code the first half of the solution. Your code is going to be the second half. Things you will need to do: 1. Read output.csv into an array of lines called `pairs`. 2. Transform each line into a pair of strings, where each string is just the word and not the quotation marks or comma or newline character. Each pair will be an array of size two. We'll pause here then talk through the rest of it. Cool?
Thinking of problems in terms of data structures and transformations is the yellow brick road. Ruby is just a language and toolset to accomplish those tasks. 
I learned most of what I need to know from MIT's open course "Introduction to Algorithms and Data Structures" on Youtube: https://www.youtube.com/watch?v=HtSuA80QTyo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=1 They do examples in Python, but they explain everything in English. You should be able to follow along. And if you have trouble, you can ask me any question you'd like.
Here we go: File.readlines("output.csv").each do |line| pairs = [] line_pairs = line.strip pairs &lt;&lt; line_pairs puts pairs end I think I satisifed #1, but #2 I'm at a loss. I tried chomp, strip (like you did in the original code), and other things I googled and found in stackoverflow, but nothing works. Thoughts?
&gt; I still don't get why not every computer has one of those built in right from the start. Intel in fact does ship the RDRAND register for precisely this purpose. The problem there is trusting them. "Built into the computer" equates to "a great place for a backdoor", and the whole mess around the Linux kernel team refusing Intel's push to solely use RDRAND is a testament to the fact that this is a hard problem. 
40% off 30 is $18, which is less than 24.95
Hold your horses! After step 1, pairs should be of length 100,000 (or whatever). Step 1 is not yet compete. 
Hm so let me understand clearly. For step 1, I'm getting a bunch of 1-element arrays, but you want me to produce only 1 array, with a really element in it? And that element be the contents of output.csv?
Ok got it! One big ass 1-element array. Now to figure out how to trim the fat... f = File.read("output.csv") pairs = [] pairs &lt;&lt; f print pairs
Hm I might not be understanding then, but this is `pairs`: `["\"haha\",\"haha\"\n\"anal\",\"analogous\"\n\"nalo\",\"analogous\"\n\"alog\",\"analogous\"\n\"logo\",\"analogous\"\n\"ogou\",\"analogous\"\n\"gous\",\"analogous\"\n\"exam\",\"example\"\n\"xamp\",\"example\"\n\"ampl\",\"example\"\n\"mple\",\"example\"\n\"peri\",\"peripheral\"\n\"erip\",\"peripheral\"\n\"riph\",\"peripheral\"\n\"iphe\",\"peripheral\"\n\"pher\",\"peripheral\"\n\"hera\",\"peripheral\"\n\"eral\",\"peripheral\"\n\"Zygo\",\"Zygote\"\n\"ygot\",\"Zygote\"\n\"gote\",\"Zygote\"\n"]` Just one array with a bunch of elements right?
I don't know why it displayed that way; here's a [screenshot](http://imgur.com/cIGTvL3)
That looks like an array containing a single string to me. Check it with #count.
Is there a way to separate the {{}} sections but skip over the {{TCG|Confused}} ect? If I can get that to work then regex the rest will be a snap.
https://github.com/nricciar/wikicloth
Give a try to my [Infoboxer](https://github.com/molybdenum-99/infoboxer) -- it seems to do exactly what you are looking for: require 'infoboxer' wiki = Infoboxer.wiki('http://bulbapedia.bulbagarden.net/w/api.php') page = wiki.get('Alakazam_(Base_Set_1)') page.templates(name: /Infobox/).count # =&gt; 6 page.templates(name: /Infobox/).map(&amp;:name) # =&gt; ["Pok√©moncardInfobox", "Pok√©moncardInfobox/Expansion", "Pok√©moncardInfobox/Expansion", "Pok√©moncardInfobox/Expansion", "Pok√©moncardInfobox/Expansion", "Pok√©moncardInfobox/Footer"] infobox = page.templates(name: /Infobox/).first infobox.variables # =&gt; [#&lt;Var(cardname): Alakazam&gt;, #&lt;Var(jname): „Éï„Éº„Éá„Ç£„É≥&gt;, #&lt;Var(jtrans): Foodin&gt;, #&lt;Var(image): AlakazamBaseSet1.jpg&gt;, #&lt;Var(caption): Illus. Ken Sugimori&gt;, ...10 more nodes] infobox.variables.map{|v| v.name, v.text} # =&gt; [["cardname", "Alakazam"], ["jname", "„Éï„Éº„Éá„Ç£„É≥"], ["jtrans", "Foodin"], ["image", "AlakazamBaseSet1.jpg"], ["caption", "Illus. Ken Sugimori"], ["species", "Alakazam"], ["evostage", "Stage 2"], ["evoicon", "064"], ["evospecies", "Kadabra"], ["evoname", "Kadabra"], ["type", "Psychic"], ["level", "42"], ["hp", "80"], ["weakness", "Psychic"], ["retreatcost", "3"]] 
Thanks, just bought it :)
Sorry. I'm confused about your question ;-) Can you rephrase? The WIKI_LINK_PATTERN is a regex to split/parse the string. You will get the link and an optional title. WIKI_LINK_PATTERN = %q{ \[\[ (?&lt;link&gt;[^|\]]+) # everything but pipe (|) or bracket (]) (?: \| (?&lt;title&gt;[^\]]+) )? # optional wiki link title \]\] } **Update** I checked your wiki text sample - there are not many "classic" wiki links. Looks like you need something for parsing an infobox. 
When is doing that useful?
It uses `Random::rand` by default, which uses a Mersenne Twister to generate pseudo-random values.
Interesting... that makes sense about the flags. Thanks for explaining!
If you want to make web apps you have to realize something I didn't in the beginning: learning ruby it's only the first step on a VERY long journey. You won't feel like you've "figured it out"for a long time, that's fine! You'll need to Google syntax and other issues for as long as you program. Programming isn't about a single language, framework, or paradigm. Keep at it.
Thanks for a very good answer! &amp;nbsp; But do you have any tips on how I can stay motivated to keep learning?
Programming Ruby, by Dave Thomas and Chad Fowler. Found here: https://pragprog.com/ You can get a .pdf pretty cheap and instantly, and a print book at a reasonable rate: the combo rate is the best. Each concept is worked in small steps. It's considered by many to be the "Ruby bible". AFTER you've done the Ruby book (which has an excellent separate reference section, by the way), then you might want to try Agile Web Development with Rails, by Sam Ruby, Dave Thomas, and David Heinemeier Hansson (the originator of Rails). Available from the same source. The book is authoritative and kept up-to-date. In roughly the same style as the other book, with an excellent reference section in the back. There are other sources, but I don't think any beat these. They're how most of the world learns Ruby and then Rails. But do yourself a favor, and learn them in that order. And YES.
Does the books contain any kind of tasks so you can see a output of your work and get some practical experience? If else, I don't this the book would work for me. 
In computer programming, as in many endeavors, there are periods where you progress rapidly, and periods where it feels like nothing you do is right, and you will never learn. It takes time, and you just have to keep plugging away. Try to not be discouraged. If it is so difficult that it almost hurts, then you need to take a break, and slow things down. When you come back to it, hours, days or even up to a week or two later, you may be amazed that things that were very difficult might suddenly "just work." If you can learn to learn at your own pace, with your own motivation, then there is nothing in life you can't tackle. Ruby is well within your reach.
Hello Sprawn! &amp;nbsp; Thanks for an very good motivational post! &amp;nbsp; I see your point with the "Learning period" and the "Not learning as easily period". &amp;nbsp; But I also have an follow up question. &amp;nbsp; I have several times been writing that I loved to see the output the Codecademy console showed me. But is a "bad thing to love"? Isn't Ruby a languange that gives you a lot of output during the making-progress? &amp;nbsp; Before I moved on to Ruby i took a quick course in HTML and CSS. I guess that's where my love for "seeing output" started as I could see the webpage take form for every line of code I wrote..
Ok, so I'll address something that I see you talking about in your comments - that now you're having to put a lot more effort into getting a satisfying output in the console, and that you're doing work where you don't see results. The fact of the matter is - a lot of programming is like that. Every complex program you see, like websites, or music players, or Photoshop, or whatever - it's a lot of little functions that are put together to do something specific. More often than not, you're not going to be putting together the function that leads to a satisfying output in the console, or an obvious result - you'll be working on functions A-Y so that you can do function Z, which is the big "oh wow this is cool" function. It's mostly delayed gratification when it comes to larger goals, so learn to celebrate the small stuff along the way.
EVERYTHING, start to finish, consists of example snippets of code you can try yourself. If you don't want to type it, copy-and-paste it in a code editor or IRB. You can see your results every step of the way. 
Ok. Thanks! I hope you reach or have reached you goal :)!
As always the deeper you get into things the harder it will be to learn, its going to be more and more challenging but programming takes long to do. Mastery almost isn't a thing in my honest opinion. I'm constantly learning things all the time. I build web apps with rails for a living and I'm still learning things about it all the time, and still struggle to get things sometimes. It takes time, just keep at it. Persistence really is the key to becoming a good programmer. Google lots and read a lot and you'll get there.
&gt; As far as algorithms go, it's more important to understand algorithmic analysis. What is the complexity of your algorithm? Under what conditions should you judge an algorithm by complexity? What is the best case? Worst case? Average case? THIS. While learning the nuts and bolts of the various algorithms provides the basic tools, the analysis is the far more important skill that goes along with the course. When something starts getting slow, it helps to be able to read a bit of code and see the nested loops and recursions that can make it go exponential.
My first experience is also writing the easiest code ever on a Commodore, even though it was an Commodore 128D :) &amp;nbsp; It's also good to hear that I'm not the only one striving for graphical feedback :P I thought that hunt is what stopped people from learning to code. &amp;nbsp; My hardware is mainly Windows machines. But I own an server with both Windows VMs and Linux VMs on it just so I can learn how to manage both. &amp;nbsp; I have been doing different courses on Codecademy for maybe 2 months total. I started with the HTML + CSS course. And it was after seeing how fast I could produce a webpage I wanted to learn more coding. &amp;nbsp; After completing the HTML+CSS course, and had created my own webpage with bootstrap, I felt pretty comfident that I would learn coding fast and easy. So I moved on to trying to learn Java. But I quickly lost my motivation towards learning Java as it was suddenly very hard to see the logic pattern in what I had to to; it wasnt clear anymore what the next line should be. &amp;nbsp; So after my quick visit in the Java course, my friend who produces webpages for a living said I should try Ruby because it was the "most logical" and it was "pretty close to writing english". And again the flame was lit and I thought this would be an easy task. &amp;nbsp; So then I found the Ruby course and started coding, and for a good 2hours everything was flowing fine, and my friend were pretty correct with the "It's pretty close to writing english" saying. But then the less logical tasks came, and I understood that this isnt going to be a bed of roses. But to the point. I think I've been on the Ruby course for 2-3 weeks I think.
That is completely normal. You are always going to be starting from scratch on something, whether it's learning a new concept or starting a new task or project. You will never learn enough, really. It's just a matter of setting new goals to do something, and learning what you need to know along the way. Now, obviously you should set realistic goals - I'm not going to expect you to rebuild Spotify using Ruby right now. But every new idea or program or challenge or whatever should make you think and hopefully take you out of your comfort zone. Once you figure out what you want to do, then concentrate on learning the concepts necessary to accomplish that task. But never wait until "you've learned enough," because you never will learn enough.
Well, it is a pleasure talking to you. I think I can be of some help. I think you are on the correct course with Ruby. Ruby has a variant language named "Rails" that you are probably familiar with. In fact, Rails was so popular that many people thought of Ruby as the boring underpinnings of Rails. This is because twitter was initially designed on Rails, and around 2007, 2008 everyone came to believe, "If you learn Rails, you will build the next twitter, and you will be a MILLIONAIRE overnight!" This, of course, turned out to be ridiculous, but it seems to be the only reason anyone bothered to learn Ruby for quite awhile. What I believe you are lacking is an environment in which to run Ruby programs. If all you are doing is running Ruby in the codeacademy interactive window, then all you can do on your own is write out Ruby code, look at it, and guess what it does. So, you need to find out how to run ruby programs in some sort of environment (some kind of window, basically). You need to able to type in Ruby commands and run programs. In GNU/Linux, you can run Ruby programs (they condescendingly call them "scripts") in the bash shell, and run an environment called `irb` - the Interactive Ruby Browser to enter, run and test ruby commands directly. What you can do then is write programs in Ruby that output to files. Then you can open the files in your browser. Since you are already familiar with html and css, and html and css are your goals, that is a good place to start.
#Thanks you all for your beautifull feedback! &amp;nbsp; After hearing what all of you had to say; I feel that I see things a little more clear now. And I feel that I understand how I can "see the progress" even thought the console isn't doing a lot of the job. &amp;nbsp; Now I will get a good night sleep and try to learn some more Ruby tomorrow :) So good night! TL;DR : Thanks for commenting! I liked speaking with you all. Good night!
This is also my first post / comment on Reddit. Similar to you, I have been around computers for a long time, did a little bit of programming when I was younger and then did something completely different. A few years ago (before Codecademy) I decided that I wanted to take up coding to boost my hard skills and just as a hobby. I also started with the Rails framework, and also wanted to see results straight away, lacking the time or the patience to learn in a disciplined way. I can't recommend Michael Hartl's Ruby on Rails tutorial enough: https://www.railstutorial.org/book Hartl gives you enough theory / practical application to keep you interested, until you have a very cool functioning twitter clone. By the end of it you will just want to learn as much as possible - and learning about loops, functions, lambda's, hashes, OOP etc. will feel like you are constantly improving your skill-set, progressing to better code. 90% of my job now focuses around programming and it is the best journey I ever started. And remember - coding is all about red-green-refactor. I think the best thing programming can teach you is to be more accepting of failure!
my advise would be to stay with 1 language and master it. Dont worry about this new technology your friend just told you about, or you read about on a blog post
Agreed. Even professionals google stuff all the time. You can't be expected to know everything about a language (or any subject for that matter), especially when it's constantly being updated, and people are developing new gems for it.
I blog and teach Ruby. Yes I encourage you to continue in Ruby. You should check out https://rubymonk.com/ . It's interactive and it teaches you in the form of going on a journey and learning along the way. And it's FREE :-)
Can I then ask you the same question that I [asked here one week ago?](https://www.reddit.com/r/ruby/comments/3tq8ym/blog_post_crafting_a_cli_tips_for_a_text_only_ui/) Where is the documentation for all this moving around stuff?
We have that already. Error messages are compiled from an error ast where you have info like input values, rule names, predicate ids etc. That ast is produced by the result objects, which you could also use to build some other representation and you don't like ast format. In general we're thinking about a separate gem that could be used to transform dry-validation errors into other forms, including AM::Errors which should be helpful when integrating with rails.
Currently the trend in webapps is that application in the browser side does a lot of things. Backend server is responsible for responding to ajax calls while the frontend code in browser does all the UI tricks. If you want to do websites you need to learn at least HTML5 and CSS (Sass/Less). If you want to do webapps you need to learn also Javascript (ES6). Ruby / Rails is for the backend stuff. Additional good things to learn are: * How to get things done: Don't tinker around, be focused and try to release with a quick cycle * Something to manage your frontend builds: webpack * TDD (for frontend browser apps and backend): mocha / phantom, rspec * Database: what's the difference between Postgres and Mongo * Security best practices * How to deploy sites to cloud: Heroku, AWS, ... I've been programming since 1992 and the learning process never stops. There will always be new things that you need to learn to keep up. Your experience with programming will increase with practice and that experience will help in learning new things. And even after 23 years you might still have to spend 12 hours of your time to figure out why some thing doesn't work as it should and how to work around that issue. And the solution might be one line of code that isn't in any way obvious and needs to be just right. Good luck :)
Learning programming *is* learning to google. Just keep googling everything, applying it, and moving on to the next thing to google. You'll get much better at googling, and thus much faster at programming. Source: Am gainfully employed developer. Still Google all the things. Also, I second the comment above. Ruby is the first thing in a very long journey! Make sure you enjoy the journey because you'll never arrive at a "destination" in this industry!
Thats cool. What do you mean with "Rails holds your hands"? Also I have figured out that theres way too much freedom. That is also one of my problems. I feel very insecure when the tutorial dosent give me "clear enough" instructions on what to write. When I tried the course "Building an interactive website" it started with some basic javascript. So I put that course on standby because I can't handle several languanges at the same time I think :)
I understand that it's impossible to know 100% of a growing object at any given time. But I'm really looking forward to the point where I feel that I know Ruby.
Rails holds your hand and hides a lot of programming details. I went on a few job interviews and they asked me about HTTP, restful routing, some SQL stuff and I barely knew what they were talking about. Rails allows you to build a web app with a minimum amount of knowledge about web development. That's good because you get fast feedback. That's bad because you think you know how to make web apps, but you really only know how to make a Rails app. JavaScript is its own beast. A lot of ruby methods aren't in JavaScript's standard library. If you feel the same look into a library line "underscore" or "lodash"
Hey rjnarain! Thanks for you for the detailed feedback! And congratz with first post :D &amp;nbsp; I looked at some of the pages in the book, and it looks very promising with all the pictures and explanations along the way. &amp;nbsp; I have never heard about the red-green-refactor, but I guess I will have to learn it the hard way ;P &amp;nbsp; Again thank you! 
Hey burntbit! &amp;nbsp; I checked over the "beginner" course of yours real fast. It looked promising and I will explore it in the coming week! 
Hello Klazzik! I don't think books will work out good for me, as I have huge problems concentrating with a book in my hands. I think I need some form of a interactive media to learn from. But you have a good point with the "Quality over Quantity" argument. &amp;nbsp; I looked a little on the first codewars challenges on Ruby, and it looks very interesting. I will indeed look more into Codewars when I feel more confident in my Ruby coding! &amp;nbsp; Thanks again for your feedback.
Hey Cr0wsb4h0es. Thanks for the feedback. &amp;nbsp; Your "aimlessly following the tasks" argument is really true. It feels like studying for an upcoming exam. And I'm pretty sure it's not a good method to learn an completely new languange. &amp;nbsp; Do you have any tips on how to get started on a project? What is the first steps needed? &amp;nbsp; Thanks again.
Hey Nesaru. &amp;nbsp; I always feel kinda "dirty" when I google the answers. I feel like I'm cheating the learning process as I often end up Copy-Pasting stuff without really understanding what it does. But maybe I'm just seeing it from a wrong perspective? &amp;nbsp; Also, I'm just learning to code so I can produce some funny things for myself, as a hobby. I'm not looking to work with coding in a company or anything. My dad works as an programmer in a big company, and he always has problems staying up-to-date with everything happening in the industry.
Ah. Then I understand the "holding hands" part. &amp;nbsp; But I think Ruby holds all(or more than) what I will ever need anyways. I'm just doing this for fun and as an hobby. I don't plan to enter programming professionally. 
If you like seeing individual lines of code do interesting things visually, javascript might fit the bill. Though I disagree about css being straight forward. Maybe in concept but not in practice. edit: *if your long term focus is creating web applications.
Haha, Ok! Then I will feel a lot more secure going into learning more coding, when I can feel that its OK to google things that are bugging you. &amp;nbsp; Thanks :)
Hey comrad! I guess I just have to keep on learning and after a while after producing some stuff I will feel better about it. &amp;nbsp; Thanks for your feedback!
Hey, I would suggest you to read up on object oriented programming ( just get the basic understanding of classes and objects ). Also it would be good if you know how functions work. If you're all set with that, since you're using ruby, I'd suggest you get started with [Sinatra](http://www.sinatrarb.com), it is a light framework for creating web application. Try installing it and playing around. If you have any more questions or need any help you can message me :) Best of luck once again. NOTE : It would be helpful if you know a bit of HTML and CSS to make your pages look pretty.
Yeah, just keep exploring and learning. And keep looking back on some of source code of yours. If you think that you wrote terrible code back then, at least you know you are progressing üòÉ 
I have not trickled around with CSS that much, so I could be wrong. The only experience I have with CSS is making an easy small website for an company I worked for earlier, and following a tutorial where I re-created the old Airbnb webpage. So it seemed very straight forward. 
I highly recommend going through a program like "Learn Ruby the Hard Way". Doing everything on your computer, working through problems, IMHO, is better than struggling through syntax that isn't always right. I started with Code Academy but branched out and was very happy I did so! It made learning easier and more comprehensive, I think.
I havent chosen a language, but I have chosen what I need a language for. I will only produce websites and stuff that should do stuff inside of browser. So that is alleredy defining what I should/can learn.
At the start I just need a lot of help from the interactive console and the tasks from Codecademy. I'm still not sure what to do with my first program. But soon I will start developing something that can be used somehow :P
dammit, i typed out a whole thing then it's gone. In browsers the front-end is html/css/javacript. On mobile apps its Swift or whatever they use. Ruby is more back-end than front-end although you can use Ruby logic in ERB templates. Browsers only understand html/css/js, though, so these templates need to be evaluated server-side. Unless Javascript is used, the page will need to be reloaded whenever anything changes. You can build Javascript on top of Rails. For example, use jQuery to send / receive data from a Rails JSON API. I think if you enjoy the front-end stuff focus on html/css/javascript. I personally think Javascript is harder than Ruby, though, so once you get the fundamentals of Javascript you shouild probably have an OK time using Ruby. If you want to make a site using just html/js/css (no back end) try [github pages](https://pages.github.com/). I think also it's important to be fearless when starting new projects. If you think you might be able to build something with your current skills, and it's a reasonably compelling idea, just start and see how far you get. Also don't get too caught in the nitty-gritty of the Javascript language. Rather move on relatively quickly to jQuery and start building stuff, it's much more fun. 
Personally I would of opted for a more concise api, as opposed to mirroring the the escape sequences directly cursor.pos = [0,0] # home cursor.pos = {x:0,y:0} # home x = cursor.pos # save current position cursor.pos += {x:5} # move 5 to the right cursor.pos += {x:-5} # move 5 to the left cursor.pos = x # restore position I don't know how easy something like that is in ruby though
I suggest you go for javascript, A company might not use ruby/python/java but they 100% will use javascript. Some might even use ONLY javascript.
I'm not learning code with the intention to get a job with programming. Mainly I just want to learn a new hobby, and maybe do small jobs for small organizations and such. But learning Javascript might not be a bad idea.
That looks like a really nice gem, will definitely give it a try. 
Thank you, I'll give it a read :)
Keep in mind any Rails app that is not very simple and basic will require you to know about HTTP and restful routing. In general, you can avoid knowing about SQL for a long time though. However, you will learn about it abstractly without realizing it (like when using ActiveRecord) which will be helpful.
Interesting idea. I suppose the angle I took was more to do with extreme simplicity, it's just a collection of codes with helper methods on top. Hence this module can be just mixed in. This has a nice side effect of being easy to compose as well: cursor.forward(5) + cursor.down(5) + .... To achieve your suggestion I would either need store the current position in instance and 'remember' the state or parse it by querying the cursor terminal position. I like your suggestion, I will definitely consider it for next release. 
Learning a language and doing exercises is good, but nothing compares to a project of your own. You say you want to make web apps. Pick an incredibly simple idea (I can't stress *incredibly simple* enough), and start to make it. You'll have to use google constantly, but you will make progress, and you will learn a lot. It should be more motivating because you are doing something real. By the end of the project you will probably be so much better that you'll want to throw out most of your early work. That just shows how much you've improved. Rewrite it and jump onto your next project. Rinse and repeat.
Hey. I don't really understand what you are saying here :P Do you mean I have to learn about "HTTP" and "Restful routing" before moving on with my Ruby coursing?
You have to find it interesting. If you don't you are setting yourself up for a lot of time spent doing what you don't want to do. 
After getting some real good tips on here, I feel motivated to keep trying! I will stick to some more tutorials, then I will start working on some kind of project and get better with practise!
This is awesome! The only issue I see here is that you'll have to get the answer exactly. It's a great idea, multiple choices would be easier but cleaner
Well this is not 1 or 2 files, but is very small and a great project. https://github.com/soveran/cuba
An interesting use of enumerators, although I'm not sure I'd write it like this in "real" code. It's a bit of a weird way to define the method, to begin with, in my opinion. Rather than doing this: pascals_row([1]) = [1, 1] pascals_row([1, 1]) = [1, 2, 1] pascals_row([1, 2, 1]) = [1, 3, 3, 1] pascals_row([1, 3, 3, 1]) = [1, 4, 6, 4, 1] pascals_row([1, 4, 6, 4, 1]) = [1, 5, 10, 10, 5, 1] Why not do this: pascals_row(1) = [1, 1] pascals_row(2) = [1, 2, 1] pascals_row(3) = [1, 3, 3, 1] pascals_row(4) = [1, 4, 6, 4, 1] pascals_row(5) = [1, 5, 10, 10, 5, 1] You could then edit your solution: # row is an Array def pascals_row(row) ([0] + row).zip(row + [0]).collect { |a, b| a + b } end With a recursive method, like: # row is a positive Integer def pascals_row(row) if row == 1 [1, 1] else ([0] + pascals_row(row-1)) .zip(pascals_row(row-1) + [0]) .collect { |a, b| a + b } end end And if performance is an issue, you could add some caching of results via memoization. However (and I know this goes against the whole interesting topic that your post is discussing...) actually, I'd just implement this by calculating the binomial coefficients directly: def fact(n) (1..n).inject(1, :*) end def binomial(n,k) fact(n) / ( fact(k) * fact(n-k) ) end def pascals_row(row) (0..row).map { |column| binomial(row, column) } end pascals_row(1) # =&gt; [1, 1] pascals_row(2) # =&gt; [1, 2, 1] pascals_row(3) # =&gt; [1, 3, 3, 1] pascals_row(4) # =&gt; [1, 4, 6, 4, 1] # ...
https://github.com/NullVoxPopuli/skinny_controllers ?
You are probably right, unfortunately I do not have enough time to re-write the whole code (this is a school assignment). Our Ruby instructor doesn't like the language, and has done little to teach us how to utilize its features properly. I would love to get into it more and be more efficient with my coding, however. For now, I just need to get what I have to work.
Cool, thanks for taking the time to work out your alternatives. The recursive solutions to Pascal's Triangle are interesting in their own right. One of the goals of the post was to highlight Enumerator which, in my opinion, doesn't get enough attention with hopes to make its usage less "weird". For sure, there are tradeoffs inherent with any of these choices. 
It seems `word_pairs` is an array of `Strings`. `#map` will iterate of the contents of an array, applying the block to each item. It's attempting to call `#first` on a string, but `#first` is an `Enumerable` method. You might want to validate the structure you're receiving the is structure you're planning on using. I'm not sure of the context of these methods, but you might want to look at `#uniq` for the `Array` class.
Apparently what you passed in as word_pairs contains an element that is "10th", a string, not a pair that you are actually expecting. Please learn to read error messages, they are often very helpful and clear enough for you to identify your bugs.
https://github.com/soveran/cuba/blob/master/lib/cuba/render.rb#L51 Why they don't use `private` key word? :)
So although the Rails [ActiveSupport](https://github.com/rails/rails/tree/master/activesupport) library isn't small, each file is fairly self contained, and could be considered an exercise in its self. If you want a more guided approach, I've actually written a bunch of articles about [reading rails](http://www.monkeyandcrow.com/series/reading_rails/), where I walk through the source. That might give you a good starting point, and then you could dive into it a bit more. For instance you might want to read [how Rails' MessageVerifier works](http://www.monkeyandcrow.com/blog/reading_rails_how_does_message_verifier_work/). Shout if you have questions, and good luck. 
As an alternative to /u/ThijsW 's approach, you could also get more granular unit testing using [stubbing](https://www.relishapp.com/rspec/rspec-mocks/v/2-99/docs/method-stubs/allow-with-a-simple-return-value). Some refactoring might make this clearer (apologies for any bugs, writing this in a hurry but you should get the idea): def create_sequence_word_pairs(dict_words) dict_words.map { |original| create_pairs_array_from_original(original) } end def create_pairs_array_from_original(original) derived_seqs = extract_sequences_from_original_word original pairs_array &lt;&lt; create_seq_pair_array(derived_seqs, original) end def create_seq_pair_array(derived_seqs, original) derived_seqs.map { |seq| [seq, original] } end For each method, you can then write a unit test. For methods that call other methods, you can use the `allow(method).to receive(foo) { stubbed_return }` syntax to stub out the response. For example: describe 'create_pairs_array_from_original(original)' do it 'foos the bar' do allow(&lt;parent_class&gt;).to receive(extract_sequences_from_original_word) { &lt;some_response&gt; } &lt;parent_class&gt;.create_pairs_array_from_original(original) expect ..... end end You can then write a separate unit test for `extract_sequences_from_original_word` to test it in isolation. As an added check, you can also expect the method to be called (again, you're checking that the method works in a separate unit test for `extract_sequences_from_original_word`): it 'calls extract sequence from original word' do expect_any_instance_of(&lt;parent_class&gt;).to receive :extract_sequences_from_original_word &lt;parent_class&gt;.create_pairs_array_from_original(original) end Hope that makes sense, apologies again for any errors.
I don't recommend this approach, it modifies the object under test, which defeats the purpose of testing in the first place.
no, college...
Curious as to what you mean. While you are stubbing out part of the method, that part of the method still gets tested elsewhere. Take this example: def make_foo(bar) baz = baz_the_bar(bar) foo_the_baz(baz) end The idea is that you unit test `baz_the_bar` in its own test to make sure if you feed it `bar` you get `spam`: describe 'baz_the_bar' do give it bar, expect baz end Since this is then already tested elsewhere, you can stub `baz_the_bar`'s output when you test `make_foo` and focus on testing the rest of the method (in this case the use of `foo_the_spam`): describe 'foo_the_baz' do it 'bazs the bar' do expect baz_the_bar to be called when you call foo_the_baz end it 'foos' do stub output of baz_the_bar expect the stubbed output to be fooed end end Admittedly you might want an integration test on top of this for safety, but OP specifically asked about unit tests. In addition to decoupling your test code a bit, as an added plus this can also speed up your tests quite a bit depending on what you're doing. I've also found that it helps with bug isolation during debugging, but that's just my anecdotal impression.
I'm sure explicitness vs implicitness could be highly debatable. Rails and Ember have a lot of magic that 'best practices' lists swear against. :-\
I'm always become obnoxious when i see benchmark without GC settings provided. You can tune CRuby GC that it uses ton of memory and does not spend much time in garbage collection. To be clear - I'm not trying to say that this benchmark is not correct, it's missing some important details.
This is an interesting talk, it starts off a bit dry and technical but gets better as it goes along and makes some good points about things sucking/being awesome during [the conclusion](https://youtu.be/qXC9Gk4dCEw?t=35m50s) 
Finals are next week, so that isn't an option. 
You might try just posting how many times GC ran during each run. Just `GC.stat[:count]` after each run. I forget when that was added to Ruby though.
Those generous warmup times really hide the main issues I've had using jruby: the startup time and the slower initial execution. I've also had issues with memory consumption, which wasn't measured in this benchmark. I'm not saying jruby is bad, but it wasn't a great fit for me. This article might lead someone to thinking that using jruby is going to yield a 4x performance improvement. It would be interesting to hear from someone using jruby in production.
Perfect! This works accomplishes the goal. a.gsub(/\&lt;\=(.*?)\=\&gt;/) do expresion = $1 puts expresion eval(expresion) end
Any versioning questions?
Thanks! I think it was Ruby 2.1, not sure :) And thanks will take a look into that. Still looking forward to what c0r0ber means exactly. Personally I'd much rather experiment with different GC settings. For me GC run time of course contributes to the run time but it does so as well under production settings, so I want to measure it. benchmark-ips runs GC, I'm forgetting if after every run or or a whole job. benchmark-avg doesn't do that - yet :)
It was something I was messing around with after I posted last night. I can get it to loop, however i need to make the game quit when a player gets a mine, something i am still having trouble with.
There's also no tuning of JRuby/JVM GC here, which for a garbage-heavy load can make even more of a difference than tuning MRI's GC. In general, though, if the benchmark is GC-limited, no amount of tuning is going to get MRI or Rubinius to beat the JVM. You make a good point also about tuning MRI GC to use more memory. This is precisely why some people initially dismiss JRuby: the JVM by default uses as much memory as you let it use to keep GC pauses to a minimum. JRuby running a Rails app *can* be forced down below 100MB heap, but you'll be trading GC times for smaller total memory use. MRI by default goes with smaller heap and higher GC times.
Great numbers on a real-world problem! Worth pointing out that we spent no time looking at the performance of this benchmark on normal JRuby (non-Truffle) and it's likely we could narrow that gap with a bit of work. JRuby+Truffle is promising tech with some great early numbers, but we'll keep making JRuby+JVM(+Invokedynamic) faster and faster too :-)
What's your take on Jeremy's opposing view? https://gist.github.com/jashkenas/cbd2b088e20279ae2c8e Edit: upvotes for intelligent conversation!
Excellent analysis, insight, and guidelines. These judgment calls and their implications are trickier than they appear on the surface.
Thanks
I don't disagree with most of those points. My next post on versioning is all about why no one does semver right, the implications, and some suggestions. I think it's simplistic to say that because something doesn't work right now that we shouldn't use it. I like this post on the actualities of working with semver https://medium.com/javascript-scene/software-versions-are-broken-3d2dc0da0783#---0-57.j0ybbvqgr Basically I think that we need some mechanical way to communicate likely hood of breaking. As my dependencies for a simple app are nearing 100 there is no way I could upgrade and manage them all manually. Semver when used correctly, can help me do my job easier. While not perfect, semver is the best proposal I've seen to address this problem. Thanks for reading.
http://m.youtube.com/watch?v=URSWYvyc42M
Worth checking out [The Hitchhiker's Guide to Ruby GC](http://confreaks.tv/videos/rubyconf2015-the-hitchhiker-s-guide-to-ruby-gc) on this score.
Once you have a certain number of dependencies, it becomes a nightmare to deal with if you can't automate management of upgrading dependencies -- turn it over to the "robots". For something like Rails, a direct dependency core to your project, you can deal with 'romantic' versioning. And yeah, keeping your version number at 0.x is definitely an opt-out from semver, of course. You can deal with a few of those in your project. But when you have a dependency graph of hundreds of indirect dependencies that share dependencies, it's a nightmare unless the compatibility can be encoded in a machine-readable way, which is what semver tries to do. Ruby community style has developed to using very complex dependency graphs. Both semver and the bundler tool are a response to, as well as enablers of, this style. Yes, it's true that semver can be hard, and mistakes can be made. Mistakes both cause pain and are unavoidable to some extent, but that's not a reason to give up on the whole endeavor; if nobody's even trying to do semver, it's like all you have are 'mistakes'. And we'd have to adopt a less dependency-heavy style of architecture, break things out into separate re-usable gems less, etc. Which would have pro's and con's. It's a trade off. "Everyone" trying to do semver and sophisticated tools like bundler do have limits to how much complexity they can accomodate. 
I wrote up my own versioning philosophy last year. I won't bump major for every last breaking change but I think SemVer's heart is in the right place. http://www.mikeperham.com/2014/09/01/library-versioning/ Note that Sidekiq 4.0 broke no APIs at all but still bumped major because of the huge overhaul.
I wouldn't bother honestly. Install Vagrant + VirtualBox and work in a linux VM.
Railsinstaller.org takes 5 minutes and you're done give or take. Then maybe a few quick fixes on stackexchange. There used to be some gem issues, but they're mostly fixed. 
I use [Cygwin](https://www.cygwin.com/) to get Ruby (among other things) onto Windows.
Like other people said, run a Linux VM. That said, if you're determined to use Ruby on Windows natively, look into JRuby - it's way easier to work with on Windows than Ruby due to the JVM's cross-platform nature.
Is anyone using this? I'm using [stickler](https://github.com/copiousfreetime/stickler) internally, but it's not very performant. I'm considering trying Gemstash out, anyone have experience to share?
Not yet but I've heard good things about Artifactory (proprietary) and Geminabox (free). The latter is pretty stale in development and the former is overkill for my purposes. I'm a little concerned at all the steps involved for stickler to mirror. Shouldn't it be relatively automatic with a manual upload option? Isn't this essentially an outbound proxy for bundler with caching and private gem server support?
&gt; As for memory consumption, yep not measuring that here as it isn't important to me as of now but might be interesting to include in the future for comparison's sake. One thing though, once applications (web or this) go multi threaded CRuby usually eats more memory as it needs to fork thanks to the GIL which multiplies memory. For JRuby and Rubinius you spin off threads which have comparatively little memory overhead. Have a bit opposite experience, with Rails based e-commerce application run on Heroku. First process forking is not multithreading but multiprocessing, second recent \*nix systems including Linux have [COW optimization](https://en.wikipedia.org/wiki/Copy-on-write), so running multiple instances is not *that* bad. We've toyed with JRuby (CRuby 2.1 compatible) but could't fit in memory limit of one dyno and logs were soon flooded with R14 quota exceeded messages. When limited max memory for JVM, the application then started crawl terribly and response times become unbearable (possibly due to frequent GC cleanups).
As a user of many libraries, I love SemVer because it helps me trust my dependencies. But as a co-maintainer of a [gem](https://github.com/neo4jrb/neo4j) with what I like to think is a respectably sized community of users, I think that a strict adherence to it helps encourage really healthy, helpful behavior. It forces you to really consider the scope and impact of our changes. Being aware that a change will break the API, require a major bump, and therefore take a bit longer to release forces you to ask yourself if there's a way to add a feature in a simpler, less intrusive way. This feels nicely Agile to me. It also encourages you to think more about setting a clear delimitation between public and private interfaces. SemVer is focused on public interfaces, so the more you tuck behind the curtain for reuse later, the easier it will be to safely make changes without breaking the contract with the user. Not only does it help you get stuff out there faster, it encourages healthy design habits.
I agree with /u/realntl. This is not a good way to teach unit testing. A unit is not a method or a class. __A unit test tests a unit of work.__ This is a common misconception. This way makes your tests very brittle. They will break when you change the implementation of the method. Tests should only care about input and output. From the test's point of view the method under test should be a black box. It could even be worse, the test wouldn't fail when you the stubbed method returns something you don't expect. You talk about decoupling your tests. Stubbing a method, couples the test to the implementation of your method. It does this in the worse way possible. If you want to change the name of the stubbed method, you need to change the test. To help with bug isolation, you could also test the second method explicitly. This is never a bad idea. Now stubs and mocks, or test doubles in general, have a place in a good test suite. You can stub calls to the database, or external systems. You don't want your unit tests to fail when a system is down. Also these systems tend to be slow, this will speed up your unit tests. A last word of advice, don't use mocking frameworks, write your own test doubles. This way you have more control over what happens. Also it could be that the test double can become a production implementation of the class. For instance you can create an in memory implementation of a database call, which can also be useful in a production system.
It's a gem for creating cocoa apps in ruby using FFI. If it's any good I hope someone has the time and will to create a fork. Patrick Hanevold was a personal friend. He was an awesome Ruby developer who also worked as a CGI artist on http://www.imdb.com/title/tt1029235/
Which ones already exist?
I'm sorry for the loss, but the gem seems pretty dead even from before... last update was 1 year ago :S
Thanks. Yes, he abandoned the project before he died. The project was originally intended to be a product to compete with RubyMotion and be ported to Android. When RubyMotion announced that they would start supporting Android, Patrick abandoned the project.
site is down.
Sign up for c9.io. I've been using it for a while and find it really great. Nothing to install and you can develop on any machine from anywhere.
What exactly are the courses this post is mocking?
Just spent 5 minutes writing a comment, then accidentally clicked the wrong thing and lost it. Thanks reddit. The tldr; was that I like your philosophy and think it's a good pragmatic solution. I believe that is where most projects end up. 
Might want to check sarcastic-ruby-parodies.com, .net, .org. Or... ruby-parodies.net/sarcasm.
Yes, I too find that bad jokes get even better when you try to explain them into betterness.
He did. He's just trying to explain why the maintainer abandoned it.
Ruby koans, probably.
Thanks!
That was very sound and welcome advice. I will take it to heart. I am still new at coding, so any pointers are always appreciated. Thank you. 
Only if you have 100% trust in the templates and their authors. ` &lt;= system 'rm -rf /' =&gt;`
There's a good chance that the project was abandoned due to health issues that culminated in the person's death. Please don't be crass.
Your response in regards to work by someone in the community who ultimately passed away is crass and juvenile. 
The final paragraph of your conclusion seems to be at odds with the rest of the conclusion. After an entire article advocating the Minitest way: "I don‚Äôt advocate one test framework over the other, as they both do the job well. If you‚Äôve never tried unit style tests, I recommend doing so, as it reorientates the way you think about your code and your tests. This way of thinking can then be easily applied to rspec."
Well, I was just stating that the project was unmaintained from before in a way of asking if this was either the relevance of the post by itself or another way to ask for someone to maintain it, all of that without making any personal remarks about either the OP or the developer related, unlike you. I agree that the response might have been a little blunt, but to be honest I dont consider it "crass" or "juvenile". So I would say that I respectfully disagree with your comment which is of no use at all besides doing an ad-hominem statement and have no intention of bringing the argument to a deeper, unneeded level. So what do you say? "agree to disagree" or wanna keep the ball rolling?
Neither. 
oh for sure. Im writing the templates myself, so if there is anyone to blame its me. Thanks for chiming in though, if this was open to user input it would be a terrible approach. 
The bug is in uri/generic.rb: def to_s str = '' # ... str &lt;&lt; whatever # ... str end That's a common pattern in Ruby...
Without GECK? Impressive. ^^^^/s
Wouldn't something like that be found by running ruby's tests with `--enable-frozen-string-literal` enabled? This seems like a bare minimum task that you'd do prior to going through the trouble of packaging up a preview release.
Garden of Eden Creation Kits are so last year.
[Symbols have the property that equality is identity](https://www.reddit.com/r/ruby/comments/3hqky4/string_literals_are_frozen_immutable_by_default/cua0o3j)
I hate projects that don't give you a reason for why it exists, or assumes you're familiar with previous versions. 
So smart.
Yes, the title indicates that the project was abandoned after because Patrick died. So to be correct; not only is this abandonedware but the developer happen to have died a few months after it was abandoned. Patrick died in an accident at home and had no family. He loved skydiving and coding. His github account with all his code is there for the grabs.
Yes
Dude, nobody understands your weird little joke. That's your fault, not ours.
What I need is a guide for is application maintainers. If I'm using server for an application will it ever go above 1.x? There's no compatibility to break if it's just a user interface.
Hey, I wrote this, might be of interest to people here.
No worries! I'm just a firm believer that tutorials should always teach best practices so that new learners don't get the bad ones stuck in their heads. Thanks for writing it up!
I've just spent the last couple of days ringing around the local design shops looking for a gig. Yeah, I think it's pretty accurate. 
Hit me up if you wanna go perm ;)
Ummm... Did you even readme?
If I can stay based in Newcastle, I'm all yours :* 
If your interested in having a message broker and don't want to drag in rabbitmq, look at Redis's [publish](http://redis.io/commands/publish) / [subscribe]( http://redis.io/commands/subscribe) commands. One thing that this approach does not let you do is have multiple workers respond to the same broadcast.
Could you explain what that use of the select method is doing? I'm not familiar with that syntax: "&amp;:eligible".
why not drag in rabbitmq? it's amazing.
I suspect that this may be intentional wordplay. Works rather well, actually. 
Definitely. We wrote https://github.com/PipelineDeals/mantle to solve the use case of managing broadcasting over channels.
I've found their chef cookbook to work very well in getting a no-hassle cluster going. 
I'm with you there.
Is this a linux system? If so, run "which pry; which irb; gem env" and post the output.
Yeah using a Mac. .rvm/gems/ruby-2.2.2/bin/pry .rvm/rubies/ruby-2.2.2/bin/irb RubyGems Environment: - RUBYGEMS VERSION: 2.4.8 - RUBY VERSION: 2.2.2 (2015-04-13 patchlevel 95) [x86_64-darwin14] - INSTALLATION DIRECTORY: /Users/steveo/.rvm/gems/ruby-2.2.2 - RUBY EXECUTABLE: /Users/steveo/.rvm/rubies/ruby-2.2.2/bin/ruby - EXECUTABLE DIRECTORY: /Users/steveo/.rvm/gems/ruby-2.2.2/bin - SPEC CACHE DIRECTORY: /Users/steveo/.gem/specs - SYSTEM CONFIGURATION DIRECTORY: /etc - RUBYGEMS PLATFORMS: - ruby - x86_64-darwin-14 - GEM PATHS: - /Users/steveo/.rvm/gems/ruby-2.2.2 - /Users/steveo/.rvm/gems/ruby-2.2.2@global - GEM CONFIGURATION: - :update_sources =&gt; true - :verbose =&gt; true - :backtrace =&gt; false - :bulk_threshold =&gt; 1000 - REMOTE SOURCES: - https://rubygems.org/ - SHELL PATH: - /usr/local/bin - /Users/steveo/code/dotfiles/bin - /Users/steveo/.rvm/gems/ruby-2.2.2/bin - /Users/steveo/.rvm/gems/ruby-2.2.2@global/bin - /Users/steveo/.rvm/rubies/ruby-2.2.2/bin - /usr/local/bin - /usr/bin - /bin - /usr/sbin - /sbin - /usr/local/git/bin - /Users/steveo/.rvm/bin - /Users/steveo/.rvm/bin 
Are you using require or load in pry? Also, are you able to use any gem other than nokogiri in pry?
Yes I was trying to require it in pry, but I've since gotten it to work. I'm not sure what did it, but thanks for your time anyway. 
I disagree with "dynamic" requires. It's much harder to track your internal dependencies that way, e.g. via grep. For example, if I want to make breaking changes to my Ship class, I'd like to know which files are requiring it and need corresponding changes. I'd call it a controversial practice and definitely not a best practice.
Anyone want to counter this? I understand this is DRY but a quick survey of Sinatra, Jekyll and Prawn seem to indicate that just listing everything out is popular. What if you add code in that folder that you don't necessarily want to have `required` at the same time everything else is?
I would take this further and say that new learners should realize that there are differing opinions on what constitutes "best practice".
Thank you so much for the in-depth reply. I have to spend some time looking up several definitions referenced here before I can understand it all. :)
Man, this post gave me flashbacks of dabbling with Gosu back when I was in college. Recently, I've been playing around with different open-source/freemium game engine toolkits for fun and Gosu would still be my first choice for learning, prototyping, or game jamming 2D games. Nothing I've seen rivals its streamlined API or ease of use, in any language. You can build a simple platformer with very little boilerplate, and understand exactly what it's doing.
I'm very glad that my post brought you good memories! :) Yes, Gosu is wonderful, I discovered it some months ago and wow! :D
You can either pull in ActiveSupport, or just copy this method from it: http://api.rubyonrails.org/classes/ActiveSupport/Testing/Declarative.html#method-i-test
Can I use it with Ruby or it's only for RoR (I absolutly know nothing about RoR, but it's used for websites).
Big thanks!
If you're interested in more of a block style syntax, you could also use Minitest specs without pulling in Active Support. require "minitest/spec" describe "Method" do it "is equal" do expect(1).must_equal 2 end end Alternately, you could pull the spec DSL into your existing test to let you use `it` blocks. require "minitest/spec" class MethodTest &lt; Minitest::Test extend Minitest::Spec::DSL it "is equal" do assert_equal 1, 2 end end
I worked for a small consultancy company in Manchester from that was very early on the Rails bandwagon. I was actually on the team that wrote the first Rails version of OTB in 2008-2009. The prior version was written in perl with [interchange](https://github.com/interchange/interchange), believe it or not. It was a great time to work in Manchester; I met loads of excellent developers (at NWRUG and other similar events) and learnt an incredible amount. Then OTB went on an massive hiring spree and before long had more developers than we had employees in total, so lost our biggest customer and everything went south. I'm glad my former colleagues all landed on their feet, though.
The `spec` is what I actually looking for! `^^` Cool, thanks!
I think it has to do with how quickly the DOM is re-rendered using different JS engines. The fewer visual 'hiccups', the better.
You probably need to install guest additions. However, you shouldn't need to use the UI of the VM. What I would normally do is put your project files in a shared folder between the VM and host system. Run your text editor in your host os and just SSH into the VM to run the code / tests / etc. You can forward some ports so you also use the browser on the host OS assuming the code is a web app. Effectively treat the VM like a headless server. One tip: try both `nfsv4` and `smb` for the shared folder, `nfsv4` is significantly faster with a mac host but it may not be the same on windows.
can anyone see the difference? I can't tell a difference at all, but I don't really know what I'm looking for, either. 
I mean it's right there in the post.
&gt; I mean it's right there in the post. There's no context in the post and I don't see a documentation link. I know neither what Clearwater is nor what DBMonster is.
[removed]
I thought about it using actual numbers, which I could use to make a graph, but I don't really know how to benchmark React rendering. I built debug hooks into Clearwater to show ("this app took X ms to generate virtual DOM and Y ms to render to DOM"). Just need to figure out how to do the same with React. :-)
You're right, I could've been a lot clearer about that. I originally explained DBMonster in the post as "TodoMVC for performance", but that didn't survive editing for some reason. My fault there. The DBMon/DBMonster app is a way to visualize rendering performance. The numbers themselves don't mean anything ‚Äî they're completely random ‚Äî what matters is the frame rate at which the app renders. If you run the two apps side-by-side in separate tabs and go back and forth between them, or in separate windows to see both at the same time, you can see just how much faster Clearwater is.
Done in PM =)
Really cannot tell here, either. They are both screaming fast.
wow this is amazing, thanks!
will do, thanks for the advice!
Heva a look at command line gems: http://www.awesomecommandlineapps.com/gems.html.
As demonstrated by /u/tashbarg, just use the constant. Also, two more options, even: module MyConst @foo = "cat" class &lt;&lt; self attr_reader :foo end def self.bar @bar ||= "dog" end end If you find yourself using too many constants, it might be worth examining why you're using so many in the first place. Ruby is a language with a huge amount of dynamic flexibility and relies quite a bit on developer diligence for good structure.
This is sweet. I turned on Google Chrome's FPS Counter to see. Made a little gif you all might want to check out. [ReactJS vs Clearwater](http://i.imgur.com/Yh3sKfn.gifv) 
What's up? PM me.
Nice! I hadn't thought about that. I usually just stick to the profiler/timeline views. :-) Thanks!
Thanks, this is definitely helpful!
A good starting point is `bundle gem --bin=$my_executable_name`. It'll spit out some scaffolding for you. See &lt;http://bundler.io/bundle_gem.html&gt;.
I noticed the same. I'm not sure what it is. I wrote the Clearwater components based on what I saw in the DOM inside the React version. If you see something I overlooked, I can go ahead and add it in.
Hey guys, I've been struggling with inventory in multiple locations, and came up with this class. In particular, I wanted to compare two collections to ensure that our inventory can fulfill a proposed Order with preferred fulfillment locations. This has _got_ to be a Set Theory 101 problem, but I am a terrible mathematician. Is there a name for this issue? 2-dimensional hash comparison? I'm also interested in other approaches to multi-location inventory; I couldn't find any gems relating to it. I would value any discussion/feedback on this gem or the problem in general. Thank you and ruby on!
Just for fun, here's a way to pass a file in; f = ARGF.readlines This takes a filename provided at the command prompt, and reads it into 'f'
Cool class. I've just been reading up on threads and queues using puma, and it would be cool if write operations were queued on a thread and locked with mutex to make modifying operations thread safe. 
The core concepts of multiple warehouse delivery picklisting are fairly simple, however they tend to become very unique quickly. Once you layer in business requirements you are often left with very complex logic trees. Consider things like: * simple needs like minimizing shipping costs (testing for shortest path delivery or large item freight cost minimizing) vs shipping speed. * conflicting order priority against limited inventory, If two customers have placed orders including the same item but you only have one to deliver how do you choose the order to pick? maximize the order that can be completely shipped (fewer customers hurt)? maximize partial shipments (more customers hurt, but some satisfaction of delivery)? maximize the largest complete invoice to lock in more revenue (less harm from a canceled backorder)? * when an order can't be picked from one warehouse, how to you optimize the split? So when systems like this are built and put into production simple testing of intersection of sets is the least of your worries.
Seems fine.
From what you wrote I did not expect what your slides contained and how they where organized. For me they are really good. How did you create them? Looks like Reveal.js. Could you share your slide sources?
I will, thanks. In my excitement in releasing the gem I wrote the documentation very quickly. I was just being stupid and cute. `#include?` is useful for spot checking a things existence, be it a location or a unit.
The site itself is hosted in Github pages; but the source isn't open. I can share you the specific markdown if interested though.
Thanks :)
Even I thought so, but it seems many think it isn't.
There are two option that i see here: 1. Like others already mentioned, maybe your Prof doesn't have any experience with ActiveRecord and thus doesn't understand how this works. 2. He knows, but he wants to get sure you know as well. Because if you use a tool, you should know how it works. The solution to both would be the same: Dig into ActiveRecord and find out how it works, then explain it to him. This will give yourself a better understanding of your Tools and will help you with similar arguments in the future.
Well, after the mysql-&gt;mysql2 change, I did `clean_database` and `populate_table` to get a fresh slate. Then I did `sale` and that got me a nil reference on `book.stock -= 1`. You don't set `stock` in your `populate_table` method. I added that in to the factory method and it seems to work correctly. So, going based on that, I don't think your professor was saying `books` was undefined. But that `books.stock` was set to nil. Which is was. And he's right -- this never should have worked. It only worked for you because you probably already had `Book`s in the database with stock on them. Basically: Test *all* your methods. Always try working from a blank slate when reproducing a problem. And read the error messages you're given. I'm sure the professor didn't just tell you "Oh books is undefined".
Having built similar systems, the very first thing you should add is a full complete audit log of every action. Essentially a double-entry accounting style ledger that tracks all inventory changes. Depending on your application, I would also caution against becoming too attached to the `location` concept. Inevitably you will have `locations` as part of your data model but there often end up being `non-location` inventories as well. e.g. Inventory that isn't yet in a location (ordered but not received inventory), inventory on trucks for delivery, inventory in the packing stage, etc. Some of these can be modeled as locations but it becomes a cumbersome model that way.
You are welcome to PM me the details as well if you like. I always like helping.
Is there something that supersedes it?
This is FANTASTIC! I've just started working on a new Rails project that I seriously began thinking I would split into separate API and UI codebases, but I wasn't sure the best way to do that that requires the least amount of typing. :) Your use of RestClient on the UI side and the serializers on the API side is very clear and looks hardly any more difficult than a monolith approach. Thanks for the example!
Done
No worries! I was just like, is there some obvious Ruby thing I'm missing here, haha.
Nice idea, I might use this as template for a rust library so I can use it in my current project! Thanks for sharing!
Dokku is still actively maintained/developed. Dokku-alt [seems dead or abandoned](https://github.com/dokku-alt/dokku-alt/issues/268). Dokku seems like it has added features and fixes for most of the functionality of the alt fork, except things like the web interface.
you are assigning the index of k starting at 1 and not zero inside your each block for one. This is why you have a length of 65 on your array. You might want to change the index to k[x - 1] *pseudo code not sure if that answers your question.
When you call `Enumerable#each` the value is passed into the block, not the index. So, you never change `k[0]` because the first value passed into the block is `1` based on the range `(1..64)`. This is also why `k` is longer, you're adding an element to it. What you're trying to do is something like: `k = (1..64).map { |x| (2**32 * Math.sin(x).abs).floor }` or `k = (0..63).map { |x| (2**32 * Math.sin(x).abs).floor }` As I'm not really sure what the end game is. 
When you do K.each { |x| k[x] # ... you're using the *values* of K as offsets into k. In other words, the unrolled loop looks something like: k[1] = ((2**32) * (Math.sin(1)).abs).floor k[2] = ((2**32) * (Math.sin(2)).abs).floor k[3] = ((2**32) * (Math.sin(3)).abs).floor # ... k[64] = ((2**32) * (Math.sin(64)).abs).floor Because arrays in Ruby start at offset 0, offset 64 is the 65th element of the array, and you're leaving offset 0 unchanged (or undefined), so that's why the lengths are not equal and you have 1 (in the first example) or a nil (in the second example) as the first element. You could rewrite it like this: K.each { |x| k[x - 1] = ((2**32) * (Math.sin(x)).abs).floor } Or like this: K.each_with_index { |x, index| k[index] = ((2**32) * (Math.sin(x)).abs).floor } But this is probably most idiomatic: k = (1..64).map { |x| ((2**32) * (Math.sin(x)).abs).floor } Arrays in Julia start at offset 1, which is why that code works in Julia. A few other notes. You shouldn't use variables named in all capital letters (like K) because that indicates a constant in Ruby. Also, k = Array.new(K) creates a copy of K and stores it k, and it's not clear why you'd want to do that since you're building k on the next line. If you were trying to preallocate storage for k by writing Array.new(&lt;length&gt;), you don't need to do that in Ruby, and if you want to do it anyway, try Array.new(K.length) instead. Best of luck to you. UPDATE: Hi everyone, when I started writing this 10 minutes ago, there were no other comments on this thread, but after refreshing the thread I see that there are other comments from 30 minutes ago. So blame Reddit for some weird latency thing going on behind the scenes. :-p I wasn't trying to steal others' thunder. Thanks and sorry about that...
Wicked. Thanks for the input. I prefer "map" because it's shorter haha. I really dig the flexibility Ruby gives. 
&gt; Edit: Also map is an awesome method. Is this considered the "Ruby" way of altering a array like this? Yes, most collection transformations in Ruby are idiomatically handled with 'functional transforms' like `map`. I recommend taking a look at the `Enumerable` module which applies to most collections in Ruby (`Array`, `Hash`, `Set`, `Range`, etc): http://ruby-doc.org/core-2.2.3/Enumerable.html Particularly things like `each`, `map`, `flat_map`, `select`, `inject`, `each_with_object`, `each_with_index`, `each_slice`, etc can make life much easier.
Arrays also start with 1 in matlab as well ;) My mistake is so apparent and simple I feel stupid but I'm glad you guys are helpful and not brutal. I learned about enumerated#map today so. That's awesome. 
Most people come into a new programming language from somewhere else, so it's not uncommon to be confused by simple things like this. I'm glad we were able to help!
Sometimes it's a question of maintainability. It may not be difficult for one person to sit down one afternoon and figure out how to configure the server, but what if that person leaves your team and someone else has to take over but it has been a year since the server has been configured and tiny incremental and undocumented changes have been made to the configuration since the initial documentation was done and so on‚Ä¶ It's not difficult, but something like heroku is just easier. 
If you want to reference the other array you can use map.with_index This will ensure accuracy! K.map.with_index { |x, index| (2**32 * Math.sin(k[index]).abs).floor } But the simple map only solution works too. This way you can still keep the reference array as a reference. You could also just assign the result to a new variable modified_k = K.map.with_index { |x, index| (2**32 * Math.sin(k[index]).abs).floor } Now you can have access to the original (array / constant) as well as the modified array :) Or you can keep it simple and do: modified_k = K.map { |x| (2**32 * Math.sin(x).abs).floor } Hope this helps EDIT: Try this! k = [] 64.times { |x| k &lt;&lt; (2**32 * Math.sin(x).abs).floor } This shoves the modified numbers into an array that you can now iterate through :) So k now equals: [0, 3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259] Now if you don't want 0 to be the first element, you can now do "65 times {}" and then do: k.shift This will "pop" the first element out :) So nowwwwww (bare with me): k = [] 65.times { |x| k &lt;&lt; (2**32 * Math.sin(x).abs).floor } k.shift Now! k is equal to: [3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745] Sorry for the huge wall of text lol But now you don't need the for loop. You will still have (1..64) modified. You can just use .times {} and limit how long the loop runs :) 
Awesome! 
You are welcome! Check out my new update. I have made some changes! 
If your [colorname] begins with a capital letter, then you could use: lcd.backlight("Adafruit::LCD::Char16x2::#{colorname}".constantize) If it's lower-case, like a method name, then constantize won't work. You would probably need to do something like this: case colorname when 'blue' lcd.backlight(Adafruit::LCD::Char16x2::blue) when 'green' lcd.backlight(Adafruit::LCD::Char16x2::green) . . . end 
[colorname] is in all caps, I'll give it a go!
My $anything. Hate. 
It's not necessary hard, but it's one more moving part, one more server, to worry about. One more thing that demands a slice of your energy/attention pie, one more thing that might take up your Saturday (or worse) when it goes wrong or needs maintenance. One app on one server is bearable. But once you start accumulating projects and servers, you might find yourself in a place where it makes sense to outsource your operations so that it's off your plate. Cleaning your house and mowing your lawn aren't insanely difficult either, but that's not why people hire those tasks out.
Ah! I didn't actually knew that dokku-alt is nearly dead/abandoned. Thanks for bringing this to light.
:), thanks! I hope it was better..
1. Yes, I messed up. I really should have completed the talk in 25 minutes or so. I just kept talking some nonsense. 2. Event was a tech gathering we do every month. There was an intro to Ruby talk, which was very well received, and they asked me to do a follow up talk. I chose this topic. Only ~20 people turned up, for an event that typically manage to get ~50. 3. Ruby is a language with an explicit design goal of maximising developer happiness. In addition to being a very warm/supportive community, the language is very versatile. It can be used build mobile apps, web fronted/backend &amp; desktop apps. Finally the language is pretty user friendly that it has inspired some really promising languages like Crystal &amp; Elixir. 4. Yes, I will try to improve the slides to add content to make it self standing. 5. Yes, I shouldn't have missed it. I accept it was my mistake, will do a better proof reading from next time.
As in?
`constantize` is a method provided by Rails (ActiveSupport), not Ruby.
I'm a little confused about exactly what you're asking, so I'll answer the question I think you're trying to ask: "I want to test that I'm processing the output of a command line application properly, but I don't want to run the application in my test environment." The answer to that question is to separate the data gathering from the processing, then test that the processing works with some canned data. Ruby is so flexible that there's no one correct way to do this, but I can provide an example. Let's say you have some code like this: class DataProcessor def self.process_data %x[foobar].split("\n").map do |line| # process each line of the output line.reverse end end end With your code coupled like this it is hard to test. If you change your code to look something like this: class DataProcessor def self.process_data data=gather_data data.map do |line| line.reverse end end def self.gather_data %x[foobar].split("\n") end end Now you can write some tests: require 'minitest/autorun' describe DataProcessor do it "returns properly processed data" do expected = %w[ tacos nachos ] actual = DataProcessor.process_data %w[ socat sohcan ] assert_equal expected, actual end end 
Personally, I'd rather hate languages with 1-based indexing than those with sigils that indicate what type a variable is. 
You could try some libraries from MicroRb.com
To me ERB made sense once I started seeing it as a Mad Lib. Start with really simple things like only using ERB bindings for single variable interpolation of an object's attributes, then build with loops and such. Manually type out all the options in a drop down for example and replace each with some ERB option, then build to the options_from_collection_for_select stuff. 
It's not so much the sigil but using a reserved word to identify a variable and then a sigil to declare the variable type. That seems redundant. And arrays starting at ones makes sense because we're human and can't fill any position 0 with something. You can call something position 0 but it's definitely not intuitive to our understanding of space and zero. It's easier and faster to understand that 1:64 is 64 positions then 0:63 being 64 positions. Just because you are used to a type system doesn't mean it makes sense and doesn't mean everyone has to like it. And nobody likes decrypting the gibberish in perl files. It's almost like reading brainfuck. 
Thank you. The output is not huge, but longer than I'd want to try to type in. Could be about 1000 lines. I have sample output in a text file. I'd really like to replace system 'foobar' with a script that just does 'cat sampleoutput'. 
If you have the sample data in a text file you can just have ruby use that in your test, there's no reason to muck about with command line stuff at that point. 
Can't think of one. If you want to build one and post a link to the repo, I'll help out!
&gt; If you want to reference the other array you can use map.with_index Or just use `Enumerable#zip` a = (1..4).to_a b = (5..8).to_a puts a.zip(b).map{|(l, r)| l + r} Death to all unnecessary index variables :P
Be more specific. Which parts are you having trouble with?
`my`/`our` and the sigils serve two totally different purposes. One specifies scope and the other specifies type of variable. RE: 0- vs 1-based numbering -- read [this](http://python-history.blogspot.com/2013/10/why-python-uses-0-based-indexing.html?m=1) I love this comment from that post: &gt; To anyone who prefers 1-based indexing: you are the same people who screwed up the calendar, starting at year 1 and calling the 1900s the 20th century (and arguing that the year 2001 ought to be the start of the next millennium). Haven't you done enough damage? :-) Seems to me that you are just hating what you don't know. 
Seems to me like your taking things way too seriously. 
Thanks for all the support!
I think I get it! ... So a binding is sort of like say a portal that beams the variables from the context to the template/basically connects the template to the context (at the point of the binding)? If that is true, then is the context (execution context) always a Class? What are the possible execution contexts? I think something that stood in the way of my understanding here is the nomenclature. It's called a Binding, but I'm not really sure to what other thing called a Binding this refers. Is it as if to say, that this literally binds the context to the template. I see this used also in binding.pry. &gt;But you could also pass in a binding that was created somewhere else and passed around, it's flexible. What would it look like to bring in a binding made in another context than the one that the template is executed in?
The other thing you can put in there is the binding of another class - the article you linked has an example of that immediately above the "Running ERB in a Sandbox" heading. The difference between calling it with no arguments vs calling it with a binding is just the difference in what variables the template uses.
Everything, really. I'm not sure I understand how it all interacts. I have the pieces .. The server, passenger, and code .. But how exactly does it work? Like I said, I've never used Ruby and I'm not quite sure how the code works. 
[Presentation slides](https://docs.google.com/presentation/d/12bTdNvRrAbfFLe03r4lUY2g12nuveNYaJeC9szCN2uQ)
[removed]
If you don't understand how it works, I'd suggest doing a Rails tutorial. Michael Hartl would be most people's recommendation. I'd start there.
I'm gonna check out Redd. If it doesn't fit my needs I'll probably build one then. ;)
I wasn't aware to the fact that class method can not be private? private self.my_method; # Code end This will not work? Also - "If you do have classes without any state, then it's probably more idiomatic to use modules instead to highlight that they're stateless". To my understanding, Modules are useful when you want to mixin similar behavior between instance. Let's say I have few methods in a module that handle files (copying, moving, deleting etc). Why would I want to mix them them all into an instance? this instance only need to access the `copy` method. Adding `move` and `delete` to an instance that doesn't use those sounds like a bad idea? Wouldn't it be preferred to self the above method and just call the specific one when I need it?
cool
Do you know any other languages? I have a [subset validator](https://github.com/yez/validates_subset) that needs some new local .yml files. Also, if you'd like to find smaller projects to take on, check out [code triage](http://codetriage.com). Sort the projects by Ruby then go to the last few pages (they are sorted in number of issues desc).
Most programmers will break down methods into smaller ones to appease a metric tool, but the codebase won't be measurably better because of this. Having many small methods isn't inherently virtuous, and the additional "readability" isn't an important factor in the quality of the code as many people presume. SRP isn't about rearranging code into smaller pieces, it's about untangling complexity. Generally, when a tool tells you that you broke the build by introducing a long method, appeasing the tool with a few extract methods is orders of magnitude easier than rethinking the design to make it simpler. So what you get with relying on static code analysis to drive design improvements is a differently arranged mess.
&gt; This will not work? No that doesn't work, you need to use the `class &lt;&lt; self` version of defining class methods to make them private. &gt; To my understanding, Modules are useful when you want to mixin similar behavior between instance. That is one use of Modules, another is as libraries of stateless utility functions. Ask yourself the questions 'would I ever create an instance of this thing?' and 'does this thing have any state associated with it?'. If the answer is no, it should probably be a module. 
Ermm? I was sure you HAVE to mix in a module in order to use it? the above example return an error for me: `undefined method "some_util_method" for Context::Utils:Module`
I think he meant `def self.some_util_method`.
Oops, should have been `self.some_util_method` Module 'mixins' are a convenience feature for adding the functionality of a module to a class/module. Actually `Class` inherits from `Module`, that is a `Class` is a `Module`. At it's core, a `Module` is just a container for other constructs. `Class` is just a `Module` that can be instantiated. Remember that everything in Ruby is just an object, that includes classes and modules. module MyStuff class MyThing def self.hi 'hi' end def instance_hi 'instance hi' end end def self.my_hi_helper 'hi helper' end end MyStuff.my_hi_helper =&gt; 'hi helper' MyStuff::MyThing.hi =&gt; 'hi' my_instance = MyStuff::MyThing.new my_instance.instance_hi =&gt; 'instance hi' 
Class methods are basically global, so it makes various "dependency injection" techniques (which is really just another term for "making use of polymorphism") impossible. Like if some objects somewhere will need a different version of the utility methods, there's no good way to give them it, or switch it at run-time, because the class methods are accessed globally as `SomeModuleOrClass.method` instead of from an object available in the local context, which can be switched to a different object with the same API in circumstances where it's required. I think that's the main downside. But I still use class methods for stateless utility methods like that, all the time. 
you welcome
[removed]
They're wrong about class &lt;&lt; self being the only way, see my reply to them in your comment's parent. Also, bear in mind that you can use any object as a method utility in that way. Utility classes/modules are really just constant references to objects utilizing singleton methods. class UtilityClass # A bunch of singleton methods. end # is the same as UtilityObject = Object.new UtilityObject.singleton_class.class_eval do # a bunch of utility methods end You can even write code to dynamically [decorate](https://en.wikipedia.org/wiki/Decorator_pattern) and undecorate objects during runtime as needed. Further, the singleton classes of objects have their own instance variables and can have attr_accessor type methods defined within them. It's not really necessary to pollute your global namespace with utility classes, you can localize it to the scope in which it will be used.
I am working my way through several Ruby tutorials, I just had a need to get this quickly. I had to jump ahead, unfortunately, which is why I needed a bit of help. Thanks though! :)
[removed]
Absolutely. You could start with a framework like Rails or a micro-framework like Sinatra. At its simplest you might only have a single model, questions... An image really, with an answer... That is presented as a button along with three other answers to other "questions" or flag pairings... Clicking the choice right or wrong posts the user's answer, generates feedback, presents the next question. From that simple first step you could make it more complex by handling administration of quizzes, different types of questions.
Thank you for the quick response! And yes, I am only going to do that one quiz for the project since the presentation can't be more than 10 minutes and I also have to present other stuff. The project itself is due on Thursday so I have a few days to work on it. I've already done some research on the basics of Ruby as I have to also write a paper on the language. Do you have any recommended sources that would possibly help me get started in the right direction?
I would stick with Rails because you'll find more documentation to help you out. Look at their guides on using generators and scaffolding to get the basic create, read, update, destroying of records working... Then look at creating a controller just for answering the questions. Using paperclip for uploading images and implementing login for administration with Devise and access control with CanCan or any of the access control libraries that have been forked from it... That would make a good round project. Also consider that even if the project itself has very simple functionality, you could raise the level of sophistication in your project by testing the application well.
I've added an update, if you wouldn't mind taking a look since you seem to have the most suggestions of any one so far. I can understand how you would imagine that he wouldn't just say "oh books is undefined." When I asked him about the grade originally, the conversation was "I don't see how this can possibly work, let's talk after class." When we spoke after class he was packing up to leave and he simply reiterated that it just doesn't work; he asked me where books was defined and I said I thought it was going through ActiveRecord. I said "it works for me," and he replied "well it shouldn't" without an explanation as to what specifically was wrong. Verbatim. After reexamining my code and still not seeing anything glaringly wrong, I checked with a rubyist I know (who agreed that it looks okay), and then posted here because the more eyes the better, right? The assignment in question is from my 5th week in a beginning Ruby class. Week 6's assignment built on assignment 5, so I received 1/3 for both assignments, dropping my grade to not passing despite having gotten 3/3 on everything else--adding to my frustration. From the teacher's most recent reply, which is a direct copy-paste from his message, I am still unsure of how to proceed in order to correct whatever is erroring on his end. Without correcting these two assignments, my grade likely won't be passing and I'll be unable to move on to the next course in this three-part series.
I've added an update and it's apparently not at all related to this, all though I thought it was a good guess. :/
This doesn't look like Ruby. 
It apparently doesn't have anything to do with this, I guess. I'm still not sure *what* the actual issue/error is, but I've updated the post if you're curious enough to look.
Isn't this just Tor being offered commercially with better curating of the exit nodes? What am I missing here?
I used `dependency injection` and `dependency inversion` while doing `.NET`, so this might be slightly off - but: &gt; "Like if some objects somewhere will need a different version of the utility methods, there's no good way to give them it, or switch it at run-time, because the class methods are accessed globally as SomeModuleOrClass.method instead of from an object available in the local context" Wouldn't I have the same issues if I'll use a concrete instance? Instead of calling `SomeModuleOrClass.method`, I would have to call `SomeModuleOrClass.new.method`. If I understand it correctly, I can dependency invert it like so: module MyStuff extend self def print_log(service) service.write('hi) end end I inverted the dependency `service` as a parameter, and now I can inject a dependency. This can work on both instance and class methods I think?
Interesting, I wasn't aware of the define_method method and class_eval, I will do some more research about it. Thanks :) 
Wouldn't a bareword, being a method also carried down through inheritance?
That's a very good point. I came from a background of compiled language, so those concepts are a bit harder for me to adjust too, but your 100% right. But isn't using barewords a better option because it's not just an hard-coded string but a method you can change the implementation to? I'm mostly referring this example: http://devblog.avdi.org/2012/10/01/barewords/ Thanks!
In you own opinion, when it's a good time to use a constant versus just typing the string directly into the implementation? I'm trying to use a constant when two methods in the same class use the same string.
For background jobs Sidekiq is the most used I believe. Resque is also widely used, but Sidekiq 4 is very promising in terms of performance. About the scheduling part, you can either use a plugin for sidekiq (like sidekiq-scheduler), crons (linux native) or -in my case- rufus-scheduler.
Thank you! Glad you find it useful.
And for more crontab like task scheduling, the [whenever gem](https://github.com/javan/whenever).
Could you be more specific? `?includes=comments,activities` would be one way to do it.
As /u/Enumerable_any said, it depends on the specifics, but off the top of my head, I'd be tempted to use postgresql and return the different subsets of data in a JSON field.
Thanks for this. My favorite is the safe navigation operator, seems like it could be pretty useful.
My feeling is that you shouldn't need to do what you're suggesting. The whole point of a REST API is to be client-independent. You don't care what the client is... you build the clients around the API. That being said, I might just make different routes/controllers for each case. Like, take the most common and have separate calls like `/user/1` and `/user_with_pets/1` and `/user_with_info/1` Anyway, just my 2 cents.
I'd recommend skipping this one. Eric Weinstien is clearly knowledgeable about the subject of Ruby Garbage Collection, but his general nervousness and the presentation structure make this a difficult watch. If you're interested in the topic, there are many other resources available, and if you're not, this presentation is not going to inspire you. [Slides](https://speakerdeck.com/ericqweinstein/the-hitchhikers-guide-to-ruby-gc) 
Presumably the clients have to authenticate/identify themselves somehow. Use that as a key to fetch the appropriate template.
It's also worth mentioning that structuring any program like this makes your life a lot easier when testing. Here you're just testing CLI output, but this technique is applicable to all kinds of stuff (API clients, database wrappers, etc).
Been waiting for this for a long time. Coffeescript's influence is being felt far and wide.
`hash.to_proc` is pretty sweet. You won't have to wrap a lookup table in a function every time.
Questions? Comments?
How is this listed as a "medium" severity bug, just off the top of my head I can come up with more than a handful of attacks that would be catastrophic against usual and customary installs.
 - Vulnerabilities are labeled "Low" severity if they have a CVSS base score of 0.0-3.9. - Vulnerabilities will be labeled "Medium" severity if they have a base CVSS score of 4.0-6.9. - Vulnerabilities will be labeled "High" severity if they have a CVSS base score of 7.0-10.0. These scores are typically calculated with this or similar: https://nvd.nist.gov/cvss.cfm?calculator&amp;version=2
Worth a watch. Andy Croll talks a bit about the increase in web page size over the last 5 years and gives some suggestions about how to make your pages smaller and faster by making sure you're serving appropriately sized images. The advice about making sure you're keeping your pages small is applicable whether you're running a small site from a single server, or a bigger CDN enabled service. There are some technical problems with the sound during the first minute or so of the introduction but they are fixed before he gets going into the full presentation. 
This code is confusing. Split the problem up into smaller parts that do one thing. Test that parts do what they should be doing individually. Connect them together. 
One of the nitpicks I have with his example and refile (as he mentions as a recomended starting point) is that both have the core idea that these image services are properly archetected as a open ended request with minimal verification and caching of the result. My very strong opinion is that it is indeed nice to have a flexible service to provide resizing of images but it is much better architecture to whitelist sizes and tightly couple backing cache for the resizes. CDN or not, with open ended resize paths like these it is entirely too easy to construct CPU/memory bound DoS against the service just by flipping sizing digits and or images. If you are fronted by a CDN, you are not protected as CDNs do not offer unlimited cache space for these requests -- a crafted attack will force the CDN cache to burst and fall back to the service. Refile had placed a mind boggling checksum option in the image url to "verify" that the request url was generated on the application to help alleviate some of this issue. I view that as a way overly complicated construct that just pushes the problem out of sight. It seems like a much better solution to store a sizing whitelist that is coupled to a cache store. This way your service urls are naturally limited to sizing that is known and tested (but still flexible enough to dynamically add or remove sizing) and the backing cache removes the CPU/memory overhead for re-resizing the images on a CDN blown cache request (or a crafted DoS hammer). I guess it is a matter of preference, I like to have a known and defined set of options to whitelist where possible instead of an open set that is much harder to blacklist or defend against. Edited to add: Re CDNs, all CDNs are not equal by any means; I have used most of the 10 biggest CDN providors over the years on multiple different projects and some even with highly cachable and static small set origins burst out and send way too many requests back to the origin. Some of the cheaper and fast to market services (for instance AWS CloudFront) appear to offer very poor cache stability even on high connection/low size assets. In one case I was seeing almost 75% of cache misses (and regather from origin) on AWS vs 99% cache hit on akamai. 
Wow, how underwhelming. A law of demeter violator operator and a couple other things that encourage bad code. Frozen strings seem cool, but it's weird to enforce immutability on just one type.
why don't you just have the client retrieve the json and leave out what it doesn't need? have your server ship everything a client might need, then let your client figure out what to use.
This announcement does not say which Passenger version(s) are patched, and the CVE itself seems to still be private. Poor form. There's a reason CVE's always list exactly what versions you need to upgrade to in order to patch. For instance, from this blog post we have no idea if a patched Passenger 4.x is going to be made available, or only 5. We have no easy way to check our machine (manually or automated) to see if it has a vulnerable version or not. We have to go look at what versions of Passenger have been released, and guess as to what versions released on what dates are probably post-patch. 
Dig looks pretty cool! No more checking for existence before accessing nested hashes. Sure, there are other ways, but this is real clean. 
Fixed in Passenger 5.0.22, 4.0.60
It's a type that's not mutable in many other languages (e.g. Javascript, Java, Python), so from that perspective it is a bit weird that it is mutable in Ruby.
You have access to all rules. You can display all information to the user. There's no convenient api for that yet but it will added in the next version. I call it "validation hints" instead of "error messages". In fact I want to experiment with a smart way of providing those hints by optimizing rule tree and rejecting rules that are not relevant. ie when an email is blank and it must match a regex it is sufficient to display information that "an email must have a valid email format" rather than "email cannot be blank" and then info about format because format expectation implies that it cannot be blank. In general displaying errors and info about rules are two similar but separate problems to solve. Sorry for the confusion btw. I should've explained this better in my post. Hope it's clearer now.
There's also the new "squiggly" heredocs: https://github.com/ruby/ruby/commit/9a28a29b870b5f45d370bc8f16c431b435f0bbb3
You should write a PoC exploit and show us :) I think this would only impact apps that rely on configuration specific handling of headers. Most rack applications simply filter/consume the headers that Passenger already passes them.
Yeah that is exciting. I was at one point coding in both Ruby and Groovy and I preferred Ruby but I really missed that safety operator.
It does however makes it easier for InfoSec people to assess just how widespread certain software and versions still are.
What other languages do should be irrelevant.
It says at the bottom that it's fixed in 4.0.60 and 5.0.22. The implication being that all other versions are affected. But I'll add the information explicitly. As for the CVE being private: that's not something we control. We were told that it would be made public on Monday. The SUSE bug tracker issue was made public on Monday though.
&gt; { a: 1 } &lt;= { a: 2 } = false { a: 2 } &lt;= { a: 1 } = false "Just like integers"
I've also mixed feelings of the forthcoming changes. I'd think more then twice before adding another core language feature, just for the sake of removing "boilerplate", like the AS's `.try` like operator. The other side of the coin is growing complexity, which would take its toll. And they should do it right, not ignoring `nil` object also responds to its methods. I'd be also interested in real world gains of making strings immutable by default. First, String unlike Symbol is quite complex object, esp. with all the stuff for unicode support. Second, most of string altering operations would require very smart persistent-like data structure implementation to prevent great performances loss contrary to mutable ones. Quick bench. in current CRuby 2.2.3 reveals about 70% slower `#upcase` with an assignment vs. direct `#upcase!`. Memory savings are also questionable. How frequent is coping with same strings in recent Rails based app ? Third, moving to a new CRuby 3 would require massive rewrite of existing codebase. Issues with adoption of Python3 is notoriously known deterrent example.
You can do this with Ruby, but understand that you're not going to get javascript / single-page-app stuff out the box. Rails will do it quickly though. 
It would make static hash table lookups faster. At the moment, if you write `foo['key']`, that's a new String being allocated on the heap right there even though there is no need to. In Passenger, we work around this (and reduce GC stress) by assigning those strings to constants and using constants to lookup hash tables, like this: FOO = 'foo' hash[FOO] But this is far from ideal, and introduces constant lookup overhead. With immutable strings, Passenger would become slightly faster.
Is direct use of string literals as keys really frequent ? I'd bet more common is use of variables, or occasionaly constants. Then it would not matter if an instance/class variable or a frozen string literal being used, performance- and memory-usage-wise. Btw. it may become so usual (mis)use symbols as keys for such demands. Since CRuby 2.2 they are also garbage collected.
Coping with the same strings is actually *very* common as that is what happens when you render views..
&gt; Constants are lexical Can you please explain what you mean about it?
Good point. I thank you for investing your morning thinking with me, cheers! :)
`module_function` is another approach. I'm not really a fan of it but if you want to see what it looks like and how to use it in practice check out FileUtils from the stdlib: https://github.com/ruby/ruby/blob/trunk/lib/fileutils.rb Note the definition of `self.private_module_function` at the top, this is how they are dealing with creating private module class methods.
Thanks! will check it out :)
 class A X = 10 class B def hello # lexical lookup of X X end end end 
Everything is off by 1, so I'm guessing the replacement string is evaluated before the matcher is applied. EDIT: So you could do like this? steps.map do |step| step =~ /(.+) -&gt; (\w+)/ "#$2 = #$1" end You're replacing the whole thing, so gsub is sort of misleading anyway in my opinion.
This is due to gsub. From [the docs](http://ruby-doc.org/core-2.2.3/String.html#method-i-gsub) &gt; However, within replacement the special match variables, such as $&amp;, will not refer to the current match. Two ways to fix it. Use `\1` and `\2` instead of `$1` and `$2` (note the single quotes): `steps.map {|cmd| cmd.gsub /(.+) -&gt; (\w+)/, '\2 = \1'}` Use the block syntax of gsub. Inside the block `$1` and `$2` are assigned as expected: `steps.map {|cmd| cmd.gsub(/(.+) -&gt; (\w+)/) { "#$2 = #$1"} }` Both output the same: [ "x = 123", "y = 456", "d = x AND y", "e = x OR y", "f = x LSHIFT 2", "g = y RSHIFT 2", "h = NOT x", "i = NOT y" ] 
Appreciate the response, but the =~ operator doesn't take two args like gsub does, and =~ returns the position (fixnum) of where the first match happens. =~ is not appropriate for replacement, that's what gsub is for. &gt; You're replacing the whole thing, so gsub is sort of misleading anyway in my opinion. Why you do say that? What are other ways you use to replace text according to a pattern?
Convenient that the caveat is mid-block. Thanks for following up!
Any chance for Spinach support? :D
Will this work with saucelabs? 
There are also a couple open pull requests on test-queue that make the stats moot for rspec, since they allow example groups to be split up across runners (full disclosure, I wrote one of the PRs). What's nice about that is you never have to worry about syncing/regenerating stats; your tests will *always* be optimally distributed, since all runners will keep working from the queue until it's empty.
&gt; The problem is that `some_array += another_array` creates a new array instead of changing the original array that you passed in This confused me when I read it at first, because we can show this behavior: irb(main):001:0&gt; foo = [:foo] =&gt; [:foo] irb(main):002:0&gt; foo += [:bar] =&gt; [:foo, :bar] irb(main):003:0&gt; foo =&gt; [:foo, :bar] So I think it's worth expanding. With Ruby's whole "everything is a reference" thing, this can be surprising behavior (it was for me for a second, and I do this every day). The problem is when we think of the `+=` operator as a concatenation operator, when really it's a shorthand assignment operator. &gt; some_array += some_other_array is really shorthand for &gt; some_array = some_array + some_other_array Which clarifies why OP's original code didn't work: `+=` doesn't modify the `some_array` object in-place, rather it *re-assigns to the same variable name*. We would certainly expect `some_array + some_other_array` to generate a new `Array` instance, and that's exactly the behavior we get when we use the shorthand `+=` operator. [](/GNU Terry Pratchett)
It should. If you want to split tests across 2 VMs then you should run each of the command on proper VM. # First VM KNAPSACK_PRO_TEST_SUITE_TOKEN_RSPEC=xyz KNAPSACK_PRO_CI_NODE_TOTAL=2 KNAPSACK_PRO_CI_NODE_INDEX=0 bundle exec rake knapsack_pro:rspec # Second VM KNAPSACK_PRO_TEST_SUITE_TOKEN_RSPEC=xyz KNAPSACK_PRO_CI_NODE_TOTAL=2 KNAPSACK_PRO_CI_NODE_INDEX=1 bundle exec rake knapsack_pro:rspec I didn't try it yet but I'd like to learn more and see your feedback. 
It looks very similar as Cucumber. I'm going to add support for it. How long your test suite is? Do you do parallelisation, for how many CI nodes? Please drop me email so I will let you know once Spinach support will be available.
Interesting, I didn't know that. Thanks!
The idea with queue seems to be nice, I read a while a go about similar solution in Stripe https://stripe.com/blog/distributed-ruby-testing I was wondering about adding queue in next version of knapsack_pro. I didn't try test-queue gem but it looks similar as you said. 
Interesting idea. I guess this would make collecting test runtime data easier for distributed setups. It's also possible in several other distributed test runners such as https://github.com/cookpad/rrrspec and https://github.com/grosser/parallel_tests. I do think this static reporting/regrouping approach is dated and flawed. You can get better balancing without as much work with a test queue approach like https://github.com/tmm1/test-queue and https://stripe.com/blog/distributed-ruby-testing The latter link has an especially good writeup about this: &gt; One tactic for splitting work‚Äîused by several of our previous test runners‚Äîis to split tests up statically. You decide ahead of time which workers will run which tests, and then each worker just runs those tests start-to-finish. A simple version of this strategy just hashes each test and take the result modulo the number of workers; Sophisticated versions can record how long each test took, and try to divide tests into group of equal total runtime. &gt; &gt; The problem with static allocations is that they‚Äôre extremely prone to stragglers. If you guess wrong about how long tests will take, or if one server is briefly slow for whatever reason, it‚Äôs very easy for one job to finish far after all the others, which means slower, less efficient, tests. &gt; &gt; We opted for an alternate, dynamic approach, which allocates work in real-time using a work queue. We manage all coordination between workers using an nsqd instance. nsq is a super-simple queue that was developed at Bit.ly; we already use it in a few other places, so it was natural to adopt here.
Try the win32-service gem. See http://abstractcoder.com/2013/07/18/create-a-windows-service-with-ruby-part-1.html
Thanks, I'll give this a read. It looks to be an approach along the same lines as I was thinking, albeit a bit more formalised.
Your code is pretty much spread all over the place (which is ok considering the repo is only solutions for HackerRank), but even if you want to stick to functional or OOP (I don't want to start a holy war here), there is a minimum requirement for functions and classes/modules if you wanna get those algorithms used by anyone in the future, even if it is yourself. So, if you're writing caesar_cipher.rb you can do something like: def caesar_cipher(word) &lt;algorithm in here&gt; end puts caesar_cipher("any word you like") -- Independently of the how fast your code is, at least you have a function that you can already use in the future. I'll leave up to you if you wanna wrap that function in a class/module that also contains all your other algorithms that you can later require/include/extend in other projects. -- Regarding the code itself, I notice that you play around with method chaining too much, i.e: lowercase_hash = Hash[lowercase.zip(lowercase.rotate(rotate_count))] -- Everyone loves one-liners because they push the envelope a little further, but for newcomers I always recommend separating their code in different lines per step of the logic, so in Ruby is ok to maybe do something like: some_var = lowercase.zip(lowercase.rotate(rotate_count)) Hash[some_var] That way is easier to read in a step-by-step way. Regarding some other tips: 1. Change `for..in` statements and use `.each`, i.e: for i in (0...n) do diag1 += matrix[i][i] end becomes: (0..n).each do |i| diag1 += matrix[i][i] end 2. Ruby has a [Matrix](http://ruby-doc.org/stdlib-2.0.0/libdoc/matrix/rdoc/Matrix.html) class embedded in the StdLib, you might want to check that. 3. Read about loops using `loop..do`, `until..do`, `begin..rescue`, etc... -- Overall, I don't want to give a full explanation about every little detail, but that's a good place to start and while at it, also check the basic syntax documentation for Ruby. Looks like you just dived into the code without reading too much about the basics, which is not a bad thing, but if your intentions are to write idiomatic Ruby, then you _should_ at least consider reading the basic syntax. Recommended reading, sites and etc: - The one and only [why's poignant guide to Ruby](http://poignant.guide/) - [Ruby Koans](http://rubykoans.com/), very good for practicing the basics and learning the TDD mentality at the same time. - [Exercism](http://exercism.io/) is a very nice site to get your code reviewed and commented in an open minded non-by-the-book way. - Also another very good read is [POODR](http://www.sandimetz.com/products), which is not really good only for Ruby, but also for your programming skills in general. -- Meh, that's my 2 cents... I always try to avoid making comments in these situations because it usually leads to confrontational arguments like _"No!. He should read this instead"_ or _"What he said is crap, this is better because I've been coding in Ruby for ~10 years"_. Hopefully you will check these things with an open mind and also hopefully you'll get to absorb some of the Ruby community spirit, which has been named as **[MINASWAN](https://en.wikipedia.org/wiki/MINASWAN)**. -- Welcome to the community and Cheers! 
Well, a good thing about Ruby is that you definitively don't have to. Everyone loves Ruby because it's flexibility and that's a very good thing, but another thing is to go the whole opposite way and do way too much structure. I think that when it comes to algorithm implementation, taking the functional way is a little more cleaner and implies less overhead, but using OOP is really wonderful in Ruby also.
There's not really a solution that puts everything into a single executable. Those that do, simply extract all the files into a temporary folder, then run it. You can do the same with NSIS (http://nsis.sourceforge.net/) for example. This just solves packaging and delivery. If distributing a folder-worth of files works for you (with or without a packaging system), then all that's left to do is include the ruby "installation" folder into that folder along with your application scripts. Then run the ruby.exe from within that folder. Since this is a server, you will want to set it up to run as a Windows service. I have used nssm for this with great success: https://nssm.cc/ Best of luck!
This worked beautifully. But in response to your explanation, wouldn't the "@" designation make the variable usable/modifiable for all methods in the program? You say that "some_array += another_array creates a new array instead of changing the original". How can a duplicate of some_array exist when @some_array is considered a universal variable within the confines of the class? 
I also asked this to the poster above, but why would the += operator reassign to the same variable name in this case? I would understand how a non-instance variable would be reassigned, as the variable's life ends where the method ends, but in this specific example, I brought in a class instance variable (@), so a duplicate would not really apply to anything outside of the method that it is in, and not only that, it would conflict with a variable of the same name that is brought into the method, correct?
&gt; I would understand how a non-instance variable would be reassigned We ARE dealing with a local variable here, though: `some_array`. If your code read: def hit @my_hand += [@shoe.shift] end That would have the behavior you're talking about. In your real code, you pass the instance variable in as the argument to `#hit`. Everything is passed by reference in Ruby. This means that what is actually stored in the name `@my_hand` is a reference to the `Array` instance. When you call `hit(@my_hand)`, what you pass is the reference; `hit` then receives that reference and binds it to the new, locally-scoped name `some_array`. That name has no knowledge of the fact that the object that it references also happens to be bound to an instance variable elsewhere. Now, at this point, so long as you're mutating the object that `some_array` refers to in-place, you're fine, because `@my_hand` still references that object. That is, at this point, the names `some_array` and `@my_hand` reference the same exact object, so a change in place to that object will be equally accessible from both names. However, if you change the object that `some_array` references, `@my_hand` will still be referencing the old object, and thus changes to the new object referenced by `some_array` will not be visible at the name `@my_hand`. I hope this helps. I know I haven't written this in the most linear way possible, I haven't had my morning coffee yet. Right now it sounds like you're just a little unclear on precisely how Ruby's pass-by-reference mechanism works, so if I haven't clarified sufficiently for you, that's the thing you should be Googling for more info. Please let me know if you have any more questions! [](/GNU Terry Pratchett)
My pleasure! Glad we could help :-) For what it's worth, [The Pickaxe Book](http://ruby-doc.com/docs/ProgrammingRuby/) is where I learned basically all the fundamentals, so if you don't have a copy, it'd be worth picking up. [](/GNU Terry Pratchett)
The URL seems to have changed :( https://youtu.be/zaql_NwlO18
How so? Both MRuby and crystal are compiled, have ruby-like syntax, and have speeds closer to C's performance. Lua can be compiled and has better performance than ruby, but the same can be said about many languages.
There is a great TopTal article about multi-threading in ruby: http://www.toptal.com/ruby/ruby-concurrency-and-parallelism-a-practical-primer
Is there a particular reason you want to use threads over any other concurrency primitive? The concurrent-ruby gem (https://github.com/ruby-concurrency/concurrent-ruby) provides a lot of other ways of doing both concurrency and parallelism that are often easier to use, such as promises, futures, dataflow, transactional memory, actors, etc. If you already have a problem you want to solve join us in Gitter (https://gitter.im/ruby-concurrency/concurrent-ruby) and tells us what you are trying to achieve.
[MRuby](https://github.com/mruby/mruby#what-is-mruby) and [Lua](http://www.lua.org/about.html) both are designed around embedding into applications. Crystal is build around generating binaries.
M'ruby
This is a great book http://www.jstorimer.com/products/working-with-ruby-threads As others note, threads are very low level. You'd be better served learning higher level, safer constructs.
&gt; Is there a particular reason you want to use threads over any other concurrency primitive? The concurrent-ruby gem provides a lot of other ways of doing both concurrency and parallelism that are often easier to use, such as promises, futures, dataflow, transactional memory, actors, etc. Just to clarify: This sounds like futures are a complete replacement for threads, but futures use threads as the lower level building block. Thanks for your work on concurrent-ruby. It made my life less painful (and more painful at the same time thanks to Rails' autoloading...)
Those controllers are in some serious need of test coverage and refactoring.
What I meant by bugging out was that it just gives me a syntax highlight. I'm still learning, so I'm really trying to learn property syntax at the same time. As to your and vsalikhov's fixes of just using "outcome" it works great, thank you!
It's still proper syntax, but RubyMine will flag things not considered best practices, such as not using implicit return. 
is just stating the variable considered a better practice in ruby?
Yes. The last value is always the thing being returned, so adding the unnecessary return adds noise. Plus, when you do see a return somewhere it tends to stick out, and you know someone *really* means it.
MRuby is embeddable. For a C code base (like H2O), MRuby is just a library to include. Have a look at [this file](https://github.com/h2o/h2o/blob/a5723300a011307b158e80f63845275a6093d061/lib/handler/configurator/mruby.c#L28), it includes `&lt;mruby.h&gt;` to use it in C code. Crystal is not designed for this purpose. Yes, it's compiled, but it generates standalone executables.
looks really nice. :D
Yea, because ruby will return the last line of a method anyway, so the return keyword is redundant. 
It is possible to compile crystal to libraries as well, though I admit that I don't really know how easy it is to call them from C. You are totally correct in that crystal and mruby solve totally different problems though.
Another alternative would be: def get_data @user.profiles.each_with_object([]) do |x,outcome| Report.results(x, :start_date =&gt; @start_date, :end_date =&gt; @end_date, :sampling_level =&gt; 'HIGHER_PRECISION').each do |results| outcome &lt;&lt; results.to_h end end end
 some_var = lowercase.zip(lowercase.rotate(rotate_count)) Hash[some_var] Take it one step further and move small things like this into methods: def rotate_and_lower(rotate_count) lowercase.zip(lowercase.rotate(rotate_count)) end Hash[rotate_and_lower(rotate_count)] If you choose a good name for that method, it makes the code really clear. Furthermore, when you get into more object orientation, these helper methods can be moved into private methods. If you accumulate many methods that all take the same parameters, you have an indication that you have a class/object to write, and thus move those params to instance variables. 
I'm sure there are people that can tell you on a high level why, but if we knew why on a granular level, then people would be out there fixing the issues. Some people are predicting that frozen (immutable by default) strings will help speed things up. But, the biggest reason is that Ruby doesn't get a lot of attention from big companies. I think the most apt comparison would be JavaScript, rather than python. There's a bunch of people out at Mozilla, Google, Microsoft, etc trying new techniques to make it a faster language. The one significant technical feature that you hear a lot about is that JS runs in its own VM. Matz has been experimenting with the idea and that's became mruby.
&gt; Some people are predicting that frozen (immutable by default) strings will help speed things up. But this program doesn't use any strings.
&gt; The one significant technical feature that you hear a lot about is that JS runs in its own VM. And by the way, I might be wrong, but JRuby is implemented in Java so it runs on the JVM right? It does speed it up a but, but it's still about 4000% slower than js or cpp (in this example).
But JVM is designed for Java, and the V8 VM is designed for JS. So there has in the past been an impedance mismatch when you try to shoe-horn Ruby onto the JVM.
You should check out [rubocop](https://github.com/bbatsov/rubocop), which is a code linter that will give you all sorts of tips on how to improve your coding style. It would have told you this exact advice in seconds and is a great tool.
Ruby already has a virtual machine. Ruby 1.9 introduced YARV (Yet Another Ruby Virtualmachine) which is the virtual machine that Ruby has been using (since 2007). It was written by Koichi who was hired along with Matz and Nobu by Heroku. Koichi's main goal is to make Ruby faster. The virtual machine did make Ruby 1.9 much faster than 1.8. It also makes it easier to make new optimizations Mruby is an embeddable language that you can compile into another program. Similar to Lua. For example if you have a machine with no operating system but a C compiler can target it, then you can embed mruby into your c program and run mruby (which is a subset of Ruby) on it instead. mruby and Ruby have very little to do with one another other than syntax. One of the coolest projects i've seen for mruby is mruby-cli https://github.com/hone/mruby-cli. Let's say you want to provide a cli to your customers how do you do it? They are running linux, mac, and windows. With mruby-cli you can write your code once in mruby and then compile to multiple operating systems, then you just ship them a binary and it just works(TM). Immutable by default strings will help a little, but it won't get us close to javascript speed. It will help though and that's the kind of thing we need, millions of small performance bumps. I'm giving more detail about that in a response at the top level. 
C and C++ are statically typed, compiled languages. All sorts of optimizations can be done at compile time when you know exactly what sort of data will be there. JavaScript has had tons of money and brainpower poured into it because it is the web's front-end language, and as a result it is quite fast. Ruby was not designed with speed in mind, so it can't compete with languages that were. It also hasn't been heavily optimized like JavaScript has. I mean, it doesn't even have tail call optimization! The whole compilation to machine code thing is pretty clutch, too. Think about assigning a variable in C vs Ruby. In C, your int is however many bits (according to architecture), and those bits are put into the proper address. The compiler checked the syntax at compile-time and did all the type-checking to ensure that we don't try to do anything silly. It's just a couple opcodes. In Ruby, you have to allocate memory, check types, call := on the first object with the argument of the second object, and so on. Piles and piles of instructions to do what seems to b the very same thing on the surface. JavaScript is JIT compiled to bytecode and has been heavily optimized. For a fun experiment, write something like Conway's game of life in Ruby, and then slowly implement its functions in C via bindings. Start out with neighbor checking, and end with full-on creation of the successor state of the board. The increase in performance will blow your mind. In C, you're moving the data around. In Ruby, you're more of a data-conductor that tells Ruby itself what you want it to do, and its beauty, elegance, and ease of development come at a price. But now folks are focusing more on Ruby's speed, so hopefully we'll see a speed increase in the coming years!
Thanks for your response! You're absolutely right that my base function in ruby has some more complexity to it. I've just changed it be as similar as the other ones (eg using a while loop and incrementing the counter, I've posted it to github). It did make a big difference. I've benched it at ~ 30 000ms. Still a bunch slower though, the root of the issue has not yet been discovered IMO. Cheers!
&gt; I mean, it doesn't even have tail call optimization! This is false (http://nithinbekal.com/posts/ruby-tco/, didn't see official docs). In addition, javascript just got tail call optimization and the lack of tail call optimization has absolutely nothing to do with how optimized a language is. Besides that, I agree with your post.
I agree. I love ruby though and all the awesome gems, don't get me wrong. And for a big chunk of applications it's more than fast enough.
&gt; +1 for -O3. I'm amazed with the power. 0.07ms is crazy! Well, it's mostly because it's no longer really doing what you told it to, but rather doing an equivalent mathematical operation, which is pretty easy given what the code is doing. Here is the assembly generated with `-O3` for the line `for (long i = from; i &lt;= to; i++) { sum += i; }`. You'll notice there is no loop here, no jump of any kind. .loc 64 13 5 ## src/main.cpp:13:5 movq %rsi, %r9 subq %rdi, %r9 leaq 1(%rdi), %rcx imulq %r9, %rcx decq %rsi subq %rdi, %rsi movq %rsi, %rax mulq %r9 shldq $63, %rax, %rdx addq %rdi, %rcx addq %rdx, %rcx I didn't bother tracing exactly what this is doing but it looks like a variant of this algorithm: http://www.wikihow.com/Sum-the-Integers-from-1-to-N
&gt; So for every integer addition in your benchmark Ruby is also doing an overflow check which requires a compare and possible branch on the CPU. I don't think this is a limiting factor. We don't need a compare - as adding will already set a flag to say it overflowed. All it requires is a single `jo` instruction after the add. This can branch to some slow-path code to handle the overflow. The branch predictor will guess that branch correctly on the first execution (we would make it a forward branch to ensure that) and for every execution after that. I don't think it should have any significant impact on the pipeline at all. All it may do is take up space in i-cache and the decode pipeline. I would be surprised if you could even demonstrate a slowdown for having the `jo` instructions in there. I tried it once and couldn't.
Someone learning programming shouldn't start with assembly language. Start high level, learn the basics then dive deep.
Oh, that was just meant as a jab at Ruby - I totally agree that it's not really indicative of anything (other than TCO itself). Thanks for correcting me re: TCO in Ruby - I (obviously) had no idea it could be enabled.
You can always make code faster if you don't care about getting the right answer :)
We're getting there. I totally get what you are saying, but you introduced two things in this that I think can get me all the way there. The 'parse tree' and 'parse time'. Are these are built at run time from the top down? So if the code is: call_a_method_that_s_been_defined def new_method_1 as_yet_undefined_method end call_another_method_that_s_been_defined def as_yet_undefined_method "do a thing" end Is it correct that Ruby would: 1: run call_a_method_that_s_been_defined 2: parse/add to the parse tree new_method_1 3: (because it is in that method being parsed/added to the parse tree) parse/add to the parse tree as_yet_undefined_method 4: run call_another_method_that_s_been_defined Or is my because statement in #3 wrong? Meaning that it parses those methods at that point because it always parses all defined methods at once? Or do I have the order wrong? Really the simplified question is, when is the parse tree built? PS - thanks for sticking with me!!!! 
I maybe went off on a tangent. I actually think __all__ companies should at least try support open source. Many get caught up in the mindset that someone else (not them) should do it instead. Kinda the "someone should do something about this!" problem where most people don't realize that someone is them.
How do you reproduce that? I tried gcc 5.2 on: #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main(int argc, char** argv) { long from = atol(argv[1]); long to = atol(argv[2]); long sum = 0; for(long i=from; i&lt;=to; i++) { sum+=i; } printf("%ld\n", sum); } and: # gcc -O3 -S sum.c unrolls the loop but there's no `mul` in sight :(
['Tis the season.](http://adventofcode.com)
I had no idea Javascript was so fast.
If you think ruby is great for text processing you have never seen perl. Ruby can do text processing but perl breathes text processing. 
The parse tree is the first thing that is built, then your code is run. And there are subtly's to methods and definitions, I get where your coming from as to timing and scope. Ruby is highly dynamic, and methods, and classes and objects, can appear and disappear at any time. And methods can change definition at any time. Lets try an example that breaks at parse time puts "here" &gt;:dfhsdkjfh:&lt; Now this will throw an error at the parse stage $ ruby scope.rb scope.rb:2: syntax error, unexpected '&gt;', expecting end-of-input &gt;:fshkdfh:&lt; ^ So the "puts here" was parsed, but never ran - we never got out of the parse stage. Now an example that goes to the heart of your problem, and which I've kinda glossed over, and I made a mistake in my earlier explanation (sorry :-( ) puts here() def here "here" end This parses fine, but my earlier error was stating that the method 'here' existed after the parse stage. That's not true. The code exists in the parse tree as something to be executed, but _until it is actual executed_ the 'here' method doesn't exist (see, we're both learning !) $ ruby scope.rb scope.rb:1:in `&lt;main&gt;': undefined method `here' for main:Object (NoMethodError) Lets reverse this declaration def here "here" end puts here() Again this parses fine, but the parse tree is different (in Ruby you can examine the parse tree, but its a bit "too much information" at this stage) The "def here" line is executed, and the method springs into existence. Lets try another to show this dynamic nature if 'a' == 'b' def here "really ?" end else def here "they are not equal" end end puts here() We define two different versions of the method, and that is decided at run time. In the parse tree there are two versions of the here method waiting to be executed, but until one of those alternatives is actually executed, here() doesnt exist at all. $ ruby scope.rb they are not equal So, now to zoom out a little. How can you tell if a method is defined at any point. You can call the "methods" method ! Unfortunately, in this simple example, things are a bit more complicated. But lets walk through it.(you can stop reading here if you like, we're going deep from hereon, I think the timing issue is clear now) At any time, we can call the 'methods' method on any object. So, when we fire up irb, where are we ? What is our context ? Lets have a look irb(main):001:0&gt; self =&gt; main Ok, so irb is telling us we are inside an object called main. What methods are available to us right here irb(main):002:0&gt;methods =&gt; [&lt;long list of methods&gt;] See those [ and ] at each end ? methods() returns an array of methods we can call right now - methods whose definition has been parsed and executed already. So now we get a bit deeper - lets define that here() method right here in irb - I mean, its just ruby code, and irb executes ruby code. irb(main):003:0&gt; def here;"we are here";end Ok, so this has been parsed _and_ executed, and the method is defined....somewhere. But where ? Lets run methods again, but lets use a few helpers to filter that huge list irb(main):004:0&gt; methods.grep /here/ =&gt; [] So that grep says put a filter in place that only allows methods containing the string "here", in their name, to pass through And the result is an empty list. What ? We just defined it. Can we call it ? irb(main):005:0&gt; here =&gt; "we are here" So output, and no error, so we can assume it exists somewhere, and ruby can find it. But why did methods() not find it Lets try a different introspection call, a method called 'private_methods()' irb(main)006:0&gt;private_methods.grep /here/ =&gt; [:here] There it is ! Now understanding why it appears in this list means you need to understand the Ruby object model, which I'm not going to go into here. But when you understand why you can only do here() and not self.here() you will have obtained true mastery One last thing - we have here() defined in irb. Lets change it - Ruby is dynamic, and I said methods can appean, disappear and change at any time - lets prove it irb(main):007:0&gt;def here;"shiny and new";end =&gt; :here irb(main):007:0&gt;here() =&gt; "shiny and new" The redefined method is parsed, and executed, and then called to show the new result. HTH
`g++ -c -Wall -std=c++1y -g -O3 -S src/main.cpp` $ g++ --version Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 7.0.0 (clang-700.1.76) Target: x86_64-apple-darwin15.2.0 Thread model: posix
Yes, there are many differences between these languages. My point stands though, Ruby does not try to compete with C/C++, it's a language for different purposes. It does however, compete with Node.
I'll go ahead and recommend exercism.io too. The nice thing about it is that people can critique each other's solutions, though you probably won't get many critiques unless you're part of a group.
OP, you can indent 4 spaces to get code formatting. click the "*formatting help*" in any comment box to read about it. :)
The canonical first projects are simple CRUD apps like a blog, or a recipe database, a contact database... the nice thing is to pick something you can knock out in basic form in a day or two, then spend some time making it nice. Build a recipe database, and add in PDFs using Prawn. Make your contact database, then try to add photos to each contact. Do a simple project, then extend it. Good luck!
`g++` was used because op's code is C++, not C and it's what the makefile called. `g++` aliases to `clang++` and `gcc` to `clang` on OSX. 
But Perl has bad breath.
I never quite understood the point of the seeds.rb file. Why not using a migration to seed your db instead? That makes more sense because you can revert. It's also easier when you have multiple seeds. I even found that project https://github.com/harrystech/seed_migration doing in fact the same thing as migrations but for seeds. But what's the point when you could use the migrations to begin with anyway?
You can get it here - https://github.com/yurtaev/idea-one-dark-theme
Id love to see how elixir would fit in here. In elixir, the loop probably wont be super fast still, however it could be chunked and probably run on a few *thousand* BEAM processes. The trick though would be to figure out a large enough chunk size to offset the task spawning time ( which is significant compared to trivial calculations) if some real work was being done in each loop, I think threading would be much more useful. If I have some time this weekend ill write up a loop in elixir and figure out if tasking it out saves any time.
I wrote a command-line roku remote. That was pretty fun and very convenient. 
Nice! Big fan of these guys.
Oh my god, I wasted so much time checking if all the variables are nil before going deeper (I'm parsing a lot of json these days)... I wish I saw that earlier.
awesome to know that this helped you! :)
As a junior software engineer, don't specialize; generalize. &gt; Are there junior level positions ever available where they take in people who just know one language really well like Ruby? For a junior position, I don't care what you know. I want you to have an interest in learning and a demonstrated capacity for doing so. Because no matter what, I am going to be using some tool or library you have not seen before and will have to learn to use. Implement a simple algorithm in Go, Ruby, and Haskell, be able to talk about the strengths and weaknesses of each in general and as they applied to that algorithm. Even something as trivial as [FizzBuzz](http://c2.com/cgi/wiki?FizzBuzzTest) works for this.
How's that gonna work with the bracket convenience getters, json['foo']&amp;.['bar'] I don't think that's gonna work.
He/she isn't a "junior software engineer". He/she is probably, today, unemployable even as a "newbie programmer". There is a rather enormous difference.
I'm just looking for a discussion. You're right, I'm not junior software engineer level. I'm looking to see what my goals should be, and his response was very much what I was looking for. Thanks for your input.
I promise you didn't suddenly forget everything after a few weeks. Sure, you may have forgotten a couple of things, but that's too be expected anyways. What I'm concerned about in reading your post is that you may basically be spinning your wheels. You can go through tutorials like Ruby Monk and Rails for Zombies, but at some point you have to show that you can apply your skills to something outside of a tutorial. I highly suggest you try doing some projects of your own. And they don't have to be big! Small projects and problems are good too. Check out r/learnprogramming - they list a lot of resources for ideas in their sidebar and FAQ. I also saw a post in r/webdev I think about project ideas specifically for web dev. But try to do something outside of a tutorial.
Awesome! That's what I was mostly curious about. Thanks so much!!
Exactly, that's what I chose to use two days ago. :)
They are taking the core technologies (that are advanced and have untold numbers of man hours in development) that power the JVM and removing the JVM specializations to make them work as a drop in and living upgrade path for other languages. So instead of using a JVM and trying to massage ruby work well against all of the requirements for java that are enforced in the JVM they are shifting that ability one step lower -- allowing ruby to more directly attach to an optimize JIT/GC/thread/profiler/... that can be customized/optimized for running ruby. It should allow for most all of the advantages (except running java code ... ) of jruby but in MRI. 
&gt; Communicating over HTTP is a great way to send messages to a service when you need an instant response. No, it isn't. It's a great way to send messages over a network which, by definition, does not provide an instant response. In a single process architecture (e.g. monolith), the latency behind any blocking IO call can be safely ignored, since the entire execution context itself is suspended by that blocking IO call. When you break your application into services deployed across many processes, that latency immediately introduces a vector for consistency problems, which are difficult to debug and severely curtail your ability to scale. "Latency is not a problem" is one of the classic distributed systems fallacies. I recommend against adopting SOA unless you understand distributed systems.
I don't know that it will make you feel better, but you can't use '&amp;.' yet; unless you are running the development build. Ruby 2.3 is scheduled for release on/around Christmas. I'm not sure why it is being labelled as the 'lonely' operator. It's more formal name is called the "Safe Navigation Operator" (which is used in the description), sometimes it's the "Null Propagation Operator". It originated from C# or Groovy (I'm not sure which did it first), but it seems that many languages are falling over themselves to implement it asap. My only guess is that they are trying the syntax distinction between C#/Groovy uses '?.',but Ruby uses '&amp;.' because the question mark is a legal function name.
Thanks for clarifying.
I think the plus is it should be indistinguishable from MRI only faster, but the minus is it isn't much faster.
&gt; Unfortunately removing the GIL isn't so simple. Jruby did it so it's not impossible.
LOL. Nice trolling there.
&gt;Funny, I've only heard that a few times before... Nothing substantive to respond to here. &gt;&gt; Tell node.js that receiving highly optimized and engineered code from large corporations can not lead to vas improvements in ecosystems. &gt;What? node.js uses V8 which is a Javascript only VM, how is this related to the discussion? Node shows the same type of symbiotic relationship between the heavy google/Mozilla investment in optimizations for browser based js vm being utilized node. The point is having large teams that are highly focused on producing optimized vm's releasing that code that can be used in multiple languages to take advantage of those optimizations is a good thing and tends to provide advantages to the languages that can use them -- especially languages that do not have large funded dev teams focused on optimization. &gt;&gt;IBM's JVM is highly optimized; ... used in IBM's JVM implementation &gt;So is it a JVM or is it not a JVM? Or is it something else? I also said : ORM removes most all of the Java/JVM specific code and exposes an AST/jit that can be highly coupled to Ruby -- not a java AST that ruby can be mangled to run in... It is not a JVM, but the opmizations and core functionality are pulled out of a highly optimized JVM and normalized to be used and specialized for other languages without the JRE/JVM layer. In this case you should be able to think about ORM as a Ruby JIT/GC/Profiler -- it is tightly integrated with no Java middle. Not similar to jruby which is a ruby runtime written ontop of a JVM. &gt;Really what I think your getting at is that I don't trust IBM, and I don't. I think they've done a shit job embracing OSS and are generally a shit company. They make a lot of money, no doubt but they make it by locking in users to their shit and generally work with companies that have shitty developers. There is no need for it and you can watch the linked presentation and realize they are doing this completely out of self interest, not to contribute back to the community. &gt;So fuck IBM, and I think if you step a little outside their 'enterprise' market you'll find that no one uses their JVM and for good reason. No one wants to be handcuffed by an entity that is non-responsive if you don't throw $1m there way. Got it, you have "the reasons yo". I see there is no point in this discussion, I may as well be talking about Trump vs Obama with you. 
Paranoid much?
haha, I thought it was a reference to this. https://www.youtube.com/watch?v=khXtUd0TEO8 (nsfw for loud cussing)
Rereading this thread I find myself coming to a vastly different conclusion. Good luck to you.
Sorry, that position has been filled. Thank you for interviewing.
It's not a ruby specific thing. Since 'Zen and the art of motorcycle maintenance' was published everything has been compared to eastern philosophy. See perlmonks.org, thezenofpython.com, 'The zen of programming', and so on.
30 years earlier, actually; 1948 Zen in the Art of Archery. The "motorcycle" one was a play on that older title: https://en.wikipedia.org/wiki/Zen_and_the_Art_of_Motorcycle_Maintenance There were zillions of "Zen and the Art of ..." books.
I chose Go and Haskell arbitrarily. They were, off the top of my head, the least like Ruby, but still useful and popular languages, I could think of. Don't get stuck in what you know right now. A good software engineer is always learning the next thing. You can't just learn language X or tool Y, and be done. Because the next new thing is coming and it may or may not supplant everything you know at the moment.
External 3rd party API or just a JSON representation of one of your objects ?
Use mruby when you need a portable, self-contained, miniature ruby runtime. CRuby, JRuby, Rubinius all have to be installed into a certain location, where as MRuby can be compiled into an existing (native) project, like a game or an agent.
Just curious, why reinvent this wheel (with less configurability) vs. using one of the many available slack gems? If they didn't meet your needs, why not a quick PR or worst case, fork? Your README says it's for ease of use, but existing gems are already pretty easy to use, e.g. here's [slack-post](https://github.com/CozyCo/slack-post): Slack::Post.configure( webhook_url: 'https://hooks.slack.com/services/BLAH' ) Slack::Post.post "Hello" 
Hey @niscrub, here's an article of mine that explains all the fundamentals with small code snippets: http://lucaguidi.com/2014/03/27/thread-safety-with-ruby.html I highly suggest you to read "Java Concurrency In Practice", which is an excellent book that covers multithreading, concurrency, visibility, atomicity. Yes, it's for Java, but the two languages share the same concurrency paradigm. Again, highly recommended.
And they're singing that same-named song by the Police!
I think this is the correct answer. There's also [Ruby Monk](https://rubymonk.com). Both of these are good resources for new Rubyists, imo. 
I've been coding Ruby for at least 10 years and it's the first I've ever heard of that. Maybe you're thinking of the Ruby Koans. 
There's also [Hash#dig](http://dev.mensfeld.pl/2015/11/ruby-2-3-0-changes-and-features/#dig) in Ruby 2.3 which would also help with this.
"Ronud"? "Semll"?? Not sure I want to take programming advice from someone who can't use a spell-checker... ;-)
Thank you. People get this wrong and it's drives me nuts. 
The Perl Monks were a decade earlier
I'm a big fan of [service](https://blog.engineyard.com/2014/keeping-your-rails-controllers-dry-with-services) [objects](https://www.netguru.co/blog/service-objects-in-rails-will-help) to help solve problems like this. They are meant to have a single api in the form of VerbTheThing.new(arguments).call and are great for Rails apps. The arguments are usually two Objects that need to interact with each other. But that's an aside. I've recently had to solve a similar problem to yours with taking data from disparate sources and transforming it into an Amazon Marketplace data feed. So in essence, it's the same: Hash in/slightly different Hash out. [Here is my code](https://github.com/johnpash/reddit-hash/blob/master/lib%2Fapp.rb) What I like about this approach is: * i believe it's quite readable. lines of code isn't something i generally care about. if you see the one "call" method, it's obvious what the output is going to be. * transforming/merging input data is simple * it's easily unit-testable (the attribute methods would have to public though) * if Amazon decides to change their format, add or remove fields, it's pretty easy for a junior dev to change this code. THIS is the biggest benefit I've experienced so far with this type of object. This code might seem at first to be overkill for a simple transformation, but imagine if you had to change cm to mm, or $ to ¬£. You just need to change the relevant method. The Amazon feed problem also has additional complexity in that one hash of input data sometimes needs to be output in two slightly different formats. So I simply subclassed this and over-rode just what was needed. My only real criticism about your code is that it feels very procedural, not object-oriented. And when using Ruby, I like to stick to OO. But that's just my opinion. Let me know what you think. EDIT: changed API to use class method
Fair enough. Maybe I confused the issue with my exuberance about using service objects. I'm like a kid with a hammer wanting to SERVICE OBJECT ALL THE THINGS!!! Yes, a plain-old-ruby-object is all that I was intended to illustrate. And doing what you suggest would make the API nicer. 
First thing I noticed is that startup is fast, unlike jruby. 
The first solution is best (most maintainable), but written to take as much space as the syntax allows (probably to illustrate a point). Here's what it actually looks like (shortest, simplest, most readable/maintainable): def self.to_google_params(params) out = {} out[:primaryEmail] = params[:address] if params.key? :address out[:password] = params[:password] if params.key? :password out[:orgUnitPath] = params[:org_unit_path] if params.key? :org_unit_path out[:includeInGlobalAddressList] = !params[:privacy] if params.key? :privacy name = {} name[:givenName] = params[:first_name] if params.key? :first_name name[:familyName] = params[:last_name] if params.key? :last_name out[:name] = name unless name.empty? org = {} org[:title] = params[:title] if params.key? :title org[:department] = params[:department] if params.key? :department out[:organizations] = [org] unless org.empty? out end 
Look at the subreddit's alien graphic.
Clean code, buuuut ;) &gt; My only real criticism about your code is that it feels very procedural, not object-oriented. One could say the same applies to your code: `GoogleTransform.transform(...)` is just a namespaced global method. How about this? class GoogleResponse def initialize(attributes) @attributes = attributes end def email @attributes[:user][:email] end def to_hash { ... } end end Gets rid of primitive obsession and mutable (global) state.
Well, whattya know. I've been subscribed to the subreddit for years and never noticed the icon. 
&gt; One could say the same applies to your code: GoogleTransform.transform(...) is just a namespaced global method. [It didn't use to be](https://github.com/johnpash/reddit-hash/blob/dd6b7d39d748fde6906dde8151d23ec90806d369/lib/app.rb) &gt; EDIT: changed API to use class method Until this.
It's not thread safe, right? Looks like I can't have two clients in the same application using different credentials.
Why should I use your site over good documentation? http://docs.ruby-lang.org/en/2.0.0/Array.html
A Person of Color rubygem? What am I missing? 
 * You need to ship a single, statically linked executable ("my_app.exe") * You're working on a device that doesn't have a lot of memory (Matz told me at RubyConf that 500mb is a good bet) * You're writing an application that needs a language for plugins/scripts (Example: https://github.com/matsumoto-r/ngx_mruby) * You want to obfuscate source code / not ship application source (MRuby compiles down to byte code) 
I really do hope Crystal takes off. Ruby is awesome, but performance and native code execution would be very beneficial for many companies wanting to save money on server costs. The one thing that worries me about crystal is it's seeming lack of pry, which makes a hard to debug language even harder. Has anyone been able to use gdb with crystal?
Article cites 3 ways Crystal beats Ruby with similar syntax. * Compiled * Native code ~~(isn't that the same as above?)~~ * Superb performance Those benefits can be had with MacRuby and RubyMotion. Different platforms, but just an FYI for Rubyists. Have not looked at Crystal at all. Thanks for the post, OP.
Compiled doesn't mean the same as native code. Java, for example, is compiled. But into Java bytecode, not native to the compiling platform.
Ah, that's true.
Yes, thanks for catching this.