I would not have the 'current directory' be a property (instance variable) of the "catalog" -- the catalog is just a catalog. What directory the user is currently interested in viewing is not really a property of "the catalog". It's a property of the UI. The Catalog is more like the "model" layer, you can have another object that's more like the "controller" layer that handles input and output with hte user. The "controller" type object will ask the "catalog" for data. So you'd never tell the 'catalog' to 'change directory'; you might tell the 'controller' to change directory, then when you ask the controller "what's in this directory I just changed to?", the controller would ask the catalog for the contents of that directory, that the controller knows is the current directory. The controller's job is keeping track of "current directory" (if and only if that's a concept that matters for your UI), the "catalogs" job is just giving information about directories and files to whoever asks for it. 
I would just use regex for this. Usually, regex is a bit more resources intensive than other programming methods, but it can be a simple solution. Match against one or more digits stuck to beginning and end.
&gt; I'm also very surprised that the Sinatra app is consuming almost the same memory than the Rails one Your Sinatra app includes ActiveRecord and ActiveSupport, which is most of where Rails burns it resources. I couldn't be totally surprised about this part of your issue.
:-O I'm so far gone I don't even know what "discrete" math means! Thank you for the tip! 
That first sentence honestly made my day :) Thank you for your advice, I do think listening to talks, YouTube, etc will help! 
Added it to my Amazon list! 
Oh, awesome. I'll check it out. 
Yeah I struggle with the stupid question thing, I waste a lot of time probably, trying to figure it out before I embarrassed myself with a dumb question... 
remove AR and AS and you will see magic :)
&gt;SecureRandom now prefers OS-provided sources than OpenSSL. This is a really good move. I know there was initially resistance.
quite optimistic. He is alone, working on free time. Look at truffle. Dozen of full-time developers, on top of Graal, and still WIP. 2020 is more realistic, and also somehow I'm afraid will be to late.
Is there an actual issue caused by memory consumption?
Try Crystal if you want something with less memory or write it in Golang.
Good catch.. to be honest AR is what I like most about Rails currently, for the other parts I'm starting to see Hanami or the ideas behind it with good eyes.
Well If you look at the second screenshot it says SWAP (500MB) is 100% used and memory 75%.. I think that every sysadmin will agree those are far from ideal situations to run a server. But, to be honest, I don't remember any notable performance problems when the server was in that state.
This is not a rant about Ruby.. I mostly wanted feedback to know if I'm in presence of a obvious memory leak or this is "expected behaviour".
I like the little AR bastard!
Oldie but goldie
It's a common misconception that classes model real-world things. Something like this might seem reasonable: dog.bark! But the reality is more like: audio_system.play(dog.bark_sound) Classes model data, or behavior, or responsibilities. I know that sounds very vague, but it takes quite a while to get the hang of it.
GUI on windows can be a pain. The only that worked for me more or less ok but with graphics from the 90s is tk. https://github.com/ruby/tk
Because ruby is a dynamically typed language and ar uses a lot of metaprogramming, the trade is memory for speed. 
use roda and sequel. Nicer plugin system, clean way of doing stuff. More pragmatic and 100% faster :) I found really bad that rails has polluted ruby community when such gems exist :)
I know about that bro, just need feedback to confirm those numbers.
A memory leak means the memory will continue to increase unlimitedly. Does it exhibit that behavior or does it simply need around a fixed amount of memory?
Sequel has lower level abstractions than ActiveRecord.. there are tradeoffs as always, but we are comparing apples to oranges.
You can apply Active Model pattern and still use sequel. http://sequel.jeremyevans.net/documentation.html 
Well, not sure.. I only have the numbers from the beginning and after 3 weeks.. maybe it's slowing leaking memory, maybe it will remain constant. Comparing with others members application behaviour with shed some light on the issue.
Its natural to be a bit higher than a fresh startup, but if over 3 weeks it hasn't increased a huge amount, then doesn't seem like a memory leak. A memory leak in a ruby gem like that would be big news. Previously the memory leaks that have been discovered have been from C extensions in gems. There are ways to do it, but pure ruby gems doesn't have much of a way to exhibit memory leaks because you don't allocate memory manually in Ruby.
Also separately but you might as well go to the latest Ruby 2.4.2 
Ok thanks, I think I was kind of on to this as I realized the hash (instance variable one) needed to be destroyed before displaying another directory. I did study Rails a little so I get the M and C here. Now I just have to decide what I use for the cataloging. Guess it's either a db or txt files. 
Makes sense. I'll just keep practicing.
Pry has some neat features. The color everything wasn’t great but I can deal. Pretty/awesome printing is very handy. But every time I try Pry I am baffled by the confusion of \^c and \^d not doing what they should at the prompt and it’s not worth it to me. Elixirs IEx does this too and I don’t understand why, but perhaps I’m just a readline loving fool. edit: formatting
One application (administrador_boletas, the sinatra one) starts at 87MB and ends at 209MB.. that's more than double.
[Pry-Toys](https://github.com/ariabov/pry-toys) is very nice. Pry is not required. 
Well, people tend to resort to metrics like CPU, swap and disk usage because they are readily available on all systems. And they *can* be indicators of issues but ultimately CPU as well as memory are there to be used. The fact that they are actually used to a large extent is not necessary problematic. The more meaningful metrics would cover what a system is actually supposed to do (e.g. serve HTTP requests) like response times and throughput. Put differently, if your overall utilization is never higher than 10% of any resource you are wasting loads of resources.
&gt;baffled by the confusion of c and d not doing what they should are you referring to the lack of debugger-style stepping commands? to get those you need pry-byebug which integrates the byebug debugger into pry. as essential as pry in any project imo. also note that you still wont get those single-character stepping commands. those used to be there but people asked for them to be removed because those characters are commonly used as scratch variables in debugging and it was getting in the way. you can add them back with .pryrc configs
Not everything is loaded at startup, and ActiveRecord in particular does a lot of caching internally after queries are executed. So startup memory consumption is never expected to be the maximum. Using ~500mb in memory is also very common from my experience for small Rails apps.
Anyone know the differences between pry and byebug? I always used pry and byebug started to be included in Rails meant more projects used that. I never really thought much of it.
I'd probably use a db, you can start with SQLite and [Sequel](https://github.com/jeremyevans/sequel) which will be pretty straightforward. 
*I'd probably use a db,* *you can start with SQLite and [Sequel](https://github.com/jeremyevans/sequel)* *which will be pretty straightforward.* ______________________________________________________________________________ ^^^-english_haiku_bot
&gt; note that you still wont get those single-character stepping commands You can actually - [Matching Byebug Behaviour](https://github.com/deivid-rodriguez/pry-byebug#matching-byebug-behaviour)
Sorry, that was confusing. Formatting on my control characters got slurped up by markdown. I'm referring to the pry console not following the readline standard for how to respond to ctrl-c and ctrl-d. From [the wikipedia](https://en.wikipedia.org/wiki/GNU_Readline): - ctrl-d "Sends an EOF marker, which (unless disabled by an option) closes the current shell (equivalent to the command exit). (Only if there is no text on the current line)" - "Ctrl+c : Sends the signal SIGINT to the current task, which aborts and closes it." I haven't tried pry in 18-24mo so this might have changed, but it's a big frustration for me.
**GNU Readline** GNU Readline is a software library that provides line-editing and history capabilities for interactive programs with a command-line interface, such as Bash. It is currently maintained by Chet Ramey as part of the GNU Project. It allows users to move the text cursor, search the command history, control a kill ring (a more flexible version of a copy/paste clipboard) and use tab completion on a text terminal. As a cross-platform library, readline allows applications on various systems to exhibit identical line-editing behavior. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
this is probably a result of building your ruby on OSX which doesnt have GNU readline. to fix this you can either install the rb-readline gem, or (preferred) rebuild your ruby after installing GNU readline from homebrew. to be clear, this isnt a pry thing, you'll see this with any program on OSX which doesnt include GNU readline as a dependency and instead builds against OSX builtin BSD-derived readline.
What is your memory profile under test? How does the memory change over time? Does it get to the 3 week value an hour after launching? A day? A week? What are the trends, and what activities in each service have the biggest impact to memory the first time they load or on each request? I think understanding what your system is doing and being able to point to where 'weird stuff' is happening/started happening is important. Have you instrumented your apps to give you this information?
Well that's an analysis that it's not cost effective to do I'm my current circustantes. I mean, I can just throw 5u$s more to linode to double the RAM and I will save money instead of doing all that (don't get my wrong, that's the way to really get a solid conclusion here).. but hey it kinda surprised me how ruby was sucking all my RAM.
This behavior depends on which `readline` lib you use to build it. If you want the GNU readline behavior, build with it. I'm guessing you are on OSX to get non GNU behavior so `brew install readline` then rebuild Ruby / Pry.
MRI doesn't return memory to the OS very aggressively. The LOC here doesn't matter, if they are periodically receiving requests that use memory to process, MRI isn't going to return it to the OS after it's done with it. Heap fragmentation can also contribute to this. That said is there actually a problem here? i.e. you didn't mention any performance issues so why is using 200MB of ram a problem?
Protip: if you're working with arrays, hashes, HTTP requests, etc. with plenty of data, and you don't want them to fill up your whole screen, just add `;` to the end of the line. Eg. ``` arr = items.fetch_all; ``` 
Looks good! Thank you.
I want to add a third internal Sinatra/Ruby app to this VPS and it looks like I'll have to upgrade. What shocks me a little it that gitea, that it's not a trivial app at all, consumes so much less memory. Do you know some setting to adjust the memory returned from the GC @moomaka?
Any changes related to memory consumption? I'know they promised Ruby 3 to have big improvements in this area.. well, see to believe.
Not really true. http://sequel.jeremyevans.net/rdoc/classes/Sequel/Model.html But I think it's true there are still some sophisticated features AR has that Sequel doesn't. But I think it's apples to apples. 
Do you have some numbers about the memory usage difference? maybe a production app or something using sequel.
It's not "ruby" that's sucking your RAM, but it is things written in ruby. Rails is known to be memory-heavy. There may be "memory leaks" in the particular applications. (ruby doesn't exactly have 'memory leaks' because it has garbage collection, but you can still have things holding onto references that ought not to be). Are you positive puma is running with a single instance?
Depends on what it's doing. e.g. you have gems listed in both Ruby apps that imply they are compiling assets on the fly rather than precompiling. 
I like it too, but it costs RAM! 
I agree with that, but 100% SWAP usange and 75% memory usage I think is a big alert.. maybe someone with a devops background can give it's opinion here.
for example: https://rubybench.org/rails/rails/commits?result_type=activerecord/postgres_scope_all&amp;display_count=500&amp;compare_with=sequel/postgres_scope_all
&gt; Do you know some setting to adjust the memory returned from the GC @moomaka? Not that I'm aware of, this is pretty standard behavior for almost all request oriented frameworks regardless of language. The JVM and Go's runtime also do not free memory to the OS aggressively. It's expensive to ask the OS for ram so they don't give it back unless it's clear they aren't going to need it. 
Pretty sure, I've checked it with htop also. Here is an extract of my puma config: threads 4, 8 workers 1 bind "unix://tmp/sockets/puma.sock" daemonize true preload_app! activate_control_app "unix://tmp/sockets/pumactl.sock", { auth_token: 'xxxx' } pidfile "tmp/pids/puma.pid" state_path "tmp/pids/puma.state" plugin :tmp_restart on_worker_boot do ActiveRecord::Base.establish_connection if defined?(ActiveRecord) end 
Yes I have.. SASS and Coffee.. those are high memory consumers in your opinion?
Compiling bootstrap from SASS isn't cheap, nor is compiling coffeescript. The fact that the gem is there isn't an guarantee that there is a problem there, it depends on how you deploy the apps. Generally you want to precompile assets when deploying a new version. e.g. in rails you may run `rake assets:precompile` at deploy time which should precompile the assets into static files and dump them into the `public/` directory in the app and under a production environment, it will serve the static files. Sinatra, it depends on how you've set it up. I think my overarching point here is that I doubt Ruby itself is your memory issue, it's likely what the apps are doing and how they are deployed can certainly impact what they are doing at run time. Ruby is going to tend to have a lower static memory usage overhead vs e.g. something like the JVM but will use more memory for a given 'request', all else being equal. Under low load that often means that Ruby will use less memory. Go is likely to beat both from a memory usage standpoint (in general, super hard to make blanket statements).
Good point, but sometimes Ruby doesn't garbage collect unless it has memory pressure. You can see more about garbage collection: https://collectiveidea.com/blog/archives/2015/02/19/optimizing-rails-for-memory-usage-part-2-tuning-the-gc This looks cool too: https://tunemygc.com/
As a Python developer learning ruby for work, pry has been super helpful to me in understanding how the language works. I guess I just come from REPL land. It is a very nice tool. I use it as a Rails console.
Well maybe I should test your hipothesis.. I bet making sprockets work with sinatra is not complex.
It's not making sprockets work, it's making sprocket _not_ work. e.g. under Rails in production if you've precompiled assets then sprockets doesn't build assets on demand. If you have enabled asset building in production, then sprockets will build the assets the first time they are requested then cache them, but that may use a lot of memory and MRI may not return it to the OS. This may be compounded based on what tools you are using for asset compilation, i.e. are you using a ruby implementation of the SASS compiler that may execute in process or a SASS gem that calls out to node to do the compilation? The former will allocate memory in process that MRI may not give back while the later compiles in another process then terminates it, freeing memory.
I think maybe you've got one worker plus one "master". I forget the meanings of the various puma configs, but try _without_ "preload_app!". Or figure out how to turn off "clustered mode" to really only have one process, not one "master process" and one "worker". &gt; Puma also offers "clustered mode". Clustered mode forks workers from a master process. I could be wrong though. Something to look into though. 
There are no stupid questions. :) If you spent lots of time struggling with something and found it stupid after you figured it out, it might be a good thing b/c you actually understood it. The only reason you find something "stupid" is b/c it becomes obvious once you get it. There are ways to shorten the struggling time like reading books, watching tutorials, getting better at reading documents, source code, and debugging, ect. But struggles are inevitable for programmers, even the professional ones :) Later you will learn to embrace the process. Each time I struggle with something, mostly debugging, I feel like a detective going after the truth. :D &amp;nbsp; **Don't worry about embarrassment.** You can think about it this way: "If there is a certain number of times I need to get embarrassed to learn to program, let them come faster and earlier so I can become a developer faster!" Cheers!
Rails has a built in console - you don't need pry for it rails console works via irb if you don't have pry 
Don't stick to stringent OO unless it makes sense and it doesn't make sense for everything, actually I'd argue it doesn't make sense for much. One of the benefits of Ruby is that while it is very strictly OO under the covers, it supports many paradigms, use the right one for the job. TicTackToe is definitely not something I would write in an object oriented manor.
A good book to read is Clean Code by Robert Martin.
awesome work, nice to see people putting in this effort
What were the initial problems? IO is already concurrent in Ruby so I assume you needed to perform some logic on the sockets and that was the bottleneck?
Processing an event stream, Ruby was fine till something on the order of 3k event/sec. Didn't scale well though. I imagine, as in most cases, the biggest change that was made was not from Ruby to another language but from Ruby to another system architecture (and thus a rewrite) which broke things up into smaller units of work that are more static in nature which allows modeling them in other languages more simply. i.e. Had we gone with the current architecture written in Ruby it would require more boxes per unit of work, but would have scaled just as well. The trade off is that the current system is harder to change.
Ruby IO is not concurrent unless you use multiple threads. Multiple threads only scale up so much. You'd only really see an increase in throughput until thread count == hardware core count. Once thread count gets beyond that, you'll see a slightly degradation in actual CPU throughput since task switching starts to consume resources. The GIL also introduces performance issues. If you have multiple threads, only one thread can execute Ruby code at a time, which leads to contention within the VM. Finally, thread exhaustion is a very real concern, e.g. Puma has this problem and drops incoming requests when all threads are consumed (if I understand correctly). The situation where this becomes a problem, is if you have any kind of upstream request. e.g. -&gt; incoming HTTP request to server -&gt; as part of processing that request, make another request via HTTP upstream If the majority of your requests only take a few miliseconds to complete, you will be fine, but as soon as latency increases, all your threads will be waiting on IO, and you'll be unable to process many requests despite being close to 0% CPU usage, because you are waiting on network IO. This can and does cause Ruby web servers (e.g. Passenger, Puma, Thin, etc) to be significantly less than optimal under load. One solution is to use event-driven IO, such as what is implemented in async. When a task is blocking on IO, it lets other tasks run - it's similar to a thread, but with less resource overhead, better guarantees about concurrency, and better scalability due to the design of `epoll/kqueue` vs `thread blocking read/write`. If you are IO bound, though, event driven IO can sometimes be a slight overhead, so it really comes down to your design requirements. But, threads for blocking IO is a pretty low-throughput solution, especially on MRI.
Agreed on all points, but most of it is an issue in all languages. I think the only Ruby specific point is the GIL. i.e. thread pool exhaustion is something every language has to deal with.
I think it’s a mistake to assume that. Ruby and other languages do encode some pretty high level procedural semantics but not every language works that way, the biggest example being Node.js which doesn’t expose threads in the language.
There are some SUPER valuable insights in the replies of this thread that took me YEARS of programming to fully understand. So you did yourself a great service asking this question here :) &amp;nbsp; These insights are: by [u/cmd-t](https://www.reddit.com/user/cmd-t) &gt; think in OOP in terms of passing messages from object to object. Every function call is actually sending a message to an object: a request for it to do something. by [u/saturnflyer](https://www.reddit.com/user/saturnflyer) &gt; Don't model the real world. Create the world you need. by [u/tom_dalling](https://www.reddit.com/user/tom_dalling) &gt; It's a common misconception that classes model real-world things. Classes model data, or behavior, or responsibilities. &amp;nbsp; To answer your question, **yes, OOP is hard to master**. As a result, there are many books written on the subject. And for a complicated system, even senior developers will have trouble getting the design right on a first try. &amp;nbsp; If you feel lost, it's not because you are not good at this. It's because the subject you are learning does require lots of time and practice. IMHO, the best way to learn this is by actually working alongside with senior engineers in a real production project. So you can see some existing designs and also bounce ideas with other engineers. While that might not be possible at the moment, you can * look at existing designs of open source projects * read books: [Practical Object-Oriented Design in Ruby by Sandi Metz](http://www.poodr.com/), [Smalltalk Best Practice Patterns by Kent Beck](https://www.amazon.com/Smalltalk-Best-Practice-Patterns-Kent/dp/013476904X) These two might be a bit too advanced. I couldn't think of any good OOP introductory books of the top of my head, maybe [Head First Object-Oriented Analysis and Design](https://www.amazon.com/Head-First-Object-Oriented-Analysis-Design/dp/0596008678)? * practice and **bounce your design ideas with other engineers** &amp;nbsp; Happy coding and I hope to see you posting more questions here! :D 
Yea that's fair, though I don't know if I buy the 'procedural' terminology. My point being that Java, Ruby, C, etc have the same thread vs event driven issues. Certainly some languages provide language level constructs for event driven processing, e.g. Go.
+1 for &gt; Don't stick to stringent OO unless it makes sense and it doesn't make sense for everything But it's still worth learning, if not necessary, consider many industrial projects are using OOD. 
&gt; But it's still worth learning, if not necessary, consider many industrial projects are using OOD. If you are interviewing for a job and it's clear they are driving 'OOD or bust', find another job :) The market is in the interviewee's favor at the moment, at least in the US.
C as a language doesn’t include threads. It’s different from Java and Ruby IMHO.
Pry and byebug are different tools, solving different problems. Pry, like IRB, is a [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop), essentially just an interactive place to write and execute code. It has a nice feature that you can trigger a pry session by calling `binding.pry` to inspect the operating situation at the current moment. Byebug is a tool for a very subtly different problem. Byebug *includes* a REPL. It is a somewhat primitive one, but I've rarely found need for anything more. IRB can be launched from a byebug breakpoint. Byebug is intended to step through code, instruction by instruction, following fairly traditional debugging actions (step, step out, watch, etc). It allows you to not only pause a program mid execution, but to advance the execution in a controlled way as well. It's further muddled by the fact that there are several plugins for Pry that provide actual debugging tools. I believe one of those modules even wraps byebug.
I agree that one should avoid companies clearly using the wrong tool for the task :)
It seems like I already have brew's version of readline, but it's possible that the last time I tried pry I didn't. I'm running through some steps to recompile and test this, but why does IRB and byebug both work and follow the expected behaviors when Pry doesn't? Edit: the newly installed pry does follow \^d signals as proper EOF. I'll give that a whirl and see how I like it. Thanks for the tip!
You can have a never ending reductionist fight about that. We could also say that Javascript isn't event driven which is true but it's only practical runtimes, the browser and node are, so what does the difference matter? I started my time in professional programming writing a mixture of C89 and assembly on 8bit microcontrollers which didn't have an OS, or malloc, or pthreads, so yea, C doesn't have threads, or a heap, or whatever, but I think that is a distraction from the topic.
And pry can replace that Rails console (which is just IRB AFAIK) with [pry-rails](https://rubygems.org/gems/pry-rails). It's nicer in many ways although the way it formats return values can be problematic with models or objects that have a ton of attributes.
In my world, IRB is the Pry alternative, if I want my features streamlined.
I just find reading code in other languages, at my stage more distracting then beneficial. Though that's not to say that I don't realize the longer term benefits. I can get about half of the meaning and the rest I need to look up. 
I agree with your position. Our thinking is not tangential but we are just reflecting on different aspects of the same problem.
Celluloid has an awesome sales pitch, you were sucked in :D
Speed? This is Ruby we're talking about, right?
I use pry in most of my apps - stepping in and figuring out where tests go wrong is kind of important
Word. Same.
I saw your PR. Your error was making a ton of changes and introducing Rubocop at the same time. I would reject that PR as well. Repo's author sets the style. But I agree that indentation is atrocious. Also who the fuck uses Hoe in 2017. Would not worry about it. But in the future ask if work is needed before sinking hours of work into something. Also I'd not use reddit account named same as your github and other accounts if you post in "questionable" subreddits. This is like internetting 101.
/r/golang *gasp*
You should not assume, for example, that Bundler is the right hammer for every nail. Like the repo author, I won't use Bundler for creating a new gem (Why would I? It is just a directory with a lib/ directory in it, and a Rake file or .gemspec file - nothing more is needed; especially for library gems). And I can drop an unneeded dependency, although that point is moot now that Bundler is part of Ruby... Rubocop is a fine tool but one has to really create a custom configuration if it should be of any use because yes, diversity. So you can't assume your Rubocop configuration is valid for everyone. If you contribute to a Ruby project, just have a look at the used style and follow it when you make contributions. It makes the whole process easier for you and for the maintainer.
In order to call `evaluate()` from outside RPNCalculator you first need to obtain an instance of RPNCalculator: RPNCalculator.new.evaluate('11+') If all you need are just functions, not objects, you can also change the definition for RPNCalculator to become a module with functions instead: module RPNCalculator module_function def sum(array) # ... end end The effect of `module_function` is the same as defining methods with `self`, which others have already suggested as a solution to your problem (e.g. `def self.sum(array)`). In order to understand why this is, search for "instance methods" and "class methods" in ruby.
If I am a owner of open source project, I’ll make it easy to contribute - using *modern de facto* tools, automated tests and code linters etc. It’s totally up to owners/maintainers though.
A long while ago, /u/binarycleric taught me about a rarely-known class in the stdlib called [`IPAddr`](https://ruby-doc.org/stdlib-2.4.0/libdoc/ipaddr/rdoc/IPAddr.html). I cannot speak to ordering by IP in Sequel, but `IPAddr` will do what you want in pure Ruby: [1] (pry) main: 0&gt; require 'ipaddr' =&gt; true [2] (pry) main: 0&gt; q = [{id: 1, ip: '192.168.1.2'}, {id:2, ip: '192.168.1.234'}, {id:3, ip: '192.168.1.10'}] =&gt; [{:id=&gt;1, :ip=&gt;"192.168.1.2"}, {:id=&gt;2, :ip=&gt;"192.168.1.234"}, {:id=&gt;3, :ip=&gt;"192.168.1.10"}] [3] (pry) main: 0&gt; q.sort { |thing,other| thing[:ip] &lt;=&gt; other[:ip] } =&gt; [{:id=&gt;3, :ip=&gt;"192.168.1.10"}, {:id=&gt;1, :ip=&gt;"192.168.1.2"}, {:id=&gt;2, :ip=&gt;"192.168.1.234"}] [4] (pry) main: 0&gt; q.sort { |thing,other| IPAddr.new(thing[:ip]) &lt;=&gt; IPAddr.new(other[:ip]) } =&gt; [{:id=&gt;1, :ip=&gt;"192.168.1.2"}, {:id=&gt;3, :ip=&gt;"192.168.1.10"}, {:id=&gt;2, :ip=&gt;"192.168.1.234"}] 
Nice work! A fun read.
Thank you! I'm glad that you like it.
In addition it's quite a good idea to store IP addresses as long (numbers). Especially if you want to sort them and/or do inclusion checks (e.g. is this IP between X and Y aka. range) on a database level. require "ipaddr" range = IPAddr.new("192.168.2.0/16") puts range.to_i # 3232235520 (equals base / 192.168.0.0) puts range.to_range # 192.168.0.0..192.168.255.255 puts range.include?("192.168.4.123") # =&gt; true puts range.include?("192.167.4.123") # =&gt; false https://repl.it/L765 Alternatively you can use database specific sort functions to solve this: [MySQL](http://matthewvince.com/2011/08/04/sorting-ip-addresses-in-mysql/) or [Postgres](https://stackoverflow.com/questions/2646710/order-by-in-postgresql-to-sort-ip-address)
What database are you using? Postgresql has this: https://www.postgresql.org/docs/9.1/static/datatype-net-types.html Never worked with it, but i might give you sorting support?
Can anyone provide summary or transcript?
Jackpot my friend, actually "workers 1" is not the same that deleteling the line allthogether.. I was spawning a master process that I was never going to use (and worse, because of preload_app! all my code was loading from the beginning). Deleting that line and preload_app! killed those unnecesary master workers and allowed me to cut the memory usage a very good deal (35-40% aprox)!
In the past, I’ve stored ip addresses with two integer columns for the first and last number of the range. This makes comparison and sorting in the DB pretty easy. 
- one guy is doing this on his spare time - GCC is better than other because (license, is used by everyone, opensource) - implementation is still on a initial phase. He needs another year to make it stable - even so, performance is almost three times faster than ruby 2.0 - no inline performance yet. 
sqlite3
You're not actually using that in production where you have more than one user, right?
Thank you! Is this THE path forward for Ruby 3’s performance boost or is it just a possible path?
No it's actually a side project of mine built on a RPi, so there aren't many different environments. 
The code in this book is Java but the material is still great.
Is there some bug in the Hoe codebase that prevents it from functioning if the current calendar year is 2017?
This is the one that Ruby code dev's like it :)
I'm sure it works just fine. It's just a dependency you don't really need. It always trips me up when project doesn't have .gemspec file. Oh, it's part of Rakefile for some reason. Publishing of gems can be done without it too. I think `gem` command supports it (or will in the future). I use this for years: https://github.com/svenfuchs/gem-release
Yeah, I use `gem push` to publish gems. I don't use Rake, Hoe, or Bundler for my ruby libraries, fwiw. Your comment struck me as suggesting Hoe is no longer fashionable. Fashion just doesn't even cross my mind as a programmer (in the context of programming).
Not a bad write up at all :)
Less about fashion more about keeping up with the times. Jeweler was a thing to publish gems too. Devs in general agreed that writing your own .gemspec does not warrant extra tools like Hoe, Jeweler, etc. http://yehudakatz.com/2010/04/02/using-gemspecs-as-intended/ I wonder how you get around not using bundler though. Can you link to one of your gems?
Thanks :)
Great read! The last exercise was confusing. Why did some elements get pushed to ary and not others? Is it because of precedence?
&gt; Less about fashion more about keeping up with the times. That is actually precisely what I mean by "fashion." &gt; I wonder how you get around not using bundler though. Can you link to one of your gems? Sure thing! https://github.com/ntl/test-bench
sweet. I bet there are lots of people doing that `workers 1` thing for no good reason. good to know. 
Thank you!
For others who are thinking of making these kinds of PRs, consider that it's a bit rude to drop into a project and start re-arranging things, changing build tools, autofixing things with Rubocop, etc. Yes, in some cases the maintainer might be a Ruby newb and be thankful that you've put them on the path towards "current best practices". But it's also possible the maintainer has been doing things a certain way for a long time (use of Hoe would be a hint...), has a workflow ingrained in their fingers (and perhaps external tooling), and doesn't appreciate changes for the sake of meeting the current "fashion", as another commentator put it. Rubocop in particular is *very* opinionated by default and it's annoying that people have latched onto that default as the "correct" way to write Ruby.
Slides are here: https://vmakarov.fedorapeople.org/VMakarov-RubyKaigi2017.pdf
&gt;one guy is doing this on his spare time I always find it astonishing to find people with this much intelligence and motivation. The open source world owes much to people like him. 
When publishing libraries for public consumption and expecting participation via bug fixes, I think it's a good idea to have something that majority of people are familiar with. Bundler and Rake are so ubiquitous that it would be weird not to use them right now. That might change in the future as they get out of "fashion".
Yes, it's about precedence and boolean logic. Everything before the &amp;&amp; operator gets evaluated first, so the following are equivalent. ary &lt;&lt; 1 &amp;&amp; false (ary &lt;&lt; 1) &amp;&amp; false The next line fails fast because the expression evaluates to true at the point where you hit the || operator (true || anything = true). Nothing after that operator is executed. true || ary &lt;&lt; 2 true || (ary &lt;&lt; 2) The next line fails fast for the same reason - the expression evaluates to false when the &amp;&amp; is hit (false &amp;&amp; anything = false), so nothing after that gets executed: false &amp;&amp; ary &lt;&lt; 3 false &amp;&amp; (ary &lt;&lt; 3) The last line continues execution because the expression is false when it hits the || (because false || something could equal true or false): false || ary &lt;&lt; 4 
You probably want to be using sort_by here: q.sort_by { |thing| IPAddr.new(thing[:ip]) }
&gt; one guy is doing this on his spare time I thought Matz and a few other core Ruby developers, and TenderLove were involved in this. I heard it on a podcast published some time in 2016 IIRC.
Always nice seeing new content on your site. Interesting problem at the bottom. Returns [1,4]?
Hoe was great stuff — ten years ago. Developer experience and project management have made *ginormous* improvements since then (says this conservative, cautious dev). There's a difference between hipster trendy and mainstream productive, and Bundler crossed that chasm well over half a decade ago. Hoe is also maintained by the group that originated MiniTest, Flay, Flog, and a ton of more niche packages. They apparently never bothered to get the hang of GitHub ("*social* coding") sufficiently to use issue tracking, repo-integrated releases, or even bother to render their READMEs properly; the attitude apparently is "hey, learning Ruby was tough for *us* back when HP just made printers and calculators; why shouldn't we build our treehouse to make it that hard for other people to get in?" Which is absolutely their prerogative, but it's hardly an attitude that fosters inclusiveness and helpful learning. Isn't that the core of MINASWAN? Being kick-ass dudes who sling code, yeah, that is and always has been worthy of respect. But we as a craft industry have moved on to demand of ourselves and others more than that.
Two words: *bus factor.*
I don't understand why you'd do this, or how that solves the problem... Surely if you were to go down that route, then you'd need **four** database columns?
Yes! Thank you.
Thanks for a comment, I appreciate it. Yes, it returns [1,4], you're right :)
if only i had RoR exp and wanted to move to nyc ;o 
No one besides me needs to publish releases. Anyone can contribute to my libraries by submitting a PR, which does not require rake or bundler anyways. I don't see an impediment here, to be honest.
Yeah, you’d need more columns but I don’t really think that’s a problem. Disk space is cheaper than processing power. The reason to do this is because you can index on these for faster lookups if you have a lot, and it’s possible to do comparison and ordering at the database level. EDIT: This solves the problem because you could order by (first, last) in your query. 
My favorite talk on this topic is ["Nothing is Something" by Sandi Metz](https://www.youtube.com/watch?v=zc9OvLzS9mU), a 40-minute talk that covers what Sandi Metz knows about objects and "everything you need to know about objects". &amp;nbsp; "All the things I’ve been telling people, all the different things, are really one thing. And that one thing is fundamentally the way in which I think about objects that may be different than what you think about. So I have taken the experience of the last 18 months and distilled it all down into this 30-minute talk." 
&gt; I don’t really think that’s a problem On a large system, yes it is a problem. This makes the database queries more complicated, which is inefficient. For example, if you store the IP as four fields and want to check if two records have the same IP address then you need a more complex query like: `....WHERE ip1 = 123 AND ip2 = 66 AND ip3 = 1 AND ip4 = 100` ...Or if you want a uniqueness index on the table then this now needs to be a composite key across all four columns. ...Or if you want to check whether an IP is within a given range then this query could become WAY more complicated. &gt; This solves the problem because you could order by (first, last) in your query. This *only* works fully if you have **four** columns, and you sort by (first, second, third, fourth). --- If your database supports it, you should ideally store the value as a native field type - such as [`cidr` in Postgres](https://www.postgresql.org/docs/current/static/datatype-net-types.html). If not, then you could store the IP Address as a (32-bit) integer. Since it's [easy](http://www.ipaddressguide.com/ip) to convert between this and the original IP address, plus sorting is also easy. (But performing more complex comparisons/operations is not so trivial, which is why a native database type should be preferred.)
Ah yes..."I'm not qualified for the position nor am I interested, but I've got this great idea..." Classic. 
Correct me if I'm wrong, but I think gem's homepage should not point to your personal homepage, but rather a page related to the gem. In most cases it's just Github repo again, unless the library has dedicated page for documentation.
Use an IDE with a debugger and set breakpoints to step through the trace?
Well said. Also I see you know all about dozens of rejected PRs trying to format README to markdown. Here's another mystery. Minitest has about 350 closed PRs yet none of them were ever merged. Author just manually does the fix and closes PR. What's up with that?
Thanks I didn't thought of that I'll fix it immediatly if I found how ;)
Why cram Rspec into a basic gem? Ruby already ships with Minitest. http://guides.rubygems.org/make-your-own-gem/ is a very good guide for creating a "basic" gem.
I didn't even realize it was in my bundle config until late. Between that and kids having trouble sleeping, I didn't get around to fixing it. 
(1) Use postgres. (2) If you absolutely must use sqlite, do the conversions in ruby and store both the integer and string formats in separate columns. (3) If you absolutely can't change the schema, you can emulate `ntoa` and `aton` in your queries using [sqlite functions](https://sqlite.org/lang_corefunc.html).
I suppose I misunderstood the problem. I’m not seeing why you’d need 4 columns. I was also assuming we’d want to store a range (cidr represents a range), rather than a single address. If you want just a single address, an integer column works great. My approach was to use two integer columns to represent a range. Of course, if your database supports a type for IP addresses, use that. 
I think they thought you were proposing to store each octet as a separate column.
Oh haha. Yeah, no definitely not that. I guess I skimmed over the fact that an IP address can be converted to an integer, and a range could be represented as two integers. That’s what I meant. 
What do you host this on?
hehe happens every single time. is RoR exp that significant to have? it seems pretty easy
In this case, for this job; yes. 
I feel like we're soul sisters; but cant someone just pick up RoR in a few hours? minutes even
...no one's ever called me sister before. I don't know if Ruby on Rails is THAT easy...
first time for everything! well i wish you the good lucks in your quest to acquire RoR talents for the city of new york; if the offers ever extends to remote (or maybe a couple(3-4) commute days a month) pick up this bananular reddit phone and send me an inbox message. I'm building a few sites in RoR now (just picked it up few weeks ago) and will probably have some experience in the futures 
Hah thanks. You should register at www.untapt.com! We're always getting more clients, so who knows. We might move closer to you!
Cool
I spoke to Vladimir in person and he said he gets to spend 50% of his time at Red Hat on MJIT. EDIT: Also MJIT isn't really comparable to the complexity of TruffleRuby. MJIT is just a JIT, TruffleRuby is a completely new runtime.
[Actually, Ruby doesn't have a testing lib since 2.2.0 :\(](https://github.com/activewarehouse/activewarehouse-etl/issues/144#issuecomment-73662802) It makes no sense.
Oh yeah. I remember reading about it. Seems like it's bundled but not part of the stdlib: https://stdgems.org/ Odd decision. 
I have been looking into The Odin project and wondered if it was worth it. Did you go into it already knowing how to code a little or were you a newbie?
Bummer about the captions. Sounds like an interesting talk.
Ah, I see. Very interesting. Thx. On the topic of precedence, [here](http://www.virtuouscode.com/2014/08/26/how-to-use-rubys-english-andor-operators-without-going-nuts/)'s a nice article on the use of *and* and *or* as control flow operators.
I'd bet that the changes were manually made so that there's no record *on GitHub* that particular changes are associated with individuals outside their littlle boys' club. I haven't been able to come up with any other explanation that's either less offensive or able to explain the publicly-visible facts. I'm seriously on the lookout for alternatives to Flay and Flog. Reek is doing a fine job as a "second set of eyes" but I _do_ like having two tools doing that sort of analysis; I learned that lesson with RuboCop. (Fine tool, great community, but introducing Reek into RuboCop-blessed code was a humbling revelation.) They're free to swing however they want to; that's part of the point. But deliberately disrespecting the tools and the wider community built around those tools (that would otherwise happily pay homage to great work) really doesn't do good things for anybody.
I'd be pretty annoyed if I spent non-trivial amount of time fixing something and my commit would never appear in the gitlog for that project. Without knowing real reason, this seems rather obnoxious. Gonna implement Rubocop in my project as soon as refactor everything and get style consistent. Dealing with code complexity is a lot of work though.
I've been using, and evangelising, RuboCop for a few years now. [Reek](https://github.com/troessner/reek), on the other hand, detects legal but highly questionable ways that you're using code, and has great doc to explain why you really probably don't want to do that. Belt, meet suspenders.
&gt; if you’ve been doing Rails for awhile by returning false in one of your callbacks (DISCLAIMER: I am not up to date on edge Rails practices, but I don’t believe Rails 5 works exactly this way anymore so check your facts if you want to use the callback halting feature) Really?? You could have [googled the correct answer](http://guides.rubyonrails.org/active_record_callbacks.html#halting-execution) faster than it took to type out that disclaimer! Improved debugging was one of the key reasons why this change was made: You need to *explicitly* `throw :abort` to halt a callback chain. (Or, if an exception is raised, it's a bit more obvious where it came from.)
Note: The safe navigation operator (`&amp;.`) is equivalent to [`Object.try!`](https://apidock.com/rails/Object/try%21), not `Object.try`.
Note: Ruby 2.3+ 
Note: dead dove, do not eat
That's fair - I'll edit the post and add the link to the Rails guide. The point of the post was to shed light onto `halted_callback_hook` as a feature though, not dig into how callbacks work (there's quite a lot out there on that), so hopefully that didn't seem lost in the mix
This is what I imagine most people do (or some form of breakpoints/puts statements). It still feels more cumbersome in my opinion, and the AS::Callbacks code can be confusing if you're not used to it. This approach feels more direct to me It's worth noting that an IDE is not necessary, and the `byebug` gem alone works fine for this (and is likely what your IDE will use under the hood)
[“Considered Harmful” Essays Considered Harmful](https://meyerweb.com/eric/comment/chech.html)
Hmm, there are some legit points made in this article, will keep that in mind next time. Thanks!
I’ve been thinking about reimplementing io using FFI. Not sure if FFI releases the GVL or not.
This was already mentioned in the article. A couple more interesting points about `Object#try` are: 1. The behaviour [changed](https://apidock.com/rails/v4.0.2/Object/try) in Rails 4; previously, `object.try(:foo)` raised an exception if the object is not `nil/NilClass` and does not respond to the method; now it returns `nil`. 2. `nil.try(:foo)` *always* returns `nil`, regardless of whether `nil` responds to the method. So for example, `nil.to_i == 0` but `nil.try(:to_i) == nil`.
Which "core IO" have you found to be misbehaving?
Were you not able process the event stream in parallel back when you were using ruby? For instance, you could have given four different ruby processes each one fourth of the events. What tool were you using for event streams?
stdlib/core IO functions should generally not block without releasing gvl. If you find one that does, maybe file an issue on ruby bug tracker? I don't know of any reimplementation of those that is a drop in replacement though. There are alternatives, some using evented architectures, but none I know of that you can just drop in and have existing code use them with same names and APIs. 
&gt; Were you not able process the event stream in parallel back when you were using ruby? Of course, no way you can processing 3k anything a sec on MRI with a single process unless it's completely trivial. Ruby was running on 12 cores across 3 boxes, 1 process per core (it was CPU bound) could handle around 5k ev/sec max. Rewrite in Go has 4 cores across two boxes and peaks at 11k ev/sec. &gt; What tool were you using for event streams? This particular process was reading pre-batched files from S3, applying some transformations then writing them to a data store.
I agree it is _often_ a workaround for bad design, but maybe not as often as the OP thinks. I think it's got a place even with good design. But and we got a lot of bad design to work around in most of our daily coding lives. Separately, whenever this comes up, I think about the fact that ObjectiveC originally behaved this way for _all_ unimplemented messages -- they just returned nil. But modern ObjectiveC I think no longer does that, at least generally. For what uses ObJC is put to now, apparently the designers/developers agreed it was not helpful. I am not sure if Smalltalk did/does this too, but much of ObjC was motivated by Smalltalk so I wouldn't be surprised. 
I first noticed it with `File.exist?`, which I reported and submitted patch for ( https://bugs.ruby-lang.org/issues/13941 ), but now I noticed that `FileUtils.rm_r` seems to be also blocking. I suspect there are more (no evidence though, didn't test it).
&gt; stdlib/core IO functions should generally not block without releasing gvl That's exactly what I always thought, that's why I was surprised &gt; If you find one that does, maybe file an issue on ruby bug tracker? Already did for the one I found ( `File.exist?` ) and it's patched now ( https://bugs.ruby-lang.org/issues/13941 ), but I noticed that `FileUtils.rm_r` seems to also block. So I think the issue is pretty wide-spread :/ That's why I was wondering if someone bothered to rewrite IO without gvl already :/
&gt; Not sure if FFI releases the GVL or not. no idea but according to https://bugs.ruby-lang.org/issues/11607 it should
[Slides](https://vmakarov.fedorapeople.org/VMakarov-RubyKaigi2017.pdf).
&gt; That's why I was wondering if someone bothered to rewrite IO without gvl already If they did, it'd probably already be in stdlib/core, right? 
probably, but it always could've been rejected on performance ground; after all, releasing the gvl does add some overhead
Eh, it's clearly the documented intent of MRI to release the gvl on all IO operations from stdlib/core. With maybe a couple exceptions here or there, it's a bug if it doesn't. But there may be many such bugs. 
Full disclosure: I work with the author.
Whys poignant guide to Ruby. 
Does that essay apply to itself?
Good article, many nice ideas there for dealing with nil.
For those overlooking the `[JA]` tag: the talk is in Japanese.
Why wouldn't you be able to put methods in a super class?
Unreadable on mobile.
Without a type system this is often the only tool in your belt.
[removed]
Do you mean the code snippets wrapping, or something else? That's the only thing that stands out when I open it on my phone.
THe code snippets don't even show up for some reason. IOS
Uuugh, that sucks. I'm on Android myself, so I can't see it. When I get to the office tomorrow I'll have someone with an iPhone take a look. Thanks for the report!
You should look at sidekiq gem. It has a embedded web admin interface.
Hah you beat me to it
Objective C never returned `nil` for unrecognized messages. `nil` does respond to all messages with `nil` though.
In Rails, or any web MVC framework, controllers only start to go bad when they start dealing with things other than the web (i.e. HTTP request/response). I would not _add_ a library to make it easier to manage having complex controllers that carry out duties beyond HTTP. Instead, I would move concerns into objects that the controller depends on.
I'm thinking you could temporarily add a column to your new table, maybe called `old_pk` or something. Once the new table is populated, you could join on the dependent tables (using `old_pk` and `type`) and update records to use the new auto-incremented PK. Then, drop the `old_pk` column. For this case it probably makes sense to write the backfill queries in raw SQL for efficiency. Also, this doesn't really solve your immediate problem, but consider using UUID PKs in the future to avoid stuff like this.
I don't know about Discord, but there are multiple Slack and IRC channels. Rubyists tend to be pretty friendly, so you might want to see if there's a local Ruby Users group in your area.
Great idea! I'm sure just having the right raw sql query to match on old_pk and then an update with the new autoincremented PK would do the trick. Thanks for the suggestion, and yes UUIDs would solve this issue, I've already started to add them. 
"Suppose you have an object hierarchy" that's the antipattern 
Im on iOS 11 and have no issues reading it. 
GoRails has a great Slack channel. Very informative videos. It’s worth the few bucks a month IMO. I’ve learned a lot. 
Maybe: response.map { |name, **args| "#{name}: #{args}" }
What’s the thing? “Prefer composition over inheritance”? I always find it hard to come up with examples to illustrate that, but here it is. 
I currently have an Ember + Rails API app and I think it is not particularly different to what you are doing. I recommend watching this video on ember-cli-deploy and see if you can make it fit to your needs: https://www.youtube.com/watch?v=QZVYP3cPcWQ. Essentially, you can build your ember app for production and deploy it to some asset host (I use amazon S3) and use your Sinatra app to render an `index.html` that includes `&lt;script&gt;` tags that will load your Ember app.
Seems like Ruby modules is a sort of multi-inheritance solution. For all the reasons to prefer composition over inheritance, it might be more flexible to use something like the [Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern) to accomplish this. From the Wikipedia entry: &gt; According to the strategy pattern, the behaviors of a class should not be inherited. Instead they should be encapsulated using interfaces. As an example, consider a car class. Two possible functionalities for car are brake and accelerate. &gt; &gt; Since accelerate and brake behaviors change frequently between models, a common approach is to implement these behaviors in subclasses. This approach has significant drawbacks: accelerate and brake behaviors must be declared in each new Car model. The work of managing these behaviors increases greatly as the number of models increases, and requires code to be duplicated across models. Additionally, it is not easy to determine the exact nature of the behavior for each model without investigating the code in each. &gt; &gt; The strategy pattern uses composition instead of inheritance. In the strategy pattern, behaviors are defined as separate interfaces and specific classes that implement these interfaces. This allows better decoupling between the behavior and the class that uses the behavior. The behavior can be changed without breaking the classes that use it, and the classes can switch between behaviors by changing the specific implementation used without requiring any significant code changes. Behaviors can also be changed at run-time as well as at design-time.
**Strategy pattern** In computer programming, the strategy pattern (also known as the policy pattern) is a behavioural software design pattern that enables selecting an algorithm at runtime. The strategy pattern defines a family of algorithms, encapsulates each algorithm, and makes the algorithms interchangeable within that family. Strategy lets the algorithm vary independently from clients that use it. Strategy is one of the patterns included in the influential book Design Patterns by Gamma et al. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
AWS Beanstalk. As easy to use as Heroku but cheaper. 
Drop the parens from the proc definition. This works: response = [ ["James", { species: "cat", age: "4" }], ["Sandy", { species: "dog", age: "7" }], ["Horse", { species: "man", age: "34" }] ] response.map do |name, species:, age:| "#{name}: #{species}, #{age}" end
 {}.tap do |new_hash| response.map { |key, value| new_hash[key] = value } end #=&gt; { 'James' =&gt; { species: 'cat', age: '4' }, 'Sandy' =&gt; { species: 'dog', age: '7' }, 'Horse' =&gt; { species: 'man', age: '34' } }
Yes, you're right, that's what I was thinking of and analagous to `try`, that's what I meant I miswrote! Thanks! 
Thanks for finding and submitting the patch! The only possibly relevant I/O work I'm aware of is Eric Wong's kgio and Tony Arcieri's nio4r.
Unreadable on desktop for anyone older than 30 or with imperfect vision or a less-than-spectacular monitor. The sooner we get over this light-grey-on-slightly-lighter-grey hipster fetish, the better off our eyes will be. EDIT: And oh, the joys of non-responsive mobile-first-last-and-only layout! On what now is a midrange desktop monitor with 2560x1440 resolution on a 27" diagonal, the single content column is a mere 10 cm wide, giving the viewer the choice of either the original, unreadable layout or a black-and-white, larger-font "reader view" display that wraps most lines of code, often two or three times. Surely great software can have better-than-mediocre presentation?
I think this is the winning solution! Thank you. I've learned this works because an array whose last element is a hash cleanly corresponds to a parameter list. It solves my case very neatly. Next challenge: solve it for the general case, where the hash is not necessarily the last item in the array, or for a hash nested inside the hash. 
Well ... Maybe. 
You *could* also consider using a composite primary key. But rails famously doesn't support this out-of-the-box, so you'd have to use an [extension](https://github.com/composite-primary-keys/). I definitely prefer this cleaner approach of sticking to rails conventions and migrating the data via a temporary column though. 
Would be curious on the performance difference, if any, from coach compared to a whole list of ‘before_action’ methods
News flash: Bundler is part of the standard library with effect from Ruby 2.5. So all those "I don't use hipster tools like Bundler" poseurs just got iced Gatorade poured down their shorts. Enjoy, guys.
It's not broken, it's more strictly enforcing usage to avoid deadlocks.
Do you know if other multi-process servers are effected, such as [passenger](https://www.phusionpassenger.com) or [iodine](https://github.com/boazsegev/iodine) (both serve Ruby apps but written in C++ and C)?
If I understand correctly the problem affects programs that do something between fork() and exec(). If passenger/iodine call exec() right after fork() or don't call exec() at all then they shouldn't be affected. It's just a guess though... This is the best (and only?) resource that describes the issue http://www.sealiesoftware.com/blog/archive/2017/6/5/Objective-C_and_fork_in_macOS_1013.html
You're right but apparently Ruby doesn't conform to the rules enforced by the OS. Before 10.13 it didn't trigger any errors but it does now. Please correct me if I'm wrong? 
You can also have this and more with OpenStruct. http://ruby-doc.org/stdlib-2.0.0/libdoc/ostruct/rdoc/OpenStruct.html Not saying one is better than the other, just check your needs and options.
OpenStruct allows the option to instantiate a struct via keyword parameters, but I feel that it falls short on other aspects that I'd use `Struct`s for. Namely: (a) Can't separate the 'class' from the 'instance of the class'. By being able to define a class for each `Struct`, one gets to specify structure + accessor methods in one place. Also, when printing/inspecting a struct, it has a friendly type attached to it. i.e. `Struct::Customer`, instead of just `OpenStruct(name: "Paul")` (b) Can't catch errors where a wrong attribute name is used, since an OpenStruct accepts **any** argument. NamedStruct prevents this by throwing an ArgumentError if a provided argument is not a member of the struct. IMO OpenStruct is more close to `Hash`/`HashWithIndifferentAccess` than it is to `Struct`. 
I also find it funny that we never seem to be able to come up with better examples of where to use inheritance than animals and shapes.
There's no way to do it in the database unless: a) the database supports a native IP address column type that it sorts properly for you. ([Postgres does!](https://www.postgresql.org/docs/9.1/static/datatype-net-types.html)), and you use it, or b) You 'normalize' your IP addresses into something byte-order sortable, and store that in a column in your db you can sort on. If you do either of those things, you will just use ordinary Sequel sorting to sort. I guess there's a third option, c) Do some kind of sort based on SQL function calls in the sort to 'normalize'. But I would not do this, it'll be a pain, and won't scale to a large table since it won't use an index. I guess you _could_ make an index based on the same func (in postgres anyway) too. But anyway, option C is not the one I would take unless I had a good reason to, it'll be confusing and a pain to get right IMO. 
The note says it was always a dangerous thing to do full of race condition. And now it's been (by default) prohibited. I'm curious if this is true on other OSs too (Linux and unixes), or if it turns out it requires some OSX-specific code around here. I suspect it's actually the latter?
The beauty of passenger is the devs really know what they're doing and do it as full time jobs, I bet they'll fix it quick if it requires fixing. /u/foobarwidget ?
According to the pthread_atfork docs [1] &gt; It is suggested that programs that use fork() call an exec function very soon afterwards in the child process, thus resetting all states. In the meantime, only a short list of async-signal-safe library routines are promised to be available. So it looks like in Linux it's discouraged but not prohibited. [1] http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_atfork.html
Sidekiq is not affected, it does not fork.
nice, thanks. Sounds like it might actually be similar, a likely race condition that you ought not to do? Seems from the OSX note that the race condition may be even more likely in OSX, especially in 10.3. But if it's really the best practice in Linux too, that might make it less frustrating for those who have to fix their software for OSX, they really oughta have been doing it all along for Linux too, to avoid rare race conditions. :) (at least if their code under linux calls anything but the "short list of async-signal-safe library routines" in the interim period). 
oops, obviously you're right. Sadly I can't edit the title...
Passenger is also affected. Even though Passenger is mostly written in C++, this issue affects the Ruby side of things. I remember a similar issue from the early Ruby 1.9 days. The Ruby devs would not allow calling Kernel.fork if one or more threads had been spawned before fork. The rationale was the same as what was given by the macOS devs: a fork at the wrong time could cause all sorts of problems. The ability to fork after having spawned threads was so popular that the Ruby devs gave in and removed the restriction. But they never fully solved the problem (and indeed, they could not): they only solved code within Ruby itself that could cause problems after a fork, but third-party C extensions and libraries can still do all sorts of stuff that could cause problems after fork. Though in practice this has not proven itself to be a big problem. I think the best thing we can do is setting OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES, as mentioned in the issue report. Seeing that doing stuff after forking hasn't been a big problem so far, I expect that setting this environment variable is enough, but only time will tell because the extend of the changes in High Sierra aren't well-understood yet. *Maybe* Passenger can inject a native extension that initializes Objective-C classes before fork (which the blog post says might work), but more testing is needed before I can say for sure whether that works. In any case, we plan on releasing a Passenger version soon that will incorporate whatever fix there is as a default option so users don't have to think about it.
I also find it funny that we never seem to be able to come up with better examples of where to use inheritance than animals and shapes.
&gt; Even though Passenger is mostly written in C++, this issue affects the Ruby side of things. The OSX issue isn't really ruby-specific at all though, is it? Applies to C++ just as well, no? Am I misunderstanding the underlying issue? (I'm sure I am, what used to be called "systems programming" is not my strong point). 
There are places where composition fits better than inheritance and vice-versa. Inheritance serves best when two objects are in _is-a_ relation (Cat is a Animal). Whereas composition for object that are in _has-a_ relation (Bicycle has a Wheel). Read more: Sandi Metz in "Practical Object-Oriented Design in Ruby" s.188
Spot on. In addition to that, even though you instantiate an `OpenStruct` with a certain set of arguments, an `OpenStruct` instance still accepts *any* method calls, returning `nil` for methods that don't match any attribute. That for me is even worse than a `Hash`, because with a `Hash` I can at least use `Hash#fetch`.
&gt; 2017, running webservers directly on your development machine Gotta get on that docker life.
Thanks for the link! It helped me focus the issue.
I have read this so often, but I still have not understood why. So I'd really love to see examples of this. IMHO in most cases things are just not hierarchical in nature. I almost never use inheritance.
Strictly speaking you are correct, it isn't really Ruby-specific. It isn't OS X-specific either, as /u/snatchery commented above based on the Open Group's man pages. The thing is that the Passenger C++ codebase is carefully written to not perform any non-async-signal-safe operations after fork. The Ruby side of things has to run arbitrary code provided by the user, so we have no control there over what exactly happens before and after fork.
@jrochkind, Thanks for linking to FooBarwidget. You're obviously right about the beauty of having a paid development team and financial backing, and I'm very happy for the passenger team (although I don't fancy paying for the enterprise edition to get multi-threading). I'm the author of the `iodine` server and I don't have this privilege, even though I try to offer a free alternative to the enterprise edition (evented, multi-threaded and multi-process concurrency model with the added bonus of native web socket support)... Also, I can't seem to upgrade to High Sierra just yet (I'm also a musician and my upgrade schedule is dictated by Avid and other audio software/hardware vendors)... which makes it almost impossible for me to test or debug the issue by myself (unless someone volunteers to get me a new MacBook Pro). However, the solution, for now, seems to be to set the environment variable `OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES`, which I can easily do (I just have no idea if it will actually do anything, since I can't test it). Anyway, thanks for the info.
&gt; The thing is that the Passenger C++ codebase is carefully written to not perform any non-async-signal-safe operations after fork. &gt; The Ruby side of things has to run arbitrary code provided by the user, so we have no control there over what exactly happens before and after fork. Does that mean that the C++ codebase will run as expected if the user's Ruby code doesn't use `exec`?
The C++ codebase will run as expected regardless of whether the user's Ruby code uses exec or not; and even regardless of whether the user's Ruby code crashes or not. Passenger uses an out-of-process architecture: the main C++ server runs in a separate process from the Ruby application, so errors in each component is isolated.
@blbil , You're obviously right to a degree. However, I prefer the speed of developing on my machine when I'm just messing around with experimental ideas. As a sidetone (although a somewhat outdated sidetone), this isn't just a development issue. I did get to deploy on macOS servers or computers (usually intranet apps for small offices and firms)... besides, some apps and data should never be exposed to the evil internet (not my philosophy, but I don't argue much with the people that foot the bill). Installing Vagrant or Docker on these localized (and disconnected) systems is sometimes a resource and maintenance price that just isn't worth it.
aha, that makes sense. would it be possible to just fork and immediateley exec before any ruby code gets run?
When Passenger Enterprise prices were public, I found them quite reasonable, but I do find making them no longer public to be a pretty big step backwards in how software is sold on the internet. :(
(sound of JRuby squeezing hands saying "excellent, excellent" in a Mr. Burns voice)
I'm trying to come up with a summary of the issue; please assist: 1. macOS includes an **Objective-C runtime** 2. macOS includes an **OS framework** based on the *Objective-C runtime* 3. **Objective-C classes** defined by the *OS framework* are `fork-unsafe`, meaning that `fork()` callers should not execute code before calling `exec()` 4. **macOS 10.13** includes a **macOS 10.13 SDK** (presumably based on the *OS framework* but not responsible for defining the *OS framework*'s classes) 5. **macOS applications** built with the *macOS 10.13 SDK* are able to use new SDK features in order to execute Objective-C code between `fork()` and `exec()`, therefore achieving the `fork-safe` property when used correctly 6. There remains a tension between `fork-safety` and `thread-safety`, due to the structure of the locks held by the *Objective-C* runtime 7. As such, there are restrictions in the *mac OS 10.13 SDK* about the nature of calls to `+initialize` between calling `fork()` and `exec()` 8. Thus, the new capabilities in the *mac OS 10.13 SDK* for calling code safely between `fork()` and `exec()` are guarded by protections which enforce the limitations to `+initialize` in order to maintain `fork-safe` and `thread-safe` properties What is the connection to Ruby on macOS 10.13? I'm not very familiar with this platform, but it would appear that the affected Ruby libs on macOS are making use of the SDK, calling `fork()`, and running into the new behavior.
This is interesting. Have you considered writing this behaviour up as specs in `ruby/spec`?
Topics include: - 10 Years of Fiber by Koichi - A recap of where Ruby 3x3 goals are by Noah Gibbs - The process of "gemifying the stdlib" by SHIBATA - How to optimize Ruby internals by Shizuo Fujita - A Typhoon - Sake 
I was mostly being facetious lol, the benefits of Docker comes when you want your local to be like your production. Makes sense for prototyping purposes to just run locally.
I'd file an issue asking that on the pundit repo, and wait at least a couple weeks. 
Prices are once again public. A while ago we were experimenting with the effects of non-public prices. The results aren't to our liking so we have gotten rid of that. We have even changed the pricing model: we now charge based on the cluster's total RAM, instead of the number of servers. This is friendlier towards microservice architectures and containerization.
This is great. Reminds me of Railscasts. Nice work!!
awesome, i'll go check em out again! 
Yes. If you for example implement that operation as a C extension then it'll work. If you implement it in pure Ruby then it *should* work but I cannot know for sure until I've tested it myself, because the Ruby interpreter can perform all sorts of stuff under the hood between that fork() and exec().
Oh interesting I'm not familiar with that project. I'll see if it is the kind of spec they are interested in having added.
Thanks for doing this writeup, very helpful. That "how to optimize" session sounds especially useful.
That's awesome. Neat find! 
Note to self: don't use an out-dated crib notes book based on v1 of Ruby as your go-to reference. Didn't know there was a struct.
https://github.com/ruby/spec in case that wasn't clear.
The problem with taking that bicycle example too literally is on full display -- we are _rarely_ in the business of modeling is-a relationships between two objects. When we do, roles are often the more appropriate countermeasure, not inheritance. For instance, a user might be cast into the role of a system administrator. In terms of code design, inheritance serves best for defining abstract classes that expose generic behavior that can be specialized via implementing template methods on subclasses. That's about it. POODR is a fantastic introduction to OOP, but it's not anywhere near an authority on software design.
pundit is quite a small gem and intends to remain simple; I personally feel it is more likely the case of the software is quite mature now and needs few changes.
Enterprise has a cluster mode I believe
Dont use OpenStruct in any code base where performance matters. Every time an OpenStruct is instantiated, the MRI method cache is cleared. https://github.com/charliesome/charlie.bz/blob/master/posts/things-that-clear-rubys-method-cache.md#openstructs
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [charliesome/charlie.bz/.../**things-that-clear-rubys-method-cache.md#openstructs** (master → 2170294)](https://github.com/charliesome/charlie.bz/blob/2170294940ba8c3917a06f9c095ce8a0e28d3a66/posts/things-that-clear-rubys-method-cache.md#openstructs) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnm099p.)^.
Capistrano is also built on rake tasks. Why not use capistrano?
Capistrano is more for deploying apps. It's not so suitable for configuring environment.
True. In most cases inheritance is not the way to go. When it goes for example, I can give you one form the project that I'm currently in. Application has many offers. Offers belongs to external providers. Application synchronizes offer data from that external providers, eg price changes, etc. Since the provider's APIs are slightly different it's convinient to model the classes which talks to the APIs in the way that there is a base class, which defines the interface and implements common behaviour and ancestor classes (each for provider) which have the provider-specific implementations (like translating parameters, building request, parsing response). Above can be modeled by composition, still IMHO inheritance fits better here.
&gt; For instance, a user might be cast into the role of a system administrator. How do you implement it? I'm curious. Do you extend instantialized user object by module with admin bahaviour. Do you have a separate AdminUser class which includes module with admin behaviour? By Rails STI? Other way? &gt; In terms of code design, inheritance serves best for defining abstract classes that expose generic behavior that can be specialized via implementing template methods on subclasses. I agree.
This is no longer completely accurate. OpenStruct no longer __globally__ (which was the problem in terms of performance) busts the method cache since ruby 2.1: See http://tmm1.net/ruby21-method-cache/ for more information
What is it that you find makes it unsuitable? I've certainly had success using it for simple orchestration by removing the dependency on `capistrano/deploy` and treating it as an abstraction around SSHKit and Rake. I've never attempted full scale provisioning like this however so I'm interested to hear your experiences
I appreciate ruby's attempts at staying cool with the cool kids, but it's so not gonna work when they introduce it at the cost of readability. Pretty much agree with article conclusion, except I wish they'd make it an actual language feature (why not |&gt;)
I guess it's good that this will soon be available via the standard library, but it feels so inelegant. Ruby (with proposed new syntax): "https://api.github.com/repos/rails/rails" .yield_self(URI-&gt;parse) .yield_self(Net::HTTP-&gt;get) .yield_self(JSON-&gt;parse) .yield_self { |_| _.fetch("stargazers_count") } Clojure (with some fake function names to match the Ruby example): (-&gt; "https://api.github.com/repos/rails/rails" uri/parse net.http/get json/parse #(get % "stargazers_count")) Implicit block parameters (like `%` in Clojure) would help.
No doubt Clojure or any functional language feels much more elegant. Still, it's nice that Ruby is trying to catch up. Essentially it needs 2 improvements * introduce a pipeline operator (or at least a short alias for yield_self) * introduce a method shorthand &amp;nbsp; "https://api.github.com/repos/rails/rails" |&gt; URI-&gt;parse |&gt; Net::HTTP-&gt;get |&gt; JSON-&gt;parse |&gt;(_) { _.fetch("stargazers_count") } not as elegant as Clojure but looks good enough
&gt; It’s more verbose than the original version... The "original version" is cheating. Most of the time you'll not write `foo(bar(baz(blah))))` for the sake of debugging and visibility, you'll write var1 = blah var2 = baz(var1) var3 = bar(var2) ...and the only "more verbose" thing is the `yield_self` call itself. &gt; It’s not an idiomatic Ruby. Obviously it can’t be because it’s a brand new feature What? It _is_ idiomatic Ruby, most of the time we process arrays of data in the same chainable way (and love Ruby's methods chainability), `yield_self` just adds an ability to process singular objects with the same chainability. It is just long missing idiomatic Ruby feature. &gt; Do we really need to name block arguments? What if we avoid the names? .yield_self { |_| URI.parse(_) } ...and use the common metaphor for "the unused argument". Awesome. &gt; Also, it would be nice to get rid of blocks. This is already possible but looks cryptic. .yield_self(&amp;Net::HTTP.method(:get)) Cryptic for who? Java guys? It, again, _is_ perfectly idiomatic Ruby, with "everything is an object" and "everything can become block". The only unfortunate thing here is `method` word itself is a bit too long, but the problem is planned to be addressed, as you've mentioned yourself. &gt; I regret that it doesn’t have a shorter name, say `pipe` or `apply`. This one is perfectly true :(
&gt; but it feels so inelegant. I believe it is just the really unfortunate name. For me it feels like perfect readable Ruby, with smallest change to language possible, just this `yield_self` name itself is nasty.
I like the |&gt; myself.
I think either of those options could work. Somethings to consider: * can a User have multiple profiles? This doesn’t seem likely but if so definitely have a different model/table for the profile that is associated with User. * is it optional to have a profile? If so, I think having a separate table/model makes sense. * are there a lot of attributes in the profile? If so, I think splitting the two makes sense. There are probably other scenarios where it makes sense to split the User and UserProfile tables/models. However, I think it might be a bit overboard to split them if there are only a couple of attributes in the profile and if every user will have one profile. Just my two cents. I think either implementation would work. 
Why not? It's a tool based on rake that connects to multiple machines, and runs shell scripts on those machines, according to defined roles. It seems to do what the OP tool does, already. 
I need some extra functionality like reverting one task while keeping others (e.g. uninstalling some soft). And some tasks should be disabled and reverted, but they should be reverted only on those machines on which they were actually applied and should not run on new instances at all.
I need some extra functionality for reverting configurations and uninstallation of software packages installed by previous run.
About the method to proc example, I think it's cryptic because 90% of Ruby (errr, Rails) devs have no idea you can do that right now. They just know the way that shorthand is typically used but don't really understand the bigger picture. I agree it's not very cryptic at all, but it is unfortunately something that a lot of devs don't understand. In the end it comes down to what type of app you are working on, with maintainability and dev team quality factored in.
could you build those on top of cap, meanwhile getting advantage of all the features already built into cap? If you did this, I think there'd be no reason to limit it to small 3-5 server fleets. 
Author here. Thanks for valuable comments. I'm really glad that you find the code idiomatic and perfectly readable. I assumed that some bits would be unusual for most of Ruby devs. Apparently, that assumption was wrong. And this is great. 
Yes every user will have around 35 or 40 atributes, like about_me, gender, age, location, education, likes, etc etc.
What makes people think there's something harming "readability" with `yield_self`? 
Try the pry gem with your irb if you want to debug your objects. It let's you change context to the object and perform calls from it's context. 
Correct, any Sidekiq Enterprise customers using the swarm feature on OSX may be affected but I doubt that's many.
So a quick summary: 1. This issue was caused by the native `pg` gem, which was linking to libpq, which linked to OSX's LDAP and Kerberos system libraries, written in Obj-C. 2. The server forked and **then** required `pg`, causing the Obj-C libraries to be initialized after fork. BOOM. The workaround is to `require 'pg'` before forking. Literally zero Ruby people use LDAP/Kerberos to authenticate with PG. This is a great example of how unnecessary upstream dependencies can cause massive headaches years later.
Nice idea but it's using simple erb templates https://github.com/mperham/sidekiq/blob/0d314b145c3d70a08a471f24dd2b15eae03a69ab/lib/sidekiq/web/application.rb. 
Thanks, I want to "pack" everything all-in-one into a ruby gem for convenience. My gem does nothing more than running a system command, gathering some data into an sqlite3 DB and then ember has a SPA that displays some stats in real time. I am hoping that I could use it like `bin/start` and have everything there. EventMachine can help also for concurrency but I am stuck in this silly issue and it seems something with the way sinatra uses public folders. 
After using elixir at my current job, I have grown to really like this syntax. That said, it needs some syntax sugar to be as purely useful as elixir
yep, this. 
Pry is a life saver!
Simple and to the point. That's what I love about Ruby. Less talking, much doing. Thank you.
One more important difference I've missed is that capistrano runs it's tasks from the host via ssh. But I found it more convinient to upload scripts on remote server and let rake run it's tasks there. So I can still use SSHKit from capistrano package, but only for uploading and executing of remote scripts) 
Ah, cool. You just need (the right version of) ruby and dependencies installed on the remote server then, which some people often want to avoid doing, or depending upon. A lot of the craziness of sshkit is indeed to _avoid_ needing the right dependencies on the remote server. 
Blocks are one of the best parts of ruby IMO, but yeah, also limiting in some ways. The key is to understand that a block is indeed a _special syntax_ in ruby, that allows you to send _only exactly one_ "proc" like argument, in a special syntax way. Indeed it is not consistent with other kinds of argument passing, it is a special syntax to support a particular use case. Start from there, and don't even bother trying to delineate all the ways it isn't consistent with other kinds of arguments. Blocks are blocks, not like other arguments, indeed they have special syntactic support, treat them as something to learn on their own. A special syntax that is largely what makes ruby what it is, making it so convenient and readable to pass a single block of logic to a method. 
remember to pair it with pry-byebug and pry-doc! the whole pry ecosystem is amazing. its central to how I work with ruby. EDIT: awesome_print is great too
Yes. I see. It's a great advantage of capistrano's architecture. But as I said capistrano is more for deploying projects, not for configuring environment. Of course you can do everything remote. But when you need some information about the hosts you're configuring you'll need to execute a lot of commands via ssh for gathering that information. And you'll need to store that information locally. But what if your script already was uploaded to remote host? All the you need information is here and no need to pull a tons of data over the network.
Good read, personally I am not a huge fan of the new syntax but it is great to see such a well written introduction! /u/tippr $2
u/snatchery, you've received `0.00446761 BCC ($2 USD)`! *** [^^How to use](https://np.reddit.com/r/tippr/wiki/index) ^^| [^^What is Bitcoin Cash?](https://rocketr.net/blog/2017/09/24/bitcoin-cash-a-simplified-explanation/) ^^| [^^Who accepts it?](https://acceptbitcoin.cash) ^^| ^^Powered ^^by ^^[Rocketr](https://rocketr.net) ^^| ^^r/tippr ^(Bitcoin Cash is what Bitcoin should be. Ask about it on r/btc)
You can use `Sequel::Model#[]` to access column values: class User &lt; Sequel::Model def name self[:name].upcase end end
I dunno, the output of various shell scripts to get information about hosts does not seem likely to be "tons of data to pull over the network" to me. Like, a few thousand bytes of data? I wouldn't be worried about it. It would certainly be possible to use capistrano to say "put this ruby script on the remote server, and then execute it", like you prefer, but yeah I could see it getting messy. But i haven't tried to do this. Use what works for you! If it were me, I'd start with capistrano, since it's already a tool for executing a bunch of things on a bunch of hosts written based on rake. Someone else in this thread already said they used capistrano for configuring environments, so it's clearly possible in some circumstances. It's true that cap hasn't been written for these use cases, like ansible or chef -- but if you're starting from scratch anyway, you have to write all that targetted-at-this-use-case stuff anyway. If it were me, I'd write it on capistrano, a mature tool that already exists and is already based on rake, for executing stuff via ssh on a bunch of hosts, which is intended to let you write your own custom "things to do", and there's no reason they can't include "configuring environment". 
Thank you for your advices! I'll find some time to give capistrano a try! Maybe it will do be suitable for this provisioning too)
I def haven't tried, so I could be wrong too! I just think it's def worth considering. Since it is already based on rake anyway, which was what you wanted! I will admit I've been interested in the idea of using capistrano for orchestration/provisioning-like things for some time. But I knew it didn't have built-in functions focused on those use cases like ansible/chef/puppet did and didn't want to rewrite them from scratch. But if you're rewriting them from scratch anyway.... Some people actually use _ansible_ for everything capistrano does, for that matter. There's really no reason it has to be two different tools, just that each has been focused on certain use cases. 
An |&gt; operator would be sooo much better than #yield_self 
Thanks /u/zquestz Much appreciated I didn't know you can send bitcoins over reddit. Amazing!
Thank you !
There is always a shorter way to do it in Ruby: {foo: 'bar'}.methods.grep(/to_/) #=&gt; [:to_h, :to_hash, :to_proc, :to_a, :to_s, :to_enum] Still rather readable. 
A friendly reminder: don't use an out-dated crib notes book based on v1 of Ruby as your go-to reference.
Introducing new feature requires thinking how it would play with existing syntax, features and intuitions of the language. Can you imagine, how will `|&gt;`-code look in Ruby, in different situations? 
Introducing new feature requires thinking how it would play with existing syntax, features and intuitions of the language. Can you imagine, how will `|&gt;`-code look in Ruby, in different situations? 
Who knew this bot existed?
Imo having just some pipe operator is enough for the code to look fine: "https://api.github.com/repos/rails/rails" -&gt;URI.parse() -&gt;Net::HTTP.get() -&gt;JSON.parse() .fetch("stargazers_count") -&gt;(stargazers){"Rails has #{stargazers} stargazers"} -&gt;puts() I used -&gt; for the pipe operator, It copes with lambda syntax nicely :)
Yeah the /u/tippr guys are pretty awesome. Bringing tipping back to Reddit!
yeah, great point. If only we were in an alternate reality ;)
&gt; Can you imagine, how will |&gt;-code look in Ruby I can at least dream.... "https://api.github.com/repos/rails/rails" |&gt; URI.parse |&gt; Net::HTTP.get |&gt; JSON.parse |&gt; fetch("stargazers_count") 
Those types of attributes are describing details about a user, so my gut instinct would be to put them in the user model. For example, a profile doesn't have a gender; a person does.
I'll second the recommendation to look for Ruby groups near you. Check on something like Meetup and see what's out there. My area has a Ruby/Rails group that meets 1-2 a month and also maintains an active Slack channel.
With the proposed shorthand for `&amp;Object.method(:sym)`: "https://api.github.com/repos/rails/rails" |&gt; URI-&gt;parse |&gt; Net::HTTP-&gt;get |&gt; JSON-&gt;parse |&gt; { |_| _.fetch("stargazers_count") } I wish there could be a shorthand for that last line as well. I'd use it all the time. 
Ooh, I like the idea of building stabby-lamba into the pipeline operator. 
Why make it so complicated? :) class User &lt; Sequel::Model def name super.upcase end end
Getting into a new language is not so hard if you're familiar with the basics. 
There are exist one edge case when Your solution doesn't work ;) If there will be attribute named `hash`. In that particular situation ruby override `hash` attribute by `hash` method. Then you need to use `self[:name]` idea ;)
Nice article, thanks!
Not too long, the concepts and how you do things are reasonably similiarish although the syntax is very different.
Found this [list](https://www.pairprogramwith.me/) of resources, but a lot of it are outdated. I don't think [airpair](https://www.airpair.com/), a paid pair-programming platform, is running anymore. I used it 3+ years ago to get myself up to speed with Angular. [CodeMatch.me](http://www.codermatch.me/) is also down. [CodeMentor](https://www.codementor.io/) looks like a good Airpair alternative. [This Meetup](https://www.meetup.com/remote-pair-programming/) looks like it's active and is done online.
A few weeks until you can use it. A few months until you love it
Me!!! We pair at work and it's a lot of fun. Have been thinking about doing pairing outside of work for a while!
Awesome. Now please ask yourself those questions: * Is there any other context where I can use `URI.parse` meaning "pass this method into other construct", not "just call the method", as usual? Why not? * Is there any other context where I can use `method(arg)` as a separate construct to be passed to some object? Why not? * What if I need more arguments? Like `yield_self { |d| Date.strptime(d, '%y-%m') }`? Or any other arbitrary block or callable object, more complicated than just method call? * What if I need to parse a list of URLs, would it still be `map(&amp;URI.method(:parse))`? If so, why it looks so different from pipe-processing singular value? * How the operator is parsed, what's it associativity? Where are parenthises could be placed for clarity? Language design is hard. I hope, you'll try to answer all those questions (and I don't say they are unanswerable), but probably after that you'll suddently find yourself with a quite different snippet of code.
Thank you for introducing me to `Enumerable#grep`.
That's more understandable than above. Now, please answer those questions: * What if I have block (or any other callable object) in a variable, how I'll add it to a pipe? * Should the syntax for pipe-processing arrays (map/select/reject) also change? If so, how? If not, why those two homogenous cases would stay so inconsistently different? * The same question as above about `tap` * How it all will look if block has more than one very simple operator? If method requires additional arguments? (Like `yield_self { |d| Date.strftime(d, '%Y-%m') }`) * How is it playing with normal calls? Like this: .... .yield_self(&amp;JSON-&gt;parse) .fetch("stargazers_count") .to_i .yield_self(&amp;Stats-&gt;store) 
OP and I synced offline with emails :D
I've found [Roda](https://github.com/jeremyevans/roda) to be perfect for any use case I had. * core functionality is small (less than 500 LOC) * contains plugins for about any feature you might need * has advanced dynamic routing (advanced in terms of features, its implementation is much simpler than static routing that Rails or Sinatra have) * performance is a priority (3 times faster than Sinatra) I wouldn't recommend using pure Rack, you'll quickly find yourself having to reimplement many things that web frameworks give you automatically (e.g. setting the `Content-Length` response header).
Oh wow, this is even more concise. Thanks for pointing this out.
I understand that, but it's a little surprising coming from other programming languages where you have far fewer special cases. This isn't a knock against Ruby's syntax, though. I really like it.
&gt; performance is a priority (3 times faster than Sinatra) &gt; where can I see a benchmark?
* https://github.com/luislavena/bench-micro#requestssec * https://github.com/jeremyevans/r10k
Is that sinatra 2 or 1? Sinatra 2 is much faster than 1.
It seems that https://github.com/luislavena/bench-micro#requestssec is updated for Sinatra 2.
No problem. What I like about the grep method is that you can take the selected values and transform using a block. {foo: 'bar'}.methods.grep(/to_/, &amp;:upcase) #=&gt; [:TO_HASH, :TO_H, :TO_A, :TO_S, :TO_ENUM] {foo: 'bar'}.methods.grep(/to_/){|x| "#{x}_WOW"} #=&gt; ["to_hash_WOW", "to_h_WOW", "to_a_WOW", "to_s_WOW", "to_enum_WOW"] And now that I am already in the mood of correcting and showing how I would do things online, this is how I would produce the same functionality of the Roman meta-programming class. class Roman SIMPLIFICATIONS = { 'IV' =&gt; 'IIII', 'IX' =&gt; 'VIIII', 'XL' =&gt; 'XXXX', 'XC' =&gt; 'LXXXX', } ROMAN_VALUES = { 'I' =&gt; 1, 'V' =&gt; 5, 'X' =&gt; 10, 'L' =&gt; 50, 'C' =&gt; 100, } def self.method_missing name, *args roman = name.to_s SIMPLIFICATIONS.each{|comlicated,simple| roman.gsub! comlicated, simple } roman .chars .map{|roman_character| ROMAN_VALUES[roman_character] } .sum # Only work in newer Ruby (Ruby 2.3+, use .inject(:+) for older versions) end end 
You're discussing very different things. The `|&gt;` is merely a proposed alias for `.yield_self`, the -&gt; method access notation is a different proposal. Question 1: `"wat" |&gt; { |x| function_in_variable.(x) } I don't understand your second and third questions about pipe-processing. What would change? What's inconsistent? Question 4: This is a question about the method access syntax, not the pipe. Pipe just takes a block and yields it with one argument. Question 5: ... `|&gt;(&amp;JSON-&gt;parse).fetch("stargazers_count").to_i |&gt;(&amp;Stats-&gt;store)` ? left-to-right 
You might like https://github.com/ioquatix/utopia
Setting Content-Length is an anti-pattern. It’s better just to use chunked encoding, unless you know the size ahead of time.
I think it's a bit extreme to say that `Content-Length` is an anti-pattern, because `Content-Length` is often useful, for example when streaming large files it enables the browser to show you a progress bar, as it knows the total size of the response body upfront.
Which is why I added the addendum, “unless you know the size ahead of time”. I agree with you.
haha yes, thanks for not making me not look like a total dick -_-'
*haha yes, thanks* *for not making me not look like a* *total dick -_-'* ______________________________________________________________________________ ^^^-english_haiku_bot
Ok, then I agree with you; when you don't know the `Content-Length` upfront, then setting `Content-Length` is an anti-pattern. Some web frameworks might iterate over the whole response body just to calculate `Content-Length`, which is unfortunate if your body is an `Enumerator` that generates a large response body, because it means the whole body is loaded into memory and it adds the additional wait time before the user can start downloading. Rack luckily doesn't do that, `Rack::ContentLength` will only calculate `Content-Length` if body responds to `#to_ary`, which `Enumerator` does not. And that was waaay off topic :P
Exactly :)
&gt; I wouldn't recommend using pure Rack, you'll quickly find yourself having to reimplement many things that web frameworks give you automatically (e.g. setting the Content-Length response header). Only that? I think I wouldn't need to re-implement Content-Length often. Once - not a problem
I've been thinking about setting something up for pair programming partners over the web, maybe even doing some live streaming twitch-style but with a more generic non-gaming element.
&gt; You're discussing very different things. We are just discussing `|&gt;` (with assumption "some syntax better than `method(:foo)` would also be in Ruby 2.5) &gt; `"wat" |&gt; { |x| function_in_variable.(x) }` Is it nice? Not at all. &gt; I don't understand your second and third questions about pipe-processing. What would change? What's inconsistent? many_urls.map(&amp;parser) # vs one_url |&gt; parser ...doesn't looks like the most consistent language possible. While many_urls.map(&amp;parser) # vs one_url.yield_self(&amp;parser) ...on the other hand, does (except for ugly method name). &gt; This is a question about the method access syntax, not the pipe. Pipe just takes a block and yields it with one argument. Yep, but arguments towars `|&gt;` implying that with `-&gt;` it would be OK, should consider this too. &gt; `|&gt;(&amp;JSON-&gt;parse).fetch("stargazers_count").to_i |&gt;(&amp;Stats-&gt;store)` Do you think it is nice? My eyes read definitely read it like 1. `|&gt;` (apply to pipe...) 2. `(&amp;JSON-&gt;parse).fetch("stargazers_count").to_i` (result of fetching stargazers from JSON.parse method?... WAT?)
That was just an example, there is hell of a lot more to reimplement. It's best shown with an example: class App def self.call(env) catch(:halt) do new(env).call end end attr_reader :request def initialize(env) @request = Rack::Request.new(env) end def call(env) if request.path_info == "/posts" &amp;&amp; request.get? posts = Post.all render("posts/index", locals: { posts: posts }) elsif request.path_info =~ %r{^posts/([^/]+)$} &amp;&amp; request.get? post = Post[$1] or not_found! render("posts/show", locals: { post: post }) elsif # ... else not_found! end end private def render(name, **options) layout = Tilt.new("views/layout.erb") template = Tilt.new("views/#{name}.erb") html = layout.render(**options) { template.render(**options) } [200, {"Content-Type" =&gt; "text/html"}, [html]] end def not_found! throw :halt, [200, {"Content-Type" =&gt; "text/html"}, ["Not Found"]] end end use Rack::ContentLength run App This is really yucky for me, I prefer a web framework which has routing, rendering, halting etc. Then I can just write the equivalent of the above as class App &lt; Roda plugin :halt plugin :render route do |r| r.get "/posts" do posts = Post.all view("posts/index", locals: { posts: posts }) end r.get "/posts", String do |post_id| post = Post[post_id] or halt(404, "Not Found") view("posts/show", locals: { post: post }) end # ... end end run App
Have a look at Hanami http://hanamirb.org/ https://github.com/hanami
hmmmmm this appears to be written by jeremy evans, author of the Sequel ORM, which is the best ORM and probably the best library in any language that ive had the pleasure of using. Will definitely check this out, thanks!
Very open-minded thoughts. To be honest, i am waiting for the part about rails way. btw. why image is related to rails way but in text I didn't noticed any word about that particular thing?
its true that rubys syntax is more complex and messy than other similar languages. [Here](https://www.flickr.com/photos/nicksieger/280662871/) is a diagram of the grammar used by a javascript parser. and [here's](https://www.flickr.com/photos/nicksieger/280661836/) ruby. That's from an [old article](http://blog.nicksieger.com/articles/2006/10/27/visualization-of-rubys-grammar/) from 2006, so its for ruby 1.8, its probably even worse now. Ruby gives you lots of weird and wonderful ways to do things, so its important to have a sense of good taste.
Me too - I was thinking of some sort of time-trading system, whereby you could pair with someone for an hour, and they pass it on, etc. Very useful for rubberducking as a freelancer.
[rack-app](https://github.com/rack-app/rack-app) looks interesting. We are developing one microservice on top of it and I don't know how it behaves in production yet, but looks promising to us.
That's surprising. I would have expected sinatra to improve more than that.
why?
It's lightweight, fast and simple. I also like the architectural model, from the Hanami guide: "Hanami keeps controller actions class-based, making them easier to test in isolation. Hanami also encourages you to write your application logic in use cases objects (aka interactors). Views are separated from templates so the logic inside can be well-contained and tested in isolation."
&gt; Rails, on the other hand, boasts perfect documentation and &gt; even users completely new to the framework could easily &gt; find whatever information they were looking for, usually in &gt; one place. That's especially true of the [Rails guides](http://guides.rubyonrails.org/). Those are detailed, helpful, and well-maintained. Great stuff.
I'm also open to work on small pair programming projects, sharing them through github.
Nothing beats pure Rack for speed... ...but it seems to me that development ease should be your top priority rather than high performance. I mean, how many hits do you expect your blog to require per minute? Personally, I authored the [`plezi` framework](http://www.plezi.io) for some lightweight API oriented projects (either Websocket or RESTful APIs, as often used by SPAs). It's speed is greatly enhanced by requiring the `iodine` server. But for a CMS, which might make heavier use of a database etc', I would probably recommend something heavier with more community resources behind it, like Sinatra or Rails (and I might write it using Rack if I were tight on performance).
P.S. How dynamic is your content? Maybe serving static files would serve you better? If all you need from forms is stuff like comments, you could probably edit static files within a simple Rack application (remember to use locks for synchronizing the editing). This way, static files could be served directly by the server, without running any Ruby, much like the [iodine Ruby server](https://github.com/boazsegev/iodine) does when serving static files.
dynamic
no, it's not
Why?
That's an interesting concept. I'm sure a lot of juniors and aspiring juniors would find it very valuable to have the opportunity to have an actual professional walk them through some production code, too.
It's awesome to see so many folks wanting to pair. I pair program a lot at work and it's IMO is one of the best ways to learn. And it's always super fun. &amp;nbsp; I put up a [spread sheet](https://docs.google.com/spreadsheets/d/1fkLKDFuXhMYz1EE9URIsn_ZGZlKbJ-3K0AvLy_T7j1U/edit?usp=sharing). Please add your info here and also grab someone's to pair from the sheet. &amp;nbsp; I'm SO excited for this! 🎉🎉🎉LET'S PAIR!!!🎉🎉🎉 
I put up a [spread sheet](https://docs.google.com/spreadsheets/d/1fkLKDFuXhMYz1EE9URIsn_ZGZlKbJ-3K0AvLy_T7j1U/edit?usp=sharing). Please add your info here and also grab someone's to pair from the sheet.
I put up a [spread sheet](https://docs.google.com/spreadsheets/d/1fkLKDFuXhMYz1EE9URIsn_ZGZlKbJ-3K0AvLy_T7j1U/edit?usp=sharing). Please add your info here and also grab someone's to pair from the sheet.
excellent, let me DM you
Errrr... &gt; Both these ways of calling myFunction are correct: &gt; &gt; myFunction 1, { |n| puts n } &gt; myFunction(1) { |n| puts n } No, they are not. The first one is a syntax error: [2] pry(main)&gt; myFunction 1, { |n| puts n } SyntaxError: unexpected tIDENTIFIER, expecting keyword_do or '{' or '(' myFunction 1, { |n| puts n } ^ I give you that, due to blocks (and their alternative notation with {}), things become ambiguous. foo({}) gives method `foo` an empty hash as first argument foo {} gives method `foo` no argument but an (empty) proc. foo({}) {} gives method `foo` both things at once. `method { "hello" }` is the same as `method do; "hello"; end`
IIUC, Sinatra has the disadvantage that each specified route is evaluated for each request; Roda (and [Cuba](http://cuba.is/), from which it was forked long ago) have various means of speeding that up, including short-circuit evaluation. We've been using Roda for APIs and internal apps for a couple of years now; we're just beginning our first customer-facing, revenue Roda app, and we're *stoked!*
 &gt; That said, it needs some syntax sugar to be as purely useful as elixir TBH, it is kinda tiresome how people tend to mask "just copy Elixir feature" demand with "purely useful" and "readable". Each language needs feature/syntax consistency, and it is usually hurt with blind copying of features. 
Yeah, I find those too-common "no, it's not" responses to a good paragraph or more of patient explanation, with no corroboration or justification of its own, childish and tiring. I've been following Hanami since the first pre-release of Lotus; we'll probably start a major application using it early next year. Going Rails-free has made Ruby *fun* again, and we really like the principles Hanami is built on: * lightweight; * thread-safe; * monolith-first yet easily decomposable using [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html); and * secure by default It's a great system built by teams I respect on sound principles. Our entire team is as excited about it as the [Roda](http://roda.jeremyevans.net/) that we've been using for a while. The 2.0 release coming up soon should be even more awesome.
Blocks are the best part of ruby, they're one of the most distinctive parts of ruby, what makes ruby what it is IMO. With a close second being the method call as "message passing" architecture, which is basically what 'metaprogramming' is about. (but message-passing architecture is shared by ObjC and smalltalk too. Not sure if smalltalk has blocks in the ruby sense as syntactic construct to make it super easy/readable to pass a logic block with little folderol). 
Definitely my favorite part. The way Ruby implements the `&amp;` really impresses me with its elegance/simplicity/beauty! So smart and beautiful! &lt;3 &lt;3 &lt;3
Do you think I covered most things about blocks or there is more interesting stuff I should check out? Give me some pointers if so :D &amp;nbsp; I agree. There are definitely [MANY similarities b/w Ruby and Smalltalk](http://vsavkin.tumblr.com/post/16375110741/why-smalltalk). I got Smalltalk Best Practice Patterns by Kent Beck, [recommended by DHH](https://signalvnoise.com/posts/3375-the-five-programming-books-that-meant-most-to-me). Haven't got the chance to read it, but you just reminded me of it. Thinking about reading it over the weekend now lol 
haven't read yours, sorry! Pretty sure Matz has said he was primarily influenced by smalltalk and Perl(!) in designing ruby, it's not a coincidence! Fortunately he took mostly only the good parts of Perl (regexp literals!), and we mostly ignore some of the bad parts that made it haha (like the punctuation global variables). 
haha, no worries.
&gt;punctuation global variables oh, we still have those $! latest error message $@ location of error $_ string last read by gets $. line number last read by interpreter $&amp; string last matched by regexp $~ the last regexp match, as an array of subexpressions $n the nth subexpression in the last match (same as $~[n]) $= case-insensitivity flag $/ input record separator $\ output record separator $0 the name of the ruby script file $* the command line arguments $$ interpreter's process ID $? exit status of last executed child process of those, only the regex ones are really useful, in some specific looping constructions. I cant remember what they are though. Maybe its in case statements that they can be put to use?
I just read all three articles and enjoyed them. The main takeaways for me were: Pt.1 The hamburger example! :D Pt. 2 A lambda needs to be called with the exact number of arguments, where a proc is more loose about the arguments it receives. Pt. 3 Different ways to use &amp; "ampersand"
Just adding that it's possible to `require 'english'` and you have access to better aliases for most (not all) of these globals: https://ruby-doc.org/stdlib-2.3.1/libdoc/English/rdoc/English.html
Every time Hanami comes up in ruby circles like this one, it seems to get an unfair dose of irrational hate that typically doesn't even get explained. I don't get it. Like you, it's been on my list of things to try out next time I need to start a web project for a while now.
Just like Perl: http://search.cpan.org/~shay/perl-5.26.1/lib/English.pm
Good write up! Nice read. FYI - The two examples at the bottom of part 1, section 3 (`Calling a code block/proc/lambda` ) are identical. I used a diff tool to make sure I wasn't missing something.. https://www.diffchecker.com/5eiecNk2
Thanks for catching that! I pasted the wrong code snippet lol. Just updated the post. The second example about passing arguments should be # Example: passing arguments def ten_plus puts 'before yield' yield(10) puts 'after yield' end ten_plus do |num| puts(num + 100) end # the above code will print out # before yield # 110 # after yield 
haha glad you enjoyed it! Let me know if you see anything worth learning about blocks I missed!
I don't think it is 'harmful', I for one just like |&gt; better. 
I would like to think I could imagine in quite a few situations, but I would expect I would miss an esoteric use here and there as most people would... that is what make talking about it in public so great!! At the same time, you could probably do both but really it just brings up the idea that keeping the language small vs having an accumulator variable... is it worth it? I don't know, but I sure like things like .reduce and .select .
We HAVE em, we just mostly avoid using em! I think there are even more than the ones you quoted. Most of em have longer spelled-out forms that most people use if they need em. The ones that actually change global behavior, using em is frowned upon. 
Matz copied a LOT of features from quite a few languages and I don't think any were just blindly copied... This particular feature is one of the favorite features of Elixr, kinda like string interpolation and trailing conditionals were some of the favorite things stolen from Perl... Just by introducing something that sticks out as much as |&gt; might (or might not) really get people thinking in more 'functional' ways... I am not purely in the functional camp, but some of the tenets actually could help code become more stable and bug free... and more understandable. Ain't hatin' just discussin' ;)
It definitely is fast, according to the benchmarks linked in this discussion. I agree it's not lightweight and simple compared to Cuba, Roda or Sinatra, foremost because there is a lot more code loaded. Hanami was meant to be a more of a counterpart to Rails, in the sense that it comes with its own set of conventions and abstractions which are better than Rails'. Sinatra/Cuba/Roda/Syro don't come with any abstractions other than routing, though for Roda there are many higher-level extensions like [dry-web-roda](https://github.com/dry-rb/dry-web-roda). So it just depends on what you want, more conventions or choosing your own path.
It gets worse, too. o = OpenStruct.new o.respond_to?(:foo) # returns false, should return true o.respond_to?(:foo=) # returns false, should return true o.foo = 'bar' o.respond_to?(:foo) # returns true o.respond_to?(:foo=) # returns true In other words, OpenStruct instances only purport to respond to methods corresponding to attributes that have already been set. I've been bitten by this when writing generalizations that copy attributes from one object to another.
I'm building a shopping cart from scratch in rails with Stripe for payments, EasyPost for shipping rates and postage labels. I've built a few simple versions of it already and am really trying to nail down the implementation this time. I'm also trying to keep it as vanilla rails as possible. My time is usually scattered but I can arrange time with a heads up. Please message me! 
RemindMe! 2 days
I will be messaging you on [**2017-10-01 21:53:20 UTC**](http://www.wolframalpha.com/input/?i=2017-10-01 21:53:20 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/ruby/comments/7389a8/i_was_intimidated_by_blocksprocslambda_in_ruby/dnoyffm) [**2 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/ruby/comments/7389a8/i_was_intimidated_by_blocksprocslambda_in_ruby/dnoyffm]%0A%0ARemindMe! 2 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dnoyg76) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
&gt; Matz copied a LOT of features from quite a few languages and **I don't think any were just blindly copied**... Exactly. Adding method (which plays well alongside existing idioms) is _mindful copying_ of "pipeline processing idea". While saying that "anything except `|&gt;` is unelegant" is what I call "blind copying", "I want Elixir in my Ruby". Note, that when in Elixir they chain enumerable processing, they _also_ use `|&gt;`, while we do chain methods.
My point is / was, keep an open mind... at the same time... coming from an old C coder, I agree with you ... don't just add stuff that does not add a LOT of value... else your C becomes C++ with 4 competing 'library vendors' ... none any good. Still , I kinda like |&gt;
&gt; but I’m one of these people who first try to master a framework and only then look at the language documentation. This is the approach taught by “the Rails way.” What? That's terrible advice. Do they mean the book called "The Rails Way" , or just what they think Rails people do, or what? I like Rails enough, but I'd never recommend that approach. If that's really the approach taught by the book called "The Rails Way", that's a shame, but without capitalizing what's in quotes I'm not sure if that's what OP is alleging. &gt; Rails has this saying, “If you have a problem, first look for the gem that solves it.” Again, what? This is terrible advice again. _Who_ has this saying exactly? I don't think it's anything in Rails documentation, and Rails itself can not speak. If the OP means he got these ideas from... reddit? Blogs? I dunno. I think they are indeed prominent ideas in some circles, and are indeed bad ones. I don't know why you'd blame Rails the framework for them. But OP is right about the way to approach programming if you want to know what you are doing. Try to understand what's going on, don't just copy and paste code. Glad OP got there eventually. I love good documentation though myself, makes things way quicker than always having to do code archeology -- it's not documentation that keeps you from understanding what's going on, it's lack of experience and lack of curiosity. 
I remember 7 (jeez it’s been 7 years) when I was grappling with the differences between all of them and what any of them did. I remember where I was too and felt so stupid and like I’d never get it. Well now I don’t even think about it or see them as that complicated. So to anyone out there, don’t feel stupid they're kinda weird but really cool when you get them
and blah-blah-blah-awesome-blah-great-blah-blah-I can't live without hanami -blah-blah-blah-blah
I really like this! It's a good, comprehensive overview of this part of Ruby. I especially dig the careful distinction between blocks and Procs themselves. I would have perhaps gone into a little more detail about the differences between Procs and lambdas, because Proc semantics (especially 'return' semantics) are a major trip-up for folks coming to Ruby from other languages. One more minor nitpick: I would perhaps say "you yield TO a block" rather than "you yield A block". In my mind, given the statement "yield @a, @b", I tend to think of @a and @b as the thing I'm yielding (along with the execution context). Pretty minor, but it's terminology which stretches across to other languages, and it might help folks understand a bit better.
Oh cool, now I feel like I actually contributed to something by buying a ticket two years in a row. I'm not such a bad mooch after all!
wow, 7 years ... Thanks for sharing! You remind me of this tweet: ["Every single thing in software was made by a human, which means you can understand it all. There are no mysteries."](https://twitter.com/garybernhardt/status/908767683805569024) &amp;nbsp; I think we are naturally afraid of things that we don't understand. But when we overcome the fear and do spend the time, everything is understandable.
Thanks for the feedback! I will dig into details about Proc semantics a bit more and see if I should incorporate them into the posts or have a separate one! &amp;nbsp; Thanks for pointing out the proper way to use the word "yield". English is not my first language and frankly, I didn't really get how "yield" works outside of the context of programming lol. But your explanation makes sense to me and helps me understand it a bit better. I updated the post following your suggestion. Thanks again!
Totally. :) Your article will definitely be the first thing I tell people to read if they're trying to understand these concepts!
Wow, thanks! That means a lot to me!! :D
how to actually run it?
I prefer option 2, if necessary, you can even consider split authentication related data into isolated database.
Risky click.
Yeah, I know and pointed it out. However, I can't yet decided if this is a good situation or not. One reason being that the now included bundler library itself bundles various gems like thor in a `vendor` directory... Maybe the situation gets better if and when bundler gets integrated into rubygems, dropping unneeded dependencies like thor.
It just maybe that the maintainer has a different workflow. From what I can gather from the commits, some tool called git-p4 is used; probably meaning that development is done using another version control system. As for closed and unmerged PRs: I also do that with kramdown - see https://github.com/gettalong/kramdown/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20is%3Aclosed%20is%3Aunmerged%20 However, this doesn't mean that I reimplement everything myself but I normally cherry-pick the necessary commits to avoid rebasing, strange git histories and such.
Why is a .gemspec file needed in a repo? Publishing of the gem is done by the gem author. How and where she manages the necessary information is mostly a subjective choice. Personally, I have one rake file in my ruby repos that does all necessary organizational stuff, like creating gems, building the doc, running the tests, ...
It’s a bit tiring when you’re just jumping from question to question. You run it like any other Rack app, I even added the “run” statement so that you can just chuck it in config.ru.
[Hobbit](https://github.com/patriciomacadden/hobbit) is my current favorite.
Hi jrochkind. I'm not sure if you read article precisely, but I don't say that Rails way or using gem for all problems is a good idea. &gt;Rails way My next article will be about terribility of that approach and trust me I'm big fan of everything except The Rails Way ;) The first part of article is about that approach when I describe big, old project with Rails ;) &gt;Again, what? This is terrible advice again. Who has this saying exactly? I don't think it's anything in Rails documentation, and Rails itself can not speak. Okay, Rails don't say - right. That says the global approach when we work with Rails. And again, I don't sure if you read that section. I'm in total opposite to that approach, try to show how aware developer can stop using all gems from the Ruby world.
Sinatra seems to do more out of the box than roda does. You need some plugins to get the same functionality so maybe the performance might be different with equivalent stacks.
I understand you don't agree with those things, and I agree with you. I don't understand why you attribute them to "the rails way". Do you mean the book of that title? What do you mean? Why is this "the global approach when we work with Rails?" It's not our approach when you or I work with Rails, after all! I think it would be good to dig into where these ideas are coming from, rather than just suggest they come from "rails" or "the rails way" (whatever that is). 
When you have something useful or informative to contribute, by all means let us know.
Yes, it bundles more as part of the core distribution; whether that's a feature or a bug depends on your approach and your application. One thing that I've learnt after 38 years of slinging code is that the [cleaner](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) your [architecture](https://medium.com/@fbzga/clean-architecture-in-ruby-7eb3cd0fc145) is, the better. That is at least as close to a universal truth as anything I've seen or read, and remains a continuous challenge.
I didn't know about rake import, but I'd read the part you quoted in bold to say that, yep, it's exactly describing the behavior you are seeing. &gt; If you import a file, and also define a task with the same name as that file, then that task will be run before the file is imported. This feature is provided so that dependency files may be generated on-the-fly. The task will be run _before the file is imported_. The file is imported when the Rakefile is loaded, since your `import` statement is just right there in the Rakefile. So the task will be run immediately on load of a Rakefile, including just a `rake -T`, which of course needs to load the rakefile. If you actually _explicitly_ invoke the task, it'll be run once when the file is loaded as a result of this code so described, and then again because you asked for it -- this part is _maybe_ a bug because rake is usually pretty good about never running the same task twice, that's usually part of rake's whole deal. But, why would you do this? I think a task set up as that bolded-quoted passage describes is not really intended to be mentioned explicitly as a rake task arg on the command line, it's intended only for automatic running on import. It's meant, as the thing in bold says, "so that dependency files may be generated on-the-fly" -- that's a little bit confusing, but basically, _don't_ name a rake task with the same name as the thing in the 'import' unless you want this behavior. I suspect it's a pretty rarely used rake feature. 
Cherry-picking still brings over the commit and properly attributes changes to the author. That's why you have 47 contributors but minitest has only 2.
David Black's "The Well-Grounded Rubyist" is one of the best Ruby books.
Very informative series and entertaining to read. Thanks!
who - us? speak for yourself.
The problem is that real life is messy and ugly. I think too many developers try hard to clean up real life rather than write their apps to function in that messy reality. Using sinatra, roda etc are great if your app isn't doing much but in real life your app is going to need a ton of stuff like reloading, intricate authentication and authorization, dealing with hostile actors, rate limiting, caching, access to third party APIs and libs, scheduled tasks, background tasks, deployment, clustering, session management, asset management etc. "simple" frameworks like roda and sinatra kick the can down the road. Oh look how simple and fast this example code is! Sure it's unsafe to put in production but hey it's fast and only 100 lines long! By the time you add all the plugins (half of which are unmaintained and undocumented), wrote all the rake tasks, broken up your routes to different files, written all the helpers you need, your new shiny app is as slow as rails and still doesn't do half of what rails does. You just wasted weeks of work trying to recreate something that has existed under your nose the whole time. One reason you spent all that time was because the documentation was so weak and you spent hours googling how to do simple stuff. Some plugins have no place to even ask questions, others send you to vacant slack channels or gitter or who knows what. It's messy and ugly. What's worse is that rails has a top notch team working on it 24X7 while your pet framework has one or two guys who work on it sporadically. It will never keep up. Is rails perfect? Fuck no. It's a memory pig and the team really should spend an entire release doing nothing but memory optimization and speed optimization but the tradeoffs of not using it for production work are too much if you ask me. I had high hopes for Hanami or another full stack framework to compete with rails but Hanami has another set of dogma it follows and like rails it has found itself intertwined with itself. I guess that's inevitable. Life is messy solutions that deal with life end up being messy.
Rails is thread safe and has been for a long time. Rails has clean architecture based on best practices. Rails is opinionated just like hanami is opinionated they just have different opinions. Rails is secure by default. So the only claim you have left for hanami is better is that it's lightweight. For that I would need to see some numbers and I would like to compare similar set of functionalities. Rails does tend to use up a lot of memory but then again it has a lot of middleware which you absolutely should have in your app if you are going to put it into production. If hanami is leaving them out and then claiming it's lightweight than you should put that into perspective. Also documentation and community count for a lot. 
The article is written poorly. You seem to be mocking the rails documentation which is unquestionably better than the documentation of all other frameworks combined. Also how do you write an application without gems? Are you seriously saying you should write everything yourself? Like write your own version of rake, your own version of rate limiting middleware? 
Thanks! I'm glad you like it! :)
Yes! This is excellent
wait, why not use ctags?
Check out [this gem](https://github.com/SPBTV/sidekiq_error_label). It allows to configure which errors should me ignored and how long. For example it’s ok to get network error and retry silently. Buy when network error happens five times in a row, exception monitoring service should be notified.
Could you show how ctags could be useful in this case? I.e. solve the same problem using ctags - that would be awesome.
&gt; Do you hate getting your inbox filled with errors you know you can ignore? Here's one cool trick to make them disappear. There's another cool trick: find the code where exceptions are being raised, and fix the bug that is causing exceptions. Yes, network errors happen. The suggested answer in this post is to _assume_ that the code hitting the network lives inside a background job that can be retried. There's a more sensible approach: the code that hits the network should anticipate network failure and be prepared to retry its own request. Automatic, catch-all retrying itself is an antipattern, in my experience. If your program crashed every time an uncaught exception was raised, then your team would have to actually address the root cause of every exception. It might be a pain at first, but over time, your software will actually start working properly in all cases. My inbox doesn't get filled up with error notifications because I don't let my programs generate those errors.
Why would anyone need to write their own version of rake? I'm not being flippant... a lot of rubyists are so accustomed to grabbing a gem off the shelf that they often bring in things they don't even need (and aren't aware they don't need).
One thing to add to this, these symbols exist perl not just as *shortcuts* but because they neutral way of storing that data for non-English speakers. 
is there really no way to edit previously written code after pressing enter?
What editor are you using when you edit code in the terminal?
You are probably running the ruby REPL. By default, you can’t edit earlier written code. The whole point of the REPL is to quickly try things out. If you really want to write code you should probably do it in a real editor. For a easier REPL experience, use pry. A REPL with many great extra features. 
It sounds like you may just be running `ruby` and typing in code? That's a hard way to write programs! You probably want to use a code editor. Common editors for Rubyists include [vim](http://www.vim.org/), [Sublime](http://www.sublimetext.com/), [Atom](https://atom.io/), [RubyMine](https://www.jetbrains.com/ruby/), etc. Edit: You may interested in [Learn Ruby the Hard Way](https://learnrubythehardway.org/book/) which will walk you through a lot of beginning Ruby info.
Check https://github.com/pry/pry/wiki/Editor-integration or https://github.com/jberkel/interactive_editor
haha no kidding! i thought that was the case but a lot of the tutorials i saw also were doing the same thing. thanks for the help.
what is repl? does that mean it only goes line by line. and is there any way i can change the terminal into a code editor or does it only support the line by line function.
im not sure what editor it is, i just type in irb.
also, i am using sublime now. basic print statements will work, but for some reason when i am building with statements like gets.to_i the program does not run. any ideas why?
The `ruby` program isn't an editor or an IDE of any kind. It's just an interpreter. You need to use a separate editor.
https://en.wikipedia.org/wiki/Read–eval–print_loop No, you cant extend it. That’s not what it (irb) is for. Use a read editor for writing code. 
**Read–eval–print loop** A Read–Eval–Print Loop (REPL), also known as an interactive toplevel or language shell, is a simple, interactive computer programming environment that takes single user inputs (i.e. single expressions), evaluates them, and returns the result to the user; a program written in a REPL environment is executed piecewise. The term is most usually used to refer to programming interfaces similar to the classic Lisp machine interactive environment. Common examples include command line shells and similar environments for programming languages, and is particularly characteristic of scripting languages. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
You'll have to give more information than that. Maybe ask for interactive help in #ruby or somewhere like that rather than a forum.
Leave any questions you want against this post and Myron and Ian will try to answer them all tomorrow :-)
For Ian: Clearly, you love to test. Would you still have taken the position at the test equipment manufacturer in Portland if it was just an equipment manufacturer? 
Thanks @petercooper :). I'm looking forward to doing this tomorrow.
1. Do you think that rspec is to complicated, and people need to learn rspec DSL language instead of focusing on testing? 2. How do you compare minitest in regards of rspec? 3. Do you look to another libraries when you build or improve rspec? 4. Do you believe that TDD mantra is the only way of writing ruby code?
What do you think about power-asserts?
They use gems that find useful. Why should you have to do all the work yourself when others have done it and probably better than you would have.
One thing about RSpec is there are so many options in the DSL that it makes it difficult for a team to write clean tests with a consistent structure and style. Is there a small restricted subset of the DSL that you recommend?
Thanks for this, really great resource. I'm learning Ruby and have tried studying procs/lambda with little success. Your series has finally made it all click! Thanks to you, I can now do this! pr = proc { |method| "I'm in #{method}!" } def foo(pr) pr.call __method__ end def bar yield __method__ end def baz(&amp;block) "#{foo(block).sub "!", ""} and #{bar(&amp;block).sub "I'm in ", ""}" end puts foo pr #=&gt; I'm in foo! puts bar &amp;pr #=&gt; I'm in bar! puts baz &amp;pr #=&gt; I'm in foo and bar!
Excluding the features removed in v3, what feature do you regret adding and why?
When dealing with serialization testing, I find it's very difficult to write meaningful tests that aren't extraordinarily brittle. Do you have any strategies for testing methods that return long strings/complicated object structures?
I'm trying to think of a question but what I really want to say is thank you for rspec! As much as I love ruby what I really miss when working in in other ecosystems is RSPEC! I've taken to avoiding the word tests and instead calling them specs. I think that is a huge part of what makes rspec different. What was the original motivation behind naming them specs? What do you see as the next big challenge for rspec? 
I'm very glad it helped! Keep learning and happy coding!
[removed]
Why yes, I love to reinvent the wheel with something so important. How did this guy know?
[removed]
You must be great at parties :)
Dick in a box? I.DONT.EVEN...
Sure am! What value does rolling your own authentication add? nil. Clients/employers would much rather have you deploy something that's stable and already feature-rich — Devise, AuthLogic, Clearance, than wasting time rolling your own. 
I think the point may be missed here. This is to help people struggling with putting things together learn how to do so by watching common things get built. Im not proposing anyone do this all the time when building an app, but for the purpose of education, Ive found many that like this type of approach. And also, as an aside, those gems might start you off quickly, but they can leave things to be desired later in the softwares life.
As always, thanks for the insight. &gt; rake is usually pretty good about never running the same task twice, that's usually part of rake's whole deal. Yes, between this and the fact that the output shown in the book is not what I'm seeing on my screen, I suspect this might be a bug. &gt; I suspect it's a pretty rarely used rake feature. Since I'm new to rake, this really helps to know. If that's the case, though, I find it a little strange that the author of the book I'm using chose to put it in Chapter 1.
Well, the holidays are coming up, after all.
I really enjoy using rspec in my projects but a lot of time I think I get stuck in a loop of testing just to test -- for example, I make a factory and test the factory data but that may or may not fit actual real world use. So I have a test, and my coverage reports look good, but my real world applicability is not actually all that great. Any suggestions on how to get out of this bad habit?
Thanks to /u/petercooper for inviting myron and ian - and, of course, thanks to myron and ian for hosting this ama. The world of code badly needs more tests and more people spreading the testing philosophy.
Okay now I understand what do you mean. When I thought about "The Rails Way" I mean the whole pack of rules which come from a tutorial, books for beginners and other stuff which tell to devs: "write the app with fat controllers and models - it doesn't matter." Why I think it is a "global approach"? I'm going to many conferences for four years, and I often saw it is a default path for many many persons(and what's worst - for many companies). &gt;I think it would be good to dig into where these ideas are coming from, rather than just suggest they come from "rails" or "the rails way" (whatever that is). Thanks for the great feedback - I will try to describe what I mean in one of my next articles!
Lately I've been thinking about two different approaches to writing specs. There's a "simple" style, which uses the minimum amount of RSpec features: RSpec.describe FoodFactory, '#make_food' do it 'makes bananas for monkeys' do factory = FoodFactory.new(:monkey) expect(factory.make_food).to eq(:banana) end it 'makes hay for horses' do factory = FoodFactory.new(:horse) expect(factory.make_food).to eq(:hay) end end And a "complicated" style, which uses more of the features of RSpec (`context`, `subject`, `is_expected`, etc.): RSpec.describe FoodFactory, '#make_food' do subject { factory.make_food } let(:factory) { FoodFactory.for(animals) } context 'for monkeys' do let(:animals) { :monkeys } it { is_expected.to eq(:banana) } end context 'for horses' do let(:animals) { :horses } it { is_expected.to eq(:hay) } end end Do you have a preference towards one of these styles? Would you recommend _against_ either style? Why?
&gt; The article is written poorly. You seem to be mocking the rails documentation which is unquestionably better than the documentation of all other frameworks combined. Hmm, do you mean is written poorly and it's related to language or "content" of the article? I'm waiting for your feedback! To be honest - after some time without Rails docs, I know - Rails docs is the best documentation from the Ruby world. I use a small chunk of "sarcasm" cause I believe that kind of proper documentation creates not aware developers, cause they don't know how it works in underground or that doesn't know about any dependencies. &gt;Also how do you write an application without gems? Are you seriously saying you should write everything yourself? Like write your own version of rake, your own version of rate limiting middleware? No, no, no! I don't mean that now everybody should write applications without gems. I'm only want to point out that we shouldn't use gems for problems related to business logic, especially we shouldn't use solutions strictly connected with the framework(aka gems based on Rails). General issues, without any specific logic, should be(or better - could be) solved with gems, but I'm trying to show what is wrong with developing the application with business logic layer by using many gems.
If you are using irb, consider using pry. It's similar to irb with many great extra features, e.g. code/command history like the one you're asking.
Yeah, I think there are a lot of people that want shortcuts (and a lot of tutorials and bootcamps etc that try to profit from catering to this desire), but those shortcuts will not make you a truly competent developer. I just think it's a bit of a shortcut to blame "Rails" for that, haha. I hope that a lot of people who start out believing in shortcuts come to find just as you did that there's no substitute for knowing what you are doing, and discover how rewarding it can be to know what you're doing! 
Thank you both for doing this. I had this book reserved on Amazon for months after a bootcamp I took spent a few nights teaching RSpec. I was hooked on specs and testing. How did writing specifications and testing become a career for you? What advice (in addition to learning RSpec) would you give to someone who wanted to do this full time? Thank you!
Also, I haven't used any of the alternatives yet, but Devise is just a tightly coupled mess. It's really hard to change anything significant about its functionality without sacrificing proper design (i.e. either you have to extend controllers and copy 90% of the code from the base class or you have to hack stuff together with ActiveRecord callbacks; just try to implement a "email address history" feature).
I definitely prefer and recommend the simpler style of your first snippet. Features like `subject`, `is_expected`, etc, have valid use cases, but unfortunately some users think it's "the RSpec style" and try to write all their specs that way. Your snippet with the more complex style requires more understanding of RSpec to grok, and the control flow jumps around. The simpler style is less code, and much more straightforward. As spec files get larger, the complex style can quickly become harder to work with, as there's more distance between an example and some of the declarations it depends upon (e.g. `subject` and `let(:factory)`). In addition, when you let RSpec generate doc strings for your examples instead of writing them by hand, it means you can't filter by the example doc string (using `--example`), because RSpec generates the doc string at run time when it runs the example, so it's not available up front for filtering. We do talk about this in the book in a few places.
It depends on what aspects of RSpec you find useful and compelling, but in general: * All you really need is `describe` and `it`, and some code in your examples that raises exceptions to signal failure. You can ignore the rest of RSpec's API and still get to use the great CLI. * I find nested contexts (with `describe` and `context`) to be a useful organizational technique, and use them frequently. * I find the failure messages and flexibility of `expect` + matchers to be really useful, but YMMV. You can certainly use minitest's assertions with one line of config (`config.expect_with :minitest`) if you're looking to simplify and cut down the site of the API in your test suite. * I find `before` and `let` to be useful for particular situations, but find that they often get mis-used/abused in the wild, unfortunately. My rule of thumb is to use them when there's a compelling benefit, but don't reach for them as the default way to write specs. * I almost never use `subject` or the one-liner syntax (e.g. `it { is_expected...}`. I think on certain kinds of projects (e.g. [mustermann](https://github.com/sinatra/mustermann/blob/v1.0.1/mustermann/spec/sinatra_spec.rb)), the one-liner syntax works really well, but on most projects I don't think it's beneficial. So my general advice isn't so much to restrict yourself per-se, but to start simple, and use additional features when it provides compelling benefits.
What do you mean by "serialization testing"? Can you provide an example?
Since you asked 4 questions, I'm going to answer them in separate replies :). &gt; Do you think that rspec is to complicated, and people need to learn rspec DSL language instead of focusing on testing? Yes, RSpec is definitely complicated. There are simpler approaches to testing. No, you don't need to learn RSpec to test well. Using a simpler testing library like minitest is fine. I think RSpec provides a pretty compelling set of features that are particularly useful for folks who drive their development via tests, but there's definitely a learning curve. There are definitely situations where using minitest is a better choice. For example, if you're on a tight deadline and the folks on your team are familiar with xUnit frameworks from other languages but have never used RSpec--I'd definitely recommend minitest over RSpec for that team.
I use [Syro](https://github.com/soveran/syro) for several projects and it's incredibly fast. It requires a bit more work to get templates up and running but it's a very fast and simple router.
&gt; How do you compare minitest in regards of rspec? They are both useful, and users should use whichever makes them more productive. They have different philosophies, though: minitest is focused on being "mini" and it succeeds at that. There's something really admirable and nice about a small, simple testing framework, that a ruby developer can read through in one sitting. I personally get a lot of mileage out of features in RSpec that minitest lacks and have tended to miss them on the occasions I've used minitest. RSpec also provides a lot of first-class abstractions that, while adding complexity, make it more flexible. For example: examples are objects (not just methods) with metadata attached, that lets you do all sorts of filtering, modifying via config, etc. Expectations use matcher objects (instead of assertion methods) which are composable. I do wish the minitest developers wouldn't present minitest as some kind of argument against RSpec, though. I see them as analagous to Rails and Sinatra: both are useful and have their place, and they need not be seen to be in competition.
&gt; Do you look to another libraries when you build or improve rspec? Not actively, but there are many features in RSpec that started in other libraries or were inspired by other test frameworks. Here are some examples: * Verifying doubles were first implemented in the [rspec-fire](https://github.com/xaviershay/rspec-fire) gem, and later ported to RSpec by Xavier Shay. * Composable matchers were largely inspired by [hamcrest](http://hamcrest.org/). * Random spec ordering was a feature of minitest that we ported over because we thought it was so useful. * `--bisect` was first available for minitest in the form of [minitest-bisect](https://github.com/seattlerb/minitest-bisect) before we added it to RSpec. * Any instance stubbing/mocking was a feature of [mocha](http://gofreerange.com/mocha/docs/) long before we added it to RSpec. * Test spies were available in some other mocking libraries before RSpec (I forget now which library was first).
&gt; Do you believe that TDD mantra is the only way of writing ruby code? Definitely not. I don't always follow a strict TDD process myself. If done poorly, TDD can both make a project take significantly longer and realize none of the benefits its meant to provide. That said: since Ruby is a dynamic programming language, and there's no compiler to catch many simple errors, I think you need an automated test suite for nearly any code that's not a spike or something you're throwing away. TDD is just one process to get there.
&gt; Automatic, catch-all retrying itself is an antipattern, in my experience. Are you suggesting that Sidekiq's retry policy is a bad idea? Bugs happen, the Internet is flaky and an automatic retry with exponential backoff is a lifesaver ~100% of the time IME.
There's some really specific Ruby books coming out these days. The last one I saw was entirely about blocks, procs and lambdas. By the way Safari tells me that your HTTPS certificate is invalid and refuses to show me the page entirely!
It seems specific but there's a lot of work we do with strings. They're also a data structure that abstract themselves from us. You can't look at the characters and immediately know everything in the same way you with something like an array. Things like this: 'à'.length # =&gt; 2 The result is it tends to be more complicated than other objects. Thanks for telling me that Safari is complaining. The cert is through Cloudflare and I'm not seeing any issue when I open it in Safari 11.
Me too! (Ian here.)
:-D I think it worked the other way around: working at a company that focused on test and measurement put me in the right mindset to be interested in testing. (That, and being given a broken set of automated software tests to fix because I was the new kid and that’s what you do to the new kid.)
I guess I'll need to buy the book to see, but I was confused by this example on the landing page. `'à'.length` returns a value of 1 with the default encoding of UTF-8. `String#length` and `String#size` both count number of codepoints. You'd have to do something like `'à'.b.length` to get a value of 2. Or just call `'à'.bytesize`. Anyway, maybe your book clarifies on this point and you're switching the default encoding. But I think in the common case of just firing up IRB with the default encoding, people are going to be a bit surprised that the result doesn't match up.
Oh yeah we know how complex strings are where I work! We're doing a new implementation of Ruby and we're still spending hours on strings and encodings. In our implementation we actually abstract strings even further - storing them as trees of arrays, rather than flat arrays, so that concatenation and taking a substring can be much faster. The cert seems to be working now - but it definitely wasn't working 15 minutes ago - Safari wouldn't even let me ignore the warning.
For me, I inherited a pile of broken C++ “scripts” that tested an embedded touchscreen GUI. They were 100% hard-coded pixel locations and wait times, and they broke every time the designer moved a button or a dialog took too long to appear. Incredibly, the team gave me leeway to throw the tests out and replace them—which I did, with some Ruby scripts in a homegrown test framework. When I learned that RSpec existed, I immediately scrapped our framework (saving a couple hundred lines of code). Upon realizing how much fun that was, I was happy to take on more testing tasks. It’s never been 100% of my job, but it’s a meaningful part of it now. So for me, instead of looking for a time and a place to write automated tests, I stumbled on a problem that automated tests helped me solve. They’re just one tool in the toolbox.
Some of my test cases come directly from the real world. We (or the customer 😭) will notice a problem with our software, and we’ll write a minimal functional test to replicate it so that we can have some confidence that our fix works. Aside from working backwards from a real bug report, another thing that can help keep tests realistic is to write a few end-to-end acceptance tests when you’re designing a feature. If you drive your app through the interface the same way your customer would, the tests can end up looking more like the real world. One final thought: I too am sometimes tempted to write tests just to have better coverage, but I try to resist the impulse and write new tests only when I see a business need (e.g., I’m building a new feature or improving an existing one). I’m not always successful at resisting the urge, but I try. ^_^
I've been following your work. It's really exciting stuff. Thanks for letting me know about Safari and taking another look.
That's part of why strings are difficult. The issue isn't that it's a different encoding. It's that there's more than one way to represent `à` in UTF-8 (and Unicode in general). Sometimes a string like that will give you 1 and other times it may be 2 (specifically for input that's external from your code). Surprises like these can be infuriating if you don't know what's going on.
I should have added this as caveat to declaring it an antipattern -- as a final safety measure, it can make sense. The cost of total system unavailability can be so high that a blanket rescue/retry is justifiable. My underlying point (that I should have made outright), is that _removing_ the need for that safety measure ought to be the goal. So, I won't say that Sidekiq's retry policy is a bad idea. I think _relying_ on such a blanket retry policy in order to avoid writing code that handles failures is a really bad idea. Code that communicates over the Internet (or any network) should anticipate failure and react accordingly. If it doesn't work under adverse network conditions, it's not _done_. Much of the power of HTTP is how well it can express failure cases in a general way. When teams decide to address network "flakiness" outside the code that accesses the network, they are opening themselves up to nondeterminism and entropy. To demonstrate my point, consider why exponential backoff is the default -- it protects against extremely hazardous systemic failure modes that only occur when the individual subsystems are out of control. Blanket retries should be a final line of defense. When it saves the day, teams should address the root cause of the failure. Teams that allow the unbounded accumulation of exceptions are bringing a lot of avoidable pain upon themselves. This is one of the largest vectors for entropy growth in projects. OTOH, teams that encapsulate failure modes and stay on top of exceptions experience the opposite -- their software gets better over time. It's common to assume that a huge exception backlog in e.g. airbrake is normal, but it actually isn't, it's just common.
Thinking about it more, maybe you're trying to highlight denormalized forms with combining characters. If that's the case, be aware that Firefox at least is treating it as a single character. It also means that the first example on the web page (`'é' == 'é'`) evaluates as `true`, while the copy leads the reader to believe it should be otherwise*. \* The phrasing on the landing page doesn't say definitively that it will be different, but IMHO, it does suggest that it will. I could very well just be reading it wrong.
Thanks!
"6 months of clojure does not compare to 5 or 6 years of ruby". Yup, using tools you know (and like) _matters_. I also, I like the way this guy approaches things and want to work on a team with him haha. 
Thanks Ian!
I'm assuming you're referring to [this library](https://github.com/k-tsj/power_assert)? I've never tried it, but it looks useful. I've done quite a bit of Elixir in the last couple years, and ExUnit uses a similar approach. `assert` is a macro that receives the AST of the passed expression, and based on that it can break it down, evaluate the different sides, and provide a really nice failure message without needing separate assertion methods or matchers. That's pretty cool. Having a much smaller assertion API makes it that much easier for people to get started with testing, which is great.
The main ones I can think of are: * `any_instance` mocking/stubbing. The code to support this is _extremely_ complicated, and it doesn't play well with all Ruby features. (For example, we've never gotten it to work write when the method being stubbed is defined in a pre-pended module). In addition, it hides complexity in the interactions of the code being tested and encourages users to work around their design issues with RSpec features instead of improving the design of their code. * The one-liner syntax (e.g. `it { is_expected.to blah }` or `it { should blah }`). There's a time and place for it (for example, I think it works great in [mustermann's specs](https://github.com/sinatra/mustermann/blob/v1.0.1/mustermann/spec/sinatra_spec.rb)), but it's led RSpec users down an unfortunate path. Over the years we've gotten a number of questions/requests that revolve around how to do more and more complex things with a one-liner syntax by adding more features to the RSpec DSL. I think that in most cases, it's better just to use `describe`/`it`, and wish `subject` and the one-liner syntax support was in an extension gem for the few projects that benefit from it. * `before(:all)`/`before(:context)`: this sounds great in theory, and seems really simple, but in practice it tends to cause problems for users, because so many things in RSpec and the surrounding ecosystem assume a per-example lifecycle. For example, if you wrap each example in a DB transaction (as most projects do), and create some DB records in a `before(:context)` hook, you've just created the records outside of the transaction and those records will leak into other examples and possibly cause them to fail. These days, if you're concerned about the speed of an operation and want to be able to do it once and then make many assertions about it, you're better off using [aggregate_failures](http://rspec.info/blog/2015/06/rspec-3-3-has-been-released/#expectations-new-aggregatefailures-api).
I wasn't around in the early days of RSpec, so I'm not 100% sure, but I believe the alternate terminology came from Dan North's [Introducing BDD](https://dannorth.net/introducing-bdd/) blog post.
To add to what Ian said, I've found two techniques particularly useful for avoiding this problem: * Outside-in development. This ensures that what you're building at the lower levels already has a higher-level component that will use it, so that you're building something that will definitely get used rather than building something that you merely hope will get used. * Code spikes. Building an initial throw-away version of something (often without any tests at all) helps you figure out what the components of a solution should be, what the boundaries between them should be, and what you're APIs should be. Once you've proved that out and thrown it away, you can build it bottom-up with a higher level of confidence that it'll actually be useful in the real world.
You're welcome!
Woops, realized I didn't respond to all your questions :). &gt; What do you see as the next big challenge for rspec? There aren't any grand challenges I have in mind, partially because I see RSpec as being largely "done". It'll continue to be supported and improve, but I don't see the API having any drastic changes again, and it's feature set is already so rich that it's kinda hard to come up with big new compelling features to include in the next major release, TBH.
&gt; Code spikes. This is a really interesting concept, thank you!
Edit: this shitty comment was rightfully downvoted. I've tried to engage with OP in a comment below. - Using scalars is faster than using objects and classes. No way! - Speed isn’t necessarily why people use OOP. - 5x speed up isn’t all that much, unless you execute it many times and NEED the speed. - clickbaity title next to all that 
EDIT: This reply was to the original post. They clarified their intent and message so it's not really relevant. &gt; clickbaity title next to all that How so? I'm a rubyist, i made code 5x faster, that code is python. It's pretty much exactly what I wrote in the title. I think perhaps you were expecting some other kind of content when you clicked the article? What were you hoping for when you clicked on the title? &gt; unless you execute it many times and NEED the speed. Sure, I agree you shouldn't optimize what you don't need. In this case this was the bottleneck of the application. In the assignment speed was required. This was for an artificial intelligence course and being able to search further than an opponent means you will have crucial edge. &gt; 5x speed up isn’t all that much In real world applications making something 10% or 50% faster can make a noticeable impact. In this case we're seeing a 500% increase in the most called method of the application. This allows me to search further than my opponents so unless they made the code 6x faster then it's pretty useful. I'm sorry you don't feel that was a good enough performance improvement. Perhaps you can stake a stab at making the code faster. &gt; Using scalars is faster than using objects and classes. No way! I didn't end up using scalars in the final optimization or removing any objects or classes. Not exactly sure what you're being snarky about here? If you're implying that everyone already knows this information, then that's not the case. Lots of people use Ruby and Python without any clue about underlying complexity. That doesn't mean you have to be mean or exclusionary to anyone who is new to performance game and wants to learn. &gt; Speed isn’t necessarily why people use OOP. I don't think this is even a thing I suggested. In fact I didn't use any OOP in my article. Did you read the article? 
I don't consider writing specifications and testing to be my career. It's a tool I use as part of my career. There are definitely folks who do testing as their job (typically SDETs) and that has never interested me very much. I want to build robust, maintainable services, and automated tests are a key tool in my toolbox to help me do that.
I have more time with Ruby than with Clojure (in calendar time). I have more time with Lisps than with Ruby. I make a lot of money with Ruby &amp; Rails, and spend my personal time with Clojure (and CL). I've made even more with Java, despite having moved on from it for my current career. I nearly threw up my hands when he got his first Clojure slide wrong, about the "filter" core function. It doesn't take "all kinds of data types". It takes exactly one kind of data type, a seq'able data type. And, even a cursory glance at the source would show that, as the input collection is immediately sent to "seq". So, yes, exactly right. The guy was trying to do a mission critical system in a language with which he was not intimately familiar. (Although with 30+ years of software engineering under my belt I would presume that 5 years is still not "intimately familiar," but I'll give him the benefit of the doubt.) I also love how he calls the JVM "maybe web scale." Now, I've been using the JVM since it first came out, and I know it deeply, and there's no "maybe" about this thing. Sure, it's not as nice (in my opinion) as the CLR, and it's heavy to deploy in some ways, but it's not particularly controversial to understand that it is "web scale"y.
With 20+ years under mine, I agree that 5 years is only barely enough to _maybe_ be "intimately" familiar -- but the problem is that if that's true, we have only so many languages/platforms/environments we possibly can become intimately familiar with in our careers. And there is real reason to stick with what you've got if it's working well enough. I think this goes against some common "wisdom" about chasing the new shiny things. I am also amazed at how you possibly had time even in 30+ years to become intimately familiar with clojure, CL, ruby, Java, and perhaps some other lisps too. :)
Thank you for taking the time to respond. Well wishes for the book.
Yes, there are multiple libraries for Ruby ("minitest-power_assert", "wrong", ...). I love power-asserts since you dont have to remember special methods like "assert_equals" and the order of the parameters (which i often get wrong with assert_equals) and also it does not need the more complicated "expect(...).to ..." DSL. I mostly write my projects in crystal now which comes with macro-support that makes it easy to provide power-asserts.
i will try that. thanks!
Thanks for derailed_benchmarks!! I always use it when evaluating gems. 
 irb(main):001:0&gt; "hello".tr_s('abcdefghijklmnopqrstuvwxyz', '48cd3f9h1jklmn0pqr57uvwxy2') =&gt; "h3l0" irb(main):002:0&gt; "hello".chomp =&gt; "hello" irb(main):003:0&gt; "hello".chomp.downcase =&gt; "hello" irb(main):004:0&gt; "hello".chomp.downcase! =&gt; nil I bet downcase! is your issue... since you are doing variable assignment in this line, you don't need to bang it anyway. Edit: From the docs: &gt; downcase!: Downcases the contents of str, returning nil if no changes were made. Note: case replacement is effective only in ASCII region. http://ruby-doc.org/core-2.0.0/String.html#method-i-downcase-21 So it's returning nil if the string was already lower-case
I just wrote a basic API in roda. Used a couple of plugins like multi route and json. I turned off logging but did load sequel. The app looks like this plugin :multi_route Dir['./app/routes/*.rb'].each{|f| require f} route do |r| r.multi_route r.root do {token: 'token'} end end require_relative 'app/helpers' This delivered about 4K requests per second using puma (no config just out of the box) running wrk -t 2 http://localhost:3000 Not too bad I guess but here is the kicker. It takes up 30 megs of RAM. That's crazy no? It also seems to be leaking memory someplace. Every time I run wrk the memory usage ups by a meg or so. 
Doesn't seem insane that you'd have to create a new instance for every request. Why can't you create it once and then call methods on that instance?
&gt;Hmm, do you mean is written poorly and it's related to language or "content" of the article? I mean it's hard to understand. &gt; I believe that kind of proper documentation creates not aware developers, cause they don't know how it works in underground or that doesn't know about any dependencies. Why should they? Do you know how the dependencies of rack works? Do you know how the pg gem talks to the database? &gt;I'm only want to point out that we shouldn't use gems for problems related to business logic, especially we shouldn't use solutions strictly connected with the framework(aka gems based on Rails). I know you are saying that but it makes no sense. You should use a gem if it solves your problem. It's as simple as that. Take devise for example. It's written and maintained by really smart people who understand cryptography and know common attack vectors. You'd be foolish to try and do that yourself. 
That's....weird, but not wrong! That does solve that problem, but a new one arises... me@X60:~/ruby$ ruby strtest.rb Enter a phrase: Hello. H3l0. me@X60:~/ruby$ ruby strtest.rb Enter a phrase: hello h3l0 me@X60:~/ruby$ ruby strtest.rb Enter a phrase: bbbbbbbb 8 me@X60:~/ruby$ Why is it, like, consolidating some letters that come in doubles or more?
yeah, read the [documentation for tr_s](https://apidock.com/ruby/String/tr_s): 1. Processes a copy of str as described under String#tr 2. then **removes duplicate characters** in regions that were affected by the translation. I've personally never seen this method, but it doesn't seem very useful imho... So, maybe you want [String#tr](https://apidock.com/ruby/v1_9_3_392/String/tr) instead?
THAT did the trick. Okay. I was over complicating it. Thank you.
Lessons: 1. debug one method call at a time. 2. when in doubt, read the docs
Thanks.
&gt;tenants of optimizing scripting languages The word you're looking for is "tenets". Otherwise, fascinating article! Thank you for sharing!
&gt; &gt; clickbaity title next to all that &gt; How so? I'm a rubyist, i made code 5x faster, that code is python. It's pretty much exactly what I wrote in the title. I think perhaps you were expecting some other kind of content when you clicked the article? Not GP, but it came across to me as "I'm used to ruby, but I came into this python codebase and fixed their shit because rubyists are so much smarter lol".
The method `.shift` updates the array and returns the removed element. So your line `item = arr.shift` is actually doing two things, removing the first element of the array, and returning that element. You can read the documentation for a better understanding http://ruby-doc.org/core-2.4.2/Array.html#method-i-shift
When you call array.shift, the first element of array is removed AND returned. So assigning a variable to array.shift is assigning the variable to the returned element.
A spell checker *is not* an acceptable substitute for a good copy editor.
Thank you for sharting!
`arr.shift` returns the first element of the array and as a side effect removes this element from the front, shortening the array and making the old `arr.second` the new `arr.first`. In ruby, the array methods `.shift` and `.pop` are the opposites of one an other, but have similar behavior. `arr.pop` removes 7 from the end of the array and thus `arr == [2, 3, 5]` will be true.
You can use any rendering engine supported by the tilt gem, which includes slim. The documentation is here: http://roda.jeremyevans.net/rdoc/classes/Roda/RodaPlugins/Render.html You need something like this on your roda class: plugin :render, engine: 'slim' And make sure the slim gem is available via your Gemfile.
that's a part on the answer
I am a ruby/rails newby...the programming world I previously worked in..well..they kinda thought that the person writing the code should not be the one writing the tests, to get the best tests. I did find that to be true...our QA department would always find bugs when we had thought we had tests covered. Does that concept exist in the ruby/rails world..that a programmer should not write his own tests? I honestly was a bit surprised on how the developer himself is trusted to do the job thoroughly.
&gt; Does that concept exist in the ruby/rails world..that a programmer should not write his own tests? It's not a sentiment I hear very often in the Ruby community, but some Ruby teams definitely work with a QA department. It's worth bearing in mind how intrinsic open source development is to the Ruby community. Considering I've never heard of an open source project having any sort of QA team (and nearly every successful open source projects has an automated test suite of some sort), it's not surprising that self-testing via an automated suite is the norm in the Ruby community.
If you also take a little bit of effort to actually _look_ at the `render` plugin documentation that Tom linked to, you'll see that it also supports layouts (independently of the templating engine).
I doubt these 30 MB come from Roda. You can use [MemoryProfiler](https://github.com/SamSaffron/memory_profiler#usage) to see were did these 30 MB of objects get allocated. Also note that it shouldn't be possible to write a Ruby program that leaks memory, because Ruby has a garbage collector.
If you had a single instance which is called for each request, that means you have to carry `env`/`Rack::Request` in argument list of each method that needs the request information, which would quickly gets cumbersome if you wanted to have things nicely refactored. Well, more cumbersome that it already is. Also, this way users can assign instance variables if they want to without causing side-effects, because a new instance is used for every request. Roda also creates an instance for each request internally, as does Sinatra. The performance impact is simply neglibile when you consider how many other objects you're creating on each request.
Okay, it's great feedback, maybe I should look at the problem from the other side, thanks! &gt;Why should they? Do you know how the dependencies of rack works? Do you know how the pg gem talks to the database? Rack, unfortunately nope. PG - I'm trying, and I believe that I am a better programmer since I decided to jump into the source code of gems. From the beginning - I don't think that writing new devise, rack, pg, or anything else is a good idea. It's terrible advice cause like you said "it's written by smart people" and they solve many problems which each dev probably meet when he would try to write something like that. But... Gems world it's not only about big gems strictly connected with infrastructure or tools which have very fundamental, essential responsibilities. In my opinion - it's a kind of application logic, not the business part. I wrote that section about using gems which could create limitations for us when we try to understand or solve business logic issues. Cause that part of the logic is very flexible, elastic - it depends on the mood of the client, sometimes on the current situation. We need flexible solutions, but gems very often put our code into some limitations.
&gt; Using sinatra, roda etc are great if your app isn't doing much For me Roda is great exactly when my app is doing much, because it lets me be much more precise about how I want things to work. &gt; but in real life your app is going to need a ton of stuff like reloading, intricate authentication and authorization, dealing with hostile actors, rate limiting, caching, access to third party APIs and libs, scheduled tasks, background tasks, deployment, clustering, session management, asset management etc. * Authentication – [Rodauth](https://github.com/jeremyevans/rodauth) * Authorization – [Pundit](https://github.com/elabs/pundit) * Hostile actors &amp; Rate limiting – [Rack::Attack](https://github.com/kickstarter/rack-attack) * Caching – Roda's [`caching`](http://roda.jeremyevans.net/rdoc/classes/Roda/RodaPlugins/Caching.html) plugin * Access to 3rd-party APIs and libs – Gems? * Scheduled tasks – Cron, Nomad etc. * Background tasks – [Sidekiq](https://github.com/mperham/sidekiq) * Deployment clustering – How exactly does Rails make this easier? * Asset management – Roda's [`assets`](http://roda.jeremyevans.net/rdoc/classes/Roda/RodaPlugins/Assets.html) plugin, Tilt, Webpack Any Rack-based web framework can use any of the above gems. &gt; "simple" frameworks like roda and sinatra kick the can down the road. What features does Rails have that Roda either doesn't or there isn't a suitable replacement? &gt; By the time you add all the plugins (half of which are unmaintained and undocumented) What are some of the plugins/gems that are Rails' counterparts and that aren't maintained? &gt; You just wasted weeks of work trying to recreate something that has existed under your nose the whole time. For me most of the functionality I need comes from gems, not the web framework. At work we're using Cuba, which is just about 250 LOC, and we didn't need to reimplement anything that Rails already has. You have to look at Rails as just ActionDispatch, because all other parts are replaceable/reusable (ActiveRecord can be used standalone and there are Sequel and ROM alternatives, ActiveSupport is not necessary, ActionView is replaceable with Tilt, ActionCable by Iodine or Faye, ActiveJob by just using the backgrounding library directly, ActiveStorage by Shrine, and so on). If we look at Journey that's part of ActionDispatch, it's incredibly more complex than Roda's routing, and it's also much less advanced than Roda's routing since it's static. That's the worst of both worlds. &gt; One reason you spent all that time was because the documentation was so weak and you spent hours googling how to do simple stuff. Some plugins have no place to even ask questions, others send you to vacant slack channels or gitter or who knows what. It's messy and ugly. Don't you need to do the same thing with Rails as well? Rails doesn't contain the whole Ruby ecosystem, you still need to use other gems for most of the things. &gt; What's worse is that rails has a top notch team working on it 24X7 while your pet framework has one or two guys who work on it sporadically. It will never keep up. Roda and Sequel have 0 open issues most of the time, so I'd call that perfect maintenance. Even if you tell me that it's because Roda and Sequel are much less popular than Rails, it still means that all of my issues are going to be solved and usually within a day. So I couldn't wish for better support than that.
it doesn't reveal what's exactly inside that layout and how to pass a variable to a layout
&gt;Any Rack-based web framework can use any of the above gems. And when it does it stats to look like a cobbled together version of rails where you have to go to fifteen places for documentation and help and god help you if an upgrade on one thing breaks your app. &gt;You have to look at Rails as just ActionDispatch, because all other parts are replaceable/reusable (ActiveRecord can be used standalone and there are Sequel and ROM alternatives, ActiveSupport is not necessary, ActionView is replaceable with Tilt, ActionCable by Iodine or Faye, ActiveJob by just using the backgrounding library directly, ActiveStorage by Shrine, and so on). Rails is an ecosystem of libraries which are maintained by the same team and tested as a whole. &gt;Don't you need to do the same thing with Rails as well? That's right you don't. There is only place to go for documentation and help for rails. &gt;Rails doesn't contain the whole Ruby ecosystem, you still need to use other gems for most of the things. But everything else is cohesive. So you have to build the equivalent of rails in your micro framework and then layer on the same gems as you would in rails for the rest. &gt;Roda and Sequel have 0 open issues most of the time, so I'd call that perfect maintenance. One guy. What about all those other gems you listed? Same right? One guy maybe two. 
&gt;Rack, unfortunately nope. PG - I'm trying, and I believe that I am a better programmer since I decided to jump into the source code of gems. Then write an article about how programmers should read the source code of all their gems and understand them. 
You didn't ask for this, so we cannot know that this is what you wanted the answer for. * Layout looks exactly the same as in the [Slim README](https://github.com/slim-template/slim#syntax-example) * You have `:layout_opts` where you can probably pass `:locals` to the layout specifically.
Garbage collection and object allocation are notoriously slow for ruby and are often the cause of most performance issues. If you can write a "functional" framework somehow that didn't allocate on every request that would be much better I think. I don't know why you need to set instance methods in a web request either. You can easily pass the request and the response around.
&gt; And when it does it stats to look like a cobbled together version of rails where you have to go to fifteen places for documentation Can you give me an example? I'll give you my example – authentication. The default Rails solution is Devise. Foremost, Devise is not part of Rails, so you have to go to the Devise repo to look at the documentation. In addition to that, Devise configuration is scattered all over the place: initializer, models, routes, controllers and Warden middleware. *That*'s a lot of places to look at. Rodauth on the other hand is configured in single Roda class, so you have everything in one place. &gt; and help and god help you if an upgrade on one thing breaks your app. No, that's exactly the problem that *Rails* has. When a new Rails upgrade comes up, it usually breaks all those Rails-specific gems (e.g. Devise). What's great when your web framework, ORM, templating library, CSRF protection, backgrounding library etc. are all separate gems is that you can upgrade them **individually**. That makes upgrading so much easier, because you can upgrade in small incremental steps. With Rails you are forced to upgrade the whole web framework *at once*, and then god help you when half of your app breaks. &gt; Rails is an ecosystem of libraries which are maintained by the same team and tested as a whole. Well, what if I want my library to be maintained by Jeremy Evans, and not the Rails team? And why do you think that hooking libraries into Rails by hand is difficult? &gt; But everything else is cohesive. So you have to build the equivalent of rails in your micro framework and then layer on the same gems as you would in rails for the rest. In my experience this cohesiveness didn't produce the best libraries. E.g. ActiveRecord is an objectively inferior ORM compared to Sequel or ROM, I'm annoyed that I ever wasted my time learning it. &gt; One guy. What about all those other gems you listed? Same right? One guy maybe two. I don't care if it's one guy or 12, if the library is better than the alternatives, I'll use it. It's better to have one guy that knows what he's doing and believed in his library, than to have many guys who are always changing because they're running away from complexity, like with ActiveRecord. Also, Roda and Sequel have had many contributors and admirers, look at the graphs. I didn't manage to find any correlation between number of official core members and the quality of the library. If you're estimating libraries by looking at number of maintainers instead of quality and features, you'll miss many awesome libraries.
&gt; You can easily pass the request and the response around. Sure, you're welcome to do that. I just gave an example of initializing a Rack app with a request/response because I think that passing request/response around is not worth the zero-performance benefit.
&gt;I doubt these 30 MB come from Roda. You can use MemoryProfiler to see were did these 30 MB of objects get allocated. puma, sequel, roda, sequel-seed, dotenv basically. Nothing else crazy. Thin uses a little less memory but not much less. Still over 20 megs no matter what you do. BTW for comparison. Crystal uses less than two megs for a similar setup and delivers way better performance. 
Been wondering about the time it takes Ruby to spin up new instances of classes, in adopting a bit more of a functional/dry-ruby sort of style lately. Guess it’s another trade off.
That is incredibly small footprint. We have a Cuba app at work, and web workers regularly reach about 500 MB.
The Rodauth documentation sucks compared to devise and setting up rodauth is ten times harder than setting up devise. Anyway that doesn't address the rails vs roda issue. you can use devise with roda and rodauth with rails. &gt;No, that's exactly the problem that Rails has. When a new Rails upgrade comes up, it usually breaks all those Rails-specific gems (e.g. Devise). Now you are lying. No it doesn't "usually" break and devise for one is thoroughly tested with every rails version to make sure it works OK. I bet they do no work to make sure it works with roda though. &gt;What's great when your web framework, ORM, templating library, CSRF protection, backgrounding library etc. are all separate gems is that you can upgrade them individually. That's bad. They are not tested together. &gt;Well, what if I want my library to be maintained by Jeremy Evans, and not the Rails team? Fine. If you want to rely on one guy then go right ahead. &gt;In my experience this cohesiveness didn't produce the best libraries. E.g. ActiveRecord is an objectively inferior ORM compared to Sequel or ROM, I'm annoyed that I ever wasted my time learning it. At this point I am not that interested in your opinion. All I know is that activerecord is tested with all other rails components to make sure it works properly and securely. &gt;I don't care if it's one guy or 12, if the library is better than the alternatives, I'll use it. It's better to have one guy that knows what he's doing and believed in his library, than to have many guys who are always changing because they're running away from complexity, like with ActiveRecord. Now you are just slinging insults. What makes you think the rails guys don't know what they are talking about? Also activerecord is not complex. 
That's terrible. Why not use a java framework if you are going to be eating up that much RAM? If my app was eating up that much RAM I'd be seriously considering redoing it in elixir or go or even kotlin. 
&gt; At this point I am not that interested in your opinion. Fair enough.
thx
&gt; I find before and let to be useful for particular situations, but find that they often get mis-used/abused in the wild, unfortunately. My rule of thumb is to use them when there's a compelling benefit, but don't reach for them as the default way to write specs. Yeah. It gets bad with deeply nested contexts, when something above expects something below to overwrite a few of it's parameters. Or contains code that is not required for nested context in a `before` block. Or when context's above contains `let!` that creates objects that you don't want to exist for *your* context, but if you want to keep semantic integrity of context descriptions you kind of *have to* nest your test case in the middle of it. Sometimes I just want to look at the context and see 90% of it's logical content, so that I don't have to scroll 400 lines above, and then 200 more, just to understand the setup.
http://rubykoans.com/ http://exercism.io/
This reminds me of a streamlined RJS. 
For really basic, look for "ruby warrior" on google, it's an rpg style ruby programming game. Might as well have fun while you learn 
Interesting concept, does it work with other work executors like esque or sidekiq?
It relies on ActiveJob to abstract the actual job queues, but there is no reason the same logic couldn't be implemented for a non-AJ worker. So, yes. 
I was thinking that we run our workers in a different environment and maintaining the websocket might be an issue 
It has a hard dependency on ActionCable to manage your websocket connections. As for running workings in a different environment, you'd probably just want to throw these jobs into a special queue which is only executed by certain workers.
Guessing this depends on Turbolinks?
Ahh, that's no good. Definitely not my intention.
It's actually jQuery dependant, no Turbolinks is involved. render_async is injecting JS code into HTML as a script tag and fetching desired URL.
&gt; not an acceptable substitute for a good copy editor Or a bad copy editor in my case, this one went past me and my (admittedly very cheap) editor. 
I'm glad it brings memories :)
[https://codefights.com/](https://codefights.com/) Good variety of challenges and a pretty good interface. 
https://www.bloc.io/ruby-warrior#/
I recommend https://github.com/evanphx/benchmark-ips IMHO it's best to start with the cleanest and most readable code and then only optimize when you find bottlenecks. For me personally using classes and OOP is faster than the alternative because it makes doing things like memoization easier and even if an extra method call might take a tiny fraction of a nanosecond (or whatever the cost) if I hadn't split the logic into a class, the optimization might have been so gnarly that I wouldn't have bothered. FWIW In the code I submitted for the assignment in the class these were all methods on an object. Clean code is easier to optimize.
Hey, I did want to mention that I was being genuine when I asked "What were you hoping for when you clicked on the title?". Several other people have said the same/similar thing in regards to the title. After some back and forth it turns out that they thought I was optimizing the interpreter or something fancy like that, and then the code is a let-down. It makes sense that you might have thought the same. I think your comment had some good points and could have helped me change the title or add an earlier warning/note (which I eventually did). The bits about avoiding premature optimization etc. could have been good discussion as well. I think we got started off with the wrong tone.
Not intending to hijack this thread, but want to give credit where it's due. When I first saw `render_async` I thought it might be doable with websockets and background job queues instead of AJAX requests... then I realized I was already doing this in on of my apps. I extracted my idea out into a [gem](https://github.com/danielwestendorf/get_schwifty) `get_schwifty`. `get_schwifty` is similar to `render_async` in that it puts a focus getting a quick response with at least _some_ HTML to the end user, while allowing heavy handed data processing to load in the background. `get_schwifty` is Rails 5 dependent, as it utilizes ActionCable and Controller renderers (caching et al built in) to do most of the heavy lifting -- in fact, the gem doesn't add much code at all, mostly conventions. Congrats to the guys behind `render_async` on the 1.0 milestone! Really exciting to see these types of efforts being made.
My thinking as well I guess, was having a weekend of doubt - thanks for the link too, looks good!
Thanks for your posts! They makes me clear my understanding of ruby blocks. And gave one more argument to read "Well-Grounded Rubyist"=) Especially I loved the third post! 
These were great, koans are amazing. Also codewars
"What are some good examples of Ruby projects that don't use frameworks like Rails?" This project tries to answer this recurring question, with a curation of 60+ ready-to-browse codebases. They have varying levels of complexity and seriousness in order to cater to all levels and interests. Contributions are welcome.
Think of a problem you have. Something that could be automated. Solve it with Ruby.
Why not list the apps and link to their repos in the readme?
Good to hear they are helpful! Well-Grounded Rubyist is very well-written and in-depth. What about the third post made it stand out?
very cool, thanks for sharing!
In order to browse the code faster, and thus learn faster. It's the idea of "[Read the Source, Luke](https://blog.codinghorror.com/learn-to-read-the-source-luke)" taken to the extreme. You download all the code once as git submodules. Then you can start browsing a project, and decide that you don't like it and switch to another one in seconds, without leaving your editor. It is also very good for code analysis. You have everything in one repo, so you can do global searches in your editor or command line tools to answer hard-to-Google code questions like: - "how to name this kind of thing?" - "how do people tend to organize such and such?" - "what library do people tend to use for doing X" - etc.
And for those of us on mobile?
To be more clear, it's not that I'm against the idea of providing it in a repo. But if I'm just looking to skim so I can decide whether to go in depth later, this setup doesn't work.
Yeah I get you, sorry this is not the main use case for this repo. You can still browse this repo on your mobile. Tap "View code", then "apps", then select one, and you are redirected to the README for that app, where you create a bookmark if you want to go in depth later. This is not perfect, but still pretty usable and better than nothing. If you just want lists there are things like https://github.com/uhub/awesome-ruby, although they mix both pure Ruby and Rails together.
thank you!
thanks for the explanation!
thank you 
Interesting, no socket required!
You achieve the same thing with submodules. I actually prefer this system. 
This isn't really practice so much as it is learning, but I think it can always be good to refresh your memory or possibly even learn something new. https://rubymonk.com/ Also I would recommend working on a personal project. It could be a gem, and application, whatever. I think you have the right mindset, I've found personally that I've learned more by actually working on something practical. So go BUILD something.
If you want some fun, try making a game with GOSU
Yeah, I read the article and it's clear you didn't mean that at all. Language can be really hard sometimes. :/
First I'd like to apologize. My initial, crude, reply indeed comes of as snarky. Sorry for that. I'll try to answer your questions in this comment and the other you posted earlier. Per the title: "Lifelong Rubyist makes some Python code 5x Faster" is very similar to "Mom finds cure for headaches, doctors hate her!" or "This one simple trick will..." in a clickbaity sense. While that might be forgivable, as someone who writes both ruby and python, I'd expect you'd bring things you learned in ruby to python. That's not really the case. You 'just' optimize some general python code and don't use any ruby-domain-specific knowledge to do so. I find it disingenuous to use such a title in that case. &gt; In real world applications making something 10% or 50% faster can make a noticeable impact. In this case we're seeing a 500% increase in the most called method of the application. Except that this isn't often the case in ruby (web) development. Most ruby development occurs in a web environment, which is almost always IO bound instead of CPU bound. In this case, you take an application that is CPU bound and pretty unique in that it needs to compete against other python programs. In this case, 1% improvement can give you an edge, but these are *very* specific circumstances. If you'd have written in in another (faster, compiled) you could 'optimize' even more. 5x faster is nothing if it applies only to 0.2% of the time spend in your program. I feel like people writing about optimization often don't present the circumstances of their optimization clearly, leading to people thinking they present general leasons learned and ultimately leading to premature optimization by people who don't know these techniques don't actually apply to their situation. Next, from the article: &gt; Prefer Logic over Objects &gt; In scripting languages object creation takes memory and CPU cycles. That memory then takes more CPU cycles to later be cleaned up in GC. &gt; Some objects are cheaper to create than others. Complex objects take longer to create and copy. Lists (arrays for Ruby) and dicts (hashes) are much more expensive to make than strings. Likewise integers are cheaper than strings. Choosing the right data structure is paramount to the performance of a program. Using a dict can be the right choice, even if instantiating one is more expensive, since lookups become O(1). &gt; Objects are slow, logic is fast. This is true in Ruby and Python. This completely depends. &gt; I don't think this is even a thing I suggested. In fact I didn't use any OOP in my article. Did you read the article? Python and ruby are Object Oriented Programming languages, you are always using OOP in that regards. Integers are object, strings are object, lists are objects. I'm fairly confident that if you threw in a named tuple or two and adhere to 'proper' OOP you wouldn't see that much slowdown compared to the final version in the blog post. I hope I answered your questions a bit with this longwinded comment. I should have posted this in the first place for discussion instead of a bit passive-aggressive list.
Props for the name.
As it's so little JS code, maybe think about dropping the jQuery dependency and writing it in vanilla JS.
Awesome idea, I will do that!
https://github.com/jeromedalbert/real-world-ruby-apps/tree/master/apps
&gt; if that's true, we have only so many languages/platforms/environments we possibly can become intimately familiar with in our careers I have only 4 years of real professional experience, so I might come at this like a total novice, but I just can't help but wondering whether in the time of Stack Overflow and the ever-changing industry that, for better or worse, sets the pace, it pays off that much to really get to know the ins and outs of language A (something that I tend to find mildly uninteresting) as opposed to learning as many paradigms and design patterns as possible, so you have a greater arsenal of skills to fall back on. But maybe I'll realise in 20 years that I'm mistaken, who knows. (Note that I'm not saying "chasing the new shiny things", which is a different thing IMHO.)
You don't define the &gt; operator, you define the &lt;=&gt; operator. The rest is done by the comparable mixin. See, for example, [here](https://ruby-doc.org/core-1.9.3/Comparable.html) or google for spaceship operator. Also, it's useful to delegate it to the members where possible. Like this (not checked) def &lt;=&gt;(other) return @year &lt;=&gt; other.year unless @year == other.year return @month &lt;=&gt; other.month unless @month == other.month return @day &lt;=&gt; other.day end
I think you need to use == in your comparison. Like @year==val.year. I could be wrong, but that stands out to me.
I don't think Koans are a good way to learn the language, but I think they're a great way to practice what you learn. In your example, &lt;&lt; is syntactic sugar for pushing things onto an array. Koans are like homework - they're a way to test what you know.
Ah got it. I see people talking about koans all over like it's a good way to learn. I'm gonna stick with codecademy. 
While it's good practice to define things in terms of `&lt;=&gt;` and gives you more power -- I agree this is the right way to do it and defining just `&gt;` is likely to give you problems -- but it should not be a syntax error to `def &gt;` class Foo def &gt;(val) return true end end Foo.new &gt; "whatever" # =&gt; true Foo.new.method(:&gt;).source_location # =&gt; ["(irb)", 5] I don't know if OP really has any "syntax error" problems, as they say, or they're just having the problem slade981 mentions in another comment, where they used `=` (assignment) where they meant to use `==` (equality). OP, when posting a problem or bug report, "it doesn't work" isn't a good one, you gotta tell us exactly what is happening that is different from what you expect to happen. An error message? What is it? Different behavior than expected? What was observed behavior, and what was expected/desired behavior? But I agree that it would be preferable to define `&lt;=&gt;` instead of `&gt;`, and that your suggested approach to implementation is a good one. 
I am most categorically not "intimately familiar" with Ruby. Of those, I'd say I'm intimately familiar with Java, and extremely experienced with CL (both pre and mostly post ANSI) but in bits and pieces over 25+ years. Clojure is new to me, with only about a year under my belt - but it tickles many of my joys and as a Lisp is in general well suited to my style, and being built upon the JVM (which you have to know if you really want to understand Java) it leverages some of my knowledge. Although I have also used ClojureCLR and have a little romance with the CLR going on the side..
One of the things a lot of experience with a broad array of paradigms, architectures, languages, frameworks, etc., and deep knowledge in several brings is the ability to analogize many new problems to other challenges you have solved in many ways in the past, and pick a reasonably close to optimal solution the first go around. In professional life, I keep falling back to the tried and true (Java, Ruby, SQL/PostgreSQL, previously C++) although Clojure quickly becoming a go-to since it's a Lisp and has the JVM access. In my personal life, I'm always playing with the new stuff and the languages I really love (Haskell and Common Lisp). For example, I enjoy playing with Idris, Erlang/Elixir/LFE, OCaml, etc. I am looking forward to learning and doing some play projects in Rust and F#. I played with Go (implemented a highly asynchronous server in it) and found it to be, how can I say it, personally revolting, but I can grudgingly understand why it might appeal to some. There are gems to read for almost every language, if you really want to up your game (Common Lisp Recipes? Metaprogramming Ruby? Back in the day, Doug Lea's Concurrent Programming in Java? etc.) as well as reading/learning the low levels of the language and even execution environment (e.g., the memory models of X86_64 vs ARM, cache hierarchies, etc.). Intel's documentation is amazingly great, for example.
thanks for the very interesting response.
I think they can be if you have a certain type of personality. If you're just trying to make the tests pass instead of heading out to learn more about why they weren't passing in the first place, then it's much more like a homework/test than a tool to learn. Some people eat that stuff up and use it as a basis for what to google and learn. I mean, in your example, a simple search of `ruby array &lt;&lt;` answers your question immediately. Personally, I think a good book and some side projects are the best way to get started. I used the first half of Why's Poignant Guide myself, and then a few other books that I don't recall. Also http://tryruby.org which is like Codeacademy. I didn't really care of the Koans either.
&gt; then I get to (...) I've never seen this so I assume the answer is (...) That's the problem. Any "learn on practical tasks" approach _assumes_ that you'll not _assume_ when you see something unknown, but google/look into your book. With this approach, Koans are useful (they show you new stuff → trying to understand it, you teach yourself). With wild guessing, they are not.
Koans are good for people who already know the language to solve unique and interesting problems. Then you look at the various solutions and learn new tricks.
When you come across something you don't know, you're supposed to go learn that *one specific little thing*. A few seconds on google would have told you that `&lt;&lt;` pushes things into an array (as well as a few other things) You're not learning anything if you're guessing. Go learn the little thing and practice it (the Koan itself), then move to the next one. You'll often see them coming back up in later koans.
Yah they work really well to sharpen and reinforce what you've learned. I think it's totally possible to learn ruby with it, but like was said before it takes a certain personality. That type of person would see an operator they are unfamiliar with (the &lt;&lt; for instance) and would research what it does. Then they could come back to that problem, and feel confident in their newfound knowledge as they instantly put it to use.
/u/rochkind details this in a reply, but please include the exact error message. "It doesn't like my syntax" isn't as helpful as "I got this error, on line such-and-such, and here's the backtrace." Edit: On trying your code myself, it fails with an ArgumentError, inside the #&gt; method, for the reason /u/slade981 gives in another comment.
The koans are just another way of learning. It depends, but a lot of times you remember something better when you have figured it out instead of just being told. The painfulness you describe is part of why they work IMO.
Different people have different learning styles or approaches. I'm not a fan of the koans either. You don't have to be. Some people love em. I dunno. 
 compare(player_choice, computer_choice) if compare == computer_choice you never store the result of `compare(player_choice, computer_choice)`. When you say `compare == computer_choice` you're actually saying `compare() == computer_choice` - that is, calling choice *again* with no arguments. Replace the two lines above with if compare(player_choice, computer_choice) == computer_choice
I'm seeing a few problems. First: if compare == computer_choice Perhaps a typo? 'compare' is a method that requires 2 arguments. Perhaps you meant assign the result of the method to a variable and use it here. I presume this is where the argument error is arising from. Second: include?('rock' &amp;&amp; 'paper') This will not throw an error, but is not how to use the 'include?' method. Passing in 'rock' &amp;&amp; 'paper' will just return 'paper', so it will just check whether choices.keys includes 'paper', etc. 
Ah, thank you so much! I'm trying to get better at storing variables &amp; separating out methods. I'm still receiving one error on this problem though: if player selects paper &amp; computer selects scissors, player still wins.. any ideas?
Yeah, thanks, you're absolutely right! I forgot to pass arguments to compare in my rps method! Any idea how i could effectively refactor my compare method to work proper? (doesn't need to use 'include?')
I found the Koans a good way to learn Ruby syntax and some of the language quirks quickly. I recommend them to folks who are already proficient in several other languages (built production systems level of proficient). If you don't know how to code or only know one or two other languages they probably don't have enough explanation for you. They work best if you already have concepts like anonymous functions, closures, object ids, etc well understood and just need to map those existing concepts to the new language. But I like constructivist approaches to education and I know they aren't for everyone.
I think you intend for your `compare` method to return the winning choice, for each possible pair of choices. However, `include?` with an argument of `'rock' &amp;&amp; 'paper'` only checks to see if `'paper'` is one of the choices, since `'rock' &amp;&amp; 'paper'` evaluates to `'paper'`. Demo: irb(main):005:0&gt; 'rock' &amp;&amp; 'paper' =&gt; "paper" irb(main):006:0&gt; ['rock', 'paper'].include?('rock' &amp;&amp; 'paper') =&gt; true irb(main):007:0&gt; ['dung', 'paper'].include?('rock' &amp;&amp; 'paper') =&gt; true
ah, you're totally right. any idea how i might rewrite this to carry out the intended behavior?
Here is another approach for the compare method: def compare(player_choice, computer_choice) case [player_choice, computer_choice].sort when ['paper', 'rock'] then 'paper' when ['rock', 'scissors'] then 'rock' when ['paper', 'scissors'] then 'scissors' else raise 'this should never occur' end end Sorting the player_choice and computer_choice, plus already knowing that they are not the same value, means you only have 3 cases to consider. If you really want to use include, you could say: if choices.keys.include?('scissors') &amp;&amp; choices.keys.include?('paper') But if you sort them first, you can do simple equality checking.
Yeah, see my other (top-level) comment.
Thanks for the tips JeffMo!
This isn't really a noob question about Ruby so much as about programming on a PC. If you're running OSX (mac) try this program, which is a replacement for the standard OSX terminal program: https://www.iterm2.com/ And while you don't NEED this program, it is certainly more versatile than the standard Terminal, which you can also use. Hint: you will need to be in the directory that you have saved whatever *.rb file you were working on in SublimeText.
Reading your question closer, I suspect you're going to ask a followup question, which is how do you actually RUN the *.rb file, in which case: https://stackoverflow.com/questions/8721369/how-to-execute-a-ruby-script-in-terminal
Hi all, I changed my function to this based on your suggestions. Can you tell me why I am getting this error below now? def &lt;=&gt;(val) return @year &lt;=&gt; val.year unless @year == val.year return @month &lt;=&gt; val.month unless @month == val.month return @day &lt;=&gt; val.day end def ==(val) @year == val.year &amp;&amp; @month == val.month &amp;&amp; @day == val.month end def !=(val) @year != val.year || @month != val.month || @day != val.day end My tests are the below. d027 = SimpleDate.new(2016, 1, 1) d028 = SimpleDate.new(2016, 1, 2) assert(d028 &gt; d027) refute(d027 &gt; d028) refute(d027 &gt; d027) I am getting this error on the line: assert(d028 &gt; d027) 1) Error: SimpleDate#test_0001_works as expected: NoMethodError: undefined method `&gt;' for #&lt;SimpleDate:0x00000001265ab0 @year=2016, @month=1, @day=2&gt;
Yes, you'll usually run Ruby scripts from your terminal. You'll need to cd (change directory) into the same folder where your Ruby script is. So, if you saved your Ruby file in a folder like: users/FF430/documents/code/ruby/hello_world.rb You'll want to open your command line (Windows) or terminal (Mac) and type in: cd documents/code/ruby Then you can run your Ruby file by typing: ruby hello_world.rb If you want to run a Ruby script directly from Sublime itself, you can go to tools, then build system, and select Ruby from the list. Then you should be able to run the file by pressing CTRL + B (Windows) or Command + B (Mac). Note: I don't use Sublime myself but I got those instructions from [this Stackoverflow post](https://stackoverflow.com/questions/11410158/execute-ruby-code-in-sublime-text-2).
Was than 6% of the way through and you've deemed it useless? 
yes. I've never learned any way but by building things, even if the things were homework assignments. I like to read reference materials too, more than most, but always in the service of building things. 
You're creating you rooms object in the wrong place. Pay attention to the difference between [a class variable `@@var` and an instance variable `@var`](https://stackoverflow.com/questions/3802540/difference-between-class-variables-and-class-instance-variables).
I tried it with a class variable and it still doesn't work, that's why I initially started using an instance variable EDIT: It's somehow working now but I still have no clue what the difference is. Some places use one`@` and some use two `@@` but argue one is better than the other or in different scenarios. I just want to be able to initialize the rooms variable to soom value then be able to print it EDIT 2: now it's randomly not working again. I'm usually able to pick up languages somewhat quickly but this is infuriating and frankly unintuitive
Do you understand what class variables and instance variables are? class Example # Class variable @@var hasn't been created yet @@var = Array.new # Now that @@var is created, you can use it # declares an instance variable but doesn't create it # Note: attr_accessor also defines a method `var` in Example so you don't need to attr_accessor :var def initialize(x) @@var.push(x) @var = Array.new @var.push(x) puts "@@var = #{@@var}" puts "@var = #{@var}" end end e1 = Example.new(1) # You can use e1.var because attr_accessor defined it for you puts "e1.var = #{e1.var}" e2 = Example.new("a") puts "e2.var = #{e2.var}" e3 = Example.new(42.8) puts "e3.var = #{e3.var}" 
Some code: class RoomGenerator def initialize(lower, upper, amount) @rooms = [] @lower = lower @upper = upper @amount = amount end def rooms @rooms end def build_rooms @amount.times do |i| r = rand(101) if r &lt;= 35 @rooms &lt;&lt; Room.new(1) elsif r &lt;= 65 @rooms &lt;&lt; Room.new(2) elsif @room &lt;= 85 @rooms &lt;&lt; Room.new(3) else @rooms &lt;&lt; Room.new(4) end end end end class GalleryController &lt; ApplicationController before_action :build_rooms, :only =&gt; :index def index @rooms = @room_generator.rooms end private def build_rooms @room_generator = RoomGenerator.new(1, 5, 10) @room_generator.build_rooms end end Some notes: * Don't confuse yourself with `attr_*` methods. They're just syntactic sugar. * Learn some more idiomatic ruby and familiarise yourself with Rails conventions _and_ follow them. You look like a PHP dev, which is okay, but you'll hurt yourself long-term by not following Rails conventions (which are often inspired from Ruby's style guide) Note to Ruby purists: Yes I lost style points by not assigning `@rooms` in `RoomsGenerator#initialize` but for the sake of this post it's probably best to be clear.
As you can see in the [example](https://ruby-doc.org/core-1.9.3/Comparable.html) I linked in my first comment, you need to ``include Comparable`` in your class. This will define all the methods that can be implemented with the functionality of ``&lt;=&gt;``, for example ``&gt;``.
Personally, I don't have any strong feelings regarding the "gems.rb/locked" changes. I think that's what the major version change is for. However, I hope bundler ships with a special command to "upgrade" bundler artifacts. Telling me to rename a file when you can automate my workflow seems pointless. And I also hope that bundler and rubygems somehow "merge together" in the future. The main pain points I've had with the 1.x series is that they strongly rely on rubygems API which may change (I remember a `#activate_bin_path`method disappearing and breaking bundler). Hopefully shipping with ruby will semi-solve it for now. But it was unbelievable how this "Bundlergate" escalated in a couple of days. 
Are the talk recordings going to be released afterwards? I'm not sure I understand the pricing.
Thank you so much! I didn't realize I needed to do that. That seemed to have worked as I don't get errors back from those tests!
Wasn't there a plan to slowly merge the two (rubygems &amp; bundle)? I think most of us install ruby, do "gem install bundler" and never use the "gem" CLI again.
There's not much details about the conference. No emails, no contacts. Just "pay to get everything" without providing enough information. Hmm.. EDIT: There is https://angulardevsummit.com that looks the same that was a month ago. Suspicious EDIT 2: @mhartl answered that the conference is legit. Hooray!
You should at least attempt to do your homework question before asking questions on reddit. Those algorithms listed don't look too difficult to implement. Pick one and start implementing. 
I do now. I was up late and for some reason the words class and instance were throwing me off to my understanding. I have it working now with a better understanding of classes as a whole. Thanks!
I'm sad I look like a PHP dev lol, I've never touched PHP in my life but I do come from an iterative style background which I'm trying to move away from. I must prefer functional languages, but the syntax is a bit of a hurdle 
&gt;I'm sad [Here's a picture/gif of a cat,](http://24.media.tumblr.com/tumblr_lmjw727Fkf1qz7o2oo1_1280.jpg) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
The conference website is definitely a bit lacking. I'm assuming that you get to watch any of the presentations live stream for free. the $97 gets you access to download the presentations after the fact, plus slack, etc. i wish they would have at least been a bit more specific about the free tier.
Gem install is still useful for tools that can be used from the command line.
I believe that is still the plan/intent/desire, I think progress on it is pretty slow. Adding bundler to ruby core maybe eases that somewhat, since rubygems is already in ruby core. Or maybe it doesn't matter much. I don't think `gem install` would even theoretically go away (It is still useful sometimes, just not for Rails dev heh; I don't think it would be desirable for all ruby projects to be forced to use a Gemfile though), the different functionalities would just become more aligned and consistent with each other instead of sometimes fighting with each other (avoiding rubygems API changes that break bundler, duplicated logic in both packages, etc). 
I found a good site with a formula here: http://www.tondering.dk/claus/cal/chrweek.php#calcdow My code now looks like this and it passes my testing. class SimpleDate attr_reader :year, :month, :day def initialize(year, month, day) @year = year @month = month @day = day end def wday #Return day of of date as integer, Sunday = 0, Monday = 1, etc. a = (14 - @month) / 12 y = @year - a m = @month + (12 * a) - 2 ( @day + y + (y / 4) - (y / 100) + (y / 400) + ( (31 * m ) / 12) ) % 7 end Math tends to have 31a to mean 31 * a and I put 31 * a in the code. Is there a better way I could have coded the formula? Thanks!
I wasn't trying to imply that `gem` is useless, but most of the time people use bundler if they do anything that has a few dependencies. My intend was to say that `bundler` is very important and it could be in the core _as well_.
I would be a fan of `Symbol &lt; String`
I believe you (as many of my own colleagues) got tired not from this _distinction_ (which is totally useful) but from _indistinction_ (see Rails, HashWithIndifferentAccess, WtfKindOfParams etc.) Symbols are "names I know", Strings are "text I've received from outside world". As simple as that. In webapps, instead of SomeParams magic, we need clear and visible boundaries, on which unsafe user input (get params = strings) is thoroughly coerced into meaningful business data (hashes with symbolic keys). What we got instead? `params.to_unsafe_hash.with_indifferent_access` pooof, problems solved.
After using Lua for a while, where all strings are Symbols (kinda), that particular part of ruby feels wrong.
As far as I know Symbol are fast regarding methods like `#hash` because internally they are handled like integers. Like u/zverok_kha I think of Symbols as names, that have a special purpose. This distinction is often very useful (one example that immediately comes to mind is representing the PDF data types in Ruby because PDF has strings and names).
It has benefits and I understand why Matz included the feature in ruby, but I agree that if I were designing a language from scratch I'd think very carefully about if I really wanted it, it often gets inconvenient. But realistically, I don't see em going away in ruby any time soon/ever, plenty of existing software depends on the distinction. 
I used to think it as well, but than I realized it's way more situations than just the web context. Integrating with a few libraries as well. &gt; Symbols are "names I know", Strings are "text I've received from outside world" And you need to work with both of them together at the same time so often that I realized I don't need the distinction. If I care or the library cares whether the name comes from internal or external input then I believe it is a sign of an incorrect design. What is the single, biggest problem solved by symbols? I don't know :)
writing performant and scalable code will always be inconvenient
Interesting read, though I actually really like symbols. I constantly aim to minimize the amount of strings in my code as much as possible - mostly input from outside, while symbols are definitely in the scope of my coding and mean something internally.
 number_of_loops.times do code_you_want_to_call_many_times end
What error are you seeing? Your code works for me
In contemporary ruby, I don't think Symbol has much to do with performant or scalable. How do you think it does? The main difference with regard to these things is that Symbols are "interned" and not garbage collected. Except that actually _caused_ performance problems in Rails. And, hey, starting with MRI 2.2 Symbols are actually GC'd too now. 
It sounds like you could use the GoF Decorator pattern here. The premise is that you can take a base item (hamburger), "decorate it" with each ingredient that they need (cheese, special sauce), and the result is a quote with the right pricing and description. (This is almost the textbook example from the Head First: Design Patterns book) For instance, if the "wiring a hot tub" job includes these services: a new electrical panel, 240V outlet, running wiring, an external power switch, and a permit. By adding decorators, you iteratively build the results: 1. Wiring a hot tub: Description: "Wiring a hot tub.", Price: none 1. add electrical panel: Description: "Wiring a hut tub. Includes a new electrical panel", Price: $299 1. add 240v outlet: Description: "Wiring a hut tub. Includes a new electrical panel and a 240V outlet", Price: $399 1. add running wiring: Description: "Wiring a hut tub. Includes a new electrical panel, a 240V outlet and running wiring", Price: $499 etc. until you've built up the quotation.
Git commit message -- how to write a great one and why. https://github.com/joelparkerhenderson/git_commit_message Questions &amp; comments &amp; suggestions welcome.
I can't speak to all the details regarding recordings, etc., but I'm giving a talk, and I know the organizer, so I can assure everyone that the conference is legit. 
The interning guarantees a unique and immediately accessible hash. Because absolutely everything in ruby boils down to hashtable lookups, including member calls, this saves the effort of calculating a possibly colliding hash that a string would require. There's a lot more to this though, like not being in the GC is a time saver for each collection etc edit: To your point on rails and MRI 2.2, ruby's ethos is basically "programer time costs more than cpu time", they sacrificed the performance because too many beginners converted external input to symbols.
you can totally just throw a variable in there.
See [my answer](https://www.reddit.com/r/ruby/comments/74gsfm/i_got_tired_of_string_vs_symbol/dnyau34/) below
No error, but it only performs the loop once no matter what I set the variable to
 print "How many loops? " number_of_loops = $stdin.gets.chomp.to_i (1..number_of_loops).each do |whatever| puts whatever end If I puts whatever, it is working. Are you sure it's not?
This conference seems to be organized by Charles Max Wood from Devchat.tv, he announced it in his latest newsletter, which concludes with the following: "If you really feel like you need to spend money on a conference, get yourself your favorite beverage or an All Access Pass to get the recordings..." So I guess yeah, talks recordings are probably not going to be free for all afterwards. Still looks cool.
I'll look more into the decorator pattern later today. Based on my limited knowledge it looks like it's used to layer attributes. That's not quite what I'm thinking. Maybe a house example is better. A contractor could quote you 1 line for $100,000 for a house or he could list all the component activities like you did above and still come to $100,000. The detailed list describing the house and the 1 line are just different ways to describe the same thing. Only the level of detail in the description has changed. The sum of the parts equals the sum of the whole. 
But doesn’t that defeat the whole point of having a more lean object to act as an identifier?
Using the example I described, you simply wouldn't output (or, maybe, modify) the description. You could still sum the price the same. The general point of the pattern is to iteratively build the quotation with a bunch of individual options which are peers - whether all stored in a Hash (options[:cheese]), ActiveRecord objects (Options model) in Rails, or PORO objects (class CheeseOption).
I just got it to work. I'm not sure what was wrong, but I was running a semi-long series of events inside that loop, so instead I took all those calculations, made them into a separate function, and called that function inside the loop. Now it is working. It would be cool to know why but I guess it works so *shrugs*
Yeah it seemed like it should work. After reading these comments, I realized that the problem wasn't with the variable but with the functions I was calling inside of the loop. I took them out and made them all they're own separate function, so rather than my loop containing several lines it only contains one. Works fine now. Not sure why
Personally I find the RSpec documentation pretty good and well organized, much better than a lot of other library. Also the method names are really expressive so it's easy to deduct. If you jump in any project that uses a library that you never used before, you are going to need some time to understand it's usage. Maybe using a [cheat sheet](https://www.anchor.com.au/wp-content/uploads/rspec_cheatsheet_attributed.pdf), like this one could help you.
Thanks for the help man
No. There's no reason why the internal representation can't be just as compact.
If you implement your own LISP interpreter you will get a better idea of why the distinction exists. Strings are for data and symbols are for identifiers.
There's that (it would add a lot of overhead to go through the inheritance chain to make sure the right vtable is used), and there's also a lot of methods of string that should never be supported by symbols because they are immutable.
&gt; the effort of calculating a possibly colliding hash that a string would require. I touched on that in the article. If symbol was an immutable, frozen string, it could still be unique and have a pre-calculated hash. Think about this way. If the symbol is dynamic (coming from string) there is no performance benefit. If the symbol is a literal in a code, then during parsing/interpreting this code it is a string (in interpreter) the ruby needs to match it with one object it keeps in an internal pool of string =&gt; symbol. Making it string =&gt; string pool of objects does not change anything regarding to speed.
And Matz said that Ruby devs no longer used them the way it is being used in LISP.
Can you provide a citation?
Hey folks, I'm organizing the conference. I'll go clarify the pricing on the website in a minute, but here's what I think you're looking for. Free tickets get you access to watch the conference LIVE on the live stream. All Access Passes get you onto the paid attendee chat room and access to the recordings after the conference. Sorry for any confusion. I'll also put an email address and/or contact form so people can contact me if need be. Thanks for the feedback.
Symbols are immutable. Your are correct about the parsing phase dealing with first as a string of course, but the thing is, you only parse once, from there on it's just an int in memory. Actually the pool is more like a table of strings, and a hashtable for uniqueness. Ideally those should basically be constant during runtime. There are many other considerations, for example comparing ints barely takes a cpu cycle, but comparing strings takes weird algorithms. A non colliding hashtable has one dereference less to it. 
I just consider google part of the documentation. If I look for "rspec any instance" I get [this page](https://relishapp.com/rspec/rspec-mocks/docs/working-with-legacy-code/any-instance) on the first try. It might not be elegant, but it works well enough for my needs.
I like it. The use of a standard set of verbs is interesting. Hadn't thought of getting a team to agree on that before. Going to explore that in future conversations with teams and see how it goes. I assume it's working well for you?
&gt; In webapps, instead of SomeParams magic, we need clear and visible boundaries, on which unsafe user input (get params = strings) is thoroughly coerced into meaningful business data (hashes with symbolic keys). I've [got something for that](https://github.com/tomdalling/rschema/blob/bbfb1dd83eb1675a9be37b6dbe6a4577ee30995e/spec/rails_spec.rb#L75-L78). I've been meaning to write about it for a while, but I just haven't found the time.
excercism.io is something similar. Not sure if it works offline though
:+1: for clarity I recommend this over 1..x :)
The big difference is that Ruby strings are mutable, Lua strings are not. Ruby 2.3 introduced immutable strings, but it's optional and (unsurprisingly) breaks a lot of things. With symbols being GCable and strings headed towards immutability in 3.0, the distinction is certainly narrowing, though.
It should after you pull the problem. You can run the tests locally.
My problem is I don't know which of several sites I'm supposed to look at. But yeah, I mostly just Google and hope for the best. The official docs make it very hard to find what you are looking for if you don't know their names, and lack any reasonable reference of how to use the damn thing as you point out.
The problem is that using their client, you can only get the next one after submitting a solution.
This cheat sheet is very handy. --- &gt; Also the method names are really expressive so it's easy to deduct. It's the job of the API to make things easy to deduce, and the job of the documentation to make things easy both to understand and to discover. The API is superb; the documentation is half great and half lousy, respectively. &gt; you are going to need some time to understand it's usage. Its usage makes perfect sense to me. The issue is that I have no way of knowing how much of RSpec I _don't_ know, and that's why discoverability is paramount. If you look at the Ruby `Enumerable` and `Array` API docs, you can tell at a glance (and more or less exhaustively) how many things you can do with arrays. And if you're familiar with maybe a dozen methods, you have some sense of how much more there is to learn. With RSpec, not so.
&gt; I used to think it as well, but than I realized it's way more situations than just the web context. I have a mostly non-Rails (web and non-web, as well as gem development) background. The first time in my life I became frustrated with Symbol/String is indeed when I've started working with Rails. &gt; What is the single, biggest problem solved by symbols? I don't know :) Well, when it comes to design tools and language features somebody considers "useful" or "useless", it is typically pretty hard to argue logically. But for me, Symbols is first and foremost tool of though -- something that, being used in my code, should be considered as carefully as other _names_, while Strings are "just content" I can't control.
Yes, I am aware of RSchema. It looks quite promising, but I still haven't an opportunity to try it (or other approaches to "solve" the problem) in battle, so I am not quite sure what is "right" (or at least will feel "right" for me personally).
Symbols are concepts, Strings are data.
&gt; Symbols are taken from Lisp symbols, and they has been totally different beast from strings. They are not nicer (and faster) representation of strings. But as Ruby stepped forward its own way, the difference between symbols and strings has been less recognized by users. * https://bugs.ruby-lang.org/issues/7792 * https://bugs.ruby-lang.org/issues/5964 * https://bugs.ruby-lang.org/issues/7797 Check out these discussions
&gt; for example comparing ints barely takes a cpu cycle, but comparing strings takes weird algorithms You can start comparing by checking hash. If you compare two symbols (immutable, frozen string with precomputed hash) that would be still just comparing two ints. It would be probably slower though if you compare normal string vs symbol.
&gt; This distinction is often very useful When exactly is it useful? Can you show an example code/class? &gt; representing the PDF data types in Ruby because PDF has strings and names Can't you create your own data type to represent PDF names? Shouldn't you represent such concepts with classes anyway?
I'd love to see Symbols gone. Strings are heading towards immutability and both Symbols and Strings are GC'ed since Ruby 2.2. Symbols are still faster than Strings but if there are people smart enough to add a JIT to Ruby then I'm pretty sure it's possible to make immutable Strings as fast as symbols. If Ruby internally needs symbols then fine, don't remove them but keep them internal. To the external world they could be immutable Strings as the OP suggests. And nope, not only mere developers struggle with Symbols. The GitHub crew does too https://github.com/blog/1440-today-s-email-incident. This change wouldn't be 100% backwards compatible and that's the biggest issue in my opinion. For instance, `:foo.is_a(String)` would return `true`, while currently it returns `false`. I posted a full response to the OP's article here http://mlomnicki.com/symbols-vs-strings/
What you're not getting is that a symbol is a number, that just happens to have a label, and always is globally unique for that label. It is a collision free hash. For strings it's pointless to first compare hashes: To hash a string you have to run over it, so running over two strings and then still having to check char by char is far more expensive than just checking char by char. To compare symbols, you just need to compare their "hash", which is pre-calculated once when being interned.
&gt; "useful" or "useless", it is typically pretty hard to argue logically I see everywhere devs saying that they don't mix them. So if symbols were strings and they don't mix them then the code would still continue to work properly. I can't find a convincing usecase to distinguish between them. Everyone says they use them for internal names. Ok, me too. But what problem does it solve that use use symbols for internal names? I am not sure. Why is it any better? And the different between internal and external becomes really blurry once you start serializing and deserializing your objects or integrating with other libraries.
I just read your article, you really need to change your attitude from "I don't know why there's a difference so let's get rid of it" to "I don't know why there's a difference, I should find out". A frozen string is just an overhead that prevents mutating methods from being called. It was put in place because of noobs who kept writing methods with unexpected side effects. Storing an extra int for every string is not free. Storing strings forever, which is/was the downside of symbols, is not free. You need to learn some C and implement basic string functions then a hashtable to see the point.
"We tried &amp; failed". Matz himself commented on the idea https://twitter.com/yukihiro_matz/status/916083723589656576 
Thanks I will have a look.
I like symbols, they have different semantics than strings. I suspect most of the problems with symbol-vs-string stems from the fact many ruby web apps don't have an explicit way of converting http params to nicer structures where symbols are used instead of strings. "Solutions" like `HashWithIndifferentAccess` made it even more confusing. Once you properly handle data at the boundaries (ie http or database) problems like "is it a hash with string or symbol keys? Or maybe something weird that works with both?" go away. Symbols are not the problem, the way data is handled in typical ruby/rails apps is a problem. I should add that there's quite a bit of legacy reasons too. Since symbols are now GCed too, a lot of libraries that produce string-indexed hashes, could've safely used symbols instead. ie rack could use symbols for params, low-level database libs could return hashes with symbols too. At least that's my theory :)
&gt; What is the single, biggest problem solved by symbols? I don't know :) From an external view, they don't solve a problem that can't be solved otherwise (i.e. with strings). From an internal view, you can't make a programming language without them. In Ruby, they're used to give the programmer access to a tool that's already there and very useful: the internal symbol table. Other people in this thread already pointed out the benefits of having this tool available. If you have problems with symbols, you're very likely abusing them. 
Please don't tell me what I do or don't need to do. I completely understand why there is a difference. I don't find it useful and I believe all performance reasons you mention could be workarounded. &gt; I just read your article, So your previous comments were before reading it. LOL. &gt; To compare symbols, you just need to compare their "hash", which is pre-calculated once when being interned. That's what I said: &gt; You can start comparing by checking hash. If you compare two symbols (implemented as immutable, frozen string with precomputed hash) that would be still just comparing two ints I don't focus on the performance aspect too much. Rather as to when is the distinction between Strings and Symbols useful. Everyone says to me they are using it in 2 different situations. But nobody says what problem does it solve or what do they gain by doing it. The reason Matz failed in implementing the proposed solution was not due to performance problems. Too many gems were broken.
&gt; My intend was to say that bundler is very important and it could be in the core as well. According to ruby 2.5 changelog, it will. But whether it will merge rubygems, that's a different issue. 
&gt; But what problem does it solve that use use symbols for internal names? I am not sure. Why is it any better? Less memory usage, less objects, faster to compare/lookup, at least in theory.
At least in Bash, `-m` isn't necessarily the problem, because you can still write detailed multi-line comments. As long as you don't close the quotes, hitting enter will add lines to the message. It ends up looking something like this: git commit -m "Terse description of the commit purpose &gt; &gt; Detailed paragraph of the underlying reasons, links &gt; to documentation or Stack Overflow, etc. &gt; &gt; This can go on as long as you want until you terminate the &gt; opening quote." 
In your terminal, run `identify -list format` and see if PDF is listed with read support. If not, you'll have to reinstall ImageMagick with PDF support explicitly enabled.
&gt; So your previous comments were before reading it. LOL. Yeah, don't need to, theres tons of valuable reasons for the difference, by thinking it's unjustifiably cumbersome I know everything I need to about your understanding. &gt; I don't focus on the performance aspect too much. that much was clear from the start, and I did list several reasons that make the distinction useful, even necessary because of ruby's general overhead, if you don't understand the implications on the runtime you need more thorough understanding of it, as well as more algorithmic competence. From your own requote: &gt; the difference between symbols and strings has been less recognized by users And indeed you don't. Despite my effort to clarify. You confuse hash and collision free hash, frozen and interned, and all the implications those have on data structures. &gt; It might be that computing a Symbols’s hash is 2-3 times faster than a String’s hash right now. I don’t know why. Then look into why, instead of assuming everything can be worked around. You sound like someone who has never even read a runtime let alone written one. You probably know only high level languages. That's why I still recommend the attitude change into inquiry rather than complaining Users like you are why symbols are now in the GC, why we needed frozen. We had the exclamation mark and it worked fine for us, but you're ruining ruby performance for the rest of us
Download them from https://github.com/exercism/ruby/tree/master/exercises ?
&gt; &gt; This distinction is often very useful &gt; When exactly is it useful? Can you show an example code/class? Think of a game where a player can move a character in four directions: left, right, up, down. In languages like C there would probably be constants LEFT, RIGHT, UP, DOWN representing these instructions. And their values would probably be integers because of performance reasons (like it was already said, comparing integers is much faster than comparing strings). In Ruby you don't need a workaround to represent this concept, you don't need constants with some arbitrary values. You can just use the symbols :left, :right, :up, and :down. What you get are expressive values that don't have and indeed need any indirection like constants. And you get the same performance as if you had chosen integer constants. I think that nobody would use strings for this... &gt; &gt; representing the PDF data types in Ruby because PDF has strings and names &gt; Can't you create your own data type to represent PDF names? Shouldn't you represent such concepts with classes anyway? Yep, I definitely *could* create a PDFName class that just wraps a string representing the PDF name. That would lead to drastically higher memory usage. And a bad user experience. Would you rather write `pdf_dictionary[:key] = value` or `pdf_dictionary[PDFName.new("key".freeze)] = value`? Care to guess what Java implementations of PDF libraries do since they don't have symbols? They create a PDFName class and then declare a huge amount of static objects for the most commonly used names... As for general representation of PDF object types in Ruby, I have actually written a [blog post](https://gettalong.org/blog/2016/pdf-object-representation-in-hexapdf.html) about that.
I don't know if this is what you're looking for, but in the top right of the page you linked (http://rspec.info/documentation/3.6/rspec-mocks/) you can select "Class list" and comb through the source that way.
It is some kind of stalemate in the discussion ¯\\\_(ツ)_/¯ With "for me, it is not convincing" repeated against each and every argument, you can question anything. For example, `map`, or `reduce`, or using blocks in Ruby, or using Ruby (against, say, Python or JS) itself. I am not sure. Why is it any better?
When I am try to git clone I get following error. What I am doing wrong? ssh_exchange_identification: read: Connection reset by peer fatal: Could not read from remote repository.
I think you can understand most of it just by looking at slides (no, I don't speak Japanese).
Maybe you haven't configured Git and added your SSH keys in Github? If these steps don't work https://help.github.com/articles/testing-your-ssh-connection/ that may be why. You want to follow the steps in https://help.github.com/articles/connecting-to-github-with-ssh to fix any problem. But if all of this works already then I don't know.
Sorry for that. I figured it out. I am using public library internet and for some reason they do not allow ssh access. At home I have no problem downloading it.
But it also protec
Cool this is a great idea! I just put in my submission. Hopefully more people want to get involved in pairing sessions
Awesome! I'm very excited about our first pairing week starting next Thursday! &amp;nbsp; Please feel free to share it will your friends and local groups. There are submissions all over the world from different time zones. I'm trying to make sure there will be at least one match for each engineer! :D
Well, shut my mouth!
Thank you for your reply. Somewhere in the throws of agitation, I nuked the ImageMagick and rmagick installations and reinstalled imagemagick@6 and the latest rmagick, which, along with ghostscript, fixed the read issue. By the way, .pdf to .png (and *only* .png) conversion messes up the colors something fierce. For others who encounter similar issues, it is necessary to apply a Colorspace to the .pdf on read, e.g: img = Image.read("in.pdf") { self.colorspace = SRGBColorspace } Thank you again for your time and attention.
Maybe something like this: class Singer def repeat_word_string(str, repeat_count) " " + repeat_count.times.collect { str }.join(', ') end def sing(phrase, repeat_word=nil, repeat_count=5) s = phrase s &lt;&lt; repeat_word_string(repeat_word, repeat_count) if repeat_word puts s end end singer = Singer.new singer.sing "Cause the players gonna", "play" singer.sing "And the haters gonna", "hate" singer.sing "i just shake it off" 
/r/rugby
Try something like this? (Untested) class Singer def initialize() end def repeated_word(word, repetition) repetition.times {print word } end def sing puts “Cox the player’s gonna #{repeated_word(“ play”, 5)} and the hater’s gonna #{repeated_word(“ hate”, 5)}, \n I just shake it off “ end end Singer taylor_swift = Singer.new() Taylor_swift.sing() 
Glad you figured it out! It was fresh in my mind, since just his week I had to figure out how to install ImageMagick on an Ubuntu 10.04 box to support a Rails 2.3 app from 2010... that was not an easy nut to crack, so I understand the frustration.
Thank you so much, i'll try that.
&gt; Thank you so much, i'll try that too 
Try this: class Singer def initialize(lyric, word) @lyric = lyric @word = word end def sing puts @lyric + " " + duplicate_word end def duplicate_word 3.times.map { @word }.join(", ") end end s = Singer.new("Cause the players gonna", "play") s.sing The `map` method collects the words &amp; then `join` creates a string with a comma + space as separator. Documentation: * http://ruby-doc.org/core-2.4.2/Enumerable.html#method-i-map * http://ruby-doc.org/core-2.4.2/Array.html#method-i-join 
Don’t dig too deep into this one (sorry, SamGill). Two things: - There are syntax errors if you run this (you don’t declare var types in Ruby (`Singer taylor = Singer.new`). - This really defeats the purpose of putting this in a class. Technically it meets the requirements but is avoiding the spirit of the assignment which is to create a reusable object as opposed to generating the text procedurally in a script. This just wraps an object around the same script you’d write if you didn’t use a class at all.
I’ve had a good experience with sorcery. 
Hey @BoWild, I took some of your feedback and went back and re-did the first part. Wanted to thank you again and give you an update: https://blindside.io/classroom/let-s-build-firehydrant-io Thanks again for the feedback! :)
Call it from the route and pass it into the view
I'm sure there's someone with a gem out there that handles named routes but from the looks of it, Roda doesn't ship with it.
It's a great book, and definitely still holds up. Congrats!
I was hoping you'd say that!! I knew it was destiny!!
Great book. 1.9 and 2.4 don't differ as much as their numbers indicate. Have fun!
I'm really glad to see a gem like this being developed so soon after this release. Super cool! Can't wait to see where this goes.
Hi @robertross, nicely done. I watched two of the videos and thought they were great. Both the sound and the structure felt clearer and more focused. Nice job! 
Yes absolutely you are right 100% - but the whole assignment is very contrived. you could probably abstract out the verses, but an object doesn't really come to mind. Could try something like this (again, untested I just hammered this out in MS Word so please forgive me if i bring in c#/Java syntax): class Verse attr_accessor: main_line, repeated_word def initialize(main_line, repeated_word) @main_line = main_line @repeated_word = repeated_word end def sing() puts “ #{main_line} #{5.times repeated_word} ” end end verse1 = Verse.new(“Coz the player’s gonna “, “play “) verse2 = Verse.new(“and the hater’s gonna “, “hate “) verse3 = Verse.new( “I just shake it off!”, “”) verse1.sing verse2.sing verse3.sing But this is slightly problematic in that verse three is not **really** like the other verses. It’s like we’re trying to force a bicycle to act like a vehicle. It doesn’t quite fit. 
Yep, the changes between 1.8 to 1.9 are way bigger than 1.9 to 2.x. Technically thats not true, but the big changes in 2.x are all under the hood. The new features which have been added since then can be picked up later, after youre familiar with the language.
just so you know, that documentation is the autogenerated YARD documentation, which is available for the whole stdlib and for all gems at http://rubydoc.info for example, the nokogiri docs are at http://www.rubydoc.info/gems/nokogiri I often just type a URL like this into my browser directly, rather than going to a gems individual website.
Ruby is a cool language but i would definently advise against solutions like puppet and chef. They are built on aged assumptions and views. The tool you want is Ansible. The dead simple provisioning tool that you could even teach to your grandmother in half an hour.
Roda has a [path](http://roda.jeremyevans.net/rdoc/classes/Roda/RodaPlugins/Path.html) plugin for generating paths/URLs: plugin :path path :home_about, "/home/about" The above will generate a `#home_about_path` method.
how is that different from hard-coding paths? def home_about_path "/home/about" end 
As a practitioner of all three solutions, I’m curious which views you see as being “aged.” 
Can you explain a little better? I have built stuff in Puppet and in Ansible and I agree that puppet kinda sucks most of the time but I'm curious what you think the reasons are for that.
I can only speak english, but I write ruby, and so I got all the important bits of this :) 
It's not much different. It's nice that you can have it automatically generate the `*_url` counterpart method. I also like the ability to define polymorphic routes. It definitely is something that you can implement yourself as well, but it's nice to have a wrapper, even if it's thin. Note that since Roda routes requests dynamically, it's not possible to have these `*_path`/`*_url` methods generated somehow automatically. So what the `path` plugin provides is probably the most that you can get.
No problem, happy to help out.
Do you explicitly call migration task? On Heroku it doesn't happen automatically. You basically have to define **release** in your Procfile Example: web: bundle exec puma -C config/puma.rb release: bundle exec rake db:migrate More info about release phase can be found on https://devcenter.heroku.com/articles/release-phase
I don't have the log file but I did see bundle exec ran even though I didn't include it in the Procfile. I'll add that line though. 
You're looking for *default_url_options*: http://guides.rubyonrails.org/action_controller_overview.html#default-url-options. I used to configure them in the production environment, which is where you probably want to put that.
I'm not in the best position to comment, having only begun working professionally in software very recently, but I would suggest the following: * Pick a specialization. Whether it's web development, mobile development, data science, gaming, or whatever else, having a sub-field of software engineering to focus on will guide the kinds of tools you learn and projects you work on, which will propel your learning faster than anything else. That will mean building a lot of domain-specific knowledge. Don't worry about "locking yourself into" a given track; if you want to make money doing this, you're going to have to make a choice first. Companies hire for the work they need done, not the languages you know. You'll be expected to learn a good deal on the job, but all else being equal, if a company has a choice between a generalist and a specialist in the kind of product they're building, guess which one they're going to pick. * Once you've chosen a specialization, figure out what constitutes a reasonable portfolio project. If it's web development, build a standard REST app in Rails. If it's mobile, make an app with RubyMotion. Use this project as an opportunity to get familiar with the subfields of your chosen specialization and the ins and outs of various best practices in software development, tooling, and workflows (e.g., TDD, git, object-oriented design, database design, CI/CD, etc. etc.). If you are doing this right, your project should wind up taking months longer than you will originally project. * Get as much experience interviewing as you possibly can. Try to arrange technical interviews that you'd have no chance of ever passing, starting right now, and keep doing it periodically until you're ready for a job. This may require that you lie about your qualifications. They may not reflect the work that you'll be doing once you actually start a job, but there's no better way to get a sense of the kinds of things you'll encounter when the time comes to actually look for work. You want to minimize the amount of time spent applying for jobs, while maximizing the time spent doing technical interviews. This may be difficult, but applying to agencies/recruiting startups like Toptal or Triplebyte should give you an easy start. Also, please follow up and tell us how it all goes.
A programmer does not just pick one language. A language is just a tool to express an idea how how something should work. A programmer should focus on how to program. Cleanly, and 'correctly'. Ruby is just one language; albeit my favorite, but still just one of many. I would add Python, C/CPP, maybe Java, PHP, JavaScript/Node, and shell scripting to the list. Also, you will be required to know operating systems and theory...this and many more are why a degree, why not required, will if anything get you a job interview. GO BACK TO SCHOOL! Get a degree in CS or Computer Engineering.
Are you setting X-Forwarded-For, X-Forwarded-Proto, etc. in the Nginx server definition? 
Hi, Kudos for willing to study on your own. IMHO, that's the #1 most important thing when it comes to programming. You are young and smart, with this right attitude and the willingness to put into the work, I think your future in programming is bright and limitless. :) &amp;nbsp; With that being said, I would like to answer your question to the best of my knowledge based on my personal experience. &gt; Are there any materials I should study after finishing it or is it pretty comprehensive? It's great that you are picking up a book and learning from it. Lots of people nowadays are too impatient to pick up a book. I haven't read LRTHW. But I was like you when I first started learning to program: I thought there was a path, a path with an end. I was constantly anxious about my progress in the path, how much have I finished and how much is left. The truth is, no matter what subject you pick (Ruby, Rails, JS, Web, ...) there are always endless things to learn and no single book, course, or certificate is comprehensive. Then I switched my mindset from "let me learn all that there is to learn about a subject, then I can start ..." to **"let me learn enough (the minimum) about this subject, so I can start working on this idea ASAP"**. &amp;nbsp; What makes programming different than all other subjects is that you can see an immediate result of your code, hence you can get immediate feedback. The best way to learn to program is by building side projects and getting your hand dirty. &amp;nbsp; So don't worry about if you have read/practice enough, learn the minimum and start working on a side project. Then come back and read and learn more, then work on the next side project or build on top of the previous one. **It's an iterative process, not a waterfall.** &amp;nbsp; &gt; Programming seems to be really community driven No doubt that being part of a community brings you many many advantages. And probably many others in this subreddit can tell you how to break into the programming community than I can. (I once read an article about the experience of a self-taught programmer accidentally joined the react open-source community and ended up becoming an influence in the community. Will try to find the link later.) &amp;nbsp; I just want to share my own experience to provide another point of view. I wasn't heavily involved in any community in my first five years of programming. I did benefit from many online communities like StackOverflow. I learned mainly through Googleing, StackOverflow, CodeSchool.com, and YouTube. I definitely encourage you to be part of a community (like this one :D ), especially since you are learning to program on your own. But don't feel that you are in many disadvantages because you are not in college. I didn't leverage programming communities in college. If anything, you are ahead of the game compared to where I was at your age. I didn't know about this subreddit until started working professionally. &amp;nbsp; My 2 cents about getting involved in a community: **ask for help and be helpful**. This subreddit and StackOverflow are good places to start. Having a personal technical blog certainly helps. &amp;nbsp; &gt; How much more of a foundation do I need before taking the next steps and what are the next steps beyond this? My answer to this one is similar to the first question. Start building your side projects. Things you wish exist and can use yourself. If the project you have in mind is too big, tear it down into its minimum form. Start building things on your own makes you start thinking like an engineer-you are actually working towards an end goal by solving problems one by one. You will start forming a big picture in your head. As you progress, you will discover more and more unknows, and you will know what are the next steps. Again, it's an iterative process. Learn -&gt; build -&gt; learn -&gt; build -&gt; Learn .... Learn as you build. Build as you learn. For example, I knew I need to learn React for my first job, and I had a problem of being addicting to TV shows. So I built a simple React app to keep track of the days I don't watch TV. https://notv365.herokuapp.com/ I self-taught by watching a series on YouTube, and brushed up the app in less than a week. Then I moved onto learning other stuff. &amp;nbsp; &gt; how long before I should consider applying for jobs? Three things you can do: 1. having a personal website showcase your projects, resume, experience. 2. an active Github account 3. fun side projects. Maybe start by trying to get an internship? My first internship was almost unpaid but I learned so much and had a lot more to show off afterward. It made my second internship much easier to find, which made landing the third one even easier. In terms of timeline, once you can build couple web app end-to-end by yourself, I think you are good enough to look for internships. Worst case is you realize you aren't good enough, but at least you will have an idea about how far you are from landing the first one. &amp;nbsp; &gt; Should I consider going through a certificate program? No. IMHO, solid side projects and an active GitHub account worth a thousand certificates. Free feel to inbox me or email me at sihui@sihui.io with ANY questions. Always happy to help a self-starter like you :) 
Aw thank you so much for this reply, super helpful and motivational :)
yes. will that fix my issue?
You are very welcome! I added the story I mentioned. &amp;nbsp; Start small, dream big, and don't settle. &amp;nbsp; There are many things to learn in this field: different languages, different frameworks, and different areas (web, ML/AI, Data Science, VR, ...). Starting with Ruby and Web development is great b/c you can see and use the result immediately. But I hope once you have enough fun and confidence with these, you will also explore other areas.
It should!
&gt; This may require that you lie about your qualifications. I can see why you suggest that (needing to pass the first hurdle to even get an invite), but I disagree. As someone who sits on the other side of the table there are few things - if any - that annoy me more than being lied at. It will show fairly quickly if the interview is properly set up and then the interview will be over as quickly and you do not gain valuable interview experience. If the interview does not make your lie surface, this is probably not the type of company you want to be working for and interview experience in such a place will be of limited value. And what do you do if they actually offer a job but then it shows after two weeks into the job that you do not have the skills you claimed you have? In many parts of the world you're out as quickly as you got in. The better approach would be open up front and e.g. apply for an internship. That way you get to see how things are in that company, how life in a company is in general and the company can see how you do on the job (and this is not only about subject matter expertise but also how you approach your job, your colleagues etc.).
One fairly obvious way "to break into the programming community" in Ruby would be to write a useful gem and put it out there. That requires a good idea of course (nobody needs the 3rd CSV parser - at least not if it isn't twice as fast as all others or has significant improved features or usability).
Exciting to see PG 10 released But I am gonna wait a bit before using it on prod (especially after understanding the partitioning concept)
If you decide you'd like a structured approach going forward I really have gotten a lot of of how [Launch School](http://launchschool.com) approaches the process of becoming a programmer. Ruby is a focus but the goal is to be comfortable by the end approaching any language or framework if needed. 
If you are interested in web development I recommend [The Odin Project](https://www.theodinproject.com/).
 rails generate model --help There you have the entire contents of this article, and more.
You’ve got nginx server/root or server/location/root pointing to your app, then start her up. You may want something to restart the app if it all goes bad (god, nodemon, whatever), and dependencies &amp; versions are up up to you too, but sure.
You’ve got nginx server/root or server/location/root pointing to your app, then start her up. You may want something to restart the app if it all goes bad (god, nodemon, whatever), and dependencies &amp; versions are up up to you too, but sure.
`Date.new` is technically not `Date.parse`...
**How can I deploy my app then? Just copy the files to a server and run it by "nohup rackup &amp;"?**
Sure, just don’t bet money on it.
I really like this post about inheritance and composition. Does not directly answer to your question but has some nice advice. http://mjk.space/how-to-avoid-inheritance-in-ruby/
If you're interested in sticking with Ruby, at least for now, I'd say the next step should be picking Rails or Sinatra and building a web application. Make sure the code lives on GitHub and you have it deployed to a server out there somewhere (Heroku comes to mind). 
That wouldn't work, you need to run a bundle install on the server to get all your gems. also maybe foreman is a better option than nohup Oh and finally docker is probably a better solution than all of the above.
Composition is actually a pattern, I don't clearly remember which one but I have used it before. 
Well done! Next step is to explore a bit, and find out which aspects of programming you really enjoy. Don't pick a direction before you've found out what will stick for you personally :) A nice way to get involved can me to start looking at making some contributions to open source projects. There are a few things out there that make it easy for people to contribute, and should point you to supportive projects. Check out: * [Hacktoberfest](https://hacktoberfest.digitalocean.com/#projects) * [Your First PR](https://yourfirstpr.github.io/) * [Up For Grabs](http://up-for-grabs.net/#/) And as for jobs - get going with applications now. You might find someone looking for what you can already do, or worst case you will learn what you need to work on in order to improve your chances. Just treat it as a learning experience, not make-or-break, and ask for feedback. Oh, and as someone said: there's no such thing as a career as a programmer in a particular language. Once you're happy with Ruby, pick up something else - you'll learn a whole load more about the overarching concepts and connect dots beyond a single syntax. Python might be a good next step to broaden things out a bit.
What gem or library would you otherwise be using to deploy your app? All deployments ultimately consist of copying the code to the right place and sending the relevant signal to the server process, either that or building a new container/VM image. Obviously you'll need to run any DB migrations, drain any queues etc. but theres no magic there, youre just running more scripts. Are you talking about stuff like capistrano or chef? All they ultimately do is automate the process of copying the files and signalling the server. If you feel like you want to just do that with a bash script instead, go right ahead, its probably a better solution for a small site.
Is this a joke?
Nope, it’s a serious article. Why do you think that if you don’t mind me asking?
Don't feel like you have to break into the "community" to have a good career in programming. The vast majority of programmers just treat it as a fulfilling job and dont ultimately give a shit about it beyond that. The people who are out there publishing high profile OSS tools and speaking at conferences are just very visible, for obvious reasons. The people who are just cashing the cheques and getting on with their lives arent attracting attention on the internet, by definition. If you really want to maximize your career advancement, engaging publicly with the community is a good way to do that. But dont feel like you have to do that if you find it difficult or offputting.
Without a bit more context this seems like awfully useless (probably even dangerous) advice. How large is your team? How big are your projects? How many people do you serve? etc. 
You’re basically advocating for eschewing much of the Rails community, which is one of the major advantages to choosing an open framework. Your two disadvantages are significant and are not outweighed by the advantages. How long have your practiced this methodology? How much time have you spent reinventing the wheel relative to implementing business logic? 
Riffing off of this, because I think you have the best answer so far: class Singer def repeat(word, times) Array.new(times, word).compact.join(', ') end def sing(phrase, repeat_word=nil, repeat_count=5) line = [phrase] line &lt;&lt; repeat(repeat_word, repeat_count) if repeat_word puts line.join(' ') end end To me, using `Array.new(elements, obj)` was the way to go for building the repeating words. I also like that this method can now be used on it's own, instead of assuming it needs the leading space. It also kills nils using `#compact`, because I was originally not using the `if repeat_word` and was going to leverage `String#strip`, but I liked that yours only calculated the extra values if necessary, so I backtracked.
everything is a "pattern", I guess. 
Found it, well guess what - It's https://github.com/nslocum/design-patterns-in-ruby/blob/master/composite/make_batter_task.rb - the composite design pattern :P
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [nslocum/design-patterns-in-ruby/.../**make_batter_task.rb** (master → f0a222b)](https://github.com/nslocum/design-patterns-in-ruby/blob/f0a222b2771183cf61c635da4e3d89046e01741d/composite/make_batter_task.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
We’ve practised this methodology for a couple of years. We’ve had the pain of scaling and maintaining large rails apps first hand, and often one of the best solutions to growing a rails app and keeping it performant is to cut down dependencies. This approach by no means stops you from adding gems, it just makes sure you think hard before adding one. I’ve used simple_form as an example, on it’s own it’s relatively painless, but if you add 50 more gems in this manner that only solve a tiny pain point, you end up with a bloated memory hog of a rails app. Vanilla Rails is about solving this and getting away from bloated apps. The Rails framework itself has more than enough built in to allow you to build almost all apps, carefully selecting the other gems you add on top of this, in my opinion leads to a much more performant application.
What’s do you think is dangerous about minimising your dependencies? I would love to hear your thoughts!
You can only minimize your dependencies if they're not needed or if you rewrite everything yourself. I can see not using gems for trivial stuff but anything that talks to a 3rd party _needs_ a gem. Anything not trivial that you have to maintain is better in a gem (think email validation, authentication and authorization etc. )
You’ll very likely spend much more money on lost or wasted time than you would for a few extra mb to run your app. 
Well that’s the point of this article, it may take a harsh stance against dependencies, but it doesn’t make good writing if you say 'try not to use dependencies that are trivial sometimes'. Nowhere am I advocating that you have to write everything yourself or that you use no gems. Be mindful and reinvent trivial things. For example, for API only apps I often find it better to use has_secure_password rather than pulling in a larger solution like devise. I very much am suggesting that a lot of the dependencies we add are not needed, or very trivial to implement yourself, the examples I used simple_form, acts_as_shopping_cart, koala (for a single request), devise (to a degree), are all fairly trivial to write yourself. "I personally try to have no more than 25-30 gems" - if you’re working on a large Rails application vs. a small one, sure that might mean you have 50-60 gems whilst carefully selecting the gems you add to your project. If you have a Rails application with 200 gems, you’re going to run into trouble, and it’s not just as easy as running it on a larger server, your development and tests will slow down too. I am sorry if the article doesn’t get this point across and I’ll consider adding an addendum to make it more clear!
Much cleaner - nice one.
I have updated the article to make it a clearer that I am advocating this approach for trivial or non-essential gems. I very much appreciate the productivity boosts that the rubygems community provides and it’s one of the reasons I love to write apps in Ruby. Personally I have wasted a lot more time debugging, speeding up slow apps and doing ops on apps that have 100 or more dependencies. Once an app gets to a certain memory usage it’s hard and cost-ineffective to run it on a PaaS like heroku. In my experience bolting on a few extra mb is easier said than done. I much prefer to keep an application a little tamer on the memory front and take advantage of heroku than to just pile more things onto the jenga tower.
There is absolutely nothing wrong with rolling your own authentication or email verification. It’s actually pretty easy, and you only do it once, and then it’s exactly what you need and you know how it works. If you’re going to use a 3rd party API but only one or two endpoints maybe it’s not worth pulling in a whole gem to use the API. Gems are great but you should be willing to maintain it yourself in case it stops being maintained. If you’re not then don’t rely on it. Look at the code behind gems you want to pull in and decide if you want to maintain that one day in case it doesn’t work properly or stops being maintained. Like everything else in life there’s a balance to be struck here. Don’t always use gems or never use gems. I think people should spend more time considering whether a gem is right for them and their project. Sometimes you spend a day making some gem work when you could have written the small part you actually needed in a few hours, and it would have the API you want too.
I feel so out of place reading these comments, not only I'd say you're in the right path, I'd also encourage you to go one step forward and stop using Rails all together for Ruby web apps. I don't use Rails (or Bundler), people freak out about the incredible amount of problems I should be having, yet my shit works and I never get bitten by unexpected dependency behaviour. ¯\_(ツ)_/¯
I'ma need you to elaborate on that. I use chef daily at work and would like to understand more.
It seems quite arbitrary to me. And therefore quite poor advice. There are no guidelines, no rules, and so on. Why Rspec?* Why serializers over jbuilder?** Why http and not one of the tens of other options? I'm not saying your choices are wrong (well, I think your choice for rspec is wrong, but that's another discussion, see below), but that you fail to offer good reasons why one should stay clear of device (I think device is one of the worst things you can do to your rails projects, right after grape and activeadmin) still, there may be moments when device is a good choice, and when you'd need to stay clear of that. Without very good and solid reasoning, I think such guidelines are not very valuable, and almost religous. So, heres our mantra: * Use rails. Vanilla. Unless you have solid, scientific reasons backed up with data. * Use hound vanilla formatting guildelines (or rubocop, or whatever, as long as it is vanilla). And only ever change that if you can prove why it is nessecary backed up with solid reasoning and good data. e.g. "I don't like the 80-lines max line-lenght, so I changed it to 120" is bad. Why 120 and not 134. Why change it? Why should we listen to things you personally "like" or "dislike" at all? * Use what rails has to offer. Only if it does not cut it, or if rails does not offer it out of the box, build it yourself. And only the moment that what you have built is becoming too big, move it into a gem, or swap it out for a gem. ^* I personally don't like rspec at all: its slow, impossible to debug, complex, and can often lead to very bad testing habits because of all the "Setup" it pretends to do for you. Add some factory girl and shoulda and I'd argue that you are missing all the good things bout TDD, and that you'll hardly benefit from it. E.g. all the mocking and stubbing: that is something you should think about and make very well founded decisions about. with rspec that's something you'll just start using all over the place, without having thought about it fundamentally, you are teaching yourself bad testing habits. Same for factory girl (if your unit-tests rely on complex setup, either the tests are bad or the unit-under-test is doing far too much: requiring a state in the database is a tell-tale: a severe code-smell. For integration-tests: if you cannot drive a basic state (register-sign-in-confirm-create-project-add-tickets) through your API or your interface, that is a clear sign of a problem in itself: your API or your UI is too slow, complex and so on. ** I don't have a strong opinion on one over the other. But you'll need damn good reasons to swap out jbuilder for something else on my projects or else it's going to be jbuilder. 
&gt; You’re basically advocating for eschewing much of the Rails community If you remember Ryan Bates' Railscasts, he suggested to sometimes re-implement simple authentication instead of using Devise, when the needs are simple. And Railscasts doesn't get more "Rails community" than that! Source: http://railscasts.com/episodes/250-authentication-from-scratch-revised Quote: "But sometimes if you just want password authentication, you may want to create it from scratch, because it's really not that difficult."
First off, good on you. Just be aware that you've started down a long road. Other responses to you have expressed this in more detail so I'll just say this, you should _never_ stop learning _something_. If you ever find yourself learning nothing new you're doing yourself a disservice. Keep a proactive and motivated attitude. As /u/sihui_io said (paraphrased), there is not end to the learning process, so don't let that be your goal or guide. Instead focus on learning what you need to know, obviously learn the basics of something (as you are with Ruby) and then learn how to solve the problem you have. I've seen quite a few recommendations to get a Github account and write side projects, and I think you should totally do that. The only different advice I'd give in that regard is that you should instead contribute to open source projects before necessarily writing your own. I'm not saying you _have_ to do this, but in my experience as a professional software engineer the best way to learn something new is to solve a problem with it. And the cheapest and easiest way to get a problem to solve is find a project online and check out it's issues. Pick one, fix it, commit it. At the very least you'll learn how to work inside someone else's codebase (invaluable experience), how to piece together an understanding from source/documentation (rare, but might exist) to identify a problem area (again, invaluable) and finally submitting a fix (adhering to community guidelines and improving an existing project, again, invaluable). By doing this one thing you will have done three things you'll find that you will continue to do for the rest of your career as a software engineer. Especially when you're working for someone else where the software may have already largely been written. A piece of advice I was disappointed to see lacking here is actually learning Computer Science concepts. I'm not a fan of school (and have made it as a senior engineer with just an Associates) but to some degree they teach things you really need to understand. Now, I'm not going to pretend like you can only learn these things from school, that's just the easiest, I find. But there are tons of online resources to teach these concepts. What I'm talking about are data structures, patterns and algorithms/complexity. A data structure is just a concept of how to organize data, and these concepts usually feature a variety of potential implementations. I don't know what Zed Shaw's book covers or how far you specifically are but Ruby's `Array` and `Hash` class represent implementations of the `List` and `Map` data structures. Ruby features more, these are just incredibly common and widely used. It's important to understand how these work and why you would pick one over the other. In order to do that, you would need to understand how they work (at both the concept level and specific implementation) and, of course, the other competitors. There are books on them, although I can't say how great they are. HackerRank, a site that provides code challenges (something you might find gives you problems to solve) also has a YouTube series teaching basics in many different data structures. Programming patterns are conceptual solutions to a common series of problems. Before I go any further I must express my opinion: &gt; Programming patterns are not _solutions_ they are _conceptual solutions_ to problems. Do not try and use them ver batim to problems and do try and be explicitly literal in their implementations -- they are guidelines. A set of "we've done this a number of times and this concept has proven sufficient in resolving this issue." Okay, now that that's out of the way, programming patterns cover a variety of topics that provide conceptual implementations to common problems encountered when writing software. There isn't always a "pattern" for you to use, and sometimes modifying the concept to fit the problem is actually necessary as no problem is really alike. There are numerous patterns for different types of problems like Singleton, Facade, Visitor, Pooling, etc... (to name just a few). You don't have to intimately familiar with _all_ of them, but having an understanding of what _types_ of patterns exist and how they might apply is a good place to start when assessing how to go about solving a problem. Aside from the patterns and data structures is complexity. While I never had to deliver a Big-O (jargon for complexity of an algorithm based on input size) value to an employer, understanding that array-backed list implementations provide O(1) (constant time, or not related to the size of the input) access to any given element and linked-list implementations provide O(n) (worst-case, where _n_ is the number of elements in the input, meaning it grows linearly in relation to input size) element access is important to making a decision on which implementation to choose (there are many other differences in complexity such as insertion/removal as well). So you should have a vague understanding of what Big-O is, how to calculate it somewhat accurately (even if just for your own personal usage) and how to compare algorithms together to make a decision on which one will be the more performant under your given constraints. My final piece of advice is don't get attached to Ruby. I don't mean that like you can't find a job as a Ruby engineer, I mean (for your own sake) don't dig yourself into the "ruby engineer" hole and make it difficult to escape. Programming professional is less focused on specific languages as it's focused on specific goals. For example, you can build websites (backend/frontend) in Ruby, JavaScript, Python, Java, D, C, C++, Haskell, Elixir, etc... (this list goes on for ages) -- so knowing "Ruby" is less important than understanding the fundamentals of building a website. And even though some or all of the above languages provide high-level frameworks (like Rails) that hide the nitty-gritty I **very highly recommend** that you learn how HTTP(S) requests work, at least at a basic level so you're not dependent on Rails's magic layers to do the work for you (i.e. getting a job using Sinatra instead of Rails, or the like). To coincide with my final thought, not only are languages not as significant, but I also recommend you familiarize yourself with Linux/macOS, working from the command line, ssh (working on a server remotely), cloud hosting providers (like AWS or Digital Ocean or Google Cloud), Apache/Nginx (very commonly used when deploying Rails applications for live consumption), and SQL/your-specific-database. That last one is important. Please don't just learn how to use a Database through Rails/ActiveRecord. Learn how to use a Database. Learn basic SQL and database design. To conclude all that, the **tl;dr** if you will, to be good at your job you'll need a healthy mix of all of the above. You **do not** need to master or understand everything in the above to get by as a junior engineer (depending on role expectations) so **please do not feel like you have learn everything I've listed to get started**. This is simply here to give you a rough checklist of things to learn as you go forward, and yes, it will take time to learn these things. So take that time, and learn them as you go, work on code challenges, work on open source, build a blog for you to catalog your learnings/thoughts (and learn how to run a server, so I mean to do this manually not using a blogging service), build personal applications, build your thoughts, build your dreams, build anything you think might be remotely interesting or fun to work on. The difference I've found between good and average engineers is that good engineers have seen more issues. What that means is the more you do, the more issues you see, the more issues you solve, the better you become overall. So it's important to do as much as you can. For example, I've been writing software for at least 18 years, I've been a professional (paid) engineer for 6. Before I got my first job I wrote a Java GUI Terminal emulator that supported ANSI color codes and had it's own color code and input coding system (which required a lot of very specific targeted learning), and then a Java MUD server, PHP websites for a friend and building small applications using SQLite to improve my quality of life at home. So build whatever you want, share everything you are comfortable sharing (on Github, **ALWAYS USE A LICENSE**, even if it's a command line script that prints a single message, commit it with MIT or something). Okay, I wish you the best of luck, you can reach out to me here on Reddit for **any and all issues you encounter or questions you have**. I'll either answer them immediately, tell you I can't and provide you the best resources I could find to get an answer, or help you interpret those resources. Here's some resources to catalog for now, or later: **Code challenges:** - hackerrank.com - codeeval.com - codewars.com - codingame.com - projecteuler.net - Participate in formal challenges like Google Code Jam, which will be extremely hard (so don't get discouraged if you don't solve any problems) when you first start, but worst case is you encounter some problems designed to get you think outside of the _brute force_ (obvious) implementations. You can also do all past problems any time. **Patterns, Data Structures and Algorithms:** - Wikipedia has great articles on these, although being more on the conceptual side usually. Articles on search implementations tend to contain a few languages of code samples. - https://www.youtube.com/watch?v=shs0KM3wKv8&amp;list=PLOuZYwbmgZWXvkghUyMLdI90IwxbNCiWK (videos about data structures and programming concepts) **Web Development:** - https://www.railstutorial.org/book I don't tend to read books, but there exist many good books. I'm not good resource to recommend any though :/ Again, best of luck, feel free to reach out to me, and never stop learning _something_.
I tend to be the one to levy a lot of criticism at RSpec, but I've got to step to their defense here. &gt; Use rails. Vanilla. Unless you have solid, scientific reasons backed up with data. Edit: that means minitest (and not rspec/cucumber etc), jbuilder, AR with a relational database (or no database if you don't need one) and so on. Automated tests are users of our code. The dependency direction goes one way. That means that to whatever extent that Rails makes minitest a path of least resistance, Rails is responsible. If a team can't freely choose their testing tool because their framework asserts a contrary "opinion," the team should fire their framework before their testing tool. Fortunately for rails developers who want to use RSpec, Rails isn't so in bed with Minitest that using RSpec is a challenge. &gt; Use what rails has to offer. Only if it does not cut it, or if rails does not offer it out of the box, build it yourself (using PORO's). And only the moment that what you have built is becoming too big, move it into a gem, or swap it out for a gem. One can decide they want to use Rails the _web_ framework without wanting to use Rails the _application_ framework. What Rails has to offer as an application framework is only ideally suited for a particular niche. In my experience, teams that rely their framework to disposition their code design and architectural decisions are not functioning at a high level. Don't get too "in bed" with a framework.
What's wrong with a team writing a gem? Nine times out of ten, when I evaluate an open source ruby gem, I end up writing one myself. It's not like writing a client library for some third party API service is all that complicated. Why not invest a few days building one? I always hear the same objection to this: "if you keep reinventing the wheel, you'll never 'get shit done.'" This is just not true, in my experience. You know who can't get things done? Those teams stuck on rails 2 with fat Gemfiles filled with libraries abandoned by authors who are now Elixir programmers.
&gt; rolling your own authentication…It’s actually pretty easy With the caveat that it’s also pretty easy to make a mistake or overlook something that results in your app being subject to a security vulnerability that the widely used, reviewed, and tested third-party library already took care of.
Not using Rails is one thing (and is totally fine), but not using Bundler makes it easy to end up in dependency hell.
jsonapi-rb is 5-6 times faster than active_model_serializers, if you're using the json:api adapter.
I've actually been trying to come up with a migration path to get out of rails. my app is pretty simple (api), but I'm unsure how to best get away from active record without re-writing a ton of stuff.
You could just use active record alongside sinatra or similar as phase 1 of that move. Do you know what you would use for DB persistence? Sequel?
been thinking about this: http://rom-rb.org/3.0/learn/introduction/why/ it wraps sequel :-)
I keep hearing this, I've never had this problem, and know other people with my same workflow who've never had issues either. As far as I'm concerned Bundler is an intrusive, 54k LOC dependency that I've never needed.
&gt; I have updated the article to make it a clearer that I am advocating this approach for trivial or non-essential gems. I'll take another peek. If you mean things like left-pad style then I'll agree with that. I think there's a fine line that's not easy to see. You have to be careful not to start re-inventing everything (and I've seen plenty of teams go down this route). Even then you'll have to maintain all the code you write long-term so you have to be even more careful not to eschew free work (open source). All-in-all it's just trade-offs and you have to determine what's write for your situation although I don't think I'd attempt to use "vanilla Rails" as a default (unless that's not your intention, in which case the blog title is misleading).
I dropped out of college because I 'knew more than my professors' and figured I'd just go make the next greatest thing and retire at 26 or whatever. Its been 12 years and I'm still looking for a programmer's job. Go to code camp and get an internship. 
 module User module CommonMethods def say_hi() raise "Pure Virtual" end end class German include CommonMethods def say_hi() "Grüß" end end class Italian include CommonMethods def say_hi() "Ciao" end end end 
What I did that really "taught" me Ruby was to find my own project and not stop until a version of it "shipped". This is essentially what coder bootcamps do. Once you have that you'll at least be able to bring it to employers and say "This is what I can do". For my first project, I made a web app. Agile Web Development with Rails is a great book. 
AMS' JSON API serializers are horribly slow, and no way of eager loading relations, resulting in n+1 queries that you can't control or prevent
yup
I've moved to using and building my own endpoints with JB and OJ. Takes some getting used to but it overall pretty fast.
Thank you so much, this comment is a wealth!! I’ll definitely work through those challenges and get a working understanding of those concepts. I’ll definitely be coming back to this comment for a long time! 
I’ll definitely check out this site, thank you 
Does it matter which I pick, Rails or Sinatra?
Yeah I the advice about not sticking to a specific language is super helpful, I really thought people just learned one or two languages and specialized in them. But I don’t know any programmers so it was just an assumption. I’ll definitely give those challenges a look, all of the suggested online challenges and problem solving stuff seems really useful. 
Can't you just eager load the relations before you pass the relation to the serializer?
I dropped out because I had a relative helping me pay for it and it quickly turned into him holding it over me. I understand the benefits of a formal education, but I tend to struggle in a classroom environment despite graduating with honors and having automatic admission to any college in my state. It’s not that I think I’m above college, it’s more so an understanding of my own strengths and weaknesses. 
i really like json:api :) 
Between "self-awareness in Ruby" and our little meditating reddit alien, it feels like we're getting close to developing "The Zen of Ruby." This is a good, simple way to break down and explain self – I like your extended detail version you linked to as well. Thanks for sharing.
Rails would probably be the more popular choice there, but either is fine. Rails is a heavier web framework with many more 'magic' elements to it, but Sinatra is lightweight and requires/allows more configuration. There are probably more tutorials for Rails, for what it's worth.
Ok cool, good to know 
Any suggestions on where to find jobs? Besides job sites like GlassDoor or ZipRecruiter I’m not sure where to find opportunities 
It's also pretty easy to avoid the generic wide surface area of large generified gems meant to fit a wide range of solutions by keeping a tight and narrow scope. Not disagreeing with you in any way, just adding that it's always a trade off.
I agree entirely. The intention behind that suggestion was admittedly a little machiavellian — not to gain interview experience, but to gather information about what kinds of questions you might be asked or challenges you might be posed in a technical interview, so that as you go through your practice, you can have some confidence about your ability to approach the next one (or specifically, the technical component). Of course if you actually want to land a job or build a working relationship, professionalism and integrity will get you much farther than deception will.
I’m curious then: how do you manage dependencies? Just vendor everything? FWIW, Bundler is 19.3k SLOC if you exclude tests.
We deploy Docker containers with our apps. You have to `bundle install` and make sure you've got files loaded where your server will look for them; that's within your Dockerfile. Then it's just a matter of getting your Docker image onto your host and running Docker, making sure that you're opening ports properly. I started off using an entirely manual process to do this, that took a good 20-30 minutes to do, using highly interactive commands. Based on that, I **strongly** recommend [Ansible](https://www.ansible.com/) or a similar tool to automate the process. It now takes me ~8 minutes to deploy a new build onto a new VPS instance (we have largely been ecstatic with [DigitalOcean](https://www.digitalocean.com/)). We don't use any Gems that differ from what we use to run the app locally (in a Docker container), but I'll say it again: automation is your very, *very* best friend. It *will* save you mountains of time, angst, and credibility. And the earlier in the project you start building deployment automation, the easier it will be for you to find and fix problems.
Or vice versa. It’s always a trade-off.
Right (and believe me, Devise drives me nuts as soon as you want something a tiny bit different). But there’s a middle-ground between using Devise and rolling-your-own that should be sought in that case (which, if you have Rails, is probably `has_secure_password`). Code directly related to security—cryptography in particular—is the last thing most people should try to roll their own.
&gt; without using a gem or library… [just run] "nohup rackup &amp;"? Well, `rackup` comes from Rack, which is a gem. So no, as that doesn’t meet your requirements. Suppose you could skip Rack and run WEBrick (since it’s bundled with Ruby) directly then just copy the files and `ruby server.rb` or whatnot…but why? As soon as you “manually” do anything on a server, you’ve already lost.
Thanks for your kind words! It's very encouraging to hear that :) You are right, Ruby does give me the Zen feeling lol 
I 110% agree regarding cryptography. I'm in no way skilled enough to build my own crypto methods. I meant "roll your own" in the sense only of building an implementation of something like 'has_secure_password' not truly building everything from scratch. One is trivial, the other is dangerous.
I said: without a special gem used for deploying such as capistrano
&gt; As soon as you “manually” do anything on a server, you’ve already lost. no
&gt; Based on that, I strongly recommend put your strong recommendation in your ass
No, your original post was unclear as to what “without using a gem or library” meant. Anyway: sure, copy the files, install dependencies, and run `nohup rackup &amp;`.
Enjoy your [snowflake server](https://martinfowler.com/bliki/SnowflakeServer.html).
Yes. Just copy the files across. The steps you've mentioned are correct. This is exactly what I do when I have to run my apps. Note: 1. It was running correctly on your machine 1. Please make sure that all the gems that **your app depends on** are installed 
thx
&gt; to gather information about what kinds of questions you might be asked or challenges you might be posed in a technical interview If the interviewer is worth his money deception will show fairly quickly and then there are no more questions to get to know. :-) Plus, you might want to land a job in this company later and chances of succeeding are worse if you have a bad history with the company. (Granted, in a large organization that might not be the case because information does not travel well always in these.) And even if the approach works as you intend, I still object against using deception. I know, plenty of people do it and a lot are successful with that approach, but I think this is the wrong path. And from a Buddhist perspective you will gain a lot of bad karma along the way. :-)
As far as I've tried, it still makes the queries.
Just include the parent module: module User def user_module_method 'user_module_method' end class German include User end end p User::German.new.user_module_method #=&gt; "user_module_method" 
Okay, only 19 LOC then. I personally dislike vendoring, I use [dep](https://github.com/cyx/dep) in Ruby, it has 277 LOC (including tests).
ELI5 programmer pairing? We work on code together? Simultaneously? I’d love to have someone to work with. Self-taught often means “I work only in total isolation.” It’s a lonely life!
This site uses Javascript to fuck with scrolling behavior. Someone didn't get the memo that this is universally hated.
Much better report than last time, with a CVE! Hooray! As with past rubygems vulnerabilities, it could be taken advantage of by a malicious _gem_, upon install. I don't personally consider it a drop-everything-to-update, but i could be wrong; ideally you'd update before running `bundle install` or any other gem installations again. 
Really belongs in /r/rails.
How is your site deployed? Your hosting provider may provide resources on setting encoding.
Just wanna point out that [cmdparse](https://cmdparse.gettalong.org/) (note: I'm the author of cmdparse) provides probably most if not all listed features and was first released in 2004... However, it certainly doesn't follow the design philosophy of Hanami, it's just plain old Ruby objects with no global state for cmdparse.
I hate JS scrolling too. But I don't see it in action on my site. :(
This is your site? Yeah, it's there. If I use the scrollwheel on my mouse, the site continues to scroll for a bit to "decelerate". It feels really weird...like the page is on ice or something. It's fine if I drag the scroll bar on the side of my browser, but scrollwheel is weird. 
Thanks for reporting, I'm using a theme over there.
Oh yeah. Hanami is a thing. I need to make time to play with it. I remember checking it out when it was launched at 1.0 and it seemed really interesting. tl;dr like rails but more modular, seemed less bloated and less opinionated.
I suppose you've moved on but I've been using AMS for years and I've never had a problem eager loading the associations.
I'm curious how you handle detecting registered 3rd party commands, so that the `help` subcommand can list _all_ available commands. I've [tried](https://github.com/ronin-ruby/ronin/blob/master/lib/ronin/ui/cli/cli.rb) to build a similar system, but ended up having issues with querying rubygems, having multiple versions of the same 3rd party gems installed, attempting to auto-load commands from other 3rd party gems, etc.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ronin-ruby/ronin/.../**cli.rb** (master → 10474c1)](https://github.com/ronin-ruby/ronin/blob/10474c197f2c130f1e09975716955322a848b20a/lib/ronin/ui/cli/cli.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply do6gzyp.)^.
`expiry`might be new but I'm using expires for ages *shrug*
I've been using gs alongside dep for about a year now. I love them, so simple and easy to understand. There isn't a feature in bundler I had used that both of these don't solve. 
Third-party commands assume for now that there is a solution to load the correct gem version (eg Bundler). `hanami-cli` works with a registry: https://github.com/hanami/hanami/blob/develop/lib/hanami/cli/commands.rb#L56-L57 For an Hanami project sequence is: 1. Require `hanami`, which registers its own commands 2. Require third-party gems from the `:plugins` group in `Gemfile` (see https://github.com/hanami/hanami/pull/832 and https://github.com/hanami/hanami/blob/develop/bin/hanami#L5) 3. These plugins may register their own commands (see https://github.com/jodosha/hanami-reloader/blob/master/lib/hanami/reloader/cli.rb#L38)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [hanami/hanami/.../**hanami#L5** (develop → 3cd1251)](https://github.com/hanami/hanami/blob/3cd125113b236bcfbb1961a1157eb2409f8ce383/bin/hanami#L5) * [hanami/hanami/.../**commands.rb#L56-L57** (develop → 3cd1251)](https://github.com/hanami/hanami/blob/3cd125113b236bcfbb1961a1157eb2409f8ce383/lib/hanami/cli/commands.rb#L56-L57) * [jodosha/hanami-reloader/.../**cli.rb#L38** (master → 91e6c39)](https://github.com/jodosha/hanami-reloader/blob/91e6c39ce472fc8792f48b3d426828065d421406/lib/hanami/reloader/cli.rb#L38) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I've had the issues with JSON API serialiazers, when nesting or using include blocks.. haven't really tried with other serialiazers, tbh
What version of ruby? You could try adding: # Encoding: utf-8 As the first line of every file. That indeed will be annoying. My guess is you are running a different version of ruby on your local machine and your production server, which you probably don't want to do, to avoid mismatches like this. 
2.4.2 
How do you combine ‘do’ with ‘else’? Based on truthiness of last expression in the ‘do’ block?
I assume it's the same as it is for begin/end, it is invoked if there is no error, ``` 2.3.3 :001 &gt; def f() yield; rescue; p 'an error'; else; p 'not an error'; ensure; p 'also, ensure'; end =&gt; :f 2.3.3 :002 &gt; f { fail } "an error" "also, ensure" =&gt; "an error" *2.3.3 :003 &gt; f { :ok } "not an error" "also, ensure" =&gt; "not an error" ```
How is it different than just adding statements to the bottom of the main code block (after ‘yield’ in your example), then?
It's the `else` that goes with `rescue`, not the one that goes with `if`. 
https://stackoverflow.com/questions/6279956/ruby-exceptions-why-else
&gt; it's just plain old Ruby objects with no global state for cmdparse. That kind of seems to be in it's _favor_, right? 
Interesting. Makes sense to rely on Bundler since hanami is likely going to be invoked from the context of a generated project. `:plugins` is a clever convention to avoid loading _everything_ just to run one command.
[Here](https://bugs.ruby-lang.org/issues/11547) is the issue thread re top-level constant lookup. Good fix IMO.
NICE. about time. :-)
how well does it handle upgrading gems?
339582 deletions jesus.. is that normal?
It hasn't been touched in three years. I wouldn't touch it with a ten foot pole.
https://www.youtube.com/watch?v=ET3Q6zNK3Io
Do you have an experience-based constructive comment to make? Thought not. Go back to /r/The_Donald, troll.
Thanks for speeding the word out! :D
Hahah, that’s your measuring sick? When was the last time your ‘ls’ command was updated? When stuff is well crafted and solves a simple problem you don’t need to keep updating all the time, it’s called mature software. Something we in the ruby community should really learn about.
Created [Pairrr](http://www.pairrr.com/) for this purpose.
Never had a problem.
`bundle install --deployment` to put all dependencies with code
&gt; It hasn't been touched in three years. This only became a problem after github, and everyone can check the commit log. Talk about project gamification. 
I don't know that I'd call it less opinionated; certainly less dogmatic about the universal applicability of its opinions than Rails. This, to me and my team, is a Very Good Thing.
I think having two string types was a bad idea but there's nothing that could be done about it because of the amount of code written with this assumption.
I can conveniently write fast code in Java or C# that don't have mutable strings.
 lines =["_______ _______ _ ______ _ ______ _______ _______", "( ____ \\( ____ \\( ( /|( __ \\ ( ( /||\\ /|( __ \\ ( ____ \\( ____ \\", "| ( \\/| ( \\/| \\ ( || ( \\ ) | \\ ( || ) ( || ( \\ )| ( \\/| ( \\/", "| (_____ | (__ | \\ | || | ) | | \\ | || | | || | ) || (__ | (_____", "(_____ )| __) | (\\ \\) || | | | | (\\ \\) || | | || | | || __) (_____ )", " ) || ( | | \\ || | ) | | | \\ || | | || | ) || ( ) |", "/\\____) || (____/\\| ) \\ || (__/ ) | ) \\ || (___) || (__/ )| (____/\\/\\____) |", "\\_______)(_______/|/ )_)(______/ |/ )_)(_______)(______/ (_______/\\_______)"] lines.each do |line| line.chars.each do |char| print char sleep 0.01 end print "\n" sleep 1 end
I did exactly this at first but didn't know about chars.each.do. thanks!
[removed]
I had heard before of non-bundler deps management, but only now I saw dep mentioned the first time. I've had a quick look, and it definitely looks quite interesting and minimal. I might find one thing or two I've grown accustomed to with bundler, but oh well. I just don't like that it assumes that I'm handling gemsets with yet another tool. How do you have your env set up? I'm using chruby/ruby-install, so no rvm gemsets for me. Preferable an also minimal solution (is gs lightweight?).
"Manually without a gem" 🙄 https://www.reddit.com/r/ruby/comments/757d12/how_to_deploy_a_rackroda_app_manually_without_a/
I wish every one of these announcements that "contains performance improvements" would clarify whether we're talking significant, or practical improvements.
Better yet, there's no reason to put it in an array. Since `\n` is a char all the same, you can just print it all. I think It will make it easier to read and change if you use something like heredoc. msg =&lt;&lt;-MSG _______ _______ _ ______ _ ______ _______ _______ ( ____ \\( ____ \\( ( /|( __ \\ ( ( /||\\ /|( __ \\ ( ____ \\( ____ \\ | ( \\/| ( \\/| \\ ( || ( \\ ) | \\ ( || ) ( || ( \\ )| ( \\/| ( \\/ | (_____ | (__ | \\ | || | ) | | \\ | || | | || | ) || (__ | (_____ (_____ )| __) | (\\ \\) || | | | | (\\ \\) || | | || | | || __) (_____ ) ) || ( | | \\ || | ) | | | \\ || | | || | ) || ( ) | /\\____) || (____/\\| ) \\ || (__/ ) | ) \\ || (___) || (__/ )| (____/\\/\\____) | \\_______)(_______/|/ )_)(______/ |/ )_)(_______)(______/ (_______/\\_______) MSG msg.chars.each do |char| print char sleep 0.01 end You could put the printer in a method and just pass in heredoc strings too, for printing whatever messages you wish.
Just a tiny nitpick barely worth mentioning, but there is an `each_char` method on string.
I think they often probably don't really know for sure, because it's gonna depend on what actual software _does_, how many times it calls the thing that has been sped up, etc. There are ways to try to make realistic benchmarks, but it's lots of work and still not perfect. You'll probably have to wait until it's been released and someone actually runs some real software against it and compares/benchmarks. This blog has been posting some interesting stuff on that topic recently. http://engineering.appfolio.com/appfolio-engineering/2017/4/14/comparing-ruby-speed-differences http://engineering.appfolio.com/appfolio-engineering/2017/8/21/rails-and-discourse-startup-times http://engineering.appfolio.com/appfolio-engineering/2017/9/22/optcarrot-an-excellent-cpu-benchmark-for-ruby-3x3 Perhaps they could be convinced to run their benchmarks against the ruby 2.5 preview, interpret the results, and report back. Alternately, they probably give enough info there for _you_ to do that yourself, but yeah, it's a lot of work. :)
Not really, you often need to revert to tools like StringBuilder to work around that lack. Also "fast" is very relative
Of course, but it doesn't happen that often. On the other hand, I've got multiple bugs because of `String`/`Symbol` mismatch.
I don't see that trouble that y'all seem to have with this confusion, if you use String and Symbol in the right way it really never interferes. Consider Java's and .net's alternatives: public numeric constants, whose value no one cares about, way more maintenance and room for bugs there, and none of the performance benefits. If you're dealing with ruby that can need them interchangeably, the rarest of cases, just `to_s` or use an IndifferentAccess structure.
- Crud testing is missing cases when you need to handle unsuccessful create, update and show. - Update test doesn't actually test if record was actually updated - "should should should should" is noise. Better format is "method_name (when some condition)" for unit tests. For integration tests you can name those whatever makes sense though. - For testing validations you don't trigger `save`. Just build a record and then call `valid?` or `invalid?` on it. Assert for expected attributes that have errors. - Integration tests should not retest same things that controller tests covered. Integration tests are mostly for scenarios where you need to hit multiple endpoints in a single session. Think registration flow, for example. Some apps might not have any integration tests and that's fine. - Fixtures need to contain absolute minimum of data that 95% of your tests require. Did you even use `users(:two)`? Neah. So why it's there? - Fixtures can be invalid because they are crammed into database as-is. Not a bad idea to have a test that checks fixture validity (as a model test). - In Rails 5 they decided not to allow testing of instance variables that get used in the views. I think that's dumb as it's a good idea to test what data flows into the view. There's a gem that re-enables `assigns` test helper. It's a pretty good started tutorial though. Glad it doesn't go "Welcome to Rails, here's RSpec". 
I added the lag, and used multiline string instead of heredoc, came out weird with heredoc: msg = """ _______ _______ _ ______ _ ______ _______ _______ ( ____ \\( ____ \\( ( /|( __ \\ ( ( /||\\ /|( __ \\ ( ____ \\( ____ \\ | ( \\/| ( \\/| \\ ( || ( \\ ) | \\ ( || ) ( || ( \\ )| ( \\/| ( \\/ | (_____ | (__ | \\ | || | ) | | \\ | || | | || | ) || (__ | (_____ (_____ )| __) | (\\ \\) || | | | | (\\ \\) || | | || | | || __) (_____ ) ) || ( | | \\ || | ) | | | \\ || | | || | ) || ( ) | /\\____) || (____/\\| ) \\ || (__/ ) | ) \\ || (___) || (__/ )| (____/\\/\\____) | \\_______)(_______/|/ )_)(______/ |/ )_)(_______)(______/ (_______/\\_______) """ msg.each_line.with_index do |line, line_num| chars = line.chars (chars.size - 1).times do |index| print chars[index + 1]; sleep 0.01 sleep 1 if chars[index + 1] == "\n" &amp;&amp; ( (line_num == 3) || (line_num == msg.lines.size - 1) ) end end
Yes, that's what I wanted to say. I agree, global state is sometimes necessary. However, there are libraries that use global state without any regards, e.g. in the form of some configuration objects like `MyLibrary.config` where other solutions would be possible. In recent years I always try to get rid of such things where possible. cmdparse could use "plugins" but this functionality is not built in; cmdparse is just bare bones command and sub command functionality stacked on top of the optparse library. There is at least one application I know of that augments its available cmdparse commands using "plugins". Although this application doesn't use global state to achieve this functionality. 
Nice. Updated. 
I'd put the string in a file and iterate over split by \\n. No declaration, no counter variable increment. Don't hardcode the line length, do dot count for each line. Pretty much what I'd do. 
The characters didn't seem to line up correctly. was kind of hard to read when I ran it. This is my attempt to clean it up: msg =&lt;&lt;-MSG _______ _______ _ ______ _ ______ _______ _______ ( ____ \\( ____ \\( ( /|( __ \\ ( ( /||\\ /|( __ \\ ( ____ \\( ____ \\ | ( \\/| ( \\/| \\ ( || ( \\ ) | \\ ( || ) ( || ( \\ )| ( \\/| ( \\/ | (_____ | (__ | \\ | || | ) | | \\ | || | | || | ) || (__ | (_____ (_____ )| __) | (\\ \\) || | | | | (\\ \\)|| | | || | | || __) (_____ ) ) || ( | | \\ || | ) | | | \\ || | | || | ) || ( ) | /\\____) || (____/\\| ) \\ || (__/ ) | ) \\ || (___) || (__/ )| (____/\\/\\____) | \\_______)(_______/|/ )_)(______/ |/ )_)(_______)(______/ (_______/\\_______) MSG msg.each_char do |char| print char sleep 0.01 sleep 1 if char == '\n' end 
Agree in sense that Rails community is overdoing it with gems. Literally every new Rails recruit joining the team wants to instal 5 gems just because they were using them in previous project. Or they just need 10% of the gem functionality. Sometimes is better to just write the solution yourself sometimes it's good to rely on well tested gems. 
Triple quotes aren't a thing in Ruby. """foobar""" is just two empty strings around "foobar" (i.e. `"" "foobar" ""`), which works because you can write multiple string literals next to each other to concatenate them. In other words, your code will work exactly the same if you only use one `"` at the beginning and end of the string.
Great, I might go bold and use 5 or 7 quotes while I'm at it 
Eh? The project is obviously abandoned. It's good that we can know about this right? 
&gt;Hahah, that’s your measuring sick? When was the last time your ‘ls’ command was updated? I trust the people who wrote ls more than I trust somebody I don't know who wrote a gem. Ruby has been vastly upgraded in the last three years and you'd think they would at least test to make sure it works well with 2.4 and maybe even take advantage of some the improvements. 
You mean like zentest/autotest or guard-rspec? 
Why clutter up your code with all those printable characters when we can use zlib! require 'zlib' msg = Zlib.inflate("x\x9Cm\x92\xBB\x11\xC40\bDs\xAA\xD8P\x8Ah\x88\x197B\xF1\x16\x9FCX:G\xEB\a\xBBB\xD8x\xE2\x01J,\x89|6\xDA\fW\xF1\x8C\xA0\x11\x12\xD2\xC40\v\xAB\x13@\xD6K1\x15\x1C\xC5;\x804\xBA\x85\x9B\xB0\x98\x01u\xB2\xE4DC\x13\xDF\xDA\xED\xB7\xC8\x18\xDC\x85A\x857\xAB\xF9L{b\xD2\x82\xBD\xDA\x9C#\xEF\x9E\xBBX\a\xAE\xD1g\x94\x042\x9B\xFD/l\"\x8D\x15E\xB1\xF0\x99\xD7A\xA6\xD8\xDA\xFA\xA0\a;\xE6\xEC\x9Fn\x11b\xB1\xF4\xDF\x1D\x9E\x87\xC5\x97&amp;H\xC2\xD6\x86/\xABv\x8E\x8D\x86\xAF\x92H\xF2\x0F\x98#\x05+\xE7\x89\xC5\f\x04\xDD\xAC\x15\xCBYY\xF4\x02\xFF\xB1\xA5\xED")
My experience in sublime is that you have to add packages, but you can get great code completion and code snippets tools. Same with syntax highlighting. I have coworkers that have their vim or emacs editors tricked out, but I'm too lazy. I remember Visual studio being really nice out of the box.
VS Code has some great built in code completion, especially for C++.
In case you just want a smaller tick function: ```ruby def tick(var); 85.times { |i| print var[i]; sleep 0.01 }; end ```
I thought you could get rid of those backslash-escapes with %q{} and you basically can but it behaves weird ô.O [21] pry(main)&gt; %q{as\n} =&gt; "as\\n" [23] pry(main)&gt; %q{as\\n} =&gt; "as\\n" [22] pry(main)&gt; %Q{as\n} =&gt; "as\n" [24] pry(main)&gt; %Q{as\\n} =&gt; "as\\n"
Guard is pretty common for this purpose. However, relying too much on naive code coverage can make some pretty bad habits, make sure to reason about your tests.
I'm guessing, as OP is mentioning RubyMine and posting in /r/ruby, they're not looking for C++ Completion.
Correct, I didn't realize what sub I was in.
I know you said no, but Emacs with [robe](https://github.com/dgutov/robe) is pretty good. You can use [Spacemacs](http://spacemacs.org) if you dislike configuration, as it has good defaults out of the box. Also, Spacemacs [supports robe out of the box](http://spacemacs.org/layers/+lang/ruby/README.html) This is a little bit of a tangent now that I'm talking about Emacs, but I think it's worth mentioning that [Matz himself is a big fan of Emacs and it actually influenced the creation of Ruby in a very big way.](http://ergoemacs.org/emacs/Matz_Ruby_how_emacs_changed_my_life.html)
I'm curious which Atom plugin you were using and what complaints you had. You could always fork and customize your favourite package.
Also, folks might want to remember that Bundler is part of the MRI standard library with effect from version 2.5.0. It makes perfect sense (to me, anyway) to maximally leverage the tools you've been handed. 🙂
&gt; The project is obviously abandoned. Your assumption based on what exactly? Nothing in the readme says it is abandoned. Link works. 2/3 people in this thread reported they are using it. 
Never understood how is this better, Ruby's way always looked "natural" for me (you start reading from the problem, and deeper and deeper by stack). Just because it is another way in Python or what?..
yeah, to be honest I'm used to the old way too. However, after playing a bit with Ruby2.5 this new way turns out to be quite convenient. Sorry, but I can't give any scientific proof why it's better. It just feels better to me but obviously your mileage may vary
I am not looking for scientific proof, but if you can show your train of thought when new way becames more convenient, I'll be grateful :)
I got better performance out of RubyMine after I tuned the java settings https://intellij-support.jetbrains.com/hc/en-us/articles/206544869-Configuring-JVM-options-and-platform-properties
fair enough! Imagine a long stacktrace. Say 120 lines. A bit Java-ish yes. Now you want to find out what exception has been raised and in which line. Warm up your fingers and scroll up the terminal window. Or wait... there's a better way. Install Ruby2.5 and see the error at the last line. No scrolling, hurray! hope this convinces you a bit :)
Hm OK, makes sense :)
For best autocompletion, go for RubyMine For lightweight editor, vscode or sublime For ultra speed, vim or emac You need to make the tradeoff and that's why people tend to use lightweight editor at the end. You may use IDE with good autocompletion but after some time you will not need it and switch to lightweight editors. And be careful don't use unknown editors because it will waste your time.
The flip side is of course that in log files you may be reading from top to bottom, but it seems this change only affects TTY output, so that's not a problem. What could be a problem is that the order is different on those occasions, which could lead to reflexively scrolling down/up only to find yourself at the wrong end of the trace.
No, automatically running changed tests is the least interesting thing Wallaby does - the videos on the site explain it better than I can.
It’s a long trip from California but I may have to come :)
to be honest, this isn't that exciting. What ruby really needs is a way to get the current stacktraces of all running threads of a running Ruby process through the MRI. It would go a long way towards identifying bottlenecks in multi-threaded code.
I don't know if I understood you correctly but you can get traces from threads, e.g. I used this (triggered by USR1 signal, creates txt file, opens in editor) to debug a somewhat complicated threaded application that liked to get stuck everywhere... https://gist.github.com/2called-chaos/2bf2f96a2b9c9f82cd7c54a83c3a2eb9 Only downside is that (if you use signals) your main thread will always have it's stack in dumping the file.
you're right of course. The problem is that this output does not show which thread is currently running, as - like you said - using signals forces the main thread to get scheduled. I should have been more clear. My bad.
That is true. One way I tried to counter it a bit (since I dealt with stuck thread logic) was to use fiber/thread variables to keep track of iteration count, last iteration time and if I really had to dig deep added `Thread.current[:whereami] = "here"` after every line in the code :D But I agree, some more introspection on that kind of thing would help a lot with threaded applications.
gs is very lightweight, but I don't even use that: ruby gems are installed in the directory specified in the `GEM_HOME` directory. I usually configure my projects through env variables, so I keep a gitignored `.env` file that can look like this: ``` export GEM_HOME="$PWD"/.dependencies export PORT=8000 # Whatever, just as an example. ``` Whenever I'm working in a project, I run `source .env` and it automatically loads my project config, including where to install gems to. Basically free, isolated gemsets without external tools. In fact, I keep a tmux session config for each project, so when I start working on it it automatically sources the env file for me. It's nothing special to achieve, but I like the workflow, maybe I should blog about it.
Hmm, I've created applications with underscores in the name before and had generators load from engine gems, I'm pretty sure. I guess I haven't necessarily done it/tested it in Rails 5.1.4. But I suspect something else is going on (whether bug in Rails or bug in the particular gem or in the application) triggering the missing expected generator, unrelated to the underscores. 
For Excel and PDF, you could use [DocRaptor](https://docraptor.com)^1, if you have a budget. If not there are solutions like [wickedpdf](https://github.com/mileszs/wicked_pdf) and the [spreadsheet gem](https://github.com/zdavatz/spreadsheet). For CSV, the [built-in CSV lib](http://ruby-doc.org/stdlib-2.4.0/libdoc/csv/rdoc/CSV.html) is totally good. For HTML there are a number of renderers and rendering pipelins available, but the [built-in ERB](https://ruby-doc.org/stdlib-2.4.2/libdoc/erb/rdoc/ERB.html) is probably a good place to start. ---- ^1. ^I ^am ^biased ^because ^I ^am ^one ^of ^the ^owners ^of ^DocRaptor.
Thanks, the main issue I have is that the project (a Rails site) started with HTML and PDF as requirements (most reports are printed for meetings), so I dutifully went ahead and made two templates for every report. Now of course the client needs to manipulate the data, and while I'm well-versed in the "Roo" gem, I'm not anxious to add a whole new template/builder for every report they need to edit in Excel.
I'll check out the name when I got home. It said it used rsense I think. It just wasn't functioning at all. I installed the appropriate gems and all. I think it might have said something about their being windows issues.
Yeah it is possible that some of the admin gems out there will do the thing you want but I usually just use DR. I have run into roo in a previous life and can understand how you got where you are. 😑
If RVM doesn't work for you, try rbenv. Here's a guide to set it up https://gorails.com/setup/ubuntu/16.04
I'm gonna try this and report back. Thanks for the help.
I'd also recommend rbenv: https://github.com/rbenv/rbenv/wiki/Why-rbenv%3F
Single Page application is awesome paradigm but because they communicate with APIs there is lot of confusion around what security measures are needed and what are unnecessary. In this article I'll try to explain when is CSRF protection needed.
I've always wanted to make a generic "report" class that can represent the data any way I want and defines multiple documents, but the code for compiling most reports ended up being very complicated. On top of that, the code for formatting most data is vastly different depending on whether it is for HTML or PDF. So my reports are just dumb Ruby object containers that perform no processing. All the smarts is in the templates and their hardcoded formatting magic. Sometimes trying to find a generic solution is a fool's errand, but it really feels like there ought to be one here.
I followed the link that CodeandAudio provided and got it done. Thank you!
All done. Thank you so much.
Came here for the dank performance memes/discussion. 
- The link you are using as a guide isn't normative. Go to the official Rails website if you *need* or *want* normative. - This is on Ubuntu. Not the most developer-friendly distro. Use what you feel like if you are already comfortable enough. If it's Ubuntu, fine. - Understand what is GPG for. Make your own risk call. - Just use `rbenv`, not `rvm`. [Better design](https://github.com/rbenv/rbenv/wiki/Why-rbenv%3F), and it's been the better option for a while.
your text has superscript numerals that look like footnote/endnote markers... but I couldn't find any footnote text. 
Thanks for the advice. I must not be ready to learn rails if I don't know this stuff.
Aah well.. `alias ruby="rc -c 'ruby $* |[2] cat'"`
Not really. tl;dr, GPG is not necessary for most developers, unless you think the Rails code you'll download itself is trojaned and will p3wn your dev machine. `rbenv` is not necessary if whatever Linux distro you use didn't screw up packaging/installing Ruby, and you're on a decently recent version of Ruby. The long answer? If you really want to develop, you have lots to learn, about the whole ecosystem, to learn to put things in context. Exercise for the reader, especially my previous comment.
you definitely should. I can think of a couple of features bundler has that are important for certain workflows, like multiple lookup options (like omnirepo-style "test against local copy of dependency" like rails or (now) sinatra have). But I think that your simple setup works quite well for most vanilla stuff. 