Java bytecode is compiled by JIT into native code in runtime. One of the reasons for that is that bytecode is cross-platform.
Because you have a Windows laptop, not everyone can afford the latest shiny Macbook Pro.
Not, not again with this please. Expecially now that all major runtimes are being open sourced, how can people still come up with this?
Ah, makes sense. Thanks. 
[You're forgetting someone.] (https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/2000px-Tux.svg.png)
Most rails servers run ubuntu, which is free, and will run on anything (and much more) that windows can run on. My work bought me the latest shiny Macbook Pro, and I gave it back to them because I prefer Linux. Linux is an amazing platform to write ruby/rails on. I would use NetBSD or something like that before I'd use windows to write ruby.
i looked at crystal a couple of months ago entirely because i'm writing an end-user ruby app, and most of the options to let non-technical windows users use it are dire. crystal sounded like it would let me compile my app and just have a downloadable exe, but given the lack of windows support it was sadly a non-starter.
You know you can install Linux on a Mac, right? 
Yeah, except MacRuby is effectively dead. It was a really awesome project, and it worked beautifully, but it hasn't been updated in years. And RubyMotion is proprietary and closed-source, and doesn't support most gems. Really wish MacRuby would come back. It's still somewhat usable, but my guess is that won't be true for too much longer.
Any PC laptop of the same calibre of build quality costs the same price... Yeah, you can buy some piece of shit Toshiba for $299, but then you'd be using a piece of shit. Carbon X1? Dell 13" Developer edition? They all cost the same as a comparable Macbook.
I had the same irrational aversion but JRuby cured me of that. I'd say you owe it to yourself to at least find out if it suits your use case.
Neat trick, but isn't wanting to do this a sign that a hash is the wrong type of object to be using? Maybe the situation you're using it in makes sense, (it would be nice to see a more realistic usage example.) but I would suggest it is better to be calling a sensibly named method on an appropriate object. Given this: person = { first_name: "John", last_name: "Smith", age: 35, # ... } Instead of this: class Hash module Using def using(&amp;block) values = block.parameters.map do |(type, name)| self[name] end block.call(*values) end end include Using end person.using do |first_name, last_name| puts "Hello, #{first_name} #{last_name}." end I'd do this: require 'ostruct' class Friend &lt; OpenStruct def greet puts "Hi #{first_name}." end end Friend.new(person).greet 
The difference is not negligible it's as you say. Crystal is 5x faster in this case (on a 2013 late macbook pro) ./fib2 0.00s user 0.00s system 85% cpu 0.005 total 
MacRuby and RubyMotion are made by the same guy that worked for Apple. From what I know they had troubles monetizing the RubyMotion when it was free/trialware so it's unlikely it will come back
&gt;Why would I not want to write Ruby on Windows? Because it's not well supported. Too bad ironruby died an ignoble death. &gt;Yours, and this typical O.S. language segregation view, is a bit of a delusional mindset IMHO. Aren't you guilty of the same thing by insisting that you only code in windows? Why don't you just code in Linux or Mac where ruby is very well supported.
many shops insist that all production machines be Windows because that's what most devs are producing on already. it's hard for a dev to get a client facing UNIX server in such places. 
A *general* solution would be to set a flag and `break` out of the inner loop, then check for the flag in the outer loop, and `break` if true. In this *particular* case, you don't need anything other than `return true` where you currently have `throw`, which will have the same exact effect :)
&gt; In this particular case, you don't need anything other than return true where you currently have throw, which will have the same exact effect :) How so? At that point, I would not want to return true but go to the next iteration of the `k.times` loop. **EDIT:** But the flag point is valid, of course and that's what I was forgetting late last night when I wrote this. Obviously I must have done something like this before too. The labelless implementation thus becomes: def rm_prime?(n, k) r=0; d=0 (1..128).each do |i| d = n / (2**i) r = i break unless (d % 2) == 0 end k.times do flg = false a = rand(2..(n-2)) x = modular_pow(a, d, n) if (x == 1) || (x == (n - 1)) next end (r-1).times do x = modular_pow(x, 2, n) return false if x == 1 if x == (n - 1) flg = true break end end next if flg return false end true end
&gt; Aren't you guilty of the same thing by insisting that you only code in windows? That assumes he has a choice over the OS.
I'm for it. . . my goto languages are Python and Ruby, I would LOVE a fast language with the syntax of either (or honestly, a hybrid Ruthon syntax would be my dream). I feel like it's time to move on from C and C++ and I'm just sick of Java, C# and JavaScript. tl;dr Python and Ruby ruined me because they're so pleasant to use, we just need something as (or almost as) pleasant that is also fast.
Yup. As I said in the post, the example is pretty contrived. I can't share my actual use case until my client says "ok", so I made one up that shares some similarities to the actually-useful one. :) I'm definitely not saying Hash#using is a valuable monkeypatch.!
&gt; It is unfair to make benchmarks that involve arithmetics ... That's ridiculous. You think it's unfair to benchmark fundamentally important things like basic arithmetic because it's "well known" that Ruby is slow at *math*? What exactly *should* we benchmark, instead of these fundamentally important parts of programming?
Come on Mike, `while !@done`? :p
I tried this with a much larger number, and crystal 0.9.1 is actually *slower* than ruby. Maybe crystal's BigInt is just really inefficient. require "big_int" def fibonacci2(n) : BigInt a, b = 0.to_big_i, 1.to_big_i n.times { a, b = b, a + b } a end puts fibonacci2 500_000 ./fib2 8.04s user 16.64s system 175% cpu 14.057 total Compared to ruby 2.2.2p95: ruby fib2.rb 3.10s user 1.03s system 94% cpu 4.379 total
Because he's 6ft tall and plays guitar yo. 
I guess, after, in 5.1 we gonna have some refactor and maybe some clean-up. Rails is like top 100 gems from rubygems :|
I prefer to test long running processes by implementing a `#to_enum` method that emits an `Enumerator::Lazy` instance. Then, I separate the threading code from the process. The threading code just takes in an `Enumerator` and calls `#each` on it (and likely `#call` on each instance iterated over). The threading code then be tested with _any_ enumerator. In fact, it can even be tested with a non-lazy enumerator, which means that your test doesn't have to shut down the thread, because it will end naturally. The process manager itself can be tested directly outside the context of threading. This is all leading up to a critique: I don't particularly care for the `private unless $TESTING` bit. Testing should always use a public API. The code being tested shouldn't change when under test, because it's actually not under test anymore. In this case, separating the concerns of thread partitioning from the long running process using `Enumerator::Lazy` would achieve that separation.
Do you have an example of this approach?
Numbers in Crystal are objects with their own methods, methods inherited from Object and methods that you define for them.
A fair example with wide set of topics covered can be found [here](http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=yarv&amp;lang2=go).
Ugh, yes. With all the other things they've pushed into separate dependencies, why not make ActionCable fully supported and included in rails automated tests... but not included in the gemspec for the `rails` gem itself, so you can just pull it in if you are actually going to use it? I'm also surprised it uses _both_ Celluloid _and_ EventMachine. 
I built a Rails 4 docker container last week and was shocked at the size it managed to reach for a an application with basically no assets. 
Yeah, I don't really get it. You either go with Celluloid and threads (it's not that bad if all you do is wait on I/O) or EventMachine and `select`. 
I think he wants you to use `until @done` Maybe even `process_one until @done` which is legal.
I've taken a look at it but haven't used it yet. . . it looks cool. There's probably enough room for both Elixir and Crystal to thrive. Anything but Javascript, Perl or C++!
Tell me about it. . . there's WAY too much Javascript out there. . . it's such a crappy language.
so changing `range` will modify `combine` without running the code again?
Good job Nick!
Recursion is useful when you want to perform a task that is split into many subtasks, but that are all the _same_ subtask. Think of it like being a general in the army who wants to know how many soldiers are on the field. Your task is simple: How many soldiers report to you? Well, you ask all of your colonels that same question. How many soldiers report to you? They, in turn, have the exact same question of their majors: How many soldiers report to you? For anyone in the chain of command, they ask the question of their direct reports, sum up all of the answers, and then report the total back up the line. Before long, the general knows how many soldiers are on the field. This is similar to how you might count how many files are on a disk. You first ask each folder in the root how many files it has. But each folder has to ask _its_ folders, and so on. Recursion is all about phrasing your problem such that if you ask it of a smaller set, you get closer to the answer for the whole set.
PE#31 asks you to solve this generic problem: given a set of positive integers S, how many distinct ways can S be combined to the sum N? Let's say the set of integers was `[1, 5, 10]` and our target sum was `15`. How do we use recursion to reduce our problem to a sub-problem? If we assume we start with the `1` piece, we now have a new problem: given the set of integers `[1, 5, 10]`, how do make a sum of `14`? From here we extrapolate that every coin in the set S that has a value less than N gives us a new sub-problem: how many ways can we use S[1..length(s)] to make the sum (N - S[x])?
Thanks for your work. Book was very helpful.
That looks scary! :-D Seriously though, it also looks like it could be a class in disguise.
My opinion is: it's one of those things you just need to wrap your head around, no amount of explaining here will help. Concerning your concrete problem, there's a very accessible section at the beginning of "Structure and Interpretation of Computer Programs" discussing your exact problem, albeit with American money: https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2 Work through that, read the explanation, type --don't copy and paste-- the code. Then "close book" and try to rewrite the code baed on your understanding of the algorithm. Get ued to doing stuff to gain insight and not asking for more and more explanations. (Actually, it's a matter of finding the right balance b/t the two)
K I S S
&gt;many shops insist that all production machines be Windows because that's what most devs are producing on already. it's hard for a dev to get a client facing UNIX server in such places. So why should the developers of ruby voluntarily subject themselves to such bondage? They don't want to use windows and they shouldn't be forced to. If there are windows developers who want to contribute patches I am sure they would be gladly accepted.
Carefuly assigning directly to `opts` there, you might be trampling someone's poor hash :(
I also absolutely love keyword arguments, and how you can combine them in the method signature. Very rich example you got there, here are some of mine (random): 1. Without keyword arguments, this would need type checking for the case when only a hash is passed in. def url(version = nil, **options) # ... end 2. If a file has an extension, then I wanted to return it without the dot, and if it doesn't have, I wanted to return nil. The below does that automatically: File.extname(filename)[1..-1] 3. In a music app we've had a search endpoint which allows you to search artists, albums and tracks all at once. Afterwards I needed to separate those three types (classes) of items, it took me a while to remember that `grep` uses the `===` operator under the hood: items = music.search(**options) artists = items.grep(Artist) albums = items.grep(Album) tracks = items.grep(Track) 
Ha ha, some just allow run their emotions away so lightly ;) Thanks for the comparison. What oper. system / architecture was the test run ?
Looks great, just picked up a copy!
Just saw this. I actually didn't know about slack-post until your comment. There are always other libraries out there. The real answer though is really just for fun and it met our needs. 
Came here to say this. The Little Schemer will break your brain and then rebuild it better, stronger.
Re-typing existing code is surprisingly effective at improving retention. It isn't a silver bullet when it comes to comprehension, but if you can DO IT then who cares if you understand it? ;-)
While just using a simple rescue will keep execution flowing, I would avoid just a massive series of begin/rescues. You could do something like this, using a tiny bit of metaprogramming. https://gist.github.com/TheKidCoder/402b7e77aae48a3da34d You could of course have an array of procs, but the concept is the same. This also helps you avoid having giant methods.
To directly answer your question, "next" is only for loops/iterators as far as I've seen. /u/TheKidCoder's example looks like a better alternative.
As a networking guy it sounds interesting, but performance is always key and keeping things as close to hardware is heavily coveted. In addition, being able to block via a FQDN vs an IP address is a pretty standard feature on modern firewalls, so I'm not sure what you're comparing it to exactly. I'd have to look into the use-case a bit more.
FYI, there are openflow controllers written in ruby, e.g. https://trema.github.io/trema/.
hello, the very main purpose of this project was learning more Ruby and more Networking, and I achieved it. As being useful, of course performance is low, but enough to work as a test bed for your ideas. another example: blocking SMTP traffic by asking some blocklists; create routes with distance based on wlan interface RSSI; create a 100% customizable wireless hotspot with captive portal; learn Ruby and Networking as I did :)
I used TRB for a small/mid sized internal tool at work (crm/project management) and it worked extremely well. I recommend people check it out.
Fair enough. My experience with celluloid in general has not been good. I think a lot of people were reaching for actors in celluloid because for a while it was "the" concurrency solution in ruby. I think now that [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby) is mature, many cases will actually be better served by the simpler and lower overhead futures or promises implements in concurrent-ruby. In fact, I understood that Rails 5 was going to have a concurrent-ruby dependency -- I wonder why they need Celluloid at all. 
English isn't your first language obviously, but it was an interesting and well structured read, cheers. 
Sorry I don't quite follow. I want to make my own HTML page where I display a feature then display the code, but in the code section, I won't be able to display &lt;button&gt;, because it will be confused as an html element, so I would manually have to type &amp;lt button &amp;gt manually to display the code as text, so I was hoping to find an easier way if I'm going to try to display html elements on the page a lot.
Exactly what I'm looking for. Extremely helpful! Will start reading about Gulp now. Thanks.
Look for opportunities, if you get an interview show how enthusiastic you are about learning and technology. Practice as much as possible, this helps with the last point... Basically at this point you know little and need to convince someone to take a chance on you. In the meantime work on your skills.
That sounds really good! Thanks. I'll link back to those lists, or the organization, in a near future.
I wouldn't bother doing more tutorials for noobs. You just did a bootcamp so get out there and build something. Make a gem, make an app and deploy it, etc. An employer is far more interested in seeing stuff like that than they are seeing that you can complete some online tutorials.
Here's my favorite example (in ruby) for teaching recursion after the super simple counting example. Recursion is a good option here, because as you tackle each piece of the problem, the pieces left can be handled by the same function. It takes an integer and returns it in English words: INT_ENGLISH_MAPPER = { 90 =&gt; "ninety", 80 =&gt; "eighty", 70 =&gt; "seventy", 60 =&gt; "sixty", 50 =&gt; "fifty", 40 =&gt; "forty", 30 =&gt; "thirty", 20 =&gt; "twenty", 19 =&gt; "nineteen", 18 =&gt; "eighteen", 17 =&gt; "seventeen", 16 =&gt; "sixteen", 15 =&gt; "fifteen", 14 =&gt; "fourteen", 13 =&gt; "thirteen", 12 =&gt; "twelve", 11 =&gt; "eleven", 10 =&gt; "ten", 9 =&gt; "nine", 8 =&gt; "eight", 7 =&gt; "seven", 6 =&gt; "six", 5 =&gt; "five", 4 =&gt; "four", 3 =&gt; "three", 2 =&gt; "two", 1 =&gt; "one", 0 =&gt; "" } def in_words(int) if int &lt;= 20 INT_ENGLISH_MAPPER[int] elsif int &lt; 100 tens, ones = (int/10)*10, int % 10 "#{INT_ENGLISH_MAPPER[tens]} #{in_words(ones)}" elsif int &lt; 1000 hundreds, tens = (int/100), int % 100 "#{INT_ENGLISH_MAPPER[hundreds]} hundred # {in_words(tens)}".strip else thousands, hundreds = (int/1000), int % 1000 "#{INT_ENGLISH_MAPPER[thousands]} thousand # {in_words(hundreds)}".strip end end 
One place I would use this over a decorator would be when I need to change a certain object's behaviour within a scope and do not want to replace all occurrences of that object with your new decorated one. But yes, a lot of "normal" cases it comes down to personal preference. 
Meh, other people cheating doesn't really bother me. 
In some ways it is also a better language. Static typing that gives you the compile-time guarantees with almost no annotation because of type inference is great. Also Crystal can be faster than even the most optimized JITs (like V8) There are also some other minor niceties over Ruby.
Note that not all compilers are equal. Crystal will often be able to generate much faster code than MacRuby. Often dynamic language AOT compilers box all data structures and dispatch everything dynamically which is actually less efficient than a good JIT like V8.
You can DRY up the logic by [extracting it into a class](https://gist.github.com/dogweather/d6e62066a2f4835d1557).
If you don't understand recursion, one of two things is happening: 1) You don't understand how stacks work, or 2) you don't understand that function call/return is just stack manipulation of parameters and return values.
I am nervous when using something that pipes basic jobs out to uncontrolled processes in the system. I wonder how dRuby deals with locking? 
function vs inherited ?
In order to understand recursion, you must first understand recursion. 
...saving your future-self time since 23 hours ago...
The Little Schemer is by far his most popular. The Seasoned Schemer is the direct sequel to The Little Schemer. The Reasoned Schemer isn't as tightly coupled, so try it out if you really like his stuff. As to whether they hold any value, I'd say try out The Little Schemer first, and that should give you an idea of what you're getting into.
&gt; "run a huge list of commands and ignore all errors" is not a good idea This is the correct answer here, really... While your examples of using one-line `rescue`s solves the problem, it's probably a really bad idea. If there is a specific error that might occur - e.g. an API time-out, or some corrupt data, or a subtle timing issue, etc. - then you should handle each possible problem gracefully rather than ploughing on blindly through the rest of the code.
My wife is in a bootcamp right now and did a blog post about it recently, I think its beneficial for beginners to see how someone else just starting out see it https://medium.com/@leighsn/pump-up-your-methods-with-yield-529974c07547#.uq9qlc3bx
It's a bit deeper than that. The rack handler instantiates and populates the env variable on every request. There is a specification for what's put in there, as it is a fairly massive object. Not only that, but it's not only data. The `request` itself is accessible through the `env` variable, and you can read &amp; rewind the HTTP connection itself. IOW, you need to know three things to use rack: the two you mentioned (your app implements `#call` and it takes an argument you call `env`), and a third thing: the massive schema of the `env` variable.
imo, Windows is a pain to dev on. I regularly use both linux and windows for ruby and c#
adds `it` and `describe` level tags for `Minitest::Spec` as well as tags for `Minitest::Test`. Also supports things like a `:focus` tag (which you can setup by exporting the `TAGS` variable in your `.bash_profile`) which can be used to quickly focus on a single test
Looking at the sum function on big int, it looks like its creating new objects every time. That can be what slows it down. https://github.com/manastech/crystal/blob/master/src/big_int/big_int.cr#L65
just tested it: https://gist.github.com/benoist/ea8f6f014d893bcea0fe $ crystal run test.cr --release 00:00:11.3355040 # creating new objects 00:00:02.1394850 # just updating self true 
The [solution](https://gist.github.com/dgm/64850fc0bd6fd61f37ab#file-google_params_converter-rb-L40-L91) I wrote looks almost identical! I also added some methods to eliminate empty attributes... although I think I still may have an empty organizations array. 
Maybe start thinking about each function/behavior you want and build out failing tests. For instance, if I try to create a directory in a path that does not exist is that expected to fail? Try to touch a file that does not exist fail or create? list a path that does not exist? Permission failures? ... For each piece of that wanted behavior write a test that is failing and then make it work. The construct of your tests are pretty bad right now but I think your first improvement is better focused on getting in the mindset of describe with test, build to green. After you get your head more around that you will have a lot of tests and should be able to see at a glance at least some very low hanging fruit where you can restructure the tests to be more dry and flexible. Edited to add, it helped me to think of tests as a spec when I started TDD. Write the tests to ensure I specify all of the corner cases and behaviors and then enjoy converting to green as I implement the spec.
[railstutorial.org](https://www.railstutorial.org/book)
Testing command line ruby commands is a bit tricky to get going: 1. Move Redbean.new to external script which requires redbean.rb 2. Pass in ARGV to Redbean constructor in the external starter script. For unix add "chmod u+x redbean" and hashbang for ruby. The file should look something like this: https://github.com/mikko-apo/ki-repo/blob/master/bin/ki 3. Your tests should require redbean.rb also. 4. Your tests should test _your_ code, not library or ruby code (unless you want to catch regressions between versions but that's a special case). Do the cleanup in teardown. I prefer to use the syntax that supports multiple afters/teardowns and take a block because if there are multiple things to cleanup and one of them throws an exception file system will be in inconsistent state. def teardown FileUtils.remove_entry_secure('testdirectory') end def test_mkdir Redbean.new("--mkdir", 'testdirectory') assert(File.exists?('testdirectory'), 'directory not created') end 5. With those changes you'll test your command line parsing and your business code, which changes the nature of the tests from unit tests to functional tests. You're not testing "small units of code", but the whole program instead. And that's a good thing. You'll get better code coverage with that. Sometimes, if your program becomes more complex you might also want to test things in a "unit test" kind of way: def test_mkdir RedbeanCommands.new.mkdir('testdirectory') assert(File.exists?('testdirectory'), 'directory not created') end
Consider that you and I may be developers that do not have any issue breaking down problems into recursive solutions. There are, however, highly intelligent developers who do not work well in that mindset -- perhaps it is an illusion to you (because you are able to think recursively) that it is not "something special", with "nothing to it". 
The oficial getting started is very good: http://guides.rubyonrails.org/getting_started.html
I'm the author of the [Learn Ruby on Rails](http://learn-rails.com/learn-ruby-on-rails.html) book. It's on [Amazon](http://www.amazon.com/dp/B00QK2T1SY), too. What do you dislike about the website?
That's pretty much my approach. Start with describing the state of the algorithm at the end of the recursion, then work on the "stepping" code that will ultimately reach that state. It's effectively splitting the problem up into two parts: an end state and the mechanism that takes data from "upstream", does some work, passes the processed data to the same method and then passes the results back to the upstream caller. The end game is just a special case, where we often do little more then just pass data back to the caller. Upstream/downstream is possibly bad terminology - but yes, starting with how you are going to finish is the same approach I use.
Sweet . Anyone knows why I can't see this version or 2.2.3 in rbenv?
You need to update ruby-build. Link: https://github.com/rbenv/rbenv#installation OSX: `brew update &amp;&amp; brew upgrade rbenv ruby-build` GIT: `cd ~/.rbenv; git pull; cd ~/.rbenv/plugins/ruby-build; git pull` Quick Edit: I just found this rbenv plugin, rbenv-update: https://github.com/rkh/rbenv-update That's nicer than having to do four commands.
Yeah the reason i've just used that, is most of the time our login has been an admin thing. We don't need to send emails out, or have forgot password features. Just need something there that's a bit better than httpbasic. In my own webapp that I've worked on, I just used it as it was easy to get a user account login off the ground. I actually removed it since, and switched to email based login. Put in your email, receive a single use token URL, click and you get a session.
There are some new features. But with few exceptions, anything written for 1.9 will run fine under 2.0-2.2 as well. You should be okay learning in 1.9. 1.8 is a different story, mainly because of string encodings, but also some other issues. Don't learn 1.8. 
I played around with this for a few minutes to see if BigInt could be updated to do this all the time (updating self vs. BigNum.new), and while it passes it's own specs, it causes the range specs to fail. Maybe a more significant refactoring would fix this, or if object instantiation was faster...
Cool. I've been a full-stack mentor for almost 2 years, I'll be happy to answer any of your questions. 
Awesome !
yep it worked, thanks!
[Iterating over an empty `Array` is not a special case.](https://github.com/ruby/ruby/blob/cb3b463a50dee9d4e3d174dc9b1d7c8181678cd4/array.c#L1844)
I'm not sure whether this pattern is a good idea, but you could write a method to do something very much like what you spec. Seems fun, so I will. Here's the api: each_and_empty(array) do |i| puts i end.empty? do puts 'empty' end Or even: each_and_empty(array) {|i| puts i}.empty? { puts 'empty' } And here's the implementation, which is very NOT high performance compared to ordinary each. Several things in here will be slow in micro-benchmarks, but it does provide that API in 10 lines. def each_and_empty(array) array.each { |i| yield i} return Object.new.extend( Module.new do define_method :empty? do |&amp;block| if array.length == 0 &amp;&amp; block block.call end end end) end A higher performance version could be written although it would take a tiny bit more code. Mainly stop using anonymous module generated on each return. Create two classes, one which has an `empty?` which does nothing, and one which has an `empty?` which just yields. Return an instance of the correct one based on whether array is empty. Actually I hadn't thought of that before, I think that's the better implementation I should have done from the start, I'll leave it to you. 
Today I feel lazy... so what is new?
FFI security fix and minor changes
http://railsapps.github.io
Why are you trying to do this? That might help us help you. Also, if all you're doing is puts, the lambda/call is unnecessary – just wrap the puts call in parens. Remember that puts returns nil, so you'll get that as the overall expression result.
Keep in mind that you are fundamentally doing the same thing as using "if" – there's no logical difference between "if A then B" and "A &amp;&amp; B". But you're doing it in a way that is likely to be confusing to others, including future-you. What you've described the need for here is for the program to execute in different ways based on different circumstances, and that means that you're branching the logic. You're just doing it in an odd way.
Ok, cool. I was trying to figure out how to execute more than one line after determining it was empty, initially using {}. Glad to see this works: methodThatReturnsEmptyArray.each { |x| puts x }.empty? &amp;&amp; ( puts("ARRAY EMPTY") ) I told you exactly what I've done and was trying to do, come up with a way to 'tag on' code that will execute if the array is empty. I wanted to avoid testing it explicitly like this: arr = methodThatReturnsEmptyArray if arr.empty? puts("ARRAY EMPTY") else arr.each { |x| puts x } end I guess it ends up being less efficient at runtime, but it's 3 less lines of typing and I don't have to assign the array I get to a variable. It also resonates more with my natural thinking which is why I generally prefer to use Ruby over other languages. The first method seems more natural to read to me. I guess that's still not perfect, here is how I would do it if I wanted to extend Array (I generally don't like modifying the behavior of standard classes) class Array def or() return self unless self.empty? yield end end [].each { |x| puts x }.or { ["Default Nonempty Array"] } This way I can even chain another operation after this.
Someone should really add this to our faq if it's not on there, it just feels like something new rubyists need to know I remember it confused me at first too...
I never understood why recursion is a hard concept to grasp :/ it's much harder to understand something like sorting imo. def rec(num) num - 1 if num &gt; 3 rec(num) end end rec(5) The method should call itself over and over again until num is no longer greater than 3. It's best to use this when you find a reason to, looking for reason to use it will make your head hurt. I've made a caesar cypher in java and that's when recursion clicked for me, I use it kind of a lot now.
If nobody's ever going to see your code, then do whatever you want. If/as this code is going to be used by other people and accumulate collaborators, it becomes more and more important to adopt a common style. That being said, my idiomatic version of [your example](https://www.reddit.com/r/ruby/comments/3xa2h5/adding_a_default_block_to_run_if_arrayeach_is/cy32jmm) would use the [ternary operator](https://www.reddit.com/r/ruby/comments/3xa2h5/adding_a_default_block_to_run_if_arrayeach_is/cy335up "boolean ? if_true : if_false"): def compute_list_of_pairs # idiomatic naming, also I like using 'compute' for expensive methods sleep(5) # simulate computationally intensive call rand(2).zero? ? [] : ["A 1", "B 2", "C 3"] # let's handle both end def compute_pairs(when_empty=["Z", "26"]) pairs = compute_list_of_pairs.map { |pair| pair.split(" ") } pairs.empty? ? when_empty : pairs end puts compute_pairs.inspect # pass to a method If you insist on doing this anonymously (without defining method/variable names), you can also use a mutative `tap`: compute_list_of_pairs.map do |pair| pair.split(" ") end.tap do |arr| arr &lt;&lt; "Z" &lt;&lt; "26" if arr.empty? end
The news will come with ruby 2.3 the next week
Both of these are good solutions. Tap is an awesome solution, and something I can't believe I didn't know about already!
I'd go with this: array&lt;&lt;"Z 26" if array.empty? array.map do |x| ... end
Natural as in it feels good to Matz to write Ruby. Expressive, like writing poetry. When I think of "simple", I think of Clojure with it's small syntax, and not Ruby with a bazillion aliased methods and it's massive syntax.
 collection.each do |element| # ... do something end unless collection.empty? 
Have you immersed yourself deeply in both before making this comparison, or are you new to Ruby? My initial reaction to Ruby was "meh", but I've grown to truly appreciate how easy it _can be_ to read (of course, this entirely depends upon the author of the code). Disclaimer: I've spent years professionally in both Ruby and JS. But I've never done ES6/Typescript. To me, what he means by saying it's not simple is that it is a robust, comprehensive language with a large stock library. It's stable, predictable, and consistent in its APIs. It can be used to build "big" things. It has fantastic support for meta-programming, which is certainly anything but simple. Throughout my career (~15 years), I've always said that the most important attribute of anyone's code is readability/understandability/maintainability. Of course it's true that you can write easy-to-read-and-understand code in any language...believe it or not, I spent years writing Perl code which I still believe to this day was pretty readable despite the language often being referred to as write-only because it _can_ be so cryptic. But thus far, Ruby makes it easier than any other language I've ever worked with to achieve that goal. Python comes pretty close, but not quite as "natural". It achieves this by doing a few unconventional things like allowing question-marks in method names and allowing you to call methods with no parenthesis (which you should only use if you're not passing args). There are so many more things than this, but here are a few contrived examples which I think are just _nicer_ to read in Ruby. Let's say you've got an instance of a `Shipment` which has a method to return its `User`, which in turn has a method to get its full-name... Less punctuation... ============= JS: return shipment.getUser().getFullName().toLowerCase(); Ruby: shipment.user.full_name.downcase Null-checks... ============= JS: shipment.getUser() === null Ruby: shipment.user.nil? Inline Conditionals... ============= JS: if (isHungry()) { eatSomeFood(); } Ruby: eat_some_food if hungry? Implicit Returns... ============= JS: function getUsername(shipment) { if (shipment.getUser() !== null) { return shipment.getUser().getFullName().toLowerCase(); } else { return null; } } Ruby: def username(shipment) shipment.user.full_name.downcase unless shipment.user.nil? end ## Alternate, but arguably less readable def username(shipment) shipment.user&amp;.full_name&amp;.downcase end Edit: complete formatting fail.
Yeah, keep taking away 1 until num is no longer greater than 3. It's a dumb example but that's recursion a method that will call itself until a new condition is formed.
I don't think that's how it works. I'm new to this so if I am wrong please correct me: ERB works because there is a framework interpreting it. The framework gets the ERB file, reads it and executes the ruby in such way that it will create a pure HTML document and then send it to the browser requesting it. You'll never execute ERB in a browser without some sort of framework/software involved in the process. Maybe your best bet to do so without a framework would be with a browser extension (if that exists).
You mean: ERB -&gt; ERB Interpreter -&gt; HTML Document Doing a quick google search there doesn't seem to be much about the interpreter. The only version I found was for ruby 1.8 (which won't be of much use as of today). Let's see if any of the gurus can answer this.
I stopped reading after you tacked on "less lines" as an argument. I would hate to work with you.
I salute you sir for creating a great library that's been extremely useful.
yup, that. Thanks
Thank you very much. Exactly what I was looking for. This cleared up a lot for me 
no problem, I copied it and am looking into it. One newbie question though, What is the '.ru' file extension you used?
Once you've written your .erb file you can use the [eruby command](http://www.linuxtopia.org/online_books/programming_books/ruby_tutorial/Ruby_and_the_Web_Using_eruby.html) to create an HTML file, then you can open the HTML file in your browser. You won't be able to open the .erb file straight in your browser if that's what you're asking. Your best bet is JavaScript if you want to do something like that.
I see. That's what I wanted to know
I agree with others that you should look at Sidekiq. It requires a Redis data store to use as a queue. If you are running on aws, you may also look into the Shoryuken gem. It's adapted from Sidekiq and made to use aws sqs as its queue. 
erb is also a command you can run erb [opts] &lt;file&gt; &gt;newfile.html &amp;&amp; open newfile.html that's the most basic you'll ever get
their readme is pretty excellent as a resource. here are my set of resources I gathered as I was learning Sinatra : https://github.com/ISS-SOA/class-SOA-repo/wiki/resource-ruby-sinatra honestly, if you understand web technology, there's not much to learn. feel free to send me a pm if you need anything. 
There is a ruby to javascript compiler so that you can write ruby code that then runs the equivalent in javascript in the browser. Since you're new to programming, I wouldn't recommend using it as learning javascript is a better use of your time, but it does exist. Try it here: http://opalrb.org/try/
ERB is for embedding the output of Ruby code into an HTML page, in a static way. You won't be able to use it for embedding Ruby in a way that will run in the browser interactively.
Thank you very much everyone. I got my answer. I guess you can't directly access erb from you browser and instead have to interpret erb code into an html file and then use the html. Much appreciated.
I implemented it like that only because it's what the OP asked for. What I think is this whole thing is probably not worth doing. But if I were doing it, the part that seems worth doing is being able to provide both blocks (each and and empty) as blocks, rather than passing in a lambda. That's what makes it fun to code, and I think it does result in increased readability (I just don't think it's worth the increase in maintainance burden or a new developer comign to the project figuring out what's going on with your magic). If you are just passing in a manually created lambda as an arg... I'm not sure you gain anything in readability over just doing without this added "dsl" entirely. As far as your 'edit' suggestion... is what to do when you are iterating an empty array a property of the _array_, invariable as to context? I think probably not, it's a property of the context where `each` is being called, in different places you want to do different things on an empty array (and in some places you don't need to do anything special), even with the same array of data. So I wouldn't set a "do this when iterating an empty array" proc on the array itself. If you did, it'll also lead to confusing non-local code where you set the thing to do on empty in one place, then it winds up being executed in another, and you forget you added that feature to Array. Myself, I'd just use `if array.empty?` for any special logic I might need when an array is empty, as everyone does. 
There's like a zillion answers already, here's mine: https://github.com/schneems/ruby_view_server It is a minimalistic html generating script that uses only the ruby standard library mainly ERB. It's part of a class I put online: http://www.schneems.com/post/25925957093/databases-rails-week-3-pure-ruby-views/ 
Sinatra is fun, and the good thing is that once you start doing it, you can start learning more and more about it. Most of the stuff you need to learn will be specific to the application you're building and the gems you're planning on using... Sinatra itself is just pretty much the basic config and that's it. 
I've recently published one very simple gem, which uses recursion for traversing nested hashes: https://github.com/denispeplin/hash_template/blob/master/lib/hash_template.rb#L16-L18 I think it's a natural fit for recursion, other ways of solving this problem will be much more complex. Hope this example will help.
Considering I put it in parens because it wasn't part of my argument but merely a nice bonus, way to be an asshole. Congrats you win the internet.
 thank you for all your insightful responses :). I will try my best moving forward with TDD. 
Yeah, that' works. I was just trying to get a nice and neatly bundled chain that I can pass to a method or chain methods off of if I wanted. In my case I'm calling a method that I wouldn't want to call twice, so I have to assign it to a new variable. Then I have to have an if block (which I can chain off of, but I can't put into a method, as far as I know) I can chain off the array using tap, which seems like best solution to my contrived problem outside of extending Array with the exact functionality I'd want.
A tool similar to what you describe is Representable: https://github.com/apotonick/representable
Is there a generally good resource? I'm having trouble specifically with the part about making the Middleware essentially talk to each other. I can align them correctly I think in the config.ru file. It's just a matter of them all sort of playing with the same env I think, or the same request. Basically, how does middleware pass information back and forth to each other?
&gt; I feel his energy and creativity would have a more productive foundation if he chose to express his code in Elixir, Having an opinion on one platform is normal. Deciding to publically call out one person because they happen to use a platform you are not a fan of is just stirring drama. In general response, I do wish the Rails team would get more brutal about closing old issues. If I ask for more information and the requester doesn't get back to me after a certain time, the issue gets closed. Many of these large projects, Rails included, have issues going back three years since last response. They even have a tag for "inactive". A bit of a hard love can not only make these metrics look better, but keep things better under control for those fixing bugs.
I agree, probably should've linked to: http://weblog.rubyonrails.org/2015/12/18/Rails-5-0-beta1/
I don't use rails (yet?) but is action cable the answer to web sockets?
I am very happy about the API mode, and probably happier than I should be about `rake` commands moving to `rails`.
Representable is a huge library for building APIs, and I think that it closer to JBuilder or ActiveModel::Serializer. It works with models and transforms them to APIs. In contrast, both gems I've published are working with pure hashes and may be used for extracting data from complex documents (hash_map_hash) or preparing data for external APIs (hash_template).
Haha, you're right. The worst part is that I've used the grep method loads of times, but for some reason didn't think of it. I figured Ruby would have had it already, but for some reason I missed it when looking through Enumerable. Oh well. Thanks!
Oh man we haven't even upgraded to 4 yet!
Woo! I take this as a clue that Ruby 2.3 will be released on Christmas Day.
You're right, that was a duchy hard sell. I'll try to avoid that in the future, thanks for encouragement
&gt; No more accidentally halting Active Record callbacks because the last statement is false. Now you throw(:abort) explicitly! why `throw` rather than `raise` ?
Counter caches are completely broken for non primary relations since the beginning of rails. I don't think it will be fixed in 5 since they already released the beta. I created an issue but in brief, increment_counters only takes the primary key as argument
&gt; throw is used to exit a block early . `throw` jumps to a `catch` label in the call stack, it's Ruby's version of `goto`. 
This seems to replace a forgotten `super`, which is trivially caught with any sort of test coverage, with an overly complex object initialization model that is most likely not only slow as hell but requires mixing in `ActiveSupport::Callbacks` all over your code base. No thanks. 
I'm excited about `ActiveRecord::Attributes` which [lets you define non-database backed attributes on models](https://github.com/rails/rails/blob/8c752c7ac739d5a86d4136ab1e9d0142c4041e58/activerecord/lib/active_record/attributes.rb) like Virtus. 
Or just avoid callbacks when at all possible.
Just two though?
Aha, no you can't do that. It has to be interpreted by Ruby itself. Same as PHP, you can't run it from the browser itself, it has to has php to interpret it. HTH
Yup, it was supposed to be a small and easy to read post :)
I hope it comes bundled with a new sprockets version that handles JavaScript ES6 as easily as Coffeescript
A few things. 1. This isn't an ActiveRecord dependency, it's an ActiveSupport dependency. It is entirely possible to install ActiveSupport independent of any other part of Rails. Depending on ActiveSupport is no worse than depending on any other library that performs a useful service. 2. It's not "avoiding a basic behavior of the language." It's avoiding a stated anti-pattern. If, as it seems you do, you disagree with the idea that it's an anti-pattern, that's fine. But in that case, surely it makes more sense to criticize the "anti-pattern" label, than it does to criticize the proposed solution? 3. "Are you supposed to do this for every method that needs to use superclass code?" Absolutely not. I'd highly recommend you read over Martin Fowler's description of the "Call Super" anti-pattern (here: http://www.martinfowler.com/bliki/CallSuper.html). There is a specific way of calling super that this addresses. And even with that anti-pattern, there is an even more specific use-case that my proposal is designed to solve -- a class hierarchy with more than two layers of inheritance. Does this turn up often? Not in my experience. It's generally better to find alternatives to inheritance if the hierarchy starts getting deep. But sometimes, once in a while, it's the best way, which is when the technique described in the article comes in handy. 4. I'm sorry you feel like I'm over-engineering something. Again, this is not a general solution to a problem, and I would _never_ use this technique as a general replacement for `super`. But is this really over-engineered? It's a few lines of code, literally. And most of the code goes on the root class, and nowhere else. That said, I'm sure I can't convince you that this is a useful technique. I'm really not trying to. But I hope you understand, too, that just because it isn't useful to _you_, it can still be useful to _others_, when used appropriately.
This is the [change-making problem](https://en.wikipedia.org/wiki/Change-making_problem), [here you can see some solutions](http://rosettacode.org/wiki/Count_the_coins#Ruby). I translated the non-cached recursive Scala one into Ruby for you: def count(target, coins) if target.zero? 1 elsif coins.empty? || target &lt; 0 0 else count(target, coins.drop(1)) + count(target - coins.first, coins) end end p count(0, [200, 100, 50, 20, 10, 5, 2, 1])
I don't follow the argument that because the Elixir repo itself closes issues faster than the Ruby repo that this somehow implies that using Elixir is better than Ruby. I don't follow the argument that because the Elixir test suite runs faster that contributing to Elixir is more worthwhile than contributing to Ruby. It is clear you have an agenda with this whole "Ruby2Elixir" shtick. Calling someone out and implying that they would be more productive and happier is completely off-base. Using Elixir does not give you some magical ability to judge the happiness of another human being. I take issue with the fact that you defend yourself in another comment by attempting to draw a parallel that DHH held controversial opinions. You aren't just making opinions, you are misconstruing facts and making up your own statistics. DHH contributed tons of code and educational material that popularized Rails. If your goal is to be the "DHH" of Elixir then you are trying way too hard and I don't think you are winning yourself (or more importantly Elixir) any fans. I say this as a Ruby dev who was interested in Elixir and who has been left with a foul taste in his mouth. Being controversial is a great marketing tactic under the premise that your message will polarize people to love you or hate you. I think it is important to be able to recognize when there is no love taking place. 
Hi OP, just curious but where do you find these problems? Are they online?
[^(**Mouseover** or **click** to view the metric conversion for this comment)](http://fiddle.jshell.net/ConvertsToMetric/xhk4y5h5/show/light/?2%20miles%20=%203.2%20km%0A "2 miles = 3.2 km Post feedback in /r/ToMetric")
Hi, the closest road to having some Ruby code in HTML as you do with PHP is using rack-server-pages https://github.com/migrs/rack-server-pages . Tested it in a little project, works great. 
You're right, the problem is with using the .first method. Break up the line in two to better see what's going on (disclaimer - it's been a while since I've used Sequel, my syntax may be off in a few points, but I hope you get the gist of it): # SELECT * FROM DB WHERE used_date IS NULL first = DB[:coupon].filter(:used_date =&gt; nil).first # UPDATE DB SET used_date=Time.now WHERE id=&lt;someid&gt; code = DB[:coupon].where(:id =&gt; first[:id]).update(:used_date =&gt; Time.now) You can infer from the SQL statements I added as comments for each line that in your one-liner you are doing an update on the result set, not on the original dataset. 
Me too until a week ago! Glad I could help a bit :)
I hate to be _that_ guy, but how is this related to Ruby?
Crystal != ruby.
If you access anything with DB[:tablename].whatever then everytime after .first, .all, etc. you get back a Hash as a result so your update uses Hash#update method to update the resulting Hash NOT the DB row. If you want to get back Objects representing DB datasets you should first create Models for your DB tables like so: class Coupon &lt; Sequel::Model(:coupon); end Coupon.filter(user_date: nil).first.update(code: 45) Also don't use "hash rocket" notation for when you have :symbol as a key. It's not idiomatic.
https://www.ruby-lang.org/en/news/2013/12/21/ruby-version-policy-changes-with-2-1-0/ &gt; MINOR: increased every christmas, may be API incompatible They released a new minor version on Christmas day, in 2013 (v2.1.0) and 2014 (v2.2.0). I'd be surprised if the next release (v2.3.0) *isn't* on Christmas day.
Yes, why have 3.2 kilometre stones?!
Look at _redka's response too. I try to use Models whenever I can because it does simplify how Sequel works and is a lot more predictable :)
to skip the introduction go to 30.24 tl;dr (or watch) is @ 44.08 thank me later
If you are serious about learning RoR's check out Launch School, previously known as Tealeaf: https://launchschool.com
You right, but *map* is a recursive method, so this parameters order was easier to implement. I'll see how to fix it.
No problem, I just didn't get this from README.
This doesn't fit the criteria of the OP.
Which is why half the posts here are about either Crystal or Elixir. I don't know about you but I'd like to see, I don't know.. Ruby.
In fact the top 3 or 4 comments advise you to not do this. So perhaps you should listen to what these experienced folks are saying instead of getting your panties in a bunch and crying like a toddler.
So I'm a toddler because I asked a specific question and get replies that aren't on topic? I understand why you would do it the other way, but that's not what this discussion is about. Please, don't get offended that IDGAF about your shitty opinions.
When (if ever?) Crystal finally gets Windows support, it will be *unstoppable*.
I think you've proven why you're a toddler.
You posted on this forum because you wanted to know what others thought. Most everyone told you "don't write shitty code you n00b. You create way too much work for the rest of us to clean up."
Rust has [2278 open issues](https://github.com/rust-lang/rust/issues) on Github. I guess it must be the worst language ever created by your logic. Or it could just be that Rust, like Ruby, is popular. And Elixir, being less popular, does not have many people creating issues or submitting pull requests for it. You cannot possibly make any realistic implication that fewer issues = better code quality. My projects on Github all have 1 or fewer issues on them, yet that doesn't mean they're well coded--it just means nobody uses them except for me.
I didn't take the time to read up on the Huffman algorithm, so for all I know you could be making it all up! But your ruby style looks pretty good. Method chains are very common, and I consider methods which have no or very few local variables to be an indicator of good (functional) ruby style. The first thing that jumped out at me was your indentation. Ruby pretty universally uses 2 spaces for indentation. Additionally, while it's a little counterintuitive if you're used to other syntaxes (eg python), I haven't found it common to indent methods defined under the private block. Some rubyists provide the private prefix on every method or manually privatize after definition to avoid any ambiguity. 
Ah, I was hoping you weren't going to mention the indentation, I haven't yet configured Vim on my current machine and, to be honest, I don't really look forward to that. As far as indenting after 'private', I picked up that habit from looking at someone else's source code, I believe. For some reason I was under the impression that that was common practice. Thank you for your input, I really appreciate it.
I'd suggest running this code against Rubocop https://github.com/bbatsov/rubocop to get some insight as to how to adhere to common Ruby conventions.
Answering asinine questions like yours encourages bad behavior. And I can see from your constant outbursts that your bad behavior has been encouraged your entire life. If you were smart, you wouldn't ignore all of the advice that various people have given on this post. Primarily, don't write such shitty code. Even if you think there are instances where such shitty code is acceptable, it's not. 
When the topic is "how do I get this shitty code to work?", the correct response is "don't write shitty code". That is both on topic and a valid and most correct response. 
Are you this guy's lover or something? He is off topic, that is all, and his responses aren't useful. Not only that, but other, more useful, repliers have mentioned it, but then also answered my question. I didn't treat any of them with hostility because they are capable of understanding that not all code is written in a public setting, nor does it have to match their personal coding beliefs and practices. So please, all of you grow up and instead of finding random targets to antagonize on the internet, go jerk each other off, you'll find yourself less likely to need to troll people on the internet. For some reason I got really good answers at first and now I have a few people that have nothing better to do than constantly berate me with their (same, irrelevant) opinions.
&gt; Even if you think there are instances where such shitty code is acceptable, it's not The knower off all things, right here. If I deem my code to be acceptable, it's fucking acceptable. I'm not a fucking child; I program professionally; I understand that there is a much more clear way to write the code, and I will do so when team practices and conventions . You however, can't comprehend that there are other scenarios besides that one. You also can't comprehend that anyone has other preference, opinions, or styles from you. So please continue to keep acting like you're important, like you matter. Keep acting as if you're bestowing some wisdom on me, some ancient secret that I didn't know. &gt; constant outbursts Nice exaggeration, I assume you think I'm having 'outbursts' because I curse, or because I'm short with you? Not sure exactly, I can assure you it's just my impatience with 'n00bs giving shitty, unwanted advice', to use your stunningly dignified phrasing. I really only want you to go away and preferably learn that nobody cares what you think. It's pretty pathetic that you are still here, still pressing because apparently this one misguided guy on the internet REALLY NEEDS TO USE AN IF BLOCK OR THE FUCKING WORLD WILL COLLAPSE.
You may get paid to write code but you're definitely not doing it professionally. Oh, and there are no scenarios, no preferences, no stylistic reason to write such shitty code. I may not matter but at least have the dignity to not subject your team to such unmanageable, crappy, hard to test code. Your team doesn't need to have conventions. Ruby has conventions. Your team doesn't need to have best practices. Programming theory has best practices. Take a gander at the SOLID principle and the ruby style guide. If not for your own sake then for those that need to fix, refactor and maintain your shitty code long after you're fired for writing such junk.
&gt; I consider methods which have no or very few local variables to be an indicator of good (functional) ruby style. Well, in this case all methods mutate state. So, you'd actually need to consider more than just the local variable count in order to call it "good (functional) style".
I use Vim with the rubocop plugin on my main development box. I find myself ignoring it 50% of the time though as it usually just alerts me that my methods are longer than 7 statements. I do catch myself using single letter variable names in my iterator blocks because of rubocop though, but that's where it finds most of its use unfortunately in my case.
Style guides and common practices are there for a reason, mainly to allow you and others to understand the code easier when reviewing or trying to understand it. These "tips" make you stop and think about your code. So no, I don't disable them. I have yet to meet a programmer in my 34 years of experience that couldn't occasionally use a nudge back in the right direction and possibly learn something new. :-) Good luck! 
It just appears to be a small amount of code, the module (ActiveSupport::Callbacks) is actually 747 lines of code. It might have a small API but behind the scenes it's an enormous edifice of code that is clogging up your class.
Well, yes, no, sometimes. If you are talking in some specific context, like RoR web development, then may be. But generally, an OO class should represent some real or abstract object and thus the class is only so good, as closely it follows the reality. If the reality dictates more than 9 fields, then why not.
Honest question: If all the functions exist within a class, does mutating the state of the class violate functional style? Ruby is not a pure functional language, so is it "ruby functional" style?
That's a good point and I'll be honest, most of the time I do stick with single letter variable names inside of iterators, but I still feel like if you can convey what kind of objects you are iterating over in a brief variable name then you should. For example using 'char' when iterating over all characters in a string. Something short like that.
&gt; does mutating the state of the class violate functional style? It probably depends on whom you ask. I'd say yes especially when the mutation is visible to the outside world (`attr_reader :table, :content` return different results). In this case the mutation isn't even necessary and `generate` could be implemented without any (internal) state modifications.
I'm 50/50 on it. Rubymine really likes to tell me that my class names are too long, which is nigh impossible to avoid in migrations and tests: `class CreateManufacturersProductsCustomers &lt; ActiveRecord::Migration; end` is a perfectly legitimate class name but generates a warning. And if I read "Share no more than two instance variables between a controller and a view" I'm gonna scream. But sometimes the warnings actually do help point to antipatterns, like if you accidentally use the same variable inside an iterator and out, or if you have a lot of parameters in a method or something. They are helpful, but only to a point. I think Jetbrains/Rubymine have bigger problems than that though, so I find myself getting annoyed with other things much quicker.
Big thanks for that! 
Thanks! Much appreciated.
So, if I may ask, why not create a migration changing "success" to a boolean?
How is telling you that writing code like this is a bad idea off topic? You need to calm the fuck down and learn to take feedback when you ask a question on a public forum.
Considering beta1 for rails 5 was just released, I would assume it would be a rough idea to quickly write a book for it. Would be nice though
They have been working on rails 5 for a pretty long time now. I forget when they officially switched gears to rails 5, but I think it was at least 6 months ago.
&gt; The next example is storing datetimes in the database as strings, with varying formats, but they get converted to a ruby DateTime on read (and vice versa on out)? Don't do that. Ever. Just don't do that. Did you read the post? It explicitly states that the `confirmed_at` attribute in the example is not a database column. It could be an attribute derived from user input (a form post) or have some other purpose. Also you seem to be under the impression that Attributes coercion does not make it to the persistence layer when you say "but they get converted to a ruby DateTime on read (and vice versa on out)". This is not the case. 
Thanks! This is awesome! I've made the 'purchase' and saved it to the kindle cloud. I don't like being locked in to Amazon or anyone else for books though. I use Calibre to manage all my books and stuff. Does anyone know a way for me to grab this off the kindle cloud so I can put it in Calibre? When I tried to enable offline in the kindle cloud reader, it tried to download an app, which I really don't want. *EDIT - Nevermind, I figured it out. For those wondering, I had to download the Kindle for Windows app, install it, download the book, go to ~/Documents/My Kindle Content, import it into Calibre, uninstall Kindle for Windows app, delete My Kindle Content folder (as my calibre copies it to a new folder). Then convert to epub so I can actually use it on my devices. Jeez. Thanks Amazon.
Thank you!
Sorry didn't notice you didn't want to disable it globally.
No UK version 😢
Great! Thanks very much and happy holidays to you, Daniel!
http://www.amazon.co.uk/gp/product/B00QK2T1SY?keywords=Learn%20Ruby%20on%20Rails&amp;qid=1450740356&amp;ref_=sr_1_1&amp;s=digital-text&amp;sr=1-1
You have to really old in Ruby years since this is the preferred way from the beginning of the 1.9.x series. I assume you're not actually doing 1.8.7 anymore and are just reluctant to change?
Thanks!!
The UK Amazon site has the book and it's free until Christmas: * [http://www.amazon.co.uk/dp/B00QK2T1SY](http://www.amazon.co.uk/dp/B00QK2T1SY) If you like the book, it'd be nice to leave a review. There's only two reviews on UK Amazon. Both five star reviews! There's three dozen reviews on the US Amazon site (almost all 5 star reviews).
Thanks Daniel! I also just figured out a really round about way through the Amazon Kindle for Windows app. I'm looking forward to reading your book!
Thank you!
you can pry my hash rockets from my cold dead fingers
Thanks a ton!
Depends. So, the way Rails does it is by making a specific Ruby script the "waypoint" of the application- I can't remember if it's config/environment or config/application- but the Rails root is relative to its __FILE__. (For reference: __FILE__ is a "global" which always contains the path of the file it's in) So, usually, I'll do something similar- if my project needs to be invoked via, say, Rake, I'll define all my paths in globals relative to the Rakefile. If the project has gotten more complex, I'll usually create a "config/environment.rb" file and define my paths relative to that script's __FILE__. For a more general strategy, I would suggest figuring out the dividing line between your "structural" code and your "application" code- also something I've learned from Rails. In "structural" code, you can directly `require_relative` files which are implicitly guaranteed to be present. These files should very quickly set up the $LOAD_PATH, so that in "application" files, you can just use "require". As for resource files, you can define their directories as Pathnames, stored in constants. So, in a loading script contained in the project root, I might do something like: ROOT_DIR = Pathname.new(__FILE__).join("..") RESOURCE_DIR = ROOT_DIR.join("/res") And then, elsewhere, to access a specific resource: File.open(RESOURCE_DIR.join("foo.txt")) Does that make sense? When I have a laptop available I could probably provide an example project. edit: [Here's a couple examples on Github to show what I mean.](https://github.com/mhink/rrubyexample) 
Thanks a lot... 
Wow, the free book offer has been enormously popular. Over 2000 copies given away on Amazon in less than 24 hours. I'm thinking I'd like to continue to offer the book for free after Dec 25. Also people have asked me what else I've written. There's the [Capstone Rails Tutorials](https://tutorials.railsapps.org/) which are intermediate level tutorials that go beyond the [Learn Ruby on Rails](http://learn-rails.com/learn-ruby-on-rails.html) book. If you're interested, you can get the dozen tutorials at a 20% discount. Go to [https://tutorials.railsapps.org/users/sign_up](https://tutorials.railsapps.org/users/sign_up) and enter the invitation code 2015RD20. The discount code for the Capstone Rails Tutorials expires Dec 31st.
Looks nifty. Reminds recent haskell's prelude implementation. Just be aware there is no TCO by default (and lang. specification) in ruby.
Where is the code at risk of recursing?
too petty to impress …
&gt; You may get paid to write code but you're definitely not doing it professionally Ohh, burn. Boy you are clever. Too bad it's false &gt; I am super angry IDK why you assume this has anything to do with a team.
Sequel auto commits with certain functions. ```.update``` is one of those
&gt; Reminds recent haskell's prelude implementation Which one? I can't find transducers in the prelude?
I wrote a book and recorded a video series about Ruby 2.0 as compared to Ruby 1.9. It's still for sale but I mean to stop that and just release it all for free.. so step one of that is here: http://no.gd/r2wt.pdf - enjoy! I'll upload the videos to YouTube shortly. Three of them are already up.. including [a guide to Enumerator::Lazy](https://www.youtube.com/watch?v=Kg4aWWIsszw), [a guide to keyword arguments](https://www.youtube.com/watch?v=u8Q6Of_mScI) and [an introduction to TracePoint](https://www.youtube.com/watch?v=V_dZQ6AeZDE).
This is a cool feature and will certainly make for some nicer looking commits! It slightly bothers me that this person kept using words like "ugly" and "hack", but it's fine. `#squish` exists in ActiveSupport, but that's a big library to include if you're not using anything but that. And I realize `#squish` is not exactly the behavior the person wants.
Also, I like that the title bar changes when you tab away from that website.
What you're looking for I think is a presenter, or maybe a decorator. But the basic idea you've described is correct. Though I think you have it backwards. The DataVisualizer is a presenter that takes a Data object and stores that data object in an instance variable within the DataVisualizer and delegates some methods to the Data object while adding additional methods/behaviors to Data (thus acting as a decorator). If the intent is to have DataVisualizer be able to receive any kind of object, then you are building a decorator. If the intent is that DataVisualizer only takes Data objects, then you're building a presenter. This is good OOP design as the Data class and DataVisualizer classes have separate responsibilities and knowledge of the internals of each class between the two classes can be limited. DataVisualizer doesn't really need to know that much about Data, only that it receives an object and can delegate certain methods to that object, what that object does when it receives those messages is up to that object and not up to DataVisualizer, that reduces coupling. +1 POODR Not sure MVC has any relevance here. The OP doesn't mention a website or web application, so an MVC design doesn't really apply.
Idk why i thought you'd be reasonable about anything. Guys like you have been coddled their entire life and whenever their world is shattered they break down like infants. Also, you're quoting things i never said. Can you do anything right?
If you were using rails, then you could already use the strip_heredoc method even if it wasn't as nice. &lt;&lt;-EOS.strip_heredoc This works just as expected EOS
&gt; Would it be bad design to contain an instance of DataVisualizer as an instance variable of Data and delegate its methods to Data? Yes. I think it is safe to say that this would be bad. Suddenly your purely data concerned (I have no idea what the actual concern of that class of yours is.. I presume it is to.. hold data?) Data class knows about how to display itself as a graph. Imagine someday you want to display the data as a table, would you then add another instance variable to Data? And then when you would like to display it as CSV... You can guess where this is going ;) You should invert that dependency. The DataVisualizer may well depend on the Data class after all its job is to display that data. If it can also display other stuff that has the same interface, you may want to dependency-inject the object to be visualized. You can think of the DataVisualizer as a Template for rendering your Data. Iff you need to perform complicated operations on Data before it is in a presentable state, you should introduce another Player that does that for you so you don't sully the DataVisualizer with that non-visualization logic, e.g., a Presenter or Decorator as others have already recommended. Hope this helps!
Looks very promising, thank you!
Better approach at the problem?
At my work we use various editors, but use Rubocop for linting. Generally, it's not too bad, although as a group we've decided to increase the max line length to 150 characters. I still get errors at times when trying to do HTTP calls due to the length of the URL. Aside from that I mostly just get annoyed at the [ABC Size](http://www.rubydoc.info/gems/rubocop/0.27.0/RuboCop/Cop/Metrics/AbcSize) errors, which mean I either have to split out my method into multiple functions, making it harder to follow what is going on in a method, or switch to using some obscur functionality in Ruby that some members of my team are unaware of, again making it harder to read.
It may be of interest to know [how Python handles the same issue] (https://docs.python.org/2/library/textwrap.html#textwrap.dedent).
ah interesting, thanks
Just so you can see for yourself, [here is `Enumerable#reduce` (also named inject) calling each on the underlying object](https://github.com/ruby/ruby/blob/trunk/enum.c#L705), and [here is `Array#each` using a for loop to iterate over every object.](https://github.com/ruby/ruby/blob/trunk/array.c#L1814) You can see that reduce/inject passes a memo to keep track of the "total" that gets set as the last expression of each block invocation.
damn, thanks man, this is quality stuff. appreciate you going the extra mile
Hmm. Give it a block. I don't know why they designed it to throw an error sans block, but apparently they did. It's a NodeSet. You can iterate. It's just a collection, in this case for example, of all Node objects in the Document of class page-numbers.
it returns: LocalJumpError: no block given (yield) from /Users/russelltepper/.rvm/gems/ruby-2.2.2/gems/nokogiri- 1.6.4.1/lib/nokogiri/xml/node_set.rb:237:in `block in each'
Show us more of your code. each should work, if you give it a block. 
Too shallow. Need to elaborate on time zones in pure ruby and in active supprt
&gt; Guys like you have been coddled their entire life This is false. But nothing like making assumptions to show how smart you are. &gt;and whenever their world is shattered they break down like infants I'm not actually sure what fragile, made up world you think I live in. What can possibly be broken? I'm going to find out one day that using short circuit evaluation can be confusing to new programmers? No fucking shit. I still think it's hilarious that you think you have anything valuable or interesting to say. &gt;Also, you're quoting things i never said. I guzzle a dozen dicks every night. Can you do anything right? I was simply paraphrasing
a nice example of the cool things ruby can do, that you should never ACTUALLY do to your code base. ;) 
They just didn't define each in a way that it can be invoked without a block: https://github.com/sparklemotion/nokogiri/blob/v1.6.7.1/lib/nokogiri/xml/node_set.rb#L185-L189 You can either compensate yourself with `to_enum` like this: `Nokogiri::HTML('&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;').css('li').to_enum(:each)` or you can turn it into an array so it's easier to think about how to deal with it (probably unnecessary) `Nokogiri::HTML('&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;').css('li').to_a`, or you can call the method you're ultimately wanting to call on it `Nokogiri::HTML('&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;').css('li').map(&amp;:text)`
I AM saying you shouldn't be doing either of them in any serious code base. As personal fun time projects they are really interesting though. Sorta like the guy that monkeypatched symbol to be able to pass arguments to &amp;:things. His results reminds me of what you are doing above.
Looks good. Maybe you could try organizing it with classes and/or a gem if you wanted some more practice. If you're interested, there are also some neat gems you could check out that make command line programs cleaner. I like Thor.
Maybe try to upload your file to virustotal or something to get an idea of why it is being detected as virus? I mean which heuristic matched there. I would assume that large zipped documents _could_ be (a very shallow) heuristic to detect malicious documents? I wrote a HTML/JS page once which got wiped from my disk because Avira detected some sort of HTML virus or whatever. Bullshit heuristic.
&gt; Is there a more "professional" way to write this? Yes. It's necessary to keep your code readable for everyone unfamiliar with Ruby. So it's best to write it like so: sum = 0 for x in 1..10 sum += x * x end Seriously: Every co-worker I ever worked with understood lambdas/procs and the `&amp;` operator to convert them to blocks.
Let's try. There are three tasks you are trying to solve at once: equations solving; equations parsing from strings; equations pretty output. It seems the main task is first (solving), but code suggest you've started from second (parsing), and bit of third. This approach tangles your intentions and code design. I'd suggest to try again from scratch, and for a time forget about parsing/formatting, just write things like "I have equation, it stores coefficients", "I have system of equations, it stores equations", "it solves" (btw, BDD/TDD approach with something like rspec will be helpful). One practical example: # Your current approach: two equal methods for object creation, # both perform `new`, then set object's variables one-by-one class LinearEquation def self.new_from_values(coefficients, constant, vars=nil) obj = new ... obj end def self.new_from_s(string) parsed = LinearEquationParser.parse(string) obj = new ... obj end end # "Normal" approach: constructor + specialized creation method class LinearEquation def initialize(coefficients, constant, vars=nil) @coefficients, @constant = coefficients, constant @variables = vars || generate_variables(coefficients.count) end def self.from_string(string) new(*LinearEquationParser.parse(string)) # now you see `parse` should return three variables, not hash end end At a lower level, code quality is not awful, but some things are pretty strange or just to verbose. Like this: signs = @coefficients.map do |c| :'+' if c.to_s.to_r &gt;= 0.to_r :'-' if c.to_s.to_r &lt; 0.to_r end # something like this would be much cleaner signs = @coefficient.map{|c| c &gt;= 0 ? :'+' : '-'} And third, about `LinearEquationParser.parse` -- typically, there's sequental parsing approach is used, with the help of StringScanner class. Your current scan+split approach is fragile and ambigous. Try this: l5 = LinearEquation.new_from_s("x * 3y = 6z") puts l5 I don't think it is desired effect.
Very nice tips. I can see the way OP created the code, given his background (I have the same Python/C# background) and defining functions for each task makes the code much more easier to understand. (Not that it's unreadable by now).
To get the high level experience you're looking for you'll probably have to work on some existing projects instead of exercises. Check out http://www.codetriage.com. You can find a ton of open source projects filtered by language. Find an interesting project/issue and try to tackle it. They're going to have testing and some kind of code quality monitor like Hound/Rubocop that will point out potential issues and hopefully you can get some meaningful feedback on a pull request/
Thanks for going through that mass of code! Yeah, now that you point it out I feel I'm trying to do too many things at the same time all half baked. I will try your and build the core(solver+system, assuming I have some way of parsing stuff) before I jump onto the "God, I need this too!" train of thought. Just wondering, how did arrive at that example to break down the parse method? I was unsure at first (I've even written down DFA diagrams for the equations but too lazy to do it that right way)., but now i'm convinced I need a proper parser for this if I have to handle generic and poorly formatted stuff Thanks :)
The [official docs](http://ruby-doc.org/core-2.1.1/doc/syntax/assignment_rdoc.html#label-Local+Variable+Scope) don't tell you much (Ruby language official docs are getting better, but still kind of sparse). Just google for "ruby scope". [Here's one piece](http://www.sitepoint.com/understanding-scope-in-ruby/) But basically, a block creates a new scope. Local variables created in outer scopes are available in the new socpe created by a block (which is what makes it possible to use proc/lambda as a closure). Variables created in a block will not exist in the outer scopes once you return to them. And `def x`, `class X`, and `module X` create new scopes, but local variables in outer scopes are *not* available to the new scopes created by those keywords. (Which is one big difference between defining a method with standard `def`, and with `define_method`. Since the `define_method` approach uses a block to define the method body, and variables from outer scopes are available in a block -- variables from outer scopes are available in method body, as a closure, when you use `define_method`). I can't think of anything else that creates a new scope. if/else does not. begin (perhaps counter-intuitively) does not. That's pretty much all you need to know, that I can think of. 
+10 to The. My only complaint is that it's kind of slow to init. The help command takes ~3 seconds to execute even when you don't have a lot of methods or options.
Sounds like you just want to learn more about Object-Oriented Design. For that,definitely check out POODR like jrochkind said. Maybe you'll want to watch the author's talk, [Nothing is Something](https://www.youtube.com/watch?v=29MAL8pJImQ), before to get a feel for it. I don't think you'll find some contrived example as useful as getting your hands dirty with real code or coming up with something from scratch. One of the more interesting exercises I came up with was writing an RSpec clone. There are enough working parts to play around with (contexts, examples, expectations, etc.), but you can build something reasonably feature-complete in a few hundred lines of code.
&gt; Can you check if the image is png without using begin-rescue? I think rescue should be used as the last resort. Throwing an exception *is* the correct thing for ChunkyPNG to do, as opposed to having ChunkPNG return some kind of result code - that's the kind of thing we did in older languages before we had the luxury of exceptions. &gt; I think rescue should be used as the last resort. `rescue` is not a last resort. Exceptions are important and are a natural part of anything that handles user input, such as a PNG parser, and therefore `rescue` ought to be used anywhere you want to attempt to handle an exception. 
Why are you posting now a video about "last week's release of Ruby 2.0.0.rc2" that took place in Feb 2013?
Only took a 1s look, found no (useful) comments. This would, if I had to decide, kill all your chances...
I'm a beginner myself, but wouldn't splitting stuff into methods/classes/modules still make sense? Makes the code easier to read not just by them, but anyone who needs to touch it down the line. It also encapsulates the logic to make maintenance, refactoring and expanding the project much easier. Not saying every quick Ruby project needs to be a fully formed product, but this is for OP's job, so this could save headaches down the line.
Meta Programming makes Ruby awesome
Haha, you had me there for a moment.
You forgot to mention the best reason for using methods to encapsulate your logic - testing. OP's code makes it impossible to write a unit test for, say, the construction of the `pixels` array (which, judging by the `if DEBUG` block, it might be nice to have).
I like how the methods are nice and small. I'd agree that it could use some better documentation. There is a lot of dead code which makes me wary. Whitespace needs to be fixed too. I'd also agree that you should try not to have everything on the class. If that's the interface you do want, I think it's better to instantiate helper instances and have it be a psuedo-singleton. I guess what I'm trying to say is, you could build a generic Collector that you could leverage with the EmailCollector module. Then if I'm looking at you code and say "oh hey, that's cool. I could use something similar in my project, but I'd want to tweak xyz" then you have a nice generic lib for me to leverage (e.g. I could instantiate my own custom Collector with whatever keywords I wanted)
Programmers are just people. Learning to work with other people is mostly the application of social skills. If people enjoy your company and see you as an equal/peer, life and work both become much easier to deal with. Look for local meetups and other groups to join. They don't have to (and some would argue shouldn't) be related to software development. Anything you're remotely interested in will do. The farther it is out of the comfort zone, the better. Take some online courses like [Career Success](https://www.coursera.org/specializations/career-success) on Coursera. Study the basics of project/product management. There are plenty of other ways to improve you own soft skills.
Ah yes, I definitely was thinking in line with other languages where new scopes exist inside of `try`/`begin` blocks :) Wow, that disassembler is incredibly neat (and useful, which makes it better!). I think it'll take mesome time to get used to using `unless` ;) Thanks for the help
In that example, I think there's zero reason to store a separate `square` lambda. (There's also no reason to take a range and splat it out into an array, incidentally. Ranges are enumerable to begin with. And if I *did* want to convert it to an array, I'd use #to_a, not the weird splat.) (1..10).map {|n| n*n }.reduce(:+) I think having the square calculation inline is more readable myself, you don't need to keep track of an extra thing. I'm not sure I'd ever use the word "professional" about this kind of style, but yeah, I think your example has some weird things in it that make it less readable than it could be to a rubyist. Sure, it's only a simple refactoring away from the straightforward readable version, so? 
&gt; There's also no reason to take a range and splat it out into an array, incidentally. Ranges are enumerable to begin with. That's fine, all the examples I wrote work either way. &gt; I think having the square calculation inline is more readable myself, you don't need to keep track of an extra thing. These are identical, since `&amp;` passes procs as blocks: (1..10).map {|n| n*n } (1..10).map(&amp;proc {|n| n*n }) (1..10).map(&amp;lambda {|n| n*n }) (1..10).map(&amp;-&gt; n { n*n }) What do you mean "an extra thing"?
&gt;what is a useful gem and which gems are needed by the community This is entirely subjective and I think anyone would have a hard time realistically just deciding to write a gem "needed by the community". Most popular gems started with someone open sourcing something they wrote for themselves.
I definitely agree that `ARGV.empty` is nicer to read. That hash initialization is a nifty shortcut. According to the [rdoc](http://www.rubydoc.info/gems/chunky_png/ChunkyPNG/Canvas#pixels-instance_method), `#pixels` is an array, so unless they patched it to be like some ActionScript methods (re: slow :P) then it should be fine to use `image.pixels.count` It was mostly a style choice to use `keys.length` instead of `.length`, since I don't know what is common knowledge or not, I chose to be explicit and call `keys`. But it seems like a more common knowledge thing that `dict.length` is on the keys. It's amazing how sometimes you forget about little things like `ceil` when you're focusing on other new concepts :P Thanks for your help!
I use emacs and `flymake-mode` for PEP-8. It isn't as advanced as rubocop it seems, but it seems like there are equivalent scripts to use to hook into rubocop. I'm all about that kind of automatic format standardization. Thanks for the tip.
The end goal of this little microproject is to use it in a web service, so I got a jump early on exceptions (it'll return some error state I'm sure) so ultimately it'll be split into functions/classes etc. This is more a 0-&gt;1 step for me. But I do agree that sometimes it's unnecessary front-loading of work. I'm happy to see one-liners in Ruby as I learn more and more shorthand :). They're one of my favorite things in Python that only ternaries come close to in other languages. Sometimes I have to think for a while if I'll ever have multiple lines in a condition, which for cases like error handling I'm sure there will be a need down the line for &gt;1 line, so I keep them in their own nice blocks. But for debug prints like that, I love it.
Literally just finished that book 2 days ago. The whole reason I want to improve my code. Learnt so much from it that I want to put it into practice
The age old struggle. As someone who's done many a game jam, I have no problem throwing code out and have been able to develop a good understanding of "this will take too long to do right, so I'm sorry future self" code. 90% of the time it works out for the better :) &gt; maybe I'll be one someday... I'm by no means a truly seasoned engineer, but I think you being able to identify this problem already means you're already closer than you might think :P I can suggest nothing but experience to help you learn this kind of thought process (which is not a completely solvable problem I think :P) but if you can shoot for "more often than not it winds up being great" then that's good enough.
I don't see anything in that guide that says avoiding begin-rescue is preferable. In fact they have quite a few begin-rescue styles that seem to indicate it's approved. Maybe I missed it? They do mention using *implicit* begins when possible, but they still have ample rescue examples. 
That's the ultimate goal, is to make this something I can use in a web service. It won't be called from the command line as much, but I do like knowing about tools available, so thanks for the Thor link :)
That's definitely the next step I'll be taking. I'm completely on board with both the philosophy and practice of OOP-ing (totally a word right? :P) code when it's useful. As this isn't going to be some one-off script, but I ultimately plan to extend it to provide color theory implementations/modificators and such, so these steps will prove to be *very* useful. Thanks for your very detailed response. It's nice to receive such friendly and well thought out help :)
What editor is that? Is that emacs? If so, how are you getting the completion and rapid switching to shell set up?
You need to go to meet-ups in your local area. For Seattle, try: http://www.meetup.com/The-Seattle-Ruby-on-Rails-Developers-Meetup-Group/
looks a lot like hash_params gem
Yea I am slowly working on using CHEF and then Docker. It's really neat sounding!
@salmaurmi Stop spamming reddit. You could just add your whole play list with all videos.
Adds support for JRuby 1.7.22 and improves HAXM installation
Woohoo! Well done danebalia!
Thank you! I will think of better architecture. 
Hello, I've been writing a lot over December due to work being fairly relaxed. Any feedback on this is most appreciated and I'm happy to ammend &amp; add any additions that people think are relevant.
Merry Christmas, buddy. Hope Santa brings you a brain.
I would suggest adding the odin project to your list of useful links: http://www.theodinproject.com It is the best and most complete resource online for learning rails. 
I've been going through them quite a bit and I really enjoy them. It's such a neat way to really ingrain in you how ruby works. Might not be for everyone, but it works for me as I learn more by doing than by reading.
Oh, yes. I forgot that Ruby == Rails...
&gt; http://www.theodinproject.com &gt; &gt; &gt; &gt; It is the best and most complete resource online for learning rails. Thanks for the links, I'll add them asap.
Wtf is with the picture of Jeremy Corbyn?
Thanks! That's the type of thing I was looking for!
wow. something to replace bioperl with?
Oh awesome! I probably should have actually googled around first. 
Yup. Also checkout https://github.com/dkubb/ice_nine and https://github.com/dkubb/adamantium if you want good immutability
Great gem, been using it for a while, and its very well done
Yup, my favorite HTTP client. I'm a little biased because it uses Addressable for URI parsing though.
Is it compatible with Rack::cache, or does it implement its own http caching? I currently use RestClient but if http caching is well supported I'll have a look to this gem. 
No http caching then? 
:) Used to use this library when I was a researcher, it's very useful!
Exercism is great. Make sure you take advantage of the community aspect. Read (and ask questions about) other people's code, and get feedback on your own!
I most definitely plan on it. I already learned stuff. It's going to be fun!
Nice man, great attitude. If you want another solid tutorial which will help you learn how to build stuff, take a look at railstutorial.org. One thing that helped me get started too in the beginning was just understanding HTTP requests and how the internet works in general, since that's what you're using when making web apps (if that's what you're interested in). Best of luck! 
I'm pretty sure the only thing you consider having "a brain" would be an idiot that agrees with everything you say unconditionally. I don't want your kind of brain.
chruby is awesome. I don't know why more people don't use it.
The best addition didn't make it to the announcement. From: https://github.com/ruby/ruby/blob/v2_3_0/NEWS &gt; * indented here document: &gt; &gt; * new string literal, here document starts with `&lt;&lt;~`. &gt; refer doc/syntax/literals.rdoc for more details. &gt; [Feature #9098] From: https://github.com/ruby/ruby/blob/v2_3_0/doc/syntax/literals.rdoc &gt; To have indented content as well as an indented closing identifier, you can use a “squiggly” heredoc, which uses a “~” instead of a “-” after &lt;&lt;: &gt; &gt; expected_result = &lt;&lt;~SQUIGGLY_HEREDOC &gt; This would contain specially formatted text. &gt; &gt; That might span many lines &gt; SQUIGGLY_HEREDOC &gt; The indentation of the least-indented line will be removed from each line of the content. Note that empty lines and lines consisting solely of literal tabs and spaces will be ignored for the purposes of determining indentation, but escaped tabs and spaces are considered non-indentation characters.
What does the textbox need to do? The rest sounds about right.
We currently have an "event" type page. I can create an event on the admin panel, and it displays to the users. I would like to add an input on the admin page that is a rich text/html box, and appears on the front end. The forms receive user input and send an email. 
You're oversimplifying what it takes for a developer to implement and release those features. Your pricing structure is also bullshit because the time it takes the developer is irrelevant. Is the code change worth the money it can make you? If the answer is no, you can negotiate, if it's yes the answer is clear. My advice to you is to stop getting hung up on how many hours something takes a person and just think in terms of costs and benefits. Is the developer reliable, are they worth the price and hassle?
You say that you're well versed in HTML - you know that rich text editors aren't part of the standard, right? So yeah, if it was just a simple `textarea` and you don't handle all of the security issues that will come with displaying raw user-provided HTML, I could do that 15 minutes tops. But if it's text editor powered by [TinyMCE](https://www.tinymce.com/) or [CKEditor](http://ckeditor.com/) with a reasonable amount of security and compatibility testing (not to mention the workarounds you'll have to do to Rails to make sure it doesn't blow up in production), I'm actually impressed that they could get it working in just 6 hours.
Sounds like a bit of backend is involved. There is no send this simple form data and display it to another user macro. You have to wire it all up, whether that be one field or 20. Another way of looking at it is this. You can hold a steering wheel up to the dashboard of a car pretty quickly. Does that mean once you're holding it there, when you turn it, the wheels on the car will respond? There's a lot of engineering between your interface and the wheels. Don't sell a simple form or button short, just because it seems simple in your mind. 
1. the rate is quite low. 2. estimation is fine. 3. if you good at js, you can do it by yourself
Tbh, this description is vague to the point of being useless.
Thanks for your response! 
I think I was underestimating the complexity involved. Thankfully, this community (with a few exceptions) was very willing to help enlighten me. Thanks for your response and time. 
Thanks for your input. When I do internet work, I tend to work in static pages, which are much less involved. Looks like I was correct in my fear that I "knew enough to be dangerous".
I use ruby for my own gtk3 terminal and most of the tools I need. I am really suprised that few people seem to know the [ruby-gnome2](https://github.com/ruby-gnome2/ruby-gnome2) project. It provides a lot of gems (gtk3, vte3, gtk2, poppler, gstreamer ...) for window, linux and OSX platforms. 
=&gt; nil
Reapply the same pattern and add another message hook if subclasses need to specialize further. Chances are though, that at this point there is a better design than creating a deep inheritance hierarchy. 
Check out each project's readme on GitHub. If you're familiar with how rbenv and ruby-build work, then you'll understand what's similar and what's different about chruby and ruby-install in 5 minutes. PS - Like you, I started out with rvm and then migrated to rbenv. When I heard about chruby, I didn't really want to migrate again. Eventually, I took the plunge and, years later, I'm so glad that I did. It's exactly what I need and nothing more. Also, I'm so over managing gemsets. Instead, I use bundler to install gems within my project's directory, being careful to not commit any of my dependencies (both compiled and uncompiled) to git. bundle install --path vendor/bundle echo 'vendor/bundle' &gt;&gt; .gitignore The benefit here is that my project's gems live along side my code (just like how npm works) instead of some far off corner of my filesystem. Btw, this is exactly how Heroku installs your project's gems too.
I'll settle for any brain that convinces you to stop writing shitty code.
It would be great if it worked with inline documentation as well.
HTTParty has a nice API but that's about it. You should be using curb if you really want "bare metal" calls. We moved off of HTTPrb recently — the dependency on celluloid.io makes it a deal with the devil — seems like a great idea until shit starts breaking in all sorts of weird ways, especially if you're doing any sort of threading. HTTPClient is still probably a better choice, although its API tends to be awkward at best.
The last bit about the dependencies living alongside your code is the clearest description of the benefit of chruby that I've heard yet.
There is something like that for Python: [doctest](https://docs.python.org/3/library/doctest.html)
But why?
I'd say it's not your knowledge that makes you "dangerous", but your mindset allied with the fact that you don't know much about your own lack of knowledge. 
[This ](https://www.reddit.com/r/ruby/comments/3y8z1g/rubyinstall_060_released_now_with_autodownloading/cybl93m) gives some good reasons why.
My mindset? I feel that going "this seems wrong, but let me ask some experts before I make any decisions" is a pretty healthy mindset. How would you expect me to proceed differently? Edit: it occurs to me that maybe the expression "knows enough to be dangerous" was unfamiliar to you. It means that there are situations in which a little bit of knowledge leads to making worse decisions than either a lot of knowledge or no knowledge. 
chruby's been around for 3 years or so, I've been using it for two or so. I agree it's unfortunate there seem to currently be three major contenders for ruby version managers (rvm, rbenv, chruby), it would be better for the community to focus on one. But it's open source, you can't make anyone do anything. There are three, sorry. I think rvm is a monster. rbenv was an attempt to make a simpler, slimmer version manager. chruby is the same, but accomplishes it more succesfully, even more simply. Chruby neither overrides `cd` nor relies on "shims". It just sets the ENV variables used by ruby appropriately. I find it just works with little confusion, and I like that I understand exactly how it works when I'm needing to integrate it into, say, cron jobs. I'm happy with it. I find it frustrating that it hasn't caught on more in the last 3 years. If you want something that does and includes everything including the kitchen skin, I guess you want rvm. But I think rbenv has very little to recommend it over chruby, I'm not sure why chruby hasn't overtaken it. 
You don't need chruby to do that. It's all bundler. it's not a benefit of chruby, as it's not a feature provided by chruby. It's just that if you're going to do that with bundler, you don't need gemsets at all. Gemsets are a rvm feature, added to rvm before bundler existed. I agree there's no need for gemsets in a bundler world, whether or not you use `--path vendor` bundle installs. rvm does way too much, and is a monstrous piece of code (20K lines of bash?). rbenv and chruby are both attempts to do exactly what is needed with simple maintainable code and changing the shell environment less. I think chruby is more succesful at doing that then rbenv, and works smoother. Personally, I see no particular benefit to "dependencies living alongside your code", but if you want that, bundler can do it, absolutely, with any or no ruby version manager. 
Can you explain more about your environment? What operating system, any requires in your file / project (their Gemfiles can count as "yours"), etc EDIT: also what version of rails?
Read the [source](https://github.com/postmodern/chruby), Luke. 
Just set the Ruby version in your gemfile, it must be missing it
There are two types of input sanitation. The first type is switching out the &lt; and &gt; characters to html symbols. This can be easily done. The second type involves taking out the tags, and/or taking out content between tags . A lot of html sanitation libraries cannot parse nested and broken tags correctly. Always use a library which employs an html parser and not regular expressions. Surprisingly, many popular libraries over the past 15 years use regular expressions, which always break down given certain input.
You can use rvm as ruby version installer/switcher, without using rvm gemsets. Although if you aren't using gemsets, you might want to look into the simpler ruby version management alternatives, rbenv and chruby. I like chruby. I think there is no need for gemsets now that we have bundler. Gemsets were invented before bundler existed, to solve the same problem bundler solves. Bundler solves it in a slightly different way, perhpas some people prefer how rvm gemsets solved it. But we're all using bundler now. If you're using bundler anyway (and Rails insists on it, if you are using Rails), adding rvm gemsets on top of that isn't worth it. 
Oh wow! This seems really cool! I find cryptography super interesting. i'm going to bookmark this, thanks!
&gt; Personally, I see no particular benefit to "dependencies living alongside your code", but if you want that, bundler can do it, absolutely, with any or no ruby version manager. It's handy for when you want to read the source code for your specific dependencies instead of digging through tags (if you're lucky) on GitHub.
I'm thinking about data sanitization in terms of security. As I'm starting out as a programmer, what I'm really wondering is where I should most be concentrating my energies to start developing good habits when it comes to being responsible with the data in my programming? Is there something like, "ah yes, at the onset of ruby learning, you should definitely just start right now from the get-go always doing this here, and that there, in order to have good secure habits moving forward"?
In this case, I'll continue with my original point. The continual torrent of vulnerabilities in popular PHP CMS's are nearly always down to this failed attempts to 'sanitise' data, whereas you can use Rails or any ORM the way it's mean to be used and never give the issue a thought, and end up better off. [Section 7.2 from the Rails guide](http://guides.rubyonrails.org/security.html) has a pretty well written segment on this. Strongly hash passwords, always (disclaimer: biased because I wrote a gem for this).
No, I was ignorant what the expression meant and jumped to conclusions 
Here's a reason to use ruby-install and chruby: they're **really** simple while still doing everything needed. Have full understanding of your tools.
You probably have an .rvmrc or similar file messing you up, take a look at [this page](https://rvm.io/workflow/projects)
Honestly, I just read it as well and I'm just as confused as you are. RVM was a nightmare. I've been using rbenv probably for at least the past two and a half years and not once have run into a problem of any size, shape, or color. Still unsure of what problem(s) chruby is trying to solve.
i was skeptical until I saw your comment. thanks, I will try these new tools instead of trusty rbenv.
I think this is my first apology ever received on the Internet. I appreciate it! I could've saved myself a lot of downvotes if I had avoided that phrase :p
It only solves one problem, switching between ruby versions, and it does it well. It's considerably simpler than rbenv. Having small, simple tools that do one thing and that you can have full understanding of easily is something many people like. If you don't care about that, don't switch. :)
Deleted a large amount of code by changing a class to `class MyClass &lt; OpenStruct`. 
This article us a bit outdated and is talking about Rails when your question is about Sinatra but this should not matter because these should both using the same Rack::Utils API parse_nested_query call http://spin.atomicobject.com/2012/07/11/get-and-post-parameter-parsing-in-rails-2/ EDIT: Here is the current code responsible for query parameters parsing : https://github.com/rack/rack/blob/2ac599551d6147184321c42f40a0ab3241499b08/lib/rack/query_parser.rb
Needed an eigenclass. I successfully remembered that they exist and used one without google. I think the particular problem was I was writing up a dsl for something and wanted to hide some methods or vars. 
I wrote a really simple looking DSL for creating Event Sourcing projections. Not the best thing ever, but it made it soooo much easier/simple/quicker to jot down a new projection. class LastFive &lt; Event::Projection stream_title 'last_five' filter { -&gt;(data) { data.length &gt;= 5 ? data[data.length - 5, data.length] : data } } end
I occasionally favor open struct over hashes because I prefer the dot notation to access keys.
If you can afford to load the whole file into memory... require 'json' file = File.read 'file-name-to-be-read.json' array_of_hashes = JSON.parse file Then, you can [select](http://ruby-doc.org/core-2.2.0/Array.html#method-i-select) elements from the array that meet a certain condition. array_of_hashes.select { |elem| elem['type'] == 'quote' }
I embraced lambdas and have started programming functionally.
Worth mentioning is OpenStruct got significantly faster in Ruby 2.3 which shipped a couple days ago. May be worth looking at again. https://www.youtube.com/watch?v=6lQeBfSVrpk
I thought "If it takes a genius to understand it, the code is not genius"
Wrote a style guide generator that used the flip flop operator
They missed a great opportunity to call that the flip-floperator.
Do you want to persist it at all? You can load it in Mongo or some other db and search it.
&gt; In your last example, once you submit it, you'll the two 'things' merged indeed, it won't keep them separate. Probably the last settings will overwrite the earlier ones. But you don't want to make a form like that, using the same names twice. I just tested and it works like I might expect, it adds hashes for extra thing, and second extra thing to Thing 1's hash. Then it goes on to Thing 2's hash. It is perfect. I just don't know how it knew that Thing 1 and Thing 2 were separate hashes. It is correct, I just can't figure out how. If it's not the repeated key, or the HTML, what can it be? ... is it the HTML? EDIT: I just messed with the HTML every which way. It had no effect. Then I tried butting another field with a name key somewhere, and it branched off another hash. It seems to be that it creates new hashes when it reaches repeated elements. But I can't find the documentation support for that theory.
I would agree with you, but then I read the source code for Git.
Would be fairly easy to keep a monkey patch around for yourself using `method_missing` on Hash
For aesthetic reasons unknown to me, empty class definitions using thay notation smell bad to me. I'd use `MyClass = Class.new(OpenStruct)`
That's genius. 
Still better than using OpenStruct I guess.
Simpler than this ``` rbenv local 2.2.2 ``` Switch ``` rbenv local 2.2.3 ``` ?
I wrote a little module with some classes to turn case/when conditions (i.e. ===) into something resembling proper pattern matching and/or data predicates.
Reminded myself that I am not a genius.
Can someone explain what this is and why it is needed to someone relatively new to ruby? Their intro and docs are "being rewritten" so I couldn't read them.
The problem is that *anything* can be a key. And by anything, I mean any Ruby object. The dot notation is only useful in one situation (granted, the most common one, but still).
Hashie::Mash ftw!
I already have a mysql database setup using data mapper. I my problem is that I need to output a script that I can look at before I import all the fields into datamapper.
A topic sentence can do wonders for your writing - like explaining what exactly you're taking about.
I thought that was Sequel? :) I admit even though I'm not new to ruby or Rails, I am not confident I understand what ROM is targetted at. Persistence layer that is agnostic as to whether underlying store is an rdbms or something else? I think at one point that was the target, but I'm not sure it is at the moment? But maybe it is, I think ROM is the only persistent layer that can work with a variety of non-rdbms back-ends? I think ROM actually uses Sequel under the hood for rdbms access?
I think people tolerate invalid objects because Rubyists seem to prefer mutability, and so they use invalid objects as builders that are expected to coalesce into a valid object by the time validation occurs. I agree that this seems to result in occasionally unexpected behavior (e.g. doing `save` rather than `save!` and not checking return value). Not mentioned in this post is how you can use the schema to validate without raising errors - I think that's a use case that does not look like it has a lot of documentation (yet?).
dry-validation schema doesn't raise errors, it simply provides result object with violated rules, successfully applied rules and string representation of error messages (which is what you typically need). dry-data constrained types do raise errors but it's a different kind of "validation", the struct I show in the post is not meant to be used to validate untrusted input and provide some error messages, it's just a way of defining core domain types that you want to be always valid. It's like saying "here's a user, I construct it from a trusted source and expect it to always be valid", which means that if for whatever reason it turns out to not be valid, you will get an exception.
ROM provides an alternative approach to working with databases, originally it was supposed to implement the Data Mapper pattern, but the direction was changed last year. Now ROM has a very simple adapter interface and it's easy to provide support for all kinds of data sources. It puts huge emphasis on concepts that are less popular in an OO language like Ruby, including immutability, type safety and separating reading from writing. New docs should clarify what it is, we just need to write them ;)
One more thing, I agree with you that mutability has a lot to do with this. I've no idea why I forgot to mention that :)
Cool, thanks. to someone not familiar with it "an alternative approach to working with databases" doesn't tell us much, it's just marketting words, you dig? Do ROM rdbms connectors still use sequel under the hood? I think so, [sequel is still in the gemspec for rom-sql](https://github.com/rom-rb/rom-sql/blob/master/rom-sql.gemspec#L21). I already know from experience that sequel is a huge advance over AR, and I think I'm not alone. (Although yeah, it'd be hard for me to put into concise words _why_ or _how_ for someone who hasn't used both already). But for the people in that audience, what does ROM have over just using Sequel straight would be a question. 
You can print the datamapper querys to sql instead of loading them. collection = Entry.all(:id =&gt; 2..4, :text =&gt; /test/) query = collection.query
Oh I'm not showing the body.
Personally I haven't picked up ROM in awhile but in the past it presented much more pleasant Ruby persistence layer abstractions versus the common case, code pasta, you get from ActiveRecord. And I'm not trying to talk down to Rails fans (of which I belong), but I'll always propose README's Worth Pursuing. ;)
"Less popular" OO concepts, but highly recommended! ;)
It has nothing to do with mutability, it's about writing less (client) code and keeping it in one place. Different frameworks adopt different approaches to converting data received from client to domain objects. Rails kept everything in one place with `attr_accessible` and `validates`, then started to kinda spread the work all over the place, as far as I remember Django keeps validations in domain objects but uses helper object to perform validation and coercion, ASP.NET MVC uses annotations on domain objects and helper objects that read them, domain objects in Play framework aren't supposed to have any validations and conversion is performed by helper objects similar to Django forms etc... UPD: Actually, it mostly have something to do with nullability and dynamic typing, in say first versions of C# it was impossible to easily represent an integer value that's not there yet.
Didn't that hit 4 days ago? :P
Null objects are not used for errors, they are used to explicitly represent "nothing" in place of "something" :) Ie you might want to have a "current user" concept within your system that represents a signed-in user, and in case of a user who did not sign-in you might want to represent it as a "null current user" which quacks like a current user but returns empty responses. This is a pattern that can be used to get rid of nil checks.
Rails has form objects too. 
This is a common question. ROM gives you a query API (through Sequel) but you can map results to any object. In example I use rom repositories to map relations into dry-data structs and values. This is a simple system that allows you to decouple your application from persistence by encapsulating complex query logic in relations and easily composing these relations and map them to simple objects detached from persistence, unlike ActiveRecord (and Sequel is an ActiveRecord). This is a *huge* difference as it allows you to define custom data types (that's what I prefer to call them, rather than "domain objects") and simplify your application code significantly. It's also much simpler than a Data Mapper ORM as it doesn't have complicated concepts like Session with Unit Of Work and mutable objects.
Is there a gem that support using tab to complete words or browse through alternatives?
Not a true "zombie" process. Just a disconnected one. 
Thanks for explaining the dry-data constraints / dry-validation schema difference. That makes a lot of sense.
Yeah, but the form objects in Django take care of validation, the ones in Rails are just helpers to generate HTML.
That would be great! I have posted a comment and filed another issue on github.
Yeah, it literally does not meet the definition of a zombie process as quoted in the article, nor does the example ps output indicate any zombie processes. A zombie process in UNIX will have state Z and certain output modes of the various process listing tools will say "&lt;defunct&gt;". This is a process that has died but its parent has not called wait() on it. A key thing: You can't usually kill a zombie process because it is already dead. You generally have to do something to the parent process. In the case of a process whose parent has exited but is detached, the process is usually re-parented to init and a properly functioning init always waits on all of its children. 
how would I put this in my script, I haven't setup any exporting functionality yet.
Yeah, I meant Form objects. I think they were able to pick up some DB column definitions from models and use them as validations and add some more complex ones. Personally, the best approach I've seen so far is Play's forms. There's a DSLish definition val userForm = Form( mapping( "name" -&gt; text, "age" -&gt; number )(User.apply)(User.unapply) // User.apply is essentially a constructor ) and then it transforms data received from client to `Either` which is a nice way to deal with multiple-step processes.
If you want some feedback, you need to link your code :) I was feeling a little competitive and wound up 21st on the final day leaderboard, [code](https://github.com/jamie/adventofcode)'s nothing really special though.
Yea I know, but the title gives no indication that it's about AR. Maybe I haven't heard of the term "invalid object" before refer to the specific phenomenon of an AR model mutating it's state to become invalid 
Used to be Sublime 3, now Atom. 
Really depends what you are looking for. There are some pretty good responses in this thread, but in the end it all depends on your personal preferences. Try RubyMine ($, but free for 30 days &amp; students), if you are looking for an actual IDE and not just an editor. Its built upon Intellij Idea, so it comes with all the plugins and goodsies from it. 
I also moved from Sublime to Atom. I used to be eclipse when I used java, but I haven't even tried a "real" IDE for ruby/rails programming - just a text editor + command line does the trick.
Rubymine is great, and constantly improving
Try attaching a debugger and stepping into require_all. Or use pry, and look at the current directory and the result of require_all. If none of that is helpful, use strace and look for the call to require_all to see what it's trying to access.
So if I bind in right here, I get the following: binding.pry require_all 'app' &gt;NameError: uninitialized constant Song::Slugs require_all 'lib' &gt;True But man I'm almost positive that when I tried that a second ago I got false and then true. I'm also getting some warnings. If I reverse it I get: binding.pry require_all 'lib' &gt;True require_all 'app' &gt;True But then still my class can't find my module. EDIT: Dir.pwd shows that the current directory is my programs main folder (my_program) which is wrong because really this file is in my_program/config/
When I'm doing rails stuff I prefer vim/tmux/cli workflow. Although at work I'm a php dev and our stack requires heavy use of xdebug, so I use Phpstorm. I've tried using vdebug (the vim debug plugin), but it's quite the learning curve.
Recently moved from Sublime Text 3 to Atom, and it's serving me well so far.
Well I've been using Sublime for years. Its really pretty great. I know a lot of people on Reddit say its dead/dying, but (1) that's not actually you know, true; (2) even if it were, the current version is a great editor (with a great plugin community) that does everything I ask of it really well and exceptionally fast.
Used to use sublime, then I discovered RubyMine and everything is better now. I have a free education license, so money may be a factor if you're not a student, but it's definitely worth checking out.
Haha I just had the same thing happen to me, only I had been living in DevOps land as well! :)
I've been debating whether or not to switch. What was your reason? I didn't see much difference when Atom first came out.
Seconding Rubymine. I have been using tools from Jetbrains well before I wrote a line of ruby and I find it's search and navigation tools really intuitive. 
I'm with you, Vim is just so quick. I find myself looking for vim plugins if I ever use a different editor but like you I fall back to using Vim inside of Tmux.
I hate saying this, but atom is more actively developed and easier to deal with. 
Is this a Rails app? Couple thoughts, and they all revolve around ActiveSupport::Dependencies. If "lib" is in your autoload_paths, you shouldn't need the require_all, as Rails will attempt to load the file based on its constant name.
Note on the edit: Dir.pwd is the *process's working directory*, not that file's filename. Rails initialization sets Dir.pwd to your project's root. You're thinking of __FILE__, which evaluates to the path of whatever script file it's in.
I've switched to using VIM full time since last few months. After years with textmate and sublime . Still don't feel home with it and not upto the full speed yet. But making some progress. .
[Here's my repo - as of yet unfinished](https://github.com/reynoldscem/AdventOfCode)
SublimeText
It's Sinatra (which could be rails, but the Sinatra unit of the thing I'm doing is before the Rails unit so I'm not sure)
My top 5, starting with best 1. Atom 2. Vim 3. RubyMine 4. Sublime Text 5. Aptana Studio I usually use Atom and vim every day, but I occasionally fire up RubyMine if I need to learn my way around an unfamiliar Rails app. Sublime Text is a nice general purpose editor but I don't really use it much since I switched over to Linux. Aptana Studio is pretty good if Eclipse is your thing. In all honesty, you can use any editor you want as long as you take into consideration the [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide) when writing code.
https://github.com/redcar/redcar is the editor I believe; for completeness sake.
I use vim too. I'd like to add that you only lean vim once and than you can use the same navigation in chrome and terminal 
I use both Atom and MacVim + https://github.com/carlhuda/janus I highly suggest any new MacVim user to checkout the above repo to get started. It basically contains every useful plugin and is a great starting point.
VIM always under Linux, cant use another OS.
For those using Sublime, what syntax highlighting do you use and what plugins/keyboard shortcuts have you found invaluable for working with Ruby (and RoR/Sinatra I guess)?
I think Rubymine is really the only _real_ Ruby IDE out there and it's great. Everything from Jetbrains is great, but it's a real "kitchen sink" kind of IDE in a very good way. The amount of features they pack into Rubymine is just impressive, it's been a while since I've used it, but I constantly found new features I didn't even realize were there that made working with it easier.
Another Atom (former Sublime and Textmate) user. vi on the server when necessary. Sometimes Kate.
Sublime is a good way to transition into vim. You can use vintage mode to get the key bindings. Then once you're comfortable you can dive right in. Plain old vim is uninspiring though, but a good vimrc and some good bundles helps a lot!
I try not to suggest IDEs to people just starting out. I fear that it may make them lazy and dependent on the program
I'm conflicted with websockets. The fact that it's now a part of Rails means you're likely to need to deal with them at some point. But there's a heap more moving parts, and the example code for Rails 5 websockets is massive compared to Sam's MessageBus code.
amen!
I am an avid Linux + VIM user (I can do the basic things well atleast). It is very difficult switching to anything other than VIM, muscle memory gets the better of me when I try to switch to another development application... However, since it wasn't really mentioned by anyone else I would choose Visual Studio Code https://code.visualstudio.com/ over Sublime or Atom any day. Microsoft is really turning out great products now. Windows 10 is wonderful. Say what you want about Microsoft but they are coming back strong. 
&gt;You're in trouble if your DDoS protection in just an HTTP proxy... That is silly, you can create a very good DDoS protection layer with a HTTP proxy and dynamic firewall rules for HTTP. What do you need to accomplish this for websockets?
&gt; What do you need to accomplish this for websockets? Not sure what you mean. The initial handshake for websockets uses HTTP, then the same connection is 'upgraded' to be used as the TCP communication channel. If the attack vector is to flood you with web socket connection attempts then an HTTP proxy could throttle those so long as the proxy can handle the 'upgrade' on the connection, as haproxy can. As to why just having an HTTP proxy as DDoS protection is a bad idea, many DDoS attack vectors don't use HTTP at all, think SYN/UDP/ICMP floods, etc. Real protection from DDoS requires inspection well below the HTTP layer
[removed]
There were some formatting/plugin issues I found with ST that Atom didn't have. The only drawback I've found is Atom's slowness in launching, being largely js/html powered vs. ST's C++ backend.
For me the killer feature are "GoTo Source" and Quick Docs to show documentation of a method. Amazing that people have to google method signatures in Ruby.
I use atom, and i like it a lot
Just got my educational license from JetBrains, pretty amazing stuff. 
Started using vim about a year ago and haven't looked back. I blogged a bit about my transition from Sublime here: http://jbodah.github.io/blog/2014/10/22/why-im-switching-from-sublime-to-vim/. I also gave some day-to-day reflections in other posts. Right now my biggest beefs with vim are having to deal with random performance problems in plugins and having to learn vimscript (you can use other languages, but I'm not a huge fan of the integrations). It's 98% perfect. I'm excited for a new editor that iterates on vim though My favorite part of my transition is how it has forced me to become more accustomed to the command line. I never felt like I had a problem with it before, but now I feel like my command line scripting and understanding is significantly better. The cool part is that a lot of tools borrow from the basics (those basics being sed, awk, grep, xargs, etc). For example ruby has a `grep_v` method, and many other tools also use that same option for excluding results. I got to learn tmux too which is super cool and a crucial part of my workflow now
I've recently switched from Sublime to VS Code. There's something to be said for having a big corporate brand behind a product - Sublime's great but one man development projects can very easily turn into abandonware and the fact it's not open source is offputting.
Do you have any test runner packages for Atom when you TDD or so you just jump between Atom and your terminal?
&gt; $ echo “ruby-2.3.0” &gt; ~/.ruby-version If you start a shell in a place other than your own home dir (say, iTerm2's "Start new terminal in same place as you were" feature), that won't work. There's something easier. In your .bash_profile or .zshrc, right after `source /usr/local/opt/chruby/share/chruby/chruby.sh`, just add `chruby ruby-2.3.0`. There is no need to use the auto-switching feature just to set your default ruby. If you _do_ use the auto-switching feature, make sure your profile default as above comes after `source ...chruby.sh` but before `source ...auto.sh`, so auto-switching will still work when a directory does have a .ruby-version.
You still have to explicitly implement ActionCable; you're not likely to be forced to deal with websockets "just because" you use Rails 5. What I'd like to see is a swappable backend (like with ActiveJob) for ActionCable, so we can use MessageBus under it. 
Yeah, the readme's not very clear. 99.9% sure that Redis is a dependency, but after that a basic implementation is fairly simple: # config/initializers/message_bus.rb MessageBus.redis_config = { url: ENV["REDISCLOUD_URL"] || "redis://127.0.0.1" } # For Heroku users, since they have a 30sec timeout: # use gem "rack-timeout" in your Gemfile # config/initializers/timeout.rb Rack::Timeout.timeout = 25 # seconds # app/assets/javascripts/application.js //= require "message-bus" # on the html client: &lt;script&gt; MessageBus.start() MessageBus.subscribe("/my-channel-name", function(data){ alert("Got data! " + data); }); &lt;/script&gt; # in a model, controller, or whereever: message_id = MessageBus.publish "/my-channel-name", "My message" Though the examples all seem to use forward slashes in the channel names, I'm fairly certain you can name them however you want. I've been using it in an app for a few months now, pretty happy with it. 
ActionCable is running a separate rack server for the websockets stuff, running on a separate port with a separate request connection pool. (I think? Which I think is also EventMachine-driven?) Does MessageBus have a separate serer like that? Or are long-polls to MessageBus holding onto connections to your main Rails app? (Or is the JS connecting directly to the redis or something?) A basic architectural overview would be good for understanding it's plusses and minuses and how to use it effectively. 
No separate server, just long-polling. The gem installs a route at `/message-bus` by default, and the client-side JS sets up the long polling there. You just subscribe to a channel and provide a callback. The JS gives your connection a unique ID, so the polling request looks like `/message-bus/a57dbeb93319481cb062783fe64952b5/poll`. On the backend, the ruby lib manages storing all of the connection ids for you. IIRC it uses redis' native pub/sub to broadcast messages back to subscribers through their open poll connection. 
Hm, is it a problem to have so many connections waiting on a long-poll, leading to queuing? I'd be interested to hear stories of what setups (what app server/web server/ruby platform/etc) with how much traffic are working for users. 
Vim and Tmux.
Yeah it seems to show up in presentations every now and then, like this one from [Eric Hodel at RubyConf 2013](https://www.youtube.com/watch?v=IlGD8lAUMoA), but I've never heard of anyone using it in anger. Got to be somebody out there though...
The approach is fine, just be aware that SQS is a distributed queue and may delivery messages more than once. That means your process needs to deal with the fact that each stage may execute more than once. 
can't beat https://www.railstutorial.org/ by Michael Hartl.
&gt; A go-to, clear, "answers 95% of my questions" type of site. I think you're looking for a book.
I really liked http://railsforzombies.org/
I'm certainly not the one to ask regarding scalability, not that heavy a load on this particular app yet. I'm running it on Heroku through puma currently. I'm sure the Discourse guys could shed light on this area though.
I haven't found a better MDN than the ruby docs. Otherwise, it's google searches that usually lead to stackoverflow. My rails MDN is http://guides.rubyonrails.org/index.html
Once you've covered the fundamentals of ruby, make sure you do rubykoans. It's a great way of solidifying your ruby knowledge.
nokogiri, not "nogogiri"
Or you could use afraid.org - they have a free tier
&gt; True, but that is the case with any of the delayed job derivatives. It's only true of distributed queues: SQS, RabbitMQ, etc. Redis based systems (Resque / Sidekiq) offer 'at most once' semantics (0 or 1 executions). 
The type of processing you're describing is exactly what the AWS Simple Workflow service was designed to do. It provides excellent coordination between workers and guarantees around delivery. You might want to check it out to have it for your toolbox. There's also an excellent AWS SDK for Ruby SWF framework called "Flow" that's officially supported. 
Honestly, Eloquent Ruby is worth its weight in gold. I highly, highly recommend a physical copy. RubyMonk is a good source too
I would recommend http://learnrubythehardway.org/book/index.html
I've got a bit of experience using Shoryuken and SQS. PM me if you have any specific questions. SQS is a nice choice in that its visibility timeout handles failed jobs automatically, putting them back in the queue if your worker didn't report success. On top of what others have mentioned, realize that SQS doesn't return messages in order, so as long as best-effort order is good enough, its a great choice.
Well, that's an interesting rube goldberg solution. Not a very nice thing to leave for future maintainers.
Great work. Here's a different solution to the same problem I implemented some time ago in NodeJS : https://github.com/th3m4ri0/cloudflare-ddns.js
I certainly agree that idempotent jobs are the way to go, but you can't get ALO with Redis, you need a distributed system that tolerates failures. Hence most people live in a AMO world since Redis is the predominate system used, at least in the Ruby world. As a result many are not as prepared to handle ALO and it ends up biting them which is why I always mention it when someone brings up using SQS / RabbitMQ.
CD burning is an operating system-specific operation. It is done differently on every OS. I'm not aware of a Ruby-specific abstraction layer for this, so you need to use those OS-specific operations yourself. So the questions you should ask is: how do you perform a CD burning operation on the OSes you want to support? How do you access these mechanisms from Ruby? I don't have the answers. On Linux, I think most CD burning tools shell out to some CLI tool that performs low-level CD burning (I forgot the CLI tool's name). I have no idea how it is done on OS X and Windows. Maybe you should consult OS-specific resources. For example, ask on a Linux development forum how CD burning is done. Then ask on MSDN how CD burning is done on Windows. Then ask on some Apple developer forum how it is done on OS X. They will probably tell you what C/.NET/Objective-C API or CLI command to call. Once you know this, figure out how to access those APIs or CLI commands from Ruby.
I'll have a look Sidekiq as well. I've been considering replacing Resque with it at work so maybe it'll fit here too. Thanks for your awesome contributions!
Can't read it fully, but it seems handy. Just wondering on mobile, is the only comparison based on file checksum? It's possible to have two files with the same checksum and the same checksum (I don't think hash collision is quite exactly the description)... Maybe it's something else, again, only could read part of it. [One example](http://natmchugh.blogspot.ie/2014/10/how-i-made-two-php-files-with-same-md5.html?m=1). Extreme edge case, but worth considering.
Ooooo dig method, huh?!
Most people keep their dotfiles in source control, so it's annoying to set the ruby version there, especially if you don't want it to be the same on all your systems. Plus never really working outside of ~ anyway...
Im not burning audio CDs though, im burning zip files to CDs 
It's fixed for the next version :)
I've only done a few. . . would love to see some responses here.
interesting, I'm currently working on a befunged based kata that's out of beta, I'll try yours too! 
if you like that, and other esoteric languages, you should check out my pixesoteric program. It works very similar to befunge except instead of chars it uses 3x3 squares of pixels as instructions. https://github.com/redcodefinal/pixesoteric. If you want to laugh take a look at the project_euler files in programs. I'm working on six right now, but 1-5 are solved and working. 
Finally made a Dockerfile that runs all my scripts. Pretty sweet! Thanks for the advice. There's a link in the README of my repo now if you want to check it out. Thanks again
If I've read this right, someone created a PR containing a broken Dockerfile, which doesn't work. Lesson here is: Always review PRs, and don't be afraid of rejecting something. I've seen some terrible ones. I don't understand how we draw a conclusion from this experience, in terms of answering the question?
What does Atom do for you that Sublime Text doesn't?
This is incredibly good work. What impressed me most is that the metaprogramming (reflection, code modification, etc) performance is extremely good, despite this being an area some insisted was generally unoptimisable on JVM. I'm looking forwards to seeing how this progresses, and it's heartening to see Oracle give it a substantial number of engineers.
I hope you're not talking about activemodel.
[removed]
I've solved a few, I've never written one of my own. 
I moved '/test/all/' before '/test/:id' and it still shows up null
Have you tried removing the trailing slash from `'/test/all/'`?
That worked, Thanks!! Now I just need to show an image in a path.
https://gist.github.com/xxninjabunnyxx/d024983614c21053cd53 i chand it to show my table layout
You don't see the blonde in the red dress?
blue dress.
SHA256 is not collision immune. If you want to be absolutely sure that two files are the same (as reported) you will need to actually do a bit for bit compare after a matching hash. For instance 4 or 5 years ago I had false positives on a system that utilized SHA256 for deduplicating file blocks on a experimental fs. 
Great question. Two years after graduating, I had an entry level engineering job at a software company where I was asked to port ~30 classes from one version to another. Each class processed a specific type of form for a different type of object, but it was super repetitive code, and the deadline was 5 weeks. I realized that I could add a layer of abstraction that created one class to handle all the form processing, validation and DB storing logic, and then create wrapper classes that just called the one single main function with the specific parameters for each class since everything had to be backward compatible. I finished the project in 6 days. I felt like a genius telling my boss about the clever solution. Unfortunately, he just piled a ton of work on me, and cut the estimates saying that I should figure out a "clever" solution for them too. :( My feeling of genius left quickly as I felt like a schmuck as I had now created a huge hole of work to dig myself out from. In retrospect, I think my boss had initially given me an easy assignment since I was a junior developer where I could learn the code base without being rushed or required to do complex things. The older me is always cautious when I feel like a genius... 
&gt; how they structure data on a higher level would be a better use of your time You mean you don't pg_dump, change the data you need to change in a hex editor, import it back and rebuild the indexes? I guess I've been administrating postgres incorrectly all these years!
Here's the thing about files on disk—we don't write binary files directly anymore. Nobody does. It would be silly to do so. Instead, we *serialize* data. What does that mean? Well, consider an object with numerous properties. There's no order to those properties. Does the `user_id` instance variable come before or after the `first_name` instance variable? It's pointless to think about that, because when we consider the object it doesn't matter. Indeed, the question has no answer. But what happens when we want to store the object on disk? Well, we need a way to store that object and retrieve it reliably. That's where serialization comes into play. Serialization is a way of repeatably representing an object as a stream of bytes on disk. Obviously, since we need to be able to store and retrieve the object reliably, so there has to be *some* method of organizing data. But the thing is—I don't care. You can store it as a JSON, YAML, or a Ruby marshalled object. As long as I get my original object back intact, how it's stored is irrelevant to me. But let's look at it from the other perspective. I don't care what the object looks like, I just need to know how to store it on disk. If your object conforms to all of the specifications required to be an ActiveRecord, then I know how to put that into an SQLite file. I don't really care what your object looks like, as long as it looks like something I can handle. I'll then write it to disk, and then when you want it back I'll convert it back to a generic Ruby object and give it to you. I have no idea what your object is or what it does, but I know how to store it on disk, and then retrieve it and give it back to you. So now, hopefully, you understand that there are really two levels of abstraction when creating a file on disk. Your program doesn't care how you store it, and the serialization library doesn't care what you do with it. So, what does this mean to you? Well, even if you were able to figure out what kind of file you're dealing with and decode the data, you're still only solving half the puzzle. The other half is solved by the code, and that's not something you have access to (for the purposes of this exercise, anyway). So the stream of bytes may represent something identifiable, but without the code to process it you're looking at little more than a list of key-&gt;value pairs. Can you figure something interesting out? Maybe. Is it useful? Without the code that was responsible for writing this object to disk in the first place, probably not.
In theory there can be collisions, the probability is so low that I take it as 0 for this gem. Also, in the case that you find a collision, you are not forced to delete the file since you can run the search in interactive mode (default) where you are asked if you want to delete each file. If you have found collisions, please share them on forums since that is always interesting for people that works with cryptography. 
First of all, thanks, looks nice. Some points: * Program raised an exception when I ran it on */usr*. Seemed to be confused by a symbolic link, file was readable. (PM me if you cannot easily reproduce it.) * I would like to see an option that checks the files byte wise for equality. Sometimes you do not want to take any chance. (Of course this only happens if the check sums are equal.) * Should the argument to the call of *all_files* in *Finder#first_run* not be *@path* instead *path*? *path* comes out of nowhere. Suggestion: Have you thought about first checking a few bytes for equality before calculating the hash? At least with pictures there is quite a chance that a lot of files have the same file size but are different. On the other hand it is quite likely that checking a few bytes already shows a difference and it is not required to calculate the hash sums. While the first few bytes might be equal because they are part of a header the first few dozen will most likely already differ. And reading the first few bytes should be faster than computing the hash sum, as long as they are below the block size. So you could use the first 256 bytes instead of the check sum and only compute the check sum if they math. (Or take 256 bytes in the middle.) If the file size is below 256 bytes just take the contents as key.
&gt; Each group of for describes four bytes. Each group of two digits describes two bytes. A byte is eight bits, not four.
Yeah I'm still using Sublime because it's still damn good stable for my needs, but I have no illusions that it's anything other than a totally stalled project. &gt; PS: I think 1-2 releases per year is reasonable, AFAIK, its been developed primarily by a single person with other part time folks brought on from time to time. That's a reasonable release schedule (Ruby itself has one major release a year!) but the ST releases don't happen that often. More importantly, since it's closed-source, we have no way of knowing if it will ever be updated. Many of us have been through this exact thing before with TextMate. Promising upstart editor, big fanbase, lots of community support.... and then the developer goes silent for multiple years, and everybody's left in limbo because nobody else has the source code.
thanks im probably gonna delete this post because i realize the gem is not ready
Erm, pretty sure a SQLite file isn't serialized. Generally, database engine stores aren't. There are layers upon layers of abstraction, schema, indexes and fun stuff. Unlike serialized data, it would be a tremendous pain to try to extract meaningful information from the file without the engine. But with the engine you can search/read/write specific data quickly and discretely. Serialized data is the opposites...you serialize it, and it's easily trasnferrable and reconstructable, but you more or less have to read or write the entire data set at once.
Probably what you want is: `asset = Assets.get(params[:id])` `pic = asset.path if asset` ps: the class should be called Asset, not Assets.
I fiddled around and came up with this solution pic = Assets.get(params[:id]).path
I think we'll need to clarify the problem. Forgetting about Ruby for a minute, let's talk about the number four. Can you take me through working out if it's "happy" ? If "producing an infinite loop" is a possible condition, how do you write code that terminates?
I would do a sanitation check, if it fails it would go to a catch all error page.
I second *disclosure5*. We don't know enough. Either the challenge itself gives a rule for detecting an infinite loop given this specific problem, or the problem is impossible. Because it is mathematically impossible to write generic code to detect a generic infinite loop. Look up "The Halting Problem". You must have a specific halting solution for this specific problem, or you can forget it. 
If it works, then why not?
Lets define the following methods: # returns the digits of the numbers def digits(number) number.to_s.chars.map(&amp;:to_i) end # calculates the square of the numbers' digits def square_of_digits(number) digits(number).map { |digit| digit * digit }.inject(:+) end Then we can write the following for happiness checking. def happy?(number, seen_numbers = []) return true if number == 1 return false if number == 0 return false if seen_numbers.include?(number) happy?(square_of_digits(number), seen_numbers.push(number)) end The above implementation relies on the following facts: - `square_of_digits(number) &lt; number` for big enough numbers - when we encounter a number the second time in the sequence, the sequence will start repeating. If it repeats, we can be sure that it will never reach 1. Edit: the first fact can give us enough information to confirm that the algorithm will eventually stop. Edit 2: fixed syntax errors 
@Anne_Ominious1 You are right. The generic infinite loop detection can't exists. But if the problem converges toward a number, or to bound finite subset of the domain, the issue can be solved.
That makes sense. And how do you draw the line between "took a lot of goes" and "loops to infinity" (which I'm only guessing, makes it an unhappy number?)
I'm guessing if its an infinite loop you would designate it as a unhappy number like you said but how would I show that?
How would I run this in the command line or create ruby program to feed it a number?
Using exceptions for control flow is a bad idea. https://github.com/bbatsov/ruby-style-guide#no-exceptional-flows In sinatra you can do: ` halt 404 unless asset ` and then have a block to render 404 pages if needed.
Note: you must be using Sublime Text. The file does not contain text lines of numbers, it contains raw bytes, when Sublime Text encounters a file that would look messed up and invalid as UTF/ASCII it will display it in "hex viewer" mode without telling you (other than the columns of numbers making it obvious).
There is a complete and nice one in ruby: http://subtle.subforge.org
Only single digit numbers + some double digit numbers will have a "sum of squares" that is larger than itself. For numbers &gt; 99 the reduction will be quicker, the more digits it contains. So you can store the intermediate results and conclude "unhappy" as soon as some result is duplicated. So I think the problem is ok as stated.
Well my brain currently writes glorious, flawless, and efficient code so I think we've reached an agreement.
There are some dedicated websites with of different problems and tutorials: like [codewars](http://www.codewars.com), [rubeque](http://www.rubeque.com/), [ruby koans](http://rubykoans.com/) It depends very much on your general programming skill. Assuming you're a beginner I'd suggest starting simple with command line applications. Some ideas: [game of life](https://en.wikipedia.org/wiki/Conway's_Game_of_Life) or a sudoku solver.
If you really need the data file to be human-readable, then use `YAML::Store` from the standard library. Or, more likely, if you'd rather optimise the performance and memory usage, then use `PStore`: http://ruby-doc.org/stdlib-1.9.2/libdoc/pstore/rdoc/PStore.html [Here](https://robm.me.uk/ruby/2014/01/25/pstore.html) is a helpful article on getting started with `PStore`. I don't think you should have any issues storing files in the same directory as the gem. Assuming you didn't screw up permissions when installing the gem/rvm to begin with. (Are you using `sudo` anywhere? You shouldn't be!)
Manually writing `YAML` to a `tmpdir` *is* hand rolling your own version of persistent storage. This is precisely what `YAML::Store` (http://ruby-doc.org/stdlib-1.9.3/libdoc/yaml/rdoc/YAML/Store.html) already does.
 arr.sort_by.with_index { |a, i| [a[0], i] }
Yes, thanks, I'm aware of tmpdir/mktmpdir.
D'oh! It is one of those times when you have been struggling quite a long time with a problem, and, once revealed, the solution looks so simple... Wonderful, thank you.
This post proves the contrary. 
Build a chess engine 
I'm in sorta the same boat. Code something you would use. I'm currently coding a ruby script that scrapes the top three most popular Heroes of the Storm builds from a build website. Then , when the script is ran, it asks the user which hero they want a build for , lists the builds available for that hero, and allows you to select that build which is printed out for you. Basically I was tired of having to open a Web browser and search for good builds. Not I can grab a build in a few seconds. About half way done now. After I'm done, I'm going to add a way for the user to add their custom builds. Edit: something I wish I knew about when I first started. The book The well Rounded Rubyist, second edition. Buy this book and read it over anything else. Shit is good.
Ah yes, I'm in a Ruby subreddit. My background is more ops and tooling, and I got caught up in the sqlite storage engine representation of data. FWIW, Active Record is an ORM framework for Rails built on top of SQLite which is a SQL RDBMS. If OP is looking at the raw SQLite file hoping to recognize Ruby/ActiveRecord data or structure, that's just not going to happen. There's already a lot of abstraction from relational tabular data to storage, and ORM is another big ball of abstraction built on top of that. 
Summary answer: You are looking at a hex dump of a binary file. The SQLite3 format will not make sense or look familiar since it's an RDBMS store, and when you put data in there, Rails will use the ActiveRecord ORM to interface with SQL. With all that abstraction, you probably won't recognize your data in there, except maybe in jumbled bits. If you want to inspect your data at a lower level you could open the file with the `sqlite3` command and/or query it with SQL commands via a lower-level Ruby library. - `.tables` will list the tables in the database - `select * from tablename;` where tablename is one of the tables will show you the data in that table. - At this level, the data is in multiple flat tables usually containing ID keys to be referenced to/from other tables.
FYI this is called a stable sort if you want to look it up elsewhere.
How do you know I could not remember this key word when I was searching? Well, indeed I could not, you are right, and I thank you for reminding it to me :-)
 timestamp = Time.zone.now.to_i.to_s File.rename(file.path, "/tmp/#{timestamp}_order.csv") and &gt; Now that we have a unique way of identifying the file we have just generated doesn't go well together. All it takes are two users submitting a request at the same second and you're in trouble. The options you have to avoid this: 1. UUIDs 2. add the user's id to the filename 3. use the contents' hash (MD5/sha1/...) as the filename
I wasn't hoping to recognize anything, I've just been curious for some time about how our own conceptualization of a database in terms of tables is an abstraction, and I was wondering what it was an abstraction of, basically, I guess, what is a database unabstracted, to a computer, what is the underlying form of what we think of as a table. I'm learning programming for the first time, and we talk about abstraction a lot, but then you've got this massively abstract idea of data tables (I think) and no one talks about it (even if it isn't relevant practicality speaking, but just to understanding and really knowing something)!
If you're new to programming and not just ruby, build a Fibonacci generator. Great lessons in recursion, variable control, and shouldn't be more than 50 lines
A collection of nice exercises http://exercism.io/languages/ruby with the ability to get feedback on your solutions.
Oh I'm with you 100%. I love finding out about all the implementation details. [Relational database](https://en.wikipedia.org/wiki/Relational_database_management_system) storage engines are a pretty involved topic with a lot of abstraction. In fact you could probably spend a career learning all the details. At the lowest level, all data is just collections of 1's and 0's being loaded, applying a binary operation and writing back out. Everything we do with computers are layered abstractions that end up there. That still blows my mind. At the file level here, there are probably blocks/extents of reserved space that may store rows of a table, various indexes for the rows, schema definition for those rows, constraints and other similar stuff. Logically a table is pretty much a spreadsheet analog of just data (no formulas/formatting/logic). The columns of the data are strictly defined, unlike in most spreadsheets. The "relational" part comes where a table might have an ID column of some sort that references another table. There is actually some math--relational algebra--that gets involved here when querying data that comes from multiple related tables. Above that you're getting into [Object-Relational Mapping (ORM)](https://en.wikipedia.org/wiki/Object-relational_mapping) which isn't part of SQLite but is an abstraction that may be better-suited to object-oriented programming storage. So there's 4 abstraction references from lowest-to-highest. You can spend a lot of time diving into any one of them or even the parts I omitted in between.
I'm in the same boat dude. Finished codecademy, finished 'learn ruby the hard way' - now started on Exercism.io which is really cool. Some other good ones in this thread. 
You can use temp files on Heroku, but you can't depend on them, as they can be deleted at any point. For files that are going to be generated and downloaded and then discarded, then this is ok. Never knew about the JID trick, thanks for that one!
Thanks, it corresponds to what I've thought about the topic.
Oh I had no idea. Since when? 2.0+? Does it work consistently across all major implementations (mri/jruby/rbx)?
While you're refactoring that ruby code, see what you can do to remove every instance of #send and .send. They are defined by Object (although not reserved) words in ruby. http://ruby-doc.org/core-2.2.3/Object.html#method-i-send
I'm not sure when it was introduced, but I just tried it in a jruby irb 9.0.0.0, and it worked fine. It's awesome :) `String#constantize` is easily the most suspect and ludicrous of all activesupport "extensions."
This is why `Object#__send__` exists, right?
The problem with this is reseting your `PATH` back to whatever it was before hand. You also have issues with `GEM_HOME` and other variables not being set. The recommended way of loading ChefDK is by running `eval "$(chef shell-init SHELL)"` in order to set everything correctly.
I don't know that kind of absolute necessary. If you intend to dynamically dispatch a method on any arbitrary object, `Object#__send__` seems more appropriate. If you intend to dynamically dispatch a method on an object whose class you know doesn't define `#send`, `Object#send` seems more appropriate.
&gt; how many steps do you allow in a function before breaking it down. As few as possible, and no fewer than that. Remember that you are testing behavior, and not your functions.
But if it doesnt exist, it will still be different to the home page right ? since i assume the homepage is not nil.
Here is some philosophical advice. The more you write/program, the better you get at it. My advice for you would be to just keep going ahead instead of succumbing to paralysis. Make a note to come back in a week to refactor the code if you want to, but always keep moving forward. In terms of practicality, maybe you can paste some code so we can help you out specifically?
It looked like we were in agreement, my code is awesome. How could it not be awesome?
&gt; Brilliant or Abusive? In this case, it's abusive. You've removed the intention of the code which is to ask explicitly "does source_url exist" *and* "is it different than the homepage_url". This was more obvious with your first bit of code. It would be even more obvious like this... &gt; if !lib.source_url.nil? &amp;&amp; lib.source_url != lib.homepage_url The question posed by banister highlights the information this new/shorter code is hiding.
Not only are u a bad coder but you fail at english. Do u understand what contrary means?
Yes, very true.
 nil != 'http://www.google.com' # =&gt; true nil &amp;.!= 'http://www.google.com' # =&gt; nil
I must have been using Rails. ;)
wow, this is just brilliant. Took me a while to figure out what was going on here, but now that I see what you did, it is just great! And thanks for the links and two options, it helps me understand what's going on here. Will be saving this for sure! Thanks!! 
At work, I've spent some time comparing code coverage solutions. The one that impressed us the most was [codecov.io](http://codecov.io). For Ruby projects, they essentially just provide a wrapper around the simplecov gem that uploads coverage data to codecov.io. The really cool thing is that they also have a [browser plugin that visualizes your code coverage directly on github](https://github.com/codecov/browser-extension?utm_content=buffer50aec&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer). It's super handy for when you have a large code base that spans several languages and you want high visibility on your coverage in one central location. Full disclosure: I have no connection to codecov whatsoever, except that I championed for it at work.
&gt; When are you supposed to use parentheses in these situations and when can you omit them? Technically never, Ruby allows to omit them. In the beginning it was very common to not use them anywhere. Over time people found that it makes for bad readable code and nowadays they are used most of the time. So use them until you get a good feeling for when it's ok the not do so. &gt; I'm not following what "do" is doing in this scenario or what you normally use "do" for. There are two main ways to define blocks in Ruby. Either enclose them in `{}` or in `do..end`. Normally the curly braces are used for single lie blocks and do..end for multi line. So it's basically the same as numbers.each_cons(3).each { |groups| return p true if groups.inject {|sum,x| sum + x} ==7 } &gt; I don't get what's it's actually saying, if you were to read it out as a sentence. [2,3,4].inject { | sum, x | sum + x } `inject` passes an accumulator value (sum in this case) into a block, together with an element of an array (in this case or any other Enumerable). We could give the accumulator a start value, but the default is 0 which is exactly what we need. So in my example the first iteration calls the block with sum=0 and x=2. The block returns 0 + 2 which becomes the new value for the accumulator. So next round sum=2 and x=3, adding 2+3=5. Last round sum=5 ad x=4 final result = 9. [2,3,4].inject(:+) Is the super short form for the same thing. It doesn't need a block at all, just tells Ruby which method to apply on the two values. (For some reason you can use either `&amp;:+` or just `:+` here. That's a minor (for now) detail about Ruby syntax.) The full line {|sum,x| sum + x} == 7 simply compares the result of the sum operation with 7. So in conclusion the possibly shortest way to write it would be: def lucky_sevens?(numbers) numbers.each_cons(3).any? {|group| group.inject(:+) == 7} end 
Also check out Practical Object Oriented Design in Ruby from Sandi Metz. With proper design, you should never need more than 10 lines for a method (Sandi only gives you 5). 
I will add a third check for all the bytes in case hashes are equal in the next version (it looked like that was a concern for a lot of people). Thanks for the suggestion
Looks promising, I'll give it a try!
The Ruby and Open Source meetup in my city is pretty decent -- it's about half folks who are developers who want to talk development, a third folks who want to become developers, and a sixth people who are polite and want to sell something. I haven't been able to attend many meetings because of other scheduling conflicts, but the ones I've attended have been pretty enjoyable. You don't lose much by attending once and seeing if you like it (or if you like it enough to try it a second time), and there's nothing keeping you from leaving in the middle of things.
yeah unfortunatelly they are all like 90% rails groups and 10% ruby. if you find a true ruby group(not all web stuff but focus on coding like pythong groups) then sing me up.
&gt; The problem with this is reseting your PATH back to whatever it was before hand. Why? `/opt/chefdk/bin` unlike `/opt/chefdk/embedded/bin` only contains chef related binstubs with the minor exception of `rubocop`. It's not going to hurt the rest of your dev env. &gt; You also have issues with GEM_HOME and other variables not being set. I've used this setup for almost a year without issue so it's unclear what your talking about, care to elaborate? &gt; The recommended way of loading ChefDK ChefDK's recommendations don't interest me much since their opinion of people whom use their software and are Ruby devs seems to amount to 'fuck you'. 
It's all subjective but I think the original way reads more like english than with the symbols thrown in
If it's a cache, how persistent do you really need it to be? If it's okay that it gets wiped after a system reboot, just throw it into /tmp. That seems like the most logical place to me.
&gt; In a the near future, maybe code like &amp;.&amp;, &amp;.&lt;&lt;, and &amp;.+ will be something we’re all used to. Correct. Everyone's used to `&amp;:` (as in `.map(&amp;:to_i)`) so we'll get used to `&amp;.` too.
I remember, five years or so ago, wondering on Reddit how a supposedly reasonably mature language like Ruby can have such absolutely primitive coverage analysis. (Basic description of what I'm talking about [here]). We have line coverage, and that's *it?* No branch coverage, let alone modified condition/decision coverage. We're taught as Rubyists to counter that by making small, simple, single-path methods as much as possible. That's good advice, and it leads us away from some of the exploded-spaghetti-factory code I've seen in Java and PHP. But adapting one's practice to compensate for a deficiency in tooling just feels…gross.
Using !something.nil? is abusive as well.
savePath is in a separate file than report, but I equired the file with savePath in it to the file that has report. 
Custom Attributes API looks like one of those little sleeper features that sneaks in and changes everything. For the better
http://stackoverflow.com/questions/8574206/ruby-how-to-import-a-variable-from-another-file
I have already included variables from other files in my main file, so that's not the issue.
I am currently using this approach in production on Heroku, the worker generates the file and the controller returns it. I have never come across a problem where the file does not exist. Perhaps Heroku shares the temp filesystem across the whole app?
So what is it all about now?
&gt; ChefDK's recommendations don't interest me much since their opinion of people whom use their software and are Ruby devs seems to amount to 'fuck you'. I see you might be slightly upset with ChefDK To answer your question I think I might have gone slightly snowblind on this. I haven't tried what you suggested but I will now. The ```GEM_HOME``` problem I had was that when Vagrant would bring up a machine and try and use vagrant-berkshelf, the gem couldn't communicate the the berkshelf gem I had installed. Vagrant only seemed to load up the ```GEM_HOME``` and other ```GEM_*``` variables correctly when I was using ChefDK. But as I said I didn't try what you suggested. I will now and see if it solves my problem :) **Edit:** Formatting
That's a hex dump of a file, with one byte per four-digit grouping. It isn't meant to be human-readable.
hey, thanks for reading the article! Regarding your remarks - yes, but I think that this discussion (although valid) is beyond the scope of the article. You can see the comments on the article itself, I had the same discussion with another person there. :) 
Agreed. I updated the article. Thanks!
I suggest you read up on the [different variable types in Ruby](http://www.rubyist.net/~slagell/ruby/variables.html) and then look closely at the differences between those that work for you and those that do not. 
I mean, there are definitely pre-built solutions. If you're truly looking to *build a forum*, and not simply install one, why don't you do that though? Could be a fun project.
I wasn't, and now that I've looked up what it means I can't see why I'd want it.
:: crickets ::
25 upboats, though...
;)
Since you probably don't wish to check if something is not nil, but if it's present. So either `unless something.nil?` or `something.present?` would be wiser (in my opinion).
I think that it's a wrong way to think how to test complex code. The right way it to write simple testable code. SOLID principles and others are you best friends there. 
&gt; The allegiance for Rails is to make it possible for one, two, or a few programmers to create amazing apps that span web, email, mobile, native, API, and all the other platforms we need to cover in 2016. Delivering for the web is getting more complicated every day. There are a thousand vendors and peddlers of complexity who benefit when things get hard and compartmentalized. Rails is here to serve as a counter to that. To retain the beauty and simplicity of building for the web without needing an army of experts. That's pretty neat to hear, and matches my experience dabbling in other frameworks. You can really get an idea off the ground in Rails.
Yes. Joined the URUG (utah) years ago and have met great people there. It has also helped me find jobs over time. Greatly recommend it.
Why not split it into multiple commands? 
The problem is that rails has gotten very complicated and hard to optimize. When you look at response times of competing frameworks (node, python, elixir, go etc) they blow rails out of the water both in terms of speed and memory usage. I think the team has to tackle that but then again I have been saying that for years and nobody seems to care about optimizing rails for a micro service world. You can't have every micro service taking up 512 megs of ram. It's not right.
I can't speak to optimization issues, but I think Rails is a lot less complicated to get an initial build up and running than with, say, node + framework or a java framework.
Both, Rails is pretty big and Ruby is pretty slow. It's like a death by a million papercuts, so any single optimization has limited impact.
Thanks! Ideally though I'd be able to publish the original command line in a book so a reader could follow it while disconnected (on the bus, train, etc.).
&gt; You can't have every micro service taking up 512 megs of ram. It's not right. Why not?
I'd say that front-end apps are not the right tool for the job. They destroy cell phone batteries and make websites slow, jumpy and awful.
I guess it depends on what the job is and who is doing the programming. If your goal is to provide an awesome native experience on a phone then yeah, build a native app.
You have my upboat sailor
What's the job? That's a very sweeping generalization to make.
you can't see why you wouldn't want that as opposed to `.map { |item| item.to_i }`?
According to my post, any job that I would use my cell phone for.
I also like using the `&amp;` in the same way with lambdas/procs #define my lambda double = -&gt; (x) { x * 2 } # use my lambda [1, 2, 3].map &amp;double # returns [2, 4, 6]
Someone told me a few weeks ago that coffeescript is no longer enabled by default in v5, but when i use the beta, coffee is added to my Gemfile. I don't want jQuery either. I was experimenting with the `-j` option but no luck. :/ Anyone? 
There's also just that no one calling themselves a front-end developer puts "Turbolinks" on their resume. They'll pad it with talk about React and Angular and someone in backend will get stuck with it.
What kind of sex do you want? For BDSM I would recommend you to implement some really big project in RoR.
I bloody wish
Feel free to, you know, post your code?.... Although I am also wondering *why* you need this? Unless you plan on running the script on a Windows machine that does not have ruby installed (and it's not easy for you to just install it)?
So many people are concerned about Twitter scale. Staaaaahp. You're not writing Twitter, and if you do manage to land the next best thing, you'll have buckets of money to replace the slow parts. Most of the apps we write have &lt; 50 users, and replace onerous paper workflows. Rails is great at that. 
1) depends on how much throughput you need how much the memory usage is a problem. 2) micro services are hard 
This looks awesome, does it work with sidekiq 4?
Yep! I knew I was missing something. My mind went immediately to storing config files outside the repo entirely. Thanks!
Yes, what's the benefit?
It's much shorter
Oh, good point! Unfortunately, Ruby does not support /\p{Emoji}/ but you could parse the Unicode database (http://www.unicode.org/Public/emoji/) to construct a regexp.
I've used forem before and it was ok, but that was 3 years ago. I imagine there's probably a better solution now. I did have to fork it and use my own version since I had to do some changes, but other than that it was ok.
Sweeping generalization here, but I would say that SOA is hard. Microservices are an easy way to build a monolithic application with physically separated components.
So you know how you can write `[1].select(&amp;:odd?)`? What that `&amp;` does is call the `Symbol#to_proc` upon `:odd?`. That to_proc method does this: `:odd?.to_proc = proc do |x| x.odd? end`. In this case, though, the numbers don't have a foo method, since I didn't define it within `class Fixnum`. Ok, but Fixnum is still derived from Object, which is where I defined my foo, since that's default environment. % ruby -e 'p self.class' Object But you still can't do 1.foo at this point — new methods in Object are defined private by default. % ruby -e 'def foo; 3; end; 1.foo' -e:1:in `&lt;main&gt;': private method `foo' called for 1:Fixnum (NoMethodError) That's why it starts working upon setting it as public.
[twitter-cldr](https://github.com/twitter/twitter-cldr-rb) includes much of the unicode database. It does support unicode-class-based regexes, but I'm not sure if it supports an Emoji class. It looks like it _should_ with the `Zsye` character property ("Symbols (emoji variant)"), as it says it supports all properties listed in the [wikipedia character property article](https://en.wikipedia.org/wiki/Unicode_character_property#General_Category) But I haven't been able to get it to work -- I can't even figure out how it works for the basic example in the docs with 'lowercase', it doesn't seem to be doing what I expect. Ah wait, maybe twitter-cldr regexes only support the two-letter properties, not the four-letter ones. But the gem might provide access to the unicode character database such that you could create your own. But if more emoji's were added, you'd still need to wait for the twitter-cldr gem to update their unicode database and re-release. 
Where? All the ones I clicked on linked to the stay tuned page. 
The example takes the response from an API, does no validation nor even checks it for an error status, apparently not even checking the HTTP response code. That's not Ruby's fault, it's just bad code and it doesn't take particularly meticulous code review to catch such shenanigans. 
I agree the example is bad code that is part of the point. The post mainly comes down to the single line ``` Name.new(response.dig('data', 'name')) ``` which accepts a wide range of inputs and produces some surprising outputs. Basically, I think each line of code in Ruby probably requires more thought both from the developer and the reviewer. I might need to change the code examples to make this more clear.
I guess I don't understand what is surprising about that line of code. `dig` returns `nil` if the path isn't found, it's not like that is undocumented or undefined behavior, really that behavior is the entire reason the method exists. Fundamentally the entire example boils down to validating data from external sources, which is just as important in Java as it is in Ruby. For example had you written a Java POJO annotated with Jackson JSON mapping and didn't define any validations, you'd also get a whole bunch of nulls and no exceptions.
Not really, though typically I see the initialize method and class methods toward the top of the class. I'd say put them in an order that makes sense to someone reading it. When you rack up enough methods that it becomes difficult to reason about what's going on in the class, you should start feeling like it's time to break that class up. See Sandi Metz' Rules For Developers: https://robots.thoughtbot.com/sandi-metz-rules-for-developers For general style, Github's guide is nice: https://github.com/styleguide/ruby
Came here to say this. Its a hell of a lot easier and less error prone to define models representing API payloads and validate them after the parsing phase than it is to try to validate as you're moving data over. In fact, trying to validate things one by one while copying them over is more likely to cause a scenario where only a partial list of issues is provided to the user, as your code will have given up after hitting the first issues.
"they're" isn't the right word to use her.
API docs are here http://www.rubydoc.info/gems/rom
I second Slotos here. You have specified a halting condition for one possibility (repeating nodes). But it is possible... not likely, but theoretically... that it could continue without repeating. Unless we had a proof (which I am not willing to undertake), that can only be considered a partial solution. As I originally stated 4 days ago: you must have a specified halting condition as part of the problem, or a mathematical proof that it always converges (whether given to you or supplied by yourself). But as Slotos points out (at his first link), Project Euler has specified in advance that all numbers will converge. So the problem has a pre-specified halting condition, if we assume they are correct. "Infinite loop" detection is a red herring, and isn't actually part of this particular problem.
private methods go at the bottom
Here's the link, since OP forgot to actually post it ;) https://github.com/lakesare/model_to_googlesheet
Yep, or [this Ruby style guide](https://github.com/bbatsov/ruby-style-guide) is good too. I tend to just work from top to bottom, keeping all private methods at the bottom and the initialize method right at the top, everything else goes in-between.
I haven't seen a standard. I use this order: - constants - attributes (EG: attr_reader/accessor or ActiveAttr) - initializers - class methods - public instance methods - private instance methods Each of these is ordered alphabetically inside that grouping. I like to define the properties of the class (constants/attributes/inits) before I define it's behaviour (class and instance methods). I like to think of it as the class telling me who it is and then telling me what it can do for me.
I wish I had this gem in one of my projects, so I'm publishing it now. And I'm mentioning it here because it's not searchable by google. And I deleted previous post because the title was awful. 
I'm becoming a fan of "form objects" like [Virtus](https://github.com/solnic/virtus) and [Reform](https://github.com/apotonick/reform). They're a good fit for taking parameters from an API or a web form, or even just loading a config file.
As a Ruby recruiter it does look good for Ruby developers to have talks and blog posts on your CV and many people are motivated by improving their online or professional profile with these sorts of things, but it doesnt mean the content is bad. If there is decent leadership anything too commercial will be filtered out of the submision process.
Depending on what you need in the forum software I *might* have a decent solution. I've been maintaining and writing this rails engine for a few years now called thredded =&gt; https://github.com/jayroh/thredded In the past year it's gone through a lot of changes and improvements and it's in line for a lot more so I can say it's by no means unmaintained. (Could always use more help, though!) For what it's worth, outside of my "sales" schpiel, there are a couple of options you may want to look into, in addition to discourse, forem, et al. * Tectura: https://github.com/caelum/tectura * Heterotic Beast: https://github.com/distler/heterotic_beast * Altered Beast: https://www.github.com/courtenay/altered_beast I mention those in the thredded readme but figured I'd include them here. Some may be dated and more for older versions of rails, but they're still options. Last thing - while Discourse may be the most feature packed ... and it is, absolutely bursting with features ... I might consider that a detriment. Sometimes less is more. Discourse's codebase, dependencies, and setup is a total bear. If you're not familiar with Docker, for instance, you have some learning to do :). Good luck!
&gt; While “unless X” is semantically equal to “if !X”, the actual instructions generated behind the scenes are not the same. Of course not. The latter one performs the unary-! method of the object in question before it evaluates it's truthyness. That also means, that they're not semantically equivalent. The "!" operator is defined by the object in question and (although that would be stupid) can be defined to behave different from logical negation.
After grouping by descendending visibility (public, protected, private), I try to order the methods in descending levels of abstraction. It's a similar approach the the [Inverted pyramid](https://en.wikipedia.org/wiki/Inverted_pyramid) style of writing used by journalists. This means you can read the class from the top down and hopefully get an overall understanding of it, and you only need read the lower-level methods if you need extra detail. (none of this is specific to Ruby of course). 
I like the ease of use for the developer. Looks like there has been work done before with https://github.com/gimite/google-drive-ruby but I like how clean the API is. 
/u/chrisgseaton hey. Thanks for reading the article. To clarify, I never mentioned in the article that "exclude?" was semantically equivalent to "!include?". I simply said that was how it is implemented. [source](https://github.com/rails/rails/blob/a476020567a47f5fbec3629707d5bf31b400a284/activesupport/lib/active_support/core_ext/enumerable.rb#L60)
/u/strongxmind curious what a "discourse smaller brother" would look like for you. I'd love to be working on that alternative 
As nice as a lot of Rubyisms are, they can bite you in the ass if you aren't careful about it. For instance, [see this article on and vs &amp;&amp;](https://www.tinfoilsecurity.com/blog/ruby-demystified-and-vs).
Yes you're right.
This is just a bunch of ads.
Yeah and you get better examples from just generating an api application.
Hi there, /u/mipadi. My blog is just Tumblr; I've got it under a custom domain. You can contact Tumblr support [here](https://www.tumblr.com/support).
Hey /u/ryuujinx. I agree with @noinkling - the difference between "and" and "&amp;&amp;" is well known now. IMO the one operator many Rubyists are yet to learn or understand is the flip-flop operator, despite how simple it is. Good thing there are good blog posts explaining it for curious devs.
I'm on a corporate machine running CentOS 6.
You're looking at the YARV VM instructions which don't necessarily map with CPU instructions. Then you imply performance differences between the implementations. The reality of performance at the CPU instruction level is FAR from that simple. 
I mean that you shouldn't infer what the majority of us spend our time on based on what David chooses to spend his or the Basecamp folk's time to work on.
There are tools like Yeoman to help with this.
/u/humzashah is how it works
&gt; We can use a Mutex, which is a shorthand for “mutual exclusion”, it implements a simple semaphore Actually it's a mutex, not a semaphore. The Ruby docs are wrong on this. A semaphore is a more general abstraction of a mutex but the Ruby implementation of Mutex shouldn't be considered a semaphore. 
Yup, I agree. But neither I, nor the rest of the core team have control over what he chooses to do (regardless of how much perceived importance it has), and at the end of the day it doesn't greatly affect what's actually happening with the framework. That said, look out for better Grunt/Gulp/Whatever hot js tool integration in 5.1
Rmagick just calls an external application, magick. You can look here for all the equivalent magick options with the associated rmagick method; https://rmagick.github.io/optequiv.html. So, I would come up with a simple, didactic magick command and try to write the expected code using rmagick/your gem. Then compare the magick example (as a string) to `"#{my_imglist}"` (or whatever you can your Rmagick object).
It's tough testing for output from a third party API or Gem. You may want to just not do it. Think about it this way, The gem or API should have plenty of tests around it, so you should feel confident using it yourself. This isn't always the case, but alternatively, how can you test for something where you don't know what the expected output will be?
&gt; That still blows my mind. I'm with you. I'm the guy who actually wants to know at what point does the physical electrical thing become something else, and I'd love to track a few of it's first manifestations. But there is SO much to learn first. I even have electrical engineers in my family, but they hate fielding this type of inquiry at Thanksgiving.
I'm a novice rubyist. But the reason I often used has_many :through in the past is: "You should use has_many :through if you need validations, callbacks, or extra attributes on the join model." http://guides.rubyonrails.org/association_basics.html#choosing-between-has-many-through-and-has-and-belongs-to-many
/u/moomaka, thanks for taking the time to read my blog post. I'm afraid you missed the tagline of my blog which is at the very top "Some interesting Ruby and Rails scenarios explained in layman's terms.". Keeping in line with that, I had to keep things simple; it also helped me make the post as succinct as possible. What I realise after re-re-re-reading the post, is that I did not properly explain the Ruby VM or the library I was using to get the instructions being analysed; it was a deliberate decision for the same reasons as before. I had provided a link to the library for people wanting to find out more but I feel this to be insufficient. Thus to make the post more "complete" I've now included a rough function of RubyVM::InstructionSequence, the link to a post that describes how Ruby executes code, and a clarification that the lines returned by RubyVM::InstructionSequence aren't the final instructions sent to the CPU.
u/Meshiest, thanks! :)
/u/awj, yes, exactly. Which is why the term "reverse ternary operator" came to my mind (as long as it sounds).
wtf?!
I've had a quick look at thredded and it looks like it could be the discourse smaller brother that [/u/strongxmind](https://www.reddit.com/user/strongxmind) was looking for. Does it have the ability for a user to make their own profile?
Look's interesting. But I think Imba may have committed the same mistake that CoffeeScript committed: it's a complete different language from JavaScript. JSX and TypeScript, on the other side, have just improved JavaScript, which makes it easier to learn and migrate from/to other technologies, etc. As CoffeScript became less interesting after ES6, Imba may become less interesting with time, too. Edit: typos
`has_and_belongs_to_many` has some details that you must be aware: - joining table must be sorted (e.g. User has and belongs to many groups, the table must be named `groups_users`). - you can't have extra attributes; just the ids. I find `has_many through:` easier to work with as it behaves just like a regular model.
I'm not sure they can be substituted for one another. You have the notion of streams (or channels) with 2 that isn't in 1, for instance. I also don't think that text parsing is a huge performance penalty outside of massive scales.
Looks a lot more like Python than Ruby to me
Can you comment on the strengths/weaknesses compared to Opal? Can you write a quick example of how you use another JS library like the Google Maps JS API? I'm always confused with this type of tool about how to call JS in a way that won't be translated. I saw it mentioned that imba.io is written in imba and the same code runs on the client and server side. Is that accomplished using websockets? How does this compare to voltrb? Can this be integrated into the Rails asset pipeline rather than packed with webpack or browserify? Maybe through rails-assets.org?
I actually found your old intro on archive.org and read about it there. The idea seems really cool. I'd love to try it sometime. It seems like the kind of thing that could really make some projects a million times nicer. But, I'll probably wait until you get the new pages up. Especially the tutorials, that would be lovely.
Because it's a rails engine it leaves that responsibly completely up to the developer and how they would like it to be. It handles the forum stuff as well as it can and leaves other stuff, user management, auth library, etc - to the parent app. And, to be quite honest, I think in its current state it STILL does too much. I'm in the middle of extracting the "read tracking" code to an external gem, and the full text search should definitely be pulled out into its own gem(s) - MySQL, pg, elastic search, etc. 
Have you honestly used all of coffee's features? I have a hard time believing any JSer that says they haven't felt the improvements of CoffeeScript when I've written OO classes with inheritance and used some functional-ish constructs like list comprehension in CoffeeScript that would take at the very least twice as much code in vanilla JS. edit: I feel like anyone who says CoffeeScript doesn't have benefits over vanilla is saying that because they generally just write a few JQuery handlers with minimal logic. Which is fine, most JS is just that, but that isn't where anyone feels the pain of JS in the browser, people feel the pain when files start to get bloated in as little as 100+ LoC that are just spaghetti already. Cleaning that up with classes in vanilla is not intuitive, doesn't read well and takes a LOT more code. This is where CoffeeScript dominates vanilla. It isn't even close in my book and I've yet to see code that suggests otherwise.
Also, /u/arrancscott, if there's anything I can do to help, don't hesitate to get in touch. I'd be more than happy to help out.
I think that's the job of the http server not the site itself. The other big thing is the ability to tell the client to get additional assets rather than the client requesting assets. 
Yeah, you should pick one or the other. There might be weird ways to make them both work together in one app, but you don't want to get into that if you are new to them both. And it would not result in a single page that is somehow part Rails and part Sinatra (at least not without a LOT of hacking). I have no idea what a "Dashing dashboard" is though. Both Rails and Sinatra are development platforms, they will both require programming, they are not plug-and-play applications you can just put plugins into like, say, WordPress. Yes, I think you got volunteered for a project that is bigger than was thought, if you have no experience with Rails or Sinatra. Yes, it sounds like "he" doesn't really understand what is entailed here. 
[This](http://dashing.io/) "Dashing dashboard"? It says "Dashing is a Sinatra based framework that lets you build beautiful dashboards." So, yes, it sounds like if the task is "to build a Dashing dashboard" with that tool, the task is to use Sinatra, and is incompatible with dependencies that depend on Rails. If you don't know ruby yet, you are going to have some learning to do. These are frameworks for programming in ruby, not plug and play apps. But Sinatra is often considered an easier starting point than Rails, if you do know how to program for the web, you can do it. 
And here's a PagerDuty widget for Dashing. I've never heard of any of this stuff before, I'm just googling. https://github.com/thegreenrobot/pagerduty_dashing
Thank you for your opinion. I don't know if I used all features. Yeah, the nicest feature is classes and inheritance, but ES6 have it now. Is Coffee's classes superior to ES6 classes? I also think the debugging is unintuitive with Coffee. The nice thing about ES6 is it is the standard, and also plays well with tools like JSX and TypeScript.
got a good chuckle
https://github.com/gottfrois/dashing-rails
For example, the documentation link you present doesn't say anything about this also working on Arrays or Structs. Documentation is for reference, not learning material.
A lot of ES6 is basically identical to CoffeeScript, but support for ES6 is still varied across browsers and you end up using tools like babelJS to get compatibility, which puts you with the same depends as coffeescript with more varied results (or so I hear, I've never used babel before). I personally prefer CS syntax, because JS is hard to organize and vertical space is precious to me, but that's just preference. So, basically I see ES6 as CoffeeScript with JS syntax without as much support, yet. Even still CoffeeScript has comprehensions and string interpolation and other things that ES6 doesn't have yet. Once ES6 is widely adopted, it'll basically be what CoffeeScript already is today with JS syntax. As for the debugging argument, CoffeeScript produces JS the way you should be writting JS. If you can't read the output JS I would suggest you aren't writting JS the way it should be written according to all modern design patterns. CoffeeScript is basically just a guide for proper design patterns in JS. I personally like the different syntax, but that can be safely ignored.
...and now you have 3 problems :) http://regex.info/blog/2006-09-15/247 https://www.explainxkcd.com/wiki/index.php/1171:_Perl_Problems
I just google it. This is the first result: http://stackoverflow.com/questions/15129355/ruby-2-0-rails-gem-install-error-cannot-load-such-file-openssl What have you tried, to fix it? Does the top answer there work for you?
The gem seems a bit dead... [here](https://github.com/ryan-endacott/verbal_expressions/pull/12) is a pending pull request from *18 months* ago. (By the way, I'm also the author of that PR.)
There's no arguing the fact that the example regexp in the post is way too complicated for its own good, but I'm not sure another abstraction on regular expressions is the correct answer either. I would personally recommend against it due to the fact that it's a less documented abstraction of PCRE which seems already has great documentation all over the place. This gem feels like it is saying "throw away all of your knowledge of standard regexp and learn this new abstraction instead"
Saw this on Ruby-Doc and thought you guys might be interested. The National Vulnerability Database (NVD) reports: &gt; **CVE-2015-7541** &gt; **Summary:** The initialize method in the Histogram class in lib/colorscore/histogram.rb in the colorscore gem before 0.0.5 for Ruby allows context-dependent attackers to execute arbitrary code via shell metacharacters in the (1) image_path, (2) colors, or (3) depth variable. &gt; *Published: 1/8/2016 4:59:04 PM*
You're opposed to using an "arbitrary operator" of `&amp;` but you seem to miss the fact `|` is an arbitrary operator too.
I like it, and I think the community needs a little competition to rubygems. The page over from the right when clicking on a gem is a bit underwhelming. I'm sure you could add all sorts of info in there. Some measure of code climate or abandonedness would be helpful. If you go on to do more: - Is it possible to link to a specific gem? When I click on a gem and the right popover appears, the url doesn't change. - Whatever you're doing for search is neat, but it doesn't allow chrome to detect that you have a search function on your site. I never hit the rubygems home page, because I can just type "rubyg&lt;tab&gt;jekyll" and get where I want without hitting the home page. This might just be a simple html tag you publish, but I don't remember. edit: formatting.
I have been toying with the idea of making a Rubygems.org proxy. It is still a work in progress, but the basic idea is to change the source of your Gemfile to one that is your proxy. By doing this, the proxy should return the list of packages and dependencies information. If you have a gem in your Gemfile that does not exist on the proxy, the proxy will download it from Rubygems. If the gem and version does exist on the proxy, it will be served from the proxy instead of Rubygems. My whole idea around this is that having a local proxy is a two part idea. 1. For downloading them gems will be much faster than downloading off of the internet. 2. If a gem is yanked, I will remain unaffected and my application will not need any immediate alternatives. I've spun up a public facing portion of this to toy around with. It by no means is efficient, but just working on the proof of concept. There are some watchdog timers that will automatically check for recently updated gems as well as new ones and pull them on a periodical basis. https://gems.driftingruby.com/ My thoughts are along with robacarp. The Ruby community needs trusted mirrors.
I will definetly check that out! Thanks
I have not tried it because I am not running RVM. I just installed Ruby from the Ruby website.
Have you looked at [geminabox](https://github.com/geminabox/geminabox)? Works exactly like what you're describing. We use it at my office (in Docker containers) and have been very happy with it. Rubygems offers a good-better-best scenario for this type of functionality here (including geminabox): [Run your own gem server](http://guides.rubygems.org/run-your-own-gem-server/) 
Nice UX! If you're interested in this sort of thing, you should definitely check out (and perhaps participate in) Gemstash: https://github.com/bundler/gemstash
I gave a short, remote talk yesterday for vietnam.rb group and recorded it, it's a brief intro to ROM: https://www.youtube.com/watch?v=hd3ZRnY1SOk Some of the docs should be ready next week btw, I'll be working on it full-time next week.
Shameless plug: check out [dry-validation](https://github.com/dryrb/dry-validation). I've created it to address this kind of issues and it's a general-purpose validation library. I'm not sure why people started associating "form objects" with some kind of a pattern for handling complex validations. It does not matter where the data are coming from, the only reason why you may want to use some form-specific abstraction is because data coming from a web form almost always must be coerced somehow. As far as validation logic goes, this is a two step process: 1) validate *types* 2) assuming types are valid, apply business rules (if any!). I've found predicate logic to be a great base for validation logic. In example a "contextual validation" is just a simple implication "if foo then bar", that's it. When `foo` is false then the whole statement is true. When `foo` is true then `bar` must also be true to make the whole statement true.
A far more useful link would be [this one](http://www.openwall.com/lists/oss-security/2016/01/05/2). This vulnerability fix was the first commit made in over three years, with only ten before that. I'd be surprised if many people had this in production.
Check out Gemstash: https://github.com/bundler/gemstash 
To be honest, I haven't used that gem either and I was wondering how popular it was. The fact that it appeared in the National Vulnerability Database (which only had a few Ruby entries last year) and, by extension, Ruby Doc convinced me to share it just in case.
&gt; But which one should be prefered? None, because neither of those "solutions" is elegant. There's no reason to avoid an explicit return with such contrived constructs. The only thing these "solutions" accomplish is to make the code less understandable. Also &gt; “each_with_object” and “tap + each” both return the subject object which saves us one line - sometimes even two lines. If you count the lines, then you'll see that "tap+each" doesn't save a single line. 
Eh, no. Sorry. You may not personally be used to it, but that doesn't mean it's a poor style. My team's standards would shun the first example in favor of each_with_object
The second line of code you suggested worked perfectly. Thank you!!
I've used `roo` in the past, which has support for both Excel and CSV and have been quite happy with it: https://github.com/roo-rb/roo
I've looked at dry-validation and I really like it. Very explicit while easy to use. Thanks you solnic for your work with that gem as well as your work with rom. 
It's not an alternative to rubygems, but to ruby-toolbox, which is dead since, I guess, 2013. Thanks for feedback, I'll try to make all of this soon.
Thanks! I have a roadmap in repo and already got some ideas from this thread, especially /u/robacarp.
hi /u/Kache. author here. thanks for taking the time to read the article. I'm surprised that you think my post contained `virtually no useful information` when it includes sections on the following: - Why Rubyists prefer `each_with_object` and `tap + each` over 'regularly explicit' code and over variations of `map`, `reduce`, and `inject` - The visual difference between `each_with_object` and `tap + each` - How to carry out benchmark tests in Ruby - The speed difference between `each_with_object` and `tap + each` - The growth performance cost of a Ruby hash Lastly, the post's title is very obvious; I made no attempt in click-baiting people into reading a huge chunk of text. I can only recommend that you avoid reading about things you `already know`.
You are correct, it is redundant. It's using an abstraction so that you work with an internal defined API (ImageBuilder) instead of the RMagick API. You've got &lt;image creation (your code)&gt; -&gt; &lt;image builder (your code)&gt; -&gt; &lt;rmagick api&gt;. It has a few advantages: - You determine the interface to build the image, instead of relying on the RMagick API - This allows you to swap the dependency without changing all the image building code. You only need to change the ImageBuilder implementation (f.e. if you want to use rasem (svg images) instead of RMagick) - It allows for fast unit tests because you don't have to execute the real RMagick code The negatives are that you have to add additional tests for the RMagick implementation of your ImageBuilder. But this will be an integration test, not a unit test. Also if you change the ImageBuilder interface, you have to update all your mocks (but this shouldn't happen if you define your ImageBuilder logical). It's a disadvantage from mocking (but that is for all mocking). Refactoring your code shouldn't make you change the test because the end result (your image) can only be achieved if those calls occur.
Ruby is pretty good at this stuff, although in the industry at large I'd say Python is more commonly used for these tasks. I would personally use Ruby though (and potentially create data I might then go on to use in R later). There's a new book out from Prag Progs on the topic which I would recommend (disclaimer: I was a TR on it): https://pragprog.com/book/rmtpruby/text-processing-with-ruby
+1 for roo! I do all my clients reports as Excel or LibreOffice and it does a great job of streamlining the laborious task of writing spreadsheet reports.
I think you could add some quick links that copy to the clipboard that would put something like gem 'devise' in automatically
Alternatively, without need additional order reversing: `heroes_list.map {|k,v| [k,v[:health]]}.sort {|a,b| b[1] &lt;=&gt; a[1]}` 
For the nils, you can use array#compact to get rid of them. For the spacing and \n, try using a regex. If you don't know how to use them, they can be fun to learn. It always takes me a couple of tries to find one that works. 
For solid Excel stuff (as well as a chance to actually multi-thread things, if you have a lot of data) look at using JRuby with the apache POI library. There's a pretty good wrapper at https://github.com/kameeoze/jruby-poi
What are those nils supposed to be? From your examples it seems we should just ignore them: content.map { |array| array.last.strip }.reject { |e| e.empty? }
&gt; [[nil, ""], [value, value]].select { |item| !item.first.nil? } No luck. Maybe i'm doing this wrong : content.select { |item| !item.first.nil? } it returns 0 since i think all elements have the nil in them? : [nil, "\n \n Ticket-Ticket-Ticket#\n \n "] Maybe its seeing the 'nil' in the first element so it drops it too?
wow . yes . This did the trick . Thank you !!!! Now to remove the ' \n ' using the gsub . Thank you again!
&gt; You may not personally be used to it, but that doesn't mean it's a poor style. What is poor style and what is not is a very subjective. In my opinion, using each_with_object in the described way has the following problems: - It hides the initialization of an (effectively) local state in the argument of a method call - It hides the assignment of a variable to said state by separating it between an argument to a method and a block argument. - It obfuscates the return value. In a long function, I have to scan back quite a bit to find out what the function will return. And again, I have to search for it in the argument of a method call - It has a performance penalty and only one real benefit: it saves you from writing two lines. In my opinion - your mileage may vary - something that only saves typing two lines once, but has negative impact for the lifetime of the code, is not worth it.
The whole point is to localize the state and effects of a method call. If you don't declare or initialize a hash you don't worry about mutating it unnecessarily. The only place you can mutate it is inside of a narrowly scoped block. Really the only objection you have is that it's not idiomatic to the type of ruby code you write and that it's slightly less performant. I'd say the first is an issue with your familiarity and the second deserves a "who cares?"
Could you explain what you mean with "don't declare or initialize"? As I see it, you initialize it in the call to each_with_object and declare it in the block parameters. I really don't see that "whole point" since I don't understand what you are "localizing" and especially not why I should "worry about mutating it unnecessarily". &gt; I'd say the first is an issue with your familiarity I have a different opinion. It's a case of code that's easy to understand. Practically every programmer will understand the non-each_with_object version immediately and grasp rough details without reading the whole code, while only a Ruby programmer with knowledge of the each_with_object method will understand what's going on and only after searching somewhere in the middle of the code for the call to it. Even a programmer that's used to the each_with_object style will take longer to understand what exactly the returned value is.
Thanks!!
A combination of compact, gsub and strip should clean these up e.g. [nil, "\n \n Final rsync of website files to CBS\n \n "].compact.map { |a| a.gsub(/\n/,'').strip } =&gt; ["Final rsync of website files to CBS"]
Pretty much anything that you would do with rails or sinatra.
What are you actually trying to do just cleaning text or actually creating statistical models and outputs on that data?
I'd recommend to do this transformation in one pass. Less elegant but twice faster.
It is telling you openssl is not loading properly, if you consider that gem install is going out to try to grab files over https and openssl is not configured right you should be able to understand that the fix is to ensure openssl is properly installed and that your ruby is properly installed to utilize openssl. 
TR?
If you prefer not using an explicit return there, that's a legit choice, I guess. But then why wouldn't you choose between each_with_index and tap.each based on which you prefer stylistically too? A 9% improvement in a micro-benchmark is not a good motivation for code style choices. In these particular cases, I agree with some other commenters that some use of `map` would be preferable, but there are occasional cases I've needed to use each_with_index and/or tap+each. I wouldn't choose between them based on a minor difference in a microbenchmark. 
technical reviewer - usually with programming books a publisher will reach out to several independent people in the industry to do a sanity check on the book. I did not do a lot on this one but did skim each chapter before release and sent notes. Some technical reviewers, however, are deeply involved with a book and work closely with the author.
Oh right! Sorry. Basically what I did was cd /tmp wget -c http://ftp.ruby-lang.org/pub/ruby/2.0/ruby-2.0.0-p0.tar.gz tar -xzf ruby-2.0.0-p0.tar.gz cd ruby-2.0.0-p0 ./configure make
 cd ext/openssl ruby extconf.rb make &amp;&amp; sudo make install cd .. cd ext/readline ruby extconf.rb make &amp;&amp; sudo make install cd .. make sudo make install Or just use rvm/rbenv like a sane person. 
Oh true! Sorry didn't look at the input data closely enough. And you are spot on, it was rejecting all items that had nil as the first element which was all of them. Looks like you've got it sorted now though :)
I was going to do everything in R, but I saw this book and it is what had me consider it. I think we have Safari, so I was actually going to see about getting it.
Yes - but why? So far every time I chose Sinatra for something more than a one-liner, I ended up requiring features from Rails. I've never used Padrino but if it's Rails without Rails, why even bother?
I added it for the next version, now it ignores the symlinks. Thanks for your idea!
V. fair re: my nervousness—I thought I had this one in the bag, then Matz sat down front row center!
I used to use *reduce/inject* or *each* only to perform similar task. So I added benchmark for them: x.report("each") do hash = {} array.each do |integer| hash[integer] = integer ** 2 end end x.report("reduce/inject") do array.reduce({}) do |hash, integer| hash[integer] = integer ** 2 hash end end Here's the result in case anyone wondering: Calculating ------------------------------------- each_with_object 45.902k i/100ms tap.each 47.219k i/100ms reduce 42.670k i/100ms each 50.733k i/100ms ------------------------------------------------- each_with_object 670.726k (± 6.1%) i/s - 3.351M tap.each 734.202k (± 4.6%) i/s - 3.683M reduce 631.313k (± 5.1%) i/s - 3.158M each 820.097k (± 5.3%) i/s - 4.109M Comparison: each: 820097.2 i/s tap.each: 734201.6 i/s - 1.12x slower each_with_object: 670726.1 i/s - 1.22x slower reduce: 631312.6 i/s - 1.30x slower
/u/jrochkind, thanks for reading. you're echoing the same thoughts as in the conclusion in my post, where i've deemed the performance difference negligible in most scenarios and decided to stick with `each_with_object` because of the (IMO) elegance it offers.
/u/jrochkind, just replied to another comment of yours. again, thanks for reading. and i believe you mean `each_with_object`, not `each_with_index`. to answer, i did make up my mind stylistically early on in the article. but i cannot blindly opt for a syntax because of its sugar. i need to confirm that my choice of syntax isn't adversely affecting the application's performance in a significant way. hence the benchmark.
CSVs are easy to handle in Ruby. There's a CSV library, but I find it's actually simpler to just roll your own: arr = data.split(/[\r\n]/).map{ |x| x.split(",")} If your data is quote delimited, you can just do something like: arr = data.split(/[\r\n]/).map{ |x| x[1..-2].split(%Q(","))} And boom, your data is in a nice 2D array for easy processing. For Excel files, as long as they are .xlsx, you can use the rubyXL library. It's not terrible intuitive, but it should be fairly easy to wrap it in something to extract your data into a 2D array, especially if the format of your Excel files is pretty consistent. Once your data is a 2D array, you can do pretty much anything with it.
If you're using Rails, just use [ActiveSupport::Cache](http://guides.rubyonrails.org/caching_with_rails.html#low-level-caching) set to :memory_store, instead of basically re-implementing it. 
Using indentation as part of the syntax, actually makes the syntax very strict. What I love about ruby is the flexible syntax. Besides the syntax, this looks awesome.
Whenever i see someone ask about doing data science or text processing in ruby on this subreddit, there are peeps recommending to use a different language and it makes me sad :'(
Before you resort to scraping websites, you should look them up in your OS. In Linux: `zdump -v US/Pacific` (or whatever timezone you are in, look in /usr/share/zoneinfo) will give you all currently available adjustments. On my system, up to the year 2499. That being said, you should never use "human readable time" for computers. Always use UTC in your programs and in the very last step convert it to human readable time according to the operating systems definition of it (timezone, dst). The ruby time class from stdlib handles dst correction automatically for you, when you convert a utc time object to localtime.
I agree, this seems geared at an audience with such a low degree of competency that their time would be better spent just learning the language.
&gt; I don't think offset lookup is what OP needs The stdlib can't tell you if `America/New_York` is UTC-5 or UTC-4 for a given period date, this is the lookup I'm referring to. An example of what OP is asking for: require 'tzinfo' tz = TZInfo::Timezone.get('America/New_York') tz.current_period.local_end # end of the current daylight saving time cycle in local time =&gt; #&lt;DateTime: 2016-03-13T02:00:00+00:00 ((2457461j,7200s,0n),+0s,2299161j)&gt;
Just because there are _some_ operators doesn't mean there should be more. And in fact, ideally in my view there would be no special operators at all, they'd just be functions like anything else. You know, like in Scheme.
Thanks for the pointer to the OS /u/tashbarg that looks like it could be a winner. My application is a simple script that will email a daily reminder of how many days it is until the next change in DST. 
This is just my personal opinion, I don't see anything wrong with the gem or using it but I would much prefer just to implement the JavaScript solution. I am not too saavy with JavaScript either but it is an important skill so I would rather instead of avoiding my shortcomings approach them directly and just learn the language. The only downfall I could really see is you are not exactly certain of the fate or support of the gem in the future. Sticking with React core is not a bad idea. As long as React is still relevant, there will be a dedicated and _paid_ team working on it.
It just looks like React normally does but written in Ruby syntax. As much as I like Ruby I'm not sure I like the idea. It's another layer of dependencies that doesn't add enough for me to justify it.
The problem is not the technology, it's the attitude of front-end devs. The zeitgeist right now is that es16 made javascript "good enough" that everyone should use it so you don't have another language compiled down to js. (of course es16 _is_ compiled down to the js that runs on the browser but that insight is not part of the zeitgeist). I like coffeescript because I'm dyslexic and the syntax is easier to read. Front-end devs tell me I'm wrong because es16 implemented arrow functions so there's no need for coffeescript anymore. You can try to explain to them that the "don't break the web" attitude (which is a good one) means that javascript can never have a major version bump to fix things like equivalence or add an existential operator and they tell you you're wrong because es16 implemented the arrow function. Anyway, Ruby is obviously a great language to work in and, if you set up a dev environment with broccolli or something, it won't make your development much more complex than just using javascript. But, you'll never be able to hire a font-end dev who will work in Ruby. I think it's a case of Stockholm Syndrome and people who only know Javascript have been so scarred by learning all of it's idiosyncrasies that they have convinced themselves that it must have been worth it. Personally, I prefer to work in sane languages that are easy to learn because they have consistent semantics. But, I always have to deal with a ton of shit from JS fanboys.
I havent tried them but big nerd ranch might have what you want. https://training.bignerdranch.com/classes/ruby-on-the-server
&gt; I think it's a case of Stockholm Syndrome and people who only know Javascript have been so scarred by learning all of it's idiosyncrasies that they have convinced themselves that it must have been worth it. FYI, since you're praising CoffeeScript and bashing JavaScript at the same time: CoffeeScript still has most of the flaws JavaScript has (+ [broken scopes](https://donatstudios.com/CoffeeScript-Madness)). CoffeeScript is mainly syntactic sugar around JavaScript and suffers from the same semantic issues (`==`, strange type coercion, ...). If you like languages with little syntactic noise you might like PureScript.
~~It's called ES6.~~ You can compile ES6 to an earlier version, just like you can with CoffeeScript.
This is probably because I don't understand the needs of data scientists, but I'm having trouble understanding the advantages of a `DataFrame` type. Rhetoric like "Because, it’s, like, 2016?" doesn't help. Could someone expand a bit on the rationale for a `DataFrame` type, as opposed to a simple array of hashes?
Done. The OP now includes not shitty code.
That was last year. It's es2016 now.
Equivalence is not broken in coffeescript and I've never had a scoping issue. 
Still shitty code. Looks like you forgot to do your homework again. 
Is that the same as ES7? ES6 also has arrow functions. I actually think I like ES6 a bit more than CoffeeScript having worked with it a little bit now.
Basically a data fram is a hash of arrays instead of an array of hashes. The advantage can be data locality (if you often want part of the "row" for all rows), and less overhead (you don't have n hash objects (one for each row), you only have k arrays + 1 hash, k will be much less than n), which also will have a positive effect on GC time. The caveat is that I'm not an expert, and have never needed to use them, so I may have misunderstood their advantages.
I do, indeed, mean UTC. From a programmers perspective, it's not about actually measuring the time, but about using reference points in time. The most important thing with that is continuity and disambiguation. Posix timestamps work quite well, but have ambiguity when leap seconds occur. For example, 915148800 happened twice, so if you logged that as reference somewhere twice, you can't be sure if things happened simultaneously (with regard to precision) or one after the other. UTC doesn't have that problem.
Scroll up, pick any starting point.
Great article! I find that good resources on test setup are hard to come by if you're not using rspec, so it's nice to see some minitest examples. If I read correctly, it sounds like your tests would mostly be model validation and capybara integration tests, since you said you don't do much controller testing. I'm curious how that is working for you. Are you able to hit sufficiently high coverage on integration tests? When I've read other testing articles, I often see advice to test your major pathways in integration, but to ensure that controller actions are responsive, and verify appropriate authorization redirects actions occur for non-privileged users. Do you take care of that in integration tests as well, or just assume that's not a part of the app that is at real risk of breaking?
wut? why not just spawn 4 threads? It's like wrapping each of the 4 method calls in `Thread.new {}` and then join. `/me` missing something? EDIT: I mean, all the EM stuff certainly has it's place and use cases, but that example seems kinda silly.
Nah, I'm a Weenie Hut alumni. 
@so_just This release is focused on assets. Starting from tomorrow we'll explore DRY gems and ROM.
Oh, I know threads vs fibers and that was not my point, that task could have just created fibers but without the whole EM thingy, right? EDIT: Oops, it appears that I didn't know Ruby fibers after all. They are Coroutines and yes, then this all starts to make sense, even the "compatible http library" requirement. Anyway, threads and thread safe code have become a trivial thing, so once you know how to handle them, the main worries outlined in that post go away. Performance-wise, yes, when the code is I/O bound, Coroutines work more efficiently.
The writer of this blog post starts out by saying, "If you develop software long enough, you notice patterns. One pattern that isn’t talked about enough is how systems evolve over time." Then he spends the rest of the article sourcing books and articles that discuss how large, complex software systems evolve over time. Personally, I've found that _most_ of the literature I've read on the practice of programming and the practice of systems administration is about how to manage the complexity of systems as they evolve. Having said which, if you've not read a blog post about that topic this one seems as worthwhile as any other. Read it for an overview, then read the numerous sources he links to :)
Correct, the point of the EM library is that you don't need to care about orchestrating the Fibers. Like all Ruby code, you can do the same thing many different ways. As an example, this code needed to be relatively simple to grok within 3-5 minutes. So yes, you could accomplish the same thing with manually coordinated Fibers.
Please don't use EM-synchrony. Fibers with their fake blocking semantics make for a truly hell on earth debugging experience. Use threads with real blocking semantics.
Its about the API to access the data. " DataFrames provide a domain-specific language for distributed data manipulation. " https://databricks.com/blog/2015/02/17/introducing-dataframes-in-spark-for-large-scale-data-science.html But there is definitely overlap with SQL.
Yeah, I've already been told it's most weak part of my reasonings :( I was too brief in this part, considering it "obvious" (which it is not). Yes, DataFrame is almost, but not completely like hash of arrays (not array of hashes: column is "solid structure with homogenous data"). But it is also almost, but not completely like Matrix (2D array). Excel tables are also close. Fact is: when you have structure like: month | visits | users | data ------+--------+-------+--------- Jan | 10'560 | 832 | 10.0 GiB Feb | 8'234 | 601 | 8.3 GiB Mar | 12'083 | 1034 | 12.6 GiB ... ...You have no good data structure to handle it and perform "most intuitive operations". And you have this kind of data everywhere.
Are you able to interact with plain old websockets? Can you provide information on what you have attempted? Logging from those attempts? Need more info to help.
I need to flatten it so that I can load them into a local db and also for peoples to see it in Excel. one day I might be awesome enough to mess with JSON but not at the moment. I appreciate the quick reply as well!
This is the API I am trying to connect too. https://www.okcoin.com/about/ws_getStarted.do I have not tried interacting with plain websockets as this API does not support it. I could test with another, but I haven't gotten to it.
Hmmmm, well, one way would be to teach yourself how these things work. https://github.com/simulacre/sinatra-websocket is a super easy websocket server. https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications is an easy way to get started interacting with it, if you know JS + Html. Otherwise, grab a client from ruby gems and interact with it that way. Then throw nginx in front of the websocket server, do a google for 'upgrading websockets to secure websockets nginx'. Without logging and some idea as to the code you are writing, I can only tell you how to teach yourself.
I would strongly advise you to learn navigating ruby hashes, as it reprisents JSON almost 1:1, and other languages use it heavily, namely JavaScript. look into flattening your hash, then you can get all of the keys or values in an array (array.join(",") will take you to csv). If you have a csv structure that goes: key,value,key,value... then flatten the hash, and do something like kv_array = []; flat_hash.each { |key,value| kv_array &lt;&lt; key &amp;&amp; kv_array &lt;&lt; value }; return kv_array.join(",") note, there are many many ways to do this. Probably better ways using array.zip or something.
http://stackoverflow.com/questions/9647997/converting-a-nested-hash-into-a-flat-hash A gem would be way overkill, if not redundant. The above link has some copy pasta functions that might work for you.
if anything good practice looking at how they dealt with their hashes. thanks for the linky-doo
That's right, I use service objects and form objects a lot.
Ah I see what you meant now, thanks.
Surely there are specific critiques? And surely you're not just trolling?
Coffeescript is not [really on the rise anymore.](https://www.google.com/trends/explore#q=coffeescript)
I'm younger than 30 and I know Lotus, but only from cautionary tales.
[ES6 however...](https://www.google.com/trends/explore#q=coffeescript%2C%20es6&amp;cmpt=q&amp;tz=Etc%2FGMT-1)
I'd just like to add that there are those of us who don't make the call as to what languages we use professionally. Therefore, it doesn't really matter how fashionable or popular it is if I have to use it every day.
It's a bit ugly, at least for the sum part I would have written a small function `sum_hourglass` that gets a position inside the array. But anyway, there are several approaches to do this and to keep with your code you could simply emulate the Java code like this (assuming your data is in the form array in array): max = 0 (0..3).each do |row| (0..3).each do |col| sum = ... max = sum if sum &gt; max end end Not very good Ruby style I think but would work.
So would i be able to sum up, let's say, first 3 indices in the row by doing this? sum = arr[row] + arr[row+1] + arr[row+2] 
Sorry, forgot the most important part. You would do it like this: sum = arr[row][col] + arr[row][col + 1] + arr[row][col + 2] That's assuming the array looks like this: arr = [ [1,1,1,0,0,0], [0,1,0,0,0,0], [1,1,1,0,0,0], [0,0,0,0,0,0], [0,0,0,0,0,0], [0,0,0,0,0,0] ] 
A great way to get the behavior of 2D arrays in Ruby is to use a hash whose key is an array representing the vertices of the 2D array. Java: array[x][y] Ruby: hash[[x, y]]
Why are you including a module to have it extend? Why not just do: module SomeModule def some_class_method end def another_class_method end end class ParentClass extend SomeModule end
If you look at the implementation of Forwardable, you'll see that the accessor used is just turned into a string and evaluated. This line (in the current trunk, so your version may be slightly different) https://github.com/ruby/ruby/blob/7cb5b7dd23afa39fe569f8312b4fe84e66ac8e61/lib/forwardable.rb#L180 essentially creates a string which is turned into ruby code. If you want to define instance methods which will automatically forward to the class methods of the same name, then you can do it like this: class Thing extend Forwardable def_delegator 'self.class', :some_method def self.some_method; end end In the code above, you haven't shown how you're trying to use methods from Forwardable, so it's not clear to me where things aren't working. I don't know if this is similar to what you are doing, but this works: require 'forwardable' module SomeModule def self.included base base.extend ClassMethods end module ClassMethods def some_class_method end def another_class_method end end end class ParentClass include SomeModule extend Forwardable def_delegators 'self.class', :some_class_method, :another_class_method end class ChildClass &lt; ParentClass end I wrote a blog post diving into Forwardable last year http://www.saturnflyer.com/blog/jim/2015/01/20/ruby-forwardable-deep-dive/ and although it appears the code has changed a little in the standard library, it's still pretty much the same.
As an alternative, if you just want to put the forwardable shortcuts in the module itself, you can do this require 'forwardable' module SomeModule def self.included base base.extend ClassMethods end module ClassMethods def some_class_method end def another_class_method end end extend Forwardable def_delegators 'self.class', *ClassMethods.instance_methods(false) end Note that the reference to ClassMethods must come after it is defined. I also prefer to put the extend Forwardable closer to where it is actually used (rather than up at the top).
* Make a clone of a popular website * A blog * To do app * Job board * Forum
TL;DR: Crouton allows you to run linux on chromebooks. Chromebooks are cheap and good. FYI, if you want virtualbox or Docker, you will have to do some extra work. I use a $300 toshiba chromebook, runs great HD display, blah blah. If you want a real sweet machine https://store.google.com/product/chromebook_pixel_2015?utm_source=Chromebook&amp;utm_medium=PP&amp;utm_campaign=Chromebook_Pixel_2015
Here's an example, an event publishing website. It has a few models and some of the interactions can be implemented with Ajax. Users can: - sign up - create and edit events - events are on locations, so users can also create and edit locations - both events and locations can receive comments - users can "RSVP" to an event
Anyone doing this for 2.3, or is it essentially unchanged?
As for testing ruby methods, I typically write tests in rspec or minitest and run that file. I use Sublime Text 3. I had coworkers who used RubyMine mostly for the ability to click on a method and jump to its definition--even if that method is defined by a third party gem. It's a really nice feature, however RubyMine is too sluggish for my taste. But your preferred text editor should be fine for ruby. As for structure, that probably varies a lot on what the project is. Ruby became popular in part because of Rails, so you'll find a lot of developers are familiar with that structure. If you're writing a gem, this might be helpful: http://guides.rubygems.org/patterns/ 
I do appreciate this's existence, but I must nitpick. &gt; 0) Since everything in Ruby is an Object Object === BasicObject.new # =&gt; false &gt; 13) The `defined?` method `defined?` is a keyword. &gt; 23) Once you freeze an object it cannot be modified. [Unless you get crazy.](https://eval.in/501842) &gt; 25) Top level scope objects can be accessed with :: And `nil::` as well for when you need to do some kind of dynamic scope resolution that should bottom out at the top level. &gt; 33) %x I'll just leave [this](http://idiosyncratic-ruby.com/15-207-ways-to-rome.html) here. &gt; 57) String#replace `#replace` is available on `Array` and `Hash` as well. &gt; 64) Using Array#() That's actually `Kernel#Array`. &gt; 74) dynamically naming classes You most certainly do not have to resort to `eval`: module M const_set 'SomeClass', Class.new { # methods here } end &gt; 81) Numbers succ They're `#pred`ators too. &gt; 87) at_exit And `BEGIN { ... }` for running ASAP. &gt; 95) block_given? For which `defined?(yield)` is a synonym, but you should forget this. :) &gt; 97) $; On the flipside, `$,` is the default `#join`er.
And that's good. Hopefully, the things you find "painful" will get called out by enough people, and improvements suggested (borrowing from CoffeeScript *et al*) that we all wind up with better, continuously improving tools. `$DEITY` knows we need all the help we can get. Good luck, Mr Phelps.
Well, I'd had several years' OS/360 experience by the time I was 30 (and it was a hysterical artefact by then), so I'm not surprised. Thank whatever Supreme Being(s) you believe in, however, that you never had to directly wander into *that* maze of twisty little passages.
I'm curious why you're using a hash for chess, as opposed to an 2D array. What does your "move" logic look like? But for this particular situation I'm guessing you have a hash that represents an empty board, with all the keys having a value that represents an empty space. I'm guessing you also have an initial board state as well, so that your game knows where new pieces should go. You could use board.merge(initial_white) which would return a new hash of the two, preferring the values of initial_white for any duplicated keys. Also, though I doubt this is what you're looking for, you can set the default value for keys in a Hash. By default that value is nil, but you can change it using Hash.default(foo) or when you instantiate a new hash Hash.new(foo). Useful if you wanted to set what the value of "multiple" keys are before you assign the key an actual value.
If you were using primitives, or if you wanted there to be references to the same object, you could do something like `hash["a1"] = hash["h1"] = Rook.new.white`. The problem with this particular approach is that it'll create a single Rook object which is shared (in a sense) between both keys. You can verify this yourself by inspecting the hash. Within the context of your program, it'd be as though there were a single rook that happened to occupy two spaces, as opposed to 2 new objects. Your current method is much better, even if it feels messy. More generally, it's possible that there are better systems for representing the board. Notably, a 2-d array (as /u/zaclacgit suggests) might be worthwhile, as it lets you use the array indices to do math and determine where pieces can go.
I really like [guard](https://github.com/guard/guard) for my tests, and I sometimes use [entr](http://entrproject.org/). They will run tests for me when a file changes. I personally use Minitest and it gets the job done I usually try to write tests first. I don't typically use IRB unless to play around. If I can't write tests first, I write only enough code until I know what tests I'll need and then write those. Over the years I've become more laid back with my testing and only try testing things that are useful, but that's more out of comfort and experience. I work with vim primarily. I moved to it from SublimeText. I like it because it's easy to extend, is cross-platform, and doesn't make me leave the terminal. I don't feel there's much need for a full IDE in Ruby. For structure, it depends what you're doing. Sinatra, Rails, and gems all have their own conventions that most projects use for directory structure. You could take a look at some of those projects for examples. In the end it's up to you.
This "sharing" of things took me a bit of time to wrap my head around at first, and it can trip you up something fierce when you're not looking for it. A real life example is pretty easy to understand. Karen, Jim, and Stuart are roommates that have moved into a new home. So far you've only met Jim, but since he's a good friend you ask him where his house is. Being the forgetful type, you write down his address on on a post it note. You then stick this address on your bulletin board. On occasion, you send gifts for the new home to Jim, always using your post-it note on your bulletin board to remember which house is his. From time to time, you ask "Oh, Jim. I sent another tea kettle! Did you get it?" Jim replies, "Yes, the house has two tea kettles now." After awhile, you meet and befriend Karen and Stuart. Since they're nice people, you decide that you'll want to send them gifts as well. You put two more notes on your board. One says "Karen has the same house as Jim." The other says "Stuart has the same house as Jim." You send a nice set of dining room chairs to Stuart, but since you're forgetful you ask him how many chairs the house has. "Five" is his reply. All is good. One day, you learn that Jim is moving out. Stuart and Karen got married, and Jim is going to find separate lodgings to allow them some privacy. You dutifully record Jim's new address, and replace the old one on your board. Some time later, you want to send Karen and Stuart a wedding present, and that's when things get weird. You check your board to see where Karen and Stuart live. Your note says that Karen lives where Jim lives. So you send your package to that address. Later, you run into Karen and ask if she got the gift. She tells you that she did not. What?!?! You know that you sent the gift correctly. You've sent hundreds of gifts, to hundreds of homes! So you send the gift again. Nope. And again. Nope. And again. Nope. You check the other gifts that you've sent in the mean time. They all arrive at the right houses. Weird! Finally you give up and ask Karen what her address is. You must have gotten it wrong. You write it down. You take it to your bulletin board. And you see your note that says "Karen has the same address as Jim." So you take your new note with Karen's new address, and replace Jim's address with it. After all, Karen has the same address as Jim, so logically Jim has the same address as Karen. You send the gift again, and the next time you talk to Karen she confirms that she received it. But then one day you run into Jim again. He wants to know why you sent him seventeen separate shipments of "His and Hers" towels awhile back, but haven't sent anything since then. This sounds familiar. Luckily, you know the solution! "Give me your address again, Jim! Somehow I messed them all up." You know the story. You get to your bulletin board and replace the only address there with a new one from Jim. Then one day, Stuart calls. He and Karen are splitting up, and he needs a place to stay for awhile. Can he stay with you? Sure, you say. And you go to your bulletin board, replacing the address there (which is obviously for Stuart) with your address. That's when you're become convinced you're a terrible friend, everyone's a better friend than you, and you should just give up on trying to be a friend all together. Because suddenly Stuart's, Karen's, and Jim's gifts all keep coming back to your house. 
Thanks for the input. The event site sounds like the sort of functionality that I would like to write. I might do a spin on that. The other ideas are also good. Keep me coming. 
Keyword arguments? Adding setters for the sole purpose of construction isn't a good idea.
So what is... Dockerizing?
This isn't really a builder, it's not much more than an object with `attr_accessor`s. A builder would not alter the `Smartphone` constructor, instead the `SmartphoneBuilder` would have a `#build` that constructed a `Smartphone` based upon it's internal state. Also, with a builder the "setters" usually return `self` for chaining. That way you end up with something like: builder = SmartphoneBuilder.new builder.set_model("Apple iPhone 6S") .add_touchscreen(4.7) .add_processor(1.84) .add_ram(2048) .add_memory(16384) .set_os(:ios) order.products &lt;&lt; builder.build Actually, I've noticed that the lack of a `#build` means that the loop in the example would append the same `Smartphone` instance each time and each iteration would "change" that instance. This way `Smartphone` can be immutable, with the convenience of mutability isolated to the `SmartphoneBuilder`.
Agreed, that seems like over-ingeneering
Thanks for highlighting Middleman. Will try to add a sample site for Middleman (Ruby) and Metalsmith (JavaScript) in the next days. Of course, any contributions welcome. Cheers.
&gt; The commands (for example in the article where the author generated a rails controller) are just too verbose That's a non-issue, just use aliases/bash functions.
Which is funny that the standards body re-named it from es6 to es2015. On a marketing standpoint, that name decision made no sense. 
Valid argument. something worth thinking about before spending hours to learn it. 
No, we invented the term 'google' to mean search for it. Could you imagine trying to say googlize it. Ha. 
No need for that here. Americans have done lots for computing (and Ruby) so chill out. 
This is very incomplete, it doesn't show the relationship between classes and metaclasses or the very interesting circular relationship between higher order singleton classes and their classes, and so on.
I live in SC but I work for a company in LA and have made 8 or 9 trips out there in the last year and a half, so I know the area reasonably well. I personally hate with a passion everything about LA except for the food and the weather. Traffic, high cost of everything, downtown has people living on the sidewalks in tents (not just in skid row)...there are some cool things spread around (mostly restaurants/bars), but I dread visiting. Obviously others love it there or they wouldn't live there. You couldn't pay me enough to move there...my 2 cents.
You hit the nail on the head with "vanity and relationships." There are people to be sure that have good families, but nobody I met really has good friends. Never lived there, but visited a number of times for work.
LA has 10m people, and most aren't in "the business" (entertainment), so I wouldn't rely on stereotypes about the people. There are people from UCLA, USC, Caltech, etc. There are people from JPL, Google, SpaceX, etc. However the reputation about weather, traffic, and cost of living are accurate. LA works if you make enough money, live close to work, and live in a neighborhood you like (LA is less a city and more a sprawl of neighborhoods). 
Actually it is 13.1m in the metro and 18.3m in the combined statistical area. There are a lot of people here... Also all the things you said are true, you can find all those people and make friends with those people without needing to worry about entertainment industry people at all.
LA is an absolutely amazing place to live but she is a hard bitch to love. It isn't an easy city thanks to the way it is spread so far, but once you find out how it works, and where the things and people you like are, there is just so much here - it just takes a bit of time and work. Once you do figure it out though you are fucked, because then you start looking at other cities and pretty much any place that you'd want to move to would seriously lack in some departments compared to LA. As for your question about stereotypes, that's bullshit. Do we say that all New Yorkers are douches because Wall Street douches are a stereotype? The fact is that the entertainment industry draws people who just want to be famous, if you aren't in the entertainment world, you don't deal with those people or even see them. There is food of all cuisines, and not just one restaurant, loads to choose from - and the produce is fresh all year. Also SoCal has breweries all over the damn place if that is your thing. You can do basically any activity you can think of within a 5 hour drive of the city - I'm struggling to think of what isn't available. If you like live music, we are spoiled silly here. Every large band in the world books LA as a tour date and often for multiple shows - the fact that the entertainment industry is here also means that when they come here they put on the best show they can. Then there is the weather and what it means to be able to be outside and using the world all year long. Want to hike in December? Go do it! Want to go scuba diving in January and not freeze? Go for it! It's also easy to get out of town, LAX has a ton of flights and, having grown up in a smaller city (I don't know where on the east coast you are), its cheaper to fly when you don't have to first fly to a bigger hub city. Not going to lie, it is fucking expensive here, so make sure you get a good salary. Also you want to live close to where you work and have fun, because the traffic is as bad as people say - the less you commute the happier you will be.
That is some sound life advice there. Thank you drunken_thor.
&gt; As for your question about stereotypes, that's bullshit. Do we say that all New Yorkers are douches because Wall Street douches are a stereotype? Thank you for saying this to me -- I needed to hear it. &gt; There is food of all cuisines, and not just one restaurant, loads to choose from - and the produce is fresh all year. Also SoCal has breweries all over the damn place if that is your thing. You can do basically any activity you can think of within a 5 hour drive of the city - I'm struggling to think of what isn't available. Hell yes. &gt; Not going to lie, it is fucking expensive here, so make sure you get a good salary. Also you want to live close to where you work and have fun, because the traffic is as bad as people say - the less you commute the happier you will be. Thanks for the heads up. I'm copying and pasting a question I asked someone else in the comments chain about this issue: As a single 25 y/o with no children, how much income is enough to be able to generally not worry about money and live by myself? I work as a part time consultant and bring in around $40,000 a year. I can afford to live by myself and eat out most nights of the week while making a larger purchase once every month where I live. I'm expecting to bring in around $110,000 if I switch to full time in LA. ___ P.S. Is riding dirt bikes in the desert a thing out there?
You'll be fine then. Just don't expect to live in a giant modern house / condo next to the beach. You can probably find a really nice duplex or bungalow, with a backyard and recently renovated, in a neighborhood near where you are working for like $2000-$2500 /mo. The nice thing about LA is that it isn't all apartments, and it isn't all single family houses. There's a mix of both and you can pick what sort of housing situation you want to be in. If you decide to live in one of the more built up hubs of the city then you can find a cool apartment and be close to lots of stuff, or you can also find a house to rent and have a more laid back lifestyle, even in the middle of the city.
Does SC stand for Southern California? If so, how do you like it down there? 
Nothing that is as battle tested as SQLite. What is your usecase that forbids a relational database?
You can use SQLite and just use one table for key, value store. There is also UnQLite, or if you want something smaller write in a hash and dump to a yaml/json file.
Dang, you're all over this thread. Awesome.
Write in atom, test with rspec and selenium, debug with puts. 
You haven't really described what it is your trying to achieve nor why you don't want SQL. There are of course thousands of ways to persist data without SQL but without knowing what your trying to do it's impossible to recommend anything. 
&gt; You just don't want to look over the hill in the Valley if you have to work in WeHo. The commute will kill you. Is Venice in the area that you are advising not to be in if I work in WeHo? I can get by with smaller space if that means I have a nicer view or area. Garage is essential, though, and that is nice to hear that you have a two car garage. Do you mind giving out a general ballpark of what you pay for rent/mortgage? Sorry if I'm overstepping by asking that. 
`unless false` gets optimized because it is hardcoded. Try this out: puts RubyVM::InstructionSequence.compile("x = false; unless x; 'iztroo'; else; 'izfalz'; end").disassemble
No worries. I pay $2700 but I'm 2 blocks from the beach. I can hop on my bike and have my toes in the sand in 5min including locking up the bike. I'm actually thinking about moving though because it is really hard to find more space in Venice without paying a ton more money - the influx of really wealthy people to the area has driven rent waaaay up. Oh I forgot to mention that LA is currently going through a bit of a renaissance right now. There is a ton of money flooding into the city to build new stuff all over, there's public transportation that is finally getting seriously tackled, and there is just momentum from the fact that we weren't ever really hit that hard by the recession. The upside to this is that there are huge swaths of the city that used to be marginal at best that are *rapidly* being gentrified / connected to the rest of the city. There's opportunity here in a way that is hard to find in other places unless you happened to be living in NYC in the 80s. So for instance there is a whole neighborhood around the 10 freeway that is between the greatly gentrified Downtown / USC on the east, and Culver City on the west called west Adams. The new light rail that goes from the beach in Santa Monica to Downtown runs through it, and there are a ton of old craftsman houses and other beautiful properties. It has been a shitty neighborhood for many years, but that is changing so incredibly fast. If I were in the market to buy a place I'd be looking there. It's going to be the next big thing in the city. http://la.curbed.com/archives/2016/01/los_angeles_west_adams_neighborhood_guide.php
berkleydb has been around for a very long time and is a simply key/value store. 
Kyoto Cabinet (formerly Tokyo Cabinet) might work for you. It's the key-value store equivalent of sqlite. 
How are the trackpads on those? I am using a work Macbook Pro. I just can't imagine giving up the trackpad. All windows ones I have used sucked.
Here's a hacky way. Store data in JSON format and update a file with that JSON. Then load and parse that file back when needed.
Not that I could find, at least not that would easily work with Ruby. I ended up using sqlite in my application even though I wanted schemaless, something like an embedded Mongodb. Though if all you want is a straight up key value store, depending on performance you can just make it yourself. At once point I'd made my own that just serialized stuff I wanted to JSON files. You lose the ability to query though, getting a sorted set of 100,000 records just isn't feasible with this, but if all you're doing is persisting objects and retrieving them by key it'll work fine. And you can always just use SQLite. Keep them all in one table with an id and TEXT field and.. that's it.
Check out rethinkdb!
What about redis? 
Seconding this one: if you're using Ruby, and you want one application to have persistent data, and you want ease of deployment, Pstore. It's an object store, it's in the standard library, it's ACID, and both its data model and its API are fully Ruby-ish.
How exactly is redis like sqlite?
Many Rubyists are surprised to know that [Ruby already comes installed with a file based object store](http://datamelon.io/blog/2015/persistent-key-value-storage-via-ruby-standard-lib.html). 
Yup. I generally use YAML::Store for my simpler IRC bots. You get an ever-so-slight performance hit over plain PStore, but the ability to go manually edit the DB is worth it
A relational database can be non-relational, just don't define any.
I've used [daybreak](http://propublica.github.io/daybreak/) quite a few times to considerable success. It's quite fast and works great for mini projects that just need some sort of simple persistence. 
It's an in-memory non-relational database. I think it could be what OP is looking for. 
My point exactly. I thought I'd seen enough of this with MongoDB a couple of years ago that everybody got shamed out of it. Guess some people are late to the party. 
If you're on AWS and need real NoSQL, check out SimpleDB or MongoDB. Both can be spooled up very inexpensively to free and are very tough. If you're just looking to persist state, I would think a local Redis or Memcached would turn the trick. Although I typically want to persist state outside of my app. 
Best guess is [meinac](https://github.com/meinac) as the strings seem to appear in his commits [here](https://github.com/rails/rails/commit/422292dc98cf42b20758025bf55b5b84260aecb4), [here](https://github.com/rails/rails/commit/6709891c522c15cea9823c43df4d312ccc5423fd), and [here](https://github.com/rails/rails/commit/096bc4be6b318f774e629d532467173b37925aab). Didn't bother digging into whether anyone else had modified them between the initial appearance and Space Oddity's commit.
Just found rethinkdb, may be a good fit https://rethinkdb.com/docs/guide/ruby/
Small footprint, easy to use. 
I get lots of people migrating from Resque to Sidekiq. I have special compatibility APIs just for this purpose. http://sidekiq.org https://github.com/mperham/sidekiq/wiki/Resque-Compatibility
Doesn't the approach discussed here just end up with you building a 50 layer docker image and having to approach limitations there at some point?
Pretty everyone I know starts with Sidekiq nowadays, probably because it is better documented/maintained and more performant. But there are huge gotchas between Resque and Sidekiq: https://speakerdeck.com/jdabbs/processes-and-threads-resque-vs-sidekiq Lastly, don't forget Sucker Punch.
&gt;if can't find given key in case of not setted dafault value. How is that the "fixed" comment?
lmdb
Could someone tell me the difference between `%i()` and `%I()` symbol arrays? I don't get what "interpolated" means in this context.
`%I` means the values are parsed for any occurrences of `#{}` and whatever the expression within that evaluates to will be inserted at that place.
Quoting you. &gt; Another thing to keep in mind is community. With a tool like Pandas, you can be pretty positive that anyone else using it is doing some kind of data science, so it makes for a good tool that the community can get behind 
I am getting: #&lt;Zlib::DataError: incorrect header check&gt; or #&lt;Zlib::DataError: unknown compression method&gt; after connection has been opened and addChannel sent. Why is that? It seems like it works perfectly for you.
Yeah, thats why i would like to see ruby have a better dedicated library for data science... so that we can have a "good tool that the community can get behind", similar to what the Python community has in Pandas. Thats the whole topic of this post. I don't know how that statement hints at "arguing that nobody should replace pandas", but whatever.
If there are more enthusiasts of ruby/rails/arduino we could make something all together. I've been thinking about this with the last ESP8266 I ordered and Action Cable which is pretty awesome. I mean, Rails with Websockets could be a brain for one or more arduino modules.
Yeah, there is still another limitation with Fibers, though. `Enumerator` and `Enumerator::Lazy` use them internally, so code inside an enumerator that calls `Fiber.yield` behaves in a surprising fashion, sadly.
I am in
This is pretty much it. Its kinda messy as i was learning as i was writing. There are much much better networks out there. https://github.com/scsilver/zipcode_reader/blob/master/app/models/neural_net.rb
I am thinking more building an interface first, an API maybe.
I doesn't really need more work. 2.3 fixed most of the long outstanding bugs, and there arent too many more features you need in a bot framework. And its developer is fairly active on freenode
What you said makes sense, but if you have a Rails project, doesn't "convention over configuration" apply to anything you might want to use with your project? It always struck me as part of the Rails way of doing things, and adding something as core to your project as Docker seems like it should follow suit. But I might be missing something behind the original intent of that saying--like I said...beginner here.
Figured it out: Zlib::Inflate.new(-Zlib::MAX_WBITS) instead of Zlib::Inflate.new(Zlib::MAX_WBITS + 32). Forked gist with update to make it work on regular ruby. Thank you for your help.
I used Ruby to build a neural net in grad school as well as to do some image processing. I wasn't anywhere near as familiar with Ruby as I am now though, so I got hung up trying to parallelize things. If you want speed, I'd recommend going with JRuby or Rubinius for native parallel threads. Alternatively, I can't imagine the overhead for forked parallelism being all that bad (but then you need some IPC).
I really like mruby. It's a really well structured and clean C project. The mrbgems ecosystem is also interested to watch grow. You can embed mruby into existing C/C++ projects, or write [a simple mruby bytecode loader](https://github.com/postmodern/mruby-embed#readme) and write the entire app in (m)Ruby!
The blog requires JavaScript just to read the static text :/
&gt; I'm still confused on the use of application servers with web servers, though. &gt; seems very resource heavy (dedicating RAM, etc for a VM). I was wondering if there were other options? It's generally better to run a VM, even for PHP etc. It's not so resource heavy: you only need a small one, say 256 MB, which is 3.1% of your RAM on an 8 GB system. The benefit of a VM is that you can exactly duplicate the configuration of your target server, as well as snapshot the VM, share it with others so you're working in totally identical environments, have different configurations for different projects, and so on. It totally kills the "Well it works on *my* system..." problem when working in teams, as well as the "Oh shit, it worked in development, but this and this and this don't work on the actual server..." problem popping up when putting things up live. &gt; I'm still confused on the use of application servers with web servers, though. Yeah, it is confusing. It helps to think of it like this. An application server like Puma, Webrick, or Passenger receives HTTP requests and, based on the rules and logic in your Ruby application, returns CSS+JS+HTML content. It handles all the request/response stuff so your application can just focus on *its* thing. It's kind of like the application server is the counter at a fast food place (taking orders, handing food over, etc, the same for all restaurants) and your application is the kitchen where stuff actually gets cooked. If you want, that's where it ends, you can usually just run Puma or Webrick on its own, and that will work. But there's another type of application called a web server. These are nginx, Apache, etc. These usually just fetch content off the disk and return it, nothing fancy. But you can optionally ask them to go and ask an application server for some content instead. So you visit a page, and it goes "Apache, give me image1.jpg, image2.jpg, style.css, things.js, ads.js, and go ask Passenger for the dynamically-generated page content." Sounds convoluted, right? But Apache/nginx are super fast and efficient, good at managing multiple users over many machines, etc, so you can rely on them to handle all that and deliver all the static unchanging files (like images, stylesheets) and just rely on the Ruby app server to provide the actual dynamic programmed bit. Why didn't you do this with PHP? Because your version of Apache most likely had something called *mod_php* embedded into it, to translate PHP itself; or it used CGI, where it launched a PHP interpreter in the background and asked that interpreter to translate all the PHP pages. This is exactly what Passenger can optionally do, bake itself into Apache -- which is why it's also been called *mod_rails*. Web/app servers are one of those things that seem weirdly and pointlessly complex from a developer's point of view, but there are good reasons for their complexity and feature sets from a sysadmin point of view, things that become important when you're managing a hundred thousand requests at once. 
I really agree . Start simple , create the obligatory blog in Rails (as the guy said running 'rails server' should be enough) , then move on to more advanced stuff . If you try to worry about chef + docker before knowing how to write a simple rails app you'll go insane (FYI I'm developing on Rails for 2 years and I can't docker or chef . why not just use heroku when you want to deploy something, especially when you're starting out? try to choose the path of least resistance).
&gt; Web servers + application servers: AFAIK, PHP can run "inside" nginx or apache through compiled-in modules. Ruby cannot, so you use a reverse-proxy such as Unicorn, Puma, or Passenger. Mongrel2 isn't widely used anymore if I'm not mistaken. &gt; Local development: While you can use containers or VMs for development, I personally just develop right on my local machine and filesystem. I've never had any issues. &gt; Build Automation There's not really anything to build, except maybe your js/css assets, but the Rails asset pipeline handles that for you. &gt; Asset Management Sprockets aids in "requiring" multiple files into one asset manifest that gets compiled into one file, e.g. `application.js`. Perhaps similar to what webpack or gulp would do in concatenating js/css files. &gt; Dependency Management Yes, stick with bundler &gt; RVM I still use RVM, but the cool kids these days seem to have moved to chruby Other tools: I'm using Atom to edit code. I deploy to Heroku. Starting to integrate React.js into projects now. [message_bus](https://github.com/SamSaffron/message_bus) has been a pretty good substitute for websockets. 
But just to clear things out : 1)Application servers: act as a middleman between your rails app and the server(nginx) . Not sure if you have them in the php world , in java I would assume tomcat\glassfish are comparable . In php you have modules written to apache though? 2) Assets managements is done with the assets pipeline (Sprockets). It will compile scss to css, coffeescript to js and minify all your assets on production (I would invest in learning this instead of using gulp ) 
Chef/Puppet and Docker/Vagrant are things I've wanted to work into my PHP workflow -- just haven't gotten around to it. Since I was thinking about picking up some new stuff, I figured I'd just try to hopelessly confuse myself and do everything at once.
Has a memory cost? Wouldn't that open you up to DoS via OOM?
I totally second the idea of starting with Sinatra. Only move to Rails if you find yourself making new project so regularly that you need (and actually understand) all the magic that goes into integerating everything together. What do you mean by a 'local dev option'?
This is the same argument I still see people using as to why they store passwords in plaintext. So long as your logins are brute force limited, they will already be protected against an OOM.
&gt; def self.digest(password, stretches, salt, pepper) &gt; ::Argon2::Password.hash("#{password}#{salt}#{pepper}") What the hell is this? "stretches" isn't used. Regarding "salt", let me quote the Argon2 readme: &gt; If you are providing your own salt, you are probably using it wrong In fact, this his how you provide a salt to Argon2: &gt; argon = Argon2::Password.new(salt_do_not_supply: salt) Why is it just appended to the password? The "pepper" isn't meant to be appended to the password either, there's a proper parameter for that too. Password hashes are not a place to be doing your own thing. 
Thanks man, I'd been working on project askdjfhaskldjfhaskldjfhaslkdfaskldfjh for like 2 weeks solid with no backup. :(
The PHC ran for two years in the same form of submission and review format that gave us AES. The review panel included people like Jens Steube, Samuel Neves, Mathew Green and Colin Percival. It's basically a who's who of the crypto world. 24 submissions were evaluated and the panel declared Argon2, from the University of Luxemburg, the winner. If you want more, you can evaluate the proofs [in the Argon2 reference](https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf). So yes, I would challenge anyone who suggests the recommendation has no backing. Disclaimer: I maintain the Argon2 gem and have made several submissions to the C mainline. I would not recommend the devise-argon2 gem for the reasons mentioned.
The -r means recursive the -f means force, so it will not error on non-existent files or directories.
You don't need to make the aliases. Honestly, it's a few extra characters to type and then everything else is 100% standard rails commands. I haven't created any bash functions (although this is a reasonable idea), I typically use CTRL+R to reverse search on a specific rails command. You could always go with a hybrid approach too where you have your rails app installed locally on your host, and then use Docker for things like postgres and redis. The above strategy isn't as portable, especially if you work on a team but for a solo dev it's not a terrible option.
This. You should implement rate limiting anyway to protect vs brute force.
Thanks for the recommendations, I will take a look at those parameters. Regarding salt, Devise assigns each user their own salt. So the implementation will need it to pass it along. You can see how Devise's own non-bcrypt implementations use it: https://github.com/plataformatec/devise-encryptable/blob/master/lib/devise/encryptable/encryptors/sha512.rb If you think there's a more Argon2-y way of doing it, I encourage you to submit a pull request.
hahahah
Read the title "Moving from fun to a permanent nightmare."
I'm on Mac, so I'm pretty familiar with Linux-ish stuff. Thanks, though!
Ruby 2.3 actually has this built-in as [`Hash#dig`](http://ruby-doc.org/core-2.3.0_preview1/Hash.html#method-i-dig). :)
I didn't know, Ruby 2.3 comes with a lot of new features :)
I think mruby will be a part of Internet of things, but now only some boards are compatible. There is a Github user called knob that [integrate it with Arduino](https://github.com/kyab/mruby-arduino). 
From the book: &gt;This book is written for GNU/Linux (Debian distro) users, thats because I think GNU/Linux will conquer desktops of programmers in near future. Almost all who have Debian GNU/Linux based distro should feel at home while trying to learn Ruby using this book.
That's not the best way to do it in ruby 2.3. You should instead use: hash.dig(:a, :b, :c, :d) 
the first paragraph needs some editing
Couldn't you just fix an initial work day for each one and then determine if the number of days since that day (using Date or some similar module/gem) is divisible by 3?
That's... brilliant. That is so much easier than what I was initially thinking.
You will find that Bozhidar does excellent job with the community [styleguide](https://github.com/bbatsov/ruby-style-guide) and [static code analyser](https://github.com/bbatsov/rubocop) that enforces these rules. I've been in Ruby community for many years and can assure you that this is quality stuff.
Thanks , I appreciate it ! 
I think this could be useful: - https://github.com/markets/awesome-ruby#coding-style-guides - https://github.com/markets/awesome-ruby#code-analysis-and-metrics
 require 'date' class Dude def initialize(d) @start = Date.parse(d) end def worksOn?(q) return (Date.parse(q) - @start)%3 == 0 end end dave = Dude.new("3rd Feb 2016") dave.worksOn?("12th Feb 2016") # =&gt; true
Forget what everyone says and go full on seattle style. You will learn much about ruby's syntax that way, and seattle style does a great job of making bad code look terrible.
you want [instance_variable_set](http://ruby-doc.org/core-2.2.3/Object.html#method-i-instance_variable_set) instance_variable_set(:"@#{song_title}", Song.new(song_title)) 
I have a feeling that what you actually want to do is not what you think you want to do. Dynamically creating instance variables like that isn't a great idea—for one thing, how would you enumerate them? Also, if your song titles have spaces in them, they won't be legal variable names and your code will raise an error. Most likely you really want to use a hash, with the song title as the key. If you're really sure you want to do this, then probably the best way is for your object to subclass OpenStruct (make sure to `require 'ostruct'` first). Then you can do stuff like `self[song_title] = 3`, which will for all intents and purposes create an instance variable named with the contents of `song_title`. So if your object is called `foo`, you could do something like `foo["Thriller"] = 3` and then later reference it by calling `foo.Thriller`. You won't be able to use the @ syntax to refer to the pseudo-instance variables, but you can always just use `self.whatever`. Again, though, this is very bad practice, and I don't recommend it. Use a hash instead—this is what they are made for.
I'm with you on this - I have never needed to do anything remotely like this so I think whatever he is trying to accomplish, it could be done in a much better way.
Running rubocop via a git pre-commit hook will keep you honest while you are still learning. Some rules are annoying or subject to bending but in general it is good advice. 
Stick it in [Overcommit](https://github.com/brigade/overcommit) and you'll never check in bad code again
Do not use eval to accomplish this. Eval could be used I this case, but it should be avoided here, and in most other cases. If you are going to use eval here, at least scope it with class_eval.
It's better to use instance_variable_set. eval function has some security problems because the content of song_title will be executed as ruby code: song_title = "a = 1; puts File.read('secret_file.txt'); b"
Great stuff posters. Thank you, much appreciated. 
Looks to be for the novice programmer, just based on a quick skim. It covers from installing on Debian through most of the topics that a beginner would need guidance on. It's by no means Debian-specific past the installation guide portion.
Less importantly, `eval` also has *much* worse performance than alternative implementations, 99% of the time.
If you use guard, you can also include the robocop reports in your guard file, with a `guard-rubocop` gem. It makes it easy to spot ~~errors~~ __style violations__ as you type them.
This! I had a helluva time trying to teach my team to follow the company's style guide. Even asking them run rubocop once in a while wasn't enough. So we all sat down and figured to how to have it run in vim and sublime automatically. I think it runs every three second and flags code as you type. It has really brought the junior devs up to speed quickly. And pull requests are much less painful now that they're not filled with pedantic nitpicking.
Have you checked what `dasherize_number(333)` returns? It doesn't return what you think it does. 
for `dasherize_number(333)` it's returning `3--3--3` because the first number is hitting condition where only a dash is appended, the last number is hitting condition where dash is only pre-pended, and the middle number is hitting condition where dash is both appended and pre-pended. You need to check if the last number was odd and therefore not add any dashes.
ahhhhh&amp;#&amp;@* i see it now.. will try again. thanks everyone (:
On a general note I really suggest you try to leverage the Ruby API. For instance, this problem screams "iterate over a list" and you do that by using a counter. There's noting wrong with that but Ruby offers a lot of solutions to this that doesn't involve a counter. You rarely need counters and appending stuff to variables in Ruby. If you look at the [String class](http://ruby-doc.org/core-2.2.0/String.html) you have the [chars](http://ruby-doc.org/core-2.2.0/String.html#method-i-chars) method which returns the characters of a string as an array. The [Array class](http://ruby-doc.org/core-2.2.0/Array.html) gives you the [collect](http://ruby-doc.org/core-2.2.0/Array.html#method-i-collect) (or [map](http://ruby-doc.org/core-2.2.0/Array.html#method-i-map)) method which lets you transform a list of elements to another list. In your case this means "convert the number to a string and iterate over the characters. Append dashes before and after if the number is odd." But that doesn't solve the whole problem because you end up with leading, trailing, and double dashes. That can be taken care of with the [gsub](http://ruby-doc.org/core-2.2.0/String.html#method-i-gsub) method on the string which lets you replace a part of the string (an unwanted dash) with something else (an empty string). [Here's my suggestion to a solution](https://gist.github.com/fiskeben/fd68edc7448ccf14f9d9). It's not perfect or anything and can most likely be better. I'm not trying to be a besserwizzer or anything. I just want to tell you about some of the things that are wonderful about Ruby :) I'm sorry if this is offending.
Here's my ruby-esque solution using the [Matrix](http://ruby-doc.org/stdlib-2.3.0/libdoc/matrix/rdoc/Matrix.html) class in stdlib. require 'matrix' rows = STDIN.each_line.map { |line| line.split.map(&amp;:to_i) } matrix = Matrix[*rows] sums = (0...16).map do |i| m = matrix.minor(i / 4, 3, i % 4, 3) m.reduce(:+) - m[1, 0] - m[1, 2] end puts sums.max
Why wouldn't you be able to use Ruby libraries, if those libraries just contain Ruby code, or possibly native extensions. Wouldn't it just be able to import the library code, the same as if it were code you wrote, and if you use a gem that requires native extensions, you'd have to build them for each platform and include that with the executable?
Oh our circle ci runs rubocop and everyone sees the fail if you push without rubocopping 
The problem is you can't depend on the user's computer having a Ruby interpreter and if they do you can't depend on the version, so if you want your code to be bullet proof you now have to ship with a vendored Ruby version. It ends up being much larger download, and much more fragile. Have you ever tried to get Ruby running on a friend's windows machine? Want to do that for everyone who needs to run your code? Eek. That being said there is a library out there do help automate some of those pains away http://phusion.github.io/traveling-ruby/.
Nice work! That is pretty useful for Terminal apps, as the speed bump is much more noticable without some heavy libraries. Btw, congrats on Pastel being mentioned in a RubyTapas :)
Bit late to the conversation, but I worked in LA for 2.5 years at an ad tech company. I did a lot of scripting and systems management. Overall I hate LA with a passion. The traffic is terrible. The people you will interact with suck. The food was alright, I've lived in the Bay Area, and I think they have better food. But in all honesty, the traffic will slowly chip away at your sole. My final words on the tech scene in LA: it's mostly ad and media based. If that's your passion, then that's a great place to be. Even if it's for a couple of years it could be fun if you live near the beach like in Hermosa, or Venice.
Guys check out https://www.lita.io it seems awesome. Their Vagrant box doesn't work for me but the gems worked fine and there are two AI ones interacting with cleverbot.
Except there aren't any. Perhaps you're thinking of something else? Maybe you should check to make sure you're not mistaken by providing a link.
I believe that this is what `Array#dig` and `Hash#dig` are for, in Ruby 2.3. So you can do `response.dig(:post, :author, :city, :address)`
If you need an excuse to learn more Haskell, have a look at the `lens` library. You should be able to solve the same problem in a more general way and use it for indexing into an array as well. E.g. third_author_lens = key(:posts) &lt;&lt; index(2) &lt;&lt; key(:author) third_author_lens.get(oh) #=&gt; "Matz"
I definitely will! I can see that my solution - which made my life much easier - isn't even optimal, but it looks like there is much more stuff hiding from me right now. 
I developed an alternative of `Hash#dig` for Ruby &lt; 2.3. You can get the code at http://irb.rocks/reduce-nil-verifications-nested-hashes/. 
Has nobody written a dig "polyfill" yet? Somebody should. I'll try to do it today. Hardest part is finding the specs so I can make sure mine is really compatible. **EDIT** I did, here ya go. https://github.com/jrochkind/dig_rb
Use '.chars' instead of '.split("")' 
I think you are right. To try to design objects without mutation is more error prone than thread instance its own objects.
How exactly avoiding mutable objects is more error prone? I've got the opposite experience.
There are two concerns in play. 1. The design of the work distribution model between the threads. 2. The relative effect of the design of an object on thread safety. I was addressing the first one; it's essential that any design of a threading model avoid the need for sharing objects. The second one can be argued for as well, but ruby objects are inherently mutable, so constant vigilance will be required if you're expecting unmutated state.
... has worse performance 100% of the time.
Rack is just a standard interface for a web server. Not related to ActionController at all.
no. not unless you pull some rails code into your sinatra project
Thanks for posting this!
Rspec or minitest, in my opinion make little difference. Whatever seems more intiutive go with it. 
If that was the case, you wouldn't be looking for a visually pleasing way to do something. You also wouldn't be looking for repeatable way to do something like this. Usually, when you're doing something once or twice, you just write the extra line or if statement needed to get the job done.
So ActionController comes with Rails?
Yup
If it starts with Action or Active and you haven't installed a specific gem for it, it's likely coming from Rails itself.
rub?
I can totally agree on that. A while ago we recruited two programmers both of which never worked with Ruby before. Both had a PHP background and one had worked a lot with Java. Especially in the beginning it is very important to pair just to get the mindset "I could just do it myself or I could look if there is already something to use". You know, if someone attempts to do a for-loop you smack the keyboard ;-) Our course of action was to give them a few days to get their environment running, check out the project code and play with it. Then we gave them little tasks on the project and let them a day to come up with a solution. The first attempts won't be perfect but I think that when you have to google and read a lot to get simple things done the learning effect is greater and more pleasant than when I just tell them how to create a migration, etc. After that we review the stuff together and then we start pairing. At the end, we still do a lot of pair programming. Most stuff just gets better if you have two pairs of eyes. I feel like we argue more than we actually program.
Always good to have multiple projects working on the same problems. I've used Lita before and it's very enjoyable to work with.
I'm using bundler but I don't have a `Bundler.require` I'm requiring the sequel gem by itself before this was run. The `Bundler.require` statement broke my local version so I got rid of it. My `Gemfile` has `gem 'sequel' ` in it. I was doing the `gem list` for the serveruser, who is supposed to be the one that 'runs' the app (I don't know if run is the correct word here). I'm not sure ab the correct Ruby install thing. I'm a front end dev so sorry for my lack of knowledge about Ruby and thanks for your help. I hope this helps.
Thank you for the tip! And yes - hoping to get into app academy!!
ah so fancy!
First of all this is super inefficient. If you want to make it a little faster, the max number the loop should go to is the number you are testing divided by two. This is because since we are testing whole numbers, the smallest divisor is two and therefore the highest possible divisor would be that number halved. This would give you a double speed boost on true prime numbers, since the longest calculation for a prime number test would be to test a prime number. Also, let's talk code clean-up. return in ruby is the easy way out, and you shouldn't use it as much as you do. Don't forget, ruby returns the last evaluated expression, so that last return is unnecessary, and you could probably refactor out the rest of them. Now for your mistake You put else instead of elsif, which causes a short circuit of sorts in your logic. You could probably change that to the (?:) operator. Hope this helps. 
&gt; go full on seattle style Sorry, what is seattle style? I am unfamiliar with that term XD 
You are actually looking at all your tests testing true. "is_prime?(2) == true: true" means, "is this thing passing my test? yes!" So "is_prime?(4) == false: true" means it passed the test because the value it returned was the value it was supposed to return, which in the case of 4 is false, because 4 is not prime. You can see this by changing "return true" to "puts true" to see what your program is telling you in a way that is visible to you rather than your tests. Your tests are looking for a return value, while puts will print out a value, and those are different. Also, change "return true" to just "true"--the last code evaluated in any Ruby method has an implicit return. And it's 'elsif' because 'else' means "if my 'if' tests false, then everything inside the 'else' loop should be executed". 'Elsif' instead is an alternative to 'if', not a catch-all like 'else'. 
thank you so much!! i havent learned the ?: operator yet but i'll definitely look into this!
how is this better/different than: - https://github.com/RubyMoney/money - https://github.com/RubyMoney/monetize
I wonder if this will work on Mac.
The Amountable gem builds on top of these great gems to enable a better management of those Money objects in a relational database.
&gt; OK I added those lines but when I ran: `bundle install --deployment --without development test` I got: `Some gems seem to be missing from your vendor/cache directory. Could not find rake-10.5.0 in any of the sources` That is usually caused by committing `vendor/cache` to your repo. Unless you're deploying as a package you should remove this directory and add it to `.gitignore`. &gt; So I'm requiring my gems individually in the files that need them, do I not need to do that if I'm using the `Bundler.require` statement? It depends. `Bundler.require` sets up the load path, etc so you load from your bundled gems instead of the system gems. It also requires each gem unless you've told it not to in your `Gemfile` by doing something like `gem 'whatever', require: false`. However not all gems will load everything when requiring just the 'root' of the gem, it's up to the author of the gem what is loaded. e.g. `require 'whatever'` may not load `Whatever::SomeThingElse`, you may need to `require 'whatever/some_thing_else'` to be able to use it. &gt; And when I added the bundler lines on my dev machine, it breaks the app and I get `Sequel::DatabaseConnectionError` &gt; And when I try to run a Rake command I get `Sequel::AdapterNotFound: LoadError: cannot load such file -- mysql` See my other comment, I don't think you have the mysql driver in your `Gemfile`, and obviously run `bundle install` after adding it. 
So you will be writing this code over and over, which means it will inevitably lead to others reading it, which means u shouldn't write this type of code.
 def nearest(x) (0..9).to_a. permutation(2). reject{|a,b| b.zero?}. sort_by{|a,b| (x - a / b.to_f).abs }. first end 