I'm just pointing out that there *are* systems that have solved this issue (albeit sometimes with tradeoffs). Postgres' synchronous replication and Kafka's producer acknowledgement mechanism are two that come to mind. I'm not suggesting either of these is the right tool for the job. I just know there's at least one customer (and probably several others) that would love this functionality. &amp;#x200B; Just something to consider going forward.
Nice article! Thanks for sharing it. I never heard about that class and its features. I‚Äôll definitely check more posts on your blog!
Pro tip: reddit markdown uses four spaces preceding each line to mark a code block instead of three backticks.
Cool stuff! Thanks!
I always recommend that people dig into ActiveSupport generally. There's lots of good stuff in their that Rails developers use all the time. There have even been a few methods that started out in ActiveSupport that have since become core language features.
Maybe I'm missing something, but what makes this strategy preferable to this? some_string == "Johny" 
That‚Äôs why Igor suggests benchmarking before using string.inquiry everywhere.. it‚Äôs more expensive than a straight-up comparison. One of the reasons I love Ruby is that it has almost unmatched power to change the *shape* of itself through meta-programming. This allows some remarkable changes to syntax that can seem very intuitive within a context. For example, consider ‚Äòlet‚Äô in specs, or ‚Äòvalidates_presence‚Äô in AR models, or ‚Äò5.days‚Äô in Rails. These are almost magical because they seem to be native Ruby.. the syntax effortlessly supports a context. We can use the same tricks we use to create expressive DSLs to actually extend and modify core syntax. I view this as *play* in Ruby at the highest levels. It is often offered without claims to performance or efficiency, but just because the idea is perhaps elegant or makes something seem easy. It‚Äôs like a beautiful riff in jazz. It comes and goes, you can take it or leave it, and can appreciate it on many levels at once. But it has downsides. It can make it hard for others to determine core syntax vs magic. It can have gotchas. It can be so elegant that it is never documented and interferes with other syntax destructively in very hard to detect ways (unless you are also a wizard). At the end, you may be left with only a question of why the hell did I write this oh-so-clever code that raises more questions than it answers? But sometimes you can leave those questions for just a while and sing.. play.. riff in Ruby... and it‚Äôs beautiful.
Sending an inquiry message works for things that aren‚Äôt strings. Objects that might have better, or at least other, uses for the equality operator. It is none of our business whether `Rails.env` returns a StringInquirer or a Rails::Strawberry::Hatstand::MagicEnvironmentPresenter object, so long as it responds to the enquiry messages. By coercing it into a string comparison we‚Äôd become guilty of [Primitive Obsession](https://sourcemaking.com/refactoring/smells/primitive-obsession). 
This feels like a non-article and self promotion. The community doesn't "encourage it" the community doesn't have a choice.
&gt; self promotion. Definitely... And I suspect that this attempt at email address harvesting is a violation of GDPR.
I don't force anything. When I talk about the Ruby community, is about their leader (The core team). As ruby is a dynamically typed and fully object-oriented language then it makes sense to use the duck typing principle. &amp;#x200B; But not one force you to do it. It's just a programming language.. &amp;#x200B; Also, Duck typing design is only a principle. So if you don't want to use it, feel free to use the \`is\_a?\` method. &amp;#x200B; &amp;#x200B;
I'm blogging since a year. I've more than 50 articles. I just launched a new MOOC. And I wanted to validate that my idea was well welcomed by the ruby community. &amp;#x200B; Thanks for the feedback. I'll be more precise about what you subscribe to in the welcome message. &amp;#x200B; But the pig picture is that I've almost done the RubyCademy Test tool and started to record video. &amp;#x200B; So if you gave me your email, then you'll be notified when the RubyCademy Test tool is ready and when the videos will be available. &amp;#x200B; Please, feel free to notify me if you wanna unsubscribe.
Ruby isn't fully object-orientated, it employs principles of object orientation but it's still missing some aspects. is_a doesn't make the language suddenly not Dynamically or Duck typed. It just allows you to implement a more static approach in your code logic. The code will still run regardless, but your logic will be enforced.
I'm pretty aware of the ruby internals.. \`is\_a?\` exists to let you ensure with what kind of object you deal with. In opposite, if you decide to adopt the Duck Typing principle in your mindset then the Ruby language tends to match with this principle. &amp;#x200B; After, that's just a matter of mindset. :-) And any ruby program is, at least, executed in the context of the \`main\` object, which is an instance of the \`Object\` class. Which is an instance of the \`Class\` class. Which is an object. inception. 
Thanks again for the feedback. I've updated my "welcome message" page according to your advices. It details what you subscribe to and which emails you gonna receive. Thanks again.
&gt; When I talk about the Ruby community, is about their leader (The core team). The creator of a language is not "the community". 
For real? We're barely at Ruby 3.0. Kinda seems like we should wait for a Ruby 3.0 release candidate before talking about 4
Dude your article is wrong. &gt;In a statically typed language, variables‚Äô types are static. &gt; &gt;This means that when you associate a variable to a type then you **cannot** change it anymore. In static typing, the types is associated with the reference and is assessed at complie time(staticly) what you are describing is strong typing. &gt;In a dynamically typed language, variables‚Äô types are dynamic. &gt; &gt;This means that when you associate a variable to a type then you **can** change it whenever you want. In dynamic typing, the type is associated with the value and is assessed at runtime(dynamically) what you are describing is weak typing.
is there a way to set options? for example, the install path? so we don't have to enter our password?
Oh right, I didn't see that ruby-filemagic is no longer maintained... OP only wants to differentiate between text and jpg though... I'm pretty sure few text files will have the magic number (ff d8 ff or something) as jpg. But yes, there are possible issues. That's why these libs are called 'magic' :)
This sounds like the wrong design. You're putting test code into the application code. You could write tests that assert your classes implement a certain interface. Don't make the classes self-test at runtime.
If they had an RSS feed, I'd include it on rubyland.news, if anyone from thoughtbot sees this. :)
This is just amazing. I remember when I just got started with ruby. It‚Äôs a great resource for beginners and intermediate developers.
I updated the article with this example.
Why is recyclable cache keys not being implemented until now? It's considerably more complicated to implement than the old method of cache invalidation. I use the adage "make it, make it right, then make it fast". Likely no one realized this was such a huge performance opportunity until recently. 
&gt; Here the a variable responds to map and returns the expected object. So it‚Äôs legitimate to think that the a variable is an Array. Um, but it _was_ an array. So I'm not sure what this example illustrates. This article doesn't tell us much. There are interesting things to say about duck typing, they are not here. 
Sweet! My company used to pay for it for me, but once I finished all the tracks it wasn't worth renewing (although I do wish I could have gone back to review tracks...). Really glad to see this move, Thoughtbot's a good company.
Glad they opened it. Going to point a few boot camp grads at it immediately.
Abstraction, Interfaces and Multiple inheritance would be the biggest ones. Not that every OO language implements them - it's just you can't claim it's "fully object-orientated" if it misses some features that make it a complete representation.
Cool, thanks for clarifying. I know what you mean about Interfaces, and I'd like em. Not sure what you mean about "Abstraction", any programming always involves abstraction. I think module mix-ins actually do provide multiple-inheritance. What is "true" or "complete" OO is much debated. Some people think it _ought not_ to include inheritance at all. Alan Kay, who invented the term and idea, has a definition of OO that doesn't include many things we think of as OO now. Personally, I think ruby is one of the most OO-centric languages I know of. Probably because Matz took a lot of inspiration from Smalltalk, the language Alan Kay invented. 
It's awesome for automated testing. The DSLs available for it are awesome, and way friendlier than any Java or python testing frameworks. Rspec is the real deal!
very cool! thx thoughtbot!
It depends on what sort of object that is. It's not something standard in ruby or anything like that. You can do `ad.method(:to_gid_param)` to see where it was defined. Or you can google `ruby to_gid_param`, which I just did, looks like it's likely part of Rails' GlobalID (if you aren't using Rails, then it's probably not that). And has no method-level docs. https://github.com/rails/globalid/blob/a9c4e1e1799b6256f15cd72242fedc46e2147a12/lib/global_id/identification.rb But reading the GlobalID gem Readme should give you some ideas. https://github.com/rails/globalid 
This is awesome. The quality thoughtbot produces is top notch. Seems like it's across everything they do... code, podcasts, etc 
You should probably take a read through some Ruby syntax, as Ruby doesn't use braces like that. https://learnxinyminutes.com/docs/ruby/ 
Line 3 and 4 are both generating a different random number. I suppose thats your issue. You can do something like result = rand 10 + 5 (not sure what you are doing there anyway could just do rand 15...) Then puts result If result &gt; 6 ... else ... end As a side note keep in mind that rand 15 will give you a number between 0 and 14.
Is there a way to do rand 1..15? So it cuts out the 0?
Yeah! One way is rand(1..15) you pretty much typed it by coincidence!
I ran into another problem. I'll get this, I swear. Here's the link: http://tpcg.io/sLc5zL Basically it's not reporting off the rand correctly. So if the rand is set to &gt;6 'You win!' It'll roll 9 and still say you lose. Am I missing something?
Rand is a function, much like fight, so every time your script hits that line it gets evaluated again and a new random value comes out of (or is returned by) the function. You could say roll = rand 1..10 And that will evaluate it once and store the value in the variable. You can then use it later in your if statement and even do a puts to print the value and you can see what it is. 
Right, but how do I then put that in an If/Else statement so it shows both the result of the roll as well as the conclusion of the if/else? For example, how do I get it to show: 'You roll [Randomized number here]. You win!' (If it's above 6. And You lose if it's below). If I put it in the initial 'If' statement and nowhere else it won't show the roll.
I think it's gonna change when RoR 6 drops
Hello, the talk notes from yesterday's Vienna.rb meetup titled [Mining for Gold Using the World's #1 and Most Popular Data Format (w/ Ruby and CsvReader)](https://github.com/geraldb/talks/blob/master/csv.md). The contents reads: - Q: The World's Most Popular Data Format? - Data Format Timeline / History - Past, Present, Future - Data Formats @ Statistics Austria - Triva Quiz: Who Invented the Space Character in Writing (and When)? - Triva Quiz: Who Invented the Space Character in CSV (and When)? - Data Formats @ Open Gov Data Austria - Data Formats @ Open Gov Data United States of America (U.S.A.) - Data Formats @ DataHub v1 - Data Formats @ DataHub v2 - (Tabular) Data Packages - And the Winner is ... Lies, Damned Lies and Statistics - What's Comma-Separated Values (CSV) - One Format? Many Formats? - CSV Basics - What about commas in values? - CSV Basics - What about quotes in quotes? - CSV Basics - Many Formats / Dialects / Variants? - CSV Basics - Edge Cases - CSV Basics - Type Inference and Data Converters - CSV Formats / Variants - CSV "The Right Way" - CSV "Strict" - CSV &lt;3 Numeric - CSV &lt;3 JSON - CSV &lt;3 YAML - Database Export - PostgreSQL CSV - PostgreSQL Text - MySQL - CsvReader Library Usage - What about type inference and data converters? - What about Enumerable? - What about headers? - What about symbol keys for hashes? - What about (typed) structs? - What about tabular data packages with pre-defined types / schemas? - Triva Quiz - Mining for Gold - What's the country with the biggest gold mining / production per year today? Happy data wrangling / mining with Ruby. Cheers. Prost. PS: The talk slides from the 2nd talk titled [Designing HexaPDF: Iterarative Design, Orthogonality and Other Design Tools](https://talks.gettalong.org/2018-10-viennarb) by Thomas Leitner
The concept of an Abstract class is more important in static typed languages, pretty much to enable a limited form of duck typing! In ruby, duck typing replaces it. You can still create a class with dummy methods and inherit from that class if you wish. Multiple inheritance has been debated by many languages, and many languages consider its absence to be a feature, not a bug. The features you describe as missing seem to me to be kludges invented to attempt to do what ruby can do with little effort.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [oracle/truffleruby/.../**ruby-managers.md** (master ‚Üí e6c5e5f)](https://github.com/oracle/truffleruby/blob/e6c5e5fe7bb89e023e944f6d37e7cdc367d553c9/doc/user/ruby-managers.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e826yod.)
I think RoR drops give nice buzz and excitement, but we need [some longer term help](https://www.reddit.com/r/ruby/comments/9pgwpq/tiobe_index_ruby_dropped_to_18th/e826y2q/)...
But there are ways to stop the hemorrhaging (and start regrowth) with some strategic effort as I mentioned in my other comment above.
Agreed....Having to reach for other languages for certain jobs means over the last couple years I have become used to those languages and they now read a lot more easier on the eyes and I think in them. I still love ruby but find myself not switching back as often as I used to even for jobs Where Ruby would do just as well. It will take as you said a faster evolution to keep pace and attract users who already have invested in stacks they already had to because Ruby was not as performant.
You can't share local variables between methods, which is what you're trying to do. You can use an instance variable instead (which is written `@roll`), another option is using a parameter. As an other remark, something that you'd probably notice yourself fairly quickly, a positive number + 8 (the value of STR) will always be larger than 6, not really a challenge to win that fight.
Still plenty of work and good pay to be had. Good reminder of practising continuous learning though. With all that said, if I were to make a new web app today, chances are that Rails would be the fastest way for me to to do.
That has to be the worst description I've seen in awhile. What does "navigating a Rails app live" even mean? This description is much clearer: &gt; This Rails engine brings a setting model into your app to be used as feature flags, gauges, knobs and other live controls you may need.
Thanks for the feedback. I will work on something clearer.
I love a new gem, but i'm still not entirely sure what I would use this for? The screenshot of the test app on the github page is dummy data, so doesn't add any extra context for me. I'm confused. 
It can be used as an admin panel to control configurations for an application that is running live. &amp;#x200B; Here are a few examples I can come up with. I hope these can make the objective more clear: * Boolean settings can be used as feature flags to decide whether to display new functionality or not * Integer settings can be used to control HTTP requests timeout configurations or as a limit of max items processed by jobs * String settings can be used to a URL for a service you're testing * Model settings can be used to switch between two implementations when you'd like to compare their behavior live &amp;#x200B; Thanks for the feedback about the dashboard screenshot. I will update it with more detailed examples.
Thanks for the feedback! Glad you found it useful
This does exist - https://github.com/SciRuby/
&gt; I'm not sure if you're saying the same thing as me or not! I am. What you described is almost exactly how I understand class `@variables`. I call them the class's instance variables; since classes are objects, it's the same thing as saying they are an object's instance variables. &gt; If you are saying both of them are bad... I'm not. I love class `@variables` and use them extensively, especially when metaprogramming. Though it appears they also suffer from some (but not all) of the problems of `@@variables`: they act like global shared variables just like the class objects themselves. Also, it's probably harder to test metaprogrammed code.
Agree, it just shows the search engine results and it might explain the top 3 languages. it most comes from student searches for their curriculum and etc.
Would love to help... What does it do? What‚Äôs an example?
Correct, the configurations are kept in the database so that they can be changed without requiring a deploy. &amp;#x200B; That is also the reason the dashboard exists. So that you can manage behavior live.
Easily set up admin panel to manage app configuration settings. Use it instead of the usual yaml file approach which requires redeployment. 
As far as rails dislike, I think a lot of people have issues with the Active Record pattern and especially the rails ActiveRecord implementation. This is something I have discussed at length with people with different backgrounds and I've come to apprecistebsome of their points. Rails to San extent encourages or at least enables you to do a lot with one class. I've seen 2k line models. The model handles validation, it has call back hell, it implements its own state machine inside of it, it has business logic. Sometimes the model has methods that edit related models directly. These are all bad coding decisions and not rewuired, it's not something built into rails but I've seen it in many rails projects. These code smells are in a lot of rails projects IMO partially because the rails documentation suggests them and doesn't suggest good practices. On a small scale it works but as your app grows it becomes unwieldly quickly. You end up with a huge mound of tech debt. All apps accumulate debt, but rails IME does it very quickly.There are lots of people out there championing better practices but rails is opinionated and it isnt championing those. I think the rails community also has a slight issues where it was a trendy framework that never got large Java or PHP enterprise adoption, but talks a lot about being pragmatic like Java devs might. Late to adopt changes in the front end world and almost begrudgingly seems to add changes to support api mode or webpack. The community seems to have large segments that prefers working with jquery. Often times it feels like their argument is 'it works and I don't want to change'. Which sounds again like an enterprise environment but rails and Ruby is supposed to be cool and easy to use not 'jquery works fine and SPAs are a needless innovation that slow down page loads'. Rails grew because it was easy to get started and fun to build. Working in spaghetti jquery isn't that. Who here has had to grep for a function name to try and figure out what damn file that jquery is running from? Tldr: Im not in love with rails or the rails community. I think the framework can be very powerful and help accelerate development. I've also seen it enables a huge accumulation of tech debt. That said I do enjoy writing ruby code (and lately some crystal as well). I think in order for Ruby to grow it needs to, to some degree extracate itself from being so linked to rails. There are real reasons to not love it, as well as reasons to use it.
You‚Äôre very welcome. Love the idea of the gem, and appreciate your work. Another thing, I‚Äôd make make it a simple form ‚Äî see heroku env variables ui. These are just suggestions, it‚Äôs your gem :) 
Can you post your full script so that we can try to recreate it?
Yes, will do
Pretty much dead on point here. I love rails and would use it in my next project. But I would use it in the style of Gary Bernhardt or the folks at thoughbot. These are the people you mention who push these good practices. But the code rails encourages is massive fat models. And those models can ruin databases. You need to be disciplined and you need to have seen how bad it can be in order to fight against this. Is there anything to be done to help this?
Crazy question: is it freezing on `give me a number:` ? If it is, can you try inputting 10 and then pressing enter? `gets` means it's waiting on user input from the prompt.
No it freezes when i hit enter and doesnt print anything. I have to close the powershell and open it again. 
Can you try replicating what I have in my screenshot (posted below)? If you can't take a screenshot, please clearly list out all of the steps that you've tried and their result. https://imgur.com/a/a7MQb7P
Removing double-spacing for clarity. print "give me a number: " number = gets.chomp.to_i bigger = number * 100 puts "A bigger number is #{bigger}." print "give me another number: " another = gets.chomp number = another.to_i smaller = number / 100 puts "A smaller number is #{smaller}."
That cleared it right up! I hadn't learned about instance variables yet. Made some great progress learning today thanks to this. Thanks again!
Oh, I think it was maybe Mancinoz saying they disliked them both equally. They are definitely global shared variables; but sometimes you need (or want for convenience) state on a class, to define how that class works. Actual ruby @@class_variables are totally broken with regard to inheritance for this, their behavior is almost never what you want. They were probably a language mistake in retrospect. If you do want class-state, @class_instance_variables is probably what you want, but they are much less intuitive to use (or even know/remember they are there), so I appreciated this article pointing them out and illustrating them a bit. I agree the `Wrappable` example was not a great one though. 
Thank YOU, Mike!
awesome article
Try flushing the stdout buffer after gets.chomp. e.g. $stdout.flush or alternatively, set $stdout.sync = true
also [http://katafrakt.me/2016/11/05/fizzbuzz-with-pattern-matching/](http://katafrakt.me/2016/11/05/fizzbuzz-with-pattern-matching/)
Im back! So this is what it looks like when i try to run the script. The cursor goes on the line below and i cant type anything. I had no problem running scripts before i tried to use gets.chomp so i suppose that‚Äôs what the problem is... http://imgur.com/UW0KNBK
You‚Äôre right, it works in command prompt. But why not in powershell? I dont know much about computers - whats the difference between the two?
&gt;There are lots of people out there championing better practices but rails is opinionated and it isnt championing those. &amp;#x200B; I really wish some best practices guide were coming officially from Rails. Things to avoid. It really shouldn't be a learning experience after you have seriously messed up your Rails project, but rather from the get go. &amp;#x200B; Ruby will also needs to improve, if you compare the changes coming from Python as compare to Ruby MRI. Although Python do have much more resources compared to Ruby.
What an awesome answer, thanks! :) 
If it wasn't profitable before, it's definitely not going to be profitable with a bunch of us freeloaders watching their content for free (and consuming their bandwidth)
People who are already working as Ruby developers might not notice this, but it is REALLY difficult to find an entry-level/junior position writing Ruby. Most of the job offers look for senior level developers, some for mid level developers, and it's really rare to see a Ruby position for junior developers. I know this very well, as I've been checking Ruby job offers for around two years. As far as I can see, the Ruby community is becoming a community of senior developers. New developers who learned to program with Ruby pivot to JavaScript or PHP because it's much easier to find a junior position there.
Gave me flashbacks to university. Most of it pretty bad, but I did relish in a couple of functional programming ideas. I'm very happy I stuck around for the end of the article.
I really like articles like this. It's a great way to take something that is very simple and turn it into something that is extensible within the idioms of the language of implementation.
And this is not a valid argument if you've not used Opal appreciably and are just speaking theoretically, as it seems you are. I think those who actually have used Opal for projects see things markedly differently than you're saying here.
Maybe this is a good starting point, since it's active, for Truffle/Oracle to put an extra Ruby developer on this area.
LOL! That took some serious effort.
I started with The Well Grounded Rubyist. Awesome book for beginners. 
Try Why‚Äôs Poignant Guide
Did you make it to the end? This is not supposed to be a model of what to do. :) But I agree it's nice to see it using actually very idiomatic and well-written ruby... to see that even if you do that, it's _still_ a monstrosity that you want to avoid unless you really do need it. 
I read the whole thing! While certainly overengineered for the proposed problem, it's a great example of how to write a rules engine in idiomatic Ruby. I've lost track of the number of times I've written and re-written something like this.
Thanks for sharing, great quality article and fun
A great Free book: https://i-love-ruby.gitlab.io But I started with eloquent ruby
Fellow novice here, but maybe one step beyond where you're at. I think this RPG-style thing is a great way to learn some basics. One thing I'd recommend is to really start thinking in an Object Oriented way. For instance, what happens to your game if Ted the Mighty is joined by Eris the Brave? As it stands now, you'll run into problems with your character sheet variables (STR, etc.). This is where object thinking comes into play. Take a look at this: [https://hastebin.com/noqubowida.rb](https://hastebin.com/noqubowida.rb) In addition to a few minor changes to clean up where you've unnecessarily repeated yourself, I made one huge change: I create a `Character` class that allows you to generate characters for your game. You can see on line 37 where I create Ted the Mighty using his particular stats. To get at his name and stats later in the program, you can use the helper methods created for each attribute (that's what attr\_reader is doing at the beginning). So, after creating Ted the Mighty using `hero = Character.new("Ted the Mighty", 8, 6, 5, 2, 7)` you can get at various parts of his character by using `hero.name`, `hero.str`, etc. You can see where I do this on line 40 to get at his name. Having that `Character` class will allow you to later do something like: `a_new_hero = Character.new("Eris the Brave", 3, 4, 5, 6, 5)` and you can access information about her, and have her `fight` or `run` in the same way, but using her unique attributes. I hope that makes sense. Just wanted to point you toward starting to wrap your mind around the usefulness of Classes and objects! 
https://pine.fm/LearnToProgram is what I started with and it was great. LRTHW bugs me (sorry Zed).
What makes you think Truffle / Oracle would put a developer there?
FYI: There's also a (free online) book edition titled [FizzBuzz by Example - There's More Than One Way To Do It](https://yukimotopress.github.io/fizzbuzz) and [fizzbuzzer gem / library](https://github.com/rubycoco/fizzbuzzer) for easy code (re)use or command line usage. Cheers. Prost.
Head First Ruby, if you need it I can share a link.
[https://drive.google.com/open?id=1aPHtno8Nc4zOEhwUJYTSyanB2T7eMUXq](https://drive.google.com/open?id=1aPHtno8Nc4zOEhwUJYTSyanB2T7eMUXq)
Great question. I started with PickAxe. It was a bit much for me to consume as I had not much experience with programming but it was valuable.
Thanks for sharing. I saw this announced the other day. I had paid for upcase and it was worth it imo. 
By the by. I tried to look at the upcase platform code yet it redirects to their platform not a github/etc repo. Am I perhaps doing something wrong?
The demo on Heroku is a great idea. I'm going to work on that and hopefully sooner than later will add it to the README. &amp;#x200B; Thanks for the feedback!
Um, no. The Poignant Guide is a work of art which caters to people of the trade. It jumps through hoops to amuse and impress even the most experienced rubyist. Not at all for complete beginners in programming. My advice? Get [The Book of Ruby](https://nostarch.com/boruby.htm) which will gently initiate you on this world. Have fun!
I would recommend The Rails Way. There will be a lot of things that seem magical but it is a way to jump in and get your feet wet and see how to be productive with Ruby and Rails. I would recommend that with any general Ruby book (lots of good recommendations here). The difference is The Rails Way will get you making interesting things fast but not teach you fundamentals - the other books here are the opposite; fundamentals but it takes a lot to start making meaningful programs
Thanks! I think i will start with Head First Ruby and then move to something like the book you just suggested. 
While I wouldn't introduce so many things into the design up front, I think you have a design in mind. It could be the final design, it could change. At this stage I usually code away, as there is always new things to discover in the code that never occurred me while I was just thinking about the design. If parts of this or the whole thing smells later, throw it away, or change it. Only way to know is to try..
Beginning Ruby: From novice to professional by Peter Cooper is the first book I read when I first started learning programming. Very easy to follow. Reads like someone is right there with you and gives a great overview of most concepts. Highly recommend as first introduction to the language and then you can branch off to get a better understanding of more difficult concepts
Because Oracle, from what Chris Seaton has said before, has the most Ruby devs under roof out of any company on the planet and is really putting a lot of resources into bringing Truffle out in front of the pack. Performance metrics are already quite impressive and this ML area seems to be a missing piece to the current industry thrust. Note [this](https://github.com/oracle/truffleruby/issues/1424).
First: Inheritance is a very rudimentary and in most cases a very bad form of code sharing, as you're finding. You should almost never use it. Second: This strikes me as a common problem that I can't remember the name of. Basically you have some higher level problem, you've already (for whatever reason) decided to head down some path and are now asking for help along that path when the fundamental issue is why you chose this path in the first place. So, what is it you are trying to achieve that lead you to this place? 
I am not really trying to achieve anything, this a simplified version of a problem that occurred on a task I was working on recently. I am just curious as to how other developers would approach this. Basically the problem boils down to: how to design subclasses that share also behavior from different roles.
&gt; I am not really trying to achieve anything You are trying achieve: &gt; I am just curious as to how other developers would approach this. &gt; Basically the problem boils down to: how to design subclasses that share also behavior from different roles. See point #2 I made above - this is a bad design, start from the beginning again. 
No worries, mate. Great project you have going.
Documentation in the repo would make it much more likely that you get people to play with it.
Definitely! I started to do things long hand because I learn by going the whole way around and then tightening it up. I actually wrote quite a bit of Ruby code defining a character class (I named it Hero, but whatever) and then assigning health values and then having if/else affect said health values with a 'until health = 0 puts 'You are dead! Game over!' I ran into another wall in that instanced rolls (I named one @enemy_attack, for example) all report the same roll. So if a goblin attacked 3 times, it would report the same @enemy attack roll. I need to find a way to have it be truly random but report on the same if/else without affecting future rolls on the same instance. Also i'm just using a compiler online. Do you know if there's a way to have ruby only run up to a point, await input, and then use the rest of the way? For example a goblin fight, being able to input 'fight' and then the program running the results of that, then being able to pick 'fight, run, talk, etc.' again? Can I do that in a compiler or do I need a standalone program?
It would be more helpful to hear about the end goals you‚Äôre trying to accomplish. I can hardly follow this design based on the sheer number of nouns being thrown around. 
Looks like you're running this in PowerShell ISE. This has problems (not sure why). Running it in regular PowerShell should work.
I'm not sure I fully understand your first issue; can you post what you've got again? For your second point, you probably want to explore `irb` (just run `irb` at at terminal). You can type code directly in there, or you could copy/paste from your text editor, or you could save your script as a .rb file, and use `source` to pull it into irb and execute, allowing for further interaction. For example, here's what it looks like if I save that little modified script I wrote as `hero.rb` on the Desktop, launch `irb` from there, and start playing with it: https://imgur.com/LIwtLy . It's super useful. 
Piotr Murach's tty-* collection does this and probably much more - have you looked at it? http://piotrmurach.github.io/tty/
That looks fantastic. Wondering why the tty in the name? It looks like a fantastic "generic" config library. Cheers. Prost. PS: May I also highlight as a "generic" example the humble props library with a "generic" name -&gt; https://github.com/rubycoco/props 
 1) Ruby is probably declining but still has a very sizable job offering and market.. Rails is still one of the most used web frameworks in the world. I wouldn't worry too much, and would try to compare apples to apples: if you are mostly a web developer - why do you care is typescript and python are gaining popularity? They are not a direct competition since they are mainly used by front end guys or data science guys. I would start to worry if everyone replaced their Rails apps in Go or Node which are more direct competitors but that's not happening. Go and Node will become just as unsexy as Rails in 5 years, if they haven't already. &amp;#x200B;
I think the whole idea of having the worker do all these things themselves is not the right way to go. You are immediately running into subclassing problems from the get go. All these handlers should be their own class and have their own concerns, with the worker delegating work to them. Using dependency injection to then modify the behavior of individual workers. See this awesome talk by Sandi Metz: https://m.youtube.com/watch?v=OMPfEXIlTVE
XY problem?
I'm not entirely sure but it looks like you're trying to implement the Template Pattern? This is a good article to explain it https://medium.com/@joshsaintjacque/the-template-method-pattern-558f3e16879f
Hello, I've added the [CSV ‚ù§ Numerics Format](https://github.com/csv11/csv-numerics) to the latest [csvreader library / gem](https://github.com/csv11/csvreader) update. Use: ``` Csv.numerics.parse # or Csv.num.parse # or Csv.n.parse ``` Happy data wrangling with ruby. Cheers. Prost. 
&gt; It uses one Fiber per request, which yields in the presence of blocking IO. Shouldn't this claim be followed with "provided that you use one of our async-patched modules for DB/redis/your-fave-network-reachable-service access?"
I do appreciate your concern that this library may be limiting its application scope by using the tty prefix. There are numerous gems that do offer 'generic' settings configuration usually named with words `config` or `settings`. They give you nice DSLs for creating a class level configuration and providing a method like access to settings etc... However, this gem is focused on making configuration management in terminal applications simple and effective, no frills. That's is why you can, for example, easily consume deeply nested keys as command line arguments. I would be happy and aspire for the tty-config to be the default go-to choice for command line applications configuration management rather than one of the hundred choices among many 'generic' solution that already do a stellar job helping people, for example, configure their Rails applications. 
Looks really interesting
The initialize method is the constructor method of any class, if you need initial values or run other methods when you create an instance of the object before it‚Äôs used
objects are state + behaviour. Like a truck modelled as an object, has state: being empty, or the load it carries, its driver etc. Essentially data that is associated with the object. In ruby this means instance variables. Behaviour is things an object can do. A truck can load, unload, move etc. In ruby this means instance methods. In this example a truck class might look like class Truck attr_reader :load # number of tons loaded attr_reader :driver attr_reader :location def load(mass) end def unload end def move (new_location) end end In your system you want to deal with objects that are ready to use. You don't want to expose a truck that is half baked. Ie you don't want a truck that has a driver, but no location. In order to ensure that all our object have all the necessary instance variables - the state set up, you set them in initialize. That code automatically runs when an object is created. 
If [ruby/ruby#1870](https://github.com/ruby/ruby/pull/1870) gets merged, I think that would fix the problem of having to write async-aware wrappers, at least for libraries that communicate with sockets via Ruby's `Socket` class (which are probably most libraries).
It is the initial eyes of the object :)
#1870 is a good first step, but I'd like to clarify your answer a bit further. Given your caveat, I'd like to draw your attention to `libpq` (Postgres client). It's not exposing or using any socket externally. The concurrency model is an explicit part of it's API, e.g. https://github.com/socketry/async-postgres/blob/f459ed180a59fce30fa6e1fa029cb7f2277da406/lib/async/postgres/connection.rb#L35-L47 It's reasonable to assume that once you make `Socket` non-blocking, everything else should follow, but unfortunately, as the above example shows, that isn't always the case.
Hey friend. If you're a bit confused about this it probably means you're new to OOP (Object oriented programming) so objects are an instance of a class, when you create an object it can have what's known as state... State is literally just information that the object holds. The initialize method is automatically called when you call `.new` on a class. Take the following example of a pet class... class Pet def initialize (species, age) @species = species @age = age end end Instance variables (state) are marked with "@" at he beginning, in the above example the state of an object would be the species and the age. If I create an instance of pet like this `Pet.new('dog',2)` then what happens behind the scenes is the object is created, the initialize method is called with the two arguments I put in. The initialize method I've created stores those arguments as state by creating variables for the arguments with the "@" symbol. So the state for that object would be @species = dog and @age = 2. I highly suggest looking into OOP as it's what ruby (and a lot of other languages such as python, java, c#) tend to prefer. Happy to answer any questions if you dm me.
I don‚Äôt see Go and Node.js are a direct competitor. However, Crystal programming language is, can be a complement to Ruby or replacement for some performance demands, I‚Äôm assuming with both, Ruby and Crystal could last longer than Node.js and Go. The cool ideas you can write desktop app with simple C binding, LLVM or so a little crazy with C language, I master a bit of C after 20 years. üëçüèª
Big "if" :) And as @ioquatix already pointed out, some network libraries don't expose the network socket that way, i.e. all database clients I can remember. My point with the earlier comment was more of a "how is this async-* ecosystem integration better than the old em-* ecosystem?", because by now we can say that the approach didn't work out well for the latter. 
I don't get it
Have you watched the video?
Which kinda of information would be relevant?
Piotr has done an amazing job on creating several nice tools for creating CLI applications. But my idea here is totally different. For example, if the user misses a command for example, we don't print an error message and leave. We give them the chance to fix his mistake and try again, all in the same session. I've never seen a Ruby gem with this mindset.
a Class is like the plans on how to build something. When you call \`#new\` on it, it's like you materializing it to life.
Thanks for the fantastic tty-&lt;&gt; gem collection series. Keep it up. Cheers. Prost. PS: Great to see the INI format supported. Did you know? There's a new-ish (and maintained) library / gem in town :-), that is, iniparser [1]. Last update for the inifile gem / library [2] (used by tty-config) in August 2014 :-(. [1] &lt;https://rubygems.org/gems/iniparser&gt; [2]: &lt;https://rubygems.org/gems/inifile&gt; 
I read the article and also watched a talk referred from another comment 'Nothing is Something'. I think I have a more clear view of the problem now. My original subclasses would differ in only how they implement the three methods. Even in the methods implementation they would share some code by using mixins. Now I think Ill just not use inheritance at all and use composition coupled with dependency injection instead. The methods would now be handled by the specific components.
I can't be the only one that doesn't trust a Ruby codebase that uses 4-line tabs.
I'm pretty sure it was in a Github discussion and not that tweet re: VM dev. I'll have to dig it up for you when I have some time, but it surprised me too. 
Let's say we want to create a `Rooster` object: class Rooster end now we can actually already invoke `Rooster.new` on it and we just got a `Rooster` object. But what if I want to name my rooster? What if I want to call him "John"? I could do this: class Rooster def initialize(name) end end Now `Rooster.new` would result in an error! rooster.rb:2:in `initialize': wrong number of arguments (given 0, expected 1) (ArgumentError) from rooster.rb:5:in `new' from rooster.rb:5:in `&lt;main&gt;' We forgot to pass the most important argument! The name of the rooster. We just replaced the `.new` method for the `Rooster` object with a method which needs an argument. So now when we give the rooster a name: `Rooster.new("John")`, it works and we get a `Rooster` object. &amp;#x200B; Now if we want to get the name of the `Rooster` object, we would first need to assign the local variable `name` of the `initialize` to an instance variable (in this case it's just `@name`). An instance variable only exists in the current instance of the object. def initialize(name) @name = name end and then we create a `name` method which simply returns the value of the `@name` instance variable: def name @name end now when we create a new rooster with a name: `rooster = Rooster.new("David")` and invoke `name` on it, we get "David"! &amp;#x200B; Don't get confused by that you need to call your method "initialize" to redefine the `.new` method of the object. That doesn't mean anything.
Thanks for the explanation! So if I get this right: While Piotr's gems are building blocks for potentially very different applications, your gem assumes some kind of default usage pattern?
I don't think that being "pure ruby" is the reason why Webrick isn't recommended for production deployments...
The standard for the ruby community is spaces instead of tabs, 2 per indent.
Blocking has both objective and subjective aspects. At some level, even `mov` blocks, more or less, depending on whether your memory is in L2 cache or main memory. "Non-Blocking" typically refers to interfaces with very large latency e.g. network IO. There are tons of blocking interfaces which are practically unavoidable e.g. file IO. I don't really see these as "terrifying" as pragmatic trade-offs. Falcon can work fine with higher level apps which invoke blocking interfaces, you just won't get the same level of scalability that you would with non-blocking interfaces. Essentially, `Async` won't be able to multiplex in this case, you'll fall back to "request-per-process/thread" performance, so if you think you'll encounter this just make sure you start a handful of processes/threads per processor core :p
I hope you don't use MRI then.
I like the logo
I know how you feel, I thought so too at the beginning, but I quickly got over it once I realized how awesome the `async` ecosystem is, and how shallow it was of me to judge a codebase just because it uses tabs :P FYI, in your editor you can set the tab width to 2 spaces. GitHub shows tabs with width of 8 spaces, but you can also tell it show a different width by appending `?ts=2` to the URL (though unfortunately it doesn't persist).
The main difference for me is that EventMachine required you to totally twist the way you write web applications, you couldn't just use Rails, Sinatra, Roda, or other Rack-based web frameworks. Goliath provided a nice framework for writing web applications in EventMachine, and tried to connect Rack with EventMachine, which didn't work because at the end of the day you still had to write a Goliath application. The `async-*` ecosystem is a huge improvement for me because `falcon` is an actual web server with a Rack adapter, which means I can switch my Rack application to run on `async` with zero changes, I just need to replace my `puma`/`unicorn`/`passenger start` command with `falcon serve`. Ok, I also need to translate any Puma/Unicorn/Passenger config file I have. Also, `async` has a much narrower native extension. While EventMachine implements the whole reactor in C++, the only native extension that `async` leverages is `nio4r`, which just implements a non-blocking IO selector in C. That makes it more accessible to people not fluent with C/C++.
Yeah, Puma has native extensions for parsing HTTP/1 requests but does IO selecting in Ruby, whereas Falcon implements HTTP parsing in Ruby but uses `nio4r` for IO selecting. So, neither of them are "pure Ruby", and they both use native extensions for different parts.
Really excellent summary! Thanks for writing it :)
&gt; So was thin. You're absolutely right. But for my use cases Thin doesn't really allow you to utilize EventMachine's asynchronicity, because it buffers the received request body data into a `StringIO` before calling the Rack app, and then it buffers the response body before writing it. So you have neither streaming requests nor streaming responses. Also, is Thin compatible with em-synchrony? Without that I don't think you can utilize EventMachine's reactor. &gt; But I don't think that none is that much more accessible than the other. nio4r wraps Java NIO for Jruby and libev for CRuby, so you have to learn C, Java, the NIO standard library APIs and libev's. I agree that `nio4r` and EventMachine are equally accessible, but I was talking about `nio4r` + `async` + `async-io`, which more-or-less provides the same functionality as EventMachine. For me the difference is that I can understand how async's reactor loop is implemented without reading `nio4r`. That for me makes `nio4r` the right kind of abstraction, as I only need to look at it if I want to understand how IO selecting is implemented.
Plus it isn't even "pure ruby", some of the core code uses [nio4r](https://github.com/socketry/nio4r) which has compiled-C for MRI, and Java for JRuby, as well as pure ruby. Puma says it uses compiled C for the actual HTTP parsing. (I think puma also has an event loop in C. Does Falcon perform as well at raw HTTP parsing as puma? Does it matter? I do not know. 
Yeah, it's kinda like a Rails, but much smaller and in a very alpha stage :). But yeah!
It sounds like you have two different issues: 1) you're setting a variable (`@enemy_roll`) and expecting it to change each time your reference it; and 2) you're wanting to keep rolling until some particular outcome. For the first issue alone, you presumably had something like this: @enemy_roll = rand(1..10) if @enemy_roll &gt; 6 puts "Hits!" else @enemy_roll end In that case, `@enemy_roll` is always going to be equal to whatever the rand method grabs for you when the variable it set. What you'll want to do it create a method that allows you to roll whenever you want. Something like this: def roll rand(1..10) end if roll &gt; 6 puts "Hits!" else roll end This would roll a 10 sider, check the value to see if it is &gt; 6, and if not, roll a new die. This works, but it's only half of your issue. It's not yet letting you loop that rolling until you get a particular result. For that, maybe something like this: def roll rand(1..10) end def encounter if roll &gt; 6 puts "Hits!" else puts "Misses! Rolling again..." encounter end end encounter That will do what you want, but I'd suggest you again return to thinking in object terms. Your enemies, like your heroes, are an obvious class that you could work on. Thinking slightly more abstractly about what constitute an object, you could create an `Encounter` class that, on initialization, takes a Hero object and an Enemy object and makes them interact. Just something to think about as you keep refining and refactoring.
If you're building on rack, I'd argue that you can't have truly streaming requests/responses. I don't remember whether thin truly buffered them, but that's something that most ruby servers do, because streaming in ruby is hard. &gt; Also, is Thin compatible with em-synchrony? It does demand from you a bit more, but I think it can be. You'd just have to wrap the request handler in a fiber, and in theory you'd get the same disadvantages that come with em-synchrony. To sum up, I think it has its use cases (just like eventmachine), but it's ultimately something I can't adopt for everything: It's unpredictable when I mix async-* with blocking libraries, and it uses ruby fibers, which well... these 2 combos didn't work neither for em-* ecosystem nor for celluloid-* ecosystem, and I can assure you, as I used celluloid in production for some years, that it's not a walk in the park. 
I think EventMachine and em-synchrony were great ideas. I tried to use them and there were several reasonable releases of RubyDNS built on EventMachine... Here are some of the issues I have with EventMachine: - Non-existant IPv6 support (at the time). - Random crashing (apparently still a problem). - Poorly abstracted APIs, differences in TCP and UDP handling, general socket handling. Here are some of the issues I have with em-synchrony: - Built on EventMachine which was/is flakey. - One gem which includes wrappers for many different systems. - Cluttered interfaces with both synchronous and asynchronous methods. - Felt like an experiment rather than a well-engineered system on which to build other things. It was these deficiencies which formed the guiding pillars of the `async` eco-system: Narrow focused gems, Try to make simple clear interfaces. Lots of test coverage. Compatibility with existing systems/interfaces where possible.
I think the pickaxe means to allocate memory for it mostly. The method "def initialize" usually calls another method too, called allocate(). To your second question - you can use initialize to do start-up related actions of your newly created object. For example, add methods there that you may want to use for setting up your objects. I usually define a method called reset() which I call within initialize too; this method sets the object to its default state, e. g. initializes some instance variables and so forth.
&gt; If you're building on rack, I'd argue that you can't have truly streaming requests/responses. I'm not sure I understand. Rack specifies that the request body should be an IO-like object, and many web servers took advantage of that: * Puma, WEBRick, and Thin chose to buffer the request body into a `StringIO`/`Tempfile` object before calling the Rack application * Unicorn and Passenger implemented a `TeeInput` which reads the request body from the TCP socket directly (streaming, but vulnerable to slow clients) * Falcon and my [goliath-rack_proxy](https://github.com/janko-m/goliath-rack_proxy) have Rack inputs that read from the socket, but they do it in a non-blocking way (streaming) As for streaming responses, I think most web servers write the response directly to the socket as the response body is being iterated over (it certainly looks so for Puma), so they implement streaming responses. I don't see how Rack would make it not possible, I'd say it *did* make it possible by specifying the response body should respond to `#each`. &gt; I don't remember whether thin truly buffered them, but that's something that most ruby servers do, because streaming in ruby is hard. From the first glance Thin also appears to be streaming the response body, because it's calling `EventMachine#send_data` for each response body chunk. But don't let that fool you, EventMachine will buffer any data sent in `#send_data` and write it to the socket only at the end of the event loop tick. So Thin doesn't do streaming, because it sends all response body data in the same event loop tick; to stream you have to send each chunk in the next tick ([like this](https://github.com/postrank-labs/goliath/blob/v1.0.6/lib/goliath/request.rb#L218-L225)). But I don't see why request and response streaming needs to be hard, as long as you make it non-blocking so that it doesn't affect the request throughput. &gt; It does demand from you a bit more, but I think it can be. You'd just have to wrap the request handler in a fiber, and in theory you'd get the same disadvantages that come with em-synchrony. I'm not able to visualize this. If you create the fiber in your request handler (I'm assuming you mean the `#call(env)`), and it gets paused when you call EventMachine, then you're still in the handler for that request. The Fiber needs to be somehow on the outer level (e.g. the reactor) for pausing the really work, at least in my head :) But I thought the point of em-synchrony is that you don't have to reimplement it. The problem with that being a separate library is that people who use EventMachine need to also remember to support it. With `async` this functionality is part of the framework.
The threadstarter hasn't yet added it to an upcoming developer meeting, which means that it may stay off for a long time if he does not add it to a developer meeting PR: https://bugs.ruby-lang.org/issues/14736
Ah there you are - you haven't yet added it to a developer meeting, so it may be dormant for months if you don't add it. :)
&gt; these 2 combos didn't work neither for em-* ecosystem nor for celluloid-* ecosystem, and I can assure you, as I used celluloid in production for some years, that it's not a walk in the park. I didn't have production experience with EventMachine, Celluloid, nor Async, so I definitely believe you. But I've read the source code a lot for EventMachine and Async, and it really seems that Async is a big improvement. But I can speak more once I've used it in production.
Actually, I went to Japan and discussed it with Ruby core team directly at Cookpad :) It's still a work in progress.
As an aside, just because I think you might be interested, but this gets even more tricky with HTTP/2 and flow control. It's not as simple as writing out the response body chunks to a socket any more. Ah, HTTP/1, those good days are over.
Any performance test against Puma or Passenger?
There are some benchmark scripts in source repo.
guys, allow me to clarify my claim about streaming request/responses: I really think it's kinda impossible to **truly** stream if you want to be rack-compliant. Why do I say that? Requests: In order to be fully rack-compliant, the input stream [MUST buffer the data into some rewindable object](https://www.rubydoc.info/github/rack/rack/file/SPEC), and that's an actual quote! So, it doesn't matter if you buffer early or you delay buffering, you're still going to buffer. Can you act upon read DATA chunks using rack? Then it's not really streaming, I'd argue. Responses: I don't buy the whole "streaming on #each" responses as being streaming, because if you still have to go up the rack stack before you're truly writing to the client. And that's for chunked responses. For "event-stream" responses, you have to resort to the hijack API, which indeed, makes it possible, by being the destroyer of layers and breaker of interfaces (artistic liberty achievement unlocked), hence by being just a great big hack. None of my arguments have to do with the async-* ecosystem btw. 
&gt; It's that simple, and I'd argue that there is nothing unpredictable about that. If you are using timeouts for your non-blocking interactions, they'll definitely be affected by "out-of-reactor" slow operations. &gt; I actually agree with this - concurrency isn't necessary for many problems. I also agree. But incompatible concurrency constructs do their own damage. And that's unfortunately the state of affairs in ruby :/
&gt; So, it doesn't matter if you buffer early or you delay buffering, you're still going to buffer. There is a big difference between having your web server buffer the whole request body first and only then call your app, and having it call your app immediately with a Rack input that dynamically fetches the request body from the socket and internally caches read content to disk. For me that's still streaming. Btw, the rewindability requirement will probably be removed in the recent future, see [rack/rack#1148](https://github.com/rack/rack/issues/1148). Note that even current Rack doesn't seem to use the rewindability, and `#rewind` is only called when parsing `multipart/form-data` POST requests. So I'd say that's a pretty lax requirement; Falcon only makes the input rewindable on `POST` requests with are multipart or URL encoded. &gt; I don't buy the whole "streaming on #each" responses as being streaming, because if you still have to go up the rack stack before you're truly writing to the client. And that's for chunked responses. This also works for normal responses. In my gem which provides a Rack application for streaming large files, in the download request I'm assigning a `Content-Length` manually, and the response body will still get streamed just as well. &gt; For "event-stream" responses, you have to resort to the hijack API, which indeed, makes it possible, by being the destroyer of layers and breaker of interfaces (artistic liberty achievement unlocked), hence by being just a great big hack. Yeah, hijack API sucks, I don't want to suddenly have to take care about lots of stuff. Out of curiosity, couldn't you handle SSE using the `#each` in response body (e.g. via Roda's and Sinatra's stream API)? I might have asked you that already in the past, but I don't remember.
why automate bash tasks with ruby scripts? It seems the direct way would be to write bash scripts.
hey, github is acting up a little bit :D so in some instances you can see that I opened a issue and a pull request :D &amp;#x200B; keep it up!
I would like to give you some criticism, that I hope you take the right way. Being 5x faster is a bold claim. It's great if it's true, but someone who just clicks might find it hard to believe. I think there is an opportunity for you to make yours a popular gem: add benchmark results to your README.md, include shiny charts showing off your 5x faster claim. Explain how you did it, why it's 5x faster, and what are the drawbacks if any.
Mostly to get better, but also some things are just simpler and better if you use a language as opposed to straight bash scripting. This is commonly done with python and Popen, to mention an alternative.
&gt; For me that's still streaming. I get what you mean, and there are advantages, like if you technically delay buffering and your web-server p.ex. supports 100-expect header, you can get away with it. But if you buffer the request body into a rewindable object and this object lives for the duration of the request/response cycle, even if a tempfile, it's not streaming per-se. But I'm not saying it's not useful. &gt; Note that even current Rack doesn't seem to use the rewindability... It doesn't matter. the rack library is just an implementation of the spec. If it's in the spec, you have to fulfill the requirement, or else 3rd-party middleware from end-user application code or library that for some reason depends on this requirement will either complain or just not use a server which advertises as "rack-compliant". You say that the requirement will be removed, but the ticket you linked was created in 2017. And I've seen the (by now 6 year-old?) roadmap for rack 2, and they were already mentioning removing it. Rack is one of the most ossified pieces of software in ruby, sadly. &gt; Out of curiosity, couldn't you handle SSE using the #each in response body (e.g. via Roda's and Sinatra's stream API)? You can't :/ Most web servers chose to implement it as chunked responses, and rightfully so. 
Is it just me, or is the text on this blog so large that it is barely readable? On chrome, zooming in and out has no effect.
Try it without the --version bit. It should install 0.0.4 
Very cool. Weird name though. Translates to scam in my language (Russian)
I don't really have any examples, but you can get pretty far with shebang scripts just using ARGV, $stdin/etc, and Open3#popen3 &amp;#x200B; As a caveat: I'm partial to just using bash these days for automation scripts due to portability. Ruby ain't small
it translates to "tattletale" exactly, and this is something little kids would use (I'm a Russian speaker), never heard this word from someone over 12 :)
Evil Martians overtook Thoughtbot as far as ruby open-source technical contributions go. Good stuff.
Yabeda not tell anyone ;P
All true, also not the point. I‚Äôm not trying to be more efficient at work: I already have a couple of bash scripts to automate and speed up the most repetitive parts. This is done in the spirit of getting more comfortable with Ruby.
Thanks! I stupidly assumed Popen was only available in Python, I‚Äôll definitely check it out!
In what Russian dialect does "—è–±–µ–¥–∞" mean scam? I thought I knew my language, but clearly not. Please teach me.
Ugh, take my upvote.
`gem pristine --all` should fix it: https://stackoverflow.com/questions/38797458/ignoring-gem-because-its-extensions-are-not-built
Thought bot seem too have gotten bored of ruby and moved on. 
Didn't notice the sub at first and this title got the former waiter in me a little defensive.
they moved on to Elixir. 
/r/lethal_punmanship is where yabeda go with that shtuff. ü§¢
...which I'll bet the marketroids at EM have taken notice of. "We're not just following today's hipster trends; we'll support you and your stack for the long haul." A lot of not-necessarily-unhipster companies *should* see the appeal in that.
Yes
I was hoping for details on internal structure of gems... at least based on definition of `innards` https://www.dictionary.com/browse/innards
Remember times where you'd google for something and find stuff from people who legitimately wanted to share something they learned/made/etc? Now it's mostly low effort blog spam from companies that want to get better SEO. Here's a better source of info about "innards": https://guides.rubygems.org/make-your-own-gem/
In my experience it's good to add slugs to urls but it's a bad idea to use the slugs to load your resources. A better approach is to add the slugs after the id in the route. my-resource/:id/:slug The slug still has value for SEO and as an informational UI element, but you are not tying your domain logic to a volatile field (an article title is probably editable, unless you're Reddit)
CMD is a holdover from the DOS days while PowerShell is a scripting environment capable of using pipes like Unix-like operating systems can. Don't get me wrong you can redirect in cmd as well but CMD is a lot more limited in terms of what kinds of admin features it supports.
They usually have very high quality and interesting posts, might not be their best effort
They usually have very high quality and interesting posts, might not be their best effort
Can you say more about what in your experience led you to believe finding by slug was a bad idea?
In step 5, I believe there's an error: &gt; @post = find_by_slug(params[:slug]) Should probably be: @post = Post.find_by_slug(params[:slug])
[https://github.com/norman/friendly\_id](https://github.com/norman/friendly_id) makes this very easy/powerful.
Sure. First of all it's not the action of finding by slug that's problematic. It's the corruption/confusion of what constitutes a unique identifier within the system which can cause a lot of issues downstream. Let's assume that the title on which the slug is based is editable. Then the following happens: A new article is published and so a slug is generated and saved. The article is shared to reddit, gets some upvotes, and generates some conversation. Then the title is edited (let's say a word was misspelled). Now there's a problem. If the we update the URL to match the new title the link on Reddit is now a 404. If we do not update the URL we've got a typo there forever. That's just one example. 
The only solution I found to this when using Rails as an API and React FE (so, SPA) was text slugs without `:id`. If you ask me adding `:id` to url's is ugly and I don't even want the user to see the id in url as it's more revealing than it should be. The React/Redux FE uses text slugs, and in BE controllers the request is text slugs, which I then convert to id's if needed for any associations. The seemed like the easiest way to handle it, it comes with speed implications and the complication of having id's persisted to DB, but slugs used in FE, but I couldn't find any other reasonable way. Open to hearing any thoughts though
Makes sense, thanks! Amazon uses a URL system (for books at least) that is reversed, but accomplishes the same thing as your suggestion. `/#{words-in-title}/dp/#{isbn}`. You can actually put whatever you want in the words-in-title path component, and it'll still resolve. 
I'm skeptical there are any actual practical performance concerns, I'd want to see some measurements demonstrating that. I would worry about what remain_calm says below, about how this makes your URLs non-persistent if the slug can change. 
Nope, no library. It's just that if I have to find something in the Redux store, I have the state shape setup so each key is the slug, and not the ID. For your statement on speed, I believe it's always faster to query with integers compared to strings. Not by much, but still for any associations I would have to also find the object by string, where if I was passing integer ID for both FE and BE I wouldn't even need to find the association and I could just pass the ID around. 
Right, if the "how much" is .000000000001% of your program execution time or something, it's not an issue. Sometimes people get performance tuning crazy and tune things that don't matter at the expense of program legibility or functionality. 
I'm not entirely sure why you've posted this. Do you think this would be a good example for others to learn how code is built? Did you want to publicise the library, because it's useful? Do you think the end result is particularly well written? Are you looking for feedback?
Yea, I agree. The making it less readable is a bigger deal in my book unless it's noticeably slower. But I try to avoid extra lookups when possible. Like I rather not have my controller searching for class by string slug when I could just pass the class ID in the request from FE.
it's really not an extra lookup. I don't think you mean "class" when yu say "class". okay, anyways. 
I can't imagine why someone wouldn't use this.
Because dependency hell sucks. Because it's pretty easy to do without a dependency, and easy to customize.
I'm partial to babosa: https://github.com/norman/babosa
This actually happens on StackOverflow when you edit a question title. If you type in the old slug (or any value that is not equal to the current slug) you get 301-redirected to the authoritative slug
What was the end result - baseline time, not parallelized vs. parallelized?
Just use the dependency. The good outweighs the bad. 
Read this: https://yehudakatz.com/2010/08/14/threads-in-ruby-enough-already/ Ruby doesn't block everything on IO ‚Äî it only blocks its current thread but allows other threads to execute. IO is the only time Ruby allows other threads to concurrently execute. So if you are calling to a time-consuming external API, you can certainly do other things while you wait for it to respond. My typical use case is when I have to make multiple API calls at the same time: I start them concurrently (e.g., using concurrent-ruby's promises or async/await) so that the total time taken is the same as the slowest call ‚Äì not the total of all the calls.
Actually, many em (event machine) prefixed gems are doing a better job regarding async io , but it makes the code harder to read and maintain. For example an event machine based http server will behave 2 times faster than a node js http one . 
Switch to RSpec, deprecations, minor enhancements, and bug fixes. New Guides website and new team member. From now on, our focus will be for 2.0. We'll deeply integrate DRY &amp; ROM.
&gt; Switch to RSpec Is there a ticket where I could read reasoning behind this?
It's explained in the blog post.
Thanks for the kind words. Let us to know how it will go.
Ok that makes sense, thanks for the answer!
When running on Ubuntu 18.04 with 4.18.0 kernel installed on latest MBP with 16GB ram and \~8 cores (including hyper threading): * rspec with spring: \~**42'** * parallel tests, 8 processes, spring and evenly distributed tests: \~**8'20"** \- so over **5x** improvement I've added a section with run time comparison, so you can checkout how it looks with less processes, or how much time saves the tests distribution (**4'30"** in our case).
Anyone who came from Java, c, c++? What did you use? Or, what would you have rather used (in hindsight)? :-)
You'll probably enjoy Qo, which implements a lot of the same ideas: https://github.com/baweaver/qo
The use case is JS developers coming to Ruby and wanting to use what they already know.
I will give a warning that the subject matter can be a bit heavy in this post. Over the past half-year I've had several people ask me what's up with all the lemurs, so I decided to finally share that story. I can't say it's a particularly easy one to write, but I hope it's of use to some of you out there. Amusingly enough the lemurs led me to _why, and through that Ruby.
`ARRAY_IT = -&gt;`, `Q = -&gt;` No, please don't. A constant should not be function. Also the syntax highlighting color scheme is hardly readable.
Yes, M and Q was what inspired me. I tried to give my feed back on [https://medium.com/@baweaver/for-want-of-pattern-matching-in-ruby-the-creation-of-qo-c3b267109b25](https://medium.com/@baweaver/for-want-of-pattern-matching-in-ruby-the-creation-of-qo-c3b267109b25) but I had not account on [medium.com](https://medium.com) &amp;#x200B; BR, Jukka
I would love an example tha compares a Thread implementation vs the async await implementation. It would make it easier to understand the advantages of async await. For example, in this example I feel like you could have achieved the same thing with a simple Thread#value or a Concurrent::Future. When reading about new things, I like seeing examples where they provide a clear advantage over the existing alternatives.
That's a nice excercise! (I want to warn, though, that your `pipe` method doesn't what you do to move "towards functional programming" in Ruby, basically ;)
Awesome.
actually we compared it with same hardware but with original osx setup: * it was impossible to run on 8 processes, 7 was maximum without crashing * it's at least 2-3 minutes slower on average so viva la Linux! :D
Thank you. Unfortunately I still get the same errors as before. Tried leaving the version bit for each command, no success. 
If price is zero issue just go with luminati.io Asshole of a business model. Great product.
Recently a friend wanted async multithreaded access to a socket, so multiple calling threads could write out messages without blocking. He ended up with something a bit like: class AsyncWriter def initialize(fd) @writer = Thread.new do while msg = @write_queue.deq fd.write(msg) end fd.close end end def write(msg) @write_queue &lt;&lt; msg end def close @write_queue.close @writer.join end end w = AsyncWriter.new(socket) w.write(foo.to_json) w.write(bar.to_json) w.close The `write` calls are clearly thread-safe and non-blocking: they just add to a queue to the worker thread. `close` is sync and waits for it to finish. With Async you could write it like this: class AsyncWriter include Concurrent::Async def initialize(fd) @fd = fd end def write(msg) @fd.write(msg) end def close @fd.close end end w = AsyncWriter.new(socket) w.async.write(foo.to_json) w.async.write(bar.to_json) w.await.close The class is just written naturally and the same thread-safe queuing behaviour is added via the proxy methods, complete with their return values being available via futures.
"If you try to make the stdlib CSV parser parse invalid CSV, it complains that the CSV is invalid". Is...this supposed to be the suggestion? There's an argument to be made that a noncompliant CSV parser has a place, because CSV produced in various toolchains can be noncompliant and needs to be parsed, but it's silly to complain about a parser refusing to parse noncompliant content. Your example "breaks" the quoting by prepending a leading space, which you implicitly assume to be a rejectable part of the field, but RFC4180 (which you even cite!) _explicitly indicates that this isn't valid!_ &gt; Spaces are considered part of a field and should not be ignored. Yes, it also says to interpret input liberally, but the fact of the matter is that this is _broken CSV_ and the handling of it is going to be undefined. If you're going to interpret "liberally" as "whatever it takes to make the input parse", then, well, sure, you can do that, but that isn't very useful because instead of the parser conservatively saying "hold on there cowboy, someone made a mistake putting this together", your parser just glosses over the issue and applies your own assumptions about what input data should look like. This is the CSV equivalent of `rescue Exception` - sure, it works, but it's going to bite you later. This is supposedly a problem in Ruby's implementation. Okay, let's look at Python: import csv from StringIO import StringIO s = '1, "Hamlet says, ""Seems,"" madam! Nay it is; I know not ""seems."""' print [row for row in csv.reader(StringIO(s), delimiter=',')] [['1', ' "Hamlet says', ' ""Seems', ' madam! Nay it is; I know not ""seems."""']] Whoops. It parses, but we somehow got 4 fields out of what was intended to be 2. That's going to cause a problem for any file with more than 1 row! How about Go? package main import ( "bytes" "encoding/csv" "fmt" ) func main() { s := `1, "Hamlet says, ""Seems,"" madam! Nay it is; I know not ""seems."""` b := bytes.NewBufferString(s) r := csv.NewReader(b) record, err := r.Read() if err != nil { fmt.Println(err) return } fmt.Println(record) } And the results... parse error on line 1, column 3: bare " in non-quoted-field Huh. What about Javascript, with the `csv` library (the most popular CSV parsing library for nodejs): const csv = require("csv-parse"); const parser = csv({ delimiter: "," }); const input = `1, "Hamlet says, ""Seems,"" madam! Nay it is; I know not ""seems."""`; parser.write(input); parser.end(); parser.on("readable", () =&gt; { let record; while ((record = parser.read())) { console.log(record); } }); parser.on("error", err =&gt; console.error(err.message)); Which gives us: Invalid opening quote at line 1 That's weird. Maybe _all_ the CSV parsers are broken? If you could demonstrate that the stdlib could be used to produce CSV that it then can't parse, you have an issue, but complaining that the stdlib doesn't parse invalid CSV seems particularly pedantic. There's definitely room to provide a more lenient parser which makes some spec-violating assumptions about what to do with invalid data, but making hay out of "the stdlib is broken" feels gross. Would it shock you to find that the JSON library doesn't parse invalid-but-human-readable JSON (which also happens to be valid Javascript)? &gt; JSON.parse '{unquoted_key: "value"}' JSON::ParserError: 765: unexpected token at '{unquoted_key: "value"}'
I see on the discussion page for the method, Matz chimes in with the question on my mind: https://bugs.ruby-lang.org/projects/ruby-trunk/activity?from=2018-05-17
Also, your library doesn't handle non-UTF-8 encodings properly (and doesn't seem to provide a way to indicate that the input file should be anything other than UTF-8): $: &lt;&lt; "./csvreader/lib" require 'csv' require 'csvreader' open("utf16test.csv", "wb:utf-16le") {|f| f.puts "„ÅÇ,„ÅÇ" } open("latin-1test.csv", "wb:iso-8859-1") {|f| f.puts "M√ºnchhausen,M√ºnchhausen" } files = { "utf16test.csv" =&gt; "utf-16le", "latin-1test.csv" =&gt; "iso-8859-1" } files.each do |file, encoding| puts "Reading #{file}" puts "-" * 40 print "Ruby (read)\n\t" p CSV.read(file, encoding: encoding) print "CSVReader (read)\n\t" begin p Csv.read(file) rescue =&gt; e p e end fp = File.open(file, "rb", encoding: encoding) str = fp.read fp.close print "Ruby (parse)\n\t" p CSV.parse str print "Csvreader (parse)\n\t" begin p Csv.parse str rescue =&gt; e p e end puts "\n" end Results: Reading utf16test.csv ---------------------------------------- Ruby (read) [["\u3042", "\u3042"]] CSVReader (read) [["B0", "\u0000B0"], ["\u0000"]] Ruby (parse) [["\u3042", "\u3042"]] Csvreader (parse) #&lt;Encoding::CompatibilityError: incompatible encoding regexp match (US-ASCII regexp with UTF-16LE string)&gt; Reading latin-1test.csv ---------------------------------------- Ruby (read) [["M\xFCnchhausen", "M\xFCnchhausen"]] CSVReader (read) #&lt;ArgumentError: invalid byte sequence in UTF-8&gt; Ruby (parse) [["M\xFCnchhausen", "M\xFCnchhausen"]] Csvreader (parse) [["M\xFCnchhausen", "M\xFCnchhausen"]]
Man, this is a great example, the async-await version is so neat. At first I thought that it was like a thread pool, but a thread pool won't retain the order of messages. And actually a thread pool is not what you want in this case, because you need things to be executed one after the other, not in parallel. Thanks a lot for illustrating!
If you're using the OSX system ruby you might try using rbenv to install your own ruby, with your own gems. I have ruby 2.4.2p198 (2017-09-14 revision 59899) [x86_64-darwin17] installed via rbenv and have no issues installing colorls. 
I appreciate the blog post but I hate this kind of unnecessary magic.
Hey everyone üëã, I'm Colby, core maintainer and the current release manager for Bundler. If you have any questions about this release or anything Bundler related, let me know below.
Thanks for the new release Colby! I really like the (older) bundle add and it's great to see bundle remove follow up. No more editing Gemfiles for me :D
Really excited about Hanami. My main wish for Hanami is to just remove the abstractions over ROM rb and instead use those resources to improves the pain points on the rom-rb ecosystem. Keep up the great work and excited for 2.0!
Yay, `bundle remove`!
I trying to understand the best way to approach FP. Ruby has its root in OOP and definitely there is a gap in FP support in Ruby. I understand that there are frameworks with quite compresensive FP support. However, I would like to apply FP micro patterns in my code base, before committing too deeply in such fraweworks. &amp;#x200B; What is your suggestion, how to move ""towards functional programming" in Ruby context? BR, Jukka
Thank You for the feedback. I will take a look, how to make syntax highligthing color scheme better.
Bundle remove sounds awesome, but I'm concerned about orphaned files. Are you still expected to run an uninstaller if it's available?
what happened to 2.0?
Sometimes repeating helps to highlight the message. Let's rewrite as an example the RFC 4180 Memo about Comma-Separated Values (CSV) (see &lt;https://www.ietf.org/rfc/rfc4180.txt&gt;) cited above: This memo provides information for the internet community. - **IT DOES NOT SPECIFY AN INTERNET STANDARD OF ANY KIND.** - **IT DOES NOT SPECIFY AN INTERNET STANDARD OF ANY KIND.** - **IT DOES NOT SPECIFY AN INTERNET STANDARD OF ANY KIND.** By the way, here are [six more CSV specs / standards](https://github.com/csvspecs) incl. "strict" JSON v1.0 encoding. What you're missing is - it's about the future - how? Things change. Is CSV frozen forever? Of course, not. See: This memo provides information for the internet community. - **IT DOES NOT SPECIFY AN INTERNET STANDARD OF ANY KIND.** - **IT DOES NOT SPECIFY AN INTERNET STANDARD OF ANY KIND.** - **IT DOES NOT SPECIFY AN INTERNET STANDARD OF ANY KIND.** One more thing and a little trivia quiz from the [CSV talk](https://github.com/geraldb/talks/blob/master/csv.md): ``` JAHR;GCD;GEM_NAME;BEV_ABSOLUT;BEV_UNTER15;BEV_UEBER65;AUSL_STAATSB;... 2011;10101;Eisenstadt;13.101;13,8;18,2;9,4;... 2011;10201;Rust;1.896;13,8;22,2;4,7;... 2011;10301;Breitenbrunn am Neusiedler See;1.902;12,1;22,4;5,6;... 2011;10302;Donnerskirchen;1.742;12,3;20,2;3,8;... 2011;10303;Gro√üh√∂flein;1.929;12,9;17;3,4;... ... ``` Triva Quiz: Who Invented the Space Character in Writing (and When)? - [ ] The Greeks in the Golden Age - [ ] The Romans in the Age of Empire (What have the Romans ever done for us?) - [ ] The Irish Monks in the Middle Ages - [ ] The Frankish Alchemists in the Charlemagne's Age (800-) Triva Quiz: Who Invented the Space Character in CSV (and When)? - [ ] [CSV v1.1](https://github.com/csvspecs) in 2018 :-) Still waiting :-). Yes, you can. Let's make it happen. Pretty printed version with space (CSV v1.1). Example: ``` JAHR; GCD; GEM_NAME; BEV_ABSOLUT; BEV_UNTER15; BEV_UEBER65; AUSL_STAATSB; ... 2011; 10101; Eisenstadt; 13.101; 13,8; 18,2; 9,4; ... 2011; 10201; Rust; 1.896; 13,8; 22,2; 4,7; ... 2011; 10301; Breitenbrunn am Neusiedler See; 1.902; 12,1; 22,4; 5,6; ... 2011; 10302; Donnerskirchen; 1.742; 12,3; 20,2; 3,8; ... 2011; 10303; Gro√üh√∂flein; 1.929; 12,9; 17; 3,4; ... ... ``` 
&gt; "If you try to make the stdlib CSV parser parse invalid CSV, it complains that the CSV is invalid". Again you're very unhelpful by saying valid CSV is invalid. How ingenious. Dare I say you lazy ___. Who says what's valid CSV - your little CSV memo by a random internet guy? Ha. Ha. Ha. Let look at the libraries again: Python has a skipWhitespaces option and the Python panda csv reader has how many options? 10, 20, 30, 40? Yes, it has 50 options incl. trim spaces, and more &lt;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html&gt;. How about the JavaScript csv library? It has ltrim, rtrim, trim and more just for whitepace options. See &lt;https://csv.js.org/parse/options/&gt;. And so on. Please, don't be irresponsible claiming the old chestnut that only the CSV RFC is valid CSV. It's just a one of many dialects / flavors / formats. 
We will be sharing news about the status of Bundler 2 in the coming days. Stay tuned!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [shime/rfcs/.../**0002-bundle-add-and-remove.md#5-removing-gems** (bundle-add-improvements ‚Üí 6b2801a)](https://github.com/shime/rfcs/blob/6b2801aab7ba7c539f81fd615b8c1fe1a79f3125/text/0002-bundle-add-and-remove.md#5-removing-gems) ---- 
this isn't for myself but I'm going to highly suggest it..sounds like what he's looking for. Thank you.
I've often wondered whether ruby's ability to define ranges as `Integer..Integer`, or `Float..Float`, or `String..String`, ... is a bit *too* flexible. On the one hand, it allows all sorts of neat syntax. But on the other hand, it causes tonnes of weird edge cases in the core language - such as how exactly these exotic ranges are defined and compared. Perhaps it would have made more sense to define something like `IntegerRange`, `StringRange`, etc classes to avoid the mess... I'm not sure. I can hear the faint sound of an angry duck quacking at me.
OK, here will be a LONG answer, so for the foreword: please remember I am non-native English speaker with good intentions, so I am trying to explain and discuss things, not being rude or patronizing, even when I seem so, OK? &gt; Ruby has its root in OOP and definitely there is a gap in FP support in Ruby. This is a very huge misconception. Ruby is a multi-paradigm language, and functional programming is one of the paradigms it supports from the very beginning, you just need to understand how the functional style of code looks in Ruby. The fact that Ruby "lacks" things that are explicitly called "pure functions", or "monads" doesn't mean it should be bent twice to achieve something "functional". The cores of Ruby functional style are: * blocks/procs * chainability. In general, we say that a goal of "functional" program is to represent the computation as a chain of the transformation of values; those transformations should not change values (immutability), should be idempotent and pure (except for the input/output, preferably clearly separated), right? So, here is some **functional** Ruby for you: ```ruby loaderConfiguration[:sqlDirectory] .flat_map(&amp;method(:list_files)) # method body is omitted .select { |file| ACCEPTED_SUFFIXES.any? { |suf| file.end_with?(suf) } } .map(&amp;File.method(:read)) .sum { |content| content.lines.count } .yield_self { |count| "dbConnection: #{loaderConfiguration[:dbConnection]}, lineCount=#{count}" } ``` That does almost the same as yours (I've omitted some details), it is much more "Rubyish" and, which is _more_ important, it is ABSOLUTELY FUNCTIONAL: It is a chain of computations, each of them being pure, no values mutability, the meaning is expressed clearly and obviously: from that value go to that, then to this, then to those, then finish with this one. This point of view on Ruby leads to a lot of small decisions about OO-design, because Ruby is a _healthy mix_ of both: in ideal case, you design/use objects that are _very_ chainable (by leveraging Enumerable/Enumerator, or with `yield_self`, or by themselves, leveraging method return values). Thinking of "kind of monads" in order to wrap some objects is helpful and useful too, I can show this example of [my own gem](https://github.com/zverok/hm). The goal, again, is to "wrap ‚Üí **chain** ‚Üí unwrap" in a perfectly Ruby fashion. Going back to your example, concept of "definitely Array with controlled types of elements" has its right for existance, just probably "idiomatic" Ruby will do something like those: ```ruby # either args = ArrayWrapper.new(args, [File, String]) # args now is an instance of ArrayWrapper! # or args = ArrayConverter.call(args, allow: [File, String]) # args are still Array, don't imitate method calls with ARRAY_IT[] ``` Hope this helps. 
The issue is that your endpoint is expecting `PUT` uploads where request body = file content, and with Faraday you're sending file content as a `file` parameter with `Faraday::UploadIO`, which Faraday will probably encode in `multipart/form-data` regardless of the HTTP verb you're using. You want pass file contents to the request body directly. This should work: conn.put("/next_cloud/url/file_name.png") do |req| req.body = File.binread("/file_path/1/2/3/original_file_name.png") end
It is mostly used for "Rails magic" kind of stuff. In a lot of apps you can see (I believe, officially promoted)` `if Rails.env.production?`... which makes you think that `Rails.env` is properly engineered object-oriented "current environment wrapper" but NO IT IS NOT HAAHA GOTCHA it is just `ArrayInquirer`
| Add --optimistic and --strict options to bundle add that will add a version constraint to new gems It's not obvious to me what this means, and I can't find any docs/examples. If you could provide some docs with an example, that would be awesome. 
I'm not familiar with Prometheus, and am not certain I understand how it fits in. To get the monitoring UX discussed in this article... is Prometheus a separate server app I need to run? 
What the reason of including `bundle gem` for generating gems (from scratch) in bundler? Why not adopt a "generic" project scaffolder for the quick start for new gems? Why? A "professional" project scaffolder lets you use templates - fits with the ruby philosophy :-), that is, there's more than one way to do it and also opens up the gem starter kits to everyone. PS: Example for a ruby scaffolder - quik -&gt; &lt;https://github.com/quikstart/quik&gt; and for two template repos &lt;https://github.com/quikstart/gem-starter-template&gt;, &lt;https://github.com/quikstart/gem-starter-template-hoe&gt;
yeeeessss
In this particular case I have similar feelings.
`Rails.env.production?` uses `StringInquirer` magic to be precise :-) I described it in the previous article: https://frontdeveloper.pl/2018/10/activesupport-stringinquirer-magic/
Is it possible to add or remove gems from the `.gemspec` file with the bundler CLI?
Nice! Any particular speed improvements that we might not be aware of? Migrating to 1.16.x was one of the best upgrades of all time because of this. Also, I wasn't aware of plugins, and how exactly libraries interact with. Guess I have some reading to do. 
Regular expressions can definitely solve this. Do a positive look forward on either ‚Äú or ‚Äò, then a second on the same values to end. Ensure you are doing a global (multiple) match and it would get you what you want. Also, it is blazing you faster than string splitting. If I have time later I‚Äôll write you one.
`#shellsplit` seems appropriate here. https://ruby-doc.org/stdlib-2.5.3/libdoc/shellwords/rdoc/Shellwords.html require 'shellwords' %q["1", "2" , "3"].shellsplit # =&gt; ["1,", "2", ",", "3"] Still need to do something about loose comma though.
Ah, yep, definitely
When can we expect blog post titled "How I sped up my test suite from 1 hour 30 minutes to just under 1 hour with this weird trick"?
I'm a big fan of regular expressions (text patterns) and I highly appreciate your tips and even the offer to put a code sample together. Unfortunately, the quoted values can hold doubled up quotes for escapes or unix-style backslash escape and some more edge cases. If I google for "csv regex pattern" I end-up - of course - on stackoverflow (aren't we all full stackoverflow coders :-)). Anyways, here's a "classic" regex pattern: (?:^|,)(?=[^"]|(")?)"?((?(1)[^"]*|[^,"]*))"?(?=,|$) The [poster explains](https://stackoverflow.com/questions/18144431/regex-to-split-a-csv): &gt; This expression will: &gt; &gt; - divide your sample text on the comma delimits &gt; - will process empty values &gt; - will ignore double quoted commas, providing double quotes are not nested &gt; - trims the delimiting comma from the returned value &gt; - trims surrounding quotes from the returned value The point is that's all great but unfortunately still not good enough for handling all edge case for a "real-world industry-strenght" csv parser. There's no shortcut - we need a hand-coded purpose-built parser :-).
``` require 'CSV' data = '"1","2","3"' CSV.parse(data)[0] =&gt; ["1", "2", "3"] ```
Great. Now try it with 1) mixed quotes and 2) some spaces - `"1",'2',"3"` - `"1" , "2", "3"` How are you doing :-)? 
There is not necessarily a one-size fits all option. Why would you need a timeout on random generic Ruby code? What is potentially going an unpredictable amount of time, why, and why do you want to interupt it? Usually we mainly need timeouts on IO, including network IO. Because those are timings that are out of our control. Things that don't touch IO are just taking CPU time, _and_ we have complete ruby control over them. So we can write the code to, say, just periodically check the time and see if it wants to time itself out. But timeouts usually come up with IO (disk, network, etc), in which case using timeouts exposed by the underlying library (usually using OS facilities in C) is the right thing to do. Which doesn't mean it's always easy -- libraries can be poorly designed, and, in truth, ruby doesn't give us great tools here. 
Hey, jrochkind, just a quick heads-up: **interupt** is actually spelled **interrupt**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
This is a bit of a personal project, I grew tired of going to RubyGems every time I want to gather information about a gem like the downloads or version info, etc. So I made this little tool in Ruby to aid me in that task. Let me know if you like it :) Here's the GitHub repository: https://github.com/franccesco/tmg Edit: Had to post it again as the first one wasn't accepted.
What grammar do you want to recognise? You gave an initially simple example and then when people try to help you're listing extra edge cases. What is the complete grammar?
In this case, the problem is not the parser, but the data source. Normalizing inconsistently formatted CSV data is a nearly intractable problem. I did data processing using Ruby full-time for a few years and was unable to find an adequate solution for this exact issue. I would request that the data be re-submitted in a tab delimited format instead.
Thanks i'll add a note. These options basically will just a version constraint on new gems you add. ie: $ bundle add json --strict Fetching gem metadata from https://rubygems.org/. Resolving dependencies... Fetching gem metadata from https://rubygems.org/. Resolving dependencies... Using bundler 1.17.0 Using json 2.1.0 $ cat Gemfile | grep json gem "json", "= 2.1" 
Thanks for your helpful answer and taking the time for a great example. I was just trying to point out that there is no simple, easy answer for the "full" CSV variants - only a purpose-built parser (with 100+ lines of ruby) can handle it - that's why they usual recommendation is to (re)use a CSV.parse library - which in ruby's case, unfortunately and sadly will NOT work. 
That's the point. It's not impossible to make the CSV parser more accepting with different variants / flavors - all you need is a little more code (e.g. a purpose built-parser instead of the current String#split kludge - see above) and that would make many ruby coder happier. The tab format has its own issues, see &lt;https://github.com/csvspecs/awesome-csv#delimiter--separator&gt;. :-) incl. like CSV what tab format are you talking about :-). Here's a spec &lt;https://www.iana.org/assignments/media-types/text/tab-separated-values&gt; by IANA. 
The goal is a better csv library with many parsers (and a more "sophisticated" default), see &lt;https://github.com/csvreader/csvreader&gt; and for all the CSV formats collecting / writing specs (grammars), see &lt;https://github.com/csvspecs&gt;. 
Ok but I don't think you're going to manage this with `String#split`, so look at other options instead, such as a finite state machine.
I know :-). I'm not in denial. I'm getting all this hate for pointing out the the ruby std library is using String#split and, thus, it can never work for handling more edge cases, of course. 
I think people were confused because it sounded like you wanted help solving an immediate problem and it turns out you were really wanting a debate about how CSV is implemented. So people were suggesting things and you‚Äôre enjoying the discussion but they don‚Äôt understand why you won‚Äôt just say what you‚Äôre input is but you don‚Äôt really have any so you can‚Äôt answer. Cross purposes.
OK. Based on the latest version available from rubygems? Or the latest version that can resolve with your existing dependencies? Is there no option for what I think is generally the consensus best practice when dependencies are using semantic versioning: `gem "json", "~&gt; 2.1"`?
Awesome. The most common thing I need is to know the recent version releases of a given gem. I keep making little one-off scripts to do that for me via rubygems API, and then losing them. :) Will this do that?
I wrote a gem called gemline to do that. Also drops a gemfile-formatted line into your clipboard for pasting into your gemfile or gemspec. Although the latest version of bundler takes care of gemfile manipulation for you.
Cool idea! What items are you retrieving that aren‚Äôt in the public api and require authentication?
What's the reason of including bundle gem for generating new gems (from scratch) in bundler? Why not adopt a "generic" project scaffolder for the quick start for new gems? Why? A "professional" project scaffolder lets you use templates - fits with the ruby philosophy :-), that is, there's more than one way to do it and also opens up the gem starter kits to everyone. PS: Example for a ruby scaffolder - quik -&gt; &lt;https://github.com/quikstart/quik&gt; and for two template repos &lt;https://github.com/quikstart/gem-starter-template&gt;, &lt;https://github.com/quikstart/gem-starter-template-hoe&gt;
Er, Repositories sound like DAO objects?
I'm with you -- I don't really get what the extra abstraction is doing.
Another thing you might want to timeout is system calls like \`foo\`
bad bot
There is nothing broken about `Timeout` module, this is a myth. Only documentation may explicitly mention obvious issues. That is nothing specific to Ruby. Interruption of code which acquires resources or lacks comprehensive handling of all possible exceptions is a general issue in programming languages. For example, in Python there was a similar function deprecated/removed afterwards, because similar misuse and misunderstaning like at ruby folk. 
In the author's example, `eligible_for_email` encapsulates information about the contacts DB table from services or controllers that would otherwise have a dependency on the DB. Of course, this may not always need to be abstracted. Other than that, the extra abstraction can hold context or state specific business rules or validations that would otherwise result in bloated context specific code with dependences on outer layers of the system. For example, handling rules surrounding a contact vs "premium" contact. 
Of course `eligible_for_email` can also be `Contact#eligible_for_email`. That works too :)
https://www.youtube.com/watch?v=CmkU2H6h8qg
Requires authentication only to list your gems through the API. Although you can use `tmg user YOUR_USERNAME` to display information about your gems without authentication. And it uses the `Gems` gem to retrieve items, it's basically just a small CLI for Gems.
I don't remember any specific speed improvements being made for 1.17.0 but we're always happy to receive those kinds of PRs from contributors.
It will add the latest version of the gem into your Gemfile, which may have a version conflict if you're working with large Gemfiles. &amp;#x200B; There is no option currently for the pessimistic operator but a PR is coming down the release line that will add that. Expect to see that in the next feature release which i'm targeting to have released in the next 3 months. &amp;#x200B;
There seems to be bit of trend in RoR at the moment, of pushing against the conventions built into Rails. I don't know what the root cause is - maybe people are reading DDD books and getting enthusiastic about the patterns without thinking through the implications. Whatever the case, I'm not convinced. I've been burnt working on code that used this approach - code that made simply saving a record complicated because you have to construct a Repo instance and pass it in, with the bulk of the Repo objects looking pretty much the same as each other. Apart from the memory / processing overhead, there's a cognitive overload to contend with. AR already gives you an API for interacting with the database. More complex business logic - or code requiring orchestration between different classes - can be farmed out to PORO service objects. The basic test you can apply is "will this approach lead to less code?" If the answer is 'no' you're probably best to rethink the way you are modelling your application. Sorry if this sound a bit cranky. As I say, I've been burned by people applying the repository pattern in RoR apps before. It feels like there's a move to make RoR more like Java, and we're sacrificing the beauty and simplicity of the framework for no good end. 
The code gives itself away. The fact that `find_by` and `destroy` merely echo the same message to the underlying AR model/class - and `eligible_for_email` is paraphrasing a scope - suggests that this is one abstraction too many. I've no sense of humour when it comes to this kind of code. If you're really worried about having too much code in an ActiveModel class, move it to a concern. Or maybe take another look at your design. Often there are hidden value objects embedded in models all over the place in apps, that be identified, tested independently and hooked up via `composed_of` to reduce the complexity in an app. DRY &gt; SRP 
&gt; The Ultimate Guide to Ruby Timeouts Awesome! Great page! 
You can use [timers](https://github.com/socketry/timers) and check whether the time has expired in some key parts of your code.
Interesting, for me it was the other way around, I have been bitten by the Active Record pattern. There are several scenarios in which I found it not to work well: * **Bulk inserts, updates, and deletions.** Yes, there are are activerecord-import, `#update_all`, and `#delete_all`, but in either of these cases you're skipping some potential callbacks. For example, `#delete_all` won't cascade to `dependent: :destroy` associations. * **Large selects.** Let's say I'm creating dashboards where I want to present a lot of data. Even though I will only use the data from the database, I still have to load all of the persistence, validation, and other logic when model instances are allocated, which takes additional time and memory. In that case I really wish I was instantiating lightweight data objects which have no knowledge of the database. * **N+1 queries.** I want to get rid of them. Bullet catches most of them, but not all. ROM by design disallows N+1 queries, because it doesn't support lazily loading associations. That's pretty cool.
Spam
This is exactly what is being done with the [GraalVM](https://www.graalvm.org/). While it‚Äôs not V8, it is a polyglot dynamic language runtime. [TruffleRuby](https://github.com/oracle/truffleruby) Is a ruby implementation that runs on the graalvm.
Whatever that is, it's geofenced. Just saving anyone outside North America a click.
WASM allows VMs like V8 to run arbitrary languages. That said, you might find https://opalrb.com/ interesting
&gt;TruffleRuby apart from *OptCarrot,* truffle ruby is still quite far off in racks and Sinatra. hopefully once they get rails running they could start optimisation.
&gt; then just use a Timeout. It'll be fine. So long as you're fine with any `rescue` or `ensure` blocks being possibly interrupted in the middle as well. Although now I'm vaguely remembering that more recent ruby versions added more tools to (confusingly) control this. But I can't remember the details and am not sure what to google for. That would be a good thing to include in that "Ultimate guide" maybe. 
Just thought I would share an update. I have added Latency bands to my project. Here is a post I wrote with more information [https://www.randygirard.com/appperf-latency-bands-with-color-schemes/](https://www.randygirard.com/appperf-latency-bands-with-color-schemes/)
`Thread.handle_interrupt` I've only ever had to use it to fix a bug once in my career and boy was it an obscure bug (in Sidekiq Pro).
V8 is highly tuned for JavaScript (and ASM.js which is similar, and WASM which is very simple) semantics. It would probably be very hard to implement Ruby semantics in V8. I would imagine in practice that you would have to emit such low-level code that the V8 optimisations you think will work well will actually not be able to be applied. We've seen this before - LLVM is a fantastic optimising compiler, but Rubinius never managed to get it to work well with Ruby because to emit LLVM IR they had to lower and then LLVM's optimisations had no high-level understanding of the code. Then there is the problem that in order to optimise Ruby really you need to optimise the standard library. How would you implement the standard library in such a way that V8 can optimise through it? Are you going to teach the JIT about all the standard library methods? I talked about this problem here https://www.youtube.com/watch?v=b1NTaVQPt1E
Yes we're still optimising web serving. The stack to do that to amazingly deep! But several independent people have benchmarked TruffleRuby on their own simpler code and found it does deliver the performance gains we're hoping for.
Thanks! Yeah, the trick is that the bugs it causes are race conditions that will show up _very rarely_ and hard-to-repeatably. 
Good point. I don't know if there's any good solution to that? The ruby `system` method ought to provide a timeout argument, but it doesn't. Although I guess it's safe to use standard `Timeout` wrapping _only_ a system call -- you might have to actually do something to kill the system call if you don't want it continuing on your system (ignored by ruby when/if it finally returns). 
The main reason is in my application code I may use other people code. Gems, libs, code written by other people on the project who may or may not still be around. It's not always easy to get down to the lowest level where timouts are exposed (e.g. IO). Another example is I may need to restrict a certain operation that consists of a bunch of IO operations. Let's say, I have 1k IOs and 1 minute to finish them. I don't want to limit any particular operation to 0.06s as there's a chance that some operations are faster than that giving more time to the slower ones and all operation still can finish within the overall time limit. To summarize, I either have no easy access to the IO exposed timeouts, or I want to impose restrictions on series of operations, not particular IO operations.
&gt; You can have your database handle this with the right foreign key setup (on_delete: :cascade), and/or you can also use dependent: :delete_all (TIL). See this SO question for options on this. Yeah, foreign key config is a good solution. &gt; It sounds to me like you want #pluck in these instances. It fetches the fields you want from your table and puts the values into an array, rather than instantiating your models. I would actually like one level above, I would like to retrieve the whole hash of all columns. And then I would like to wrap it with a value object, so that I can use method calls. 
Ah I see. You can do `Widget.pluck(:*)` which would get you all columns, but puts the values into an array of arrays. There's also a gem called [`pluck_to_hash`](https://github.com/girishso/pluck_to_hash) that will pluck them into an array of hashes. Still, using `pluck(:*)` to fetch all columns for 26k records (15 columns/attributes) was pretty slow on my local machine. The fewer attributes I pluck, the faster it gets. YMMV, I suppose!
I implemented both CPU and wall time timeouts in [comlim](https://github.com/Freaky/comlim), though it hasn't really gone past proof of concept stage. You might also consider running commands under [timeout(1)](https://linux.die.net/man/1/timeout).
/u/geraldbauer: As I'm sure you're already finding, all you're doing is garnering a lot of negative comments and downvotes. The way you are presenting your arguments are incendiary in nature, and likely to do more to turn people away from any potentially valid points you might have than convince anyone of anything. As I've mentioned to you before, and will do so again here: I would encourage you to consider the spirit of Ruby in your writings. Any merit to your writings will be tarnished by the manner in which you present it. Your obsession with CSV does not justify the continued vitriol.
AR objects are ORMs, Repositories, and do main models at the same time. They validate, run queries and commands, and handle business logic. They become god objects over time. If this works for you, that‚Äôs fine. But many folks find that as their systems become more than CRUD apps, or as specialized members join their team, a separation of responsibilities greatly aids maintainability and extensibility.
There's no vitriol. It's all in the spirit of ruby and the free world. There's nothing wrong with a good argument and a little polemic to make the point.
Any comments? Guess you only answer questions that you like. Oh well.
Really great project, congrats to the team to getting to 1.0
Just to 0.60. :-) Before getting to 1.0 we still need to do a bit of work. 
Could you please tell me the command you used for this? I googled how to install ruby with rbenv and followed the instructions, but still get the same error. Do I need to export anything to PATH in order for this to work?
If rbenv is functioning you just need to type 'rbenv global RUBY_VERSION' for example: rbenv global 2.4.2 You can also run 'rbenv local VERSION' in a folder and rbenv will switch to that version of ruby before running anything in that folder.
&gt; I use my own .gemspec generator. Can you tell us what's the name or where to find out more about your .gemspec generator?
&gt; GraalVM vs V8 w/ Turbofan I'm just a little curious. I know it's not feasible, but with your deep background in Ruby, what would the differential actually, and speculatively, be in a Truffle built on V8 vs GraalVM? 
It should not need `--safe` flags, all cops should be safe by default. Rubocop broke my code a few times and any organization knows not to use auto-correct because it breaks code, giving it a really bad reputation where it could be an amazing tool.
Here you are back again with a non-apology where you‚Äôre insulting the entire Ruby community. Please find a different community to ‚Äúcontribute‚Äù to.
I'm NOT insulting the entire Ruby community. That's your interpretation. I'm just pointing out the the standard CSV library is broken and that there a better alternatives. That's all. &gt; Please find a different community You, see, I wouldn't say that - that's the difference. Learn to handle a good argument and a little polemic.
&gt; That‚Äôs your interpretation Here you are ignoring any responsibility for what you write, again. What you claim to be an apology fulfills none of the requirements. I‚Äôm not going to bother pointing you at the requirements of an apology. You‚Äôve shown it would be a waste of my time because you will sidestep responsibility for your own words. You‚Äôve been harassing a respected member of the community for months and expect nothing but kindness and sweetness in return? üôÑ I chose the words I did because they could cause a few interpretations from ‚Äúmaybe that person who took the time to show me how my words were harmful the last time I posted is trying to point out that I still have work to do‚Äù to ‚Äúmaybe my aggressive writing style doesn‚Äôt fit here and I should change it‚Äù to ‚Äúfuck you, fuck off‚Äù. Please reflect on why you chose the interpretation you did.
&gt; "valid" means just what the library choose it to mean - neither more nor less. No, it means just what the RFC describes. Anything else is a bug. I understand your point (I think?) that the RFC does not accurately describe much actually encountered CSV, and sticking to the RFC does not adequately meet your and many people's practical needs for a CSV parser. But you are not helping things by mischaracterizing the purpose, intentions, or goals of those who in past or present attempted/wanted a standards-compliant parser. And misunderstanding or mischaracterizing the purpose of standards for data formats in the first place. That purpose is pretty much the opposite of "just what a given implementation implements support for." That you wind up with that is in exactly what standards-based data formats and standards-based parsing of data formats is intended to avoid. 
Ran a \`--safe --safe-auto-correct\` on some of my projects with &gt; 90% coverage and all tests still passing. There were a lot of little changes like \`zero?\` instead of \`== 0\` and extra line between guard clauses. Great work!
&gt; But you are not demonstrating an understanding of the point/goal of standards-based parsing in the first place, or the problems that it is meant to avoid. For the record the alternative csvreader library includes a [ParserStrict](https://github.com/csvreader/csvreader/blob/master/lib/csvreader/parser_strict.rb) for that use case (that is, RFC 4180 compliance) but also [ParserStd](https://github.com/csvreader/csvreader/blob/master/lib/csvreader/parser_std.rb), ParserTable, ParserTab and others. Thus, sorry, I don't understand your reasoning. In ruby code by the way that looks like: Csv.parse # use "standard" parser aka "ther right way" Csv.strict.parse # use "RFC 4180" parser - every space, every blank line, etc counts. Csv.tab.parse # did you know - there's a spec for tab from IANA? and so on. PS: Disclaimer - Shameless self-promotion - yes, that's code I've written so clearly I do not understand the difference between strict and (almost anything goes) :-).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [csvreader/csvreader/.../**parser_std.rb** (master ‚Üí b67df07)](https://github.com/csvreader/csvreader/blob/b67df077298ffc0c13c98a92a8d86a1205f5fd38/lib/csvreader/parser_std.rb) * [csvreader/csvreader/.../**parser_strict.rb** (master ‚Üí b67df07)](https://github.com/csvreader/csvreader/blob/b67df077298ffc0c13c98a92a8d86a1205f5fd38/lib/csvreader/parser_strict.rb) ---- 
By the way, do you also have anything to say about the csv parser code? What do you suggest? 
There's nothing wrong with a good argument and a little polemic. Reflect on that. Sorry I don't see where you're going. How much more constructive can I be - all the articles include many detailed examples what's wrong and more important my humble little self tries to put together the working code. What's your definition of constructive? What more do you expect? 
&gt; You‚Äôve been harassing a respected member of the community for months **Let me try a last time - if someone cracks a joke about how PHP is horrible - is that harassing Rasmus Lerdorf - or someone lets call him Super Hero Douglas Crockford writes about the bad and ugly parts of JavaScript is that harassing Brendan Eich? Please, get real.**
This smells bad and desperate on their part. Any reason why you're still with them? 
PaaS you mean I guess? Never had this issue with Heroku, which I highly recommend still after so many years.
I deleted my stack today after 3 weeks of hard work to unwind everything and porting it over to a new provider. 
I looked at Heroku but ended up going with Cloud66 because I like the bring-your-own-cloud thing. 
Yeah but it‚Äôs half a PaaS as you still need to manage things. I also know ppl who had major issues, but it was a long time ago. If it works for you, awesome! :)
Would be good to know what algorithm is being used for encryption and hashing. Also see `ENC(1)`.
they don't have an option to pay with a credit card? That alone is enough to make me skip a company in search of a competitor. If they do accept credit cards, you're foolish for missing out on lots of points. 
I literally could not make a change to my billing without adding a new valid credit card.
Ya, I figured it was their way of getting rid of the little guys, which is pretty shitty imo.
They are totally different thing, V8 wasn‚Äôt built to be a VM for other Lang, and while GraalVM was built from ground up to be one VM to rule them all. 
Dispute the charge with your credit card company. You didn't agree to the 300% increase, and you've been more than patient giving them a chance to correct the error.
This is good, there are a few more "tricks" it's good to know. What if you want to look up the version of a currently loaded gem? And you don't know if it's got a constant like `Psych::VERSION`, which is after all only a convention? if Gem.loaded_specs["psych"].version &gt;= Gem::Version.new("3.0") Let's say you want to see if a given version is 3.0.x, _including_ 3.0 pre-releases? Where you don't necessarily know (or want to fix in code) the number of the earliest pre-release, maybe it hasn't come out yet? The `release` method chops off any pre-release components. Gem::Version.new("3.0.0.rcwhatever1").release =&gt; #&lt;Gem::Version "3.0.0"&gt; # Or, this is is actually how semver.org says to do it, # although for some reason in ruby we usually don't... Gem::Version.new("3.0.0-beta").release =&gt; #&lt;Gem::Version "3.0.0"&gt; Gem::Version.new("3.0.0.rcwhatever1").release &gt;= Gem::Version.new("3.0") # =&gt; true Put em together, let's find out if we have a version of `some_gem` installed, that is at least 3.0.0, but we want pre-releases (beta, rc, whatever) count as "at least 3.0.0"? if Gem.loaded_specs["some_gem"].version.release &gt;= Gem::Version.new("3.0") 
They stand up you app your own cloud provider account so you have full access to the resources generated.
it lets you use any algorithm from openssl. *yawn*
I'm open to any suggestions/solutions and I'll keep the more straight forward approach in mind if a similar problem comes up. Thanks for the insight!
&gt; Do you have advice on thinking of more efficient solutions or does that just come with time? My only specific advice in terms of Ruby is to realize that using stdlib method may trump any complexity analysis you may do since the stdlib stuff tends to be written in well optimized C. Basically an O(n) algorithm that involves a lot of Ruby may be slower than an O(n^2) algorithm that is part of the stdlib up to much large N than you may be used to it C. Otherwise it's the same as other programming languages. &gt; Could you explain what the underscore does in your loop with idx? This is just a convention for variables that are being passed to a block/proc that you don't care about, I updated my answer to avoid this after thinking about it for a minute :)
One thing to not here: The way Ruby does variable assignment isn't quite like passing a pointer, you can't actually change the 'thing' being pointed to in Ruby the way you could in C. You can modify the thing being pointed to but not completely change the thing being pointed to. i.e. it's pass by value, but all values are references. 
Should have mentioned that I have no programming knowledge, am an electrical engineer by trade (the design machine type and not so much the electronics type). That link does not make sense to me, looking for more basic things that I can start with (and direct my colleagues to).
&gt; There are gems that rely on callbacks So? I really don't understand the point of what you're saying. You're anti-AR because gems _exist_ that use callbacks? You're obviously doing it some other way which I'm sure can work with AR just as easily so I can't fathom a sound argument here... &gt; Fortunately, Sequel allows you to override what gets instantiated I agree Sequel makes this easier....here is the thing, Sequel has callbacks too, it also has gems, and some of them use callbacks... &gt; I'm trying to. It's just that I can never really be sure that I did, because my Active Record ORM won't tell if I missed an eager load. Repository patterns which separate database communication and entities simply don't allow implicit N+1 queries, so with them you can be sure you're not making them, at least not implicitly. Problem is that you've introduced a bunch of complexity for something that _extremely_ easy to solve, finding N+1 issues is trivial. &gt; I like that the libraries I use have my back whether I'm dealing with simple or complex use cases. I don't want to feel like I have to hack my way through when I need something more advanced or better performance. So you are willing to trade slower development most of the time in favor of the rare case something needs to be more complex. That's fine, I disagree, but let's just call that out as the tradeoff being made here and not mask it in a bunch of FUD.
Ah I see. What will you use mRuby for? IMO the best way to learn programming is build something. The thing about mRuby is that it's like an alternative implementation of Ruby for embedded systems and not very people use it, so most resources you will find out there will be for the official version of Ruby.
I upvoted because I *hate* practices like this. I wish someone from EngineYard would comment though. Regarding the hosting, you might find interesting the book I am writing about deploying to VPS (https://vpsformakers.com/). Unless your app is something truly complicated managing a single VPS is not such a big deal.
Use crystal &amp;#x200B; Disclaimer: the compiler is slow though.
Without being too specific, it's being added in the near future to a product we make that is used to make custom UIs. At the basic level, you don't need any programming knowledge to use the product, it handles that for you. Advanced functions though need to use a not very good homebuilt scripting language (it's quite limited). At a conference I attended recently it was announced that a new (not yet released) version will be adding mRuby support, and they want everyone to push our customers to use it because of the enhanced functionality. As the person that our customers will be contacting when they have questions on how to use it, I therefore need to know...how to use it. Ideally that would be learning it myself, as well as having ready resources that I can give to our customers so they can go and learn it themselves. I would also like to be able to pass on anything I find out to my colleagues, so they know what to do.
I'm not anti-AR. We use Sequel in our application, which also implements the Active Record pattern, and has other "bad" things you've mentioned. I'm just saying that I sometimes didn't find the AR pattern working well, and I see the advantages of the repository pattern. I admit I haven't yet used it in a real application, but I'm interested in trying it out and seeing how it works. &gt; Problem is that you've introduced a bunch of complexity for something that extremely easy to solve, finding N+1 issues is trivial. If you're referring to [Bullet](https://github.com/flyerhzm/bulletv), the number of open issues and the size of the gem doesn't make it seem like it's an extremely easy problem to solve, at least not for ActiveRecord. But you're right, in general it should be easy. I'm now planning to create a Sequel plugin that will raise an exception when you attempt to retrieve an association which hasn't been eager loaded. That would be opt-in per dataset, because I would like to avoid having to eager load in tests. &gt; So you are willing to trade slower development most of the time in favor of the rare case something needs to be more complex. That's fine, I disagree, but let's just call that out as the tradeoff being made here and not mask it in a bunch of FUD. No, if the repository pattern does significantly slow down development, then I wouldn't like to use it. I'm just not sure that it does, once you learn how to use it.
&gt; If you're referring to Bullet, the number of open issues and the size of the gem doesn't make it seem like it's an extremely easy problem to solve, at least not for ActiveRecord. Bullet catches obvious stuff, basic metrics for endpoint performance and # queries per endpoint catch the rest.
Does not really work for dynamicaly generating script inside a bash :/ I'm basically replacing few bash functions with ruby ones, so I need to use bash's variables etc.. :/
&gt; basic metrics for endpoint performance and # queries per endpoint catch the rest. Yes, that's true that everyone should have these metrics. But this are still post-shipping techniques, I want to be unable to make N+1 queries in the first place, to have the CI fail if I made them. That way I don't have to worry about catching them later on, because I didn't introduce them in the first place. Yeah, silly problem, I know. I just don't want to have the overhead of thinking whether I've eager loaded everything, and find out that some performance issues we're having in production is related to N+1 queries.
That's a pretty good load time as far as I'm concerned. The the most popular CLI I've used that was written in Ruby is [hub](https://github.com/github/hub). So if you want to speed execution time, I would draw knowledge from there, e.g. you can see the [1.11.0 release notes](https://github.com/github/hub/releases/tag/v1.11.0). However, the maintainers of hub still weren't happy with the Ruby boot time, so they rewrote hub in Go a few years ago. Maybe that also says something.
Ah I see, so you are given the software with a running version of mRuby. I guess that just learning some basic Ruby should be enough then. Any Ruby book should do, maybe you can start with [codecademy](https://www.codecademy.com/learn/learn-ruby).
That solution lets users substitute `123-whatever` with `123-shit` and everything will still work.
Keep track of the random number and then... what? A solution basically like yours is discussed. Is the point of your comment just to brag that you came up with something quickly?
The people who write mruby seem to have absolutely no interest in getting people to use it. They don't have a mailing list, they don't write blog posts, they don't document anything. Shame really. It's an interesting project. 
Yeah, that's what I do. Come here and brag. :/ 7 minute shuffling thing just stuck out and it felt like anything would be better than that. Ah, fuck it. Here's a better solution: array = ('AA000'..'ZZ999').to_a loop do puts array.delete_at(rand(array.size)) break if array.size == 0 end
Awesome, is VoD enabled?
ohhh. I think there is a misunderstanding. "This crying session only lasted 7 minutes." means that the author became emotional once they realized there was a more simple way to achieve their objective. I don't think they meant that the program took 7 minutes to run.
Oh. Damn. I misunderstood. I also assumed that shuffling large array is slow (it really isn't).
There was a time, some years back, when EngineYard was an easy choice for a Rails PaaS. Those days are long past. EngineYard is now a rip-off. There was a time, a few years back, when AWS OpsWorks was an easy choice for migrating a Rails app off EngineYard. Those days are long past. AWS has been slowly neglecting OpsWorks to death. AFAIK our PaaS choices today are Heroku, Hatchbox, or DIY (devops-it-yourself). 
Store the unshuffled name array as a constant, then use a linear feedback shift register to generated a unique and non-repeating index into the range. require 'bundler/inline' gemfile do source 'https://rubygems.org' gem 'lfsr', require: 'lfsr/pure' end class Robot POSSIBLE_NAMES = ('AA000'..'ZZ999').to_a.freeze private_constant :POSSIBLE_NAMES def self.forget @@lfsr = LFSR.gen(POSSIBLE_NAMES.length) end forget attr_reader :name def initialize reset end def reset @name = POSSIBLE_NAMES[@@lfsr.next_i] end end 
After researching it some, apparently such things do exist, but the majority of it is in Japanese. Not coincidentally for certain, I work for a Japanese company. It won't be the first time we've had to struggle against similar circumstances. 
I don't think you're going to get much better than that, I'm afraid. Yes Perl is better, but Ruby is already pretty good.
I've put together a recommended list for ["New to Ruby?" at the (new) Ruby Quiz website](https://github.com/planetruby/quiz#new-to-ruby), also see the posting in reddit :-). PS: The New to Ruby? list: - [Learn Ruby the Hard Way](https://learnrubythehardway.org/book/) by Zed Shaw - free online book edition includes 50+ exercises (starting with Exercise 1: A Good First Program; Exercise 2: Comments And Pound Characters; and so on.) - [Learn Enough Ruby to Be Dangerous](https://www.learnenough.com/ruby-tutorial) by Michael Hartl - free online book edition includes many excercises - [Ruby Exercises @ Exercism](https://exercism.io/tracks/ruby) by Katharina Owen et al - free online excercises - all 91 excercises include (automated) tests and many solutions for browsing
Yeah thanks seen it. It doesn't answer the question, though: just through a quick googling I can have a list of like, 20 "books for new Rubyists", but how to compare them? I've seen people typically not sure about Zed Shaw's book quality (and is more "try this/try that" style than "consistent tutorial" style, as far as I can see)
A bit late to the party but I'll answer, in case it can help anyone. I've been using a DO VPS for five years now, to host half a dozen small web apps, mostly ruby apps (sinatra, rails) and static websites. I'm using [mina](https://github.com/mina-deploy/mina) to deploy all of them. Works pretty well. Mina is easy to understand (much more than capistrano, the DSL is small) and that's why I decided to use it in the first place... and I've kept using it for my personal projects over the years. Even though my workflow is simple right now, I'd like to automate things a little bit more and be less agnostic about the underlying server/vps... If I just need to add a new project to my current setup, I'm fine, but booting a whole new server would still require a lot of time.
I tried to solve this with the FSM gem I've written. It clearly shows in the diagram that the complexity quickly grows out of hands. Still, one advantage is that you can draw this and reason about this by looking at diagrams. [gem](https://github.com/phaul/mealy) / shameless plug [diagram](https://github.com/phaul/mealy#csv-parser) And the code snippet here: class CSV include Mealy initial_state(:start) { @line = []; @text = '' } read(state: :start, on: "\n") transition(from: :start, to: :comment, on: '#') transition(from: :comment, to: :start, on: "\n") read(state: :comment) transition from: [:normal, :start], to: :quote, on: '"' transition from: :quote, to: :normal, on: '"' transition(from: :start, to: :normal, on: ',') { @line &lt;&lt; '' } transition(from: :start, to: :normal, on: ' ') transition(from: :start, to: :normal) { |c| @text &lt;&lt; c } transition(from: :normal, to: :start, on: "\n") do emit @line &lt;&lt; @text; @line = []; @text = '' end read state: :normal, on: ' ' read(state: :normal, on: ',') { @line &lt;&lt; @text; @text = '' } read(state: [ :normal, :quote ]) { |c| @text &lt;&lt; c } finish { emit @line unless @line.empty? } end def parse(text) CSV.new.run(text.chars).entries end 
Dunno, do you have system ruby installed? If no, you could try that, it should make sure dependencies are satisfied..
I'm using ruby script to generate my PS1 and since the script is written inside my ~/.bashrc, I can in-place expand bash variables; it also mean I have just one file I need to copy to new machine to get most of my prompt working :)
Is this an ad?
Yes if you consider any announcement of any nature are ads. 
I had a similar issue when I was starting with Ruby. One think that really helped me to get forward was the error messages themselves. Look for missing dependencies, etc But still, it was one error after another. Getting up and running was more important for me at this stage so I decided to give up and use the one provided by the system. You might want to do so unless (or until) you have a particular need to use rbenv.
Well, I mean, on mobile I wasn't able to ascertain at a glance what this was, and this line: &gt; What is PowerRuby &gt; PowerRuby is a privately held business incorporated and based in Bath, UK. made me think this was an ad for some service-based company for getting stuff onto IBM i.
It didn't occur to me that RuboCop is not 1.0 yet. I wonder what the maintainers thoughts are on when/what pre-requisites are appropriate for 1.0. It's of course already being relied on by a lot of people "in production", although "in production" for a developer tool isn't quite the same thing. 
I would start with trying to use Ruby for something like Project Euler - to solve the problems. After that go to Learn Ruby The Hard Way: https://learnrubythehardway.org/book/ And do the koans: http://rubykoans.com/ Last step is to look at some open source projects and try to understand how they actually leverage Ruby. 
[POODR](https://www.poodr.com/) is great :)
That's... a very limited customer market. Having worked at IBM and with DB/2 before, I don't wish them on my worst enemy.
Here's a start: https://github.com/rubocop-hq/rubocop/milestone/4 The library's primary author has also given various talks about what major milestones are, in his opinion, blocking the `v1.0` release. This issue was one of them: https://github.com/rubocop-hq/rubocop/issues/5980
I am actually surprised by this as well. I wish some one could give us some insight. 
A monad is a monoid in the category of endofunctors. This is actually pretty cool though! Not sure I'd want to introduce this into production yet... but definitely worth exploring!
From the article: &gt; And yes, ruby still has a GIL ...unless you're using JRuby, which you definitely should be if you're trying to multithread stuff. Or just run things quickly. For many workloads, JRuby is crazy-fast.
Much less the good people of the Ruby community
`IBM i` has to be the oddest name for a system ever. &gt; Marketer 1: "How can we make this completely invisible to search engines?" &gt; Marketer 2: "Name it after the first-person personal pronoun?" &gt; Marketer 1: "Genius!" &gt; Marketer 2: *cashs huge bonus check* 
I always view medium as an author hostile platform as well. That's me. I'd start advising content producers not to author content for the platform.
mruby maybe? [https://github.com/mruby/mruby](https://github.com/mruby/mruby)
Yeah I have 2.4 installed, thing is, I had rvm working, but rbenv is just not wanting to cooperate for some reason. But thanks for the advice, I might just do that just to get going.
I've been learning Ruby a few years now, and I keep seeing this sentiment (particularly of note from thibaut_barrere and other ETL peeps) but am a bit intimidated to jump into jruby, as I have no Java experience. How easy is it to use, and set up? Do I need to be thinking differently? Of specific note, most of my Ruby involves SQL server (sequel -&gt; tiny_tds) or html parsing (nokogiri), which both rely on C extensions, and I don't think those work there... Right? Am I foolish to not be pursuing this? Does it make sense to jruby anything more than fast scripts where the slow startup time doesn't matter as much? I have these same sentiments when people talk about the upcoming truffle.
'The Well Grounded Rubyist' by David Black
What's wrong with it? Just curious, since I have never worked with it. I guess it's due to that the enterprise world is a bit... painful to deal with?
Will definitely look into the koans; thanks. But I personally find "the hard way" is more for beginners rather than intermediate/advanced developers.
Until you try to use it in Rails in development mode. :( https://github.com/ruby-concurrency/concurrent-ruby/issues/585
Thanks for the suggestions, guys. Most of them are definitely sources I need to look into more thoroughly. However, "the hard way", Chris Pine's tutorial, etc appear to me as though they are geared more for new programmers rather than people who have some experience in other languages.
Eloquent Ruby by Russ Olsen. You can skip POODR if you have experience with OOP programming, which I assume you do coming from Java. 
POODR doesn‚Äôt teach you Ruby at all, just object oriented design patterns. 
Just have OpenJDK installed, `rbenv install jruby-9.2.0.0` or your favoured equivalent and use it more or less as you'd use MRI. SQL database access is generally [via JDBC](https://github.com/jeremyevans/sequel/blob/master/doc/opening_databases.rdoc#jdbc-), which includes SQL Server support. Should just be a matter of tweaking the URL you pass to Sequel. Nokogiri has a JRuby version and should Just Work. Whether it's worth it is a matter of opinion. It's a good choice for long-running services, and things that benefit from concurrency, where the increased startup and memory costs can be amortized. If nothing else it's worth playing with just to see what the fuss is about. If you've written any gems consider testing them with it, add it to your CI pipeline if you have one.
Looks like great foundational work! Thanks for sharing your progress.
I'd look at the Hard Way, it goes from beginner to intermediate. If you feel like you're ready then try out the Koans!
The well grounded rubyist is the one I learned from when I did the switch from java.
If anyone else stumbles upon same problem, here's the solution: Uninstall rbenv, then sudo apt install libssl1.0-dev fixed the issue. Apparently newer versions of Ruby doesn't work with the libssl that was shipped with Ubuntu.
There is also AnyCable https://github.com/anycable/anycable
Another vote for Eloquent Ruby. I came from Java as well and didn't grok the Ruby way of doing things until Russ Olsen just laid bare the whats and whys of Ruby. I haven't seen such an explanation anywhere else. I was able to let go of my Javaisms with every page I read.
The "Hard Way" is rubbish. It'll make you fight Ruby instead of understanding it. I'll put my vote in for Eloquent Ruby, which /u/slenfbot mentioned above. I came from Java as well and didn't grok the Ruby way of doing things until Russ Olsen just laid bare the whats and whys of Ruby. I haven't seen such an explanation anywhere else. I was able to let go of my Javaisms with every page I read.
I‚Äôve been using truffleruby extensively in some scripting tasks, in some things it seems similar to mri but in others you can really tell when the JIT kicks in.
That's not really the point or is it? For an existing app you sometimes need to sprinkle websockets to avoid long polling etc. 65k connections per process sounds like more than enough for the vast majority of apps...instead of introducing another stack. 
For the record, there is a very interesting work going on to reduce the memory size of a Ruby unit of parallelism (= thread) ; you can check the [Ruby Kaigi presentation here](https://rubykaigi.org/2018/presentations/sugiyama-k.html). Out of my head, I seem to remember they mention a 40% reduction in total memory usage if they use 10k threads. Also for the sake of comparison with Go ([source](http://erlang.org/documentation/doc-10.1/doc/efficiency_guide/processes.html#creating-an-erlang-process)): &gt; a newly spawned Erlang process uses 309 words of memory in the non-SMP emulator without HiPE support (I have yet to verify if there is a slight overhead in Elixir process, compared to Erlang, but I will check that!) Pragmatically, on the example mentioned, though: I know with Elixir (I use both Ruby &amp; Elixir in production) that I'll have almost no effort nor (Rack etc) hacks to be able to handle XX k connections with Elixir. This will be almost effortless. In that situation, I would definitely use Elixir for the part of my systems which benefits from such characteristics.
/u/Freeky notes below are pretty good! Indeed I'm using Nokogiri with JRuby and it works perfectly fine. For Capistrano, I actually recommend using MRI for the deployment, because using Capistrano with JRuby is today both very slow, and also problematic (see below a paste of an actual Capistrano project I used in the past, before starting to use MRI for the `cap` command instead): # deploy.rb # A couple of compatibility notes: # - I discovered at deploy time that sshkit (used by capistrano) is not officially supporting JRuby # - Evidence is here https://github.com/capistrano/sshkit/issues/325#issuecomment-178681084 # - Things "should work" with a bit of tweaking though # - Later I found I was not alone: # https://github.com/jruby/jruby/issues/4191#issuecomment-283245523 # https://github.com/jruby/jruby-openssl/issues/105 # - I'm applying this fix: # https://github.com/jruby/jruby/issues/4191#issuecomment-283245523 Net::SSH::Transport::Algorithms::ALGORITHMS.values.each { |algs| algs.reject! { |a| a =~ /^ecd(sa|h)-sha2/ } } Net::SSH::KnownHosts::SUPPORTED_TYPE.reject! { |t| t =~ /^ecd(sa|h)-sha2/ } That said: each workload is very different. I use MRI, JRuby, Elixir (and hopefully TruffleRuby in the future too) all in production, and found it's hard to tell in advance what will perform best on a given topic I've not yet covered. When performance is important, I can only encourage you to compare the technologies &amp; create quick benchmarks. As they say, "never ASSUME or you'll make an ASS out of U and ME".
Aye, the OS was the limiting factor on the Elixir machine too, they never found the extent to which their code would scale.
65k but you use a ton of RAM. It would be cheaper to use Ably or Pusher.
Thanks! This was the kind of insight I was looking for. I will definitely give it a go.
I think maybe you don't realize how sarcastic this sounds. 
&gt; Coming from Java, I'd strongly recommend going with the Pickaxe (Pragmatic Programmer's guide to ruby) - it's targeted very firmly at java developers looking to explore ruby. Thanks a lot. I will skim the free version you linked which will help me decide if I want to order a recent version (hard copy). &gt;I think it's worth exploring those topics from scratch within ruby, because a lot of "the ruby way" is due to ruby approaching a lot of those fundamentals in a very different fashion than you might be used to in a Java world. I do agree, and that is what I meant by the "*Ruby way of doing things*", not skipping the whole topic altogether. Keeping to my example, the fundamentals of flow control or loops should be the same in most high level languages. So, for instance, I personally would benefit from a lesson on ruby's way of iterators instead of lengthy intros about loops.
Thanks everyone. I see ***Eloquent Ruby*** and the ***Well Grounded Rubyist*** are recommended more frequently. I am sure I will benefit from reading both; but given time and financial constraints, I just want to pick one at the moment. What did you benefit most out of either? (Just the pros from your perspective, without necessarily comparing each)
How much cheaper? Seriously most startups don't count +-30 bucks a month, not even 100 bucks. Could be an issue for hobbey projects I guess.
Besides the guy specifically said he hasn't even tried to optimise anything
If you maintain 65k persistent connections with Ruby, the extra cost won't be +-30 bucks (at least in my experience!). A couple of notes: - You don't have to switch your whole stack, you could use a polyglot approach (e.g. use /u/mperham Faktory or similar) - The author used the word "hijack" 15 times in the article, and you can bet this cost will show up later in the maintenance :-)
What the fuck is this half-baked shit? I cannot even define classes there. Pressing enter without typing it returns an error. https://imgur.com/a/nDd1ecF
These articles are really toxic. Please stop posting them.
Nice read. One thing that maybe some frameworks already cover but is apparently too high-tech for Google is history management. E.g. the new YouTube creator studio is an SPA and if you go to page 2 of your videos it doesn't update the history... at all (no back button, no hotlinking, nothing).
Like all these articles you've posted on CSV, this comes across super sarcastic and over the top. If you've found a limitation in the CSV library, then great fix it. It doesn't need a million posts to Reddit.
Like all these articles you've posted on CSV, this comes across super sarcastic and over the top. If you've found a limitation in the CSV library, then great fix it. It doesn't need a million posts to Reddit and ending every comment with a drinking toast.
There‚Äôs little to argue with here except to say that SPA‚Äôs are a good way to transition from bad backend choices to something better. In two shops I‚Äôve worked at SPA‚Äôs we‚Äôre used as a a way of gradually refactoring away from really bad backend choices while still being able to crank out features. The first was a Java app that relied heavily on JSF and rich faces for the view. It was a really unfortunate choice for what was a really complex UI. I left before they completely removed JSF and turned the backend into a restful api but I hear it‚Äôs much better these days to work in and less buggy. The second shop we took a .Net app and over the course of several years turned into it into an SPA then replaced the backend with Ruby on Rails. Now we‚Äôre talking about what can be moved back to the server. Another project at the same company, we took an overly burdensome ‚Äúenterprise‚Äù Spring app and again moved much of it to the front end and now they are in the process of migrating the backend to Ruby on Rails. 
Please stop posting this junk to this subreddit. All the best. Cheers. Prost.
If you‚Äôve found a bug in the CSV library then submit a PR. You‚Äôve posted a lot of articles all pointing the bug out already.
Nice article. After two years of component-based javascript for client- and server-side rendering (vue), I find myself coming back to Rails with Vue components only the browser-side and good-old remote javascript. I missed ActiveRecord and databases with ACID guarantees so much.
Not sure I entirely agree here. These are all good considerations, but I don't think they're all the nail in the SPA coffin, so to speak. Plus, what do you do if you need multiple different consumers of the same backend? REST API + SPA has been the better way to handle this in my experience. I personally feel like I'd rather have a pure SPA than Rails-style RJS and the "Pretend SPA" that Turbolinks gives you.
I‚Äôve been using RoR with Turbolinks and Stimulus for a while and it‚Äôs just such a pleasant experience. Meanwhile the same project requires me to maintain a cross platform Angular/Ionic SPA, so I see the problem from both sides. I much prefer for former. 
I don't really like Zed's either. But I haven't myself looked at most of these, since it's been so long since I learned ruby. Maybe if you stated some opinions about what _you think_ would make a good book, it would be easier for people to say "yeah I think this one qualifies". When you say "complete novice", you mean to programming in general too?
This article just reads like it was written by someone who has no idea what they're doing in this "new world," is feeling left behind, and just wants to complain about it. I've been working with ruby for &gt;10 years, PHP for years before that, always using "standard" architecture. I'd used turbolinks, etc. and it was fine. I was also skeptical of SPAs and a lot of the new frontend stuff until I decided to give it a fair shot about 3 years ago. I would *never* go back. It has nothing to do with performance or any of the other common reasons refuted in the article and everything to do with the supposed downsides. Velocity is better, development is simpler and overall more enjoyable, concerns are much more clearly separated... I could go on and on. And no, this isn't coming from a perspective of "I build everything in node now, wheeeee!" I still prefer to build my backend APIs/GraphQL in ruby because I absolutely love the language and prefer it for that type of work. (Side note: if you're working with react graphql *might* be the missing link to understand how great all this can be) Just because you haven't put in the effort or felt the need to understand and learn something doesn't mean the rest of the world is crazy.
One counterpoint is that, while SPAs are more complex to develop than stateless HTML pages, backends for SPAs tend to be *much* cleaner because they can focus entirely on handing structured messages. Another counterpoint is that the alternative to an SPA isn't going back to HTML rendering in the backend. There's nothing stopping frontend developers from having a bunch of separate HTML documents that independently boot and load different javascript libraries/init scripts. In that case, you can pretty much directly emulate backend rendering by having a HTML page for each "view" that does frontend template rendering from a JSON response. That solution lets you keep the clean backend *and* avoid a mega SPA monolith.
I've done this on a bunch of projects and it's _super_ useful!
Well, first, a bit of context. I am (for a long time already) a "Ruby Basics" mentor (paid one; besides my other, volunteer activities). The mentorship works like this: I give a student some links/book names to teach themselves, and provide them with tasks with gradually increasing complexity (from "enter two variables, output true/false" and all the way up to "create a DSL with metaprogramming, test it and document"), code reviews, advice in chat and so on. And while my experience and approaches to explaining things evolve with a time (or so I pretend to myself :)), my "links pool" is a bit outdated. It is not that critical, but sometimes important. Now, on the level of the students: they are pretty varying, from "strong Java middle trying to quickly switch to another language" to "17-year-old guy with his first computer bought a week ago". For most of them, in fact, "just Google it" or "take Pragmatic Programmer's" or "look at official docs, they have everything" is typically enough for a solid ground; but _sometimes_ there are, actually, the guy or girl who should be slowly and calmly exposed to the most basic concepts of variables, conditions, cycles and so on. I typically handle it myself, and have Chris Pine's book as a strong backup (it even has a free Russian translation, and some of my Ukrainian/Russian students even struggle with their English reading). But, as I said, it has its sad flaws from my perspective. Now, about "what you think would make a good book" -- maybe that's exactly the question I am trying to find an answer to! As I said, the obvious requirement is "calm and slow explanation from the very beginning", but the depth and order and ways of explanations may vary significantly, and that's the main topic of my research. Currently, I have a pretty good "test subject" on my hands (my wife is interested into "trying a bit of it", and she is smart yet very "humanitarian", so to speak), so I can try some approaches and receive a deep and well-reflected feedback. Of course, I am reviewing all the "obvious lists" (not tried to delegate this work to /r/ruby), just thought maybe strong opinions may help with the prioritization of the reviews.
Thanks! Will see how my idea holds up once I get around implementing tables ;-)
FYI: If invite you to join the [ruby-talk list](https://rubytalk.org/) that is the "official" channel for the ruby quizz. As you can see from all the hate here on reddit I am not welcome and get blocked, censored and bullied. All the best. Cheers. Prost.
There are so many downsides. Cross browser testing and inconsistencies. When running server side your code will always behave the same and is comparatively easy to test. SEO and linking requires extra code and hacks.. These are uses for it definitely but I think using as litter as is necessary is appropriate.. Also DHH said this in a talk. Basically if you're making api calls anyway you're better off prerendering it server side and using turbolinks to shove it into the DOM
Btw, `rb_str_new2` will copy the string you pass in. The example in this blog post will leak memory because `string_from_library` calls malloc but the caller never frees the buffer.
The crux of this article is simply, "Stop using a screwdriver on nails." SPAs are a tool in the tool box. Need obnoxiously slick UI? Need something more akin to a Application on the Web? SPAs are fine. Is your site really just a set of glorified reports and forms? MPAs are better.
I'm curious what the rdbms was. Does an update like that always cause a table-level exclusive lock (which I think is what they are describing), or is it system-dependent?
&gt; That's a problem with browsers no matter what. I agree. But let's not move large swathes of our codebase onto this problematic platform... &gt; front end testing is not hard to do. It is. At minimum requiring a lot extra effort. Doing it properly requires automated testing using multiple VMs, emulators and real devices. All this infrastructure exists it just comes at a cost. &gt; It's a lot easier to let the front end handle changing the data. This assumes you already have committed to SPA And you're free to disregard DHHs opinions but I fully agreedl with him
&gt; This book is not about patterns; however, it will prepare you to understand them and give you the knowledge to choose and use them appropriately. https://www.safaribooksonline.com/library/view/practical-object-oriented-design/9780134445588/ch01.xhtml#ch01lev2sec2 
If they are using MySQL MyISAM, then yes, it‚Äôs a table level lock. Innodb uses row level locking. But I don‚Äôt know why anyone would use MyISAM for the storage solution behind an api unless it was readonly, which it obviously isn‚Äôt. They did mention concurrent requests for the same user so maybe they were having issues with row level locks building up trying to update the same user record? The article was kinda light on the details. 
You get downvoted on this Subreddit because you wind people up. You do goofy things like end all your comments with 'All the best. Cheers. Prost.' It's cringeworthy. Maybe think about how you interact with people and whether it comes across naturally or not.
&gt; I agree. But let's not move large swathes of our codebase onto this problematic platform... What exactly is your problem with browser JS? &gt;It is. At minimum requiring a lot extra effort during development. Doing it properly requires automated testing using multiple VMs, emulators and real devices. All this infrastructure exists it just comes at a cost. I can't disagree with this any harder because you're just throwing stuff at the wall. Define "properly". A `test` directory and including Jasmine into your project is not hard. Selenium tests are equally hard whether you're using Capybara or anything else. Just because you don't like it doesn't mean it's not a thing people can and should do. SPAs aren't the solution for everything, for sure, but this article offers a lot of unsubstantiated claims that simply do not hold up in the real world of web development. Lots of times I have tried to do what a SPA does with pre-rendered pages, including your solution of using Turbolinks to stick it in the dom, and every time I have reached for a SPA in those cases it has been the right solution.
According to the docs, \`String.%\` subs in things that look more like `"foo%{bar}" % {bar: "123"}`. So, I think you need to mutate "{var}" into "%{var}" first. &amp;#x200B;
Properly referring to having automated tests running in CI pipeline or business processes around it. By properly I mean having CI pipelines running integration tests using capybara and selenium. And they should run across different browsers and platforms (IE/Chrome/Safari/iOS/Android/etcetc). Using something like [browserstack](https://www.browserstack.com/pricing) so you don't need to maintain your own infrastructure for this. &gt; Just because you don't like it doesn't mean it's not a thing people can and should do. Sure. It comes at a cost. Some are willing to just pay it or have already paid it. Sometimes it's an unnecessary cost and sometimes it's justifiable.
thx
```ruby #!/usr/bin/env ruby substitutions = { 'var1' =&gt; 'Hello', 'var2' =&gt; 'World' } string = "my_string_{var1}_{var2}" puts string.gsub(/{(.*?)}/){|key| substitutions[$1]} ```
Need to still figure out how to get OBS to behave on audio sync.
Hey, sorry to bother. I didn't want to create a new post, and this was recent enough; plus you seem like the guy to ask. I'm in a similar position to OP here, but I just wanted some information regarding whytheluckystiff.net, because although its the same name, and domain, he never refers to himself as _why. Did it get repossessed, or is it the same but just he's different? I feel terrible for being this nosey; but, curiosity is as such.
It was PostgreSQL
It got repossessed, it‚Äôs not the same guy.
The way I'd do that depends on whether this clamping business is needed repeatedly in a single class: [:id, :icon].each do |key| attr_reader key define_method("#{key}=") do |val| instance_variable_set("@#{key}", clamp_unsigned_byte(val)) end end Or if it's needed in multiple classes across a project: class Object def self.clamped_attr(*keys) keys.each do |key| attr_reader(key) define_method("#{key}=") do |val| instance_variable_set("@#{key}", clamp_unsigned_byte(val)) end end end end Which would allow you, in any class, to do: class Foo clamped_attr :id, :icon end In other words, you're messing with metaprogramming, which is a hoot.
Holy freaking crap, that's amazing. I can use the `clamped_attr` to do what I need to do for sure. Thank you so much!!
codewars.com
https://exercism.io/tracks/ruby
Most of the arguments of the article aren't related with SPAs, rather with a lot of bad practices around most SPA-based tutorials (ex: you **can** use session-based authentication with it). It also fails to address the reason why SPAs came to be in the first place, right around when smartphones hit the mainstream: * we need to target multiple devices (can't send them HTML); * we don't want to duplicate code (HTML-and-JSON-and-routing logic); 
Looks like a great solution! Happy to help. :-)
Nope. Filling up /r/ruby with absolutely useless articles with clickbaity titles (so long that one can naively spend several minutes trying to understand if there are a piece of non-trivial information, by chance), once or more per week in order to gain audience/clients fits my "spam" definition, honestly. 
Something to consider - The def keyword does not return a symbol in all rubies. In at least some versions of jruby def returns nil, so you can't use that trick there. Something to keep in mind.
Via https://twitter.com/k0kubun/status/1057654130867499014. The JIT &amp; MRI is getting better and better on raw performance, which is great!
Wow, the new JIT bumped performance from ~55fps to ~86fps. That's a huge step forward. No idea if this will translate to Rails apps (which are typically more IO-heavy than CPU-heavy) but everything helps.
You can definitively try reading this one: "From Java to Ruby: Things every manager should know" by Bruce A. Tate And online: [https://www.lynda.com/Ruby-training-tutorials/303-0.html](https://www.lynda.com/Ruby-training-tutorials/303-0.html) [https://www.udemy.com/topic/ruby/](https://www.udemy.com/topic/ruby/) &amp;#x200B;
It's free for the default tier. I'm not paying a cent for it at the moment.
Not yet I think (or at least, not in a fast fashion). More context at https://twitter.com/k0kubun/status/1057658184649691136 I think we need to gradually move up the ladder to more complex Ruby apps (I'll definitely try out on ETL workloads), then Sinatra &amp; Rails.
Cool thanks man.
Both TruffleRuby and MRI JIT are not doing well for Rails at the moment ( slower ), they are looking for a small Application that is Rails like but without the huge complexity to benchmarks / measure and optimise. 
I'm doing the ruby track right now! it's pretty fun.
Outside of Rails the convention I see is to match the class hierarchy. This is my preference as it makes it easy to find which file a class is found in.
I believe Loofah is what Rails uses under the hood for sanitization, so you'll want to patch. 
Loofah is what Rails uses for HTML sanitization (actionpack depends on rails-html-sanitizer which depends on loofah). You should update your loofah dependency. 
I believe rubocop-rspec (and its associated style guide) enforces for each `MyLib::ClassA::ClassB` (which is supposed to be defined in `lib/my_lib/class_a/class_b`) corresponding spec structure as `spec/my_lib/class_a/class_b_spec.rb`, most of the time it is sane enough rule to follow. So top-level spec folder probably looks like this: ``` spec/ my_lib/ # ‚Üê that's where actual specs go spec_helper.rb fixtures/ helpers/ # ‚Üê and/or shared/, and/or lib/, where the code to help defining specs live ```
Maybe checkout the bug reports and feature requests on the project listed here: https://awesome-ruby.com/
Hey, thank you so much. This is a great idea. 
you - idiot
You're going to have to find something to apply it to I think. Maybe an open source library that you care about? I was lucky to pick up a legacy project in Rails that nobody had the expertise to work on many years ago then used it to build a project management tool that nobody used. lol. But thats how I got hooked on it. Think of something to build that you'd personally use. 
It is hard to beat finding a project that tickles your fancy in some way and finding a way to contribute to it. Just the act of understanding a larger existing codebase that evolved over time will give you a perspective you can't get from a toy project. Solving real problems is a much better way to stay motivated too. And the more you work at it in a state of flow, the quicker you'll learn.
Think about problems that you have in your own life - things you want to keep organised, things you want to plan. Find something that you do that currently has some annoying steps. Then make yourself a little website or script that helps you do that thing easier. Some personal examples: My music collection has some duplicates, but when I run the duplicate scanner in Musicbee it tells me about a bunch of tracks that I don't consider duplicates so I can't see the signal for the nose. So I wrote some scripts to scan through and report possible duplicates, letting me mark things as valid so that they don't appear in future reports. The gig guide has hundreds of shows, but most of them I don't care about, so I made myself a little site that grabs the gig guide, filters out bands I know I don't like and lets me know about shows with only the bands that I like or have never seen before. Then make myself a spotify playlist of bands I've never seen. I want to see 80+ films at my local film festival, but the film festival website is designed for somebody trying to see only a couple of films - I scraped the website and put all the data in my own database and put an interface on top focused on how I want to browse the guide.
I'd try and get over the resistance to learning web. Building a simple website is very very straightforward in ruby and the clear separation of client/server helps to learn a lot about interface/logic decoupling.
Currently doing this with server rendered React/GraphQL. Been a lovely compromise.
We tried out Stimulus but it was so just so messy. I don't think it addresses the frontend state management problem nearly as well as React, for example. However for less interactive apps it's prob a nice upgrade from JQuery soup.
Something like Sinatra might be what you‚Äôre after. 
Affects ;-)
I think more people should learn Rails, but if you really want to learn ruby I don't think learning Rails is the best way to go. Nor Sinatra. But if you still want to go that way I strongly suggest building an API and skip all HTML etc. Perhaps a crawler might some nice to start with. If you're into cryptocurrencies then something like a Blockchain explorer, perhaps?
Hey, just curious‚Äîwhat makes you say that you are "not really ready to dive into Rails"?
wow, as someone a little more than halfway through the same (awesome) course, i've been wondering the exact same thing i feel like once i'm done i'm just gonna try to force feed myself rails before i really try to work on something...seems hard to find something that wants/needs ruby without rails 
5 PM UTC happens when this comment is 5 hours and 23 minutes old. You can find the live countdown here: https://countle.com/8FPdkKnBK --- I'm a bot, if you want to send feedback, please comment below or send a PM.
I want to really have a good understanding in a more practical sense of the Ruby language before trying to add another piece of technology onto Ruby. We all learn differently and while most maybe able to easily learn things in tandem I'm not really like that. I had trouble when I first started teaching myself C# because people that I did know at the time kept trying to tell me I should be learning ASP.net at the same time. When I stopped trying to do both I got much more confident with learning.
yeah, I never got those right. Can't edit titles on reddit oh well 
http://rubyquiz.com/
Nope, it's good: https://github.com/rubocop-hq/rubocop-rspec/blob/master/lib/rubocop/cop/rspec/file_path.rb#L18
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rubocop-hq/rubocop-rspec/.../**file_path.rb#L18** (master ‚Üí fa74c78)](https://github.com/rubocop-hq/rubocop-rspec/blob/fa74c78a3b6f26a5a5fb2298c5481425d01b5cfa/lib/rubocop/cop/rspec/file_path.rb#L18) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e8ujbi0.)
Right on, thanks!
Hi all, I am one of the Passenger developer, and CTO at Phusion. This session will not only show you how the feature is going to be coded, but I'll also be around to answer questions. So treat this as a **coding session + AMA**. &amp;#x200B; The session won't only be about coding. It's accompanied by a presentation that explains Passenger's architecture. The code will also be explained: what does this code do? how does it fit in the architecture? what are caveats to lookout for? what performance characteristics to lookout for? how do these C++ language features compare to other languages like Ruby, JavaScript, Java, etc? &amp;#x200B; Looking forward to hear from you all.
You can definitely, definitely do that with a crystal-compiled binary.
I would say to make a web scraper something fun. I first started with a Instagram Bot. This is also a great tutorial to code along with, it is simple, but shows you how to refactor. Probably one of the best free resources for ruby/rails. [https://www.theodinproject.com/courses/ruby-programming/lessons/event-manager?ref=lnav](https://www.theodinproject.com/courses/ruby-programming/lessons/event-manager?ref=lnav) 
&gt; Testing is more important than shipping. Nah. 
What you're doing there is basically combining multiple datasets together into an expression fragment containing subselects, a bit like: (((SELECT ... WHERE ...) AND (SELECT ... WHERE ...)) OR (SELECT ... WHERE ...)) What you want is to chain them to build up a single dataset representing your query: def c a.b.or(...) end Which is functionally identical to writing: Test.where(...).where(...).or(...) Not sure if there's a nice way of getting the or condition from a scope, short of literally putting the arguments in a constant or so.
&gt; Where do you recommend putting sample data for tests? There's no golden rule here -- The data might come from within each file, or within the application, or pulled in from another gem, or generated dynamically as part of the test, .... But *in general*, I would be inclined to put data in `spec/fixtures/*` -- and you can organise sub-folders in any sensible way there.
Rubocop-rspec. I'll have to look at that. Where can I find the style guide? Is there something other than the docs for each cop? 
yes and no. I don't see how it's possible to enclose conditions like this. What about `(a.b).or(c.or(d).or(e))` it doesn't seem to work. There must be a way to merge datasets into one.
Thanks for the share. JIT is looking really promising!
It is. If shipping today means that you will not be able to ship next week because you are too busy fixing production bugs.
Looks like [subset_conditions](https://www.rubydoc.info/gems/sequel/Sequel/Plugins/SubsetConditions) is what you need.
&gt; Use default arguments instead of short circuiting or conditionals &gt; Default arguments are often cleaner &gt; ... your function will only provide default values for undefined arguments I think this makes it inferior. def create_micro_brewerycreate_micro_brewery(name) brewery_name = name || 'Hipster Brew Co.' brewery_name.something end create_micro_brewery(nil) # no error def create_micro_brewery(brewery_name = 'Hipster Brew Co.') brewery_name.something end create_micro_brewery(nil) # error Now without an explicit type check or `respond_to?` they both can fail. But in my experience `nil` is the common case and is why I more or less don't use default arguments. Minimizing runtime errors is often the cleanest approach.
&gt; Avoid negative conditionals # Bad if !genres.blank? ### end I mean this is just silly. &gt; Ruby comes with its own testing tool (RSpec) built right in When did this happen? 
Ruby doesn't have interfaces, but every major gem/framework relies on the concept of interfaces. Every single use of that programming paradigm, in ruby, is duck typing in real-world code. Duck typing absolutely works. Sometimes it's a hassle to find out that the thing you've been treating like an array for the last three years actually isn't an array and doesn't entirely quack like an array, but sometimes you never become aware of that detail because it simply doesn't matter, and that is the power of duck typing.
It‚Äôs also worth noting that some duck typing can work statically: it‚Äôs typically called structural typing . Typescript and flow do this for JavaScript (a language that leans on dynamic duck typing heavily) with powerful but unsound type systems. There are [proposals](https://medium.com/byteconf/stripe-is-building-a-ruby-typechecker-d6cd7cee6abf) to bring these sorts of guarantees [and surface syntax to aid them](https://bugs.ruby-lang.org/issues/9999) to ruby. Crystal provides static duck typing and feels a lot like ruby. Go also uses a very weak form of structural typing. 
\&gt; I mean this is just silly. This is standard and straight out of the ruby style guide: [https://github.com/rubocop-hq/ruby-style-guide#unless-for-negatives](https://github.com/rubocop-hq/ruby-style-guide#unless-for-negatives) Not misunderstanding double negatives makes you stop for a moment and think. It's bad in code for the same reason it's bad in English.
Can you bring it home with an example?
``` def get_average_by_method(time_object_list, method) count = 0 sum = 0 time_object_list.each do |i| count += 1 sum += i.send(method) end return sum/count end Call it with `get_average_by_method(time_object_list, :hour)` `send` is a method (on Object) that "calls a method" in a string by an object. (Technically, Ruby doesn't "call methods" so much as "send messages", but that's probably a distinction without a difference for your purposes.) Now - all of that said - this isn't very "Rubyish" code - `Enumerable` has a method called `inject` or `reduce` (they're the same) that you should always think about when find your self accumulating into a single value outside of the loop. `inject` takes the return value of an expression and passes it as the block parameter to the next iteration of the loop - so your function can be simplified into: ``` def get_average_by_method(time_objects, method) time_objects.inject(0) { |memo, time| memo += time.send(method) } / time_objects.size end ``` Ruby implicitly returns the results of the last expression in a block, so you don't need a return. Note: I didn't test this and I can never remember the order of arguments to inject. https://stackoverflow.com/questions/1341271/how-do-i-create-an-average-from-a-ruby-array 
It clicked for me when inspecting the params that get sent to a controller. Everyone treats it like a Hash, since it quacks like a Hash, but go inspect its class, and its classes class, etc - it doesn‚Äôt inherit from Hash at all. That said I‚Äôve never built anything with duck typing in mind, and I agree with your overall point
I also think tests are a sign of failure. ;-) The Ruby community is big into tests, but ... it's because we **need** tons of tests, which other languages don't.
Thank you! That's a really interesting example I'll have to think about. Yes, `params` is hash-like. Thinking about, the consistent naming (Rails and every app always calls it `param` tells us what to expect.)
I agree about the tests (which I write religiously in ruby). Stack Overflow is a godsend no matter what experience level you're at, and I would rank it up there with google search and wikipedia as one of the wonders of the internet.
I just realized the line will have the form: time\_list.map(meth.name.to\_sym).reduce(:+) / time\_list.length adjust the others accordingly.
&gt; This is standard `if !s.blank?` is about as standard as it gets. Personally I'm fine with both, but calling `if !s` "bad", come on... &gt; ... and straight out of the ruby style guide: Doesn't matter. 
Yes, in the same way that a really nice laptop A/C adapter that's light and compact is a godsend, and I used to keep one in travel bag. But what's better is a modern laptop with an all-day battery. I haven't worried about a travel charger in years. 
All of the code in this thread is hard to read (four space indent makes a code block on reddit), so someone else may have already said all of this, but! The way to do exactly what you're asking, if I understand what you want, is: def get_average_by_method(time_object_list, method) count = 0 sum = 0 time_object_list.each do |i| count += 1 (sum += i).send(method) end return (sum / count) end get_average_by_method(list, :wday) (what gives integers a #wday method? I do not know, I'm trusting you on that!) A possibly more rubyish and flexible way do it is to use the "block" parameter that all methods get, which can be called with `yield`, so the caller can pass in whatever transformation they want (which may not just be a method) def get_average_by_method(time_object_list) count = 0 sum = 0 time_object_list.each do |i| count += 1 sum += yield(i) end return (sum / count) end get_average_by_method(list,) do |item| item.wday end But here's how I'd probably actually write it, and not even bother putting it in a method, because it's one line: avg_wday = time_object_list.collect(&amp;:wday).sum / time_object_list.length 
I think people forget that there are multiple different style guides, and either way they're guides, not rules. You can read a guide to improve things, and you can refer to a guide when you need guidance, but it isn't the rule of law that must be obeyed.
Funny additional detail about this example in particular: params used to actually be a Hash. I'm not sure if it changed in Rails 4 or 5, but I know it was after 3 because I just did a 3 to 5 upgrade and had to fix some things. This change was a good illustration of both the good and bad of duck typing. Most code didn't have to be changed because params still \*mostly\* quacks like an Hash. On the other hand, there are Hash methods that you might've called on params that won't work anymore, and you might not know about it if you don't have good test coverage or don't happen to hit that code branch in manual testing.
&gt;Practically, this seems like a needles distinction. &amp;#x200B; Code becomes much easier to read when it is semantically accurate and explicit. Again, this boils down to the same reason "nil" should be avoided in general. \`nil\` almost always has an implicit, undocumented meaning, as you state here: &amp;#x200B; &gt;In the absence of a value, you want a default. This is the purpose. &amp;#x200B; I agree the API you showed is shitty. But it's shitty because that should never happen to begin with. &amp;#x200B; If you're accepting user data, you are validating it first and an empty name is probably a validation error. But the whole example is contrived. It's a fruitless conversation when divorced from context. Also, there might be some cases where you could convince me \`nil\` as default value is preferable. I think the rule is a good general advice, though.
Have you used nokogiri? element.xpath("selector") Doesn't _really_ return an array, but you can pretty much treat it like one. But I hear your point generally, I think it's not totally unreasonable. 
Some things in Rails especially, and other things, are under-documented, under-spec'd. I agree. In recent Rails, `params` is an `ActionController::StrongParams`, and you can see it described, along with all it's methods, here: https://api.rubyonrails.org/classes/ActionController/StrongParameters.html If you've been able to use it without needing to consult that... I'm not sure if that's supposed to be a strike against or strike for it! But if you're nervous about what it is and does... why not look it up? Including even going to the source code when necessary. I'm not sure that there is more or less "cargo cult" regardless. Some programmers are copy-paste programmers, some programmers dig into it and try to understand what's going on. I agree the latter is better, and will lead to better code. I'm not sure I agree that ruby's dynamic duck typing encourages one over the other. The "duck typing" approach is what lets you pass an ActionController::StrongParams to a method (maybe written by someone else somewhere else) that didn't even know anything about Rails, and have that method still work. Except that's a good example for the counter, because ActionController::StrongParams are... kinda weird. _Usually_ work. Mostly. And be sometimes really confusing and frustrating when it doesn't. it's true! You are not alone in thinking strong static typing makes a better language, it's a popular viewpoint. But I really like ruby, and find it mostly works out. Although personally I wish ruby _did_ have a (dynamic) notion of an "interface" definition, and think it would make ruby better and make it easier to write clearer and more reliable code -- but apparently most don't agree, including Matz. :)
Google's part of my dev environment. 
I think I had this exact same problem with either \`params\` or \`ENV\`. I like to use Hash#fetch, but I believe it wasn't available. 
You might be fine with it. Both other devs might not be and either way, the negative conditionals have a potential for errors and bugs, so why not change it to positive if it's easy enough?
Fun fact: strong parameters actually did inherit from Hash originally! I believe that changed in Rails 5
And someone else beat me to it apparently
Every time you call .each on a container - do you really know the type of the class? 
[RSpec](https://rspec.info/) **is not and never has been** part of the Ruby core or Ruby Standard Library. [Minitest](https://github.com/seattlerb/minitest) or its companion, `Minitest::Spec` *were*, from Ruby 1.9.0 until Ruby 2.2.0 removed them from the Standard Library. Both RSpec and Minitest have been available as separate Gems for their entire product life. [Test::Unit](https://ruby-doc.org/stdlib-2.1.9/libdoc/test/unit/rdoc/index.html) *was* part of the Standard Library, but it was removed as of [Ruby 2.2.0](https://github.com/ruby/ruby/blob/v2_2_0/NEWS) and has since been maintained as a [standalone Gem](https://test-unit.github.io/). For several years now, it has been used on fewer new projects than Minitest or RSpec. The difference between RSpec or Minitest::Spec on the one hand and Test::Unit and Minitest on the other has been described as &gt;RSpec is a DSL for writing tests, geared towards BDD. Minitest is "just Ruby", and supports TDD natively. The confusion, as with many things Ruby, no doubt comes from people's first exposure to Ruby through Rails. Rails has always highlighted testing as part of the core development activity, first with Test::Unit, and later with Minitest. (To use RSpec for testing, you \_still\_ need to add the \`--skip-tests\` parameter to \`rails new\` and then add \`rspec\` to your project manually, unless you use one of the many third-party app generators out there.) This may seem pedantic trivia but, as you get farther along in the development lifecycle of your app, understanding what came with Ruby, with Rails (or whatever framework you use, if any), and from some other Gem is going to be *Important* when something gets updated and something else breaks, usually with a version-dependency conflict. I've seen those sorts of misunderstandings kill projects whose teams lacked the experience to understand \*why\* things broke and what their choices really are. Don't be one of them.
You know there is already a community ruby style guide? https://github.com/rubocop-hq/ruby-style-guide Also for rails https://github.com/rubocop-hq/rails-style-guide
It takes the same amount of work fixing it before or after we ship. But shipping something will atleast let us fail fast so we know if it's worth spending more time on certain features.
Which is better: perfect tests but never shipping, or shipping super frequently with zero tests? The answer will tell you which is most important. 
It should be `if s.present?`. They are identical in complexity except for the negation, so the one without negation is strictly better. When there is no opposite method, then it becomes more tricky.
&gt; standard and straight out of the ruby style guide Since when some guide by a some gem author is more standard than a keyword `unless` by Matz?
We do watermelon to explain to business team. Green outside, red inside. "Yo, we tested and ship this feature", actually we just shipped this feature and wait rollbar to notify us if user gets an error on production environment. Why? business team has tight deadline
TIL, thanks!
&gt; It takes the same amount of work fixing it before or after we ship. Fixing mistakes after shipping is way harder than fixing them in development or QA. Specially if you messed up users' data because of your bug.
If writing good tests means that you will never ship, maybe you should work a bit on your testing skills. IMHO.
Shrine uses duck typing when uploading files to a storage. The input IO-like object only needs to respond to: `#read(length = nil, outbuf = nil)`, `#eof?`, `#rewind`, and `#close`. That enables it to accept *many* type of objects: * `File` * `Tempfile` * `StringIO` * `IO` (e.g. an `IO.pipe`) * `ActionDispatch::Http::UploadedFile` * any Rack input implementation (`Unicorn::TeeInput`, `Passenger::TeeInput`, `Falcon::Adapters::Input`) * [`Shrine::Plugins::RackFile::UploadedFile`](https://shrinerb.com/rdoc/classes/Shrine/Plugins/RackFile.html) * [`Shrine::Plugins::DataUri::DataFile`](https://shrinerb.com/rdoc/classes/Shrine/Plugins/DataUri.html) * [`Zip::InputStream`](https://github.com/rubyzip/rubyzip#reading-a-zip-file) * [`SymmetricEncryption::Reader`](https://rocketjob.github.io/symmetric-encryption/#large-file-encryption) * [`Down::ChunkedIO`](https://github.com/janko-m/down#downchunkedio) * ... They don't need to include something like a Java interface for Shrine to support them, they just have to implement the required methods, with behaviour defined by the `IO` class.
False dichotomy
In the rubocop's main organization (I don't know why rubocop-rspec doesn't links to it explicitly): https://github.com/rubocop-hq/rspec-style-guide
In the rubocop's main organization (I don't know why rubocop-rspec doesn't links to it explicitly): https://github.com/rubocop-hq/rspec-style-guide
Blashphemy! Aren't you the man himself?! Haha I've been listening to your podcast, honestly like your style of questioning! In any case, I've been trying to get your free micro course too, but every time I try to key in my detail, it just gets stuck at 50%. Any tips?
I'm not a huge fan of duck typing, precisely for the reasons you state. I usually find myself introducing `is_a?`checks to make sure an object is what I expect it to be. The main problem I run into with duck typing is that I'm never sure a method does what I think it does. Sure, this instance responds to `read`, but do I know for sure what that method does? And how many parameters it has? Class A might implement it in a different way than class B perhaps. Basically I feel that I'm always kinda 'guessing', which requires you to either implement manual type checking at runtime, or write extensive tests to make sure it works.
I am indeed aware. I'd suggest you make it clear on your comment then. To me it was not obvious
&gt;I usually find myself introducing `is_a?` checks to make sure an object is what I expect it to be. Then you are using the wrong language - or the right language in a wrong way. :-) &gt; or write extensive tests to make sure it works. You have to do that anyway - even with statically typed languages, right?
Another way to do this is with a block: def get_average_by_field(time_object_list, &amp;method) count = sum = 0 time_object_list.each do |o| sum += method[o] count += 1 end sum / count end And then avg_hour = get_average_by_field(objects) {|x| x.hour} avg_hour = get_average_by_field(objects, &amp;:hour)
I think `IO` streams are the best example of the strengths of duck typing. I wrote a class to read/interpret bytes from a file, but really it reads from any stream-like object. `StringIO`, `File`, anything that responds to `#read` or `#write` is fair game.
The comments seem to reflect that people either come from a different background and fail to perceive duck typing, or are frustrated because they'd expect and want such things to be caught at compile time, not runtime. The second one can only be solved by the ruby core team, and it's not easy to solve due to ruby's always-dynamic nature. The first one though, is a developer issue only. As all powerful features, they take some time to be fully understood, and time is rarely a variable in our daily jobs. Hence, the way we perceive it is shaped by our past experience. As most languages taught us to think in terms of types, interfaces, inheritance (and Ruby still kept some of these concepts), this is how we're gonna approach it. On the other hand, the description of the issues with rails params leads me to diagnose it as "primitive obsession". Janko just gave a great example of how shrine leverages duck typing , but in the end is always up to us to make it possible. Take rack, for example. Its spec remains unchanged for many years, however, and I've seen this too many times in middlewares, people to this day still expects the second value of the response to be an Hash, when the spec only requires it to "respond to #each".
I think the point being made is that the amount of tests needed in statically typed languages can be significantly smaller if you design your type hierarchy cleanly. I've seen pretty massive (&gt;50 kLOC) C++ game engines in the wild with no tests whatsoever that were easy to understand, refactor, and maintain because the designers focused on clearly designed, usually immutable, types. Conversely, I've seen quite small ruby libraries that were a nightmare to maintain because, without tests, it's quite difficult to ensure a change to the codebase doesn't break something because a wierd duck-typing trick is done elsewhere in the code.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day!
I didn't ask for this
&gt; Then you are using the wrong language - or the right language in a wrong way. True, I would rather use a statically typed language. But saying that I'm using "the wrong language" doesn't mean there are no problems with duck typing at all. I feel duck typing has some problems, and manually type checking is a way to mitigate those problems slightly. &gt; You have to do that anyway - even with statically typed languages, right? Of course, just saying that in my experience I need more tests in Ruby than in a statically typed language, because duck typing introduces more uncertainties.
&gt;I also think tests are a sign of failure. ;-) The Ruby community is big into tests, but ... it's because we need tons of tests, which other languages don't. Some languages, maybe. But many users of statically typed languages are also strongly into TDD. And tests are actually a prime example of how duck-typing has clear advantages over static types. In a test for a statically typed language, I can't just hand it a thing that quacks like a particular type or interface - it must *be* that type or interface. Which requires me to design my classes and interfaces a certain way, *and* write lots of mock/fake code just to test. In a duck-typed language, I can hand it something and, as long as it quacks correctly, the tested code doesn't care.
If I need to work on my testing skills, you definitely need to work on your reading comprehension. IMHO.
&gt; Some things in Rails especially, and other things, &gt; are under-documented, under-spec'd. I agree. Ruby has a similar problem. Try to find a document that explains in some detail how to use the jit for your projects. I filed a request for improvement, so hopefully this will become better - but let's see how long this may take before it really becomes good. Documentation is where ruby could be improved, in general, immensely.
`container.to_enum`? Although, properly implemented `#each` will already return an enumerable when not passed a block. 
I have a hard time upvoting or downvoting your comment here because you mention both an accurate opinion and something that may be controversial. I agree with your comment about tests to some extent. IF we have to use tests to compensate for anything then why use a flexible language like ruby in the first place? So here I agree with you. BUT, having said that, tests can STILL be useful. One specific area is to ensure that core functionality works. I sometimes have to rewrite old code and for this, I need some form of tests to ensure that I don't forget certain functionality. I disagree about your claim that we need tons of tests, though. I never needed "tons of tests" for my code to work perfectly well. As for the dev enivironment, I agree. I don't have a perfect setup here though since I depend on other things such as KDE konsole, the editor etc... Some editors such as geany provide an integrated terminal (through vte); but it's still not a perfect replacement. I'd love something like squeak, but on the whole OS level. I once wanted to have a Ruby-centric OS as well but even despite ruby being great, it is so much work.
We all have our anecdotal experience. Ive seen really shitty java code, we all have. Is java a shitty language?
&gt; Crystal provides static duck typing and feels a lot like ruby I am not sure about that claim. It is often mentioned but crystal has changed quite a lot in the last ~2 or ~3 years.
You need to have larger programs written in crystal and used by people.
The point is - why do you have to know, if you don't need to know?
&gt; The main problem I run into with duck typing is that I'm never sure a &gt; method does what I think it does. Well - both Array and String respond to .size method call. Are you sure you can not figure out what this does? There may be some stranger examples but this is mostly a problem with whoever originally implemented that. Or it is code that comes not from core/stdlib.
&gt; Conversely, I've seen quite small ruby libraries that &gt; were a nightmare to maintain because, without tests, I have seen ruby code, that had tests, and were awful to deal with. So I am not sure your observation really applies. Tests on their own do not make the associated ruby code better. A lot of this has to do with experience of the ruby hacker at hand. Someone who is bad at ruby will always fail hard, even with perfect tests. Tests can not be a surrogate for incompetent code.
Hey bot, please stop pestering us humans. Plus whoever wrote that bot - stop spamming us here. This is a discussion between humans, not between spammers.
&gt; because duck typing introduces more uncertainties. Not really. I also don't know why you need more tests? Is your ruby code that bad to begin with?
&gt; But I really like ruby, and find it mostly works out. Agreed, ruby allows for the most beautiful code of all languages I know and whenever I need a script that just does something fast and dirty, ruby will be my go to language... That sounds like a bad thing, but what I mean is you can make dirty stuff very fast in a ‚Äúfriendly to read for the next developer to come‚Äù way in ruby. I can‚Äôt say I know any other language that provides a better way to do that than ruby. &gt; I wish ruby did have a (dynamic) notion of an "interface" definition, and think it would make ruby better and make it easier to write clearer and more reliable code -- but apparently most don't agree, including Matz I agree with this so much... Especially in a duck types language some way to enforce interfaces to be implemented make so much sense. It should be: ‚Äúif it quacks like a duck, we should make sure it also has wings, feathers, a beak and paddle feet before treating it like a duck. Remember the incident with the duck whistle hunter? That guy did not float at all....‚Äù 
I also heared of a good practice to keep the order of args the same as mentioned in the function's name, therefore: Bad: def add_month_to_date(date, month) Good: def add_month_to_date(month, date)
Fair point. I'm just stating that my *anecdotal* experience is that crappy statically-typed code (e.g. Java) is usually easier to salvage than crappy ruby code because there's at least a bare-minimum amount of type information to play with. Tests tend to be more of a necessity with ruby because there's no type system to lean on. The ruby guides I followed back when I was doing RoR development seemed to encourage doing `is_a?` tests on things quite a bit.
Huh? What ruby guides encourage doing is\_a? tests on things? I don't really see that a lot at all.
It's worked wonderfully for me. A few points: * I seldom check if something "is a" class, because I'd rather do without that cyclomatic complexity. A good rule of thumb is that if it isn't obvious what's supposed to be passed in to a method, something is wrong. * Most of my classes are under 100 lines of code, and their interfaces are small and focused. They can be readily understood. * I always use namespacing. Sometimes this means a lot of nested namespaces, but I'll take that over not having an organizational taxonomy of classes and modules. * I would get no benefit from an IDE, because my projects never get so expansive as to benefit from one. If I can't find where a constant is defined within about 5 seconds, something is wrong. I fix it. I don't work in legacy apps these days, though. I do want to harp on this point: &gt; But for me in the real world of legacy apps, I constantly want to know, "what is this object"? What's its type? Because I need to know how to use it; what its methods do, and what they return. A type isn't evil - it's simply the sum of the messages that an object responds to. In the world of legacy objects, I seldom ask those questions about the essence of a class. The reason for that is that most of the classes will more likely be dumb receptacles for code than intrinsically useful. The better your code is, the better duck typing works.
Ruby *does* come with a testing library, but it's Minitest, not RSpec. And it's the better of the two, IMO.
Usually when we talk about "interfaces" we mean a mechanism for doing ad-hoc polymorphism, where we can specify an arbitrary interface and then say what types will respond to that interface (and sometimes how). In Ruby, interfaces are implicit. We accept values of all types, but then our code only works with values of those types that implement the methods we are using. Ruby modules can help making implementing an interface easier (like Enumerable), but they aren't really the interface themselves. I can make a class in Ruby that implements the implicit "enumerable" interface, without using the Enumerable module.
&gt;Since when guide by a some gem author is more standard than a keyword &gt; &gt;unless &gt; &gt; by Matz? You misunderstood. The ruby style guide is arguming *for* using unless. &amp;#x200B; Also, it's not "guide by some gem author" -- it's a massive community effort and is the de facto standard for best style practices in ruby.
It seems like Rails aren't interested in not depending on a vulnerable version: https://github.com/rails/rails-html-sanitizer/pull/73
Rails does not need to insist on a non-vulnerable version, as long as it allows the non-vulnerable version. Apps just need to upgrade their dependencies. It is a reasonable position of Rails' to not be doing releases all the time with updated dependency requirements whenever a dependency (possibly second or third order) releases a patch for security vulnerability (or other bugs). After all, sometimes a security patch release might introduce other bugs. It is the apps responsibility to control it's dependencies, not Rails'. So long as Rails dependency requirements do not interfere with updating to the patched version. 
I don't agree, especially not since they depend on 2.2.2 directly, and that 2.2.3 only includes the security fix: https://github.com/flavorjones/loofah/compare/v2.2.2...v2.2.3
Ruby's OO model was strongly influenced by/based on Smalltalk. Smalltalk also lacks any explicit interface definitions. Some people have thought it should, here's one interesting paper: http://www.jot.fm/issues/issue_2002_05/article1/ I don't think this is/was a popular opinion among Smalltalkers, although i can't find anyone writing about it much. But if you google you can find some discussion/debate. 
I think it would be nice if there were a clearer way to keep track of a formally specified description of what an "IO-like object" is to shrine, or to anything else (which may have it's own not quite the same expectations for an "IO-like object"). I have run into this problem before, specifically with IO-like objects. I forget the details, but I think it was working with one of Nokogiri's streaming parser interfaces, which took/returned an IO-like object, but it's expectations didn't quite match those of some other gem's objects I needed to pass or get the IO-like object. Sorry, my memory is vague. But IO objects is probably also the best example of how it would be really nice if there were a clear specification so software could more reliably interoperate. I'm also not sure what that would look like in ruby. It's notable that Smalltalk, on which ruby's object and dispatch model is closely based, also lacked formal interface specifications. There's a [paper](http://www.jot.fm/issues/issue_2002_05/article1/) about adding them -- and they could probably be added to ruby too, dynamically, in pure ruby code -- but it's really an ecosystem issue, since interoperability is the problem trying to be solved, a gem providing a language feature doesn't help unless it catches on to be considered 'standard'. 
You misunderstand what Cargo Cult programming is. The key with Cargo Cult behavior is that it's *ritualized*. It's when you do things in your code that you don't understand but you feel like you have to do anyways. You know why you use params, it's to get your parameter values. Generally I would say Rails is quite good about not having Cargo Cult programming. Because Ruby is such a powerful language, a lot of boilerplate isn't needed. I very rarely have the sensation of, "I guess I need to put this line of code here, but I don't know why". That doesn't mean I fully understand the implementation, but that isn't necessary. Beyond that, the whole Cargo Cult thing is overblown. You should always strive to understand what you're doing, but you never will 100%, especially when you're first learning. The problem comes when programmers don't ever try to understand what they're doing and just copy paste code in hopes that things will start working. It's ok for learning, but it's too sloppy an inefficient for real work.
The thing is, I've run into exactly the same problem in Java. Just because something has the right type, doesn't mean that it's implementation will interoperate with things that use that type. You still might need to read the documentation that says things like, "The read method is unbuffered and should be wrapped in an implementation of ImageInputBuffer."
All the time when interacting with third-party code that didn't anticipate me using it the way I am.
Fair enough, good example. Method signature interface isn't always enough to show/prove true "type" either. But it's probably better than nothing! But yeah, it's not clear to me how one would fit it into the ruby ecosystem and language semantics, and additional language features/complexity do have some downsides, and would not provide a panacea anyway, and I do like ruby generally. I still wish ruby had some formal notion of interface. :) If it was method-signature-only, it at least still gives you a place to _document_ what the intended semantics are. Right now, where do you even go to look to see what an "IO-like object" needs to do, or to see if one gem's notion of an "IO-like object" matches another, or if writing a gem and wanting to take or return an "IO-like object" to see what that means that will be interoperable with other gems?
This is a pretty broad question, so I‚Äôm not sure how to help you. In general, if you try to do something and run into problems it‚Äôs easiest to get help if you 1) share the exact code you had a problem with along with 2) the exact text of the error message you received. If you still have the code where you tried to add User and got an error, share that code and error and I‚Äôll try to point you in the right direction. 
In this case I think they should cut a release and make it depend on 2.2.3 so that everyone that aren't aware of loofah being vulnerable will get an update when they update rails-html-sanitizer. I don't see the downside in this case by depending on 2.2.3 instead of 2.2.2 from the point of rails-html-sanitizer. 
You will need to create your model and then add another migration to create the association in your database. ``` rails generate model user name:string # this will also create a migration to create the user table rails generate migration add_user_to_review user:references ``` If you look at your latest migration it should look something like this: ``` def change add_reference :reviews, :users end ``` Now after you run `rails db:migrate` your Database is ready, but you still need to tell your models about the association. ``` class Review &lt; ApplicationModel belongs_to :user end class User &lt; ApplicationModel has_many :reviews, dependent: :destroy end ``` You can find more about how associations work here: https://guides.rubyonrails.org/association_basics.html
Thanks for the info! If you have time, could you clone my project and check it out? You'll see how I currently have it set up (only Review model) and anyone can add a review, and the reviews index route just lists all reviews. I completely understand if you can't haha, but worth a shot asking :) What I want to accomplish is to have new review be tied to a certain user (eventually whichever user is logged in, but this can be simulated with dummy data i assume), then update the reviews index route to show which user created that review, or possibly have another route to go to "your reviews". I'm sorry if this is very vague. I understand MVC, but Rails just doesn't click with me as much as some other things I have done. 
Shopify for the user experience, with an API integration to push/pull products and orders would be my recommendation. E-commerce is very, very complex. It starts simple, then you realize you need coupons, and discounts, and tracking repeat customers, and .... a million small things. I've done a Shopify integration with Ruby driving, and it was pretty great. We got our products loading dynamically, could update inventory and pricing, etc, but at the end of the day, the user got a nice UI to shop with, and we could take advantage of Shopify's deep tools and plugin ecosystem. Best of both worlds.
&gt; WHY would someone maintaining an app update their rails-html-sanitizer dependency, if they weren't aware of the vulnerability? &gt; &gt; Likely because most do not depend on `rails-html-sanitizer` they depend on `actionpack` or `actionview` which can depend on a vulnerable version of `rails-html-sanitizer`because it can depend on a vulnerable version of `loofah`, they will likely only upgrade to a non-vulnerable version of `loofah` when they upgrade Rails. I might care too much about this, but you own your dependencies, and if you depend on vulnerable software your software is vulnerable. I had more faith in the Rails maintainers.
Cool, so if I understand correctly. You suggest building an API with all the business logic and stuff and then a Shopify site to be the frontend. Or did I miss something? Do you have any examples of which tools in the Shopify ecosystem I would need if I have all the business logic in the API? Can I write my own API client in ruby and use with Shopify?
I guess we want pretty much the same as what you had. Except we're starting from scratch. We will build up or inventory by hand picking items from a few suppliers and then show them in an e-commerce. Plus invoicing and probably some blogging and the usual stuff :) We probably want the inventory to be customised for the logged in user.
It seems like you're saying "I want the argument to tell me what I can do it". Duck-typing flips that. You tell the argument what interface you expect it to implement. These are still types, and you still need to be organized about your type structures - how you enforce the interface is implemented is up to you. If you have any doubts about an object you could always wrap it in a facade &amp;#x200B; Your Ruby programs should have types but how you enforce and organize them is up to you &amp;#x200B; In my experience, pretty much every case where this has become an issue has been because of objects that are too big with really wide, confusing interfaces. The correct approach (in my opinion) is to limit scope so that things are easy to reason about - then you don't have this problem any more and interface checking becomes more or less a non-issue &amp;#x200B; As far as real successes in duck-types, I think it comes down to things that require very small interfaces like \`Enumerable\` which on requires you to implement \`each\`
In that case, you're probably best off with just straight-up Shopify. If you don't have a back end, and aren't really clear on what it would do, why do you need one? Shopify, off the rack, does everything you want done, possibly with a plugin or two. Not the most exciting answer, but there you go. It's nuts, in the current day, to build an ecommerce platform from scratch unless you absolutely need to. The state of the art is too good to catch up with. Now, once you have your basic biz ops working with Shopify, maybe you want to automate something, or pull the products out into other sales channels, or whatever. That would be a good time to build some custom code and use the Shopify API to do your magic.
Ok. I will see how far I get with Shopify. (Sounds like very far üòÄ) Thanks for sharing info!! Cheers!
I still don't understand under what scenario you think rails-html-sanitizer doing a new release with updated requirements would result in more people updating loofah. EITHER WAY the maintainer of an app will need to update their dependencies to get a new loofah. EITHER WAY the maintainer of the app _will_ get a new loofah, if they run `bundle update`, `bundle update loofah`, or update any of the things that depend on loofah like `bundle update rails`, `bundle update rails-html-sanitizer` or `bundle update actionpack`. If they run any of these things they get the new loofah, _without rails-html-sanitizer needing to do a new release_. I don't think you care too much, I just don't understand your analysis of why a new release of rails-html-sanitizer is important. 
Assume that DIY is going to be 2 to 10x more time-consuming than you expect. This applies to pretty much any software development. 
Thanks for the pep talk üòâ Yeah, I know it's always a ton of more work than you expect. Nowadays I usually try to assume the worst before I multiply any time estimate by œÄ Fortunately we will only deal with organisations and have no deliveries. So that simplifies a few things. But I know, invoicing is a mess. Dealing with costumer is a mess. Building software that someone else is going to use is a mess. There will be headaches..
I think it‚Äôs pretty super()
Rails isn‚Äôt a good environment for determining if duck typing is good or bad. Rails has a TypeMismatch exception FFS
If you‚Äôre planning to make a serious eCommerce store, definitely use shopify. I‚Äôm a senior rails engineer. Have worked on huge eCommerce production apps with hundreds of thousands of checkouts a week. You don‚Äôt want to fuck with that stuff yourself. I promise. Especially starting out the most important part is marketing and getting customers. 
Shopify. I‚Äôm a full-stack developer, and I just won‚Äôt bother. Shopify has already dealt with most of the complexity and edge cases. 
I don't think that it works this way around regarding the tests. I.e. I think that *because* Ruby is so easy to write, people also have the time and nerves to actually write the tests that they maybe wouldn't have in another language. And duck typing lets you create smaller test files by allowing you to use whatever works for you for mock objects: Simple `Object.new` objects or full-blown mock objects.
Ok. So everyone agrees on Shopify. That makes it an easy decision üòÅ
I wanted to add something else. I'm a casual user of a piece of software called RPG Maker VX Ace -- it's the software that got me into using Ruby, in fact. It's a bit old now, it was released in early 2012, so it uses Ruby 1.9.3. The way the software works, is it has a "game player" built out of native objects (like bitmaps, sprites, display lists, etc) but exposes these objects to the Ruby code that runs the actual game logic. Because of Ruby's duck typing, if I wanted to make another player for the games it creates to add support for Ruby 2.5, gamepads, hardware acceleration and other things, I can. I can redefine what a Bitmap is, or what the Input module detects. It wouldn't be easy - I'd still need to scour the documentation to see what methods I'd need my new substitutes to respond to, but it's still possible. I know it's an edge case and not at all typical of what a professional dev would see in their day-to-day, but I thought it was a unique example of when duck typing can give one an unexpected solution to an issue.
I‚Äôd prefer having from_hash or from_h as an API.
Second that. This is the naming scheme I've used so far.
Personally, I would be surprised if a method called `from_hash` set some kind of internal state. For me, `.from_x` calls the `initialize` (possibly of the appropriate subclass) while turning it's argument into a format that `initialize` understand. I would call a method that initializes an object and sets internal state `.deserialize`.
Agreed; OP has asked for two different things in one request * "load an object's state from a hash" * "takes another object and converts that object to your object" The former is a mutation, the latter is a factory. Agree about `#from_hash` for the factory method. But for internal state mutation, I'd hope to find something domain-specific and intentional rather than generic and mechanical. 
I know this is getting out-of-scope for the initial question, but -- would you make a deserialization method for different inputs? For instance, `#deserialize_hash` or likewise?
To be honest, I have never needed more than one serialization format, so that question never came up for me. If you have complicated state you're trying to set, it is a good sign that you should split your class, move (parts of) the internal state into a new class and inject the new class in your old class. Difficult to say without knowing the specifics.
It's not really a complicated state in this case, I'm just asking hypothetical questions. The class represents one entry in a binary file consisting of X entries, Y bytes long. I'm using a gem to load the binary file, and the gem puts the loaded bytes into a hash. So all the method really does is assign instance variables based on the keys of the given hash.
given there is `#to_h` I woul go with `#from_h`
What other data structure would you use instead? Why not just Object.set_attributes(yourhash) 
I can't find that in the docs. Is that a Rails thing?
Try some Crystal as alternative to Ruby and even more expressiveness, sometime it's faster than Go.
I believe you could try Crystal if you curious to try another Ruby.
To update the logic for how a review is created, you'll need to update your ReviewsController create method. It's using strong params, so you'll also need to update the `review_params` method. Since this is for a school assignment, I won't give you the exact code, but that should point you in the right direction
Why not use a struct for that? Or why not just manipulate the hash as-is? What is the purpose of transforming your data structure?
I think I'd go for a class method initializing the object from a state. `MyThing.from_hash(attributes)` If you really want to import a state into the instance, I'd say that's starting to smell like the state should be it's own class, which could be intialized with whatever you wanna load the state from. state = StateObject.from_x(attributes) myInstance.load_state(state) 
I'm reading `#from_hash` as an instance method, which is a little confusing to me. That says to me that I'm getting a whole new object in exchange for the provided input. I've prefer `#load_from_hash` as an instance method name. It's hard to say without concrete examples. In general I like to add a class method called `from` to handle type conversion and initialization (I borrowed this pattern from rust). This method can check which methods the input object responds to or what type the input is, and then perform the conversion and initialize the object.
Thanks! Would I still be on the review/new for when I associate the user to the review? Or would I need some route such as user/review/new? 
I'm guess /u/seainhd means, say you're dealing with car data that you could make Car objects, you can do some thing like `car_1 = Car.new(car_data)` where `car_data = {make: 'honda', year: 1998}` you'd have car_1.make =&gt; 'honda' and car_1.year =&gt; 1998. If you initialize with `def initialize(car_data={})` then anyone that sees your code knows it's creating objects with data from hashes. class Car def initialize(car_data={}) @make = car_data[:make] @year = car_data[:year] end end Or maybe I completely misunderstood your question and the initial reply.
I don't think there's a completely standard convention. _Some_ things in stdlib provide a kind of weird Kernel#MyThing() class method. def Kernel.MyThing(arg) translate_to_my_thing(arg) end # then anyone can just call: MyThing(foo) #=&gt; a MyThing instance # Note that is calling Kernel.MyThing, a completely different method than # MyThing.new But I wouldn't do that! Among other things polluting Kernel seems evil. And it tries to convert from any kind of input at all to MyThing, which is just, yeah. So it might be a convention in the stdlib, but I wouldn't try to emulate it. I think the next most common is indeed `MyThing.from_hash(hash)`. Note that's a class method, not an instance method. (When we abbreviate something as `#from_hash` it usually means we're talking about an instance method, but believe you meant a class method all along? At any rate, I think a class method should work best here). 
Yep. I think it just makes something like Shoppify (and however much Shoppify costs) seem a _lot_ more attractive, was the implication. :) I would assume that if time is of the essence, the more you can use Shoppify for (up to "everything"), the more time you'll save vs DIY, to arrive at having a reliable product with features needed, even for an MVP. 
I would want some clarification on what you mean by "objects state", whether this is from scratch or also supports an update. If its the former, I'd agree with what some others are saying, you wouldn't need or want a from method and rather just have an initialize method that takes that object as its argument, e.g Object.new(hash). A hash is probably the most complicated object to handle that way since you so commonly have an argument hash for initialize methods. Alternatively using the builder might be another good way to handle this without complicating initialize on your object. (Builder::ObjectFromHash or ObjectFromHashBuilder) This might be the option I'd go for particularly if your looking for clarity in naming.
I'm not sure that writing out 'end' is better than curly brackets. Remember that in JavaScript functions are first class objects.
I hear what you're saying. It just seems like I see way too many occurrences of }); than I personally am comfortable with
Ruby is a language that prioritizes programmer satisfaction. It's designed to make things pleasurable for you as you're completing tasks. It's got a great standard library, clear syntax, and a large community providing libraries for many things that you may want to do.
Personally I find it's minimal syntax makes it easy to build something quickly. It's openess also makes it easy to monkey patch core classes, which is good for polymorphism.
My favorite two features are that you can implement complex logic with a very small amount of code and that it makes it easy to write elegant code. It's block syntax is a particular favorite. I also like it's interactive console which I use all the time.
It's so nice to write. I came from PHP and honeslty wasn't really up to learn it, but my company started using more and more Ruby code and I had no choice. Now, I'd never go back and using Java-esque PHP frameworks makes me feel gross. &amp;#x200B; I would suggest that ruby is more of a prototyping language, or a language that is useful to getting stuff out the door - as an agency, thats exactly what we need to do and it saves a bunch of time, especially when using Rails. Its also a mature ecosystem, so if you run into problems, then its very likely that they have already been solved on StackOverflow, so you can fix the issue quickly and move on. 
looking back over Ruby's lifetime, I'd say it's strength is in quick, effective prototypes. you can build a business quick with Ruby, and once performance becomes an issue you migrate to something closer to metal. a ton of now huge websites started as RoR projects. 
&gt; `})` FTFY: JavaScript does not require trailing semicolons if you don't start the next line with `[(+-/*&amp;|.`.
The number of times and I missed a semicolon is too high to count... 
look at [https://ruby-doc.org/core-2.2.0/ObjectSpace.html](https://ruby-doc.org/core-2.2.0/ObjectSpace.html) 
I mean with JS they aren't strictly necessary. Lots of debate in various style guides over whether or not its best style there (although more often than not people seem to use them). I like not having to use semicolons but I don't really think these minor differences make ruby that much better. It's not that I don't appreciate the dev experience with Ruby, it's just that I've found I can quickly realized adjust to most of these things after a week or two working in other languages. Others are welcome to disagree. 
The metal is the physical computer processor. When you run your program through interpreters or virtual machines, that adds some overhead. When performance becomes a critical issue, you may choose to reimplement some aspects of your project using a technology that compiles down to native code so you don't have that overhead. 
Not sure how that helps, which method exactly do I want?
something more specific
I personally find def foo(var) #do stuff end To be more aesthetically pleasing then function foo(var) { /* do stuff */ } But that's just me. I also don't write much JS, and most of my ruby code is for infrastructure stuff since I'm over in DevOps land. 
I don't believe there is any way to do this without `eval` (or a C extension). 
It depends on what type of programmer you are, as an automation oriented sysadmin, I prefer the broad functionality Ruby offers. Used with Chef I can manage a whole fleet of Unix machines, used locally I can perform a lot of really powerful low level administrative functions, Ruby a much more versatile language than folks give it credit for. As others have pointed out, there are a number of Ruby based DLSs.
Convention over configuration is most definitely a rails concept not a ruby concept.
Extreme productivity. This comes through with being dynamic and concise, having great libraries for everything, having an excellent test story, and being well-supported by many platforms. Ruby is one of the few languages where no matter how fucked up a piece of code is you can unfuck it rather easily because the runtime lets you dynamically change classes and methods
Noted that I managed to kill one of the channels, so sound is only coming out of one "ear". I have that fixed for future streams, feel free to tell me if you notice anything like that while watching! &amp;#x200B; This one covers procs, blocks, and lambdas in some basic detail.
_everything_ is a first class object in Ruby, which can be really nice, like asking nil if it is nil or not.
I've been writing code for 30 odd years now. Starting with BASIC on an Atari 400. In my professional career I've worked in C, C++, C#, Elixir, Java, Javascript, Pascal, Perl, Python, Ruby, Visual Basic and probably a few more I've forgotten. Of all the languages I've worked with, Ruby has by FAR allowed me to accomplish more work for a given amount of effort. It's incredibly flexible and "elegant". I say elegant because it's less verbose than many other languages and it's syntax and idioms make it easy to read. Things like: do_something unless some_condtion instead of if(!some_condition) do_something(); The standard library gives you a lot of functionality and the enumerable module makes list comprehension easy. You can accomplish in one line of Ruby what would take dozens in other languages. Ruby is NOT a language to learn for high performance applications, mobile apps, or games. (Though I'm sure someone will chime in to say they do mobile apps and games in ruby)
I've been writing code for 30 odd years now. Starting with BASIC on an Atari 400. In my professional career I've worked in C, C++, C#, Elixir, Java, Javascript, Pascal, Perl, Python, Ruby, Visual Basic and probably a few more I've forgotten. Of all the languages I've worked with, Ruby has by FAR allowed me to accomplish more work for a given amount of effort. It's incredibly flexible and "elegant". I say elegant because it's less verbose than many other languages and it's syntax and idioms make it easy to read. Things like: do_something unless some_condtion instead of if(!some_condition) do_something(); The standard library gives you a lot of functionality and the enumerable module makes list comprehension easy. You can accomplish in one line of Ruby what would take dozens in other languages. Ruby is NOT a language to learn for high performance applications, mobile apps, or games. (Though I'm sure someone will chime in to say they do mobile apps and games in ruby)
I agree that "Convention over Configuration" is a framework tenet and not language principle. However, in a similar sentiment, the argument can be made that Ruby and the community favors "implicitness over explicitness" given its dynamic, reflective (meta-programming), and object-oriented nature. It's very easy to write Ruby code that lets you write methods/functions and set default values for arguments in declaration or not explicitly having to state the return value or what data type a function requires and returns or if it even it returns anything at all or hell, let's just use a splat to add flexibility and reduce the need to be explicit about everything. While "implicitness over explicitness" isn't the same as "convention over configuration", I think they share a sentiment of getting to writing the code you want to faster.
&gt; clear syntax There are a great many good things you can say about Ruby, but *clear* syntax is not one of them. Things like implied hashes and similar choices make it incredibly and unnecessarily hard to parse Ruby code compared to many other languages. Ruby's syntax is easy to parse into tokens and idiomatically tends to favour english words instead of sometimes-cryptic operators made out of punctuation, but turning those tokens into a coherent, accurate understanding of what to language is actually doing under the hood is far harder than many other languages.
Cars don't *require* seatbelts either, but only slapdash idiots rely on that fact. And if you see someone wearing a seatbelt then leaning in, unclipping it for them and claiming you've "fixed" their driving is the height of presumptuous arrogance.
Cars don't *require* seatbelts either, but only slapdash idiots rely on that fact. And if you see someone wearing a seatbelt then leaning in, unclipping it for them and claiming you've "fixed" their driving is the height of presumptuous arrogance.
But lots of big sites are still Rails. Shopify, basecamp, and GitHub come to mind. Sure Rails isn‚Äôt sexy anymore but I don‚Äôt think any other framework beats it in terms productivity. 
* Expressiveness and programmer happiness are a major priority of language design. As a programmer (who programming languages are designed to be used by) this is sadly true of far too few languages. * Because of that expressiveness Ruby is not necessarily the best language for solving any particular problem in, but it's generally *amazing* for writing a DSL in that allows you to solve the problem (and any/all other problems in its class) more elegantly than otherwise.
Your analogy assumes using semicolons in JS is as vital as seatbelts on a car. It's a matter of opinion but using semicolons as an argument against JS syntax is silly -- which was my point.
Agreed - it's *amazingly* flexible and a joy to use as a developer for that reason... but anyone claiming Ruby's syntax is clear, (ie, unambiguous and easy to parse) either doesn't know Ruby very well or doesn't know many *other* languages to compare it to.
Agreed, from an algorithmic standpoint it is not clear. But for humans it is fine. That is at least my experience ü§∑‚Äç‚ôÇÔ∏è
I really enjoyed the books by Jesse Storimer on systems programming - they were very insightful: https://www.jstorimer.com/pages/books
I have attribute methods to clamp values within ranges allowed by the specific byte lengths. Also I‚Äôm adding methods to modify the data in different ways, and to also make some of it more human-readable. 
Actually it's the opposite - machines have to be able to parse Ruby code unambiguously *by definition* (no matter how much back-tracking and reshuffling of the parse tree it involves), but for humans reading quickly there are so many pitfalls and tripwires that require additional cognitive overhead that a clearer syntax wouldn't. For example, consider the whole lack of parentheses and variable numbers of method parameter issue: def printParams(a,b=nil,c=nil) puts a puts b puts c end def double(i) i * 2 end Now `printParams 2` =&gt; `2` and `printParams 2, 3` =&gt; `2\n3` and `printParams double 2` =&gt; `4`, fine. But `printParams 2, double 3` is a syntax error. Not only that, but unlike all those pythonistas remember how we all hate significant whitespace? `printParams (double 2), 3, 4` =&gt; `4\n3\n4` but `printParams(double 2), 3, 4` =&gt; syntax error Ruby's syntax is so flexible and it overloads tokens so much that it's not hard to generate plenty of edge-cases like that that are rare or entirely absent in other languages with less flexible or less ambiguous syntaxes. I mean don't get me wrong - if you learn Ruby and spend a lot of time working in it then you grow the required bits of the brain to do all that back-tracking and disambiguating subconsciously and it largely stops bothering you... but that doesn't mean the syntax is *clear* - it just means you've stopped noticing all the bits that aren't because you've learned how to handle them by rote.
I agree with your point but I think you have confused "convention over configuration" with properties of a "dynamically typed language". Simply put there's nothing to configure in vanilla Ruby.
Sorry, but I didn't make any statements regarding "convention over configuration" for Ruby nor am I the original replier. I literally agree by starting out by saying "Convention over Configuration is a framework tenet and not a language principle". &amp;#x200B; If you read my comment, I argue that Ruby lends itself to be more "implicit" in nature instead of "explicit" through its flexibility, syntactic sugar, dynamic, reflective, and OOP nature. This is not the same thing as "convention over configuration" but they do fall under the same umbrella of "less boilerplate". And plenty of Ruby's features that lends itself to be more "implicit" are not simply a result of just being dynamically typed. For example, Python is a dynamic/dynamic-typed language yet it strives for more explicitness (at least relative to Ruby).
&gt; either doesn't know Ruby very well or doesn't know many *other* languages to compare it to. I know Javascript, C# and Python (with a sprinkling of Go) besides Ruby. Yes it has its areas but if I compare ruby across the board most of it is more readable and intuitive than the other with the exception of Python &gt; so much that it's not hard to generate plenty of edge-cases You said it - edge cases. There comes a point when you know a language it all seems clear but if you are going to stack up C# and Javascripts as more clear syntax in general you have my disagreement (and given the people who hate JS I would not even be close to be alone) 
&gt;But that's just me No its not just you :) and you were kind not to use an example with 3 pairs of parentheses and 6 curly braces.
I actually learned Ruby first and found Laravel easy to pick up because of it.
Make that 100x. The only justification for rolling your own e-commerce software is that your business model is in creating e-commerce technology. Otherwise go off-the-shelf. It doesn't have to be Shopify or entirely DIY. There's a middle ground of using Spree/Solidus. These supply the e-commerce engine so that you don't have to, but you still get to program in any custom behaviours. 
Having developed with spree/solidus before... I'd just stick to the "that 100x" part, myself. 
Ruby is, for better or worse, an extremely flexible language. I think it's great for creating DSLs (Domain Specific Languages), because you can write code that is very terse, but does a lot. For example, look at [capistrano](https://capistranorb.com/) or [rake](https://github.com/ruby/rake) or [rspec](http://rspec.info/). A creative developer can do all sorts of interesting things. Monkey-patch existing classes? Sure! Change the behavior of standard libraries? Why not? Including one file could alter how an entire Rails app behaves? Go for it! The flip side is that it's possible to write really cryptic code. Not cryptic like dense Perl or obfuscated C. More like staring at a small chunk of code and asking yourself "How does this do anything?!?" I've been using Ruby for about 7 years now, and have been programming for over 20 years. I like it a lot, and feel comfortable with it, but I try not to be too "clever" with it, if I want anyone else to understand the code that I wrote. (Oh, and if you have a use case where high performance is really important, it's probably not the best choice.)
&gt; There comes a point when you know a language it all seems clear but if you are going to stack up C# and Javascripts as more clear syntax in general you have my disagreement (and given the people who hate JS I would not even be close to be alone) I'm genuinely puzzled by that statement. People generally (and often understandably) hate JS because of the lack of standard library, incompatible runtimes, prototypical inheritance and counterintuitive type-coercion, but none of that has anything to do with syntax. Syntax is the way you express things like expressions, blocks, methods, etc, and as JS inherits from C (by way of Java) those things are typically *extremely* clear and unambiguous. You may think parentheses and curly braces are ugly and I wont entirely disagree, but they're short, visible tokens and they're absolutely unambiguous in their meaning. For example, I don't think you can come up with (m)any *syntactically* ambiguous examples in Java/C/JS like the ones I gave for Ruby, above. Off the top of my head the only one I could even think of for JS would be: function test() { return 2; } `test()` =&gt; undefined ... but to trigger that you have to go out of your way to invoke parser error-recovery behaviour (automatic semi-colon insertion), and that's literally the only example I can think of in the entire language. Other than things like relying excessively on operator precedence (which pretty much all languages share), what *syntax* ambiguities can you think of (for example) in JS or Java?
\&gt; Ruby is a language that prioritizes programmer satisfaction. I think it's funny when people say this. I absolutely despise ruby in every possible way. I find myself hating the messiness of the code. It allows programmers to break too many rules (monkeypatching, etc) which makes predictable patterns hard to "just know". I've only been doing Ruby for 5 months now (after 15 years of Java) so I'm clearly biased toward my better known language; however, people told me "once you go ruby, you'll never go back" to which I just laugh. I fantasize about having some interfaces and better collection libraries all the time.
In fairness Ruby also gets kind of hard to follow when you get multiple blocks deep, but that's less of a Ruby/JS thing and more of a programming in general thing. 
Clear for humans 
Ease of prototyping. Most other things are overshadowed by other languages with most points of praise coming to personal preference, habit, or simple unwillingness to admit that this one point is extremely important and can make or break a project or business. It is also the point that tends to lead to increased cost of ownership of ruby projects in later stages. It is simply too easy to bodge together something that fits the bill here and now. It is a great tool for worse is better approach. It is just one of many otherwise.
I'm pretty sure that anyone who learned PEMDAS (or BEDMAS or BODMAS or BIDMAS, depending on your region) when they learned algebra can handle Ruby's method parameters. Just like with algebra, you either use parentheses so that you don't write your parameters ambiguously, or you learn how Ruby handles method parameters so that you can correctly omit parentheses. It's not ambiguous if you know the language, just like how the order of algebraic operations isn't ambiguous if you know algebra.
You should probably use something like JSON.
No clue what JSON is.
That does make sense. The beginning "Object" part threw me off, since there's still a lot of methods on everyone's favorite superclass that I'm sure I don't know.
A couple of things: - You are assigning variables in a while loop rather than checking. Use `==` to check if two things are equal. - You are comparing into to strings in the second method: `@wheels &gt;= ‚Äú1‚Äù` - There are a few variables that can probably be omitted (mostly Boolean variables) - Take a look at the Highline gem for cleanly handling stdin questions - Take a look at Rubocop to get other suggestions on code quality.
He is a great writer, sad that he disappeared from the face of the planet, but his books are still here.
JSON is a type of text format that looks like a Ruby hash, i.e. \`{'key':'value'}\`. It's usually used to send information between systems/software, as it's a universal format, especially for web stuff. It is handy for simple config files, as you can easily read it in and parse it to a hash, modify it, and write it back to file. &amp;#x200B; require 'json' \# Writing the JSON file. The "to\_json" method is added to the Hash by the json gem. my\_config = { :wheels=&gt;4, :passengers=&gt;2 } [File.open](https://File.open)('config.json', mode='w') { |f| f.write my\_config.to\_json } &amp;#x200B; \# Reading the JSON file. The "parse" method turns the JSON string into a Ruby hash object. my\_config = JSON.parse [File.open](https://File.open)('config.json', mode='r').read my\_config\[:wheels\] \&gt; 4 &amp;#x200B;
is a pity that there is not alternative to rails as in marketing. for us, tiny startup, roda + sequel + minitest is fantastic. also, thx for sidekiq, we are using the Enterprise edition for 2 years now and is great!
Wow. I hadn't looked him up in awhile, but he does appear to have abandoned all of the sites where he had an online presence. I hope he's doing well, and just wanted a more private life. His books were great! They seemed to guide the reader through his thought process to arrive at a deeper understanding of the way things worked.
Why don‚Äôt you make it a proper gem?
Sorry you took it that way but I am not going to agree that its either rude or unconstructive. Theres a difference between something being rude and unconstructive and just something you don't want to hear. Life IS short and people DO waste it following up things and you will find out later NOTHING can be more constructive than advice that makes you use your time more constructively and meaningful . My point was to EXACTLY explain why I was not going to go into it further as you requested. Programmers in particular spend too many freaking hours arguing stuff like this back and forth and back and forth. You don't like a language then YES - I stand by it - move on with your life because regardless of the language time is something you don't get back "(but might think is endless now). 
Great advice. It's a bit sloppy but it gets the job done for me. I always have difficulty figuring out how to get the script to loop without using the while/until loops. Also I should've mentioned this in my opening post, but I can't use any gems, so it has to be as homogeneous as possible since I don't have admin access at work (where this is needed).
I definitely should've remembered to put this and i'm sorry I didn't, but I can't install gems at work since I don't have admin rights. I gotta make this as baseline ruby as I can.
&gt;It was unconstructive in the context of the conversation we were having. I don't agree and a poster or posters on reddit saying something does not make it something I need to agree with. I was giving the reason why i would not be getting into further. Me giving my reasons for not answering your question is not a derail or off topic. When you ask ME a question you don't get to dictate my answers. endlessly debating things that at the end of it will add zero to the world and create nothing is a issue with programmers and the surce of useless Languagewars . Your own arrogance and pomposity matters little.I reject them as well but in keeping with my GREAT advice already given I leave you to another meaningless argument. 
Solid advice! Great stuff! Unfortunately I can't install gems since the work has admin block on installing things through Ruby so i'm hoping for something as baseline Ruby as I can get. The only thing I can think of is to put in placeholder lines and then gsub them with an invisible counter set but i'm really hoping to avoid that since that's basically going around the globe to go to my neighbor's house instead of just going there directly. I was hoping there was some sort of built in search function with ruby, such as 'File.search("textfile.txt", "Feedback:","a") do after|line| &gt; puts "blahblahblah". Or even just an 'append after line 3' because I can just put \n in my code.
I'll check on Monday. They definitely strip a lot. I keep telling them if I can have admin rights i'll make their lives so much better. :D
You should be able to set GEM_HOME to somewhere in your homedir, and then install gems there. Alternately, if Bundler is installed systemwide you can `bundle install --path ./vendor/bundle` to install gems locally for a project.
I'll have to try that.
JS has gotten a lot better in this regard with asynchronous await and promises. Ruby might be more aesthetic but that really shouldn't be the primary way any programming language is judged. It's a nice to have. The fact that rubyists jump up and say 'our language is better because it is prettier' is part of why I think it often gets relegated. Things like the ease of metaproggramming are much bigger things to talk about. 
I look forward to trying this one day, I had an API wrapper partly written in Node.js but I seem to recall some annoying detail of their API which required multiple calls to be made just to get some basic details about users and their completed katas.
I mostly use Reddit to read comments and learn why people use/like something but I found out that a good place to do that is hackernews tbh
and that's where you should be. on Reddit, everyone gets a trophy for trying apparently.
Sometimes I upvote so the thing will attract interest, and hopefully people will comment. Then I see, oh, there are some comments, good, let's see what people have to say. And I find this. Apparently you and I both have nothing to say about it! 
I do have something to say, use containers and stop reinventing the wheel.
Oh, thanks for the advice! I didn't know gems came 'default'. I thought they were add ons. Neat! I learned something!
My work computer is on Linux and no, it doesn't work. I tried with other gems. Says I don't have admin rights.
\&gt;Assumes containers aren't already reinventing the wheel
Containers, containers everywhere! This is the key to everything, right? Like you said - containers it's a Wheel. 
I like the idea! Was there any inspiration taken from foreman perhaps ?
Sure it was! [https://github.com/vifreefly/procsd#difference-with-foreman](https://github.com/vifreefly/procsd#difference-with-foreman)
Awesome! I loved playing around with foreman when worked with heroku hosted projects Sadly the export for systemd was not always a smooth transition for me. I like how you started address this part primary. Keep up the good work! :)
You can use [rvm](https://rvm.io/) to install gems locally. I recommended Rubocop because it‚Äôs good at pointing out small mistakes and common style guidelines.
Hi, thanks for your feedback ! In fact we have implemented specs that enforce that our claim, for example : https://github.com/klaxit/fast-polylines/blob/master/spec/fast-polylines/decoder_spec.rb :) But you are right, it's too hidden to be quickly noticed (and so it's difficult to believe). I will plan to add a nicely presented benchmark &amp; explanation soon :)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [klaxit/fast-polylines/.../**decoder_spec.rb** (master ‚Üí e354ba1)](https://github.com/klaxit/fast-polylines/blob/e354ba1ad825478d08e6a8cb281feeddf3091ab8/spec/fast-polylines/decoder_spec.rb) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e934bgc.)
Something about ruby just fits my brain, you know? Here's an example of the 'programmer friendly' philosophy: ~ $ python Python 2.7.15rc1 (default, Apr 15 2018, 21:51:34) [GCC 7.3.0] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; exit Use exit() or Ctrl-D (i.e. EOF) to exit &gt;&gt;&gt; quit Use quit() or Ctrl-D (i.e. EOF) to exit &gt;&gt;&gt; exit() ~ $ node &gt; exit ReferenceError: exit is not defined &gt; quit ReferenceError: quit is not defined &gt; (To exit, press ^C again or type .exit) &gt; .exit ~ $ irb irb(main):001:0&gt; quit ~ $ irb irb(main):001:0&gt; exit ~ $ You spend less time sweating the irritating details. 
You can use zapier
Not sure if something like this exists for Ruby or not, but there is https://github.com/notifme/notifme-sdk for JS. Worth checking out. 
So, it is a planned semver major upgrade for the annual non-semver ruby releases. And all so we can have another zigagem bundled into Ruby installed packages... is it really worth it?
A lot more reasonable than the initial plan for 2.0, though I'll still curious how much stuff they plan to break for no good reason in 3.0. 
Rolling your own isn't too bad. I've done it for [TinyVoicemail](https://tinyvoicemail.com). Any gem will likely use the respective gems underneath anyway. 
WUPFH?
The $(document).ready stuff needs jquery, but no bootstrap.js, so you can load jquery library on header, and leave bootstrap.js at the end.
Do you not have a stacktrace telling you on what line the error is occurring and in what file? The problem is exactly what it says, something is trying to call a method on nil that doesn‚Äôt exist.
I think I'm getting a filtered perspective because of my work: I'm doing contracting as a senior dev, and pretty much only get hired to work on projects that never have tests, never have documentation, and never follow good coding practices. So I'm often stuck with some that isn't working, and some variable and wondering what it "is".
edit: I appear to have located and installed unpack: bitnami@debian:/$ gem install unpack Fetching: unpack-0.2.1.gem (100%) ERROR: While executing gem ... (Gem::FilePermissionError) You don't have write permissions for the /opt/bitnami/ruby/lib/ruby/gems/2.3.0 directory. bitnami@debian:/$ sudo gem install unpack Successfully installed unpack-0.2.1 Parsing documentation for unpack-0.2.1 Done installing documentation for unpack after 0 seconds 1 gem installed bitnami@debian:/$ cd opt/bitnami/apps/redmine/htdocs/ bitnami@debian:/opt/bitnami/apps/redmine/htdocs$ sudo bundle exec rake redmine:plugins NAME=redencrypt RAILS_ENV=production rake aborted! NoMethodError: undefined method `unpack' for nil:NilClass but still no joy.
Bundler is a great tool, I just wish I didn't have to _think_ about it so much.
Did you try running the command from `/opt/bitnami/apps/redmine/` instead of the plugins directory? Did you already run `bundle install --without development test`?
 /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:193:in `invoke_with_call_chain' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:237:in `block in invoke_prerequisites' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:235:in `each' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:235:in `invoke_prerequisites' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:212:in `block in invoke_with_call_chain' /opt/bitnami/ruby/lib/ruby/2.3.0/monitor.rb:214:in `mon_synchronize' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:193:in `invoke_with_call_chain' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:182:in `invoke' /opt/bitnami/apps/redmine/htdocs/lib/tasks/redmine.rake:57:in `block (2 levels) in &lt;top (required)&gt;' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:271:in `block in execute' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:271:in `each' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:271:in `execute' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:213:in `block in invoke_with_call_chain' /opt/bitnami/ruby/lib/ruby/2.3.0/monitor.rb:214:in `mon_synchronize' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:193:in `invoke_with_call_chain' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/task.rb:182:in `invoke' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:160:in `invoke_task' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:116:in `block (2 levels) in top_level' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:116:in `each' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:116:in `block in top_level' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:125:in `run_with_threads' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:110:in `top_level' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:83:in `block in run' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:186:in `standard_exception_handling' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:80:in `run' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/gems/rake-12.3.1/exe/rake:27:in `&lt;top (required)&gt;' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/bin/rake:23:in `load' /opt/bitnami/apps/redmine/htdocs/vendor/bundle/ruby/2.3.0/bin/rake:23:in `&lt;top (required)&gt;' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli/exec.rb:74:in `load' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli/exec.rb:74:in `kernel_load' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli/exec.rb:27:in `run' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli.rb:335:in `exec' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/vendor/thor/lib/thor/invocation.rb:126:in `invoke_command' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/vendor/thor/lib/thor.rb:359:in `dispatch' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli.rb:20:in `dispatch' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/vendor/thor/lib/thor/base.rb:440:in `start' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli.rb:11:in `start' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/exe/bundle:32:in `block in &lt;top (required)&gt;' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/friendly_errors.rb:121:in `with_friendly_errors' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/exe/bundle:24:in `&lt;top (required)&gt;' /opt/bitnami/ruby/bin/bundle:23:in `load' /opt/bitnami/ruby/bin/bundle:23:in `&lt;main&gt;' Tasks: TOP =&gt; redmine:plugins:migrate =&gt; environment bitnami@debian:/opt/bitnami/apps/redmine/htdocs$ I must apologise, as I'm not _that_ technical compared to a lot of people.
Your best bet might be to google this issue as it seems specific to the redmine plugin you‚Äôre using. Sorry I couldn‚Äôt have been more help.
I think you can do even better by passing a block that calls whatever needs to be called on `time` instead of assuming it's a method call.
Thanks all the same. I've been all over google, and not had any joy. I don't know if it is the plugin, the VM I'm trying to use being configured to not allow changes to some parts, Ruby being odd, a combination, or what... Frustrating :/
On the second part, I think so. just tried it again: bitnami@debian:/opt/bitnami/apps/redmine$ bundle install --without development test Could not locate Gemfile on the first part: bitnami@debian:/opt/bitnami/apps/redmine$ sudo bundle exec rake redmine:plugins RAILS_ENV=production --trace rake aborted! No Rakefile found (looking for: rakefile, Rakefile, rakefile.rb, Rakefile.rb) /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:698:in `raw_load_rakefile' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:104:in `block in load_rakefile' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:186:in `standard_exception_handling' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:103:in `load_rakefile' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:82:in `block in run' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:186:in `standard_exception_handling' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/rake-12.3.1/lib/rake/application.rb:80:in `run' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/rake-12.3.1/exe/rake:27:in `&lt;top (required)&gt;' /opt/bitnami/ruby/bin/rake:23:in `load' /opt/bitnami/ruby/bin/rake:23:in `&lt;top (required)&gt;' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli/exec.rb:74:in `load' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli/exec.rb:74:in `kernel_load' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli/exec.rb:27:in `run' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli.rb:335:in `exec' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/vendor/thor/lib/thor/invocation.rb:126:in `invoke_command' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/vendor/thor/lib/thor.rb:359:in `dispatch' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli.rb:20:in `dispatch' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/vendor/thor/lib/thor/base.rb:440:in `start' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/cli.rb:11:in `start' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/exe/bundle:32:in `block in &lt;top (required)&gt;' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/friendly_errors.rb:121:in `with_friendly_errors' /opt/bitnami/ruby/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/exe/bundle:24:in `&lt;top (required)&gt;' /opt/bitnami/ruby/bin/bundle:23:in `load' /opt/bitnami/ruby/bin/bundle:23:in `&lt;main&gt;' bitnami@debian:/opt/bitnami/apps/redmine$ It's a weird one.
When you say the VM, are you talking about running this locally or is this for the production site?
Something I noticed is that you‚Äôre running the plugin install command from the plugins folder. The documentation here requires you to be in the htdocs folder.. https://docs.bitnami.com/general/apps/redmine/configuration/install-plugins/ Could this be the issue?
This is a pretty huge project (3+ years in the making), and it feels a bit surreal to have finally reached this point. For anyone interested in event sourcing or microservices/SOA, I recommend you have a look at Eventide!
The error is probably happening in the String#unpack method, inside the Base64 gem. You can reproduce the error easily in IRB: 2.1.5 :001 &gt; require 'base64' =&gt; true 2.1.5 :002 &gt; Base64.decode64(nil) NoMethodError: undefined method `unpack' for nil:NilClass from /Users/jlauer/.rvm/rubies/ruby-2.1.5/lib/ruby/2.1.0/base64.rb:58:in `decode64' from (irb):2 from /Users/jlauer/.rvm/rubies/ruby-2.1.5/bin/irb:11:in `&lt;main&gt;' I can't speak to a solution, since I don't use Redmine, but the issue appears to be in the guts of redmine, and isn't related to an "unpack" gem, that's a red herring. Something is trying to base64 decode nil when it requires a string. I'd find where that happens on line 59 of /opt/bitnami/ruby/lib/ruby/2.3.0/base64.rb and walk backwards through the stack trace from there. Chances are there is a configuration value missing or something like that. Good luck!
pretty sure I was in /htdocs/ not /htdocs/plugins/ but I could be wrong. Giving it a rest for the evening now. Not like i'm getting paid for it!
What is IRB? What you have said about the base64 decode makes sense, so I'll have a look at that tomorrow. Thanks for the help :)
Congrats on the major release! I saw a talk at an Austin Ruby event on event sourcing, definitely made me walk away and want to teach myself more. I haven't gotten a chance to use eventide yet, but it looks pretty cool and it looks like the documentation is much improved from the last time I looked at it, which should make it easier to play with. 
As a total aside, are you all using vuepress for the website and docs?
The documentation is indeed vuepress, but the website is not.
Congrats on your release. Looks like a great project. Two questions: 1. How does it compare with [https://github.com/zilverline/sequent](https://github.com/zilverline/sequent) 2. What is your recommendation for learning CQRS concepts generally (outside of any specific framework)? Or would you recommend it learning it via eventide?
Before I proceed, I should add the caveat that I'm not intimately familiar with Sequent, so am not well qualified to offer a fair comparison of the two. If I had to guess at the most significant difference, I'd say Sequent is designed with Rails users in mind, whereas Eventide is designed with the use case of building evented, autonomous microservicesservices in mind (although nothing about Eventide is incompatible with being used in a Rails environment). At first blush, Sequent offers a very different underlying database implementation. We went with a single table for all messages with semantics inspired by [Event Store](https://eventstore.org). We leverage Postgres advisory locks to ensure consistency. Sequent, on the other hand, stores stream data separately from events, and offers a separate table for storing commands. I'm not sure what the implications are for consistency, or if they require transactions in order to ensure consistency. I'd be investigating that closely if I were considering Sequent. Second, the framework primitives that you build off of in Sequent are very different from Eventide. Eventide, for instance, stays out of the way of entities: you can use plain old ruby objects as entities, or data structure classes with typed attributes (think Virtus). Entities are separated from the actual event sourcing in Eventide because our projection classes (they contain the code that takes events and applies corresponding changes to entities) are separated from entity classes. Sequent, on the other hand, appears to comingle event projection with entity classes together in a base class called "aggregate root." At this risk of criticizing another project (which I prefer to avoid), we regard aggregate root classes as an _antipattern_, as they tend to attract undesirable coupling (the same way that "fat" ActiveRecord models do). Third, Sequent offers some elements that Eventide probably won't ever offer. Projectors, which I believe are designed to update "read models" in CQRS lingo, are really not part of Eventide proper, although we do offer some supplementary tooling for that outside the core offering. Similarly, Eventide offers no corresponding equivalent of Sequent's "Workflows," which appears to be about managing processes that are actuated by reacting to events. We don't distinguish between entities meant to encapsulate application data (typically the ActiveRecord models in Rails apps) and entities meant to encapsulate processes (typically the background jobs in Rails apps). We model them both effectively with event sourced entities. Pub/sub is only a matter of subscribing to an event stream with Eventide. I hope to be posting more about what makes Eventide distinct in the coming months. I likely won't be addressing specific frameworks like Sequent, but hopefully it should at least cover what makes Eventide unique.
I'm failing to see how collection libraries tie into ... anything else you mentioned in your post. I replied to the substance of it, not the thing you tacked on at the end. I'm sure everyone else would appreciate a "hey, here's where I think Ruby's collections are deficient" post if you've got one to give. Either the situation would improve *or* someone might point you to better answers, so *somebody* would win.
Fantastic book
Honestly think this is great news. Bundler should have been apart of core Ruby, for a while now. Just about everyone on nearly every project with dependencies outside of core, is using it.
Haven't worked on IBM-I OS, but I have worked on Z/OS before; and if they are anything similar to each other. its a terrible Linux/Redhat experience. Driven by huge globs of unmaintainable Cobal and ASM programs.
IRB is the ruby interactive shell, a ruby REPL. It comes bundled with ruby.
It doesn't seem so, as you get upvotes :) and I get your point. In many occasions I've had feelings similar to yours. However, I realised that in some cases it's easier to compile the essence and case studies into a tiny article, which you can actually read while in a bus, while in bed, or whatever idle activities you're currently up to. Sometimes its easier for me to read that kind of information in a form of a tiny article / blog post, than to read the documentation, which often is just pure technical knowledge that does not include use cases or answers to questions that may follow after reading. I've tried to put stuff that tell just a little bit of a story behind what's the reason to even write down such article, my own experiences even in 1:1 situations during a code review, hopefully making it a bit more meaningful than just a doc page. Maybe it wasn't enough :) Thanks for the feedback! &amp;#x200B;
Yeah, that's exactly what I needed. I have been searching and it seems that there isn't something similar for Ruby.
Like others have suggested I think it won't be too difficult to roll out your own implementations. You can always build a middleware wrapper that handles the interactions with these various notification mediums. Or if it feels it's too much, just delegate the notifications part to the above linked JS library from your Ruby code. 
I don‚Äôt agree with this at all. Docs are cold and don‚Äôt go into history, reasons for doing anything, or comparisons a lot of times. Putting a ban on any blog about programming? I‚Äôm not saying all posts are high quality, but that doesn‚Äôt make any sense.
Amazing answer. tyvm.
You need to read your error messages: Counting installed Ruby versions: none There aren't any Ruby versions installed under `/home/palash25/.rbenv/versions'. You can install Ruby versions like so: **rbenv install 2.2.4** 
Hmm, I'm not sure I like this approach, because it _can_ still pass if you have a thread safety bug, I think? It might pass some times and not others. Plus it could be pretty slow. But I don't have a better alternative to suggest. the only alternative I know of is thinking really hard and writing complicated tests that confusingly use countdown latches in _just_ the right places and ways to force certain orders that could be buggy. 
Don‚Äôt agree with what? first of all you get the comment wrong. I‚Äôm talking that I don‚Äôt see useful articles w/o any extra information, deep explanations(including history, references, points behind using this or another thing, further readings and etc.), academical or ideological part of sense. For example this article could contain some points like: why do we need immutable things at all, what should be immutable, what shouldn‚Äôt be. Those who understand what to put to a constant and distinguish immutable things from rest of data will catch this simply looking at the Object class reference or any ruby tutorial. P.S. Probably, this article would come in handy for those who is switching to Ruby from any another pl. Author, don‚Äôt get me wrong it‚Äôs just an opinion 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [Falcon: A modern high-performance web server for Ruby, supporting HTTP\/2 and HTTPS out of the box. ‚Ä¢ r\/ruby](https://www.reddit.com/r/RubyLang/comments/9urdpw/falcon_a_modern_highperformance_web_server_for/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
JIT Ruby seems like it could be a Thing, anybody play around with it yet?
d'oh!
What's the error message after running the rbenv install command? 
Stupid question: why doesn't the `$(document).ready` function wait for the jquery library to be loaded? Isn't that kind of the purpose of the function? Moreover, as the library is deliver from a CDN, most likely isn't this downloaded after the first page visit? Would sourcing the jscript library from `/public` eliminate this issue?
https://twitter.com/presidentbeef/status/1058082497886609408?s=19
I usually agree with you, but this is is a well-written, entertaining and informative article. Also, to look something up in the docs you have to know what you are looking for.
&gt; Stupid question: why doesn't the $(document).ready function wait for the jquery library to be loaded? Isn't that kind of the purpose of the function? You need to load jQuery to use '$' function. So, you can't use $(document).ready before load jQuery. &gt; Moreover, as the library is deliver from a CDN, most likely isn't this downloaded after the first page visit? Is cache is activated, that will be correct. &gt; Would sourcing the jscript library from /public eliminate this issue? What issue?
A bit hacky but I think this works reasonably well irb(main):005:0&gt; str = 'this is many words and whatnot' =&gt; "this is many words and whatnot" irb(main):006:0&gt; str.split.map { |word| word[0] = word[0].upcase; word }.join(' ') =&gt; "This Is Many Words And Whatnot" If you need to maintain whitespace though this will fall apart and the road you're going down looks pretty correct, just add a condition for `i == 0`
BTW, String#capitalize does this with no index manipulation. So it could be: str.gsub!(/\w+\b/) { |word| word.capitalize } This is a better, faster, and less hacky way, I think.
How rails does it: [https://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-titleize](https://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-titleize)
Note that this is very similar to my approach, just with some edge-case handling =)
&gt; `if array[i-1] == nil || array[i-1] == " " ` So, what if your `i` is zero? Then you'll get array[-1], which gives you the LAST element in the array, that is `[a,b,c][-1]` -&gt; `c` That means you'll capitalize the first item in your array IF the last item in the array is nil or a space. This is not your intended behavior. You could implement what you want like this, potentially: str = 'this is an example string' last_char = nil str.each_char do |char| if last_char.nil? || last_char == ' ' print char.upcase else print char end last_char = char end That'll print the string correctly, but it's not a good method. For example, having a comma in your sentence will ruin your title case.
I think in rails 3.0 there is a titleize method, which is exactly what I‚Äôm looking for 
My best guess is (I'm currently on mobile), that the web server has no MIME type configured for `.rhtml` files, and defaults to `application/octet-stream`. The server might also set the `X-Content-Type-Option` to `nosniff`, which inhibits browsers from performing content type detection on their own. You can verify this with cURL (look for the `Content-Type` header): $ curl -I http://www.sparknotes.com/testprep/books/sat2/physics/chapter18.rhtml You basically have two options, if you want these files to be displayed in a browser: 1. setup the MIMW type for `.rhtml` files to `text/html` -- the "how?" depends on the server software 2. rename the files to `.html` -- that might break links, though
&gt; However, Node.js is growing fast and can become the next big thing. The speed and scalability that Node.js provides is one of its biggest advantages I think that just about anyone basing their decision on which language to choose based on it's "scalability" has read way too many articles without actually working in the field. Shopify runs on RoR and they handle 80000 requests PER SECOND. Just what kind of application are you planning to build to need more than this? At such a scale you also have far more issues than language alone since you will be bottlenecked by your IO, your database, your load balancers and your architecture. Language being just one spice in a dish known as a scalable application. I am not denying the fact that Node can be faster if you do CPU bound operations but frankly I dislike how "scalability" is mentioned in the context of a language itself. 
 Hi, &amp;#x200B; One of the Sequent authors here. realntl gave a pretty good summary of the parts of Sequent that were mentioned. Thanks for that. At first glance the microservices (Eventide) versus webapplications (Sequent) might be a good comparision. Although nothing prevents you from using Sequent in a microservices architecture. Just a few extra comments to clarify what Sequent does: 1. Sequent indeed uses transactions (optimistic locking) to ensure consistency. The aggregate\_id and sequence\_number are the unique key for event streams. This is enforced by Postgres. 2. We did not design it specifically for Rails users (the initial app was/is a Sinatra app), but more for building with webapplications in general. Our aim is to have a Rails like experience for building event sourced (web) applications. 3. The AggregateRoot model indeed has it's advantages and disadvantages. As a rule of thumb we tend to keep the AggregateRoot's small. And so far that is working for us. Other then the Events we hardly have any "undesirable" coupling (or coupling at all) regarding the AggregateRoot's though. So I am not sure what is meant by that. 4. Indeed we have also offer Projectors and Workflows for the reasons mentioned in realntl comment. As for the best way to learn CQRS or Event Sourcing: IMHO the articles / presentations from Greg Young are a great source. Also my colleague wrote a nice blog serie on event sourcing (from 2012 using Scala, but still great) [https://tech.zilverline.com/2012/07/04/simple-event-sourcing-introduction-part-1](https://tech.zilverline.com/2012/07/04/simple-event-sourcing-introduction-part-1) Also looking at the code of existing libraries like Eventide or Sequent really help. And finally: take some time and try to implement your own library/framework. That really helped me in understanding the different concepts, the essence of event sourcing / cqrs is not that big actually.
Hi, We have updated the docs quite a lot last few weeks on [sequent.io](https://sequent.io) actually. So "rather incomplete" sounds a bit dissapointing, but we are always open for suggestions. So care to elaborate a bit more on what are you missing? 
Titleize comes from activesupport gem. No need to load rails for it :)
&gt;le 80000 Agree. Also basing it on current popularity is somewhat short sighted, who's to say Node won't be ditched in 5 years for something shinier? It's already happening in favor of Golang.
&gt; David Heinemeier Hansson created what would later become one of the most used programming languages. what?
Lot of low quality blog posts getting posted to this sub lately.
marketing crap
Has the Rails team said anything about what their plans are? Can we expect Rails to be supported at launch? I‚Äôm excited to test the jit stuff. Also, any idea about why there are issues with Rails?
Dude, I am worried. Do they keep you hostage? Threaten your family? Wink if they are forcing you to post this bullshit. (If somebody persuaded you or your boss that's how you build the company's reputation or identity, they were laughing at you.)
Thank you, I've not used cURL except in php. One thing that I did was fetch the rhtml file through file get content and printed it, it actually worked. And the second method that you suggested above also worked, didn't understand the first one though. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [adamkewley/jobson/.../**pom.xml** (master ‚Üí d73f4e4)](https://github.com/adamkewley/jobson/blob/d73f4e41d1cae5032c8bea47d1fa9fbc0cf79a83/jobson-swagger-ui/pom.xml) ---- 
 array.each_cons(2) do |prev, current| current.capitalize! if prev.nil? || prev == ' ' end One difference to your solution: this one does not wrap, i.e. look at the last `Array` element if `i == 0`.
Interesting. Thank you for sharing.
Try Facets https://www.rubydoc.info/github/rubyworks/facets/String
`gem install --user` installs into your home folder, so assuming you have write access for your own home (I assume so), it really should work. Can you please try again (I dunno, `gem install --user pry` or something) and paste here exact command and error message? I admit I'm bit curious why it's not working :)
correct answer IMO
&gt;You need to load jQuery to use '$' function. So, you can't use $(document).ready before load jQuery. Assuming that it is referenced in the page, once the library is download from the CDN, shouldn't it then fire the `.ready` method? Said another way, doesn't the browser recognize that the `&lt;script/&gt;` block (defined earlier in the page) has a dependency upon another `&lt;script/&gt;` block defined later in the page? I suppose the answer is 'no', given the behavior that I'm experiencing. &gt;What issue? If I had the jquery library located locally, would that fix my 'timing' problem? I'm thinking 'no', because of my response (above). What I don't understand is if Bootstrap recommends that JS library inclusion be done at the end of the page (in a layout, perhaps), where do they expect the `&lt;script/&gt;` that contains the `$(document).ready` function be located? If I have page-specific JS, that is included in the layout using a `yield`, there is no way that it will function if the JS library is included in the page after it. &amp;#x200B;
I raise you: str.gsub /\b\w+\b/, &amp;:capitalize 
I extended my benchmark from 100,000 jobs to 500,000 jobs to get the expected runtime from 20-&gt;100 secs to see if the JIT warms up: NoJIT: 107 sec W/JIT: 139 sec This is one run on my laptop on battery with browser, music, etc going in the background so take with a grain of salt but this roughly matches the 25-30% hit I initially saw. 
All instruction to browser (HTML and JS) are intepreted in order. There is no way that the browser now what '$' means, if the jQuery source code is not loaded first. About the *$(document).ready* method, we must remember that is a method that will be triggered once the document is fully parser, but to be defined you need jQuery first. So, the sequence will be * Load jQuery * Defines one or more $(document).ready instructions * Document fully loaded * All $(document).ready instructions are triggered So, if you put jQuery script at the end, $(document).ready should be after that part. 
How about `thing.to_s.capitalize`
Hi @sendo77, good point: incomplete is definitely the wrong term. I'd say that the eventide doc has more coverage (as in it covers more topics) compared to sequent docs: it covers some suggestions regarding oop and the thought process behind event sourcing, not only the docs of the framework itself. That's why I introduced the docs as "extremely valuable", independently of using the framework or not. 
Thanks a lot for your input and the, for me, HUGE compliment. I never thought about setting the permission with the FileUtils. When I use ruby for this I think I need to generate the SSH key with user permissions. The thing with the erb templates: You mean something like \`def configure\_supervisor\_user\`? I haven't looked into testing yet, because I have no idea HOW to do it.
This!
Oh boy... where do I start? :-) cURL is a command line program. You open a terminal and execute it like I showed you: $ curl -I http://www.sparknotes.com/testprep/books/sat2/physics/chapter18.rhtml This will print something like this to the screen (these are the HTTP headers sent by the server): HTTP/1.1 200 OK Server: nginx/1.15.1 Content-Type: application/octet-stream Content-Length: 45684 X-DNS-Prefetch-Control: off X-Frame-Options: SAMEORIGIN Strict-Transport-Security: max-age=15552000; includeSubDomains X-Download-Options: noopen X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block Accept-Ranges: bytes Cache-Control: public, max-age=0 Last-Modified: Wed, 29 Aug 2018 21:24:06 GMT ETag: W/"b274-16587927330" Date: Wed, 07 Nov 2018 19:49:47 GMT Connection: keep-alive That's the response of the web server serving the `chapter18.rhtml` file. This is also how (in large portions, omitting some details here) how your browser interacts with the server. Note the lines starting with [`Content-Type`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) and [`X-Content-Type-Options`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options). They indicate how the server thinks this file should be interpreted. The first value is the [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) (which differentiates image data from stylesheets, videos, audio, plain text, etc.). Here, the value is `application/octet-stream`, which donates binary data (like downloads, but also unidentifiable data). Normally, your browser will try to auto-detect the MIME type (called content type sniffing: "if it smells like an image, display it as such"), however the server also sent an `nosniff` directive. So your browser goes "hey, this *looks* like HTML, but the server explicitly tells me this *is* binary" and in the next step "I don't know how display binary data, so I'll save it as a file in the downloads folder". We can also see the server software (`Server: nginx/1.15.1`). Your system administrator has, by the looks of it, either changed its [`default_type`](https://nginx.org/en/docs/http/ngx_http_core_module.html#default_type) to `application/octet-stream`, or explicitly setup a [`type`](https://nginx.org/en/docs/http/ngx_http_core_module.html#types) for `.rhtml` files (this is what I was suggesting to change in my first point above). Btw. [`file_get_contents`](http://php.net/manual/en/function.file-get-contents.php) ignores most of the HTTP headers and just downloads the response body into a variable. That's why it seemed to work (try `curl` without `-I` to get the same effect on the command line). Ignorance is bless, isn't it?
Thanks
Well, I've been doing it full-time professionally for 7 years, and I wouldn't say I've fully learned it. But being able to create useful things in a language does not requite anyone to learn every piece of it. Still, it takes a few months of focused study - multiple hours per day, every day - to get to the point where you can just create something that's usable by other people. Since you haven't worked with code before there is a lot of other things to learn along with the Ruby language (which you'd have to learn with any language). Things like using the command line and including code written by someone else in your project, how to debug and find errors, how to google the right thing to find the code you need. Another tricky part about Ruby is that normally it's used to create web applications, and to do that you also need to understand HTML, CSS and JavaScript. I'm sure that sounds daunting, but don't let it. These things are all part of learning to code and you'll learn them as part of that quest. I only mention these things to point out that it takes a while to understand all of them and fit them together into a working piece of code. This is why it takes more than a few weeks to get it, and likely a few years to feel really comfortable. I'm happy to answer more questions for you. This is absolutely something you can do.
Honestly, I wouldn't start learning how to program with Ruby. Too many instances where there are multiple ways to do the same thing and one is preferred. There is a lot of good beginner material out there for python and that is probably where I would start. 
My dad did a python course a while ago, it was a free college course and he thought he might as well give it a go. He is a engineer and he struggled with the course so I don't how it would be like for me. He still has all his notes though, which could be handy
Fair enough -- I tend to prefer using explicit blocks to Proc syntax. To me, that syntax is neat, but its cost is ease of understanding and refactoring. Blocks are easy to use, easy to change, etc. It's the same reason that the rails code linked in another comment used the same methodology.
A week or two? Try a year or two. Programming is no cakewalk, and it takes some serious time and effort to become a software developer who doesn't suck. Here's a syllabus for you to become a Ruby on Rails developer in 2 years, by putting 1 hour of study a day: 1. Download [Racket](http://racket-lang.org/) and with it do the [How to Design Program](https://htdp.org/2018-01-06/Book/) course. Do all the exercises, don't skip any. This course and language is the most gentle and straightforward intro to programming there is. 2. Download the personal edition of [VisualWorks](http://www.cincomsmalltalk.com/main/community/product-portal/trying-cincom-smalltalk/try-cincom-smalltalk/) and learn Smalltalk with the [Joy of Smalltalk](http://sdmeta.gforge.inria.fr/FreeBooks/Joy/) book. This will allow you to master Object Oriented programming and design. Pick the exercises that you would enjoy doing and make them. 3. Get the *Well-Grounded Rubyist* book, download the latest Ruby version, and now (after you have done both the previous courses) it will be easy for you to understand Ruby fully. Also, get *Design Patterns in Ruby* which will further your understanding of Object Oriented design. And get a Rails book (don't know which to recommend). I am teaching myself Ruby at the moment, and I have already walked the path I am advising you. At the end of the day, it will be your own interest and passion which will guide you forward. Godspeed.
Also for the hell of it white spaces as syntax. Seriously if this wasn‚Äôt a thing I would totally spend more time with Python. 
I think this is terrible advice. Python isn't something that's going to magically explain the fundamentals any better than Ruby. In fact the syntax and god awful white space requirements, IMO actually hurt more than help. As it can easily lose a lot of meaning behind the intent for which you're trying to comprehend. Where as Ruby, despite having a dozen methods for doing iterations; Can deliver better meaning and understanding with its more sensible comprehension approach. Maybe I'm completely bias as they come. But I really do believe Ruby is much easier to develop and understand than Python.
I understand that teachers like it. They even made up their own word de-dent. Having been someone on the other side of the desk, having extra variables that are unclear can be a detriment to learning. There is nothing more frustrating in programming to me than an error that is invisible or camouflaged to the eye. 
That's a fine opinion to have, I disagree and think whitespace requirements help instill good habits, and think learning fundamentals of programming is easier when there is are fewer ways to do things. I do think that both python and ruby offer some niceties in terms of easy to read syntax that make it easier to work with than Java or C for starting. (Java was my first language, followed by python and C, I've taken intro classes taught in each of those. Learned ruby on the job) I'm wandering what about the whitespace requirements you think is god aweful? Do you think it is god aweful to require blocks of code have the same indentstion and for line continuation to also be indented? Pep8 has some requirements beyond that which can be annoying but adhering to pep8 standards is not required to actually run python.
I've been on both as well ü§∑. To each their own.
¬Ø\_(„ÉÑ)_/¬Ø Agreed fellow Reddit programmer.
The biggest downside of Python to me is not the language, it‚Äôs the community‚Äôs practices. Despite being an object oriented language, every piece of python code i come across is procedural hell tied together by for loops. The Ruby community does a better job on insisting on better OOP habits (small methods, functional iteration, idiomatic code, etc.) and cleaner code. I think that‚Äôs the best part for beginners to takeaway. 
Probably too late for your assignment, but try using jruby. It has much less accidental thread safety.
In 2 months you probably can learn it well, apart from the part (gem) Ruby on Rails.
I'll have to check the exact configuration, but I believe 5.2 handles transactional tests in such a way that database cleaner is no longer needed.
A couple of weeks to learn, a lifetime to master. In a couple of weeks, you can expect to start being able to "do stuff". Solve real problems, start being able to move your own learning along. Learning to be a "productive programmer" will likely take something between 6 months and 2 years - by then you'll be able to tackle pretty much any "bite-sized" problem, and have a good chance of solving it. Learning to be a software engineer... is a lifetime endeavour. A very rewarding one, mind you.
Maybe you have an error in your inputs for multiplying two arrays of floats, like you're trying to multiply a multi-dimensional array instead of an array? $ ruby -ve 'a = [1.1 ,2.4, 3.8]; b = [4.7, 5.3, 6.2]; p a.zip(b).map { |x,y| x*y }' ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin17] [5.170000000000001, 12.719999999999999, 23.56] For multiplying multi-dimensional arrays use Matrix: $ cat t.rb require 'matrix' a = Matrix[[1.1, 2.4, 3.8], [4.7, 2.2, 6.5], [5.3, 7.4, 8.9]] b = Matrix[[4.6, 3.7, 2.1], [5.3, 8.3, 8.4], [1.2, 6.5, 9.2]] p a * b $ ruby -v t.rb ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin17] Matrix[[22.339999999999996, 48.69, 57.42999999999999], [41.08, 77.9, 88.15], [74.28, 138.88, 155.17000000000002]] 
Rethinking, matrix multiplication may not be what you want? If you want cell 0, 0 from `a` multiplied by cell 0, 0 from `b` then `zip` your multi-dimensional arrays together then apply the same method you already used for each pair of rows.
Maybe it's about begin rescue else end
Problem solved 
 [a, b].map { |arr| arr.transpose.map { |cols| cols.reduce:* } } #=&gt; [[27.401000000000003, 39.072, 219.83], [29.255999999999997, 199.61500000000004, 162.28799999999998]]
You can create such workflows in [Automate.io](https://Automate.io) With it, you have a lot of integrations possible like - Gmail, MailChimp, Twilio, Slack etc.
I can confirm, this as I had recently started a new a Rails 5.2 app, forgot to install database cleaner, but when I realized that I then wondered how my tests were passing, and not throwing constant failed uniqueness constraints. That‚Äôs when I found out about the new transactional tests feature. To enable it in rspec you just need: config.use_transactional_fixtures = true The only caveat that may cause issues that I can think of off the top of my head is this won‚Äôt automatically clean up anything created in a `before :all` or `before :suite` hooks, like most dbcleaner configs I‚Äôve come across will, so you‚Äôll just have to remember to clean up that stuff in the corresponding after hook if you are doing that.
I didn't get any error message on running rbenv install it successfully installed Ruby on my machine, but rbenv init is the on still creating problems. I still get the same message on running init which is: # Load rbenv automatically by appending # the following to ~/.zshrc: eval "$(rbenv init -)" 
I would say keep it simple. 1. Deadlock issue might be related to wrongly setting up the concurrency. Try to find this out. 2. The workers pipeline approach seems the most straightforward given your knowledge, the thing you will have to take care is that if one of the intermediate processes fails then you have to abort the process or either have a sort of recovery strategy. sidekiq-batch or Rocket Job (http://rocketjob.io/) might be helpful. 3. Another system for this seems to be an overkill, if you don't have experience in another technology then that's going to take way too much time.
My last project involved working with doorkeeper. I am a rails dev who has been working with ruby and rails for quite a while now. Feel free to PM me at /u/enry_straker
I think Passenger was the fastest Rails server last time I checked, maybe give that one a try?
If Ruby needs a server where you have to pay thousands of dollars per year based on how much memory your servers have in production, staging, development and in Q/A, we have already lost this comparison.
We've started to run [ruby_audit](https://github.com/civisanalytics/ruby_audit) in addition to `bundler-audit`. It warns about vulnerabilities in ruby itself.
We've started to run [ruby_audit](https://github.com/civisanalytics/ruby_audit) in addition to `bundler-audit`. It warns about vulnerabilities in ruby itself.
Yes, as I wrote in orig. post i launched 3, then 4 workers in all cases. I'll try investigate ActiveRecord thread pool as suggested. Thanks for pointer. 
I'm aware details are required for definitive decision. I'll try to put them to some publishable shape and upload on gist. Just asked for a general knowledge if it is usual choke puma/gunicorn with 100 concurrent requests only.
Phusion **Passenger** is open source and **free**, but there is a commercial (paid) version - Phusion **Passenger** Enterprise - which provides more features as well as commercial support.
Hi! this sounds good, you mean on the provider side?
Puma should be the fastest.
Okay, then let me rephrase: If Ruby needs needs a commercial product costing thousand of dollars to be able to be fast and deploy without any downtime, Ruby have already lost this comparison. Most/all other languages gives you Zero-downtime Rolling Restarts for free.
I'd love to use RocketJob on stuff. But, its Mongo requirement is a killer. I already typically have Postgres, Redis, and often Cassandra or ElasticSearch. Adding yet another database to maintain ends up being the killing blow. 
PHP is hardly used by "the majority of the Internet." The *WWW*, maybe, but that's only because there are a lot of half-assed WordPress sites out there. If we're talking novel software, PHP is irrelevant. Java's probably bigger.
&gt; Just asked for a general knowledge if it is usual choke puma/gunicorn with 100 concurrent requests only. Just to clarify here: You're not testing 100 concurrent requests, you are testing 100 concurrent connections which wrk will use 16 threads to send requests on as fast as it can. The result will be many fewer concurrent requests, at least up to the point where you saturate the backend. wrk will basically do everything it can to kill the backend regardless of the settings. i.e. `wrk` isn't designed for modeling users, it's a throughput testing tool, what you're seeing is the saturation point/behavior of each backend which in most cases is tunable. So a better way to approach this problem is to start with a low concurrency setting for `wrk`, and slowly turn it up recording the req/sec numbers, at some point you'll find the req/sec number will likely start to drop as concurrency goes up. The peak req/sec number for each framework is what you want to use for a performance comparison, once past the peak you can decide how you want to deal with the backend being saturated and in some cases can tune settings to push the peak higher. As a side note: You haven't mentioned what hardware this is running on but you usually want to set the `wrk` thread count to the number of physical cores on the box running it (and it's usually not a good idea to run it on the same box with the server). You can tune the number of connections to generate the desired load.
What a weird response. The comparison was PHP VS Ruby on Rails Web based performance. No, no one is making e-mail servers in PHP because it's not designed for that - neither are they in Ruby on Rails. Wordpress is only but one CMS and it does not make up the majority of PHP based websites. For major sites PHP is used by Facebook, Yahoo, Some parts of Google, Imgur, Wikipedia, Mailchimp, Tumblr, Flickr and many others. Sure a lot of sites are built in Wordpress but so what? Whilst Java is the dominant language in the mobile sector, you only generally see it at big corporates using it for web applications. 
Is it worth for you to consider Crystal programming like Amber for better performance and lower memory? What I see the benefits of Crystal as a microservices which you can split up different features and reduce technical debts.
`[1,2,3].inject{|a,i| a*10 + i} ` `#=&gt; 123 `
I have done both backend and frontend oauth integration, what do you mean "provider side"?
ah, ty, this looks similar to my solution, i used Array#each_with_index and first did Array#reverse on my integer array in order to based the powers of 10 on the index. above is nice though, ty!
I dont think you understand any of it.
very nice, ty, plan to save that.
&gt; Ive been able to run a Rails app with 10k daily page views on 1 of the cheaper Heroku dynos with Fastly. 10k views a day is less than one request every 10 seconds, you could host that on a raspberry pi.
PHP is used by 80% of the internet. Wordpress is used by only 27%. [Source](https://www.whoishostingthis.com/compare/wordpress/stats/)
Enlighten me, please. PHP knocks Ruby out of the park out of the box, supports zero-downtime deploys, and is free.
True, but that 27% accounts for the 20% that do *not* use PHP. And there is no "framework" that is used *more* than Wordpress, even though combined others are used more than it, so it does have the most influence. 
I agree it's the most used single CMS, it's not the majority of PHP websites however. As for frameworks I would imagine Zend or Laravel are the most used frameworks
I don't understand why people think that benchmarking trivial things like this has any relevance to production use w/a real world app. Rails is good/fast/low-cost enough for Github, Basecamp, Cookpad, Zendesk, Apple, Netflix, Intercom, and more. It's fast enough for any CMS project.
&gt;a.zip(b).map { |arr| arr.transpose.map { |x,y| x \* y } } Yes! that's exactly what I wanted, thank you!
well I would like to turn the app in question into an oauth2 provider - so it would act as "google" or "facebook" when you click 'login with facebook' using oauth2 - does this make sense?
$0.50 u/tippr
u/cavinkwon, you've received `0.00084447 BCH ($0.5 USD)`! *** [^^How to use](https://np.reddit.com/r/tippr/wiki/index) ^^| [^^What is Bitcoin Cash?](https://bitcoincashers.org/) ^^| [^^Who accepts it?](https://acceptbitcoin.cash) ^^| ^^r/tippr ^(Bitcoin Cash is what Bitcoin should be. Ask about it on r/btc)
Varnish is still amazing, though, as long as you have a lot of anonymous users.
I don‚Äôt think OP mentioned anything about being worth a six figure salary
As does ruby. There is nothing language specific about your comment. 
No, it does not. Then why did op say you needed to use Passenger?
They meant the open source, free version of passenger. Apart from that there is also, for instance, puma. 
Sure. Let me know what a good time for you is. I am usually available between 10 AM till 1 PM and again from 2 PM till 6 PM. NOTE: - i am currently based in India so i am in timezone GMT +5.5. You mentioned Max Planck Institute, Berlin - which is GMT +1 ie a 4.5 hour difference between your timezone and mine. I would basically need the following information 1) Background of the project (so i can understand what has been done so far and what needs to be done in the future) 2) What the goal of this phase is? ie is it just conversion to an oauth2 provider? What specifically does that entail etc 3) What your timelines are (ie staged delivery dates/Milestones etc) 4) What your budget is for this phase? 5) What specific changes you need made in DoorKeeper (assuming we fork it for our custom requirements) ie any requirements document or rough list of desirable changes. 6) Version of the Ruby and Rails codebase used currently. ( You had mentioned Rails 5. Is it 5.1 or 5.2 etc) 7) Sample client security requirements etc ( I would be using them as test cases for the above scenario. ie i would be building both minitest or rspec tests and also using existing applications as clients for manual testing too) 8) Ideally i would like to know about your background a bit - and you should get to know my background too. I would estimate the initial call to take between 30 to 60 minutes, so budget your time accordingly. Bye for now...
Hi Enry, This sounds good to me, I can certainly provide you with most of this info during our call - Would monday at 16:30 indian time work for you? this would be 12:00 for me if I'm not mistaken. In the meanwhile, here's a little bit more info: 1) we are building a middleware solution to connect resource providers who own textual resources and make them available in an unified manner through a json api to researchers using research tools, who connect to our own API. 2) The goal is to allow people to connect to our middleware's auth / authorization mechanism easily when they are using a research tool so that the research tool can make authenticated calls to our API. We already have users, organisations, providers, etc in our domain model, and use devise for auth. we use the consul gem for authorization, and at the moment our api is protected by a simple token-in-request-header mechanism, which we would ideally like to replace. 3) We would ideally like to get the oauth2 provider stuff ready for jan, as we are still in the dev phase but would like to launch around march of next year. 4) We have around 5k available for this work package, but can probably get a little bit more based on your estimation... 5) we would like to, if possible, have our own 'authorised applications' interface, which would ideally be based around the activerecord model of 'research tools' we have already implemented - this is not a must however and we can also consider making doorkeeper authorised applications 'research tools', whatever is cleaner/ makes more sense... 6) we are using rails 5.2.1 7) sorry I am not sure what you mean by this 8) I'm mostly a web dev, with stints as a CTO, team lead, etc - my website at www.belouin.com has a little bit more info about me! Hope this gives you a bit more background, I hope to talk to you soon! cheers, pascal 
The page objects are a neat idea. I've accumulated a bunch of shared examples/contexts (originally thought to be glorified setup blocks), where similar behaviour started to creep in. Time to refactor those out in page objects :-)
Cool. If you have any other ideas on how to organize something better please share :)
 ~/code/elisp &gt;ruby def str2int(s) s.chars.each_with_index.inject(0) { |t, (chr, i)| t + (chr.ord - "0".ord) * 10 ** ((s.size - 1 - i)) } end while s = gets puts [i = str2int(s.chomp), i.class] end ^D 0 Fixnum 999 999 Fixnum 123123 123123 Fixnum
What framework was your PHP code using?
Thank you for your insights.
You're welcome
CMS charity project.... you‚Äôre not gonna be pegging the rev limiter on any of these technologies. Your traffic won‚Äôt get that big. It doesn‚Äôt matter. Optimize for your own developer speed and happiness and the best ecosystem for what you‚Äôre building. 
Easy solution in 4 characters, use eval: irb(main):001:0&gt; eval("311") =&gt; 311 If you're really scared of eval for some reason, you can filter the string to only have digits: irb(main):002:0&gt; eval("evil string 311".gsub(/[^\d+]/,'')) =&gt; 311
üëç we do this as well and it's great. Another cool trick is to define derived meta data and lazy load deps using `when_first_matching_example_defined` to keep the suite running fast for simple specs
it's just slow, although interestingly enough, i guess it's faster with the gsub after it warms up: Benchmark.ips do |x| x.report { "123".to_i } x.report { "123".each_char.map { |c| case c; when '1' then 1; when '2' then 2; when '3' then 3; end; }.reduce(0) { |a, i| a * 10 + i } } x.report { eval("123") } x.report { eval("123".gsub(/[^\d+]/,'')) } end Warming up -------------------------------------- 261.604k i/100ms 53.137k i/100ms 22.628k i/100ms 19.692k i/100ms Calculating ------------------------------------- 6.398M (¬± 3.6%) i/s - 32.177M in 5.035615s 633.358k (¬± 9.8%) i/s - 3.135M in 5.005581s 209.215k (¬±17.4%) i/s - 1.018M in 5.033528s 212.105k (¬± 7.2%) i/s - 1.063M in 5.040902s &amp;#x200B;
Of course it is slow, everything other than "to_i" a terrible idea with regards to performance.
definitely, but \`eval\` is about as slow as you can get 
What is the impact of this on Rails? Is this only a problem is I'm de-serializing data using Marshal? 
Hi pascal, This sounds good to me. &gt; Would monday at 16:30 indian time work for &gt; you? this would be 12:00 for me if I'm not &gt; mistaken. Yup. That time works for me. Shall be online then. &gt; 1) we are building a middleware solution to &gt; connect resource providers who own textual &gt; resources and make them available in an &gt; unified manner through a json api to &gt; researchers using research tools, who connect &gt; to our own API. Something like an online marketplace for researchers to either publish or subscribe from each other - from an API perspective. &gt; 2) The goal is to allow people to connect to our &gt; middleware's auth / authorization mechanism &gt; easily when they are using a research tool so &gt; that the research tool can make authenticated &gt; calls to our API. Which research tool is being used. I assume that different researchers will be using different languages and tools and that the APIs would be both discoverable and documented through something like swagger? &gt; We already have users, organisations, &gt; providers, etc in our domain model, and use &gt; devise for auth. Good. Guess devise is a de facto standard in the rails community by now. Just glad that people didn't try to spin their own authentication mechanism - though rails provides plenty of support for it. &gt; we use the consul gem for authorization, and &gt; at the moment our api is protected by a simple &gt; token-in-request-header mechanism, which we &gt; would ideally like to replace. Consider it done. That's where i come in :-) &gt; 3) We would ideally like to get the oauth2 &gt; provider stuff ready for jan, as we are still in &gt; the dev phase but would like to launch around &gt; march of next year. I really can't make any estimate at this time. But a custom Oauth provider is key to this architecture and that implies lots of both unit and integration tests to accompany the codebase at a minimum. &gt; 4) We have around 5k available for this work &gt; package, but can probably get a little bit more &gt; based on your estimation... Hmmm...Shall add it under the "To be discussed" category. &gt; 5) we would like to, if possible, have our own &gt; 'authorised applications' interface, which would &gt; ideally be based around the activerecord model &gt; of 'research tools' we have already &gt; implemented - this is not a must however &gt; and we can also consider making doorkeeper &gt; authorised applications 'research tools', &gt; whatever is cleaner/ makes more sense... Shall keep it in the "Good to have but not critical" category for the first release. The key to early releases is mainly core stability and user acceptance. Things like custom UIs can always be added in later releases. &gt; 6) we are using rails 5.2.1 That's good. No need to worry about backwards compatibility right from the start. &gt; 7) sorry I am not sure what you mean by this Don't remember my point 7, but shall look it up and if it's important, we can discuss it during the call. &gt; 8) I'm mostly a web dev, with stints as a CTO, &gt; team lead, etc - my website at &gt; www.belouin.com has a little bit more &gt; info about me! I am an old time programmer. Been working in this industry from the early 90's. My linkedin Profile will give you some more background though [LinkedIn Profile](www.linkedin.com/in/rajashaker ) &gt; Hope this gives you a bit more background, &gt; I hope to talk to you soon! It does, and i look forward too. Cheers, raj
&gt;Is this only a problem is I'm de-serializing data using Marshal? Yes. And it has been know for ages that unmarshalling untrusted data is a bad idea. The novel thing is they made a compact universal gadget chain, meaning it doesn't rely on any non-default libraries or gems.
Just looked up point 7. That's rather important. It basically means, i would be using the same or similar research tools that your users would to manually test the setup on a regular basis - since it's key that the overall solution fits in easily with your customer base's existing workflow.
i installed the gem file but this eror repeats
A alternative I've been using that works on Ruby 2.x: http://egonschiele.github.io/contracts.ruby/ Has better syntax imho too and allows method overloading: Contract Contracts::Num, Contracts::Num =&gt; Contracts::Num def add(a, b) a + b end Contract Contracts::String, Contracts::String =&gt; Contracts::String def add(a, b) a + " and " + b end add(2, 4) # 6 add("2", "4") # 2 and 4 add(Object.new, Object.new) # Exception
The code is parsing `foo.method!(x, y)`. The resulting AST contains a scope (1), a method call (2) and a "left hand side" (3) which you need to unpack before having access to the variable name. I find it pretty straightforward actually.
How much mature is this? Do you advise it for production?
I don't use it in production but plan too. I did not encounter any issues with it and its 6 years in active development.
Exactly! But the point of this new runtime exception is to catch errors as early as possible in a call stack. I want to find the exact place where wrong type appeared, so I can fix it quickly by looking at exception in error monitoring system. I hate when nil appears 15 methods up the stack, and I have no idea where it came from, and also the exception itself can be very different from NoMethodError. This makes debugging some exceptions very tricky. With type assertions it's clear where exactly the problem is
This is something I've needed to do -- the problem is that the example shown here has some security problems. If a user includes `host` or `scheme` in their URL params, then those will end up given to url_for, and change the URLs on your page. In some cases they may able to access/execute things they ought not to be -- url_for isn't necessarily secure against user-submitted input. Rails actually made it harder to just re-use `params` because of these security problems. But then it continued to evolve from there, the error message you got less clear, etc. And they never clearly delineated how to do it in a _secure_ way -- apparently they aren't concerned about the use case? Here's some more info: https://github.com/rails/rails/issues/26289 https://github.com/rails/rails/pull/20797 At one point I started figuring it out, and there were some not so widely known Rails methods that were helpful, but I never totally got it smooth. I was hoping this screencast would have figured it out, but nope. The example here may not be a very good thing to recommend, I believe it has some security issues. 
I did not find such a tool yet. Both gems also download the same vulnerabilities db.
I've always used S3, but I've also heard good things about Google Cloud Storage. At the end of the day I'd keep things in one place so if you're already using one or the other probably just stick with it.
Since the vulnerability db is a gem, I don't think they'll download it twice? They'll both use the gem installed in the system.... maybe. Perhaps someone should PR an improvement to one tool or the other for a command-line switch to do both. Ruby-audit already includes [bundler-audit](https://github.com/civisanalytics/ruby_audit/blob/master/ruby_audit.gemspec#L25) as a dependency, so it might make sense for it to be able to do both. Alternately, ruby-audit's functionality should probably just be included in bundler-audit? Although I guess ruby-audit intends to be usable on products without bundler. One way or another, I think making the "developer UX" of using these tools as simple and brainless as possible is the key to impact. 
I thought the whole point of Duck Typing was that ultimately you don't care about type. If I have a variable that I think is an array, and it provides an `.each` method, then I don't really care that it's actually `SomeSpecialNotArrayTypeThatActsLikeAnArray` class (ok, rubocop might complain about that one...). By enforcing strong typing you essentially lose all of the benefits of duck typing and essentially add another point of failure. While I certainly take your point about "no method each for Nil class" errors, does this really fix it and is the trade-off worth it? What about generic functions? Or do I now need to implement `add_one_int`, `add_one_float`, `add_one_dbl` (or implement a bunch of `interfaces {}` which completely defeat the purpose of strong typing)
Usually if a need array-like class it would be Enumerable, and I can assert Enumerable type, which acts like interface in other languages. But really, the main pain I'm trying to eliminate - nils. They pop up all the time in unexpected places, deep down in the call stack and often times the exception is not "NoMethodError for nil", but something crazy caused by nil in unexpected place (\`URI.parse(nil)\`, for example). Also, there is another reason besides weird runtime errors: readability. By putting type "annotation" you describe the interface better. In large code base I often find myself in a situation "ok, here is a class with a bunch of methods with a bunch of arguments, but what the hell each argument means?". Strong types provide more info about interface to teammates. You can certainly have generic functions, just assert multiple types they can accept. You don't need generic function for every possible class in the world. But even if you do - no problem, don't use type assertion. Or use interface assertion proposed by a colleague [https://github.com/olegantonyan/typerb/pull/2](https://github.com/olegantonyan/typerb/pull/2) to check \`respond\_to?\`. It's not invasive, not every method requires type assertion. I usually write \`raise TypeError unless argument.is\_a?(Whatever)\` in a constructor and don't bother with other methods. This helps a lot with debugging errors, and also improves readability.
Duck typing is overrated - all large codebase I‚Äôve seen have eschewed it in favor of proper structural typing or nominal typing checked statically or on function invitation 
Yeah, you would want to have a whitelist of allowed params. I didn't cover it in the episode, but you could simply make a helper method with those allowed certain params. def current_page_params request.params.slice("query", "filter", "sort") end &lt;%= link_to "with foo", current_page_params.merge(foo: true) %&gt;
Also if you want to be sneaky as well, instead of a case statement you can use: char.ord-'0'.ord but you'd have to validate that it's a number first.
&gt;as is not enforcing using $PORT (it's especially silly when I'm using a unix socket to communicate) Yes, I remember I had problem with exported Foreman service and Sinatra + Puma server process. Puma will never switch to the sockets communication (even if it's properly configured in the \`config/puma.rb\`) if there is $PORT env variable available. Puma will use $PORT no matter what.
sweet, interesting. Ruby's got all kinds of tricks. thanks!
I'm simple man. I see conf video by Sandi Metz, I upvote
Hey guys, I wrote this little gem to make my life a bit easier and thought maybe you guys would like to use it as well. Let me know what you think!
I'd rather see more tech and less psychology in a keynote for a language but I guess.....
Right on. Your example actually specifically and intentionally worked around rails strongparams trying to prevent you from doing what you did with `request.params`. Thanks for the update. 
Psychology is really important to software development, because our ability to work as a cohesive team often times defines our success... but we tend to suck at it. I really like that talks like this are a thing. 
 I don;t know that its a thing. Never seen a keynote in any other language on that subject. I'm thinking because theres more updates and features which Ruby seems to be pretty slow with.
I always find it nice when people include links in their readme to external software used/neccessary for the project.
Except that the language is pretty meaningless without people to use it to develop products for other people to use, and how those people interact, define their needs and wants, and express whether a product is good or not, are all strongly linked to psychology. In close to 40 years, I've seen a huge difference between the "all that matters is code" guys and the people working on solving problems with code, and it's the latter group that always aren't just better people, but have the more useful (i.e., genuinely interesting) technical bits to pass around.
Will be curious to see where it goes from here. They've gone from "don't benchmark this" to "1.7x faster on this one benchmark" since May, so I wonder what'll happen when they optimise for Railsy things.
Sell software keys and have it phone home maybe? In my experience, Ruby, Python, et al don't have good distribution stories for end user software.
The best way to secure your ruby product is having a good lawyer write the terms of the contract so you can sue them into oblivion if they try and redistribute your product. GitHub Enterprise is obfuscated but the real security is in the legal terms 
You‚Äôll need a license server and a proper contract so when people redistribute they will be breaking the contract and you can civilly sue them. 
Thanks for the feedback. Will do it!
Can you port it to Crystal?
The one time I felt the need to do that (for a webapp), I was satisfied with building it as a precompiled .war with jruby and warbler.
I'm not saying its of no importance. Its just not keynote material in any other language conference. its a separate workshop. Plus in my own decades of experience teams that have issues of communication and conflicting desires and motivations are NEVER fixed by one speech. That requires an ongoing program. I'd be thrilled to have her working with team over a quarter. not so much a keynote.
&gt;Python is fairly easy in that regard and also has much of the readability people like about ruby. Thats quite true and I agree with your suggestion of Python but for different reasons. - wider use language. Its more motivating to keep going to learn a language used in real life to do more things.
I find your remark insufficiently persuasive. 
Your remark was DEFINITELY insufficiently persuasive 
Check out https://keygen.sh/
Check out https://keygen.sh/
Does it need to be their equipment, or just on-premise? Do they need administration access into the equipment? Remember that if they really want to, they can remove your license checks; things like GH enterprise are obfuscated mostly to keep prying sys devs away from making "minor tweaks" to the code that make support calls hell. 
Hi! To get some inspiration, you can check out the following layers of Spacemacs. Even if you use vanilla Emacs, it can give you an idea of how to put things together. * [ruby-mode](https://github.com/syl20bnr/spacemacs/tree/develop/layers/+lang/ruby) * [ruby-on-rails-mode](https://github.com/syl20bnr/spacemacs/tree/develop/layers/%2Bframeworks/ruby-on-rails)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [syl20bnr/spacemacs/.../**ruby-on-rails** (develop ‚Üí a3cac69)](https://github.com/syl20bnr/spacemacs/tree/a3cac69fb4bb20cb854ce83451f25e44f5190464/layers/%2Bframeworks/ruby-on-rails) * [syl20bnr/spacemacs/.../**ruby** (develop ‚Üí a3cac69)](https://github.com/syl20bnr/spacemacs/tree/a3cac69fb4bb20cb854ce83451f25e44f5190464/layers/+lang/ruby) ---- 
Try bbatsov‚Äôs prelude. It‚Äôs got company mode for completion, rspec mode for tests, abunch of other Ruby goodness, and tons of other general goodness. Spacemacs is also an excellent place to start. I have a colleague who uses it in holy mode (not via bindings) just for all of the sharp edges it rounds off. 
Here's part of my emacs config: init-ruby-mode.el https://github.com/erickj/emacs.d/blob/master/lisp/init-ruby-mode.el
wow, thank you, very interesting. 
&gt; In dynamic typization, type validation is performed during the execution &gt; of the program, and not during compilation. I do not think ruby uses "type validation". That actually defeats one point of duck typing - that is, to not have to care about what "type" something is IF it is not necessary. (People often forget the second part and think that duck typing must apply to everything at all times.) I mean the whole term "during compilation" is wrong to begin with because... there isn't much you compile in a normal .rb file right? Unless you use some wrapper to some C/C++ code or something like that. Or perhaps some other means to compile code - but these cases are less common than just having code reside in .rb files. Without any compilation. &gt; Metaprogramming allows you to create software code and libraries that &gt; other developers can reuse and easily customize according to the needs &gt; and tasks to solve. And you can write code that others can reuse and customize without metaprogramming too. So that is not a distinguishing characteristic. &gt; Going into metaprogramming, developers can create DSL - &gt; Domain-Specific Languages ‚Äã‚Äãfor solving complex tasks within &gt; specific industries. To be honest ... since it depends on a definition ... I use "meta" programming sparingly; usually just to autogenerate some code; or to add/remove methods to certain objects (a good example is a config-object that stores configuration, a bit like struct/openstruct does, where it will feed back what configuration is active on the end-user side). &gt; In the Ruby ecosystem, the standards of writing and &gt; structuring codeare approved by the global community &gt; of devs and recorded in the Ruby style guide. (Rails &gt; style guide is approved as well). TOTAL and UTTER ********. Bogus. Please do not believe whatever any random person writes on the www. There is one ultimate authority - and that is the ruby parser. Everything else is up to whoever wrote the guide(s) at hand. In the case of the former, I assume that he must refer to the default guide enforced by rubocop. But rubocop is not the ruby parser. &gt; Also, Ruby pays much attention to checking how the code &gt; conforms to the norms and standards (RuboCop, &gt; SimpleCov, RubyCritic, Rails_best_practices). Is that so? I have been using ruby since about ... 15 years and I never need an arbitrary random "style guide" to know how to write code. That is not to say that everything written in a style guide is crap. A lot of it is perfectly fine. A lot of it is totally bogus too, though. I guess the only useful part of that article may be the list of links provided at the bottom ...
Now come on dude - if you want a full JIT comparison then wait until the JIT has been properly optimized AND make meaningful benchmarks such as those that will be used for optcarrot. To quote a random twitter statement is bogus as-is.
First, the JIT that we see right now is not the JIT that will eventually be the one that that we will use in e. g. ruby 3.x Second, you can be sure that the main author but also the other core devs will work to optimize on JIT-optimizable parts. Third, we already know that the JIT works - not just from other languages but also because that ... dude whose name I forgot... Vlad something, Red Hat dude, had another JIT and that JIT led to a much faster code execution (but had other problems such as maintenability). Fourth, as matz said - not every code base will benefit equally; and some may even run slower (at the least initially but perhaps some projects may not benefit from the JIT). I think people ought to be patient and wait and see. The JIT has not been around for a long time. I am sure there will also be thorough documentation eventually as to what people can expect, just in order to avoid those "omg omg omg it runs slower omg omg omg" on twitter comments.
The goal was for ruby 3.x to be 3x as fast as ruby 2.x. I do not know the present status but that goal was almost already achieved the last time I looked (some months ago). So it is likely that ruby 3.x will indeed be more than 3x as fast as ruby 2.0 was. How much JIT can improve on top of that for SOME projects remains to be seen. Rails is not trivial - it will be easier to see improvements for other projects. And I am sure that this will also be mentioned in upcoming benchmarks - folks have to be more patient really.
&gt; How long would you say it takes like a week or two to fully learn it? People are different so this is hard to say. I am a slow learner so I need at the least a full month to really grasp most concepts of a language - if the language is simple. I think the only advice I could give is to simply write a LOT of code. To me this was always the best method by far. Also make your code available to others - this helps in many ways too. Try to document or keep notes a bit here and there too; that may help in the long run as well. The pickaxe also helped the first time I read it. It was quite simple to understand.
I don't use Spacemacs but these look very comprehensive, I should be able to get them working with vanilla Emacs
&gt; think whitespace requirements help instill good habits That is absolutely bogus. I give you an example: - In perl we need to use ";" to terminate statements. I often forgot it accidentally. In ruby I don't have to worry about this. This has NOTHING to do with "good habits" - this is simply because the parser is too stupid to figure out the intent (in perl). No amount how awesome my habits are - the worse language means that it will hinder me more than it will help, as compared to other languages. &gt; do think that both python and ruby offer some niceties in terms of easy &gt; to read syntax that make it easier to work with than Java or C for starting. Dude ... Kotlin? For Java? I mean, is there any comparison? Both Java and C have a lot more syntax than ruby and python. And C in particular is not a trivial language. Try to write kernel code that Linus accepts; try to patch gcc and glibc. Write something where you have to handle memory leaks. These were reasons why Rust was created (to some extent; Rust is more aiming at C++). &gt; Java was my first language, followed by python and C Yeah - it probably ruined you. I guess you still think in terms of OOP like Java taught you. Right? Ruby follows a model much closer to smalltalk. &gt; I'm wandering what about the whitespace requirements you think &gt; is god aweful? I can not speak for him, but I hate it whenever I copy/paste code into the interactive python instance and it tells me "bla bla indent is wrong bla bla". But the bigger issue is the philosophy. WHY should a programming language HAVE to care about indent? Why is that necessary? Since you defend whitespace, remember - guido said that if he were to change one thing about python, he'd get rid of the whitespace kludge. &gt; to require blocks of code have the same indentstion and for &gt; line continuation to also be indented? I can indent fine without the parser telling me that my code does not work. I do not WANT to have the parser refusing to run because of an additional layer of useless complexity. &gt; Pep8 has some requirements beyond that which can be annoying &gt; but adhering to pep8 standards is not required to actually run python. PEPs are one thing - the parser is something else. Because if the parser (or lexer or scanner or whatever) rejects the input stream there really is not much that can be done. I'd actually like to have full control over the ruby parser too to modify it as I want to. :) For distributing my own code, though, I am super-conservative and default to "standard" ruby - aka the latest stable version. I do not even duck patch core classes simply because I don't want to burden other people with MY own modifications that I made to core classes. But the functionality of duck patching is great (a few call it "monkey" patching but ruby is all about the ducklings rather than the monkeys.) 
Yes that is true. But I think this is partially because python originated from another area. A bit what guido used to use. It has another OOP model compared to ruby. The ruby OOP model is much easier on my brain. I can't easily wrap my brain around list comprehensions. .map and .each on the other hand are SO MUCH EASIER on my brain.
That is not about learning, though. The code WILL NOT RUN with the "wrong" indent level. Why does a programming language need this?
That is fine. I have been in two python courses as well. Has been a lot of fun - not so much because of python but because of the other people there. :) Python is the go-to language for most of the non-professional developers. These are the people who will never really learn C, C++ or Java - or even if they do, they may prefer to use e. g. Python. Or Ruby. Because these languages are a LOT simpler.
Exactly. And there are common use cases where one variant is better. For example ".each" is superior to "for" in almost every case; but I also found "for" to be somewhat useful when you are dealing with matrices, filling them up etc...
I agree that there is some merit for using python over ruby - momentum is a good reason. I do not agree on your second part though - I use ruby for literally everything, including the www but without rails. I never understood the "limitation" that people attributed to ruby. I use ruby to compile everything from source on Linux. It works very well. Others do so with their own scripts too, like homebrew (on mac; though there is some linux port).
What if we decided to eschew large codebases, instead? :-)
what area did guido come from?
I would be much more productive in my smaller codebase as well, with some form of static type checking :) 
Most languages I've used require you use parenthesis in function calls. A lot of your frustration seems to be around that. Also J never said it is more readable than ruby, simply that it is closer to the readability of ruby, which also to me means generally more than most other programming languages. 
A lot of begginer content is important to make it easier to find tools and tutorials while getting started. So my argument for whitespace in python is mostly one of learning. I have seen some really unreadable code while working in tutoring labs. Code so unreadable the people who wrote it couldn't find bugs. A lot of this happened because people screw up whitepace and make it harder to find what is s block and what isn't. Python forces better habits around this and force you to learn to pay more attention to this which can save you a lot of time downtown the kine. Sure maybe it's a shortcoming of the language parser, in practical terms when I've worked in python it has been a non issue. I honestly don't think starting in Java has ruined me, maybe it has or did others, but I spend a lot of time writing functional code as well as OOP and some procedural stuff where it makes sense. Out of all languages I've use Java is probably my least favorite. My problem with Ruby as a learning language is that a lot of concepts in ruby don't apply to other languages. Yes I much prefer .each loops to a for in but if that is what you learned iterating over an array in Java or C will be a lot harder. Learning .each loops is easy though. Similarly implicit returns are uncommon, and then when I say 'a lot of ways to do things' I mean things like checking .nil? Vs .present? What about unless vs if, Etc. Python generally has a simple one way to do things, which IMO makes it easier, IMO to learn and move through concepts of getting bogged down in what syntax to use where.
So exec out to vim?
agree, the tweet belongs to the guy from sidekiq :)
It might be a better idea to ask on the dragonfly subreddit and mailing list if you already haven't. I know they maintain rbenv in dports/avalon, so I'd approach it from that angle and ask about ruby-build support in rbenv.
I've run rails on freebsd for 10 years just fine, though i use rvm. are you forced to use dragonfly? does dragonfly have the ports system?
I have not seriously tried BSD + ruby, mostly because I am using linux and linux is the better BSD. (I am serious about this comment too; top 500 supercomputers running linux speaks for itself.) To the topic of rbenv though - I never understood the need. There are distributions such as GoboLinux that show that you can use AppDir versions for programs. And this is what I am doing with ruby too. For example, right now I have two ruby versions: /Programs/Ruby/2.5.3/ /Programs/Ruby/2.6.0-preview3/ In the past I had more ruby versions but I only use the latest stable these days. When I need to switch, I set a symlink called "Current" through a script that changes the active version. So this is a bit like a "version manager" - except that I can do so for all programs. (It does not work for all programs since some require hardcoded paths and assume /usr/ hierarchy embedded in the binary. But for ruby this approach works 100% and I have been using it since like 13 years or longer.) So when you write "I must use a version manager", nope, sorry - you do not have to do so. You can manage your ruby version fine. I do so too and I can change the version at any moment in time. As to why BSD fails at rdoc, I think you should file a bug at: https://bugs.ruby-lang.org/projects/ruby-trunk The core team will try to make things work, if you can give a detailed description. I personally skip rdoc generation anyway since it takes time and gives me nothing I use (I either use online search for new information; or look at my local knowledge base, which I update every now and then. I hate rdoc.)
the world has clearly gone mad. That's what i think about checkins like this. Or when they changed the name to factory bot. Not that I liked the name factory girl in particular. Somewhat related thought: unfortunately too many people are into software, and with popularity it has lost its niche, it's not engineering or science any more. It's a controlled typing governed by management. And that being the trend this or similar thing will become more frequent.
That would be great, but for some reason nobody wants to pay for "hello world" ;) Any successful software business would have large enough codebase, with a lot of bad decisions, hotfixes, etc. They pay us to deal with imperfection. btw, microservices don't count, no arguing :)
Sure, you don't _need_ a version manager. You just need to do some manual configuration that most people will never have to do and probably doesn't work similarly across distros, hope your distro has the ruby you want in it's sources (or that their build tools support your configuration), and write some scripts to either manage your PATH or some symlinks so that you have the version of ruby you wanted. Or you can install RVM/rbenv and all of that shit is handled for you (plus other stuff you may or may not find useful). Your choice.
I honestly don't understand why we should care, or why you want us to. 
The change seems pretty meaningless and inconsequential. The _motivation_ for the change, on the other hand, seems part of a recent ideological trend that projects some sort of US-centric view on which everything is possibly offensive, such as OP's example with master-slave or white/black-listing. I think it's a pretty toxic and fruitless mindset, and even acknowleding this seems to be pretty fruitless as well. But there seems to be no escape from it. 
Every unnecessary change is bad, and there is no inconsequential change in software. Two years from now I guarantee someone will have a merge conflict because of this. And the more unnecessary change is in the harder it gets. Every change makes it just a little bit harder.
As a VI guy... I can only say... /FlamewarOn!! 
I tend not to do the 'file per library' thing with rspec setup anymore, I only organize into a separate file when the configuration is large, e.g. Capybara. The reason is that when you actually care about the support is usually when upgrading libraries and something goes wrong, it's almost impossible to figure out what is actually happening and when it's happening with something like `Dir[Rails.root.join('spec/support/**/*.rb')].each { |f| require f }` pulling in dozens of files and an unknown order. You end up trolling through dozens of 5 line files instead of just looking at a single ~100 line config block. 
I use Ruby &amp; Emacs just fine. I'd say it's probably a step or two below RubyMine, but nothing beats RubyMine so Emacs does a pretty good job in my book. Plus, RubyMine lacks all the features and goodness of Emacs ;) Here are a few packages I recommend: - [bundler](https://github.com/endofunky/bundler.el) - [rinari](https://github.com/eschulte/rinari) - [ruby-hash-syntax](https://github.com/purcell/ruby-hash-syntax) - [rvm](https://github.com/senny/rvm.el) - [rsense](https://github.com/m2ym/rsense) - [robe](https://github.com/dgutov/robe) - [inf-ruby](https://github.com/nonsequitur/inf-ruby) - [quickrun](https://github.com/syohex/emacs-quickrun) There are many more packages I have which makes coding Ruby in Emacs a joy. I also have *many* customizations for these packages which make them *much* more palatable than their default configurations. Honestly, though, if I posted it here there would be hundreds of lines so I'm happy to PM you whatever you want. I've got key bindings, custom functions, settings, and much more. If you'd like to know something for a specific package like robe, I might be able to post it here. Just let me know. The moral of the story is: coding Ruby in Emacs *is* fun, as long as you have the right packages and the right customizations!
The 'code of conduct' fad is marxist cancer - anti-white, anti-male, anti-meritocratic.
[Doom Emacs](https://github.com/hlissner/doom-emacs/tree/develop?files=1) has out-of-box support for Ruby with Vi key movements (or not if you don't want it). 
The OP is for sur trolling, but it appears the term ‚Äúblacklist‚Äù has origins in government-mandated social exclusion and rights deprivation. Not a friendly word. 
What I think is toxic, dangerous, and fruitless is the ideology that motivates trying to turn trivial and relatively inconsequential actions into controversies not just despite but _because_ they were (presumably) taken to try to be more welcoming or less uncomfortable, as if that's a bad thing. 
Prepare for flame war!!! Seriously, though, as a vim user, get a good .vimrc setup and you‚Äôre good to go.
Both work well with ruby having standard IDE functionality, it's not so much "best plugin" as how you customise each to suit how you work. Maybe not the answer you want Vim is "just" an editor whereas emacs can be your only app doing browsing, git &amp; mail from within. It's down to what suits you. &amp;#x200B;
How about stability of things like viewing variable contents, indentation lines, and intellisense? Git and browsing aren't that important since I have multiple terminals and a file browser open anyways in my i3wm setup.
Please see this: https://www.reddit.com/r/ruby/comments/9vxo2l/ask_rruby_how_to_develop_ruby_with_emacs/ You'll notice some excellent tips and you DON'T HAVE TO CHOOSE BETWEEN EMACS &amp; VI(M) - since you can use [both](http://spacemacs.org/doc/DOCUMENTATION.html#editing-styles) via Emacs. If you DO want to be an Emacs purist, like many of us, then you can use "[Holy Mode](http://spacemacs.org/doc/DOCUMENTATION.html#emacs)" in Spacemacs, but you can stick with [Evil](http://spacemacs.org/doc/DOCUMENTATION.html#vim), which many people like. Or just use [Hybrid](http://spacemacs.org/doc/DOCUMENTATION.html#hybrid) mode.
stability? 
This is a use case I far prefer using an event listener pattern, preferably with some middleware to handle plumbing like event persistence/idempotency. This mechanism is easy to test, safe, and easy to debug in my experience.
This is *preeeetty* awful. Anyone who POSTs to your endpoint can exert control over what method gets called, in a kind of demented method call version of SQL injection. Instead of routing all your webhook calls to some generic `webhook` method, why not....route different endpoints for different services directly to the relevant `handle_` methods directly? Use a simple before filter to abstract out the basic json parsing stuff. Don‚Äôt reinvent to routing wheel. 
This is why I'll stick to binary, less insensitive, although wait a minute. They'd probably have a problem with that too. 
Great claim, any easy way to integrate this in rails and benchmark on heroku? 
Not the author, I saw this on a Ruby newsletter and post it as it doesn‚Äôt seems reddit had any previous discussions. Although I am not entire sure if Unicorn / Puma were ever the bottleneck though. But one thing Argoo do seems to be a lot better is memory usage. 
yawn. i couldn‚Äôt care less about codes of conduct. it‚Äôs seems like codifying common decency. but i have an even harder time understanding the insecurity that drives people to hate it. i say let‚Äôs use them as long as common decency is not so common. 
Scott, Thank you very much for the recommendation. Although this may seem like a good direction to consider for the future, I don't think we want or have the time and resources to convert the system to SOA at this time. Maybe when the team grows.
Oh, I do wrap the code around with Reloader/Executor. I don't believe the issue is with that. It is possible that there is some part of the code we've written that is simply not thread-safe, but it needs to be pinpointed. My relative inexperience, on the one hand, and the confusion about concurrency with Ruby, on the other, is giving me such a headache as I am trying to figure out what would be the best way to do concurrency with Ruby within a slightly complex (monolithic) system. And not just a simple a thread or two here and there.. I have been focusing on other things lately, leaving it execute sequentially for the time being, but I plan to go back to this, eventually, and give it another try.
Brilliantly ugly. I am glad matz won't add type uglification to ruby. I am not so much opposed to optional typing as such, but, boy - what a mess. What would be kind of cool would be if we could have two variants of ruby, though. One for the light weight aka the "scripted" variant - and one that is compiled, like crystal. The latter variant may then also be partially incompatible to ruby but could be compiled. Crystal sort of showed that it can be done. Unfortunately crystal is not ruby ... differences to ruby are slowly accruing if you have followed crystal for a while (but admittedly, the crystal team always said that syntax-compatibility is NOT a goal, so that's fair enough).
While I don't like typing, I think there is more than one way to verify on types. Different languages handles types differently too. Historically I think the strongest case for types is for languages that can be compiled. Ruby evidently does not fit that criterium.
That is totally bogus. People are super-productive without static type checking as well.
This is not so much a tip but I have found that one does not really need a whole lot to write ruby code productively. The main functionality I usually want is syntax highlighting in colour but even that is not s important. In the end I use ruby as my whole super "IDE". I'd even use ruby as interface to the whole OS but this is not so easy since most of my linux system is C/C++.
As far as I am aware, the core team has probably already agreed on `.:`, otherwise, I doubt @nobu would do that commit.
So you are arguing against dynamic type checkers in a post about dynamic type checkers? Please repeat the mantra of duck typing etc. but you won't make use cases go away where you need type checking.
What do you think about optional typing in Python https://docs.python.org/3/library/typing.html ? Is it ugly?
I like how it's done in Crystal. It has \`not\_nil!\` method
so now we have - puma - falcon - agoo
(Sorry for spamming! Second post in a day could be too much for /r/ruby, but the news are funny.)
That's actually pretty great, I don't follow the ruby commits or the Redmine so I quite like it. Good quality content right here.