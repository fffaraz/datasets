Since I just use Ruby for my own little projects, I've found 1.9.1RC1 to be stable, fast, and use less memory. So..."yes". If I had a company with software running on Ruby, then of course I wouldn't switch to a new version until it was nice and stable, with the bugs worked out.
Symbols are interned strings. Nothing more, nothing less. The benchmark examples are moderately flawed. example-9 does NOT create 10m new Symbol objects. It references a single Symbol object 10m times, whereas 10m new strings are created in the example. The obvious object construction cost skews the results. example-11 is similarly flawed; it creates 10m strings, 1 symbol, and doesn't turn off GC. Symbols are not magical 40% faster shiny happypills. They're just interned strings. Of course they carry the benefit of interned strings as you would expect them to, but they also carry the potential detriment of never being collected, so abuse of them leads to memory usage inflation in your app which cannot be recovered until the app is fully ended.
And here I was, expecting "wicked cool ruby scripts" when clicking on the link, only to be taken to a page which discusses a book which apparently has some "wicked cool ruby scripts" in it. This makes me a sad, sad panda :-/
I am surprised he didn't mention markaby which IMHO is even better than HAML because you can code up "widget" like things.
I was going to say "why the hell are there so many different gem packager packages?" but I see that this one is actually rather interesting, with its github angle.
or Erector, which is also a builder, but uses classes instead of template files. Here is his example translated to Erector or Markaby. html do [:representative, :junior_senator, :senior_senator].each do |legislator| div :id =&gt; "legislator" text legislator.to_header person = @legislators[legislator] text person.firstname text person.lastname span person.phone, :id =&gt; "phone end end 
I wish there were binaries :(
Do you have a link to erector. I hesitate googling that :)
Finally a Ruby Assembler that is packaged as a RubyGem. Most will know of metasm (which is packaged with Metasploit). Metasm is apparently very powerful, but lacks documentation and is not available on rubyforge. Also, metasm's developers are hard to contact.
I agree! I've been playing with shoes for a couple of months and it is really fun. Because you can come up with a whole lot of presentation with very little logic, I'm using it to teach my girlfriend to program. Two (very) small complaints: 1) Shoes doesn't have a built in IDE like processing. This makes it a little tricky for true beginners because you have to set them up with a reasonable environment. I use Scite and change the Ruby options to run Shoes when you press f5. There *are* some guys on the mailing list that have a demo IDE written in Shoes itself that will allow you to refresh code without stopping and starting the app. 2) The documentation is plentiful, but scattered. I found myself constantly bouncing between the included help app, the gmane mailing list archives, why's illustrated guide, and the website. The only way you'll be able to learn the ins and outs is by immersing yourself in the community. Sometimes very valuable things have not made it into any of the official help files. All in all its great. Hopefully will inspire lots of other gui toolkits. _Why shits rainbows and unicorns.
I think it would be cool if the help app contained Why's Poignant Guide. It seems like a perfect place for it. Also, on the off chance that _why looks in here -- reading the Potion source is a giddy experience. It blows my mind that this is what's needed to implement a language; it's never seemed so approachable before. The closest I've ever gotten to hacking 'real' languages (not a dsl or metacircular interpreter, etc) would be hacking on Arc, but as it stands, Arc is implemented on top of what is already one of the most powerful languages out there. But a little language that lays right on the metal -- I've never even really considered playing around with that, because of the crazy amount of code I'd assumed it would require. It gets me wondering if I could squeeze Potion dow onto an ATTiny2313.
The only information I have about what Wilson is is that it is a "pure ruby x86 assembler". Just a touch more information would go a long way.
Grr! That's not authentication, it's authorisation.
The answer seems to be no. 
Ruby has been used heavily at the more innovative end of web development over the last couple of years - and I think there has been a drop in innovation lately.
oh damn.. and i thought everyone would go back to leaving us alone and we could enjoy being swept under the rug...
People aren't fizzing about it as much now, they are busy working with it. Ruby has become their day job instead of their dream job. I'm not complaining.
&gt;and I think there has been a drop in innovation lately. Like Yarv and Jruby and Ruby 2.0? Yeah terrible stuff... 
I use Ruby every day and have for almost three years. Almost never do my searches contain the word "ruby" ... most contain rails, gem or some specific plugin or module that I am searching for. The API documentation is usually enough and if you really want to know what's going on just read the source. Rubyists are a pretty smart bunch and clumsy search usage is probably not very common.
My eyes!
I have personally developed over 50 websites with Ruby on Rails at my job in the past couple of years and that number is only continuing to grow. 
It's my day job and I am not complaining either. Ruby and rails have changed the way I work and that's saying a lot considering I am a stubborn son of a bitch.
not to mention rack and sinatra and phusion on the web development front
And merb hit 1.0 this year... Almost forgot about that... 
 Yes there has been some innovation in tools - yes there has been improvements to some frameworks. However there are less people starting new projects at the moment - and less projects are getting funded - and people just generally seem to be doing less sexy software at the moment - it's 12 months since I saw a new webapp and thought 'WOW'. You only have to subscribe to the Ruby blogs or lurk in the IRC channels to see people just aren't as active as they were a year ago. It's not because Ruby itself is getting less popular - it's economic - because Ruby is at the innovative edge of software development and that sector is suffering most right now - in 2 years when growth returns it could be like 2007 again. 
My response is sort of like my response to Windows vs. Linux. I don't care if most people run Windows, so long as it's possible for me to use Linux. So I care more about hardware support and things like adherence to open standards than about market share. Ruby is a joy to work with, and I have the freedom to choose my tools, so I can use it. A lot of people like other languages, and I'm glad they're happy. 
Why?
What's happening in the Ruby community?
I've done a quick script to scrape the base ruby methods and check their usage on Google Code Search — and the results for 800-odd ruby methods are at Github along with the source code. Top five are #new, #each, #dirname (odd!), #join and #to\_s with 784k total mentions in Google Code Search. Bottom five are #default\_bindir, #yaml\_tag\_subclasses, #class\_variable\_defined?, #break\_outmost\_groups and #valid\_jd? with whopping 0 total mentions.
dirname is probably for: require File.dirname(__FILE__) / 'some_lib'
Interesting. Now the ruby guys know which methods to optimize first.
`__DIR__` FTW! anyway it seems realy strange that one of the most used methods is one called "ruby" which I never heard of. EDIT: escape
Your mission: create a worthwhile script using all the unused methods listed (768-806): &gt; default\_user\_source\_cache\_dir, readable\_real?, valid\_time?, valid\_civil?, load\_path\_insert\_index, lineno=, default\_sources, writable\_real?, instance\_variable\_defined?, blockdev?, grpowned?, is\_complex\_yaml?, have\_option?, public\_method\_defined?, private\_method\_defined?, ruby\_engine, valid\_date?, gregorian\_leap?, executable\_real?, block\_given?, method\_defined?, default\_system\_source\_cache\_dir, group\_sub, chardev?, blob=, closed\_write?, generic\_parser, taguri=, valid\_commercial?, closed\_read?, is\_binary\_data?, valid\_ordinal?, protected\_method\_defined?, julian\_leap?, default\_bindir, yaml\_tag\_subclasses?, class\_variable\_defined?, break\_outmost\_groups, valid\_jd?
Hip hip hurrah to style over substance, ramaze over sinatra, and hoptoad over get exceptional :p
Let's launch wilson in Ruby interpreter built for UNIX-alike operating system written in wilson asm… Oh wait, I think I divided by zero.
http://rubyforge.org/projects/erector/
Thanks. Looks pretty awesome. Do you have any idea of whether it takes more ram or is much slower than erb?
Cool, I never thought of scraping Google Trends. Still, I don't like the amount of global variables.
In the codebase I work on for a living, I'd be happy with some intermediate usage of hashes and arrays. I cringe everytime I open a source file and see things like this: data = get_some_huge_pile_data a = [] data.each do |thing| a += transform_thing( thing ) end 
Just a small lesson I learned with Ruby recently - hashes do not preserve order in the values... If you want to use an ordered hash, consider using Dictionary from the Facets library... 
Just hope there's enough RAM to store the entire array :)
I've been caught out by this before as well. In Ruby 1.9 this is changing though, and hashes will preserve their order.
Not very idiomatic.
Why wouldn't a beginner be able to just read the docs? This shit is trivial.
It's the first post of 3 that describe the system.
[This slideshow](http://slideshow.rubyforge.org/ruby19.html) on what to expect in Ruby 1.9 says hashes are now unordered. [This link on Reddit](http://dablog.rubypal.com/2009/1/14/10-things-to-be-aware-of-in-moving-to-ruby-1-9) says that hashes are now ordered. I'd much prefer the former as keeping hashes unordered seems to align more closely with the simple data structure we all learned about, and probably provides a speed advantage over keeping them ordered.
I [trust eigenclass](http://eigenclass.org/hiki.rb?Changes+in+Ruby+1.9) on the matter.
I also trust Dave Thomas (PragDave), who said that they are ordered when giving his Ruby 1.9 talk at RubyConf 2008.
I've too heard that 1.9 is supposed to have ordered hashes. In the meantime, take a look at Ruby Facets - they provide ordered hashes through the Dictionary object. There's others too that do it.
My 1.9.0 install appears to preserve order.
This is "most occurring in source code" not "most called in day-to-day use". In particular File.dirname I can't imagine is actually called that much. It is just that File.dirname(__FILE__) idiom at load-time
Also, if you're using Rails or have access to ActiveSupport, ActiveSupport::OrderedHash exists. No need to use this in 1.9, though.
Looks like it: &gt;irb(main):001:0&gt; a = { "test" =&gt; 1, :test =&gt; "b", 1 =&gt; "f" } &gt;=&gt; {"test"=&gt;1, :test=&gt;"b", 1=&gt;"f"} &gt;irb(main):002:0&gt; a.keys &gt;=&gt; ["test", :test, 1] &gt;irb(main):003:0&gt; a.values &gt;=&gt; [1, "b", "f"] 
That's not really indicating anything: ~&gt; ruby -v ruby 1.8.7 (2008-08-11 patchlevel 72) [i686-darwin8] ~&gt; irb &gt;&gt; {:a =&gt; 1, :b =&gt; 2, :c =&gt; 3}.keys =&gt; [:a, :b, :c] 1.9 does have ordered hashes, anyways.
For anyone using Textmate this is a must if you plan to try out out vim!
"Ordered" in the sense of preserving the order in which keys are added to the hash or of maintaining the keys in an ordered manner? With 1.9.0: irb(main):001:0&gt; a = {} =&gt; {} irb(main):002:0&gt; a[1] = 1 =&gt; 1 irb(main):003:0&gt; a[5] = 5 =&gt; 5 irb(main):004:0&gt; a[2] = 2 =&gt; 2 irb(main):005:0&gt; a[10] = 10 =&gt; 10 irb(main):006:0&gt; a[3] = 3 =&gt; 3 irb(main):007:0&gt; a =&gt; {1=&gt;1, 5=&gt;5, 2=&gt;2, 10=&gt;10, 3=&gt;3} irb(main):008:0&gt; a.keys =&gt; [1, 5, 2, 10, 3] 
&gt; This link on Reddit says that hashes are now ordered. "ordered by insertion order"
ActiveSupport::OrderedHash is forward-compatible: on 1.9, it's simply set to Hash.
I had a look at the 1.9 source code at one point. The items do store an order; however, it is still essentially a hash table, and any difference in speed is likely to be negligible. Basically, each item in the hash also stores a pointer to the next/previous items in the list. So insertions and searching still perform like a standard hash (aside from needing to update a few pointers on insertions) while iterating acts as a list.
Oops, just saw this [was submitted to /r/programming](http://www.reddit.com/r/programming/comments/27mxn/) a while back.
wow. Inspiring. Here is a nice video which shows the school/environment where Matthew works: http://amanikids.org/news/20081127112004
Yesterday someone showed me a trick for making a deep object copy: obj = {:level1 =&gt; {:level2 =&gt; 'data'}} # This simply copies 2nd level hash's reference :( obj.dup # But this will deep copy it all. copy = Marshal.load(Marshal.dump(obj)) So even though that is a neat trick, it looks like it might be a good idea to do the deserialization side with this extention.
The premise of PureMVC suggests that ActiveSupport and ActionMailer are unnecessary extensions of Rails that make that framework bloated. That may be true for some applications, but I haven't observed that. In fact, each of the six Rails projects that I have had a hand in developing and deploying have taken advantage of ActionMailer and ActiveSupport features. 
rubygems-update.
hpricot, or lately, nokogiri.
sequel
That'll be built-in come 1.9, so you get to pick another! Woohoo!
prawn or webby
It's not saying "Rails is bloated". RoR is about providing a good set of defaults for web development in a nice language. PureMVC is making _cross-platform development_ easier by implementing an MVC framework in many different languages. ...and good luck with that.
ParseTree, and the like.
rspec. bdd changed everything. I could also go for the test/unit "enhancements", but that'd take a number of gems to get me nested contexts + a mock framework.
This is a tough question, since most RubyGems have more than one dependency.
dbi
Already got my copy!
rubygems so I could install more gems.
I just read it today. Cucumber looks great, Rspec looks tangled up. For your Ruby testing, also take a look at Shoulda and FactoryGirl... both are good.
rails? :P
Huge pet peeve of mine. Thank god somebody explained it.
Yes but sometimes the gem won't work unless you require rubygems. 
Do you mean "won't work" as in won't load? Can you give an example?
Yes that's what I mean. I don't remember the individual libraries but it happens occasionally. I think the last time it happened it was libxml-ruby or perhaps sequel. Edit: It was libxml. Here is a transcript. ~$ irb irb(main):001:0&gt; require 'libxml' LoadError: no such file to load -- libxml from (irb):1:in `require' from (irb):1 irb(main):002:0&gt; require 'rubygems' =&gt; true irb(main):003:0&gt; require 'libxml' =&gt; true irb(main):004:0&gt; 
And that is his point. If you are using a library in your code, then it's up to you to decide the environment, say, by using rubygems and 'require "rubygems"'. 
acts\_as\_enterprisey
So the recommendation seems to be to wrap require rubgems in a LoadError rescue block: http://github.com/henrik/slugalizer/blob/1e23d71cf1fdb0be269341137ced7fbf8ac73909/slugalizer.rb#L6-12 It's not a dependency on rubygems per se.
This is a perfect example. You should do this instead is the point: ~$ irb -rubygems irb(main):003:0&gt; require 'libxml' =&gt; true Or, ~$ RUBYOPT=rubygems irb irb(main):003:0&gt; require 'libxml' =&gt; true 
ActiveRecord ActiveSupport ActionPack ActionMailer pick one
Hpricot.
I guess I don't get what the big deal is.
&gt;The choice of library management system should be down to the environment and not enforced by a library or a single portion of a larger application. I don't really see what the big deal is either. You can install rubygems from yum or apt. Rubygems is a libarary requirement for other gem based libraries. It's not just a library management system; it's also a prerequisite requirement to make other gem based libraries work. They're not telling you the sysadmin to use gems to install libraries. The sysadmin can install all needed libraries from apt or yum repositories. But if you install ActiveRecord from gems or from yum the outcome will still AFAIK be the same - you'll need to require rubygems too.
for most apps i use, even small personal projects, i just freeze the gem into my app, because i don't want to mess with version problems or having to manually install something on a production machine. so i don't understand the fight against rubygems at all, it seems like a false dilemma to me. 
rubygems messes with $LOAD_PATH which makes it much harder for individuals to specify which versions of which dependencies they want to load at runtime.
&gt; This is a perfect example. Not really. All you've shown is that you're able to require rubygems from the command line at run time. Which is nice and all, but so what since in irb you can require it interactively whenever the hell you want. OP's beef is with scripts that are coded to require rubygems regardless. EDIT: Shit, you *are* OP. Heh. Anyone got an faceggwipe?
&gt; Rubygems is a libarary requirement for other gem based libraries Gems rarely require rubygems themselves; plenty also provide tarballs with setup.rb, or need little more than lib/* copying to site-ruby, and the gems basically do little more than provide an optional means of managing their installation; just in a way which sadly requires the use of 'require "rubygems"' to make them work. e.g. there's a libxml-ruby gem, but my OS also provides a ruby18-libxml package. Something which depends on it and assumes it needs to load rubygems to do so just has the effect of making it take twice as long to start.
What if your lib depends on other gems? Is it better to have the user require it herself?
FasterCSV. It'll be in core for 1.9 though. Second choice: DBI.
Yeah, $LOAD_PATH is one big mutable array that can be changed anywhere. There should be an api to manipulate $LOAD_PATH. Direct manipulation should be heavily discouraged. 
Set the dependencies in the gemspec. Do _not_ put Rubygems specific code in the library, but use regular require to load the libraries. If the application that uses your library does so through rubygems, it has to require rubygems anyway.
s/core/standard library/ and s/It'll be/is/ :-) (Sorry for the Perl syntax.)
Let the testing and patching begin. The bcrypt gem is still borked on Ruby 1.9.
GUYS IM TOTALLY DRUNK RIGTH NOW BUT SERIOUSLY, RUBY IS AWESOME. IM GONNA OPEN UP SHOES LATER WHEN I GET BACK FROM THE CLUB AND PROGRAM A FUCKING T REX YYYYYYEEEEEEEEEEEEEEAAAAAAAAAAAAAAHHHHHHHHHHHHH
puts wow
EventMachine
ParseTree only works on ruby 1.8
Do want! But ftp.ruby-lang.org is melting under the strain of all the rubyists trying to download. Maybe I can grab it from svn.
Dumb question, is there a torrent for this??
I've been looking for a torrent or a mirror for about an hour without any luck. I can't connect to the SVN server either.
Completely fails to mention http://ziya.liquidrail.com/
 f=rand(5)+1;p"FUCK YEAH!".scan(/./).map{|c|c==' '?c:c*f*(rand(5)+1)}.join
Work with it as normally. require 'library-name' If the user uses RubyGems, this will work fine. If they don't, it will still work fine (whatever system they use to get your code, they'll also use to get the dependency you're trying to require). For instance, if they 'vendor' your code into their project directly, they can also 'vendor' your code's dependencies. If you are trying to debug your own code, etc - put the `require 'rubygems'` command into the deubbing file - whether it's the Rakefile or the RSpec runner or whatever file you run at the terminal that includes your library. (Don't, however, put it in the specs themselves!)
A torrent would be an awesome idea. Anyone with good bandwidth (for seeding) want to volunteer?
mocha
There was an article about using swing to build a gui for ramaze apps. Anybody know anything about that?
From [Ruby 1.9.1 Released - First Production Release of the Fastest Ruby Ever!](http://www.rubyinside.com/ruby-191-released-first-production-release-of-the-fastest-ruby-ever-1480.html): &gt; If ruby-lang.org is still down or is as slow as ever, you &gt; can alternatively download **[our mirror of &gt; ruby-1.9.1-p0.tar.bz2](http://www.rubyinside.com/files/ruby-1.9.1-p0.tar.bz2)** &gt; ... &gt; - be aware that this is a [bzip2](http://en.wikipedia.org/wiki/Bzip2) file and it &gt; may be taken down within the next few weeks (in which &gt; case, just use the ruby-lang links).
&gt; runtime checking (would help performance) Huh? Something's missing here. What about a ruby19-minus-encoding-madness-fork?
&gt; runtime checking (would help performance) Probably because knowing the type at runtime speeds up the method lookup. As for removing the encoding, fyi, his Ruby-Lite version didn't have it.
&gt; Probably because knowing the type at runtime speeds up the method lookup. That would be "no or fewer runtime checks" though, wouldn't it? Anyway, it's probably clear what is meant.
Agreed.
Thank you to all who are making this happen. I've been waiting for something like this.
Camping.
Here's an idea far a project for ruby. How about some documentation that isn't entirely worthless?
This is a cute way to use inject, but I'm not sure I'd like to sit down and debug a problem with this system. Also, this is an iterative solution, not recursive. &gt;class Object &gt; def send_r(method) &gt; method.split(".").inject(self) {|ob, meth| &gt; ob.send(meth) &gt; } &gt; end &gt;end This calls the block given to inject iteratively, there is no recursion.
Perl can do the "right thing" because its addition and concatenation operators are different. In Ruby, you use the same symbol for each operation, so which of the following is correct? a) "5" + 3 == 8 b) "5" + 3 == "53" 
I'm not sure that it's yet official. The only references that I've found speak of a 2.3 release candidate, however the tag doesn't show RC status. Is this the official 2.3.0 release?
If you post constructive criticism instead of mindless flaming then maybe people will actually listen to you.
Actually, there currently is a thread on that subject on ruby-core. Not every critique is mindless flaming. The wording could be improved though.
Where'd the page go?
Want something constructive? Look through the documentation that comes with Ruby--all the methods with completely EMPTY documentation, and you will find that "entirely worthless" really is the most applicable choice of words. Here, first one I picked out of the list: http://www.ruby-doc.org/core/classes/XML.html That's some bangup documentation. If proper documentation was required for a component to ship, Ruby would still be in the Alpha stage. Edit: picked another one pseudo-randomly: http://www.ruby-doc.org/core/classes/SOAP/Attachment.html --completely worthless.
sinatra
awesome! thanks guys! I love these bindings. 
these are better suggestions 1) limit the number of AR objects created, constrain find(:all) 2) use eager loading to reduce queries for attributes on associations 3) look for queries with "IN (x,y,z)" and make those real associations 4) cache, cache, cache 
actually.... I'd never heard of metasm. doh. :P
Wilson is a pure ruby x86 assembler that is _awesome_. How's that?
because I could. because I had an itch to scratch. because it was awesome to NOT program in any of the machine code and instead parse the NASM machine code appendix. because I worked on rubinius and this would be another way to do fast but without all the baggage of llvm.
see rubinius. see squeak. take it to its logical conclusion.
Super-useful. I like the fact that you can update your collection of feeds quickly. This is going to be handy.
Check out the benchmarks in [the readme](http://github.com/pauldix/feedzirra/blob/13d9de5c1013cdf7adfc07d1fdbe05eee64a88ad/README.textile): 10x speedup compared to the alternatives.
You could have written the documentation for that method in the same time that it took to write your post.
The XML module has no documentation because it has no methods and no use. It's just for namespacing things under it. If you knew ruby, this would be obvious, but it's clear you're just picking stuff randomly and complaining about what everyone else says.
Could definitely have tried a little harder on the name.
That's discussed that in the comments of the post. Check them out.
okay... more details! but the real problem i was trying to address is if you have a page that takes over a second to load, what are the things you can check for that will offer the most results for the least amount of work 1) you should ALWAYS be cautious of doing a find(:all) on tables unless you are ABSOLUTELY sure the table won't grow much (eg. US states) and really you should be cautious of anything loading more then 50 AR objects in memory. not because your machine will suddenly crash or rails sux, but it's a good point to ask yourself if there is a better way. maybe not, it's your call and depends on what you are doing. this is ALWAYS the first thing i check for when a client comes to me looking to speed up their app. i do this first because time and time again it's offered the biggest speedup for the least amount of work. 2) this is the second thing i look for because when a rails rescue project comes to me, i can almost guarantee that some one will have a page where they display attributes of an association and have a query hit the database for each row displayed. this is called N+1 and is easily fixed with eager loading. so you get something like User.find(:all, :include =&gt; :projects). 3) this is just part of a larger problem where people come to rails but don't quite think IN rails yet or don't realize what functionality rails offers them. you should always have api.rubyonrails.com open. I've been programming in rails for a few years now and i still keep it open when i do anything.. 4) in the article linked to it suggested not using link_to or url_for because of routing, but if you use caching, it solves the speed problem. if you are using page caching, then you entirely side step rails and pages are served from the web server. the problem with not using link_to, is that if you ever need to change the url for a resource, instead of changing one line in your routes file, you are changing anchor tags in a million places. i've had to do it before and it's not fun. something else that i thought of after was creating indexes on commonly searched rows. if you are searching by the username column, put an index on it... just keep in mind it's not a silver bullet, because it slows down updates and inserts that's noticeable if you abuse it. however, a few properly placed indexes will give you an insane speedup. and one last bonus thing... if you value speed. for the love of all that's holy never, ever, ever, get a random bunch of records by using a :sort_by =&gt; "RAND()" because that will do a full table scan and then just return the number specified by your limit statement. if you have 10k rows, this is a painful experience
Always great to hear updates. They need to blog more FFS.
well it just depends on what stage of performance analysis you are at... if you are starting out.. typically you are doing silly things with ActiveRecord... once you get past that.. then your recommendations kick in... i think i'll work up a blog post... 
RubyParser is still 1.8 only though, isn't it? Has somebody managed to actually install it: $ gem install fabiokung-sexp_processor -s http://gems.github.com Successfully installed fabiokung-sexp_processor-3.0.1 1 gem installed Installing ri documentation for fabiokung-sexp_processor-3.0.1... Installing RDoc documentation for fabiokung-sexp_processor-3.0.1... $ gem install fabiokung-ruby_parser -s http://gems.github.com ERROR: Error installing fabiokung-ruby_parser: fabiokung-ruby_parser requires sexp_processor (&gt;= 3.0.1, runtime) 
My fault. Just add github as gem source: gem source -a http://gems.github.com Then you don't need to use "-s http://gems.github.com" in the "gem install" calls 
I used this for the first time about a week ago and I think it's pretty nice. The way it's structured really encourages you to put your rules into sort of heirarchal relationships, which for me really helped me organise my old rules and discover redundancy, etc. I find the need to use = before a rule that uses a variable pretty damn odd though, I mean is there ambiguity without that = there? I don't see any so it seems like an odd choice, but maybe I'm missing something.
I agree about the =, it has bitten me more times than I like. Otherwise, it's an amazing way to write your css. Goes especially nice with haml.
Yes there is. Plus and minus are legal characters in urls and attribute values, and for them to have different meanings when used in a scripting context, you have to provide something to the Sass parser that indicates what mode you are in.
Ah, that makes sense. The cases I was looking at were simple things like ":color = !baseblue" or ":width = !sidebarwidth" where I wasn't using any of the mathematical stuff. I mean I'd kind of like it if you could use plain variables outside of the scripting mode for simplicity's sake, but there is an issue of consistency so I guess I can understand the decision not to do that.
It's definitely worth considering. You should bring it up on the haml mailing list and we'll discuss it further.
I'd like to see the same thing with braced rather than indented blocks, so I can say what I mean and have my editor autoindent it.
Himself as in? Ah, you mean handed by god? :)
This has pretty much nothing to do with Rails whatsoever.
where the beer flows like wine and the women flock like the salmon of capistrano
Arg, don't do this in the controller. Even as an example, it just gives people bad ideas. This kind of code belongs in the model.
How would you handle an advanced search scenario in the model?
This is way less than perfect (it's late) but here's one (crude) way of moving this stuff to the model: http://gist.github.com/59079 If your search becomes quite advanced, you should consider moving the search code into a separate Model (not a subclass of ActiveRecord::Base). 
Very nice... if I get a minute I'll edit that into the post and throw some props your way :)
I improved on your script a bit, now it installs both versions with prefixes: http://gist.github.com/59216 Also, it aliases the binaries to ruby19, not ruby18. It's time to move on! d-:
The Jit work is really interesting.
Shouldn't that be 1.8.[67]?
It's bash-style, not regexp.
Sorry, but this is a waste of effort. Take for example [the entry on Hpricot](http://isitruby19.com/hpricot). 5 comments on 3 versions on 3 or maybe 4 setups. 3 marked as working - except one of those actually states in the comment it's failing - and 2 marked as failing. Apparently something's been fixed, apparently it hasn't been fixed, and - oh - and good luck tracking progress cos there aren't any dates. So is Hpricot ready for Ruby 1.9? I am none the wiser. Would the lighthouse/official mailing list/support forums be a better focus of this energy? Definitely. EDIT: added link
I'm just afraid that people post their error reports there instead of the official bug tracker. That site should encourage people to do that.
Precisely. If you think this is a good idea, you're probably using Twitter for announces and IRC for a changelog.
Oh shit! My next project is totally gonna do that. And main repo is a gist. &lt;3
Does clicking on this link bounce anyone else back to reddit? Copy/paste into address bar works fine... What's the deal?
Developers can search for their gems on the site as well.
But they shouldn't! Developers should see a new ticket in their bugtracker. End of story. Developers can also find issues at Stack Overflow or IRC or whatevz. Doesn't men they should.
fair point.
um.... I take it this is the Ruby equivalent of the C, C++, etc. "continue"?
Some of the developers are MIA, for instance bcrypt-ruby. Maybe it's good to have a community site where people can discuss bugs and share patches, without need consent from the original developers. If people feel strongly about keeping the original developers informed, they should relay the bug-reports up-stream.
In Ruby and Perl (and others?), "next" moves to the next iteration (like C's "continue") and "redo" restarts the *current* iteration. You'd most often use redo in situations where you want to discard certain results and just redo the block without fiddling with your iterator. puts "Please enter five numbers &gt;= 1..." numbers = [] 1.upto(5) do |n| print "#{n}: " num = gets.to_i if num &lt; 1 then puts "Invalid number, please try again..." redo end numbers &lt;&lt; num end puts "You entered " + numbers.join(", ") Running it, we see: Please enter five numbers &gt;= 1... 1: 82 2: 12 3: giraffe Invalid number, please try again... 3: 5 4: Invalid number, please try again... 4: Invalid number, please try again... 4: 1 5: 0 Invalid number, please try again... 5: 2 You entered 82, 12, 5, 1, 2 (Forgive my code... My Ruby skills were never terribly sharp, and now they're pretty rusty on top of that.)
Why aren’t you using DataMapper? It’s specifically designed to be stand alone, and covers all of the things that you’ve listed there. I’ve used DM for several strictly data related tasks that range from mocking up new app model structures, or to provide access to existing databases, and a lot more. And there aren’t any dependencies on a web application framework :) The syntax is negligibly different, and if you can get over the few best practice type things that DataMapperers dissuade (like STI, which they finally have relented on) then DM will do you fine.
I've tried vim, TextMate, Aptana/RadRails, Eclipse, JEdit, Komodo IDE, gedit, and Borland 3rd Rail. Netbeans is by far my favorite for development. Netbeans has great integrated debugging.
"gem install rails rack sqlite3-ruby works too, which is nice to see. You need the rack gem for later on. What isn’t nice to see is that when you run rails test is that you’ll get some stacktrace like:" Im new to Ruby. What did he just say?
Yes clicking on that link takes me nowhere. Copying it and pasting it into a new tab works. Strange.
Your own, probably. Throw together some script-fu in a Rakefile or something.
Background: I was looking to pick up a static website compiler for managing some friends websites, but I'm completely stumbled by the sheer amount of similar projects. Does anybody here have experience with some of these and could perhaps highlight some pros/cons? So far, my own enquiries has turned up these three as the seemingly most interesting candidates - apparently in order of complexity: * [webgen](http://webgen.rubyforge.org/documentation/getting_started.html) * [nanoc](http://nanoc.stoneship.org/) * [webby](http://webby.rubyforge.org/tutorial/) One thing I was considering was to write a gui frontend for it (Possibly using Shoes, and backed by git), to make it possible for non-techies to update and publish the site. This means that a good api is probably an important feature.
Avi Bryant, courtesy the OP: &gt; If you want to develop innovative software, don't preach to developers. Ship to users. Developers resist change and cling to their beliefs. Users don't know or care.
Yeah, that's an option of course, but I was hoping to get the benefits of using a package that is maintained by someone else than me.
Exactly. I did this with [git-blog](http://github.com/elliottcable/git-blog) - before any of the above were available, iirc. Unless I missed one. But yeah, it meets my needs perfectly - because I wrote it. It's really just a bag of raketasks anyway.
&gt; Why do we have hyper-evolved text editors, and jobs where we use crap software and crap tools? They've become hyper-evolved because they're used everyday by people who can potentially improve them - therefore they're in an environment of hyper-natural selection. Not to mention that text editing has been around a long time and is a fairly stable and well-understood domain. And that thing I just wrote to parse some HR shit into some other HR shit, isn't. &gt; Imagine if you went to the doctor's office and found that the doctor uses a transdimensional laser scalpel to open his letters, but he plans to do surgery on you with a sharpened rock. Imagine if every time you went to the Dr they just wanted to treat you with the latest largely untested drug.
How about StaticMatic: http://staticmatic.rubyforge.org/. It uses Haml templates with a similar workflow to developing a rails app. Other templating languages are in the pipeline but we've found non-techies with html experience pick Haml pretty quickly.
I loved Giles' comments for a cited blog post: http://abstractstuff.livejournal.com/60388.html
I rolled my own (http://github.com/sandal/blaag), but wish I knew about Webby before I did.
I would recommend [Jekyll](http://github.com/mojombo/jekyll).
Could not agree more. I am in a .NET shop and it frustrates me to no end how much 'enterprise' software costs, how long it takes to build and the bloated processes. Most corporate developers and managers think it's about the technology. NO, it's about the product and getting out there faster than your competitors.
&gt;Imagine if every time you went to the Dr they just wanted to treat you with the latest largely untested drug. No kidding.
Looks interesting. The similarity to Rails is a good idea, since it would allow a seamless transition if needed. Not sure if that would be relevant for me, but it's still a nice feature. Is there any reason why you don't use rake?
Don't know how I missed that one? Thanks.
I'm gearing up for a third mini-interview. What would you like to know?
Man, I hope *I* never say something really stupid on my high page rank blog.
There's going to be a lot of obscure but valid http response codes that that would miss. It's good for quick and dirty though.
why not link to the article with the actual content?
I'm kind of surprised this isn't an option in IRB[:CONF][:PROMPT].
Oh, dear God, I am kind of surprised IRB even works. That piece really ought to be rewritten.
conf.return_format="#=&gt; %s\n"
Oh. Why am I blind? I scanned the entire :PROMPT hash looking for =&gt;, but I guess it blended in too well with the hash formatting :P
The dependency ruby-terminfo will not build on OSX Leopard for some reason. I am going to have to put up with this \n in my irb output, perhaps forever. *sniff*
Teach Textmate how to detect the right Bundle.
Been there. Duh'd that.
Won't this damage Ruby in the long term? Will EY support a migration to 1.9? Will they create their own dialect, perhaps porting ideas from 1.9? I'm not saying EY is an evil corporation. Yet, will it make economical sense to be 1.8.6 official team and then let it go?
Further more, if they want to stay with 1.8.6, why not invest in Ruby Enterprise Edition?
Built fine for me on 10.5.6
but changing IRB.conf[:PROMPT][:DEFAULT][:RETURN] to simply "%s" doesn't return the same results as irb_rocket (output on the same line rather than on the next line) I'm making the wrong change? 
Because Ruby EE has no interest in cross platform support.
Why would EY support a migration to 1.9? I don't follow.
Nor does Engine Yard.
[citation needed]
Try this. http://merbi.st/plugins/21
hei, you don't need the ";" in that function definition in the title :)
Why? Engine Yard runs a Linux as their OS for their servers. Their primary interest is ensuring that their environment stays stable, secure, and performent.
Maintaining the 1.8.6 branch does not mean sacrificing cross platform support. Otherwise, they're not really maintaining it.
Agreed. I'm just confused as to why they'd want to maintain something as large as Ruby 1.8.6 when they could invest in something that's more attuned to their immediate business needs (i.e. Ruby Enterprise Edition), especially given that their stated interest in Ruby 1.8.6 is that they rely upon it.
If EY only runs Linux for their servers, then Ruby EE may be the way to go. But then they're at the mercy of the Ruby EE team, and there's no guarantee *they* would maintain compatibility.
That's my point. EY won't have reasons to support a migration. We want every rubyist to use 1.9 after a time, right? Faster vm, better unicode...
errr...yes you do. It's all in one line (those are linebreaks in ruby)
 &gt;&gt; def euler(x) cos(x) + i*sin(x) end =&gt; nil &gt;&gt; euler(4) NoMethodError: undefined method `cos' for main:Object from (irb):1:in `euler' from (irb):2 no you don't.
It's extremely difficult for those of us with eye issues to read grey text on a black background. 
&gt; This is more of a snippet than a plugin, it's pretty unprofessional that you're publishing it as such. What an asshole.
oh right! Passing to the next level is entirely based on my feeling of the moment. Hope it's not raining the day I'm auditing you!
Haha, thanks for the support! Glad not everyone agrees.
 include Math 
and well. Seems that the news aren't really that good: http://blog.brightredglow.com/2009/2/12/this-is-not-cold-fusion but 42%... not bad still.
I only have 16 giraffe statues/stuffed animals on my corporate site what can I qualify for or can you point me to where I can buy more
Rufus is awesome. John (the author) is also a first class guy.
and "def i" :)
Being giraffesoft, we are the only authorized dealer of official RMM-sanctioned giraffe statues and stuffed animals. Get in touch with me for price and purchase information.
# So there I was reading why's poignant guide to ruby when I came upon the # following piece of code (I added the print statement). kitty_toys = [:shape =&gt; 'sock', :fabric =&gt; 'cashmere'] + [:shape =&gt; 'mouse', :fabric =&gt; 'calico'] + [:shape =&gt; 'eggroll', :fabric =&gt; 'chenille'] p kitty_toys[0] #I was then writing my own little version of it which was pretty much the same thing. cars = [:brand =&gt; 'Toyota', :type =&gt; 'sedan'] + [:brand =&gt; 'Nissan', :type =&gt; 'truck'] + [:brand =&gt; 'Suzuki', :type =&gt; '4WD'] p cars[0] # In case you ran the program and missed the problem, let me repeat the output. # [{:shape=&gt;sock, :fabric=&gt;cashmere}] #[{:type=&gt;sedan, :brand=&gt;Toyota}] # When the kitty_toys[0] gets printed, it's printed in the correct order of :shape # then :fabric but when you print the cars[0], it's reversed so it prints :type then # :brand. I can't for the life of me figure out why it's doing that. Please tell me # why this is happening. # P.S. While were all here discussing ruby, I might as well get this question of my # chest: when I type require 'my_program.rb', ruby can't see where my file is # located. Is there somewhere in particular I should place my file for it to be # noticed by ruby? Can I point ruby to the directory? Can I add that directory to # the list in $: which I understand to be where ruby looks for the required file? 
Because you're making hashes (the things grouped by {}), and the order of hashes can't be guaranteed.
Hashes don't have a defined order, like arrays do. In the kitty_toys example, the fact that the keys were printed in the same order as they were inserted is just a coincidence. From the Ruby docs (http://www.ruby-doc.org/core/classes/Hash.html): A Hash is a collection of key-value pairs. It is similar to an Array, except that indexing is done via arbitrary keys of any object type, not an integer index. The order in which you traverse a hash by either key or value may seem arbitrary, and will generally not be in the insertion order. 
You need to update to the latest version of Ruby, version 1.9.1. There's a big switch going on right now, so some things aren't compatible yet - but it's best to start with the new version. One of the major (and somewhat controversial) changes in 1.9+, is that Hashes (what you see above) now preserve the order. (i.e. they won't exhibit the problem you describe) Re P.S.: You need to use `require 'my_program'`, not `require 'my_program.rb'`. You can certainly modify $:, but it's generally bad practice except in certain situations. What you *may* want to do, is create a gem for your program, though that may also not be what you're headed for.
Also, if you want more ruby noobish help, feel free to join #RubyNoob on Freenode (irc://chat.freenode.net/#RubyNoob) and hit me up with any question that strikes your fancy.
Question, why does the order matter? Hashes are unordered key-value pairs and it doesn't matter what order it prints in, so I'm not seeing how that's a problem. As for the last, it's require "my_program", the .rb isn't needed and require automatically appends it.
Add the directory to $: You can add a top level directory and then require using relative paths. $: &lt;&lt; File.expand_path(File.dirname(__FILE__) + '/lib') require 'some_path/some_file' will pull the file from ./lib/some_path
It probably doesn't matter, I expect he was simply confused by it.
It happens to everyone at one point, the concept of an associative array is confusing at first when a tutorial doesn't really explain 'why' they work the way they do.
I seem to remember _why's stuff pointing this out. But it's been … a while, so I can't be sure. Unless I checked. And I'm far too lazy to do so d-:
Although I can't see what it offers that cron doesn't.
Advantages over cron that I can see: * Access to your rails environment. (Okay, cron could call a rake task that loads the environment. But this is simpler as it's right in your rails project. No need to mess with editing crontab as root.) * Ability to set up and/or trigger scheduled tasks dynamically based on user input. 
You can make changes and deploy with capistrano. BTW Who the fuck downmodded my post and why?
Well, I guess the debate is over then, isn't it!
[So let it be written, so let it be done.](http://www.ispythonbetterthanruby.com/)
Yup. It's impossible to beat those kind of arguments.
The site is wrong. The correct answer is 'NO'.
it gives no answer 'cause both are turing complete, that's why you can build the same apps. another question is how funny it is to work within, all other is like a kindergarten and that's not the right place for such stupid comments
Yes.
amazing that with a site this simple, .... it doesn't [validate](http://validator.w3.org/check?uri=http%3A%2F%2Fwww.isrubybetterthanpython.com%2F&amp;charset=(detect+automatically\)&amp;doctype=Inline&amp;group=0) ... Doesn't give me a lot of confidence in the authors opinions
Why the hell does the HTML contain "NO", which is then replaced by "YES" through CSS? Fool search engines to think the answer is actually 'no'?
FTFY. Thanks, BTW!
google.com doesn't validate, either. http://validator.w3.org/check?uri=http%3A%2F%2Fgoogle.com&amp;charset=%28detect+automatically%29&amp;doctype=Inline&amp;group=0 
Amazing that despite the simplicity of your comment, you were able misspell author's. authors != author's != authors' Doesn't give me a lot of confidence in your opinion. 
touche! :)
Seconded. I recently wrote a worker management tool on top of rufus and god that does the same without needing rails http://github.com/jcapote/theman/tree/master
Wha... Seriously, what the hell?
Hmm, that's almost exactly what a 'WSDL' file for a SOAP API is.
Graceful degradation of an avatar? Wow, glad to see we have our priorities straight. 
I think that Ruby is more regular than Python (i.e. it sticks to the everything-is-an-object model), but I don't like its shitty "module" system, which I think is analogous to C's #include directive, and it's too slow. Python is decently fast and has a real module system.
Well you know, I had the choice between writing an avatar fallback and curing cancer.
OK, I have to admit, today I learned how to fit text to a curved path. Here's to important stuff! 
Hey now, a collection of small minimally-useful things can be worth more than the sum of its parts! :)
The only way I've found that's reliable enough is annotation methods. I had to solve the other half of this problem - generate c# interface files for use with XML-RPC.NET - which means specifying types all over the place. The advantage to that is that you can add automatic type-checking if you want to. I've not needed any other target languages (or libraries) yet, but they wouldn't be too hard to add. Anyway, I'll spin a gem and stick it on github, but it's not too hard to roll your own if you need to.
No, you're right. It doesn't.
&gt; The strength of the freezer goes up to 5, but I am personally satisfied with leaving it at 2. Yay, _why cares about the environment! Let’s fight global warming together!
finally..!! another person who wanted the internet to be transcribed by monks... sigh.. now only to wait for the time machine with my biscuits and nutella
That _why exists makes me happy.
Although Prince is great if you can afford it, it seems like this article completely ignores Prawn::Format. It won't let you do HTML+CSS -&gt; PDF directly, but the subset it supports and the ability to add tags may be good enough for many people's needs. http://jamis.github.com/prawn-format/ The gripe about Prawn being nearly impossible to produce a table of contents with is legit. We need to fix that, and will before the summer.
Thanks dude.
I know that, but do you know a good way to generate WSDL from Ruby outside of Rails, for a stand alone SOAP server.
Programming has never been so easy!
"If I ever get a time machine, I'm going to go back and smash the Gutenberg press so that when the Internet arrives, it'll be transcribed by monks that way GOD INTENDED"
i wish the internet *were* transcribed by monks - then we could look all the software patent trolls in the eye and claim prior art
Yes! Fight refrigerator warming! Up to 5!! Up to 5!!
As long as you don't need to deal with too many databases, to many strings, reporting, pdf generation etc. 
What irks me is that if I was born later, I could've been _why. But no, I had to live the ultra-serious Generation X crap.
http://github.com/regularfry/xmlrpc_annotations/tree/master It's not too clever - right now c# is fairly hard-coded, but you can see the idea.
can you (the dev) do me a favor? go to /config/heroku.yml and change it to: toolbar_collaborators: false toolbar_public: false Otherwise, great app!
Yes. Just like screwdriver &gt;= hammer. 
VIM is ready since ...
Since when? Please don't leave me hanging!
Textmate standing by (yeah i don't want to start this debate again, but yeah, i'm generally advocating "fantastic text editors" over "IDE"...)
app overlimit error. gotta contact the heroku guys to help fix that. (I've done a few heroku apps.)
The beginning of all times maybe? Why shouldn't it be ready for 1.9 source?
Brainfuck is turing complete, too.
Is NetBeans ready?
spam..yawn..
I don't see the point. Ruby has metaprogramming. AOP is a great solution to address the lack of metaprogramming in more traditional OOP languages like Java and C++ by getting all up in the compiler's bizness.
Domains are too cheap these days.
Just trying for some humor. Hmm...this gives me another idea...
ed is ready
cat is ready if you use the bleeding-edge version from git
Modes built for editing 1.8 source wouldn't know about the new (optional) lambda syntax. That's about all I can think of.
We should go nominate _why.
copy con!
My first reddit post and I put into the wrong category! Tried to switch category but couldn't find how. Tried to hide but that didn't take it out of circulation. Is there a missing manual of submitting that I've missed?
That's exactly what I need for my site. Thanks
Interesting, though acts\_as\_taggable\_on already has support for different contexts, so I'm not sure what this offers over it. Edit: A smaller code base?
A *much* smaller code base. acts-as-taggable-on.rb is &gt; 300 LOC. It also suffers from using a lot of SQL when ActiveRecord and named_scopes can usually do the job for you. Those methods are scary when you think they might all need to be changed when customizing... 
via: http://accidentaltechnologist.com/infoq/my-conversation-with-new-relic-ceo-on-infoq/ 
great post, thanks!
After reading the article and comments, i am slightly confused: which syntax violates Tennent’s principles, after all? Can somebody put it more clear? My feeling is that Proc.new return behaviour is in accordance with this: "The Correspondence Principle states that an expression or statement, when wrapped in a closure and immediately invoked, ought to produce the same behavior as the same expression or statement without being wrapped in a closure." But in my code i prefer using lambda, as it behaves like anonymous function, which is more clear than proc thing. 
Thanks, I'll definitely be keeping my eye on this one.
Too Funny
Matz, Katz, and DHH? Clearly the only reasonable name is HHatz.
Well played, sir!
Call it Marbles. 
or Merbles.
Douchebaggery...off...scale...must continue...forward...
It's a new project and it wants your help.
He forgot. Don't use mysql. 
Why?
Sweet post! Thank you.
Just last week I had to wake up in the middle of the night because the mysql deamon died due to corrupted innodby files. I had to set the recovery level to 6 so I could dump the data. When I restored it it was missing some indexes. Sucks.
This, uh, sounds like a great way to kill your performance.
This is for development only, where the current reload mechanisms pretty much sucks due to issues with 'require' and what not. Performance doesn't matter during development.
I have explained the load vs. require crap so many times. This is great for dev.
Perl adds an attr_accessor, then overloads it. Nothing particularly compelling to Ruby users, especially since we already have doodle, fattr, and so on.
I can see it being useful for plugin/lib development, but man, development is already slow enough, spinning up an entirely new Rails environment on each request just isn't going to do a whole lot to enhance my productivity. I contend that performance _does_ matter for development. Development speed is bottlenecked by your request speed. I'm not developing against 2.3 right now because of a bug that walks my entire app file tree on each request, which increases time of each request by _four seconds_ because of the size of my project. That's a major, major productivity killer right there. Plus, you know there's going to be some poor schmuck that deploys this thing in production and ends up serving 0.3 req/sec while his hard drive thrashes about like a stuck fish. There certainly isn't anything in the source that prevents you from running it in production.
Rails actually does a pretty good job at serving a development environment, automatically determining wether a gem should be included with #load or #require and thus Shotgun isn't really much worth there. But adding that functionality to, say, Sinatra is really out of it's scope - instead we now have a tool that works for all Rack based apps. (And spinning up a new Sinatra session is usually done pretty quickly.)
For Sinatra and other lighter frameworks/custom Rack apps, I'll completely concede the point. Where there aren't already good reloading mechanisms in place, something like this could definitely be useful.
That's sad. Good luck Jamis, and thanks for your code.
Capistrano and SSH are terrific tools, and we have Jamis to thank for that. With all software projects, there is an appropriate point where the tool just works, and there is little or no need for improvement.
February 24 1993 was when the name Ruby was conceived during [a chat session](http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/88819).
The end of sqlite support in ruby really sucks! SQLite was great for web apps.
I had almost precisely this thought this morning, when I was cogitating Jamis stepping down from Capistrano et al.
From the comments: &gt; Jim Weirich Thu, 26 Feb 2009 14:48:37 PST &gt; &gt; My plan is to have a release polished up and ready to go by the time the first postcard reaches me. The card that reaches me gets a mention in the release notes. Mission accomplished!
Interesting. I did something similar in 2006 for my own site and submitted some fraction of my code to georuby. I will take a look when I get a chance.
This chapter is basically the meta-programming / DSL stuff if not by that name. It gives a good sampling of the overall feel for the book. Feedback is very welcome. The book will be released under a CC license 9 months after it hits the shelves, so it will eventually be an open community resource.
Gregory has done a really good job on this chapter and the other chapters I've read (the first three). If you're interested in Ruby, take a look. I think you'll find it worth the time.
interview with the author (Gregory Brown) @ RubyInside: http://www.rubyinside.com/ruby-best-practices-gregory-brown-interview-1332.html
two more interview are available: http://on-ruby.blogspot.com/2008/11/ruby-best-practices-mini-interview-1.html and http://on-ruby.blogspot.com/2009/01/ruby-best-practices-mini-interview-2.html 
Very nice -- I think I'm basically the target audience for this -- a couple decades of coding, but new to Ruby. Ruby itself seems straightforward enough, but I *have* had a lot of best practices types of questions.
That's exactly what the book is for, yes. Please let me know where I've missed the mark, there are still a couple weeks to add clarifications and clean things up. 
If it's using google's own polygons then it's virtually worthless. You really need to overlay your own tiles for any kind of performance
Last time I checked hacking involved at least /changing/ something. All this guy did was use a Ruby feature. It's not like he had to recompile the ruby interperator or anything.
hacking in my opinion also includes testing the limits of something in an effort to really understand it. He did that and so imo what he did was 'hacking' and even if it wasn't, it's still quite interesting :)
In general, hacking involves solving a problem. The problem the author solved was how to fill a blog post and in this respect it is a hack. * http://en.wikipedia.org/wiki/Hack_(technology) * http://www.websters-online-dictionary.org/definition/hack
A for effort, F for execution.
Paper? How 20th century.
the site says it's paper *and* pdf, the pdf version being free
Seems like a pretty informative and interesting book. Although the quality of the writing isn't quite as high as Russ Olsen's book ('design patterns in ruby') the content is top-notch and the coverage is great.
I really need to check out that book, I keep hearing great things about it. As for RBP, the writing quality might go up a bit once O'Reilly's editors have a chance to fix my mangled text. But it's fair to say I've focused more on the content than anything else. Thanks for the kind words! -greg
1.9 *and* mod_rewrite support? Neat.
"..It seems as though all the applications have to share the same CSS files. When your applications are stored in separate directories and are served by different web servers, how do you go about sharing them?.." Why is this even posted, and a whole blog post written about this? Unless i'm missing some big issue with all of this... 1. Put the assets to be served from separate subdomain (assets.mysite.com) 2. Call the CSS or images from the PHP or Rails or static version of your site. This is like the guy who wrote a whole Rails plugin just to show the copyright year at the bottom of his site. Time.now.year
A Twitter RubyGem? Nice.
I find it handy to have local documentation, though it does make for incredibly slow installs.
I had to do this on my Eee PC. RDoc is just slow, combined with the rather slow Intel Atom CPU means installing something big like Rails, which has multiple dependencies each with a lot of documentation, take something like an hour. Ouch.
foobar ||= true might be something like what you're looking for. Though it assigns if foobar is undefined, false or nil.
Yeah, that's my preferred construct, but in this case I didn't want to clobber the variable if it was already set to false.
Another fantastic entry [with geoip directly in varnish](http://projects.linpro.no/pipermail/varnish-dev/2009-March/000980.html).
Strange. &gt;&gt; y = 1 if defined?(y) =&gt; 1 &gt;&gt; y =&gt; 1 &gt;&gt; z = 1 if false =&gt; nil &gt;&gt; z =&gt; nil Neither of those are really expected, but assigning the variable to `nil` is better than `1`. 
 irb(main):006:0&gt; x NameError: undefined local variable or method `x' for main:Object from (irb):6 irb(main):007:0&gt; defined? x =&gt; nil irb(main):008:0&gt; puts 1 if defined? x =&gt; nil irb(main):009:0&gt; y = 99 if defined? x =&gt; nil irb(main):010:0&gt; x = 99 if defined? x =&gt; 99 That is kind of strange. 
Yeah, maybe they should change that behavour.
Turn off rdoc; you'll still have access to ri.
Wouldn't this be considered a bug that should be fixed?
[Not really:](http://twitter.com/jimweirich/status/1275186387) &gt; FYI: I'm not really delaying for the postcards. I still have some windows based rake testing to do, but should be able to finish tonight.
Speaking from experience, unless you're only translating one or two word phrases, or very simple and unambiguous phrases ("this is a pen"), Google translation, and similar online services, are useless as the translation is more likely to be wrong than right. 
I'm a pretty big Heroku fan. It's not perfect, but when it works it's effin sweet.
Love heroku and mad sexy layout page.
Care to elaborate a bit? We try really hard to avoid additional abstractions / introducing new tools and techniques where one already exists. For instance, if you look at the [Dyno stuff](http://heroku.com/how/dynos), you'll see that it's basically just a bunch of common tools that are in widespread use. Disclosure: I'm a Heroku employee and share holder.
I liked the other version better.
I agree, it's pretty much a common setup except the routing mesh and process separation. I was wondering a bit about the compiled slugs. What does compiling actually mean?
And now Rake emits a warning caused by RDoc. Well, at least it only happens _once_ ;)
We build a fast-mounting file system image from the app's master branch HEAD, basically. We publish the slug "to the cloud" where it's pulled down on a bunch of machines where the backend Ruby (Thin) processes run. So, in this case, "compiling" is some light verification of the app's filesystem hierarchy and building a filesystem image. We call it a "slug" because it's "fired" into the app serving machines. Oh my. There's some abstraction there after all :) Not so much code/logic abstraction but definitely some higher deployment concepts.
May I ask you, how much memory is occupied by one Dyno? It would be interesting to have a stripped down low-memory-footprint Ruby+Rack running in the cloud, much like Google's AppEngine.
Ah .. ruby ... dear ruby..
So is there only one database? Are you running a cluster? Do you have any copies of any of this stuff which are not on amazon?
So true.
that's backwards... Rails has a method for accessing the 42nd element of an array, and it's nicknamed "accessing the reddit"
This was added by DHH as a snarky response to the furor over second, third, fourth, etc. methods on array, IIRC.
I can understand the snarkyness. Yet more proof ActiveSupport is bloated.
Thankfully Rails 3 is refactoring ActiveSupport...
Actually, he *replaced* the methods sixth, seventh, eighth and ninth with just the single method fourty_two. So it became *less* bloated as he did that.
It should really be replaced with nothing, and DHH can move that crap into his irbrc.
Possibly the most pointless post I've every seen.
For asking question?
Reminds me of [sl](http://packages.debian.org/lenny/sl).
 def forty_two self[41 end Wow man that's some serious fucking bloat. Three whole lines!!!
I think its a fair point. Do people really need those methods. If the answer is yes, then what, do they start using them everywhere? Do they start requiring active-support in their other code just so they can use them? Software bloatedness is not defined by a single method alone, but by the tendency to include unnecessary code which builds up over time. No problem with DHH's snarky response though; if you can't be snarky in your own code, where can you be? :)
Cloud computing, iPhones and web frameworks. There's just one thing missing... How do I use it to leverage my social capital?
haha true it has a lot of buzzwords, but at least it is actually useful and does something. 
awesome!
This is great...!!!
See http://defensio.com/downloads/rails/ and http://defensio.com/downloads/ruby/
This is garbage.
&gt;I think its a fair point. I don't. &gt;Do people really need those methods. do you really need an ORM?, a car?, a nice watch? a suit? extra virgin olive oil? a web development framework? A laptop? an xbox? &gt;If the answer is yes, then what, do they start using them everywhere? Everywhere they want. &gt;Do they start requiring active-support in their other code just so they can use them? If they want to. You know that they can right? You knew that it's possible right? &gt;Software bloatedness is not defined by a single method alone, but by the tendency to include unnecessary code which builds up over time. Interesting. So somebody should not accuse some software of being bloated simply because of one method. That's really interesting. Kind of profound almost. Maybe we should sit down and think about this for a while. 
"So somebody should not accuse some software of being bloated simply because of one method." No, and I wasn't.
You can also check out ElasticPod: http://www.elasticpod.com/ Pretty cool, been using it for awhile.
That's interesting. I'd imagine if you create many classes in your tests (to test mixins, like the example), you'll quickly run into name clashes. Since Ruby happily lets you define a class twice, and just adds new methods to it, you can get some very confusing failures or unexpected passes. By using nameless classes and never assigning them a name, that would never happen.
I've never in all my years of doing TDD ruby had that problem. That said, anonymous classes do have their uses.
sudo gem install rdoc new rdoc is faster and uses a lot less memory
I apologize in advance for the chuckle I stifled.
err, what's the point? What does it do that distinguishes it from other Ruby frameworks? It's a steep climb taking on the big guys... Also... no rack?
Is this a joke?
I like the comic! ahem.
Pretty.
Actually, there's two nicer ways to interface with excel. First, you can simply create an html table and pass an excel header and excel will open it just fine. Second way to do it is pretty rad and rather unused by the masses because, well, they're kinda stupid. The excel web import feature allows you to link a spreadsheet to an html table. So instead of opening up a page and generating something and exporting to excel, you can just open the spreadsheet and hit refresh. For some applications that just works dandy.
itym rails shop. :/ 
though the focus on candidates who have already contributed code still applies, of course.
Do you have links to a howto or something explaining that?
http://tinyurl.com/ag7mwr And http://tinyurl.com/aby92h
Thanks for nothing. 
The first hit on each link is about as vivid of an explanation I can give. 
Yes I've been using HTML tables for a long time to create Excel files... works well and does allow formatting. Just name your HTML file with .xls extension and Excel loads it fine. One caveat... if its a big file then make sure each row is a separate &lt;table&gt; otherwise it will take a while to load ;-) /I3az/
Just what we need. Another ORM. 
Actually, m4dbi has been around for a while, it's just getting noticed now.
2.3 is best release in a while. Nested model forms are a huge enhancement that has been years in the making and, now that I've been using it, completely indispensable. The other big features are also very welcome and huge improvements. Last stop before Merb merger... are you ready? I sure am...
I think I'm the only one who isn't too excited about this release. Compare this to [2.2's release notes](http://guides.rubyonrails.org/2_2_release_notes.html); it seems like it's more infrastructure changes than code-level feature type stuff. Then again, I might be biased because I mostly work maintenance on a few "legacy" apps rather than start new ones often.
Yeah. I've been using the RCs for the last couple weeks. The change to Rack is nice. Simply because it allows for Middleware but nothing too immediate to change to (I did change one request to use metal this morning). But it's a good improvement. Other then improved modularity though. And fixes (they say they fixed the rake gems:install to actually work with interdependent gems....hopefully it does), I'm not sure what else I want from Rails. It pretty much does everything I need that it should. (Obviously I have other needs but that should be handled by plugins/gems) Of course performance enhances are always a plus. The 3.0 release where they are merging with Merb should be interesting.
I'd love feedback and suggestions for improvement.
I stand corrected
it's my experience that software development magazines are just props for offices. 
Not bad - Hpricot is a pretty rad tool for parsing html - huge fan of it. Don't know if using MySQL full text search would be faster or not - certainly the code would be shorter ^_^
hpricot is really really slow and has _horrible_ memory requirements. I highly recommend using nokogiri over hpricot.
I just ran a small test -- about as useful as those published in favour of nokogiri. I parsed a media wiki dump, 8MB, and iterated 10 times over all pages: user system total real hpricot 16.363000 0.220000 16.583000 ( 17.736000) nokogiri 18.176000 0.130000 18.306000 ( 19.259000) hpricot doesn't look "really slow" here. nokogiri allocated about 70MB memory, hpricot 120MB. hpricot requires more ram but not horribly so. http://pastie.org/419005
What's wrong with submitting your own content? If it's good content it will be upmodded and if it is not, it won't. It's as simple as that. Isn't that the whole point of reddit? (And also what makes reddit different from digg ;))
&gt;If it's good content it will be upmodded and if it is not, it won't. If it's good content someone else will submit it and if it is not, it won't. Generally, submitting your own content is considered bad form.
This is pretty interesting, I like how it isn't very magical and lets you set things up exactly how you'd like. Probably useful for situations in which ActiveRecord's conventions would get in the way. I haven't tried it yet, but cool stuff.
A handful of lines of javascript?
You're using the hpricot that was released TODAY. The benchmarks were written LAST WEEKEND against the previous version. 10 iterations is NOT a benchmark. With my students, hpricot was over 20+x slower and took over 1.2 gig of RAM to parse a straightforward 8 meg itunes XML file. 1.2 gigs for an 8 meg file? Yes, that is horrible memory requirements. 20+x slower. Yes, that is really really slow.
+ Engines! 
Can someone explain VM threads in general more to me? Like, are they direct translations to OS threads, or just a conceptual translation? I mean, I understand that you *can* think about them that way, but from what I understand of these, the processor/OS do not schedule/preempt them differently like they were another actual thread. Is that right?
The code is based on a small script I actually use. It's true I used hpricot 0.7 but last week, the original script wasn't noticably slower. I'm sure nokogiri is an excellent library but up to now hpricot handled every html/xml file I threw at it well.
A VM thread is just that: a thread running inside of a VM. Whether or not that corresponds to an actual OS thread depends on the VM you're talking about. In this article, it's stated that "Rubinius has a 1:1 native thread model. In other words, each time you do Thread.new in your Ruby code, the instance returned maps to a single native thread." This is significant because that's not the case for the VM the majority of the ruby world uses, MRI. There was recently a good article published about this: [Concurrency is a myth in ruby](http://www.igvita.com/2008/11/13/concurrency-is-a-myth-in-ruby/).
What was the rant?
Somebody made a [summary](http://blog.jdbartlett.com/2008/01/rails-is-ghetto-disney-version.html) of it, I couldn't find an original to see if it is accurate or not. Anyway, it's good to see somebody caring about the impact of what they write.
Don't you see? It was a brilliant joke he played on all of us! An Andy Kauffman-esque prank on the whole internet, making us think he really was a jock-type internet blowhard. Rewriting history sure is fun, no?
Forbidden. Aargh I missed the whole drama and now I can't read the rant :(
Wow, he changed his blog style too. It used to be so bad-ass...
And I thought Zed was really an asshole and subsequently ignored anything attributed to him. So it was all just parody? 
I love Ruby, but we have a really odd community. 
He prolly just took it too far. He played it as a joke from the get-go, but it was too easy to take him seriously unless you actually met him at a conference. It's a shame that he generated such intense hate, 'cos he's actually a really smart and polite dude to talk to.
I thought his persona was hilarious. Now I like him even more.
Those grapes were probably sour anyway.
So that's the new algorithm: come on like a badass and then disavow your badassery.
Take the "http://" out of the middle of the URL and markdown won't barf on it.
I bet your baby precursors don't taste sour.
I can only hope he creates a new theme "Zed's a decent bloke when you get to know him"
it really depends on what you talk to him about.
I love Ruby; we have a really odd community. FTFY :-D
Google for "zed shaw rant boy" and see what it suggests you really should have looked for.. :P
Oh, Zed grew up! About fucking time too.
Yeah, it is now at least, after the fact.
Three Reasons to Like It * Unix integration which doesn't suck. * Functional programming that works reasonably well and allows for beautiful, concise code. * Metaprogramming which lets you extend standard classes and refactor code and have it just work. And a personal, non-objective one * Syntax which gives you two ways to do things -- not a mess of similar choices, but not restrictive either. The usual caveats -- slow performance, more than enough rope to hang yourself with, and poor threading support still apply.
irb, blocks, everything is an object
It is elegant, interesting (in comparison to other languages) and feels like it has been designed by a coder for a coder.
sdavis's + the fact that AFAIK the ruby community represents the absolute leading edge in humane software testing via BDD: using cucumber &amp; rspec for outside-in testing have changed the way I develop, for the better.
Ruby's iterators are cool Procs, Lambdas, and blocks Duck Typing True Object Oriented - there's no exceptions like in other languages. int is still an object unlike other languages. The suck of ruby though is the punctuation it uses for variables: @instancevar @@classvar *args for extra method arguments &amp;proc for passing a block to a method :symbol =begin / =end for block commenting The punctuation with variables kind of as annoying as Perl's IMO. EDIT: Also watch out for the way Hashes get ordered. Found that lesson out the hard way. It's an annoying feature that's fixed in 1.9, but in the 1.8 branches Hashes do not preserve ordering. (And I know the arguments for/against).
It's not Perl! (The above counts as three reasons!)
Yes, agree with all of these (including the variable name stuff)
I like to imagine Ruby being to Perl what Delphi is to Pascal etc. It's like the old one, but better and with proper objects and shit.
Exactly. Ruby has the soul of Perl with almost none of the drawbacks.
If you had said "Smalltalk" rather than Perl, I would have agreed with your analogy. I consider Delphi to be an evolutionary improvement over Pascal but Ruby is revolutionary compared with Perl.
I don't share your concern over the variable 'punctuation'. * (asterisk) is actually an operator, usually called splat. A pointless example of its use... def my_method(arg1, arg2) # do stuff end my_method(*["val1", "val2"]) _Why explained it best when he said that the splat is Ruby's pipe for arrays. Edit: Speaking of _Why, check this out: BOARD_MEMBERS = ['Jan', 'Julie', 'Archie', 'Stewick'] HISTORIANS = ['Braith', 'Dewey', 'Eduardo'] case name when *BOARD_MEMBERS "You're on the board! A congratulations is in order." when *HISTORIANS "You are busy chronicling every deft play." end case name when "Arthur", *BOARD_MEMBERS "Either you are a board member... or you are Arthur." end case name when *BOARD_MEMBERS|HISTORIANS "We welcome you all to the First International Symposium of Board Members and Historians Alike." end From http://redhanded.hobix.com/bits/wonderOfTheWhenBeFlat.html. As you can see, the splat is not some 'punctuation'. Symbols are not a Ruby invention. Denoting a keyword symbol with a colon is seen elsewhere. I suppose my question is how you would denote a symbol? Or would you rather use a constructor or something? I find the colon prefix to be highly readable, especially when combined with syntax highlighting. =begin/=end is pretty a rarely used from what I've seen, but certainly not variable punctuation in any case. As for hash ordering, I don't know how you can complain as unordered hashes are extremely common in programming languages. It's not a feature, it's an implementation detail, and one that is documented.
Thing is, you can copy and paste perl into a ruby script and a lot of it will work straight off -- especially that wacky $_ shit that goes on everywhere in perl.
Also watch out for: If you have an attribute setter method (i.e. def somevar= ...), you'll have to call it as "self.somevar = ..." from within that object. Without "self." it creates a local variable. I am constantly burned by this. The last statement of a function is the return value. Makes things nice &amp; concise, but if you don't really want to return a value this can blow up. For example, accidentally returning false on an ActiveRecord callback function.
The thing I like most is its ability to express complicated computations with very little noise (the code written tracks the problem domain very closely). As an example, if I wanted to see if an array of cars have a specific car, I could do something like cars.collect{|c| c.name}.include?('Caprice') Or, even more succinctly, taking advantage of a symbols ability to be converted into a proc, cars.collect(&amp;:name).include?('Neon') What if you want to see if all of the cars are red... cars.inject(true){|match, car| match &amp;&amp; car.red?} # Also: cars.all?(&amp;:red?) This sort of stuff is all over, not just with arrays. Very little time is wasted setting up loops and keeping track of state and such. This is what Ruby's blocks allow us to do. Very cool stuff. Ruby's Mixins are very cool. The ability to write functionality in one place and include it whereever its used is indispensable. If complex behaviors need to be defined that depend on the environment in which they're used, that's possible to. A module can define a method called "included" that is called by Ruby when the module is included into something. From there you can set up variables, alter the way things work, etc. This is one example of "Meta programming", something Ruby is pretty excellent at. A third thing... the community. The community focuses on things that I care about: code quality, good tests, solid APIs, good documentation, etc. This manifests in a host of awesome tools for everything with APIs that make the programmers life very easy. Just look at Cucumber or RSpec or Rails or Sinatra for examples of how awesome our tools are.
The variable sigils are 100 times more useful than Perl's and 100,000 times more useful than PHP's.
Or, to see if all of the cars are red, you could ask: cars.all {|car| car.red? } And with Symbol.to_proc, this shortens to: cars.all?(&amp;:red?)
$_ is, at least, very non-idiomatic in Ruby. Block/lambda syntax replaces the main use case.
Duh, yes, that's the best way to do it. I had a more complicated example using inject, but then decided to simplify it without thinking too hard about it (clearly). All? and Any? are indispensable.
kunjaan, what's your background in programming?
Ruby was the language that taught me about DSLs. Also, Ruby's goal is to make coding fun again :) That's enough for me.
I can read my code 6 months after I've written it, even if I haven't touched Ruby in those 6 months.
It's not. I just subscribe to the subreddit because I have nothing else to do with my life.
It is easy to get start. It has little noise and the most important thing: It is a lot of fun to use it. I enjoy writing code with Ruby
1. it's relatively powerful 2. it isn't compiled (this is a personal preference) 3. it has a large and active community 4. it has multiple implementations like jruby That last one is important because you can choose the right platform for your task. If the jvm/java has some library to talk to some obscure thing then you can seamlessly use it from ruby. Or you can stick with MRI and even switch between them as the task demands.
Hey I don't disagree with any of what you've said - just saying what some of the things I struggled with when I first ramped up with Ruby. In particular with Rails, knowing when a method expects a symbol or not was confusing to me at first. I got the hang of it, but it took a bit. Big fan of the language - these are more irritants than problems. Want to hear me complain, let's talk about how wordy Java is and how much of a pain in the ass their Regexp library is to use. And why stringvar1==stringvar2 is false and you need to use stringvar1.equals(stringvar2) and how I think that's just obnoxious :)
Im a comp sci grad student- dabbled mostly in scheme, c# and scripting langs. I started this thread so that I could highlight the intersting aspects of this language while I was learning it (just in case i dont miss the cool parts:)
I agree. You can write [very succinct one liners in ruby](http://www.fepus.net/ruby1line.txt) that are almost as tight as their perl equivalents. The power and brevity of perl, yet object oriented with chainable methods makes it a great everyday unix system utility language.
Copying perl's `-ne` and `-pe` flags are the justification for also copying perl's $_ var.
Blocks: these enable functional idioms, which make things like iteration more expressive. Introspection: Ruby can be used to simplify itself and your problem domain. Community: when I started using Ruby, almost everyone who was involved outside Japan hung out on the same IRC channel. And it was a great group: I learnt more there than I could have anywhere else.
Haha, way to extend the olive branch by dissing java to a Rubyist ;) I, too, struggled with Rails back when I first started, but I made the mistake of attempting to learn Rails and Ruby at the same time. Bad idea. Rails makes a ton more sense when you have a bit of Ruby sense. My problem along your lines (perhaps the same problem) was thinking that symbols were magic and the :controller =&gt; blah, :action =&gt; blah stuff were named parameters and the colon =&gt; stuff were named parameter syntax. It wasn't until I decided to learn ruby that I realized that those are just hashes with symbols as keys and that in certain well-defined cases, Ruby is smart enough to turn a whole list of those babies into a single hash object to pass to the function you're calling. Long story short, we're in agreement I suppose :)
Cuz itz pretty and you can code in rhyme.
Blocks (aka Proc). Monkey-Patching (with taste and restraint of course). Meta-Programming.
* Blocks are hugely awesome. They're scoped, for one - they're not the same as passing an anonymous function as a parameter. * It begs you to implement a DSL, and most commonly used libraries are DSLs. Look at the Hpricot and Builder gems and see how they implement their abilities in a "uniquely Ruby" way. Rake, shoulda, etc. * Dead simple introspection, dynamic method creation. * You add a method to a class in the same way you define the class: `class Array` `def shuffle` `sort_by {rand}` `end` `end` Makes extending the language very easy and limits conflicts. edit: can't get the stupid block of code to work. * Mixins/Modules - write code once, apply it to any number of classes or other modules easily. * Extremely active community that places enormous emphasis on testing, specs, and documentation (latter not always true, sadly).
1) All (most) the power of lisp without the ())((()()( 2) gem. 3) the community; most things you want to do are already done in some awesome way by awesome people
1. when i want to write an arbitrary script to do an arbitrary thing, i can and typically it is very easy. 2. everything is an open object. if i want an object or an instance of an object to behave some way, or have some method, or whatever, i can do that. 3. a natural syntax for fluid interfaces. hashes look nice, symbols look nice, 5.times {|i| } does what you think it would... for me, ruby is the nicest looking fully object oriented language that i can also work for an awesome company where i write essentially reasonable code all day. and then on my own time i can use it to write stupid scripts and whatever. it's versitile, it's easy to read, and it's object oriented. what more could you ask for?
ooh irb, good call..
i was unaware perl had a soul...
In some languages (like C) you focus on the hardware and other low level details. In others, you focus on the language itself. When you're writing Ruby, because everything is an object, you are focused on your data. That's really what matters most, anyway.
1. method_missing() allows you to define behavior at runtime. This is what makes ActiveRecord so easy to use without a lot of bloated configurations or code. 2. Mix-ins are a very powerful way to assign shared behaviors across many classes. They're way more useful than Java interfaces (which allow you to share only a contract, and not state or behavior), or templates (which are hard to implement, and have painful syntax). 3. Ability to evaluate expressions at runtime. Neither Java nor C++ support this. Honorable mention: it's fully object oriented. You can call methods on a number, for instance (e.g. 3.days.ago).
Potential for readability is nice. Some examples: return "You must enter your name." if name.nil? 100.times { print "hi" } There are also little conveniences, like string interpolation. For example, the following lines of code are equivalent: a = "The time is " + hours + ":" + minutes + "." a = "The time is #{hours}:#{minutes}." 
Ruby code is easy to read. Even other people's. In our team environment, that makes things like code reviews easy, and team ownership of code the default. Ruby code is easy to write. You can focus more on the problem presented by the requirements, and not on problems presented by the language. Ruby code is easy to use/deploy/ship/whatever. We have a 1.5 year old Rails app, with about 10k lines of code that deploys rather quickly (our record is 5.1 seconds for a full deployment). Gems are easy to use, and fairly easy to understand (the structure). Code you find scattered about the 'Net is also easy to paste into IRB to see what it does. 
It's not PHP! (The above counts as three thousand reasons!)
I find the ideas of doing something in a Ruby way and tidy, compact and elegant code are often synonymous with each other. If a problem is getting out of hand, I tend to "Rubify" it and it comes right. Ruby's taught me a lot about programming, and the further I study the language the better programmer I become. At its heart, it's simple, but even after using it for 2 years I wouldn't say I've come close to mastering it. Ruby's also used by bleeding edge, creative and influential people. Which means if you keep your ear close to the Ruby world you'll often be the first to pick up on a number of new innovations in the field of programming in general. I think the language itself is sometimes responsible for this kind of bleeding edge, creative output.
3.times {puts "hip hip hurray!"} Oh Ruby, you had me at times. 
&gt;You can call methods on a number Of course the cost of that is performance. Int's aren't objects in Java because it's better to map an int to a system int rather than wrapping it in an object. But if THAT is your bottleneck you probably don't like Strings either and prefer char arrays and should be coding in C 
The defining principle of Ruby and Rubyists is that they follow the principles of DRY (don't repeat yourself) almost to a fault.
When I die, I will be entombed with my edition of [Programming Ruby: The Pragmatic Programmer's Guide](http://www.rubycentral.com/book/). And some of my more loyal slaves, I imagine. 
l = 'Ruby' comment = "The defining principle of #{l} and #{l}ists is that they follow the principles of DRY almost to a fault." 
Yep. Zed is the Andrew Dice Clay of programming.
Though its worth mentioning that in Ruby, a character or an integer is a single value, whereas more complex objects manifest as references, at least once you get down to the C code. The performance hit isn't as bad as you might initially think. Or at least it is in MRI. Can't speak for JRuby or YARV, though I suspect the latter is similar.
I used ruby for web scraping (hpricot), for standalone script to process data in mysql database. Ruby is extremely simple and straight forward to use. Right now I am dealing with large amount of datasets and text processing in ruby is extremely slow compared to python and php. I am now with python and I will return back to ruby at any second once its performance is par with other languages.
It's fun. More fun than any other language I have tried (although I haven't tried them all).
Ruby 1.9 and jruby 1.2 are on par with python (pretty much). Time will tell what rubinious and maglev will do. 
via: http://blogs.sun.com/arungupta/entry/totd_76_jruby_1_2 TOTD # 76: JRuby 1.2, Rails 2.3, GlassFish Gem 0.9.3, ActiveRecord JDBC Adapter 0.9.1 - can they work together ?
Code blocks, Perl like syntax but with a regular object model (no blessing), syntax difference between class variables and instance variables.
This comment deserves way more upvotes. Heh.
I don't use Rails and don't particularly like it, but I agree with the people here who think the Ruby subreddit is too small to be split. Also, a lot of the Rails stuff has wider applicability, especially now with the Rails / Merb merge and the move to make Rails more modular (conform with the Rack interface etc.). If/when the Ruby subreddit gets enough posts that stuff fly off the front page in less than a day a split would make sense, but we're far away from that. 
I mainly use Python, but the reasons Ruby keeps tempting me: 1) The `gem` command. `easy_install` is okay, but very limited (no uninstall). `pip` is better, but it's not as wide-spread, and it's another ferking tool. There's setuptools, disttools (and a bunch of others).. Ruby has gem.. 2) It's community. There are lots of really cool/useful projects/libraries/applications around Ruby. 3) Rails. Kind of the same as 2, but I think Rails is basically the reason Ruby is so popular. I *much* prefer Rails to Django (the Python equivalent)
 g = ["Ruby"]*5 g[0],g[2],g[4]=["The defining principle of ", " and ", "ists is that they follow the principles of DRY almost to a fault."] comment = g.join Didn't like those repeated "#{l}"s much.
hey can you explain more what you mean when you say passing a block is not the same as passing an anonymous function as a parameter? :)
There are some projects where I have to use straight-up Java and as I write code, I keep thinking... _"This would be so farking easier to write in ruby."_ consider: Java: `ArrayList&lt;MyClass&gt; new_list = new ArrayList&lt;MyClass&gt;();` `for (int i = 0; i &lt; my_old_list.size(); i++) {` ` new_list.add(my_old_list.get(i).some_transformation());` `}` vs. Ruby: `new_array = my_old_array.map {|element| element.some_transformation}` 
&gt;Ruby's taught me a lot about programming, and the further I study the language the better programmer I become. That is enough reason for me to learn this language. &gt;number of new innovations in the field of programming in general Could you please give some examples?
Or even: my_new_array = my_old_array.map(&amp;:some_transformation) 
It does what I mean and works like i want.
yesssss! i need to make more use of symbol to_proc
Zed is no longer a member of the community by his own choosing. He is now a member of the python and factor communities. Let's see how long that lasts.
Did you parse it as html or did you use the Hpricot XML method? 
To be fair, this exists: http://functionaljava.org/ but i agree it's far from ideal.
1. Fully object-oriented 2. Meta-programming 3. Great projects like Rails, Sinatra that do what I need them to do, with a n extremely helpful community and great workflow tools like Github. 
thanks. i wasn't aware of this. as you say, it's far from ideal, but better than nothing.
It's the closest thing you can get to scheme in the _real world_™
i've got a crazy idea... why not link to the actual content?
This is a good suggestion for some prospective Ruby developers. rubyonrails.org [agrees](http://rubyonrails.org/documentation), and has for quite a long time now.
If you're looking for more people to learn Ruby, look to academia. Java survives because it's the language taught at most colleges/universities. Python is now becoming more popular in colleges, but there seems to be little effort to get Ruby taught at colleges. They could, at the very least, run some kind of on-campus RUG so students could learn it, even if profs don't want to teach it.
This is a classic guide to learning Ruby. I'm surprised it hasn't been mentioned on here before. Also, 'why' is a genius. He's written tons of really useful libraries for Ruby, including the new graphical toolkit, Shoes (www.shoooes.net).
I respect the guy's work and recognize how he has a strong appeal to his many fans, but for the life of me, I can't read through his stuff. I guess I don't have enough patience.
As a ruby user I have to say that python's documentation is better, hence there would be no need to buy a python book if I wanted to switch. I'm not sure a high number of ruby newbie book sales is a good sign.
getting rid of rails?
I agree wholeheartedly. I really respect _why, and wish I was 10% as smart and creative as he is, but I can't stand his writings. One of my first exposures to him was the article [The Fully Upturned Bin](http://whytheluckystiff.net/articles/theFullyUpturnedBin.html) which I thought was fantastic; reading almost anything else of his and I get turned off by the... creativeness.
&gt;Fabienne: Whose IDE is this? &gt;Butch: It's Rails, baby. &gt;Fabienne: Whose Rails is this? &gt;Butch: It's Ruby's. &gt;Fabienne: Who's Ruby? &gt;Butch: Ruby's dead, baby. Ruby's dead. 
For anyone who doesn't "get" or like the guide's style, read the Ruby code only, and if that's unclear read the paragraphs around the code. Between all the foxes and bacon there are some really clear explanations of some of Ruby's more advanced/distinguishing features.
Can you be more specific?
Im new to Ruby, and I am quite interested, but have some questions. First, Ive heard Ruby is slow. Just how slow in comparison to Microsoft's CLR (C# family)? Ive also read there are issues in integrating Rails with IIS. Thing is, I want to learn it, but we're primarily a Microsoft shop and it doesn't *seem* to fit in very well. Ive poked around with it under Kubuntu, and it is indeed quite fascinating. Unfortunately, Im spoiled by Visual Studio, so Aptana is really giving me alot of grief. Is there a better IDE for working with Ruby, or do most of you just use text editors? Help a guy out! :) Edit: Im also learning that this may be a *bad* time to be learning Ruby. With changes from 1.8 to 1.9, and a makeover for Rails, it seems there is some compatibility issues (yes, that i have banged my head against a few times). Anyway, thanks for your comments. Thanks
 Ruby is quite slow, but we've not had any particular issues arising from its slowness in a web context. Scalability problems have largely been orthogonal to the runtime speed, though I'd say we've had to "scale" sooner than we might have with a faster runtime. If you develop or host primarily on Windows, and prefer IDEs, I would not recommend Ruby. Windows is a second-class citizen, and there's just less an IDE can do with a dynamic language like Ruby, short of going whole hog and keeping the runtime resident like Smalltalk.
It doesn't fit in well with an MS shop, though the DLR+IronRuby is supposed to have some support for Rails. So you might want to wait for that. NetBeans has Ruby support, but like the above commenter says, IDE's just don't work as well with a dynamic language like Ruby. I'm totally in love with Visual Studio (flame on if you like), but I write all my Ruby stuff in vim + a powershell terminal. I tried learning Rails using NetBeans, but it was an exercise in frustration compared to the editor+terminal approach. If you liked what you saw in Kubuntu, migrating to a Windows environment is fairly transparent. Get a good text editor and don't put any spaces in your Ruby install path and you'll hardly tell a difference. I recommend vim + the FuzzyFinderTextMate plugin. The Rails directory structure is a little bit weird at first, so some sort of editor plugin for navigating the directories is a big help. Oh, and deploying Rails using IIS does seem to be a nightmare. 
Speed-wise the current mainline interpreter is slow. The next generation of interpreters will be roughly Python-speed. In terms of fit, whatever you could currently do in IronPython, you *will* be able to do in IronRuby, but it's not ready yet. If you want to get used to the language, you can try it out with Silverlight 3, but you might as well wait until IR goes 1.0.
I develop Rails apps quite happily on Windows. I can't speak for the IIS question, however, because I deploy to a Linux/Apache environment. To be quite honest I mostly work in the Scite editor packaged with the one-click installer, which is quite customizable. Especially if you work with small source files and terse methods, likely if you use TDD, then that's plenty. Occasionally (much less often than with C#) I find myself having bitten off more than I can diagnose in a text editor and drop into NetBeans, which has enough debugging for anything I've needed yet. Of course, you don't need to leave VS at all: there's Ruby In Steel (http://www.sapphiresteel.com/) which has free and more capable paid-for versions. On performance: Ruby's WAY slower than C# for stuff where microseconds matter. It's fine for most tasks though - with my Rails apps I have several tens of gigabytes of data: the DBMS is more often the constraint. Mostly it turns out that I just don't need any more performance. Thanks due to Intel and AMD for fast chips, I suppose. 
&gt; With changes from 1.8 to 1.9, and a makeover for Rails, it seems there is some compatibility issues These things likely won't affect you any more than any other actively developed languages and frameworks. Regarding 1.8 vs 1.9, the main issue is that not all code has been updated for 1.9, but this is easily avoided by sticking with 1.8. Most incompatible syntax changes between the two are relatively minor, so it's not an issue to learn 1.8 and later move to 1.9. Regarding Rails, it's mostly the internals that are currently getting rewritten. From a developer's perspective, it's going to be more or less the same as it is now, but with the ability to do more (embed apps from other frameworks, switch out components) if you choose to.
**Speed**: well there's no sensible answer without knowing what you want to do with it. **Editors**: I recommend e Editor (if you want to set up a Cygwin stack) or Jedit (Jedit is fantastic) but neither is a full IDE. But you're going to be doing TDD, right, so you won't need the IDE training wheels :) **Servers**: you can go with IIS (there's ample help out there). We go with Apache + Mongrel. **Fitting in**: it's a whole different world and culture to the one you know. But I think if you're interested just plunge in. True, all the cool Ruby kids have Macs, but there are plenty of us rolling with Windows too so just ask for help in the usual places (stackoverflow, ruby-forum etc.)
By the slow "current mainline interpreter" I assume you mean MRI 1.8, which is indeed slow, but is no longer the current interpreter. Ruby 1.9.1, which I believe you reference as a "next generation" interpreter, is stable, "production-ready", and has been released almost two months ago. The widespread tendency to somehow cling to MRI 1.8 is something I cannot find any explanation for, especially considering the amount of flak 1.8 has been getting over the years for being slow and somewhat prone to excessive memory usage. You would think that when a stable version of the "faster Ruby" is finally released, users will rapidly migrate to it, but the opposite seems to be happening. Staying on 1.8 can be perhaps partially justified if you are maintaining an existing application, but there is no reason why 1.8 should matter to users new to Ruby.
IDE = NetBeans Download the ruby-only version and it's reasonably lightweight. 
The biggest reason is a lack of 1.9-compatible libraries. There's headway being made, but there's still a lot of very "core" stuff that breaks in horrible and interesting ways in 1.9.
It's dog slow in windows. It's more than twice as fast on linux as it is on windows.
Doesn't sound like you want to learn it at all. Stick with .NET.
apt-get install ruby-full still installs 1.8. Libraries haven't been updated yet. The majority of development work is not on new build, it's on maintaining and enhancing existing work that's been developed on 1.8. It's analogous to the situation that PHP was in for a while - a ton of code was written for PHP4, and it kept being written and maintained on PHP4 despite PHP5 existing and being generally better through sheer momentum. Personally, I'm starting to target jruby by default.
When I say developing with Ruby on Windows sucks, I mean *as compared to using Ruby on Unix-y platforms*. Using it on Windows is still better than the default .NET stack (in the cases I'm using it), if you ask me. It's not as bad as it used to be to get Rails running under IIS, and SQL Server plugin for ActiveRecord has some issues, but you may not run into them depending on what you're doing. I develop most of my apps on OSX and deploy to Windows for several months now, and given the option of using .NET or Ruby, I tend to choose Ruby in most cases. Even having to write my own monkey patches to get around some issues that have come up, overall development has been more pleasant and faster than I'd be able to do in C# and ASP.NET. If you go this route, feel free to send me a message (click my user name and look on the right for "send a message". I've got enough time spent dealing with issues that I might be able to answer some questions. I'm looking forward to using Rails with IronRuby one of these days, which will make integration much smoother I'd expect.
jruby is a great option, especially on windows. 
closest thing that can come to lisp in the non mainstream languages
Except for compiling C extensions.
Actually I've used it for a long time in windows. Using the one-click installer works rather well. For small apps (And small is relative), I often just start mongrel as a service in windows. Works great. So you dont have to fight IIS at all. I've even set it up to use windows domain credentials to login, and to use AD groups for access control. Making it very seemless. For some apps, that need to call AD, or want to use WMI, windows is the only game in town. If you building a large scale app that has 10's of thousands of users I would one it in Linux VM's, far more efficient. I've done 30-40 apps in Rails, and least 30% are in windows. I often do the development in windows even if its heading over to linux in the end. If you want some examples, look at http://mentalpagingspace.blogspot.com or email me 
You guys rock. Thanks all of you for your great comments.
Hpricot is designed to be an HTML parser - the fact that it parses XML is almost a side-effect of that. The fact that it handles HTML so well is one reason why I've used it - though Nokogiri has made a lot of headway as well. If you're just doing XML, though, stick to noko/libxml-ruby, definitely.
I'd really like for that to just go away. My brain revolts and plain refuses to remember what the various Perl inspired $[something]'s mean out of pure disgust. 
many of the major libraries, like hpricot, mongrel, etc, have java versions.
[Psst!](http://monkeybars.rubyforge.org) That being said, there are some design details in monkeybars that I'm not sure I agree with, and the documentation is somewhat less than ideal right now. You do need to know a bit about Swing to use Monkeybars effectively.
Why can someone only be in one community and not another? I primarily use Ruby and Rails, but am also very interested in learning the strengths of other frameworks and languages (even in PHP) - does that someone mean I can't really be in the Ruby community because I'm having an affair with Python or Erlang? Even though Zed's rant was perhaps a little extreme (was he playing a Kaufman-esque joke or not?), I think his point was pretty solid - we shouldn't be so xenophobic. *It's okay* to say that other frameworks/languages have strengths. It doesn't automatically mean that Rails or Ruby sucks.
&gt;Why can someone only be in one community and not another? Because he chooses to. Nobody "kicked him out" of the ruby community. He went frothing at the mouth, called the ruby community psychotics, called everybody all kinds of names and said he was leaving. &gt;I primarily use Ruby and Rails, but am also very interested in learning the strengths of other frameworks and languages (even in PHP) - does that someone mean I can't really be in the Ruby community because I'm having an affair with Python or Erlang? Of course not. That's you though. Zed is not you. &gt;Even though Zed's rant was perhaps a little extreme (was he playing a Kaufman-esque joke or not?) It wasn't a joke. Further posts on his blog and his highly erratic writings point to an unstable person. &gt;I think his point was pretty solid - we shouldn't be so xenophobic. The ruby community is most welcoming. It's full of brilliant, innovative, funny, kind people who do incredible work and bend over backwards to help newcomers. I don't know where you got the idea that the ruby community was xenophobic. That's the first time I have heard that and it certainly doesn't match my experiences and the experiences of anybody I know. &gt;It's okay to say that other frameworks/languages have strengths. It doesn't automatically mean that Rails or Ruby sucks. Sure. But Zed didn't say that. Zed said that ruby sucks, rails sucks, the ruby community sucks, and the people who program in ruby are psychotics comparable to murderers. He said he was never going to code in ruby again and said he no longer wanted to be associated with anybody who was in the ruby community. 
WTF, I swear you people are stalking me. I'm the one who wrote the lone tweet about this subject. I left an answer at stack overflow, but the summary is that I never could quite make it work with the Haskell FFI -&gt; C lib -&gt; Ruby FFI.
You've got a little something on your chin...
A couple of posts mention TDD... that's Test Driven Development. I'm not sure if that term exists in the windows world. That means, code tests before anything, see them fail, do the code, run again the test, fix whatever needs to be fixed. Ruby's philosophy is different from C#. Less verbose. Other languages tend to mix layers of abstractions. You see, data implementation (let's do this with a polar coordinates) mixed with business logic (pan 10 degrees to the north). With Ruby you want to keep them separate. We create Domain Specific Languages (DSL). You see that behaviour when you start with TDD. That's just a DSL for tests. As for the "maybe a bad time to be learning". On the contrary! Yes we are changing to 1.9. Here's a clean slate for you. You will learn it without baggages. And for Rails, well, I guess that you could learn some Merb and see what works for you :)
"With my students"
And the author probably doesn't get that yelling "you're doing it wrong" over and over again is not going to convince anyone who has done mock-first development and rejected it because its a pain in the ass. Generally in programming if it hurts it means there's something wrong with the approach you're taking, and mock objects make things hurt. I don't want to have to remember that I spec I wrote a month ago had a certain mocked off interface that I just renamed or changed the semantics of. The computer should be able to tell me the impact of changing implementations of mocked interfaces, it shouldn't require me to have a mental database of all places where interfaces are mocked in the spec suite, integration tests or not. 
I had to read that 3 or 4 times to realize that it was just you watching me, rather than some sort of sexual reference.
I'm not a programmer by trade, but I like to program as a hobby. Ruby makes it much more enjoyable. 
This looks really ugly to me. If I came across this in someone else's code I'd probably have to spend a minute scratching my head before rewriting it to look like: &lt;% if results.empty? -%&gt; &lt;li&gt;no hits found&lt;/li&gt; &lt;% else -%&gt; &lt;% results.each do |x| -%&gt; &lt;li&gt;hit:&lt;%=x-%&gt;&lt;/li&gt; &lt;% end -%&gt; &lt;% end -%&gt; What's so wrong with this?
[The blog post](http://weblog.rubyonrails.org/2009/3/16/rails-2-3-templates-engines-rack-metal-much-more) [The release notes](http://guides.rubyonrails.org/2_3_release_notes.html)
Agreed. I would much rather have code that is explicit about what it does rather than too clever. In the comments on that article, I also liked one commenter's suggestion of using this very concise syntax: ary.each do |i| puts i end.any? or puts 'none' 
I don't even like that. I'm a big fan of fail-fast; I'd rather have the don't-do-anything case up front. It drives me up a wall to see code this: if some_class.valid? # 25 lines of code else puts "SomeClass not valid" end 
I'm more used to seeing the affirmative case appear first, at least in most of the code I've worked on. But either way seems fine to me. This is more a chocolate-or-vanilla kind of thing, I think. Psychologically, when I write a condition I'm saying to myself: "If this is true, THEN let's do this, OTHERWISE let's do this other thing". Whereas you're saying to yourself "If my failure condition is true, THEN I want this to happen, OTHERWISE let's put on the big show". That wouldn't be an intuitive way for me to write a condition although I could easily adapt to that style if my coworkers were doing it that way. I'm curious: did you consciously change the way you wrote conditions at some point or did you always do it that way? 
This isn't exactly breaking news.
There's a tutorial here on using OpenID with authlogic: http://www.binarylogic.com/2008/11/21/tutorial-using-openid-with-authlogic 
It depends on the context, but I didn't mean to say that I prefer negative logic; I actually much prefer positive logic ("if something" versus "if not something"). If I find myself writing something like "unless ... else ...", I'll reverse it to be "if ... else ...". However if I'm defining a function, I like to write it like this: def function( n ) if n.nil? puts "n was nil" return end # here's a bunch of code end Rather than: def function( n ) if n # here's a bunch of code else puts "n was nil" end end I consciously started coding this way a few years ago when I got my first professional coding job and I had a lot of coworkers who were fond of the [arrow-code antipattern](http://c2.com/cgi/wiki?ArrowAntiPattern). 
Ok. I see what you mean. Thanks for the link. Never heard that term before.
haha... looks reddit'd. http://github.com/michaeledgar/harsh/tree/master
Welcome to almost two weeks ago.
I'm not the author, but I posted this because I agreed with him. I like using mocks, but I think that they should be used in cases where it gives a lot of benefit. If I'm depending on specific behavior in a model beyond basic create/update/delete stuff, I'd rather mock that in the controller's tests and test the model's logic in the model's tests. Then if I come back and refactor the model and break the interaction, it will be the acceptance/integration whatever test that fails instead of all of the controller's tests. Testing style, like most other things in programming, is a matter of personal preference; what looks clean and elegant to one person might look like a horrible kludge to someone else. The author here was replying to another blogger who had dismissed mocks using a bad example of their usage.
Seems like a tough job, but its worth a shot. I went ahead and donated.
Awesome explanation of Cucumber.
Looking very promising indeed. Also thanks for the more up to date git mirror too ;)
Okay, I'm sold now... Is macruby a complete ground-up project, or is it a fork that'll be able to keep up with core language changes? As the main ruby interpreter progresses, will macruby keep up?
&gt; As the main ruby interpreter progresses, will macruby keep up? According to the developers, that's a priority.
Yeah, but what I mean is it a fork that's got code merged in from the trunk all the time? Or is it maintained in parallel? It's a pretty big difference. The latter means it'll always be behind... 
Out of curiosity, why do you prefers rails over django? I'm not that experienced in either (I did the beginner tutorials in both and that's it). However while I keep hearing a lot of hate directed towards rails, no-one seems to dislike django.
works for me
If MacRuby is going to be based on LLVM, wouldn't it be possible to make it a cross-platform solution? LLVM can compile into many different backends, right?
isn't rubinius going to use LLVM?
Yeah, [looks like you're right](http://www.infoq.com/news/2009/02/ford-state-of-rubinius) about that.
As someone who is suffering through a platform where I have different charset encoding to deal with in ETL jobs, this article really adds a bit of clarity. Thanks. 
They were, but then Evan decided to write his own JIT instead. They had an experimental JIT working before they merged the "stack-full" branch, where they got rid of the heap-allocated stack-less call frame non-sense. Now the JIT doesn't work anymore but I think they're going going to get back to it soon.
Very informative article, would read again +++.
As an old Drupal rat, this... actually looks pretty neat. Anyone use it?
Probably because I used Rails before Ruby, but Python before Django.. I found Django rather unpython'y. It felt it uses far too much "magic". I could also never remember all the imports and "shortcuts", for example (from the tutorial) from django.shortcuts import get_object_or_404, render_to_response from django.http import HttpResponseRedirect from django.core.urlresolvers import reverse Like I said, it's probably because I used Python a lot before Django.. but I think Rubys flexibility does lend itself more nicely to Rails, than Python to Django
There needs to be a special term for an attempt at an April Fool's Day Joke, which is in all of its points true and then ends up looking like a joke made by an author at his own expense.
An April fail?
That's pretty good, except we should capitalize and pluralize "fail" to give us: "April Fails!" 
I like it, but I think you can take it utterly seriously.
That's your good for noticing. I was interpreting the article as the apology of a latecomer to the party.
So if this is a joke, does that mean he likes Perl?
 module Enumerable def threaded_map results = map {nil} ts = [] each_with_index {|obj,i| ts &lt;&lt; Thread::new { results[i] = yield obj }} ts.each &amp;:join results end end
Any reason this isn't default?
you're a little late to the party ;) http://www.reddit.com/comments/6co57/parallel_version_of_enumerablemap/ http://coderrr.wordpress.com/2008/03/19/parallel-maping/ what'd you use to make the screencast btw?
Well, shucks. That implementation is a little cleaner, too. I used gtk-recordmydesktop, followed by [mencoder](http://ubuntuforums.org/archive/index.php/t-1014814.html).
cool thanks i'll check it out
Hobo has had this for a long time: enum.*.bla(1) =&gt; enum.map {|o| o.bla(1) } http://github.com/tablatom/hobo/blob/d8b5b90d630e3911fab8655275cc043217bc32d8/hobosupport/lib/hobo_support/enumerable.rb
I started life out as a Perl hacker, and I do like Perl for very short system admin tasks and as a universal shell replacement. I wouldn't push Perl for large application systems, though.
You really think the points I made were all true? Here are the points I was arguing in non-obfuscated/non-sales-pitchy terms: http://enfranchisedmind.com/blog/posts/ruby-is-the-future-2/
I didn't think they were all true, but I felt that people could argue that they were true. To me, some are gray area items.. things which people do which seem to work okay for them despite the fact that many people from different programming cultures consider them horrific.
So, out of curiosity, if you were writing a web app or some such moderately complex piece of code, would you prefer Perl to Ruby or Python?
Good rule of thumb: if you look at your code and have to ask if it is too clever, it probably is too clever. In fact, it probably crossed the clever line a while ago.
I was under the impression that only one Ruby thread could be running in the interpreter at the same time. If that's the case then it doesn't really matter if it's threaded or not, the same work will get done in the same amount of time. Does this work doing actual work, and not just using sleep? Though this could be useful for io-bound tasks where most of the time is spent waiting and the threads are paused.
Rails
 # of iterations = 1000000 user system total real null_time 0.260000 0.000000 0.260000 ( 0.281800) map 17.120000 0.130000 17.250000 ( 19.205743) to_proc 44.220000 0.430000 44.650000 ( 50.080658) every 66.930000 0.670000 67.600000 ( 76.222073) 
personally, I'd add an optional parameter that lets you specify a maximum number of threads - then split the job up between them, because `(0..10000).to_a.threaded_map` would be quite interesting. Or you could use a thread pool. But it's a good start.
&gt; If that's the case then it doesn't really matter if it's threaded or not, the same work will get done in the same amount of time. It matters a whole lot if your code is waiting for IO.
Yeah, I mentioned that part..
Yeah OK, but I think that *is* the use-case really.
Well, for starters, resource exhaustion when you try to start 1m+ threads at once.
Of the three, I'd probably use Ruby, because the Rails framework is better than any Perl framework I know, and I don't know Python much beyond "Hello, World". Note this has everything to do with the frameworks available, and not to do with the language.
Sounds neat... looks?? who knows.. a demo/screenshots would be nice. (I don't feel like watching a video from a conference at the moment)
Threads are concurrent under JRuby.
A blue ruby is a sapphire. I knew it was only a matter of time before there was a sapphire programming language.
that matter of time was 2008... http://www.sapphiresteel.com/The-Sapphire-Programming-Language
http://www.sapphire-lang.org/wiki/1
(and i believe this was the first: http://www.perl.com/lpt/a/91)
OK so it's possible to make a really fast ruby by making small changes to the language. Why don't we do that? Also where is duby? 
I only half-disagree with that one. I wince at novice Ruby developers using method_missing, alias_method_chain, etc. And God help the one who's ambitious enough to try and walk through the code, without realizing some of that code doesn't exist in any file.
That seemed pointless?
Judging by the date on the linked HackerNews comment, this is rather old. Still interesting, though, even if there are easier ways of doing it.
I can't think of any practical case where you wouldn't know ahead of time how many levels of Hashes / Arrays you need in your structure. If the data is that amorphous then it seems to me that you would want some kind of tree. This looks like a solution only a Perl programmer could appreciate. If you know in advance how deep the structure will go, something like this will work just fine. data= Hash.new { |h,k| h[k]= Hash.new { |hh,kk| hh[kk]= Array.new } } 
&gt; This looks like a solution only a Perl programmer could appreciate. He's not joking. This autovivication feature is already in the core language, for anyone not familiar with Perl.
I can think of situations in the past where I would have liked to have that functionality, mostly when dealing with arbitrarily-nested form parameters. (a user can have a widget that can have a comment which can have tags which can...) But yeah, if it meant that kind of hackishness, I would have avoided it.
Arbitrary depth autovivication, as it exists in Perl, is very handy for lots of applications. I can't imagine needing to know how many levels I'd want up front, when writing Perl code. I also think the AVHash subclass is cleaner and more flexible than either the Y combinator approach or your static vivication example. 
I agree that the AVHash approach is better than the Y-combinator. But, if I have data with that many arbitrary levels, I think I would go with something like an XML library. (Not that I am a big fan of XML, just that an XML library would implement the right kind of tree structure and access methods.) The example I used actually came right out of a script I wrote to combine ARP tables with CAM tables to track the switch ports of IPs on our network. In this case, I knew that I needed Hash -&gt; Hash -&gt; Array for Switch -&gt; Port -&gt; MACs, so spelling it out that way made the code clearer.
Okay, so… it's cool and all. But, uh… what about “private”?
I found this when searching for "fuck yeah ruby" and subsequently lol'd.
I guess it scales now. *ducks*
I have the urge to downvote you, but I know you did it out of humour, so I'll let it slide.
Weeeeeell... i don't really want to make this argument, but... with Ruby 1.9 out and hardware so cheap (compare 2x hardware costs with 2x programmer costs) is it really such a gain to move to a "faster" language? I upvoted the story, but anyway!
I upvoted too - i like the line at the end about the yacht :)
But is it really 2x programmer costs? Is it only 2x hardware costs? I think its more like 100x hardware costs vs 1x programmer costs in twitter's case. And the hardware keeps growing while the programmer can decrease.
Well, maybe with pre-1.9 Ruby. Scala (what they're looking at according to this article) runs on the JVM, so it's a bit faster (and uses a bit more memory) than 1.9 Ruby. It also requires more code, i don't think it's right to say it requires no more programmers than Ruby. I'm not trying to say that Twitter should definitely do this or that because i don't know their specific needs and numbers. Just that it's not as clear a win for non-Ruby languages as it was pre-1.9. (Edit) After digging around a bit, i found [this](http://ikaisays.com/2009/04/02/twitter-ruby-on-rails-scala-and-people-who-dont-rtfa/). It explains a bit more (than Dave Thomas) about the likely motivation for moving to Scala: getting multithreading. Which pretty much rules Ruby out--even 1.9 doesn't have "real" multithreading (yet?), though maybe JRuby does.
Getting multithreading is just part of the overall need: concurrency. No digging around needed, Dave Thomas is quite explicit about it in this article.
Ruby 1.9 has real threads, not "green" threads like 1.8.
They should move to Wt ( http://webtoolkit.eu ). It's C++, provides very nice ready-made widgets and it scales like hell. You can deploy it using its own embedded HTTP(S) webserver or as a FastCGI module with Apache, IIS, etc.
Just what I needed for a MUC logbot I was working on.
They rewrote the entire backend in Scala and only use RoR for the frontend web serving.
Interesting article. I think the issue with Array#sum hits between the grey area of convenience vs correctness. Sure, ["this"].sum doesn't work, but [1,2,3].sum is very convenient and useful. The correct solution could be NumberArray.new([1,2,3]).sum (where NumberArray.new fails with an error if the passed array wasn't all numbers). However that is a lot more tedious to work with, and I'm not sure that there is much of a benefit in terms of reducing defects either.
I fail to understand why containers themselves should provide any other methods that are not related to, you know, containing things. Of course, this is what you get when you insist on "object-orientation".
Thank you! If convenience is your goal, `sum([1,2,3])` is also handy. If you absolutely, positively MUST scratch your opening core classes itch, you could write: def Array.sum(arr) arr.inject(&amp;:+) end And now you can write Array.sum(...) whenever you like without implying at individual arrays all know how to sum themselves. I'm all for convenience, I love Ruby, but at its heart it is an OO language and if we ignore the basic principles of OO thinking in pursuit of pretty programs, I fear we are really cutting *against* Ruby's grain, not with it.
This is the Liskov Substitution Principle in disguise. It's the case where a class isn't even a behaviorial subtype of itself.
If I may indulge in violent agreement, I agree with everything you said except I would state that Array#sum is what happens when you *fail to insist* on OO :-)
[Insightful as usual](http://www.butunclebob.com/ArticleS.MichaelFeathers.LiskovSubstitutionInDynamicLanguages), Michael. I should have caught that, especially given [prior claims on my part](http://weblog.raganwald.com/2008/04/is-strictly-equivalent-to.html "IS-STRICTLY-EQUIVALENT-TO-A").
it has a global interpreter lock
"so it's a bit faster (and uses a bit more memory) than 1.9 Ruby." It's a lot faster and probably uses less memory. The memory overhead of the jvm is marginal on larger long running processes. Garbage collection strategies become far more important.
Kinda why i think it's "too" clever... much of that is being cleaned up and refactored for Rails 3
Their performance problems aren't with the web interface. The problems are with the backend messaging system. So moving to Wt wouldn't help.
I fail to see why array.responds_to? :sum == false in case its contents don't allow summing whereas :checking_account.responds_to? :write_check == true even if the balance is == 0 and you won't be able to withdraw, for instance.
Matz seems to think that letting a method raise an exception is just as valid, if not more so, as using respond_to?. (I don't agree, just sayin'.) [source](http://www.ruby-forum.com/topic/97965) &gt; We haven't implemented a method that can't be executed. Object#dup just fails if the object is not able to be duped. 
Moving to Wt would certainly help, even if indirectly. If you have a C/C++ backend and a Ruby frontend, you need to write Ruby bindings or use some kind of backend-frontend communication mechanism (i. e. one more thing to take care of and one more layer of inefficiency). If you have a C/C++ backend AND a C++ frontend, you need not write bindings: you just link and are done. Not to speak of the myriad of high-performance C/C++ libraries already available for almost everything.
This is exactly the sort of thing Haskell's type classes were designed to solve. For example: Prelude&gt; :t sum sum :: (Num a) =&gt; [a] -&gt; a So the ideal syntax – here just an unary function – is available but restricted to lists of numeric things. I wonder if there is some way to retrieve Array#sum in a restricted fashion.
I think this argument is confusing state with essence. Yes, the state of [ 1, 2, 'abc' ] means it's not summable. But the state of a File object for a read-only file means it's not writable. Does that mean File shouldn't have a write method? Actually, it looks like mtoledo made much the same point while I was waiting for reddit to register me. 
Very good question. My thought is that there is a difference between an account that *sometimes* permits a withdrawal and an account that *never* permits a withdrawal. Orange Savings accounts *never* permit withdrawals. ElectricOrange accounts usually do. Likewise if you have a certain array and it sometimes contains all numbers and you want to sum them, but it might contain an element that causes #sum to raise an exception, the programmed behaviour seems correct. However, identifying an array that sometimes contains numbers is not the same thing as identifying some arrays that contain numbers and some arrays that do not. In fact, some arrays might contain numbers but there might still be no semantic reason to sum them: an array of object ids, for example. My feeling is that if you have a container that might contain numbers that need to be summed, it ought to respond to #sum, and it's ok to raise an exception if it happens not to contain numbers when you invoke the method. But if semantically a container never contains things that can be summed, it should not respond to the #sum method, just as an Orange Savings account should not respond to the #write_cheque method. JM2C.
#sum should be defined on the Number (or FixNum, whatever) class. As a "collective method" (or swarm method, if you love biology metaphores.)
The numbers i've seen (re: Scala vs. 1.9 Ruby) suggest that's not the case. That Scala is a lot faster in some areas, no faster in others, and almost always larger in terms of memory/code use. I might be wrong, i'm not totally familiar with Scala.
What about Array#min and Array#max? They imply the elements of the array not only are comparable, but comparable with each other. If you try to write a check with an account of 0 balance, you get an exception indicating that invalid state. What about an appropriate exception when you can't sum the elements of the array? What about Array#sort? Also implies comparable elements, but it accepts a block. What if Array#sum accepted a block with two arguments, and you're responsibility was to add those two elements and have it be the return value of the block. But the default behavior was to call the + method lhs and pass it rhs.
Patches, which improve ruby's memory footprint and gc/threading behaviour. Interesting read: http://sites.google.com/site/brentsrubypatches/
I agree. I think that if you have an array of unknown values that you want to sum, *you* are doing something wrong — not the language. Create a subclass of Array called IntegerArray and add functionality to make sure only integers makes it into it if you run into this problem a lot.
Yeah, but no longer can you just hit up the documentation for Array and find sum in there. If you have a bunch of unknown types of values in an Array, and you try to sum them up, it seems *you* are doing something wrong, not the language itself.
Yeah, i agree. But then, in that case, having Array#sum is perfectly fine as he might contain numbers that might be semantically summed. And if you want an array of object_ids or strings or something else that shouldn't be summed, you should just have a StringArray class, which doesn't respond_to? :sum and than you could do things like check if is_a? String when adding, etc, like an actual Orange Savings Account. But the actual Array class is a Checking account, not a Savings one.
This is a silly objection. As others have pointed out, there are tons of reasonable situations that would be precluded by the rule that "not all X can be Y'd, so at most some X's should implement #Y." For example, a filehandle that you *know* will never be writable. What's your solution here? Build a special file class that doesn't implement #write? An OO interface isn't just the presence of a method. It's the entire behavior of the method, and sadly that can't be entirely captured by a method signature. Array#sum (which really should be Enumerable#sum, but hey, let's not nitpick) is a method that applies #+ in a certain manner to its members, and if they error out, then that error gets propagated. *That's* the interface, and it's a perfectly reasonable one. Heck, _this is the whole point of duck-typing._ We can write Array#sum and it can apply to anything that responds to #+ and returns something else that responds to #+. We don't have to make a subclass for every possible semantic case and end up like Java. 
 Prelude&gt; head [] *** Exception: Prelude.head: empty list Prelude&gt; 1 `div` 0 *** Exception: divide by zero Typeclasses didn't catch those. The above examples are classic motivating introductions to dependent types. Every time I say 'if (such\_and\_such(x)) { y(x); }, I have shown that the x in y(x) is such\_and\_such, which is its interface. There are x's that are writable(x), nonzero(x), etc... So the x in the conditional test is a superclass of the x in the consequent branch even though a type system might not be smart enough to see it. The author is discussing the modularity of standard libraries, not type systems. His conditional tests for an interface are an attempt to isolate a subclass of x for the consequent branch. Unfortunately the standard library assumed something about x which is not statically required to be tested in any conditional, just as head is statically defined on all lists in Haskell. With good modularity the conditionals will be meaningful and will isolate a subclass of x. Array#sum has poor modularity in that it depends on both the type of the receiver and of its contents, thereby increasing the complexity of the conditional test required to eliminate runtime errors. IMHO.
You should link them so we can make an informed statement. My guess is this. You are talking about micro benchmarks. Something like the tak benchmark. This is a small algorithm with maybe 20 lines of code. The jvm has a memory overhead of 10+MB. Obviously the 10+MB will stand out for 20 lines of code. That overhead absolutely disappears for any kind of production system. In the production system the garbage collector makes a much bigger difference in memory usage. btw, I've been programming ruby professionally for 4 years and still pick it over any other language. I'm simply being honest about the state of ruby given my experience. I've been doing a lot of jruby the past 6 months and the jvm is an awesome platform. 
jruby, because its in the jvm, has pthreads without the global interpreter lock. Besides, why use threads? There are better ways to achieve concurrency (e.g. Actors).
If there's a global interpreter lock, using an actor library won't really help.
Are any of these going to be incorporated into ruby?
I've been using jruby at work for the past 6 months or so. This past week I wrote a threaded indexer using java's util.concurrent library and I have to say it was easy given that the entire project took about 200 lines (not counting tests). Actor's are great too, but it's good to have options. I actually prefer IPC with separate processes most of that time, but that's a story for another time. 
I think he was suggesting an actor model for jruby or on the jvm, in either of those cases it wouldn't have the GIL. Jruby uses native threads without a GIL. 
Woot. I just got into an Arduino class at UCSD, and I am also learning Ruby (for my web projects). Bookmarked. Thanks.
&gt; Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. &gt; &gt; - Jamie Zawinski To do this properly, you need to parse the abstract syntax tree. Tools like cscope do this properly for refactoring in c. Ruby has libraries that let you accesss the AST. If you use a tool based on regex, you're going to have a serious mess.
Do you mean `arr.inject(&amp;:+)`? I would say that `sum` *is* defined on the Number class, it's just called `+` :-)
Not again: http://www.reddit.com/search?q=andand
object.try is new in rails 2.3 and does this already, you only need this gem if you are on old rails
1. `Object#try` has different semantics, or at least it did the last time I had a look at it, and; 2. From time to time people use Ruby without Rails.
New Collaborative Ruby Blog featuring postings from James Britt, Gregory Brown, Kirk Haines, Robert Klemme, Jeremy McAnally, Sean O’Halpin, Magnus Holm and Lakshan Perera.
Yeah, I've had a great time playing with it. I'm a bit leery of relying on it for anything other than toy/demo apps, but only because they're not asking me for money :) I'm hopeful that we'll see some ideas about the plans and pricing soon!
I'll be on board when I can write to disk in some kind of permanent way. This is necessary for something like a ferret full text search.
Your point is valid, but you shouldn't be using ferret anyway unless you hate yourself. Try sphinx. We moved from ferret to sphinx recently and I'm never going back.
I second the sphinx recommendation, but how would that solve the problem of not being able to write to disk? Sphinx still has to store its indexes somewhere.
I'll try it once they announce pricing for it. It's been in beta for a long long time so far...even a ball park figure would be useful so I can compare it to running a vps
You're right. That's what I meant by saying "your point is valid." I could have been clearer. Cheers
I actually use lucene.
I used ferret years ago and it was unstable back then. I keep hearing that it's greatly improved. Why do you find sphinx so much better? btw, I used ferret as an example because that's what heroku has installed by default. 
I'm using thinking sphinx, so my opinions are oriented around that. Not to pimp my own blog, but since you asked, I wrote this about my experience: http://blog.semanticart.com/comparing_thinking_sphinx_and_acts_as_ferret_for_full-text_indexing_in_rails the two big winners in sphinx VS ferret are sphinx's memory usage (kb versus mb) and indexing speed.
Worth reading and therefore upmodded, even if I don't agree :-)
bonnified? really?
Thanks for the info. The reason I haven't tried sphinx is that the documentation doesn't say anything about controlling the indexing process. For example, in lucene I create a lot of custom filter chains that vary greatly between data sources; i.e. custom tokenizers, stemmers, etc. Do you know if this sort of thing is possible in sphinx?
I don't know about your specific needs, and my usage thus far has been fairly simple, but you can define sql queries to specify what to index and there's a good number of options for settings including stemming, etc. Fwiw, it also handles ActiveRecord associations well if you want to index a child attribute or whatever. The peepcode pdf for thinking sphinx is pretty helpful although slightly outdated in a couple places.
This is retarded ['1', '2', '3', nil, '5'}.compact.map(&amp;:to_i).map {|i| i * 10}.sum Does not have to be rewritten as: sum(map(map(compact([1, '2', '3', nil, '5']), lambda {|i| i * 10}, lambda &amp;:to_i ))) Instead do it the "right way" ['1', 2, '3', nil, '5'].compact.inject(0) { |sum, v| sum += v.to_i * 10 } ZOMG! I don't understand why that's hard, the docs for Enumerable#inject even sum a sequence as an example. 
Summing numbers is kind of the "hello world" for reduce (or whatever your languages chosen name for reduce is) isn't it? Maybe I'm missing something that requires the overly complicated alternative the article suggested? I also don't really understand why he's using a mess of maps instead of a reduce in the first place, but wtf do I know.
http://docs.heroku.com/full-text-indexing
If you need to write to disk on Heroku you have a few options. Put it in the DB. Put it in S3. Put it in the tmp folder (which is very transient but good enough for ferret). 
I'm getting ready to start a project on heroku using ferret. I don't think the tmp solution is good if your data set is large, luckily mine won't be for a while :) I'm curious to see if ferret can use a db or s3 for it's index in a sane. I don't mind if there is a lag in the time it takes the index to update. 
Great. And I just found out you can run Django, and any other WSGI-compatible framework, [via Passenger too](http://github.com/kwe/passenger-django-wsgi-example/tree/maste) \\o/
Is that like techie queues?
They heard we liked plugin management?
This is currently not a heavily promoted feature. It started out as an experiment to show that it's possible, but we were and still are unsure how much demand there really is for WSGI support.
Pluggin I'd like to write (or even better, have someone else write for me): gem install &lt;whatever&gt; on &lt;insert package managed system&gt;: 1. downloads and builds the gem 2. builds a system packing using predictable system package naming scheme 3. installs system package, thereby installing gem (albeit indirectly). In a perfect world, all system packages get converted over to using this system. Nicely solves the system package versus rubygem issue, *and* makes it dead simple to use the latest gem version or a gem version from, say, trunk while still being all warm and cuddly with dpkg or rpm or whathaveyou.
To me, that's a feature of "for" - not an evil. An example: The other day I was working on a system where there are some predefined variables and any number of customer defined variables that go into making a pricing calculation. The customer writes the complex pricing formula and Ruby evaluates it. In this case, I *need* those variables to exist outside the scope of the each block, and I have no way of creating them outside of a loop since the names are unknown before run time.
The gogaruco schedule is http://gogaruco.com/schedule/ and there are people chillin' in #gogaruco on freenode :)
Why is the code sample in the screenshot typeset in Comic Sans?
Because all of the code samples in the book are in that font... which seems really cheesy and unprofessional to me. Also, the code samples use camel case for variable and method names. I hate silly arguments about code formatting, but using underscores for variables and methods is a very well-established practice in Ruby and it's just silly not to follow it. Or rather, it's one thing to not follow a language's accepted conventions in your own code, but it's bad form not to follow them if you're writing an introductory book to said language. Still, it's nice to give away a book for free. I'm not sure why we need yet another introductory book to Ruby, but whatever.
I also have a problem taking seriously a Ruby book that uses CamelCase for variables and methods. Another kind of lame example is the ch 19 Rails blog that is basically scaffold code. But instead of using the helper methods that map.resources :posts in routes.rb provides, i.e., posts_path, post, new_post_path, etc., the author uses the older: &lt;%= link_to post.title, :action =&gt; 'show', :id =&gt; post %&gt; instead of &lt;%= link_to post.title, post %&gt; which is right there in the index.html.erb page under the show link. I'm all for free books as well, but if beginners are going to be picking up bad habits, what good are they. 
&gt;Because all of the code samples in the book are in that font I had to go and download it just to verify. Holy fuck. That is ridiculous. Is comic sans even monospace?
I wouldn't recommend this book. If you're an experienced Rubyists, there's nothing really to see in here. On the other hand, if you are getting started with Ruby (this book's intended audience), you will learn habits that are not the recommended de-facto Ruby coding style.
Thank you for your comments. In the course of writing The Book of Ruby and its smaller sibling, The Little Book of Ruby, I have had occasional discussions with readers who like or dislike the fonts and naming conventions. The reason for adopting both the fonts and naming conventions can be summarised in a single word: Smalltalk. Early versions of Smalltalk introduced Bitmap fonts which often had characters somewhat similar to those of Comic Sans. In the course of my writing career (I have written programming columns on many languages - Ruby, Java, C’, Delphi etc. etc. - in UK computer magazines for over 20 years) the convention of using a mundane font such as Courier for code blocks has been unwillingly forced upon me. Bearing in mind Ruby’s very great debt to Smalltalk, I decided to break out of that convention and try to replicate the feel of the old Smalltalk code ‘look and feel’. The naming of variables is also taken from the Smalltalk tradition. I don’t really believe that each language needs to have its own “accepted conventions” in the naming of variables or that “it's bad form not to follow them if you're writing an introductory book to said language.” On the contrary, in my view, clear code is clear code in any language. If it’s clear in Smalltalk, it’s clear in Ruby - bedsides, which, I happen to like that style. If other people don’t, they are entirely free to write code just how they wish. Finally, one thing I should probably clear us is that The Book of Ruby is not merely ‘an introductory book’. It certainly does introduce Ruby to those who are new to the language. But I trust that the reader will find that it goes much further than that. best wishes Huw Collingbourne
Thank you for your generous time and effort, I'll enjoy having a read through shortly. I do strongly disagree with you on a number of your points though, and think you undermine your cause by not teaching people idiomatic Ruby. Your choices for breaking with convention are very personal to you. Except, the book and code isn't for you; really it's for everyone who isn't you. Most programmers will write in more than one language, on the web often for the same project, and you need to have the ability to switch between language conventions and idioms. And so with a great service comes a great disservice.
&gt;I don’t really believe that each language needs to have its own “accepted conventions” in the naming of variables or that “it's bad form not to follow them if you're writing an introductory book to said language.” I took a course in Ruby at Harvard Extension school recently and I was highly annoyed when I got points deducted from homework projects because I used camel case rather than the underscore in my naming convention. After years and years of programming, I'm more comfortable with camel case and I am annoyed by use of underscores in naming conventions. Furthermore, I am turned off by the Ruby mafia telling me how to name my variables when camel case perfectly acceptable in the programming world. This issue is enough to turn me away from Ruby. 
I figured this belonged in ruby, since a lot of Rails developers are a bit frustrated by having to manage configuration for apache, nginx, and/or whatever else, and my sample templates are what I use for rails-y stuff.
Nope.
I agree with you on the topic of conventions. Great work on the book man. One thing that irked me was the permissions thing. Why not license the book under "Creative Commons", requiring only attribution, and not allowing commercial use? Why not allow people to make changes to it as they please and release for free (since it's already free)? You could even make it a community project, updated quickly by the community when required.
There is an expression that's relevant to this: "When in Rome, Do as the Romans Do". There is almost no difference in programmer productivity when using camel case vs separating words by underscores. Reading and typing "someFunction" is no more difficult to me than "some\_function". I've been programming mainly in ruby and haskell lately. Unlike ruby, haskell uses camel case, yet having to switch between the two notations hasn't been difficult at all. However there is a large benefit with sticking with one notation. When using method names, there is no need to guess whether the name is send\_input or sendInput. Also, if you import two different libraries, you will never have to deal with using two different notations in the same file, eg aVar = some_function(anotherFunction()) vs a_var = someFunction(another_function()) This issue belongs in the same class of issues as coding style, indent size and spaces vs tabs - important to be consistant, but the choice doesn't really matter. An inability for a programmer to switch between naming conventions without experiencing high amounts of frustration in my opinion indicates an inflexible and incompotent programmer rather than a poor and inflexible language.
I am entirely in agreement. It seems to me that some people put great emphasis on trivialities (e.g. how variables are named) while paying scant attention to the really important things (e.g. language ambiguities). As a developer of the Ruby In Steel IDE I have had to go into the Ruby language, libraries and interpreter (Ruby and C code) in nit-picking depth to ensure that our IntelliSense and debugger are able to support some incredibly strange constructs in Ruby. One reason for writing The Book Of Ruby was to introduce people to some aspects of the language which are not well documented elsewhere for the simple reason that, unless you are doing the sort of work that we are doing to support Ruby (which very few people are!), you probaly will never come across them! It has always struck me as very odd that so many people in the 'Ruby community' believe there are inviolable rules which dictate the 'Ruby way' of doing things. Unfortunately, all too often this involves mundane issues such as naming conventions rather than more important issues such as deep encapsulation (something which is poorly understood by many Ruby programmers) and avoidance of ambiguity. What is boils down to is this: if people don't like the way I name my variables and methods, they won't like my book. That's too bad since I have no intention of changing the way I name my variables and methods! :-) Best wishes Huw
Upvoting you sharkfish, because even though you're wrong, your comment is both [informative and on-topic](http://www.reddit.com/help/reddiquette).
You could also do: BANAL_MESSAGE_FOR = Hash.new("I don't know what you are doing").merge({ :edit =&gt; 'You are editing.', :show =&gt; 'You are viewing a single instance.' })
Calling procedures in Ruby is not exactly the same as creating a DSL
The conclusion is not a shocker at all. New rules: no performance, memory benchmarks with OCaml. 
As noted in a comment, you can use the K Combinator or [Kestrel](http://github.com/raganwald/homoiconic/blob/master/2008-10-29/kestrel.markdown). In Ruby 1.9 or with [andand](http://github.com/raganwald/andand/tree/master): { :edit =&gt; 'You are editing.', :show =&gt; 'You are viewing a single instance.' }.tap { |h| h.default = I don't know what you are doing" } Or the Rails Way: returning( :edit =&gt; 'You are editing.', :show =&gt; 'You are viewing a single instance.' ) do |h| h.default = I don't know what you are doing" end This seems to express what the author is saying very cleanly to me.
Programming complexity is the usual reason. Threads get nasty faster than you think. Also, MRI's threaded IO sucks, which is one reason EM was written in the first place. Leave concurrency to the kernel, it's better at it :-)
Agreed. Until three months ago I had been doing Java for six years. In Java-land, camel case is king. Now I am doing Rails, where underscores are preferred. I didn't even consider writing my code using camcelcase; all the code examples, documentation, and pre-existing code used underscores, so I did as well. It was neither difficult nor worthy of worrying about. Yes, it's a style issue, but as you said "when in Rome..." Also the use of Comic Sans -- a non-monospace type, and a ridiculous one at that -- in a programming text makes me discount it immediately. 
Wouldn't is just be easier to use something like packet? It's not hard to write a server yourself, but it's basically boilerplate code, except you have a lot more testing to do. Also, whats the expansion for EM? I'm having a hard time googling it. Finally, if your service can be over HTTP, Sinatra makes it so painless it's fascinating.
I been messing around with Ruby the past couple of months. I moved on to trying out rails but want to come back to programming 'offline' apps. I've noticed that learning gets a lot easier for me when I've got some good tutorials/ebooks to use but couldn't find good material for building a gui front-end for my ruby apps. Tk is documented in the ruby help file, but I really don't want to work with it. Qt's docs are all C++ based and the tutorials I found online based on ruby was for building a game, whereas my goal was a boring old desktop app. I tried out shoes, but it's really limited in its feature-set currently and I can't get it to play nice with gems. Finally, I moved on to WxWidgets, which comes with a great demo app written in ruby, touring most of its capabilities but for a noob like me, it was kind of overwhelming. Noticing the great number of ebooks targeted at budding ruby developers, I was hoping that perhaps a great ebook or set of tutorials existed for programming a gui for ruby? tl;dr: just read the title...
http://rubyeventmachine.com/
There is also the reactor library which is tiny (100 lines or so). 
Shoes is about the only GUI thingy which isn't either a direct-mapping to the equivalent C API, or Visual BASIC.. It's actually pleasant to write, surprisingly flexible, and easy to make decent looking application
you can make thin run in multiple threads if you want... to get the best of both... 
I don't think you are going to find a lot of documentation on ruby GUI stuff because it's not done so much. You should look into both monkeybars (swing) and glimmer (swt). They both have pretty good community support where you can get your questions answered. Shoes also has an active community although it's less mature as a GUI framework. If you go with tk, qt, wx etc you might find a lot of python docs which might be easily translated to ruby. Good luck.
There is a good book entitled "FXRuby : Create Lean and Mean GUIs with Ruby". AFAIK, FXRuby is cross-platform, but works particularly well on Windoze (Since Windows Ruby One-Click Installer seems to install Fox, Scite, etc.) I've been trying to learn how use XCode and MacRuby which is going to be an awesome combo a) once I learn it better b) once there is more documentation on HotCocoa, which maps Ruby syntax to come of the extremely verbose NSWindow/NSView syntax. This of course is only if you use a Mac. Hope this helps. 
[shoes](http://shoooes.net/) [shoes](http://shoooes.net/) [shoes](http://shoooes.net/) [shoes](http://shoooes.net/) [shoes](http://shoooes.net/) [shoes](http://shoooes.net/) [shoes](http://shoooes.net/) [shoes](http://shoooes.net/) 
Yeah, but nobody knows shoes!
If a programmer can't tell the difference between what is convention and what is code--then maybe he shouldn't be programming in the first place. While it may be annoying that he's not using social conventions, the code stands valid. As long as users aren't using this book exclusively (which nobody should to learn anything), I don't see what the big deal is.
The wxruby mailing list was active at one point, but shoes and other stuff is prob better for alot of stuff.
Ah yes. Ruby with a thick Haskell accent. I've seen C with a thick Lisp accent. This is nothing.
Try "wxruby" and "qtruby4" (gems). The second one is for making GUI apps, using Qt, and the first uses wxWidgets, I think. A few days ago I was looking for the same information, and in my opinion there's no fair to make GUI in ruby apps.
Mostly reference. Integers are actually passed sort-of by value unless you've already done something that forces them to be an object (eg. call a method on them).
There's also the lazy way. foo.bar.baz rescue nil I'm not advocating use of that, but I won't pretend I don't use it constantly in one-off scripts, either.
 def change_string(s) s.downcase! s.gsub!(/[aeiou]/, '_') end junk = "THIS IS SPARTA!" puts junk change_string junk puts junk ---- $ruby by_ref.rb THIS IS SPARTA! th\_s \_s sp\_rt\_! BY REF! 
Judging by the comments, the answer appears to be that there is no common agreement.
Shoes is sweet.
I don't see articles in /r/ruby with links to technical papers often enough. I'll have to come back to this one some other day when it's not so close to the time I get off work!
This is seems like a relatively big deal considering some of the dependencies. Am I crazy?
see [andand](http://weblog.raganwald.com/2008/01/objectandand-objectme-in-ruby.html)
That is sad there is a lot of great stuff that is dependent on this project. I am sure some will work around it, but others will probably just reach EOL as well...
I'll miss heckle.
there is a possibility of getting heckle to work by making it file-based rather than reflection-based.
There are already plenty of soap clients. What's sorely lacking is a halfway decent soap server library. Also you have a dependency on nokogiri which last time I checked didn't work with jruby. Perhaps using hpricot would be almost as fast but also give you jruby compatibility. Finally... Yes soap4r needs some TLC but it's pretty damned easy to use as a client. soap = SOAP::WSDLDriverFactory.new(url).create_rpc_driver response = soap.SomeSoapCall(request_params) Looking at your documentation it seems like I'd have to do a lot more work to get the same result. I don't mean to be harsh. I really don't. It's just that I have been very frustrated with trying to make ruby play well with soap and hate to see so much work going to building another client when the client is the easiest part of all. I have made soap calls with CURL sending raw XML and then parsing the raw XML that came back. actionwebservice needs serious love. There is no decent alternative. Every two weeks somebody writes to the ROR mailing list asking about being able to serve soap requests from their rails app only to be greeted by deafening silence. please, please, please, please please somebody pick up actionwebservice and give it the love it deserves. 
Appreciate your feedback. A soapserver was out of the scope of what I needed. So was jruby. Are all libxml-based parsers incompatible with jruby? You're right that building a client is fairly easy; It's just that the only one I could find, was bloated and crufty to work with, so I wrote my own. Incidentally, you might say that it's not much more than a toolbox for manually sending XML forth/back over curl. &gt; Looking at your documentation it seems like I'd have to do a lot more work to get the same result. Yep. The problem is that soap4r only works like that if you're very lucky. If it does; By all means, use that. But when you have to muck about with it manually, it's a pain to work with. Or at least, that's what I think. &gt; There are already plenty of soap clients. Really? The only one I could find was soap4r. Do you know of any other?
&gt;Are all libxml-based parsers incompatible with jruby? Yes. Hpricot uses a C based library too but the library has a java equivalent so it works. &gt;Really? The only one I could find was soap4r. Do you know of any other? wso2 is the other one (it has a server lib too but it doesn't even generate WSDL for you). Of course as I said there is always net::http and raw XML. 
You have forgotten to read it, I think... Ruby and Java pass a reference, ok, but they pass it by copy ;) This is just a terminology problem.
This library looks interesting. Did you check out my [SOAP library](http://github.com/jeremydurham/serviceproxy/tree/master) as well? They seem to be similar in some ways. 
C++ passes by value by default. You can pass by reference with the &amp; operator. Passing by reference us usually taken to mean that the function receives the address of the argument, NOT the address of what object/value the argument is pointing to. For example, the following (in pseudocode) is not possible without pass by reference: def swap(a,b) temp = a a = b b = temp end x = 1 y = 2 swap(x,y) // now x = 2 and y = 1 The terminology is not helpful. You can pass-by-value even when passing a pointer. Pass-by-reference, while still passing a pointer, is actually passing a pointer to the variable holding the value rather than the value itself. An extra level of indirection. 
Why wasn't the interface preserved in 1.9? This is (was) one powerful module.
&gt; OpenSSL extension compilation on Gentoo fixed &gt; The Ruby OpenSSL extension didn’t compile correctly on Gentoo. This issue has been fixed by applying a patch by the Gentoo developers. I'm glad to hear it! Great work everybody.
I'm so used to "Enterprise" being a punchline I was surprised to find this is apparently real.
once compiled to bytecode, 1.9 drops the AST
I didn't try your project beforehand, had I known about it, I certainly would have. It looks remarkably similar to Handsoap. It's almost scary how much they look the same actually. I noticed that you use XmlBuilder. I started out with that, but found that it didn't work as fluently with all the namespaces that SOAP messages often have. Looking at your code, I'm beginning to doubt whether that was a good choice, seeing that you made it work pretty well. How have you found it? Have you run into some corners with it? (Such as setting a namespace on an attribute)
http://twitter.com/d2h/status/1590279638
Same thing happened last year. Why doesn't DHH register it for more than a year? Last Updated On:23-Apr-2009 00:07:53 UTC Expiration Date:19-Apr-2010 22:40:29 UTC 
Because he doesn't have $70?
This sucks. API mirror? 
http://www.gotapi.com/rubyrails
bad link: it pulls you right back to the regular Rails site. use this: http://www.railsbrain.com/
 since you're working in rails, you probably have bash open; pop open a new tab and do: $ gem server then go to http://localhost:8808/ [edit: why the hell won't it do line breaks? and it isn't taking my markdown formatting. grrr]
Err was the whole point of this code to get the line: yo dawg("I put a") clone in_ur clone so_you_can(print) while(you print). to compile? I think this should really be called ru/b/y
compile... riiiiight http://www.iolanguage.com
I sure hope it was.
pretty neat :)
I think mine is better ;) ~150 LOC in Ruby, Ramaze and Sequel. Have also API with basic auth: http://github.com/zh/turl/blob/c56dad12073e7c91ddf5203b4f4c6c434880e3ae/turl.rb
When do we get 1.9? Actually will all you gem authors get off your lazy asses and fix your code so I can use 1.9 already?
Dear god, their entry-level professional solution (50MB? that's tiny.) at the recommended number of Dynos is $123/month. This makes me quite hesitant, despite how innovative their solution is and the rails-specific benefits it may have.
It seems too expensive for hobby projects. I'm not willing to pay for Blossom + 2 Dynos, when I can have 4 virtual servers for the same price, which can probably host 20 Rails apps.
you could always do Blossom + 1 Dyno which is free
Remember that dynos are per hour, so the quoted price is if you use them fully all month, which you probably wont. Edit: Also, that's 50MB static content, heroku has a read-only filesystem. 50MB of just compiled code and deployed images is pretty much, you keep all the dynamically served content somewhere else, like S3, which i would have to grant would cost even more.
1 Dyno is roughly equal to one mongrel instance, so you could run 20 rails apps on heroku completely free as long as you don't use more than 1 dyno per app, i don't think a hobby project would need more than one.
I understand it as 50MB of database storage. Nowhere does it say anything about deployed size, I guess there's really no limit here.
I'll take a Zilla with 40 dynos, a side order of nightly backups and a nightly cron. And I need two Blossoms with 1 Dyno for the kids. That'll be $3032. Please drive through.
That's right. One Dyno for free is great, but beyond that, all options seem expensive to me. EDIT: I did a simple calculation and you pay 1$ for 100,000 - 1,000,000 page views for 2 Dynos depending on your cpu time per request. Looking that way, it's not that expensive.
http://apidock.com/
11 votes? crazy you ppl are...
kiss my ass. errr... I meant to say... patches welcome!
Except it isn't that you get 2 dynos and they only kick in when necessary - they have to be adjusted manually, and when you have 2 dynos active, you're paying for both. You could write a script that kicks them on during peak hours with their gem/rake interface, but it isn't just paying for raw CPU time.
Oh, then i stand corrected. I actually thought you payed for raw CPU time. Well, it's still cheaper than EC2.
true, but not by much. two dynos are $36, 2 ec2 instances (small linux, bandwidth uncalculated) is $43.80. EC2 has gotten crazy cheap over the last few months.
it *is* for database storage, look at how the page is organized - database options vs. dyno options. i use heroku on and off for pet projects, but i forgot how static content is counted. i didn't follow the free app migration to heroku garden (stayed at base), so i had to use git to keep going, losing the web dashboard that held all that info as a trade-off.
That was my first thought. It seems quite expensive. Heroku doesn't seem to compare favorably to App Engine. The only thing I could see is if you really want/need to use Ruby. 
Here's another one: http://github.com/cannikin/gattica/tree/master
Also, with amazon, space is significantly cheaper (500GB is 75/month + 1 instance cost @ around 22 so 97/month, vs. 200/month)
I've been using Heroku for a couple of weeks and fell in love with it. I'm glad that they are still providing a free service but am wondering if 5MB is really enough storage for a personal site/blog as they tout in their [pricing](http://heroku.com/pricing) page.
Try filling a database with 5MB of blog posts. If you do, colour me impressed.
Or: class Factory def initialize classes @classes = classes end def self.create(name,*args) @classes[name.to_sym].new(*args) end end Usage: MyFactory = Factory.new({:circle =&gt; CircleShape, ... }) shape = MyFactory.create(:circle) The method shown in the article looks rather un-Rubyish to me. 
probably a dumb question, but why doesn't this post show up in http://reddit.com/r/ruby/new ?
cool!
But that would mean that Ruby programmers do the same thing as programmers in every other language with named procedures!!
I would like to avoid doing : Array.index(Enumerable.find { |blarg| blarg =~ /blah/ }) as that traverses the array twice. Is there any built in method that does this for me? That is, it's a method that takes a block and returns the index of the first element for which this block returns true? (I'm using 1.8.6 on windows) Thanks
Unobtrusive monkey patching?:) (it will work with 1.9 which has index with block). http://pastie.org/private/5vllufjkptaoc0kzssixow class Array begin [1].index {|e| e == 1} rescue ArgumentError puts "(monkey-)patching Array#index (RUBY_VERSION = #{RUBY_VERSION})" alias_method :__old_index__, :index def index(obj = nil) if obj.nil? self.each_with_index do |e, i| return i if yield(e) end return nil else return __old_index__(obj) end end end end
doesn't return it, but: [1,2,3,4,5].each_with_index {|x,i| puts i if x == 2} I try and avoid needing indexes, it's not very Ruby-esque, but sometimes unavoidable.
this works: `a = [1,2,3,4,5].each_with_index {|x,i| break i if x == 2}` 
sweet, I'll now add break with value to my block hacking repertoire
so... use "for" when you know you need that functionality, otherwise use each and avoid potential problems.
Ruby 1.8.7's enumerable module contains a method called "find_index" that does exactly what you want. Perhaps easiest way to go about doing this is to upgrade?
Yes, indeed! I just thought it was extreme to call it evil.
&gt; I try and avoid needing indexes, it's not very Ruby-esque Without knowing more about the problem you're trying to solve I can't say you don't need indexes, but I also try to avoid them unless necessary.
I'm very curious to see how RubyMine stacks up against Netbeans.
Looks like a great book! Browsing through it so far, it seems very well organized and put together. I really appreciate your releasing it free to the community. 
Interesting to see JetBrains make something that's NOT an addon for Visual Studio. I mean, if you're stuck with it then ReSharper is a blessing and all, but it's nice to see that talent used for something *I* actually have a use for. Still trying to figure out what I'm going to do with this free ReSharper license I got, no copy of VS2008 to use it with :/
I would like to incorporate an All Pairs combinations testing tool (like this one written by James Bach: http://www.satisfice.com/tools.shtml) into a custom test tool I need to write. Does anyone know of one written in Ruby (I'd prefer to stay in Ruby)?
I use netbeans, some of friends use rubymine. They seem to think it's better. I might try it but I have no intention of buying it. 
Why not use the eclipse ruby addon that's free? There's also an eclipse rails addon too that's half decent as well... 
Because I hate eclipse, it's slow and bloated and the UI is convoluted as hell. They're all java apps though so they all inherintely suck due to non-native UI's though :/
Pfft. EMACS baby.
OMG -- multiple!?!?
JetBrains make IntelliJ...arguably the best IDE for Java development...The resharper product is an offshoot of that.
Rather unfortunate that from what I've seen with RedMine thus far IntelliJ has got to suck on linux. It looks like ass :/
... it's 2009 and people still don't know how threads work in ruby?
What is the point of using virtualbox here?
I was under the impression that everybody did. I only clicked the link because I expected something new :P
Virtualbox is useful if you are stuck on Windows and cannot replace the OS with Ubuntu/Linux. Dual booting is also a pain. VirtualBox is ideal as it gives you a faster Linux based development platform (when compared to Windows) whilst letting you retain you current Windows setup (so less pain).
Redmine is pretty good on Ubuntu 9.04. Good performance and looks good too. Prefer it to Netbeans as its got the edge currently, specially if you use Git to manage your source.
&gt; if Time.new - time &gt;= 10 He's creating a new Time object on every iteration, which as well probably taking longer than the division may well synchronise on some central heap mutex. If so this would make the results invalid. It would be a better idea if the main thread signalled or stopped the test threads after waiting for 10s.
me too... and he doesn't seem to get the concept of a global interpreter lock... in other news.. perl, python, etc also suffer from this "bug"
Just downloaded it and gave it a run. First step is to switch to the Textmate Keymap. Then it felt much much better. Its got some extremely cool navigation features. And its actually pretty snappy (though, I'm on a pretty fast laptop with SSD). I'm going to try using it for full time dev for a few weeks. If I stick with it that long, I'll probably purchase.
Exactly what is hard about using actual cron?
Nothing.
The thumbnail fits perfectly....
Fuck yeah!
Mine is in the mail. Or so they say. Somehow i've managed to go without the Pickaxe up until now. Hopefully i'll pick something up/get to use it as reference.
Mine too, and only a year or so after I ordered it in "beta".
I just bought the ebook. Can't wait to read it. 
I want it. Have to wait a month more :(
Presentation was retarded and not very funny but degrading? Next up a women making a presentation like Steal like Wall Street. And men will be offended because most of thieves that work in WS are men ... c'mon , stop the BS 
I think it's time to let this issue go. People make faux pas and should not be crucified for them. They also exercise poor judgment sometimes, even if they are leaders. Leaders are not infallible. The most poignant and pertinent response to this whole thing is [by this woman](http://dyepot-teapot.com/2009/04/25/dear-fellow-rubyists/). If everyone could just read that and digest it, the entire community could move on to bigger and better discussions. I feel bad for the original presenter. I'm sure he wanted to come across as funny and edgy while maintaining the interest of his audience. He was probably worried that the dry (to the non-techies) material might not be enough to pull it off. Cut him a little slack. I am not defending the offensive content of the presentation, I am simply trying to bring some compassion here.
Why do people like that book? The Ruby Programming Language is vastly superior.
Like Mr. Fowler said the TFA: &gt;The issue is no longer the presentation, but the reaction of the community to this event. The problem is that for some period of time a number of people refused to even admit it *was* a problem. Making a faux pas is one thing. Refusing to recognize that you made one is another matter. Edit: Case in point: fbru02's comment below.
It is really really tough to admit when you have made an error in judgment. Especially when you are a public figure. Especially when you are among peers. Especially when you already have a "rated R" reputation to uphold. It is embarrassing, and as a man it is seen as a sign of weakness. Not to mention it is mortifying. I know this because I have made this type of error, except far less publicly. And I had to go through this. It is not pretty. I think it is best to assume an impression was made and to let it go than to force a public apology.
But it's not just the presenter. Fowler correctly said the issue is the reaction of the *community*. People didn't say, "Let up on the guy. He made a mistake." Well, some did. But some didn't. Some said, "What are you? A prude? We're edgy! You're the one with the problem." **That's** the problem here.
OK, so because not everyone in the community was quick to condemn this either out of ignorant misogyny (easily rectified by the link i posted) or a simple wish to not contribute to the crucifixion, it is somehow indicative that the community sucks? What if it is simply that not everyone in the boy's club that is this programming community had been taught to be sensitive to the perceptions of the gentler sex and that this was simply a valuable lesson to them? Do we have evidence that initial belligerent reaction was not tempered at all after thorough discussion? This is a matter of ignorance and maturity, that is all. Young geek boys, eager to appear macho, bombarded with sexual imagery day in and day out on the Internet with a collective experience of actual women that is probably sub-par. This was bound to happen.
The way I see it, Haml reduces HTML to its essential components and is infinitely easier to read. The whole "learn another syntax" doesn't really make a lot of sense considering how dead simple it is: .css-class, #css-id, %tag{ :attribute\_name =&gt; "attribute\_value"}, = for code with output, - for code without output, whitespace nesting and that's about it. Plus, if there's a compelling reason to have a template/partial or 2 or 4 in erb, you can mix and match with no problem. Don't like large templates in haml? Do those with erb. Anyway, to each his own...
Number one reason that haml rocks : no closing tags.
Think this was blown way out of proportion myself. And really who gets offended by porn? Seriously, offended? Was there a priest at this conference? Might not have been the most professional thing but give me a break.
Minor gripe: &gt; The future of Rails is Ruby 1.9 I have more faith in the JRuby devs than I do in the MRI/YARV ones. Performance is irrelevant if the answer is wrong.
(Sorry for cross-posting. I should have put it here first.)
I'm a bit of a spectator on this, what's the wrong answer in the case of YARV?
Apparently he doesn't like the developers of YARV for some reason. It sounds like his entire objection is based on his dislike of a set of people. 
That first example doesn't seem right... Doesn't the order of rescue statements matter? Should it be begin method() rescue SpecificException e handleexception() rescue DifferentException e handleexcetion() rescue Exception e handleGeneralException() ensure doStuffRegardless() end If you have the general exception handler before the specific ones then the specific ones will never happen no?
Yeah, actually Robert mentions that later in the article, but you should leave a comment on the blog because that caught me off guard too.
The problem is the development process. The people working on Ruby 1.9 are mostly the same ones who worked on 1.8. Here are the three general problems I have with MRI: * the test coverage was poor * the code is terrible * the mainline devs weren't able to provide security fixes in a timely manner So, given their past record, I have low expectations for their more recent work. By comparison, the JRuby developers contributed substantially to RubySpec, are actively concerned about regressions, and know their craft. Furthermore, if someone does find a vulnerability in JRuby, it's less likely to be critical due to the JVM's security model. 
via: http://topsecretproject.finitestatemachine.com/2009/05/on-the-rails-maturity-model/
So he made a mistake. I would never have thought a presentation like this would have caused so much offence either, however it evidently did. To victimize Matt like this though - after all he has done for the Ruby community - especially Merb - I feel is a massive overreaction, and it's got way out of hand.
I started studying programming (again) a few months back and chose to go down the ruby path. Ruby has been so much fun to learn and it has really got me interested in programming again. I've learned the fundamentals, building a lifeless gui using wxruby and using the far prettier shoes. I've tried out rails and a bunch of great gems. But now, I'm not sure what else I go from here? I thought of trying out building a game but I'm not all that interested in graphics and don't see building 2d games to be a useful skill for me. The one thing which I feel I haven't delved too deep into was meta-programming. Right now, I feel like I explored the whole map of the introductory level of a video game and have no idea how to progress from there. I found this insightful [post](http://www.reddit.com/r/reddit.com/comments/2ld0v/ask_reddit_i_want_to_learn_to_program_and_have_no/c2lejn) which suggested learning more about programming via some books but I simply don't have access to them. Should I move onto a lower level language like C? I've heard you could improve performance of ruby apps by re-writing some bits to C, and imagined that learning C may become useful. I really love Ruby and would hate to leave it though, but don't know what I should move on to (besides meta-programming). What would you guys suggest?
Like yourself I am an aspiring pro rubyist. These are the things I am currently midway in Ruby: Mastering Test Driven Development is a *must* to become an efficient Ruby developer. Ruby Koans ("A set of Koans to teach the Ruby language"): http://github.com/edgecase/ruby_koans/tree/master is a nice way to both brush up Ruby in minute details in many aspects and learn developement the TDD way. You mentioned game so what can be better than a game where you code in Ruby to *play* It is basically a Nethack style dungeon game except that you write code to make the necessary moves / attack / defend. Ruby-warrior : http://github.com/ryanb/ruby-warrior/tree/master
Excuse the shameless plug, but my book is written exactly for this purpose. http://oreilly.com/catalog/9780596156749/index.html I wanted to help people break out from that plateau of 'baseline proficiency' into looking at development in a new way. While I don't promise anything revolutionary, it almost certainly would give you a new perspective on things.
Start a blog about how amazing you are, and take care to spend more time finding fault with other members of the community then you do actually posting about code. Remember, everyone that disagrees with you is an oversensitive idiot!
Code-heavy blogs are great too, like sandal's (and others') [ruby best practices blog](http://blog.rubybestpractices.com/). Aside from books and blogs, the best way to get better is to practice. Writing gems and plugins and things is great, but writing silly code to test ideas you have is great also.
Python, is that you?
Use whatever language works for you in a given situation. 
I agree
Definitely good advice. There is no substitute for writing code.
Hah, I've been in the community for a while and I know it can feel that way sometimes. But really, that's more correctly associated with the Rails community than it is with Ruby. Folks I'd label as 'pro Rubyists' ( David Black, James Edward Gray II, Jim Weirich, Christian Neukirchen, Charles Nutter, among many others ) don't remotely fit your assessment. I don't mind people ribbing at this, because it's a real problem. But this posting wasn't about Rails, was it? And even if it were about Rails, there are lots of productive folks in that community facing the same problems, which may indeed be a hopeless scenario. But please, let's not take a core language community who in certain regards still does appreciate the hacker spirit and being kind to one another and lump them in with douchebag fanboys and wannabe "rock stars" with an inferiority complex. There is still a lot of good going on in Ruby, and it's a really sad thing that it's hidden beneath all this BS. 
Yeah, but I don't think I could deal with the startup time of the JVM *plus* the startup of JRuby for every script/program. Not to mention the JRE dependency in general. As good as JRuby might be/become, it has a serious handicap in terms of carrying around the baggage of Java. That's not to say that JRuby isn't good for Java developers. But if you don't need any Java, JRuby is pointless. 
You need to find a reason to program for yourself. Find something that interests you that you can throw some Ruby at! But if you just want to play around go here. http://rubyquiz.com/ start on number 1 and work your way through to the bottom.
Wow, you learn something new every day. I especially liked: class Point &lt; Struct.new(:x, :y) 
Because the person is unable to commit to using Linux as his main OS, like a real man. And Ruby on Windows sucks. 
I agree -- you can't use JRuby in two cases: * when start-up time is important * when memory is somewhat constrained I use Ruby for apps that run weeks without interruption, so a two second start-up up is irrelevant. The memory is another matter, since memory is the biggest bottleneck we have per server, and JRuby is hungry. However, MRI's GC marks objects directly, thus preventing the operating system's copy-on-write from being effective, which is a problem if you're running many processes of the same thing. JRuby doesn't/didn't share well either, but it has native threads. I haven't yet benchmarked the memory consumption since the apps here require some C-based gems (another limitation of JRuby), but at some number of serving threads JRuby probably uses less memory that the equivalent number of MRI processes. This bears further investigation. In any case, I strongly disagree it's pointless. Ignore Java (dmpk2k: disliking Java since 1.1); JRuby stands on its own merits. I have such a low opinion of MRI and its development process that if it was the only Ruby implementation available Ruby simply wouldn't be considered for greenfield projects.
&gt; I found this insightful post which suggested learning more about programming via some books but I simply don't have access to them. i suggest you get a library card.
Gems and plugins... I was thinking of that at one point. During my stint at coding rails apps, I built my own little polling system as the only polling plugin I found seemed inadequate. Didn't really get round to making a plugin out of it but I guess producing and maintaining a plugin could be a great way to learn.
Just read the readme to the 2 games and I can see myself sinking a lot of time in them. The only reason I don't want to go through with building a game is that I don't want to make yet another text adventure game (which a game I was building started resembling) and don't have the skill or the tools to produce some good art for a 2D game. I thought of recruiting some designers willing to work on an open source game but it seemed too early for me to try that considering my ruby proficiency.
Write something, that really challenges your current skills. Even at the risk of failing, you will learn a lot by building something, that pushes you out of your comfort zone. Examples: Parsers. Compilers. Interpreters. Search Engines. Neural Networks. Game Engines. 
personally i have used both. i am using rubymine over netbeans
I don't think I would like to join a community which strives for mediocrity. 
Well, in that case you can join the real Rails rock stars - no one would argue that they are *not* striving for mediocrity. On a more serious note, which part of the mission statement or announcement made you think that RailsBridge is striving for mediocrity?
&gt;Well, in that case you can join the real Rails rock stars - no one would argue that they are not striving for mediocrity. Yea. I always want to hang around with people who want to be the best. I want to surround myself with people who push themselves, people who work hard, study hard, and bust their asses to be amongst the elite. I want to be around people who are smarter than everybody else. Those are the people what inspire me to do more. Those are the people who can teach me to be better. &gt;On a more serious note, which part of the mission statement or announcement made you think that RailsBridge is striving for mediocrity? I think it was the following. &gt;It’s very important to understand that we are not trying to form yet another oh-my-god-we-are-so-awesome Rails group of uber-hackers which looks down on everyone not in it’s ranks - for two reasons, at the very least: &gt; * RailsBridge is open to anyone! - you don’t have to be a Rails core commiter, coder with 20 years of experience or a renowned Rails blogger - it’s enough if you’d like to make the Ruby/Rails scene more welcoming in any way &gt; * We are trying to promote the exact opposite philosophy - we acknowledge that Rails’s image is somewhat tarnished because of the “rock star” attitude and we’d like to show by our actions that we are working on this and will eventually turn Ruby and Rails into a very welcoming and enjoyable community 
I guess you either missed or disregarding the events that created this group... I understand that without that context, this new community might sound like you described it. As for having people that are smarter than anyone else - that's obviously very subjective, but we have a Rails core committer, one of the most active Rails evangelists, a lot of the most helpful people from #rubyonrails, and other great guys - anyway, time will show where this group is heading.
I'm with you. I hate when communities are all yes-saying and mutual patting and scratching on the back. If it also keeps the pansies out, so much the better.
&gt;I guess you either missed or disregarding the events that created this group I didn't miss it. I know perfectly well what happened. Some guy put pictures of scantily clad ladies on his slides and reddit's monocle fell out. That night everybody who was ranting and raving about offending the ladies jerked off to porn they downloaded from the interwebs. It was amusing to watch a bunch of people whose hard drives are full of women degrading themselves by slapping cocks on their faces get all sanctimonious. I enjoyed it quite a bit. 
&gt; Yea. I always want to hang around with people who want to be the best. Posted on Reddit.
An interesting idea, it would be nice to have a more nice and inclusive ruby/rails community. I have to wonder though, does this have any chance of success? Does anyone know of a similar "community branch" in another project that was somewhat successful?
ALT.NET comes to my mind http://altdotnet.org/
In my defense I am the most hated person on reddit, especially proggit. 
I'm not sure this is striving for mediocrity. You can be welcoming and accepting to newcomers while at the same time being a brilliant and hard working coder. Haskell is an example of this I believe. It is very welcoming to newcomers, with newbie questions always getting good answers. However, if you look at a lot of stuff that is produced and published on blogs you can tell many of the people in the community are very gifted programmers.
Fluffy inclusive hypocrite month on proggit = open season on the likes of you and I
Will there be tits?
I agree. You are so right. Is your back itchy?
You mean besides man-boobs?
&gt; jerked off to porn they downloaded from the interwebs. Hrrm done in perl of course. 
But why? I don't believe there's anything wrong with the community as it is. Like any community, there is a difference of opinion on a certain topics. It'd have made more sense to assemble a team of advocates for inclusiveness. Even then, these ideas ring as hollow and overly political.
&gt; the real Rails rock stars Turns out, [the whole rockstar thing was a hoax](http://railsculture.com/2009/may/rockstar-culture-turns-out-to-be-elaborate-prank.html).
 describe "readying the skin" do given do @person = Person.new "Buffalo Bill" end it "puts the lotion in the basket" do @person.in_pit.else_it_gets_the_hose_again end end
| you can't use JRuby in two cases: | | * when start-up time is important [nailgun](http://wiki.jruby.org/wiki/JRuby_with_Nailgun) kinda solves this.
omg this is so inappropriate. 
What's with the DHH hate? Isn't this kind of petty and stupid, or am I missing something ..
Dear sir: that site is great.
It's totally childish, but I have to admit it made me smile. I can imagine David had to smile as well. He'll never admit it I guess.
No hate here, just silliness. DHH thought it was pretty funny
Thanks for adding my post
who said they are thread safe?
dunno if anyone has, but it's a common mistake people make with threads and ruby
I don't know if anyone has, but it is a common (if mistaken) assumption that operators are thread safe. This isn't true for any language that I know of, but this didn't mean that it isn't something worth a mention. 
I've seen OS qualifier problems that involve precisely this fact. Atomicity of operations is often overlooked.
 def lock unless @mutex @mutex = Mutex.new @mutex.synchronize {yield} end end Isn't the above the same exact problem? It may pass the unless condition in more than one thread and switch context before it is assigned the first time. Isn't the actual solution to initialize @mutex once in the constructor and reuse it, rather than anything about how ||= is not atomic? 
good tip, i wouldn't have realised until after a fair few hours of debugging.
I remember that I found exactly the same problem in "Ruby Cookbok" but I was too lazy to report it to the authors :D.
http://www.crummy.com/writing/RubyCookbook/ Download file: http://www.crummy.com/writing/RubyCookbook/downloads/Ruby%20Cookbook%20Source.zip From "Ruby Cookbook Source/20 - Multitasking and Multithreading/04 - Synchronizing Access to an Object.rb" http://pastie.org/470008
&gt;# class X &gt;# @@class_mutex = Mutex.new *require* is not thread safe. Meaning that this won't necessarily work. 
You should have named him when you submitted it: David A. Black. He also happens to be one of the nicest guys in the Ruby community, and has done a hell of a lot over the years to help spread the word, long before Rails showed up.
Yea, that's the same problem, except it's more obvious. The issue is that ||= can give the appearance of atomicity. I did mention in the post that one solution is to initialize @mutex in the constructor. There are (although uncommon) times when this isn't possible or what you want. But also the case in question isn't the only situation where ||= is used and you could run into race conditions.
Yes! And there should be a staff person (get an enthusiastic volunteer to do it if staff are busy) sitting in the front row with a BIG black-on-yellow REPEAT THE QUESTION sign. 
I don't want to.
Yeah, so... i think i need to bookmark this guy. Four posts in a row, now?
I like him. He doesn't give a shit. 
It's a good reference book. I'm not too hot on its tutorial section but as a reference book it's solid.
a bit?!
Some people love Ruby, some people *love* Ruby.
As much as I love Ruby, for my boxers I think I'd prefer a Python theme. 
Is this from someone who has the rights to use Rails' trademark and logo?
No, and I'd certainly love to see the panties modelled on the gonewild subreddit... Hmmmmmmmmmm.... EDIT: To clarify - I would like to see them modelled by a woman... Don't even go there you sick fucks :)
damn, what, no boxer briefs?
I'm not disagreeing with the article, but one subtle gotcha is that you also might inadvertently code a particular implementation as part of the tests. You likely won't notice these intermingled details on v1.0 when your idea matches your first implementation, but when you start work on major under-the-hood changes for v2.0, your tests will start to fail due to the dependencies. This doesn't mean this kind of testing is bad, but in the hands of a naive boss it may work you into a corner where you have to replace whole implementations in one commit just to keep the tests from failing. Coding intent into tests means getting deep into the same cloud of details you'll be in when working through the implementation. Be careful not to mistake your choice of implementation as intent.
I'm not sure I understood what you say, but I'll try to answer. I think you made a valid point but also have to add that the tests will never be totally independent of the code they are verifying. One can use some kind of fake objects (mocks, stubs, proxies...) to isolate the tests from the code, but then you need to use some kind of integration testing approach. I use both techniques and, for a simple example, coupled tests were simpler and helped me get to the point faster. And the point wasn't that you have to code intent into tests but use tests to drive the implementation of code that ends with clear intent.
Everything on the internet is videos now...
IMO, TDD on its own doesn't lead to a cleaner API/Implementation, it just helps ensure that it is put in practice. You said: "But, the code isn’t consistent" Was it the TDD mentality which lead you to this conclusion or the fact that you know how clean code looks like, what a bad API looks like, what's a code smell etc.? Nice article, though I would've liked an example on the horrors of writing test cases for a bad code.
I think both things help: TDD and experience with good code. Tests will also help other developers to maintain the code well designed. But, yes, they won't operate a miracle on the hands of a bad developer. I like your idea for another example and will try to address that soon. Thanks!
&gt; I like your idea for another example and will &gt; try to address that soon. Thanks! Looking forward to it, thanks. :-)
This post on Queueing in Ruby with AMQP covers installing Erlang, RabbitMQ, and the Ruby AMQP library as well as performing some very rudimentary queueing and dequeueing snippets.
So the answer is... write code to prevent yourself or your team from mocking/stubbing certain methods? I'm not sure that's addressing the root of the problem... Anyway, I find that mocks and stubs are just plain overused, and I was definitely guilty of this. Since I've learned my lesson (namely by extremely brittle tests), I've switched to using the factory pattern to create test objects in the database and run the tests against that. Tests are far less brittle, and are actually testing more, which in this case I think is ok. I still use mocks/stubs in places where the code is interacting with a system that is outside the scope of the current test (eg. something that is specced out elsewhere), when it's easy to just stub a typical response from that object.
anyone know of a transcript of the maglev update?
radhruin, that's the same approach I use when writing my tests. About your first consideration, I agree entirely. That's just a way to warn you, but doesn't address the real problem. I don't use it, but I think it is a good tool for teams with novices or for people who are transitioning from a very "isolationist" way of doing tests to the more "traditional" way and need some help initially. I added a note to the article to clarify this position. Thank you, man! :)
jruby 1.3 + nailgun is going to kick some serious ass I think. 
I doubt it. Most likely from someone having no clue about open source.
I know this sort of nasty business model is common, but I still think it's worth raising awareness that this sort of thing really does bother content creators. It's one thing to make money off of ads on your own site, but a whole other story when you overlay them onto someone else's work.
I find this technique really annoying as a reader, but as a content creator, not so much. It's a frame doing what frames do. I don't see the ethical issue, at least not in this instance. You could make a Web browser that had ads in the chrome but you're not really overlaying ads onto other people's content. Thankfully, of course, you can use a bit of JavaScript (as has been done here) to resolve the issue, with the humorous side effect that going back to the about.com site is a lot harder due to the JS jump ;-) As long as someone isn't *changing* content, proxying it, or claiming to have made it, from an *ethical* point of view, I don't see the problem. But then, some people have had problems with other sites even *linking* to them, so nothing will surprise me.