Thanks so much for the response, I hadn't seen that project yet. https://github.com/esbenp/pdf-bot is similar Some questions: What about private information? Data stored behind a session cookie or something? I guess you just point your local dev box at this service too? How does it scale? Performance? Any downsides or pain points you've found from going this route?
Very smart. Having it used as a middleware is probably the most useful part of this along with how robust the PDF capturing is. Price makes sense too! I'll definitely be trying it out!
That‚Äôs great feedback, something I hadn‚Äôt thought of. Thanks! ü§ó
I forgot your internet hug. Come here, you! ü§ó
Our app runs on heroku, so we just deployed this to heroku as well. Font availability on heroku is poor, so you need to create your own build pack. We only use generally available fonts, so it‚Äôs ok to create a public repo for the build pack, but I‚Äôm not sure how one would deal with licensed fonts. There should be a way to do private build packs but I haven‚Äôt looked into it. You can specify an auth key that‚Äôs sent in a header, and heroku gives you SSL out of the box, so no one else can send JavaScript to the underlying chrome. URL2PDF has two modes: load a url or POST the HTML to its endpoint. We use the latter so the content of the document is never really exposed to the world. Only css is loaded by the headless chrome. The PDF gets pushed to s3 by our own app in a worker and then processed from there. Locally/in dev we spin up a local instance with foreman/forego and puma-dev. I haven‚Äôt done any performance testing (we don‚Äôt create that many docs), but it‚Äôs not painfully slow. It‚Äôs used headless chrome to build the PDF, that makes life a lot easier than layout with Prawn, but chrome doesn‚Äôt do page numbers. If you need page numbers you need to use css counters and a wrapping div for each page, effectively laying out each page individually. You currently can‚Äôt to variable length content with page numbers. `@page` directives are only partially supported. I‚Äôve used Prawn before, but the manual layout is a pain. Also last I used it it didn‚Äôt do font fallback for multiple scripts (think CJK plus Thai plus Cyrillic). wkhtml2pdf required patching QT to support css page breaks last time we used it. Everything is a trade off. I‚Äôm also using this service locally to generate pdf invoices from stripe invoices, which are only on the web for accounting. I like it, it‚Äôs been super stable in production (in dev on macOS it sometimes generated empty pdfs, but I haven‚Äôt seen that behavior in prod on linux), but no page numbering is a problem, but that‚Äôs chrome 
&gt; Do you know what's causing the socket error? Yes, take a look at the stack trace, the error is right there: C:/Ruby25/lib/ruby/2.5.0/net/http.rb:939:in `rescue in block in connect': Failed to open TCP connection to **CM**:80 (getaddrinfo: No such host is known. ) (SocketError) "**CM**" isn't a valid host, so you've got some invalid data somewhere. When you post a stack trace like this you also need to post the unedited file that caused it. The stack trace has line numbers in it (go ahead and read it), and isn't much use without the corresponding source. Try putting some more debug in to see what data you're getting out before the line that the program errors on. 
Any chance the Boss can be taught to use the Print to PDF functionality present in most browsers these days? Then you won‚Äôt have to reinvent the wheel. Chrome, Safari, and Edge support this out of the box I believe and Firefox has an extension. You can then use CSS to control the output using print-specific stylesheets. 
I use a forked and tweaked version of the wicked_pdf gem https://github.com/mileszs/wicked_pdf to generate invoices/receipts, usage history and graphs dynamically for logged in users, and administrative reports dynamically for management and accounting. There's no way I'd ever add an external dependency for this, due to security/confidentiality, performance, reliability, and flexibility considerations. (no disrespect intended)
None taken, You get a hug! ü§ó
This is a completely functional option! I actually tried this, a while back. It was quickly shot down by users because all they heard was "Print". I got all types of responses like, "I don't even have a printer, this would never work". ¬Ø\\\_(„ÉÑ)_/¬Ø You get two hugs, one for your comment, another for your practical and most simple answer. ü§óü§ó
Existing solutions? Please do add them here.
If you have the report in a view, why not just render the template to a string and use https://github.com/wkhtmltopdf/wkhtmltopdf ? I find it works great and is really easy to hook up in a format block in a controller action. 
I like DocRaptor the best (great support, simple api and pricing), but there‚Äôs also pdfcrowd and pdflayer. I think there‚Äôs also one called hypdf, though I can‚Äôt remember if that was a heroku-only service. I think there are more, but that‚Äôs all I can think of at the moment. If you haven‚Äôt tried it, maybe give DocRaptor a shot and see if that does what you want?
You don't actually need to fill in your payment details. You just need to login, then navigate away to the content section of the site.
Wow. Love this so much that I posted it to the Jekyll "channels" too. See: - [@ Jekyll Talk](https://talk.jekyllrb.com/t/real-world-case-study-build-online-books-with-markdown-and-the-jekyll-static-website-compiler-free-ruby-reference-2-5-book/1679), [@ Jekyll Reddit](https://www.reddit.com/r/Jekyll/comments/8aoicu/real_world_case_study_build_online_books_with/), [@ Awesome Jekyll](https://twitter.com/awesomejekyll/status/982687051060523008). Keep it. Up. Best part the [`_data/book.yml`](https://github.com/rubyreferences/rubyref/blob/master/_data/book.yml) file. Yeah! Well done. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rubyreferences/rubyref/.../**book.yml** (master ‚Üí e7345a4)](https://github.com/rubyreferences/rubyref/blob/e7345a4672c23e86a0f010f6cd6fa47e5c5b763b/_data/book.yml) ---- 
Well, I maybe messed up with this part, but what I meant, that almost all other languages have some obvious link to "read this, that's all you need" (maybe it is not always _all_, but it is always there, easy to read and pretty comprehensive).
Makes sense! Will do.
At my company, we use a mix of wicked_pdf and a custom gem that wraps chrome headless. While they have their own quirks and flaws, they do the job just fine. What would you offer that is different or worth paying for (assuming you will build a SaaS product) than just rolling one of the above yourself? 
Could you elaborate a little more detailed? Wicked_pdf was always very buggy in production on my side, but using chrome may be a good option 
We use wickedpdf to render rails pages. We have some PDFs that we generate with prawn. Prawn has its own weird license though, so we might actually switch to something else with an mit license. 
lol dude, tell me just one language that feels better to develop in than ruby
At my previous job I used PDFlib for it. Expensive as hell but nothing else supported to advanced PDF options I needed. 
Can you post a guide to contributing to the Reference? Once I clone the repo, what do I do to build it locally, serve it locally, etc? I think this will really help you get more contributions.
Hmm, what did I consider this API for? I remember looking it up, just not why.
ü§ó
ü§ó
ü§ó
Honestly ‚Äî last time I had PDF generation as a part of a project, I discovered that ActiveAdmin offers a pretty good print stylesheet, so I simply instructed the client to print a PDF via the browser and it went well.
I had to solve the same kind of problem around 4 years ago, and the easiest solution for me was to render the PDF using PhantomJS (headless browser). This was especially useful since the charts I needed to export we're already being generated with D3.
Yes, probably should be done more clear... For now, there is a readme in `_src` folder: https://github.com/rubyreferences/rubyref/tree/master/_src, which has "Source guide". Basically, * rerendering is performed with `_src/exe/render.rb`, from `_config/structure.yml` and results of parsing &amp; sanitizing of Ruby sources (done by corresponding scripts). * serving locally is done by Jekyll, with `jekyll serve` in a root folder.
This approach creates a lot of garbage, a more efficient approach would be something like `gets.chomp.gsub! /\b\w/, &amp;:upcase`
The regex doesn't need to be that complicated (or limited to english): `"Amy Smith-Brown".gsub! /\b\w/, &amp;:upcase`
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [iliabylich/memoized_on_frozen/.../**memoized_on_frozen.rb#L63** (master ‚Üí 4eb0634)](https://github.com/iliabylich/memoized_on_frozen/blob/4eb0634fd75082ebf3e0e76cca05ab1bc80631c2/lib/memoized_on_frozen.rb#L63) ---- 
Thank you for a great response! First of all, thanks for pointing to ObjectSpace.define_finalizer (not sure though that it will work in this case, since global values are not GCed, so this callback will be never invoked. Maybe I still miss something). And I guess I know the reason why I didn't stick to your solution: I've initially convinced myself that it can be solved by using a local state. Thank you! I like your solution and I admit that it's better :) Next time I'll try to think more critically.
On this topic, check out Safely gem. 
Before reading this I wasn't sure whether the post was serious or a lazy trolling attempt &gt; the language is too un-specified and difficult to support real IDE' Surely someone with +300 GitHub on Ruby OSS projects would know the real reason for IDE support being difficult on Ruby...
&gt; URI must be ascii only It looks like you've got some data cleanliness issues. That first string: "\x86\xDBi\xB3\xFF\xF0\xC3\a\xE2\x95\xE9\xDE\xC6\xD7(\x9B\xFA\xDF\xEA']\x92\xFC\xB7\x8E\xFF\xC6z{ezf\xA7I\xC7\xA7x*\xDEj\xDA+N\x8AU\x89\xEC\x06\x15t\xD1\x02\xB6\xAB\x86\xD9\xA5" Base64 decoded is: &gt; str = Base64.encode64(data) =&gt; "https//wwwfilenextcom/rf6iddkvy3jv/GentlemanSceneCreatorTopV\niewGFXTRArarhtml\n" In the last example you've got what looks like some extra data in the URI "\r\xC3\xDC", that's what's causing the error. Where that those extra chars are coming from I don't know.
This looks *really* impressive, thanks a lot for creating this!
&gt; There are enough articles about "why immutability is good", thread-safety is the main point. There doesn't seem to be any concurrency protection in this gem though, whether the memoization added here is thread-safe will depend on what you are doing, and what ruby platform, no? The initialization code could be run more than one time if multiple threads trigger it concurrently. 
Ah, I see, thanks for teaching me that bit. I looked at the code and saw `self === $! ? yield($!) : fail` and figured it was just spitting out a RuntimeError.
Fun stuff. Very nice. I'm a tad shocked that folks in [the proposal referenced in your project's README](https://bugs.ruby-lang.org/issues/6739_ consider adding `begin`, `end` and some newlines "bloated code". But, in the name of them and, since we're already monkey patching, here's my proposal: class Array def with any? { |e| e === $! } ? yield($!) : raise end end data = File.read(path) rescue [Errno::ENOENT, Errno::EPERM].with { warn "Error: #$!" }
That's because you're downloading into your root under destroy_all_software, that file path should really have `.` or `~` with a `File.expand_path` at the beginning. 
Due to community feedback about my much regrettable patch of Array I've revised my proposal to the (arguably worse üòÅ yet cooler üòé) [following](https://github.com/ktchen14/rescue-with/commit/6ea653127f0ccdcfb274aed33f6c0b5ad1524cc8): def with(*a) a.flatten.any? { |e| e === $! } ? yield($!) : fail end data = File.read(path) rescue with(Errno::ENOENT, Errno::EPERM) { warn "Error: #$!" } 
Heroku
Right? I'm lazy, just push to Heroku is enough for me.
Care to post link to your github profile ? Just curious what stays behind those bold statements, in the better case. Or that utter rubbish in the worse..
Get a RaspberryPi, or heroku or a cheap linode account.
Heroku makes it so easy... plus you can optimize most of the time to pay a minimal amount with a little cleverness if your traffic starts to jump. No brainer 
Digital Ocean VPS for $5/mo or an AWS free tier are both satisfactory for a small web app
yeah agree.. text processing totally depends on knowing input.. for example, `smith.brown` should result in `Smith.Brown` or `Smith.brown` ... 
Python, Elixir, Haskell, Swift, Elm...
Do you ever jump in to new large projects, working on other peoples' code?
Of course: extremely dynamic syntax and a culture of using it excessively, avoiding explicit namespaces on method calls, and other practices which defy static analysis.
I'm playing with your Ruby blockchain stuff. It's very good. It's giving me a way to learn it without having to learn Go or C++ at the same time. But... When I try running central bank from the command line as described in [blockchains](http://yukimotopress.github.io/blockchains) section 6. using centralbank it doesn't work because centralbank is in the bin/ directory, so I tried (after setting chmod +x etc) bin/centralbank and then got an error I've never seen before env: ruby\r: No such file or directory So I wrote added one space at the end of the shebang header line That removed the extra \r and I then progressed to bin/centralbank Traceback (most recent call last): (LoadError)h file or directory -- Because it doesn't know where the library path is. If I run with ruby -Ilib bin/centralbank Then it's fine. So you need to do something to remove that \r at the end of the shebang line, and add the library path before the require. 
Thanks! Still some work to be done, but it already stands well on its own. 
Not often, but yes - why? And care to mention the languages you are comparing Ruby to?
Thanks for your kind words and reporting the centralbank error. Will try to change the line encoding to all unix-style (remove the \r). Cheers. Prost.
Ok, apologies for the radio silence. Been away for a few days, so haven't had access to my computer. The code I was using was if browser.link(:visible_text=&gt; /\\?tagged=ruby/).exists? print "Found URL as expexted" else print "No URL found" end I just wanted to see if it could find the URL and print the result. In regards to your question, I did some reading. I believe you were referring to Scan, the result is generated and either added to the result array or passed to the block. In terms of the URL, I wasn't using RegEx correctly. I needed to match non-digit /\d/ and /\w/ to match the single word. I'm not sure If I'm way off, but could I use an if statement which includes scan, to match the URL request then if returned true .click? I need to go back and test, but I appreciate your approach to answering my question. I'm still going through the motions of learning. Thanks again!!!
I run one on amazon just so I would learn how to use it, but you‚Äôre right, everything else goes on heroku.
Haha, thank you not.
Well for our main use case, we generate quite large reports with lots of text, images, charts etc. with headers and footers using wicked_pdf and have only really ran into a few odd cases where some fonts would be rendered poorly, some broken styles or pdf generation took far too long. Most of these issues were fixed by compromising in the design and implementation of our reports so it was perfectly fine for these cases, however I do wish it was a bit faster and was backed by a more modern browser. For other reporting/pdf requirements, I wrote a gem (not open source sorry!) that (among other things) would use chrome headless to generate pdf files using html. I'm sure if you googled for a way to do this, you could trivially come up with something similar. It works amazing for most pdf requirements and doesnt suffer the same bugs as wicked_pdf, however it still has it's own quirks with its API and weird issues with header/footers. Once those issues are ironed out we will be ditching wicked_pdf as it is no where near as nice as working with a fast, modern browser. 
Work was auditing all our gems and licenses. I think it‚Äôs easier if everything is a standard mit one than if we have to read through a handful of bespoke licenses. 
Great content here and in the survey results. I‚Äôll post them after results stop rolling in. Judging by the downvotes, some of you don‚Äôt like virtual ü§ó, even tho I promised to deliver in my post. Sorry for invading your personal virtual space, you cold monsters!
Kinda lazy audit. Gives me that "we don't actually want to read all these licenses" vibe.¬Ø\\\_(„ÉÑ)_/¬Ø 
You‚Äôre not wrong. There might be more detail that I‚Äôm not aware of. I‚Äôm not on the team doing this, I just read their slack. 
`cap production deploy` on a VPS doesn't exactly kill me though. 
Did you know you can do this with your models in Rails? Post.validators.to_check_constraints(:pg) Post.validators.to_javascript camelize: true You can do it but it won't work. Ahahahaah!
One more idea... class Proc def rescue_call(*error_classes) call rescue *error_classes =&gt; exception yield exception end end -&gt; { data = File.read('none') }.rescue_call(Errno::ENOENT) { $stderr.puts('No data') } Although, I don't like this approach or any other monkey-patching approach. Fun to think about though.
&gt; I think ease of understanding is more prioritary than efficiency. So you think `gets.chomp.split(/\b/).map(&amp;:capitalize).join` is easier to understand than `gets.chomp.gsub! /\b\w/, &amp;:upcase`? I don't think so.
It is when you already have `gets.chomp.split.map(&amp;:capitalize).join(' ')`.
For small ruby scripts I like popping them in a Serverless environment like OpenWhisk or IBM Cloud Functions. They support running things in Docker containers so I just have one Docker container for all my small ruby scripts. Doesn't cost me anything really and its quite flexible.
Matz is a pretty good steward. 
Agreed. I always enjoy articles about, and interviews with, Matz. His enthusiasm for what ruby was, is and will be always shines.
Yeah, I did the same thing. For me, Heroku is just too easy and convenient to use compared to other platforms that, for small projects, I wouldn't even bother with anything else.
I don't think Rubinius uses LLVM any more - they decided to make it just an interpreter now.
It's certainly alive and well in my heart. I've been trying to teach myself Rails, and after lots of work, I think it was only yesterday that it finally clicked. Already loving it, and already not looking forward to learning other kinds of backend web apps...
Can you be more specific about what it means "it really clicked?"
Uh oh, does this mean 5.0 no longer even receives severe security updates? The Rails "maintenance" page hasn't been updated with examples for 5.2 being out (It still says "5.1.Z" is the "latest release series"), but I think that's what it implies? I think 4.2 will still receive updates for "severe security issues" (but nothing else), but 5.0 may not even receive that? A bit regretting my decision to upgrade my app from 4.2 to 5.0...
That's simply wrong, you should never close yourself for other technologies! 
I've never understood why people get into almost religious arguments over &lt;insert framework here&gt;. I used Rails a lot, now I use Node. There are nice things about each, and bad things about each. That's it.
If you are in Europe, Hertzner has started a cloud VPS short time ago and the prices are very competitive, starting at 2,5‚Ç¨ / month. The drawback: the dashboard lacks monitoring features, you need to add a 3rd party software if that's important for you. If it's a hobby app, probably it's not a matter https://www.hetzner.com/cloud 
 I don't do what you're saying "that's simply wrong" to... I didn't posit anything Not closing myself off at all. I just have taken a good long look at javascript and Node, and it's not nearly as fun to me as Rails 
Why not just... keep up with updates?
That does sound nice. You don't even want to know. 
Short answer. Use WordPress. Rails is opinionated enough but not to the extent of adding every thing you need. And authentication? Use has_secure_password and cookie, rails cookie is encrypted
First release of Qo, short for Query Object. It's my play at pattern matching and fluent querying in Ruby based on a few of my posts earlier: * https://medium.com/rubyinside/triple-equals-black-magic-d934936a6379 * https://gist.github.com/baweaver/611389c41c9005d025fb8e55448bf5f5 * https://medium.com/@baweaver/new-in-enumerable-triple-equals-predicates-c1fcd0eabf6d Git Repo: https://github.com/baweaver/qo Few quick code examples: case ['Robert', 22] when Qo[:*, 10..19] then 'teenager' when Qo[:*, 20..99] then 'adult' else 'who knows' end people = [ ['Robert', 22], ['Roberta', 22], ['Foo', 42], ['Bar', 18] ] people.select(&amp;Qo[:*, 15..25]) # =&gt; [["Robert", 22], ["Roberta", 22], ["Bar", 18]] Enjoy!
I feel you. I'm getting ready to launch an update from 4.2 to 5.1 tomorrow. I won't do 5.2 for a while because of dependency support issues. Then I got 6 more rails apps to do to complete the stack. By the time I'm fully on 5.2, 6.0 will be out lol
5.0 -&gt; 5.1 -&gt; 5.2 upgrade should be pretty doable though. Gotta redo all the controller tests though.
Wait, they truly are removing them? I thought they'd do it in a far future... Controller specs are so much better than request ones... 
Not really. I was making a direct reference to features that were talked about in the article for version 2.6+ which are features that I need in my day to day work. In order to understand where I'm coming from, perhaps we should take a history trip for a sec. I started using Ruby well before Rails was available. I started using Ruby to replace Perl and Bash scripts at an ISP as a System Administrator. I eventually moved on to web related work and ended up replacing PHP/Perl with Ruby written PHP style. This was before Rubygems was a thing, so I made due picking through libraries on the web (often in Japanese) and including things like erb and database adapters. I didn't discover Rails until I started hanging out in the #ruby room shortly before DHH started suggesting we try it out and replace our cgi scripts with it. This was back before he started his [Write a Blog in 15 Minutes talk](https://www.youtube.com/watch?v=Gzj723LkRJY) at meetups: before RoR was even RESTful. I remember the uproar of some of the community when REST was announced at Rails Conf. Back about 5 years ago I was working for a billing processor who's core product was written in Rails. They kept having problems with communication time to the payment processors in production and it was a mostly an http timeout issue with some PCI compliance encryption stuff thrown in the mix along with other services written in Fortran and C# mucking things up. I ended up having to go async with it, but because of various business logic queues didn't fit the bill, nor did callbacks directly. I ended up using custom threading, because of various failure factors that I had to handle, and queuing with services workers as well. It was a bloody complicated thing that only I and one other senior dev understood or could even come close to maintaining. The tooling just wasn't there in gems or otherwise that worked consistently. I even managed to find a memory leak (found via strace after random failures of the service) in passenger that made me switch over to Puma. The next time we had to do concurrent things, I offloaded to node in the short term and erlang for the longer term. Shortly after that I learned Golang and changed how I thought about building services: in particular SOAs. So, here's how I judge a language now. I look at the standard library to try to discover what the language was designed for. This includes reading what the authors write about, what the community is focused on, etc. Then I test my theory with several PoCs. I would say Ruby was designed for General Programming. The internet wasn't it's main focus though it gradually picked up tricks to handle that, especially post Rails - which changed the community radically and applied new pressures. I still use it for puppet, chef, ansible, and even 3scale. Erlang was built with fault tolerent communication in mind. The ability to scale across nodes with processes and to catch failing process with a supervisor is awesome! I would have to say though that Golang was really the first language designed for how the internet is used today. The majority of libraries I use are in the stdlib. I only reach out to one lib for netter route handling and another for a database adaptor. Both of those accept the way that the stdlib works implementing interfaces directly from there. If we wanted to compare the way Ruby vs Golang communities work I'd say that Ruby language development is driven by community projects, whereas with Golang, the language development drives the community projects. Not only is the latter true, but I'm seeing the Golang language drive features in other languages such as making channels cool again. That's what I'm seeing happen in Ruby with Guild. I've left off comparisons of distribution (binary please), etc. I feel that I've probably said more than enough in the parent post about my hopes for Ruby. I really don't want to say one language is better than another. I use Ruby, Golang, Rust, and sometimes Python as needed. I have other languages at my disposal for less needed tasks. The point is, I really hope Ruby speeds up and provides more in it's standard library so that I can use it more often: I can see it growing, and though it's not there yet, I have a lot of hope for it.
I did this one earlier this year. Go to 5.0 first. There are enough changes that you won't want to do this in one shot.
Not really redo. Just need to update the calling syntax on the request methods. That was probably the least painful party of our journey from 4.2 -&gt; 5.1. I'll be looking at 5.2 today...
I just gotta deal with all the abandoned dependencies too that have gemspecs limiting to rails 5.0, and may need changes to work with 5.1/5.2. 
I worked at a company that spent over a year upgrading 2.3 to 3.x. The pain is real. I try not to couple strongly to any frameworks anymore, including frameworks I've written :-)
At least when 6.0 is out 5.2 will still be receiving patches for major security vulnerabilities under the maintenance policy! I think what I learned is it's better to stay on a x.2. 
Fortunately, upgrade pain hasn't been nearly as bad as 2-&gt;3 in Rails since then. It can still be painful though. 
I think 3-4 was pretty easy, but I don't know about 5. After a few years away from rails it's hard to recognize parts, tbqh Rails 3 also had 1.8.7 -&gt; 1.9 ugh
Yup, 4-&gt;5 was also "pretty easy". But "pretty easy" on a model project can still be lots of pain on a messy project with lots of legacy and architectural and dependency choices you would do different today (you may not have been around when they were made in the first place). 
I know this pain, it's real. Happy hunting... If you get through it, it's a great feeling being (tech)-debt free!
Hey /u/janko-m, just had a thought: Is making sure the JPG output is a _progressive_ JPG part of the ImageProcessing API? It makes _so much_ sense to make sure your thumbnails are progressive JPGs. They are often (for mathematical reasons I don't understand) _smaller_ in file size, but more importantly they load with a way better for UX under a slow connection. Another, although less important, thing that makes a lot of sense for web thumb JPGs, is stripping EXIF metadata, and making sure they are translated to color-profile sRGB. These are things that all the guides for creating JPG thumbs on the web recommend (including [Google's](https://developers.google.com/speed/docs/insights/OptimizeImages)), but I find often left out or not highlighted in documentation in ruby easy-thumbnail-gen libraries. 
I feel the same way about Golang. I recently built a product that wouldn't be possible with just ruby/rails etc but Golang had the concurrency, channels and semaphores that I was looking for. I am still using Rails on the administrative side, but for the extremely high performance parts I had to switch to Golang. 
It is really hard to get excited about the latest Rails releases. Rails used to fit nicely in the ballpark where most of Rails would be useful to most applications but it only keeps growing. On every release, it feels that there are more and more parts of Rails that I won't be using. It all started in Rails 5.0 with ActionCable (which is still painfully slow and horribly awkward to setup in production). Now we have ActiveStorage. ActiveStorage is actually really nice but is there any reason to make it part of Rails besides "Basecamp uses it"? The simple fact it is built by the Rails team will make it a standard in the community. Why force it down on everyone? Bootsnap is a welcome addition but do we really need bootsnap and spring? Now if something goes wrong when loading code (believe me, it does happen), I need to debug three different places: bootsnap, spring and rails autoload. Every Rails release makes me worried my application is becoming harder and harder to maintain by the sheer amount of moving pieces it brings. Can we please go back to basics? I have to admit early hints support in HTTP2 is really welcome though.
Due to modular nature of Rails I have no idea what you're upset here with? Don't want ActiveStorage, turbolinks, whatever? Just exclude it. I kinda like that Rails is including things that most apps need. Otherwise you have problem with upgrading because all 3rd party dependencies take years to catch-up.
See the Ruby gem [contracts](https://rubygems.org/gems/contracts), a very robust and flexible type-checker. See also the [tutorial](https://egonschiele.github.io/contracts.ruby). 
&gt; Otherwise you have problem with upgrading because all 3rd party dependencies take years to catch-up. Well, if you make the Rails integration of your libraries small or nonexistent, then there is nothing to "catch-up" with. For example, I've maintained [Shrine](https://github.com/shrinerb/shrine) for almost 3 years now, and I never needed to update it to support a new Rails version, because it only has a tiny ActiveRecord integration that relies on stable ActiveRecord API. I would prefer if, instead of reimplementing some gems like they did with ActiveStorage, Rails would pull that gem in as a dependency and maintain only the Rails integration.
I hear you. On one hand, what sucks the most is the fact that ActiveStorage is not a separate gem that could be swapped in for Shrine or something else. `rails new` will put all AS stuff in your app (unless there's a switch to skip it). On the other hand I like the fact that Rails team is now responsible for maintaining file upload functionality. I wish they just absorbed Shrine instead of making something from scratch. Although Shrine doesn't do on-the-fly image transforms like AS does with `.variant`. That's a big thing for me. I maintain this [CMS](https://github.com/comfy/comfortable-mexican-sofa) for over 7 years now. Obviously it has file upload functionality. It used paperclip for years. Problem is that if parent app is using something like Shrine or Carrierwave, now we has two different libraries doing the same thing. So I really like having not to depend on 3rd party libraries. Actually with last major release I removed like half of dependencies because they are either outdated or just don't work with 5.2. 
I can definitely remove them (and I do). I just don't agree with them being good defaults in the first place. I also don't think the situation is sustainable in the long term. At this moment, Rails has 348 open issues and 719 open pull requests. As Rails continues growing in complexity, it will only become worse. And we are not counting all of the dependencies that Rails brings in. I know that many like to use Rails as a black box and that's fine but as someone who contributes to Rails, it makes me worried about the complexity of the Rails codebase and how it affects my applications.
I did the same but with AppEngine. Maybe I should put a blog about it
You should! I originally tried App Engine Flex, but it only works with 1-container apps, you can't use Cloud CDN, and I ran into some apparently hardcoded `app deploy` timeout limits. Managed TLS/SSL certs is awesome though. For a simple app I do think the PaaS-style of App Engine is preferable.
&gt; On one hand, what sucks the most is the fact that ActiveStorage is not a separate gem that could be swapped in for Shrine or something else. Yeah, since ActiveStorage is tightly coupled to ActiveRecord and Rails in general, I cannot use it, as I'm not using Rails nor ActiveRecord. So for me and the rest of the Ruby-off-Rails community Shrine or something else still needs to exist. I expect that Shrine and ActiveStorage will be implementing a lot of the same functionality, just like ActiveRecord and Sequel. &gt; Although Shrine doesn't do on-the-fly image transforms like AS does with `.variant`. That's a big thing for me. I agree that on-the-fly processing is really useful, but that functionality could also easily be implemented on top of Shrine. The reason why Shrine doesn't do this by default is because this functionality is a separate problem, which already has mature solutions like [Dragonfly](https://github.com/markevans/dragonfly/) and [imgproxy](https://github.com/DarthSim/imgproxy) (in [this post](https://twin.github.io/better-file-uploads-with-shrine-processing/) I show how you can hook up Dragonfly to do on-the-fly processing). Also note that on-the-fly processing isn't suitable for everyone and all types of files (e.g. video transcoding should be started on initial upload), so if it wants to be generic enough, a file attachment solution should provide a way to do both on-the-fly and on-upload processing.
After JIT is bit more polished, interesting metric I think will be `jit-max-cache / RAM usage`. I wonder on how bit project will JIT be really usable.
That does not sound production ready.
It's not, it's just me experimenting with it
Thank you!
(on Google Cloud)
Im not a developer. Just to be clear. 
Back to Ruby!
Ruby doesn't store data. Your data is most likely story in a SQL Database. And .Net can read SQL tables. pro tip: Hire a developer.
Yeah, I asked why we transitioned then. 
Your own computer, if you don't care about ugly domain names. Else, Heroku.
Good job, mate. Looks interesting.
that's where Google Kubernetes Engine exists, yes
This is great! Can you give some idea of the costs involved?
Don't want to upgrade until this bug is fixed https://github.com/rails/rails/issues/32329
I'm aware, but my point was **Google** Kubernetes Engine is in the title so it should be clear I'm talking about GCP without needing to clutter the title further. There are other options for running Kubernetes as well, like OpenShift. Maybe I'm mistaken and people think Google still owns the Kubernetes name (given the history) or something? *shrugs*
Like you said, it'll be EKS and not GKE.
That looks nice. I would use a different wildcard, though. For example `Qo::ALL`, otherwise you can't match on the symbol `:*`. 
It's a toss between succinctness of language and absolute security in the API. I leaned towards succinctness as a wildcard literal match will be the same as a wildcard match in the first place
Do you have any suggestions on the great resources to learn Golang?
All releases in the current major series and the last release in the previous major series are maintained, that includes 5.0. https://github.com/rails/rails/commit/22b0a302156027291e9e44897d9e49f01ab07908
You can't AoT compile Ruby. Meta-programming means anything can change at runtime and may need to be recompiled. The best you could do is pre-cache some JIT'd methods you know you'll need but that isn't AoT compilation.
I can't say that my speed matches other's. I've had over twenty years of learning and experience behind me through my career. I can say that my C and NodeJs knowledge worked towards helping me grasp Golang quickly. I learned on my own in about a week with the [basic tour](https://tour.golang.org/welcome/1) and some helpful free [books](https://github.com/dariubs/GoBooks/blob/master/README.md#starter-books) to guide me. Reading the stdlib and source code helped. Being able to read and understand other people's source code is key to your future period. I'd double down on learning from other programmers source code as a new grad. The hardest part of learning Golang was unlearning what I thought OOP was. There are some transition points that help you along, but if you have to lean on OOP you really have to think of structs and packages as your class and namespacing. It's not a perfect match and it would be better to leave OOP aside when learning this kind of language. It's more FP than OOP, with a twist of helpful mutation and concurrency added. That's probably good language learning advice anyway. Come to the language through the problems the creators sought to solve. Learn enough of its history to sympathize, then set aside your ideas of what good programming is. The community will usually be there to help guide you when you're stuck. Some paradigms never change. You still need loops and variable assignment, etc. Just don't drag in a whole philosophy and try to shoehorn it in.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dariubs/GoBooks/.../**README.md#starter-books** (master ‚Üí d9e0737)](https://github.com/dariubs/GoBooks/blob/d9e073764bffc4b73e3e187a3691d163c357f768/README.md#starter-books) ---- 
The [go wiki](https://github.com/golang/go/wiki#getting-started-with-go) has gotten surprisingly good. I recommend the tour then think of a normal problem you solve at least monthly and try implementing it. Follow up with the [go packages](https://golang.org/pkg) and play around I'm the [playground](https://play.golang.org). The source code in the golang repo has some really great idioms as well. You should try to read some of the function implementations as a reasonable introduction into how the core writes Golang as well.
try COBOL, it's this new exciting tech stack. 
&gt; part of it is that it tales twice as much code as it does in Golang for me; I find that hard to believe for anything sufficiently complex. Golang is "primitive" as hell, just has a strong stdlib for the most common web things. So, yeah, building a run-of-the-mill website with Golang is probably faster. But after you get the basics down? After you've exhausted Golang's stdlib? Once your requirements change down the line and the scope of the project is expanded? Or as you said further down, "I would say Ruby was designed for General Programming." And yeah, at some point, you stop worrying about all the fancy web features in Golang's stdlib and start solving abstract problems in general. Ruby has more expressive code, it has stronger tools to facilitate abstraction, its focus is, overall, on elegance. Golang is *purposefully* designed to be very C-like, with primitive tools for abstractions, and a focus on minimalism without regard for elegance. To be honest, I haven't done much with Golang yet, but in it's C-likeness (and probably Python-likeness), I'm going to say it probably ends up being a lot more convoluted and complex at the end of the day. &gt; the amount of cognitive load we deal with with Ruby until I have to teach a developer Ruby. I also wouldn't say cognitive load is particularly represented by how easy it is to teach relative to other languages. I think (drawing off of reading Golang code and my C and Python experience) Ruby is probably a lower cognitive load -- precisely because it's goal is to let you use powerful abstractions expressively. Once you've abstracted an idea, you rarely have to worry about how it works at a lower level. This doesn't seem to be true in Golang -- after all, its designed to be effective by putting lower-level ideas right in your face (for example, its lack of OOP). I'm not trying to bash Golang here -- but its designed from top to bottom to forego expressiveness in favor of simplicity. This is a good thing for many purposes (such as ease-of-learning, and what it's doing is very obvious), but generally, expressiveness leads to less code that's easier to understand (which I'll contrast with "easier to understand how it's doing what it's doing"). Golang sometimes is just a better fit anyway. Some programmers prefer "shallow" code (ie. fewer abstractions, using language primitives very close to the API layer) over the "deeper" code Ruby prefers. And, especially when you prefer shallow code, I think you're going to be more annoyed by relying on 3rd party code and prefer Golang's style of having the most common tasks built in. If you have to onboard a lot of programmers, yup, that's exactly a sort of problem Golang was meant to solve. And it seems you're reaping the rewards of these benefits. But I felt compelled to reply as I think you're ascribing deficiencies to Ruby wherein they're really just preferences or different needs. For example, you're not casting a preference for a language that's easier for dev onboarding, you attributed that to ruby having a "greater cognitive load." Your preference for shallow code is cast as "golang takes less code to write." Etc. Also, I'm mostly just replying as a way to procrastinate doing my homework.
Just more procrastinating on homework. :) &gt; It's more FP than OOP, with a twist of helpful mutation and concurrency added. It's not FP at all, and it purposefully foregoes OOP. First and foremost, Go is a [Structured programming language](https://en.wikipedia.org/wiki/Structured_programming), and its features, including concurrency and first class functions, are all intended to be used in that paradigm rather than use any off-shoot paradigms. It's approaches the Structured paradigm in a very "back to basics" way.
Awesome, thank you! There is definitely some confusion about this. I think yesterday edgeguides said differently? If this is a change in policy, thank you! 
Yeah, hate it when people assume everyone knows acronyms (like SICP = Structure and Interpretation of Computer Programs).
HTTP/2 Early Hints, Unobtrusive JavaScript (UJS), new error page based on better_errors, CLI hooks, project middleware, enhanced support for plugins, custom repositories commands, coloured logging, bug fixes. Starting from tomorrow we'll team with ROM and DRY teams to build Hanami 2, ROM 5, and DRY 1.
Congrats! =)
[removed]
Cobol on Cogs. called COC for short . hmm...I love COC
Is tech-debt free really a thing? I think maybe all one can do is try to keep up with it and keep it under control, there will always be more. :)
Uh, you didn't get early hints at all in any version until now, right? So how would them not working right keep you from upgrading? You're not losing anything...
I think that's easier to do with some kinds of functionality than others. But shrine is super duper awesome. 
I do think a built-in out-of-the-box maintained-by-shrine-maintainer(s) integration with dragonfly would be super great. Although I guess that might probably require some framework- (rails or sinatra or whatever) parts, which I know you try to minimize in shrine... but booting them down the road for consumers to deal with isn't necessarily minimizing the pain. In part showing the challenge of what you suggested before, keeping the coupling with the framework minimal. 
Oh my, if you saw Rails in 2.0 or previous days, you'd know what not modular really looks like! :)
I don't have an accurate full month's billing cycle I can share unfortunately, because until a few days ago I was running n1-standard-1 VM instances for the GKE cluster. I've also been deleting and recreating projects repeatedly and GCP's web console doesn't seem to let me view past projects' bills. This is the bill for running the demo for the first 10 days of April however, without the VM costs: | Product | Resource | Usage | Amount | |----------------|--------------------------------------------------------------------------------------------|-----------------------|--------| | Compute Engine | Network Load Balancing: Global Forwarding Rule Minimum Service Charge | 10.00 Day | $6.00 | | Compute Engine | Storage PD Capacity | 3,101.42 Gibibyte-day | $3.54 | | Cloud SQL | DB generic Micro instance with burstable CPU running in NA (with 30% promotional discount) | 10.00 Day | $2.52 | | Cloud SQL | Storage PD SSD for DB in Americas | 100.00 Gibibyte-day | $0.57 | | Cloud DNS | ManagedZone | 154.00 Hour | $0.04 | | Compute Engine | Network Inter Zone Egress | 2,937.25 Mebibyte | $0.03 | | Cloud Storage | Multi-Regional Storage US | 411.44 Gibibyte-hour | $0.01 | | | | Total | $12.71 | I don't know if that all can be extrapolated linearly for the rest of the month or not, as GCP has sustained usage discounts for some resource types (the DB instance for sure should fall under that). According to GCP's calculator, running 3x g1-smalls as I do in the demo should cost $41.39/mo: https://pbs.twimg.com/media/DaEuBGKUQAAGlx-.jpg With the 3 nodes, there's still plenty of headroom if you wanted to run more application servers, background job (Sidekiq) workers, a Kubernetes CronJob or whatever: https://pbs.twimg.com/media/DaEuASCVAAAW3LE.jpg If you were really cost-conscious you could probably just run 2 VMs for the GKE cluster, although I think you risk some downtime when doing Kubernetes version upgrades (you'd probably want to disable auto-upgrade and do manual upgrades, temporarily adding an extra node to the nodepool so you have 3 nodes during upgrades).
Wow, that's a team with some heavyweight developer experience. Do you have more info?
Nicely explained. Looks like you can do stuff similar to 'with-&lt;some resource&gt;' lisp macros.
It is, although staying current with framework releases is far from the only action step needed :-) Tech debt is not a great analogy, but, you're right, sometimes we discover that a past decision was suboptimal. To stay "debt free" you have to correct those problems immediately. To be honest, developers often have a hard time seeing this as realistic. After all, we are entrained to believe that business needs trump software needs. This is short sighted, though. The business benefits greatly from a software team that stays on top of things. Much moreso than whatever they inevitably gain by wanting to expedite features at an unsustainable pace. Businesses and developers alike don't even know what this level of maturity is like, and so can't really even prioritize trying to get there. It's real, though, and it's amazing.
If you're still looking for a solution here, we should have support for this in a couple of weeks. Let me know if you're interested to check it out.
Sometimes the past decision _was_ optimal in it's context, but the context has changed. I dunno, I'm dubious. I think it can be done on shared code (gems, frameworks), if you prioritize getting it right over getting it released. (I keep thinking of writing something up on something I wanna jokingly call "slow code"). But on an application for a particular enterprise? Our job is to meet business needs, and I don't believe that optimizing exclusively for maximal code quality always meets business needs. (Certainly neither does optimizing for minimizing it!)
&gt; Sometimes the past decision was optimal in it's context, but the context has changed. Yes, definitely. It wasn't wrong then, but it's wrong now. And by "wrong" I don't mean anyone should be made to feel bad or anything, just that it needs to be fixed. In my experience, most developers are spending all their professional time building at or near the lower specification limit. Meaning, they are doing the bare minimum needed to get things working and tested. Building at the upper specification limit, where you aim to maximally enable future adjacent work, is extremely uncommon. And when we start thinking about doing so, it feels like it'll take forever, and it actually will, at first, because we've never _practiced_ delivering at the upper specification limit. My experience has taught me that the more we practice "raising the bar," so to speak, the more that it takes less time to reach a higher standard. And our enterprises benefit greatly from higher standards. No business benefits from sinking three months into a rails upgrade, for example. Or from being unable to partition the system because the codebase contains pervasive use of relational DB associations that traverse across what would be partition boundaries. &gt; Our job is to meet business needs, and I don't believe that optimizing exclusively for maximal code quality meets the needs of every enterprise in every context. When code quality is defined as a developer indulgence, the conclusion you reached is the only logical one. But when code quality is _defined_ by that which maximizes the lifetime value for the business (and minimizes lifetime cost), then we have a definition of code quality that _serves_ the business. That's the only kind of definition that I'm comfortable with, to be honest. &gt; There are many places in between "crap unmaintainable code at an unsustainable pace" and "zero tech debt ever") There are, indeed. But I am not arguing that we never have "tech debt." I'm arguing that it should be taken care of immediately, in every circumstance except emergencies. The more we practice hitting the upper specification limit, the more often we get things right the first time, and the easier it gets to stay "debt free" because our progress is never hindered.
Ah, but predicting exactly what code will "maximizes lifetime value for the business" and "minimize lifetime cost" (including the "initial" implementation cost) is far far from trivial! For one (but _far_ from only) reason, because it's hard to predict what the lifetime of the code will be. And thus is the life of an experienced developer. I'm not disagreeing that many many enterprises don't allow the developers to do their thing. But just having an enterprise that supports it still doesn't make it easy. 
Yes, we changed the policy just yesterday to include all current releases in the major series.
you are my hero of the day thank you! 
Why?
Depends on what functionality you're interested in. There are a number of good alternatives when it comes to error tracking (Rollbar, Raygun, Airbrake, Bugsnag, Sentry...). For profiling, there's Skylight, Datadog, Vector, and probably a few more I'm forgetting. NewRelic has the advantage of being a one stop shop, but it's also phenomenally expensive compared to most of the alternatives.
Skylight and Scout are alternatives to consider.
AppSignal is my favorite!
Depends what you need. New Relic is great for all-around monitoring but stupidly expensive. In my company, we run it for the server monitoring, error checks, and service alerts. Probably mostly for the error checks but here something like Rollbar is superior. Also good alternatives out there for profiling and such but as a one-stop solution, NR is hard to beat if you can afford it.
I‚Äôll post the github soon once I get back to my laptop, if that suggestion doesn‚Äôt work. I initially noticed the issue when I attempted to add a new hash to one existing outside of the function. In the story there is a path that gives you a pet and allows you to name it, then adds the name to the character_info. That‚Äôs where the issue arose. I‚Äôll get back to you once I am able to access my code.
Yay. Ive started to use hanami a few month ago (coming from ramaze and rails for work) and I begin to really like it and already use it for new production sites.
Either pass the value to the function such as: def function(name) Puts name End Or make it a class variable (less preferable): @name
Woah! Looking forward to Hanami 2.
Same reason I'm building a tiny Ruby in Rust. To learn.
Why not?
That's some clever coding, but I wonder if it really took less time than getting a JVM with client mode to install! But I'm not sure how much speed-up client-mode really gives you. JRuby has a whole page on dealing with and ameliorating slow boot times, which mentions several hints, including a project I hadn't heard of called "theine", which I guess is like "spring" for jruby. https://github.com/jruby/jruby/wiki/Improving-startup-time
Here's a write-up on variable scope http://ruby-for-beginners.rubymonstas.org/writing_methods/scopes.html
"There's always a million reasons to not do something."
Been looking at this myself. I'm currently in the process of evaluating the [Elastic APM](https://www.elastic.co/solutions/apm) stack - I know and love ES and Kibana, so doing APM in it seems like a good fit. The Ruby agent is still pretty young, but it's coming along rapidly.
What a weird metric - lines of code vs. _lines_ of test code? Not coverage?
It happens a lot, actually. e.g. ActiveRecord classes don't know what attribute access methods need to be defined prior to the application interrogating the DB table on startup. Or, you have some code that depends on a runtime constant, e.g. a value from `ENV`, that can completely change the available JIT optimizations.
I tried implementing a VM in Go once, but dynamic typing is not easy to implement in Go, as it has no generics. I ended up using Lisp instead. I was curious if OP made a VM but it looks like it simply interprets the AST, which is fine for learning of course :) Good job!
Be advised - If you are building rails apps for Raspberry Pi (or any armv71 architecture) be advised that there is a bug in Ruby, up to and including the latest stable release `ruby 2.5.1p57 (2018-03-29 revision 63029) [armv7l-linux-eabihf]` that will effect apps using `rails &gt;= 2.6.0` Rails 2.6.0 bundles the gem bootsnap by default which triggers the bug in Ruby. Any attempt to run a `rails` command will fail. As a fix, disable bootsnap by commenting out or deleting the following line of code: # config/boot.rb require 'bootsnap/setup' # Speed up boot time by caching expensive operations. 
&gt;&gt; I find that even in small Rails apps, Ruby makes refactoring too difficult to do as often as needed. So nobody does it. &gt; &gt; I have exactly the opposite experience. I'm skeptical - when you jump into new projects, they genenerally have great test coverage, and refactoring is a breeze? Not my experience as a consultant or employee. &gt; Ruby is very easy to refactor unless your test coverage sucks. Sounds like you agree with me: As you say, Ruby on its own is not easy to refactor. It requires extra work on the part of the developers.
Testing Skylight right now. What do you think about Scout?
What do you like about AppSignal?
Yes, i feel NewRelic is really expensive, and haven't aged really well. Our needs are mainly error monitoring, but performance monitoring and global server performance will be nice add-ons.
Our needs are mainly error tracking, but performance monitoring and global server performance will be nice add-ons. What do you think it's the best tool for error tracking?
In that case, Rollbar is my recommendation. It will get you far even on free tier and got lots of cool features. For performance, something like Scout can be investigated also
&gt; Elastic APM Cool thanks! This not an hosted solution, we've to install on our servers right? Actually, I rather have that I think.
&gt; I'm skeptical - when you jump into new projects, they genenerally have great test coverage, and refactoring is a breeze? Not my experience as a consultant or employee. Certainly there is selection bias involved, but I don't work for companies with shitty test coverage, always a question I ask during interviewing. Really the language doesn't matter here though. &gt; Sounds like you agree with me: As you say, Ruby on its own is not easy to refactor. It requires extra work on the part of the developers. If you have shit test coverage you can't refactor with confidence whether it's Ruby, Java, Scala, Go or anything else. Static typing isn't a magic bullet, "if it compile it works correctly" is a pipe dream.
I‚Äôve used Rollbar and Airbrake in the past. Both are solid. 
&gt; coming from ramaze and rails for work Somewhat off-topic, but I'm a bit surprised to see people still using Ramaze after all these years. It's a shame it never really took off.
Use a method such as: def name; character_info["name"]; end
So it sounds like you're trying to access it outside of the instance, but that hash is in the instance scope and therefore inaccessible from outside. Plenty of ways to do it, here's a basic example: 'class Character attr_accessor :character_info def initialize @@character_info = Hash.new end def set_name print "Enter Name: " @@character_info['name'] = gets.chomp.capitalize end def name @@character_info['name'].empty? ? 'Anon' : @@character_info['name'] end end character = Character.new character.set_name puts character.name'
So it sounds like you're trying to access it outside of the instance, but that hash is in the instance scope and therefore inaccessible from outside. Plenty of ways to do it, here's a basic example: ``class Character attr_accessor :character_info def initialize @@character_info = Hash.new end def set_name print "Enter Name: " @@character_info['name'] = gets.chomp.capitalize end def name @@character_info['name'].empty? ? 'Anon' : @@character_info['name'] end end character = Character.new character.set_name puts character.name``
Correct. I'm sure that Elastic is going to offer a hosted solution at some point, but the whole stack is open source and is built on your typical ES/Kibana setup.
honeybadger is another error monitoring (no performance) service that I use. It's priced well. 
Sentry is by far my favorite error handler. The free version records up to 10,000 events per month.
A caveat to the custom map function, most (all?) methods defined in Enumerable that take blocks return an enumerator if no block is given to them. This allows you to chain enumerations and pass them around.
Definitely recommended to use a class object to store this type of stuff. Then like others have said, you need to initialize the object outside of the scope so that it can be refined across multiple pages/views/rooms/whichever. 
That metric was in rails as part of 'rake stats' from the very early days, before code coverage tools were available. I guess some folks still use it.
I'm the co-founder of AppSignal. In that case definitively look at our product. We offer an integrated solution for all three areas you mentioned.
&gt; I do think a built-in out-of-the-box maintained-by-shrine-maintainer(s) integration with dragonfly would be super great. Great suggestion, yeah, it would be great to make a `shrine-dragonfly` gem that makes this easier. In that gem it wouldn't be a problem to add additional integrations if they're needed.
went to sentry from new relic.. alerting and big free tier
tl;dr: They're exactly the same.
Performance benchmarks versus MRI and Jruby? Or is it too early for that to be meaningful?
Well, i do still use it in production and do not miss any features tbh. Web isnt that fast with new technics. Manveru told like 3 years ago to me, "what, you still use ramaze? Its 2015" (He was the guy who created ramaze).
Ah, now that you say it. Your name sounds familiar (not only) from the irc times.
Tackle these http://blog.headius.com/2012/10/so-you-want-to-optimize-ruby.html before making performance claims about Ruby, I'd say.
I think others have probably answered your primary question, but I have meta suggestion. When asking for help, instead of saying ‚ÄúI get an error‚Äù say ‚ÄúI get this error:‚Äù and then paste the full text of the errors from your terminal. It makes it easier for people to respond with correct answers that are specific to your situation. As you learn more about software development and your questions get more complicated, it will really pay off. Anyway, I hope your learning project goes great!
They don't offer Rails monitoring (at least when I reached out to them in 2014). When I checked with them in 2014, this is part of the reply I received: Sorry for the confusion - we actually no longer offer the Rails Monitoring (https://scoutapp.com/info/support_app_monitoring) as we decided to focus on server monitoring. The help page is still there because some customers are still using the Rails monitoring offering. FYI, the Rails Plugin does provide some less-detailed Rails metrics. 
It‚Äôs actually the one I actively testing now, thanks foe the reply. 
I would recommend joining the Selenium slack channel. A ton of people on it, including Selenium devs, that could help.
Thank you for the suggestion! I have asked the question there as well, but haven't heard anything back as of yet. 
An I see. Maybe open an issue on Github? Looks like a possible bug. Did you try a different browser by the way?
I really love Warden: https://github.com/wardencommunity/warden It is a rack based authentication library. Devise uses it under the hood as well. It is very configurable and you can add multiple authentication strategies very easily ( e.g. tokens, remember me, password strategy etc etc) This RailsCasts is old but still relevant: http://railscasts.com/episodes/305-authentication-with-warden
[Rodauth](http://rodauth.jeremyevans.net/) would probably be my first choice, coming from the guy who makes my first-choice [ORM](http://sequel.jeremyevans.net/) and [framework](http://roda.jeremyevans.net/).
I personally use Warden. There are a few alternatives listed here: http://awesome-hanami.org/ I know that Ryan Bigg is building a new one for Hanami.
Warden will work for any racked base application, which currently means practically any ruby web application.
bcrypt
That‚Äôs really useful advice. Thank you.
Looks great, looking forward to rolling out some quick site to test this one out!
Are any major gems/apps using Refinements? Keyword arguments? I've seen very little use of either in apps or gems I've seen. Both were introduced in Ruby 2.0 so backward compatibility shouldn't be an issue anymore.
Very good point. Quick [https://github.com/search?utf8=%E2%9C%93&amp;q=refine+language%3ARuby+extension%3Arb&amp;type=](Github search) says it all Is it aversion to change and (unfounded) fear of breaking things? As for keyword arguments, I've actually noticed when working with junior developers that the resources they've used to learn have rarely explained them. Not really surprised when I get confused looks when I show how you can use those. In a way, it's not something that they might actually *need* to know, but it might be part of the problem in how rarely you see those in the wild.
We think alike! I very nearly added a note to my above comment for fear it would be come off as rude :)
Do you want to be able to store an arbitrary number of employees? Do you know what kind of variable you would use to store an unknown number of things? Also consider how a user should say that they are done entering employees and want to move on to the calculation. How might you do this?
I second this. Unlike Warden which provides only authentication, Rodauth is a full-featured account management framework that gives you everything you need, just like Devise.
You should look at using [Hash](https://ruby-doc.org/core-2.5.0/Hash.html) with [Array](https://ruby-doc.org/core-2.5.0/Array.html) and specifically `#append`. Something like `loop` might be useful. (https://docs.ruby-lang.org/en/2.5.0/Kernel.html#method-i-loop)
Thanks for the help!
Is there a pre-built oauth solution for rodauth?
GitLab makes use of keyword arguments in various places, though typically only newly added code uses it.
&gt; Generally, people say you shouldn't roll your own authentication code This is a maladaptation of: "don't roll your own crypto". Auth logic isn't crypto so feel free to build parts of it yourself. E.g., PORO policy objects work quite well over Warden. That said, making your own tokens requires applied crypto knowledge and you shouldn't do it unless you have studied the basics.
Use Solidus. 19/20 of the top contributors to Spree moved to Solidus after Spreecommerce cashed out. That 1 out of 20 simply cached out and isn't active on any of the projects anymore. That's why you'll see the GitHub stars lower on Solidus. The devs who were building and maintaining Spree decided to fork after Spreecommerce was causing drama. It's basically a MySQL vs PG comparison. Because of this, Solidus is far more advanced and leagues ahead of Spree. Solidus is Spree, just rebranded. The "new" actively maintained Spree is not the original Spree everyone knew and loved. It's a zombie project. It's like when your amazing Twitter gets hacked and you have to make a new one. That's essentially what happened. Use Solidus, it's the original Spree.
The safe navigation operator and keyword arguments are both excellent additions that improved the ergonomics of ruby. They aren‚Äôt groundbreaking but when you need them they are super handy. 
Two very different cases, as for me. Keyword arguments are everywhere: in production codebases, in newer (Ruby 2.1+ from the beginning) gems, in Rubocop suggestions and in the focus of the language development. Refinements fell in a rift between "we use ActiveSupport everywhere" and "extension to core objects are EVIL (even from refinements)" mindsets, constantly shamed by community speakers (like Bozhidar Batsov or Nick Sutterer) and have no support in JRuby (which is a serious "no" for almost any gem developer). It is a pity, I think. The feature is pretty useful (it is like "macros hygiene" in other languages). Yes, needs some thinking and polishing, but as far as (almost) nobody uses it ‚Äî ¬Ø\\\_(„ÉÑ)_/¬Ø
you got it! you can make your life even easier (or at least your code a bit more readable) by moving the repetitive `puts`+ `gets.chomp!` into a single method you can reuse: ```ruby def input(request) puts request gets.chomp! end ``` Now, you can (re)use it like this: ```ruby employee[:name] = input("Name of employee") employee[:wage] = input( "How much does #{employee[:name]} make per hour?") employee[:hours] = input("How many hours does #{employee[:name]} work per day?") ```
[https://relishapp.com/rspec/rspec-core/v/3-7/docs/hooks/before-and-after-hooks](https://relishapp.com/rspec/rspec-core/v/3-7/docs/hooks/before-and-after-hooks) the APIs are great for this
Yeah but which is the best for just this one test case?
I'd still argue that you shouldn't roll your own auth. It just takes one user that figures out an edge case you didn't consider that gives him admin access to ruin your app and your users' experiences.
I liked using bitwise logic for storing certain flags in a db field without having to do a migration every time we add a new flag.
Agree with you! By applying a mask to a set of flags we can easily manage a set of option in a DB
&gt;11 comments I've seen its best uses in "fast\_" versions of already existing methods for core classes, and some low\-level level operations that ruby core classes sometimes surprisingly do not support. \[xorcist\]\([https://github.com/fny/xorcist](https://github.com/fny/xorcist)\) is the best example. 
+1 for Rodauth
pdf only ?
For the time being, yes. It should be available for Kindle soon as well. You can fill out the form on the page to receive an update when that happens.
So the way this works is that when the user inputs a name for "Name of employee", the name automatically gets put into my employee name array? 
You know, I've been meaning to look into the elasticsearch gem. We use searchkick for a Rails project, but I'm not sure why.
Thanks for the recommendation, I did see an echo of hanami recently in either /r/ruby or /r/rails... what's your opinion so far?? I *love* rails and was actually impressed by the persistence and model decoupling. Can someone link to some benchmarks? Most of the things I've found are blogposts from several years back. Also, has anyone tried it?
I love how ActiveRecord/arel API is getting modular and composable enough to do cool stuff like that query_builder stuff. 
Not at the moment, but I believe that OmniAuth can easily be added on top of Rodauth.
I agree with you. At one of my jobs we rolled our own auth in a Cuba app, and I think we would have been better off with Rodauth (we couldn't use Devise/Sorcery/Clearance/Authlogic, as it wasn't a Rails app). We had opened a bug bounty for others to report security issues, and I've seen reports of some subtle issues our app had, that are already solved in Devise/Rodauth. 
Is uploading files via Heroku to S3 a bad thing? I am a starter and want to get some insight on this. When you refer to Active Storage, are you referencing having the ability to upload directly from the client to the cloud? How much of an improvement is that compared to Heroku to S3?
By combining the self-documentation of positional arguments with the flexibility of an options hash, keyword arguments have become the indispensable mechanism for passing optional collaborator objects in my code. I'm less taken by the safe navigation operator. It's handy but I regard it as indicative of a possible smell. When I write one I always think "have I missed some implied null object that I should bring to life?". As in [Nothing is Something](https://www.youtube.com/watch?v=29MAL8pJImQ).
Keyword arguments are an excellent addition, but I absolutely view the safe navigation operator as a code smell. You should rarely dig around in objects that are too far removed from the current context. I always use #fetch instead of #dig to ensure that the data meets my expectations.
Here is how I'd do it. If you are learning Ruby, you should use classes and such to struct your code. It's not easier to do it without it. https://gist.github.com/pedrozath/693484901a98d015b75a27e74e8e8577 PS: Please don't present this code as yours (on your school or anything). Use it for educational purposes and feel free to ask how many questions you want :)
We switched from New Relic to Datadog recently and have been very happy with the change so far. The APM monitoring in Datadog doesn't seem as robust (or I'm doing it wrong), but the rest of the monitoring is top-notch and plugged straight into PagerDuty.
Sorta. In Ruby, a method is always implied to be called against self. The reason you generally see self at all is to distinguish between a call to a method: self.foo = 5 and creating a local variable: foo = 5 That's the main use. No self, local variable is implied. And of course you also may need to explicitly pass the current self to a method or whatever. Super is a different issue. Calling super searches for the first definition for the current method one step up the inheritance/module chain. If you explicitly pass arguments, e.g. super(1,2) or even super() with no arguments, you make the call with the specified values. If there is no parameter list, i.e. just super, you do the call *with the arguments passed to the current method*. So in this case, calling super will call Hash's []= method with (key, value) as the arguments, whereas the first super call explicitly passes the key and the new array. Make sense?
Thanks, it just looks really cryptic. I was looking at it last night and this morning I guessed that self must be assumed but still wasn't sure. Thank you for your help.
you'll see it in most ruby code you look at, it is fundamentally part of ruby, to all methods on self without having to say "self.", it's just how the language works -- like many other OO languages. Java is similar, although what ruby calls "self" java calls "this". 
I have yet to use the safe navigation operator, but keyword args, I want to marry them. 
I don't think Refinements have _worked out_ to solve the problems they were meant to. Even people who would rather avoid re-opening stdlib classes... refinements don't really let them do what they needed to do before refinements in a convenient way. 
What's the main problem with them, for you? (I don't say there are no problems at all, just interested in your perspective)
Hello! Look, links from Google: 1. https://github.com/gosu/gosu/wiki/ruby-tutorial 2. http://dreamingechoes.github.io/game/gosu/ruby/become-a-videogame-developer-master-with-gosu-and-ruby/
&gt; Is uploading files via Heroku to S3 a bad thing? Yes, it's an extra hop for the file on the way to S3, which depending on the file size could add a noticeable amount of processing time per a request. Directly uploading a file S3, then sending a reference ID of that file is super fast in comparison. Active Storage has direct upload capabilities, though I've not tried it yet :/ I've heard good things about it.
Don't forget about [Padrino](http://padrinorb.com/). 
Well it's certainly faster than `man -K`. 
`try` has become the new `rescue nil`
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/github] [Gem Documentation](https://www.reddit.com/r/github/comments/8c7gqr/gem_documentation/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
You might not want to use RubyDoc.info if you care about how your API documentation is viewed. Better provide an explicitly generated API documentation where you can control all aspects. For the same reason you might also want to use a website for your gem's general documentation, and not Github's Readme page. If you don't have any webspace, use Github's free web hosting facilities where you can push your HTML/CSS/JS/... files, or use the integrated Jekyll.
Thanks, gettalong!
This is a popular question, so I wrote up the common cases and gotchas: http://thejqr.com/2013/10/14/selfless-ruby.html
&gt; The gemspec must specify any additional markdown file that's needed. Why is this a complication? &gt; Is there a reason not to just set the gem's documentation URL to the README.md over at the GitHub project? It depends what is documented and who your audience is. For methods it's important to document the method's signature: arguments, return values, exceptions. If the method accepts a `Hash` of options, those should be documented, etc... RDoc and RubyDoc.info make this easier to for users to consume than a README. GitHub Flavored Markdown (GFM) supports Markdown based tables and of course HTML can be added, but not everyone will use GitHub to view the docs or have/want to turn your HTML/GFM laced README into something digestible (though [Ocotdown](https://github.com/ianks/octodown) is nice üòâ). If you're documenting commands, config options, or even a small set of methods whose usage is simple enough to describe via an example then a README can work. Also note that RubyDoc.info uses [YARD](http://www.yardoc.org/), which does not support all RDoc directives. Most notably `:nodoc:`. 
I'm guessing you have some python experience? Perhaps? I only ask because I've been doing Ruby for four years, but had to start a project in python this past week. I felt the exact opposite of you :) I think the thing most distinct with this difference is that "the default method definition implies an instance method" in Ruby. You have to try a little harder to define a class method (when you understand how Ruby is executing your code at runtime it's actually quite clever and enables a lot of incredible programming opportunities. I don't know if the same exists in Python, because I think the magic largely comes from Ruby's inheritance mechanism.) Anyway, your post stood out a bit to me this morning as I am currently sharing your confusion on the other side. We'll each get there though, and reap lots of great programming karma for it!
[GitHub Pages](https://help.github.com/articles/what-is-github-pages/) and [SDoc](https://github.com/zzak/sdoc) are good options. 
Do you know if YARD documentation would be able to be hosted by GitHub Pages? 
Exactly
Thanks for replies folks. To expand, I would like to build the software and hardware to be able to connect a rails app to an internet enabled product of some sort, ideally I'd like to built a wifi enabled mains plug, safely. Was hoping in might be able to find someone else out there that has done such a thing and published part of the journey which I could use as an outline guide, solving problems along the way as a learning exercise.
@pmurach I'm a great admire of your work in these terminal gems, thanks for sharing. I may be using this one in my gem soon (http://github.com/pedrozath/coltrane).
It makes the null object pattern easy to write, as in `user.authenticate(password) || NullUser.new`.
In ruby only nil and false are falsy values. Everything else is a truthy value. So it's common to return something in a Boolean like function. But a method called authenticate should return an user anyway. A method called valid_password?() could return a Boolean.
OK.. that makes sense. So I guess essentially it has all of the functionality that returning true would have, plus more flexibility if someone wanted to actually use the returned user
Yeah I am with you and dhh on this regarding fixtures and minitest. I really prefer mini test to rspec. In don't like the rspec syntax of trying to be English. Plus most factories are just simplified fixtures anyway. I don't see a benefit over fixtures.
That's exactly the point yes. Pretty common in ruby.
I‚Äôm not at a computer right now so I can‚Äôt verify the behaviour, but my guess is that with your helper variable example you‚Äôre only calling `foo` with `‚Äùb‚Äù`. The reason that helper variable syntax works is because `+` is a unary operator - the ruby interpreter actually sees three distinct operations in that example - an assignment (of `‚Äùb‚Äù` to `_`) and two unary operations. The reason it doesn‚Äôt work inside the function call is because for a given argument you can only pass a single operation :) The reason the example with the `+` signs following the characters work is because they can only be interpreted as binary operations there.
I can't provide the "technical" reason, but take the two examples: def foo true &amp;&amp; true &amp;&amp; true end def foo true &amp;&amp; true &amp;&amp; true end The first example works fine. The second borks. In short, the first works because the lines end in `&amp;&amp;`s, which tells the interpreter that a new line will follow. In the second, the lines end in `true`, so the interpreter thinks the statement is ending. Or something like that. But you get the point hopefully.
You can end a line with a `\` to tell ruby there's something coming on the next line. So this would work: foo( "b" \ + "a" \ + "r" )
Decided to write a post about how some of the tricks and "magic" in Qo work behind the scenes. If you really want to learn more about it, take a look at the source code and tests. I've tried to keep everything thoroughly documented. Give Qo a try, let me know what you think: https://github.com/baweaver/qo
Since you can upload *any* HTML files to Github Pages, yes, it is possible. However, you would need to generate the YARD documentation beforehand, i.e. locally, and then upload it to Github.
Thanks, sshaw_, for your thoughtful reply. The [GitHub repository](https://github.com/BurdetteLamar/markdown_helper) that I have made into a [gem](https://rubygems.org/gems/markdown_helper) is in fact simple enough to document in the README page. But two others, [one larger](https://github.com/BurdetteLamar/structured_log) and another [much larger still](https://github.com/BurdetteLamar/RubyTest), would suffer from the lack of API documentation. _What was I thinking?_
Thank you! I've created tty-config to work well for configuring CLI tools. Actually, I have extracted it from a tool that I'm currently working on, so it is based on a 'real' need. Please give it a try! Your coltrane tool for teaching musical chords looks awesome! I really like it, may use it as an example of nice and useful CLI tool in Ruby in my talk, if you don't mind?
I was using Ruby / Rails when the current company I'm at was at one time fully owned by AT&amp;T. 
Thanks! That'd be an honour :). Also I'll sure use this gem in the future. Do you use telegram or any instant messager?
According to the description it'll be great until you want to work past ruby 1.9 
ah yeah, noticed it after i posted. i guess online resources is it and of course consulting with others. 
thank you! i usually use ruby-doc.org 
That's a good source too - online sources are just more easily up to date is all
I work for a VC, and use Ruby for devops, as well as for web services. No Rails - some Sinatra. 
Apple (#3) has several job postings for Ruby/Rails. https://jobs.apple.com/us/search?#&amp;ss=Ruby%20on%20rails&amp;t=0&amp;so=&amp;lo=0*USA&amp;pN=0&amp;openJobId=113160599
Of topic, but why using both Chef and Puppet? Why not just do all your configuration management in one? Are there certain things that each one does better that makes it worth keeping two configuration managers around? Or is it some departments just have a preference for one vs the other?
I don't know if it's still present, but OSX Server (when it was a separate OS instead of an add-on) shipped a Rails app in the OS itself. I believe it did mobile device management?
I worked for Centura Energy, they used a big mix of tech (Best tool for whatever they're doing) but Ruby was in there. 
We use whatever tool is best for the job -- there's definitely a good amount of ruby (and rails), particularly with greenfield apps.
parse the Atom feed .xml
I work for a privately head company, we use Ruby for Chef.
Here‚Äôs the code for the well known [Rails tutorial](https://github.com/mhartl/sample_app) by Michael Hartl. Here‚Äôs the [actual tutorial](https://www.railstutorial.org). It says the code is out of date and idk if you need to pay for it now or something. But you probably can compare the old version of the code to the new book. The benefit of this sample app is that the tutorial is extremely in depth and you can read about the reasoning behind certain code decisions if you want.
I'm actually working thru that book ;) So I already have it. On chapter 7 It's *super* useful but I was hoping for a second example
You can check https://github.com/tomatoes-app/tomatoes, it's a simple Poodore Technique application with sign-in using omniauth for Github.com authentification and a Monaco database
&gt;No Rails \- some Sinatra. Serious inquiry here \- was the 'no rails' by choice, necessity, you're the geek in charge and made the decision or? I like seeing "just ruby, not rails", as that means \(to me anyway\), that someone along the chain of command understands that Ruby != RoR and it's a scripting language/tool. Are you/your company in the USA or outside of it?
That's pretty much exactly what I was looking for. Thanks!
Thanks, that looks really good. Exactly what I was looking for 
I'm not fortune 500 but we're a pretty big craft brewery and our distribution portal is written in Ruby (Padrino specifically)
I've got a similar thing going where we have multiple configuration managers and it's purely because we haven't finished migrating everything. Frankly it's unlikely we will any time soon, so we maintain two separate things
Not Fortune 500, but $500mil/year revenue on a steady upward trajectory for well over a decade. Home improvement/remodeling industry. Our enterprise-y monolith is Ruby on Rails. We manage servers with Puppet, but that is on its way out for us. Lots of good things about Puppet but what we *don't* like about Puppet is having all of the Puppet config stuff in one repo managed by operations, while all of the application code is in another repo managed by developers. We have a devops team to bridge the gap so they're not *entirely* two separate worlds or anything but it's not ideal. We're moving to a model where our build process spits out Docker images that contain both code and configuration. We'll probably be there by the end of the year. 
How's Padrino working for you? I'm spending my Sunday trying to decide between Hanami and Padrino for a personal project. Probably gonna write a small toy app in each to get a feel for them.
Yeah, specifically I thibk theyre,using it for maps at least
So far I like it and it makes perfect sense to me. But I have never worked in the web industry so it's just a newbie's opinion
I switched from full Rails to Sinatra at my last job and for a project of this scope, Sinatra would have just required too much stuff added to get the functionality I needed. Padrino is a great middle ground if you don't want the full Rails stack but still want the flexibility of having generators, etc. Plus my time with Sinatra got me hooked on Sequel as my ORM of choice!
Financial Services reporting in. We're using a ton of ruby. Rails, Roda or Sinatra for our user facing and internal framework needs. In addition, we are taking advantage of the intuitive syntax and using ruby as a lingua franca for our cross discipline training sessions.
Don‚Äôt work there, but Bloomberg uses Ruby and/or Rails, to tell from their job postings...
The semi-technical reason is that because Ruby doesn‚Äôt require a line ending token there are syntactical ambiguities (such as the two examples here) that it needs to resolve one way or the other - generally it leans towards that a new-line indicates the end of your expression.
Ruby + Rails for almost all web services, which are mostly just REST-ish API layers. Most of the smarter server work is handled by Java or Python.
LOTS should stand for ‚ÄúLord of the Strings‚Äù
They clearly need a newer config manager that encompasses all their use cases.
Obligatory relevant xkcd https://xkcd.com/927/
Not fortune 500, but not a startup by any means. We use ruby as our main scripting language for most devops tools (deployments, general automation, for things in our ci/CD pipelines, etc) and for chef obviously which we use for configuration management on our whole stack
Fortune 500. Ruby for Infrastructure-as-Code (not chef/puppet).
Lord of the Shebangs
I‚Äôve been working on a CYOA as my first big coding project, and I‚Äôm really glad this was posted. Looking through other‚Äôs code has taught me a lot of different options and capabilities that are making my progress a lot smoother. I‚Äôm looking forward to scouring the code for this and seeing so many new ways of doing things.
This looks good! Just something I want to point out, you shouldn't need to write many `case` or conditional statements if using proper OOP, that's more suited for Functional Languages. In OOP inheritance and factories (convention-over-configuration a la Rails) are preferred over conditionals. Of course, Ruby being awesome, it doesn't get in the way and just lets you use it any way you like.
Is this a bank or an insurance company or ?
What does your company do ?
What does your company do ? What field ?
What's the main business of your company ? What do you do ?
It's a large telco company.They are usually so big that entire divisions could be considered a separate companies (they are that different and are usually a result of acquisition or a merger). From what I know all of the big configuration management softwares were in use (ansible, salt,cfengine etc).
My Twitter DM is open or you can use Gitter https://gitter.im/piotrmurach/tty
Probably best to ask on StackOverflow
Perl was my first ‚Äúreal‚Äù language after learning some AppleSoft Basic as a kid. Thankfully it was a joy to use and is what made me want to pursue programming as a profession. 
exactly my first thought. btw: if anyone want to feel that 80s nostalgia for gaming, I can recommend to play another round of rogue-like games. nethack or zangband or any other clone that runs on your machine :)
&gt; The security patches are no longer applied to the Rails 5.0.Z series. Actually they revised their security policy last week apparently after this was written (but before today when it was released?) Patches for severe security problems are still included with 5.0 releases. (Thanks rails team!) https://github.com/rails/rails/commit/22b0a302156027291e9e44897d9e49f01ab07908
The [reference code](https://bitbucket.org/railstutorial/sample_app_4th_ed) for the latest edition is hosted on Bitbucket
thanks for your precious tip ! :-)
I did read the article, again mapping ruby shape to haskell is not going to get you a clean implementation no matter how much you refactor -- the way to do this is to document and have a test suite for the interfaces (not the code structure) and then implement a clean and Idiomatic haskell implementation that really is well written and returns the expected interface. Mapping at this layer and trying to 1:1 map from ruby to language X is the hardest way to get a clean output.
[removed]
https://launchschool.com/blog/integrating-rails-and-bootstrap-part-1/ This is one I've used in the past. It was pretty easy to setup and is free. Good luck! Learnrubythehardway is also good if you're just getting into ruby, but it's a little tedious if you already know how to program.
Why not just use [GNU/Parallel](https://www.gnu.org/software/parallel/)
At which point exactly? As I mentioned there's probably a good reason why auto-correct doesn't work in parallel. You'd have to at least lock files. But correcting files separately in parallel would work imo. However that's not something where you'd gain much since if you're constantly using RuboCop chances are there're only a couple offending files. Besides it's not cross-platform.
Nice :) If you have a Medium account you could leave it there as a comment.
I'm not sure if you're going to find a gem that does this out of the box. You can check out gems like [PDF Kit](https://github.com/pdfkit/pdfkit) or [Wicked PDF](https://github.com/mileszs/wicked_pdf) which can handle converting a view to a PDF. Just create a view that lays out the data on the page like a check and then convert to a PDF for printing. The one thing to note is that sometimes text needs to be calibrated for the printer. I've noticed this with QuickBooks check printing.
Yes, I think what you're saying is right in many situations. But one thing to point out is that we're determined to avoid the [Big Rewrite fallacy](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/) (even though we've been tempted to take that route). Another thing is that this particular part of the Ruby code (the score calculations) is mostly functional already, so the leap to Haskell isn't that big. The main impedance mismatch is the flexible scoping rules of Ruby for which the technique in the post is a good help to understand what's going on. But yeah, it's still just a complement to ordinary testing, which we also do.
We're a sass company that spans many platforms, specifically in e-commerce (think connections to things like eBay/Amazon/magento) out stack uses most languages which makes deployment complex
&gt; Besides it's not cross-platform. it's cross-platform enough given the existence of cygwin project imho
i think you're overthinking it. 
Awesome. Used `saves_description = yaml_file.instance_variable_get(:@correct_guesses)` and it works now. I think the thing that differs between the way I'm doing things and the other code I saw was how I'm saving the data with `data = YAML.dump(self)`. Anyways, thanks.
Don't test migrations. Test the model. Also, you don't have to use TDD all the time. The important outcome is that you actually write tests. When you write them doesn't matter.
Your description code don't line up. You're just writing the contents of malware.txt to f4. malware_lines = File.readlines('malware.txt') ml = malware_lines.uniq a = ml f4.write(a)
Sorry that was a change I made to see why the hell the file size was increasing. it should be a = ml - sl
Ruby has several ways of making a variable. name = gets.chomp.capitalize Here, "name" is what is called a "local variable." As you might imagine, it can only be used in the place where you make it, that is, locally. When you make a method with 'def start' you have made another place, where your old 'name' variable isn't available. Try this code: number = 1 # local variable, available only locally, in this namespace. def two number = 2 number end puts two # 2 # two didn't mess up our old number because it was a different namespace. puts number # 1 def three @number = 3 @number end puts three # 3 def four @four = three + 1 # methods are available everywhere in the object @four end def five puts @four @four + 1 end puts five # an empty line, and then NoMethodError: undefined method `+' for nil:NilClass puts four # 4 puts five # 4 # 5 
Use the return value of the method. Return the node when it is found, otherwise return nil. Don't invoke the method again if you get the node in the return value.
Because Ruby 2.5 was segfaulting a lot on Rails I decided to start migrating to Rails 5.2 during the weekend. I was surprised to see a lot of broken gems. Also, I saddened by the fact that when checking the Github Issues of these gems, these problems were known for a while and not fixed. I've so far made 4 pull requests on different repos and no comments on anyone yet. I know people are very busy, and the hard work is often done for free, I don't want to come off as complaing about that. But there does seem to be a lack of being to communicate with the authors/maintainers of gems. 
*Profoundly* disagree. 39 years dev experience; 25+ with formal test experience; 12 years TDD/BDD/DDD experience. Write your tests first. That's the only way to prove to yourself that the code you write is actually the code you need, and not some YAGNI wank that'll just become a maintenance headache down the road. Remember, the best code you ever wrote will always be the code you *didn't have to write* to get the job done.
what you are doing here array_second = &lt;&lt;-RUBY def second self[1] end RUBY a = [1, 2, 3] a.instance_eval(array_second) is adding singleton methods to the singleton class of object a. A lot more idiomatic way of doing this is simply saying a = [1, 2, 3] def a.second self[1] end which is exactly the same as defining singleton methods for a class with def self.something (when self is the class) aka class methods. a = [1, 2, 3] def a.second; self[1]; end 
Gem maintenance is a significant community issue though, and an important concern for the over-the-top ‚Äúis ruby dead‚Äù line of questioning. It‚Äôs not dead, but a lot of active maintainers did move on to other places. 
The goal or my article is to present the BasicObject#instance_eval method and not to talk about the anonymous instance of class Class that is lazy initialized for any object a.k.a the singleton class.. But thanks a lot for the demo. :-) 
Sure in Ruby you have to jump to source more often, but even Ruby has API docs. And I have to jump to source in other languages too when stuff isn't behaving as expected. 
Maybe u made too big methods or complex? I think...
Please install Rubocop, run it, and fix every warning it gives you. Use proper logging, not `puts`. Please put an empty line between method definitions. And in general, use some empty lines to break up your code; it's very hard to follow when you don't use "paragraphs". (feedparse.entries.first).respond_to?(:guid) The parens around `(feedparse.entries.first)` are unnecessary. samplefeed_hsh = {"global"=&gt;"some global setting", "preferrence"=&gt;"some preference"} It's better to use symbols as hash keys unless you really need strings. That then also means you can use the new hash syntax: `{ global: "some global setting", preference: "some preference"}` 
why?
Thanks, I will do that
A little trick for OO, is when you have method names like `getlog` and `checklog` it can often be a hint there is an object you can create and use it log `log.get`, `log.check`, etc.
A lot of gems rely on "unstable" APIs, which are not part of rails extension contract \(if there is such a thing\). Given that rails constantly breaks API, even in your applications, it will also break other gems. And not all of them have an army of committers like rails. Some rely on only one maintainer, which eventually loses patience and gives up. 
You don't need a before block for one test. Otherwise put it at the same nesting level as the test.
The answer from /u/jawdirk is correct, but here's an expanded look at why, in case anyone's interested. Let's say your target is somewhere down the left edge of your tree, and you're looking at the root node. You get to the following block: if currentNode.left != nil depth_first_search(target, currentNode.left) end Well, there _is_ a left-hand node, so you'll call `depth_first_search` on it. And since we've assumed that the target is somewhere on the left-hand edge, then at some point, many layers of recursion later, the search will find the target, and print out a "Found" message: if currentNode.value == target puts "Found target (#{target}) at node: #{currentNode}\n\n" return Ok, great. So we return nil from `depth_first_search(target, currentNode.left)`. Then what happens after we leave that block? if currentNode.right != nil depth_first_search(target, currentNode.right) end Well, there _is_ a right-hand node. We've already found the target on the left edge, but there _is_ a right-hand node. So we're going to call `depth_first_search` again on that. This search will invariably fail, because the target was already found! And eventually it will run out of nodes and print out your "Not Found" message.
WOW!
*Disclaimer: I don't consider myself an expert on best practice in OOP, Ruby, or anything for that matter, so I would real like that other commenters to give feedback (positive, negative, or neutral) on the opinion following.* *Also note: others have given good stylistic advice but I'll just restrict myself to specifically OO matters, as that's what you've asked for. Although, the width of the lines made it pretty hard to read, not sure if that's GitHub's fault though. Also, including a real-data @feed_hsh or .yml would be useful but I still got the gist.* *Another note: I've had a lot of coffee, so I've added tl;drs headings in my wall of text to try to break if up (the irony, considering my advice, is not lost on me).* tl:dr; OOP is really about relationships between multiple objects ---- I don't know if you're planning on using this object elsewhere, but having one object in OOP is basically procedural programming with extra steps (although you've said it's just for practice so maybe you *intended* to restrict yourself to a single object). OOP is really about helping you to model the *relationships between objects* (physical or conceptual). If you only have one object, you're not really doing that, especially if you only have one copy of that object. tl:dr; your hashes are objects in disguise, break them out into their own classes --- As other commenters have pointed out, you could break this class apart into many classes. Basically any hash (incl. the hashes inside the hashes) can instead be a class. I would say you could definitely make a Feed class (and keep them in an array). You could move most of the content of #getdown into a method in that class. You could definitely put #parse entirely within the class. Maybe pass the base save folder when constructing the Feed, and then it could just save itself. That's all I've got time to blurt out for the moment. I hope there's something helpful in there (and hope even more there's not something erroneous, or misleading haha). 
In my experience usually the main gems are fine after the first or second patch release. But kudos for being proactive and submitting pull requests!
File#write expects a string not an array. 
Man I love splitting my code into paragraphs but get lots of pushback from coworkers. I continue the practice in my personal projects but find it interesting that people want to read 15 lines of code stuck to each other without so much as a hint to change of context e.g. setting up values, calculating return values and returning them etc.
That sucks. What an unreasonable standard. Do they just enjoy not being able to read, or
I‚Äôve gotten feedback from at least one coworker that the spacing makes the code less readable. At this point I just push it through on methods that are more than a little complex because I need to read it too. However on small methods I give in. ¬Ø\\_(„ÉÑ)_/¬Ø 
I have retrieved these for you _ _ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¬Ø\\\_(„ÉÑ)_/¬Ø`&amp;#32;or&amp;#32;`¬Ø\\\_(„ÉÑ)\_/¬Ø` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
Gotcha, transliterating to a new language is a "big rewrite" even if you try to rationalize it as not such. =)
That cleared everything up. Thank you for the wonderful explanation. I've got it working properly now. More importantly, I understand it. Thank you.
Ok, so the log would be an object and the feed could be a separate object.
I'm not too familiar with bundler. I will look at that. I see what you mean about having a few classes rather than one big abstract one.
I have never heard the phrase "inner variable" before. Do you mean "instance variable"?
Thank you for your comment Exactly. But, as we called them from an outside scope, I prefer to refer to them as ‚Äòinner variables‚Äô. 
If what is passed is not a string it will be converted to one using to_s. This may well be the cause of the extra data as converting an array of strings to a string with to_s gives you a string with brackets, quotes, commas etc. 
Personally, I would suggest that if you are writing intro's for beginners, you use standard terminology so they get used to the conventional terminology, instead of coming up with your own. 
Thank you for your suggestion :-)
Yup!
Yup, you've got it. It's just a little *cheat* that's easy to identify. It doesn't mean something needs to be a separate object, but sometimes you can see some really nice abstractions without thinking too hard. These are two of my favorite talks about OO. Basically everything Sandi Metz does is gold. https://www.youtube.com/watch?v=8bZh5LMaSmE https://www.youtube.com/watch?v=OMPfEXIlTVE
I don't understand what relationship there would be between ruby 2.5 segfaulting and Rails 5.2. I don't think you found the right direction to try to solve your problem! (I'd downgrade to ruby 2.4, and/or figure out what was causing the segfaults -- probably a dependency with compiled C of some kind, rather than Rails). But yeah, there are gems that used to be maintained well and aren't anymore. I don't know if this is going to happen in any mature community that's old enough to have "old" stuff, or is part of the ruby community having gotten a bit smaller from it's heydey. Many have learned to be careful with what dependencies they use as a result though, rather than trying to solve everything with someone else's gem. 
There's a lot more to learn about variable scope, especially when you start making your own objects, but this is a good start!
Gah, agreed. Hovering over each segment shows the actual numbers, but not having them displayed in plain text without hovering isn't helpful. I'll see if I can improve quickly.
facepalm.jpg The area of slice is a square of the value it tries to represent.
[facepalm.jpg](http://i.imgur.com/FwsRdVg.jpg) --- ^(*Feedback welcome at /r/image_linker_bot* | )[^(Disable)](https://www.reddit.com/message/compose/?to=image_linker_bot&amp;subject=Ignore%20request&amp;message=ignore%20me)^( with "ignore me" via reply or PM) 
So you starting a business then?
Yes! I think there's a market of developers who'd like this to be easier. I didn't want to get raked across the coals for shamelessly plugging on reddit, so if you're interested (and haven't figured it out already) DM me and I can send you more information.
I swapped them out for a bar chart üëç
I've created this gem to provide a better way to create value objects from active records model. Please I want to know what's your opinion about it! Any feedback or idea to improve is greatly appreciated.
I'm willing to bet the IT department at your employer has a bunch of guys that are Microsoft certified, your company is deeply entangled in the Microsoft universe \(Exchange server, Office365, etc\) OR one of the Pointy Headed Bosses read somewhere that ruby is dead and only Microsoft can provide the solutions to non\-existent problems...
Does this mean I should stop maintaining the CombinePDF gem?
I just saw that you‚Äôre looking for a new maintainer. I might be willing to take it on. Let me know if you think it would be a good fit.
Seriously? I'm clearly very new at this and rather than being helpful and giving constructive advice, you'd rather just make me feel bad?
yes
Hmm. Ok. On a theoretical level, I get that. That makes complete sense, and I suppose it's what I had in mind for how it *should* work... but on a more practical level, I'm not completely sure how that is implemented in this case. I suppose that's what I thought I was doing with that return after the very first 'if currentNode.value == target'. Obviously that isn't actually the case. Can you give me any pointers for what direction to go to implement your advice?
Thank you very much for taking the time to write this all out. I *really* appreciate it! I thought that something like this might be the case but wasn't quite able to wrap my head around it entirely... I suppose that's the perils of recursion... I'm not quite sure where to look to get it to exit rather than continuing on. Could you point me in the right direction?
composed_of is kind of poorly documented and rarely spoken of -- I kind of thought maybe they had removed it from Rails! Not remembering the exact name of it to google for. I wonder if the author didn't know about composed_of, doh. Oh hey, I wasn't totally imagining things, look it's a PR from 2012(!) in which Steve Klabnik removes it from Rails 4(?), but then it didn't happen. (?). https://github.com/rails/rails/pull/6743
I'm working on something (in progress) that can be used for similar purposes, but serializing everything inside a postgres jsonb column. https://github.com/jrochkind/json_attribute
Yeah, a) it didn't happen, but b) it still could if the Attributes API gets extended, as Sean Griffin (who did the implementation work for attributes) touched on briefly in [this podcast](http://bikeshed.fm/8).
I have something (not nearly so developed) in my toolkit but have not gemified it, just https://gist.github.com/inopinatus/f1c3a06b319adf80ed4f9aeee65db220. Still not sure I actually like using jsonb for the attributes of a domain entity. It's super handy in a pinch (STI especially) but leaves me feeling like I've failed at ORM and sold the database short. 
WeasyPrint is not popular but I found it to work well. I've been considering moving off of wkhmtltopdf to it as wkhtmltopdf doesn't have a big team backing it (take a look at how overwhelmed the github is with issues -- I feel sorry for the maintainer). The interesting thing about WeasyPrint is that they really pay attention to the CSS standards and aim to implement the standards. Perhaps on their own timeline as it can happen but that is the goal. That is admirable but it also works fairly well now. For my usage, I was able to get more control over the rendering process and found it to be a win over wkhtmltopdf. The only reason I haven't switched is I tried it in order to complete a report for a perspective client but that fell through. The existing wkhtmltopdf work is fine so not in a rush to swap it out (always something else to work on).
I have poodr and 99 bottles but a lot of it is over my head.
Cool, are you doing anything different to these guys? https://docraptor.com/
Yes! My product doesn‚Äôt just provide an API, but provides most of the UX (optional) as well. Not to mention modern JS/CSS support and most of the optional configuration done within the HTML itself.
Didn't really use to make PDFs a lot but I tried wkhtmltopdf -- the only problem was the "unpredictable" page size depending on OS. Maybe it is already fixed somehow, idk, it was 1.5 years ago.
ok so like I can design a pdf layout template then merge it?
Not quite. Think add .pdf to a URL and get a PDF back. [Here‚Äôs a quick 1 min example](https://breezypdf.wistia.com/medias/hkgrltma8o) of adding pdf support to a web app that stores data in the session, along with a live [demo](https://ruby.demo.breezypdf.com) and the [source code](https://github.com/danielwestendorf/breezy_pdf-ruby-demo).
is there anyone at this point who *doesn't* have their own json attributes mapping library?
Tremendously better. Thank you
Hey. It‚Äôs been awhile but I just wanted to thank you for your support. I managed to get the URL using regex. I also improved the script identifying the HTTP requests that are made and parsing the JSON. I then extract the data from this and will attempt to use Mechnize to post these HTTP requests. I also started to look at Nokogiri. Thanks for the support!!!!
What would be "proper logging"? I have just gotten used to putting in messages so I can debug.
Ruby has a built-in `Logger` class. Its documentation is [here](https://ruby-doc.org/stdlib-2.4.0/libdoc/logger/rdoc/Logger.html). It's a lot more powerful than just `puts`. Some reasons: * Whenever you log a message, you specify the "level" of the log. Is it a debug message? A warning? Is it a completely fatal system error that means your app is crashing? Then you can set the logger to ignore messages that are not very important. For instance, if you set the logger level to "warn", then only warnings and more important messages will actually be logged; others (e.g. debug messages) will just be ignored. * You can tell it to write to the screen like `puts`, but you can also tell it to log to a file. * If you're logging to a file, you can tell it to keep the log file under a certain size, and once you go over that size make a new file. This way you don't end up with log files that are gigabytes in size. * All of the above is configurable in code, so you can have different settings for your development version and the production code you release to customers.
Thanks
The author here! Haha I feel really embarrassed as I didn't know about compose_of API. I wouldn't have developed this if I knew about it. But now that I have already developed it, and comparing the too, I prefer to map the attributes and schema data as hash and not with an array of arrays like the compose_of API uses. I was thinking in adding the constructor feature too. But also I was planning to are more conventions. Like reading your PORO attributes to automatically map without any configuration. Maybe I should improve the compose_of API and write a PR to it. What do you think about?
As far as I know the Attribtues API just map one column into an object, and you cannot map multiple. Right?
The compose_of API seems to be kind of a red-headed stepchild of Rails, the Rails devs seem to be always trying to get rid of it, heh. I wonder if you could develop your thing as an even slimmer gem, a layer on top of the existing compose_of, that provides the API you like better? Plus, if the Rails devs ever did succeed in removing compose_of from Rails, you could just copy the code that (at that point used to be) from Rails into your gem, and users of your gem could keep on trucking. (I wouldn't feel too embaressed, last time I thought I needed `compose_of` and couldn't remember the name of it, I couldn't find it trying to google for it without knowing the name! And with some memory of how Rails devs tried to kill it before, figured it had been removed.)
I believe that is true at the moment, without some crazy hacking anyway. 
In my json_attribute (prob soon to be renamed before release), you can store different attributes in different columns. `json_attribute :my_json_attribute, some_type, container_attribute: "some_jsonb_column"`. But you'll still end up with at least one top-level key, the json in the db will be `{ "my_json_attribute": ...}`. It is not set up for your use case, it's true -- I generally want to put multiple attributes in a column, for me that's part of the reason I want to do this at all. Additional features could possibly be added to meet your needs better, but I'm focusing first on my needs and some reasonable generalization from them. Trying to be super duper flexible can be a recipe for chaos in the code. :) Likewise, _most_ features of the gem don't actually rely on postgres jsonb, and _could_ work with MySQL :json (or even text) columns too. (The obvious exception being the querying using jsonb contains). But I'm starting with what makes sense for me -- and I think most people who want to use json in the db probably are already wanting to use postgres for it's superior features wrt to that. But yeah, it's not gonna work for everyone! 
The timing of this is rather eerie. I was just dwelling on this idea yesterday evening. Saving.
Does this work like Faye, where you‚Äôd POST to the server to have it broadcast messages to clients?
Thank you BigBinary for these super useful and well-written/researched "changes in ruby" posts! 
To provide a bit more background, whilst tangibly similar to Faye the architecture of Bifrost is much simpler, this has disadvantages in that, right now it can only run on a single server as sockets are stored in memory and your web app has to POST to the bifrost server to then relay messages out to all clients. The model is very similar to Pusher if you have used it. Whilst there are disadvantages I feel the simplicity and convention of a uni-directional push only model and using JWTs for authentication lead to a much faster setup and lead to less things going wrong. Crystal and Kemal are very fast and use minimal resources on the server, so a single server setup should be more than okay for most use cases.
Great! Benchmarks of TruffleRuby vs JRuby vs Ruby looks very promising.
There are several issue with chrome on travis. Most notably their container infrastructure seems to has issues with recent Chrome's sandboxing system. Here is the config I use, which has some extra stuff in it to get downloads working in headless chrome: ```ruby require 'selenium/webdriver' Capybara.default_wait_time = 5 Capybara.register_driver :chrome do |app| Capybara::Selenium::Driver.new(app, browser: :chrome) end Capybara.register_driver :headless_chrome do |app| options = Selenium::WebDriver::Chrome::Options.new options.add_argument('--headless') options.add_argument('--no-sandbox') options.add_argument('--disable-popup-blocking') options.add_argument('--window-size=1366,768') options.add_preference(:download, directory_upgrade: true, prompt_for_download: false, default_directory: DownloadHelper::PATH.to_s) options.add_preference(:browser, set_download_behavior: { behavior: 'allow' }) driver = Capybara::Selenium::Driver.new(app, browser: :chrome, options: options) bridge = driver.browser.send(:bridge) path = '/session/:session_id/chromium/send_command' path[':session_id'] = bridge.session_id bridge.http.call(:post, path, cmd: 'Page.setDownloadBehavior', params: { behavior: 'allow', downloadPath: DownloadHelper::PATH.to_s }) driver end Capybara.javascript_driver = :headless_chrome ``` And in .travis.yml you need these two settings: ``` sudo: required addons: chrome: stable ```
Recently, I undertook a migration from PhantomJS/Poltergeist to Headless Chrome/Selenium on a project I work on (Rails 4.2) and faced similar issues but happened to solve them by adding this to my .travis.yml file before_script: - wget -N https://chromedriver.storage.googleapis.com/2.36/chromedriver_linux64.zip -P ~/ - unzip ~/chromedriver_linux64.zip -d ~/ - rm ~/chromedriver_linux64.zip - sudo mv -f ~/chromedriver /usr/local/share/ 
Recently, I undertook a migration from `PhantomJS/Poltergeist` to `Headless Chrome/Selenium` on a project I work on (Rails 4.2 but we're currently working migrating to Rails 5 and everything has gone smooth so far) and faced similar issues. I finally got Travis to work with said tools by adding this to my `.travis.yml` file: before_script: - wget -N https://chromedriver.storage.googleapis.com/2.36/chromedriver_linux64.zip -P ~/ - unzip ~/chromedriver_linux64.zip -d ~/ - rm ~/chromedriver_linux64.zip - sudo mv -f ~/chromedriver /usr/local/share/ You also need to add `chrome: stable` under the `addons` section. As a recommendation, I'd avoid using `chromedriver-helper` since (at least for us), adding it to our Gemfile usually broke Travis and none of our tests would run.
thanks, i'll try it out. What's that "bridge" stuff about? I didn't see that in any of the other various things I was finding on google! 
Originally headless chrome didn't allow downloads, as of Chrome 64 it does support it now but there is a series of steps required to enable it. If you don't need the download support, I think the key issue is disabling the Chrome sandbox, the `--no-sandbox` option, along with _maybe_ forcing travis to run on the VM based architecture, `sudo: required`. Also I believe the default version of Chrome on travis is pretty old and headless had some other issues so either using `chrome: stable` or something &gt;= 64 is recommended.
We actually modified our `rails_helper` but sure: require 'selenium/webdriver' Capybara.register_driver :chrome do |app| Capybara::Selenium::Driver.new(app, browser: :chrome) end Capybara.register_driver :headless_chrome do |app| capabilities = Selenium::WebDriver::Remote::Capabilities.chrome( chromeOptions: { args: %w(headless disable-gpu) } ) Capybara::Selenium::Driver.new( app, browser: :chrome, desired_capabilities: capabilities ) end Capybara.javascript_driver = :headless_chrome Take into consideration that if you work **with** Docker and you're going to run your tests **with** Docker, you'll also need the `no-sandbox` flag in the `chromeOptions` line
As a counter point, I use `chromedriver-helper` without issue but force a particular version by calling `Chromedriver.set_version '2.37'` in a support file (required in `spec_helper.rb`).
&gt; disable-gpu We haven't found this is required but we're on Mac/Linux, I think it's mostly a windows problem.
Is that in fact the version you are currently forcing? Really, y'all, I (and others) need _all_ the details, if you aren't gonna open source your code to show me. :) Following other stuff I found on google, I always had the sense that if I was just missing like _one mystery line_ and then it would work, after all they said it worked for them! But not me. :)
Interesting. I think we didn't try that but since `chromedriver-helper` meant one extra dependency (we have our fair share of gems already) and it just broke our CI, we took it out of the equation almost immediately. Nevertheless, thanks for the tip! I'll check it out to see how well it fares
Yes. I can't point you to a repo but I just switched one of our apps over from `capybara-webkit` to `chrome-headless` last week. Everything I changed is now listed in this thread. The only tests that required changes were those that were testing file downloads. 
Our specs got much more stable when we changed feature specs into system specs. Maybe that would help?
thanks but not the sort of problem i'm having, i'm not even at the point where I can have that problem. :)
Okay, I'm making progress, thanks moomaka. But now I have a new error. I have followed your advice for "sudo: required ; addons: chrome: stable` in .travis.yml, with chromedriver-helper gem, and `Chromedriver.set_version '2.37'`. Now I have a new error! ``` Selenium::WebDriver::Error::SessionNotCreatedError: session not created exception: Chrome version must be &gt;= 64.0.3282.0 (Driver info: chromedriver=2.37.544315 (730aa6a5fdba159ac9f4c1e8cbc59bf1b5ce12b7),platform=Linux 4.4.0-101-generic x86_64) ``` Any thoughts? Maybe I'll try it without the `Chromedriver.set_version '2.37'`
I had the same error prior to adding `chrome: stable` as Travis has an old version of Chrome be default. Look at your build log and confirm that it's installing chrome stable, I'd also double check your `.travis.yml` file and make sure it's correct. e.g. you haven't duplicated the `addons` section or mixed tabs / spaces, etc. 
Aha, I **had** duplicated the addons section! Good call! Man, if that was gonna be a fatal error I wish travis would complain about it! Holding breath and waiting for travis....
Note /u/chrisgseaton's example in the link above: $ wget https://github.com/oracle/graal/releases/download/vm-1.0.0-rc1/graalvm-ce-1.0.0-rc1-linux-amd64.tar.gz $ tar -zxf graalvm-ce-1.0.0-rc1-linux-amd64.tar.gz $ export PATH=graalvm-1.0.0-rc1/bin:$PATH $ gu install -c org.graalvm.ruby $ ruby --version truffleruby 1.0.0-rc1, like ruby 2.3.7 &lt;native build with Graal&gt; [x86_64-linux]
**SOLVED SOLVED SOLVED** Thank you reddit and especially /u/moomaka. I used moomaka's recipe with a few mods. * Indeed I did not need `sudo: required` in the travis, I went back to `sudo: false`. (I _do_ have `--no-sandbox` as a chrome option, it's _possible_ you don't need that if you do `sudo: required`). * I did add a `dist: trusty` to the .travis.yml, because travis docs suggested it might be necessary. I _think_ this is the default dist anyway, but doesn't hurt. * I did not need to set a specific chromedriver version after all, unset it works. My stuff is open source, so I can show it to you and future lost souls who come accross this. Commit that sets it up (nor merged into master yet, sorry a bunch of errant cache file removals made it into the commit too, and I'm not gonna try to clean up the commit right now): https://github.com/jrochkind/json_attribute/pull/14/commits/ef608b94aa63fcfd202f0855c2471be15659b2fa Succesful travis build: https://travis-ci.org/jrochkind/json_attribute/builds/368332700
Oracle legal standing in the way of progress, what a surprise. It is the same bullshit with their JDK when you have to install it on your servers. It leads me away from Java, so I hope they are happy. I am glad that TruffleRuby found a way, I hope they can use it for other software.
Good step forward but the number one news I want to hear is that we can start testing that bad boy on full featured rails apps (activerecord etc). Hope it comes this year and the same for a Crystal 1.0 release. then things will get very interesting
Couldn't agree more. If all these things come out along with Ruby 3... well all I can say is that Ruby just got a lot more interesting to a lot more people. Performance has been the Achilles' heel of Ruby so far, but it may be able to stand up to (and beat) its competitors with newfound vigor if all these projects hit the ecosystem as hard as I hope. Especially if they hit at the same time. Talk about a perfect storm.
I've always liked the System76 laptops, but they're a bit expensive. I recently picked up a Dell laptop from Costco when it was on sale. Similar specs as the 14" laptop, but cost $700 vs System76's $1400. You can install any OS including Ubuntu on these. However, from ever Windows laptop that I've owned in the past, the one major annoyance has always been the trackpad. None of them that I've ever had could even come close in comparison with Apple's. Even though the internal CPU/RAM/SSDs are similar to other laptops, the finishing touches on Macs are still the best out there IMHO. Over time, you will be just as functional if you were on Ubuntu or MacOS. If pricing is a major concern, I'd go with a similar spec Dell (or equivalent) and install the OS I want on there. If price and immediate productivity is a concern, go with a system76. If money is less of a concern, go with the Apple.
Padrino, last i checked, was halfway to Rails. So it offers a lot more built in (admin dashboards, accounts, ...). Roda is more in spirit with Sinatra in that it is barebones, but offers a better way to structure your routing and better performance.
Well I don't use the Padrino admin dashboard but I like the generators and stuff that comes with it.
Great advice thank you!
So the main issue is that even if `depth_first_search(target, currentNode.left)` does find the target, it goes right on to `depth_first_search(target, currentNode.right)`. What you need is to do some check in-between those calls to see whether searching the left-hand side was successful or not. Well, how do you know whether it was successful? The easiest way to communicate success or failure up to the previous iteration of the method this is to have `depth_first_search(target, currentNode.left)` return some value that indicates whether it found the target or not. You _could_ just have it return either `true` or `false`, and that would work, but traditionally, the most-convenient way to do this is to return the search result itself: if currentNode.value == target puts "Found target (#{target}) at node: #{currentNode}\n\n" return currentNode # &lt;---- instead of returning nothing Then your `if currentNode.left != nil` and `if currentNode.right != nil` checks get a little more complicated, because you want to store a possible result from the left-side search and check to see if you even need the right-side search. Maybe something like: result = nil if currentNode.left != nil result = depth_first_search(target, currentNode.left) end if !result &amp;&amp; currentNode.right != nil result = depth_first_search(target, currentNode.right) end Then, if you get through all of that code and your `result` is still `nil`, you know that the target wasn't found in either the left or right-hand branches from your current node (or those branches don't exist), so we can return `nil`. Or, if we _did_ find a result, we can just return that result to indicate that we found the target. Either way, I would then replace the entire `if currentNode == @tree[-1]` block with simply: return result Admittedly, this does not print out the "Not Found" message, but I would usually leave output to the code that's calling the search function rather than have the search function do it. In the code that calls this search, then, you could have something like: root_node = @tree[0] # IDK what your tree object is like, this is an assumption found_node = depth_first_search(target, root_node) if found_node puts "Found target (#{target}) at node: #{found_node}\n\n" else puts "Target (#{target}) not found.\n\n" end ------------------------------------------------------ (Chapter 2) If you're interested, there are some other ways to streamline this code a little bit more, but sometimes making code smaller actually makes it harder to follow. Here's how I would actually write this method: def depth_first_search(target, current_node) return nil if current_node.nil? return current_node if current_node.value == target return depth_first_search(target, current_node.left) || depth_first_search(target, current_node.right) end Whoa, that's very different than what you wrote. But the basic functions are still there. Part of what's confusing is the order of the lines. The first line, `return nil if current_node.nil?` is basically doing the same thing as your `if currentNode.right != nil` and `if currentNode.left != nil` conditions previously did, it just means that you don't need to check the left and right nodes separately in your method ‚Äì you can go ahead and call `depth_first_search(target, current_node.left)` without worrying about whether the left-hand node actually exists, because if it doesn't exist, this first line will notice that and return `nil`. Remember, `nil` is what we return to indicate that we didn't find the target on this pass. If there's no node here, we definitely didn't find the target. The second line is straightforward, it survived pretty much intact from the original. If we _have_ found the target, return the node. Simple enough. The third line is a simplification of all of that `result = nil`, `if !result &amp;&amp; ...` stuff from my previous version. It relies on the logical OR operator, `||`. The nice thing about this operator is it will only evaluate (run) the right-hand side if the left-hand side returned a falsey value (that is, either `false` or `nil`). Basically, the expression first calls `depth_first_search(target, current_node.left)` and then _only if that returned `nil`_ will it go on and call `depth_first_search(target, current_node.right)`. If either of those calls return a successfully-found node, that's what the whole expression will evaluate to. Then that result (either a node from the left side, or a node from the right side, or `nil`) will be returned directly. This means we can get away without ever actually assigning that result to a `result` variable at all! I like the streamlined version because it makes it really easy to see that one of four simple things is going to happen: either (1) there's no node here to search, so we didn't find the target, (2) we _did_ find the target, (3) we searched the left-hand side, or (4) we went on and searched the right-hand side after searching the left.
Performance has been the Achilles' heel only in PR. I don't think away from "bad PR" many people have struggled with performance related issues....
Nice article!
Dell isn‚Äôt the same brand as they used to be. They once made rock solid machines but that doesn‚Äôt seem to be the case anymore. I buy Apple hardware because it just works and it‚Äôs problem free. I could go through the issues I‚Äôve had with Dell, as well as people I know but you can Google and find all sorts of stuff. A $3K laptop should not have multiple screen issues across multiple machines nor should a $1500 all-in-one have a power button failure when it can‚Äôt be replaced because it‚Äôs permanently attached to the motherboard. My advice is to buy used or refurbished Apple. I sold a 3 1/2 year old early-2013 MacBook Pro for $1200 and it ran like the day I bought it. I just didn‚Äôt need it anymore. Apple machines really last and you can get a great machine pretty cheap. That said, Ubuntu is great. I use it for servers and haven‚Äôt had any issues. It uses apt which is similar to brew on Mac. The main drawback is no access to things like Office, Photoshop, etc but if you don‚Äôt need any of those you‚Äôll be fine. 
`report_on_exception` is a welcome change, given that without it, exceptions in threads are silently ignored, which I've personally found pretty frustrating at times when trying to debug multiple threads in Ruby.
I was going to say that Ruby makes it trivial to drop down into C so any thought loop can be made extremely performant. But, you never read blogs about it because it really isn‚Äôt necessary. Most performance problems I‚Äôve solved have boiled down to hitting the database to much. I‚Äôve never seen an issue that would benefit from a faster language. 
Because the previous comments missed it: terminal emulator that comes installed by default (GNOME terminal) has all the same functionality and the Ubuntu package manager is Aptitude.
You are truly a gentle(person) and a scholar! Seriously, thank you for taking the time to write this out. I know that this is a fair bit of your time to answer what was kind of a dumb thing to be stuck on, for a ransom internet person you don't know... But the level of detail that you went in to explain this to me really won't be forgotten. You are actually *really* good at explaining the concepts in a way that I understand. So, really, thank you very much! I'll be going through this a few times to make sure that I understand it.
[removed]
Does it differ resource-wise(memory)?
I still think `yield_self { ... }` should've been `block_chain { ... }`
Well I know I have. Not anywhere as near as people say but yes a few applications where I had CPU intensive processing it was VERY noticeable. Ruby is definitely slow with those kinds of tasks compared to Go. I don't know why i have been able to overlook syntax with almost every language and just want to barf when I see some of Gos 
I thought the tentative target for Ruby 3 was 2020?
For development ubuntu is good enough. apt-get, rbenv/rvm, chrome/firefox, rubymine/vim and you are rolling. I've been using it for 6years without issues. If you need MacOS depends on what are the other usecases you use machines for. I am happy I switched to MacOS even thought it is 2-3x more expensive.
Bad PR is understated. You find yourself with non-tech executives telling you that Ruby would be a bad choice for the four user intranet you want to build because Google said it performs poorly, and you start to see PR as something to fix.
It doesn't make a considerable performance difference. I think it's easier to read and understand if you pass it in the constructor. Just something to note: If an object has an attribute which sometimes it's used and sometimes it's not, then it's not consistent and hard to test. It makes the object complex. In that case a common refactor can be applied -- don't remember the name given to it by the "Refactoring" book but basically it involves moving all those attributes to it's own object, an object which always makes use of them. So if your Feed class does not always need a log array, I'd make a new `FeedLog` class and plug it in somewhere.
Excellent talk, thanks for sharing!
I wouldn't recommend using attributes which sometimes get used and sometimes not. It's considered bad Object Oriented Design. I ellaborated a little more on this in my other comment.
What do you build when you‚Äôre dev at a VC? 
Tools to manage deal flow and research, in our case. 
Interesting, thanks
[removed]
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/github] [Gem markdown\_helper CLI](https://www.reddit.com/r/github/comments/8dfaxk/gem_markdown_helper_cli/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
yeah I am on the fence -- I have used jsonb in this way before but 9/10 times I end up going back and just refactoring into a properly normalized relationship that is flexible. Highly unstructured/schemaless data slapped in jsonb always ends up feeling like a punt of the problem to the future...
It can def go both ways, but there's a reason postgres has been doing amazing things with their jsonb support, there is lots of interest. I figure if postgres is gonna do awesome at it, might as well get AR using postgres doing awesome at it for when it matters. What I'm hoping to migrate from is a really hard to work with store not based on an rdbms _at all_, so. 
What is \`gu install\`?
Oh, maybe it is. I thought it'd be sooner.
I just had a friend explain this to me. Turns out just a lot of the guides I'm using were under the assumption the programmer would be using dev servers, which is the reason for separate ports. It's fine in this situation to have it running off the same port. I was just unfamiliar to the process for dev servers here.
I think a better direction for `NoMethodError: undefined method '[]' for nil:NilClass` would be to consider type safety when coding. You could coerce nils into empty arrays and guarantee that `#map` won't raise an exception for something that is expected, or you could raise exceptions when you expect some variables to have a certain value. For me, when I encounter this error I feel like this is a lesson for me in type checking. I try to ask myself what wrong assumptions I've done about the data, and how can I better expect those next time.
&gt; Also I still wish yield_self { ... } had been block_chain { ... } module Kernel alias_method :block_chain, :yield_self end that should work? I mean, you can propose it as an alias, lot's of methods have multiple names, imho there no reason why this one has to have only one...
This is a good way of looking at it but sometimes empty value coercion is also not what you want. If the array should not be empty then the coercion from nil to an empty array can also lead to problems.
I mean, I think the _optimum_ is having no method so long that it's more than one "paragraph". :) But I do "paragraphs" too. 
Hence why I said you could also raise an exception. I think it's all about being explicit about your expectations in the code, which is also why I typically hate to see code that abuses safe navigation operator.
Hi, I'm the author of the post. I think this is an interesting point, I definitely agree about being explicit about expectations. I think the important thing is what you do once you've used safe navigation because you may still have a `nil` at that stage. That's when you can decide to `raise`, coerce or just nil check. I really like your way of looking at it though. So much of coding is about what assumptions you made up front that don't pan out as you expect. This is a good lesson :)
Cool! Now in Rails you could replace this raw-ish SQL: Subreddits.where('created_at &gt; ?', 1.year.ago) with a nice hash-conditional: Subreddits.where(created_at: (1.year.ago..)) Although, now that I look at that I kind of hate it... 
Ah, my every day thoughts as a programmer summed up so succintly. 
&gt; or you could raise exceptions when you expect some variables to have a certain value and they're nil instead. That you expected some object to have a #[] method, but it was nil instead -- is of course exactly what the original NoMethodError is telling you! But agreed it can sometimes be useful to catch it earlier. Other times, it's useful to do other things. 
This should work `Subreddits.where(created_at: 1.year.ago..)`
Shouldn‚Äôt you be able to do Subreddits.where created_at: 1.year.ago..
Probably, but personally I'd never leave out the parenthesis around a call to `where`, if only because I'm so used to see it as part of a chain.
True.. Anyway this new feature looks so awesome. And yet another great article from Shannon.
I could totes add support for this to Arel. Now to speed up the PR process for Arel :-/
I have the same philosophy. I want my code to fail quickly, not silently, leaving nils which are only caught much later. I wrote this small gem which adds the `dig!` method combining the best of both approaches, IMO: https://github.com/dogweather/digbang
Programming without nils definitely provides a nicer coding experience for me: I get much more meaningful error messages which are located right where the error actually happened.
IMO the article highlights a problem when using Ruby for application programming instead of scripting: The easy thing is not the safe thing. And so there's a list of programming practices to remember when coding Ruby to get more reliability. One tiny example: The API for a hash ("dict") is exactly the opposite of Ruby. In Python, the `[]` function will raise an exception is the key isn't found. There's a non-safe, silently fail option which returns a nil, but it's more work - a method call similar to `fetch`.
Interesting. The freezes are happening on Heroku, and so it's been a little tricky figuring out what's going on. I don't really need 2.5.1 for anything particular. And I haven't seen any big list of e.g. bugs fixed that's motivate switching to it.
FYI, in addition to the `digbang` library I mentioned in another comment, I've also written these two ‚Äî keeping them small ‚Äî to help use real types and no nils: * [validated_object](https://github.com/public-law/validated_object) * [should_be_a](https://gist.github.com/dogweather/5cf6509dcf64199bc175620e350c8998)
Too bad you won't have a similar API for `&lt;`, `&gt;=` and `&lt;=`.
Yep we noticed this as well on our Rails 5.1 app
"formatting ew ew ew" Shutup bro. Quit being an arrogant prick.
uh-oh. &gt; Largely the entire board of Ruby Together has churned a few times since the foundation was created, many of those people in protest of the direction Andr√© was taking the foundation Seems like the board members who quit would have instead been more responsible to insist on a new person in the unpaid executive director role. 
Reddit thread about it https://www.reddit.com/r/ruby/comments/6zvvg4/after_20000_in_ruby_together_donations_over_past/ 
really to tired to check out now but will check out tomorrow started learning ruby 5 days ago loving it
Edabit was literally made for someone like you. I just added Ruby support a few days ago so the resources \(helpful documentation / tutorials\) are lacking but should be quickly populated over the next month or so.
Thanks for adding the support man honestly wish i could check it out now just so tired ill try to give feedback tomorrow. Have a good 420!
&gt; Seems like the board members who quit would have instead been more responsible to insist on a new person in the unpaid executive director role. This probably suggests that the structure of the board is relatively informal, and from the smell of it, they left because the drama wasn't worth it. This org is at the center of so much drama. Anyone worth their salt would pack their bags... we don't need Ruby Together. We already "ruby together", it's called open-source.
I'm very much a novice but I tried my hand and some of the easy challenges and found the website to be very helpful. I've bookmarked it and will come back once I know a little more.
Just tried out a problem. It's a very well put together site. There's not much to complain about, but here's a few ways it could improve: - Allow voting on the challenges and sort them by highest rated. - The profile picture cropper is weird. The crop box could actually go outside the image. This made it difficult to just capture the whole image. - I think my code's indentation was messed up. When I look at it under the solutions tab, the indentation is weird. I'm pretty sure it wasn't like that before submitting.
As a senior dev who makes bunch of pair programming interviews when the company is recruiting, I suggest writing something more complex than single-method challenges. Maybe an API or simple app, like a shopping cart.
That's actually a big problem. They are a 501(c)(6) and that means the board needs to be operated by non-paid officials to avoid conflict of interest. Page 6 (#4) of this document https://www.irs.gov/pub/irs-tege/eotopick03.pdf is a good reference of it. 
I think it's worse, we kind of _do_ need Ruby Together... to function sanely and productively. 
I agree with your sentiment, but disagree with the conclusions. There are many things that are not tenable with only ‚Äúopen source‚Äù. Running infrastructure, and wearing a pager for ops are two examples. While people could volunteer to do those things, such efforts aren‚Äôt really sustainable. That‚Äôs why RailsConf is run by Ruby Central and their profits are used to maintain RubyGems.org infrastructure. The people you think-of when you think of open source are almost all likely sponsored to work on open source one way or another. Either directly as a full time job (Like Heroku hiring Matz) or part time as part of work that aligns with company needs (I get to spend a small part of my work day on Sprockets). Think 20% time. While lots of people make plenty of small contributions in their true ‚Äúspare time‚Äù the bulk of large, maintainable, and sustainable feature work is done via some kind of sponsorship. The idea of RubyTogether (as I interpreted it) was to make it easier for small companies and individuals who cannot hire an Eileen or an Aaron to help contribute to open source financially, in a way that would at least partially align with their values and needs rather than being at the mercy of other‚Äôs direct or indirect sponsorship. The problems it was trying to address and day-to-day realities of open source economics are still here. How to effectively address those issues, is still an open question. 
yeah I also started learning ruby at code academy a coupleof weeks ago but already from the first challenge I have to say your site made me think a lot more, I think the fact that the code syntax is not immediately available to be copied just by glancing on the left (like in code academy) makes a huge difference. Couldn't even finish the first one! that's great! thanks 
Board members of a 501(c)(6) can absolutely be paid. Even 501(c)(3) board members can be directly paid (though there are more drawbacks there). It's extremely common for members of the board of various non-profits to be paid employees of that non-profit. Curious what part of that document specifically makes you think that they would be unable to pay a board member.
We might need *something* to help support important open source efforts in the ruby ecosystem, but we do not need Ruby Together in the slightest.
Thank you. However, I should have mentioned that App Academy is a coding bootcamp that I am trying to attend. It's not an interview for a job. They only require that you know a little bit of programming going in. The problems I linked above are the official problems that they recommend you be able to solve going into the interview.
Very fair comment. I suspect one issue is that to build a "solid gold" non-profit foundation, you need 3-5 people, all of whom need some amount of compensation. Director, owner of Bundler, bundler dev, etc so as to avoid conflicts of interest and check each other's power. Asking Andre to set up all of that at the beginning is asking a lot. Sure, Sam has a great point and so perhaps now is the time to make those changes but I'm not willing to tear the guy down because RT has problems. Like us, he's a developer and setting up a non-profit isn't in any of our wheelhouses. I appreciate what he's built even if it's not perfect. I hope all involved can talk together and reconcile.
Here's what a third party organization has to say about governance. https://www.councilofnonprofits.org/tools-resources/can-board-members-be-paid It's the bylaws that dictate the conflict of interest, not the IRS, so its a best practice issue, not a regulatory compliance.
I understand op's point of view, but I agree with you. I don't know why are Classes considered somewhat an advanced concept, when in reality it should be one of the first lessons.
This is the point I agree with. Ruby Together has such a history of BS around it. As I said last time there was a critique of them, the gross thing is they go around pan handling with guilt and sometimes false claims about their own importance. They seem to lack integrity and why people give them money is a mystery to me. I actually like the idea of the organization, like this blogger says too, but everything about the damn thing is just gross. It's like a caricature of the not-for-profit, but definitely for profit type group.
&gt; Seems like the board members who quit would have instead been more responsible to insist on a new person in the unpaid executive director role. You're certainly welcome to join the board and steer them in the right direction. Then maybe you'll stop armchair quarterbacking (*) and realize how entrenched this problem really is. *) I'm referring to both this post and the last time this came up.
Hi I scheduled for 11 am assuming its PST
Thanks for sharing, these are fun :) Just a nitpick, but I feel like you should tell users about implicit return in the first exercise, it makes it seem like they have to use the return keyword.
I've not come across that myself. Could it be something to do with the order of pre-action filters: https://stackoverflow.com/a/39954005/28376
In an article about errors, we're going to talk about errors. That doesn't mean there aren't thousands of applications out there successfully using Ruby. You make a good point though, we should re-evaluate the ways we use the languages we use often. The `[]` function in Ruby does allow us to make more mistakes than `fetch` and it would likely improve most applications. Have you written up anything on this difference between the languages? I'd love to share it :)
I have a blog outline for it. :-) I‚Äôll write it up and send you a link. 
Thanks! I‚Äôve got an article outlined - I‚Äôll write it up and send you a link 
why would there be any reason to think wycats would be more likely to commit malicious code than any present committers? But I agree this isn't that much of a big deal. (Removing authors from listing in the .gemspec seems skethchier, but still not obviously _that_ much of a big deal. But removing wycats from listing in the gemspec definitely rubs me the wrong way, bundler wouldn't exist without his vision and expertise, why take away his credit? Unless he asked for it or something, what was the motivation to do this unusual thing?). 
I don't think it's a matter of wycats committing malicious code himself. But what if someone managed to hack his GitHub credentials and push code to Bundler surreptitiously that is malicious? Inactive committers sometimes go dark altogether. If they're unreachable but start contributing again, maybe it's not actually them, but you're relying on GitHub to determine who is who and that may not be entirely reliable. GitHub verifies signed pushes based on a public GPG key that the user uploads to GitHub. If someone gets into an account, uploads a new GPG key, and starts pushing signed commits, how often are people actually going to go through the trouble of verifying it? It's GPG after all
Allowing gem push to rubygems.org is a separate concern than the "authors" array in the Gemspec. You add or remove Rubygems.org via the `gem owner` command http://guides.rubygems.org/command-reference/#gem-owner. AFAIK the authors array is only to give attribution and doesn't do anything functional. It's highly unusual to remove prior authors in a gemspec. I maintain some libraries such as Sprockets. I've not added myself to the author section https://github.com/rails/sprockets/blob/master/sprockets.gemspec#L38, but I have push access to rubygems.org/gems/sprockets. 
Possibly a reasonable argument for commit bit. Removing the credit from the .gemspec authors, though?
with all due respect, choosing not to add to add yourself is way different than choosing to remove others.
&gt; (As an analogy, when your "product manager" and your "technical lead" are the same person, it's not a good situation -- for reasons that aren't even about financial interest in most cases, but just the importance of having both perspectives involved). Off topic, but please elaborate. This analogy seems less clear to me than the conflict of interest with Bundler at hand (which is fairly obvious).
apart from being slower, web scraping is against the terms of service of many sites. i wouldn‚Äôt start building anything serious using it. 
There is a proper note on the gem page
For your first point, I think he's talking mainly about Andre. Andre is a leader at Bundler and if he was supporting the changes that broke those builds then perhaps he's not someone we want leading another crucial ruby organization. That was the point I got from that particular example, and perhaps this is just his attempt at showing some patterns of behavior he's noticed.
Sam makes it seem like it was something nefarious. Here's the change he is talking about: [https://github.com/bundler/bundler/pull/5878](https://github.com/bundler/bundler/pull/5878) As you can see, Andre didn't write the code. He did merge the PR. Was Samuel Giddins paid by RT to write that code? I don't know. But it's really hard for me to see the leap from "merged a PR that broke some things" to "Activities from Bundler leadership, paid by Ruby Together". Should Andre and the Bundler team have been more careful? Should they have had a better test setup? Sure, maybe. But nothing indicates this was a purposefully hostile change. Maybe there's more to it \- maybe Bundler has broken lots of things and isn't being a good Ruby citizen. But that isn't supported by linking to one mistake.
I'm certain Schneems was just making the point that the authorship array had nothing to do with security, if anything to point out that it does in fact appear a little dubious.
Another thing is: Rails give you options regarding how to store a session - in a cookie itself, or with some back end like redis or relational db. CookieStore is rather controversial as you can not manage your sessions anymore - if a cookie gets leaked you can't just simply flush this session so your only option is to wait until this cookie gets expired. An option when the only content of a cookie is session id is considered slow since you have to query your back end store with every request just to retrieve session. The approach described in the article is some kind of combined one: you have a back end store which only gets queried once the payload of the token is checked and all claims are verified. 
Correct answer: there is no difference at all. JWT is just a way of how you encrypt cookie.
Correct answer: there is no difference at all. JWT is just a way of how you encrypt cookie.
So far it sounds like you have some models and data, but nothing to act as the main "driver" of the show. In rails, consider that you use a "controller" to direct traffic: it's job is to interpret what must be done, and the models in play. In a command line app, you need the same thing. Create a new file called `cli.rb` (for command line interface) or `main.rb` and use that to direct the flow of interacting with these models. This file will be the main entry point into your application, and is in charge of understanding how to glue everything else together, so that your individual classes can specialize in their niche without needing to know much else about each other.
&gt; Using JWT for sessions will require developers to implement a custom authorization system on both server and client sides. To me that‚Äôs all the reason I need not to use or trust JWT for sessions Developers are notoriously bad at custom security 
Here's an example involving a security release https://www.schneems.com/2017/09/13/how-august-2017-rubygems-vulnerabilities-were-patched-on-heroku/#timeline 
Divide your code into defined methods. You can use classes but you don't have to. So, for example: def rate_hash {:t_mobile =&gt; x, :verizon =&gt; y, ...} end def get_rate(service_name) rate_hash[service_name.to_sym] end Or something like that. If you prefer classes, you could do it this way: class RateHash @@the_hash = {:t_mobile =&gt; x, :verizon =&gt; y, ...} def get_rate(service_name) @@the_hash[service_name.to_sym] end end Then later in your code, just call (if you use methods): get_rate('t_mobile') or for classes call RateHash.get_rate('t_mobile') However, classes are very inefficient. They have a lot of overhead, so they consume memory and are slower than plain methods outside of classes. In a simple app, you probably won't notice the difference though. To get user input, you can use the ARGV array. If your main file is main.rb, and you run ruby main.rb 'thing_one' 'thing_two' then inside your program ARGV[0] is a string = 'thing_one' and ARGV[1] = 'thing_two' I hope that helps. 
Awesome, please do!
Having recently lived through this at work (custom authorizations via JWTs), I whole-heartedly agree with the sentiment.
Honestly if a committee got together and came up with a portable, bureaucracy approved future for Rails session cookies, they would invent JWT.
When you already have a well-written, well-designed, robust, secure, standardised, reliable and widely used and recognised mechanism, one thing is certain: the JS community will roll their own incompatible and malfunctioning replacement. 
Don't forget the vagaries of different JWT implementations and the standard itself, making these packages incompatible with one another. I'm afraid it will be politics, rather than a solid set of base standards, that will determine which JWT packages are most suitable for adoption.
On serious leaks you can flush all cookies. On minor leaks you can limit or reset one session. Your implementation should always have ties to your backend in some way, either on session or user level. Also your argument of storing the session id in the cookie being considered slow is basically bs. Who considers it slow? Since when are indexed lookups on unique values from a database slow? Or even worse , a key value store? And with tokens in your cookies you will have to look up the token anyway to validate it, dont you. Just .... facepalm.
Great way of misinterpreting the words. Any backed session is relatively slower than CookieStore. &gt; This cookie-based session store is the Rails default. It is dramatically faster than the alternatives. (api.rubyonrails.org) What JWT gives you in comparison with plain session id is claims. The lookup to identify if the token is present aka session is not flushed should be performed after the token itself is checked.
What does token/cookie expiration have to do with hijacking detection? No one said that cookies do not support expiration.
This is the most accurate comment I‚Äôve ever seen on reddit
Did you look at what's current in master and has been for over a year at least? Because that was a removal that was reverted quite a while ago
fair enough, cool. 
&gt; Rails gives you options regarding how to store a session - in a cookie itself, or with some back end like redis or relational db. Literally no one stores the actual session in the cookie, you store the session id in the cookie. &gt; An option when the only content of a cookie is session id is considered slow since you have to query your back end store with every request just to retrieve session. A single DB query or cache hit to grab session data has basically no impact on performance. Like so little that you would not be able to measure the difference reliably (ie: standard variation of request time is far bigger than a single db request).
Tell Don't Ask is a _principle_. Not a pattern.
Agreed. This is actually a refactoring using the strategy of extracting a type implied via switch statements into duck-typed classes. 
It‚Äôs an unfortunate, non-idiomatic way of writing Ruby. The gist of it, is that it‚Äôs gonna loop until you reach the end node. A sane approach would be to have the while before the return: while (node.next) do node = node.next end return node Btw, this implementation falls flat on its face when doing find-tail with head=nil
That code isn't written very clearly: while (node = node.next) do return if !node.next end
Translating this from postfix form to nested form will probably help. To do so, we proceed from the outermost inwards: return node if !node.next while (node = node.next) becomes while (node = node.next) do return node if !node.next end which can be further transformed into while (node = node.next) do if !node.next return node end end So it iterates through the list, as you said. When there is not a next node, it returns it, as you said. But what should be more obvious now is that when there is a next node, it simply does nothing, because the if test is false, and there is no else. 
&gt; `while (node = node.next)` is true whilst there is a next node Not quite right‚Äîit's not doing a double-equals (`==`) equality comparison, it's just doing reassignment (`=`) for the next iteration. Take the full context: def find_tail node = @head return node if !node.next return node if !node.next while (node = node.next) end It's traversing the list by returning the node it has (`return node`) if it has no next (`if !node.next`). Otherwise, it performs the same check on the current node's next (`while (node = node.next)`). It's a little ugly because ruby has no `do...while` construct (where you always evaluate the code once before performing the check; the trailing format feels like it but isnt'), so instead you have to `do` it once yourself then `while` it. However I believe this code is synonymous to the simpler form: def find_tail node = @head node = node.next until node.next.nil? node end
Attribute.
Atter
If I call a gem `something_attr`, do you think that will be confusing? What if there's already another gem called `something_attribute` or `something_attributes`? My motivation to use `attr` instead of `attribute(s)` is both because it's a lot shorter to type (presumaby why `attr_accessor` wasn't originally `attribute_accessor`), and because other(s) have already taken the names with "attribute" spelled out. :)
If there's another gem already called `something_attribute` I would not call mine `something_attr` - that seems disrespectful.
If there's already a gem named `something_attribute` then `something_attr` is confusing in my book since `attr` == `attribute` when I talk about it.
Attribute
two things: * I query my database for almost every session-bearing request anyway to fetch the account &amp; profile and to render navigation correctly. * You actually can flush sessions with cookie-based session storage. Keep a generation number in the account record, include it in the session, and verify currency each time. Then you can literally invalidate every current session *for that account* by incrementing the generation number. This gives you a cheap "logout everywhere" mechanism.
If you have to verify the cookie against your backend witch each request then you simply ignore all advantages of CookieStore.
So now I have to fetch the account with each request, yet who's telling that I actually need it?
The damn cookie. Christ, I just realised from your other responses that we're arguing with an idiot. Where's that block button gone? 
fantastic talk. good reminder to move beyond refactoring and make this a real people-to-people tool. not quite sold on how to do event-storming, but that means i should read more about it next. that said, it does seem like lots of people approaching this in different ways. this talk gave marco's mish-mash of favored techniques. i'd love to hear other strategies and combinations of communication and modeling tools.
That's really cool.
"When you fail to abstract data into representational objects, then you get stuck with implementing the methods for the abstraction at every interaction of that object rather than just once with creating an object as the abstraction" is it just me or is there something self-contradictory in this? "When you fail to abstract data into representational objects, then you get stuck with implementing the methods for the abstraction at every interaction of that object " -- what object, the one you just didnt implement? 
You say attribute very differently than I do.
Hello, building (static) website, books, presentations, radio shows, and more with ruby? Let's make jekyll 4.0 better, faster, ....! Yes, you can! To quote Olivia Hugger (@dog_awoo), the Jekyll Open Source Project Lead writes: ¬ªNow is a great time to finally take on the feature you‚Äôve wanted to see in Jekyll for ages! Just open an issue or experiment with the code to get going!¬´ Source: [Jekyll 4.0 is on the Horizon!](https://jekyllrb.com/news/2018/04/19/development-update/) Happy Jekylling. Cheers. Prost.
anyone wanna PR it to ruby_prof as a convenience api? :)
Props to the Jekyll team for dropping support for EOL versions of Ruby. As a community, we spend way too much effort keeping everything compatible with old versions of Ruby, and it's a big drag on progress.
Much more basic and lower-level than the examples you're looking for, but Piotr's tty toolkit is pretty neat. https://piotrmurach.github.io/tty/ But it's not gonna do what you want, I think. I think maybe there just aren't a lot of people doing complicated curses-based UIs these days? At least in ruby?
Don't think so, but with a bit of toying around it is a very rewarding experience to learn curses and using the ruby bindings for curses. It has rough edges, some things do not make a lot of sense, but it is a fun project.
Bugs happen, even security bugs happen, but releasing a patch without a CVE is not professional security/release management. 
That makes sense. Be aware there's a variety of acceptable URLs. See the `GIT URLS` section of `git help fetch`. I actually [just wrote some code](https://github.com/sshaw/git-link/blob/63dc5f485f6bba105065d875d0007e212301d283/git-link.el#L256-L277) to deal with this. It's in elisp though üòÅ.
There's [a JavaScript library](https://www.npmjs.com/package/git-url-parse) that does this. May be be easier to follow what they do...
&gt; But what if you need to distinguish between nil and no value being provided? Don't, what do you think `nil` means? If you're using `nil` for something other than 'not there', that is your problem.
Rust, Ruby; pretty close, right? ^^^/s
I just used it for a `default` param, where I wanted to disinguish between directing that `nil` should be the default, and the caller not making any default direction. Which might a difference in the context. I think that was appropriate. Never say never. `nil` is a value already existing and used by other ruby code you are interacting with. You're not adding some kind of global `NOT_THERE` constant, it is just a unique value particular to the method used to indicate no arg was passed. There are various kinds of 'not there'. I could imagine a query API of some kind, where searching for "records where column X is `null` in the store" is a very different thing than "I didn't tell you anything about what I wanted column X to be". Sure, you could use a special constant or object to represent the store "null" value -- hey, you've got more than one value indicating different kinds of 'not there' again. 
In all the cases you mentioned, just check for the existence of the hash key.
We're talking method arguments. You can do that if you use old-style `def foo(options = {})` instead of keyword arguments. I don't think the old-style is ever more clear than keyword arguments. Or even-newer-style double-splat for that matter, which would also give you a hash to check the keys of. I don't think there's anything unclear at all about a NOT_PROVIDED constant. 
&gt; I could imagine a query API of some kind, where searching for "records where column X is null in the store" How do expect to be able to define that with keyword args? Are you going to meta-program you're where method for every class based on boot time table inspection? How do you handle join constraints? etc. &gt; We're talking method arguments. You can do that if you use old-style def foo(options = {}) instead of keyword arguments. Keyword arguments don't replace all usage of passing options hashes. &gt; I don't think there's anything unclear at all about a NOT_PROVIDED constant. More code, more constants, more names (which are likely badly named). I'd much rather read `if options.key? :default` than `if two == NOT_PROVIDED`. One reads well and is clear about what it's doing, the other is not.
I would much rather see the accepted keywords in the param definition. shrug. 
Breaking this one up as it can get really really dense if I go much over 6 minutes an article. 1. Scopes - get / set a known path in a hash 2. Traces - get / set any matching path anywhere in a hash 3. Evolve - Specify a series of transformations to apply to a hash http://ramdajs.com/docs/#evolve Anyways, back to borrowing things I found that are fun in Haskell and Rambda!
How would you implement assert\_changes? I agree the distinction is not needed in 99&amp;#37; of cases. I presented the pattern and you choose where to use and where not.
Can we use it over https://github.com/joshbuddy/jsonpath?
&gt; Adding a NOT_THERE constant doesn't fix the underlying issue. Yes it does. When `nil` is a _valid argument_, which is different from no argument being provided, it does fix the problem.
/u/MeckiSpaghetti do you mean like when your end users double click on your jar and it starts running some command?
Hey! Yeah, it seems like I worded my question poorly, sorry for that. Let me try again: When double clicking the created .jar in a desktop environment, the behaviour by default is similar to running this on the command line: jruby -S my_program.rb This is what I would like to change now. I'd like to specify different command line arguments to let jruby run my script when double clicking the jar. For example: jruby --dev -J-splash:media/image.png
A lot of old debunked arguments in here, along with a nice dose of clickbait-y hyperbole.
https://media.giphy.com/media/3o7aTskHEUdgCQAXde/giphy.gif
Thanks, all. I'm thinking that on the whole, it'll be simpler to just have the caller provide the names of the repository user and project.
Find out about the Jekyll team here &lt;https://jekyllrb.com/team/&gt;. My humble self (Gerald Bauer) - I'm not part of the Jekyll team. I "run" the [awesome jekyll channel](https://twitter.com/awesomejekyll), help with "unofficial" starter themes, snippets, etc. and try what I can do to contribute. PS: Sent in / posted two ideas for jekyll 4.0 too :-).
i don't know much about it but this sounds like something that belongs to the manifest file.
Without keyword args. Keywords args are useful when the method requires a specific hash key to be present in it's args. The situation at hand is that the hash does not require the hash key to be present so it makes sense to capture it in a hash param and ask if it was provided (Hash#key?). In other words instead of inventing a special value that means the arg was not provided, we simply check if the arg was provided. One less level of indirection and our code mimics exactly what the real logic is.
You know about optional keyword args, right? Which is what the whole OP is about, right? How does this square with your belief that the whole point of keyword arguments is... not optional keyword arguments? When ruby provides for optional keyword arguments with default values? Do you consider them an abomination which should never have been added to ruby? We're just gonna have to disagree here I think. I find your beliefs oddly religious and nonsensical. But to each their own! 
&gt; You know about optional keyword args, right? Which is what the whole OP is about, right? How does this square with your belief that the whole point of keyword arguments is... not optional keyword arguments? When ruby provides for optional keyword arguments with default values? Do you consider them an abomination which should never have been added to ruby? You're confusing optionality of the caller vs the callee. A required keyword arg is required by both. A keyword arg with a default, which I guess is what you mean by 'optional' keyword args, is required by the callee but not required for the caller. Which is _not_ what the OP is about. The OP is about an argument that is optional to both the caller and the callee. Keyword args does not have syntax that defines this situation, and it doesn't need to, since this is what hash params allow. This can be modeled pretty easily though: `def my_thing(required_one: 1, required_two: 2, **optional_params)`. Now you can be explicit about checking if a param was provided by checking for the key in `optional_params` without weird constant hacks. 
I consider `**optional_params` a weird hack. shrug. 
Possibly. Trace responds to :=== so it's definitely possible to emulate a lot of it. I'd have to play with that though to really know. The difference is that XF is just plain Ruby, you don't need to know another path language to use it.
&gt; I understand you have your own views on how ruby should be used that differ from most of the rest of the ruby community, that's cool. I'm not sure what it you are referring to here, double splatting optional keyword params? It's not some obscure hacky concept, it's a common pattern. You'll see it in many projects, search the rails source code for example.
Hey, interesting experiment on Ruby edges! Just wanted to point out: https://github.com/baweaver/xf repo is currently detected as "HTML" (as a primary language) on GitHub, it may stay in the way of its discoverability.
Yep, just nuked the coverage artifact in there, and fixed!
This was very helpful and exactly what I was in need of, thank you 
neat!
I appreciate your invaluable feedback ! Thanks a lot ! :-)
Among others, in believing that `**options` (and then more lines of code to doc accepted options and/or raise on unrecognized ones) is somehow more clear or legible than a simple `arg: NOT_FOUND` arg definition.
&gt; Among others, in believing that **options (and then more lines of code to doc accepted options and/or raise on unrecognized ones) is somehow more clear or legible than a simple arg: NOT_PROVIDED arg definition. It's fine that we disagree on that, but I don't understand why it is you presume to speak for ruby community or how you have come to the conclusion that the wider ruby community is on your side here. Certainly in my experience double splatting optional args is more common than `NOT_PROVIDED` constants. &gt; Rails also uses a NO_DEFAULT_PROVIDED constant. Indeed, the pattern is used in several other places in rails as well. My point wasn't that the sentinel pattern doesn't exist or isn't used. 
ha, and mine isn't that `**options` doesn't exist or isn't used! Anyway, clearly neither of us wants to let the other get the last word, but we have nothing else to say to each other. 
Dis you try it? :)
Pretty cool gem dude. My only comment would be that I feel like it would be more developer friendly to support a different syntax for your third example, so it could be easier to read when chained. Maybe: ``` my_user.posts.where_assoc_count(5, :&lt;=, :comments).old.by_admin ``` I'd think you'd only have to return the relation at the end of your #where_assoc_count method. Whaddaya think?
I wanted a simple configuration solution that wasn't integrated into rails, and was completely invisible to my objects. 
Capistrano still works. One ideal to work toward is shipping a complete system (e.g. EC2 AMI or Docker image). Docker isn‚Äôt difficult to pick up, but it isn‚Äôt brain dead simple. If you have the time, learn Docker. If you are under a time constraint, keep it simple and use Capistrano. 
Check out https://www.hatchbox.io - dead simple setup and deployments
That can't work. The `old` and `by_admin` are scopes on the `Comment` model, while we are querying on `Post`. Every `where_assoc_*` returns a relation on the same model as a `where` would, so in that case, on `Post`. For that suggested syntax to work, i would have to return a custom object which tries to guess if the methods called on it are for the `Comment` or the `Post`, and there would be problems. 
Okay, I really do need to learn that for updates. What about the initial deploy? What do I have to do and set up on my own before I can use Capistrano?
I've already written a very detailed reply in regards to this, but would greatly appreciate others feedback on this, including syntax suggestions and support. Of course, dissent is welcome as well, I would prefer such an idea to be implemented as cleanly and effectively as possible - baweaver
I'll write another reply to define the categories of matching and how each would look potentially. Good point to specify. I would like it to work on all of them
You don‚Äôt fetch the account. At scale you need only distribute the dataset of generation numbers to all front-end servers. It changes slowly, works well as an eventually consistent dataset/CRDT, and scales all the way to having billions of accounts represented in just a few GB. 
Seek out tutorials on running Rails in production. Once you have that you should be able to drop in Capistrano to update the source code, install gems, and restart your application servers. 
Great job. Thanks for sharing it. I will definitely use it. p.s. I've added it to "Awesome Ruby", too https://ruby.libhunt.com/
sweetsauce! did you consider a PR into rails?
Thanks for sharing Hatchbox! :D I'm always around if you guys have any questions on it!
This sounds like an interesting project that would be right up my ally. I am still very new to GitHub and am still learning the basics, but my primary focus revolves around improving my technical writing skills. I‚Äôd be happy to volunteer for writing use cases and any other relevant documentation.
You might provide `with` and `without` aliases like `Post.with(:comments)` and `Post.without(:comments).where(is_spam: true)` That said, I'm saying that but wondering if this isn't just a new layer of magic to continue confusing all of us...
1. What problem is this solving? 2. Why is it so important that it should be a ruby core feature? 3. Does the syntax benefit from this level of terseness, given that it looks more like perl than ruby? I'm very concerned about how hard this is to read for such a narrow use case. It does not seem to lend itself to well-encapsulated objects.
Yep! That'll be coming this summer. Since I can't guarantee every app uses puma, it was easier to launch with Passenger instead which will work for everything.
If you stay in Ruby long enough you'll work on two different projects with two different versions of Ruby. Via the Gemfile you can also "lock" to a specific version of Ruby, so if you're on a team and you have two projects, even if they both work fine under Ruby 2.5.0 and 2.5.1, you'll need to use that __exact__ version for the project to run. It's one more way of ensuring consistency. I think the other reason generally is security. When you run `gem install` or `bundle install` there are post install hooks that can execute arbitrary Ruby code. I've never heard of a malicious one in the wild (other than proof of concepts). Chances are if there was one it would hopefully be found out sooner than later. If you find that you have to `sudo gem install` then I think the code in the post install hook would run with sudo permissions which would be even more dangerous. In general if you have to run `sudo` when you're working on a Ruby project, you're maybe not headed in the right direction.
I answered in response to your other question, though honestly if you're just playing around and only have one project or want to write some scripts it's fine to use system Ruby. I interact with my ruby version switcher several times a day, every day. If you're planning on writing anything serious, or maintaining anything for a length of time, I would recommend some kind of a version switcher.
Interesting. Is backwards compatibility that big of an issue in Ruby? I've never ever had to switch to a non-current version of Node for anything
The only thing I'll add to the other reply is that it is true that today you are writing code against the newest Ruby. But in the future, it will not be, and there could be compatibility issues that you've acquired over time. Just like with library dependencies (gems, npm, etc), it's about pinning specific versions so you can have consistency and upgrade when you decide it's appropriate. It really sucks to find out that something isn't supported in the same way, like a DB driver, and not having an easy way to back out. Using a version manager feels very comfortable and non-invasive. It's very much the same as using `npm`, `yarn`, or `gem` but at the language level. It's not required, but it won't take much to learn and will reward you handsomly in approximately 6-12 months.
#### 1 - What problem is this solving? Succinctness of code and expressive power. The recent destructuring changes, and now pattern matching features of Javascript have unlocked some very concise ways of expressing otherwise verbose invocations. The ability to say more with less is the holy grail of programming languages, so features that allow us to move towards such a reality should be earnestly considered and pursued. #### 2 - Why core? This is not a new language feature. It's been done in several others: * Javascript - https://github.com/tc39/proposal-pattern-matching and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment * Elixir - https://elixir-lang.org/getting-started/pattern-matching.html * Haskell - https://www.haskell.org/tutorial/patterns.html * Scala - https://docs.scala-lang.org/tour/pattern-matching.html * OCaml - https://ocaml.org/learn/tutorials/data_types_and_matching.html#Pattern-matching-on-datatypes Ruby as a language grows from ideas learned in other languages. It's tagged as being based on Smalltalk, Perl, and Lisp so it's far from unusual to see it get features other languages consider commonplace. The main reason, however, is bringing it to more vanilla level speeds. My implementation is on average 3-4x slower than plain Ruby, and considering patterns tend to be used frequently in tight loops that's a bit much. Many of the improvements around this will also likely unlock faster avenues of functional style code. #### 3 - Terseness That's one proposal for it, there are several more. If you dislike one there are others which may implement it in a more pleasing manner. See any of the items in #2, there are many ways to do this. Done well, pattern matching is incredibly expressive. That's why I posted a link to the ticket here, to ask the community what their thoughts on this are. You'll have to expand on what you mean by well-encapsulated objects. It's actually very possible via arity and `to_proc` to treat a class as a destructuring itself, especially when combined with `to_ary` for implicit destructuring. This would be very similar in theory to Scala Case Classes, but may be more difficult given Ruby's dynamic nature. As far as narrow use cases, I would say that argument does not make much sense to me. Pattern matching is used very frequently in languages it exists in. Destructuring is already super common in Javascript, and I would bet on pattern matching being even more so when it gets into Stage 3 and final acceptance.
It's usually because one project is using newer features that don't exist in prior Rubies. You won't see that between 2.5.0 and 2.5.1 but you will between 2.4.4 and 2.5.1. Also Ruby doesn't totally follow semver. There are major features added on the minor version (i.e. the 2.x) version. Sometimes there are changes or deprecations. For example prior to Ruby 2.4 an integer is a Fixnum class. When it got really really large it would turn into a Bignum class. In Ruby 2.4 this behavior was removed and they're all just an Integer class now regardless of size. The change was done in a mostly backwards compatible way, but it's possible you wrote code that was explicitly relying on that behavior and then your code's broken. Changes to the "patch" level are generally backwards compatible i.e. 2.5.0 and 2.5.1. Though you'll likely want to run on the latest in the series as new versions come out for security releases. 
Try running `gem env`. It will give you all the configuration on your system. When you `gem install` you should typically only be seeing results from `rubygems.og` and not from `gems.rubyforge.org` or `gemcutter.org` (wow, that one is really old) Here's my `gem env` output: $ gem env RubyGems Environment: - RUBYGEMS VERSION: 2.7.6 - RUBY VERSION: 2.5.1 (2018-03-29 patchlevel 57) [x86_64-darwin17] - INSTALLATION DIRECTORY: /Users/rschneeman/.gem/ruby/2.5.1 - USER INSTALLATION DIRECTORY: /Users/rschneeman/.gem/ruby/2.5.0 - RUBY EXECUTABLE: /Users/rschneeman/.rubies/ruby-2.5.1/bin/ruby - EXECUTABLE DIRECTORY: /Users/rschneeman/.gem/ruby/2.5.1/bin - SPEC CACHE DIRECTORY: /Users/rschneeman/.gem/specs - SYSTEM CONFIGURATION DIRECTORY: /Users/rschneeman/.rubies/ruby-2.5.1/etc - RUBYGEMS PLATFORMS: - ruby - x86_64-darwin-17 - GEM PATHS: - /Users/rschneeman/.gem/ruby/2.5.1 - /Users/rschneeman/.rubies/ruby-2.5.1/lib/ruby/gems/2.5.0 - GEM CONFIGURATION: - :update_sources =&gt; true - :verbose =&gt; true - :backtrace =&gt; false - :bulk_threshold =&gt; 1000 - REMOTE SOURCES: - https://rubygems.org/ 
Yeah, pattern matching on method signatures would be amazing but it'd probably be difficult to do without somehow routing back to that type of dispatcher. Take it from me, splat methods are slow, so the more we can avoid them the better. You should suggest your idea on the issue! The more the merrier, just make sure to show as many use cases and examples as you can.
Thank you for your input
if everything is working for you, and you don't want to deal with a ruby version manager, then just keep doing what you're doing, we've got no reason to try to convince you. You'll realize when you need it, or you won't. 
This one deals far more with how to use recursion to descend into hashes, some practical uses for yield, and how it really doesn't take a lot of code to do some really fun things. Enjoy!
Thank you for the detailed response. I took a look at the scala and js examples. This issue is new to me so bear with me if I am misunderstanding it. Based on the examples, the chief advantage seems to be improving the expressive power of case statements and similar structures. In all of the examples the caller is analyzing the internals of the passed objects using the match/pattern functionality, and then performing an action on their behalf. This violates the dependency inversion principle, SRP, and generally speaks to objects that know too much about each other. If the goal of this functionality is to make that kind of thing easier to perform, I would expect its effect to be detrimental. I would not expect to approve code that uses the new functionality in the way outlined by the proposals' examples. 
By that same note though, any dispatching action violates the rules. Most of the use of right hand pattern matching pertains to previously unstructured data that you would want to dispatch to depending on content or rather patterns. The problem with taking a rigorous view of OO and GoF rules in Ruby is that it's a language with functional leanings. Some patterns really don't entirely make sense, and really is conflating knowledge of imperative programming with how you view functionally oriented code. One of the more common examples of pattern matching in Elixir involves http response codes. Typically you'd use an if or a case on that. What if you could destructure the response on the spot and dispatch to the relevant handler method in one line? The other common cases are extracting data from container style classes (functors) like Maybe, Some, None, and other ideas from FP. Read into Railway oriented programming some time, it's on an F# blog. It's honestly an entirely different paradigm of thinking about how data flows through an application that's fundamentally different from pure OO and GoF style patterns. Thinking of it in such a manner will only confuse you further. You might consider going through some basic Haskell, Elixir, or Scala tutorials. Keep in mind that despite being fundamentally different in thinking, they're not incompatible philosophies of code. 
This is very cool and I'm already investigating adding it to my blog.
Sweet! Feel free to ping me if you have any issues.
Its a very pleasant language to work with. You'll see that when you get into it ;) So probably you'll start to code more and more ruby and then you will need a version manager. I'm happy with rbenv, but nowadays it seems people seem to prefer chruby.
so you need to store a cutt-off copy of your accounts table in memory or in a key-value storage and to keep it in sync with the actual db. Well, sounds much worse than standard sessions table management.
The issue title says "Proper pattern matching" and there's one thing I don't quite understand. One of the main traits of a "proper" pattern matching is exhaustiveness. We need to match *all* possible patterns to *some* value. Given dynamic nature of Ruby, how is this going to work out? 
That was my initial idea. However, there was an attempt by someone else here: https://github.com/rails/rails/pull/21438 It was probably not as complete as my gem. We'll see if they changed their mind since 2015. If lots of people start using it, it could be more convincing for them, however, they might not agree with some of the design decisions (such as making things more complex to handle has_one properly).
Most Rails developers quickly learn that minimizing the number of database queries by properly specifying eager loads is critical for good application performance. Unfortunately specifying eager loads is error prone and can cause encapsulation problems. You can have your cake and eat it too with goldiloader ;) https://github.com/salsify/goldiloader
It isn‚Äôt. 
Tis the least I could do considering I now have all this free time NOT setting up production environments! :)
Thanks, Whispres. I'd be interested in your views about what should be next in markdown_helper: https://github.com/BurdetteLamar/markdown_helper#what-should-be-next.
Why not just make a concern "Commentable" and implement "with_comments", "without_comments", and "less_than_five_comments_by_admin". I think this is dangerous as it makes it even easier for the logic of the model to escape it's scope. It's very common to see scopes and complex conditions which belong to models, live in controllers, which should be avoided.
&gt; So how would I know when I have to interact with it? Usually only if you're using a larger project. Generally a Rails app will have an explicit version defined in the Gemfile. &gt; Like right now I just have a toy program that‚Äôs outputting a bunch of text but I‚Äôm using the gem rainbow for styling. How do I know if I need to use chruby? It seems to be working I don't think you need to right now. &gt; Also why do you recommend chruby over another version manager? It seems everyone here likes it :) There's a really long history here. First RVM came, it was entirely written in bash (still is). It has a feature where when you change directories `cd` into a Ruby project that it automatically uses the version of Ruby that is in that project. In order to do that it had to overwrite `cd` between that and the fact that most people couldn't read or contribute to it (not bash experts) it fell somewhat out of favor, though I still think it's good. It's the biggest cannon in the arsenal. Then came rbenv and chruby. Rbenv was created as a "lightweight" alternative with none of the RVM 'magic'. I've used it for a long time and got stuck with some bugs that cost me a lot of time, so i'm not a huge fan currently. Chruby is the lightest possible implementation. It doesn't really do much of anything other than point at different ruby folders. That's it. I like it because it's pretty bomb proof and it does what it claims to do. Honestly though at this point all three are pretty well battle tested and good. It's mostly a matter of preference. &gt; Unrelated to my original post, but if you don‚Äôt mind me asking why do you write Ruby? What draws you to it over other languages? It was the first programming language I can truly say that I learned (besides basic and maybe "matlab"). It's really good at web apps (Rails, sinatra, etc.) and shell scripting. I've been using it for the last 10+ years and I still really like it. To me no other language maps to my brain quite like Ruby. 
The examples show how the methods can be called, and give one example of each method. This is just a basic tool to do something correctly. Where the developpers decides to use them is not something the gem can or should control.
Thanks for the comments. I forgot to include the output of gem env, which of course showed all the old gem sources. I've changed it to https://rubygems.org, but now it's simply not working: $ gem install google-api-client -v '~&gt; 0.8' -V ERROR: Could not find a valid gem 'google-api-client' (~&gt; 0.8), here is why: Unable to download data from https://rubygems.org - timed out (https://api.rubygems.org/specs.4.8.gz) It's bizarre, because: $ curl -O https://api.rubygems.org/specs.4.8.gz % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 3470k 100 3470k 0 0 3470k 0 0:00:01 0:00:01 --:--:-- 2796k Clearly it can pull the specs. At this point, I think it's some hokey crap with rvm, but I'm not sure. At least I feel like I'm going down the correct path. $ gem env RubyGems Environment: - RUBYGEMS VERSION: 2.6.14 - RUBY VERSION: 2.4.1 (2017-03-22 patchlevel 111) [x86_64-darwin14] - INSTALLATION DIRECTORY: /Users/mdchaney/.rvm/gems/ruby-2.4.1 - USER INSTALLATION DIRECTORY: /Users/mdchaney/.gem/ruby/2.4.0 - RUBY EXECUTABLE: /Users/mdchaney/.rvm/rubies/ruby-2.4.1/bin/ruby - EXECUTABLE DIRECTORY: /Users/mdchaney/.rvm/gems/ruby-2.4.1/bin - SPEC CACHE DIRECTORY: /Users/mdchaney/.gem/specs - SYSTEM CONFIGURATION DIRECTORY: /Users/mdchaney/.rvm/rubies/ruby-2.4.1/etc - RUBYGEMS PLATFORMS: - ruby - x86_64-darwin-14 - GEM PATHS: - /Users/mdchaney/.rvm/gems/ruby-2.4.1 - /Users/mdchaney/.rvm/gems/ruby-2.4.1@global - GEM CONFIGURATION: - :update_sources =&gt; true - :verbose =&gt; true - :backtrace =&gt; false - :bulk_threshold =&gt; 1000 - :sources =&gt; ["https://rubygems.org"] - "benchmark" =&gt; false - REMOTE SOURCES: - https://rubygems.org - SHELL PATH: - /Users/mdchaney/.rvm/gems/ruby-2.4.1/bin - /Users/mdchaney/.rvm/gems/ruby-2.4.1@global/bin - /Users/mdchaney/.rvm/rubies/ruby-2.4.1/bin - /Users/mdchaney/.rvm/bin - /opt/local/lib/postgresql94/bin - /opt/local/bin - /opt/local/sbin - /Users/mdchaney/aws/ec2-api-tools-1.3-51254/bin - /usr/local/bin - /usr/bin - /bin - /usr/sbin - /sbin
Is there any reason `MALLOC_ARENA_MAX=2` isn't default for everything ruby, then? Is this a setting that makes sense for sidekiq-type loads, but not neccesarily for other loads?
Author mentions promises too. His idea is, if I understand correctly, "of course, you can build `if`-s and `for`-s from `goto` primitive, but this doesn't meen `goto` should be exposed".
That's cool and not unreasonable. Building a "nurcery" out of futures or promises in ruby-concurrent is probably 4 or 5 lines of code. 
&gt; Is there any reason MALLOC_ARENA_MAX=2 isn't default for everything ruby, then? The reason for multiple arenas is that a lock on the arena has to be held to allocate memory, with many threads and few arenas there will be increased lock contention, your program will be slower. How much this matters for MRI probably depends a lot on the workload. The GIL likely overshadows or removes a significant amount of contention but there are still off GIL operations that may suffer from the increased contention, network IO for example.
It could be cool if the graph had three lines: - Glibc with default settings - Glibc with `MALLOC_ARENA_MAX=2` - And Jemalloc
https://twitter.com/pierre_olivier/status/989191366268936192 &gt; Just added MALLOC_ARENA_MAX=2 to my heroku config and looks like it will save me $200/mo in workers! Thanks @mperham ! 
Neat. What goldiloader does in fact how NeXT/Apple Enterprise Objects Framework did it when I used it a couple decades ago. 
:D make sure you post here when you do!
When I think Ruby apps, "memory light, performance critical" is not typically what comes to mind, especially with Rails. Is there anyone that wouldn't trade 2% of performance for 50% memory savings?
I think rolling it out with the next stack revision or for only new apps is perfectly acceptable. Don't want good to be the enemy of perfect, as they say. People are used to improvements rolling out in new versions.
Okay, this is bizarre. The issue is that I cannot open https://api.rubygems.org/ - it just hangs. It also can't open cnn.com, but slashdot.org is fine: $ irb 2.4.1 :001 &gt; require 'net/http' =&gt; true 2.4.1 :002 &gt; require 'net/https' =&gt; true 2.4.1 :003 &gt; client = Net::HTTP.new('api.rubygems.org',443) =&gt; #&lt;Net::HTTP api.rubygems.org:443 open=false&gt; 2.4.1 :004 &gt; client.start Net::OpenTimeout: execution expired from /Users/mdchaney/.rvm/rubies/ruby-2.4.1/lib/ruby/2.4.0/net/http.rb:904:in `initialize' from /Users/mdchaney/.rvm/rubies/ruby-2.4.1/lib/ruby/2.4.0/net/http.rb:904:in `open' from /Users/mdchaney/.rvm/rubies/ruby-2.4.1/lib/ruby/2.4.0/net/http.rb:904:in `block in connect' from /Users/mdchaney/.rvm/rubies/ruby-2.4.1/lib/ruby/2.4.0/timeout.rb:103:in `timeout' from /Users/mdchaney/.rvm/rubies/ruby-2.4.1/lib/ruby/2.4.0/net/http.rb:902:in `connect' from /Users/mdchaney/.rvm/rubies/ruby-2.4.1/lib/ruby/2.4.0/net/http.rb:887:in `do_start' from /Users/mdchaney/.rvm/rubies/ruby-2.4.1/lib/ruby/2.4.0/net/http.rb:882:in `start' from (irb):4 from /Users/mdchaney/.rvm/rubies/ruby-2.4.1/bin/irb:11:in `&lt;main&gt;' 2.4.1 :005 &gt; client = Net::HTTP.new('slashdot.org',443) =&gt; #&lt;Net::HTTP slashdot.org:443 open=false&gt; 2.4.1 :006 &gt; client.start =&gt; #&lt;Net::HTTP slashdot.org:443 open=true&gt; 2.4.1 :007 &gt; client = Net::HTTP.new('cnn.com',443) =&gt; #&lt;Net::HTTP cnn.com:443 open=false&gt; 2.4.1 :008 &gt; client.open_timeout=1 =&gt; 1 2.4.1 :009 &gt; client.start Net::OpenTimeout: execution expired from /Users/mdchaney/.rvm/rubies/ruby-2.4.1/lib/ruby/2.4.0/net/http.rb:904:in `initialize' It's starting to smell potentially like an SSL issue of some sort.
Just proposed a new variant syntax: https://bugs.ruby-lang.org/issues/14709#note-6 ```ruby match(value) do |m| m.when(/name/, 42) { |name, age| Person.new(name, age) } m.else { |object| raise "Can't convert!" } end ``` A practical usecase may be something like this: ```ruby def get_url(url) Net::HTTP.get_response(URI(url)).then(&amp;match do |m| m.when(Net::HTTPSuccess) { |response| response.body.size } m.else { |response| raise response.message } )) end ```
Just to let you know people don't get notified when you reply to your own thread. Maybe give chruby + ruby-install a try instead of RVM https://www.reddit.com/r/ruby/comments/8eov33/ruby_ecosystem_guidance/dxxywz1/?context=10000
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [baweaver/qo/.../**77eb2544c41b33361a561178b145d33fa2409bde#new-in-this-branch** (pattern-matching-block-format ‚Üí 77eb254)](https://github.com/baweaver/qo/tree/77eb2544c41b33361a561178b145d33fa2409bde#new-in-this-branch) ---- 
I disagree. Here is mine take on this for anybody interested: http://nts.strzibny.name/on-managing-ruby-versions/ I wish I stop seeing everywhere 'don't run system Ruby' as an advice to a beginner. As long as they have some Ruby available they can start learning and playing with it. Instead they have to face decitions on what manager to install &amp; how to use it &amp; why do I have weird errors in the terminal now?
Thanks for the reply. Please note my update on the original - the issue has nothing to do with rubygems. I cannot open a socket connection to a remote domain that resolves to multiple IP addresses from Ruby. No problem opening a connection to one of the IP addresses. Tracking that down today.
https://github.com/ankane/groupdate is kinda more versatile, timezones and all. and with (shameless plug) https://github.com/codesnik/calculate-all you can graph even more analytics in one query
There's a James Golick talk from years and years ago talking about the ineffeciencies in GNU malloc and the improvements to Rails performance using an alternate. It seems to be a long term case of stubbornness.
Pretty much useless because you could already do `1.step`: https://stackoverflow.com/a/38971822/322020
Holy moly, it has been almost 10 years since I've seen you. Looks like you're doing well, congrats! And thanks for the article.
Are you behind a proxy or VPN?
This is seriously amazing. Thank you mike for all the extra $$ and room to scale! You rock!
Rather awesome project, wish I had seen this article before I converted my stuff from static Jekyll over to rails. 
I like this gem for its simplicity. For those looking to perform advanced reporting features, we used the [ActiveReporting gem](https://github.com/t27duck/active_reporting), which we really like. It encourages clean and flexible reporting code by separating any reporting DSL into so-called "FactModels".
Generally, it's usually a quite old version. For instance, Ruby shipped with Sierra is 2.0 and does not support TLS1.2. CentOS 7 ships Ruby 2.0. Many popular Ruby gems these days only support Ruby 2.2.2+ (because that's what Rails 5 supports).
I wasn‚Äôt running the system‚Äôs Ruby, I was running my Homebrew-installed Ruby. I was just confused about why I couldn‚Äôt just use Homebrew‚Äôs Ruby for everything and why I need a version manager at all
By value. For more details, see this: https://stackoverflow.com/questions/1872110/is-ruby-pass-by-reference-or-by-value
Whether the pattern can be applied in some larger context in a way that creates good code isn't something that can be seen in the supporting arguments for the proposal.
By value, but those values are object references. It‚Äôs complicated like that
aye, complicated a bit, eh, ty!
ty! 
What‚Äôs your dns situation looking like? Do you have multiple resolvers? Are they behaving correctly? What does wireshark say when you initiate a connection?
You might want to check out [active\_mocker](https://github.com/zeisler/active_mocker#activemocker)
Thanks! ... I will check it out =)
+1 to looking into your dns resolver.
I'm always wary of folks pronouncing that they've succeeding something "simpler." Usually, this just means they have discarded the concepts that aren't already familiar. This article is no exception in that regard.
"made simple" is often a codeword for "made it work for our unique environment and use-case."
That's definitely a valid concern. I'll look into getting practical examples of usage added to the proposal within the next day or so. A lot of it relies on prior knowledge of functional languages and how they apply the idea of pattern matching. Either that or Rust, which also uses it frequently.
You need to provide more information about what you‚Äôre trying to solve.
Indeed. And it takes a lot longer than a few months to be in a position to declare victory. With event sourcing in particular, if you have to go back and change anything about the way you're writing events, you're going to get hosed. There are plenty of event sourced systems that seemed fine after the initial phase of development, but the long term outlook still proves extremely bleak. In fact, much of the full breadth of knowledge that's been built around ES systems is meant to equip teams to both overcome common pitfalls _and_ unlock the fullness of the benefits. Hacking together a minimal implementation of a few aspects of the overall pattern might be a useful learning tool, but it's downright reckless to put into a production system that real humans are counting on.
1.1.1.1
I don't understand what you're asking. There is a loop in this code already. The .each method. 
Can you make your question clearer? What do you mean by "incorporate"?
Anything of note here, or are you just posting for visibility?
comment is the Comment object, not the comment text, so it does not have a length argument. Try checking the length of the comment's comment property. 
I think ES-like structures with lightweight implementation can be tremendously powerful and useful. I have two such in my current major project: one is double-entry accounting of payments in our two-sided network; the other is a CRDT set of changes to the documents that our users publish. In both cases there's a time bound on the relevance of data which is super important to contain complexity if there's a future change. I never use ES for master data. And I think creating application-layer infrastructure for aggregates &amp; reactors et al is over-egging the pudding. 
What you're saying makes sense. To be honest, though, I treat data retention as an ops problem. As you hinted, entities have their own life cycles. There's absolutely no need to keep data from entities that mattered five years ago in hot databases. So... why not delete them? The cost is not only storage but the ongoing support cost presented by event schemas. One of the big benefits of event sourcing is that new materialized views, reports, etc. can leverage historic data. That doesn't mean your transactional systems have to maintain that event sourced data forever. We can backfill data from replicas of master data when we generate new reports, for instance. That said, event sourcing is also a powerful tool for robust distributed messaging, and thus it's valuable for partitioning (e.g. microservices). I wouldn't throw the baby out with the bathwater, so to speak.
`&lt;h1&gt;Course Rating Information &lt;/h1&gt;` `&lt;p&gt;` `&lt;strong&gt;Number:&lt;/strong&gt;` `&lt;%= @course.number %&gt;` `&lt;/p&gt;` `&lt;p&gt;` `&lt;strong&gt;Year:&lt;/strong&gt;` `&lt;%= @course.year %&gt;` `&lt;/p&gt;` `&lt;p&gt;` `&lt;strong&gt;Name:&lt;/strong&gt;` `&lt;%= @course.name %&gt;` `&lt;/p&gt;` `&lt;% if @course.comments.exists? %&gt;` `&lt;h2&gt;Ratings&lt;/h2&gt;` `&lt;% @course.comments.each do |comment| %&gt;` `&lt;p&gt;` `&lt;strong&gt;Commenter:&lt;/strong&gt;` `&lt;%= comment.commenter %&gt;` `&lt;/p&gt;` `&lt;p&gt;` `&lt;strong&gt;Score:&lt;/strong&gt;` `&lt;%= comment.score %&gt;` `&lt;/p&gt;` `&lt;p&gt;` `&lt;strong&gt;Comment:&lt;/strong&gt;` `&lt;%= comment.comment %&gt;` `&lt;/p&gt;` `&lt;p&gt;` `&lt;strong&gt;Length of comment:&lt;/strong&gt;` `&lt;%= comment.comment.length %&gt;` `&lt;/p&gt;` `&lt;p&gt;` `&lt;%= link_to 'Destroy Rating', [comment.course, comment],` `method: :delete,` `data: { confirm: 'Are you sure?' } %&gt;` `&lt;/p&gt;` `&lt;% end %&gt;` `&lt;% else %&gt;` `&lt;h2&gt;No ratings available&lt;/h2&gt;` `&lt;% end %&gt;` `&lt;%= link_to 'New Comment', new_course_comment_path(@course) %&gt;` `&lt;%= link_to 'Back to course listing', courses_path %&gt;`
So basically, it's on ruby rails, and there are user input comments \(comment.comment\). I am displaying the length of characters in the individual comments already via .length, but I need to get the total number of characters in all of the user input comments displayed? thanks!!!!
So the array method I gave above definitely applies in this case. You have an array of comments in `@course.comments`. So, assuming I am understanding you correctly, you could do: ... &lt;% if @course.comments.exists? %&gt; &lt;h1&gt;The comments are &lt;%= @course.comments.sum(&amp;:length) %&gt; characters!&lt;/h1&gt; &lt;h2&gt;Ratings&lt;/h2&gt; &lt;% @course.comments.each do |comment| %&gt; &lt;p&gt; &lt;strong&gt;Commenter:&lt;/strong&gt; &lt;%= comment.commenter %&gt; &lt;/p&gt; ... &lt;% end %&gt; &lt;% end %&gt;
I am very curious what is really non-idiomatic right there. Injecting something via a constructor? Can you elaborate more? And yeah, you're right - I've never seen such "construction" but only in simple rails (crud) apps. I've seen the similar solutions is larger apps. Did you see/use for example Hanami framework? DIP is about creating a loosely coupled system. No doubts about it. Using DI (via constructor) is one of the ways to achieve that but of course, not the only one. 
I am old fashioned and therefore want everything to be a) language agnostic and b) a postgresql extension
The only non-idiomatic part I see is passing data _and_ dependencies to the constructor. You won't be able to create your dependency tree at "compile" time (during app start up) because the data will only be available during runtime, so you are forced to create your dependency tree with every usage. ReportGenerator = ReportGeneratorManager.new(deps) # ... ReportGenerator.call(data) is more useful. I'd also avoid using default arguments for dependencies. This will lead to people being lazy and not passing dependencies all the way down. Therefore most layers above `ReportGeneratorManager ` will end up with implicitly hard-coded dependencies.
*Fair warning*: this is highly experimental and definitely a messy branch. It also uses `binding.eval` and some other hackery. If Qo was magic, this is black magic. The benchmarks could use some improvement, but the gist of it still stands: It's possible to get near-vanilla speeds with expressive language on large array querying using only Ruby.
Yeah, that's a very good point about passing data &amp; deps together to the constructor. I must agree. When it comes to default arguments for dependencies, I would agree but partially. If our "ReportGeneratorManager" class sits high in the class hierarchy it's ok to do it. For example, a solution used for controllers in Hanami framework. Controller objects are created implicitly so this is the simplest way to inject such dependency and probably the only one.
I can not stress how using this techniqe along with IoC Container helped me untangle complicated apps. To bad that in our community people tend to underestimate their value.
Forgive me if I've miss interpreted your question, but I think `Array#product` is what you are looking for. [\[docs\]](https://ruby-doc.org/core-2.5.0/Array.html#method-i-product) sizes = [:small, :medium, :large] elements = [:fire, :ice, :water] species = [:dragon, :elemental, :unicorn] combinations = sizes.product(elements, species) puts combinations.take(6).inspect #=&gt; [[:small, :fire, :dragon], [:small, :fire, :elemental], [:small, :fire, :unicorn], [:small, :ice, :dragon], [:small, :ice, :elemental], [:small, :ice, :unicorn]] puts combinations.at(17).inspect #=&gt; [:medium, :water, :unicorn] puts combinations.index [:large, :water, :elemental] #=&gt; 25 I have no idea how the internals work, but a quick experiment seems to show that it is O(n^2) up to 4 items and then O(1) thereafter.
Doesnt seem to be.
The one major issue is that if you discover the events you wrote were wrong, or were stored in a manner that is undesirable (for instance, race conditions are possible that you didn't consider initially), you're going to have a really hard time fixing that. Excruciating, even.
Yes I get the reasoning. To make my point clear, it may be just my personal prefference - if I wanted tight coupling I would hardcode the `XmlRaportGenerator` into the `ReportGeneratorManager` class. If, hovewer I wanted loose coupling, I would move the knowledge aboyt `XmlRaportGenerator` into the container. So that `ReportGeneratorManager` doesn't even know that smth like `XmlRaportGenerator` exists. I would orchestrate both in the container. I just don't like something-in-between-solutions, like: ReportGeneratorManager def initialize(data, generator = XmlRaportGenerator) 
Ruby 2.7 is 2019 Xmas, for majority of people that is 2020 or early 2021 deployment. ( Sigh ) Or will someone have to fork the Ruby MRI and make Jemalloc as default?
I'm still surprised that we still harp on BDD or TDD or any of the testing methods.
Works for me: &gt; 2018-04-27 17:03:43 +0100 &gt; 2018-04-27 17:03:43 +0100 If it were me I'd consider [profiling](https://github.com/ruby-prof/ruby-prof) the code to see where the time is taken up.
I've opened a ruby-core issue to use jemalloc. We'll see what they say. If you have graphs or data about a move to jemalloc, please add a comment to the issue! https://bugs.ruby-lang.org/issues/14718
I'd consider using [chruby](https://github.com/postmodern/chruby), which is _very_ simple (much much much simpler than rvm) and pretty much does what you're trying to do, but in a proven and mature way. What you're doing might work, or be close to working, but why figure it out when chruby already has for us. Alternately, I suppose, you could look at what chruby does, and copy it for yourself. It's a 100-line bash script (with plenty of comments and whitespace), so perhaps it found the need for more than 5 lines, but it's also doing a little bit more than you are (like letting you switch to a ruby by name without it's full path). https://github.com/postmodern/chruby/blob/master/share/chruby/chruby.sh You could maybe continue to build rubies with rvm, but I'd use something simpler for that too. the chruby readme has several options. RVM being in your system at all tends to mess other things up. If you want something simpler than rvm, which I think you do, I think it's time to move away from rvm. :)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [postmodern/chruby/.../**chruby.sh** (master ‚Üí 4c46722)](https://github.com/postmodern/chruby/blob/4c4672214e2200271c3301a6f4e2cbb9445d6efd/share/chruby/chruby.sh) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dy2fy3g.)
These are the types of conversations that I had hoped to provoke by posting this here. I'm currently working with ES in a fairly well-constrained (for now, anyway) Rails app at work and despite the fact that I've drank the kool-aid with this app I am still on the fence about it. One useful thing that I did take from this article, though, is the idea to do yourself the favor upfront and make it as easy as you can to back the ES bits out in the event that you might need to. I took the same approach, and it at least gives me that peace of mind.
Perfect, was looking for something simpler than RVM. Thank you.
Any word on ActionCable scalability? I've seen a few posts suggesting 3rd party libs instead due to scalability issues.
I have no idea, From what I read it isn‚Äôt really useable beyond a few dozens of concurrent user. 
I prefer rbenv to chruby because as soon as you need to trigger ruby from cron, your non-login shell will not work with chruby, but the shims from rbenv work just fine. RVM is just a hot mess, not touched it in years.
Any idea how soon the video will get posted? This is one of the talks I‚Äôm most interested in but didn‚Äôt get a chance to catch any of the live streams. 
I was looking around yesterday and for RailsConf 2017, the videos got posted a couple weeks after the conference. So probably pretty shortly.
They were all pretty good, but this one was exceptional. Hopefully it‚Äôs up soon. 
Personally I use a go-backed websocket server and communicate over redis for the queues and messages, and call them from the rails side.
Does it happen with system ruby or Ruby installed by rbenv? Do you have anything else third-party installed e.g. via homebrew?
http://anycable.io
Reading he article, I did get the feeling that the author was hinting that TDD is not as useful, but I do feel that testing both what an object is and what it does with BDD is necessary. I would also say that some people would see it as overkill or being cumbersome. But using MiniTest for both unit and spec testing then using cucumber as a feature test with different language could and is actually very helpful.
Reading he article, I did get the feeling that the author was hinting that TDD is not as useful, but I do feel that testing both what an object is and what it does with BDD is necessary. I would also say that some people would see it as overkill or being cumbersome. But using MiniTest for both unit and spec testing then using cucumber as a feature test with different language could and is actually very helpful.
The Ruby runtime is the container. We can, and do, inject dependencies directly into classes and object instances from outside. We can even do it to libraries that don‚Äôt explicitly support this, at the risk of technical debt of course. Case in point, I have a business rule mechanism that starts with Object.new and then includes modules according to configuration to make it do something useful. No container infrastructure required. 
Confreaks had mentioned one month from Railsconf, so I would expect them around May 18th https://twitter.com/confreaks/status/986634131252678656
Submit your proposal to bugs.ruby-lang.org
https://bugs.ruby-lang.org/issues/14722
Um. Is this actually Matz?? 
You could easily implement this in a gem so why does it need to be in core ruby?
I didn‚Äôt get that vibe at all. BDD is a specific type of TDD. The workflow he proposed is most certainly TDD - but beginning with a failing integration test and using that to determine which components to build first. Each component still gets unit tested. He specifically mentioned writing failing tests and the red-green-refactor cycle. That‚Äôs TDD.
Check out Apache Arrow: https://arrow.apache.org/ There's a Ruby implementation here: https://github.com/red-data-tools/red-arrow
Are you sure a non login shell can't be configured to use chruby? It should just involve placing the chruby invocation in the appropriate non-login profile. That said, in production, I typically just install new rubies from an apt repository like brightbox that publishes recent versions. Much easier than dealing with any of this dev tooling. No reason to need multiple rubies in production, in my experience.
I saw this maybe a week ago and it‚Äôs written in Crystal which I‚Äôd heard about but hadn‚Äôt really checked out. So I did. Now I really want to learn Crystal. I did a hello world but haven‚Äôt had time to go deeper yet. It looks very cool though. And the Lucky framework. First I‚Äôm gonna finish my current Rails app and try BitFrost. Excited about how fast it is. 
How faithful are you all to TDD? For example, if you‚Äôre working on a class, maybe some kind of service object and you‚Äôre not really sure how it‚Äôs going to work or if you need multiple classes, do you start hacking/prototyping and then write your tests as your start to understand the classes? Or do you just write tests, then your class code and then refactor? Just curious how others work. 
Hello, great (static) website theme. You're more than welcome to add your Spacetime theme to the [Dr Jekyll theme directory / listing](https://drjekyllthemes.github.io/). Cheers. Prost.
Thanks for Ruby!
Seems great. I will do that.
Sure. https://github.com/postmodern/chruby/wiki/Cron I'm not sure what rbenv is doing differently to work in cronjobs more easily? 
I was looking at using brightbox recently, and was annoyed to see they only have packages for the most recent patch release. Like 2.5.1, but not 2.5.0 any longer. Which makes it hard to use for reproducible builds. Sure, I want to update to 2.5.1 when it comes out, but I want to do it on my timeline, not just the next time I build a host having it automatically install a slightly different version of ruby than the last time I built a host, cause 2.5.1 came out, and then maybe there's a bug that effects my stuff, etc. Any advice?
Is there any concern that they‚Äôre trying to reinvent the wheel here at all? What is a Guild comparable to in other languages - are they comparable to Erlang processes or Go channels? The send / receive mechanism seems similar to those. 
I had mediocre grades and in relative to my peers. \(meaning B and C grades in subjects like math and chemistry, and one E grade in Economics\) My friends had like All As in schools and A/A\*s in Board Examinations. Things worked out well. You can save money while applying to schools. You don't need to do 50 schools. Should be less than 30 even if you are not confident. However, you should think of other countries as well. US is not like an exclusive education paradise. 
Bad bot
I don't think so. It draws heavily on existing models of concurrency/parallelism and their implementations to reduce the impact of GIL on Ruby while improving ergonomics and not sacrificing single thread performance. The last one is actually really hard to do. The Python "GILectomy" was around 20x slower than with the GIL, last time I checked.
You are forgetting [fxruby](https://github.com/larskanis/fxruby) which is sort of old but it gets the job done for simple apps.
I'm I wrong in saying that, given you understand OO, you technically understand FP? The FP is just an approach where you don't store state? Pipelining operations over injecting state into an object and then mutating that state without passing parameters around? I understand FP reduces side effects, but in general if one eliminates those side effects in OO, they generally do so by "dropping back" to FP. Perhaps my understanding could use some adjustment. I just always felt that functions are so foundational to any approach that considering an approach built on top of it as being non-functional was a bit narrow of a definition.
You're not wrong, in a sense, given that (as you say) you need to understand how to define and call procedures in every style of programming (including OO). However, you would also need to drop classes, inheritance, and all the OO machinery - as a matter of fact, the closest thing to FP is imperative programming (e.g., C) where you force yourself not to use explicit state. Even then you'd be missing important pieces of the FP puzzle, like solving pretty much every problem with recursive/inductive solutions, preventing the existence of a whole class of bugs (off-by-one errors, etc.), and many others. To use your analogy, it would be like "I know differential calculus, and now you want me to solve my problem using discrete maths only, so I have to rethink the whole thing" :-)
Bad bot
There is an argument that you can't be '[a bit functional](https://queue.acm.org/detail.cfm?id=2611829)'. That would make functional programming e.g. in Ruby, impossible. Adopting a functional style, is just that.. missing the substance. Following that argument, understanding OO wouldn't really give you an idea how to write in FP 
Awesome. This makes sense to me. Especially the notion that there are more complex concepts and methodologies that assist in maintaining a purely functional approach. I would love to see more relatable examples of pattern matching making my life better. I know it's an amazing thing... I just haven't run into a compelling reason to go down that path. Admittedly, that is because I have been emphasizing other concerns on my road, but pattern matching is on my list. Do you have some good youtube videos or anything that really illuminate the subject? 
Bod bat
&gt;However, you would also need to drop classes, inheritance, and all the OO machinery Objects and classes have more to do with the type system and enforcing the validity of your data structures than they do with the style ‚Äî functional, imperative, declarative ‚Äî the program's written in. When used this way, objects are basically just validators wrapping a generic data structure, which is quite functional but also practically useful, especially in the absence of a good type system.
Beat bot
Bad bart
Not that I'm aware.
FYI: Added some test assertions thanks to minitest in [`token_test.rb`](https://github.com/openblockchains/universe/blob/master/tokens/token_test.rb). Example: class TestToken &lt; Minitest::Test def setup @token = Token.new( name: 'Your Crypto Token', symbol: 'YOU', decimals: 8, initial_supply: 1_000_000 ) end def test_transfer assert_equal 100_000_000_000_000, @token.balance_of( owner: '0x0000' ) assert_equal 0, @token.balance_of( owner: '0x1111' ) assert @token.transfer( to: '0x1111', value: 100 ) assert_equal 100, @token.balance_of( owner: '0x1111' ) assert @token.transfer( to: '0x2222', value: 200 ) assert_equal 200, @token.balance_of( owner: '0x2222' ) assert_equal 99_999_999_999_700, @token.balance_of( owner: '0x0000' ) end #... end 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [openblockchains/universe/.../**token_test.rb** (master ‚Üí 6a7eee7)](https://github.com/openblockchains/universe/blob/6a7eee79c7e7888df7022a6ecb62c9625b3fab0c/tokens/token_test.rb) ---- 
Doesn't bundler need rubygems to actually fetch the gems? Or do you have bundler put your current gems into your repo for deployment? I do not like not being able to build an identical machine at any time, if the package for whatever version I currently have installed is no longer there from brightbox. But I guess one solution would be mirroring the package from brightbox with a patch-level name locally, so I always have whatever version I last installed even when brightbox has updated. 
No, standalone bundles generate a "bundler/setup" file that directly add each installed gem to the load path. It's really snazzy. Good thought on mirroring brightbox but retaining the old packages.
Could you elaborate on how I would use classes specifically? I use methods in my code all the time but I don't see the importance of classes
Oh, there's an API on top of it [https://github.com/flajann2/fxruby-enhancement], should have put it on the first post :P
There were several references to Elixir and Erlang in the presentation. They are definitely paying attention to what's in other languages -- at least those. And trying to adapt them to be compatible with existing ruby idioms, without inventing a whole new language (which Matz does not want, and I agree). 
Say you're making a website that people need to log into. You can make a User class that has a username field and a password field. You're going to want to store that information in a database so you don't lose it, so you could add a method to User that saves a particular user to the database. But, if someone tries to create an account with a 4000 character username or a 2 character password, you should probably not store that in your database. You could add a method to User that checks if the user is valid. And if some other dev wants to do something with a User, they can use the class without needing to know all the internals. They can look at the public methods and that's all they need to know. If you look into Ruby on Rails, you'll see object oriented stuff everywhere.
So classes are used as databases?
isn't this the same as: def get_url(url) Net::HTTP.get_response(URI(url)).then do |response| if v == Net::HTTPSuccess response.body.size } else raise response.message end end
I agree - I was referring to "traditional" OOP, where objects are often used to encapsulate state. To be fair though, the standard technique would be to use an abstract data structure (as defined by the set of functions you can use to manipulate it), and I'm not sure I'd call that an object - but then again, no one has ever given a satisfying (or even commonly accepted) definition for objects in OOP, so we can say whatever we want :-) Also, I do believe that the complexity of inheritance etc (even in functional settings) is more trouble than it's worth, but of course that's a personal opinion. Thank you for your comment! 
\o/ Thank you. I love how you didn't bother to repeat the address of the group, since you know that strings in reddit are immutable. :-)
Halunke has the huge advantage of being easily searchable for. (What the FUCK were they thinking with "Go"?!)
I was worried that guilds seemed like a wrong path somehow... but I'm feeling better about em from these slides. 
Classes encapsulate data, expose behaviors though methods, define relationships and act as an abstraction for a "thing" in your application. Basically they're organizational units for your code. Classes can represent a table in a database (these are called 'Models' in an MVC framework) for example, but they certainly don't have to. Here's a very simple somewhat Rails-y example. Let's have class Cat and Owner, defined as such: class Owner has_one :cat def feed_cat # cat feeding logic end def entertain_cat #cat entertaining logic end end class Cat belongs_to :owner attr_accessor :hunger_level, :bordem_level, :num_lives def alive? num_lives &gt; 0 end def hungry? hunger_level &gt;= 5 end def bored? boredom_level &gt;= 5 end def eat raise NotHungry if hunger_level &lt; 1 hunger_level -= 1 end def play return scratch_owner if boredom_level &lt; 1 boredom_level -= 1 end def knock_things_off_shelf # thing knocking logic end end owner = Owner.first #fetches an owner from the DB owner.cat = Cat.create(name: 'Nermal') begin if owner.cat.hungry? owner.cat.meow until owner.feed_cat owner.cat.eat until !owner.cat.hungry? end if owner.cat.bored? owner.cat.knock_things_off_shelf until owner.entertain_cat owner.cat.play until !owner.cat.bored? end end while owner.cat.alive? 
They provide scope, and hide variables. I am learning OO as well. Working through the ruby cookbook at the moment.
Looks like you might enjoy functional programming, if you don‚Äôt know any functional languages you should try one. 
Essentially yes. You could express about anything in Qo with regular if/else branches, but after a while it's more a matter of succinctness than anything. Once you get more than one or two conditions it can start getting unwieldy, and that's not uncommon in ETL type jobs.
 If you enjoy Ruby syntax, go for Elixir.
It's a nice way to keep track of lots of variables in a reasonable way. Say, you had a simple game where enemy spaceships spawned from the top of the screen and occasionally shot down missiles. You want a spaceship to spawn every 5 seconds or so, and fire a missile every 2 seconds or so. So, for each spaceship, you have to keep track of a seperate x &amp; y coordinate, as well as different timings for when to fire missiles. Could you do without using OOP explicitly? Yeah. Instead of having an array of ship objects, you could have an array of arrays or hashes, containing numbers for the x, y and timings, and a seperate set of methods to parse the arrays and execute the desired functionality. But it will tend to make your code a lot less readable and intuitive than writing it using Object Orientation.
Hey, Fluffy\_ribbit, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
It's weird cause nowadays alot of languages support both styles of programming and it all depends on where and what you are working on. The language I like which isn't necessarily object oriented is LUA though.
Hey, invention64, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
After a quick look: Guilds look most comparable to Schedulers! (Prove me wrong ... not in an aggro way, but just in a "after looking at it, that's now my mental model"). Which is kind of awesome to have available. Ie, presentation says 2 things: - containment goes: Guild has many Threads has many Fibers - only one Thread can execute on a Guild at a time It's necessarily higher-level and heavier-weight than the equivalent in beam land, as the beam is a vm built from the ground up on a different model than ruby and most other languages. I mean, preemption ...
More of getting my musings over the last week or so out. I'd be curious to see if there's a way to unfold loops like this at a C level but I know absolutely nothing about native extensions and if that's even remotely plausible in the first place.
As somebody else suggested elixir might be easy to pick up if you enjoy ruby. If you want to go to something more hardcore (but maybe harder to pick up) you can try (in order of difficulty from easier to harder I think) Clojure, OCaml, Haskell.
so that you can have two methods with the same name but different meanings appropriate to their types
Congrats! Massive nitpick (and I'm sure I'm not alone here): [lose the tabs; 2 spaces. :)](https://github.com/bbatsov/ruby-style-guide#spaces-indentation) 
Great work... thank you for creating this gem and sharing it. Minor areas: * Fix spelling of image_dimentions * Rephrase to use "lon" or "lng", but not both * Rephrase to use all cap "OSM" or first cap "Osm", but not both * Refactor to use "return" or implicit return, but not both * Refactor the gemspec to use an explict manifest (i.e. list each file rather than using `git ls-files`. * Reformat indent to 2 spaces Major areas: * Add tests * Refactor code to be more testable For example, you have this line in an inner loop, and the line combines and instance variable with loop variables with an IO call: tile_file = Tempfile.new(["tile-#{@zoom}-#{tn[:x]}-#{tn[:y]}", ".png"]) I suggest you refactor that code into multiple pieces: one to generate the file name using functional code, one to do the IO, such as: def tile_tempfile_name(x, y, zoom) "tile-#{zoom}-#{x}-#{y}" end def tile_tempfile Tempfile.new(tile_tempfile_name(tn[:x], tn[:y], @zoom)) end The refactor makes the functional method much easier to test, and also make the IO method easier to test by enabling you to fake as you like. Similarly, refactor to separate the generation of the tile file paths from the actual downloader file reader/writer. You have some values that use multiple representations, such as "lat_deg" meaning "latitude represented as degrees" vs. "lat_rad" meaning "latitude represented as radians". I recommend adopting a naming convention "lat_as_deg" and "lat_as_rad". This looks trivial yet is a hallmark IMHO of well-written code because it makes the intent clearer. Make this a habit and it will help greatly on larger projects. Investigate the point of this line: link_from_tile_number(tn[:x], tn[:y]) Why is it necessary? 
I wondered if I could use math operations on a module and coax them into procs like this: ``` [1,2,3,4,5].map(&amp;Mf + 5) # =&gt; [6, 7, 8, 9, 10] ``` ...and what do you know, it works! So I just packaged them all right quick and decided to share.
Don't `include Magick` globally, because then that's applied to other people's code, too. Instead include it just in your class: class OSMTileGrabber include Magick # ... end Also, RMagick can be tough to install, e.g. `gem install rmagick` on Ruby 2.5.1 fails to install C extensions for me. I would recommend using MiniMagick for simple solutions like these, which simply shells out to the command-line and doesn't have C extensions. I'm guessing this should work: MiniMagick::Tool::Montage.new do |cmd| cmd.merge! file_paths cmd.geometry "+0+0" cmd.tile "#{image_dimensions[:x]}x#{image_dimensions[:y]}" cmd &lt;&lt; output_path end I don't know how big this tiles can get, but you might want to avoid loading them whole into memory: IO.copy_stream(read_file, tile_file.path) # or FileUtils.mv read_file.path, tile_file.path Be aware that Tempfiles will get automatically deleted on garbage collection if you don't keep the reference to the Tempfile object, so I'd recommend returning them instead of just paths.
bad bot
Thank you, Code-Master13, for voting on CommonMisspellingBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Looks really cool. Are you thinking of adding new topics? I want to learn about data science. Can I get a weekly digest? 
Thanks! Yes, I am slowly adding topics. Datascience will likely be next. 
can you tell us a bit more about the kind of project that was not possible in ruby/Rails?
Thats quite comprehensive, Thanks for the advice. 
I personally really don't like 2 spaces. That's why I use tabs, so it looks good for me and anyone else can just set tabwidth to 2.
Bost beat
I have no criticism but only praise: congratulations on creating something - anything - and opening it up to criticism. 
This is a great comment. \+1 
Starting to understand the concept now, I made a simulation with 'cells' that replicate and die with elements of mock evolution, using classes to create the cells as separate objects and giving them attributes with the attr_accessor method 
Cool, have you dipped your toes into rails yet? 
bad bot
Not yet, I'm learning ruby so I can use rails so I'll start rails when I've learnt the syntax of ruby
I agree \- can I ask you what's your background and how you got into FP?
Looks really cool ! How does it work ? Do you curate the articles and manually input them to the DB ?
Thank you for the link! I know what you mean \(just the lack of TCO makes me want to give up writing FP code in other languages\), but I also understand that often you can't pick the language \(especially at work\), so you have to work with what you have. To be fair, even without being able to use some \(or most\) of the traditional FP techniques in other languages, you can still benefit from the FP way of organising code and modules, the way you do testing, and other things. Can I ask you how you got into FP, and what do you use it for? Thanks!
When you say "illuminate the subject", do you mean pattern matching or FP in general?
That's cool :) Out of curiosity, would you be able to provide an example where the concision of `Qo` wins out over a slightly noisier but less magic traditional approach? Not trying to get at you, i'm just genuinely interested as i would be keen to use it in production if i see something that blows me away... :)
Some gems to try: Sinatra, httparty, nokogiri
Thanks :)
The best seller one is offering a free coupon: https://www.udemy.com/learn-to-code-with-ruby-lang/?couponCode=RUBYONE
I would say it reads RSS from differente sources and then matches by hashtags. I have my pet project which does something similar although this is a lot prettier/better. : ) 
It's less about preference, more about consensus. I am not aware of any major Ruby gems that enforce or even use tabs. If you want to work on gem design/OSS, it is helpful to follow as close to conventional Ruby as possible, so Ruby developers are likely to jump on and help with your project. It may be more of an open debate in other languages, but from what I have seen Ruby has landed fairly solidly on the spaces side of the argument.
I'm really looking forward for getting preview build on this :) Doesn't look like it's quite there yet sadly.
With enough support and lingering enthusiasm, I'd believe in brighter future of Ruby. However it is not a new idea at all. I do remember KO1 already presented Guilds 2 or 3 years ago on a Rb conference as a solution to multiprocessing \*\*and\*\* keeping as much as possible from backward compatibility. If you would think about the problem thoroughly, you can't come with a much different solution unless burn all bridges from over a decade evolved GIL'ed CRuby ecosystem. Quality implementation of Guilds is what now Ruby really needs, its Achilles heel in world of multicore processors and distributed computing.
Nice intro to an interesting topic. 
I really love to see more Ruby libraries for OSM usage! Thanks! I learnt about imagelist and montage - that's an interesting command. Note that, according to the warning section in the readme your library should send a custom HTTP User Agent to help OSM Admins identify if someone is using it. 
I'd settle for an idiomatic wrapper around ncurses. (I know there's an existing lib.)
Are there no conferences in Florida anymore? There used to be one in St Augustine but I think they quit doing that one. Anyone know of any others?
Very nice!, are you the gem's author?. This is the sort of thing that should be pushed into the std or ruby itself. 
&gt; I plugged it in and started running the headless feature as I would Phantom JS. I actually really enjoyed the speed and performance of the driver. I might start using it as my integration driver from now on. Unfortunetly, it would not allow for downloads using the browser while using headless mode.(at least at this point) It does support it now actually, see my comment here for enabling it: https://www.reddit.com/r/ruby/comments/8d6vdb/capybara_rails_chromeheadless_on_travis/dxkwp58/
This gets to the main problem of TDD. It's fine if you're working on a pre-defined task, e.g. "Add a download link to the accounts page". It doesn't work at all for anything that requires real design work.
This is exactly what I have been waiting for before touching front end again. Sweet
Cool! I've got a somewhat similar thing at http://rubyland.news, but I like yours. Interested in how you did it, is your code open source?
&gt; they'd have to overhaul the entire IO layer to make green threads work properly. Blocking IO calls would need to trigger the scheduler for green threads, for instance. I don't see that being a major issue and most IO is already non-blocking on MRI, i.e. it releases the GIL allowing another thread to run while waiting on IO. They are going to have to do some major internal re-work to support guilds anyway, there are tons of things inside MRI that make the assumption of GIL protection. &gt; I don't see why Guilds would need to have any higher footprint than threads. Could you explain what you mean? I'm assuming there is some non-trivial const within MRI to setting up and managing a guild. Worst case a separate interpreter instance per guild. But even OS threads are not cheap to create in comparison to something like a go func and you can't just willy-nilly spin up a million threads and let the runtime do the right thing, or spawn one per request the way you would go funcs for http requests. I think the biggest issue I see with guilds at the moment is that they don't at all feel like part of the language. In fact I don't see anything in the slides that couldn't be implemented in pure ruby running on jRuby / Truffle today.
Oh awesome! I'll try it out.
why the fuck does it say free when i purchased for ¬£9.99
Ah, you should have rang me up schneems - me and Parslet go back to 2012!
Should you view part of the course already atm, you'll find a better and more comprehensive subject module with engaging humor **to read** [for free here.](https://pine.fm/LearnToProgram) It was introduced by other Redditor on my initial journey :)
Oh cool. What have you done with it? I think I‚Äôm squared away for now, but might hit road blocks later.
&gt; Ruby threads are OS threads. If the IO operation is intended to block, then I believe ruby will internally perform a blocking IO operation after releasing the GIL. I'm not really sure what level of abstraction you're talking about here. Ruby just provides a thin wrapper over the various IO syscalls so whether the underlying operation is using `O_NONBLOCK` or not depends on the code path and isn't really up to MRI. Any extension that expects to wait is expected to yield the GIL. &gt; The OS scheduler is what decides to pre-empt a thread waiting on IO and schedule a different thread. Threads are not really preemptive in MRI, though they may appear that way. MRI will periodically (and I believe at certain critical points) decide if it wants the thread that currently holds the GVL to release it, at which point other threads that were waiting for the GVL will wake up and try to acquire it. Which wins is likely up to the OS scheduler. &gt; For green threads to work, ruby would have to jump into an in-process (i.e. not the operating system) task scheduler after it releases the GIL. Yes green threads require a user-land scheduler, that should be assumed. &gt; And it would have to do this for every different implementation of an IO operation. Not necessarily. What Go's scheduler does is maintain a thread cache and any time a go func makes a syscall (IO or otherwise) it doesn't schedule more work for the thread that go func was running on until the syscall returns. This doesn't require a bunch of operations, just wrappers on provided syscalls which MRI mostly has already. Of course in MRI you can always use nio4r or similar to speed up network IO and divvy out work if you're worried about too many threads blocked on syscalls. This is one of the advantages of abstracting the language level concurrency model from the OS thread model, Go can just spin up another thread (or grab from cache) to keep work moving along while some other go func waits for a 5400rpm drive to find a file.
you are on fire, mate!
Well to start by going down the list then... ### Why did you decide to learn FP? Honestly because as a Junior I was so obsessed with the idea that I had to know everything about programming and the dark magics hitherto that everything became a requirement. FP was one of those. A very big disclaimer here is that this is not a particularly productive way to learn things, and Seniority is far far more about soft skills than how well you can necessarily code. More on that in a later post though. Hm, I should write that up. Anyways, back to FP. I got hooked on this idea that I was part of an elite set of programmers who did things the one true and righteous way, and started spouting off about how awesome FP was. Never mind that I never actually built anything of value in it at that point, the righteous indignation did wonders for my ego. If you're getting the feeling that this is a dig at past me, great! Don't do what I did, it's incredibly pretentious and does you no good. When I really started to learn some of it was when I decided that I wanted to know how and why things worked under the hood. Enumerable always fascinated me, and after reading a bunch of Raganwald's works (Kestrels, Quirky Birds, and Hopeless Egocentricity) I was hooked. It led to a lot of experimentation and tinkering that resulted in some of my earlier gems like Izzy and more than a few old blog posts. You know what I've come to realize though? I still know jack-all about FP, and there's a ton more to learn. ### What's been the biggest challenge? HM type systems and abstractions which lead to code that looks like something out of a mathematical textbook. There are no real descriptive names for things, and it becomes layers of abstractions built upon prior knowledge dense enough that you need a shovel to get through it. The basic ideas make enough sense, but after a while it feels like you've just hit /r/restofthefuckingowl/. It happens. Take a step back, relax, and go back over the previous materials. The one thing I've learned is if you don't completely understand the underpinings of prior concepts you're going to be _super_ lost later on. It's ok to take your time. You normally read 1-2 pages a minute on fiction books? Great! If you're reading much faster than a page every 5 to 10 minutes you should slow down and make sure you can actually taste the knowledge on the way down. Programming literature, especially functionally oriented, is dense. Digest well and slowly. ### How much time and money have you invested? ...I'm not checking my books budget and you can't make me. Far longer than I can remember or really care to. It's a continuous process which requires a ton of investment, but here's the thing: so does any language or tool chain. You weren't a Java or Ruby pro in your first few years (even though some of us like to think so), so what makes you expect it'll happen instantly for Haskell or the like? If anything it takes even longer because it's such a foreign concept to the way you've considered things before. Getting good takes time, so make sure you're in it for the long haul
Fantastic writeup. Thanks!
Thanks for your reply! Can I ask which FP languages you decided to study? Haskell, Lisp, Erlang, ...?
Primarily Scala and functionally oriented Javascript. I keep skimming around the edges of Haskell, and one of these days I'll take the full plunge.
I see - thank you!
Awesome. Things look promising indeed!
Could someone talk about how they deploy websockets with Rails? Do you use different servers and a hostname for them running with Puma, and do you deploy them separately?
Thanks for a great writeup! I never actually understood, what is the advantage of using Rack hijack for SSE compared to using the `#each` and `#close` interface of Rack response bodies? For example, if I were to implement SSE like this: class MyRackApp def call(env) body = Enumerator.new do |yielder| 10.times do |i| yielder &lt;&lt; "data: #{i}\n\n" end end # if we wanted to add teardown body = Rack::BodyProxy.new(body) { ... } [200, {}, body] end end does it have any limitations compared to a Rack hijack version? Note that I'm aware this wouldn't work for implementing WebSockets, since there is no way to detect data pushed from the client. I'm just curious because I always thought SSE was possible without Rack hijack.
As another patch proposal on the dreaded rack, this kind of works. I think that the semantics of this "rack.upgrade" object are too oriented for the author desired scenarios, which are websockets first, and sse sorta after. Thing is. The upgrade protocol is specific to http, it supports also tcp or h2c (for which that callback object doesn't map very well), and sse is http, not an upgrade. If you ask me, this just seems a temporary hack on another temporary hack. And then, you have to convince rails to adopt this. Sadly, such is the state of affairs with rack. Godspeed.
waiting begins now ;) ...
Thanks for clarifying. &gt; Most servers implements the "endless each" as chunked encoding. If servers were to detect that you've set `Content-Type: text/event-stream`, could they avoid the chunked encoding? &gt; Besides, the http connection will be over after iteration, and sse was made for really long lived idle connection scenarios, like push notifications and chat apps. Well, theoretically the `#each` object (in this case Enumerator) doesn't have to finish producing content, right? Though, I don't know how that plays with web worker timeouts.
I've been working on [falcon](https://github.com/socketry/falcon). You can use it to host highly scalable apps which use web-sockets. Think, 100,000 connections per second on an 8 core server. It's not as good as what you could get if you implemented it in C++, but it's pretty decent for Ruby.
&gt; If servers were to detect that you've set Content-Type: text/event-stream, could they avoid the chunked encoding? In theory yes. &gt; Well, theoretically the #each object (in this case Enumerator) doesn't have to finish producing content, right? Nope it doesn't. I implemented real-time beer on the wall song here: https://github.com/socketry/falcon/blob/master/examples/beer/config.ru You can stream arbitrary data for as long as you want. 
I'm happy you agree it works. As for the semantics: I think you're thinking in terms of network protocols, which are NOT what your application should be worried about. An application should never receive the `h2c` upgrade header or a TCP/IP upgrade header (which, afaik doesn't exist) - these things are requested by the **client** from the web server. Such network related concerns should be handled by the server. Your application should require zero knowledge about the protocol (except, perhaps, asking if the transport layer is secure / encrypted). On the other hand, if the **server** wants to change the way it interacts with your Rack / Rails / Sinatra application, the application will receive a notification, using the `env['rack.upgrade?']` variable. The `env['rack.upgrade?']` variable effects the **server&lt;=&gt;application** semantics, not the **network&lt;=&gt;application** semantics, and decouples the application from the network layer. The HTTP/1.1 Upgrade header has nothing to do with the `rack.upgrade` name (and if this confuses you, you can suggest a different name in the PR's thread).
I‚Äôd be happy with a simple hookup to Unreal Engine 4. How hard can it be?
&gt; I never actually understood, what is the advantage of using Rack hijack for SSE compared to using the #each and #close interface of Rack response bodies? Using an Enumerator body has a number of downfalls - but the main issue is that it's consuming and often blocking the server's thread. Put simply, this patterns locks the server's thread in the `each` loop, preventing the server from handling other tasks / clients. Consider the following variation on you code: class MyRackApp def call(env) body = Enumerator.new do |yielder| 10.times do |i| # emulate a blocking call sleep(1) yielder &lt;&lt; "data: #{i}\n\n" end end [200, {}, body] end end This will place the server's thread in `sleep`, which will prevent any work from being performed for 10 seconds. Avoiding a mutex or a blocking call by simply returning earlier and adding more loops to the body (as some patterns might consider) will only spin-lock the server's thread. On the other hand, by using a callback or event reactive pattern, the server's thread is free to work, increasing concurrency and the efficiency of your code. 
Redis cluster protocol implementation.
If Ruby threads are operating system threads, then the operating system can and will pre-empt them. The fact that io blocking/non-blocking semantics are passed through to the system call is exactly what I'm talking about. Ruby would need to always use non-blocking calls, and rely on a green thread scheduler to preserve non blocking semantics. Literally every case of Ruby making a blocking system call would have to be changed to allow the green thread scheduler to present blocking semantics to programs. For reference, I worked in operating system kernel development for several years (mostly Linux). I am, however, a bit light in my knowledge of how Ruby is implemented. Any technical details you can provide would be appreciated 
As I understand it, every thread that is waiting on the GIL is, according to the kernel's task scheduler, effectively "asleep," and the OS won't schedule them to run. I agree that the effect of the GIL is, in essence, cooperative multitasking with blocking IO semantics that lift the main drawback of coop, which is the need to explicitly yield control back to the other threads. &gt; MRI's source code is already littered with calls to yield the GIL at exactly the points you'd need for this. You don't need to rearchitect anything, use the existing hooks. Yes, the work you are describing is exactly what I envisioned. It seemed like a high level of effort to me, though. Replacing every instance of a GIL release followed by a blocking IO system call with a GIL release followed by registering the IO call with a green scheduler is a big change set, and would undoubtedly take a long time to debug and perfect. Programming languages can't really afford to ship with showstopping bugs, so what seems like a straightforward task might be painstaking and tedious when you've got hundreds of thousands of users impacted by a mistake. Also, when you say thread group, do you mean ruby's ThreadGroup class? I read through it's documentation when I was writing my actor library, but didn't notice it had any special ramifications. Thanks for the discussion.
Yes, it will block that web worker from doing the other work, but the web server itself should still be able to serve new requests, provided that there are available workers, right? At least that was the result when from my testing with Puma. But, I agree that it's not scalable, it's a pretty easy DoS attack vector. One of my projects ‚Äì [tus-ruby-server](https://github.com/janko-m/tus-ruby-server) ‚Äì requires the underlying web server to support non-blocking streaming requests and responses in order to work properly (you can run it on regular web servers, but there are caveats). I knew that [Goliath](https://github.com/postrank-labs/goliath) supported non-blocking streaming (well, [*response* streaming was missing initially](https://github.com/postrank-labs/goliath/pull/343)), so I created [goliath-rack_proxy](https://github.com/janko-m/goliath-rack_proxy) to enable using Goliath just as a web server for a Rack app. Anyway, that was the easiest solution I knew at a time, but it took a lot of work. I'm not entirely happy with it, as Goliath adds a lot of web-framework stuff that I don't need, and requires some patching to work with Rack 2.x. I'm wondering whether I could achieve the same thing with Iodine/Agoo. Thanks to this blog post I know now that they both support response streaming, but it seems that at the moment it's either for SSE or WebSockets, and in my case tus-ruby-server is streaming files from AWS S3, so it's just regular HTTP response. I'm guessing Iodine/Agoo weren't meant for this use case, but just wanted to check.
It's not a stupid suggestion, unfortunately :p
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [socketry/falcon/.../**config.ru** (master ‚Üí c31424c)](https://github.com/socketry/falcon/blob/c31424cc9e3ad1b11997182f4c265210bc664911/examples/beer/config.ru) * [socketry/async-http/.../**writable.rb** (master ‚Üí ca655aa)](https://github.com/socketry/async-http/blob/ca655aa190ed7a89b601e267906359793271ec8a/lib/async/http/body/writable.rb) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dy9p3gb.)
I actually wanted to remove nginx and directly serve with `falcon` to minimise latency, so it does need to be able to stream static files efficiently :p
Ok, thanks for clarifying. &gt; Side-Note: if you're streaming static files, why not simply use a static file server (using an nginx proxy can help with that and iodine includes a static file server as well)? The main reason is that, while the files uploaded to that Rack app can be stored on disk, they can also be stored on AWS S3, Google Cloud Storage or other services (whichever storage the developers configures when starting the app). And the download endpoint also needs to check whether the file was fully uploaded. But wait, I could just have the download endpoint redirect to the Nginx/S3/GCS URL of the file. That sounds like it would make total sense. Goliath would still be useful for its request streaming support ‚Äì allowing interrupting the upload request at any point and have the Rack app still store file content that was sent until the interruption ‚Äì but at least this will remove the downloading responsibility from the Rack application.
check out dry-rb.org
I don't know Caddy, but looking at their page and their code only the binaries distributed from their site are commercially licensed. The code is Apache licenced, so you could compile it yourself, or very likely, find another precompiled distribution. 
Um... what is caddy?
For those too lazy to Duck/Google * [caddyserver.com](https://caddyserver.com/) : "Every site on HTTPS"; and * [their GitHub](https://github.com/mholt/caddy).
That‚Äôs awesome
Fork it and remove sponsor header?
Can't wait for a DOM API.
Maybe HTTP/2 will prevent me from using `sendfile`, but the X-Sendfile support will still work. When I'm done authoring HTTP/2 support the file will be automatic streamed piece by piece (similar to the way it's [currently performed](https://github.com/boazsegev/facil.io/blob/3f7734dfc378a748a54d4c6433820a5afb0aee91/lib/facil/core/sock.c#L405-L442) when `sendfile` is disabled for a connection or a system).
`splice`, as in the Linux system call? I don't know if it works with sockets, I think it's pipe specific. Also, it would prevent the code from running on BSD systems or mac OS (I don't think they have an equivalent). Unless TLS/SSL moves into the OS layer and `sendfile` supports it, I think I will have to code a user-land streamer, but thanks for the thought.
I think some OS does support kernel level TLS. I remember reading about it.
\&gt; I think you're thinking in terms of network protocols, I'm not. This is all HTTP\-specific, which is application protocol and \(IMO\) shouldn't be too abstracted from the framework/application. \&gt; An application should never receive the h2c header... And what about the framework? And I don't mean the h2c case specifically, but a framework should be able to opt\-in when the case is websockets, right? \&gt; \(which, afaik doesn't exist\) TCP over HTTP is a niche case of the Upgrade header being used to establish TCP connections over port 80 \(there's also \`\` Upgrade: tls\` , for that matter\). Not important for this discussion, but let's assume, for the sake of argument, that the "application" being mediated through rack to the http server is a proxy and not CRUD\-rails. \&gt; The HTTP/1.1 Upgrade header has nothing to do with the rack.upgrade name... Naming things is hard :\) and from what I saw in the PR comments section, it's already misleading more people. My proposal comes below. Again, I'll rephrase: the proposal seems to be websockets first and sse sorta\-kinda. so why not go with "rack.websockets?" and "rack.websockets\_handler", and forget SSE for now? Specify the websockets handler API to fit the needs of that protocol, no need to hammer the edges to fit both cases just because they look similar. That'd be true \*\*S\*\*OLID. The main weakness of the proposal is rack itself, and us having to again forego OO to dump yet another object\-or\-proc in an env field, and the fact that rack in itself is kinda ossified \(for back\-compat, I know\), and we could just adopt some request\-response interface that has been working well so far for node or go. But that's not related to the PR, so don't get me wrong.
Yes. The JIT is part of the 3x3 initiative. To quote from the page: &gt; Note: The baseline for Ruby3x3 is 2.0 so all the improvements in 2.x will count toward the 3x goal.
One could argue that's TDD's most important value -- telling you that you're not ready to start programming, and to close your laptop lid and figure out what needs to be done with your team on a whiteboard or something. I sometimes do benefit from writing sketch code to help with design, but it's something I throwaway. A good example of this is breading new technical ground, like setting up postgres materialized views for the first time. Without exception, I find that the code that ensues from methodically building up design elements inside out is always superior in my experience. The time it takes to write code once I know what it's supposed to be always proves inconsequential, anyways. Just my experience with it. 
...with Shoes 3 being superseded by Shoes 4, and Shoes 4 being in construction and JRuby-only :)
Here is nice overview of most of options available: https://saveriomiroddi.github.io/An-overview-of-ruby-gui-development-in-2018/
I don't really understand the concerns (or rather single concern, on that thread), but I'm not really a systems programmer. Do you understand the concern?
The problem, is that if you call strdup, and then free on the returned pointer, you'll end up with a crash because the memory wasn't necessarily allocated by jemalloc. The problem is a bit messy as I read it. It looks like strdup isn't standard, so it's implementation varies. And that is an issue, it might directly call the system allocator, it might directly use glibc's allocator, etc. The reason jemalloc is fast/better is because it allocates chunks of memory at a time and reuses those chunks instead of talking to the system allocator. When you give it a pointer it didn't allocate, it doesn't know how to free (it doesn't know which memory chunk the pointer came from).
Would this also work on Macs? I read where it says Linux only but I know a lot of the stuff is the same between the two, or at least from a user‚Äôs perspective it is. 
Looks like it only covers the `ppoll()` case for now, so it depends if macOS has that. &gt; *all pthreads platforms should eventually benefit.* Covers anything Unixy at least.
Most of the time I see instance_eval is being used in gem DSL https://github.com/lassebunk/human_power/blob/master/lib/human_power/rails/controller.rb#L7 I would only use it with enough testing
Tbh, I'd use JavaFX with JRuby if I had to make a GUI application with Ruby. We do not have many good/updated GUI Libraries of our own.
My understanding: looks like the GC thread tries to wait until the GVL is available rather than forcing a context switch. This is useful in Unicorn and other single-threaded processes where you want to wait until the end of the request to GC but less useful in Puma where you might have 10-20 threads handling requests and fighting for the GVL.
I mean, sure, but OPs question is still quite valid, I think particularly if you are doing ETL processing or other long scripty tasks.
^The linked tweet was tweeted by [@keystonelemur](https://twitter.com/keystonelemur) on May 03, 2018 05:12:06 UTC (0 Retweets | 2 Favorites) ------------------------------------------------- Infix operators, duck typing, and eval are fun! (There be truly black magics here, this is just a teaser of the fun to come) [Attached photo](https://pbs.twimg.com/media/DcP2442VwAAVMva.png:orig) | [imgur Mirror](https://i.imgur.com/oOaYeu4.png) ------------------------------------------------- ^^‚Ä¢ Beep boop I'm a bot ‚Ä¢ Find out more about me at /r/tweettranscriberbot/ ‚Ä¢
Now we're really getting into some black magic territory. More of I can't believe I got that to actually work properly than anything. Working on some testing and codifying on it before I shove it on Github, but the super hacky 0.0.1 is out there in the wild. Careful, it might eat your code.
It should. Any modern POSIX system would have it, including MacOS, but probably not things like Solaris.
Thanks. I really like an idea and already updated the post to reflect it.
 (1..100).map do |m| case 0 when m % 15 then 'FizzBuzz' when m % 3 then 'Fizz' when m % 5 then 'Buzz' else m end end 
Meanwhile, check out Ferro: https://easydatawarehousing.github.io/ferro/introduction/
hey, hello. sorry for the long response. I added FAQ and answered to your question: [https://blog.davydovanton.com/kan/faq](https://blog.davydovanton.com/kan/faq)
I'm using rvm, but the system Ruby has the same issue.
There's no reason to believe it's an issue with my DNS. Everything else works fine - it's just Ruby.
Well when I last had an issue like this, DNS was resolving an IPv6 address, however my ISP was not honoring any IPv6 traffic, and would cause about a 2minute timeout, until it would fail to an IPv4 address. 
Yeah, same. I just wanted to see if I could make it work more than anything. The fun part is not stealing equality and inequality ops for too long and wrecking === comparators. 
That's a shame. That 300 seconds seems too coincidental to be anything other than a timeout though, is that repeatable? You may need to break out gdb to delve deeper, but I can't help you with that.
It would be nice if they included the reasoning about the characters. What defines the non-ASCII 1827?
They're capital letters.
I'm not sure on details about upper case unicode, but i'd be interested to learn more. This writeup has a bit of info: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
This presentation is about to level up: https://confreaks.tv/videos/rubyconf2017-esoteric-obfuscated-artistic-programming-in-ruby
I found the curry method in ruby and thought it was SUPER interesting. I am not sure I would ever use it in production, but maybe it has its use cases?
Thanks!
I believe that's what Eric means when he talks about the optimized epoll with 0 timeout. All poll impls seem to optimize this case so it shouldn't have much overhead, i.e. little downside.
Using curry to set up configurable test expectations, which could be used like a function or passed partially-configured as a block. Haven't decided if it's a good idea yet. Normal use: check_for[:health, person] As block: [person1, person2].each(&amp;check_for[:sickness])
The unicode character database and the properties included for each codepoint, presumably. 
&gt; Unicode Character Database Ah yes, let me just peruse this 110MB PDF and glean the pattern. ;)
I don't know how to interpret it either. But I don't think there's any pattern. It's literally just that some codepoints are marked uppercase. Human languages, they are amazing! If you want to know how to know whether a given char is marked uppercase in the UCD or not, I think the twitter_cldr gem might be able to tell you, it does a lot of stuff with exposing data from the UCD as well as the CLDR (Unicode Common Locale Data Repository). Unicode is actually pretty amazing. 
Looking forward to the font issues ‚ñØ‚ñØ‚ñØ‚ñØ.‚ñØ‚ñØ‚ñØ(‚ñØ‚ñØ‚ñØ‚ñØ)
Breaking your mind*** wow that‚Äôs embarrassing :)
reporting in from attempting at work... saw 3x memory reduction with about 10% improved speed :) nice article!
Constant lookup works lexically, and only in places named by a `class` or `module` keyword\*: ``` class Outer module Inner1 puts "Inner1: #{Module.nesting}" end Inner2 = Module.new do puts "Inner2: #{Module.nesting}" end module Inner2::AnotherLevel puts "AnotherLevel: #{Module.nesting}" end end ``` \* Plus their inheritance hierarchy
So then it's cool if I use real Greek letters for trigonometric functions, and I'll not need to write *theta*, when I mean Œ∏ ? I posted about this here a few years ago and was told that though Unicode variables are possible, it would be frowned upon. These rules for class names imply that sticking to Latin1 is an unnecessary stricture.
So it really is tied to just those keywords. Interesting. It seems like it's one thing to know that lookup works lexically, but it's another thing entirely to fully realize what that means. Thanks for the example. That helped a lot.
Playing with your example... class Outer module Inner1 puts "Inner1: #{Module.nesting}" end Inner2 = Module.new do CONST = 5 puts "Inner2: #{Module.nesting}" end module Inner2::AnotherLevel puts "AnotherLevel: #{Module.nesting}" end puts "Outer: #{Module.constants.include?(:CONST)}" puts "CONST = #{CONST}" end ...which yields ... Outer: true CONST = 5 So constants really are only defined on "proper" modules, not modules constructed programmatically. Interesting. Then doing `Outer::Inner2.const_set(:FOO, 3)` sets the constant on Inner2, but not Outer. &gt;&gt; Outer::Inner2::FOO 3 &gt;&gt; Outer::FOO Traceback (most recent call last): 2: from /Users/bfoz/.rvm/rubies/ruby-2.5.0/bin/irb:11:in `&lt;main&gt;' 1: from (irb):25 NameError (uninitialized constant Outer::FOO) Very interesting. 
True story: my iPhone chose to crash rather than render this webpage. 
What?
Btw, here's how to look up case with [twitter_cldr](https://github.com/twitter/twitter-cldr-rb) gem, which is focused on locale internationalization of all sorts of stuff, but also provides the UCD and ruby API to access it. TwitterCldr::Shared::CodePoint.get("√Å".codepoints.first). properties.general_category # =&gt; #&lt;Set: {"Lu", "L"}&gt; "Lu" is the category for "Letter, uppercase". I guess "L" means "Letter" generally, although it's not listed in the valid values on the wikipedia page: https://en.wikipedia.org/wiki/Unicode_character_property#General_Category 
Do you know if it could be used with Sequel models too?
Its a good summary. I worked with QT a few years back and its a real pity that the bindings have stalled (its very good). 
This is neat, though I wonder if it's all that common to find practical uses. I did have a bit of a laugh during the introduction (not at the author's expense or anything): &gt; This is an extremely powerful concept in javascript and other functional languages. With currying, you can pass around a pre-loaded function, do some computation, and call that function with another arg that you've created. I was thinking: "Classes. He's talking about classes."
constant lookup is WEIRD in ruby, I've never understood it. _And_ [changed slightly in ruby 2.5](https://blog.bigbinary.com/2017/10/18/ruby-2.5-has-removed-top-level-constant-lookup.html). I don't have an answer to your question, but I try to avoid relying on constant lookup rules. 
There are trade offs. Rails allowed them to get to market as soon as a possible and make quicker changes early on. Surely that had to contribute to their success. 
It is rarely the frameworks fault. It is what you do with it. Also I thought they abandoned rails almost right away because Twitter scale is actually ridiculous and they needed something that could handle the volume better. 
I hope DHH goes to town on this bitch.
&gt; Twitter‚Äôs backend was initially built on Ruby on Rails, a rudimentary web-application framework that made it nearly impossible to find a technical solution to the harassment problem. LOL
I don't see how building a moderation system has anything to do with which web framework you're using. I would imagine that most of the business logic for a moderation system wouldn't be related to web at all, so it wouldn't be written in Rails, but rather in Ruby or another language. But it sounds to me that by "Ruby on Rails" they probably meant "Ruby". I just always get confused when people use Rails and Ruby as synonyms.
Hard to say, though. Maybe Rails saved them six months of initial implementation effort. Would their market opportunity close in that time? Would their runway expire? The prevailing attitude of "startups have to get to market as soon as possible, no matter what" doesn't seem to be based on any evidence or analysis. It seems much more like doctrine that everyone sort of just accepts without ever questioning.
Twitter needed queues, but it used an ORM instead thanks to relying on Rails. There is a clear mismatch there, and I don't really buy that they had a viable path to scaling on top of Rails. That said, I agree with the overall sentiment that Twitter's architectural choices were _theirs_ to own. Blaming a framework just makes them look like they aren't in control of their systems. It honestly makes them look not only inept but unprofessional.
I like the implication that there's a possible technical solution to the harassment problem. There are "solutions" but they all suck.
Well it‚Äôs a fact that more startups fail than succeed, so spending time early on scalable infra is a complete misappropriation of time, although it‚Äôs an engineers wet dream. Do things that don‚Äôt scale until you find product market fit. 
My point isn't that startups should build web scale infrastructure from the get go. I don't think they should, and I don't think engineers would particularly enjoy it if they were asked to. Large scale infrastructure might seem "fun," but it's not as "fun" to most programmers as delivering features. &gt; Do things that don‚Äôt scale until you find product market fit. There's a middle ground: choose an architectural style -- and build a team with the requisite skill -- that allows your organization to exploit the opportunities present at early stages of company growth, without having to rewrite everything 6-18 months later. Sure, most startups fail, but we shouldn't succumb to survivor bias. A lot more companies _could_ succeed than do. I know that every single company I worked at that featured a giant "majestic" monolith as its centerpiece stood a far greater chance at success with a better software implementation. It takes a measure of success to even have enough runway to make a huge mess. IME, most startups that end up there simply don't have the means to get over this hump. Twitter was an exception.
All it means is that the writer does not know what she's talking about.
So what should github say? Did they won the internet war with RoR? What about Airbnb? Or Square? 
I will check this
The `&lt;center&gt;` cannot hold. It is too late.
I like it, but count 2 lines.
You're not wrong, but Github has different architectural needs. First and foremost, they enjoy a revenue model that (I would imagine) allows them to spend much more per user on infrastructure. And, I don't think that they _just_ have Rails. As I understand it, they've evolved quite a bit over the years even though their Rails app is still a centerpiece. It wouldn't be surprising to find that they've heavily streamlined the most critical bottlenecks with custom implementations and infrastructure. Which sounds a lot more attainable than trying to "scale Rails" as the person I responded to suggested.
Yes!
I'm a big fan of FP and learning it has made me a much better OO developer, but FP _in Ruby_ does not sound like a good idea to me. The language just doesn't support key functional patterns (such as functions) and is not designed for it. The idea of creating an intro to functional principles for Ruby developers is great though, so maybe I've misunderstood what you're suggesting.
Module in Ruby also has #module_function, which "Creates functions for the named methods": https://ruby-doc.org/core/Module.html#method-i-module_function Ruby has composable functions, whatever you want to call them. Methods and Procs can be curried, etc.
ty!
Yeah, gotta love everyone blaming technology and this invention of "fake news". At the end of the day it's all people problems and society has failed generally at this point and thus where we are now. Now where'd that power button go.....
I'm, uh, aware of that fact. I've watched too many startups dump obscene amounts of money into extremely underengineered monstrosities. They are penny wise, pound foolish, as the saying goes. It's a cultural thing, not a financial thing.
Thank you! I'm actually spending more time with Ruby and Chef so this is super helpful. 
I would definitely be interested in reading more on these topics. I'm particularly interested in the third bullet point, as I've started to go down a similar route myself.
happy to help
 happy to help you
awesome!
Interesting points. I should distinguish between rails as an application framework and rails as a web framework. The web framework side of Rails is a well greased groove at this point. I'd expect it to be reasonably well architected. The application framework side features a forms-over-http ORM which is never going to be as valuable to someone like Twitter as queues. "Hydrating" models, including the relational association graph, plus applying changes and validating, then saving by issuing SQL queries in a transaction has its limits. Which isn't to say it's inherently wrong, but it requires a large amount of computational work just to update an entity. As you mentioned, Github doesn't just have an ORM behind the scenes. I'm sure they use one for things like project settings and account profiles, but likely not for their primary use cases.
Makes sense. As far as the OP, can we both agree that a choice to use Rails has probably very little to do with "nearly impossible to find a technical solution to the harassment problem." :)
Agreed, the article just deals with a very low hanging fruit that I see every day. Where you get into trouble is when you have way more joins than that, and subqueries, searches, and everything else.
(I also am not sure why it is reasonable to allow some of these choices, eg ‚í∂,‚í∑,‚í∏,‚íπ, or roman numerals, as initial letter in class names!)
More details on the numbers, as of Unicode 10: There are 1702 characters with Lu category: `(0..0x10FFFF).count{|ord| chr = [ord].pack("U") rescue nil; chr &amp;&amp; chr.valid_encoding? &amp;&amp; chr =~ /\p{Lu}/} #=&gt; 1702` There is another Unicode property called "Other_Uppercase": 2160..216F ; Other_Uppercase # Nl [16] ROMAN NUMERAL ONE..ROMAN NUMERAL ONE THOUSAND 24B6..24CF ; Other_Uppercase # So [26] CIRCLED LATIN CAPITAL LETTER A..CIRCLED LATIN CAPITAL LETTER Z 1F130..1F149 ; Other_Uppercase # So [26] SQUARED LATIN CAPITAL LETTER A..SQUARED LATIN CAPITAL LETTER Z 1F150..1F169 ; Other_Uppercase # So [26] NEGATIVE CIRCLED LATIN CAPITAL LETTER A..NEGATIVE CIRCLED LATIN CAPITAL LETTER Z 1F170..1F189 ; Other_Uppercase # So [26] NEGATIVE SQUARED LATIN CAPITAL LETTER A..NEGATIVE SQUARED LATIN CAPITAL LETTER Z You can test for all uppercased with `\p{Upper}`: `(0..0x10FFFF).count{|ord| chr = [ord].pack("U") rescue nil; chr &amp;&amp; chr.valid_encoding? &amp;&amp; chr =~ /\p{Upper}/} =&gt; 1822`
I got curious and did some more investigation and posted it [over here](https://www.reddit.com/r/ruby/comments/8h8518/investigating_chars_in_list_of_allowed_new/). 
&gt; Methods [..] can be curried, etc. Except for `new`, unfortunately (its arity is `-1`). This makes patterns like `Vector &lt;$&gt; parseX &lt;*&gt; parseY` impossible to express without overriding `new`. 
Metaprogramming is primarily useful in library building, less so in immediate application code. In Ruby you can nearly always take multiple paths to achieve the same ends, but sometimes you want to use metaprogramming for semantic and design reasons. For example, I'm working on a Sinatra GraphQL API right now where my queries must be handled by resolvers that return a ternary lambda. I've chosen to group my resolvers by domain into classes, but I didn't want my resolver methods to actually literally return a lambda, mostly for style reasons and because it felt too easy to break. I also like the idea of there being, within my resolver classes themselves, semantic separation between resolver methods and helpers. So in my `BaseResolver` class I did a little metaprogramming to allow this semantic separation. class BaseResolver def self.define_resolver(name, &amp;block) define_singleton_method name, -&gt; { -&gt;(opt, args, ctx) { block.call(opt, args, ctx) } } end end Which allows me to write my resolvers as such... class ResourceResolver &lt; BaseResolver define_resolver :all_resources do |opts, args, context| ... resolution logic ... end define_resolver :resource do |opts, args, context| ... resolution logic ... end class &lt;&lt; self def helper_method ... other logic ... end end end This also gives me a level of abstraction between my resolver definitions and their implementations. For example, right now I don't want my resolvers to be stateful (beyond the local lexical scope). If I change my mind, I can reimplement `self.define_resolver` to define a class method and an instance method and have the class method instantiate and call, for example: ... def self.define_resolver(name, &amp;block) define_singleton_method name, -&gt; { self.new.send name } define_method name, -&gt; { ... maybe I want to do some stateful tracking here ... -&gt; (opts, args, ctx) { block.call(opts.args.ctx) } } end ... And there will be zero change in my clients. It's definitely up to you. There's almost never a real need to metaprogram in application development, and you can make arguments about the need to do so even in library development (although it's definitely got broader usecases there). The vast majority of the folks I've worked with have never used Ruby's metaprogramming beyond dynamic function calls. And it's super easy to get carried away with metaprogramming and make it so that nobody else on your team has any idea what in the hell is going on anymore. 
There‚Äôs more to it. The key is in the word ‚Äúmeta‚Äù. If you need a method, yes you just define it. Example of cases where metaprogramming can help: - how would you add a method to all classes in a hierarchy? - how would you know how many times a method was called or how would you intercept a call to a specific object - how would you implement an object that has dynamic properties? - how would you write a dsl? You don‚Äôt really need to use metaprogramming if you don‚Äôt want to. I think about it as another layer that can be really powerful when done correctly in the right setting or can spell disaster when done for the sale of doing it. 
Here is an example of how you might use method missing. ``` # farm.rb # class Farm attr_reader :animals def initialize(animals: {}) @animals = animals end def get_animal_count(species) return @animals.fetch(species.to_sym,0) end def method_missing(name, *args) animal_match = name.match(/\A(\w+)_count\Z/) if animal_match animal_name = animal_match[1] return get_animal_count(animal_name.to_sym) else return 0 end end end `` ``` &gt;&gt; require_relative './farm' =&gt; true &gt;&gt; farm = Farm.new(animals: {chicken: 4, cow: 1, goat: 5}) =&gt; #&lt;Farm:0x00007fc49c82d0f8 @animals={:chicken=&gt;4, :cow=&gt;1, :goat=&gt;5}&gt; &gt;&gt; farm.chicken_count =&gt; 4 &gt;&gt; farm.cow_count =&gt; 1 &gt;&gt; farm.goat_count =&gt; 5 &gt;&gt; farm.pig_count =&gt; 0 ``` 
Thank you so much!
Convenience. Consider the following code without metaprogramming: class Handler def handle(message) case message.type when SomeMessage # ... when OtherMessage # ... end end end Now, with metaprogramming: class Handler handle SomeMessage do |msg| # ... end handle OtherMessage do |msg| # ... end end
Back when ActiveRecord spammed objects with find_by_#{attribute_name} functions (find_by_id(), find_by_name(), etc), it build these functions by reading the list of database columns and building function names dynamically with define_method()
To make your data sore immutable you add (crypto) hashes. That's just another column in your database table. Let's call the column hash :-). If you're interested in learning more about blockchain - may I highlight the free booklet titled "[Programming Blockchains Step-by-Step book / guide. Let's build blockchains from scratch (zero) step by step. Let's start with crypto hashes...](https://github.com/openblockchains/programming-blockchains-step-by-step)". Happy blockchaining with ruby. Cheers. Prost.
Here's a metaprogramming example from ActiveContract: If you have a table (mapping) you want to allow easy array-like access, thus, lets build a helper class: class BalanceMapping def initialize( **params ) @params = params end def [](key) ## e.g. find by addr:,key: Balance.find_or_initialize_by( @params.merge( key: key ) ) end end ## class BalanceMapping Now if you have many tables / mappings it gets verbose to hand code, thus, let use a meta-programming macro: BalanceMapping = Mapping.create( Balance, :key ) # or even nested AllowanceMapping = Mapping.create( Mapping.create( Allowance, :key2 ), :key1 ) That's way shorter. And the magic metaprogramming code is: class Mapping def self.create( klass, k ) Class.new do define_method :initialize do |params| @params = params end define_method :'[]' do |key| ## e.g. find by addr:,key: if klass.respond_to? :find_or_initialize_by ## assume ActiveRecord klass.find_or_initialize_by( @params.merge( k =&gt; key ) ) else ## note: allow "nested" mappings; assume "nested" mapping klass.new( @params.merge( k =&gt; key ) ) end end end end end # class Mapping See the source @ &lt;https://github.com/openblockchains/universum-contracts/blob/master/sandbox/mapping.rb&gt;
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [openblockchains/universum-contracts/.../**mapping.rb** (master ‚Üí e2ddf1f)](https://github.com/openblockchains/universum-contracts/blob/e2ddf1f88d97bf6e798060d25e7b555ead203515/sandbox/mapping.rb) ---- 
No worries. A blockchain at it most basic is (just) 1) a data structure, the next level is 2) a distributed database and the next is 3) a network. For the decentralized nature everyone (node) has a copy / clone of the same database (same transaction / block records). It's just data. The posting was about (smart) contract (scripts you run to change the world state from A to B - in this case the "state transition" gets recorded as SQL statements and the storage was for the (private) contract storage. Anyways, all I'm trying to say it's just code and data. No magic and you can use ruby (even for building the latest and greatest world computer 2.0 from scratch).
I find metaprogramming to be super useful in client projects when I know that methods will follow the same format, but with 1 key change. Say you want to enumerate through a series of filters, and you want to apply it to an array, instead of doing something like: ``` def short arr.select(&amp;:short_filter) end def long arr.select(&amp;:long_filter) end ``` You can simply use metaprogramming to enumerate the list of functions you're going to have since they all follow the same format. The downside is it's harder to grep for, so make sure you include comments to allow for searching by function name.
I count 6! 2 in Gemfile, 2 in application.js, 1 in controller, 1 in view. 
Just because you can, doesn't mean you should.
very nice. nope not open source, but might be in the near future. 
This is perfect thank you !
Just one example; I often do something similar like the following to keep things DRY: class Foo VALID_STATES = %i[ not_started trial expired active canceled ].freeze def initialize(state) @state = state end VALID_STATES.each do |state| define_method("#{state}?") do @state.to_sym == state end end end
With the addition of this feature, Rubyists in various languages can use their own alphabet for the first character of a Class or Module.
If you created one article in April and five in May then you should have such hash
Of course anyone can migrate off of a bottleneck. That's what Twitter ended up doing.
There are so many possible answers to your question that it's hard to answer it. The Forwardable library is in Ruby's standard library and provides convenient methods that allow you to do things like delegate [:street, :state, :country] =&gt; :address Maybe that's useful to you. Maybe you'd rather write out def street address.street end But what happens if street isn't present, maybe you need a nil check... def street address.street if address end ActiveSupport provides a delegation library that allows you to return nil if the other object is missing delegate :street, :city, :state, to: :address, allow_nil: true Maybe you want that. Or maybe you want your own thing. Perhaps you might get a value from one object if that object is present or otherwise return a value from another object. Metaprogramming can allow you to write the code you want. It can allow you to provide a declarative interface that takes all the boilerplate away and let's you focus on the substance of what you really want to read in your code. Rails has many examples of this like declaring `has_many :widgets` I wrote about the Forwardable library here https://www.saturnflyer.com/blog/ruby-forwardable-deep-dive and I think it's a great library to use to get a better understanding of applicable meta programming (although the code has become a bit more complex since I wrote that https://github.com/ruby/ruby/blob/d32763eca0817c92ee0451ee6e08576879317e22/lib/forwardable.rb#L192). I wrote about getting info from one object if it's present or fallback to another source here https://www.saturnflyer.com/blog/easy-metaprogramming-for-making-your-code-habitable Sometimes metaprogramming is useful, sometimes it just makes indirection, but it all depends on what you want to do.
In the gem I developed for musical theory (coltrane), I have a Chord class. I want to be able to do: ``` Chord.new(name: 'CM7').has_minor_third? #=&gt; false ``` There are 15 types of interval in my library. I don't wanna clutter my code with 15 repetitive methods. I rather loop through all intervals defining methods programatically. Ruby is about writing code as close to natural language as possible. If we choose Ruby, it's coherent to sometimes give up on standards, performance, etc, in the name of expressiveness. Else, we would just be using a faster and more popular language.
I think ruby gets pretty carried away with the "domain-specific language" idea, some of which makes metaprogramming necessary or at least tempting. Take this dummy code: class ThingCollection def self.thing(name, fancy_option=:nah) deets = complex_logic(fancy_option) all_of_the_things &lt;&lt; Thing.new(name, deets) end # ... More methods to support #thing. def show_and_tell all_of_the_things.each { |t| puts t } end end # Usage class MyThings &lt; ThingCollection thing 'TV' thing 'Reddit' thing 'Plumbus', :schleem end It is nice that MyClass doesn't have to worry about #complex_logic or Thing#new. However, now that we're hiding how the things are managed, it would be weird to expect MyClass to inspect all_of_the_things directly. So we go and add #show_and_tell and release V2.1 gem. Then we realize we want the handy #repurpose method, but only for things that use :schleem. We could define this method on every ThingCollection, but then we would need to raise a UselessMethodError for non-schleemy things. Perhaps we should step back and reevaluate our inheritance model- woops, while that discussion was going on we resolved a github issue by merging a PR that uses #define_method. Oh well, that'll look good in the V2.4 "Juicy July" changelog.
Do you use Sequel with Rails or without?
I think your example is missing
You just skip those gems indicated as being for production only.
In certain applications, there are gems that you want your production environment to load and other gems that you don't. One good example are unit tests \(like rspec\). Your production environment shouldn't be running unit tests, it should be handling web requests, doing background work, etc. Bundler makes it easy to exclude installing certain categories of dependencies if you don't need them. Environment\-specific gems are defined in a block within the Gemfile like so: `group :production do` `gem 'foo_gem'` `gem 'bar_gem'` `end` So if this block were defined in your Gemfile and you ran your command, every gem except 'foo\_gem' and 'bar\_gem' would be installed. Make sense?
Because its easier to have one code base you work on for each project. This option let's you exclude things like unit tests, which are not run on production systems, while still being able to test the exact same code on your dev systems. Think things like linters/tests/etc. Why maintain two separate gemfiles when you could instead have one file per project that just uses different gems based on your needs?
ok that makes sense Thanks!
&gt;happy to help you
Your Welcome
 happy to help you 