That's pretty cool, you inspired me to scrape around in MacRuby; Still waiting for [MacRuby: The Definitive Guide by Matt Aimonetti](http://oreilly.com/catalog/0636920000723), the early release is [out](http://ofps.oreilly.com/titles/9781449380373/index.html) I coded up a simple status bar app: [macruby hello-appbar.rb](https://github.com/RobertLowe/hello-appbar/blob/master/hello-appbar.rb) 
That's kind of what I meant... I've been designing/coding professionally for many a year now, but my next project is in ruby, and I know it not at all, so I was trying to get something whereby you can learn language specifics or common pitfalls, but in a fun way.
This seems like it could be interesting. Thanks =D
fun is for women and children, and homosexualists.
No. Next question? 
Nyet.
No it shouldn't. The following code would suddenly become impossible (or, at best, unbearably ugly): mylist.grep do |item| item =~ /foo/ end.map do |item| item.upcase end And that's why Python's mandatory-whitespace-for-syntactical-scope sucks too. And that's why the "end" keyword is a thing of beauty, not an ugly wart.
I like it. A lot.
Project Euler.
If so, Ruby would reach perfection.
that guy's `parse_new_attributes` method is a pig, way too long, and breaking so many rules of good design. A guy who writes a method like that im not sure i trust their opinion at all.
Breaking all existing code in random and exciting fashions seems like a good deal. 
No.
TIL you can call methods on end (I just hack on ruby for fun). Thanks for this example!
It's the rubygems way!
Well if it ever does get significant whitespace Python style, it had better be optional.
In this example it's calling methods on Arrays. 
Fuck no!
You mean the author of haml? https://github.com/drnic/haml/blob/master/lib/haml/precompiler.rb Edit: Or the guy who contributed it and the bunch of funky peeps who work on haml. :)
If it does, I switch to another language. Significant whitespace in Python is a major reason I ended up with Ruby instead. 
https://github.com/michaeledgar/seamless ?
Why not support both? Since the "end.map" usage is rather rare (compared to other code), just make it so "end" isn't required by default, but if it's there, use it the same way as it's used now.
No. What this does is force consistency across editors, which is a ludicrous thing to build into a scripting language. One of the worst things about python. Now, for haml, I think it's OK because it is consistent with the language's goal of minimalism. Also, I've come to accept it because haml is fucking awesome. 
Look at these comments, so much hate for an idea. Sheesh. I think, if it were an option (like maybe `#!/usr/bin/env ruby --whitespace-panic`), I would enjoy it thoroughly. Every time I write more than 40 lines of Ruby, or, a real app, I look back at my code and think "God damn is this code ugly." I follow all the Ruby style guidelines, and then I refactor things to look prettier and more word-y rather than symbol-y, and it still looks wrong. Looking at the example shown, I realize that dropping `end end end` makes things just so much cleaner. You can argue about the technical aspect of whitespace sensitivity, but from the standpoint of readability, it's a major improvement.
Just do the python challenges in Ruby, most of the python challenges seem kinda language agnostic anyway (well, except one that uses pickle) 
I have no strong feelings about significant whitespace versus explicit "end". But I've always found it funny that Ruby and Python seem to have themselves completely backwards on this issue. Python, with its "explicit is better than implicit" philosophy, seems to be the language that would want the explicit "end". Ruby, being a language chock full of new and different ideas about code style, seems to be the language that would be more likely to do something as unusual as significant whitespace. I write more Ruby than Python so I'm more comfortable with "end", and I definitely wouldn't advocate making such a fundamental language change for a questionable benefit. *edit: fixed my last two paragraphs being out of order*
I'd rather see mandatory brackets for single-line blocks and anything calling a method on the block return. i.e. collection.map {|x| x.foo } or collection.map {|x| x.foo }.flatten Anything with a `do` could use whitespace, and if you don't like whitespace, just don't use `do` blocks. On the other hand, I also think that system constructs should use blocks, too. So maybe I'm insane. if(x) do some_method end
Yay more architecture dependent libraries needed. As a ruby package maintainer, this kind of sucks.
No. Why would this be a good thing at all? He makes the argument that your code will look marginally cleaner, but at what cost? Sure, 99% of all the code you write won't need to break these simple significant whitespace rules, but Ruby has always been flexible enough syntax-wise to allow you to break the conventions when needed. Not being able to do that will just be a pain in the ass for no real benefit. Though I will say that significant whitespace works well in something like HAML. Your only task in HAML is to produce an HTML hierarchy, significant whitespace and HAML/HTML just fit nicely together.
Go use python. 
With my limited experience with Python (one uni course): - Two spaces vs Tab in different editors was a nightmare. Especially when copying code snippets from the internet and having to convert their indentation style to match mine. A rogue tab indentation somewhere in the program would prevent the entire script from executing. - Tracking which level of indentation I was in could be unwieldy at times, especially for nested conditions. I liked the significant whitespace until I started using it. Now I love my *end*s. Let Ruby and Python have their differences.
I don't just dislike significant whitespace, but I consider it to be absolutely wrong. Awful idea.
Syntactically it's a method attached to an "end". Semantically it's a method called on an array.
You know what you'd *really* love? A good editor.
The correct answer is "Read *Eloquent Ruby*", as I am now. Cleared up a few style complaints I had, and things I was doing wrong. Like, I was skipping parenthesis on everything possible, which was the wrong approach in terms of true readability/grep'ability.
One thing to consider with Ruby is what is returned. Methods, functions, everything, will return a value. When everything returns something, and everything returned will be an object, chaining methods together becomes possible. The `.grep` method returns an `Array` object, exactly the same as any other `Array`, so you can treat it like any other `Array`, including calling `map` on it. For example, we're all familiar with chained methods like this: [1, 2, 2, 3, 4].uniq.reverse But methods that take blocks also return after they've finished, so: [1, 2, 2, 3, 4].uniq.map{|i| i*2 }.reverse Conditionals also return a value (even it it's `nil`), so: if x &lt; 5 "small" else "large" end.reverse Etcetera. It's a fun language.
Sure, but I'd rather be able to depend on basic editors like Gedit and Notepad++.
Hmm, I've had plenty of experience with TextMate where it fails at converting copied text into the correct indentation. I thought TextMate was a good editor.
Agreed. I initially dropped all parentheses unless the interpreter absolutely needed them, but after using Ruby every day for years, I only drop them from method definitions if they don't take parameters. I tend to also put empty parentheses at the end of method calls, so show that I'm calling a method and not an attribute property, in case anyone has to come along and track down which bit of code it's executing. All-in-all, I'm relearning a love of parenthesis. But I *love* that when writing a DSL I can drop them.
Syntactically it's a method attached to a block, which is part of the previous method call. If it used { } instead of do end, it would be syntactically pretty much the same thing.
Yes, we will downvote you because we don't like that your opinion is different to ours! Edit: For the record, I think significant whitespace is an awful idea, I love HAML, but there are a lot of very good points made against it in these comments. I upvoted you anyway though because the downvotes you got were for a stupid reason.
Coming from Python and having been using Ruby seriously for the first time recently, Ruby's view of truth/falsiness is one of the things I've been surprised to be most annoyed by. I didn't realize it wasn't possible to override this behavior in Ruby. In Python you can just implement a magic method.
Ruby's view of truthiness is inherited from lisp. I think it's nice, it's what makes the `@x ||= initial_value` idiom possible. And although you can't redefine truthiness in Ruby, you can do some cute things with blocks https://github.com/banister/custom_boolean hehe
`x ||= default` baffles me. Since it's short for `x = x || default` that means it evaluates x even though it doesn't exist. Why is `x ||= default` better than/different from if `x is None: x = default` in Python? (besides the fact that you get to refer to a variable you never even initialized to None before).
_**File a Bug**_
It's actually short for `x || x = value`. 
`x ||= default` is shorter than `x = x || default` and makes the language consistent. If you're gonna have `x += value`, which means `x = x + value`, then why not have it for other operator like`-`, `*`, `/` `**`, `&amp;&amp;` and `||`? To follow Ruby's spirit, `x ||= v` makes the language more fun to use than `x = x || v`.
Ah, that makes sense. That's backwards from how those operators usually work! x += 1 is x = x + 1 x ||= 1 is x || x = 1 Now how is that particularly dependent on Ruby's notion of truthiness? Edit: wait, either way you interpret ||= it depends on x being evaluated for its truthiness before it exists, no? And either interpretation of ||= would have the same result... or am I tired?
It must be short for `x = x || default`: &gt;&gt; $ irb &gt;&gt; x || x = 5 NameError: undefined local variable or method `x' for main:Object from (irb):1 &gt;&gt; x =&gt; nil &gt;&gt; x || x = 5 =&gt; 5 &gt;&gt; y = y || 7 =&gt; 7 And after you evaluate `x` once, even though it threw an exception, `x` becomes nil. Strange behavior...
I'm in the opposite opinion, I personally hate Python's true/false test. No, I don't hate Python, only its true/false testing. I think they are putting in the wrong concept for `truthiness` construct. They are pushing for `nonzero`. I want to test true/false, not nonzero. Python's test magic method is even called `__nonzero__` and `__len__`. What if I have something that should test to `false`, but it's not `zero` or `empty`? Sure Ruby can't do that, but if Python wanna go that route, it'd better be a sound concept. Having to say that something is `nonzero` or have `length` just so that it's considered `true` just feels wrong to me. Why can't I have `__bool__` method? And it's funny that this part of Python has more magic than Ruby.
The worst part of this is that it was ever necessary.
Whereas I, after three years using Ruby, now drop all non-required parentheses. I think it's important that no one should *care* whether it's a "regular" method or a getter.
I agree, this has not been a fun role for me to fill. But like anything else, whatever the original seeds of conflict were, the fans were flamed by misinformation and poor choices on both sides that caused things to come to a tipping point. This sort of situation can cause one bad decision to pave the way for the next. But now, things are cooling down again, or so I hope. It's only been a week or so and we've seen renewed commitments from the RubyGems maintainers that indicate that they do care about the community and that they're listening. The real measure of success will be whether in a couple weeks, I can forget all about this and leave my post as self-appointed mediator without things flaring up again or falling apart. I think I will be able to do that, but it's going to take everyone's help to make sure that happens.
They already [renamed `__nonzero__` to `__bool__`](http://docs.python.org/release/3.0.1/whatsnew/3.0.html#miscellaneous-other-changes) in Python 3 ;) &gt; What if I have something that should test to false, but it's not zero or empty? I agree, personally I'd have liked it if closed file handles / sockets / db connections etc. evaluated to False. &gt; And it's funny that this part of Python has more magic than Ruby. I dunno, especially since they renamed it `__bool__` it's explicitly equivalent to a "type cast", and is similar to `__int__`, `__str__` and so on.
I actually disagree with this, but I'm willing to be argued around. Not so much whether you use parens or not (it's up to the programmer), but the idea that no one should *care* whether it's a method or not. We're not talking about users of your code, because they don't generally interact with the code by digging into what you've written and seeing your code. Those people rightly should never be concerned about the abstractions used at all. We're actually talking about your *fellow maintainers* of the code, because they're the ones that will see it, and those people *will* care whether it's a method call or not, because it's highly relevant to them. I learnt to use parens in this way after maintaining someone else's large project that didn't use them, and realising it's actually pretty lousy for the next person.
why is it better than `if x is None: x = default` ?? because it's something typed so often, and is so ubiquitous that the shorter and sweeter the better. Typing `if x is None: x = default` could become frustrating and annoying very quickly, on the other hand `x ||= default` is short and sweet.
"It's shorter" wasn't an answer I was expecting. You wrote: &gt; Ruby's view of truthiness is inherited from lisp. I think it's nice, it's what makes the @x ||= initial_value idiom possible. I was asking how a simple "if nil then assign default" was dependent on a particular version of truthiness -- inherited from lisp, and so on[1]. Sorry if I wasn't clear. [1] ironically some versions of lisp *do* count the empty list as false, if the Internet is to be believed Edit: apparently the empty list and `nil` in lisp are equivalent. I guess Python is actually more lisp-y here in evaluating empty lists to false. Edit 2: as for `if foo is None: foo = default` being ubiquitous, the *only* time I remember ever typing that in Python is when I want a mutable default parameter and `def foo(default=[]): ...` bites you in Python so you use `def foo(default=None): ...` instead.
Can you summarize the situation? I've no idea what's going on...
Lots of drama was happening with RubyGems, last week I collected feedback from the community and then met with Eric+Ryan (the maintainers of RubyGems) to find some compromises. The one big item we *didn't* talk about was release management, so that's what I followed up with them on today. They more-or-less agreed to give the community what was asked for, as far as I can tell. (Or at least, the decisions made today will make the situation workable as time goes on) Full list of posts is at: http://blog.majesticseacreature.com/tag/rubygems (read from bottom up)
it's ubiquitous in Ruby; so in Ruby it's nice to have such a short-cut, it's an extremely common and convenient way to lazily initialize an instance variable. I don't know/care about python. I don't even know what you mean by: "I was asking how a simple "if nil then assign default" was dependent on a particular version of truthiness" is even asking. Simply because an empty list in Lisp is also falsy doesn't make Python more 'lispy' than Ruby. Indeed, Python doesn't even have native 'lists' (as in a linked-list not just an array called 'list'), and neither does Ruby. Perhaps if Ruby did have native lists an empty one would be falsy too, I don't know.
&gt;it depends on x being evaluated for its truthiness before it exists, no? What do you mean before it exists? It exists as soon as you name it, it's nil though.
When you say `y = y || 7`, `y` doesn't exist yet, yet you're able to say `y || 7`.
&gt; I don't even know what you mean by: "I was asking how a simple "if nil then assign default" was dependent on a particular version of truthiness" is even asking. You said: &gt; Ruby's view of truthiness is inherited from lisp. I think it's nice, it's what makes the @x ||= initial_value idiom possible. So I asked what Ruby's particular version of truthiness had to do with making that idiom possible. &gt; Simply because an empty list in Lisp is also falsy doesn't make Python more 'lispy' than Ruby. I said "more lisp-y here". I meant "in this case". I wasn't saying Python is overall "more lispy" than Ruby because of that one thing.
Local variables are created and assigned `nil` when they are first seen by the parser, and are accessible at any place lexically after that point (in scope, of course). y = y || 7 will work if y has not yet been assigned. irb &gt;&gt; y ||= 3 3 &gt;&gt; y 3
It's not surprising it took until Python 3 to rename it either, considering Python didn't even have `True` or `False` until what, 2.4? 2.5?
For the record, I did it for the bounty. I hope I can be forgiven.
I didn't say it doesn't exist yet. It exists, it's just nil (or undefined or whatever) but it does exist and it can be operated on.
x, the variable, would get 'evaluated for truthyness'. But checking if a variable is false or nil wouldn't be a big deal. It's the `default` that you'd want to make sure is short-circuted. The big reason `x || x = value` is nice is that if the short circuit happens, you skip an extra assignment.
ah ok. Yeah the Ruby idiom works because something is only true if it's not 'nil or false'; and in most instances 'false' isn't a valid value for the ivar, so we can take `x ||= default` to mean (generally) "only assign the default value if x is nil (unitialized). In python however, since `[]` is also 'falsy' such an idiom could not work as `[]` is a very common default value.
Well, the fact is that it *is* a method call, regardless of the parentheses. The only other thing is could be is a local variable, and the code in a method should never be so long or complicated as to make this unclear. I would suggest (without having seen it) that the large project you refer to was difficult to maintain for other reasons. I do still think that even a maintainer of your code shouldn't (in general) care whether a method is being called or not. The only times when this would be important is if there's a bug or a performance problem. And I would suggest that the pseudo-documentation of the empty parameter list would not be sufficient to make fixing those issues much easier. In the Ruby world, it's just very uncommon to use parentheses for empty parameter lists, so I suggest that's because the concern you address isn't generally such a big issue. But, clearly, you disagree - based on experience I haven't had.
... yet talking about it this way over and over doesn't really help move things forward.
There are some good discussions in the links to this (self-proclaimed) [definitive list of ||= (OR Equal) threads and pages](http://www.ruby-forum.com/topic/151660/).
Thanks! "`||=`" was kinda hard to google for :-|
There wasn't really anything to file a bug against, but I did comment on the original post. Also, I used it as an excuse to go look at the ruby code. Its all fixed now anway.
That is awesome!
this might be more appropriate in /r/circlejerk
Dude's code seems wrong. ruby-1.9.1-p378 :023 &gt; class NullObject ruby-1.9.1-p378 :024?&gt; def method_missing(*args,&amp;block) ruby-1.9.1-p378 :025?&gt; self ruby-1.9.1-p378 :026?&gt; end ruby-1.9.1-p378 :027?&gt; end =&gt; nil ruby-1.9.1-p378 :028 &gt; NullObject.new.foobar.baz.buz =&gt; #&lt;NullObject:0x000000017a6938&gt; That's a NullObject, not a nil. I see what he's getting at, but when the example is a lie, it's harder to understand how he gets to the punchline. 
I've found the 'pg' driver to be unacceptably slow, especially compared to either mysql or sqlite. Perhaps this was due to poor database optimization, but my test case involved a single (indexed) table and no joins. If anyone has any tips for improving pg performance in a development environment, I'd love to hear. (I don't have any real numbers anymore, but the difference was something like Item.all with 9000 rows taking 5-10 seconds with pg, and 100-200ms with mysql). I've read that it might have something to do with pgsql's slow row-counting, but it really seemed like the problem was in the pg driver. (ruby 100% cpu) I found the same across two different platforms, different versions of ruby, postgresql, and the pg driver. I'm actually just about to try it with the 3.1 RC. I've experienced seemingly unrelated [segfaults](http://redmine.ruby-lang.org/issues/4611) that mysteriously and reproducibly go away when removing the pg gem. ...and finally, WHY WOULD ANYONE USE HOMEBREW?! MacPorts is not difficult to use, keeps its shit out of your shit, and, most importantly, it ensures you will not be stuck sorting out issues caused by building against ancient system dependencies. It is a solution to a nonexistent problem, as far as I can tell...?
I used MacPorts for years, but I switched to Homebrew a year or so ago and haven't been disappointed. I got annoyed that MacPorts insisted on building a whole bunch of libraries that I already have -- especially when it would completely rebuild X11 stuff. I also like that Homebrew uses binaries for some big packages like GHC (which takes forever to build via MacPorts, but is a snap with Homebrew). I've also found it easier to make Homebrew use packages that I've compiled by hand. Finally, the fact that Homebrew is managed via Git is nice. I occasionally wanted to customize MacPorts' port definitions, but that's a pain because either (a) they get wiped out whenever you re-sync MacPorts, or (b) you have to maintain your own custom ports repository. Relatedly, it's a lot easier to pull out old versions of a formula in Homebrew, if you want to install something other than the latest version.
One better, welcome [mynu](https://github.com/robertlowe/mynu/)
slow row counting shouldn't cause that significant of a difference between pg and mysql (at least if you're using innodb). did you make any tuning-related config changes to pg? ianadba, but i've been told there are some settings that have been pessimized in the macports default install
Relevant!: [tenderlove on prepare statements in 3.1](http://www.youtube.com/watch?v=kWOAHIpmLAI&amp;feature=player_embedded#t=9m28) * [sqlite](http://www.youtube.com/watch?v=kWOAHIpmLAI&amp;feature=player_embedded#t=11m28) * [postgrel (performs well even with complex statements)](http://www.youtube.com/watch?v=kWOAHIpmLAI&amp;feature=player_embedded#t=12m42) * [mysql (not so awesome)](http://www.youtube.com/watch?v=kWOAHIpmLAI&amp;feature=player_embedded#t=13m28) Overall postgres is the best
The more I read from this guy, the more I want to read. Go Avdi!
Thanks for your response, I wasn't aware of a couple of the strengths you described. I appreciate that MacPorts is sometimes inefficient and slow, but ... you must realize how old some of the system libraries you are compiling against are? Would you use this in production? I still think that for anyone installing any non-trivial packages, MacPorts is the saner option.
I'm almost positive the issue is with the pg driver itself, and as I indicated, I was able to reproduce the slowness across multiple platforms/versions. &gt; i've been told there are some settings that have been pessimized in the macports default install I will look into this, thanks!
Thanks, I saw some notes about pg in 3.1 - hope to try it very soon! I'm sure lots of people are using it with 3.0 and older, but my test case was so simple and easy to reproduce, I'm not sure what to think...
Doesn't work outside of a bash environment.
Yeah, that was a plain-ole typo that someone else pointed out too. Guess I should really go fix it.
Ah, rockin, thanks for the update!
Jar Java? Meesa not understand sentence.
first.
What about it?
Before you make a decision for or against SlimGems, please be sure to check out my series on RubyGems, in particular note the following things that happened in the last week: * RubyGems now promises to stay API compatible with whatever version of gems ships with the latest point release of Ruby 1.9. That means if RubyGems 1.8 ships with Ruby 1.9.3, the RubyGems 1.8 API will be preserved at a minimum until Ruby 1.9.4 comes out, which will be no sooner than 6-18 months from now. * RubyGems has removed two deprecation warnings in 1.8.4 and 1.8.5 that account for virtually all deprecation warnings that were frustrating users. * Bundler works out of the box on RubyGems 1.8, as does Rails 3. The next point release of Rails 2.3 will also support RubyGems 1.8. Evan Phoenix is a maintainer of both RubyGems and Bundler, and is taking the responsibility of cutting stable releases of RubyGems for the time being, which nearly guarantees there will be no further Bundler issues. * Frequent point releases of RubyGems should hopefully be a thing of the past, because starting with RubyGems 1.9, there will be beta and release candidates running for a month long cycle before they get shipped as stable releases that get installed by gem update --system You can find additional information here: http://blog.majesticseacreature.com/tag/rubygems
ruby warrior is more on learning ai than ruby itself
Heroku is currently charging per dyno or per Thin instance. Running multiple Unicorn workers is essentially a way of "cheating" that system by getting more out of cheaper Heroku plans. This can't be the business model they've envisioned; it costs them more resources and more money if everybody does it this way. Does Heroku have an official stance on this?
why the downvotes? Gregory isn't trolling, he is adding to the conversation significantly. He has put a lot of work into fixing the rubygems situation, and so are the maintainers. EDIT: i'd just like to add that the community's time would be better spent supporting rubygems than fighting against it, especially when the maintainers are willing to listen.
Perhaps they're trying to become more competitive. Heroku before was rather expensive as soon as you outgrew your free Dyno. For $36, you can get a nice VPS with ~1GB RAM which would run tails around Heroku running two Thin processes (incl. the free one.) Personally I've migrated quite a few apps from Heroku to Linode as soon as things started to get slow…I'm sure quite a few others have too. And as soon as you've done the hard work of migrating away, it's not worth moving back when Linode is so competitive.
You mean this method is probably officially sanctioned by Heroku, on purpose, and not just a random hack by a random dude that may stop working at any time? I can't imagine this, a large part of their costs are from AWS fees. If they allow running 4 Unicorn workers that like they'll make a loss considering how much RAM it takes.
Maybe, they have a RAM and CPU cap, so it's not as if this is a way to get infinite resources. We'll have to wait and see what they say though, hopefully it's true.
It's almost as if software on different hardware under vastly different conditions may not act exactly the same at all times!
@seacreature is a great guy. Thanks for heading all this up and helping the community out so much.
Some corrections &gt; (1..1000).inject(:+) This is not Symbol#to_proc, inject merely accepts a Symbol. Symbol#to_proc looks like (1..1000).inject(&amp;:+) The former passes a Symbol to inject, the latter passes a Proc. &gt; Verify if tokens exist in a string Doing this in Ruby (using include?) is going to be a lot slower than doing it in the regex engine. &gt; Find minimum (or maximum) in a list Why would you not have a sorted list if you knew you were going to be finding maximums or minimums? This is the kind of snippet that you say "oh that's neat" but would never actually use.
I DON'T HAVE ANY FRIENDS TO IMPRESS. :'(
"Dramaqueen" has never had an antonym til now: "seacreature".
Dude I'll be your friend. Now impress away.
I'm gonna respond to all your response here with: Awesome. Thanks for reaching out to Reddit. I keep opening the app store in the hopes there will be a new version of this app available. :) *tries out bands mentioned*
&gt; Doing this in Ruby (using include?) is going to be a lot slower than doing it in the regex engine. I would have thought so too but... require 'benchmark' n = 50_000 words = ["scala", "akka", "play framework", "sbt", "typesafe"] tweet = "This is an example tweet talking about scala and sbt." Benchmark.bmbm do |b| b.report('include?:') do n.times do words.any? { |word| tweet.include?(word) } end end b.report('regex:') do n.times do words.any? { |word| tweet =~ /#{word}/ } end end end ... output ... user system total real include?: 0.050000 0.000000 0.050000 ( 0.053684) regex: 0.180000 0.010000 0.190000 ( 0.184905)
I don't have any friends that this would impress. :-(
Thank you! You are a gentleman and scholar. Array#grep is one of my favorite methods. It lets you "grep" for things: list = %w{ the quick brown fox jumped over something } list.grep(/^\w{3,4}$/) # =&gt; ["the", "fox", "over"] It calls === on the argument for comparisons. Calling === on a class object is the same as calling is_a?. I like to take advantage of that. For example, let's find only the strings from a list: list = [Object.new, 'hello', 'world', Object.new] list.grep(String) # =&gt; ["hello", "world"] grep also takes a block, so it can sort of act as a map too: list = [Object.new, 'hello', 'world', Object.new] list.grep(String) { |s| s.tr('l', 'x') } # =&gt; ["hexxo", "worxd"] I hope that is impressive enough! &lt;3 &lt;3 &lt;3 &lt;3 &lt;3
If you compare against a regex instead of a string compiled into a regex (on every iteration mind you) it comes out much more even: user system total real include?: 0.100000 0.000000 0.100000 ( 0.102281) regex: 0.100000 0.000000 0.100000 ( 0.100304) master regex: 0.030000 0.000000 0.030000 ( 0.021065) Only slightly better, negligible for sure. However, if you compile all the items into one regex, not surprisingly the result is *much* faster.
Man, you're the whole Ruby community's friend. 'Cept for them haters that don't like ALL CAPS AND JOKES.
&gt; require 'hpricot' My friends would not be impressed by that.
&gt; **Filter a list of numbers** &gt; `[49, 58, 76, 82, 88, 90].partition { |n| n &gt; 60 }` This is misleading, I think. It partitions the array based on the test in the block, so the array above becomes `[[76, 82, 88, 90], [49, 58]]`.
No, thank _you_ kind sir and colour me impressed. Go on, colour me. I &lt;3 Enumerable. Something cool in there every time I look. I didn't know how great `grep` was! My humble offering to the gallery is `each_with_object` with which can tidy up one's `injects`. It's Ruby 1.9 but it's been backported in ActiveSupport. So most folks will already know about I guess. %(ruby is really awesome).inject(Hash.new(0)) { |h, str| h[str.chars.first] += 1 h # must remember to return the memo (hash in this instance) } # using each_with_object %w(ruby is really awesome).each_with_object(Hash.new(0)) { |str, h| h[str.chars.first] += 1 } # woah no need for explicit return! Much neater imo, despite the ugly method name! EDIT remember the memo and args go in reverse order to inject! 
I tried refinery once and found it kind of lacking in features. For example you could not define content types to be put inside of pages. If I remember correctly (it's been a while) skyline let you do that. It's easy to use for a beginner but for a programmer I'd say it's not the best one.
Why I like Ruby so much, such one liners are not that exciting in a dynamic language. Dynamic typed languages have been known for their conciseness for a long time. What is impressive about Scala, is that it is statically typed yet concise as well.
Am I the only one unimpressed by these?
&gt; file_text = File.read("data.txt") How else can you do that?
open, read, close? As one would in C, etc.
this post is embarrassing, delete it.
Uh, **fluffer**? Is there a British meaning of that word that I am not aware of?
Yes, #select is a better choice.
In this case, I went with partition because it's closer to what the original in Scala did.
Would you mind posting the benchmark code?
Looking back at my changes to your code I realized that I made a mistake so you can disregard the "master regex:" line. Fixing the error caused the speed increase to go away. I have previously read that using "|" inside regexes is a lot slower but I was not expecting it to be 100% slower than simply comparing against each regex. For reference, the first master regex line was essentially doing: tweet =~ [/scala|akka|play framework|sbt|typesafe/] and the fixed version (much slower, doing a regex compare against an array apparently is really fast :P) was doing: tweet =~ /scala|akka|play framework|sbt|typesafe/
Are you unimpressed because you've used Ruby for so long that stuff like this is old hat, or because the language you prefer is also so tersely expressive, or because you don't think such capability is valuable, or because you are trolling? It's always good to post the reason's for one's opinion.
Soon :) We're just getting ready to submit 1.2 with a ton of small features and fixes.
i guess ruby's philosophy of "more than one way to do the same thing" should apply outside of ruby syntax too..
I made a lengthy reply about my thoughts on this matter on both Hacker News (http://news.ycombinator.com/item?id=2617881) and in a comment on the original thread. I'm not going to repeat it here because I want to bow out of this conversation and focus on coding and behind the scenes way of helping solve this problem, but since I've talked with dozens of people about this since I got involved, I figured maybe it's worth sharing my perspective.
No, I think they mean exactly what you're thinking of. It is The Register after all.
Are you asking, or did you forget to link it?
I liked Array#grep before. Now I love it. I had no idea you could do all of that.
I was really into Haml for a short time. But a lot of the savings in time spent writing HTML can be had at the editor level. With Vim and plugins like snipmate and Zen Coding or sparkup, you can generate big swaths of HTML quickly, perhaps even more so than writing in the condensed Haml syntax, and you have something everyone familiar with HTML can easily read when you're done. Still, I like Haml and I do miss the filters.
man all this drama sucks; i used to think the 'dramaqueen' stereotype of rubyists was just pythonista FUD, but it seems there may have been some truth to it. Hurry the fuck up and sort this out, this shit is embarrassing for all rubyists.
Haml is just WAY easier to read than erb. IMO the controversy really boils down to people who have a problem with significant whitespace, and in some cases people who don't use Haml filters, such as markdown for content ([Haml sucks for content](http://chriseppstein.github.com/blog/2010/02/08/haml-sucks-for-content/)). If you have issues managing indentation, I might suggest that your code is written in a disorganized style. Use helpers. Use partials. Don't write thousand-line templates. I would give that advice even if you aren't using Haml.
If you look at his history, he's got a habit of doing this. Most likely he doesn't understand that you can't use the "text" tab when posting in combination with an external URL. It's one or the other - a title + URL, or else using the "text" tab makes it a self post.
[Slim](http://slim-lang.com/) is even easier to read than HAML. It doesn't have to be a Erb vs. HAML choice.
I hear good things about the [ZenCoding](http://www.vim.org/scripts/script.php?script_id=2981) vim-plugin for auto-generating boilerplate HTML, much faster than you could write HAML.
I agree
-1
Is that what's going on? Trying again!
Ok, it was showing that I was on the link tab, but when I clicked the link tab, it changed. 
What right do you have to tell others what to do? They don't owe you anything and you aren't paying them. 
and there goes malcontent again, with his bland commentary...
wow awesome. did not know about this. i'll probably use this 50 times next week. learning inject was one of my ahhhhhhHA ruby moments. 
Using editors to generate boilerplate seems much less efficient than using a language which is inherently concise. You can compile Haml into HTML too.
If the difference in efficiency was a couple orders of magnitude more than it actually is, that would be a lot more compelling. But, the difference is modest at best, and the gap decreases significantly the more your editor can handle a lot of the extra verbosity for you (closing tags, etc). Also, there's something to be said for working at the level of the final product, and not adding the Haml-&gt;HTML translation step to your request-response loop.
And there you go demanding things from strangers and thinking the world owes you something.
I'd rather have browsers that accept Haml, myself. ;)
-1, cloying sycophant.
I to disagree with his 'arguments'. 1. Haml isn't broken either, but way faster when writing a template. 2. I never had a problem with to many whitespaces and I wrote (IMHO) quite complicated sites. 3. So? Who cares?
What do you prefer?
At this point my vote for rails CMS systems is "None of the above". Very few of them are rails3 and they all lack the functionality and the community of plone, drupal, joomla, or whatever. It's a sorry state of affairs I am afraid. Too many chefs cooking too many mediocre dishes.
This is the first beta so I would greatly appreciate any constructive criticism and feedback. One of the major differences between this and Observable is that it won't hold open a reference to your observer in the observed class. With observer any class that doesn't specifically remove itself from the observed instance will have a reference remain open and will never be garbage collected. Eventable not only handles that for you it also allows for more fine-grain event handling. You can specify exactly what events you want to listen for and what methods you want called when the event happens. You can install the gem from RubyGems: `$ gem install eventable --pre`
Are they putting tail call optimizations yet? How about the GIL, when is that going away?
are you as boring in real life as you are on the internet
are you as boring in real life as you are on the internet
TCO can be enabled [by tweaking vm_opts.h](https://github.com/ruby/ruby/blob/trunk/vm_opts.h#L22).
I think the guy makes an interesting point. But fuck this post for the title.
It's to make people click on the link. *Scandalous*
There is nothing in that repository?
Sensationalist.
did you read the link in the description ?
Include your monkey patches as modules. Also I like the idea of [multi_json](https://github.com/intridea/multi_json), [DataMapper](https://github.com/datamapper/dm-serializer/commit/a97da1d3045c821b86d047fac91bd4ecd6610a4c) recently switched to it.
Ah I see. Maybe resubmit with correct link?
you give me a BJ and i'll consider it
I am completely in favor of making convenience monkey patches opt-in and therefore available to application authors. Including them in libraries with no opt-in is bad practice, IMO.
hi, what's up
I also like the pattern of separating the monkey patches into their own file/directory. I always make a `foo/extensions` directory, containing `array.rb` or `kernel.rb`. Allows for cherry-picking.
Why isn't it on by default?
Asking questions really bothers you eh?
I was going to ask what this gives you that attr_accessor doesn't but someone in the comments section answered it for me: &gt;We're using this in our ActiveModel classes for processing arbitrary (non-database-backed) form inputs, where ordinarily all #attr_accessor gives you is the raw string. Adding Virtus allows us to know that we're dealing with Integers, or Booleans (checkboxes anyone) without having to muck around in the code. It makes the code much clearer and feels more natural.
i heard that this project was very popular among the gay community
 $ cat bundler-exec #!/bin/bash bundle exec $1 [:/](http://i.imgur.com/mzcSG.jpg)
I'm surprised no one has made a rubygems extension to make bundler-aware bin stubs. That seems way easier than aliasing every possible ruby command.
very good clarification and explanation of the rubygems situation
Monkey patches rarely are a good idea in a gem (unless the explicit purpose of the gem is to change core lib behavior). Too bad there isn't a good way to scope monkey patches :p
`alias be='bundler exec'` ?
I get the impression that you might not have understood what bundler-exec does. My bad; I should have explained it better! :/
If you are going to run nginx and multiple rails apps why not use passenger standalone? 
If you use RVM's gemsets correctly, you don't ever need to do this. Just have a clean bundle and no global gems, and you can do everything like it's the only project on your system. 
Does it have validations and/or defaults? That would make it a very compelling project if you could define defaults for your attributes and set validations for them. If they did that I would use this is in every class I create.
Defaults will be implemented soon (as it's a standard feature of DataMapper). Validations will be implemented as a separate project.
-1 just because you're a serious dick, regardless of the actual merit of your comment.
Looking forward to it. When that happens post here again.
Bundler adds a couple of seconds to the startuptime of my projects, that really adds up if you are testing all the time.
If all you want is SASS, not Compass, just do the latter bit.
This list is full of things that are good to know. But I was personally unimpressed because I have been spoiled by an education in functional programming. It seems map and inject are standard in most functional languages, where functions are first class values. If anything, this post is not so much as "Impressive 1 liners" but an example how awesome lambdas as first class values are, IMO.
It's not loading for me, at the moment.
This is exactly how I roll. Conflicts between versions of RSpec made me get deep into gemsets and I never looked back.
no.
Extension/inheritance is always more dangerous than composition due to the fact you rely more on the internals, which may not be exposed to you or even remembered.
CS101
Note that as of present, you can't compile it with the Ruby 1.9 support. At least, not easily. It's not a default. Just in case you were wondering :-)
Gary Bernhardt has an exceptionally punchable face.
While a good write-up on how to best use inherited, it makes me sad that Dave had to submit the bug report for Jamis. Remember, Rubyists, ALSO file bug reports when you blogs out problems you have with software!
Hopefully it compiles with 1.9 support via RVM soon, even if it's 1.8 by default. I'm not interested enough to compile it myself from source, but I'd definitely test it out with my apps.
Right up to the part where you have to deal with cross platform struct issues and low level systems programming. ;)
"In MongoDB, the indexes are already in memory, so you can achieve great performance as long as you have enough memory. " Um, mysql will keep the indexes in memory too.
Digging through the FFI github repo it seems that a few things have improved, like you can provide the struct members you want and the header and FFI will create the correct layout, and you can pull #define'd consts from headers too. I still prefer writing C extensions for the C libraries I've wrapped. When I wrapped libz and worked on some of the socket API for rubinius I felt that I was doing all the extra typing of C with none of the benefits of ruby. When I write C extensions I write a minimal C wrapper and a lot of ruby glue to get a nice API. FFI made me feel like I wrote even less than a minimal C wrapper so I had to put glue around it to get to the usability of a C extension in order to put yet more glue around it to duplicate the API of require 'zlib' and require 'socket'
This post is presenting MongoDB as some kind of magic pill for high performance. As someone who has run MongoDB in production for a while, I can say that it isn't. MongoDB *can* be blazing fast if you know what you're doing and how to tweak it, but so can MySQL or any other database.
With mongodb you have to maintain your relationships manually and that's a pain when you have many interdependent tables. 
I have no clue what "maintain your relationships manually" means. You can use Mongoid just like you would use ActiveRecord.
The point of the piece is that it is a better default. I agree that it is not a magic pill. Obviously MySQL can be very fast, particularly with the correct surrounding infrastructure. Glad to hear from someone who has actually used MongoDB. There are fundamental limits to the performance of MySQL that MongoDB can often push farther past. For example, write intensive data like counters. Another would be schemaless data. I have experienced the pain of trying to do both of these in MySQL. Thanks for reminding me- I am adding these use cases to the post.
This is great!
thanks, that does sounds silly as written- I edited the post
You can't explain that...
Thanks! Macruby is pretty cool, I'll be intergrating it into [Mynu](https://github.com/RobertLowe/mynu) next
Why this got downvoted: David Chelimsky (the lead developer/maintainer of RSpec) &gt;“In my experience, custom steps can easily become too complex” &gt;So can your Ruby code, unless you are disciplined about design and refactoring. When I say what I’m about to say, I’m not saying “you”, and I’m also not saying “this doesn’t happen to me,” but if your custom steps become too complex then you’re doing it wrong. &gt;EIther way, there is duplication to manage. With declarative steps the duplication is in the step definitions (i.e. in Ruby), whereas imperative steps put them directly in the scenarios (i.e. in Gherkin). In my experience, Ruby is easier to refactor than Gherkin.
[FFI::Platform](http://rubydoc.info/gems/ffi/1.0.9/FFI/Platform) can help you detect known platform specific differences.
oh god... Drupal 
&gt; Cucumber’s primary benefit is building a comprehensive test suite from reusable steps. How many times is the "primary benefit" of Cucumber going to change?
So he wants me to create a user with root-like privileges to deploy with and he thinks it is more secure than just root because...? Also, SSH won't ever send your password in clear text, no matter what. Sure, SSH keys are better, but still. What you really should do is create a new user with no privileges, which will only run your app. You may even go the extra mile and set a rvm environment just for that user.
you are correct, but you're more likely to f something up using root user than a user with sudo access. A user with sudo access you need to explicitly type sudo and initial time enter password prior to making fatal mistakes.
Sure, but it only protects against yourself.
It's weird Gemtesters was the only Ruby entry on that site. 
The sudo part worries me, but the SSH and iptables configuration are something every server should have.
A common mistake people make with SSH, is setting weak passwords or worse using the same password on multiple servers. By only allowing authentication via SSH keys, you kill any chance of bruteforcing SSH credentials. Some popular tools to test your password strength: * [ncrack](http://nmap.org/ncrack/) * [hydra](http://www.thc.org/thc-hydra/) &gt; What you really should do is create a new user with no privileges, which will only run your app. You may even go the extra mile and set a rvm environment just for that user. Couldn't agree more! Your www/deploy/backend users should have zero privileges. Do the administration from a separate account.
That article ended before it got to the actual content. 
Tuning your GC is all well and good but making sure your app doesn't allocate objects it doesn't need to in the first place is better. Using Unicorn's oobgc, I've been able to mostly remove GC from the request process but there are still a ton of objects getting created which wastes CPU during the request and after each request during GC.
Yeah... my intention was to protect me from myself. I have at times messed up the server logged in as root. Also any rogue scripts that execute will not run in root. But you are right. I should probably setup a separate account with zero privileges for the app another account for administering the server. 
Fair enough, this post was in some sense really an introduction of our intent to write a series of articles on this subject...
It sounded like an interesting start, I was just looking forward to reading on how you tuned the GC and such. 
That is definitely one of the topics we plan to cover in the near future. For our first pass introduction to how to tune the GC in Ruby for better performance, do check out an older post of ours http://engineering.gomiso.com/2011/02/25/adventures-in-scaling-part-1-using-ree/
While I have you guys here reading this, do check out our post about how we developed a hybrid native/web framework for iPhone development that gives us the best of both worlds here http://engineering.gomiso.com/2011/06/10/hybrid-native-web-mobile-app-development-%E2%80%A2-part-1-the-motivation/ again only an introduction, expect more posts on this subject in the future
Low hanging fruit in messing with the garbage collector? Dude. Normal people don't do this. Look at your database's slow query log first. Check your caching and database indexes. Messing with the garbage collector is a micro-optimization that's going to bite you in the ass.
We have extensive profiling, we check the slow query log, we have New Relic Gold which gives us much deeper insights into the exact execution path of our application and a breakdown of each component. We add indexes on every common query identified as slow. Turns out that in Ruby in particular, being aware of and tuning the garbage collector (and monitoring object allocation) are indeed great ways to improve performance significantly as evidenced by http://blog.evanweaver.com/2009/04/09/ruby-gc-tuning/ https://gist.github.com/465182 http://thefjord.org/2010/07/05/ruby-garbage-collector-tuning-a-walkthrough/ etc. Unless the ruby community at large isn't "normal" which is debateable, I would say your suggestions are sound but don't be so quick to judge a multi-pronged approach.
Like the article you posted here, you don't get to any good actual content. For all I know is you guys created another phonegap. 
Interesting, but there's no link to this hybrid native/web framework.
only Iphone?
I'll have to check that out. I've been using my own rake task to do daily backup to an s3 bucket, but I recently had to rewrite it when they forced an upgrade to the newest version of the heroku gems in order to use pgbackup.
Awesome, I like it very much. validates_presence_of and friends always felt to me like getting close to the line where your (agile) client is defining the system by what fields should be in the model (a dangerous place). 
Thank you! :) The reasons you mentioned are exactly why I wrote this matcher. Shoulda and Remarkable are very large libraries and I have more power and flexibility with ValidAttribute.
Very cool, I'm going to try switching out Shoulda for this tomorrow morning on a project I'm working on.
Sweet, let me know if you have any questions or run into any issues. :)
I think it would be much more advisable to define a variable for a certain behavior, and to initialize that from an environment file. That keeps the code more semantic, and side-steps this whole platform-specific stubbing business.
That's great that you have the data for tuning the GC, and that it's so easy, but seriously, it is NOT low hanging fruit. Collecting and interpreting that data is not easy. It may be easy once you pull the branch down, but pulling it down is the hard part.
Ruby redditors, I call forth and need your help. Please. :]
It can be done. I did this with the upload module a year or two back. Don't have that code any more though.
I use [configatron](https://github.com/markbates/configatron) extensively for that exact reason. edit: err, that was ment to be in reply to synt4x
It's shit like this reddit. Thanks for your guys help! Figured it out, see: http://stackoverflow.com/questions/6335081/getting-upload-process-via-nginx-unicorn/6348958#6348958
Especially if you use Jruby!
[Settingslogic](https://github.com/binarylogic/settingslogic) is what I use for similar reasons.
I tried that on a new project but switched back as it barfs if I access a key which doesn't exist. I'm used to configatron returning a nil type object in those cases.
Information on integrating Ruby apps with JMS would be useful to people (we've done it here ourselves). You can't ignore it.. it's pretty much the most widely used messaging system out there, and you will encounter it eventually. 
I'm interested to know why it would take 3 days to set up a server. I can follow the tutorials on linode and set up most things in a couple of hours; for example ubuntu, nginx, psql, memcached, sphinx. I'm sure there are things I'm missing with regard to optimisation or security and I'm curious as to what they are. Not that I disagree with you or agree that heroku is expensive. For small apps that don't spin down (2 dynos) $35 and require greater than 5 mb database for example. $15. Spinning up with ruby 1.9.2 takes 20-30 seconds in which time undoubtedly most people will have cancelled the request. For larger apps it soon begins to make sense. 
A compatible license! Hooray, Bob(Michael)! Also, some awesome stuff defining possible ruby semantics - I don't think it's something people think about most of the time. There are quite a few methods of sensing a block there I never considered - who knew that defined?(yield) would tell you if a block was present or not.
&gt; A compatible license! Hooray, Bob(Michael)! Sorry it took so long to change! I ended up putting it off and putting it off, until I gave up and decided to wait until I graduated. &gt; who knew that defined?(yield) would tell you if a block was present or not. I actually only found that out because I was looking up how defined?() works for local vars and expressions in [The Ruby Programming Language](http://books.google.com/books/about/The_Ruby_programming_language.html?id=jcUbTcr5XWwC), and on the same page it mentioned `defined?(yield)`. I didn't notice that `iterator?` was an alias to `block_given?` until about 2 weeks ago.
`defined?` is a crafty, evil bastard. I delight in misusing it. :)
With JRuby? Or MRI/other impls?
We're using JRuby (mainly for reasons other than JMS), and the ActiveMessaging plugin. I found a good blog post about it here: http://www.shaneharvie.com/2007/06/asynchronous-messaging-with-rails.html 
do you know the `defined?(super)` trick? yes? what other ones do you know, im qrs.
Add to your .profile: alias be='bundle exec' Now `be rake spec`.
Unless you inherit a legacy spaghetti bolognese + ball of mud project in which whenever you try to refactor and improve crappy code someone starts jumping up and down telling you that they don't have the budget for suchlike improvements. Then you have no choice but to stub out the `Rails.env`. Of course, you can hardly survive in an environment like that for more than a few months, so you'll leave it and let it sink into the deepest depths of the dark ocean of software development's hall of shame!
Rails seams to be tracking along the same path Java did. Soon we will all be back to writing EJBs.
Rails always had a lot of "magic" and such. It was never for beginners to learn as a simple way to just make a web server, I mean compare Rails 1.0 (or earlier) to web.py. In Ruby Sinatra is the simple web framework that is easy to reason about. Rails is not, never was. Anyone who ever thought rails was *for* beginners was mistaken. You *could* understand how to *use* the system and throw together a web app with little code but you probably wouldn't really understand what was happening. That distinction may or may not matter depending on the situation. Don't the cool kids use Node these days anyway? *\*ducks\**
Rails never was for beginners. Many things were MUCH more difficult in the v1.2 days than now (hosting wtf?). There are a few more standard things that you need to learn (ie: bundler) but say in the case of bundler it's easier than what it replaced (remember gem vendoring? /shudders)
bloat and complexity is the price of progress. not a problem anyway, since a lot of beginners are not going to move to ruby/rails since every major language have their own frameworks.
I agree that Rails was never really for beginners. Yes, barriers to entry were quite low but soon it resulted in lots of crappy code, PHP patterns and, which is the worst, people satisfied with that level. On the other side it took really long time to learn to go beyond it, to the good stuff (why, when you can do it 'simpler'?). And now, when entry barrier is moved forward, the path to 'good' level is shorter and it's harder to get lost. Which is good from the point of view of community and maintaining code of others.
How so? I don't see that at all...
I'm a little surprised rspec beat out Test::Unit by such a wide margin. It has seemed to me like the pendulum has been swinging back toward that, with MiniTest a part of 1.9.2 and everyone talking about it as much as they are.
I definitely don't see that, a lot of the work in rails seems to be towards modernizing and streamlining. There is no real bloat in the framework that I can see.
Awesome project. Glad to see Pry getting more love. Were there parts that really needed Pry and that would be too difficult to implement in IRB? Or was this done with pry purely out of novelty's sake? 
Rails was never meant for beginners - the real problem is that a lot of people don't bother learning Ruby before they jump into learning Rails, and Ruby can be a bitch if you are not used to concepts like blocks and lambdas, even for seasoned PHP and Java developers.
agreed! put it in the view so you only have to edit one file
I look forward to trying this out. I was really excited when I first learned about pry, but was a little disappointed when I realized pry wouldn't be a sufficient replacement for ruby-debug.
Agreed, I started with Rails 2 and find 3 much easier to use.
Thanks, I'd forgotten how much time I devoted to keeping various mongrel clusters going with monit. Both ways, uphill, in the snow, etc.
I just started using Rails, coming from Python/Django. Rails is awesome. Super easy to use, and light-years ahead of anything else I've seen. Sure there are lots of microframeworks that let you write super light websites, but any substantial effort is going to run into the design problems which Rails solves out of the box. 
The opening description in the readme implies that the only other way of debugging is using 'puts'. ruby-debug is fantastic.
Websites are complicated. No framework, no matter how magical, is going to substitute for the knowledge that every web developer needs one way or another: how websites work. What a great framework like Rails can do, is provide you with a set of tools, defaults and shortcuts to reduce redundancy/repetition in the development process and allow you to more efficiently do your job.
not only vendoring, but I picked up a bunch of other peoples rails sites where I had no idea which version of a gem they were using and the latest version didn't work. 
Am experienced with 4GL programming. Tried to get into Ruby/Rails (I mean-it's preinstalled on my Mac FFS!) followed a tutorial, downloaded some or other update, had some incompatabilities, spent days trying to solve the errors and degradation warnings that return every time I issue a line of code in the terminal, I now have more versions that I think I am actually aware of, I am concerned that I have fundamentally borked my Mac on some level and any initial learning curve thrust I may once have had is just bitterness and ignorant disdain at this stage. What a mess this verkakte language is.
Honestly thats what I thought, I tried and failed to learn rails back the early days. It wasn't until a couple years ago I finally caught on. Rails should be making good code that is easy for the people who code rails a lot to do. Trying to go to the lowest common denominator is going to end up with a mess.
goddamnit, where are the tutorials for Sinatra? I can't seem to find any :(
Where's the "so" in front of that question?
Did you try turning on the "safe" mode for mongodb? What was your experience if so?
I remember watching [the original Rails screencast](http://media.rubyonrails.org/video/rails_take2_with_sound.mov) about 5 times thinking *"Oh it's so easy! /s"*. DHH: "So easy to get to *Hello World*!" Me: "Umm, `&lt;?php echo 'Hello World ?&gt;`" ??
Pry can easily be started using any binding you want to eval stuff. IRB doesn't allow you to do that (at least, not that easily), and the REPL should really have access to local variables and other information to be useful. Also, though it is not absolutely necessary to have this, Pry has a nice command syntax, so you can mix Ruby code and commands that have a natural syntax, like "b test.rb:20" or "b Foo::bar". Plus the default command set provides features that are quite useful in a debugger — printing the code of a method, listing methods, …
Oh, no; it is saying that using a debugger (any debugger) is an alternative to changing the code to print debugging information.
Peepcode has several. 
why rails has to be for beginners? 
Except "Hello World" is a working blog.
Nodejs + express ftw! I got tired of dealing with the strange 'magic' behind rails. 
Oh a cool kid! :p I'm actually using Node a lot these days too, in fact I've written more JS than anything else the last few years. Dabbled in express a little and it's quite nice.
Yes they are. Just because your shitty language/VM can't deal with them efficiently doesn't change anything.
Your code must be absolute unreadable garbage if you just throw exceptions every fucking which way to control flow. That is not how exceptions were EVER designed to be used, not even in C# which has very fast exceptions. 
Ruby has a non-linear flow control mechanism for use in scenarios like this: [throw/catch](http://ruby-doc.org/core/classes/Kernel.html#M001394).
Don't worry; your intent is obvious to anyone that does more than scan code blocks, especially when the preceding sentence to that code block is "If you wonder why use a debugger: how often have you written things like this?"
Uh, yeah they are. They change the flow of a program in a controlled manner. Whether they're the right kind of flow control for a particular situation is another matter.
lol @ naming a well known keyword for exceptions handling for use on a non exception case
People seem to have no qualms about abusing exceptions anyways, so what's the harm in naming it something familiar?
I know this now, my `Hello World` right there is the first bit of PHP I've written in 3 years :)
uh, i dunno... maybe consistency!!??? but i suppose matz has a weird notion of "more than one way to do something" to include "more than one way to name something"...
Title is a bit misleading, but good article none the less. Exceptions are for **exceptional** (read: **dangerous**) edge-cases in your code, not for common cases where you must halt/cleanup. It's not that hard to use meaningful return-codes (Integers or Symbols) to represent success/failure cases, and simply `return` in the middle of the methods.
Exceptions are much more useful than Integers or Symbols (don't know what you're referring specifically to here) when it comes to **nesting** if statements or nested calls to other functions as detailed by Java's [explanation](http://download.oracle.com/javase/tutorial/essential/exceptions/advantages.html). Also, you don't have to maintain a list of integer codes to check the output for and interpret it. Custom exceptions can also carry additional information if you choose to store it when you throw it. 
Id love to upboat the next article. The one with actual content.
I suppose you could also return Hashes or Structs. I think the problem here is that some developers use exceptions to represent State Transitions, when they should be passing around some kind of State object, and avoid the overhead of raising/rescuing exceptions.
"faster and easier to use" compared to what?
I sent a pull-request with some basic cleanups. I might continue digging through the code later on. * I would suggest looking into [YARD](http://yardoc.org/) for a more detailed documentation format; a lot of methods are missing complete documentation (ex: all valid options for `Capture#initialize`). * Use the pcaprub on github/rubygems, and not suggest doing a `svn co` in the README. * Try to identify parts of the code-base that could be replaced by other gems, such as the hexdump formatting code. The less code you have to maintain, the better. * RSpec tests go in `spec/` and test-unit tests go in `test/`. Try to standardize on one testing framework, and not confuse contributors. * Consider making PacketFu compatible with [test.rubygems.org](http://test.rubygems.org/), to collect user test results. This involves adding a `Rakefile` with a `test` task (to invoke all tests) and adding a `.gemtest` file. Then you can have users `gem install rubygems-test`, run `sudo gem test packetfu` and the results will appear at [test.rubygems.org/gems/packetfu](http://test.rubygems.org/gems/packetfu).
Updated w/ robgleeson's fork; as a proper delegated class, a+
-1
Have your tried [Fabrication](http://fabricationgem.org/) yet?
Compared to PacketFu of a couple months ago.
&gt; even if you tell **her** not to hit the database FTFY!
Awesome, thanks for the points! I did look at YARD very briefly (since it's what's used by rubydoc.info (http://rubydoc.info/gems/packetfu/1.1.1/frames), and the documentation does seem compatible. The two test frameworks are there because I'm not settled on which to use. Test::Unit and RSpec are both attractive for different reasons. I'll probably end up switching over to RSpec before too long, which will make the whole test.rubgems.org thing easier. 
No, I've been using Factory Girl for around two years and only tried Machinist as an alternative. Would you mind explaining why Fabrication could be better than FactoryGirl or Machinist? Thx :)
Fixed, thanks :)
I never really understood why anyone would use these gems. Most of the time, what you want it to accomplish is this: # Spawn a Person instance with some dummy data person = Factory.build(:person) # Result: #&lt;Person name='John Smith' email='js@hotmail.com' username='john_smith'&gt; Then why not just do this? def Person.spawn(hash={}) hash[:name] ||= Faker::Name.name hash[:email] ||= Faker::Internet.email hash[:username] ||= hash[:name].parametrize Person.new hash end person = Person.spawn # Result: #&lt;Person name='John Smith' email='js@hotmail.com' username='john_smith'&gt;
Sure, in the simplest case. But when your Person has 1-N associated Addresses, an optional Car, and a list of Children, your simplicity falls away. To do this with one of these gems, I'd say Factory(:person) And the rest would all get made, too.
 I think it would take a very complex edge case scenario to break this simple solution: def Person.spawn(hash={}) hash[:name] ||= Faker::Name.name hash[:email] ||= Faker::Internet.email hash[:username] ||= hash[:name].parametrize person = Person.create(hash) 5.times { person.add_address Address.spawn(person: person) } person.add_car Car.spawn(hash[:car]) if hash[:car] person end def Address.spawn(hash={}) # ... end def Car.spawn(hash={}) # ... end 
First, `factory_girl` syntax is terser than your example. Second, it also gives a nice way of composing and naming more complicated objects from simpler, base, objects. Factory.define :person do |p| p.name Faker::Name.name end Factory.define :person_with_car, :parent =&gt; :person do |p| p.cars { |p| [p.association(:cars)] } end (This has 2 benefits. We can use the simplest valid objects in our test where we can. And when we read our specs, `:person_with_car` indicates what kind of object we have built.) Third, `factory_girl` encapsulates different build/save strategies, sequences etc. From my experience, we use all of its features in almost every project. Finally, when new devs join they are familiar with the library straightway.
Why do you need a gem to create a csv file? It would be fairly simple to just create a new file with a .csv extension and write comma separated data to it. That way you don't need to learn another gem, just straight ruby.
This. I do it all the time.
It's not finding CSV::Writer. Maybe [this](http://stackoverflow.com/questions/2139479/write-csv-in-ruby-1-9-and-csvwriter) is the same issue.
Check your gems. Are you using 1.8.7? You might need to use FasterCSV in that case
and when you have strings with commas, and quotes, and new lines... it's a gem worth learning I think and it's pretty simple
This. For 1.8.7 you should use the FasterCSV gem. For 1.9.x, FasterCSV was rolled into the native libraries and renamed just 'CSV'. Depending on your version of Ruby, you could be using a completely different CSV API.
It's not just any gem, it's part of the standard library in 1.9. Try: CSV.open('path/to/file.csv', 'w') {|csv| csv &lt;&lt; data }
Ah yes, thanks very much! That's the issue! They completely changed the CSV generate command from 1.8.7 to 1.9.2. So what works for 1.8.7 doesn't work for 1.9.2. And 1.9.2 also made FasterCSV obsolete. So... Anything that says 'CSV::Writer.generate(outfile, ',') do |csv|' should be replaced with 'CSV.open(outfile, "wb") do |csv|' As shown in the links below: http://www.ruby-doc.org/stdlib-1.8.7/libdoc/csv/rdoc/classes/CSV/Writer.html http://www.ruby-doc.org/stdlib/libdoc/csv/rdoc/classes/CSV.html#M000190
You're fine, ignore the error. rubygems automatically runs rdoc on gems, but often libraries omit this documentation, or have some code that confuses the rdoc parser. The majority of people don't even use the local ri/rdoc documentation anyway.
** C:\ ** &amp;#3232;\_&amp;#3232; 
Due to AIDS, oops, I mean Windows.
-1 this has already been done to death
gem install firewatir --no-ri --no-rdoc
Used it a few minutes ago to test a regex for reformatting file names. As a beginner, it's really useful.
I really love rubular, it was great for me starting out with both ruby and regexs.
Also, it's generally not a good choice to put methods inside business objects just for testing purposes, like your `Person.spawn` method. This is a thing I don't like about Machinist, cause if I ever need to define my own `make` method on `Person`, this would conflict with the method being added by Machinist, while Factory Girl doesn't touch the namespace of the business objects.
Love using Rubular... great tool. Just wish it worked offline as well...
Well, you could probably quite easily write one.
weak and lame
I don't like it either, but whatever, it's here and people are going to use it.
Original author, from the comments: &gt; I still don’t understand though. You find the syntax pleasing? Are you saying that the only argument for its existence is how some people find it looks on screen? *derp*
It's with the intent that you learn the language. In Ruby, I can be clever and "1".to_i all over the place just to be consistent w/ all strings throughout a program. Or instead of [] and {}, I must use Array.new and Hash.new. Or I can write what's clearest right then and there to remain consistent w/ the local (local to the line I'm writing) structure.
It's the first place I go to when I need to figure out a regex. :)
I was just thinking this - I'd love to have a copy just running in the background on my machine. A quick hostnames tweak and rubular/ points to the local copy. It doesn't appear to be open-sourced - does anyone know of any similar, freely available projects? If not, I'll whip up a 1.9-compatible version and open source it.
There is some simple (no javascript) version [here](https://github.com/seanhandley/Rubex).
I use this regularly
I wish I knew about this a while ago, would have been useful for hammering out mah regex, since I'm still a bit green.
This is beautiful documentation. Gorgeous. It is a shining example. I will be recommending this for how docs should be written from now on. Also, I am writing a shell, and I think I will include alf somehow in it.
I agree with the author. Changing syntax only because "99% of the time you use symbols as hash keys" is so rails, but it's ruby. I don't get it why there is so big pressure to change language to fit framework's philosophy... But anyway, it does not harm when there are two available options. I'm just afraid that many will insist on deprecating the original syntax and that it will actually happen.
I believe there is a textual format output to a method in the regex that does the samething.
its windows fault? no wonder ruby is losing out to python, because python works too well on windows.
I don't like the new lambda syntax. It looks too much like coffeescript
&gt; I'm just afraid that many will insist on deprecating the original syntax and that it will actually happen. You can't deprecate the old syntax unless you never have a hash literal *ever* with *anything* other than a Symbol as a hash key. You might ask your co-workers to use the new syntax when working with Symbols, but that's hardly deprecation.
Not gonna lie - this is a good idea for a simple contest! I'm willing to bet a few cool ideas will come out of this.
rspec!? Wow, that's like a fight with broken bottles.
It seems to explode if you try to submit a gist.
This [response](http://www.ruby-forum.com/topic/1970910#1006483) was very informative. For those not familiar with ruby-talk, Ilias Lazaridis apparently has a history of posting lengthy and usually misinformed critiques of languages/tools. I'm beginning to feel there are too many critiques/spectators, and not enough patches/contributors. If you have reservations about a Language or a Community, a) help improve it b) find another one c) build another one.
I didn't mean to imply that it was Windows's fault. I was just saying that Ruby and Windows don't mix well sometimes. Ruby can work fine on Windows though, check out RubyInstaller for Windows or JRuby.
if you want some offline app, you might find some [here](http://stackoverflow.com/questions/89718/is-there-anything-like-regexbuddy-in-the-open-source-world)
So Ilias Lazaridis is the Xah Lee of the Ruby world?
I think one of the great thing with the new syntax is that it's the same thing as json. So let's say you have a small webservice that serves json, you can render it the same way server side as you would on the client. But yeah, it's not game changing.
Misleading title of "shell commands"; I thought this was a way to run executable files without shelling out.
I still use the old Hash/lambda syntax, because many users are still on 1.8. If you don't prefer a certain style of syntax, don't use it.
Yes, something went wrong during the validation of the Gists. I deployed a hotfix. :)
Thanks a lot for so much compliments! Writing good documentation is difficult. I'm quite happy with this one, even if it lacks a few things... Enjoy Alf, and tell me how you use it in practice so that I can make it better!
I've used CSV data once in the past 5 years, and that was last week, and I don't foresee myself using it again for a very long time, but I'll certainly include it in my shell.
Thank you for this. One can never really have enough tools in their benchmarking belt.
Waiting for service pack 1 : ehec
which is a bad thing, why? I must admit, I really didn't like the look of coffeescript when i first saw it, but the way it fixes scoping and inheritence in javascript made it's utility worth it. Then again, I didn't like the look of the ruby syntax initially. I can only put it down to the fact that most of my commericial programming career has been using c style languages using braces for blocks.
That is a very nice DSL, I've often seen benchmarking libraries leave the variation, and range as an excercise to the reader, this looks great
No, he has trolled several programming language communities over the years, for example ca. 10 years ago Lisp programmers in comp.lang.lisp. Other than Xah Lee who occasionally writes something interesting and insightful he never contributes anything worthwhile. He's probably the only troll who has developed an intricate scheme, that he calls evaluations, in which he goes through several phases of attacks on a language community and then documents the responses of his annoyed victims as the results of these evaluations on his website. After a while he usually vanishes for a while. I always assumed that he must have been sent into a closed psychiatric ward in order to get crisis treatment during these times. When he's mentally stable enough he's probably allowed to leave, but a short time later he becomes crazy again and starts another evaluation.
It's funny. I've found the same thing just yesterday. It started to be extremaly painful when I switched to rails 3.1 because all assets are served by rails in default.
Not only does the new syntax suck, they removed the old syntax where you could use commas, e.g. h = {1,2,3,4}, which was very handy for quickie hash variables in irb sessions.
http://homepage.mac.com/roger_jolly/software/ regexhibit
&gt;It turns out that by default, Mongoid preloads all my models to handle model inheritance. Well that doesn't help me. I can confirm, however, that the former tip does speed things up a bit
Well since you can't take a joke... Last time I checked, coffeescript does not fix anything in javascript. Scoping and inheritance are not broken in javascript, they just work differently than in other languages. Coffeescript does make it much more difficult to shoot yourself in the foot if you aren't very experienced with javascript, but I'm still not convinced that using a hybrid ruby/python/erlang syntax is a solution to people's javascript problems.
You can use: `Hash[1,2,3,4]`
They didn't 'change' the syntax, they added a new syntax for the particular use-case of named parameters. I probably wouldn't use the new syntax for anything except in named parameter context, but in that context it's great. Also, in that context the keys are _guaranteed_ to be Symbols. Just as blocks are special syntax for passing a single proc to a method, this new hash syntax is a special syntax for passing a named-parameters hash to a method.
Here's the thing. Mongomapper is just as active and yet it doesn't have stupidity like this. I've a highly recursive data model with SCI in some parts, and everything is super snappy in development mode.
Although there are already many other respectable commenting gems [out there](https://github.com/search?type=Repositories&amp;language=Ruby&amp;q=comment&amp;repo=&amp;langOverride=&amp;x=27&amp;y=10&amp;start_value=1), I created this gem to unify duplicate commenting code from an existing application. After tackling the learning curve of how gems work and the concepts of Rails Engines the gem is working great. I'm using [Jeweler](https://github.com/technicalpickles/jeweler) to manage the basic gem tasks. It also takes care of releasing the gem to [rubygems](http://rubygems.org/gems/loudmouth) It includes generators to have custom views and even can install an override controller into the app to customize how loudmouth functions. tl;dr: a commenting gem. first gem == hard but great experience 
that is nice, can comments be commented on too?
Thx :-) Threaded comments are there but not enabled yet...just a couple versions away once I smooth some of the rough edges. (a couple weeks probably)
I'd confused the term SCI (Single Collection Inheritance) with just model inheritance. The Mongoid docs didn't seem to define what SCI was. I found an explanation in the MongoMapper docs and updated my blog post. It's possible this might help you yet.
I went with Mongoid because when I was taking an initial look at the repos, it was more watched and had a more active commit log. I couldn't find any deep comparisons of the two ORMs, aside from that RubyInside article from a year ago. I didn't think it was relevant anymore. There's also this from Quora.com: http://www.quora.com/What-are-the-advantages-of-using-MongoMapper-versus-using-Mongoid which seems to favor Mongoid. Mongoid also seems to have more 3rd party gem support, like the carrierwave gem which I use in my app. The MongoMapper official site doesn't really explain why I should choose it over Mongoid either. I wish it would explain how it differs, b/c if it's just a different looking API, then that's not enough to sway me to it. However, after this I think I'll experiment with a MongoMapper branch and see how it compares.
can you add extra fields to the comments, such as DM flag or anything else like that?
Absolutely. You can create a migration to expand (add_column etc.) on the comment model. Then use the override controller to handle that additional field and custom views to display it how you want. &gt; rails g loudmouth:override_controller &gt; rails g loudmouth:views This is the manual method of extending loudmouth but if I were to see enough requests for a specific feature (like DMs), I'd be inclined to include support for it natively. Most likely with a switch to optionally enable or disable that functionality. 
I'm wanting a threaded commenting system with a private flag, or it can be considered a DM but the whole conversation thread is still in context.
It becomes addicting; Watch out.
Most of the 3rd party gems, like carrierwave, work on Mongomapper as well, often without much modification. If there's a gem for Mongoid that doesn't seem to support Mongomapper, drop a query on the google group and myself or a few others will add the support in matter of hours. It's not advertised that said gems work with Mongomapper, but they do. As for the differences, the biggest difference for me is that Mongomapper has a built-in IdentityMap plugin which Mongoid does not. This plugin watches for already loaded documents and returns those rather than issuing queries to MongoDB. It's a good, early prevention of the n+1 query problem.
I was thinking "Why wouldn't you just want to use RDoc" - too long in pure ruby :)
Great article, but I would figure the grouchy attribute would only be exposed on days-of-the-week divisible by two. ;)
So true - I have two more gems that I'm itching to write. Unfortunately, as rewarding as gem development has been so far, it's distracted me from new features/bug fixes in existing code. Trying to find a balance :-)
This is a nice idea. I've never seen anything like that before. I would have to think through the visual part to make DM threads distinct among a sea of comments. I've added it to my list. If I ever get to adding this in, I'll drop a message.
While this is a pretty solid offering, I REALLY wish there was better documentation. 
shouldn't that be: fight! if ready? &amp;&amp; set? the original: if ( ready? &amp;&amp; set? ) { fight! }; is not valid ruby
*There are only two kinds of languages: the ones people complain about and the ones nobody uses.* -- Bjarne Stroustrup
I would appreciate any sort of commentary on my code, **but especially any thoughts on improving my puns**. I hope I am not alone in being able to appreciate this: def dig_for_treasure(&amp;block) return false unless block_given? if !grub.nil? self.swag = grub spyglasses.each {|x| self.swag = self.swag.send(x) } end treasure_chest = self.swag.map do |spoils| self.prize(spoils) end treasure_chest.each do |loot| yield loot end #THIS IS A PUN: Treasure chest *yields* loot! end **EDIT**: Some are missing the puns (not surprised - pirate is an ancient language) so I'll endeavor to highlight a few. **EDIT2**: On second thought rather than just pasting a bunch of my code in here I'll just work on the gem some more. Most of you suck! Thanks for the few positive comments! In looking for puns to help you poor humorless saps out I've already found a few places I can improve. **EDIT3**: I know I said "any kind of commentary" would be appreciated. I'm revising that to "any constructive comments that will help improve the humor value/fix bugs will be appreciated". :)
Suggestion, please avoid silly names in your code.
I can appreciate the humor in this, but being a full time Ruby developer, I wouldn't use this because of the silly naming scheme. Your method names should at least come close to what action it performs.
I agree with the other comments. While I do appreciate what it does, I cannot get past the naming convention. I smiled while I read it, but I could never use it. One of the reasons why I enjoy ruby and rails is because I don't necessarily have to memorize every method, several times I just try a name and it works. Earlier today, I did not have to lookup Hash.select, it was just there and working. This would leave me wondering where the "parse" method was or how to append a row? what are columns called again? This would leave me a slave to the docs and forget if another developer had to come in behind me to figure out what the code did.
The library looks awesome, except it's pretty much unusable.
luls
Everything you say is true. But there is another side to the story, and though it pales in comparison to the importance of your statements, it is still worth mentioning. If you just use things blindly you open yourself for unexpected bugs. Because libraries to not all implement *some_method_name* the same way. An important idea in the Ruby community is: "Don't use it if you don't understand the API/and or the source". I think you have valid concerns, they are just lower priority for me in this particular gem, than having fun. Any library you use a lot will cause you to memorize the methods by default. Also many people are using it despite the apparent drawbacks.
I did it for the lulz, and for myself, as a challenge.
It is not for everyone. The method names do map pretty well to the pirate terms as an analogy. This was my overriding goal in method name choices.
That's cool, just letting you know, that as a fellow rubyist, and like another redditor stated, we're used to a somewhat consistent naming scheme. I avoid rdoc at all costs.
can we stick to just writing code? What is all this pirate shit ?
Factory girl is much more flexible than machinist. FG will generate stub models too. I used to use Machinist for all my projects. Now I use FG because it is more actively maintained (How long has Machinist 2 been in development?) and I feel is more flexible. 
Only 1 of the ~20 gems I've written/contributed to is in "pirate shit". YOU SHOULD BE THANKING ME, MATEY. ARRRR. I suppose you codescriminate against code written in Spanish and Klingon as well... Perhaps we shouldn't let hydrochlorofluorocarbons use computers in the first place. :/
well I do respect the effort put into making open source libraries with a lot of functionality. I do think the naming will deter many people from taking it seriously and using it in their projects.
Clearly it does. I don't care though. My friends use it. Others find it humorous. I'm really looking for ways to improve my puns here...
&gt; especially any thoughts on improving my puns You haven't made any puns (you've used that word twice in the comments here), just so you know. Here's wikipedia's definition: &gt; The pun, also called paronomasia, is a form of word play which suggests two or more meanings, by exploiting multiple meanings of words, or of similar-sounding words, for an intended humorous or rhetorical effect. Using cute pirate words is not making a pun. It's at best general wordplay.
you dont care? well we dont care too. go to some english grammar forums and take your "puns" there.
I copied a few lines of code from thousands and you say there are no puns? Also if you don't get the double entendre of plundering booty then how have you survived on reddit? Some of the puns are ruby-based: &gt; treasure_chest.each do |loot| &gt; yield loot &gt; end Seriously the puns are all over the code.
Should I care? I wrote it, and I and many others do use it and appreciate it. It is in production use on many large websites. Why should I care that you get no benefit from it? I have shared this with many others and the response has generally been along the lines of "excellent" "I don't even" "well done", etc. This subreddit is apparently for sucks with no appreciation for humor. Dayam.
Avoiding rdoc at all costs is what I used to do, before I learned that I was only hurting myself, and often missing important features that make life easier as a coder. You're doing it wrong (at least, according to convention).
&gt; I copied a few lines of code from thousand and you say there are no puns? I went on your github page, too. There's no puns relating to CSV input/output, as far as I can tell. Just a sometimes-clever mapping of pirate-related terms to the domain of CSV IO. &gt; Also if you don't get the double entendre of plundering booty then how have you survived on reddit? Making sexual innuendos is not the same as making a pun.
You mean it is OK to have gems that are inherently nothing more than silliness: * [enterprise - to make your codes run slowly and suck more](https://rubygems.org/gems/enterprise) * [kitty - to print silly ascii art](https://rubygems.org/gems/kitty) * [your_mom - what the name says](https://rubygems.org/gems/your_mom) But having a silly gem that does real work is somehow bad? I understand it is less usable than a similar gem might have been with more appropriate attribute and method names. But it is more fun to use because it introduces levity into the code. :)
There are many more in the code than in the readme to be sure. Sorry you didn't find them. :/ EDIT: aye =&gt; by, and arr =&gt; AR (ActiveRecord) def find_aye(columns) "find_by_#{columns.join('_and_')}".to_sym end def find_aye_arr(data_hash, columns) columns.map do |col| data_hash[col.to_s] end end
Sorry you refuse to admit you misused the term "pun" :/
Some of the puns are ruby-based: &gt; treasure_chest.each do |loot| &gt; yield loot &gt; end Yes, because I didn't. You just haven't found them. Make.walk_the_plank
It's disappointing to see a fully-featured gem that does something useful and have it be wasted by having it be completely unusable due to cute naming. He's not saying you're a bad person, just that it sucks that an otherwise positive contribution is wasted.
Sorry you have such a simple definition of the word "pun" &gt; Making sexual innuendos is not the same as making a pun. ["pun1 - n (Literary &amp; Literary Critical Terms) the use of words or phrases to exploit ambiguities and innuendoes in their meaning, usually for humorous effect; a play on words."](http://www.thefreedictionary.com/pun) So, yes an innuendo is a pun. &gt; Using cute pirate words is not making a pun. It's at best general wordplay. [Definition: A play on words, either on different senses of the same word or on the similar sense or sound of different words. Also known as paronomasia.](http://grammar.about.com/od/pq/g/punterm.htm) So, yes, a play on words is a pun, and you are wrong on both counts. Can you admit you so narrowly defined the word to make me an grammar offender, or do you just like to piss people off? How come nobody told me I was arguing with a troll?
&gt; So, yes an innuendo is a pun. There's no ambiguity in what you have shown. It's "lol look at pirate words! Make.walk_the_plank that's a pun on stuff!" &gt; So, yes, a play on words is a pun You just read: &gt; X is a Y with property Z and responded &gt; So, yes, a Y is an X! Logic skills are crucial.
Many people do use it. I agree many other people can't use it because they don't reach the intelligence requirement, and many other people just won't because they don't like using something that makes mapping an active record model to a CSV a **ONE LINE STATEMENT**: Usage with ActiveRecord What’s the simplest thing that will work? class MyClass &lt; ActiveRecord::Base has_csv_pirate_ship # defaults to csv of all columns of all records end MyClass.blindfold # creates the csv, and returns the CsvPirate instance MyClass.walk_the_plank # creates the csv, and returns contents of the exported data (that was written into the csv) (as a string) MyClass.land_ho # Does Not create the csv, sets up the CsvPirate instance. You can manipulate it and then call .hoist (Could it be any fucking easier?). I have fun working on this code, because it takes something inherently boring as hell, and makes it cool. :)
It is, actually, a pun. That's a line from my example code in the readme, where "Make" is a class name refering to makes of automobiles: Assuming a Make (as in manufacturers of automobiles) model like this: # == Schema Information # # Table name: makes # # id :integer(4) not null, primary key # name :string(255) # factory :string(255) # sales :integer(4) # class Make &lt; ActiveRecord::Base has_many :vehicle_models named_scope :factory_in_germany, :conditions =&gt; ["factory = ?", "Germany"] has_csv_pirate_ship :chart =&gt; ['log','csv'] end #To create a csv of the names and ids of makes with factories in germany and return the text of the export: Make.walk_the_plank # Get it? HA! If you can't believe I wrote this whole thing JUST to be able to make jokes like that... check ma sources :) So now that that's clear... let's move on to the definition you fail to understand: &gt; Definition: A play on words, either on different senses of the same word or on the similar sense or sound of different words. Also known as paronomasia. As in the above example Make the noun is a pun with Make the verb. Another type of pun described by the definition is on the "*similar sense* [or sound, which I admittedly do not make much use of, aside from "yield", "map" and "arr", and which seems to be the only thing you accept as a pun] *of different words*: Case in point: attr_accessor :aft # extension, default is ('.csv') *Aft* has the same root word as (or is the root word of) *after*. This is a *similar sense of a different word*, namely, *extension*, as in a filename. This is a **pun**. I am really tired of your beligerent nitpicky assinine baseless grammar vomit, so I may not respond even if you do. I hope you enjoy never using my gem!
[8,938 downloads disagree with you](https://rubygems.org/gems/csv_pirate)
"Use" ≠ "Downloaded a goofy library I saw posted on a mailing list" Downloads are not a measure of users. By the way, the "kitty" gem you linked has 2k downloads, and meme_generator has over 2k, as well.
Being that this is the first time I have posted anywhere about it aside from my no-traffic blog, and that it has spread via word of mouth, to my colleagues over the years, and to most of the sites I've worked on (several dozen), some of which now have other maintainers, including rails core team members... I'd say it's value has been seen by those who use it in practice. Looking at the upgrade cycle over release numbers, there is a clear trend, not random spottiness. [You're an asshole.](https://github.com/pboling/csv_pirate/commit/75ac9ff98c00f8454a4e7d73d4ab55d651da6b65)
I believe it is what ancient man called "fun". Yep, just checked, it's damn fun.
I would give you a million high fives. Excellent library, with fantastic naming. 
That's correct, the original is not Ruby at all. I chose it because of the order of the words. `fight! if ready? &amp;&amp; set?` just doesn't look as cool. ;)
whatever
Have a look at http://zencoder.com/
Assuming you are the rcov guy... same username on github... Thanks, that means a lot to me. :)
ZenCoder is even supported by Heroku, too. Worth checking out!
Since syntactic uses ruby -c it can't check everything. You need to run the code to find all the warnings.
No, not at all. I read the docs when I begin working with a project, but it's much more difficult to memorize weird naming conventions when they don't follow the same (overall) consistency as many other gems.
Erm, that's for transcoding (i used them just this weekend!), but it isn't a video platform like Kaltura at all, and it also isn't free software, it's SaaS On that note, http://www.pandastream.org/ is free software
Fork it and add aliases then if it's that important to people, and clearly there are alot of people here who would like it to have a normally named API. If someone does this I'll pull it. To be honest, I find CsvPirate API much easier to remember than FasterCSV for equivalent tasks, and perhaps it is because the analogy works in so many cases, like the "figurehead" being the "header", etc. I have to look up FasterCSV api every time I need to modify code or implement something with it. Maybe that's just because I wrote it. I find that people generally remember what the booty is though (columns/data-retrieval-methods). :)
Oh, somewhere over [here](/r/rails)
I'd fork and apply, but I work with CSV in my apps maybe once a year, lol.
I was just thinking this - I'd love to have a copy just running in the background on my machine. A quick hostnames tweak and rubular/ points to the local copy. It doesn't appear to be open-sourced - does anyone know of any similar, freely available projects? If not, I'll whip up a 1.9-compatible version and open source it. [pertinent Everyday Scripting with Ruby: For Teams, Testers, and You](http://www.amazon.com/gp/product/0977616614?ie=UTF8&amp;tag=polidebanews-20&amp;linkCode=xm2&amp;camp=1789&amp;creativeASIN=0977616614).
hehe
Well, you could probably quite easily write one. [pertinent Everyday Scripting with Ruby: For Teams, Testers, and You](http://www.amazon.com/gp/product/0977616614?ie=UTF8&amp;tag=idenprop-20&amp;linkCode=xm2&amp;camp=1789&amp;creativeASIN=0977616614).
ruby, unlike python, isn't much used outside of a web framework. if rails loses steam, ruby suffers along with it .
Upvoted for silliness :-) I probably wouldn't use it since I'd get confused by the syntax but if it makes your coding enjoyable for you then I'll raise me flagon to ya!
Disaster. Really. I started with Rails back in 0.10. Back then, Rails promised developing websites would be easy: - Sensible defaults and convention, as opposed to configuring a dozen hundred-lines XML files to even get started - Clear separation of logic and presentation (MVC) - Fast development (of websites) - Performance would improve rapidly thanks to all the people working in Rubinius, JRuby, YARV, etc What do we have now? - So much convention it's often difficult to follow code. This violates the principle of least surprise and is even worse than editing XML files to get configuration right. At least when I edit XML files I see everything that goes on. With Rails, mysterious things happen and it's due to some convention you don't know about. - Code is a mess of Ruby, HTML, Javascript, CSS and whatnot. I was horrified when I took Redmine a couple of years ago. - Turns out developing with Rails is not much more faster than any other solution. Developing with ASP.NET is much much faster, for instance, thanks to Visual Studio. - Performance is still very very bad I gave up on Rails in mid-2007, when I found about [Wt](http://www.webtoolkit.eu/). Yes, I'm hardcore: - I like to develop webapps in C++ - I like to forget about pages, hits, sessions, etc and think only in terms of widgets, like in a desktop app - I like the performance: absolutely awesome, it runs on embedded environments with a 400MHz processor a 2MB of RAM - Deployment is a joy (essentially, copy one big file) 
Good for you, want a round of applause?
I was just thinking this - I'd love to have a copy just running in the background on my machine. A quick hostnames tweak and rubular/ points to the local copy. It doesn't appear to be open-sourced - does anyone know of any similar, freely available projects? If not, I'll whip up a 1.9-compatible version and open source it. [pertinent Everyday Scripting with Ruby: For Teams, Testers, and You](http://www.amazon.com/gp/product/0977616614?ie=UTF8&amp;tag=idenprop-20&amp;linkCode=xm2&amp;camp=1789&amp;creativeASIN=0977616614).
Love using Rubular... great tool. Just wish it worked offline as well... [pertaining to Everyday Scripting with Ruby: For Teams, Testers, and You](http://www.amazon.com/gp/product/0977616614?ie=UTF8&amp;tag=polidebanews-20&amp;linkCode=xm2&amp;camp=1789&amp;creativeASIN=0977616614).
[yos_hiko exists only to produce spam](http://www.reddit.com/user/yos_hiko13)
[goldina_w exists only to produce spam](http://www.reddit.com/user/goldina_w)
That is cool, I never knew about [LASER](https://github.com/michaeledgar/laser) before. Good to see more solutions to the perceived pain-points in Ruby.
* Deploying doesn't have to be painful. There are _many_ alternatives to Capistrano, such as [vlad](http://rubyhitsquad.com/Vlad_the_Deployer.html), [inploy](http://blog.js.hu/2010/07/14/make-rails3-deployment-more-robust-with-inploy/), [ScrewCap](http://gammons.github.com/screwcap/) and [deployml](http://github.com/postmodern/deployml#readme). Gem dependencies are now handled by `bundle install --deployment`. * Blame [W3C](http://www.w3.org/) for HTML, CSS and JavaScript, not Rails. :P * [Redmine](http://www.redmine.org/) is not the best example of a modern Rails app, it still doesn't support Ruby 1.9.x. * You can also develop Rails or Ruby apps in an IDE. [RubyMine](http://www.jetbrains.com/ruby/) from JetBrains is quite popular, and can slurp up [YARD](http://yardoc.org/) documentation for it's InteliSense. * Performance bugs still pop-up in new code, but we can [profile, isolate and fix them](http://rhnh.net/2011/05/28/speeding-up-rails-startup-time). Also, everyone can start using [Ruby 1.9.2](http://www.ruby-lang.org/en/), [JRuby](http://www.jruby.org/) or [Rubinius](http://rubini.us/) today. Your right though, not every web-facing project has be built with Rails. The Ruby community now has [Rack](http://rack.github.com/), [Rum](https://github.com/chneukirchen/rum), [Cuba](https://github.com/soveran/cuba), [Sinatra](http://www.sinatrarb.com/), [Padrino](http://www.padrinorb.com/) (based on Sinatra, but with more organization/helpers), [Jekyll](https://github.com/mojombo/jekyll/wiki) / [Nanoc](http://nanoc.stoneship.org/) (for static sites), [Goliath](http://www.igvita.com/2011/03/08/goliath-non-blocking-ruby-19-web-server/) and many more projects that I'm forgetting.
"PHP, the piss of the internet." -Anonymous
Thanks. I don't see why code, open source nonetheless, has to be all button-down all the time. I am disappoint in this sub-reddit.
woody2shoes: srsly rubyrogues, railscoach, teachme2code, etc, etc aren't you doing too much? it's a little bit much IMO. 
 if ready? &amp;&amp; set? then fight! end preserves the order of the words and is valid ruby. It does have that pesky "end" though.
I'd avoid this and here's why: * It adds yet another application layer to your stack * It defines the object association at the view layer (not the controller level) * Separates your models from your javascript (why does your javascript understand your application differently? is it a one off case? code it as such.) Just my two cents, looks great though, but double edged.
By the gods, excellent!
How is this getting downvoted? I know there's a lot of ruby heads here, who don't use rails, and ruby is after all a scripting language, but a web app is the most common use for ruby, is it not?
Interesting perspective. I obviously see it a bit differently. For one, I see crafting a public JSON/XML API as a representation (or view) and that view logic belongs in the view. Setting up these arbitrary representations and filtering and renaming columns simply isn't business or domain logic. It certainly doesn't belong in the controller (where I often see it in the wild) and yet it also doesn't belong in the model either. It belongs in a presenter or a view. This also has a lot of benefits. It is much easier to version your API because you can simply create templates for each version separating the representation from the model. It also makes controlling your responses much simpler. Most people end up coupling these custom hash responses in their model and overriding as_json or to_json. This is a hack at best and is hardly a best practice for managing an API. Also with these approach you get JSON/XML formats both for free based on the agnostic template. It is separation of concerns. It doesn't add an application layer anymore then having HTML views does. It does not define the object association at the view level. It defines it at the model level. The only thing happening in the view is the presentation of the association. There's a big difference. The presentation of the child element is entirely view related. The models are separated from API anyways whenever you build public APIs. Public APIs are *rarely* one-to-one with a data schema supporting them in practice. Public APIs are almost always intentionally limited and serve to present the data in the flattest and simplest way possible to make developers lives easier. No sense muddling up a simplified representation with the actual data schema. They often are necessarily different. We are now using RABL for our entire API and it has cleaned up our models and controllers quite a bit more then we expected. It has made versioning a breeze and keeps the view logic where it belongs. I would encourage you to give it a try before writing it off. We have just released a helpful guide about building public APIs in Rails here: http://engineering.gomiso.com/2011/06/27/building-a-platform-api-on-rails/ hopefully that can serve as a getting started guide for somebody new to view-based API declarations.
JSON &amp; XML are data exchanges, object notation, right? Models are objects too. I believe that the further you craft a data exchange away from originating source, the more convoluted the solution becomes. It's not very RESTFUL either. (Why can't it just work with ActiveResource? And yes, this isn't an all-in-one case) Rapidly versioning an API isn't developer friendly either. I think it also pushes against softer lifecycles. When you're able to create a data schema and presentation layer closely related you have a highly successful api, look at freshbooks for instance, it's up to the developer and business to decide what the best implementation is for the solution. I don't think they're completely rare either, just well thought out. That kind of my point though, if you only have a few use cases, it might not necessary to work against conventions, look at the big picture and reevaluate if it's necessary.
Fair enough, I agree the right tool really depends on the situation. In a simple private API everything would be hooked up 1-1 and the model and representation match exactly. I just find that when building out a developers platform, a lot of the columns you find you don't need to expose in a public API and very often it becomes necessary to include custom representations of attributes or associations. Not saying it is impossible to create exact model-&gt;api public APIs but I will say if you look at most popular developer platforms (i.e instagram, twitter, facebook, et al) most of them I can tell you first-hand do not expose their API in a way that resembles their exact data schema in any recognizable way. Anyhow I think we are roughly on the same page and I think the decision does have to be made on a case by case basis from the context and the goals of your API.
Example of where I might use this? I assume Ruby has basic functions to get web resources. Is this just a way to do it persistently? Seems like something that should be rolled into Ruby.
If you use Net::HTTP but only run one request per call to ::start switching to net-http-persistent can give a speed boost. Persistent connections avoid an extra SYN/ACK round trip and TCP slow start for every request. Net::HTTP handles most of the work of maintaining a persistent connection, but not the part about when its ok to retry. This latest update allows you to rety when the spec says you can't (but you should determine it will be OK to do so). It should be rolled into ruby, but it's not ready yet. It needs more, like mechanize's user-agent library to handle the other important user-agent features. I'll be proposing incorporation when it's ready.
it's cute, but really image manipulation is the *last* thing that should be written in pure ruby, it's nice as a toy, but far too slow for serious use. Rewrite it as a C extension, you can provide the same API and not lose any performance. Further rbx and jruby both support the standard C API so it'll work on those too.
Good point, and something others have thought about too. There are C extensions to the native ruby manipulation called oily_png for chunky_png. Chunky PNG also supports RMagick in and out. 
If this is interesting, you might want to check out this week's code brawl: http://codebrawl.com/contests/pixelizing-images-with-chunkypng
At first I thought: Same basic problem area as RABL, right? I haven't actually used either of them, just read docs/tutorials/blogs, but I think I like RABL's approach a LOT better. Then I realized, wait, API Smith is for building _clients_, not servers? Okay, that could be kind of cool. 
No. While the Syck parser temporarily ruined YAML, it's still useful for representing key-value data and comes with every Ruby. You can define [arbitrary blocks of text](https://github.com/ronin-ruby/ronin/blob/master/gemspec.yml#L13-33) in YAML, a lot easier than in Ruby. YAML also ships with every Ruby environment, no extra dependencies. Finally, YAML has a Specification, so your data will not rot overtime and become legacy cruft.
Also no. YAML is great for sharing data amongst different languages, if need be. YAML is lame because of one line of code? Don't get it. The more complex your config, the more punctuation you'll need. Keep it clean, stay with YAML or something like it. Your users will thank you. 
Great, so we've cycled back around to "Code is configuration"? Data is data. Code is code. The two are separate and should be kept distinct. Configuration *code* should be code, but it should *always* be driven by static data. When your configuration is code, you increase your attack surface, increase the possibility for a configuration mis-step to cause *drastic* problems in your application, reduce portability, and introduce about a half-dozen other potential problems. Keep your code and your data separate, for the love of all that is right. Bonus: Try using your ERB configuration files from a different language.
His example is too verbose as well. :foo: :bar # =&gt; {:foo =&gt; :bar} There, fixed it.
I like it, but I don't think I need it. &gt; It adds yet another application layer to your stack I just see this as the equivalent of builder for xml &gt; It defines the object association at the view layer This bit is a little murky, maybe it could be done a little better (using the instance objects from the controller?) &gt; Separates your models from your javascript (why does your javascript understand your application differently? is it a one off case? code it as such.) I don't have a problem with a view being a subset of your model. 
You have one colon too many
I prefer heredocs for arbitrary blocks of text. You can left align them to keep yourself sane.
Yeah I would say they are actually complementary. Build the API with RABL and consume it with API Smith.
Naw dawg, he is just performing some hot symbol-on-symbol action.
I'm not convinced. In fact, the more times a person says "always" and uses italics, the less convinced I am, in general. I'm curious about the six other potential problems. But most of all, I feel someone is reaching when they bring up "portability." I wonder what percentage of YAML files are ever ported from a Ruby app to one in another language? Fewer than one in a hundred, I would guess. My other big objection is to drawing a sharp distinction between configuration and execution. Rails became popular precisely because it draws that distinction far less sharply than other environments. Remember "convention over configuration"? Where are those conventions stored? Not in YAML files, that's for sure.
valueForKeyPath mmmm... delicious. http://www.spice-of-life.net/wodock/api/com/webobjects/foundation/NSKeyValueCodingAdditions.html
who is this knob-end avdi? the guy has barely any open source contributions (his github is pretty crappy) yet he feels he can lecture to the ruby community? He also has such strong opinions. He wrote one crappy book that he CHARGES money for whereas _why, zenspider, tenderlove wrote huge ruby libs (much harder to write a lib than a crappy book) that they give away for FREE. I'm sick of him and his stupid long hair. He has to earn some credibility by actually writing software that rubyists use before he starts condescending to everyone.
* Executable configs require tighter access control and more review for changes. For example, the WoW addon community has seen innumerable issues with addon localization, wherein Wang Lo the Chinese Localizer Who Doesn't Speak Lua adds a Chinese locale in interpreted Lua code, screws something up, and breaks the whole thing for everyone rather than just screwing up a translation. * Executable configs can break between versions of an interpreter. See: Changes in Ruby's hash syntax and the changes in the lambda/proc convention. * Executable configs have a tendency to attract nasty hacks and "it doesn't fit anywhere else" kludges. Data configs offer no such holes. * Configuration in code is far harder to update from code, whereas a serialized data format is trivial to both read and write. * Executable configurations just nearly invariably result in global namespace pollution. This becomes particularly evident if a config is ever re-used in multiple contexts. Portability is something that I specifically experience with. I have two large applications that have crosstalk between Rails and PHP/Python (database connection info, environment info, navigation data, localization data), and in both cases, I had to move configuration *out* of PHP or Python arrays into some intermediate format (YAML, incidentally), so that we weren't going to have to maintain native-language configurations in multiple places with potential possible desynchronization. Sure, probably not a concern for some people, but the issue absolutely exists, and it illustrates why you should keep your data and code separate. "Convention over configuration" in the Rails sense doesn't refer to the sort of configuration that would typically belong in a static data file. It refers to things like table and field naming conventions, where ActiveRecord would just Magically Work and infer all sorts of relationships without having to be explicitly defined. Writing `belongs_to :user` is obviously far preferable to `belongs_to :user, :class_name =&gt; "User", :foreign_key =&gt; "user_id"` in terms of developer productivity. It was about doing less repetitive typing, not about avoiding data files. Static configuration is very much its own animal, for things like database connection info and API keys and localizations. There are times when configuration in code is appropriate, but it's far too often done wrong just because it's easy, and speaking from experience, it sucks to be the guy six months down the line that has to clean it up.
If it's going to be read by a machine and sometimes parsed by a human, then data needs to be in JSON. If it's going to be read by a human and sometimes parsed by a machine, it needs to be in YAML.
FUCK AVDI AND HIS STUPID-ASS HAIR! (or, alternatively, stupid ass-hair.)
Thank you, this made my day!
You have gone TOO FAR sir, when you insult a man's ass hair!
shit, he’s out to get me D:&gt;
Yeah, and I've got STRONG OPINIONS so you best watch out.
yeah.. write something awesome first mr. avdi.
heredocs work, although they breakout of the indentation of the code. stuff = &lt;&lt;END What happened to my indentation? END
I was showing the YAML equivalent of the authors configuration code: SomeLibrary.config = { :foo =&gt; :bar } 
:P Maybe broken was too strong a word - javascript just constantly suprises you. for example; var i = "whatevers"; function hi() { console.log(i); var i = "new"; console.log(i); } hi(); that second var in there makes the line above it print undefined. take it out and you get proper closing over. vs. i = "whatevers"; hi = -&gt; console.log i i = "new" console.log i hi() no var so no problems.. coffeescript automatically adds the vars in the right places to make the scoping sane. This is a real example from a real bug found in jquery recently. 
I was thinking about this issue today actually. I think it's a good idea to come up with this, however I feel the implementation needs some work. For example I would have implemented it with something like faraday instead, which has support for pluggable adapters, including em-http-request which provides ASYNC support. Which is a huge factor here, because if you're doing a lot of client API calls you're going to have a huge concurrency problem on MRI (but also uses Net::HTTP for JRuby). Also, httparty uses Crack instead of the usual JSON library which is faster. I also found the description to be complicated.. I wasn't actually sure how you would make a simple example and then call the API. And if you are making a model for the API, chances are you know the url.. why specify it on instantiation? It would have also been nice to get some other features here like validations support. I may be implementing something similar in the near future, simply because I need it and this unfortunately isn't quite what I need. I do love the properties though!
link please [here you go errbody](http://blog.mostof.it/interactive-editing-in-irb-test-ideas-like-a-pro/)
Sorry, something got messed up http://blog.mostof.it/interactive-editing-in-irb-test-ideas-like-a-pro/
Well done you sadistic bastard!
Then use &lt;&lt;-END
I'll just answer briefly. I do think you raise some good points - I just don't think they're generally applicable. There is no change in Ruby's hash syntax. There is an additional syntax that is supported. Changes in the treatment of local variables should not affect any sane application. But neither of these is an argument against using code, since any config file must be interpreted by code itself, which is subject to those same arguments. In fact, such interpreter code can be quite a bit more complicated than simply doing what you want in the code in the first place. I am not concerned with the opportunity for nasty hacks, nor for idiot-proofing. The degree to which these things is important depends on one's working environment. It could easily be that the WoW add-on community is better served by config files than by code. Rails most definitely eschews configuration files over convention. The best example is the mapping between database columns and object instance variables. In other systems, you have to define this mapping, typically in XML. Not in Rails. And when you need to override the mapping that Rails performs in code, what do you use? More code - as your `belongs_to` example showed. Rails has many other places where a block of code is executed intead of a data file being interpreted (as the source article to this thread showed). Portability is very important - if you need it. If you don't, it's gold-plating. The vast majority of code in my experience will never be ported. Finally, doing things "because they're easy" is an excellent philosophy, in my book. :)
delete this post now, since youve reposted it.
how does this compare to [pry](https://github.com/pry/pry/) ?
Hey that's handy! Although it still doesn't eat leading white-space from `each_line` like the YAML `|` specifier does: puts &lt;&lt;-END indent END YAML.load("foo: | one two ")
The url portion passed in as an argument is only an example of the data transformation / data portion - the actual client code (see ClickyClient client class) has a base_uri class method you can use. One of the things I do plan on adding in the near future is better tools to override urls (e.g. to work with, for example, things like twitter clients that work across different implementations of the api by third parties slightly easier). Lastly, I am planning to move to faraday - the reason I originally went with httparty was because we were rapidly prototyping stuff as we went and I didn't know faraday well at the time so I figured it'd be faster and simpler to work with - Your point about it using crack is exactly why I want to switch to faraday (as well as giving a response middleware you can add processing to).
Very much so - We have another library (Which will hopefully also be open sourced in the future) that handles the server portion for us but RABL is just as good a choice. API Smith is badly named (since it's not about creating api's, it's about consuming them). Alas, I completely missed (rather badly I must say) how bad a confusion the name could cause.
"This week’s challenge is to pixelize the image below, so your resulting image is built up from blocks of 10 by 10 pixels. Remember: you can’t change the size of the image." It's not clear to me how to build a 300x225 image out of 10x10 blocks since 225 is not a multiple of 10. Is there something I'm missing here?? Link to image: https://gist.github.com/raw/5dace61b37de19a56637/032f70a3023e37a7dc1fe4a619cd8c4f970d1677/output.png
weird and totally undiomatic use of the `[]` method. This is probably the first time the `[]` method has been used to SET state in the entire history of the world. Creepy.
Then don't add any?
sounds like you want to make a pull request =P
Sorry, bad example. What I meant to say was: module Foo def self.foo str = &lt;&lt;-END 1. one * two 2. three END puts str end end Foo.foo Produces: 1. one * two 2. three ^^^^ \____ leading white-space As opposed to: foo: bar: baz: | one two three YAML.load_file(...) # =&gt; {"foo"=&gt;{"bar"=&gt;{"baz"=&gt;"one\ntwo\nthree\n"}}}
No state is set, it just [wraps around the String argument](https://github.com/janlelis/paint/blob/master/lib/paint.rb#L59-61), sort of like `Set.[]`.
`Set[]` and `Hash[]` are essentially constructors for their respective types. His use of `[]` while maybe not setting state is still pretty unusual. It's not a constructor (in so far as it's not returning an instance of a `Paint` object); i've never seen anything like it and i'd say it's unidiomatic. Why didn't he just use a top-level method? Instead he's got a class/module that looks/behaves like a top-level method. He might as well define a `Paint()` method or better yet a `paint()` method. 
Yeah it definitely made me look twice, since I've never seen data _and_ options being passed to `[]`. I'm not sure why `Paint()` wasn't used, or a mixin module with a `paint()` method. At least there is still this [last resort](https://github.com/janlelis/paint#fork_box).
I am using `Paint.[]` to keep the global namespace clean. I even thought about stuff like `Paint("string")[:options]`, which looks really cool. Although, I don't think it would be bad code to use `Paint()`, you are now free to choose if you want to define a `Paint()` or `paint()` method. It doesn't create some kind of `Paint` object to keep things simple and quickly get the object you are interested in: a colorized string.
Yeah a play on words with something consumption related might have been a good way to differentiate. Nonetheless, looks like a cool library. I would be curious to hear more about what you guys use for building the server-side APIs. Is it an extension/hack on to_json, json view templates, or another approach?
I've been working on this exact same problem for a while. Nice to see that people are running into the same problem. Write enough libraries around HTTP services and they all become the same. They get really boring to write and more of a bitch to test. It's a repeatable enough pattern to extract it into it's own library. The last example is too obtuse imo.
What is the motivation for making this? edit: didn't mean to offend. I'm genuinely curious as to what prompted you to make this. There is no right or wrong answer, I'm just curious.
What is the motivation for making Paint?
Can anyone post a screenshot/demo of this in action? I know I should find the time to take it for a ride, but I just can't seem to.
It just makes colored text on terminal emulators...
This is the basis for LASER. The paper's pretty good (the first bits are for Ruby newbies), and errbody should be excited for LASER. Let's hope it gets accepted into RubyConf 2011.
That's my thesis - uhh, AMA?
Is your name Michael Edgar?
Yes!
/squints Story checks out. 
So do you envision there being easily available tools for doing more in-depth static analysis on dynamic languages soon? Do you think there are aspects of Ruby that make it more or less amenable to this vs. other languages like PHP, Javascript, or Python?
&gt; So do you envision there being easily available tools for doing more in-depth static analysis on dynamic languages soon? Absolutely, and they're already getting there - pylint is an excellent tool for Python, [JSlint](http://www.jslint.com/) and the [restrict mode](http://restrictmode.org/) checker for JavaScript are great too. There's been work on an optimizing PHP compiler, [phc](http://www.phpcompiler.org/), as well, though I don't know if it does much to find bugs or just compiles. &gt; Do you think there are aspects of Ruby that make it more or less amenable to this vs. other languages like PHP, Javascript, or Python? In the general case, it's less amenable, but I personally find that makes it more fun to work on. 1. There's more than one way to do everything - see my blog post on [block usage inference](http://carboni.ca/blog/p/Laser-Infers-Block-Use-Patterns) and I bet you'll learn something unexpected. Having widely-varied syntax and ubiquitous use of blocks means the tool needs to be able to understand a lot of code before you can understand anything, if that makes sense. These aren't asymptotically-significant challenges - but there's this sense that there's always something you're missing, and you're usually right. 2. Widespread use of metaprogramming, `eval`, reflection, dynamic constructs like `{method,const}_missing` make analyzing real code hard. While these are possible in PHP, Javascript, and Python, they aren't used nearly to the extent that they are in Ruby. 3. Parsing Ruby is just plain hard. The other languages you mentioned have relatively simpler grammars to deal with. I use Ripper which is brutally hacked into the YARV bison grammar, and it's had some really glaring bugs along the way. 4. Ruby has a fair amount of implicit semantics - some of which can be strange. Like how local variables are created by the parser, all the block argument-munging semantics... it's hard. That said, you can do anything in Ruby you can do for those other languages - it's just a matter of how hard you have to try. And Ruby doesn't have ridiculous constructs like PHP's `$$var` (or `$$$$var...`), or the rest of PHP's design disasters. But things like `const_remove` *ruin* lots of opportunities, and that's one of the few constructs I simply do not handle.
Thanks so much for that info. You should do a real AMA in /r/programming or something, I think it would be really interesting! Another thing I'd like to know about is the possibility of synergy between static analysis techniques and some of the runtime performance enhancements that are going on in the javascript world, but maybe I'll wait for your AMA. :)
&gt; Another thing I'd like to know about is the possibility of synergy between static analysis techniques and some of the runtime performance enhancements that are going on in the javascript world This is something I'm most excited but most cautious about. Right now my implementation is *not* conservative - it will incorrectly interpret a subset of Ruby programs. But it's true that static analysis could make lots of optimizations possible - if Laser can simply prove the absence of calls to, say, `Proc#binding` on a given block, the block itself and the enclosing scopes can be optimized in a big way. I already do a fair amount of constant propagation that I don't know to exist in the current implementations, but it is quite likely that their respective JITs find the same constants; dead code/useless variable optimization is in there as well (only for warnings). Some of the JavaScript stuff happening is actually kinda far ahead of what current Ruby implementations can take advantage of simply due to crazy stuff like `Binding#eval`, constant removal, etc. I expect Rubinius to be the best eventual target for this work, but who knows.
Can the analyzer analyze itself? ;-)
what grade did you get? (btw what does AMA mean?)
That's actually a really important goal of any PL project: compiler writers want to bootstrap, analyzer writers want to analyze their analyzer. Right now, it can't analyze all of Laser, but it *can* handle some of the cooler metaprogramming techniques I use. That's a big goal I want to reach though!
AMA = Ask Me Anything I got an A. And "high honors." Word.
 user system total real str.include?(x): 0.220000 0.000000 0.220000 ( 0.224157) str =~ /x/: 0.620000 0.000000 0.620000 ( 0.619257) str[x]: 0.480000 0.000000 0.480000 ( 0.476655) str.match(x): 1.240000 0.000000 1.240000 ( 1.244419) str.scan(x): 2.260000 0.000000 2.260000 ( 2.259026) EDIT: as indicated below, casecmp is bailing after the first character (duh), so I pulled it out. And the regex is not compiled on every iteration.
Nit: `casecmp` is the case-insensitive version of `#&lt;=&gt;` - so doing `"a.b.c.......".casecmp('x')` is just going to check the first character and bail out as -1. It's not checking for inclusion.
Mmm...casecmp is not really equivalent to the rest of those methods, since all the rest are searching for a substring, while casecmp is only doing a comparison of the strings. I would have expected =~ and match() to be equivalent, but it looks like there is some difference in behavior which causes a performance difference even when match() is given a regexp.
proper nit!
no offense, but it was actually me who wrote this and you're taking credit for my project. just sayin
String#match must create a MatchData object. String#=~ does it lazily.
Where are #index and #rindex ?
 user system total real str.include?(x): 0.220000 0.000000 0.220000 ( 0.220683) str =~ /x/: 0.490000 0.000000 0.490000 ( 0.488704) str[x]: 0.470000 0.000000 0.470000 ( 0.472842) str.match(x): 1.250000 0.000000 1.250000 ( 1.251247) str.scan(x): 2.040000 0.000000 2.040000 ( 2.038398) str.index(x): 0.240000 0.000000 0.240000 ( 0.239646) str.rindex(x): 0.410000 0.000000 0.410000 ( 0.404449) Different box. ruby 1.9.1p243 (2009-07-16 revision 24175) [x86_64-linux] Linux .. 2.6.32-30-generic #59-Ubuntu SMP Tue Mar 1 21:30:46 UTC 2011 x86_64 GNU/Linux model name : Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.40GHz model name : Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.40GHz model name : Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.40GHz model name : Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.40GHz
Not sure what you're looking for perhaps: [EventMachine](http://eventmachine.rubyforge.org/EventMachine.html)?
I always wondered why the ruby stdlib did not provide a `ThreadPool` class? Although, it is easy to roll your own using [Queue](http://rubydoc.info/stdlib/thread/1.9.2/Queue) and an Array of Threads.
I'm looking for something to spawn k threads and take n &gt; k blocks for the threads to execute and have each block executed by one of the k threads. The blocks will (among other things) modify some shared data that I will protect with a lock.
easy, you say? pastebin or gtfo ;)
Ah, interesting, you could write something easily enough. These are from googling `ruby thread pool` http://stackoverflow.com/questions/3840751/why-doesnt-ruby-have-a-threadpool-built-in http://snippets.dzone.com/posts/show/3276 http://burgestrand.se/articles/quick-and-simple-ruby-thread-pool.html http://burgestrand.se/code/ruby-thread-pool/thread-pool.rb It seems ruby doesn't have a threadpool in standard lib because you can make one easily enough with queue / thread. 
I can do one better :) http://lmgtfy.com/?q=ruby+thread+pool
This reminds me of [threaded map](http://www.reddit.com/r/ruby/comments/89eaf/threaded_map_screencast). I forget the name of the gem that provides this monkey patch to Array/Enumerable.
gem install work_queue
do you really think i didn't do this before posting my question?
Thanks, I saw all of these when I googled before posting here. The last one is the only promising one, but I was hoping for recommendations from people that have actually used an implementation in production.
more of a threaded #each rather than #map, but you get the idea.
Is this for a rails app? There's a couple of gems for queuing: http://ruby-toolbox.com/categories/queueing.html https://github.com/defunkt/resque http://github.com/collectiveidea/delayed_job https://github.com/purzelrakete/workling 
I assumed that if you were asking about a Thread Pool, you probably hadn't looked at existing Thread Pools. They are really easy to implement using Array, Queue, Mutex, Thread. Here's an example [Thread Pool](https://github.com/postmodern/threaded_server/blob/master/lib/threaded_server.rb) I wrote for accepting network connections.
I'm still trying to think through in what cases I'd actually need this abstraction, instead of just the 'bare' http client library plus data structure. "* Converting API responses into Ruby objects should be a straight forward and simple process." Turning XML into a nokogiri object, or JSON into a hash is pretty straightforward and simple. "Extracting parts of a response shouldn’t be complex." The API's for extracting parts of a response from a nokogiri object or hash are.... well, generally not complex for my use cases. Maybe this is the tipping point, when what you need to extract is no longer easy with selectors against nokogiri or hash/array accessors against a json data type? "HTTP is your friend and should be simple." Well, now here's a real problem, ruby's HTTP client libraries have TERRIBLY INCONVENIENT APIs. But this is a general problem not limited to API consumption. Although that is a main use case for HTTP in my life, this is still a problem that wants a generalized good HTTP client library in it's own gem de-coupled from an "api client" library. On the other hand, several (or more) have tried their hands at that, none have yet become apparent as the de facto standard, which is really part of the whole problem, without a de facto standard (because Net::HTTP is so inconvenient to use and generally awful), every gem uses it's own library and it's a mess. 
Threads in ruby &lt; 1.9 are an awful hack job.
Why not just email the errors yourself? 
[Here's a diff of the ChangeLog between this and the last release.](https://gist.github.com/1061046)
Uh... Logger is already thread safe. There's no need to wrap it up in additional synchronization.
anyone know of an ETA for the release date of 2.0?
Christmas! The year, though, is presently unspecified.
Sounds like Perl6. ;-)
Some syntax highlighting on that gist: https://gist.github.com/1061787
fwiw, 1.9 was also scheduled for xmas for maybe three years?
Last I heard, it will still be [a few years](http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/34066).
"Allioth Shootout -- Silly" made me laugh. :)
An oldie but a goodie
Any talk of a better type system? Optional typing or type inference perhaps? How about pattern matching? Function overloading? Anything interesting at all?
Interesting: selector namespaces, traits, prepend, named parameters, multiple VMs in a single program, a new light-weight embeddable ruby (rite)
I am not saying those are not interesting but no tail call optimization? Nothing at all performance related? 
he just said performance will be improved, he didn't say anything specific iirc. Why don't you watch the vid yourself? :)
[Zed Shaw is now the official leading spokesman for the C programming language](http://www.reddit.com/r/programming/comments/ifd7e/learn_c_the_hard_way_zed_shaws_started_work_on_a/), so there are much more important things for you to do than wasting your time on this petty argument about Ruby. Get on it! 
I just didn't feel like watching a half hour video. I kind of wish they took some hints from mirah. So many people have so many good suggestions to improve ruby but Matz seems to be ignoring most of them. Sigh. 
Hey my stalker is back! You are zed aren't you? You only come out on zed threads and you love zed more than you love life. 
To answer some of the questions you pose at the end. Yes, Rails 3 exposes any GC issues more because it was designed to be more modular (pick and choose the parts that you want), thus causing more smaller files, and more object allocation. Also, to be completely honest, rails 3 on the whole isn't as fast as rails 2. The features have come first, and the optimising is hopefully not far behind. As to why there aren't more people noticing the GC issues in rails 3 earlier, I think that largely comes down to a combination of both an applications traffic profile, and the complexity of the application itself as to whether GC poses a problem. I know that a large amount of the ruby/rails community is still using 1.8.X (whether that's REE or not), so I get the feeling there's a decent number of people running rails 3 under 1.8.X, and so suspect that the GC issues aren't a noticeable problem for most people.
this read like a troll post, and if you read the comments, its clear that most of them has never worked with ruby or rails..
Railsonfire provides simple Continuous Integration for Ruby apps hosted on GitHub. We are currently in Beta and would need your feedback. If you got any questions we will answer them here or send an email to contact@railsonfire.com or a tweet to [@Railsonfire](http://twitter.com/railsonfire).
I am not the sharpest knife in the drawer, and I just don't think Rails is all that complicated to learn.
ah nice thing, will try it out
Same. It never struck me as particularly hard. Sure, there was a learning curve, perhaps steeper than it could be, but then again, I'm a big boy, I'm okay using big boy tools that don't make sense on the first read through. Things can be difficult and still be good.
ill give it a shot as well
TIL Zawodny works for craigslist. I used to read this guy's blog on a semi-regular basis when he was still a Yahoo! employee... and a little heavier. I suppose he thought that he wasn't expecting a whole lot of change from the Rails 1.x days when he took Rails 3.0 for a spin. 
Would be really useful for me, thanks!
I'm curious: What's your specific use case?
Personally i think that there's way too much magic in rails. I prefer Sinatra, even if it also has it's faults. Still looking for that one web framework where everything just says click. Kinda like pythons flask, but well, it's python :/
Isn't it obvious? This is a much better alternative than CSV exports .. The customer doesn't even need Office or whatever installed. Then can they export to Excel if they want to; or work with the data straight in Docs.
Yeah pretty much what Ralf said. Exporting simple reports would be easier. We work on e-commerce sites, so quite a bit of stuff can exported. 
I think Rails is complicated if you want to learn it as a traditional web framework and try to fit it with traditional web site. If you learn Rails as a resource-centric control system that runs through HTTP protocol, there isn't much complication in Rails. Generate a model, list it, show it, edit it, update it, add an action to it. I think Rails is still simple to one who learn Rails "the Rails way". Those who already know what "web application" is and tries to learn Rails their own way ends up starting with "harder things in Rails" first. For example, in any other web framework, a web applications that do some custom action without hitting any database would be consider "simpler" than one that hits database and list/show/create/edit the resource. But in Rails way, the latter one is the simpler one.
Whenever someone tells me that Rails has too much magic, I always think of that old quote: "Any sufficiently advanced technology is indistinguishable from magic" The thing for me is that the magic is only magic at first, once you get over the learning curve, it's not magic any more, it's science. Don't take any of this to be an indictment of you or your opinion. Sinatra is a kickass framework which is high on my list of things to mess with. But -- I guess is just seems like people think that a framework is just supposed to be this thin wrapper around a protocol. I'm all for simplicity, but the reason I want to use a framework is to save me the frustration of what boils down to rolling my own. By allowing for magic, which is really just a name for convention internal to the framework, I gain the benefit of not having to write a great deal of code. I guess my view is twofold. One, I view code as conversation, Rails gives me a common context with which to communicate my ideas to fellow programmers and future versions of myself. Second, it's all about the right tool for the job. If I just need an simple API with few resources to expose, then the startup cost of Rails (in terms of development overhead, and not necessarily speed), might not be worth it. But for a whole-application problem. With all the details that come with that. A "full" framework like Rails makes more sense. I dunno, maybe the best way to word it is that I don't think it's ever a bad thing to learn more tools. I goes with the notion of craftsmanship -- a carpenter doesn't have just one kind of hammer, and one kind of nail, he has specific tools to do highly specialized jobs. That's what I want. Rails is my sawsall, it'll do most of what I need most of the time. Just like we can't discount the "smaller" tools, we also can't discount the old standbys. I'll have to look at flask, since I've never heard of it till now, but I'm pretty bigoted against python on philosophical grounds (there is _definitely_ more than one way to do it.)
rails programmers are, for the most part, a bunch of ninnies. a sizeable portion of them hardly even know ruby very well. They just mindlessly churn out crappy "webapps". 
no zed shaw is zedshaw.
tl;dr
Rails does have too much magic, some of which is still undocumented and not very well thought out. What confuses new users is that Rails is trying to solve problems with HTML/CSS/JavaScript, by throwing new tools/languages/libraries at it. This increases the learning curve and scares off users.
Sort of like how Java programmers are, for the most part, a bunch of morons churning out shitty Swing desktop apps. C# programmers are, for the most part, a bunch of jerks churning out crappy COM objects. See, I can churn out shitty generalizations too. 
&gt; I guess is just seems like people think that a framework is just supposed to be this thin wrapper around a protocol. This is exactly what i want, more or less at least. A thin layer that removes the "complexity" of rack, but still allows you to have it near at hand.
rails is whats going to kill the ruby language.
except, fucko, java programmers are actually java programmers. rails programmers are often just 'rails programmers' with limited understanding of ruby itself.
You forgot to login as xardox. You need to keep your sock puppets straight zed.
It hasn't so far. 
sounds cool. give it a try soon.
in rails there is only ONE way, the rails way... actually any other way is not welcome in rails community (heck, they even ate up merb so that there will be only one lol...)
I disagree- there is the _default_ way, which is the most common way. But I never feel like I'm totally bound to that way. I can always duck around the framework. Besides, the comment was more on the level of language and not framework, but whatever.
And I think that boils out to the fundamental philosophical difference. It's about opportunity cost, Sinatra/Padrino have very low opportunity cost, it's cheap to spin up an app in them, it's cheap to understand them, but in the end, TANSTAAFL kicks in, and you can't get as much for free out of them -- the benefits of rails complication / magic (in things like the new Asset pipeline, the routing layer, rack, etc), is that it by paying the cost once to understand it, you never have to think about it again. I'm not saying Rails is the right tool for every job, my point is that it's a _different_ tool that should _definitely_ remain in our toolbox.
I can only speak from personal experience here, but I never found the learning curve to be that steep (I started with 3.0). No steeper than the learning curve for any other web framework, anyway. Perhaps I'm just brilliant (or more likely, too arrogant to give up), but the quantity of magic going on -- while occasionally confusing -- never seemed like it was magic without a cause, it was always useful magic, something I knew was saving me time or concern with something minor, something which most of the time I wouldn't care about. Like I said before, I think that people have this notion that a framework can never be "meaty" -- that every framework has to be wafer thin so as never to scare anyone and -- as a result -- never really provide any powerful tools. I think part of the reason rails was successful was that it _did_ provide that magic. I think the distinction needs to be made, there are two kinds of frameworks, big but arcane, and small but straightforward. Game programming is informative here. In the game programming world, the framework is routinely very big, and hides alot of details from you -- look at XNA, it's a big and mystical framework. Compare to raw OpenGL, small but (relatively) straightfoward, compare again to basic BitBlt (absent but utterly trivial). The benefit of XNA is that -- in spite of the magic -- if you're willing to pay the opportunity cost to learn it, you can write pretty impressive little games with minimal effort. I guess -- and perhaps this means I've become the dreaded "Rails hipster" -- I'm okay with people having a hard time getting started with Rails if it makes it easier for me to get my work done, now that I've put a downpayment on the opportunity cost.
I kind of feel like this is a moment for me in the ruby/rails community, I've been trolled by badsex. I feel so proud.
Great job propagating the stigma of the ruby community being immature, by the way. I await your further raging. 
Sure, i understand the point. Right tool for the right job. Now, I've not used rails that much, but i get the feeling that once you want to move in to domain specific stuff, then you'll better off with the thin wrappers then the full stack. The problem with the full stack is that it solves it's target problem very nicely, but (imho) once you move out of that target area things starts to get a bit fuzzy, while in the wrappers you'll have to start thinking about these sort of things from the start and you'll have a better(i'd like to write understanding, but position might be a better word for it) position to do the domain specific stuff.
Hey, why aren't I mentioned in this rant?
Hey, folks, I'm a Ruby and Rails lover, and posted this simply because I find most everything Zawodny says about his technical choices to be interesting. So my prescription is to take with as many grains of salt as are needed.
http://peach.rubyforge.org/
Right-o *tips hat*. A quite pleasant discussion which resulted in mutual agreement. Pip pip.
I rather have performance improvements than more syntactic sugar.
most of these were extremely boring 'novelty' solutions.
cool - helps to speed up development
Short version: I wasn't satisfied with the features of the existing gems. I wanted to have an easy and consistent api that does not enforce string extensions, but also provides 256-color support :)
Ah, 256-color support doesn't exist in the others? Thank you, this is good to know.
This makes me sad. Plenty of excellent analysis of the bug A *fix* for the problem presented **No link** to a filed bug report on the ruby bug tracker. 
&gt; The problem is that the object and garbage collection implementations in REE/MRI/YARV are not valid C code [Citation needed]
Blog posts don't fix bugs, patches do. I guess the community will just have to fix this. :)
The title is somewhat melodramatic. This bug is an implementation mistake, not so much a "broken promise".
TLDR (without angry rant): Ruby's GC searches the stack for pointers to your objects. Your compiler will try to optimize local variables and store them in registers. There's a helpful macro in ruby.h to force write object references to the stack, thereby avoiding this problem.
"broken promise" is a figure of speech. He alludes to it in the text of the article (under the heading **The General Case**): &gt; In other words, Ruby's object and GC implementations are breaking their &gt; contract with gcc.
Did you read the specifics of the fix? The fix has to be applied ad-hoc all over the place, taking specific gems you need into account (and future gems have to be written with this in mind). This is not a reasonable patch to be asked to contribute, *especially* when Joe's done the very difficult work of actually mapping out this bug. 
Your comment is ridiculous given how 'reasonable' and 'well mannered' you are when receiving bug reports.
I think you missed the section "How to detect this bug class"
[Citation needed]
Patches after the fact are the wrong way to go about this. A tool like the one proposed in "How to detect this bug class" would be a decent band-aid, but bringing it to the attention of people who could do something about it certainly won't happen in a bug report.
Oh look, drama.
What about JRuby? Will awareness of this bug boost JRuby development and adoption?
or IronRuby, MACRuby or Rubinius.
What do you use? Rubinius looks very interesting/promising but I haven't heard much about it. It seems like the "systems engineer" who wants a rock-solid Ruby platform is still using JRuby.
I use MRI 1.9.2, and test on MRI, JRuby, Rubinius. Rubinius has potential, but they are still working on 1.9 support and their version of FFI is still broken. JRuby is really solid, except the JVM startup times are horrible on 64bit systems (no client VM profile for x86_64).
TLDR additional: There's also a way to perform static analysis to detect this class of bugs without tripping over them through data corruption or crashes.
I mean this in the same vain as [postmodern](http://www.reddit.com/r/ruby/comments/ihaz1/the_broken_promises_of_mrireeyarv/c23rr46): &gt;The title is somewhat melodramatic. *understatement*. 
this is too primitive, there are a tonne of gems that do this much, much better than this, check out: https://github.com/janlelis/paint as just one example
Kill it? No. Expose some of the fundamental problems with open classes and mixins? Yes. Rails, I think, will be the primary motivator for selector namespaces.
Ruby is an interpreted language. No compilers needed. As for good practices, the rules of thumb are "there's more than one right way to do things" and "if it doesn't feel natural, it's probably wrong". The Ruby community is definitively less stringent with style than say Python (with their PEP 8). If you're absolutely new to Ruby you may want to consider Hackety Hack instead of Why's guide. 
I will definitely check it out. A friend recommend Why's to me because of the way I learn although I will admit, his side-story can deter from study time. 
That being said, there's a lot of convention in writing Ruby. There's always the currently right way of doing things and you'll just have to keep up with the community, which is a good thing IMO. I would suggest taking up a small project for your own use and then see where you go from there. Since you were probably interested in web development before, you might want to check out the rails framework. 
I run OSX 10.5.8. I was unable to find a working version that didn't req. 64bit. Do you by chance have a link to a such?
Nvm, I found [this](http://hacketyhack.heroku.com/content/4d17c344f0f2ec1e8d00001a).
Since you didn't mention having any experience with Object Oriented Programming, I think you chose the best Ruby Guide for yourself, because Why explains a lot of the OOP principles in a newbie friendly way. I do have two questions though: A) What platform are you using? Starting with ruby can be a bit easier on systems with a good command line (Linux, Mac). I am not sure if there is any comfortable console solution for Windows. B) What do you want to do with your newly acquired powers. Are you just trying to learn to code? Writing a website?
I'm upvoting you here because I don't understand why information as important as Ruby 2.0 information is released only in video form. I can read the same information in far, far less time.
That's natural, but performance is an implementation detail. As we especially know from JRuby, MacRuby, and Rubinius, performance is not purely a feature of a language. Ruby is a language, and what matters in a major version change like 2.0 are actual changes to the language itself.
As a linguist, you probably know that most Germanic languages all stem from the Roman language, which is why words like Ruby is Rubis in French, Rubin in German, Rubino in Italian and Rubí in Spanish. They're all similar (admittedly, Ruby is not a great example word, but you get my gist, hopefully.) Think of most programming languages the same way. The if/else block in Pascal looks like (I hope I got this right, It's been 10+ years since I've even looked at Pascal): if exp1 = 42 then begin exp1 := 0; done := true; end else begin exp1 := 42; done := false; end; end; In Ruby, it's basically the same thing: complete_newb = true if complete_newb puts "hay guise" else puts "I'd know how to do this shit on my own." end You obviously have some discrepancies with this idea (Lisp is completely different, for example), but as soon as you become familiar with one, you are basically good to go to another. It'll take time to pick up its differences, same as learning a new spoken language, but it's not a big deal. Biggest challenge, read the docs and figure out why I used `puts` instead of `print`. In fact, the answer is linked over on the sidebar just to your right. As soon as you can figure out how to read the docs, you're better off than most. We're here to help piece it together when it gets too cumbersome.
&gt; puts "This is some red text: " + "OMG it's SO RED!".red I'm confused: how is this primitive? The Paint gem looks way less advanced than the Colored gem. But maybe I am missing something?
Some general stuff: Get RVM and get on 1.9.2. The REPL is your greatest tool. There are many many great gems - pick one and have a play around. Nokogiri is very fun, and great for little spurts of learning to begin with 
 complete_newb = true print = if complete_newb "hay guise" else "I'd know how to do this shit on my own." end ... irb(main):011:1* end =&gt; "hay guise" That's perfectly valid ruby code, but doesn't work as expected read below: 
Very naive question: is there no way to tell the compiler *not* to perform those specific optimizations? 
is it me or would it be slightly more readable/understandable if the "print =" were reproduced in the true and false portions of the if statement?
(not OP, just adding to what you said) I started with the ruby 1.8.7 interpreter in windows vista. I'm pretty sure there's a compiled binary. IRB worked exactly the same as it does for now now on Ubuntu 11. I ran into some gem incompatibilities further down the line, but I think for learning ruby, the windows interpreter will work just fine.
If you only need to color a couple Strings, with 2-3 colors, I think it's OK to hardcode it in and avoid the extra dependency.
&gt; Encapsulation in Ruby: 'private' doesn't work like in Java FTFY, article sucks
here's a pointer: `int* (*func)(char*, int);`
Temper temper
Yeah, thats true. Ruby 1.8.x for windows comes with fxri which can be useful. 1.9.x only comes with irb which is great, but running it in a windows console is painful (unless you adjust the column count).
Using projects which force colour onto me is a chore. Sometimes I have a black term, sometimes I have a white or grey term window. I'd kill for a safe default of off, and an env variable turned it on.
I'm a rewb myself (get it, Ruby newb? Goddamn I'm clever) but I think this is one of those style things that the Ruby community has going for it. I think it would be more "scannable" if the if/else block had primacy, but if since what you're doing is printing something, this block of code reads more "naturally," like a sentence would. Print, if complete_newb is true, "hay guise"; otherwise "I'd know how to do this shit on my own." I could be wrong though. Like they say, there's more than one right way to do Ruby. I personally probably would have doubled up my puts, but I learned my first programming concepts in C++ and C#.
then you would use a ternary operator: print(complete_newb ? "hay guise" : "aslkdfas") Or if you really didn't want to: complete_newb = true print (if complete_newb "hay guise" else "I'd know how to do this shit on my own." end)
If you have trouble with W(P)GtR, check out http://pine.fm/LearnToProgram/. It's a more normal introductory book and possibly the greatest programming book ever produced. In your example above, you're assigning a string to the variable `print`. Thus, the value of print will be one of those strings. Now, there's a method called print which you are now overshadowing. Perjaps you would like to pick a different name?
who are the two girls on the left of the main header image
Oh, that's terrible advice! Hackey Hack (and Shoooooooes) has never worked perfectly (okay, maybe someone fixed them). But, it's like taking baby steps before you take baby steps. Getting through the Poignant Guide is the absolute best intro to programming around, and it's with a real language, not the hacked up DSL that HH/Sh is. **edit:** the above is a terrible, terrible lie. Except the baby steps part. I still think Ruby is simple enough without the DSL abstraction. :)
For just starting out, I'd say go with the (broken) default installer for Windows/OSX/Linux. Once one gets the basics down (strings, arrays, loops, conditionals), then delve into RVM. RVM can be a little intimidating if it doesn't work immediately on the first try.
A DSL is still a real language. And while Why's guide is a *good* guide, I just don't feel that it's right for everyone. 
NO FUCKO, german languages do NOT come from roman languages, are you stupid? see here: http://www.danshort.com/ie/iecentum.htm they are separate branches on the proto-indo-european tree, that's going pretty much as far back as you can go. Germanic languages are as close to fucking HITTITE and GREEK as they are to roman (latin) languages. Don't feel so clever now do you you fucking moron?
encapsulation is a lie, you don't need the real one (JAVA's) nor this one. learn a bit of Python.
[Ahem.](http://humblelittlerubybook.com/)
I agree, that would be fine. But if you use it heavily for whatever reason - the dependency is very small.
I agree. I always try to set a background on colors if I am going to use them (as everyone has a different console theme). I may add a default of off and a flag for enabling color in my latest script: https://github.com/grok/script-update-repositories
ಠ_ಠ Those are friends of mine sir :-p
I am not a sir; I be but a lowly midshipman. But srsly, a/s/l kthx.
In Ruby, and unlike say C, Pascal, Python, etc, (almost) everything is an expression that returns a value, including "if". Repeating the "print", in each case isn't more readable at all (it's significantly less DRY, too). You're merely letting your familiarity with languages where things like "if" are mere statements mislead you into trying to write those languages in Ruby. 
You may have better luck than me, but I found WPG to be so strange that I had a hard time actually learning anything. If you're in the same boat, you may find this more straightforward guide easier to digest: http://www.ruby-doc.org/docs/ProgrammingRuby/ 
Not telling you gives me this feeling: http://i.imgur.com/Z9dif.gif
As the current maintainer of Hackety Hack and Shoes, this makes me cry. :'( I've put in a lot of work into both, Did you try the 1.0 release of Hackety? It's admittedly not perfect, but bug reports are welcome.
Yep! Sorry about that. I've since found some people who have 10.5 machines, and they're working on it!
_why's stuff makes better art than instruction. It's cute though. 
Ah, the good old ternary operator. That the entire thing can be boiled down to two lines of code makes me happy. Ruby is just cool like that.
I'm running OSX 10.5. I don't really know what I would like to do with it. A friend recommended it and I kinda enjoy studying. It's been a few years since I last sat down to learn so I figured 'why not?' I honestly don't even know what practical applications ruby has.
How about using the ternary operator? complete_newb = true puts complete_newb ? "hay guise" : "I'd know how to do this shit on my own." You can use 'puts' if you just want to print out the appropriate string. If however, you want to assign the appropriate string to an instance variable you can instead do: foo = complete_newb ? "hay guise" : "I'd know how to do this shit on my own." When in doubt fire up irb and see what happens irb(main):001:0&gt; complete_newb = true =&gt; true irb(main):002:0&gt; puts complete_newb ? "hay guise" : "I'd know how to do this shit on my own." hay guise =&gt; nil irb(main):003:0&gt; foo = complete_newb ? "hay guise" : "I'd know how to do this shit on my own." =&gt; "hay guise" If you want to learn Ruby, Ruby on Rails I'd suggest the following books: * Programming Ruby 1.9, Eloquent Ruby, Metaprogramming Ruby, Thr Rails3 Way, The Well Grounded Rubyist, Agile Web Development with Rails (4th edition) or check into a course like The Pragmatic Studio courses, http://teachmetocodeacademy.com/ or google around for other stuff Good luck and feel free to ask more if you want.
Oh god no, I'm so sorry. I'm sure it's wonderful! I hadn't looked at it since Art &amp; Code like 3 years ago, I assumed it was abandonware. Again, apologies. editing now.
The `volatile` keyword in C should prevent it. I guess you want a program-global setting?
No worries! It's still a bit awkward in places. But I'm taking August till at least February off to work on both full-time. So hopefully ill be able take care of those things.
The Ternary operator isn't specific to Ruby. http://en.wikipedia.org/wiki/Ternary_operation
Well, kind of. It seems like he wanted to print the statement "hey guise", or fall back to "I'd know ...", using the method print. His code actually creates a variable named print that then contains the string "hey guise" if complete_newb is true. Test it out by running it form a ruby script and not IRB, which has the habit of printing the value of expressions after every line. Your script won't print anything, unless you add one of the lines: puts print print print p print after the if/else block Creating variables that are the same name as keywords or methods is a bad idea.
Yes, but it's part of why ruby is cool
Quite right, thanks for the catch
As someone who personally doesn't use HH or Shoes but has suggested both to younger individuals in an effort to wet their appetites I thank you for all of your extremely hard work!
:) Thanks for the suggestions!
I wish I had good suggestions to give. Better yet, I wish I had more free time to contribute to the projects in some way shape or form. :) Just for my record in case I ever get some free time: https://github.com/hacketyhack/hacketyhack https://github.com/shoes/shoes
Well, just get through the guide and then explore. Maybe you'll get some ideas while reading it, maybe you hit some real world problem that ruby can help solve. I think the two places where "regular" people might want to code a bit are quick thingies on the command line to automate something and web sites/ web apps. Ruby really shines in these two categories, but it has a ton of other uses as well.
Even just telling other people about it helps. And I know how hard it is to contribute, no worrries. :)
Yeah, that's pretty much a perfect post.
You can just use the name of the files as tasks: files = { :a_file =&gt; "/tmp/a_file", :b_file =&gt; "/tmp/b_file", :c_file =&gt; "/tmp/c_file" } files.each do |name, location| desc "process #{location}" task location do process_file(name, location) end end desc "Process all files" task :process_all_files =&gt; files.values Then run with --trace: [aaron@higgins rockwell]$ rake process_all_files --trace ** Invoke process_all_files (first_time) ** Invoke /tmp/a_file (first_time) ** Execute /tmp/a_file ** Invoke /tmp/b_file (first_time) ** Execute /tmp/b_file ** Invoke /tmp/c_file (first_time) ** Execute /tmp/c_file ** Execute process_all_files [aaron@higgins rockwell]$ If you're using these files to create new files, you may want to check out the [file task](http://rake.rubyforge.org/files/lib/rake_rb.html#M000002). Then if you have a pattern of files that need to generate other files (like .c files compiled to .o files) you should check out the [rule task](http://rake.rubyforge.org/files/lib/rake_rb.html#M000007).
Luckily, you don't need pointers when writing ruby code.
I learned how to program from Chris Pine's book.
No kidding. I'm a fledgling Rails developer and have added this to the list of resources I continually revisit while I'm coding. Does a good job of breaking down a practical application of Demeter Law checking (something I always struggle to grasp). An example of another resource I revisit is Code School's [Rails Best Practices](http://railsbest.com/).
I like the cut of your jib! This is the way to contribute productively to any project. Got a gripe? Write a solution! Also, specifically I like this patch - makes good sense to allow quoted labels there.
Thanks for the suggestions! I had no idea that I could use file names for the name of my rake task. I'll have to see if I can use this to improve my rakefile. I think I need to experiment with the rule task. I'm not sure if this is a good fit for the current project I am working on, but now I want to give it a try.
I can parse the statement and discern the meaning, but IMO this approach quickly gets ugly really fast: a = if b c + if d e else f end else g - if h i else j end
@mattosaur yeah, I learned my first programming concepts in C++ and Java @seydar: that ternary operator actually makes quite a huge difference in readability to me. There's something I find unpleasant about a single statement whose meaning spans multiple lines.
No problem! I'm glad to help out. The rule tasks are good because you'll only regenerate the files your need. So if you have 5 source files, and only one of them changed since the last time you ran, on the task to regenerate *that file* will run.
very nice :-) I was just looking for a quick and dirty VM for compiling and executing very simple workflows with a persistent stack. This could provide a basis...
Excellent comments too. Avdi's blog is so good.
Nice
Very cool!
I haven't coded with Ruby for a while but when I see something like this I remember why I love it so much.
The obvious answer is to stop doing it when it gets ugly, and find another, less ugly, DRY manner of structuring your code. Taste is one of the most important attributes of a good programmer. edit: for instance a = if b c + (d ? e : f) else g - (h ? i : j) end is much more readable because it avoids the second nesting.
Could you elaborate on that? I'm always eager to hear about people actually use one of my fun-projects :) This, I wrote years ago in PHP for a web based coding challenge game and just rewrote in in Ruby last night.
As I just wrote in another comment, I wrote this years ago in PHP and rewrote it in Ruby last night. It was very fun and it looks soooo much more elegant in Ruby!
Do you still have the PHP code? I'd be interesting to see the comparison.
The code does look very elegant, but still gets to the point! Whenever I have an idea for a project I always consider how to make that project in Ruby. Usually I can't because I generally make cross-platform applications which I prefer Java for as it gives me the least headaches in that scenario.
I'll sent it to you via pm ... it's too disgusting for the general audience ;)
Well, it is probably difficult to elaborate here in details. I'm looking for a nice solution to execute workflows that model medical processes. No existing solution that I know fit my needs... One reason is that medical processes are long-running processes so that the process state must be saved on disk. One solution that I've imagined is compiling them to a VM providing special support. I would like to start a "quick and dirty" proof of concept, probably in Ruby to have a friendly hosting language. "Ton post tombait pile poil", as we say in french ;-)
Your project sounds really interesting. Let me know if I can help you in any way.
Anyone know what's new to 1.9.3? Any language changes or additions? EDIT: Thanks for all the replies much appreciated.
I argue that it is cleaner to have a Paint() method that belongs to a library that already introduces a Paint class, than to manually pollute the global namespace with methods. Or put differently: You're basically protecting the kind of folks who write horrible code.
http://redmine.ruby-lang.org/versions/show/24
Why does that protect folks who write horrible code? In your opinion, would it be an acceptable compromise to offer `require 'paint/paint'` to get a `Paint()` method?
One big change is that it has a lazy sweep garbage collector. The lazy sweep GC is slower when you have very few objects in your system, but much faster when there are many objects. The author gave a presentation about the new GC at RubyKaigi last year. You can watch a video [here](http://vimeo.com/14549681) but it's in Japanese.
To answer your first question: It is very unclean to add methods to the global namespace, unless they match your library's/class's name and thus act as a kind of type caster (like Integer() and co in Ruby itself). So having Paint() as part of the paint library is fine, while someone else randomly defining that method is not. So the fact that you did not include that method only protects people who write bad code. Regarding an "acceptable compromise": Paint[] itself already _is_ an acceptable compromise (and a design decision). Adding paint/paint.rb which defines a Paint() method defeats the point of this discussion though. People would still be confused by Paint[] at first glance. And once they realized that it is [] and not (), there isn't much point for them to require an additional file; they could just as well continue using []. It's just a horrible barrier to begin using the library.
wfm
http://svn.ruby-lang.org/cgi-bin/viewvc.cgi/trunk/NEWS?view=markup
This makes me happy.
Exactly the kind of thing I was looking for; thanks very much!
very handy link - thanks
**Scooping the Loop Snooper** _an elementary proof of the undecidability of the halting problem_ by Geoffrey K. Pullum, Stevenson College UCSC No program can say what another will do. Now, I won't just assert that, I'll prove it to you: I will prove that although you might work till you drop, you can't predict whether a program will stop. Imagine w e have a procedure called P that will snoop in the source code of programs to see there aren't infinite loops that go round and around; and P prints the word "Fine!" if no looping is found. You feed in your code, and the input it needs, and then P takes them both and it studies and reads and computes whether things will all end as they should (as opposed to going loopy the way that they could). Well, the truth is that P cannot possibly be, because if you wrote it and gave it to me, I could use it to set up a logical bind that would shatter your reason and scramble your mind. Here's the trick I would use—and it's simple to do. I'd define a procedure—we'll name the thing Q— that would take any program and call P (of course!) to tell if it looped, by reading the source; And if so, Q would simply print "Loop!" and then stop; but if no, Q would go right back up to the top, and start off again, looping endlessly back, till the universe dies and is frozen and black. And this program called Q wouldn't stay on the shelf; I would run it, and (fiendishly) feed it itself. What behavior results when I do this with Q? When it reads its own source code, just what will it do? If P warns of loops, Q will print "Loop!" and quit; yet P is supposed to speak truly of it. So if Q's going to quit, then P should say, "Fine!"— which will make Q go back to its very first line! No matter what P would have done, Q will scoop it: Q uses P's output to make P look stupid. If P gets things right then it lies in its tooth; and if it speaks falsely, it's telling the truth! I've created a paradox, neat as can be— and simply by using your putative P. When you assumed P you stepped into a snare; Your assumptions have led you right into my lair. So, how to escape from this logical mess? I don't have to tell you; I'm sure you can guess. By reductio, there cannot possibly be a procedure that acts like the mythical P . You can never discover mechanical means for predicting the acts of computing machines. It's something that cannot be done. So we users must find our own bugs; our computers are losers!
Haven't seen that one before! A lot of good work has been done on termination, for the record. I cite them in my thesis - Microsoft's terminator project is the cooler ones in my opinion: they work to prove termination in device drivers in C/C++. Whenever I simulate Ruby code in Laser, I just cap execution at X basic blocks. It could be smarter, but there hasn't been a need yet - that should only happen if you have an infinite loop in top-level code.
Kill it. KILL IT WITH FIRE.
one of the reason why python was a massive (and a continued) success was because it works flawless on windows. even the pyside project (which i thought was purely nix) have a working windows version. on ruby, the rails community has taken over and poisoned the ecosystem with their apple fanboism and general elitist attitude towards windows. rails was the best and the worst thing that happened to ruby. ruby/rails will never regain its former glory (if it ever had one)...
Rails has done more for ruby than anything else. As for windows it's up to the people who program on windows to submit patches to make the various libraries work on windows. You don't expect somebody who doesn't run windows to fix a windows issue do you? 
this is just a rumor but i heard that you can't sleep at night unless you have a belly full of cum.
Similar but more general: ConqueTerm, using ":ConqueTerm irb" (or ":ConqueTerm pry", if you're using the Pry gem). You can also do ":ConqueTerm rails console" and ":ConqueTerm rails dbconsole"... and obviously also for non-Ruby stuff like ":ConqueTerm bash".
pry? what'sthat?
I hardly understand what problem this solves... Isn't it way better to run vim in a screen session, with irb in an other window?
* https://github.com/pry/pry * http://banisterfiend.wordpress.com/2011/01/27/turning-irb-on-its-head-with-pry/
If you run an interactive session within vim, you get vim editing, vim buffers, vim completion, vim macros, vim navigation... basically, you get vim.
Don't forget VIM syntax highlighting and color schemes.
Homophobe much?
rails has done well for itself. as for ruby outside of rails, well it will never ever catch up to where python is now. even on something that everyone can contribute (like documentation), ruby is lagging behind. the python [2.0.1](http://docs.python.org/release/2.0.1/) doc from 10 years ago is far far better than the current ruby doc. sad. yes, ruby core/lib devs should run windows if they cared enough for ruby, but obviously they dont. 
First time I've ever that song, so I'd say no.
I take it you are talking about [Jeweler](https://github.com/technicalpickles/jeweler#readme), which re-generates an explicit gemspec. Technically you are not updated the `VERSION` twice, Jeweler is silently updating the gemspec, as part of the release process. I think it's important to note, there are other alternatives to Jeweler, besides Hoe: * [Bundler](http://gembundler.com/) * [Ore](http://github.com/ruby-ore/ore#readme) * [Inochi](http://snk.tuxfamily.org/lib/inochi/) * [simple-gem](https://github.com/reagent/simple-gem#readme) * [bones](https://github.com/TwP/bones#readme) You could also just use a pure-Ruby gemspec and `gem build` / `gem push`, but please remember to commit all changes before releasing a gem, and please `git tag` your versions. Too often I find projects without a `ChangeLog`, `README` or version tags, because the author choose DIY route.
There wasn't a common tool used across all the projects I looked at, so no, I'm not singling any tool out. Jeweler, Bundler, Ore, Inochi and simple-gem all seem to have the version stored in two places based on looking at the commit history for each repository. bones appears to be the only tool in your list that follows the DRY principle for the version. Regardless of what technically happens, if you're not protected from having a different version between your gem and your source how is the tool helping you? I don't see anything in Jeweler that ensures the two versions are the same. There's gemspec:validate, but that only seems to check if you can eval the gemspec file.
Bundler, by default, loads the version from the `version.rb` file. Ore allows you to omit the `version:` value from the `gemspec.yml` file, and specify it in a `version.rb` file, otherwise the `version:` in `gemspec.yml` is the authoritative version. It looks like Inochi generates a gemspec, much like Jeweler. Bundler/Ore do protect you from having a gem with a different version, than what was currently in the source-code.
Yes. Whenever I do anything awesome in ruby I always go "ruby ruby ruby! ahhhheeeahhhhaaaa!"
If you're generating the gemspec when the version changes you should have tooling to update it all in one commit to avoid an inconsistent repository. Jeweler doesn't seem to have integrated gemspec generation with the tasks that alter the version (judging from its own commits). Inochi doesn't seem to have tasks to manage the version so you have to remember to generate the gemspec to keep them in sync. I don't see bundler protecting me from having different versions. `rake release` certainly doesn't have that check: https://github.com/carlhuda/bundler/blob/master/lib/bundler/gem_helper.rb#L42-52 Since you wrote Ore I'll take your word for its correctness, but I don't think there are as many uses of Ore as there are Jeweler or Bundler for writing and releasing gems.
I agree, this is one of the risks of having tools make commits for you. It sounds like Jeweler just needs to decouple the gemspec regeneration from the committing, and commit the `VERSION` bump with the new gemspec. Bundler should ensure the released gem has the same version as the repository, since it appears to rebuild the gem before pushing it. https://github.com/carlhuda/bundler/blob/master/lib/bundler/gem_helper.rb#L64 
Upvoted because I actually do.
I recommend you to see a psychiatrist.
:-| NO
I added a new example: Calculate faculty using the stack.
Some people do: http://www.youtube.com/watch?v=kTNZ3_rp2wI
Unfortunately, this video is not available in Germany because it may contain music for which GEMA has not granted the respective music rights.
That's the link to `build_gem`, the `release_gem` method [explicitly checks that you haven't released that version yet](https://github.com/carlhuda/bundler/blob/master/lib/bundler/gem_helper.rb#L63).
&gt;rails has done well for itself. It was the most important factor in increased ruby usage. &gt;. as for ruby outside of rails, well it will never ever catch up to where python is now. So what? &gt;yes, ruby core/lib devs should run windows if they cared enough for ruby, but obviously they dont. Once again...... People who use windows need to submit patches. People who don't use windows can't fix problems on windows.
It checks to ensure that you haven't released yet, but it doesn't ensure that any VERSION constant in your project matches the one in the gemspec.
totally
Xavier, I think you rock, but shame on you for being Aussie and naming that class LoadPathAnalyzer instead of LoadPathAnalyser 
&gt; So what? because ruby is very dependent on rails. when rails die (not soon, but it will), it will be the end of ruby. &gt;People who use windows need to submit patches. People who don't use windows can't fix problems on windows. windows support need to start from the creator. fortunately for python, guido [cared enough for windows](http://www.linuxjournal.com/article/3709) and had mark hammond from the start. python from the start sets a very good example (caring for windows, great documentation) which other python devs followed. ruby sets a bad example which ugggh.. other devs followed (poor windows support, incomplete documentation, platform fanboism, etc etc..)
That's a damn good idea! I can't help but pick at the code given though... def load_path_freqs(features, paths) features.inject(Hash.new(0)) {|a, feature| which = paths.detect { |path| feature.start_with?(path) } a[which] += 1 a } end That's how I'd write it, personally. Well, I'd use `find` instead of `detect`, but different strokes for different folks. No need to write anything more: that's the entire algorithm you wanted.
Agreed! Similarly: optimi*z*er!
&gt;because ruby is very dependent on rails. when rails die (not soon, but it will), it will be the end of ruby. It's cute that you believe that. &gt;windows support need to start from the creator. No it doesn't. It needs to start from people who use windows. &gt;python from the start sets a very good example (caring for windows, great documentation) which other python devs followed. ruby sets a bad example which ugggh.. other devs followed (poor windows support, incomplete documentation, platform fanboism, etc etc..) Wonderful. Go use python. Really nobody cares.
This looks like an implementation of the ubiquitous 'fold' operator in functional programming languages. blambeau: You might want to read [this paper](http://www.cs.nott.ac.uk/~gmh/fold.pdf). It might give you some ideas that you can use in your gem here. 
Thanks for the pointer. I had a few basic notions about fold in functional languages, but I should certainly read the paper to understand it more deeply. thx!
`colour` or `color`? Also, `LoadPathAnalysis` would be acceptable.
I'm a bit hazy on how user-specific data does not harm cache-performance. Is the idea that users who have visited the site will retain their cookies? What about logged off users? Maybe the cookie is not part of the cached page at all, but then how is the cookie served?
To me, it's better the way Xavier did it - the concerns are separated out nicely and it would be easier to extend/test. I do agree, however that Hash.new(0) or similar is needed/would be nice :) but that's a minor niggle :) 
first.
place.
I found [this](http://www.mnot.net/cache_docs/#TIPS ) via a link on that page: * Use cookies only where necessary — cookies are difficult to cache, and aren’t needed in most situations. If you must use a cookie, limit its use to dynamic pages. So I'm still perplexed.
Great now the shit I write can be incompatible with anything else and have to wait for maintainers to make their shit work on new versions. No thanks.
idiot.
You don't test private methods, so this is no more difficult to test than his. There's no clear reason why this would ever be extended. I cite YAGNI.
Obviously you've never maintained more than your workstation.
If you read the readme, you'd see I recognize this project is not relevant for production deployments. It's for fun, experimentation, and research.
These rubies are clearly experimental rubies not meant for production, in the case someone does use them in production then they're on their own and of course you dont have to support them. 
let's be friends
He can cache the frontpage, which is likely to be his most heavily visited page. Then if a user logs in, he'd bounce them off an interstitial page that just sets the cookie and redirects back to the cached frontpage. To handle traffic spikes from referral, which is his scenario, the most important thing is to cache main entry points to the site for for non-logged in users anyway. The front page doesn't ever need to set the cookie, in that case, and can contain JS to inspect cookies set for his domain. 
Also, some of those might appear in the next version (like Refinements) - and the developers might appreciate people's experiences in experimenting with the features before they are officially available (and locked in place).
Aren't most things heap-allocated? Why does the stack matter?
It irritates me to see this downvoted without comments. It *is* relevant even if not positive or popular.
That makes sense. Thanks... But it means that the stuff which appears for logged in users -- name and avatar -- must reside in the cookie. Right? That's in the JavaScript, but not in the Ruby code for that example.
Did you watch Aaron's keynote?
Reddit fuzzes numbers to help prevent gaming. It's possible nobody downvoted this.
Nay... kinda wish there were a tl;dr on why it's not straightforward ref counting
I watched it in the video capture, but he doesn't really explain it sufficiently, the only explanation is the single sentance I quoted in the blog: “The way that ruby’s garbage collector works, it has to scan the stack for objects to collect, so obviously as our stack gets larger, the garbage collector has to do more work.” Um, okay, i still really don't get it, but I'll take Aaron's word for it, he ought to know. 
It was at -1 before I upvoted it to zero. Fuzzing to a negative score seems like a bad idea to me.
Any C function that gets called will add a few words to the stack size, even if it has no local variables. Local variables themselves can add considerable stack size overhead. And then, any Ruby method call may trigger a number of C methods from the underlying implementation. After that, I believe there are a bunch of (relatively large) ruby_frame structures that are inserted into the C stack as new ruby methods are called. I don't recall the source for sure (possibly from an old REE team talk), but all this can lead to the stack space used for each thread commonly being up to or over 64k. It's true that every Ruby object is allocated in the Ruby heap (even if they point to additional data elsewhere, like String), but a C reference to a Ruby object can exist anywhere. Since Ruby's GC doesn't rely on reference counting, it has to iterate over every thread's stack looking for references back to the Ruby heap. If it didn't, any local variables used in C extension functions would have constant memory corruption problems. That implies that GC would have a somewhat linear slowdown in terms of stack size. Large stack sizes are also a big problem in 1.8.7, because every time a thread is context-switched the old stack is copied to the heap and a new stack copied in to replace it. That's resolved by moving to pthreads for thread management in 1.9, iirc.
Yeah, I doubt _that_ would happen...
Well, that's because it uses mark and sweep, not reference counting. Reference counting isn't exactly straightforward, it doesn't handle circular referneces well, for example. For a bit more than a TL;DR, see here: http://timetobleed.com/garbage-collection-slides-from-la-ruby-conference/
Okay, well, basically, Ruby uses a mark and sweep gc, and so it has to walk the entire object graph to do the marking. For more, see here: http://timetobleed.com/garbage-collection-slides-from-la-ruby-conference/
A few quick things: 1) [Enable GC Instrumentation if you haven’t.](http://support.newrelic.com/kb/ruby/ruby-gc-instrumentation) Will make determining the slow downs MUCH more transparent: http://engineering.gomiso.com/2011/06/06/low-hanging-fruit-for-ruby-performance-optimization-in-rails/ 2) [Enable rpm_contrib](https://github.com/newrelic/rpm_contrib/blame/master/README.md) This adds additional measurements to make profiling performance easier.
Interesting post if it is correct but doesn't quote any numbers at all. Aaron Patterson mentioned that it is in an issue with rails (the framework). But his comments aren't necessarily true for this app. Any testing would prove this. I've learnt through days of debugging that assumptions are normally the cause and anything you can do to prove that what you are saying is correct will help you get to the root problem. The post has very grandiose comments seeming to claim that a number of well used ruby VMs (REE, JRuby (comments) and MRI) are slow. However has no numbers or to back this up. That isn't to say the author is wrong, it's just I have no way to prove that he is right. If I came across this as a bug report I would not even start looking at until the author can prove it's not themselves causing the issue.
Thx, much preferred to video. You may also be interested in this, steev - a paper on how awesome mark and sweep is in ref transparent langs: One Pass Real-Time Generational Mark-Sweep Garbage Collection http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.42.7791&amp;rep=rep1&amp;type=pdf (this is clapton btw)
Very lucid, thanks. karma++
Ref counting is one of the slowest forms of GC there is and doesn't handle things like cycles. While it may be easy to implement, it becomes non-straightforward very quickly if you want it to be correct or fast.
Hey buddy! Ill check it out, thanks.
You know, both are good points. I'd never explicitly heard the rule "you don't test private methods" but looking through my code, I find that I generally don't, and when I have I could probably refactor the code. Thanks for the insight.
I can only wonder if web support gets further optimized and baked in.
Yes, the entire article does seem a bit half baked. 
gratz on the matz.
I understand the cyclic dependency being a problem with reference counting but i don't understand how it's slow? Care to elaborate? 
You might think that, but then, think of WEBrick. Bored? Send this request: GET / to a WEBrick server edit: patched it
will this be a mini-monopoly? definitely a good promotion
I admit I have forgotten most of what I ever learned about systems programming and have only a vague understanding of 'heap' 'stack' etc.-- but it's clear to me why GC time is determined by number of objects created (size of the entire object graph). But it's not clear to me why the size/depth of the call stack correlates to size of the entire object graph, or otherwise determines GC time. Which is what Aaron was saying, right, that the size of the call stack effects GC time. All I can come up with is maybe something like, that the larger the call stack, the more local variables are in scope, each referencing objects? Except for local variables that no longer hold references when they go out of scope... I can't think of anything else about the size of the call stack that would have anything to do with the size of the object graph. 
Great slide deck. I'll have to read more about Tri-Color GCs and the like.
Have you reported a bug yet? If not, you can do it [here](http://redmine.ruby-lang.org/).
Alright, so imagine you're a simple Ruby program, no Fibers, no threads, just one stack. You've called 10 calls deep. Some of those might be Ruby code, some might be implemented in C (if you're using a core library class, it's quite possible). Doesn't matter. Then you decide to allocate a String, and BAM. GC happens. Ruby says "okay, what objects do I need to hold on to?" Well there's some easy stuff - class variables and global variables, you're gonna want them. The rest depends on well, where you are. You're 10 calls deep. You need all the objects reachable from variables in the current method, or at least it's a safe bet that you do. Also, when this method finishes, it's going to go up the stack - and you better hope the objects there are still reachable! When that method finishes, the frame above that needs its locals. And so on, up the stack. Ruby finds those objects by finding the boundaries of the current stack, and searches that memory for references to Ruby objects. If your stack is 100k of memory because you're dozens of calls deep, it needs to check a lot of that 100k for references to Ruby objects. If it's 10k, it needs to scan a lot less memory. If it's 1k, it's even less. Checking that memory takes time, especially because your caches are likely not holding your entire Ruby stack.
[I'll do you one better](http://redmine.ruby-lang.org/issues/5022) - I've included a patch :)
thanks! =)
you broke the first rule... but thanks for breaking it :)
I would like to say that *Eloquent Ruby* is a great book for learning the style and idioms of Ruby.
Agreed. I guess that point in particular could have been made a little clearer in the review.
I had trouble with a few idioms in Ruby, and a few style guides. For instance, I would remove all parenthesis that weren't required. This book set me straight on how to make things more readable and idiomatic. So glad I got it.
The parenthetical style described in *Eloquent Ruby* is basically my only complaint with it, actually. It says that the community votes, in practice, to leave parentheses in by default, but that is not strictly the case. I find that, for instance, method definitions in the vast majority of cases use parentheses for arguments, but method calls often don't unless adding parentheses clarifies where the method call ends and something else begins. The Rails community takes an even more extreme approach basically just leaving out parentheses whenever it is at all possible to do so, from what I have seen. My tendency is to just write code without parentheses, except in a couple of key cases (like parentheses around arguments in method definitions), then add parentheses if I look at it and it appears unclear. Nobody has complained to me about this style yet, and it seems to line up reasonably well with the way most other Rubyists on the ruby-talk list and posting code on Bitbucket or GitHub do things. I tend to think that, a lot of the time, leaving out the parentheses makes Ruby code clearer. If I had to identify a consensus in the Ruby community on use of parentheses, I'd say it's probably that they don't much care whether you use parentheses or not, though you should try to avoid nesting parentheses too much, and sometimes parentheses clarify things a little bit -- but not all the time. Special cases take special handling, though; nobody really thinks that a Kernel method with only one argument should have parentheses in the general case (thus the fact that pretty much nobody, basically ever, uses parentheses with `puts`).
I personally have trouble reading my own code when the parenthesis are omitted at every opportunity. But, I wouldn't call that a complaint for the book. He does mention the most common style, and he even mentions it as not being a hard fact. (i.e. it's good to know what is considered common, rather than him omitting it.)
That's sorta my point -- he suggests that the default in the community is including parentheses, but in my experience and observation, it's not default except in specific circumstances.
From the code I've read, I've seen mostly parenthesis with some drops in places. Only Rails seemed to have a lot of parenthetical drops. Maybe it's a Rails-to-Ruby convert thing? (I personally dropped them out of minimalism.)
The standard style is to include ()s in method definitions that have arguments, and never otherwise unless it would be ambiguious (for example, `link_to "Article", article_path(@article)` has both kinds at once)
I guess all I can tell you is that in the code I've seen, one of three things is usually the case: 1. It's a Rails coder, and the rule seems to be "no parentheses ever, at all, if you can possibly get away with it". 2. It's not a Rails code, but it's a generally idiomatic Ruby coder, and the rule sense to be "don't bother using parentheses unless you have a decent reason to do so in that case or it's a method definition". In practice, I think this results in about 35-40% parentheses usage for code other than method definitions. 3. It's someone whose code is recognizably non-idiomatic in a few ways. There are exceptions, of course. I think a lot of people in their first year of using Ruby use a lot of parentheses, for instance, but that tends to go away gradually. Check out *Ruby Best Practices* and *Metaprogramming Ruby* for a bunch of good examples of idiomatic Ruby code, by the way. They're also just great Ruby books in general.
That is most definitely not what I've seen. For example, how about GitHub's [Linguist][L]. It follows exactly what was in Eloquent Ruby (mostly parenthesis, but omit them when there are no arguments, except common calls like `puts`). [L]: https://github.com/github/linguist/
I'm not sure what you mean. All of that code is just what I said.
Well, maybe _all_ is a bit excessive. This does have a bit more parenthesis that I'm used to seeing, but mostly in edge cases where it's not _strictly_ ambiguous but could be (like nesting a File.expand_path inside of a Yaml.load)
Sort of like casting.
That's exactly the sort of parenthesizing policy I've seen in practice most of the time. Thanks for your comment to ruby-talk about the unidiomatic style exhibited in *The Book of Ruby*, by the way. It was a useful warning that may have saved me $25+.
It really pains me to say it, because it's a great book otherwise.
I honestly don't think it's too big of a deal if parenthesis are used, but personally, I find my code much more readable when I use parenthesis. My personal exception are common functions and things I've done for a DSL. Examples of how I write: puts "Foo" entry.delete! entry.add(something) entry.update(name : 'John') if new_entries.empty? That's just my current style, but it helps me to scan my code visually.
You only mentioned definitions, not calls. Linguist uses it for (almost) all calls to functions.
Right. Where those calls are ambiguous. Of course, the definition of 'ambiguous' is a bit... ambiguous. ;)
Yeah, see, something like add(something) would cause me to pause, because I'd be wondering what's so special about that method invocation... the update would be something I'd not be for or against.
Is the changelog of 1.3.0 available somewhere? I've checked on github and sourceforge but have not found it. 
[First result](http://groups.google.com/group/rack-devel/browse_thread/thread/7dce0d9b17ec9cb3) on google for "rack 1.3.0 changelog" :)
oops, sorry ;-) and thanks!
Preaching to the choir mate :) This should be posted in /r/python (yes I'm still bitter about Python best dynamic programming language this year)
I made this because I often want to open the files listed in a stack trace in say, hoptoad, and get annoyed with having to edit the path to match mine.
it will be javascripts turn once microsoft is done with node.js port.
k
From who?
You can always use GitHub's compare view: https://github.com/rack/rack/compare/master , click on the start and end, and you get this: https://github.com/rack/rack/compare/1.3.0...HEAD
FYI, you don't need Bundler for a gem with no dependencies.
heh good catch, thanks
I take it you mean *Eloquent Ruby*, regarding the use of parentheses. I similarly hesitate to say anything unflattering about it, given its quality in general, but I just find that statement about how parentheses are used does not match up with my experience of the reality.
I haven't read eloquent ruby.
oh please no. the more syntactic sugar you add to ruby, the closer you to get to a Perl nightmare. least surprise means less syntactic sugar, people. and yes, maybe this isn't technically syntactic sugar if you reserve that phrase only for things at the compiler/interpreter level, but it's the same thing. Taking something that was quite easy to do before using standard langauge constructs, and providing a completey different and more mysterious way to do it just because you like how it looks on the screen better. (in this case, to save, what 10 or 15 chars at most? come on.)
http://www.linuxjournal.com/content/readers-choice-awards-2010
Registration takes you over to a page on stagehq.com which says registration isn't open...
They just sold out an hour ago.
Lame!
Last year they were able to open up registration again after securing a few extra tickets. But I dont know if I would count on it- theyre at a different venue this year.
Damn. My partner got a ticket and I didn't. If anyone comes upon an extra, I'd be forever grateful. [edit] lul
your "partner" are you a gay????
I hate these guys, just write out a blog post like regular people. Listening to some boring ass podcast sucks. I want to read at my own rate, with nice code samples.
Hmm. I was not as impressed with the rest of the content of *The Book of Ruby* as you, evidently.
Who got changelog cliffnotes? :p 
Happy days. Love the desc: This release doesn't include any secuirty fixes, but many bugs are fixed in this release.
Yah, Changes from [p180 -&gt; p290](https://gist.github.com/1085832)
I summarized some choice ones for you. Here you go: http://www.rubyinside.com/ruby-1-9-2-p290-released-the-lowdown-on-rubys-latest-production-release-5145.html 
Do I need to walk over to Japan and hammer the semantic versioning doc on someone's door Luther-style? When will this craziness end? Production release of the ruby language? Then make it 1.9.3. It *should* be 2.0.3, but I'll let that slide for now.
semantic versioning is for fags. You seem like a fag. 
Thanks. I followed the steps to upgrade in rvm.
Read some basic ruby tutorials on the web. Try out ruby koans. Do some of the problems at codeeval.com using ruby.
Pragmatic's Programming Ruby by Dave Thomas is a good intro to Ruby Pragmatic's Agile Web Development with Rails is good for Rails
A couple of years ago, [I asked essentially the same question](http://www.reddit.com/r/programming/comments/7wa4l/suggest_a_programming_language_for_a_newbie_to/ "Those were the days before self-post with text") and someone suggested to me a great beginner's tool for learning Ruby called [Hackety Hack](http://hackety-hack.com/). I'd suggest you try that out. It'll give you a taste of Ruby and programming in general. If you're still interested in Ruby after you complete Hackety Hack, there's a ton of material out there to continue your journey. My path went something like this: - [Hackety Hack](http://hackety-hack.com/) (Feb 2009) - [_why's Poignant Guide to Ruby](http://mislav.uniqpath.com/poignant-guide/) (Feb/Mar 2009) - [Chris Pine's Learn to Program](http://pine.fm/LearnToProgram/) (Feb/Mar 2009) - Started picking up Ruby-on-Rails from around mid-March from various tutorials on the internet. Here's a [great one](http://ruby.railstutorial.org/). Fast forward to 2011 I know work as a .NET programmer at a company mostly writing in C# and building desktop applications and websites. I can safely say that everything I've learned from my Ruby days I still use today. Even the Rails stuff since Microsoft copy-pasted RoR for .NET and called it ASP.NET MVC.
**Disclaimer:** I am not trying to imply there is one true REPL solution for Ruby, nor trying to push Ripl as being "better" than Pry for all purposes, nor am I attempting to "hijack" this reddit "thread". I in fact, I have used Pry to catch subtle bugs from within the tests of [ronin](http://github.com/ronin-ruby/ronin), which also uses Ripl for it's interactive Console. I like using Pry for debugging purposes. I think [Ripl](http://rbjl.net/44-ripl-why-should-you-use-an-irb-alternative) might be a better alternative to IRB for new Ruby users. Pry seems more tailored to developers (which is fine imho); example: the `cd` command for context switching shadows variables/methods named `cd`. &gt;&gt; obj = Object.new &gt;&gt; cd obj Beginning Pry session for #&lt;Object:0x000000025f3398&gt; &gt;&gt; cd = 1 SyntaxError: &lt;main&gt;: syntax error, unexpected '=' =.pry This gotcha also effects local variables/methods such as `stat`, `version`, `reset`, `import`, and `install`.
All of those are great. Also consider checking out [Simply Rails 2](http://www.sitepoint.com/books/rails2/), which walks you through making a "Digg clone" (lol). 
Looks good although its rails 2. It's probably a good a idea to be learning rails 3 at this stage. 
This is expected behavior, however it's true that the error message could be a lot more descriptive and would reduce confusion in this situation. `cd` and friends are commands, not methods. Commands were chosen over methods because they present a number of [advantages (see overview)](https://github.com/pry/pry/wiki/Command-system) but in cases of conflict (as in your example) they are still easy to resolve. Simply prepend a space to the use of `cd` and `cd` will be interpreted as pure ruby code. I do not think this behavior will be sufficient to scare off 'new users' ;) However, imo, i think for truly NEW Ruby users nothing beats plain old IRB :)
Maybe also, filtering out `foo [binary-operator]` as non-commands might help?
This is the proper way to do blogspam. You answer a literal question and provide usefull information.
some commands can determine what matches them (see: [regex commands](https://github.com/pry/pry/wiki/Command-system#Command_regexp)) and they could decide to filter out binary operators. However as a general filter for all commands i think it would be too limiting. I feel that so long as the error messages are good (i will work on improving these) the kind of confusion you're talking about can be eliminated.
But it may still contain security bugs :P Need to keep hunting.
Correct me if I'm wrong, but [Semver](http://semver.org/) uses the 3rd number for patch-level releases (no new features, just bug fixes). Patch-level releases above `0.y.z` would be considered production-ready.
weird, your career path went in the opposite route to most people i know: it normally goes C#/.NET ===&gt; Ruby in my experience; people wanting to escape the straitjacket that is microsoft development world.
Haha, bummer. I thought it was the second version of the book... like first there was Simply Rails and this was the updated sequel. Which I guess in a sense could be true, but shoot. Hope I'm not totally in the dark when I start using Rails 3.
I've taught Ruby and Rails at the college (extension) level, and my recommendations are: Flanagan and Matsumoto, The Ruby Programming Language (RPL). This does not have problems, but some of the code examples are fairly sophisticated. Matsumoto ("Matz") is the creator of Ruby; Flanagan has written books on Java and JavaScript. I think that at this point RPL is tighter and has more information density than Thomas's Programming Ruby (aka the Pickaxe). For problems: The Ruby Quiz - http://www.rubyquiz.com/ - a great project would be for you to read Flanagan and Matz and cross-list it with examples from the Ruby Quiz and write a blog post. The whole community would benefit from a "key" to the Ruby Quiz that points up the exploitation of specific techniques and language issues. Owen, Eloquent Ruby. This would be a good followup to RPL. It gets into important issues regarding class and object creation, call chains, and the like. Black, The Well-Grounded Rubyist. Gets into edge cases. Discursive, but in a good way. For Rails, Hartl's Rails Tutorial (http://ruby.railstutorial.org/). IMHO, you can't be a great Rails developer without being a solid Rubyist. So read the Ruby books first. Now, as you can see, I haven't explicitly recommended the Pickaxe or the Pragmatic Programmers' Agile Web Development with Rails - these great groundbreaking books were the only books for awhile, but I think the ones listed above may have a bit more power for a newbie at this point. One thing I really, really like that Thomas has done since Programming Ruby is his video series on metaprogramming - http://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming : It is sequenced wonderfully and it is structured to produce some "aha" moments. 
It's definitely easier to get a .NET job when it's your first. 
It's not all that different. A couple of idioms need relearning. I think Ryan Bates probably has a Http://Railscasts.com episode explaining the new bits. 
Not a book but I learned ruby by doing Euler puzzles and then looking at other ruby solutions after completing each one to see the better, idiomatic way.
As a rule of thumb I try to avoid using callbacks as much as possible. It just leads to spaghetti code and unexpected behavior especially if you manipulate dependent or depending objects which have their own callbacks. Also AR should make it much easier to define default values. Also AR should not send nulls to the database for the fields you didn't set. In postgres this prevents the database defaults from being applied.
While I will absolutely be taking the pickaxe book (Pragmatic Programmer's) and the Poignant Guide to the tomb so I can reference them in the afterlife, I'm getting more and more surprised that Russ Olsen's books aren't mentioned as go-to Ruby resources. No quizzes or anything like the OP wants, but I really love Eloquent Ruby and Design Patterns in Ruby, both by Russ Olsen.
Try The Pragmatic Programmers Learn to Program by Chris Pine. There are some very difficult problems to solve and the second edition includes the answers at the back. 
In addition to the resources already suggested, I recommend finding a good personal project for yourself to build with Ruby. I've found that's the best way to learn anything really, as your motivated to dig deeper. If you do get involved in the Rails community, it's also a good conversation starter, and a good opportunity to ask others for advice if you get stuck or otherwise have questions.
I had a row about this with someone on here recently (wasn't you, was it?). Posts that significantly extend and provide context to news aren't "blogspam"! :-) An ancillary point is that blogspam is typically done on smaller blogs trying to get cheap attention, whereas Ruby Inside is the most popular Ruby blog so it's more a public service so that the most # of people get to find out the news. If anything, the announcements on ruby-lang.org are the real waste of time because they rarely go into any detail or tell us anything useful beyond the title, but how crappy ruby-lang.org is is a topic for another day ;-)
Why not take CodeSchool's free Rails for Zombies intro course? It's an interactive video lesson + in-browser code environment that gives you challenges to complete: http://www.codeschool.com/
I just did this myself. I read Agile Web Development and The Rails 3 Way. It worked for me. 
Wasn't me. I was just pleasantly suprised that the blog was mentioned as a comment, yet was more usefull than the actual 'official article'
Good stuff. :-) As you can tell, I've had the blogspam card pulled on me a few times here ;-)
As a college student, I read these and landed a nice summer rails gig :) Go for it, OP, these are great books that will teach you a lot.
I really can't understand that. Microsoft make the most comfortable straight jackets. But seriously, Visual Studio kicks all sorts of ass and after getting into C#, I kinda enjoy all the benefits of static typing. Whenever I'm writing some algorithm I usually code it out in Ruby first to see if it's possible then re-write in C# once I settle on the approach I want to write it out with. The one issue I have with working with Microsoft tech is the costs involved in doing so legitimately. The licensing fees for SQL Server is not only confusing, but also looks really out normal folks range. Lucky there's AppHarbor out there (the Heroku for ASP.NET).
I wanted to mention that I have recently (past week) exploring using the combination of: * [ripl](https://github.com/cldwalker/ripl) * [boson](https://github.com/cldwalker/boson) His configuration is available from: * [irbfiles](https://github.com/cldwalker/irbfiles) There are some things I don't like about the setup in general, but because pretty much all functionality is written as arbitrary modules/classes, it's rather easy to change the environment to suit your needs. The documentation isn't great (which I'm working on for my own needs, and plan ask him to pull). Note, I am not using this to do general ruby or rails development, I'm just looking to make a tool to use with [puppet](http://reductivelabs.com/puppet). So I can't comment on general use. Both of these are works from [cldwalker](https://github.com/cldwalker).
-1 that's great, but this thread is about Pry. 
Alright so this is another epic battle in Rubylandia .. pry vs. ripl In this battle of wits, nuts and bytes there ought to be two winners, shouldn't there be? Or will one side have to be CRUSHED and SQUISHED ... So one side tends to pick &lt;INSERT NAME&gt;, the other side tends to pick &lt;INSERT OTHER NAME&gt; and you tend to want to see one winner alone. Battle gear ready? Good. Let's pick a side then and START THE BYTE-BLOODBATH! *ponders* No, wait. Although I myself am absolutely biased and would be standing on pry's side, crushing ripl with ease, I believe it is kind of cheap to want to promote ripl on a pry-thread. And of course, vice versa. Besides, it is kind of childish too in this epic race of whose mother has the better REPL ... So let's make this differently instead and enact fair rules for pry, ripl and any other &lt;INSERT HERE MY REPL IS BETTER THAN YOUR REPL&gt;: - Stop promoting ripl (or other REPLs) here in ways done by technogeeky and postmodern. Mentioning ripl is fine but hello you two are shamelessly super-promoting ripl!!! What does this have to do with pry either? I am not going to ripl threads and promote pry either and try to point out percieved flaws within ripl. So let's be nice and gentle and stick to the topic on hand, rather than want to promote &lt;INSERT ANY OTHER REPL HERE&gt; In the end, people will flock to what is better anyway, so here is where the battle should proceed - on the QUALITY of the code and the USABILITY of it, the DOCUMENTATION and perhaps the COMMUNITY too.
lol wtf, upvotes!!!
Really? Your comment is the only one in the thread that doesn't mention ripl.
yep and yours is the only one that *just* mentions ripl in a thread about a pry screencast. DId you even watch the screencast or did you just come here to talk about ripl?
I understand where you're coming from, but I'm not a ripl sheeple or something like that. I usually use Haskell, and I don't know a lot about any of these irb alternatives (nor do I know much about the IRB augmentations out there). I just made a comment that I have had some success in the past week working with ripl, which was mentioned in this thread already. I don't want to make people avoid pry, or make people use it. Not everybody has an agenda.
Just Do It. Learned Ruby + Rails over Christmas, made a bunch of random apps, and am almost done migrating my vBulletin community over to a custom Rails forum. Most important thing is exposure, not the resource you choose. I learn new tricks and idioms every day.
That's just what the research shows (see Jones). Think about it tho... in a copying GC, time spent in GC is proportional to the amount of live objects and it is only spent when memory hits some threshold. In a generational GC, time spent is only proportional to the amount of live objects in the first generation (and second/third/whatever if the generation space is all live and still full after sweep). But in reference counting, EVERY object on EVERY reference/dereference has to be mutated. That adds up really really fast.
Sorry
See the sidebar? ALL THOSE THINGS. I put them there for a reason.
So the author of the book doesn't believe in adopting the idioms of the language he's writing? Isn't that about the same as saying you're not going to speak the local language like the locals, but instead with whatever screwy accent you're comfortable with?
Not a book, but I wrote http://ruby-kickstart.com/ for people wanting to learn Ruby. It has short narrowly focused topics, video where I go over them with my friends who are learning Ruby too, quizzes you can use to make sure you understood the material, and 50+ programming problems you can solve that each have an automated test suite and a solution provided that you can compare to if you like or reference if you're having difficulty.
Good analogy.
Can you link to where Huw left his comment about your review? i'd like to read the whole argument
No problem, I see these post about once a week, specifically, checkout out http://rubykoans.com/ &amp; Metaprogramming Ruby
Curious how this compares to [Gosu](http://rubygems.org/gems/gosu) or [rubygame](http://rubygems.org/gems/rubygame)? Looks really polished, well done.
Thanks. :) I haven't tried Rubygame. About Gosu, Ray provides higher-level classes regarding game logic (scenes, animations, and a generic event system); Gosu doesn't know about those concepts, so you'd need to implement them yourself (surely, every game will have multiple screens and things to animate). Also, if you want to do some low-level rendering with Gosu, you need to fall-back to plain opengl. Ray's drawable system was made so you can use it for anything you like (even if it requires to write shaders if you don't use the default).
Looks good! Nice to see OpenGL shader support in a Ruby game engine. Does it do any sort of resource management, or is that up to each game?
It provides a way to cache images, fonts, and sounds, if that's what you mean (just Ray::ImageSet["foo.png"] would access it).
It's the same as if you would talk about Ruby in a Python thread or about JRuby on a Rubinius mailing list... DON'T EVER DO IT!
&gt;Looks really polish "[Polished](http://dictionary.reference.com/browse/polished)" ? or "[Polish](http://en.wikipedia.org/wiki/Poland)" ?
[Chingu](http://github.com/ippa/chingu) provides those higher level concepts to Gosu.
Very interesting keep up the good work. Continue developing the documentation and think about what you can do to build a community to help you out.
http://www.reddit.com/r/ruby/comments/iomiw/reviews_the_book_of_weird_ruby_and_eloquent_ruby/
thanks, but i cant see Huw's comment there, but maybe i just dont recognize his screen name in that thread. Which comment is Huw's? I'm curious what he had to say in his defense
Developer server, yes, yes, it could be better. But compared with setting up an apache server, messing with passenger or whatever is contemporary these days, scaling, etc etc... git push heroku master saved my life.
Whoops! It was in the proggit version, not the /r/ruby one. http://www.reddit.com/r/programming/comments/ioor4/reviews_the_book_of_weird_ruby_and_eloquent_ruby/c25ke1z and http://www.reddit.com/r/programming/comments/ioor4/reviews_the_book_of_weird_ruby_and_eloquent_ruby/c25k54f
Huh? WEBrick is almost never used for production. Heroku uses Thin (which in turn uses some of mongrel). WEBrick is just fine for development where performance really doesn't matter, though, so if that's what you meant I agree..
I made one to many typos in IRB, especially on longer method names, so I threw together a gem that attempts to guess the method you meant to call, and then calls it. See the github page for more on how it works. Hope somebody finds it useful.
Don't just blindly downvote postmodern; pry is clearly not an alternative to IRB. It is a debugging aid, and should be used as such. Ripl is an actual alternative to IRB. I say this as an avid pry user.
Hi, I'm glad you're an avid Pry user but i'm afraid i dont see how Pry is "clearly not an alternative to IRB" :) Pry was influenced by [IPython](http://en.wikipedia.org/wiki/IPython) significantly and features hardly any commands that are not also found in that REPL. In particular the `show-doc` and `show-method` and `ls` commands are very useful when Pry is just used in an explorative capacity, as IRB is often used. In fact Pry features only one command, `whereami`, that is designed uniquely for debugging Although Pry is particularly good as a debugger I do not think it's fair to relegate it to this; nor is it even used in just this way by a significant number of its users.
Looks really good! Does it play nicely with Rubinius? I'm quite comfortable Gosu and Chingu but I would happily give Ray a try if Rubinius support is there or on the cards.
Ugh, I can't go one sentence without making a typo. Thanks.
by that logic, that means if youre ever in the south you going to use the speech patterns and vocabulary of larry the cable guy? or if you are in england you are going to force yourself to use a fake english accent? besides, ruby prides itself in the philosphy of more than one way of doing things. that philosphy should be applied broadly and not just when its convenient (eg. syntax)
Actually i'm interested why you think Pry isn't an IRB alternative, as there must have been a miscommunication somewhere. Can you tell me why you thought that? (Also, i assume you are not just using a very, very old version of Pry that *only* had runtime capabilities? Pry has changed hugely in the last 3 months or so)
&gt; besides, ruby prides itself in the philosphy of more than one way of doing things. That's Perl. Ruby's more about encouraging a good way to do things, and giving you the freedom to find it. TIMTOWTDI is not a term I see in the Ruby community so much; I've seen it maybe twice applied to Ruby in years of involvement in the ruby-talk list, both times as a direct response to someone saying something about Python's more narrowly defined "one right way to do it".
it is a ruby philosphy now since matz [said](http://www.artima.com/intv/ruby3.html) so.
I'd have characterized that as a case of Matz saying that Ruby's philosophy is freedom. Giving people more than one way to do things is just a means to that end. I guess it could be interpreted either way, or both simultaneously, though.
Sure it works with Rubinius! It even supports JRuby. :)
briliant!
why not just use completion instead? `require 'irb/completion'` If it completes, then you have the right method.
Awesome. I wrote [guessmethod](http://guessmethod.rubyforge.org/) years ago, which used the same dangerous method_missing with levenshtein distance logic. But **you** implemented all the extra features people wanted that I was always too lazy to implement. I'm looking forward to giving this a shot instead. Edit: Oh, two things that guessmethod has that this doesn't (yet, I imagine) are the same thing for constants (via const_missing) and rake tasks (via rude monkey-patching). Maybe I'll whip up a patch :)
Yeah, that's a good point too.
Neat idea... the idea of a REPL for git is in itself interesting, the method-level blame is a great concept. I'll definitely for it when I have some time to play.
Just for example that I can't do `cd = 5`. That breaks it entirely. It overlaps A LOT with IRB, which makes it a great partial replacement, but I often use IRB to test out bits of code that I write (not just exploratory), but the above example shows that it can't be generically used for that purpose. IRB at its core should be very simple. Pry is much more than that, and it encompasses most of IRB and much more, but it still leaves out a little bit.
http://www.reddit.com/r/ruby/comments/ir3yv/a_great_new_screen_cast_for_the_pry_repl_an_irb/c26del9
There are only a very few Pry commands (mentioned by postmodern) that could possibly cause conflict with local variable assignments. As explained in the reply to postmodern it is also very easy to resolve such conflicts (simply by prepending a space). I personally do not think that avoiding a small number of variable names is a large price to pay for the functionality provided by Pry. However, if there really is an issue here then i can provide two options: (1) A config option toggle that applies a command prefix such as "%" before all commands, so that `cd` would become `%cd` thus avoiding any naming conflicts, or/and (2) A toggle to turn all command processing temporarily off. How about it? :)
I liked "test rockets" a lot - I feel as though some of the other entries were stuck on rspec-like syntax, so props go to the unique idea :) clear, concise, and simple.
I think providing both options would be best, but if you only want to do one, do (2). Thank you!
I should probably have used Google before writing code, but implementing Levenshtein was just too appealing. I have subsequently looked at guessmethod. Nice. And I think your code is a bit cleaner than mine. :-) Did you ever try guessmethod on ruby 1.9? The default binding is different from 1.8. In 1.8 const_missing is executed with self == Object, but in 1.9 I can't figure out what the context is, and the only constants available are related to extend-command.rb. [:EXCB, :NO_OVERRIDE, :OVERRIDE_PRIVATE_ONLY, :OVERRIDE_ALL]
Mostly because I thought it would be fun (especially the Levenshtein distance part), and I couldn't remember how to enable completion, and obviously implementing a gem makes more sense than Googling for the simple solution. :-)
interesting. what are your reasons to choose unicorn over passenger besides rolling out new features as they become available?
guessmethod is currently broken on 1.9. (blows the stack in the levenshtein method), and I just haven't gotten around to fixing it. I'm not sure I'm seeing the same problem as you are with const_missing: $ ruby -v ruby 1.9.2p180 (2011-02-18 revision 30909) [x86_64-darwin10.6.0] $ cat const.rb class Test ONE = 1 TWO = 2 def self.const_missing(*args) p constants super end end Test::THREE $ ruby const.rb [:ONE, :TWO] const.rb:7:in `const_missing': uninitialized constant Test::THREE (NameError) from const.rb:11:in `&lt;main&gt;' Feel free to hit me up off Reddit: cmshea at gmail.
thanks. having the app's unicorn and bluepill configs 'inside' each app is also a win. :)
I would have just wrote it like this: https://gist.github.com/1093102
Long sequences of ends tends to mean your code is messed up and is too nested. It's an obviously ugly indicator of some ugly code in most (all?) cases. 
Is this like Runnable from Java or curried functions?
The video comparison is amazing. Shouldn't active_reload be included in Rails core?
http://youtubedoubler.com/1fts - I think that spree was a good example app to pick up because everybody can try it for himself and it is big enough to make you see the difference and the benefits. Small rails apps don't need such things.
There's also [rails dev boost](https://github.com/thedarkone/rails-dev-boost) which I believe works in the same way.
I'm wondering what the difference is. That's what we use and it works for our rails 2.x projects too.
Nice. Much simpler implementation than [rails-dev-boost](https://github.com/thedarkone/rails-dev-boost)
It didn't work well for my app. The nice thing about active_reload is that it is very unlikely to break anything.
Yeah, if you have nested loops (let alone with an `if` or `case` inside!) you're obviously writing bad code. I guess most rubyists don't have to implement algorithms, but those that do, end up with several levels of `end`s, and that doesn't mean they have bad code.
I'm as guilty as anyone with nested loops, but that technique does strike me as much more procedural than OO, and so probably not elegant Ruby-esque code.
Yeah - algorithms are often highly procedural in nature. Finding the dominator tree of a directed graph is going to be a mess if you try to cram it into a bunch of methods instead of just a couple nested loops. Algorithms I write in Ruby actually are often extremely readable because of Ruby's syntax and built-in data structures. They just end up with ugly "ends" all over. So I do recognize the frustration. Sadly all the solutions I've ever seen are abominations.
Check out [Sinatra-Reloader](https://github.com/rkh/sinatra-reloader) if you use the Sinatra framework. :)
What didn't work well? We use it on our Rails 3 project (which was converted from Rails 2 recently) without issue.
Does it reload individual files, or the whole app if one file changed?
The idea behind active_reload is way simpler and less hackish thus less error-prone. I'd love to see a performance comparison. 
I just got done looking at the code in active_reload vs rails-dev-boost. Quite the difference, indeed!
Don't pay too much attention to him, he's just promoting his own work. Check out his [comment history](http://www.reddit.com/user/paneq), including his [announcement post](http://www.reddit.com/r/rails/comments/i9pkw/faster_rails_development_part_2_annoucing_active/). It looks like he even [registered an account](http://www.reddit.com/user/lewy313) just to leave a comment. This doesn't detract from the gem if it actually works, of course, but I wouldn't take his word as fact. 
This looks great. I've been looking for something like this to build quick GUIs for some ruby based music performance projects I've been working on. At one point I started building high level classes for Gosu but never quite took it far enough to be useful
Thanks. I haven't gotten to test it yet, so perhaps it won't work as well as rails-dev-boost. But if it does, it's a *much* simpler implementation. edit: And I just tried to use it with our project. Unicorn won't even start up with active_reload. I just noticed that it depends on ruby-1.9.2, we haven't been able to upgrade to that yet.
Yes, currently it needs ruby1.9.2 but that will change.
lewy313 is my friend working on stopango.com . They also use this gem so it is likely that he upvoted my post because I told him about it.
I wish I knew. I would create an issue in such case. I believe that I am pretty good at finding what's wrong and sometimes even fixing it (https://github.com/apotonick/apotomo/issues/28 - one of the weirdest bug that I hunted recently) but I couldn't track it down. If rails-dev-boost works for some people and makes them happy and more productive then it is awesome and kudos for the creators which are probably much smarter than I am. It didn't work for me as well as it does for others so I created a very simple alternative solution. It does not change rails code reloading, does not try to make it faster, there is no voodoo. Only one simple change that makes huge difference and is not likely to cause any trouble.
It doesn't try to be too smart and reloads the whole app. The same way Rails does normally. 