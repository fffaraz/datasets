Ruby bug: https://bugs.ruby-lang.org/issues/6284 So, same, not merged but it's interesting. Though I don't see any usecase I would have.
Not disheartening the gem. But in the README it says to serve static sources at 100k per second. Isn't nginx or Apache better when it comes to static files? 
That's seriously cool.
&gt; It might be a better idea to ask on the dragonfly subreddit and mailing list if you already haven't. I did that before posting here. I was informed that it's a [known issue](http://gnats.netbsd.org/53154). No suggestions, though. &gt; edit: and if you're building ruby versions yourself and don't care about ruby-build, just look at the dports makefile for ruby and you can see the patches and configure flags they use for building the base ruby package successfully. I was hoping it wouldn't have to come to that! Thanks for the thought-out response, though. I do keep this on my radar as a last resort.
&gt; PS: I must use a version manager. I am not forced to use rbenv, though. Note that with rbenv and chruby at least, you can _build_ ruby however you want, and still use rbenv or chruby for switching between rubies. Personally I wouldn't want to be dealing with the Makefiles directly, but then I'm not the one trying to build it on BSD, heh. 
Only reayding the topic already implies something fishi
If I'm reading that last spec correctly, there is one difference, which is that you can redefine `#method` but `.:` will always have the same meaning.
Written in rust please
nobu also makes a lot of things that don't make it to the trunk
&gt; Would this support procs with two or greater arguments, and what would the syntax look like? [Looks like only the first stage of the pipeline could have multiple arguments.](https://github.com/nobu/ruby/commit/0ae8304d52cf69c753201a21be1bc24377f58f90#diff-259f250fd3284378603814e17aaad68cR1428) &gt; Would it only work for procs, or for anything that responds to #call? [Looks like callables should work.](https://github.com/nobu/ruby/commit/0ae8304d52cf69c753201a21be1bc24377f58f90#diff-259f250fd3284378603814e17aaad68cR1463)
I'm kind of torn. On one hand, I think this is pretty neat. On the other hand, I'm imagining myself buried in unintelligible code that overindulges in "functional" tricks.
The real MVP
&gt;I was hoping it wouldn't have to come to that! There is a middle ground, you can look at the makefile from dports (which you should probably get accustomed to using anyways, if you're going to be running bsd), figure out what you need to figure out, and then submit a bug request (or possibly even a PR) to ruby-build's github telling them that it's busted on dragonfly. At that point, you've at least passed the buck on to some other poor soul :D
This is a legitimate concern for me: &gt; I'm also really afraid of having chance to read something like `a &gt;&gt; b &lt;&lt; c &gt;&gt; d`.
Yeah, I wish they only had one direction of function composition. 
fwiw, the ports makefile I was talking about is kinda a different beast than an autoconf generated one like ruby's. These are really just a scripts with a bit of syntactic sugar for building the package, and generally aren't giant pain in the ass to [take a glance at and quickly understand what's going on](https://github.com/DragonFlyBSD/DPorts/blob/master/lang/ruby25/Makefile).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [DragonFlyBSD/DPorts/.../**Makefile** (master ‚Üí 190fd01)](https://github.com/DragonFlyBSD/DPorts/blob/190fd0155bbae9c91aeefbcdf5843c7afeda0b74/lang/ruby25/Makefile) ---- 
I'm not sure if I like that syntax. Is this gonna be a thing? foo = &amp;File.:read foo.call('bar') 
is this the originating issue? https://bugs.ruby-lang.org/issues/6284 
Yeah, they've probably just got caught with "symmetric syntax" temptation.
If it merged today, what version would it be available in?
so how I can use this with rails/roda/sinatra?
Upcoming 2.6 (released this Christmas, as usual), I believe/hope.
Will it work with anything responding to \`#to\_proc\`? For example could I do: \`\`\` \[" hello ", " world "\].map(&amp;String.method(:rstrip) &gt;&gt; String.method(:lstrip)) \`\`\`
Random - is the `&amp;` calling `#to_proc` or `#call`?
your rbenv problem sounds rbenv-specific, so consider testing others. besides that, you should always turn off doc generation on production machines, it just consumes time for things that are never used.
I believe you are right, it's `#to_proc`, but when actually running a proc-like thing, it must respond to `#call` with any number of args.
I started using vim for no real reason and stuck with it. It's wound up being a good choice for a few reasons. I really like modal editing. Most machines at least have vi. Ruby is well-supported with vim and there are a lot of Rubyists or former Rubyists in the community. You can script vim with Ruby. I don't have anything against Emacs though and am jealous of things like being able to use lisp instead of vimscript. I'd like to learn more about what Emacs provides
Well there's no reason you'd need to be so verbose if it just calls `to_proc` on everything; this is just a verbose example. If it worked with `to_proc` you could use `Symbol#to_proc`: ``` [" hello ", " world "].map( &amp;:rstrip &gt;&gt; :lstrip ) ```
Well I just learned we are getting the .: operator, so all is good. 
Exactly why I am excited about GoLang. They won't bloat it, they said this pretty clear multiple times. I've been doing Ruby for over 8 years and I still love it.
So basically: "data.json" .then(&amp;File.:read) .then(&amp;JSON.:parse) .map(&amp;Product.:new) .then(&amp;Product.:import) 
going to +1 for rvm it just works and seems to have consistent gem isolation across ruby versions if you need to support multiple ruby versions w/ different gems
Here is one written in C - [https://github.com/boazsegev/iodine](https://github.com/boazsegev/iodine)
Fixed your formatting: require 'bundler/setup' require 'net/http' require 'uri' require 'twitter' module GetTweet class Error &lt; StandardError; end def self.catch_tweets client = Twitter::REST::Client.new do |config| config.consumer_key = "LULULULULULU" config.consumer_secret = "LULULULULU" config.access_token = "LULULULUL" config.access_token_secret = "LULULULUULU" end # getting all tweets in a hashmap with "mention" without retweet in option timeframe @tweets = client.search("#mysearchrequest -rt", since: "2018-8-27", until: "2018-11-7") @sorted_tweets = @tweets.sort_by {|tweet| tweet.created_at} @sorted_tweets.uniq.each do |tweet| @tweet = tweet puts @tweet.full_text end end catch_tweets end and require 'net/http' require 'uri' require_relative 'get_tweet' INSTANCE_URL = 'https://LULULULULULU.de/posts.json' API_USERNAME = 'LULULULULULU' API_KEY = 'LULULULULULU' def self.send_request url = URI.parse(INSTANCE_URL) request = Net::HTTP::Post.new(url.path) request.set_form_data({'api_username' =&gt; API_USERNAME, 'api_key' =&gt; API_KEY, 'title' =&gt; "Neuer Post", 'topic_id' =&gt; 8, 'raw' =&gt; "#{tweets}"}) http = Net::HTTP.new(url.host, url.port) http.use_ssl = true response = http.request(request) puts response.code end send_request 
I run system Ruby under everything, but I'm 99% certain gemsets have prevented a whole whack of frustrating issues.
You're on the right track. You could store those URLs in an array, check to see if the URL is in the array, and if not, post it to discourse. If you leave this running for very long, that array could get very large, so you probably want to address that. Also consider that your Twitter api call has a "since" param. I'm not going to look up Twitter's docs for you, but if that allows you to send a date time instead of just a date, you could do this: @@last_search = nil def self.catch_tweets ... client.search("#mysearchrequest -rt", since: last_search, until: "2018-11-7") @@last_search = DateTime.now ... end Assuming that @@last_search gets formatted in the way Twitter wants it (if not, [learn how to format datetimes](https://ruby-doc.org/stdlib-2.3.1/libdoc/date/rdoc/DateTime.html#method-i-strftime)), and assuming you don't care about thread safety.
Wouldn't it be easier to use jbuilder to generate the XML files and then use generic encryption on the text file, e.g. using `ActiveSupport::MessageEncryptor`
For anyone wondering how to set it up for rack based apps: http://www.ohler.com/agoo/doc/misc/rails_md.html
http://www.ohler.com/agoo/doc/misc/rails_md.html
Thank you so much!
jbuilder is used for json generation, so I assume you mean builder. Message encryptor on a flat file would be the equivalent of using gpg. I would prefer gpg. https://www.gnupg.org/gph/en/manual/x110.html In the post, I shared a way of using two open xml based standards (xmldsig and xmlenc) for signing and encryption. In what I am aiming to be a ruby friendly way. The example is contrived but a real world example is using xml-kit for generating SAML messages.
in crystal [10, 20, 30].map &amp;.modulo(3) #=&gt; [1, 2, 0] [1, 20, 300].map &amp;.to_s.size #=&gt; 1, 2, 3 [[1, -2], [-3, -4]].map(&amp;.map(&amp;.abs)) #=&gt; [[1, 2], [3, 4]] [1, 2, 3, 4].map &amp;.**(2) #=&gt; [1, 4, 9, 16] I hope these are possible in Ruby.
Yeah, they finally went with the same syntax I original proposed 6 years ago!. Although my proposition was for composing on one single direction. Also is a shame they didn't allow symbols as the first element of the chain.
It's hard to believe that it'll be any faster than puma or passenger for normal Ruby apps. Most real app performance is 95% app code; there's only so many microseconds to be shaved these days, no? I like that he is trying Tidelift for sustainability. https://github.com/ohler55/agoo#support
&gt; Note that with rbenv and chruby at least, you can _build_ ruby however you want, and still use rbenv or chruby for switching between rubies. True. It's not total failure that brought me to post. I just found the required tinkering to exceed what _I_ consider reasonable. &gt; Personally I wouldn't want to be dealing with the Makefiles directly To be fair, setting environment variables was enough. &gt; but then I'm not the one trying to build it on BSD, heh. Not all BSDs are the same. I completed the same task with practically zero friction yesterday on OpenBSD. Another poster on this thread uses FreeBSD with no problems.
I am so confused by this code.
A real-world example of that (which I have faced) is being told you must have 0 dependencies and only use stdlib for an ultra-portable Ruby script. These extreme scenarios do happen.
Aside from the merit, why do you put the successful path outside the exception boundaries? Isn't that simpler: ``` def webhook event = JSON.parse(request.body.read) case event['type'] when 'invoice.payment_succeeded' # handle success invoice event when 'invoice.payment_failed' # handle failure invoice event end render :json =&gt; {:status =&gt; 200} rescue Exception =&gt; ex render :json =&gt; {:status =&gt; 400, :error =&gt; "Webhook failed"} end ```
Well you need to whitelist the methods either way, so it evolves back to the original case statement. Also rescuing Exception is pretty horrible practice too.
if you exited about go, at least write the name properly :)
Block support for \`to\_h\` seems nice. 
yes it is
Looks great
It's not. Extracting the archive and having at it yields the exact same error. 100% agree on disabling the RDoc step.
Probably, lots of people pushed for those lately (I did!). And now winter is coming, the new release is coming, so....
AFAIK, Crystal have made a conscious choice to make `&amp;.method` an atomic idiom on its own (unlike Ruby's to_proc + Symbol, to_proc + method). It has its virtues, as we can see. I don't think something like this will come to Ruby, if only in a long iterative process. For example, `&amp;.modulo(3)` can currently ALMOST be implemented in Ruby with `Symbol#to_proc` and `#curry`: [10, 20, 30].map &amp;:modulo.to_proc.curry(2).(3) But it is not the same, Ruby's `curry` binds the first argument, so this renders to `3 % 10, 3 % 20, 3 % 30`. So, we need some `rcurry` (reverse curry, binding args from the tail, and probably able to work without explicit specification of number of arguments (which is impossible for current implementation of currying!): [10, 20, 30].map &amp;:modulo.to_proc.rcurry.(3) This obviously looks super-ugly, and 10 times worse than just `map { |x| x % 3 }`. But if this would be possible in this, ugly, way, then probably some syntax shortcuts could be invented, which allows writing "simple" code that effectively renders to the same syntax. On the "let's be extreme side", you can do this! class Symbol def call(*args, &amp;block) proc { |x| x.send(self, *args, &amp;block) } end end p [10, 20, 30].map &amp;:modulo.(3) # =&gt; [1, 2, 0] p [[1, -2], [-3, -4]].map(&amp;:map.(&amp;:abs)) # =&gt; [[1, 2], [3, 4]] p [1, 2, 3, 4].map &amp;:**.(2) # =&gt; [1, 4, 9, 16]
I've been getting the same error and haven't found a solution yet.
`filter` is popular in other languages, but now we have `filter`, `select` _and_ `find_all` synonyms, and somehow whichever one I get used to will be the one whatever project I am currently working on has a rubocop-enforced styleguide forbidding. 
First of all thank you for the formatting! Thats really helpful! I managed to create a date method &amp;#x200B; def self.date date = Time.new #set 'date' equal to the current date/time. date = date.year.to_s + "-" + date.month.to_s + "-" + (date.day-2).to_s #Without this it will output 2015-01-10 11:33:05 +0000; this formats it to display DD/MM/YYYY end and adjust the tweet search like this `$tweets = client.search("#test -rt", since: "#{date}", until: "2018-11-15")` &amp;#x200B; But the biggest issue i cant get solved is that i don't know how to save the tweet urls into an array and append every new tweet to it. I probably should go with a hashmap for it or something like that but i not sure how. And then i have to look for a possibility to automize the file probably using sidekiq
In Houston, not Waco, but welcome to Texas! It's a bit cold now, but you can get some chili to warm up!
I wouldn't store the URLs - just store the IDs. `tweet.id` instead of `tweet.uri` @@processed_tweets = [] def self.catch_tweets ... @sorted_tweets.uniq.each do |tweet| @tweet = tweet next if @@processed_tweets.include? tweet.id @@processed_tweets &lt;&lt; @tweet.id puts @tweet.full_text end ... # Now we're going to manage the size of that cached array so it doesn't get too big. # Maybe 200 works for you, maybe you need a larger number @@processed_tweets = @processed_tweets.slice(0,200) if @processed_tweets.size &gt; 200 end
I had to lookup what "WFM" means and the first result was "Wired for Management". I now know it means "Works for Me", but I thought that first meaning was also relevant.
Lots of Rubyists in Austins, and I assume Dallas as well. Waco is between those, and the drive is not trivial, but also not so far that you couldn't make it a day trip for a conference or meetup.
Wow I‚Äôm super hyped! Matz mentioned and thanked me in his opening keynote at Rubyconf LA just an hour ago. https://imgur.com/a/BLtslTV
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/QPj1gn4.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e9mvcws) 
Very cheerleader. We could use more objective reviews. E.g., I've seen reports of no speed improvements with the JIT. And it's utterly under-documented, and difficult to use. &amp;#x200B; Apart from that, most of the "what's new" looks like additions to API's: convenience functions and accessors. &amp;#x200B; I wish that there were API deletions, deprecations, and fixes: it's an untended garden that just grows and grows.
Good info, but my god that guy needs an editor.
for what? :)
Well, they're overriding stdlib _now_. they weren't when they were written. Sort of retroactively overriding it. 
Having a C compiler in a production machine/container is a security no-go. Not sure about MJIT, the rest is cool tho.
Yep, there are a ton of things in core and stdlib that are acklowedged to be poor choices. Modern Ruby style tools check to make sure they're not used.
That makes sense, thanks for the explanation. The method reference operator looks great.
Coming from Boston I doubt this is of concern. 
I think that's a perfectly good solution. But this isn't the only alternative to non-deterministic tests, WebMock/VCR etc give you completely deterministic tests! They do give you some more tooling/infrastructure to deal with though. But yeah, if you can take the network access out of the responsibility of a certain class, it's almost _always_ a good move. I don't think you are always left with _nothing_ that you want to test where WebMock and VCR could come in handy (although in this case I agree there's probably no need to test standard http tools that are already well-tested elsewhere) -- but always good to look for a way to factor the responsibility out before just reaching for VCR/WebMock, it gives you a better design generally not just easier testing. 
I need the url cause I want to send them into a discourse topic, and to achieve that they get embedded properly I need to send the urls to the topic 
Same, but i got it working. Turn off your ad blocker. (or, disable whatever service that's blocking that domain; /etc/hosts, router, vpn, etc.)
For compiling a neat list of what changes are coming to Ruby 2.6. 
Were you there? He said he didn‚Äôt know if you were but definitely thanked you for your contribution!
Austin yo.
Unfortunately no, I tweeted and thanked him for his appreciation and how honored I am. 
Hey man, thank you a lot for the comment. Can you pin point to what parts need to be edited? I am not a native English speaker and would like to improve my writing.
I have often wished we could start depreciating those in JIT. The idea is simple, if you want performance, you will allow the Modern Ruby Style. And than few years later drop those in the Interpreter as well.
Nice! Thank you. Any plans for Ethereum?
Nobody has noticed `Range#===` switched to use `cover?` instead of `include?` :( Fought for this change for several years!
I think you have a good point. I may well add an integration test for downloading the XML file. I should also update my post to make it clear that it doesn't have to be either/or.
mssql are doing same
Good idea. I've had this problem a lot too. Will be using this! Having the ability to serve a local image would be nice, often times a product or profile will have a generic, default image. Maybe an option to suppress HTTP exceptions..? 
What a stupid thing to want to have. Interestingly enough, none of these "conduct" jokes is part of any licence.
I don't quite understand why it is "marxist"; nor why it would be "cancer"; nor what it does have to do with white, male or meritocracy. I do think they are all utterly useless though, for different reasons.
That deseserves a downvote. Why? Because you assume an "insecurity" here. I can assure you that there are numerous perfectly valid reasons to be against any codified bible text, no matter how it is called. "i say let‚Äôs use them as long as common decency is not so common." That, again is an assumption - that there is a lack of "common decency". I fail to see that. Do note that being in opposition to the code of jokes by no means says anything about adopting a point of view that is antithetical to what a code of joke may say. It's a bit like the differences between a religious person, an agnostic, an atheist and a non-descript / non-defined person. A bit like a meat-eater, a vegetarian, a vegan and someone who merely states that he does not eat animals (which would not make that person automatically a "vegan" or a "vegetarian"). I understand that in the modern era where there is only good and evil it's a bit difficult to understand, but there are more shades of grey than these two polar opposites.
The syntax isn't pretty ... I don't have a good alternative though. :( 
I don't like .then either, but .then is actually nicer to read than .yield_self. I can see myself using .then whereas I have avoided .yield_self (and will probably not use it either). I am not at all happy with the syntax for chaining with both &amp; and .: I have no better alternative syntax proposal though. :( 
The syntax is indeed not great. The problem is ... can we find something more elegant? I tried and failed. Perhaps if we could get rid of &amp; then that would be nice.
Wow is that ugly! I hope we don't see a crystalification of ruby. You guys already went overboard in crystal.
&gt; &amp;.modulo(3) I hope this will never make it into ruby. Why would we need matz if crystal's awful syntax choices would make it into ruby too? ;)
Good to see you are still around to see your issue approved after 6 years. :D
That's not true - there are many patches that have not been merged in. Matz has the final say on everything. It may be that some things were communicated faster between them but just because nobu creates a patch does not mean that it will automatically go in. Nobu often provides patches to make discussion etc.. easier since it can help test out stuff too.
Agreed to the first sentence. Unsure about the second sentence.
.: is problematic though - :: exists and so does . My eyes are bad! :(
No, that is simply incorrect. You should know that by now too. xmas release is NOT "experimental" - it is for stable things. Not ad-hoc mass approval. If it were otherwise then matz would contradict what he said before (in regards to breaking changes and the 1.8.x to 2.x painful transition for some). I would recommend to see this more as increased discussion and possibly merging of the code, but not necessarily automatic approval and, even more importantly, "this will go into xmas release in the next month".
???
I disagree on some of your comments. I think .filter is great, because .reject and .select are ultimately filters, so the alias name is fine. "then" is not a great word, I agree; but yield_self is annoying to type, whereas .then is shorter, so from this point of view, .then is better than .yield_self. What worries me more is how useful yield_self is. I don't remember ever having really needed it. Also it is not true about "along with everyone else" since you can find different opinions on the bugtracker. But matz is the core designer and decides what gets into ruby and what does not. Crystal follows a more open-styled evolution if that is more your thing.
I don't think elixir-syntax works well for ruby in a 1:1 setting.
Finally I can agree with you - not necessarily on the syntax part of example A, but most definitely that example B will not work 1:1.
Yeah. You are now one of the few who have a blog article approved by matz. :) I still have not, mostly because I am insanely lazy and thus don't really write much on blogs at all (in general, not just related to ruby ... I think you need to really like writing about things).
They discussed the idea for, IIRC, 2 years without being able to agree on syntax. I once [compiled](https://bugs.ruby-lang.org/issues/13581#note-21) a list of all proposal gathered along the way, there are kinda two dozens of them. Maybe all of us have missed some nice opportunity, but I believe I haven't seen anything more atomic and less cryptic than `&lt;receiver&gt;&lt;punctuation&gt;&lt;method_name&gt;`, and of all possible `&lt;punctuation&gt;` options almost no one seems to be catastrophically worse or incredible better than other (though, I personally dislike anything that uses `|` or `&gt;` characters). So, I'd say it is good they finally choose something.
What the heck are you babbling about there? And you are not even specific, so - go start. Be specific. Name what is a "poor" choice. So?
Are you two tag-teaming without content? Like one is a human and one is a bot? What the hell is "Modern Ruby Style"? What does that even MEAN?!
It is not a security no-go of course. How could it, anyway?
For many changes out there, I am not sure what they will improve specifically ... so I am not sure what Range#=== will add what I really need. :\ :/ I'd like to have case-when menu as a first class citizen though.
You are self-entertaining yourself there bro! I also had no idea what WFM means. I always think first it is some expletive. Something like WHAT FUDGE MOTHER ... which evidently makes even less sense than the, by now, infamous Wired for Management.
&gt; so I am not sure what Range#=== will add what I really need So, you never use ranges in `when`?..
That is actually a pretty cool change. Would you like to write an example and I‚Äôll edit the post and credit you?
Well theres no way to get much better syntax, since Ruby method calls do not support currying OOTB. Due to that any normal method call will be instantly evaluated. So there is no way we will get syntax as nice as Elixir's pipe operator...
I will see if there is an Ethereum API that is as straightforward Strike ;)
Oh, sorry, I meant no offense. I understood what I was reading, but the wording is kind of awkward. I'd assumed that the author was a native speaker who was just being lazy or careless. Being a non-native speaker of the most illogical language in the world is a totally valid excuse. :-) Here's an example: &gt;&gt; There were some offers as to how to create the JIT compiler itself Now, if you were a native speaker and had written 'offers', I'd pick on you; it's not quite the right word there. Maybe should have been 'proposals'. *However*, that's actually a pretty subtle distinction, because in some contexts, 'offers' and 'proposals' mean the same thing. Not in *this* context, but it's an understandable mistake. One more example‚Äîif someone had gone through the US, Aussie, or UK school system and ended up writing this, that's one thing, but if you don't write English every day for years and years, I'd expect some occasional awkward sentences to appear. (Underlying theme here: English is an unnecessarily complex and illogical language, and all the native speakers do know that.) &gt;&gt; John Hawthorn shows in his early post from ten months ago, internally how it looks like. I might word that as &gt;&gt; John Hawthorn wrote a blog post 10 months ago showing the internals of the implementation. Something along those lines. Anyway: sorry for being a jerk. 
 Simple Geocoding by IP Address Given a User model with known IP address, automatically fetch coordinates and store in lat and lon attributes: # app/models/user.rb geocoded_by :ip_address, :latitude =&gt; :lat, :longitude =&gt; :lon after_validation :geocode ‚Äî http://www.rubygeocoder.com That said, I don't think using the IP address to determine someone's (more or less) exact location works well for your use case: The distance between what my home IP address resolves to and my actual location is almost 8 km (5 miles). If I use my phone's IP address, it's 8 km, too, but in the other direction. That's without considering things like proxies, VPNs etc. If you want the user's location, you really should use client-side `Geolocation`. A super easy way would be to populate input fields with JavaScript code that's being run when the document is ready. Something as simple as this (using jQuery for simplicity): ``` navigator.geolocation.getCurrentPosition((position) =&gt; { $('#latitude').attr('value', position.coords.latitude) $('#longitude').attr('value', position.coords.longitude) }) ``` This doesn't consider the client denying access to their location. See [1] for the `Geolocation` documentation. [1] https://developer.mozilla.org/en-US/docs/Web/API/Geolocation
&gt; Name what is a "poor" choice... Off the top of my head, * Global variables * The various Perl globals * `for` loops * The broken `@@` design * The standard HTTP library etc., etc. These aren't anything to be ashamed of - every language has good choices and bad choices over time. Ruby's problem is that the widely acknowledged bad ones are never cleaned up - they're just added to the list of things to avoid.
Nice!
Yeah, I should be more specific. I'd like to see just a simple recipe for actually running the JIT to even see it in action. I've tried every permutation of its options... and I can't determine if it's using the compiled code, if it's working as it should, etc. etc.
The geocoder gem has both IP geolocation (e.g. `request.location`) and Google Maps (and others) API based location search (e.g. `Geocoder.search("Paris")`). The OP post is confusing because he talks about filling in locations and the Geolocation JS API.
Yes, you can do both `Geocoder.search('1.2.3.4')` and `Geocoder.search('Place de la Concorde, Paris')` and you can get their geocoordinates by calling `#coordinates` on a result object. (`Geocoder.search` returns an array.) My point is that the location you get from an IP address does _not_ reflect where the _user_ is "exactly" and an error of 8 km (in my case) does not help his use case, at all.
See Rubocop. See the Rails source code. Just a couple examples.
Well said
The hostile reaction to this is my favorite thing about the Ruby community. Nobody wants moralizing nitwits solving problems we don't have. 
https://rubyconferences.org/
Thanks for taking the time and effort to help me out! Really appreciated, you are awesome!!
Do you feel like writing a short example about it? I will happily edit the post and give you the credit!
Do you feel like writing a short example about it? I will happily edit the post and give you the credit!
Yeah, I can see how this could be an issue now. Still open to something less weird-looking.
So you say it is not, then you ask why. Ehm. Restricting compilers and/or interpreted languages is a standard security hardening technique. I've seen customers even recompiling linux distribution packages to strip down executables to bare minimum code. Less code, less bugs, less attack vectors. In the container space, it's rather technical challenge than security issue. I will definitely not want a compiler to be in every single container with Ruby app, it can be probably solved somehow. Time will show. &amp;#x200B;
Thanks for the thorough reply! Sounds like the geocoder route is not viable... I'll have a look at doing it client-side and then writing the values to the database.
So the modulo operator works on Enumerables now and it still hasn‚Äôt occurred to anyone that `/` should be an alias for `String#split` smh 
ü§Øthat's such a great idea
FINALLY enumerable to_h and variadic hash merges fuck yeah
Operator overloads are a slippery slope. I totally feel you on that being a sexy syntax but hope typing the extra 4 characters take you less time than the benefits of explaining what the division method does on a non numeric type to the unsuspecting. 
`Hash#to_h` is ugly.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/happyface] [\[r\/ruby\] RR 388: RuboCop (and Emacs I guess :-)) with Bozhidar Batsov | Devchat.tv](https://www.reddit.com/r/happyface/comments/9x9mbv/rruby_rr_388_rubocop_and_emacs_i_guess_with/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Wow, super-cool story. So many parties and "cultural preferences" that could be easily blamed, but probably the root of the problems is much deeper than some library's approach to code. The whole mutability thing is doomed :)
can you show me how other programming languages are doing this?
Other programming languages are not doing this uglyness.
Hey man, really awesome comment, thank you for taking the time and helping out a random guy on the internet like me improve his writings! Much appriciated!
Also the Ruby stdlib CSV module is leaking.
2.6.0-preview3 with JIT is a lot slower than 2.5.3 at a fairly common task - parsing a log file. To reproduce, create a 19Mb Apache log file and run this script: IO.foreach('logs1.txt') {|x| puts x if /\b\w{15}\b/.match? x } Factoring out startup time, my `time` benchmarks show Ruby 2.6.0-preview3 to be 60% slower than 2.5.3. Without JIT both Rubies were identical when startup time was factored-out.
Here is Takashi's most recent slide: https://speakerdeck.com/k0kubun/rubyconf-2018?slide=80 The most important thing is this, in my opinion - he wrote that if you experience any slowness due to jit, even more so when you may feel that this should NOT be that way, please do and provide extensive information on the ruby bug tracker at: https://bugs.ruby-lang.org/projects/ruby-trunk Ideally by giving as much information as possible. Most importantly if you already may have some benchmarks in use, and the jitted code performs slower. While I am not as optimistic as Takashi in regards to making this very fast before the xmas release (but I am perfectly fine with improvements in 2019, too), I think the key message really is that people should give feedback on the bug tracker, rather than just do twitter-orgasms without much information how to reproduce ... :P (Although I understand it partially because twittering is easier than providing lots of useful information in a bug tracker, but if you complain about jit not being fast, yet don't give feedback, how should the ruby core team improve on it?)
&gt; If you follow any of the above links, please respect the rules of reddit and don't vote &gt; in the other threads. Can we add a no-bot rule? I do not come to reddit for the bots - I come to reddit for the humans (I use only old.reddit.com though; can't cope with the new interface ...).
Actually I disagree with you on .to_h being ugly at all. It is very simple and easy to understand and fits in line with .to_s .to_a and so on. As for %, well - I don't think it is necessary ugly: (1..100) % 3 But I probably won't use it myself. It's not necessarily bad, but not really that useful to me personally. The beaver also wrote so in the article (that is the beaver on IRC also a shapechanging lemur ...) As to your last comment, how ruby becomes "more ugly" (should that not be uglier?", well - here I actually have to partially agree with you. Only partially because not all new features or changes make ruby uglier; and some of them are more on personal preferences. But yes, some syntax changes aren't that great for various reasons. It is always difficult to pick syntax for anything that may be new, years lateron. What I have found works well for me is to simply ignore things I do not like from a syntax point of view. I do not use @@ and I do not need them, to give an example. I am in support of removing them, but: a) other people use it, and like it b) even if @@ remains, I actually don't mind that much since I do not use them anyway. It would be different if things were to affect me, but since most of these changes don't, I really don't care. I also wonder whether people who are extremely critical actually use ruby to begin with. My bet is that 90% of those who are critical are not even using ruby to begin with - at the least on reddit. Reddit in itself is a HUGE biased bubble. You can see it with the gazillion of rust promoters on reddit, whereas in reallife the real adoption rate and users of rust is SIGNIFICANTLY lower than what you get on reddit. So reddit works as a biased amplifier - and the rust example is just one example among many more.
Ok, so you are doing the trollololol path now. Let's see hmm... a little language called python. Mr. Guido added := which I think is awful syntax. Guido adds it eventually to the language. Lots of people don't want it (I can understand this), Guido throws in the towel and retires (I can understand this too). So your claim: "Other programming languages are not doing this uglyness." Is completely incorrect, totally bogus and I am also sure you MUST have known this before you posted the above. So I think that is a conclusion about what you are trying to "achieve" here.
As far as I can understand, it is not "leaking" (e.g. creates objects that will never be GCed), just allocates too much string objects on the way. An unfortunate set of circumstances led to the problem: * Draper redefines `AR::Base#===` in order to have `model == model.decorate` * It uses `respond_to?(:decorated)` to check if the object checked is decorated (with Draper) * AR's `respond_to?`, by a set of complicated reasons, converts method passed to `respond_to?` to String (BTW, in current master method code is different already in a [different way](https://github.com/rails/rails/blob/master/activerecord/lib/active_record/attribute_methods.rb#L268) * bad things happen to Ruby's memory when a lot of new strings created quickly (even if all of them have the same content!)
Shameless plug: I wrote an actor library for ruby: (https://github.com/ntl/actor)
The entire purpose of symbols is to pass around commonly-used identifiers without them being reallocated. Converting the method name symbol into a string seems like such an obvious failure. And the change in the current master is still doing that.
&gt;please do and provide extensive information on the ruby bug tracker at I don't see it in the slides (I was looking at them before publishing). I think he requested benchmarks in general and since he asked on Twitter, people included me tweeted. (Note that I am not present at the RubyConf so maybe he said it.) Do you know about some tracking bug that discuss this?
Well, one can boldly say Rails never got Symbol/String distinction clearly (that's where you get `HashWithIndifferentAccess` and all other flavors of "it can be a string or maybe a symbol, let's just pretend ...").
Interesting. We have the same issue to profile memory. It‚Äôs not easy to do. 
&gt; Why couldn‚Äôt something like this be used for Ruby‚Äôs default concurrency model? It could be. But so what? Lots of models could be used for Ruby's default concurrency model. What's special about actors? Guilds are a bit like actors.
Thanks for the detailed explanation! This made a lot more sense to me than the article as to why the number of strings balloons.
&gt; fits in line with .to_s .to_a and so on What do `String#to_s` and `Integer#to_i` do?
Yep this is exactly that. You can look at this https://github.com/benoittgt/understand_ruby_memory/wiki/%E2%9C%85-How-to-measure-with-a-graph-output-the-memory-and-CPU-%3F
Don't get me wrong, the article wasn't unclear! It just wasn't clear to me how `respond_to` and the high number of strings allocated were related. I definitely could've just missed that part of the article though.
I guess is more marketing :) I prefer to have a gem, that is maintain, and get more updates than waiting for a new ruby version :)
&gt; What do you think? I don't think Rust does anything special that will solve any of the interesting problems we have in implementing Ruby, making it fast, or making it secure.
Sounds like you might find https://github.com/socketry/async useful.
For me, this would be interesting if it weren't for crystal [https://crystal-lang.org/](https://crystal-lang.org/)
Not from Waco, but Rubyist from DFW checking in.
Up until semi-recently, Rails supported versions of Ruby that did not garbage collect symbols. This would mean that using a symbol representation internally would have provided trivially exploitable DoS attack vectors for all Rails apps. We do not support those versions of Ruby any longer, so there's no reason we couldn't switch to a symbol representation today, but such a transition would: - Break a lot of existing code that (incorrectly) relies on this internal implementation detail - Require a fairly substantial amount of time - Be incredibly bug prone
That has absolutely nothing to do with it. It is 100% about methods that often take user input, and symbols not being GC'd on old versions of Ruby
I've migrated from Active Record to [rom-rb](https://rom-rb.org/) which uses Sequel in its rom-sql adapter. I'm pretty much happy that I've made the move. Rom-rb enforces clean architectural patterns.
Definitely true at some level, but with some of the debates about Crystal and ultimate barriers perceived by its creator, I wonder if it wouldn't be useful, if not at least interesting, to see this project progress.
couldnt Rails have decided to just use strings in these cases?
Do you have this implemented somewhere? Do you have instructions on how to implement it on ruby on rails site? What are the steps?
I used the Twitter link on this one so you could check out the hashtags on it and see some of the fun that went down. Somewhere north of 1000 lemur stickers were on the loose, and quite a few found good homes and new friends.
Keep in mind Crystal now has a very limited amount of developers capable to tackle the most complex issues with compiler. This can change and hopefully it wont be too late to fix the issues with compile times if that is what you are referring to.
I am wondering how the Rails communities think of this. Do we accept that &lt;70ms is S Class? Because to me S should be &lt;30ms. Or even preferably 20ms. Which is currently not possible unless it is a Hello World Rails app.
What is this measuring? Is it first to paint?
So basically multi-threaded brute force I guess. BTW make sense but `digest` is actually a C extension https://github.com/ruby/digest/blob/master/ext/digest/sha2/sha2.c
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/digest/.../**sha2.c** (master ‚Üí 6873bbd)](https://github.com/ruby/digest/blob/6873bbd05da958e0f31e879deffc66ece1083dc2/ext/digest/sha2/sha2.c) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e9szd6u.)
As /u/BumpyBallFan said, crop the image in the normal rectangular way, and then round it up with CSS. The circular component can be considered presentation logic; if you ever decide that you want to switch to rectangular avatars, you won't have to reprocess the images.
format and presentation on mobile aren‚Äôt great. TL;DR: interesting topic, but way too much cute fluff. Should have led with: all_true = data.map(predicate).reduce(:&amp;) 
Celluloid is dead.
There was never a ruby version 1.9.8. There was a version 1.9.3, released in October 2011; then 2.0.0, released in February 2013. The latest stable ruby release is 2.5.3. Version 2.6.0 will be released in December (2018). Also, *most* ruby code is backwards compatible. Lots has been added to the language, but most of what you've learned before still applies.
Lol what even is this post
Yeah and it's pretty hard to go from cropped to uncropped :D
...when the Fire Nation attacked?
lol he made me doubt that a 1.9.8 existed, thanks
Yes, CSS works great, but the problem is I'm using this avatar in email signatures, and Outlook doesn't support border-radius. The image itself has to have the effect applied. Thank you for the links!
I see a few options: - Having a job that fetch each non-cropped image and crop it and store the cropped image (e.g. you can use the mini_magick gem for that): that would require a bunch of data/model changes - Use cloudinary to store the images and have transforms on them - Use VML to have the cropping works in Outlook: https://litmus.com/community/discussions/6939-rounded-image-outlook
That's amazingly great help. I owe you one! Got a bitcoin address for tips?
Now we see the disadvantage of the serializing processing steps approach that Active Storage uses. The command you linked to: convert input.png \ -gravity Center \ \( -size 200x200 \ xc:Black \ -fill White \ -draw 'circle 100 100 100 1' \ -alpha Copy \ \) -compose CopyOpacity -composite \ -trim output.png is generated in MiniMagick like this: image = MiniMagick::Image.open(path) image.combine_options do |cmd| cmd.gravity "Center" cmd.stack do cmd.size "200x200" cmd.xc "Black" cmd.fill "White" cmd.draw "circle 100 100 100 1" cmd.alpha "Copy" cmd.compose "CopyOpacity" cmd.composite end cmd.trim end But Active Storage of course doesn't support passing a block to `:stack`, because that can't be serialized into the URL. For Shrine I'm currently developing an on-the-fly processing feature where you would define processing separately from the URL: variant :rounded_thumbnail do |file| ImageProcessing::MiniMagick .source(file) .gravity("Center") .stack { ... } .trim .call end photo.image.variant_url(:rounded_thumbnail)
lol I lost so many bitcoins I don't want to deal with that anymore but I will PM you if you wanna do something
Generalizing a set of numbers seems not helpful to me. Is there a framework defining the requirements that I am missing?
Yes, I also think we should!
Again, we could not have represented it as a symbol internally while we supported versions of Ruby that did not GC symbols. This isn't a "we think strings are the same as symbols" thing, it was a requirement to avoid a major DoS vector
Yes, yes, I understand that perfectly, sorry for not mentioning it in the first place. I **do not** tried to make the slightest implication of "somebody just didn't do their homework", I am just saying how things are now, for a complicated historical set of reasons. And that the consequences we now have to deal with in 2018 aren't that pretty, to say the least.
I see this job ad everywhere, it's basically spam at this point. Also it's not Ruby, it's Elixir. Also this subreddit is not for job ads
Source?
What makes this official?
Nice illustrations, especially pictures of DHH and Matz. Seems like it was made for Keep Ruby Weird. Anyway I personally think reduce often makes code harder to understand that it needs to be.
Oh my, hello. This was [created and tweeted](https://twitter.com/nateberkopec/status/1062782741857648640) by me as something of a joke, as I am a video gamer and enjoy tier lists, but also I'm a consultant specializing in Rails performance. The tiers are based on my experience as a consultant and seeing 100+ real-world production Rails apps. It's for grading yourself against your peers, C of course being the "average" (though I think still on the "too slow" side of things). &gt; Do we accept that &lt;70ms is S Class? Because to me S should be &lt;30ms. Or even preferably 20ms. Which is currently not possible unless it is a Hello World Rails app. And that's the way it will be until Ruby 3x3 comes to pass (which, judging by the very preliminary work on the JIT, may actually happen). You can't "write better-er Ruby" to get to a 30 ms response. A 30 ms response is, more than likely, a toy app, an extremely simple JSON-serving API, or a 404/cors preflight/etc. Consider also that the average database query takes 1-5 ms, and most applications perform 10-20 queries per request. And what would be the point of reducing an applications response time from 70ms to 25ms? I [delve into this question quite deeply on my blog](https://www.speedshop.co/2017/07/11/is-ruby-too-slow-for-web-scale.html), but the gist is: all you're doing is reducing your EC2/server costs by a factor of 2. Which, while good, isn't worth the kinds of gymnastics you would have to do as an app developer to get there. 
Neat, BTW most gems like yours automatically defaults to using env variables so no need for `Strike::Client.use_environment_variables`. &gt; Strike is an easy to use, stripe¬Æ-like API for Lightning. Yeah, even the API looks the same :D
Yeah I would prefer using VCR / Webmock instead of having to change the source code to make testing easier
True, though it also helps build a fundamental knowledge of recursion and category theory without me explicitly saying that anywhere in the talk. 
I once worked at a company that had some page response times that were greater than 30s. What grade is that?
I'll likely also format this out as a longer Medium post, perhaps an ebook later 
Yep, the gist author is far better at explaining it that I am :) 
Other guys are being a little.. whatever. Ignore. Yes, you have discovered an instance of two general rules that are useful to know: 1. Any recursive function can be written non-recursively. 2. Recursion is slow. Every time you go ‚Äúup the stack,‚Äù you‚Äôre adding yet another layer of memory usage. You don‚Äôt begin discarding layers until you go ‚Äúdown the stack.‚Äù Can you see why, or do you want me to explain? 
Does Ruby compile with TCO natively now? Thought it was still a compile flag. 
graphql.org is all you need to start. then find the ruby libs after you understand what‚Äôs going on at the link above 
Write a program the sends users notifications if someone comments on one of their GitHub gists or unstars their repository. Use [GitHub's v3 REST API](https://developer.github.com/v3/), then rewrite it using [their GraphQL API](https://developer.github.com/v4/). Then write a GraphQL implementation of the [Reddit API](https://www.reddit.com/dev/api) for say for subreddits, users and search. Then try fixing some bugs with [graphql-ruby](https://github.com/rmosolgo/graphql-ruby/issues). 
T for Timeout
Annoying pop-up but posted by Matz on Twitter and quite interesting. https://twitter.com/yukihiro_matz/status/1063543477068165120
MRI doesn't have TCO unless you've explicitly compiled it with the option enabled (which is a bad idea, TCO isn't a good thing). That said, your results have nothing to do with TCO anyway, fib1 is O(2^n), fib2 is O(n). 
The performance difference has nothing to do with recursion, well, maybe a little to do with recursion but it's in the measurement noise. The real reason is that your recursive example is O(2^n) (google Big O Notation). Basically the number of operations it performs is 2^n where n is the input, for large n, this is a really big number. Intuitively if you walk through the algorithm its recalculating every value along the way. Try it with a small number: fib(4) / \ fib(2) fib(3) / \ / \ fib(0) fib(1) fib(1) fib(2) So with an input of 4, we had to perform 7 computations, you can repeat this with bigger numbers and it'll approach somethings like 2^n (I think technically it's like 1.6^n but it's a big number which is all that matters). Your loop based version is O(n), it just goes through once. Which isn't really worth drawing, there is a loop that starts at n and reduces by 1 each time, it executes about n times. So for example, if n = 42 then 2^n = 4,398,046,511,104 which should explain the waiting. 
We have several services that need to respond in 25ms p95, it's not a contrived target. It is probably is a contrived target is you're talking about a user facing web service, but 70ms is also a contrived target there, 100-200ms is fine in general.
Thanks for pointing out my error. TIL
I'm disappointed at how slowly ruby is evolving. Even C++ is evolving much, much faster with significant new features with every release, and a new release every 2 years. Javascript also is out of sight with its improvements. Ruby is falling behind -- we don't even have hash destructuring yet, or async/await or a proper `import/export` system. It's getting embarrassing.
Find a way to use it. I forced myself to replace some of the API endpoints of www.saashub.com from REST to GraphQL. Having a specific goal helped a lot. You may need an evening or two to go through the docs. After that everything is smooth. To me, http://graphql-ruby.org/ guides were useful and enough. (although some parts were outdated compared to the latest version of the gem) 
Part Two is out: [https://medium.com/@baweaver/reducing-enumerable-part-two-chartreuse-master-of-map-7bc7fb3e6768](https://medium.com/@baweaver/reducing-enumerable-part-two-chartreuse-master-of-map-7bc7fb3e6768)
I hear you. What all do you guys use Ruby for at PIA? I know that the Mac app was Ruby at one time, is that still true? Thanks for the great product by the way.
It's currently being rewritten in C++ with QT (you can see it in closed beta). The original app has a Ruby server that manages openvpn and a client written in nwjs :)
Part Three is out: [https://medium.com/@baweaver/reducing-enumerable-part-three-indigo-master-of-select-332d8eb0b0bd](https://medium.com/@baweaver/reducing-enumerable-part-three-indigo-master-of-select-332d8eb0b0bd)
&gt; proper `import/export` system I wish. The current `load`-based system always changes global interpreter state and the only way to keep things isolated is by namespacing stuff inside a `Module`s named after the gem. It's not a very good way to do libraries. I'm not sure if one can be retrofitted into the language at this point. 
&gt; So, that first example works but doesn't close the connection. I am not sure I understand, it does call `client.close` after the read/write loop. &gt; Also, I don't understand why there are two client.close in the forking example, I would be very interested to know the reason. When you call fork, the file descriptor is duplicated, so it needs to be closed both in the parent process as well as the child process. The actual connection is only closed when all file descriptors are closed. &gt; Also you are using both the async gem and the async-io gem. Right, I'll update the article to mention that. &gt; Anyway, interesting read, async-postgres and async-http-faraday seems like such obvious ideas now that I think about it. Seems like everybody will benefit a lot from those when they are stabilized. I truely hope so! Thanks for all your feedback.
So, for any of the examples, if I run the server and then do `curl localhost:9090` then I receive back the request headers but then the server hangs and doesn't close the connection. That's definitely related to `client.gets`.
Right, but these are not web servers :) Try using netcat, e.g. `nc localhost 9090`.
Oh ok, my bad, makes sense
It's okay and good to ask questions :)
Falcon with a basic Utopia website has an average latency per page load of 2.26ms. Throw in a few database queries and you'd still be under 10-20ms on average.
Author here, thanks for sharing! I don't like the popup either, but it's necessary to support the time &amp; work I put into writing articles. You can avoid it by visiting the site with a mobile device (it's disabled there) or by appending this at the end of the URL: ?tl_inbound=1&amp;tl_target_all=1&amp;tl_form_type=1&amp;tl_period_type=1 Thanks for your understanding.
Yes you are basically correct, the concurrency model is much more important, but only if your application does blocking I/O of significant latency (e.g. database, network). Then, Falcon and similar designs can make a big impact.
Not enabling javascript seems to do the trick too.
If you don't use Tracepoint, what do you use?
I think shoutout at the end of the article would be much much less annoying and probably more effective. Kind of like what Cloudflare does in its blog. Great content BTW
He made and ran some benchmark among other things. I disagree with your sentiment (e.g. it's low effort, I actually think it's a much higher effort than what it looks like, but you are free to make something better). But I like your questions.
Who is Matz and who is DHH in there?
Yeah, in fact, the section about transient heap definitely stands out :) I'd have absolutely no complaints if it would be the ONLY section, with post appropriately renamed. I just don't get why to put it into the middle of the rest, strikingly much fewer effort sections (and my complaint is true for 8 of 9). ¬Ø\\\_(„ÉÑ)_/¬Ø
&gt; We show that fibers require minimal changes to existing application code and are thus a good approach for retrofitting existing systems. That just hasn't been the actual experience in ruby. For a while EventMachine was very trendy to talk about; it no longer is because it turns out that trying to use it for concurrency ended up "infecting" your app, requiring that almost all IO operations use "special" tools, causing problems with dependencies that did not use these special tools, and requiring all your dependencies to be on the same page, as it were, with the EM ecosystem. This article does not succesfully convince me that anything is different now. 
interesting, ty!
wow, interesting . yes I have heard of Big O Notation but not gone into detail. thank you!
interesting, ty
thanks!
thanks! i'm not sure I understand the stack part (up vs down). if there is documentation/article you'd recommend I could even go to that to save you time explaining. regardless, thanks!
I know this is a silly thing to complain about but I thought the indentation looked a little weird in the post and then when I looked at some code examples I saw they're using hard tabs [https://github.com/socketry/falcon/blob/master/examples/beer/config.ru](https://github.com/socketry/falcon/blob/master/examples/beer/config.ru) &amp;#x200B; Have you thought about adopting a more idiomatic Ruby style, as in 2-space soft tabs? I know for a lot of Rubyists code like this is pretty off-putting (as in I just showed it to some other Rubyists who agreed)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [socketry/falcon/.../**config.ru** (master ‚Üí 61fca3b)](https://github.com/socketry/falcon/blob/61fca3b7db0285ab298d9840ae0ab0044b648265/examples/beer/config.ru) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e9w3mwn.)
Please note that my explanation is actually incorrect. Fib2 just has a more efficient algorithm, and has less to do with compiler optimization.
When actors are similar to global state, or they exhibit similar problems, something is very wrong with those actors, IME. I think there's a big disconnect between actor frameworks (I'm more thinking of other programming languages here) and the actor model itself.
&gt; In my view, this hasn't been the actual experience in ruby. For a while EventMachine was very trendy to talk about; it no longer is because it turns out that trying to use it for concurrency ended up "infecting" your app, requiring that almost all IO operations use "special" tools. Given that EventMachine is callback driven, I can certainly agree with that, and I ran into exactly the same problem which is why I eventually made Async. &gt; I believe that when EM was trendy, the argument was, sure, but you can just swap out all that IO without changing the rest of your app. But it just didn't work out that way, because the parts of your app that did need to be changed ended up not very well bounded. It caused problems with dependencies that did not use these special tools, and requiring all your dependencies to be on the same page, as it were, with the EM ecosystem, and making it hard to write shared dependencies that would work with "regular" or EM code (or yet another different non-EM choice of evented server). It just ended up being a lot of unsustainable work -- when the existing ruby ecosystem was not based on an evented model, and the ruby stdlib didn't "bless" (let alone require) any particular evented implementation to get everyone on the same page. Which is why we don't hear much about EM anymore. This article does not successfully convince me that anything is different now. Frankly, that all sounds like tooling and design problems. EventMachine made a ton of bad choices: providing an entirely new model for I/O, not integrating well with existing Ruby sockets, using different interfaces for TCP and UDP, etc. It's no wonder it didn't scale up to larger more complex projects. 
You can set the tab width to whatever is your preference. For Github, which I'll admit has crappy defaults: https://github.com/socketry/falcon/blob/master/examples/beer/config.ru?ts=2 If you browse the article on a mobile phone, it will change the tab width to 2 dynamically, so more code can fit in. I think that's a pretty cool feature of hard tabs. &gt; Have you thought about adopting a more idiomatic Ruby style, as in 2-space soft tabs? I don't actually mind which way it is, but I find soft tabs generally more cumbersome to work with, so when it's my own choice, for practical reasons, I prefer hard tabs. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [socketry/falcon/.../**config.ru?ts=2** (master ‚Üí 61fca3b)](https://github.com/socketry/falcon/blob/61fca3b7db0285ab298d9840ae0ab0044b648265/examples/beer/config.ru?ts=2) ---- 
I absolutely agree with you on all those points, unfortunately that's where celluloid ended up.
totally agree. I am a ruby fan but not a ruby fan boy. those I see have voted you down. I've seen 3 threads recently about 2.6 and its my thought every time. NO it need not be like javascript but it s feeling like Python 2.7. For various reasons we had to go to node for some needed speed on a project. As I become more and more comfortable with it I find myself reaching for it more often than I would have ever thought. I get entirely why those who leave aren't coming back but still like Ruby. There was a time when that "like" was "deeply in love with" &amp;#x200B;
I agree. I used to have a pop up on schneems.com but lots of people complained. I switched to a fork object at the end of articles and people stopped complaining, my conversion rate went up by a tiny fraction (at least it did not get worse). It might be worth a try /u/jesus_castello 
I get all of that, but my initial reaction after looking at the examples directory was to stop caring because the syntax seemed jarring to me. This is seriously the first Ruby project I've looked at in years which doesn't use 2-space soft tabs, and I think you might be losing potential users who are as off-put by this as I am. I found this issue, for example https://github.com/socketry/falcon/pull/1
Fair enough.
Someone tried to fix that with the em-synchrony gem and its many db and http clients and socket (at least tcp) API. Celluloid did the same. It didn't matter, because in the end, activerecord adapters use the raw db clients, there's net-http which manages socket interactions directly and most third party client SDKs use it (in fact most layer 7 protocol implementations in Ruby do this), and there is a huge cost in experimenting with this. As much as I appreciate another stab at making event loops work in Ruby, I don't see how it will improve on the past aforementioned approaches. Besides, fibers aren't the answer. As it is, they have limitations which cap their benefits (bound to a thread), they can't be properly implemented in jruby, and they're a low level abstraction in a high level language.
Hey, ioquatix, just a quick heads-up: **truely** is actually spelled **truly**. You can remember it by **no e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: The spelling hints really aren't as shitty as you think, the 'one lot' actually helped me learn and remember as a non-native english speaker. They're not *completely* useless. Most of them are. Still, don't bully somebody for trying to help. Also, remember that these spambots will continue until yours stops. Do the right thing, for the community. Yes I'm holding Reddit for hostage here. Oh, and while i doo agree with you precious feedback loop -creating comment, andi do think some of the useless advide should be removed and should just show the correction, I still don't support flaming somebody over trying to help, shittily or not. Now we have a chain of at least 4 bots if you don't include AutoMod removing the last one in every sub! It continues! Also also also also also Have a nice day!
Delete
If you create an [`.editorconfig`](https://editorconfig.org/) in the root of the project: root = true [*.rb] indent_style = tab indent_size = 2 Not only will this automatically configure a lot of editors, which might be useful for contributors, but Github will parse it and display tabs with ts=2 by default.
Good idea yeah I did experiment with that but it forces a particular tab indentation, so I wasn‚Äôt sure if I like it but yeah I think I‚Äôll do this so that it‚Äôs not jarring for new users :)
Part Four is out: [https://medium.com/@baweaver/reducing-enumerable-part-four-violet-master-of-find-436864d1712f](https://medium.com/@baweaver/reducing-enumerable-part-four-violet-master-of-find-436864d1712f)
Have you ever looked at the MRI source code?
delete
I'll try to answer briefly, but stack is the context of your program, every time that the function calls itself it has to re initialize all those variables. Since each layer of the stack depends on another layer below itself, the memory will be freed inky when the last one returns (then the second to last will return and so on and so forth). So that means more memory and more overhead for your program. 
Delete all unneeded comments at first, it will be much easier for you to find that error yourself
I am hoping one day Crystal will its place.
Like they said, delete all the comments. You have a trailing uncommented end at the bottom. Each line you want to comment needs a # sign in front of it to prevent it from running on app load. 
Since EventMachine provided its own implementation of non-blocking I/O, you couldn't for example do this: require "http" require "async" require "async/io/tcp_socket" require "async/io/ssl_socket" options = { socket_class: Async::IO::TCPSocket, ssl_socket_class: Async::IO::SSLSocket, } Async.run do |task| task.async do http = HTTP::Client.new(options) http.get("https://httpbin.org/delay/5").to_s end task.async do http = HTTP::Client.new(options) http.get("https://httpbin.org/delay/5").to_s end end # finishes in 5 seconds You could theoretically do this with all gems that allow you to inject the socket class. That's a big improvement over EventMachine right there. Yeah, that still won't work for gems that use native extensions for I/O. For [some](https://github.com/socketry/async-postgres) you can create wrappers, like for the EventMachine ecosystem. But while EventMachine required you to make big changes to your code, `falcon` doesn't require any changes, so you should be able to get the extra benefits from I/O that can be "async'd", and for ones you can't you just get the same performance as with regular web servers. Assuming your code will still work correctly wrapped in Fibers, then it seems to me that you can only win.
&gt; not a ruby fan boy. those I see have voted you down It's not about being a blind fanboy. It's about the comment being totally non constructive. There is plenty of Ruby criticisms that are upvoted on this subreddit, see matheusmoreira's response for instance.
&gt; Async actually has completely transparent support for net-http. Are you talking about `net-http` the library? Because that's what I meant, and I haven't seen any way of making it work transparently under async. &gt; If you take the time to truly use async I think you will get a handle on why it‚Äôs a significant improvement. As already mentioned to /r/janko-m , I don't see the big difference from celluloid-io's way of abstracting evented IO, besides removing all of the other stuff that made celluloid such a big mess to work with. But the core of it seems to be similar. Am I wrong? &gt; Fibers being bound to a thread is actually the biggest advantage for user code... I beg to differ. Switching coroutines across threads in a pool seems like a no-brainer to me, and the way context-switching works in the go M:N green thread model. But I guess we're just gonna have to agree to disagree. &gt; JRuby is getting native fibers... I've heard about coroutines in the JVM for years. I'll believe it when I see it :) &gt; I can see how you might consider fibers to be low level but so are threads and processes. I agree. And having those abstractions there is already an issue. matz already mentioned a couple of years ago, that his big regret in implementing ruby was allowing the `Thread` class. I don't know his reasons, but it seems to me that exposing the thread abstraction led to the GVL, and holds back the adoption of any other concurrency abstraction (even guilds) because they can't break `Thread` code. Compare this with go, a not-so-high-level language as ruby, which creates concurrency abstractions such as goroutines/channels, which don't map 1:1 to OS/system-level abstractions. But those are just my 2 cents. 
&gt; It's not a big improvement over celluloid-io, though. In fact, the whole "inject this socket class" idea probably comes from there. Oh, I've never actually used or read about `Celluloid::IO`, didn't know it provides the same socket wrappers. I'm wondering what was wrong with those, and what makes the `Async::IO` wrappers better. /u/ioquatix? &gt; Exactly, and then you're gonna have to convince projects to migrate to async-* wrappers, like in the em-* days. I'd say that complaints about eventmachine weren't the only reason that failed. Yeah, I definitely agree on this. But I feel like with EventMachine there was more emphasis that using blocking code is dangerous, because it will block your one and only event loop. With `falcon` you can still easily spawn worker threads/processes, so blocking IO is not any more dangerous than it is in regular web server setup. The `eventmachine` ecosystem hardly mentions how to spawn multiple event loops, I only found `einhorn` recommended deep in the Goliath wiki. &gt; I had the hardest time (and ugliest monkey-patches) making net-ssh work under the celluloid-io event loop, just to name you an example I know of. Ah, that sounds painful :(. I understand your disappointment with this approach. Yeah, using `async` only makes sense for me if my dependencies will still continue to work the same even if I don't make them `async`-aware.
Just start dropping code until you dont have an error anymore 
ah ok, ty
blame spring; it probably cached some incomplete file. start rails with DISABLE_SPRING or pull it out of your gemfile
is the c part of c and ruby part?
This depends on local Rack adapter and may cause server to hang. 
I believe one of the biggest reasons for the GVL is actually native C extension code, and you'd need the GVL (or an alternate concurrency safety approach) even without ruby-exposed threads, if native C extension code can possibly use threads. If nothing uses threads, then of course you don't need the GVL.... cause there are no threads. :) I don't think ruby without any threads would have been super succesful, even if you don't use threads yourself, if you're writing a web app your app server almost certainly uses threads and/or fibers, and would have trouble doing it's job without them. Certainly ruby with no threads at all is no _better_ for concurrency than the GVL. :) I guess the alternative is really a different higher-level concurrency abstraction of course, rather than just none. That could be good. I think to some extent the proper concurrency abstractions/semantics is still an unanswered question, with still a diversity of implementations on different langauges/platforms. (Although of course you can find partisans insisting that theirs is obviously the best). Everything from node.js (insisting on single-threaded evented as fundamental to the platform), to erlang. Recall that ruby originally had only "green" threads (not true OS threads), and it was considered a huge advance when it supported "real" threads. Of course, a platform insisting on/limiting to _any_ particular approach will ensure the ecosystem grows consistently around that particular approach. Ruby has not done that. But it was very different times when ruby was created. If you insist/limit to a particular approach, and it ends up _not_ suited for some particular domain of problems, it does not help language adoption. Ruby for better or worse has always been intended as a general-purpose language, and with it's Perl inspiration roots, to "there's more than one way to do it". 
Yeah it IS about being a fan boy and you just proved it. Only criticism that you approved of are not to be downvoted. matheusmoreira's post offers as much solutions as [PIAJohnM](https://www.reddit.com/user/PIAJohnM) \- in fact less because it ends with " I'm not sure if a better system can be retrofitted into the language at this point " What more constructive are you going to get out of that?
This is awesome. Thanks!
&gt; Exactly, and then you're gonna have to convince projects to migrate to async-* wrappers I don't think anyone has to convince anyone. That's not my style. This article I wrote is actually a little bit more opinionated than I would normally prefer too. I think it's as simple as projects providing a way to inject sockets. It doesn't (and I don't think it's a good idea) for it to be async specific. An example of that is `http-protocol` gem which is concurrency agnostic. `async-http` is built on top and it is certainly not concurrency agnostic because it supports connection pooling and multiplexing which require _some_ model of concurrency. But for many projects, I think you can be concurrency agnostic and that's a good thing. &gt; "inject socket class" API idea. It's one approach. `http-protocol` assumes a default interface for I/O which you can make sub-class to change the I/O behaviour. I'm not sure it's the right solution either but it works pretty well. If I/O had a uniform interface, whether it blocks because you are running on a thread or a fiber should be a non-issue. It sounds like you have a lot of good ideas so I welcome you to contribute to `async` and perhaps tools like `net-ssh` need PRs so they can accept foreign sockets.
I don't know why do we need this feature at all. Most of new Ruby features are just unobvious mess. Matz is going crazy?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [Introducing Yabeda: Modular framework for instrumenting Ruby applications ‚Ä¢ r\/ruby](https://www.reddit.com/r/RubyLang/comments/9yat46/introducing_yabeda_modular_framework_for/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Rails _does_ use strings instead of symbols internally for precisely this reason. :-)
Thanks for your work! I've been reading into serverless solutions and have been planning on reading more about FaaStRuby
 def non_zero_rand(range) begin n = rand(range) end until n != 0 n end non_zero_rand -7..7 #=&gt; &lt;a non-zero random number&gt; 
What kind of action and integration are we seeing with this and Opal?
*Seriously* awesome. This is just what I was looking for 6 months ago. I'm going to give a lot of thought to how to start integrating this into our (Hanami) app.
Neat, started by making a random string generator: https://api.tor1.faastruby.io/admin/random Then made a login page: https://api.tor1.faastruby.io/admin/login Then I made a bitcoin miner: https://api.tor1.faastruby.io/admin/miner (just kidding I didn't but you should definitely make sure the API can't be abused because it can be abused pretty quickly in its current state). 
I love this. The fibers solution is spectacular and the async wrappers might be just what I've been looking for. I'm on a large Rails project that needs to make async calls to services over https. I don't want to have to restructure the app or make it thread-safe, since it's huge. (Even in smaller apps I don't like using threads because bugs are so hard to reproduce and fix.) The main difficulty is we have our own internal HTTP client wrapper that implements a lot of behavior that's useful for service calls, such as configurable retries and circuit-breaking. But it uses an adapter pattern so it might just be a matter of adding an adapter for Async::HTTP. As a minor aside, I agree with the comments that it would be nice if the code used 2 spaces with soft tabs, not hard tabs configured to look like 2 spaces. The Ruby community has settled on this convention for a long time. But honestly this looks so useful to me that I'd probably use it even if it uses 11 spaces with a few tabs thrown in.
hacked [https://pastebin.com/AF2UmJsC](https://pastebin.com/AF2UmJsC)
what about just ``` def non_zero_rand(range) n = rand(range) until n != 0 n end ``` ? Is there a difference I'm missing?
Good occasion to test serveless! Thank you!
Better. Even clearer if you use while n.zero? 
Hanami is awesome! I've been looking for integrations as well. I've been talking to the HyperStack guys, and would love to have a chat with you as well. PM me anytime.
Let me know if you can help with anything! I am always at the chat at [https://gitter.im/FaaStRuby/Lobby](https://gitter.im/FaaStRuby/Lobby)
Elegant example.
I use 2 spaces for indent myself. Tabsters are underpaid wimps - but in fairness, the tab did not distract me. My first thought was whether I would write or use code like that. I am undecided about this as of yet ... so I never reached the tab versus space situation in the first place there. :P
While this may not be visually pleasing, to be honest, I don't think he would lose any potential user or contributor because of THAT. That would be excessive. How many people do you know WITH NAMES in reallife who are like that? I know none. Actually, you seem to be the first to nitpick anyway... :P
While I agree with 2 spaces as indent, I happily point out that there is no ruby style guide. What you probably refer to is the specification in use by rubocop.
The awkward thing is that even the C part of ruby may have files that are tab-indent only, 2 space indent only, and some that mix both. There was a funny PR issue by ... shyouhei I think, so based on this in the long run we will probably see consistency here either way rather than wild reign of chaos.
I would not put too much thought into this. Why not? Because I think it is like one of those projects that will be abandoned quickly. Which is a common situation for many projects hosted on MS GitHub these days.
Come on dude ... "It could have potential " That's like ... from 100 cool ideas, only one makes it big. That project is one of the 99 that don't.
Yes, people invest a lot of time into useless projects. 
Thanks! I will try to use FaaStRuby in my next project :)
&gt; Actually, you seem to be the first to nitpick anyway... :P If you actually read my post and clicked the link, you would discover this is not the case.
Pedantry. There is a ruby style guide. It may not be "official" but it is maintained by a credible high-profile organization (rubocop), is well-accepted, and is the de-facto standard.
Does that mean you use a lot of ["integration tests"](https://guides.rubyonrails.org/testing.html#integration-testing)? It does seem like that they've made "request" tests a lot closer to "integration" tests, it's not entirely clear to me why have both at that point. (I do still sometimes want to unit-test my controllers... but Rails seems uninterested in me doing that). 
Omg! I‚Äôve been trying to do this for a while! I‚Äôll have to try it out - thanks!
Thanks for putting this together! Imma tweet this now. Happy to have my local meetup in Boulder on the list!
It appears the RSpec core team advise you quoted: &gt; For new Rails apps: we don‚Äôt recommend adding the rails-controller-testing gem to your application. The official recommendation of the Rails team and the RSpec core team is to write request specs instead. ... is out of date already. The [example request specs](https://relishapp.com/rspec/rspec-rails/v/3-8/docs/request-specs/request-spec) given in the RSpec documentation will not work with Rails 5+ without the rails-controller-testing gem, although this is not mentioned in the docs. The only place I see it mentioned is in the [Upgrade Note](https://github.com/rspec/rspec-rails#upgrade-note) of the readme.md in the source (and even there, it implies rails-controller-testing is required only for controller specs. I don't consider it fair to expect users of a fresh install to read the upgrade section and so they would probably miss this. Admittedly, if you run the example tests without rails-controller-testing a helpful error message will prompt you to add it to your Gemfile but, in my opinion, the dependency should be made clear in the documents. It would appear that both Rails and RSpec are advocating moving away from a three floored testing pyramid and dropping integration tests completely, leaving just the ground-floor unit testing and top-floor feature testing. 
Doesn't look like you can use a connection string with postgres. You can use URI query params or pass those arguments as a hash http://sequel.jeremyevans.net/rdoc/files/doc/opening_databases_rdoc.html#label-Using+the+specialized+adapter+method
Hey, we have a PDF that we have to parse regularly where the actual data that we need is the *background color* of each table entry. Is there a way to accomplish this with your library? Thanks. https://i.imgur.com/pq3OZUD.jpg
Hm that sucks a bit :/ I get it from environment and wanted to avoid having to parse it.. I wonder how hard monkeypatching the support for this would be
something like `$ faastruby --region sfo2 --rails create-workspace my-workspace` honestly I don't know many professional ruby devs that AREN'T rails devs, so you might consider using more rails best-practices inside the params/response/renderer Similar its incredibly common for people to throw raw events into a job/queue processor so they can easily see activity anomalies and retry errors and such. 
&gt; Although I am not entire sure if Unicorn / Puma were ever the bottleneck though. But one thing Argoo do seems to be a lot better is memory usage. I think memory use and heap fragmentation concerns are should be given more weight when testing and selecting a server. I was happy to notice your comment.
Biggest thing that stands out to me is that your get method is calling `puts` which returns nil, you definitely want to be returning that response array. If you need to debug, use `p` (which returns its argument) or use an intermediate variable. 
Don't use `puts` for `#get`; just return the data. ```ruby def get(path) ['200', {}, ["hello from get #{path}"]] end ```
I think this mindset, much moreso than indentation, is the problem I have with async family of gems. It's going to make adoption of these gemsnare hard sell to engineering teams. If you only plan on having yourself use it, why bother open sourcing it out of curiosity?
I find tabs significantly better. I refuse to do things just because it‚Äôs dictated to me. Indentation doesn‚Äôt affect the functionality of the code in any way. Some forms of indentation definitely make code harder to work with. See MRI for an example of that. If you tell me there is a technical problem because of indentation I will find it hard to take you seriously and I feel like you are taking my time away from more important issues. There should be nothing wrong with a diversity of opinion about the best programming practices and this works for the betterment of all. Plenty of people are using async and while it‚Äôs definitely a challenge to the status quo, that‚Äôs actually a good thing IMHO. Diversity is a good thing, and I actually believe it‚Äôs better for accessibility too. For example, a blind programmer once told me tabs are far easier to navigate. So you know, I can‚Äôt please everyone, but at least I can be internally consistent.
That‚Äôs actually not what I said.
Just remove the puts 
Thanks a lot for the detailed insight, it's really interesting.
How would it handle duplicate fields in the header?
Just be sure that you clean up after yourself, native extensions can't be garbage collected, maybe Rust helps the developer out more here than C?
It does. Rust effectively has automatic memory management, without a garbage collector or reference counting. It does that through a system called ‚Äúownership‚Äù. I would encourage to check it out. It‚Äôs a great language, and it is quickly becoming my preferred language for new projects. 
Anything that can masquerade as C you can use I guess. 
&gt; The applications written in Ruby will demonstrate the ability to handle a high load, which is particularly useful for the fintech industry ‚Äì the interruption of work may result in a serious loss of money for the app users. Does he really advertise Ruby as "performant"/"scalable"?
He advertises one particular, mostly Ruby, outsourcing company, nothing more :)
I don't think so. If this PDF is produced the same way every time, I would suggest to parse it with some instruction parser (I prefer PDF::Reader) and to look at how the bgcolor is described.
Why would you need this instead of active record?
Because you might be consuming a GraphQL endpoint? :)
Hmmm, I'm glad to see alternative graphql clients besides githubs quite poorly documented one, but at least the way wee use graphql, this library encourages some pretty bad antipatterns. Static queries are good, they allow you to do things like static analysis, query whitelisting, and persisted queries, none of which are possible if you're query strings are not stable. In addition, some of the reasons that one might want this DSL as pitched in this blog post as already built into the language: - unlike SQL, gql is already composable thanks to fragments. So there's really no argument here - with skip and include directives, minor adjustments to queries can be made statically in a way that is still analysable etc Overall I don't understand who this is for. You're throwing away a lot of great tooling and inventing a novel DSL with little discernible benefit, and many drawbacks.
100% agree. This is cute, but a huge step backwards.
Expedia put out a Kotlin version which is actually pretty good. https://github.com/ExpediaDotCom/graphql-kotlin
Do which one sounds more appealing to you! Both of them will provide a solid foundation for applying to full time jobs afterwards.
Both of them are equally appealing to me! Which one do you think has a slightly more edge over the other? 
Depends. "Edge" would be a personal thing. Some things to ask yourself in order of importance: * What's the mentoring system like? Will I have regular sit downs with my mentor? * How much did I like the engineers/other people I met at the company? * Which product sounds more interesting to work on? * If this internship turns into an enticing full time offer, which company would I prefer more?
Spot on. Which has me thinking, maybe I can shore up Githubs docs this weekend.
Thank you very much for the list! I have been to just the second startup till now as it's in my city itself. The second startup claims that the founders are ex-googlers (never found a proof like that on LinkedIn or any such website). The people are extremely friendly though. They are trying to increase the workforce from 10 members to 50 members by the end of this year (and all of them just by 6 months interns!). My senior has done a 6 months of internship there before and her experience was good. Their product keeps on changing as it depends upon the clients. I have never seen a full time offer opening by this startup and they've never talked about a PPO opportunity. The first startup has 4 founders, all from IIT-Delhi (top college of my country) and there are proofs for the same on LinkedIn and IITs website. The product which they're working on is for freight negotiation. They are also promising a PPO of $6000-$13k if I do exceptional work.
The first startup sounds a lot less shady, so I'd go for that one. 
it's all the same shit. either you can write good code or you can't. choose based on the people and how much you like them. also $285 is per day, right?
monkeypatching the support would consist of exactly what you'd have to do to parse it, plus monkey-patching. :)
Thanks for your insights! Can you be more elaborate why do you think so?
Wow! Thanks for your insights! And btw, I have developed many college projects in PHP &amp; vanilla javascript, and they are quite easy. I'm surprised to know that Ruby and RoR are more pleasurous to learn! 
How the tool works and how easy it is for the tool to generate strings is irrelevant to me. There's two options: learn GraphQL, or learn GraphQL and learn this DSL on top of it. Now with the SQL equivalent (SQL vs ActiveRecord DSL) we learn both because AR provides a lot of value, primarily allowing composition without string slamming that eventually devolves into a shitty untested implementation of an ORM :P. But here, there is no value added. You're just learning a DSL for the sake of not having strings in your Ruby code. &amp;#x200B; Keeping the syntax identical to GraphQL has value. Just look at \[the graphql extension for VS Code\]([https://marketplace.visualstudio.com/items?itemName=kumar-harsh.graphql-for-vscode](https://marketplace.visualstudio.com/items?itemName=kumar-harsh.graphql-for-vscode)). You get syntax highlighting and fragment autocomplete / validation all in your Ruby code, exactly because you \*didn't\* needlessly use a DSL, but instead opted to use the same query language literally every other language uses. &amp;#x200B; &amp;#x200B;
I used it in the past, but it was slow I moved from Tracepoint to running standard lib Coverage and using the peek results feature, which wasn't available when I first created Coverband.
You‚Äôre trying to use double quotes inside double quotes. 
/u/Jodonavan can you elaborate on how you would fix this?
Just replace the inner double quotes with single quotes. get "/data/foo/#{res['oid']}" If you're not using string interpolation you should use single quotes.
Looks promising. Could you help me find the pricing page or something please?
Welcome to the programming club! Here's how to get help on the internet (assuming your course allows it!): Take a shot at the problem. Google the error messages. Look around and understand what's not working *first*. Then, try to get the problem down to the smallest possible sample program, ideally a few lines that don't work how you'd expect them to. At that point, you're ready to get help. You can post here, or at Stack Overflow, or other similar forums. Post what you're trying to do, the code you're using, and what you're getting as output. Try to be really clear. At that point, if you've done your work, rando's like me from all over the internet will converge and offer advice and pointers. :-) But we need to know what the problem is, and you need to have taken a shot at solving the problem first. Otherwise, no cookie. Or code. Or whatever.
Chug a red bull and take a little break from the problem, a solution may come to you. Or you can describe the problem, lol ;)
Don‚Äôt focus on leaning a language. Come up with a small project idea you are personally invested in and can implement in three weeks. Then focus on learning whatever tools you need to get that done.
Start with thinking about what options will be most useful for your career. Then, narrow the list by what seems like interesting stuff to spend your free time on. 
Forget about the technology stack for a minute. The first opportunity sounds like you will be working on a product. The second sounds like you will be working on creating client websites. I suspect this will just be billable client work which, worst case, could turn out to be rote work, potentially constrained to a very narrow set of tasks. Are they cookie cutter sites, or are the clients coming to you for something innovative? Then, forget about what I just said and ask yourself which group seemed like they would be more enjoyable to work with? Who seems like they are more likely to mentor you vs. just getting some work done? Go with those guys.
thanks for the kind comment, earlier today i released a new version that includes improvements and a bug fix. i hope it is useful 
If you're going to be in this field (IT, development, etc) you need to learn how ask good questions. A problem report needs to contain: what exactly you tried, the exact error message, what you expected to happen, what actually happened, what you have already tried, and steps to reproduce.
Fun to see how things are translated. `... TypeFragment` to `___ TypeFragment` is nice. But, overall, if one's going to learn a DSL to learn a DSL then the former DSL should offer more than nuanced differences in syntax. Not sure if being in Ruby is enough...
lots of people mentioned it, google, ask on your student channels or a classmate like if you have slack or something there. of course, if you want to ask here, post your code (google formatting in reddit if you want to do code, you basically need to indent 4 spaces is what I do), and post what you did and which part you are stuck on. best wishes! also which boot camp are you in, if you don't mind being asked?
Walk through your code line by line, make sure you really understand what all of it is doing. Double check your variables, make sure you don't have a 5 in place of an S or something dumb like that. Make sure everything is closed the way it should be, def has an end, if has and end, etc. Google the error messages, read the error output also, sometimes it's helpful. Last but not least you can post your code here. Helpful internet tools to learn ruby, Learn Ruby the Hard Way, hackerrank, code academy, and I'm sure there are others, but I've had good experiences with these.
Will think about it! Thanks!
No shame in asking questions whatsoever. BUT I'd like to let you know you should very rarely need to resort to actually posting online. In programming there's almost always someome who's had your problem before, or a similar enough one. That person posted on the internet and got an answer. Now all you need to do is find that post. Ive said before that if somewhere were good enough at googling things they could do my job without knowing how to program. It's obviously an exaggeration but not as much as you might think. When you're looking for the answer to something programming related you should almost always include the name of the language in your search. And then you can usually copy and paste the first few words of the error message your getting into your search. I was just writing some ruby the other day after not touching the language for awhile and I was having some trouble. I was getting nil somewhere I didn't expect it. What helped me was to look at the documentation for the specific methods I was using to see what they return and in what cases they return those values. 
`require 'pry'` `nasa_data = [` `"Direct Marketing News" =&gt; {` `"computed_region_cbhk_fwbd" =&gt; 46,` `"computed_region_nnqa_25f4" =&gt; 2095,` `"country" =&gt; "USA",` `"domain" =&gt; "com",` `"email_hosts" =&gt; "`[`dmnews.com`](https://dmnews.com)`",` `"location_1" =&gt;` `]` &amp;#x200B; `# 1. Create a method called company_name that takes in two arguments, an array and a company name.The method must return the entire hash for the given company.` `# Your code here` `def company_name(nasa_data, string)` `nasa_data.each do | item |` `if item.key == string` `puts item[string]` `end` `end` `end` &amp;#x200B; &amp;#x200B; &amp;#x200B; `company_name(nasa_data, "Garmin International")` under '# Your code here' is what i have so far, below is the error code i get when i run it in iTerm ‚ûú nasa-data ruby code.rb code.rb:187:in \`key': wrong number of arguments (given 0, expected 1) (ArgumentError) from code.rb:187:in \`block in company\_name' from code.rb:186:in \`each' from code.rb:186:in \`company\_name' from code.rb:192:in \`&lt;main&gt;' ‚ûú nasa-data &amp;#x200B;
[Closed], [offtopic], [duplicate] We can create the SO experience right here!
Nah you just type the error message word for word and hope that somebody has a similar question then copy/paste the most upvoted answer and change your method names accordingly without bothering to read the explanation and thus learning nothing. THAT's how you do it! 
Hey, i posted the code below, this challenge is a systems check so unfortunately I'm not allowed to ask my classmates which is why i turned to reddit since i couldnt find it anywhere online, I am currently at Launch Academy in Boston MA
Have a look at the docs for [Hash](https://ruby-doc.org/core-2.5.1/Hash.html#method-i-key) specifically the `key` method. Happy to answer questions
ok, you should cut/paste your response at the bottom of the post and edit it into your original post, cause people might be missing / not scrolling the actual problem. cool. not sure I can help, i'm still learning, but taking a looksee
in addition to what /u/three18ti said, did they give you an example/s of what the return should look like? "The method must return the entire hash for the given company." company_name(nasa_data, "Garmin International") so was there a hash you were given in the problem that contained the data for that company Garmin? They should always give you example/s of return output so you know what exactly they are looking for, unless its an interview type setup. In any case, if its a straight bare-bone hash, i guess that's simple enough.
yeah so that would be where that array 'nasa_data' is, everything that inside "Garmin International" is what they want returned, i just cant seem to figure out how to get it, theres way more to the code but this is just for the first question
don't worry, i've been there. you are in a good place though, chances are you can get a lead.
oh well first off it doesn't even seem there is a closing `}` for the hash, unless I'm mistaken or you simply didn't past the given data correctly: nasa_data = [ "Direct Marketing News" =&gt; { "computed_region_cbhk_fwbd" =&gt; 46, "computed_region_nnqa_25f4" =&gt; 2095, "country" =&gt; "USA", "domain" =&gt; "com", "email_hosts" =&gt; "dmnews.com", "location_1" =&gt; ] i'm relatively newer but have been solving lots of problems, so i guess for me i'd need to be sure i have the correct data and syntax. if i'm not helpful, pardon, i was trying to play around and noticed the above. maybe I can simplify it and just make my own data: nasa_data = [ "Direct Marketing News" =&gt; { "computed_region_cbhk_fwbd" =&gt; 46, "computed_region_nnqa_25f4" =&gt; 2095, "country" =&gt; "USA" } ]
im so sorry, i deleted the wrong portion of the code -\_-
yeah edit it all nicely into the original post, and that may help you get better/correct help too.
alright now it should be all set, put the wrong hash in
do you use irb at all? have a mac? if so just type 'irb' in terminal and then you can play with your code. the brackets don't match so i don't get a return form irb for a complete data set. a complete hash in an array would give me the `=&gt;` and the array with hash inside: irb(main):001:0&gt; nasa_data = [ irb(main):002:1* "Direct Marketing News" =&gt; { irb(main):003:2* "computed_region_cbhk_fwbd" =&gt; 46, irb(main):004:2* "computed_region_nnqa_25f4" =&gt; 2095, irb(main):005:2* "country" =&gt; "USA" irb(main):006:2&gt; } irb(main):007:1&gt; ] =&gt; [{"Direct Marketing News"=&gt;{"computed_region_cbhk_fwbd"=&gt;46, "computed_region_nnqa_25f4"=&gt;2095, "country"=&gt;"USA"}}] look and don't sweat any of this. if you are brand new, you basically haven't had time to progress and grow yet. also while you prep, try this out: https://launchschool.com/books/ruby and they have other useful start/foundational books but only thing you really need is this and perhaps command line will be useful at this point, github also: https://launchschool.com/books oh and if you have the time, Launch School is really fantastic if the situation suites.
i recommend this method: https://medium.com/launch-school/solving-coding-problems-with-pedac-29141331f93f tldr, figure out your Inputs, Outputs (what data types are these) Examples, Algorithm(how do you thing you can map out solving the problem), then you can Code. 
but do you have a mac? I've used pry too, its good for testing for me and seeing where mistakes in code are. haven't used it in an irb fashion but perhaps others do. as long as you have something you use to test out simple things like that.
cool yeah pry looks like it should work fine, i just tried it some. i've only really used it for testing and did code play in irb, and well, also on repl.it using Ruby (i love it for testing out code too), you can basically run your programs there and see if they work instead of on command like.
ive actually tried using that, my code was already in there, but yeah, still no luck with irb, cant figure it
&gt;My communication with the clients became robot-like, where the robot is limited to just four verbs Without a doubt, this is one of the most subtle problems to creep into a project over time. Developers will naturally begin casting all of their ideas into CRUD, partially because Rails makes it feel just a little bit "icky" to stray too far from the CRUD path. When CRUD language ceases to be the natural description for a scenario, sticking to that dialect tends to warp the understanding of the concepts that are being worked on. Over time those concepts will continue to warp in the codebase, and what should be intuitive to a newcomer becomes that embarrassing (and confusing!) piece of the project that no one wants to explain or touch. Mental gymnastics needs to be performed to understand the concept as it is written in the text of the program, but describing it in plain language is disturbingly straightforward. And then, inevitably, the whole project turns out the same way. Of course, that can't all be blamed on CRUD addiction, and large monotholic RoR apps have more problems than an overreliance on CRUD. But it seems like mature, monolithic RoR apps tend to have a lot of the same problems, and "communication" based issues like this are prevalent. 
The person who is capable in creating tech documentation is an engineer. The best person for this task is an engineer who worked m specific part that is needed to be documented. There is no sense to hire someone who will do that. He will ask the responsible engineer and it will result in time waste for both
The reason I specified that the person who would be the "doc person" is a programmer themselves is because I'm assuming they could do a lot of the documentation themselves without having to contact the engineer. I am assuming though that the engineer has written that "self-documenting code" that's considered best practice. Even so, if the doc developer contacts the engineer, she's not wasting her own time, because it's her job to document. And if she gets the relevant details from the engineer in a quick and concise manner, she's wasting less time for the engineer overall. I'm not disagreeing with you (even though it sounds like I am), I'm just explaining how I see the situation from the outside, and asking for clarification.
I see. Well, we have tried similar approach and it ended up with the same issue with constantly changing environment. Such person can‚Äôt catch up, i.e. she is always behind and front-end engineers can‚Äôt wait 
This is another problem that is bravely solved by single-page app developers that is absent from other architectures. If you have to do this then I think it'd be better to automatically build a JavaScript client based on backend metadata.
I am not sure what I am looking at. Big half-screen header says "A Comprehensive Guideline to Design Clean and Organized Code in Rails". Under it, another header of almost the same size but different design says "How to get clean and maintainable code in Rails with Service Objects?" Under it, there are several small paragraphs, basically saying "To get clean architecture, you should use service objects". Is it the whole "comprehensive guide"? Or maybe one chapter of it?.. (If it is so, maybe it makes sense to state it in a more clear way.)
Amazing resource, thank you! 
currently I'm not quite happy with my career. Web is not such a nice field, doing CRUD, and react, vuejs does not make me happy :)
you are welcome, thanks for the feedback :)
this is where google - and youtube - are your friend, if you hadn't yet, and it's not a big deal, looks like you can use pry just fine too. but if interested in irb, here is a video, its pretty intuitive: https://www.youtube.com/watch?v=rJ5jPEg5G8w if you have really really basic questions don't be afraid to ask either, /r/learnprogramming is again a good place for stuff like that too. but here people are willing to help.
I will get a tutorial and video out shortly. And will post it here!
I previously used New Relic and was never a huge fan. Too "enterprisey" for my taste. I much prefer [Scout](https://scoutapp.com) for Ruby apps. It has a better UI and is focused solely on Ruby/Rails, so their transaction traces and debug tools are actually useful. I use [Raygun](https://raygun.com/) for error reporting.
I‚Äôve seen two companies drop new relic in favor of datadog and sentry.
Awesome gem. I use this all the time. 
&gt; To those wiping coffee off their screens after reading the OP: yes, we were all this new once. This is a healthy attitude. I wish it were more common!
as a full-stack developer (rails), i tried to re-implement some back-side projects in react for last three years, but that only left me burnt out. but Elm, even though it took a second round, is currently making me a lot happy. i can only second what others told you, but if that hasn't satisfied you, let me suggest this nice, not-so-new but not that mature yet, pure functional language.
It's good to know that you can be comprehensive in just one page. Please ...
Thank you! This is really helpful! 
Question: do you still do server monitoring? We're not (yet) to containers, so we run on VM's. It's nice to also have the overall picture of ram/cpu/etc
&gt;datadog Great, thanks!
We're using insights to see overall traffic, infrastructure to monitor the VM's, and then application tracing to review performance, dig into errors, see database vs app server issues, etc. Overall it's been very useful but there may be better Ruby specific options (we previously had an [ASP.net](https://ASP.net) system as well - which started us into new relic ages ago)
I would second DataDog as an excellent and constantly improving product. Having APM, logging, and metrics in one place is great.
&gt; However the pricing is getting to be really, really high for the amount of use we get out of it Yes. It has gotten too expensive. Datadog is more reasonably priced.
Not only awesome, but also full feature and up to date üôÇ
Thanks mate!
This isn't a bad idea. It won't help us with metrics, but may give us enough to get a general idea of what's going on.
I have lately been intentionally moving away from CRUD in my Rails actions, having come to similar conclusions. It _does_ make it more of a pain to do routing, you don't get all that Rails magic routing, including the "just works" polymorphic routing. I think it's worth it. I actually like Rails quite a bit (can tell you plenty of things I don't like about it too). I've been using Rails since 2.0. Before the "resourceful routing" stuff. I was suspicious of the resourceful routing from the start, but I went with it, as the Rails easy path, and as what all the projects I was working on (including collaborative open source) were doing. But I've coming back around to my original suspicions, and tried to retrain my brain to build the controller actions and URLs that actually make sense for the app, and deal with the added explicit work for routing and route path. I think it's worth it over all. (It's probably no coincidence that "REST" is held in somewhat more suspicion in web dev in general these days). 
+1 for Sentry. I met the owner back at Railsconf a couple years ago, and since I haven't seen a better error reporting platform. They even offer a free self-hosted option of their main service, ala Gitlab vs Gitlab.com.
We see this exact `puts` confusion very often here on /r/ruby. I wonder if it's because ruby tutorials so often start with "hello world" type examples, where it's convenient to get the learner doing something by printing to the screen. I think maybe all ruby tutorials forever should take on the obligation of having a section near the beginning illustrating the difference between a method return value and `puts`ing to the console, making it clear when _not_ to use puts. 
&gt; I've been using Rails since 2.0. Before the "resourceful routing" stuff. I was suspicious of the resourceful routing from the start, but I went with it, as the Rails easy path, and as what all the projects I was working on (including collaborative open source) were doing. The problem suggested by the article, which I agree with, is that developers who spend most of their time exclusively doing web development often have a hard time evicting CRUD from their mind when they step away from web development. The web, after all, is just a data transport mechanism. It's "domain language" _is_ comprised of concepts like CRUD, REST, etc. Steering web endpoints away from the web's natural context seems like it leads to things like SOAP. All of that to say, I don't think that either CRUD or Rails (the framework, not community/best practices/etc.) are actually a cause of this problem. Rather, I think that cramming all of our software development into CRUD-ish web frameworks has had this unfortunate byproduct of turning CRUD into a more general _lingua franca_ of software development. For instance, most of the time these days when I have an opportunity to work with a younger product manager, they've already adopted CRUD terminology to reason about and describe the use cases that they're designing around. This wasn't natural for them, but it was probably the path of least resistance when collaborating with web developers! &gt; CQRS/Event Sourcing still looks like over-engineered confusingness to me though. :) In the wild, I've actually seen it turn out as an _under_-engineered pile of confusingness more often. Like anything, with a combination of helpful abstractions in place and our own increase of skill that comes from practice, the cognitive load diminishes. And when executed well, it absolutely can displace CRUD and restore the language of the _business_ in our software.
I'll give a +1 for scout. My team's monitoring needs are fairly minimal and cost was too much for new relic. We use it in coordination with pingdom for uptime monitoring. We have no complaints so far and can get the information we need. I also looked at skylight when making the decision and I liked their interface and the company seemed solid so, I'd say they're worth checking out. 
My co-workers wanted me to share my experience in using Mat Views in our application, so I decided to just do a blog post so if anyone else out there is curious what they are and how to use with your Rails project, here it is. Hope it helps my team (and you). 
Very nice
We're in the process of dropping new relic for datadog
Instana has better pricing and all infrastructure, metrics and traces are all automatically tracked and correlated in a dynamic graph (internally in the back end) for better alerting and more. Plus when you view a trace you can track it to the exact host and process and see their exact state at that moment. Plus I built the Ruby support for Instana so you could always ping me for anything ;-) 
Really liked Datadog myself. New Relic is nice for getting detailed stack profiles. Right now we have neither though and can't say I'm hurting because of it
I've been looking into this lately as well. First, it should be noted that some great libraries already exist. Namely gosu https://github.com/gosu/gosu and minigl https://github.com/victords/minigl. These two resources could take you pretty far. The big hang up for me is cross platform support and distribution. For better or worse c# and unity/monogame seem to make that pretty streamlined. I would love to see ruby extend itself into this arena as it would be such a delight to develop in ruby. Good luck either way! 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/gameengdev] [Would I be able to make a small game engine in Ruby?](https://www.reddit.com/r/gameengdev/comments/9z9kz3/would_i_be_able_to_make_a_small_game_engine_in/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Prometheus is amazing.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [veelenga/awesome-crystal/.../**README.md#game-development** (master ‚Üí 95f09d3)](https://github.com/veelenga/awesome-crystal/blob/95f09d319dc819d346561af0f995fee933a0dbfe/README.md#game-development) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply ea7jjvx.)
Very nice explanation! Thank you for putting it together. 
Update cost of refreshing the m.view is to run the query in the first place. It was obviously not very slow in this case. But what happens if it is? Can it be refreshed in a transaction or will the whole model be unavailable during refresh?
Materialized view is good for something that is refreshed like once a day or even less if you have something like we had which was every 5 minutes by cron it can get into issues. First of all we had a complex materialized view and second we had more than few millions rows to go through and ofc it joined on other tables so it started pretty soon in prod to take longer than 5 minutes to rebuild/refresh. IMHO if the feature works for you it is fine, I don‚Äôt expect you to have as many songs and we had transaction entries but all I can say is that clients don‚Äôt like to learn they can see their transactions statuses update after 1-4 hours from doing them :). 
You can make it refresh concurrently if your view is setup correctly. Guy in the post doesn‚Äôt have much data to work with obviously so he didn‚Äôt yet got to the ‚ÄúI need to make this work faster‚Äù stage.
It sounds like a great project and a helluva undertaking. I've been learning ruby over the past six months and see tons of resources for the fundamental aspects of ruby. It would be great to see more resources for intermediate to advanced topics covered in a better way. Gorails.com does a pretty good job. 
Gosu is not a game engine, it‚Äôs a low level graphics rendering layer.
I create only free stuff but I know that great stuff is usually not free because the creation process takes a lot of time and senior developer's time is very valuable. Sooner or later such school will get paid options or paid access so I'm not sure if there will be someone able to provide tons of great content without getting any money or profit for this. Even in open-source oriented big companies, there is a limited time that can be consumed for creating free stuff for other less experienced developers. I think paid resources are already win-win solutions but it is just my own opinion.
Thanks! Fair points!
At some point you are going to have to use a lower-level language. I‚Äôm sure it‚Äôs technically possible. But, a *pure* Ruby graphics engine would only be interesting in that it would be so *difficult* to make performant. What I‚Äôm getting at is that, yes, to achieve your goals, your best route is to make Ruby bindings on top of an engine written in C/C++/Rust. The actual Ruby in your engine should be thin, minimal and only there for convenience. I‚Äôd recommend building on top of https://github.com/bkaradzic/bgfx You don‚Äôt need you expose all of BGFX to Ruby. Make your engine how you want it to be. But, leverage the high-performance code that‚Äôs sitting there as much as possible. 
I've been reaching to the help of materialized views from time to time. It definitely can simplify things if used correctly (not overused). The biggest burden is how to efficiently support and maintain them. In that regards, I've always used "scenic" gem (https://ruby.libhunt.com/scenic-alternatives), and I'd highly recommend it.
First time I'm hearing about this, sounds pretty impressive. Sadly it looks like it's still immature/in development, so I may have to stick with C/C++ for now if I want performance. Definitely keeping an eye on this one, though.
Aw, was hoping I would be able to use Ruby2D. Looks like I'll have to bite the bullet and use C++. Nice library though. I'll be checking that out.
I like to say it's not immature but you could already start early to gain ahead of the competition, so when Crystal is probably become popular which I can't predict, then you would have the lead and code that stabilize earlier than those started in the future.
I prefer Capybara, but Watir is a choice as well.
This looks promising! Ruby's `require`/module system really needs to be approved upon. The biggest sources of `require` related bugs are IMO the transitive nature of `require` and `require` leading to arbitrary code execution. Once we had different default locales set for `I18n` depending on the load order of files. This was a fun one to track down... However, I'm reluctant to use any external library for such a core functionality. Hopefully something similar will make it into the language (like mentioned in the Readme).
To answer to your question - I am using AppSignal and I'm quite happy with it, it acts both as performance monitoring and error reporting tool. I do miss some memory-related features I've seen in Scout and Skylight. Somewhat related question - does anyone have experience with Elastic APM?
If you go with gosu ask check out chipmunk. https://github.com/gosu/gosu/wiki/Ruby-Chipmunk-Integration It‚Äôll help with collision detection. I believe it‚Äôs written in c with ruby bindings, but I could be wrong there. 
Their new-ish logging system is really, really good. As is everything else they do.
We used [Skylight.io](https://Skylight.io) and I was pretty happy with them, they continue to be better every day. Btw for errors we used Rollbar.
VERY GOOD POINT. I'll edit and add in the Benchmarks. Thanks for that. &amp;#x200B;
I'm surprised even with complex joins that it would take over 5 minutes! We have some very complex mat views as well, and they still refresh very quickly. That said, we aren't dealing with millions of rows. 
Thanks again. I've added the Benchmark output to the blog post. (to query 'all' with both methods, it went from 7.8 to 1.7 seconds)
Sounds pretty cool. But I can't shake the feeling that the author really want to write JavaScript.
 x.report( 'xcsv:' ) { n.times do XCSV.open( "#{data_dir}/finance/MSFT.csv" ) { |csv| csv.to_a }; end } x.report( 'fastest-csv:' ) { n.times do FastestCSV.read( "#{data_dir}/finance/MSFT.csv" ); end } user system total real std: 3.426003 0.031991 3.457994 ( 3.458502) split: 0.910320 0.008102 0.918422 ( 0.918477) lenient: 3.405903 0.031962 3.437865 ( 3.438372) xcsv: 0.948309 0.020006 0.968315 ( 0.968342) fastest-csv: 0.568832 0.020016 0.588848 ( 0.588900) 1. CSV fields can contain quotes and newlines, nothing of this is covered by split. 2. FastestCSV doesn't cover newlines. 3. XCSV requires Rust and in the early stage of development (shameless plug: it's my gem).
&gt; Ruby's require/module system really needs to be approved upon I think it's fine the way it is. You're basically trading the occasional annoyance of a load order or similar bug with the constant unnecessary boiler plate of import statements, I don't think it's a good trade.
&gt; I think it's fine the way it is. I recently started to think it is not (pretty akin to OP). Two main problems are unrelatedness of files and modules, and global scope polluting. That seriously affects our APIs and general approach to code. For example, when you writing one library, and need _several_ concepts from another, you have several choices, all of them pretty nasty: * `Just::Call::It.whatever_deep(it is)` * `include Just::Call::It` into your current scope, polluting it with probably a lot of totally unrelated stuff (so, now there is `MyDataExtractor::XMLElement` after you've included Nokogiri) * some people go for constant renaming (which is not very common idiom), like `JC = Just::Call::It` * ...also, there are more exotic approaches, like `include Virtus.module`, which harms automatic documentation generation and code analysis. All of this lead to library design choices: when you think of how it would be to a user, you can't rely (how pythonystas or rustaceans do) on user's ability to do `import module as m` or `import foo, bar from module` (and have it ONLY in the local scope), and is doomed to invent some smart tricks sometimes (for example, urging users to pass `:symbol` where `library_defined_name` would be more appropriate). After working with several languages, I'd say I see the value of "boilerplate of import statements", exactly because it makes you _think_ what is available here, or what you want to make available somewhere else. That's not to add to: * `require 'foo'`, which suddenly makes module `Bar` available; * `require 'foo'`, which suddenly extends `String` (refinements tried to solve this, but people were unimpressed -- I believe partially EXACTLY because we are not used to "what included here, is available only here") * that fact, also mentioned by OP, that if you want to have some pretty simple module available both as `Mod.method(...)` and `include Mod; method(...)`, you need to go into some additional work...
I did not upvote or downvote you because I think that you mention things I can agree with and things I can not agree with. I think there is one thing you did not include in your assessment, and this is that by all of require()'s shortcomings (I am not even going into require_relative() ...) it is super-simple. This is IMO also the biggest weakness of Modulation - it is too complex. I don't think many will reason against alternatives ... but not all alternatives are equally great.
I assume you refer to python's import. But suggestions have not: a) suggested to copy/cat the python variant b) make it the "only true way". I agree that ruby needs a better way to add code though. 
There have been various efforts in the past; rubygame; there was also a game engine in ruby ... I forgot the name hmmm... godrin ... something antergos ... nope sorry, I simply forgot the name. People tend to give up after a while. :\ Happened to me too. I still use ruby for many projects but presently not really actively investing time into creating a game. I noticed that many people get carried too much away when writing ruby code though.
I think we would be nitpicking if we'd agree on that.
That was overall a very good speed-run of several scraping techniques. I particularly liked the angular and iframe examples -- those are more obscure scenarios, so this showcases far more advanced techniques than most similar tutorials. I do have two issues with the video though: 1. Admittedly this could have been purely for demo purposes, but why scrape google searches by filling in a form? You could just visit the URL: `https://www.google.co.uk/search?q=CHANGEME&amp;tbm=isch` directly. 2. A more significant issue is, why is this a rails application? The video has nothing to do with rails. It would have been much better, in my opinion, to clearly showcase this as an example of using ruby **off* rails! You could run `bundle init` instead of `rails new`, if you still want to add dependencies to a `Gemfile`.
Hmm. 3 weeks is a tough timeline. Obviously I am biased and suggest ruby since it beats the others. However had ... perhaps your use case may be a different one and you could benefit from investing the time into something else? Hard to say for others I think. To be honest, I think rather than suggesting ruby (even though I do), I think you should pick on something that either is interesting you a lot and focus on that, while having fun with it; or, alternatively or in addition to that, focus on what you may benefit from in the longer run, e. g. 2019 already. Which I think only you can decide. Perhaps you need a faster language? The list you gave is pretty wild to me. :P I think rather than going to tell you what to do, even as a suggestion, I can name a very few specific reasons why I think ruby is great: - Ease of flow on the mind. I adapt ruby to how I want to think (though of course I often have to adapt to ruby, too). I use lots of aliases and top-level methods for modules; I typically use a method called menu + regexes to interface with a specific class. That is really convenient to me since I sort of use linux + bash + kde konsole + ruby as some kind of "IDE". It is not really an IDE but I have so much ruby code that solves given tasks and I just end up combining them. For example, "extract_audio" to extract ... audio. "cut_audio" to ... cut audio. Various helpers ... "rblanks" to replace all ' ' with '_' in the current directory (I hate ' ' in filenames, mostly because they are not so convenient as _ instead). And so on. - Ruby is a LOT of fun to use. I used PHP and perl before and they never were near as much fun as Ruby. Python is acceptable to me but Ruby beats Python in various ways (as far as the language design is concerned). To improve ruby, just keep on writing ruby scripts that you may use. You may have to find an area that interests you, which will get you going. I am a noob when it comes to javascript but I needed web-scraping and did so via ruby (and some other folks who wrote code that allows web-scraping of javascript-generated sites). I once needed that for university lectures that are only displayed via javascript ... annoying. :\
I can understand that. I feel a LOT in programming is boring grunt work. There are also really awesome projects though. I avoid JavaScript since it annoys me when I have to use it.
I do scraping for a living, but for years was using an IDE for the job. A few years ago I started learning Ruby, and saw a lot of potential for building a scraping platform. Through my efforts to level up this skill for commercial products (i.e. managing hundreds of sites and collections, running frequently etc), I had a really hard time figuring out how to organize such a project in a sane way. I've always had a strong desire to leverage Ruby for what it is, without rails, but on two separate occasions, we hired some other "scraping experts" to help give some guidance. To my surprise and dismay, they both started off by recommending to use Rails to manage my project. The specific reasons were that you get started quickly, in a layout people recognize, with the following capabilities already sorted out for you: - database and models (this was the most valuable) - task execution (rake) - test organization - organized logging - env separation (again, thinking specifically about data separation, or proxy management) In both examples, there were no controllers or views. It was strictly to get a handful of features and organization for free. Arguably, all of those things can easily be sorted out without Rails (like Rake or tests for example). However, it certainly did reduce the amount of thought and planning to get a project up. And if you ever did want to make the scraping accessible from an API, well, you already did that. This all felt really wrong to me. I very badly wanted to sort out how to do this stuff without relying on Rails: I _love_ when Ruby does great things without relying on Rails. So, I didn't follow this advice and tried to string together my own versions of these projects. In the end, I tried many different ways to organize, and never felt happy. My most successful was leveraging Sequel for data, Kiba to help with some data cleaning, Sidekiq and Faktory for job management... but I'm not experienced enough at organizing a large, maintainable project at this level. I had a miserable time trying to understand how to put it all together in a great way, particularly organization, code loading, separating dev from production, logging, and stuff like that. Basically, all of the things I mentioned that Rails does for you. When I was trying to do it in the context of Rails, it came together a bit easier, but I felt wrong, knowing that it's a hacky way to accomplish my stuff. In the end, I found that Scrapy in Python is actually exactly the thing I had been trying to develop in Ruby. Often Scrapy is demod as a simple scraping tool, but it's magic is in the project organization, and project level style of thinking. It is far more powerful than the generic "loader parser" that it is always demonstrated as. So, I saw it as my responsibility to pivot over that way. All of this is to say: building in Rails gives you a full project framework to work within, and if you are doing large, commercial scraping projects, you either need a faremwork to carry you, or you really have to know you stuff. There's just too many bits and bobs you have to think about otherwise. 
I only watched the first two minutes but isn't phantom deprecated in favour of chromedriver now, as chromedriver can now evaluate js as well?
I value your opinion because I know that you know your stuff: I've seen other bits of your work. I'm curious as to why you hold this opinion? I've not worked with Capybara, but have used Watir significantly to great delight. Can you share your thoughts?
Great rundown. I've been playing around with scrapy recently and I like it. Is there a detailed video, course, or book you can recommend?
Sounds cool, but can I suggest that instead - you can contribute to an exisiting project in [The Odin Project](https://www.theodinproject.com). It's all opensource at [github](https://github.com/TheOdinProject/).
Thanks. I will check it out. 
Happy Cake Day ivanraszl! Here‚Äôs hoping you have a day that's as special and wonderful as you are.
I'm happy to read the present discussion. FWIW some of the issues raised here are also being discussed on the Ruby issue tracker: [https://bugs.ruby-lang.org/issues/14982](https://bugs.ruby-lang.org/issues/14982)
That is not the same as keyset pagination. It is just skipping the count().
I've start by re-use my ruby script that list all files by size in /Users/user/Downloads, and do the same in, scala, java, c#, kotlin. Was ok :) I feel, that other people are doing much nicer stuff than web development. When I was in my 20, I've work with c/perl for an email server. On that time I hate it, but now... I miss it :) Web, is some CRUD, DB, some js and that all :). I feel like a I'm waisting my time. Getting in touch with c ruby api, or helping the ruby community also difficult. I fell like a have to learn a lot, and everyone is better than me. I will try this week to use substratevm as: - take jruby, use the same ruby script to list files - convert to a jar - use substratevm to take that jar and make a binary Sorry for the rant! And thx for the long message, was really nice!
Both Capybara and Watir can use Selenium driver to communicate with browsers (PhantomJS, Chrome, Firefox, whatever). But for Capybara there are also other drivers which written in pure Ruby and don't use Selenium. For instance Capybara has awesome PhantomJS driver called Poltergeist (pure Ruby, doesn't use Selenium). This is great, because it's not a secret that Selenium devs don't like when their product use for scraping purposes. For example there is no API present in Selenium to set/get custom headers (although many people asked them to implement this feature). You can't set cookies unless you first visited a required domain page. You can't rotate proxies on the fly. In Firefox they messing with HTML response by adding to it special Selenium tag so it's possible for website to detect Selenium usage using JavaScript. All that missing stuff is really required in serious scraping. Using Capybara + Poltergeist you can do all the things like set/get cookies/headers at any time, rotate proxies, inject Javascript and so on. Suddenly development of PhantomJS has been stopped, but it's still a good choice (for some cases) for scraping. There is a new player called Headless Chromium, which is awesome I would say (modern render engine, fast, NO MEMORY LEAKS like PhantomJS). Currently it's possible to use it with Ruby only through Selenium (like it does Capybara and Watir), although there is pure Capybara driver for Headless Chromium in development ([https://github.com/machinio/cuprite](https://github.com/machinio/cuprite)).
Yes, sometimes people use Rails because they simply don't know the proper way how to organize project without Rails. Just like you said: database and models (and how to organize migrations, this one is really important), code loading, logging, environments, console alternative (like rails console) and so on. It doesn't matter what project does, is it web application with Sinatra, or scraping application, or bot platform (for Telegram/Facebook messenger) or whatever. I have some experience with it, and will write an article about code organization without Rails and with Sequel as ORM 
Hehe, this gem might help: https://github.com/ioquatix/trenni-markdown
Thanks for the reply, yes, I have struggled with all that when using selenium as well. Thankfully, I only work with a very small number of sites that use bot detection that's worth anything... For those sites I used a modified chromedriver, and that was enough. These days though, I'm using node and puppeteer for those ones-- I hadn't yet seen that devtools protocol was hooked up in Ruby, so I'll have to check that out. That will lead me down the path of checking out Capybara a bit more. Thanks again for your thoughts!
I went through the same process of finding a solution for the "make sure the client of my code checks all error cases" issue a few years ago: https://gist.github.com/timhabermaas/1ac34b7f7ad02a847ee0#emulate-exhaustive-pattern-matching-in-ruby-using-cps--required-keyword-arguments. I ended up with callbacks + required keyword arguments as one solution. It doesn't compose well, though. Chaining calls to service objects would end up in callback hell.
&gt; I strive to make mine as functional as possible Have you tried using [free monads](https://typelevel.org/cats/datatypes/freemonad.html)? They let you describe the side effects in a pure manner and it's up to you to interpret them later. No dependency injection necessary. I haven't found a good solution for the clunky syntax, though: Db.create_task(task).then do |_| Redis.incr("task_count") end Maybe https://dry-rb.org/gems/dry-monads/do-notation/ is worth checking out.
I think you have a bug in the `snippet_5.rb`. Instance method `call` is called without arguments. 
I think the third method works out best for my apps. I'm a big fan of using the Interactor gem to handle my service objects
Yes. Do not create a new project with phantomjs if you can avoid it
I'm the author of [opal-phaser,](https://github.com/orbitalimpact/opal-phaser) a game engine on top of Opal which lets you write HTML5 games in Ruby. It definitely fits the bill of "little 2D indie games." It's also quite fast according to my recollection, at least as fast as [Phaser itself](http://phaser.io/) (at the time I was developing it). I learned a lot by building it and building games with it, so I'd be happy to share my knowledge with you. 
I know. I feel the same way about the lack of documentation in some parts of the standard lib but since I was working on a pretty small project(just 1 script) I wanted zero external dependencies that's why I chose optparse. 
You mean that you rescue certain exceptions in one place in your app and handle them by mapping to responses, right? The thing that I was pointing out is that if you aim for a better architecture, you want to have clear public interfaces. If say AR exeptions are not rescued by the service, they become a part of it's public interface - poluting it. I mean if you wanted to write a documentation for the class `CreateUser` (`snippet_2.rb`), you would need to describe the `call` method and all the exceptions that are expected to be raised `ActiveRecord::RecordInvalid`, `ActiveRecord::RecordNotFound`, etc. 
So your last example could be rewitten to dry-rb like: ```ruby class FinishTask include Dry::Monads::Result::Mixin include Dry::Matcher.for(:call, with: Dry::Matcher::ResultMatcher) def call(id:) task = Task.find(id) return Failure(notice: 'Task already finished') if task.finished? task.finished = true task.save! Success(notice: 'Task successfully finished') rescue ActiveRecord::RecordNotFound, ActiveRecord::RecordInvalid =&gt; e Failure(notice: e.to_s) end end # controller finish_task = FinishTask.new finish_task.call(id: params[:id]) do |result| result.success { |notice:| redirect_to foo_path, notice: notice } result.failure { |notice:| redirect_to another_path, notice: notice } end ```
as one mentioned "elastic search" and I would also add SOLR.
Troll
What's the exact goal you are trying to achieve? If it is "I don't wanna see `(1 undocumented)` because I just don't care" -- then just don't look at it. Seriously. Otherwise (if you care about your code and docs), you can understand what is it that RDoc tries to say: that it would render `crc32_ITU_T` method inside some _class_, and that class would be `String`. So, your docs would contain top-level `String` class with one method -- which is OK (documentation reader would most probably understand it means you are extending core `String`). This class' docs would be empty, that's what RDoc is concerned about. Good thing to write there is something akin to "The library extends `String` with this and that because reasons." Alternatively, you can just hide the entire thing from RDoc with `:nodoc:` comment, but that means your code's docs reader will never find out you have provided `String#crc32_ITU_T`.
We're launching our Rails-centric APM in the next couple of weeks. [https://baseline.red](https://baseline.red) &amp;#x200B; Write me an email if you're interested in trying us out. jim@baseline.red
Happy to hear that. Any feedback how to make it better appreciated :)
If you like even faster, I like to see if Crystal fanguage can get faster?
There's a Crystal game-dev library called \[\`prism\`\]([https://github.com/neutrinog/prism](https://github.com/neutrinog/prism)) if you want to have a quick look and see what they've got going on.
I‚Äôm confused. If you wanted to code Ruby with static types then why wouldn‚Äôt you just use a different, statically typed language? We only have Typescript because we‚Äôre confined to JavaScript on the Web.
&gt; If you wanted to code Ruby with static types then why wouldn‚Äôt you just use a different, statically typed language? Generally speaking, that's a common misconception, frequently said about almost any new language feature: "if you want X, why don't you just get another language?", where "X" in (functional style, immutability, pattern matching, types, performance, you name it). There are two important things to note, though: * language choice is a hard and loaded thing, it is not like the choice of a pen or shoes or even your next smartphone, because the programming language is a _tool of thought_; it is not like "oh, now I need feature X, so I'll throw away all my Ruby experience and idioms and intuitions and just take Ocaml for the next week, why not" * some new ideas can be imagined to integrate with current language idioms and intuitions. For example, as Python experience shows, besides "just take static"/"just take dynamic" dichotomy there could be a sane middle way for a dynamic language with optional type annotations. In a lot of places in a Ruby code we already have something like... @param path [String] @return [true, false] def exists?(path) path.is_a?(String) or raise ArgumentError ... So, the idea of most of "added types" experiments (for example, recently published Stripe's [sorbet](https://sorbet.run/)) is to make those ad-hoc checks/descriptions more formalized and discoverable. Unfortunately, all of said above has absolutely nothing to do with the library in question, which is just an utility for better argument-checking exceptions :)
Programming languages as a tool of thought is a good point and a reason to invest in a language whose feature set doesn‚Äôt fully match your needs/desires. Something like type checking I do think represents a fairly meaningful shift in a language‚Äôs idioms and thought process but it‚Äôs all moot here as that‚Äôs not on the table here =)
&gt; Unfortunately, all of said above has absolutely nothing to do with the library in question, which is just an utility for better argument-checking exceptions :) Forcing something to be a string and ignoring that to_s is a thing is terrible. Are gems like this for people that don't write unit tests?
Yes, this is a (not particularly attractive) little DSL for asserting things about arguments at runtime. It‚Äôs something that should take about 15 lines of code to implement.
Your absolutism makes you honor, yet the matters are probably a bit more complicated. First, there are different approaches to argument types appropriate in different situations. Sometimes, "it responds to this and that methods" is enough (but if there are more than 1-2 methods, in absence of interfaces in Ruby makes checking it with `respond_to?` too tedious). Sometimes "coercible to" is enough, but it should be well thought-out what coercions are acceptable. BTW, `to_s` is almost never sane! because _any_ Ruby object has `to_s`, unless object's class takes special precautions of `undef`-ing it, and you may be very surprised with the effects of `to_s`-ing something inappropriate. Sometimes "make sure it is _exact_ expected type" is the most reasonable thing to do. All of it is super-important especially on API entry points (including internal APIs one part of system provides to another). Because "hey dude, this public method accepts file path, but you provided some integer" is MUCH more helpful (including on unit-tests) than "`X` is doesn't respond to `#y`" 5 levels deep in the library. And you are very lucky if it is just so, not some weird side-effects because something being `to_s`-ed violently and treated as a DB filter has removed half of your data. That's why real production code, ESPECIALLY libraries/big module interfaces typically have documentation explaining types of parameters expected, and precondition code to enforce them. And that's where discussions and experiments of "soft typing" emerge.
I get your point, but it seems that "sometimes typecheck" is also a useful notion. For example, lot of operation/business action systems make use of Virtus-alike declarative attributes of operation: class SomeAction &lt; BaseAction param :foo, Integer param :bar, Hash[Symbol, String] # .. end SomeAction.new(foo: 1, bar: {x: 'test'}).call ...and from LOT of real production work with this approach I can assure it is useful, easy to use, and integrates naturally with other Ruby code. Take a pattern-matching as an example. There are languages where pattern-matching is a primary tool of design (e.g. each method defined in terms of several different bodies, matching different pattern of args), and there are others where pattern-matching is present just inside something like `case`. Both approaches are useful. The same _may be_ true with strong typing (which, again, Python's experience seems to comply with; and as Stripe's experience with sorbet probably also demonstrates) -- you may make use of a tool for _eventual_ declaring of types, which could be used to generate docs, to auto-analyze code, to provide better introspection and better reporting on test environments (while being optionally turned off in runtime), for example.
like getopts with guard clauses?
Rails is just web isn't it? You can make a ruby program easy enough
string.scan(/word 1/)
[string.scan](https://ruby-doc.org/core-2.2.0/String.html#method-i-scan) should do the trick, returns an array of occurrences.
Same. Depending on your google skills, I would think 1-3 hours for a crude form page (command-line args), controller action, and result page
Presumably all you need is a page that'll offer to Do Something via a form, and then instantiate the same objects (and send them the same messages) that the CLI front-end would've otherwise. If that's all it is, it'll usually be straightforward. However, Rails might be Too Much Framework for this and you could easily get bogged down in unnecessary effort, especially if you're coming new to it and unsure of what's relevant to the task at hand and what's not. Take a look at Sinatra as well for a popular and much lighter-weight option. NB: if your program is long-running then do the work via a background job instead; use a web front-end to place the request and monitor for the result. 
Thanks a lot! Any recommendation on where to start? 
Hi, I understood everything but the last paragraph, what do you mean by long running and what do you mean by use a web front end to place the request and monitor ? 
Long-running meaning if it goes for more than a few seconds. Web requests are generally expected to be short-lived. Most web infrastructure will terminate the connection and thus the process after a few tens of seconds. As a result, it's a common pattern to use a web application to create a request for work to happen, usually as a database record. This gets picked up by a background worker in a separate, non-web-facing container (such as Sidekiq or delayed_job). The worker job performs the task and updates the request record with completion status as it goes. In the meantime the web browser can poll for job status, either as a user refresh or as JS. If you're needing that, then Rails makes sense, since it provides the ActiveRecord and ActiveJob abstractions that can speed development. 
Thanks a lot for your reply. It should not go for longer than a few seconds though ! 
Btw any advice on where to start? 
Setup active job and drop it in a queue to do work. 
A lot of people swear by https://www.theodinproject.com/ which also introduces Sinatra before moving on to Rails. 
If you want to use Rails, the [Getting Started](https://guides.rubyonrails.org/getting_started.html) guide would be a good place to start. However, if you would rather keep things simple, I would recommend [Sinatra](http://sinatrarb.com/) or Roda. Though I'm having troubles finding good a "getting started" guide ‚Äì their READMEs are more in form of an API documentation than an intro to main features.
If you really want to introduce proper static typing in OOP language, it's much more than "this is object is a `String`". Is an array of `String`s also an array of `Object`s? How do you even define parametric types? What to do with duck typing? Check Scala, consistent typing in OOP language is **hard**. Everything else leaves too many holes.
I've enjoyed using gem `contracts`: [https://rubygems.org/gems/contracts](https://rubygems.org/gems/contracts). It's extremely versatile. Be sure to see the excellent tutorial at [https://egonschiele.github.io/contracts.ruby](https://egonschiele.github.io/contracts.ruby).
This is why I love TypeScript (which surprised me). It's how I imagine Ruby if it was typed. While you can use classes, everything is basically just gently typed duck interfaces. It's a lot less strict than Java, C#, or Elm for example, but still tremendously useful for catching errors the computer can catch, and after a decade of ruby having intellisense again is invaluable for large codebases. I think it really is the best of both worlds (dynamic and static), and I wish there was something like it for Ruby.
This code does not give you static typing though, so if you did want that, you won't get it here. 
nice find
Super easy. Is your CLI in ruby?
im going for the latter ;)
idk what that means but ill find out! 
You should post the source of your script in a comment and we can help a bit more. A ruby script is just code, and rails apps are just code. 
Hi, https://pastebin.com/E5iTM0dd
I have recently used ruby curses for writing a small document-tagging tool. I believe that most of the problems I had came from lacklustre documentation rather than the implementation itself. I'm not sure what the typical use case for using this gem is, though.
thanks. i have 12 hours to work on it lol
Right, but he wants a count, not an array: string.scan(/word 1/).count Should get the job done.
*"...the rest is left as an exercise for the reader."* ;)
&gt;And is anyone interested in (yet another) wrapper? If you do, please call it "FoiledAgain" :)
Phantomjs/poltergeist is not maintained anymore AFAIK
Hey! Glad you are starting your journey on becoming programmer! Something that could be helpful is to copy and paste the code into a gist at gist.github.com that way we could help follow through the code with you locally on our machines.
Don‚Äôt use a while loop. Just if/else statements. 
If I use if else statements how can I get it to repeat though
class Account attr_reader = :name attr_reader = :balance def initialize(name, balance=100) @name = name @balance = balance end private def pin @pin = 1234 end def pin_error "Access denied: incorrect PIN." end public def display_balance(pin_number) if pin_number == pin puts "Balance on account #{@name}: ¬£#{@balance}." else puts "Error: #{pin_error}" end end def withdraw(pin_number, amount) if pin_number == pin if @balance &gt; amount @balance -= amount puts "Withdrew #{amount}. New balance: ¬£#{@balance}." else puts "Insufficent Funds." end else puts "Error: #{pin_error}." end end def deposit(pin_number, amount) if pin_number == pin @balance += amount puts "#{amount} added to account, New balance: ¬£#{@balance}" end end end checking_account = Account.new("Robert Templeton",100_000) kellys_account = Account.new("Kelly Johnstone", 450_000_000) johns_account = Account.new("Jek Hughes", 125_000_000) puts "Please enter account name!: " acc = gets.chomp while true puts "Please choose from the following: Balance: ------- Withdraw: ------- Deposit: ------- Exit: -------" choice = get.chomp.capitalize! case choice when "Balance" puts "Please enter Pin: " pin_number = gets.chomp.to_i acc.display_balance(pin_number) when "Withdraw" puts "Please enter Pin: " pin_number = gets.chomp.to_i puts "Please enter amount to Withdraw: " amount = gets.chomp.to_i acc.withdraw(pin_number, amount) when "Deposit" puts "Please enter pin: " pin_number = gets.chomp.to_i puts "Please enter amount to Deposit: " amount = gets.chomp.to_i acc.deposit(pin_number, amount) when "Exit" break else puts acc.pin_error end end 
In ruby we use loop do...end instead of while true
&gt; If you really want to introduce proper static typing in OOP language I am not. I am explaining why _eventual type annotations_ may be a _useful addition_. Thank you very much, I am pretty aware of the current state of "type systems" thought.
I don't know the history of motivation, but in fact people have become interested in fibers for high-performance highly-concurrent "evented" code (compare to [node.js/javascript's similar concurrency model](https://www.javacodegeeks.com/2013/12/node-js-non-blocking-io-model.html)). Actually some googling reveals that people were interested in fibers for this purpose from the start. Here's a piece from 2009 (even before 1.9 dropped with fibers, i think) from Ilya Grigorik, where he highlights the use for evented code: https://www.igvita.com/2009/05/13/fibers-cooperative-scheduling-in-ruby/ It is true that continuations could have been used for same. But they lacked the performance characteristics to make it useful. At any rate, it's not just "generators", but an evented concurrency model. That was documented as _one_ of the focuses of interest from the start. And I would say has become the _main_ interest in fibers. Don't get me wrong, personally I am not too interested in node.js-style evented code, for a variety of reasons. But for those who are, fibers are what makes it hypothetically possible with the desired performance characterstics. 
I cant remember if Matz made any comments about TypeScript.... but what we do know is Matz really dislike Types.
That'd definitely work if I didn't want a random input from a user. I only used 'word 1' as an example, but the program isn't supposed to know what it's looking for beforehand. My problem is: when I, the user, input 'word 1' (input = gets), the program looks for each individual letter of my input. I want the program to output 3 when I input 'word 1' ('word 1' appears 3 times in the string). Just like if I input 'word 2', I want the program to output a 1 ('word 2' appears 1 time in the string). I hope that clears things up.
Thanks! Yeah, it's true that you can build highly-concurrent evented code using event-machine. And there is good examples of it like [Goliath](https://github.com/postrank-labs/goliath/). However, I'm pretty sure that the main point of adding fibers to ruby, was to replace continuations, whose the main use was to build generators. I'm making this conclusion, for two reasons: First, that pretty much what Koichi, who wrote them said in his [presentation](http://www.atdot.net/~ko1/pub/ContinuationFest-ruby.pdf). Second, to make fibers act as fibers, you have to require 'fiber', first. So it's seems like a nice to have, but not a primary interest. &amp;#x200B; I was trying to answer a question why fibers were added to ruby and it's seems to be that it was the reason. But you're right, I should've wrote about the possibility to use fibers with event-machine to build concurrent code. I'll to rewrite the blogpost to incorporate that. Thank you! &amp;#x200B;
Awesome overview. I remember when Fibers landed and very few people wrote about them as clearly and as succinctly as you. Much appreciated for the new resource to share around. ‚ù§Ô∏è
You can assign that one input to a local variable, and then use it in your scan pattern. 
Seems a bit pointless if it's just going to spit out a different runtime error. Truth is, if you want static typing, a different language is better. Crystal is exactly that for example.
Very nicely done. I'm currently using a python script, instalooter, to follow and scrape some accounts, but may migrate over to this, since I generally prefer ruby gems to python eggs/whatevers
The other thing to consider doing is to incrementally replace scaffolded code. To do so, use the same workflow as you'd use for any untested legacy code. 1. Write feature specs for the happy path of each generated CRUD action; 2. Using test doubles as needed, write feature specs for each important error case for each generated action. "Important" is going to be a judgment call that improves over time, but throw YAGNI out the window until you're confident enough to make that assessment; 3. Now that you have working (if scaffolded) code fully* covered by tests, you can start refactoring. I usually start by 1. Ripping out any generated actions that aren't going to be needed in production; 2. Consider using Interactors or service objects to isolate the domain logic from the HTTP processing and input validation performed by your controller. TDD those with a view towards how you'll drop them into your existing controller and have your tests still pass; 3. Extract repetitive code into shared modules. Having lots of private methods on a controller is a *major* code smell. 4. Documentation is a Good Thing. If you're working with a RESTish API, learn Swagger. Otherwise, YARD will make your future self's life *much* easier. Iterate and riff on those a few times until you have shop standards that work for you. Remember that the whole "skinny controllers or skinny models" "debate" is *so* 2012; the correct answer is "yes" to both.
This is an interesting read: https://www.codeotaku.com/journal/2018-11/fibers-are-the-right-solution/index
Score. We'll check it out. Thank you! This is awesome!
Thank you!
Thanks for this. Adding it to the list to check out.
Checkout Upcase if you're looking for free content
Has anyone really done much with Stackdriver ? I feel like it's pretty rough
Well put! I wholeheartedly agree with all of this.
You‚Äôve sold me. I imagine it‚Äôs also useful when ingesting data from APIs and other external sources where you genuinely need to expect a certain shape of data. Once it‚Äôs in your system, that typing is still valuable but less imperative.
Cool, thanks for the info!
Good to know. I could see this getting expensive. We do plan on switching to containers in the future.
Yeah, Fibers are pretty dope. We use them implicitly whenever we use Enumerators. I also used them explicitly in the [Down](https://github.com/janko-m/down) gem to implement [on-demand streaming download](https://github.com/janko-m/down#streaming).
How many people use of scaffolding regularly? Personally, I don‚Äôt use it, but now I‚Äôm wondering how common it is. 
In my experience, super common for Rails apps near the beginning of their life but less and less common as the application gets older and goes from "build" phase to "maintenance" phase.
If the words are split by a space: string = "word1 word1 word2 word2 word1 word3" You could use split and then work on the array. And then use a loop. If you want all word counts you can use a hash but if you are looking for a single word us .each user_input = gets.chomp word_count = 0 array = string.split(" ") array.each do |word| if word == user_input word_count += 1 end end Word count increments each time an element in the array is equal to the word you are looking for. Don't forget to use .chomp on your gets, otherwise I believe the gets has a new line, the chimp removed that and returns the gets. Or maybe I am thinking backwards and it actually removes the gets and returns what was removed which in effect gives you the user input. Something like that, anyway, I think you need gets.chomp not just gets.
Noted, thank you :)
I don‚Äôt really use rails g scaffold often, however rails g model/ rails g controller can really help give you some extra time in an interview practical challenge.
Learn React. It‚Äôs the most popular JavaScript framework for a reason. I personally put it off for too long and wish I‚Äôd gotten stuck into it earlier. 
I started learning ruby 6 months prior to becoming a professional web dev, and it has not been of much help, apart from the occasional script. wasn't able to find a junior rails position, but there are loads of jobs for js, react in particular. React is in huge demand right now, i highly encourage you to pick it up. I 
Another vote for React. In all likelihood, most jobs you apply for will appreciate that you have experience with modern JS and a modern front-end library. Even if they‚Äôre using Vue or something else, your experience with React will leave you better prepared for whatever they throw at you. I worked backend exclusively for years before being forced to take on more of a full stack role. Now, the majority of my time is spent in React. I prefer it to working with Ruby in many ways. 
React is not related to Ruby in any way.
Did OP say that it was? Thanks for the completely irrelevant comment.
it's r/ruby dawg
You should definitely learn React. The mental model you get from it applies to so many other things. It really affects the way you look at software. Representing the view as a function of state is simply a fantastic idea. You‚Äôll start thinking about state and functions a lot more, which I think improves your code elsewhere.
If you are looking to be a backend dev then you might not care. If you are looking to be fullstack then probably. Though you may want to look at what front is used most in your area. Vue is also quite popular with some of my ruby working aquaintances.
OP has clearly posted the question "should I learn A?" to a subreddit `/r/A`. Not my comment is irrelevant.
thanks, happy you like!
Absolutely. While I had no trouble getting a junior Rails position, React is blowing up at the moment. And while the popularity of React may be fleeting in the end, I think its programming model will be around for a *long* time on the web. Understanding React will make you way more hire-able, and help you to write better UI code in general, and easily work with any of the numerous React-like frameworks out there now. For me personally I ended up going with **Elm** in my Rails projects because I found the JS toolchain to be totally insane and not worth dealing with as a solo developer, but I had a massive leg up because it works a LOT like React.
I'm going to go against the grain here and recommend Vue.js over React, based purely on my personal experience. You should probably learn React and understand the concepts, and React is fine as long as you don't go too far into the crazy levels of abstraction, but I find myself infinitely more productive with the tooling built around Vue and Nuxt.
It doesn't seem like the issue facing the author (counting by group) has anything to do with the web framework, but rather the database tooling. I also don't see any substantiation of the claim that Hanami is a "hipster framework." To me, Rails is a "hipster framework," but even then, that's just like, my opinion, man.
This, exactly. It's really easy to swap out the model layer in Hanami - there's even [a page in the official guide](https://guides.hanamirb.org/models/use-your-own-orm/) that tells you how to do this. I've been using Hanami for awhile now, and I always swap out for Sequel. Just makes life a lot easier.
Fibers are a basic primitive that many languages support and are used for a lot of things. Arguing there is any 'one true use for them' or 'one reason to implement them' is missing the forest for the trees. As a side note: continuations have not (yet) been removed from MRI, you can still `require 'continuation'` and use `callcc`. There is discussion about removing them though. 
I think RubyMonk is a good fit for what you're looking for. They have a good amount of reading material available if that's how you learn best. I would also recommend doing Hackerrank problems on your spare time as well, they have a solid base of problems for Ruby Fundamentals. &amp;#x200B; I think a universal best practice for learning any language is repetition solving various problems, so I think if you did all the challenges and finished the RubyMonk tutorials then you'll be a Ruby Developer in no time!
&gt; Even if they‚Äôre using Vue or something else, your experience with React will leave you better prepared for whatever they throw at you. Not really - JSX is very different to plain JavaScript, and common React state-management systems like Flux or Redux are *very* different to most "normal" MVC/MVVM/MV\* systems used by other JS frameworks. Don't get me wrong - idiomatic React has a lot of benefits, but "similarity to other JS frameworks/architectures" is not remotely one of them.
I use them a fair bit for views/controllers but not the defaults. I don't think a lot of people do it but the generators are very easy to customize, e.g. setup views using your default style/layout and default controllers that implement your usual patterns. Obviously you end up customizing still but it does still get a lot of boiler plate out of the way, assuming your app does a lot of CRUD style stuff.
hanami might be a better architecture in a theoretical way, but it's hard to compete with the years of work that's gone into Rails, including the years of people contributing docs and tutorials and blog posts with examples, etc. 
I'm not sure if Hackerrank has problems for Haskell but they do have a bunch of functional programming problems that can be solved in any language. Here's the link for some of the Ruby practice though [https://www.hackerrank.com/domains/ruby](https://www.hackerrank.com/domains/ruby) &amp;#x200B; As for your set up - I'm coding on a Macbook Pro but I think your best bet to download Ruby is [https://rubyinstaller.org/](https://rubyinstaller.org/) (not sure though). As for your IDE I would recommend VSCode, Atom is also another good one and is very user friendly for beginners.
Do you think the hanami maintainers have considered making Sequel the default/recommended ORM?
Depends on your goal. If you're a junior and just want to get your first job than sure. If you're a senior I don't think it's the best investment of your time, these companies (Google, Facebook) tend to change frameworks quite often...I'd invest my time on backend (get better with python, java, spring) etc. 
Frankly I lost track of thread-related stuff in ruby. I hope matz radically revamps this in ruby 3.x. Someone even suggested Thread::Light not so long ago on the issue tracker ... Who can remember all of this?
Just looking for Rubyist opinions on React and whether its worth the trouble because I'm a Ruby developer trying to break into the job market.
Thanks this seems to be the consensus. They do have a course Ruby on Rails with React, Angular, and Vue. This might be my best approach to getting my feet wet with the most popular JS frameworks. 
I love Ruby and would love a job around it. At this point, I'm trying to be as marketable as possible, eat shit, until I can leverage for a more desirable position. 
Sequel is hardly an ORM. It has it's model but general consensus in Hanami/ROM/dry-rb folks is that it's a bit too low-level. I generally agree. I use Sequel extensively, but in a project where I deal with data only, not with actual model or entities. Hanami Model is based on ROM, more precisely version 3. The main problem is that upon Hanami going 1.0 ROM4 was already around and 3 did not receive much care (which is understandable). Now they are planning to base Hanami on ROM5 (I think). It's supposed to come out in January. If you ask me, Model is the weakest component in Hanami stack. If I were to do any serious project with Hanami today, I'd choose ROM4 instead ‚Äì it's in many places already better.
&gt; it's hard to compete with the years of work that's gone into Rails I don't think Hanami is trying to do that. It's not another go-to framework which is supposed to replace Rails. It's more focused on people that had enough with Rails and the "magical solutions" built upon it (think Devise). So it has to be different. And of course, it's young, it's less popular and it has higher entry barrier, so naturally there are not as many solutions as for Rails. But basically you can cover all standard webapp needs with existing tooling already.
Wow, that's neat. I built an app using Instagram API during hackathon some time ago and was very disappointed few years later when I realized the API has been so drastically limited. This brings back the functionality I need! &amp;#x200B; Do you know how long the session\_id lives?
What are you comparing Hanami::Model with exactly? &gt; To be able to fix my problem with this framework, I had to get access to the Sequel::Dataset object and do the call by myself. That sounds like a proper solution. The count that you were fetching probably wasn't related to any entity in your domain, so it makes sense to fetch the data directly.
Using React, they're likely to deal with webpack, maybe (probably?) babel, dependency management, the various ways of declaring variables, promises, JS's scoping quirks, different ways of declaring functions, maybe mess with the prototype, get a sense of JavaScript's stdlib, start thinking about DOM blocking/non-blocking operations, maybe some testing, and more. This is valuable for anyone who's going to be working with JavaScript.
Is it even still working? Pretty sure it's pretty dated now and haven't been updated in a long time.
Nobody is entitled to Rails or Rails support for free either. If someone found Rails easier to work with than hanami, I find that a useful review. I agree that "hipster framework" is a silly thing to say, and the review could have been a bit more even tempered. I'm guessing that he felt a bit defensive in that he found something hard to use when lots of people on the internet basically imply it's what the "smarter" people are all using. It goes both ways. These days, when people talk about the things they don't like about Rails (or ruby in general!), I find people on reddit don't get too defensive. Sure, Rails (or ruby), has problems. We like it anyway. If you like something else better, go ahead and use it. But when people talk about the things they don't like about some _new_ thing, I still see people getting really defensive. We'd never "blame the user" for our own software that way, but when someone has trouble with hanami, it must be their fault, not hanami's. None of the open source we use are we entitled to. But all the more reason that reviews of how people found it (whether beginners or not, on various sorts of projects) are useful to others deciding what to invest time in. 
Hey, Hanami author here. "Hipster framework" a dismissive comment. I don't want even argue about it. You're just throwing shit at other people's work, that committed years of their life to build a OSS (and don't forget, _free_) project to give you the a choice. Now getting to the technical matter. It would be silly from us to NOT explore other possibilities in software design. If I had to write a Rails clone, that would have been pointless. Other point. ORMs are hard. We try to do our best. In the spirit of a cooperating community, we would appreciate contributions. Not just "hey my question got unanswered" (I'm sorry for that), but "hey, it was hard, but I made it! Here's a PR to enhance the code or at least to document the solution". We're not your software provider, nor we signed any contract with you.
This is great input - how you feeling about price?
Thank you!
This is great input - how you feeling about price? Any other thoughts on why you switched? 
Is it even possible to revamp the threads implementation? Removing the global interpreter lock from YARV is a major breaking change that will probably deprecate all existing C extensions, so YARV maintainers will probably keep that lock forever. All the Ruby code running on top of that particular implementation is unlikely to ever run in parallel, even though the C code might. Languages need to have a built-in foreign interface from day one in order to avoid locking users into this type of implementation-specific issue. By the time Ruby got `ffi` it was too late...
New relic was too expensive for what they offered. And DataDog / Raygun integrated better with our other enterprise applications. 
Hey did you give it a try? Do you have any feedback?
Agreed. Model-related code has been a pain point to some degree in the 3-4 projects we've done so far. We *love* Hanami otherwise; believe that Hanami::Model is about halfway to being a decent ORM that, like ActiveRecord for Rails, derives much of its current value from being a "natural fit" for the framework; and are devoutly praying that Hanami 2/ROM 5/dry-rb 1.0 gets it the rest of the way.
Yes. Don't compare it to Rails 5.*x*. Compare it to Rails 1.*x* or, really, any version before 2.3, where ordinary teams started getting real work done at scale. That's like comparing a Lamborghini Hurac√°n with a Model A Ford; you can argue that their intended function is similar, but you wouldn't want to drive a Lambo on the roads a Model A was designed for, and the Model T wouldn't have happened without the Model A before it. Finally, thanks for adding "hipster framework" to my list of automatic interview-filtering phrases.
I appreciate the kind words! I see we're in the same boat, haha! Not a fan of optparse either and would rather almost always use ARGV directly instead. I like how flexible and unopinionated optparse is, though. But requires too much work (explicit and verbose declarations) to get going quickly, to my taste.
Glad you like it! Hehe
 Glad you like it! Hehe 
it seems to work, I can do the first exercises without any problems
Turns out it's actually ROM4 ;)
Thanks! That's exactly why I did that. Lowering the "whelm" barrier to add new commands -- getting rid of the bureaucracy, straight to the fun part: `def cmd_foo` haha!
Yeah I like how the library automatically discovers all methods prefixed with `cmd_`. The user can pass in any object with those methods so it doesn't force an architecture on the project. When I tried to make an option parser I made a big framework... Seemed like a good idea back then.
They're not the cheapest, but also not the most expensive option. Definitely cheaper to run than NewRelic, by far. Their support and live chat is quite good, so whatever you're after they can probably help you work out a package.
It is true. Enumerators are paused fibers that resume whenever you try to get a new element.
If you want to make your own terminal control library, check out [this rather opinionated post]. While not completely portable, it introduces a lot of concepts that I wish I'd known about when I started. [This article] about the terminal system as a whole is very nice too and quite detailed. [this rather opinionated post]: http://xn--rpa.cc/essays/term [This article]: https://www.linusakesson.net/programming/tty/
I reckon most of the author's concerns could be addressed with better documentation - which, let's face it, is hard to write and maintain. The article kind of implies that, but the choice of words is indeed a bit strong regarding the framework itself. Still, your comment is worse and doesn't really solve anything. As an OSS maintainer it would be much better for your users's and - even more so - your own sake if you didn't take that kind of feedback as personally as you did there. Thank you for all the hard work you've put in Hanami, and OSS in general, so far.
My bad. Still, a huge improvement over 3.3.3, I reckon.
I try to use Instagram API first, but like you said is drastically limited. So i change to use crawler! thanks you like. My sessionid is 484 long!
No shame in that (been there times and times again before...). I've seen many attempts out there, and they end up looking like Thor, or worse, Hanami::CLI -- I'm guessing that's the kind of big frameworks you meant yours looked like. Anyway, props to you for scratching your own itch instead of settling for the status-quo from back then. Do keep on innovating with your own solutions and share üôÇ Would be glad to see what you come up with.
Your code works, which is the important first step. Rubysist love the acronym "DRY" which stands for don't repeat yourself. If you look at your code there's lots of *near* repetition. Really the only thing that changes are the values used for multiplication and division so if we had a map containing those values we could simplify things. Likewise, we don't need those intermediate strings, we can just shovel the next set of characters onto a string we're building. With that in mind we could rewrite it something like this: ROMAN_VALUES = { 1000 =&gt; "M", 900 =&gt; "CM", 500 =&gt; "D", 400 =&gt; "CD", 100 =&gt; "C", 90 =&gt; "XC", 50 =&gt; "L", 40 =&gt; "XL", 10 =&gt; "X", 9 =&gt; "IX", 5 =&gt; "V", 4 =&gt; "IV", 1 =&gt; "I", } def roman_numeral() puts 'Please enter number, and i will convert it to old roman Numerals' user_num = gets.chomp.to_i original = user_num roman_value = "" ROMAN_VALUES.each do |value, str| count = user_num / value user_num = user_num - count * value roman_value &lt;&lt; str * count end puts " The number #{original} in roman numerals is : #{value}" end roman_numeral However there's still room for improvement. Ruby has a [modulo operator](https://en.wikipedia.org/wiki/Modulo_operation) so we can leverage this to reduce the amount of math needed. That would look something like: ROMAN_VALUES = { 1000 =&gt; "M", 900 =&gt; "CM", 500 =&gt; "D", 400 =&gt; "CD", 100 =&gt; "C", 90 =&gt; "XC", 50 =&gt; "L", 40 =&gt; "XL", 10 =&gt; "X", 9 =&gt; "IX", 5 =&gt; "V", 4 =&gt; "IV", 1 =&gt; "I", } def roman_numeral() puts 'Please enter number, and i will convert it to old roman Numerals' user_num = gets.chomp.to_i original = user_num roman_value = "" ROMAN_VALUES.each do |value, str| roman_value &lt;&lt; str * (user_num / value) user_num = user_num % value end puts " The number #{original} in roman numerals is : #{roman_value}" end roman_numeral 
Efficient? I guess your code is efficient enough, but that might not be what you are looking for. In coding, at least professional programming, the first priority (at least in OOP) should be "be easy to read", when it's easy to read, it's easy to change. Your code is not very easy to read. Methods longer than 5 lines are not easy to read. This is opinionated of course, but I like [Sandi's rules](https://robots.thoughtbot.com/sandi-metz-rules-for-developers). I wrote a more OOP version [here](https://repl.it/repls/ImpureHumbleDefinitions), similar to what /u/Jdonavan wrote. I use reduce instead of each and pass an accumulator instead, but using each is fine too. Also, you could apply the [Chain of Responsibility](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) pattern, where you'd have several transformation objects (one for 1000, another for 500, another for 100, etc), and one linking to the other (1000 links to 500, 500 to 100, 100 to 50, etc). I think that one would also fix the error of printing 4's as IIII, although that's actually valid roman numbers, both IV and IIII notations are correct.
**Chain-of-responsibility pattern** In object-oriented design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain. A mechanism also exists for adding new processing objects to the end of this chain. Thus, the chain of responsibility is an object oriented version of the if ... *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
So maybe at least `hanami new --no-model`? Nah I understand the maintance cost argument. Thank for all the work on hanami btw :) Yep, I've even contributed to this page of (old) guide :)
Welcome to Ruby! Hope you're enjoying it. When I first started learning, I loved doing these little programs. First time coming across this one, and I've never had to convert numbers to Roman Numerals in real life code. And reading through the process, it's not an immediately obvious solution either, so it's good job on taking the time to figure it out. As far as feedback goes, you are repeating yourself entirely too much, and Ruby provides a lot of functions to reduce that repetition -- though I wouldn't expect a beginner to be aware of them. If we look at the basic algorithm for converting arabic to roman: &gt; Compare given number with base values in the order 1000, 900, 500, 400, 50, 40, 10, 9, 5, 4, 1. Base value which is just smaller or equal to the given number will be the initial base value (largest base value) .Divide the number by its largest base value, the corresponding base symbol will be repeated quotient times, the remainder will then become the number for future division and repetitions.The process will be repeated until the number becomes zero. [source](https://www.geeksforgeeks.org/converting-decimal-number-lying-between-1-to-3999-to-roman-numerals/) So first we have a set amount of base values to use to convert a number to roman, which you implemented by writing out each comparison `m = user_num / 1000 # etc...`. However, a better solution so you don't have to write out each base, divide by the number, and store that in a variable, would be to just store all the bases in `Hash` so we can use it to look up the corresponding roman numeral for a given base: ROMAN_BASES = { 1000 =&gt; "M", 900 =&gt; "CM", 500 =&gt; "D", 400 =&gt; "CD", 100 =&gt; "C", 90 =&gt; "XC", 50 =&gt; "L", 40 =&gt; "XL", 10 =&gt; "X", 9 =&gt; "IX", 5 =&gt; "V", 4 =&gt; "IV", 1 =&gt; "I" } Why would we want to do that? If you break down the next part of the algorithm, what needs to happen next is **repeatedly** using those bases to determine which roman numeral to use, so if we have them all in one structure we can just reference the `ROMAN_BASES` hash while using some looping mechanism instead of repeating the same code over and over again. How can you do that? Well, if you break down the core of the algorithm, what you're doing is taking one value and converting it to another, or in more CS/Math terms you're **reducing a value to another**, and most programming languages support a way to do that using a method called `reduce` that takes an initial value (the arabic number) and using some set of other values (the `ROMAN_BASES`) and reducing them to a new value (this is actually one of the concepts I struggled with when I first started). And ruby `Hash`s have can use that method, however *idiomatic* ruby instead calls the method `inject` (though you can still also use `reduce`). So instead of writing out each comparison on a new line and repeating the same code more-or-less, you can use `inject` to loop over the bases and accumulate the roman numbers with each iteration the number becoming smaller until it's zero, at which point you'll have you're conversion. To achieve that the code would look like: ROMAN_BASES = { 1000 =&gt; "M", 900 =&gt; "CM", 500 =&gt; "D", 400 =&gt; "CD", 100 =&gt; "C", 90 =&gt; "XC", 50 =&gt; "L", 40 =&gt; "XL", 10 =&gt; "X", 9 =&gt; "IX", 5 =&gt; "V", 4 =&gt; "IV", 1 =&gt; "I" } def to_roman_numeral(arabic) roman = "" # intial empty string used to accumlate ROMAN_BASES.inject(arabic) do |num, (base, symbol)| # num.divmod(base) will divide the arabic number by the roman base # and return an array containing the quotient -- number of symbols needed # and the remainder which will be used on the next iteration to do the # same for the next symbol, for example: # 3004.divmod(1000) will return [3, 4] which means we need 3 "M" symbols # and the remainder will be for, so then on the next iteration it will do # 4.divmod(900) and return [0, 4] meaning we need 0 "CM" symbols # and so on symbol_count, remainder = num.divmod(base) # then we multiple the symbol by the count to get "MMM" and add to # our roman string roman &lt;&lt; (symbol * symbol_count) remainder # and return the remainder for the next iteration end roman end to_roman_numeral 3004 [Which you can play with here](https://repl.it/repls/HurtfulCompetitiveRar) I realize this may be a bit confusing, so if you have any questions feel free to ask! 
Thank you so much everyone for the helpful replys much appreciated!! I'll have a proper look over them when I get home from work.
In general a lot of your could could be simplified, but I think you should not worry about this too much. The more you write, the more you can see areas where you can be shorter, without sacrificing readability. First thing is always "does the code work". If yes then this is ok. At a later time you may want to use a class and separate the parts a bit, such as using a separate method for getting user input (I love this) - but this is a lot up due to personal preferences too.
&gt; Methods longer than 5 lines are not easy to read. I can tell you I have methods longer than 5 lines and they are SUPER EASY to read. I write only code that makes me not have to think at all.
&gt; And is anyone interested in (yet another) wrapper? Or is it just me? I'd love to have a pretty simple API that is also powerful for curses-related stuff. But there is a reason it is called curses - this thing is fucking awful. I hate it. I don't want to use it in the way it is. Often 1:1 mappings from C to ruby suck too. But if someone were to do a good API layer ... that would be nice. I don't think this will happen, though. People run into curses quickly give up. There just lies Cthulhu.
Would be nice if he were to manage - but so many have fallen to the curse of curses ...
Indeed!
&gt; I believe that most of the problems I had came from lacklustre documentation rather than the implementation itself. There! Big problem nr #1. &gt; I' not sure what the typical use case for using this gem is, though. There! Big problem nr #2. Curses does not work. People only think it does. :)
5 lines is a bit extreme for some people, it's based on Smalltalk-style of OOP, but it's doable, and quite nice once you get used to. That being said, the Rubocop config we use at work actually uses 10 lines as max, I think 10 is a good limit. Personally I rarely go over 5 though, not because of the rule, but the Single Responsibility Principle.
It seems that you are throwing sh\*t back. I can appreciate all the effort and quality of work in Hanami but I'm thrown off to your response to some user's perceived negative feedback. Just wondering what else is causing that type of reaction.
Good podcast with good points. Disappointed that there were no mention about performance implications of using rspec/factories.
Right? Maybe a userspace build-install system like `brew` on OS-X but to have another place to look beyond `apt` just confuses things.
Ask about me in the community, I‚Äôm always calm and patient. But I wanted to put the author of the article in the prospective of what means OSS. To me it isn‚Äôt throwing shit back. Peace. ‚úåÔ∏è
Thank you so much for taking the time to help me out, one question. I tried to do a similar thing to you but my hash was throwing up an error until I changed It to all Caps, Does making it all caps make it a Global Variable? and could I also use $roman\_values to the same effect? &amp;#x200B; Thank you again
Putting it in all caps makes it a constant. Think of it as a global variable you never change. 
Thanks. Yeah, generally, using generating data before each test case using factories is going to be slower than generating data before the whole test suite using fixtures. It's actually more of a "before each test case" vs. "before each test suite" difference than a factory vs. fixture difference, but "before suite" tends to be used with fixtures and "before test case" tends to be used with factories.
Instead of just giving you the answer, here's an explanation :) When you have `req.body`, it's a string. You can check this by doing `req.body.class` and it will return `String` `JSON.parse` turns the string into a hash with string-based keys (not `:symbols`). When I'm debugging JSON, what I do is this: json = JSON.parse(req.body) puts json.keys # will return an array of the keys of the current set, so ['accountData'] puts json['accountData'].keys # returns ["name", "stats"] puts json['accountData']['stats'].keys # returns ["statdate", "sale", "refund", "cbck"] and I'm sure you can figure it out from there :) 
Saved my life. Thanks!
I tried it already and found that it's impossible to install snaps to the user directory, only system-wide. That means we still need use sudo while `gem install` or `bundle install` otherwise it will not work. Not good. I guess I'll stuck to rbenv for production.
There is a Linux port of Brew.
I was expecting a snap back hat and got excited to see some official gear!
Same time you can install docker and have any version on demand on your box anytime or same time. 
Does setting GEM_HOME to something in your user dir work?
See [New to Ruby?](https://github.com/planetruby/quiz#new-to-ruby) @ Ruby Quiz for (recommended) free learning resources. Happy coding with ruby. Cheers. Prost.
Thanks!!!
Koichi Sasada gave a presentation on Guild at RubyConf this year. I wasn't able to attend that particular talk so I'm not able to give a progress report, but here is a slide deck from another 2018 conference where he presented the progress on Guild as well: [http://www.atdot.net/\~ko1/activities/2018\_RubyElixirConfTaiwan.pdf](http://www.atdot.net/~ko1/activities/2018_RubyElixirConfTaiwan.pdf)
I think the Well-Grounded Rubyist is a great book for not-quite-beginners to understand how ruby does things differently from other languages.
Yea but OP is just talking about making another Curses wrapper. Not making a better terminal UI library.
Long term, I like to build something like Spacy/NLTK but for Ruby. Also, which are lightweight. Because, most of the libraries are pretty heavyweight. My goal is to create a performant ML/NLP lib maybe not the most state-of-the-art but atleast close enough. I am teaching myself ML and as I progress, I will keep on building. 
https://www.theodinproject.com - check out the Odin Project. 
I‚Äôd recommend you just keep your front end and backend entirely separate.
This. 
Thanks! &amp;#x200B;
really appreciate it, I'll look into it.
Bruh
Have you tried ``` testXML.xpath("//parameter[@name='drug-name-ddl']").text ```
\`testXML.xpath("//parameter\[@name='drug-name-ddl'\]")\` should get you the element \`testXML.xpath("//parameter\[@name='drug-name-ddl'\]").text\` should get you the text \`MORPHINE PH\`
Finally!!!
About time! If only one could now get a background job lib which triggers lambda functions over SNS, we could make this baby fly
O\_O best Christmas ever !
Oh man, my thoughts exactly!
[https://www.serverless-ruby.org/](https://www.serverless-ruby.org/) updated 
While thats awesome, the fact that we can now bring our own language and arbitrary runtimes is way more meaningful, imo.
interesting. what do you need shoryuken for? I've been working with it, and I didn't find it as pleasing as sidekiq to write jobs, i.e. configuration not so intuitive, local dev environment mount, not as featured. 
We connect SNS to SQS which does support lambda invocation. We also use sidekiq and built a lambda that inserts directly into redis which sidekiq picks up and processes. 
I feel the same way - Ruby is and always will be my passion but sometimes you just butt heads against its slowness in a way that traditional horizontal scaling doesn't really help with. That said I'm hyped for this and am going to use Ruby for my lambda functions anyway - for me it's going to be good enough most of the time.
I'm quite interested in Curses, and I think the gem Curses does alright. The only real issue I have been having is compiling it with the right ncurses [(or else all kinds of weird behavior will happen)](https://github.com/ruby/curses/issues/42) Luckily the solution was simple enough: &gt; bundle config build.curses --with-cflags="-I$(brew --prefix)/opt/ncurses/include" --with-ldflags="-L$(brew --prefix)/opt/ncurses/lib" One thing that could be interesting instead of yet-another-(n)curses-gem would be to have a Ruby Termbox implementation/wrapper: https://github.com/nsf/termbox, it is a very small C library with a small API that is much easier to comprehend and use, unfortunately the author do not seem to like terminals that supports 24-bit colors: https://github.com/nsf/termbox/issues/37 :(
Awesome!!
I have a PR open for an example using serverless framework https://github.com/serverless/examples/pull/336 Makes deploying to AWS ez-pz
Sometimes you want to generate a function from a template and execute it. The template vars can come from SNS, redis, Dynamo, anywhere really.
Nice! I will play with this over the weekend!
It really depends on what kind of development you want to do... &amp;#x200B; Ruby is nice because it's very developer friendly and has a very open and helping community. If you want to learn better code design in Ruby I'd suggest any book by Sandi Metz
I don't scaffold, I don't think it's a good idea. &amp;#x200B; Rails as a framework is already super opinionated, but when you scaffold you end up having to edit a lot of code that doesn't work the way you want it to. Its like when you copy and paste code from stack overflow, it leaves a lot of room for error, and you're right, it's not compatible with TDD.
the problem isn't that you're using a loop, its that you're using a loop that never ends, then 'breaking' it. &amp;#x200B; The better practice would be to do something like `x = 99` `while x != 10 do` `'x gon give it to ya'` `x -= 1` `end` &amp;#x200B; or in your case &amp;#x200B; `while choice != exit do` `'x gon give it to ya'` `x -= 1` `end` &amp;#x200B; while technically your implementation is correct, it leaves your code open for the possibility of an infinite loop later down the track which is a big no-no. &amp;#x200B; As for your question, If I'm not mistaken, you want to be able to search your account by name? You can probably create a class called 'Bank' or something to that effect which stores your accounts in an array (or hash) and has a method called find\_account\_by\_name... I'd say that would be the more OO way of doing things
while I agree with that statement, I would also discourage writing a loop with the potential to be infinite.
I'm using Sinatra. My questions are entirely about Javascript.
Some background: I have a \~2TB database with several partitioned tables running in Amazon RDS that I need to maintain long term. RDS does not support the most common way of managing partitioned tables via the excellent [https://github.com/pgpartman/pg\_partman/issues/152](https://github.com/pgpartman/pg_partman/issues/152) . Additionally cron tasks are less than ideal since they depend on a host directly and are harder to manage externally. PgDice is built on top of the extremely useful [https://github.com/ankane/pgslice](https://github.com/ankane/pgslice) gem which provides much of the heavy lifting. The benefit of this gem is that you can call PgDice methods from Ruby directly and thus handle exceptions and alerting with existing tooling such as New Relic etc. without adding another mechanism for alerting and handling failures for cron tasks etc.
Interesting to see [Crystal also possible](https://www.reddit.com/r/crystal_programming/comments/a1sx95/hello_from_crystal_in_aws_lambda/).
Your sample XML indeed does not have any namespaces. That second hash param to `xpath` is for [XML namespaces](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Namespaces) -- which your document doesn't have, so it's not what you want. 
Looks really cool. Excited to start messing around with it. I'm the author of [PgParty](https://github.com/rkrage/pg_party). Wondering if there's an opportunity for some collaboration here. I've wanted to implement automatic partition creation for quite some time.
There is a trend to avoid Sprockets in Rails too, for what it's worth. It just does not pair well with complex modern solutions such as Angular or Vue. There is a Webpacker gem in Rails that is a wrapper for Webpack and its idiotic config files no one can write. Outside of Rails you can try to use webpacker_cli, but it's pretty new: https://github.com/danielpclark/webpacker-cli
nice post showing how all the parts come together. also, good catch on the c extensions. 
&gt;I'm the author of PgParty. Wondering if there's an opportunity for some collaboration here. I've wanted to implement automatic partition creation for quite some time. Certainly! There are some semantic differences between the gems as I'm sure you already picked up on. That being said I think it's worth looking into. List partitioning is something I'd like to support and it seems you've got that figured out. I'll PM you.
Take a look at https://github.com/aws-samples/serverless-sinatra-sample which demonstrates adapting the API Gateway's JSON payload to Rack. Personally would like to see that extracted into a gem. 
Stripe: https://medium.com/byteconf/stripe-is-building-a-ruby-typechecker-d6cd7cee6abf
Vinted: https://www.startuplithuania.com/news/vinteds-head-of-engineering-i-was-not-a-ruby-developer-before-i-came-to-vinted/
Fwiw I think a lot of companies do, they just don‚Äôt advertise the composition of their entire stack.
Yes, you're right. I didnt mean to make it sound like those were the only two options.
Would you ever attempt to try this with a full app + framework?
AWS provided an example using Sinatra, and I assume you can run any Rack based application. Technically you can run Rails in Lambda, but a newly generated Rails app and all of its gems is just under the 250MB size limit for Lambda. Any extra gems or node modules will push it over the limit pretty easily.
I didn‚Äôt get to see this talk in person but it was a pleasure meeting you! I‚Äôll be sure to watch this soon, it looks like an interesting topic. Also it‚Äôll give me some context to all those lemur stickers I have. 
looks fun :)
It is! I did it last year and it was great but sometimes not that easy :) One tip: Only use `irb` for quick results but save your solutions since later on puzzles may depend on earlier solutions. I didn't know that and had to search through my irb history for earlier results... twice ;)
There is also the AoC reddit with its solution megathreads (only read them *after* you have done the puzzle): https://www.reddit.com/r/adventofcode/ Quite interesting to read, especially later on for the harder puzzles. It's astonishing what people do with vim or just regexps...
Thanks for the link! tbh it's quite interesting even now, for example my version is a "bit" longer than part 1 here https://www.reddit.com/r/adventofcode/comments/a20646/2018_day_1_solutions/eau567l/ (Warning: spoilers, obviously).
I know Stripe is Ruby no Rails. I think they mentioned that in [their Ruby type checking talk](https://www.youtube.com/watch?v=uFFJyp8vXQI).
Then you might enjoy reading through the megathreads of last year. If I remember correctly, there was one person who solved nearly all puzzles just using vim and regexps, another using perl and (nearly) *only* regexps. Some puzzles also lead you down the rabbit hole with regards to algorithms and data structures. For example, one puzzle was using a coordinate system and could be solved using complex numbers as coordinates.
I love this. Storytelling is great. Is there more?
Thank you! This is very useful.
- jvm - go - net core
Go is really fast, but somewhat less elegant. You may also write rubygems in Go so learning it is a great investment!
I'm not familiar with Elixir's implementation but in other languages I find TCO to be more dangerous than beneficial. Compilers are often rather picky about when they detect a tail call and as a result you can easily make a seemingly innocuous refactoring that seem fine then explodes as soon as it sees real load. TCO is a highly leaky abstraction. 
There are quite a few site using Hanami Framework, along with quite a few using Sinatra. Ruby is popular in Japan and it is not only used on the web. The problem is I haven't find any info on it. I know Nier Automata uses Ruby / mruby. &amp;#x200B; But by far I think Ruby is 90% Rails.
Interesting! Do you have resources where I can read more in regards to that?
didn‚Äôt abandon ruby but left rails for sinatra and then roda. the benchmarks for roda speak volumes. 
I don't have a particular link handy but one mitigation example is the `@tailrec` annotation in Scala. You can apply it to a function/method and it tells the compiler to spit out an error if the compiler isn't able to generate TCO'd code. I imagine if you google around on the history of `@tailrec` you'll find some better write ups on its reason for existing. 
I switched to Python for machine learning, but it seams to me Ruby would be just as good, except for a lack of machine learning libraries. I‚Äôm considering which libraries I could rewrite as gems, etc.
Wow interesting, will read more on it, thanks man!
Didn't abondon, but wrote some microservices in Elixir/Phoenix.
Didn't abandon but enjoy working in elixir
I'll never stop programming in Ruby. It's just to useful a tool in my tool belt. Currently I'm working in spring on Java and kotlin on the jvm as well as vuejs on JavaScript. Compared to rails, I really don't think too much of spring By the same token I think hibernate is a travesty compared to active record I like kotlin however. It has many rubyisms that make working on the jvm a lot nicer and more fun. 
Eagerly waiting to fully migrate over to Crystal as soon as it hits 1.0 ‚ÄúFast as C, Slick as Ruby‚Äù
I‚Äôve moved some projects over to Go. Personally I like the Echo framework. 
I realized upon reflection that hibernate itself isn't bad, it's really the way spring interfaces with it that's so awful, so that's really a criticism of spring not hibernate. Sorry for casting aspersions in the wrong direction.
There is a Sinatra tutorial right on their page: https://aws.amazon.com/blogs/compute/announcing-ruby-support-for-aws-lambda/ And correct me if I'm wrong, but I think having a background job runner will be essential, which appears to be discussed here: https://www.reddit.com/r/ruby/comments/a1jm46/aws_lambda_now_supports_ruby/eaqgfu1/
BestBuy is probably the biggest. They're a huge Ruby shop.
Rails for work, but Rust &amp; C# (.NET Core) for other projects.
Why would you be using rvm / rbenv in production in the first place?
Well why not. You have another way?
At my previous job, Cloudaper, we used Ruby for a Windows scanning client (WIA). I know, right?! Actually it worked, but the toolchain to make build/an installer is pain and it was decided to rewrite it (though it's possible they still run the Ruby version).
I think the point is production should have one ruby version. If you need a different version you should rebuild the environment. Having multiple ruby versions in prod is a recipe for disaster.
Probably you're right. Question wasn't about multiple versions. Let's say ruby-build vs snap then. Anyway, to have Rbenv or RVM managed ruby on production server, it is a common pattern, take a look at official Capistrano [Rbenv](https://github.com/capistrano/rbenv) extension for example. 
Docker
We used to use brightbox's PPA, then for a short time used rvm's packages (but not rvm) and now build docker containers for deployment which have the proper version baked in. I'm sure some people do use ruby-build in on production servers but it doesn't sound like a very good idea to me. Really I think your comparison should be Snap vs deb/rpm/whatever packages from other sources. Which as long as it's built with the same settings I don't think it really matters, though I'm sure there will be some angry neckbeards over canonical attempting to 'centralize' linux packaging and analytics collection. 
Oh there will be soon enough :) I'll be doing the a talk on scaling Christmas at WaffleJS in SF on Wednesday and turning it into an article later. 
Yep! Same to you, feel free to ping me whenever you find yourself off around SF. 
Why would you deploy a Rails app to AWS Lambda? That's just mixing tech that serves different purposes.
I prefer a "real" installed Ruby (e.g. by the system package manager, or rbenv/rvm/...) because it normally means less problems later on. And should also be much smaller in size.
Nier Automata was written in Ruby!? I've never heard of a big video game use it before, that's so neat!
[SciRuby](http://sciruby.com) initially set out to do this, but I'm not sure about how active the project is at this point.
But why should I care?
The article was super easy to follow, thanks for sharing!
Of course not, because everything is an object. Even classes are objects. So a ‚Äúclass method‚Äù is really just an instance method defined on the Class object. If you‚Äôve ever worked with modules that add methods to both a class and instances of the class, this is actually pretty intuitive.
From the perspective of MRI internals, there is very much a notion of singleton methods, and I imagine this is the case for most other implementations as well. Prior to Ruby 2.0 there was even `singleton_method_added`: https://apidock.com/ruby/BasicObject/singleton_method_added VMs present a facade in which there exists an unboundedly deep singleton class/metaclass hierarchy, but what they're doing is dynamically creating metaclasses as needed, e.g. as you explore into the metaclass hierarchy, or define instance-specific behavior on objects. I think a more interesting way to describe this particular aspect of Ruby is: "In Ruby, everything is an object, including classes. Singleton methods are instance methods of a class object."
I'm not terribly familiar with Snap but why is it 'less real' or 'larger in size' ?
So.. Enum.each was not good enough for you?
Switched to python. Now playing with rust. If I were to go back to scripting, I‚Äôd seriously consider go.
If you install via the system's package manager or rbenv/rvm/..., the installed Ruby relies on many system packages already installed. For snap packages, these system packages have to be inside the snap as well, making it larger. And since some setup must be done by the snap package on invocation (e.g. set up correct paths etc.), some things *may* not 100% work correctly. I haven't played around with snaps much but I would generally use system packages if possible.
Same here. I'll still maintain my Ruby and RoR apps, but anything new I'll build in Elixir and Phoenix, with Vue/Nuxt on the front end if I need the interactivity.
I still use Ruby but I think Go is the natural successor to C and a great choice for system tools &amp; utilities. 
Python and Django. Although ruby is still my favourite language and Python still isn‚Äôt as intuitive and fun to work with as Ruby. However Python has greatly surpassed it in terms of library ecosystem and general tooling. For personal use, I‚Äôll probably always stick with Ruby
What if you have multiple applications running?
The ability to offload server management is nice; there's a similar idea in the [Zappa framework](https://GitHub.com/miserlou/Zappa) for Django. Unless you're in a high traffic situation it can stay cheaper than some other containerization solutions and whatnot.
Still working with Ruby, but I've taken an interest in Data Science recently so I've been spending a lot of time with Python for NumPy and Pandas. I've also got my eye on Crystal, but haven't really spent much time with it yet. 
We do at Square. It's used a lot for infrastructure code and other tools. That said, we do use a lot fo Rails as well. 
I really like Clojure, it feels so right.
Yup, but as someone who just started programming it was a revelation!
Functionality-wise, you pretty much don't have to know it, but it helps you understand Ruby a little more
Thanks man! Glad you liked it :)
This was for learning purpose and is not about Elixir, code samples were just tools to help me get the message across. The title is very clear about what it's talking about
Any interest in an r/ruby leaderboard?
Haven't left Ruby, nor Rails entirely, but I am spending a lot of time with Elixir and Phoenix these days, and Elm on the front-end.
I didn't left Ruby completely, I still maintain some projects based on rails. But nowadays I'm using Clojure and ClojureScript for smaller projects I have. And really love it!
Using the same stack here + graphql
Great to learn Ruby and can be apply to Crystal easily!
Left personal projects in Rails to work in the industry with Laravel. Moaned everyday about little things I missed and had to relearn. Now back with Rails for work üòÅ. Happy dev again! 
Honestly, this is more about terminology. Strictly speaking there isn't a huge difference between classes and modules either; the no-instantiation part of modules could easily go or classes could be "included" too. It was simply a design decision by matz. Ruby is not my language; I would have most likely not done that distinction, but I'd still would have to offer similar functionality (e. g. that you can share and re-use code and code components). But it is the way it is so it really just goes down to terminology. I used to create toplevel directories in my larger projects called class_methods/ or module_methods/ but lately I have started to call it toplevel_methods/ which seems to cover the other two better. E. g. code such as: module Foo def self.bar puts 'hello from Foo.bar' For methods like that.
I wanted to upvote you for the first part; but the second part is a bit strange. &gt; If you‚Äôve ever worked with modules that &gt; add methods to both a class and instances &gt; of the class, this is actually pretty intuitive. I do not find the distinction between classes and modules THAT intuitive. To me it was simply one design decision that was made. One could have also picked another decision here.
It isn't really that important; only thing where it may be important is when it comes to terminology. At the least the "official" terminology imposed by the C API level. The pickaxe used other words in various instances , for example.
Yeah, I admit the title is a bit misleading, I agree with the terminology part. For all we care, class methods still exist (everyone calls them that), but I just wanted to highlight that it is in fact an instance method on Singleton Class under the hood. Not quite sure if I understood your directories part though
How did you go about learning spring? any useful websites you used etc?
&gt; Whats your thoughts about snap Ruby package? It's good that it is there for those who may need or benefit from it. I personally do not need it and will not use it. I compile everything from source, using ruby (evidently the initial bootstrapping of ruby has to be done in another way; which happens by compiling or installing it from some site, usually from source from the official ruby homepage). I do not need any of the above made available through snap because I have exactly the same functionality already as-is. And I can use any version as-is thanks to a managing scheme similar to GoboLinux, e. g. all programs are installed via a versioned AppDir. That is also why I have no need for rbenv, rvm etc... and so on because I have this for EVERY program already, as-is, not just ruby. I am surprised that not more people make use of that and instead default to the limited FHS, such as in debian (or the systemd disaster there; I can not understand how oldschool linux veterans can use systemd productively).
Why not? I would not know why not. And you gave zero reasons why this is impossible, so ...
I don't get this "argument". Why would it not be possible to switch versions? You can always note down which versions of gems you need, either via Gemfile, or on your own (it's trivial; I don't even understand why bundler exists for such a trivial matter).
This is only partially true, though. In particular when you write "install via system package manager" - precisely that has been a source of problems for newcomers, and PRECISELY FOR THAT reason, things such as rbenv/rvm were created. Upstream distributions can make idiotic changes, such as changing the expected paths (see debian) or crippling ruby (e. g. removing mkmf and other things - again, debian is guilty here). &gt; I haven't played around with snaps much but I would generally use &gt; system packages if possible. While I myself can not really recommend or NOT recommend snaps, since I have barely used any of them, I do not see how the alternative to "use system packages" is better IF these are changed and cause downstream problems for the end user - what debian did. And it is very unfair to others. If debian creates problems then it should solve them, not send people to e. g. IRC support channels like #ruby where people have to solve problems caused by the debian team. Many other distributions do not have these problems because they aren't cripple-happy like debian is.
I like to think of Classes as objects, and modules as just a bag of functions, for me that's easier to reason about
I've been wanting one of these for so long. I didn't make one myself because I wouldn't have the time to actually maintain it/take care of it, so I'm glad this is a thing!
My man!
Started writing a new application in spring boot. Read the book, just spring (easy short read) Baeldung has many good articles on almost any Java related topic you could shake a stick at. Every time I ran into a problem I read until I understood the issue thoroughly Rinse wash and repeat.
TLDR: Elixir has no loops That's an incorrect summary, though, and it's the first thing we read. There are for comprehensions and a number of functional programming constructs.
flatpack maybe not snap as its tied to canonical.
Try using a block. expect { do_something... }.to raise_error 
Beyond product shops, [Citrusbyte](https://citrusbyte.com) Is a digital consultancy/agency that uses a lot of ruby (off rails). They tend to favor the right tool for the right job and that‚Äôs not always ruby but quite a bit of their work is. 
Aha! That worked. Can you explain why a blocked except worked but my example didn't? I'm a bit of a Ruby newbie
You are trying to say "this code should raise error". How should Ruby (rspec) check it? It should: a) run your code; b) check which errors it have thrown, if any and c) compare it with the expectation. In order to do so, it should have _a code to run_ passed to it. Now, let's compare: expect { something }.to raise_error It is calling of method `expect`, passing to it the block of (still NOT performed) code. Then RSpec can test it, by running the code (calling the block and catching the errors it may throw). What's going on in this situation: expect(something).to raise_error You are calling method `expect`, trying to pass it _the result of evaluation_ of `something` (e.g., the code which throws an error is ALREADY PERFORMED, and error is thrown by the time you are trying to call `expect`, it is too late to intercept it). Hope this helps.
If you think you're going to rewrite Python machine learning libraries in Ruby, you'd better get started because there's a lot of work to do! ;)
I'd be happy to join
Haven't left but reaching for it a lot less. Kicking and screaming to node.... Adonis and nestjs stopped most of the screaming though. Why? More processing power for select projects that needed it and honestly - seen a huge decline in the Ruby ecosystem.
Oh, yes, I completely realize this would be an insane amount of work and it's very unlikely to actually happen! Don't hold your breath :-)
With you on that but from what I have heard that's at minimum a year off . Add to that a couple years for ecosystem growth (or write too much from scratch) we had to put that way back on the back burner
I‚Äôm not actually referring to the use of modules themselves, but specifically to modules that are designed to add both instance methods and class methods, for example by using [this pattern](http://www.railstips.org/blog/archives/2009/05/15/include-vs-extend-in-ruby/). This nicely illustrates the difference between `include`, which adds methods to the class definition (‚Äúinstance methods‚Äù), and `extend`, which adds them to the singleton class object (‚Äúclass methods‚Äù). So there really is no difference between an ‚Äúinstance method‚Äù and a ‚Äúclass method‚Äù, at least in how they are written. The only difference is where they are defined.
I've had one up: `217857-98ea009a`
Any concrete perf issues or you just like the performant by default thing ?
Thanks!
I get that Debian's ruby packages are not ideal in terms of execution but to be honest I think that outdated versions were a much bigger problem with the system packages, especially for LTS releases. At least this is what drove me to rbenv/rvm. Nowadays, with Ruby having a specified versioning policy it is much better on Debian/Ubuntu and I basically rely on rbenv/rvm only to get additional old/pre-release versions for testing.
Yep. That makes more sense too when you see... module X def foo() 42 end end a = "hello" a.extend(X) a.foo # -&gt; 42 "extend" is designed to add a module's methods to a plain object. When used in a class, it is adding the module's methods to the class object.
Has anyone written an article laying out exactly what would need to be implemented? I'd be very curious.
Hey r/ruby, I started working on this couple days ago to learn more about blockchain and distributed systems. There are many things that I would like to add to make this more robust, please don't hesitate to star the project and hit me up if you would like to contribute :) 
Why ruby version is 2.4.5?
Not for a specific reason. Thats what I had on my system, and wanted to write it down so that same version is used on heroku. We should be able to safely update the ruby version.
Cool project!
No concrete. Fir example. We had a project that required reading and comparing very large CSV files. Just too slow in Ruby even with streamlining and tweaks. Several times slower than node.
Ah yes, I understand it! Thanks for your clear explanation and taking the time out of your day to do it.
I don't understand this - the syntax of elixir is acceptable but significantly worse than ruby's. So you must have had other reasons to use elixir.
And - is your machine already "learning"? I mean python is really where machines learn a LOT. In Ruby, machines can not learn anything right - my machines are now on the level of cats. Soon they go to school and "learn" more ... PS: There could always be more gems in ruby. It reflects the interest of people using the language. I find the whole field of machine learning hugely disappointing, but if you have the time you could create a gem that also acts a bit as a "tutorial" / "teacher"; others could then benefit from it. I sort of try this with two of my own gems in different topics, one being in bioinformatics and the other in a setup vaguely similar to LFS (linux from scratch), just both using predominantly ruby.
https://rubygems.org/gems/sciruby it is not very active. Oddly enough bioruby is also not very active. My own gem is almost already better than bioruby (not yet, I need to add a lot more documentation, polish the code and add more functionality - but it is not that far away considering they had a head start of almost 10 years). For some reason people fatigue VERY easily in ruby. I don't understand why. Perhaps they get confused on the way years lateron - or simply reallife time constraints kick in.
FYI: For an alternative starter do-it-yourself peer-to-peer (distributed) blockchain see the centralbank gem -&gt; https://github.com/openblockchains/centralbank Happy blockchaining.
You don't need to have a finished solution for everyone and everything. You could focus on a simple gem that is useful for some basic tasks and acts as a tutorial and then leave it at that. The advantage here is twofold: - Others could learn from it. - Others could base code off of your code to extend the machine-learning libraries/code. Sort of like a tutor. Without that EVERYONE is going to say "no machine libraries in ruby".
Nobody is writing a tutorial about it in ruby. :)
How do you know your machines are now on the level of cats? That‚Äôs very interesting! Please tell us more.
What about writing up bitcoin in Ruby? It would be great to have a Ruby library.
This is so unique. No one did it before.
Koichi is still working on it. As far as I know the feature and functionality itself will make it into ruby 3.0; the name may change, who knows. But guilds won't be for the next upcoming xmas release.
Left it for Crystal, similar syntax and about 10x faster, the type system and compiler are amazing. You develop in a typed language but feel like a dynamic environment, it really is getting the best of both worlds 
Dou you mind sharing your bioinformatics gem? I might be interested :)
Lack of Funding.
FYI: There's the bitshilling up and coming as a bitcoin alternative in ruby - https://github.com/bitshilling Or universum as an ethereum alternative in ruby - https://github.com/openblockchains/universum-contracts Cheers. Prost.
Thanks, I will check it out. Do you think you could theoretically get a java job now or is the Rails experience completely irrelevant in java land? Let's say a Senior Rails dev took 6 months to learn spring on this own time and then applies for a spring job, is he a junior now?
This is very sad, since the old one was JRuby and had a very high level of compatibility. Plus \_why's artwork and tutorial was in there :-(
Sure, the syntax of Ruby is so expressive and I still enjoy it, especially for basic scripting or stuff over dealing with Bash. Elixir does do one thing better than any other language I've seen, and that is [pattern matching](https://elixir-lang.org/getting-started/pattern-matching.html). It's broken my brain when trying to switch between languages, since it's so powerful and I rely on it so much. Elixir is built on Erlang, which runs on a virtual machine called BEAM. It has a very good concurrency and parallelism story - add cores, and you basically get more performance for free. Phoenix, the popular web framework for Elixir, takes advantage of all the language features, which results in really good out-of-the-box support for WebSockets, which my main project was built upon, so it was a natural fit. Plus we cluster multiple servers and get distributed pub-sub messaging and added redundancy without any external dependencies, again, basically for no extra work. I thought moving away from OOP to functional and immutable paradigms would be difficult or feel like a step backwards, but it's actually made it better to structure growing projects. Refactoring is easier, and there's no implicit state or inherited behavior that you have to know about, because everything is explicit. You know how many times I dug into Rails source code? Zero, because it's a pile of hacks and hooks and implicit state that's impossible to grok unless you're a core team member. Whereas with Phoenix, I dive into source all the time, especially when helping answer questions, to see how the internals work, and you can follow it all the way down, because it's just functions, man. So hopefully that answers your curiosity. I'm obviously biased at this point, but I've enjoyed the transition.
It's pretty active. But Ruby is still going to have less sci/math momentum than Python, presumably forever.
The problem is, it depends a *lot* on your application. I ran an analytics group on Ruby back at OnLive, and all we needed was (part of) SciRuby. But our needs were pretty basic - freeform statistical analysis, but no machine learning. For a given machine learning problem, the question is mostly "is there a good, performant Ruby implementation?" But there are a lot of those different problems.
Hi, thanks to your feedback we have created a benchmark-ips benchmark &amp; displayed the results in the README :) This is now live : [https://github.com/klaxit/fast-polylines](https://github.com/klaxit/fast-polylines)
Looks like you found support. Here is another place to look [https://relishapp.com/rspec/rspec-expectations/docs/built-in-matchers/raise-error-matcher](https://relishapp.com/rspec/rspec-expectations/docs/built-in-matchers/raise-error-matcher)
Can you please edit your post so that it's a well-formatted, complete code sample? I can't see how you've actually tried to access that variable; you're showing the error, but not showing what triggered it.
Obviously you mean on the same production box. That only serves to further increase complexity. I am not here to tell you how to do things, I am just saying that keeping it simple will.........keep it simple.
I don't know that saying "it is a common pattern" makes it a common pattern. If you aren't using multiple versions, perhaps there is a use...then again why use rb-env, in product, if you don't need multiple versions?
What's the argument? &amp;#x200B; Are we in agreement or are you taking the side that though one has a production build configured to a specific Ruby version, it is acceptable to have multiple Ruby versions on that machine.
This has been resolved. \`human\` is in scope; had a typo on my end. 
hey! thanks for attempting to help and pointing out the lack of clarity around my question. &amp;#x200B; The issue was that i was trying to access the variable from inside the it block. At the time, due to a type, it was returning a NameError. 
just offtopic question, what is a minimum RAM/CPU requirement for Elixir + Erlang server machine? I just want to try for a pet project
Not "written" in Ruby, most likely its game engine scripting language uses mRuby, just like many others using Lua for its scripting language.
For development, or production? The requirements are pretty modest, either way. I'm looking at my Phoenix development server sitting around 100MB, and I have two servers load balanced in production, each with 20 WebSocket connections and handling 10 requests/sec at 20ms, that are 200MB apiece.
I mean for production and it looks like quite low. Thanks!
Oh yeah, I'd expect a 512MB instance would take you very far. The BEAM has its own memory management system and garbage collection, and it will gladly grow to fill your system's memory if you allow it, but its garbage collection is also very lazy in the name of performance, so don't worry if the memory usage is overall higher than you expect.
You might want to use a thread-safe Hash like Concurrent Ruby's \[1\] Hash and \[2\] Promises and/or \[3\] thread pools. &amp;#x200B; \[1\] [http://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent/Hash.html](http://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent/Hash.html) \[2\] [https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent/promise.rb](https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent/promise.rb) \[3\] [http://ruby-concurrency.github.io/concurrent-ruby/master/file.thread\_pools.html](http://ruby-concurrency.github.io/concurrent-ruby/master/file.thread_pools.html)
That's a somewhat complicated question and it honestly depends on the person you ask. If you ask an HR person they might see it that way. I don't think anyone with an ounce of experience in the field and certainly not an engineer or anyone technical would see it that way. Now if rails is the only framework/stack you've ever worked in, I might say you were a little junior because of a lack of breadth. The only way to fix that is to try a different ecosystem. In my experience, the more tech stacks you know the more perspective you gain and the easier it gets to pick up new ones. From an interview perspective an HR person won't be able to understand what you say no matter what. A technical interviewer will be able to pick up on both what you know and where your gaps are. Hopefully that helps. Re tooling isn't easy, but it is something a software engineer should do with some regularity for lots of good reasons.
Better make this an issue in the gem repo, here [https://github.com/grosser/parallel](https://github.com/grosser/parallel) so it's findable Reduce your issue to something that is easy to explain/reproduce like \`Parallel.map(\[1,2\]) { [Hash.new](https://Hash.new) { } }\` instead of having readers jump though complicated code and to improve your understanding. Return something dumpable from the block to make it work, since parallel uses Marshal.dump internally which can be seen from the backtrace \`Marshal.dump([Hash.new](https://Hash.new) {})\`
When using forks, the parallel gem needs to serialize the ruby object to send it over a pipe. It uses Marshal to do this, which is what's raising the exception. This makes sense, because Marshal would otherwise need to also serialize ruby code to get evaled, and I don't fault a serializer for not wanting to eval code. I'd either: 1. Strip the default proc (e.g. via \`hash.default\_proc = nil\`) 2. If your workload isn't CPU-bound (e.g. it's IO bound), parallel can process with threads instead.
In my opinion it shouldn't require any changes in Rails, excepting new features (e.g. push). Even that can probably be done by using a sufficiently clever backend/middleware.
I just wanted to know if 2 CPU and 2 GB RAM will be enough as I see it has to be 
What benefits are you expecting in the app server with http/2? You can already get almost all the benefits of http/2 with a pass through CDN setup, which is usually a good idea anyway. 
Rails 5.2 added early hint support which covers that vast majority of use cases for h2 push. 
I'd recommend jruby. There are many multi-threading examples to google. It's easy to get started.
Check out [the Ruby thread gem](https://github.com/meh/ruby-thread) for easy multithreading. You could use a thread pool or a pipe to operate on the list in parallel 
Put that sucka in a thread my man
What kind of work are you talking about? MRI can't execute Ruby code in parallel, so threads aren't useful when trying to "parallelize" computations. https://stackoverflow.com/a/47947764 You'd need JRuby for that. For I/O heavy tasks using threads is still fine and concurrent_ruby has decent abstractions for using threads.
Rack is based around the request/response cycle which makes it very hard to push things to a client without it doing a request. Rails also depends on that. That hurdle has not been overcome yet. 
I think shopify does; they report bugs to mruby so I don't believe they use mruby for rails.
&gt; &gt; &gt; But by far I think Ruby is 90% Rails. Nope, it is about 50%. You can check this by looking at the gems published. I use ruby since almost 20 years (ok since ... 2004 or so) and I don't use rails. You just don't read as much about these folks because we aren't marketing gurus unlike rails folks.
For all of its faults, rack is perfectly HTTP/2-aware (minus push). But don't expect to see it in puma, if that's your question.
Well there's web sockets built into Rails now...
You might find the [parallel gem](https://github.com/grosser/parallel) to be useful. 
Been having a little bit of a problem with day one part 2, works fine using a set or hash but not an array (checking for the dupe)
You gotta meet my friend, her name is GIL
A little more insight: [https://github.com/puma/puma/pull/1403](https://github.com/puma/puma/pull/1403) [https://github.com/rails/rails/pull/30744](https://github.com/rails/rails/pull/30744) &amp;#x200B; Rails 5.2 and puma support Early Hints (and the rest of H2 anyways) &amp;#x200B; nginx does not support Early Hints with Rails/puma: [https://github.com/puma/puma/issues/1570](https://github.com/puma/puma/issues/1570) &amp;#x200B; H2O can be used as an alternative (in a Rails/puma Reverse Proxy setup): [https://h2o.examp1e.net/](https://h2o.examp1e.net/)
You may discover that ruby is not the best language for writing parallel code. You can achieve efficiency in utilising the CPUs through multithreaded/multiworker webservers and background processing systems. 
GIL does not mean you cannot run things in parallel. Yes its not \_true\_ parallelism, but in most cases switching tasks while waiting on some kind of an IO is fine. 
You might like the [concurrent gem](https://kinnrot.github.io/ruby-async-await/) which implements an \`async/await\` API.
Fork a worker and return the hash map in serialized form over a pipe.
Well, the whole point of GIL is to prevent you from running things in parallel, isn't it? Sure, we can still run some things asynchronously, and it's fine. But it's a whole different talk about concurrency, parallelism and how GIL works with FFI in Ruby.
The `httpx` gem supports HTTP/2: https://gitlab.com/honeyryderchuck/httpx
Several requests for JSON from an API could see benefits from this. A lot of front-end frameworks could make multiple API calls per page load.
That has no impact on the app server, for that all you need is the termination point from the client to be h2 (proxy, web server, CDN, etc).
Let me introduce you to my pals, JRuby and Rubinius. They don't know and don't care about your friend. :P
Seems like it requires complexity and setup knowledge though. It would be nice if it could be done out of the box. 
Can you give a quick example of this workflow?
https://github.com/socketry/falcon is attempting make steps
Hey everyone, I just launched Stealth 1.1, the open source chatbot framework I've been building. If you haven't heard of it yet, it's inspired by Rails in that it provides an MVC architecture for your bot. Version 1.1 adds some cool new features like reply variants that lets you utilize a single codebase for your bot across multiple messaging platforms. &amp;#x200B; I know docs can be a little daunting, but I am working on some screencasts that I hope to share soon. Thanks for checking it out! Major ‚ù§Ô∏è for the Ruby community.
I would also consider Sidekiq for a long-running task.
&lt;3 Stealth
üò±been waiting for this
Nice! I will have a look at it! Thanks for posting this information. 
The formatting is terrible here, making it really hard to read, but assuming that you can define an `initialize` method for `SomeClass` you could inject a dependency in your test. def initialize(file_checker: Pathname) And later in the code you'd just use `file_checker.new('config.yaml').exist?` That way your test can use some other implementation where you can pass in `ExistingPathName` and `MissingPathName` classes for success and failure paths. Or maybe you pass in an object that responds to `exist?` instead of passing in the name of a file and provide success and failure for that in the tests.
ugh! I opted into the new design hence the problems with formatting i don't understand why though given that my post was written using markdown. Trying to edit it now
JesusChrist. Relatively new to reddit so signed up for the redesign option. Been getting comments about my formatting being off. Opted out of redesign, trying to format code and WAHT IN THE BLAZING HELL?? How the hell have folks been writing code blocks on this site? &amp;#x200B;
We have cross app subscribers to listen. APP1 publishes to SNS -&gt; SQS -&gt; APP2 subscribes and fetches from SQS We still use sidekiq for in app async work
JRuby or Rubinius.
&gt; it's not really an I/O blocking function &gt; in most cases switching tasks while waiting on some kind of an IO is fine
I don't really get building an app with 'serverless'. We use AWS lambda for a few light things, mostly automating some stuff with logic needed. But, why build an entire app on this stuff? I don't get the benefits of it and it seems like there are a ton of downsides. 
I really don't understand what you mean, if your goal is 'fast load time' then you _have_ to understand CDNs and general network architecture, there is no way around that. Also your termination point most likely already supports h/2 anyway, e.g. if you have a pair of servers behind an AWB ALB then you have H2 support already. 
Low attack surface area. 
Can you elaborate? The majority of the 'attack surface' is in your app, not in the networking layer. 
Serverless encourages a microservice architecture where it‚Äôs easier to both see rate and provide fine grained control of application processes. Servers are submerged and so their security is passed off to another vendor (Amazon). Serverless encourages ephemeral processes. In the case of AWS, API gateway makes a call to a lambda. It runs it‚Äôs process and then vanishes. There‚Äôs nothing on the application side to hack in to. The persistent part is walled off in AWS infrastructure. It‚Äôs also apparently better in terms of cost and scaling, but I don‚Äôt know much about that. Whether serverless is really as secure as some claim, I don‚Äôt know. I‚Äôm not a cyber security expert and am parroting the justification I‚Äôve heard. Serverless is a bit of a pain in the ass. It‚Äôs also great for small services that don‚Äôt need persistence.
Not to be confused with Firebase, which is NoSQL.
&gt; Serverless encourages a microservice architecture where it‚Äôs easier to both separate and provide fine grained control of application processes. Why do you think that is a good thing? For whom? What situation would you be in where such separations are a 'good thing' where you can't also have 1+ devops people around? &gt; Servers are submerged and so their security is passed off to another vendor (Amazon). Security of what exactly? Most security issues are in the app, not the 'server' (whatever you mean by that). &gt; In the case of AWS, API gateway makes a call to a lambda. It runs it‚Äôs process and then vanishes. This is not correct. &gt; There‚Äôs nothing on the application side to hack in to. The persistent part is walled off in AWS infrastructure. This is ________really________ not correct, flat out dangerous statement. &gt; It‚Äôs also apparently better in terms of cost and scaling, but I don‚Äôt know much about that. It's only cheaper in situations where you can't offset the cost of a half decent devops person. After which it is vastly more expensive, particularly with any sort of performance SLA. &gt; Whether serverless is really as secure as some claim, I don‚Äôt know. I‚Äôm not a cyber security expert and am parroting the justification I‚Äôve heard. Serverless is a bit of a pain in the ass. It‚Äôs also great for small services that don‚Äôt need persistence. Why would you feel the need to reply to a comment, putting forward opinions, then cap if off with "I don't know WTF I'm talking about?". Maybe just don't comment? 
Okay. Cool talking to you.
Ruby/Rails selling point is ease of use and developer happiness. Requiring developers to also learn a bunch of extra dev-ops stuff instead of fixing the features out of the box is counter intuitive. One of the biggest arguments I see against this stack is speed / performance. Anything that tackles that concern will help.
Directly serving static assets is already a _really_ bad idea for your rails app so you _really_ should already be using a CDN for those. Chances are that CDN already handles H2 so again I don't get your point. 
Maybe try not being such an asshole.
What class is "file"?
Good to know this option exist.
This is cool
For this using a regex is usually best.
How utterly useless. People should do something more productive.
&gt; In a lot of places in a Ruby code we already have something like... &gt; &gt; # @param path [String] &gt; # @return [true, false] &gt; def exists?(path) &gt; path.is_a?(String) or raise ArgumentError I don't - beuecase I think it's total crap to taint comments with useless markup used for rdoc/yard like this. But even then this is only about comments - there is a difference to code. The original question by MB_Zeppin still stands - why use this? I have no idea. It seems utterly useless to me and a waste of time. &gt; some new ideas can be imagined to integrate with current &lt; language idioms and intuitions. HOW does the specifid API "integrate" at ALL? This is my general problem with types. They do not "integrate" at all. They are like an ad-hoc afterthought and, even syntax-wise, are just ugly and add burden for no real net benefit (if you already wrote good ruby in the first place; if you start with shitty code then literally any 3 years old can make that code better just randomly)..
Looks like typical rails code you write here. I knew I am not the only one who feels that rails is alien to ruby, syntax-wise - even though it is evidently ruby code. Actually your variant is even worse than rails code since you take rails-like API and bolt "types" onto it. How horrible.
&gt; I imagine it‚Äôs also useful when ingesting data from APIs and other &gt; external sources where you genuinely need to expect a certain &gt; shape of data. Now you confuse me - how is it that we could only do so via types and no other way? 
&gt; Are gems like this for people that don't write unit tests? I don't write unit tests - and I find the library awful and useless. So, no - I think it is a general thing that this is useless. But I think the author is just experimenting with ideas so that's fine. Should only add a disclaimer like "Warning! Useless code. Don't use it." That would help a little.
&gt; BTW, to_s is almost never sane! because any Ruby object has to_s, unless &gt; object's class takes special precautions of undef-ing it, and you may be &gt; very surprised with the effects of to_s-ing something inappropriate. Complete rubbish what you write. .to_s is perfectly fine - if you need a string representation of your object at hand. So in these cases it is 100% fine. I honestly don't get from where you are coming from telling people that .to_s is an anti-pattern. 
If you were aware of it then you wouldn't try to want to change ruby into what it is not - see your strange claims about .to_s being bad.
Agreed.
Yup, agreed. I think the author was more like trying things out. Even the API feels like an experiment-job.
&gt; It's how I imagine Ruby if it was typed Syntax-wise there are so many differences. I've seen other type-proposals to ruby and they didn't really look anything like TypeScript, so I am not sure why you draw the connection to it, coming from Ruby.
Just finished implementing Sinatra application on AWL Lambda [https://github.com/aws-samples/serverless-sinatra-sample](https://github.com/aws-samples/serverless-sinatra-sample) &amp;#x200B; this is super cool. Sinatra running on Lamda :) &amp;#x200B; \*\*note:\*\* reminder that Sinatra running on Lamda (as well as Expres.js running on Lambda) is more like "try it out" feature of AWS Lamda not really what Lamda was designed for . Yet pretty neat that it works so easily :) 
That is incorrect. You would know that if you would have watched some presentations. What matz said was in regards to type hinting - e. g. in documentation. What he spoke about were projects of implementing types; one approach was to add that information to another file (e. g. separate from .rb). What matz also said specifically was that types violate the Dont-repeat-yourself tenet. But that was not the only criticism. Syntax-wise type add burden to ruby. What matz then said lateron is that he does not want to regret adding types to ruby years lateron. Python has been going towards more types and I am already 100% sure that this won't work for them. How can I be sure? Because the libraries at pypi do not really make use of that. (Even if you include inertia, e. g. python2 still used, new libraries still don't include this bastardized joke of types that python is using, or at the least some people in python want to use). It is MUCH better to say no early on, then to add something that is hard to remove because some people may depend on this crux.
Yeah - type-people hate ducks. :(
Agreed! Although it would be interesting to have two variants of ruby too. Sort of like ruby+crystal (though not crystal ... some of the syntax changes in crystal confuses me).
&gt; Learning to build a modern web application is daunting. Ruby on Rails makes it much easier and more fun. It includes everything you need to build fantastic applications, and you can learn it with the support of our large, friendly community. Literally the text on the homepage. It is my understanding you can get http2 out of the box in C#, Node, Elixir, Erlang, and Java without having to learn about CDN, reverse proxy, etc.
You do rely on the description to give enough of a clue about the return type (unlike a fully-populated YARD definition, say). But you picked an example that [seems to do a better-than-average job](https://api.rubyonrails.org/classes/ActiveRecord/Scoping/Named/ClassMethods.html#method-i-all): &gt; **all()** &gt; &gt; Returns an [ActiveRecord::Relation](https://api.rubyonrails.org/classes/ActiveRecord/Relation.html) scope object. Though note those methods arrive on Relation via included modules, which you have to explore in turn to find them. Sometimes that sub-grouping makes sense in the docs, and sometimes it's an unfortunate--or potentially confusing--leakage of implementation detail.
Not a direct answer to your question, but IMO binding.pry is a better way to get this kind of info. It starts a repl in the middle of whatever you‚Äôre trying to debug. ‚Äòobject.class‚Äô will tell you the class of what you‚Äôre working with. ‚Äòls object -m‚Äô lists all the stuff on the object, with the -m filtering it to just methods. 
I'm not saying it's what Ruby would look like if it were typed, I'm saying my experience with TypeScript is how I imagined Typed Ruby would be like. It still all of the duck typing, modularity, blocks, etc., just with strict contracts for the duck typing. Imagine that you get all of the same power and flexibility of Ruby, except now all of those hashes you pass around as options have compile-time checking. Rails has tons of options hashes, and even after 8 years of Rails, I'm still constantly looking at the docs for what the options are. With types the way TypeScript implemented them, your compiler and IDE can verify the duck typing for you, which prevents a lot of surprises. JavaScript's shitty language design has plagued me for 20 years, so I was very skeptical of TypeScript, especially coming from Microsoft. However, I am incredibly impressed. I think it's a very well-designed combination of duck typed and strongly typed that brings the strengths of both rather than diminishing either. I wish more languages would take some inspiration from it (Elixir, Ruby). Now when I'm writing Rails code, I miss it all the time.
Or just call .methods on User.all 
Honestly, why are you being such a dick. If you know better than me, why did you ask the question in the first place? So you could puff your chest and prove your superiority? Grow the fuck up and get over yourself.
Building on what some others have said, from a console: What does it return? `User.all.class # =&gt; User::ActiveRecord_Relation` Where is the method defined? `User.method(:all).source_location # =&gt; [...activerecord-4.2.10/lib/active_record/scoping/named.rb", 24]`
1. You misspelled Nate Berkopec‚Äôs name 2. I‚Äôve avoided Heroku CI because I believe it doesn‚Äôt support chromedriver for Rails system tests. Do you not use system tests or do you have a workaround?
Probably that the pg libs are not on the Lambda server: &gt; Requirements &gt; PostgreSQL 9.0 or later (with headers, -dev packages, etc). https://bitbucket.org/ged/ruby-pg/wiki/Home
Thanks for noticing that typo, it's fixed now! It seems that using chromedriver on Heroku requires a [buildpack](https://devcenter.heroku.com/articles/heroku-ci-browser-and-user-acceptance-testing-uat#testing-with-selenium), but historically our end-to-end testing was done on Circle CI so we never faced that issue.
You are probably right. I was thinking of creating another docker image with this information but then I may get away from being able to test since it the existing Docker image I assume follows AWS Lambda. Does anyone know if there is a workaround or basically Ruby will never be able to contact a backend DB, well Postgres to be specific. There is a gem for DynamoDb aws_record but I want to use a SQL server not a NoSQL server.
So you run both Circle and Heroku CI? (I'm assuming you're the author)
Nice article, a couple of comments: 1. You cover several possible awful ways to implement the feature so I was very glad when you finally got to the "good" solution at the end. 2. Why not a middleware pair that knows how to pass all RequestStore attributes as a child hash within the job payload? Now you can add all sorts of contextual data for the job (including user) and access it via RequestStore inside and outside the job.
What's wrong with this? class DeliveryController &lt; ApplicationController def update # update attributes DeliveryUpdateWorker.perform_async(params[:delivery], current_user.login) # render delivery end def destroy # delete attributes DeliveryDeleteWorker.perform_async(params[:delivery], current_user.login) # render :ok end end I consider your abstraction worst than the non-DRY code
Is there any way to put gems in a lambda layer to allow for inline editing? 
If somebody on my team wrote this, I would immediately reject the PR. Your initial implementation was clear and to the point. It was obvious what was happening and why. Your solution (read: abstraction) is full of unnecessary magic and leads to hard to debug code later on. I don't understand what was wrong with explicitly passing in the current user.
Studies have shown that cycle time is one of the most important metrics contributing to expected success/failure of software projects. So, the longer it takes you to iterate (design, change a feature, get feedback, repeat) the higher the chance that your product will fail. In that sense, waterfall is the failure mode of agile. Agile projects that fail to keep a low cycle time approximate the results of waterfall. 
&gt; I don't understand what was wrong with explicitly passing in the current user's info Explicitly passing in the `current_user` makes it more likely to mess up: You could accidentally pass in another user leading to security issues or you could forget to call `.login`, leading to (harmless) runtime errors. None of this is likely, but it's still a valid point pro abstraction. That being said, I would've rejected the PR as well. Replacing a method argument with a hash lookup should have a very strong reason.
It's called 'imposter syndrome' [https://www.codingdojo.com/blog/programmer-imposter-syndrome/](https://www.codingdojo.com/blog/programmer-imposter-syndrome/)
To find last Wednesday, you could use `Date#downto` - it steps over days backwards one day at a time. ``` last_wednesday = Date.today.downto(today - 7) do |date| break date if date.wednesday? end ```
Hi! I'm also working on baking this directly into SAM CLI support. Stay tuned for that :)
This is correct - there are precedents for bundling binary dependencies or including them as a layer. Unfortunately, it's more than just a bundle install I'm working on some examples and hope to have them posted soon.
We've used both in different combinations over the past years, but unit tests were mostly ran on Heroku and even before parallel option was available, so we felt the need to develop our own test profiling solution to save time ([TestProf](https://www.reddit.com/r/ruby/comments/a3cm26/big_on_heroku_scaling_fountain_without_losing_a/)).
The downsides of bailing early are that you don't get references, you can't really put it on your resume and you had to quit your current job to do this one and are now unemployed. The biggest thing for me would be leaving steady employment for employment that I know is only going to last 8 months. Getting the senior/lead title on your resume is helpful in getting better jobs in the future though, so confidence aside if you think you can do the job then go for it.
My current position is also contract, so definitely not steady, and most of it isn't actually rails work anymore. There's a good chance of extension or turning to permanent after the 8 month one too.
&gt; Looking at it, it all seems like straightforward stuff that I could probably do, but I'm not at the stage in my career yet where I'm brimming with confidence. So what makes you not entirely confident? One thing you didn't say is what they'll expect you to _do_ with that codebase. Does it have lots of problems that need to be fixed? Is there an existing list of features they already know they want added? With a timeframe/schedule? I think one of the biggest thing you are probably missing at that stage in your career is the ability to estimate how hard it will be to do something, how long it will be taken. Which _to be clear_ is something hard for _everyone_ even with more experience. But we get a _bit_ better at recognizing a train-wreck in waiting. Like, if they are expecting your productivity to be at a level that would be unrealistic for _any_ developer, and/or for you specifically. If it seems like straightforward stuff you could probably do, then you probably _can_ do it, possibly by _figuring out_ how to do it (which is what we all do all the time). My only concern is if they are expecting _timelines_ that are just plain unrealistic -- or if they are giving you an app to maintain that is totally broken in various ways and needs to be seriously improved _immediately_. Which is a not uncommon thing to wind up happening to a developer in this sort of situation even if they are more experienced, but being more experienced can give you the experience to _recognize_ it before taking the job. 
Cost, at least from a startup perspective is a big reason to have Lambdas process REST calls in my situation. Overall ELB, NAT gateways, maintaining updates to instances, all cost time and money. So instead of going through and automating creating new AMIs with new packages, or even if all is automated, scheduling notices for customers. For a medium to large company it costs a lot less to go with API GW + Lambda, of course there is costs to go into serverless.
Cool - I did not know about #downto.
You can try using the [postgres-pr](https://github.com/mneumann/postgres-pr) gem instead.
I did try using that gem but I gave up because I don't trust a gem when the last time it was updated was 2015.
That would be amazing to see in action. I do know I can zip up the different folders like vendor/bundle into a serverless config (I am using Serverless not SAM) but I didn't know if I could somehow inject the reliance on the postgres libraries that are needed. It would be amazing if someone did figure it out and got it running.
There certainly is value to not managing infrastructure, but there are various options between lambda and managing your own VMs (or bare metal). Various PaaS options (e.g. heroku), container deployment options (e.g. GKE, Fargate, etc, etc). I also wouldn't under-estimate the cost of building an app around lambda, it imposes a lot design choices on the application leaving you at least somewhat locked into the architecture and makes some things much more difficult (background workers). If you're 'medium to large' I'm sure you have someone capable of creating dockerfiles and setting up GKE / Fargate / whatever which leaves you with a huge amount of flexibility in the deployment and architecture of your apps. 
You can use `Date#wday` to get the number of the day in the week. I'm not quite sure what you're trying to do after that
This is not a internationalization-safe method, but... subtract the day of week from the current day to get Sunday. Then subtract 4 days to get Wednesday. now = Date.today payweek = (now - (Date.today.wday)) - 4
It's a contract. If it doesn't work out, you move on to another one, and you explain that the contract wasn't right for you. The upshot is that if you \*are\* ready for it, it's a good career move. Go for it. 
&gt; I'm not at the stage in my career yet where I'm brimming with confidence I've been programming for thirty years and I'm not brimming with confidence. What I do have is a three-decade back catalogue of mistakes to reflect on. 
Why not use multi-stage docker builds to build and install the pg gem? Seems like you need to bundle dependencies anyway.
The problem is that I am not sure if I am getting too far from the AWS Lambda build. From what I understand is that you have to zip everything up into a package (to push to Lambda), which makes sense, however, I am not sure how to handle zipping up what is necessary for the postgresql gem and I am afraid building a new docker would solve the local building problem, but not the AWS Lambda deploying problem.
It's good that you are being honest and humble with yourself. Thsoe are very good qualities to have. That being said, every time I have felt the way you do about a project I ended up doing just fine and learning a ton. It's important to put yourself just outside of your comfort zone in order to grow and develop. If you aren't a teeny bit worried about new projects, you aren't growing and progressing. Do your best, be honest and up front. If you end up feeling in over your head, no biggie. You can just have a simple conversation about it and say, "Hey you know I felt really good about this when we started but as the project has gone on, I am really not entirely confident in my abiltities blah blah" and you can separate amicably. That's pretty unlikely though. I'd definitely go with the 'screw it' attitude and give it a shot.
I'm working on a side project that's headed in the same direction. I'm considering using CodeBuild and CodePipeline to package it up the lambda with native extensions. For what it's worth, if you wanted to go down the road of using posgres-pr, the Sequel gem [https://github.com/jeremyevans/sequel](https://github.com/jeremyevans/sequel) appears to support it alongside the regular pg gem. [https://github.com/jeremyevans/sequel/blob/master/lib/sequel/adapters/postgres.rb](https://github.com/jeremyevans/sequel/blob/master/lib/sequel/adapters/postgres.rb) That's some assurance when an actively maintained gem is using it. 
We use chrome driver for our rails feature specs running on Heroku CI. Outlined here: https://devcenter.heroku.com/articles/heroku-ci-browser-and-user-acceptance-testing-uat#testing-with-selenium
It will probably be easier for you to use spot instances in order to reduce costs than migrating your app to lambda, even if you make lambda work you're basically porting your monolith to lambda which kind of misses the point of having the ability to scale each function separately, if you go the lambda way you need to start thinking differently 
yep do it, i would.. 
From my experience ‚Äî if a company offers a "lead" position to Junior/Mid level developers they've got barely maintainable codebase. Also they are probably cutting costs which is not a good sign Last but not least: if you'll be a lead, then you probably the most skilled developer there (if not the only one). It will slow down your growth. Having more experienced colleges to talk with is vital for fast growth
&gt; That‚Äôs why I made a shell script (yeah, Rails generators are &gt; overkill) that creates a new app from a boilerplate app &gt; I preconfigured I do not use rails (don't need it; ruby handles all my web-related activities nonetheless) but this dude is a clown too. He uses rails... thus uses ruby ... AND THEN HE GOES ON TO WRITE A SHELL SCRIPT??? This is why rails is bad - it attracts people who do not understand or even use ruby. Why would he want to write a shell script for this? I assume because he could not write it in ruby due to lack of knowledge.
The job sounds uninteresting to me so I can not give any advice on it. I think it depends on whether you want to invest those 8 months. You'll get the things done during that time, don't worry. I would not go into the job with that attitude of wanting to bail out early - that would not work. Really you shouldn't be so concerned with failure. There are only two things needed here - time and knowledge. As you have (a) time, (b) can be gained. You may have to invest a little more time early on; or perhaps even before you start to take the job. I can't do a recommendation on the job itself, though, because I myself would never have the faintest interest in that kind of job to begin with.
I love you man, you crack me up. üòÇ Each language has its own problem space. Shell scripts are good at moving files around, interacting with other CLI tools and... interacting with the shell (no kidding). Using the right language for the right problem space will result in terser code. Try the same in Ruby and it will probably be longer. Same with `awk`, it's good for one-liners if you can apply it to the right problem space. It's all about choosing the right tool for the job.
Sorry I do not understand what you are saying. Are you saying that because of the gems / dependencies that I would have to rely on, that the functions wouldn't scale because they would all still be tied to all of these gems? I still think it would save some money in the long wrong where as spot would reduce cost, however, perhaps spot is the way to go given the newness of Lambda layers. Thank you for your input.
I have taken a look at the Sequel gem and I wouldn't mind using it however I really wish Sequel had its down postgresql connection that it could establish. I read this in the main github gem page that you mentioned /sequel and I noticed it did need pg. 
It has been all day and I have no idea how to use my Rails 5 API-only app on Passenger+NGinx. That's the problem! There are not enough guides to do that. Guides tell you how to deploy an app with the assets in public directory but the API is not working. &amp;#x200B; What do I have to change? Nginx config? Setup a Upstream server? If yes then why? And on which port is my app running? &amp;#x200B; I feel like Sandra Bullock swaying away in space in the movie gravity. Nothing works and I am running out of time. 
I'm pretty sure that Waterfall killed Waterfall.
Did you manage to fix this? I'm getting it on every command, and I'm starting to get sick of it
Do you have any sources for those studies? I'm really interested in reading about it.
Very simple example would be def calc_result(out_pipe) # do calculation here and return the hash or whatever end def main_func p_r, p_w = IO.pipe pid = fork { p_r.close; p_w.write(calc_result.to_json) } p_w.close # do the main function stuff here Process.wait(pid) res = JSON.parse(p_r.read) # use the `res` here end Probably it's missing some stuff but this is general idea how to do this. I can recommend [this book](https://www.jstorimer.com/products/working-with-unix-processes) as a fairly good introduction on this topic. 
Hello Enumerable\_any, We missed to add the complete problem context in the blog. We've updated it now. Please check [https://gist.github.com/neerajdotname/bdbf7a51b84377539439b33dd93b7694](https://gist.github.com/neerajdotname/bdbf7a51b84377539439b33dd93b7694) for the reason behind passing the current\_user by default.
My dim recollection was seeing someone (authoritative) talk about it in a google talk. I tried to find something quickly on the internet, but I didn't find anything I would consider good (e.g. comparison between real software projects with measured cycle times). I did find a few studies that used simulations to support the claim, but that seems weak to me.
Hello mperham, We missed to add the complete problem context in the blog. We've updated it now. Please check [https://gist.github.com/neerajdotname/bdbf7a51b84377539439b33dd93b7694](https://gist.github.com/neerajdotname/bdbf7a51b84377539439b33dd93b7694) for the reason behind passing the current\_user by default.
Fair enough, thanks for taking the time to properly explain the context. Using `Thread.current` for that purpose seems pretty dangerous, though. You'll always have to look out for people using threads to speed up I/O heavy code because that would break the `before_save` hooks.
Hello edgarortega, We missed to add the complete problem context in the blog. We've updated it now. Please check [https://gist.github.com/neerajdotname/bdbf7a51b84377539439b33dd93b7694](https://gist.github.com/neerajdotname/bdbf7a51b84377539439b33dd93b7694) for the reason behind passing the current\_user by default.
That's why we used [RequestStore.store](https://github.com/steveklabnik/request_store) to access \`Thread.current\` in a thread safe manner :)
I'm not worried about thread-safety. `RequestStore` uses `Thread.current` under the hood, so it has the same problem; creating new threads will effectively clear the `RequestStore`: irb(main):002:0&gt; RequestStore.store[:foo] = 23 =&gt; 23 irb(main):003:0&gt; RequestStore.store[:foo] =&gt; 23 irb(main):004:0&gt; Thread.new do irb(main):005:1* p RequestStore.store[:foo] irb(main):006:1&gt; end =&gt; #&lt;Thread:0x00007f894b9c75f8@(irb):4 run&gt; nil irb(main):007:0&gt;
Hello ezekg, We missed to add the complete problem context in the blog. We've updated it now. Please check [https://gist.github.com/neerajdotname/bdbf7a51b84377539439b33dd93b7694](https://gist.github.com/neerajdotname/bdbf7a51b84377539439b33dd93b7694) for the reason behind passing the current\_user by default.
So, you just want to know how many days to Wednesday? This will shift payweek to be zero on Wednesday rather than Sunday. &amp;#x200B; payweek = (3 - now.wday) % 7
Rails is great because its a coding / web friendly answer to MS Access. It can do 98% of what in a few strokes, but coding by convention is seriously spooky stuff. 
Thanks for pointing that out. We don't use threads in our application as of now.
Yeah that's more of an advanced thing when you already know what you want. I would definitely not recommend that to a beginner.
I wish I did
tl;dr: He runs `git clone git@gitlab.com:jeromedalbert/boilerplate-rails-app.git` instead of `rails new`. But since that's a [private repo](https://gitlab.com/users/jeromedalbert/projects), I cannot judge how sensible this idea is.
:(
WE recently moved our application from Heroku + CircleCi + bunch of Heroku elements plugins to AWS (codebuild, ec2, cloudwatch and etc) and the total monthly bill got 10 times lower. I guess it's ok if you have 1-3 devs in your team but if you have a bigger team it shouldn't be a big deal even without having dedicated DevOps engineer.
"TruffleRuby runs Rails, and passes the majority of the Rails test suite. But it is missing support for Nokogiri and ActiveRecord database drivers which makes it not practical to run real Rails applications at the moment." Really can't try it until that's been addressed.
I think it is the Sulong part ( Translate C from LLVM into GraalVM byte code ) that is holding up. The team at TruffleRuby really want it to be a drop in replacement without any tinkering. I sort of wanted to ask on Twitter about running Rails but I was afraid of being too annoying asking the same question in every TR release. So we just have to wait.
Alright - time to test this so that the x-mas release goes smoothly.
"X-mas Release"... Sounds like a nightmare I once had... Is that not a Friday afternoon release, times 100?
Anyone tested running via bundler (bundle exec ...)? Will have to wait until this evening to compile and try myself. 
[https://gitter.im/graalvm/truffleruby](https://gitter.im/graalvm/truffleruby) is a great place to ask questions like that. very approachable people.
you might want to ask that question in [gitter](https://gitter.im/opal/opal)
Thx, but asking the same question every few weeks isn‚Äôt really helping. So I thought I just let them get on with their work. 
&gt; Additionally, for projects in which there's no real point in delivering preliminary working versions or additional features besides the main goal, Waterfall is also the way to go. Totally missing the point. 
Try it on Heroku! https://twitter.com/schneems/status/1070784574081261568
I'm get to compile the Heroku release of Ruby 2.6 this year for the first time ever. üéÖüéÑüéÅ
This is really interesting, thanks for sharing. It was interesting to work out the implications of forking, closing stdin in the forked process, yet using stdin in the main process to read stdout from the fork. I've not used `fork` before.
Actually, it's probably a good thing since most developers/companies won't be working during Christmas. That way the Ruby team can catch most bugs before the vast majority of people upgrade.
I am really pleased to see this and they have been really responsive to fixing issues. Travis support is now simple (via RVM) and I'm adding support to `async`/`falcon` and everything in between. A lot of specs still failing, but it's progress!
I guess most people are waiting for the upcoming Rails optimizations üöÄ "As of Ruby 2.6.0-rc1, we achieved 1.7x faster performance than Ruby 2.5 on CPU-intensive non-trivial benchmark workload called Optcarrot https://gist.github.com/k0kubun/d7f54d96f8e501bbbc78b927640f4208. We‚Äôre going to improve the performance on memory-intensive workload like Rails application as well."
I tried the new 2.6.0-rc1 with the specs of www.saashub.com Raw (and not scientific üôà) results: 2.6rc1 was ~8% faster compared to 2.5.1 without JIT and was ~24% slower with JIT p.s. I'm aware that specs are not a good example of using the JIT enabled ruby.
It's expected that Rails will be slower at this point with JIT. The implementation is still a work in progress. If you have a small example program (not rails) that is slower with jit enabled k0kubun would like to know. Right now even a "hello world" rails app is a bit to unweildy to optimize. 
You can run rails now, a default `rails new truffle_app --skip-spring --skip-bootsnap` will install fine (at least on my machine). I think you have to install libxml2 via homebrew for nokogiri but that's it. In terms of running stuff, sqlite seems fine and pg will install and some things work but it seems to throw exceptions in migrations. It does seem fairly easy to crash it with load testing tho. 
I haven't used Ruby on Lambda, but based on a quick read of the AWS page on it, you'd do `bundle deploy --install` and then zip up your ruby code + the bundle directory to get all the gems, including the pg gem which you already compiled (using a docker image or something). This is similar to how it works with Python anyway - some Python libraries require native compiled code, so you must do that in advance and zip them up with the Python Lambda code. Not sure why you are worried about "getting too far from the AWS Lambda build" since it's just Linux. You can use the AWS Linux docker image (there is one for Lambda in particular) and then install the tools you need to build the pg gem, and then compile it in that (extended) image using `bundle install --deploy` and copying out the result. You should only really need to do this one time ever, so after that just keep it around every time you need to re-zip your lambda.
I‚Äôve got some bioinformatics programs that I‚Äôve written that sometimes make the JIT run slower. I‚Äôll do some performance testing to isolate them down to a smaller size. As for the JIT warm up time, should I just save the JIT code in between runs?
I liked it, thanks!
On behalf of the community. Thanks buddy
Could another invite link be made? The one in the OP expired. 
Can you share any of the code? Either put it in a public repo or you could put it in a private repo and give him access to it. I think he would be interested even if it's not super small. Here's his original call for slow examples on twitter https://twitter.com/k0kubun/status/1060423381021937664
Actually I thought I had it right. I did a build install --deployment on the build-ruby2.5 after I installed the postgresql binaries that were needed to successfully bundle in pg. docker run -v "$PWD":/var/task -it lambci/lambda:build-ruby2.5 /bin/bash -c "yum -y install postgresql-devel postgresql-libs ; bundle install --deployment Then I ran the docker container echo '{ "status": "ok" }' | docker run --rm -v "$PWD":/var/task -i -e DOCKER_LAMBDA_USE_STDIN=1 lambci/lambda:ruby2.5 status.lambda_handler { "errorType": "Init\u003cLoadError\u003e", "errorMessage": "libpq.so.5: cannot open shared object file: No such file or directory - /var/task/vendor/bundle/ruby/2.5.0/gems/pg-1.1.3/lib/pg_ext.so", I wished it would have worked but it did not. Perhaps the reason is because postgresql installes the file in libpq.so.5 natively on Amazon Linux? I am not sure. If anyone has any thoughts let me know.
Sorry about that, https://discord.gg/UyQnKrT I edit the original post as well
I am unable to install nokogiri on this ruby version (MacOS + RVM) Already run xcode-select --install Anyone got a fix? &amp;#x200B; Also not sure why BigDecimal.new is absent
I think the core difference is that when ruby is released users are not getting the new version automatically, which is not the case for other things (e.g. web apps)
Excited that for Sequel there seems to be only one issue remaining: https://github.com/oracle/truffleruby/issues/1507
indeed, the fact that `BigDecimal.new` is gone is problematic, but It was deprecated in a previous version. Although for some reason a rails project of mine fails when trying to use the `get_process_mem` gem, which in theory [tries to handle this](https://github.com/schneems/get_process_mem/blob/master/lib/get_process_mem.rb#L12). I suspect it's being autoloaded, so `respond_to?` does not know about that.
&gt; PS: Due to duck typing design, Interface Segregation and Dependency Inversion principle are not relevant in Ruby. How is duck typing relevant here?
&gt; Due to duck typing design, Interface Segregation and Dependency Inversion principle are not relevant in Ruby. I fould this statement wrong and naive. They are relevant. Interface Segregation can be vialated by eg _forcing_ caller to pass an argument that is not needed: ``` class X def smth(param) # .... end end x = X.new # in one context param is relevant, so caller is passing it: x.smth(123) # in other context param is irrelevant, so caller should not be forced to pass it: # bad (interface segragation violation): x.smth(nil) # good (default arg): x.smth # or, also good, another specific method: x.smth_without_arg ``` When it goes for Dependency Inversion, it is relevant, because in some cases inversing the dependency direction makes code cleaner (more maintable). This case happens, when A depends on B and B is more likely to change then A. If we had this dependencies inversed, so that B depended on A, the code would be more maintaible.
Hi Kmaicher, thanks for taking the time to give me your feedback. Best regards
You've got a syntax error in one of your snippets &amp;#x200B; &gt;class Dashboard &gt; &gt; attr\_reader : users &gt; &gt; &gt; &gt; def initialize &gt; &gt;@users = User.all &gt; &gt; end &gt; &gt;end &amp;#x200B; There's a space between : and users which should not be there. &amp;#x200B;
I'm curious of people will see improvements for sidekiq workers which get triggered a lot. That should be able to take advantage of the jit assuming the work is slightly cpu bound.
Absolutely agreed. In fact, everything about SOLID applies to any OOP language, as these are design level concepts.
Maybe this one? [http://slideshow-s9.github.io/demos/10things.html](http://slideshow-s9.github.io/demos/10things.html)
Doesn't look like it, but thanks for replying :) The number was way larger than 10, but without remembering the actual title my searches are coming up blank. I'm digging through confreaks looking for it.
It‚Äôs generally a [bad idea to inherit from core Ruby classes](https://words.steveklabnik.com/beware-subclassing-ruby-core-classes) like Array or Hash. Try [using a delegator](https://stackoverflow.com/questions/31861322/how-to-wrap-a-ruby-array-with-a-custom-object-but-support-the-same-methods-as-a)instead. 
This maybe? https://confreaks.tv/videos/railsconf2012-ten-things-you-didn-t-know-rails-could-do