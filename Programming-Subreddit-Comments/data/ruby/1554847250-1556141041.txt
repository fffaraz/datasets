2.6 added `to_h` with a block argument. Otherwise you need to do `map { ... }.to_h` where map returns an `Enumerable` of `Arrays` of 2 elements.
I've recently come up with a very simple way to use Rails and AWS Lambda by making API Gateway &amp; Rack talk together. Please take a look at this [introductory blog post](https://technology.customink.com/blog/2019/03/13/rails-on-aws-lambda-with-sam/) or the GitHub project https://github.com/customink/lamby
Semi-Related. I've recently come up with a very simple way to use Rails and AWS Lambda by making API Gateway &amp; Rack talk together. Please take a look at this [introductory blog post](https://technology.customink.com/blog/2019/03/13/rails-on-aws-lambda-with-sam/) or the GitHub project https://github.com/customink/lamby
I've recently come up with a very simple way to use Rails and AWS Lambda by making API Gateway &amp; Rack talk together. Please take a look at this [introductory blog post](https://technology.customink.com/blog/2019/03/13/rails-on-aws-lambda-with-sam/) or the GitHub project https://github.com/customink/lamby
I've recently come up with a very simple way to use Rails and AWS Lambda by making API Gateway &amp; Rack talk together. Please take a look at this [introductory blog post](https://technology.customink.com/blog/2019/03/13/rails-on-aws-lambda-with-sam/) or the GitHub project https://github.com/customink/lamby
JRuby doesn't support C extensions though, so you would need a way to disable building/loading them on JRuby, or release an MRI-only gem that contains the C extensions.
Thanks for linking to my C API guide (emberb)! I like how much detail you went into on the gem side. That's definitely a part I glossed over.
As OP suggested, the answers are found in [Nokogiri](https://github.com/sparklemotion/nokogiri/blob/93d1a80a154f33a925f2b7d3a127add194cc763c/lib/nokogiri.rb#L4-L33). There's no need to disable building extensions for JRuby, use [rake-compiler](https://rubygems.org/gems/rake-compiler)'s java extension support then build and upload a [java platform version](https://rubygems.org/gems/nokogiri/versions/1.10.2-java), [like nokogiri](https://github.com/sparklemotion/nokogiri/blob/93d1a80a154f33a925f2b7d3a127add194cc763c/Rakefile#L177-L191). You can even do that and also release a [precompiled CRuby version](https://rubygems.org/gems/nokogiri/versions/1.10.2-x64-mingw32) which is common for cross-compiling to windows, which is another thing rake-compiler makes easy.
Nokogiri definitely doesn’t have a pure Ruby version.
Thanks for the feedback!
Wow this is pretty cool. It's a big project and I don't think it has any "real world" use but it's cool to see nonetheless.
Just ordered. I was going to balk at the £36 price (\~USD46.95, \~SGD63.60) but then I read the [*Reshaping history* sample chapter](https://shop.jcoglan.com/building-git/history.pdf), which gives "comprehensive" a whole new level. If you do the math on the number of likely sales and the amount of time it would have taken one guy (who already has an impressive [body of public work](https://github.com/jcoglan?utf8=%E2%9C%93&amp;tab=repositories&amp;q=&amp;type=source&amp;language=) out there) to write such a "deep dive into the internals of the Git version control system", it's a steal if you have any interest at all in understanding how your tools really work.
Bad name really. We already have a JIT in ruby; I don't think people may easily distinguish towards a downcased jit meaning something else.
I am not sure why you feel a need to tell others that you ordered it "despite the price"? Are you an influencer or something? I mean, why is the price really mentioned? I myself mentioned the pickaxe in the past, but I don't recall having mentioned the price ever, even less so in £ or then going to do the translation into other currencies ... that is VERY strange for someone to do really. I am also not even sure WHY the analysis of this has to be connected to the price? Or any purchase? Is that what was meant by the one who linked it in? Reddit is a strange place ...
it's a command line program, it's not meant to be a gem or included in a ruby program in general
Read the Git book. It's free.
Command line programs are also commonly distributed as gems, because as it is, nobody's going to check out a github repo on their own just to, uh, be able to check out a github repo...
Yes :) [https://discord.gg/KbDHDez](https://discord.gg/KbDHDez)
Report it. It’s spam.
This book is not a Git manual.
The obvious "meta" "end" goal would be for people to not only cherry-pick from within the feature set available for ruby, but to leverage ruby to create their own language(s). I'd like this for the www too, so that we are no longer required to have to use the terrible thing called JavaScript but still be able to do user-interface interaction.
`[2, 4, 8, 16, 32].map { Math.log2($1) }` the dollar should be an ampersand i think.
drop &lt; 9.6
The pragmas library / gem is in part inspired by Babel (for JavaScript), see &lt;https://babeljs.io&gt;. Not sure if you can add a Babel "frontend" that turns Ruby (or JavaScript next :-) into "old" JavaScript. Another (upcoming) way in the JavaScript world is WebAssembly, see &lt;https://webassembly.org&gt;.
Meanwhile, Amazon Redshift is based on postgres 8.0.2 and isn't likely to be updated anytime soon. &amp;#x200B; Thankfully, we use Sequel for handling that (as our queries is a lot more complex compared to what is convenient to express in AR), even if that also gives warnings due to the low Postgres version. &amp;#x200B; Bleh.
I don't think I would actually make the time to read the whole book but I get the feeling that there is plenty to learn here as a Ruby developer.
true, the repo doesn't use any gem that's quite amazing, everything is either standard library or bundled default gems
just to be clear, this gem doesn't do anything right now right?
Why you would maintain three versions of an implementation when you have a java extension and cross-compilation set up for environments without a compiler is beyond me. Rake-compiler makes packaging painless, distributing a precompiled gem is easier than fighting bug drift across versions.
The pragmas code gets "extracted" from the universum and michelson libraries. It works like a pre-processor and for now does basically just search and replace on your source code text with regular expressions, see &lt;https://github.com/s6ruby/universum/blob/master/lib/universum/contract.rb#L10&gt; as an example forthcoming.
I would be okay with &lt;11
9.5 is EOL in 2021... seems a bit premature?
Could you summarize what &amp; why the Attributes API is? I've read the API docs and listened to the thoughtbot podcasts where it was discussed, but I don't get the motivation for it, and when it should be used by app devs.
The first line (on mobile) of that title got me scared.
I knew Nokogiri contained both C and Java extensions, but I think a step-by-step blog post walking someone through how to setup such a build system might be more educational than digging into Nokogiri.
Last summer, we started a project to improve backend code quality and ended up writing some new cops to fill a few gaps in RuboCop's autocorrection capabilities. &amp;#x200B; I see there's been some discussion of the Ruby plugin for Prettier on this sub. With these new rules, we've been able to double down on RuboCop, so our team only has to run RuboCop instead of both RuboCop and the Ruby plugin for Prettier. (We need to run RuboCop anyway for non-formatting linting.) It's not perfect, but it works in practice. &amp;#x200B; Curious what you think!
I agree, jit already has a popular and wide spread meaning.
How's the performance? After reading [The Missing Ruby Code Formatter] I've been curious whether it was usable on a day to day basis as an on-save formatter. [The Missing Ruby Code Formatter]: https://metaredux.com/posts/2019/03/30/the-missing-ruby-code-formatter.html
Definitely it's slower than prettier, but some engineers do run it upon file save. It also runs in our precommit hook, and I suspect that's where the majority of formatting happens. I've heard good things about [https://github.com/fohte/rubocop-daemon](https://github.com/fohte/rubocop-daemon) speeding up RuboCop performance, but performance hasn't been enough of an issue internally for us to investigate that project yet. `$ time rubocop --cache false -a delivery_order.rb # 464 lines` `real 0m2.550s` `user 0m1.878s` `sys 0m0.666s` &amp;#x200B; `$ time prettier -c DispatchApp.jsx # 496 lines` `real 0m1.013s` `user 0m0.813s` `sys 0m0.293s`
Then write it? Why are you trying to get other people to do this this labor for you? Writing such a thing with samples will take at least eight hours of labor.
&gt; It also runs in our precommit hook, and I suspect that's where the majority of formatting happens. That sounds like a fine time to format the code. Thanks!
Another factor is that we want to run RuboCop on precommit for non-formatting lint rules as well, such as: [https://rubocop.readthedocs.io/en/latest/cops\_rails/#railsdate](https://rubocop.readthedocs.io/en/latest/cops_rails/#railsdate) So the relevant performance metric is the marginal additional time needed for the new formatting cops, rather than the raw RuboCop vs Prettier times.
hey dude. thank you/your team so much for making this fantasic library. our team is being grouped with a bunch of java-heads who keep insisting that java is the only way to go, and you kept our rails proejcts relevant (and kept our jobs too!). What are the best places to keep up with karafka news (separate site/blog) or just the plain-ol github updates?
are the pre-commit hooks running locally? is it a bot in the PRs? (like houndci) does it reject incorrectly formatted commits?
You are comparing the JS formater of prettier with rubocop, not prettier/plugin-ruby vs rubocop like I expected BTW, still very interesting. time bin/prettier --write app/controllers/users\_controller.rb app/controllers/users\_controller.rb 192ms 0.58 real 0.51 user 0.07 sys time rubocop -a app/controllers/users_controller.rb ... 2.36 real 1.86 user 0.49 sys
I would write such a blog post, but unfortunately I don't have a lot of free-time or extra energy (I haven't even had a chance to catch up with r/ruby recently). Seeing as how OP has already written a blog post on Creating Ruby native extensions, I thought maybe OP might be interested in doing a follow-up post? I am not trying to coerce people to do labor for me, merely suggesting the idea. Apologies if I offended anyone.
A pure Ruby version would be useful for Ruby implementations that can’t run C extensions or can’t run them well, like Topaz or Rubinius.
Package versions available through \`apt\` can often lag behind the most current version. Try installing \`ruby-build\` from the [official git repo](https://github.com/rbenv/ruby-build) rather than through \`apt\`.
your .ruby-version file and ruby directive in Gemfile have different versions probably, all the mentioned ruby versions are supported as far as I know (even though you should even at least 2.5+ as that is going to be the minimum for rails 6)
effectively seems to be 2.5.1 in latest ubuntu LTS (not that I would ever recommend using the apt provided ruby as it requires root for installing gems)
Yep, good point! For us JS prettier vs rubocop timing is still useful because we know the front end setup is fast enough as a reference point. Really, we should run this on a bunch of files many times and take summary stats, with/without rubocop formatting rules enabled, etc. That could be whole other post. FWIW, I can imagine a future in which we have both Ruby prettier plugin and RuboCop running, once the former is mature and we have more internal dev experience cycles available to set up the double tooling. We wanted a production-ready solution on the order of months in summer 2018 because the team was/is growing so fast — couldn’t wait for the prettier plugin to mature. Definitely not recommending against it though!
It's hard to figure out your question: Are you seeing this error locally or on heroku deploy? And what version is specified in your Gemfile?
You can also [use ruby-install](https://github.com/postmodern/ruby-install#integration) to install 2.4.6 for rbenv: ruby-install --latest --install-dir ~/.rbenv/versions/2.4.6 ruby-2.4.6
Or you can install 2.4.6 from source into the rbenv directory: sudo apt-get install -y build-essential bison zlib1g-dev libyaml-dev libssl-dev libgdbm-dev libreadline-dev libffi-dev curl --remote-name https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.6.tar.bz2 tar -xjvf ruby-2.4.6.tar.bz2 cd ruby-2.4.6 ./configure --prefix="$HOME/.rbenv/versions/2.4.6" make install
We have a precommit lint script that runs locally, finds changed files, and operates on them. For the frontend it runs prettier in write mode automatically. For the backend it runs RuboCop and prompts you to autocorrect y/n. If you say y, it autocorrects and commits if there are no remaining violations. Then on GitHub PRs we run that same lint script on all files as part of our test suite. If those tests fail, you cannot merge your PR. So there are several checks depending on developer setup: upon file save, upon precommit, upon PR tests, upon pre-deploy master tests, etc. Perhaps we can open source some it at some point. It's not super complex -- the general idea is all above.
 data.reverse!.uniq { |hsh| hsh[:name] }
+1 if the original array can be manipulated if not ``` data.reverse_each.each_with_object([]) do |hash, hashes| hashes.push(hash) unless hashes.any?{|h| h[:key] == hash[:key]} end ``` Not considering performance
I never knew Flexport uses Ruby Rails! I hope they continue to disrupt the industry and becomes the Amazon of freight forwarding company.
As pointed out by /u/PikachuEXE, this will mutate the original array. `data.reverse.uniq!`, on the other hand, will leave it intact.
He doesn’t want to create intermediate copy.
I install rbenv and ruby-build through Git, so in order for me to update it I just have to run: cd ~/.rbenv &amp;&amp; git pull cd ~/.rbenv/plugins/ruby-build &amp;&amp; git pull Then I don't have to wait for some maintainer and a release.
But he wants to create a uniquely reversed copy, which this will do. It creates 1 new Array, no intermediate Arrays. Your method also creates 1 new Array but it mangles the original Array to get there. Using destructive methods in a chain is a great idea, but to avoid mutating the original object, they should only be used on the second and subsequent methods in the chain.
I assumed the reason he doesn’t want intermediate array is because he doesn’t want the cost of allocating the copy of presumably very large array, where the unique version is significantly smaller. So the intermediate array that he cares not to have is the reverse copy of the original one.
This is a very good point. In that case, I stand corrected. It looks like you and /u/PikachuEXE have got each case covered between you. Learning has taken place. Thank you.
What does this blog post contain that's not already present in other sources? For example the [top link](https://scotch.io/tutorials/understanding-ruby-closures) for the phrase "ruby closures explained".
reminds me of my recent hacker news comment :) [https://news.ycombinator.com/item?id=19618418](https://news.ycombinator.com/item?id=19618418)
Awesome question. This content is available on other pages. The reason I wrote about this one is, a few years back, I didn't understand what others wrote. So this post I wrote in a way I had wished someone had written for me to understand. Probably there's someone out there who with the plethora of info on closures available online can't quite grasp the concept, like me in the past. So in a way this was the missing post I wished had existed. I explained it for myself when I didn't understand it 5 years ago with the idea that someone is like me 5 years ago and need \*this\* kind of explanation.
Fair enough. I just see a TON of "hey I wrote a blog post that's 99.99% what's already available" and I always wonder why they went to the effort to write / promote it.
I believe writing about a mixed Java and C extension would be useful even for my own understanding. It's a great suggestion and it seems people would be interested in it. &amp;#x200B; However, I'd have to learn more about it myself before actually getting down to working on a post. Anyhow, thanks for the suggestion and feedback!
Writing can be a great way to not only help others understand, but to better understand something yourself.
Exactly. For me the intention to write and share is like me saying: "Hey, I learned something, I'm making it public". With the intention that an expert or more experienced person will catch something and correct what I thought I knew or understood among other reasons. Plus to probably help someone else. Plus to keep a record of what I know or learn for my future self.
No need to quash their enthusiasm. They wrote a thing, presumably learned something in the process and are excited enough to promote it. Some folks learn through repetition and/or by hearing the same thing stated differently, so even if the content is the same it can still help concepts "click" for the author and others.
 crypto.map { |k, v| { k =&gt; v } }
``` crypto.map { |k, v| { [k] =&gt; v } } ```
crypto.to_a.map(&amp;:to_h) You need a version of ruby with to_h, which is like 2.5 or more i think
Thanks moomaka for the quick reply ! It worked perfectly fine for me !
It's not an "intermediate" array if you use `uniq!` instead of `uniq`, no? If you wanted to get it back in original order _without_ reversing the array twice... I don't think there's any built-in API to do it, you'd have to write your own algorithm. Which might end up effectively slower than the built-in stuff, since the built-in stdlib stuff has a lot of methods written in C.
The [`String#split`](https://ruby-doc.org/core-2.5.3/String.html#method-i-split) method is your friend ;)
The EventMachine gem has a [BufferedTokenizer](https://github.com/eventmachine/eventmachine/blob/master/lib/em/buftok.rb) class you could use.
Thanks for explaining it. Do you think it can be a feature request to control the official `Array#uniq` method by passing some hints from consumer code? something like `[1,2,3,2,4].uniq(pick: :last)` .
For this use case, use `split`, but this is the closes I know about: https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html
okay yeah I found it on the internet but let's say I want blue, purple,{green,orange} and I want only what is between { and }, do I just do object.split("{ and }") cause when I tried doing this it gave me and error
This could be done, but you could also go ahead and use [`String#scan`](https://ruby-doc.org/core-2.6.2/String.html#method-i-scan) or [`Regexp#match`](https://ruby-doc.org/core-2.6.2/Regexp.html#method-i-match) to first find the content between your braces and then go ahead and work with the content in between.
`crypto.map {|*x| x.to_h }`
formatting code: def new_sum(array) sum = 0 index = 0 while index &lt; array.length sum += array[index] index += 1 end end p new_sum([99, 101, 88, 4, 2000, 50])
&gt; From the above it can be observed that while Procs will snap out immediately on seeing return, Lambda’s hesitate until everything in their context is executed. This is misleading to the point I can't really tell if you have the right idea or not of how `proc` works. Either way: A more precise way of expressing the difference is that returns in proc's are *lexically scoped*. That is: they return from the block the proc is being *defined in*, while return in lambda returns *from the block itself* In your example it's not clear that what happens is not just that the proc exits from `call_closure`, but also from *main*, because you're not printing anything after the `call_closure` with the block See this example: ``` def foo(closure) puts "before yield" closure.call puts "after yield" end foo(lambda { puts "lambda"; return }) foo(proc { puts "proc"; return }) puts "after proc" ``` "after proc" will not get output, because the return in the `proc` does not just "snap out immediately" out of the context it was *called* from, but it returns all the way out of the scope it was *defined in*, and thereby terminates the program as a whole (if you wrap the last 3 lines in a method and call that, it will just exit the method it was defined in and the main/global scope will continue. Consider proc as a shortcut for this: ``` def foo(closure) puts "before yield" closure.call puts "after yield" end def bar foo(lambda { puts "lambda"; return }) foo(proc { puts "proc"; throw(:return) }) puts "after proc" end catch (:return) { bar } puts "We're returning here" ``` That makes passing down a `proc` useful mainly if you want the ability to return out of deeply nested scopes, or the ability to effectively abort processing of something that calls closures but doesn't offer any other way of signalling to stop. You can use throw/catch or raise/rescue for that, but both of those can be trapped (e.g. if the code you call happens to `catch()` the same value (though you can avoid that by picking carefully) or `raise` can be trapped by a blanket `rescue` - a return from `proc` to my knowledge can't be intercepted/stopped by code in an intervening scope.
Look at enumeration class, take_while method to be exact...
Also if your solution includes while or for, there is 99% of the time way better solution already in the available methods.. Enumeration class which both hash and array are children of, has most of the time the needed answers
what is the utility of those commands
\`procs\` don't seem useful until you start writing library code or frameworks/engines that have a lot of hooks and integration points. Sometimes you want the end-user to be able to handle errors, but sometimes you want the control to be able to just outright stop further execution of hooks and either handle an error yourself. or let the error bubble to the top so the end-user can see it.
I have linked the documentation. There are good explanations and examples
 'blue,purple,{green,orange}'.scan(Regexp.union(/(?&lt;!{)[^,{}]+/, /(?&lt;={)[^}]+/)) #=&gt; ["blue", "purple", "green,orange"]
Check out `Array#reduce`
Exactly. And since lambdas and procs are both Proc instances, you can leave the choice to the user without having to write a single line of code to enable it.
Seems like you're coming from a different language with its own `stringtokenizer`. If you could provide us with code in that language using that `stringtokenizer`, we can try converting it to idiomatic Ruby.
I come from Java
Got it. To help us explain how you would do it in Ruby, it would be great if you give us a snippet of code with [`StringTokenizer`](https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html) that does what you want to do with your files/strings.
This post is actually about code blocks. Code block becomes a closure when it encapsulates and uses parent context e.g. def a(x) Proc.new { |y| x + y } end b = a(3) b(4) # =&gt; 7 b(6) # =&gt; 9
I think this is what you want &amp;#x200B; `input = [99,101,88,4,2000,50]` `def new_sum(array)` `sum = []` `for item in array` `sum &lt;&lt; item if item &lt; 100` `end` `return sum` `end` &amp;#x200B; `puts new_sum(input).inspect()`
I doubt it.
You can work with rubular until you find the target easily via a regex. Give it a try - it is not as powerful as tokenizing the whole string, but regexes are actually a LOT simpler than tokenizing the whole input stream really.
 &gt; [99, 101, 88, 4, 2000, 50].select { |n| n &lt; 100 } = [99, 88, 4, 50] Or as a method: def new_sum(array) array.select { |n| n &lt; 100 } end &gt; new_sum([99, 101, 88, 4, 2000, 50]) = [99, 88, 4, 50]
basically Ruby's stringtokenizer is split, this is the equivalent I looked it up now my problem is that I need to tokenize something between { } and I don't know how, I looked on the stack overload but none of the code seems to work even if I try object.split("{ and }") or object.split("{" and "}") this still dosen't work.
Yeap. I got a gem that had last release in 2017 (some minor thing too). It's small, does what it needs to. Pretty much unchanged for 10 years now. (Rails 2 era?). I'm 99.9% sure it works with Rails 6 as well. 30-50K downloads a month and slowly going up. But looking at the commit activity one could say it's dead.
There does need to be a way to mark a gem as finished. I'm not sure what that term should be though. I feel like "complete" or "finished" have a bit too much finality to them, which isn't exactly what we're trying to encapsulate here. "stable" is also a bit of a misnomer, since what does that mean for libraries that are under active development but won't crash your app? Maybe "steady"? It's not under active development, but it's not abandoned. It's unchanging, because it doesn't need to change. It's possibly not perfect, but that's OK, there is a team (or individual) maintaining it, triaging bugs.
I have this as well with the Warden library which has &gt; 28 mil downloads last time I checked. I still get asked regularly if it works with current versions of Rails, Rack or Sinatra. I would love a way to identify a library as "stable" to make it clear it's API works, unlikely to change, and therefore doesn't require active commits.
"Feature Complete"? "at spec"? I like Feature Complete though.
Maybe bump the changelog with "compatibility" :) But yes, I agree that this metric is imperfect.
You can also use \`array.reject { |i| i &gt; 100 }\`.
I think a wise thing to do would be to at least keep abreast of Rails/Ruby releases and keep your README up to date in terms of compatibility. Yes, it means you have to check in s few times a year, but at least you're showing that you're cutting the gem through platform updates, even if you're feature complete and defect-free.
Yeah, I've thought about this. Seems like one signal for 'done' is that it still gets "sufficient" regular downloads from rubygems. Which is a number that is available. I'm not sure the right number for 'sufficient'. It might be not just the raw number, but trend over time. It still has as much or more downloads from rubygems as it ever had, it's a good gem. The rubygems downloads are decreasing, plus no activity, that might not be so good.
&gt; I'm 99.9% sure it works with Rails 6 If it's got no CI and/or you haven't done any commits to _test_ it under Rails 6, I'm skeptical of that level of certainty.
Yeah. It got CI. Need to bump versions once in a while.
[Rubinius runs C extensions](https://github.com/rubinius/rubinius#the-ruby-programming-language), but given the 11 commits it has received in the last year I think it's fair to say almost nobody uses it. Topaz hasn't had a commit in the last two years, so it's fair to say nobody uses it. I have more lines committed to Rubinius than the top ten contributors to Topaz, so I'm going to estimate that they didn't get very far in being a complete ruby. It's fair to say Ruby users that can't run C extensions don't exist, but if you manage to dig one up the cost of supporting them would not be worth even an FFI wrapper for the same library the C extension is wrapping. I've implemented wrappers both ways and the FFI is often just as difficult to maintain as a C extension because the documentation is worse, you don't have the help of a compiler, and debugging is harder because there's the C code implementing the FFI wrapper in the middle of all your calls to the library you're wrapping.
yeah, none of those are going to do anything. object.split("{ and }") Means to split on the string literal `"{ and }"`. Not helpful. object.split("{" and "}") Is going to be evaluated by first evaluating `"{" and "}"`, which is just two strings with the `and` operator in between them, and evaluates to `"}"`, so it's just `object.split("}")`. You can use [StringScanner](https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html) as Arjes pointed out above. (This isn't a very widely used part of the stdlib, I think most things are either too simple or too complicated for it). You can try to do it with regexps. Or you can write a parser, perhaps with [parslet](https://github.com/kschiess/parslet) That's all I can think of.
I agree with this, a simple readme update just to check compatibility is a good super minor version bump candidate
Here's a StringScanner example based on inputs you gave below: require 'strscan' input = 'blue, purple,{green,orange}' s = StringScanner.new input tokens = [] # Some assumptions about the input tokenized: # # * tokens are split by ',' # * tokens starting with '{' can contain any character up to the next '}' # * there is no other escaping mechanism # * a '}' is always immediately followed by a ',' # * a '{' in the middle of a token is not handled specially until s.eos? do token = case s.peek 1 when ',', /\s/ then # skip the , delimiter and whitespace s.getch next when '{' then # #scan is anchored at the start of the string, so this scan reads from # '{' to the next '}' # # This does not handle nested {}, you'd need to switch from a lexer to a # parser for that s.scan(/.*?}/) else # otherwise a token ends at the next ','. s.scan(/[^,]+/) end tokens &lt;&lt; token end puts tokens
And here's an example that could be used by a parser to handle nested {}: require 'strscan' require 'pp' input = 'blue, purple,{green,orange}' s = StringScanner.new input tokens = [] until s.eos? do token = case s.peek 1 when /\s/ then [:space, s.getch] when ',' then [:comma, s.getch] when '{' then [:open_curly, s.getch] when '}' then [:close_curly, s.getch] when /\w/ then [:text, s.scan(/\w+/)] else raise "unknown character #{s.peek 1} at #{s.pos} (next bytes: #{s.peek(5).inspect})" end tokens &lt;&lt; token end pp tokens
The reason why I'm asking you to provide Java code is to give us an idea how you would use Java's `StringTokenizer` to split the string. The thing is, both of your approaches will also not work in Java: `new StringTokenizer("blue,purple,{green,orange}", "{ and }");` will tokenize it to `blue,purple,` `gree` `,or` `ge` On the other hand `new StringTokenizer("blue,purple,{green,orange}", "{" &amp;&amp; "}");` returns a syntax error. Others have provided other solutions, but I prefer meeting halfway and working with what you already know.
I think OpenCV is what you are looking for, you would need to detect the QR code then decode it using a plugin maybe, or another lib. small note is that this may be easier with python as that's what a lot of OpenCV folks use
My main thoughts when a project is abandoned verses done is through a combination of multiple things. If a project does not have any commits in over a year and have very low count of forks and stars, this is a concern. However, if the project is popular and and doesn't have any commits in over a year, but there are no issues or pull requests, then I would consider the project as stable and "done". On the flip side, no commits in over a year, there are a lot of pull requests and a lot of issues, I would likely consider the project abandoned.
https://en.m.wikipedia.org/wiki/Fast_Artificial_Neural_Network Haven't got far enough to see how it handles images, though wiki suggests it does. There's a joke sort algorithm about 10 comments down in my profile is you want to see a low effort config and use rain-mANN sort.
Any chance you can mention your project as a possible example in the github issue? Would love to have a bigger data sample to understand if suggested solutions match the initial data set that people provided.
Can you mentioned your gem in the github issue? Would love to have a bigger list of gems that qualify for 'finished' status.
There's tons of options, here's a couple more not mentioned: `crypto.to_a.map(&amp;:to_h)` `crypto.each_pair.map(&amp;:to_h)` (enum variant)
I can't imagine using ActiveRecord with Redshift.
Would be nice to see information about rationale behind that. I'm sure there is some - some Postgres feature heavily used in Rails 6 that is not available in &lt;9.3. What is it?
This would be a good example for .select / .reject / .filter. I would not refactor that code since it seems to be needlessly complicated compared to just applying a filter instead, though.
9.3 stopped being supported by postgresql half a year ago and either way that version is from 2013. What more rationale do you need? Also, proper JSON types support are from 9.4 forward.
This right here. I always use the number of issues, the number of open PRs, and the time of last commit as my guide to whether or not I can reliably use a gem. Check out MiniKeePass for example: https://github.com/MiniKeePass/MiniKeePass 278 issues, 28 PRs, last commit October 29, 2017. That project is dead. Compare with Pundit: https://github.com/varvet/pundit 11 issues, 6 PRs, commit history is largely CI updates. Still some active development but the basic feature set is unchanged. https://github.com/kjvarga/sitemap_generator 5 issues, 5 PRs, last commit was in January, last commit before that was July. Development is slowing down and I'd argue this gem is pretty close to feature complete.
The semi-official way to go about this is via a e. g. 1.0 release. Perhaps rubygems.org should allow some de-registering of projects where you remove yourself from a gem; and instead put the gem into the "community", aka through the rubygem team, to decide what will happen with it. The only solution right now seems to be binary between let it stay as it is, even though you may no longer maintain it; or remove the gem so your name is not associated with it any longer. Perhaps there should be more ways; also visual identifiers to designate stability on top of that.
The problem is that this requires manual time investment and in many projects that are considered "stable", the original author already abandoned or gave up on the project really. So your solution sounds nice on paper but it does not work in practice. It may be best to get away from the strict "one owner of a gem", or even a "few owners" (where many can become inactive), towards a situation where there is an ADDITIONAL way to maintain or update existing gems that are used by lots of people. This requires some definitions, rules etc... and perhaps even retaining the old version, while pointing to the new one as well. A bit like branching via git, but for rubygems directly rather than just git (everyone gets lazy because git does everything, yet the package managers don't ... ).
Low.
Dozens. Literally dozens.
too low.
There are 53,736 readers, judging by the sidebar. Unfortunately, the majority of people on this sub are people that signed up for reddit, went on, thought of things they liked - ooh, rubies! diamonds! - and subbed. Then never were heard from again.
Really, i thought there were many , and i still like programming using Ruby.
Yeah, I get that. However it's possible to have automation to test against multiple Ruby/Rails (One example: https://docs.travis-ci.com/user/cron-jobs/), and you can be notified when there's a failure. Travis CI is free for open-source projects, so if you cared enough to put a Gem out there, you should probably put a _little_ investment in setting up automation around it. If it's truly been abandoned, and I've either already got the gem in my project and/or really need its functionality and can't find a replacement or workaround, I'll fork it to my (or my company's) gh account. It then becomes part of our upgrade tech-debt of course, but that has to be balanced against the cost of implementing that functionality yourself. If I run into an issue during an upgrade, I'll definitely make a PR into the original repo when I/we fix it as part of our upgrade ... it's then up to the maintainer to decide if they want to accept the PR or not. I've definitely ALSO been in the situation where a gem does _almost_ everything I need. So I'll fork the repo, add what I need and offer up the PR to the repo owner. If they don't want the feature, I now "own" my own fork, and need to manage keeping current with the Parent repo. I mean, gems aren't magic. They're just Ruby code (mostly of the time). ANY time you bring an external dependency into your project, you have to recognize that you may end up owning that code, and need to weigh that against the cost of implementing it yourself from scratch. It's your responsibility to kick the tires ... look at the implementation and test coverage ... Weigh the cost of bringing in (and potentially own) the dependency against building it yourself. It's awesome when you can get something "for free", and this is how open-source works. When the original project is active and "working" the way you need it to, then yippee. But you do need to be cognizant of the fact that there _are_ hidden costs to FOSS, and every now and then you may need to "do your part". &gt; This requires some definitions, rules etc... and perhaps even retaining the old version Well, this _already_ happens ... every version from a Gem's history is available. As for rules/definitions ... doesn't this already exist? I mean the fork-&gt;pull model works. If the Parent doesn't want (or isn't responsive to) to your changes, then maintain your own fork. If you want to publish your work, make a small change to the name of the Gem and publish it and become the maintainer of the fork. If your work's any good, the public will start following your fork instead of the abandoned one.
I'll probably try to estimate it with profiles that have active ruby repos
I work in NYC. There are hundreds of Rails job postings and lots of companies still using Rails. I wouldn’t say it’s a low number.
the object.split("}") doesn't work, because it gives me back everything I specifically want what is between { }
Combine this with a version number of at least 1.0, before it can be considered being "done" as opposed to being abandoned
10% of top 10k websites, x 50 = 50 000 working professionally of top 10k websites
Sorry for being That Guy. Could you point me to some of the places you're seeing Ruby positions? I happen to be looking in NYC.
That's a difficult question. Because how can you determine the number exactly? You can try to use something more specific such as the number of people registered at rubygems.org. This is not a good metric either because I am pretty certain that a large majority of ruby users will never be there; and many accounts are inactive, so ... I have no crystal ball but I'd say when you have the number of python developers world wide, the number of ruby users is about 1/3 of that, give or take. That's a shitty metric too but then again all the other metrics, such as Google Trends, TIOBE or any other fake-scientific voodoo will always be massively biased. Giving an absolute number ... and I am quite sure to be wrong ... I'd say there are 1 million ruby users world wide, and 3 million python users world wide. But perhaps someone who knows better can give more accurate numbers.
Dont be sorry! If we don't help each other out we're not much of a community.
That's above my grade.
That happens on other subs too, though. Most ruby users - or python users for that matter - are not registered at reddit though. So it is not a good metric either.
How do you define a Ruby programmer? Can code in Ruby? Has done a Ruby project in the last 2 years?
`Float::INFINITY`
I've done it before in an old rails app, but I think I ended up generating the QR code in HTML/CSS markup if I recall correctly.
If you are looking for just an order of magnitude estimation, treat it as a [Fermi problem](https://youtu.be/0YzvupOX8Is).
&gt; Implicit returns just everywhere, all the time, always assumed, if you don't want a return value, either do `return` or `nil` at the end but most methods do return something useful &gt; Having no empty parentheses when calling a method and passing no arguments quite split on this. for me it depends where it's used, e.g. `render @user` but `User.find(params[:id])`. &gt; foo = bar you wouldn't do that typically &gt; gprivate in the same line as the declared methods everytime I wrote a private method you can have only one method private: class A def a; end private def b; end def c; end end &gt; anything I should watch out for in particular? reading code of nicely done projects like rails does help, and prettier plugin-ruby and rubocop helps a lot too (most people use rubocop for linting, even if everyone has a different config)
FWIW these are the gems used: * rotp * rqrcode * chunky_png * rqrcode_png
https://www.indeed.com/m/jobs?q=Ruby+On+Rails&amp;l=New+York%2C+NY There’s a ton. I happen to just get emailed constantly so I know they’re out there. I also just know a lot of companies in the area that use Rails. Betterment, Stash, my company. A lot of new and established companies use Rails. Plain and simple.
The same way you would estimate any other thing. You would take estimates using multiple sources and compare them until you were satisfied. There's two ways to estimate something: top-down (how many people are on earth? what % of population uses reddit? what percent of redditors subscribe to /r/ruby?) or bottom up (10% of stack overflow survey users use Ruby, 10000 devs took survey, a trillion devs working)
Nice. I appreciate the feedback and the tips, RuboCop seems pretty cool. Thanks!
Rails developers or Ruby developers? Because there is more to Ruby than just Rails...
Although I think that the node community has it worse, there is definitely a popularity-driven development associated with most libraries. For people writing small "do one thing well" libraries, it is frustrating to deal with queries around perceived "abandonment". However, not as frustrating as this aggressive approach that the ruby community has adopted towards removing support for "older rubies". Why is this frustrating? As a maintainer of a "low change ratio" gem, I get, let's say, a couple of PRs or issues per year. The issue itself is something small. Sometimes a typo. However, I always get in trouble because of the CI, because: * they'll recommend you to update rubygems due to potential security fixes; * rubygems stopped supporting ruby 2.2 or lower (or smth like that) * the rubygems version might be incompatible with bundler, so gotta update bundler as well * bundler stops supporting ruby 2.3 or lower after bundler 2 so, fixing a small issue becomes redesigning the whole CI suite, because the dependencies broke my build. Now you can accept that they don't want to maintain discontinued/older/unsupported versions of ruby and yourself break support to those, or build a defensive CI pipeline and hard-set your dependencies. * The former will frustrate your customers/users; * The latter will make it more difficulty for you to keep forwards compatibility;
This is ruby, so the number is constantly mutating.
I'd say knows how to write a simple Ruby program, or a simple CRUD Rails app
Rails developers count!
What about about people that use things like Chef or Vagrant to set up environments for other languages?
StackOverflow's last survey with 90k devs: [https://insights.stackoverflow.com/survey/2019#technology](https://insights.stackoverflow.com/survey/2019#technology) Looks like 8.4% mentioned Ruby as technologies they use? Then if we look at the estimate of developers worldwide: [https://evansdata.com/press/viewRelease.php?pressID=268](https://evansdata.com/press/viewRelease.php?pressID=268) They estimate 23,000,000. If we take 8.4% of that, leaves us with \~1.9mi people. So there should be at least 1,000,000 people that can write simple Ruby programs out there. But that doesn't mean Ruby programming as main job. I guess it means people that write a little bit of Ruby sometimes at work or on personal projects. Maybe people that use tools that use ruby (like vagrant) are included in that mix?
&gt; Implicit returns: these are just bad IMO My coworker feels the same way as you, but even if you write explicit returns for most code you write you still have to live in a world with implicit returns (not `return`ing still returns). Implicit returns leads to clean code IMHO (e.g. moving guards to the top of the method, avoiding jump-returns out of loops and instead using proper methods like `find`) &gt; foo = bar means bar could be anything foo = bar() lets me know bar is actually a method After 8 years of doing Ruby I've come to think of this as a feature. You might have a temporary local variable being referenced, but that can easily be refactored into a method by just pulling it out (since parens aren't necessary the interpreter will still know what you mean) &gt; How weird would it be if wrote private in the same line as the declared methods everytime I wrote a private method? Pretty weird, but not unfounded. I've found that almost every private method I write really just belongs in an inner module/class as some public method. The issue you run into using a `private` per method is that you now can have public methods at the bottom of the file which obscures your interface &gt; Anything I should watch out for in particular? In my opinion, the faster you acquiesce to Ruby's functional paradigms the happier you will be. Learn every method in `Enumerable`. I have a lot of coworkers with a similar background to you and I find they try to write a lot of procedural Ruby. Ruby is a lot nicer to you if you try to do things with chains of simple `select`s and `map`s than it is if you write big complex loops
Well if they know Ruby enough to extend Vagrant's configuration, I'd count them.
&gt; Ruby is a lot nicer to you if you try to do things with chains of simple selects and maps than it is if you write big complex loops. Generally speaking if you need to use a temporary local variable, there's a better way (although in the extreme local variables can be good for readability) Would you mind expanding on this a bit? I don't use select or map very often, so your post made me feel like I am missing out on something big.
It took me a while to get used to implicit returns because you usually don't see them in other languages, but once I did I started to prefer implicit returns. Give it time.
Ruby has a dash of functional programming thrown in even though it is mostly object oriented. The documentation for the [Enumerable module](https://ruby-doc.org/core-2.6.2/Enumerable.html) covers select and map and a lot of other useful methods, such as 'any?'. Basically, 'map' allows you to call the same method on every item in a collection, transforming it into a new collection. Running 'select' on a collection returns only the elements that meet a certain condition, similar to a select statement in SQL
&gt; no empty parentheses when calling a method If nothing else, it reminds you that you can't pass function objects around by name the way you can in JavaScript or Python. `foo = method` means something very different in Ruby versus other languages.
You'd be surprised at how many people can use Vagrant/chef and not realize they're writing Ruby. If they don't know they're writing Ruby, are they a Ruby developer?
So in C-ish languages I might do something like this: # I want hash to index all of the strings by their first letter elements = ["hello", "world", "whatever", 123] hash = {} elements.each do |thing| next unless thing.is_a?(String) hash[thing.first] ||= [] hash[thing.first] &lt;&lt; thing end Modern Ruby tends to be more functional though and uses a lot of the methods in `Enumerable`. Here's an example using some of those helpers: elements = ["hello", "world", "whatever", 123] elements .select { |thing| thing.is_a?(String) } .group_by(&amp;:first) [The Enumerable docs](https://ruby-doc.org/core-2.5.1/Enumerable.html) define all of these. `select` is a filter (e.g. only let things pass if the block is truthy) and `map` converts each element to some other thing. This kind of chaining tends to break up the problem nicely into smaller subproblems and scopes all of the variables used in each subproblem Imagine if the example was really complex. You would have a ton of scope overlap in the first example making each subpart of the problem more difficult to understand. In the latter approach you are usually only concerned with what happened in the stage before/after your own
This is only one part though - often gem authors have already abandoned a project. There should be some way to let a gem stay where it is but dissociate it from the author, without deleting it. Something like community-maintained or something.
\&gt; I'd love for a compromise in regards to writing Ruby where it doesn feel as different as writing other languages. The rest of your questions are really a subset of this one. You are asking for permission to go against the norms. I think this is a mistake, regardless of the languages involved. Ruby is flexible enough that you *can* do this, but I believe it's best to follow what the community generally does in order to fully "fit in" and understand the language. You should strive to write Ruby code that looks like most everyone else's Ruby code. Kind of like "you need to follow the rules first before you know when it's okay to break them". That being said, nothing you've asked about is going to negatively affect behavior, performance, or maintainability, so...go for it if you want. The language lets you.
There is no "general consensus" because if you are going to learn one thing it is that people are different - and that applies to the ruby "community", whatever that term effectively entails to, means. But since you gave a list, I will make some comments: &gt; Implicit returns: these are just bad IMO and having return written explicitly increases &gt; readability at a quick glance I actually mix both without a problem. Being able to drop return actually increases readability, since you know that the last value returned is the one that is returned anyway. But if you like explicit return, nobody stops you from using them. You can also use method calls via () including cat.meow() all the time. People coming from python complain about the fact that you can omit the (), but then when I ask them why they cry like little girls about it, while being able to use them anyway, they hiss and make lots of szszszhsweary sound. http://bash.org/?400459 &gt; Having no empty parentheses when calling a method and passing no arguments: I understand &gt; the reasoning, but this also decreases readability IMO because Nope. It increases readability. But again - while you may be pimping your flow, YOU CAN USE () like crazy and ruby will work just fine. So just keep on using them. Granted, people may call your code like a noob or "non-idiomatic", but you can use it. &gt; Third and last is: How weird would it be if wrote private in the same line as the declared &gt; methods everytime I wrote a private method? I'm not a friend of just writing private once &gt; and then writing all the private methods below. I see this a lot in crystal. I think it is an utter shit style. The indent level is wrong when you use leading "private". Additionally, private in ruby is like bombing for peace or fudging for virginity. It makes no sense in ruby honestly because the whole OOP model is simply different to C# or Java. My best advice for people coming from C# and Java - don't switch languages. Your brain got corrupted. IF you still want to switch then throw over board lots of assumptions that you have; and MUCH MORE IMPORTANTLY, go and find a style that you may feel comfortable. For example lots of ruby users do this: def foo a b c But this is where I myself am super-conservative like an idiot, and do this: def foo(a, b, c) I understand why the first is done. I think it is great that it can be done, too, but indeed, my brain takes longer for the first than for the second. For the same reason I do not use ternary. My brain takes longer. The other parts, though, like it would be better to have mandatory explicit returns or mandatory () - nope, sorry. Python already covers this clown-attitude. We don't need dictatorship-like languages. This is ruby, the land of the original hippies! Ruby is all about finding what works for YOU. It is not for YOU or anyone else to try to lecture others about what style to do, even if I myself also have an opinion - you are all doing it wrong. :)))
The same way you estimate the number of piano tuners in Chicago.
/r/whoosh
So are you asking about the number of _Ruby_ developers, or the number of _Rails_ developers? Because, though Rails devs are the majority, there's more than just "Rails Developers" who use Ruby...
&gt; do return or nil at the end but most methods do return something useful You actually have trailing nil? I don't think I ever wrote a method that required that ... but your mileage may vary. &gt; Having no empty parentheses when calling a method &gt; and passing no arguments &gt; yes, that's just how it is, just much better when you get used &gt; to it Huh I misread ... I thought he found that mandatory () makes for better code. Aka the python way. Which is just wrong. People already seem to forget that you can not trust the snake ... what's that story with the apple, RIGHT! You can not trust a python ... even though it was not a python in the original story I think ... &gt; reading code of nicely done projects like rails does help Actually I found the rails code terrible. I'd rather recommend looking at other code bases that have not been written with a rails-DSL-like oddity at hand, such as rack.
&gt; In my opinion, the faster you acquiesce to Ruby's functional paradigms the happier you will be. &gt; Learn every method in Enumerable. I have a lot of coworkers with a similar background to you &gt; and I find they try to write a lot of procedural Ruby. Ruby is a lot nicer to you if you try to do &gt; things with chains of simple selects and maps Dude ... this is oldschool OOP method chaining. I don't know why you say this is a "functional paradigm". People seem to suddenly retro-redefine the words here.
&gt;I thought he found that mandatory () makes for better code. Aka the python way. Which is just wrong. That is what I meant do. I like the mandatory (), makes it more readable. I can't see how it make it worse. It's an easy differentiation.
&gt;After 8 years of doing Ruby I've come to think of this as a feature. You might have a temporary local variable being referenced, but that can easily be refactored into a method by just pulling it out (since parens aren't necessary the interpreter will still know what you mean) Huh. Not a bad way to think about it. Maybe in a few years I'll appreciate it. I'm open to having my mind changed I guess. &gt;The issue you run into using a private per method is that you now can have public methods at the bottom of the file which obscures your interface I can see that. Thankfully I've got the habit of organizing and keeping my private methods all below the public ones except on some specific cases. &gt;Ruby is a lot nicer to you if you try to do things with chains of simple selects and maps than it is if you write big complex loops. Yeah, I got that feeling a lot from doing the Ruby codecademy track. Thanks for the feedback, really solid!
Yeah, you're 100% spot on I'd say. Thing is between Java and C#, Ruby is the first language I'm going to that differs significantly on how to write it and I'm worried how well I'll be able to juggle my muscle memory between them.
at least 3
Thanks man! I appreciate the reply. Completely agree with you on the whole ternary thing too, fuck ternary. Also, I'm sensing a little hostility towards Python?
I came from both C# and Java directly to Ruby, so I completely get your frustrations. IMHO, I totally agree with the criticism against implicit returns. I just end up using explicit returns everywhere and apologize to my coworkers about it. If I'm in an interview, I tend to say something along the lines of "I do it by habit to increase readability across different language users, and by reference". Also if you admit that it's against standard Ruby, but list your reason, it's usually not a big deal (though some Ruby purest will probably tell me I'm the devil, lol).
I've only really been doing Ruby for about 5 weeks but coming from a very basic 15y old FORTRAN95 education preceded by TrueBASIC, I'm basically only barely used to OOP. Implicit returns are magic to me. Ternary operators seem to decrease readability despite their convenience. attr_whatever's hidden methods have been fucking with me all week... and the complete lack of strictness around types for variables totally fuck with me at almost all times. I should state also that I'm pretty new to most modern coding paradigms despite this previous experience. However a lot of Ruby's methods seem to work how you'd expect them to when they've got any type of variable thrown at them, sometimes you can choose from more than one of them. My instructors keep saying it's a weird language because of this. Equally you can still throw together something that you think at first glance shouldn't work, but it does because whoever wrote the default methods for Ruby was smart, but even though it does work you won't feel confident about it. It's definitely useful, but it's also definitely odd.
ahaha. yup. ternary operators CAN be nice if you keep them neat, but quickly turn into shit shows if you dont abuse them (i had a co-worker insist on using nested ternary operators and he was the devil). most of the modern languages have all moved to generic/weak typing which can be a blessing or a curse. i've been coding in ruby for 4-5 years now and still find myself stumped with some concepts. i will say that i LOVE the enumerator module and highly recommend learning map vs collect vs each. great stuff there.
There are several style guides out there. I find them really useful to get what is considered as readable for most.
When learning a new language while heavily steeped in another this inevitably happens. I think your complaints are more that TBH and less about ruby, i.e. this one thing is different than what I'm used to therefore I dislike it. You could make a similar argument about braces in Java and of course most OO languages have their PERLisms. &amp;#x200B; I work with a lot of Java devs. I think the implicit returns are probably bothering you because Java code will be like this &amp;#x200B; if something this else that end &amp;#x200B; versus the more rubyish syntax of embracing the implicit return of the last thing and we use short circuits &amp;#x200B; return x on if condition thing &amp;#x200B; In fact, I know when one of our Java devs wrote the code just because of this quirk LOL TBH they're only an issue because nil exists but that's a whole other complaint. &amp;#x200B; The problem with your reasoning on private in ruby is moot. Private and protected are mostly synonymous. TBH the main thinking I've embraced (IIRC it was gleaned from a Sandy Metz talk) is that private code shouldn't need tests, e.g. testing that 1+1 always equals 2 is pointless, while protected methods should be tested. Most times protected is best to use. Plus with the runtime and metaprogramming in ruby, you can still access the private/protected method anyways via send. So that might be one thing that always bugs you about ruby. TBH it's not a huge deal IME. &amp;#x200B; re: no ending parenthesis. You can put them there if you want but most rubyists don't because you don't have to, TBH it's never been an issue for me. &amp;#x200B; You'll find in ruby more of the responsibility is thrust on the developer, e.g. to write tests and not do dumb things, understand the scope being operated on, etc. In Java/C you can lean heavily on the compiler and your IDE. In ruby, you need to embrace tests, especially integration type of tests, i.e. testing the overall input yields the overall desired output. Things like guard and simplecov can help with making red/green testing easier.
That is nice to hear!
It was really good back in the day. It's pretty outdated at this point. You're better off picking up the ruby pickaxe or the new version of The Well-Grounded Rubyist. I'm a pretty big fan of Ruby Koans too.
I mean, our class instructor was explaining .map to us using a literal map as an example, but he got totally derailed when another student piped up with "it might mean Make Array Please" and stopped the class as he was so thrown (in a good way) to share it on slack with his fellow instructors... It was a nice moment. But yeah I'm aware of map and each, I'll have to go look up collect and see how I can use it in future.
You will read the book and find yourself drawn into the mystery that is Why, eventually abandon your life and move to Utah in search of the enigma, eventually to be lost to history yourself.
Coming into learning Ruby with no Object-oriented programming experience, I found the first half of Why's to be a very enjoyable and informative way to grasp the fundamentals. I recommend it to everyone even those with OO experience just cause it's a fun read.
Not my cup of tea, but I already had extensive background in programming languages. It's fun if you are starting out.
&gt; Implicit returns: these are just bad IMO and having return written explicitly increases readability at a quick glance Something you need to come to grips with is ALL statements and expressions return values in Ruby. So having an explicit return doesn’t add value because everything returns something. Understanding this will help you avoid some subtle bugs. foo = “foo” foo = if false “bar” else puts “baz” end foo # =&gt; nil This is related to the fact that ALL code in Ruby is executed, there isn’t seperate parse and execute stages. These concepts combined enable you to write some very nice code. Ruby also tries to reduce line noise (though fails sometimes with the Perlisms) so anything that isn’t required to make the code parse is optional; see point 2. And once you get used to it you’ll wish other languages did the same. Rust has kind of embraced implicit return though they have that weird semi colon thing. &gt; Having no empty parentheses when calling a method and passing no arguments: I understand the reasoning, but this also decreases readability IMO because foo = bar means bar could be anything foo = bar() lets me know bar is actually a method I used to be a strictly no brackets guy but over the years I’ve switched to brackets (almost (I see what you did there)) everywhere, so you do you. One thing to be aware of though is sometimes you might think something isn’t a method call when it actually is, eg accessing object attributes. class Foo attr :bar def something() self.bar = "baz" end end Foo.new.something NoMethodError (undefined method `bar=' for #&lt;Foo:0x01dc1a98&gt;) &gt; Third and last is: How weird would it be if wrote private in the same line as the declared methods everytime I wrote a private method? Until recently `def` returned `nil` (see point number 1) so this wasn’t possible. I think it was Ruby 2.5 that`def`was changed to return a Symbol to allow this so go for it.
I think it was more of an art project than a ruby tutorial. it's quite a funny book though.
ok, just finished doing that. what next? learn rails?
"Learn" Rails was supposed to be the first step. Wrestle with fat controllers for two years *then* you learn Ruby. Then you learn service objects. Then you learn Sinatra. Then you learn Rails.
I agree with many others here. It's fun but there are better books to learn Ruby. The pick axe book is great. Practical Object Oriented Programming in Ruby is fantastic.
i heard rack is the fastest so i’m going to use that. after i learn rails of course.
There is a lot of noise compared to signal, but I find it to be a very special resource I don't want to have missed. The more you enjoy something whimsical the more it will jive for you.
Well-grounded rubyist and eloquent ruby are my favorite books, with ruby under a microscope if you want to dig deeper. A bunch of folks warned me away from pickaxe.
It should be your *second* Ruby book, first learn the syntax then read this
Going to the crux of the question here. Idiomatic Ruby is very different from idiomatic Java or C# and you probably should strive to write idiomatic Ruby rather than coerce ruby to be similar to any other language. Things as simple as naming conventions for methods that return Boolean conventions are different in Ruby. Everywhere else you might have a method named isEmpty or is_empty but in Ruby it’ll always be named empty? This is a common polyglot problem and it’s fine in the beginning as you’re learning and need to get things done. As you spend more time in Ruby-land, however, all you’ll see is idiomatic Ruby so you might as well get used to reading and writing it.
It's still worth a read just for whimsy's sake. Reminds me of The Little Schemer.
Tbh, Ruby Koans is an amazing teaching tool. I hope there are more teachers in other languages that adopt this sort of style
If in doubt write your code then run rubocop across it to see how you are differing from the norm. You should try to match the accepted idioms of a language community IF your code is going to be read by others
right.
I spent years - decades even - writing in C and C-like languages and Ruby was a little different but only at first. Now they're all second nature. You'll be fine.
&gt; foo = bar means bar could be anything foo = bar() lets me know bar is actually a method, which not only makes it easier for me to understand what the code is doing but also easier to look for documentation available on the method Welcome to late binding in a duck typed language. Time to unlearn all the B&amp;D from those OO imposters. [Here's your introductory lesson](https://www.rubytapas.com/2018/06/05/barewords/) &gt; Anyone who came from C# or Java have some tips? Write idiomatic Ruby rather than trying to fight it. You're just unfamiliar, that's all. I spent years - decades even - writing in C and C-like languages and Ruby was a little different, but only at first. Now they're all second nature. You'll be fine.
I never liked it. I found it terribly confusing. I can appreciate the art but from a teaching background, I found it utterly useless. I preferred a style such as Chris Pine's learn to program. There are others who loved the guide though. People are different so their use cases are different too and what they prefer.
I still have a huge problem with the whole "I found a backdoor!" storyline. Is that really a definition people use for a backdoor? If it were, why would the rubygems team not eliminate gem + authors? I am pretty sure that not everyone agrees on the same definition, yet the guy keeps on chanting how he has discovered a super-sneaky mega-deadly "backdoor". I don't quite understand it. Then again people shouldn't be using SASS in the first place. The SASS folks are Google worker drones so they don't maintain the ruby code anymore since they are full-scale committed to Dart. Let these folks move, they won't be missed by anyone who is seriously using ruby. That's harsh - but the truth. PS: Actually, even aside from the term "backdoor", people who use eval() like that should be perma-banned anyway, even if not due to backdoor-abuse of people downloading the gem but simply due to idiocy alone. Unfortunately the rubygems-infrastructure is only very slowly adapting to more control that USERS have over downloads and installations when doing any "gem install" job. This is on the one hand a feature (manage + install all dependencies); but can also be abused by a**hats in general. There need to be some additional settings that people can do, such as "do not install when another author has been put in place of any gem involved in this install-chain"; and perhaps some who may screen changed code for a**hat activity in general, be it real backdoors or eval() clowns. Evidently this won't if the same author turned full-scale evil, but the real idea here is to simply give ruby users more opportunities to declare how they want to interface with dependencies, rather than to assume that 100% want to do blind gem installs. I myself actually manually (!) register gems I need into a ruby project (the one that handles all compilation and installation on my linux systems), and then I just install it through that project (which can also handle dependencies; but the quality is quite bad overall, it's very complex and merely a hobby project in the end; but for my use case it suffices). Another reason why gems itself should become better is simply to get rid of those "backdoor backdoor!" chanters, like that dude. He also couldn't wait but point out to his company over and over again, so the whole thing was really more of a promo - otherwise if the "backdoor" was the primary focus of interest, why would he keep on mentioning his useless company? People who are interested in telling OTHERS about a "backdoor"; don't go about telling stories of random companies UNLESS you keep the whole thing as an advert from the get go. ;)
Do you have an example of what you'd use the XML log for? Is it possible to extend with other output formatters? Thanks for sharing!
How about "mature"?
Pretty epic. Deserving of more upvotes from people too, for the effort. I myself would have given up early due to the complexity. Using eval() is indeed pretty terrible and should not be done in like 99% of the cases, but one can say something about keeping things simple. Terrible - but simple. :)
Hah thanks very much! ☺️ Indeed Eval is the silent killer. It was quite the effort to remove the usage of it. I ponder if I should have started with an AST from the begin with. But ah well. Thank you, again! 😊 Much appreciated!
While it didn't teach me to program much beyond the very basics, it remains one of my favourite books of all time. It's so funny and likeable, why's line of thought is addictive.
You are definitely not alone!
Mabe you're looking for `race_array.map.with_index { |el, idx| "#{idx+1}-#{el}" }.reverse! }` I wouldn't `#reverse_each` here. The intention of the code is less clear, and it's actually slightly slower. The case for `#reverse_each` is to avoid the unnecessary array allocations of `array.reverse.each`.
It tries to answer—right in your terminal—questions like the following: * Colleague added gemname to our Gemfile, what is it? * How outdated is my favorite gemname I am using locally, what's changed since then? * What's that benchmarking gemname's synopsis was, again? * There is gemname advised on the internetz for my problem, is it still maintained? Is it widely used? Fetches data from rubygems.org and GitHub, uses some heuristics to extract meaningful parts of data, and prints nicely.
&gt; race_array.map.with_index { |el, idx| "#{idx+1}-#{el}" }.reverse! } thanks for the reply! are you meaning the Enumerable#each_with_index or array#each_index? also, can i have that singular curly bracket befor the reverse? that seems off..
"Some people, when confronted with a problem, think 'I know, I'll use regular expressions.' Now they have two problems." -- Jamie Zawinski
&gt; are you meaning the Enumerable#each_with_index or array#each_index? Neither, that's Enumerator#with_index. &gt; that singular curly bracket The } on the end is a typo, I've edited that out.
Hells yeah buddy. :D
ah ookay, i was looking in enumerable docs and didnt, see it naturally. Whats the difference between enumerable and enumerator? anyway, when i plug that in and run my test, it seems to return the same array. im not sure if its my own error. my tests passes the method an array as an argument and checks if the result is equal to the original(it shouldnt be) and also if the result is equal to the example reversed and ordered ("4-element", "3-element",...)
You're doing it wrong.
 race_array.each_with_index do |el, idx| race_array.map.with_index(1) { |el, idx| "#{idx}-#{el}" }.reverse! end and heres my test require "horse_racing" describe "#horse_racing_format!" do it "should modify its parameter (destructively)" do horse_race = ["Abricot du Laudot", "Black Caviar", "Brigadier Gerard", "Coup de Folie"] copy = horse_race.dup horse_racing_format!(horse_race) expect(horse_race).not_to eq copy end it "should follow the horse racing formatting style" do horse_race = ["Abricot du Laudot", "Black Caviar", "Brigadier Gerard", "Coup de Folie"] horse_racing_format!(horse_race) expect(horse_race).to eq ["4-Coup de Folie!", "3-Brigadier Gerard!", "2-Black Caviar!", "1-Abricot du Laudot!"] end end
This is really cool! Wish I would have had this when I freshly started out with Ruby and Rails. I love little handy tools like these that simplify searching workflow. Good job on the documentation too! Answered all of my questions in the readme.md. Any next goals for it?
Thanks! &gt; Any next goals for it? Not sure for now. Probably when/if people will use it, I'll have some cases to fix, and enhance the heuristics of parsing. I don't have any clear "roadmap", because what I wanted to achieve (make a handy tool + experiment of parsing free-form data of gems into more machine-readable format) I've already achieved.
You've got a loop around a loop, which makes no sense at all in this case, and you really should've mentioned the destructive modification up front, because that is, in general, terrible style for a method and only used very carefully and selectively. Nevertheless, this probably passes your tests: def horse_racing_format!(race_array) race_array.map!.with_index(1) { |el, idx| "#{idx}-#{el}!" } race_array.reverse! end Good luck!
ah ok after looking at it and contemplating, i totally see what you mean. thanks so much for not only helping me solve it but also giving me great explanations into whats happening! very much appreciated!
I half made a near identical post before realizing I should prob check that someone else hadn’t already.
Any reason you didn't mention Rexical (formally Rexx) to generate this? Yes, docs aren't _that great_...
Input to reporting: history report and changes report. https://burdettelamar.wordpress.com/2014/12/14/changes-report/
I had a use case for something similar. Summarize a project's dependencies: https://github.com/sshaw/explain-dependencies
I avoid bundler, largely because I do not need it and I do not like it (although I agree with the idea to have it had merged). So I will ignore the bundler-specific question. Instead I will look at the question as to what you may want to use, e. g. .rb files, and may wish to build a .gem from this via oldschool .gemspec (the even older way to install is setup.rb, which I still use as a generic fallback). Actually building a .gem and rubygems homepage has a nice tutorial - I recommend it: https://guides.rubygems.org/ Even if it differs a bit from bundler, the information you can obtain there is VERY worth the time. Anyway - say that you have a project called foobar. Typically you create some directory called foobar/ - here I refer to the base directory on your local system. Inside, create lib/foobar.rb which will load up other files, and also create lib/foobar/. At the least that is what I do. Now, in that lib/foobar.rb file, you add code that pulls in the other files. This is the file that will be loaded first when you do: require 'foobar' How you decide to structure that file is up to you. I myself often create another subdirectory called requires/ where I put require .rb files that load other parts of a project, depending on how large that project becomes. Inside foobar.rb I often then only do: require 'foobar/requires/require_the_foobar_project.rb' Or something like that. I think you make this too complicated though, because it really is just multiple requires (call a .rb file); in python this is a bit more annoying. While import works, requiring single files in python is, from my memory, slightly more complicated than the ruby way: require 'bla.rb' load 'bla.rb' # but people prefer require over load, for lots of reasons The, in my opinion, more important part is to use some toplevel "namespace", usually a module. So: module Foobar; end There you can put lots of stuff, classes, constants, anything that you need in your project. Ideally design via a OOP centric way - it just leads to a better code layout. I am seeing lots of terrible ruby code being pushed to rubygems. Many people don't quite have practice with it - practice is the most important thing. You should start pushing a gem as soon as possible. Don't mind if the quality is not yet perfect, it will get better with more iterations, you will add more documentation etc... - even if it is just a test gem. Ironically the most "popular" gem that I ever wrote, at the least in regards to downloads, is a stupid gem where I only dump a lot of custom ruby code that I may use on any given system. It is a very chaotic project but people seem to find it more useful than projects that I found to be more important ... it's very strange to me. :\ :/
I actually reached out to them last week. They said ticket prices should be about the second as last year (400/700).
If you installed bootstrap-sass 3.2.0.2 to a Rails app and deployed it, your app was vulnerable to remote code execution from a third party. This would clearly be a severe security vulnerability in your app, no? I think the author was using 'backdoor' as a synonym for 'security vulnerability that allows remote code execution'. I maybe would have used the word 'vulnerability' instead, but I think 'backdoor' used in this situation is probably commonly understood. I'm not sure you understood the actual vulnerability that was released (by unknown parties) in bootstrap-sass 3.2.0.2? The rest of your comment I find fairly unintelligible, not really sure what you're going on about. Not really asking for clarification, I don't think there's much there.
Many of your issues do seem to stem from only using regexes! To be precise, some form of context-free grammar would parse the jsonpath language. (In fact, there's an incomplete one [here](https://github.com/stevenalexander/antlr4-jsonpath-grammar/blob/master/JsonPath.g4)). Converting that grammar's parse tree to an AST may or may not be worthwhile (and using a CFG at all may be overkill if you don't need to catch 100% of jsonpath cases), but certainly makes an interesting project!
I reckon he mentions his company the first time this issue got exposed. Something along the lines of "use our scan to see if your app is compromised" IIRC.
For sure. I absolutely agree. That's why I didn't start with an AST. The scanner fulfilled most of my needs. But made for obscure bugs. :-)
Did you consider using [parslet](http://kschiess.github.io/parslet/) for a parser?
Hey man! Thanks for the tip! I'll take a look. 😉
I think I’ve heard of it but once, and usually something that I need StringScanner for doesn’t get too complicated that I can’t manage it. The [tokenizer method](https://github.com/ruby/rdoc/blob/bcc91fe7ade33914395291f9d1683af30b35b9d5/lib/rdoc/markup/parser.rb#L454) for RDoc markup isn’t 100 lines, and one I’ve written for work is around the same
you should initiate `sum = 1`, not `0`
Thank you! I am a doofus! lol
No problem! FWIW a more Ruby-like solution could be done using [\#reduce](https://ruby-doc.org/core-2.6.2/Enumerable.html#method-i-reduce) ```ruby array.reduce(1) { |product, n| product * n } ```
lib for gem code, bin for executables, test for tests, root files are config files basically, rarely more is needed IMHO
I'm just asking out of curiosity, but what do you have against bundler? Do you use something else in its place?
Good work zverok.
lib houses code that isn't directly related to your app, for example, a client class that you write to connect to a third party api
This is a good case to use a while loop and looking at the index of the array. Think about what index you are looking at in the input array after each iteration and when to stop iterating.
fun little problem. &amp;#x200B; ok, you need to know how to address an element in an array. you need to know how to append to the second array. You need to know how to find out the size or length of an array. Like the other comment said, a while loop is good.
I have been using parslet and it's really cool, but I also recently came across [whittle](https://github.com/d11wtq/whittle). Only mentioning it to add to your options.
another way to look at is with Array#shift. Then instead of incrementing an index that you use to read a particular member of the array, you drop as many elements as what you last saw. Either way you have to be careful about overrunning the array.
i'm a bit late to the party, but fwiw, each_pair is a pretty unique method that almost nothing has except hashes and hash like things. each is _the main_ Enumerable method. For most collections pairwise enumeration doesn't make sense.
&gt; If a project does not have any commits in over a year &gt; and have very low count of forks and stars, this is a concern. Why should that be a concern? There are projects that may have lots of commits, all of which do cosmetic nothings, in reality. Not every project has the same size, so why should no change to a small project be a major concern to anyone? &gt; but there are no issues or pull requests Not every project even has that. You can't file issues on rubygems.org directly, unfortunately. You depend on Microsoft here, through GitHub - or another wholly privately owned entity, which kind of defeats the purpose of permissively licenced open source code. &gt; On the flip side, no commits in over a year, there are a lot &gt; of pull requests and a lot of issues, I would likely consider &gt; the project abandoned. The thing is, and this was raised at the ruby bug tracker already, such as by headius in regards to patches that have been tested, work, but have not been merged in due to NO MAINTAINER of some projects, is that there is currently no simple way to maintain a project by OTHER people. So they are slowed down too. In the long run something has to be done here when it comes to inactive projects in general. You don't want them to tain the other ACTIVE projects really.
In most cases, the lib directory should only have two things in it: 1. A file whose file name is the name of your gem with an .rb extension. This is the file that people will require to use your gem. 2. (Optionally) a directory whose name is the name of your gem. Within this directory, put all the code for your gem that isn’t in the lib/{gemname}.rb file. In most cases, (1) should require any files from (2) that are needed to use your gem. All the code for your gem should be nested in a module whose name is the name of your gem (converted to Class case). You can read the bundler documentation for more details or run ‘bundle gem {new gem name}’ to see what bundler creates for you.
In a project created by ‘bundle gem’, ‘bin’ is used for development-time executables (like setup and console) and ‘exe’ is used for runtime executables.
Deploy the lost art of recursion. def process((head, *tail)) return head if tail.empty? [head, *list(tail[head-1..])] end input = [2, 1, 3, 2, 5, 1, 2, 6, 2, 7, 1, 5, 6, 3, 2, 6, 2, 1, 2] list(input) #=&gt; [2, 3, 1, 2, 2, 1, 5, 2, 2]
Ignore the iteration weenies and deploy the ancient magicks of recursion: def process((head, *tail)) return head if tail.empty? [head, *process(tail[head-1..])] end input = [2, 1, 3, 2, 5, 1, 2, 6, 2, 7, 1, 5, 6, 3, 2, 6, 2, 1, 2] process(input) #=&gt; [2, 3, 1, 2, 2, 1, 5, 2, 2]
https://jmettraux.wordpress.com/2011/05/11/parslet-and-json/ But I'd use [Racc](https://github.com/tenderlove/racc) and FTW.
A for loop with an index pointer is your friend here.
 a1 # original array a2 = [] idx = 0 until idx &gt; a1.length a2 &lt;&lt; a1[idx] idx += a1[idx] end puts a2
Also write a simple test with the input and output. So every time you run it’s obvious if you’re close...
Yay Atlanta!
Have a look at this [http://www.pythontutor.com/visualize.html#mode=display](http://www.pythontutor.com/visualize.html#mode=display), switch it to ruby mode, copy the class example you have in there, and execute an it on an example array. . Step through the execution, follow where the program pointer is, by looking at the arrow next to the code (on the left) Here's one I created for you : [pythontutor](http://www.pythontutor.com/visualize.html#code=class%20FlattenArray%0A%20%20def%20self.flatten%28array,%20result%3D%5B%5D%29%0A%20%20%20%20p%28array%3A%20array,%20result%3A%20result%29%0A%20%20%20%20array.each%20do%20%7Celement%7C%0A%20%20%20%20%20%20next%20if%20element.nil%3F%0A%20%20%20%20%20%20element.kind\_of%3F%28Array%29%20%3F%20flatten%28element,%20result%29%20%3A%20result%20%3C%3C%20element%0A%20%20%20%20end%0A%20%20%20%20result%0A%20%20end%0Aend%0A%0AFlattenArray.flatten%28%5B%5B1%5D,%202,%20%5B3,%204%5D%5D%29&amp;cumulative=false&amp;curInstr=14&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=ruby&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false)
Well this is something! I wrote the original RubyCAS server a dozen years ago. If I remember correctly, I did it in _why's Camping framework (the madness!) On a whim. I haven't used it or really thought about it in a decade, and all but forgot about it. Crazy to stumble on this video here and see that it's still alive and kicking, living on as a Sinatra app.
I don't usually like to just post a working example to a question like this, but I figured that showing you some actual working code and explaining it step by step could be really helpful to helping you understand what is going on. I recommend that you take my example, run it, read through the comments, and try to figure out how it's working. Once you've done that, come up with a different way of doing it. Others have suggested using a while loop and shifting items off of an array. Write a script that does it that way. Try different things out and use this as an opportunity to learn. My code below is not the "best" or most efficient way to solve this problem, but it's easy to read and follow along. Please don't just copy and paste this and move on, it's really not helpful to you at the end of the day. Anyways, here's the code. I hope this helps! ``` def generate_array(input) # The array of numbers to return at the end of the method. output = [] # This variable will keep track of how many values you should # skip before appending something to the output array. # # Since you want the first item, it will start at 0. values_to_skip = 0 # Loops through each value in the input array. # # Others have suggested using a while loop and shifting items off # of the array, and that will work just as fine as well. One of the # beautiful things about ruby is that there are usually a dozen # different ways to solve the same problem and each one is correct. # # Looping through the values this way though has a couple of benefits. # # First of all, you will not have to worry about keeping track of your # position in the array and accidentally trying to grab values outside # its range. # # Secondly, looping through the array would not modify the input array. # It is generally good practice to not modify the variables passed to # your methods unless that is its intended purpose. input.each do |value| # The general idea behind this method is to keep track of how many # values we need to skip before adding a value to the output array. # # Since we start off at 0, this will ensure that the first item in # the array will be added to the output array. if values_to_skip &lt;= 0 # If there are no more values to skip, then append the current # value to the output array. # # This variable will start off at 0, so the first item in the # input array will be added. output &lt;&lt; value # Once a value has been added to the output array, we should # skip that many values until we append another item. values_to_skip = value end # After every iteration of the loop through the array, we are one # step closer to adding an item to the output array. # # If we just added 2 to the output array, then that means we should # skip 2 values. At the end of the loop, the value of values_to_skip # will be 1. # # It will enter the next loop and do nothing because values_to_skip # is not 0 yet. At the end of that loop (it will have skipped 1 # item already), the value will be 0. # # The next loop will then see this value is 0 and append a new item # to the output array. values_to_skip -= 1 end # Finally, return the output array. output end # Your example input array. input = [2, 1, 3, 2, 5, 1, 2, 6, 2, 7, 1, 5, 6, 3, 2, 6, 2, 1, 2] # This will print out [2, 3, 1, 2, 2, 1, 5, 2, 2] pp generate_array(input) ```
Get to know Ruby's enumerable methods, life is much easier when you're familiar with them. For this one, `map` and `compact` will work for you. arr = [2, 1, 3, 2, 5, 1, 2, 6, 2, 7, 1, 5, 6, 3, 2, 6, 2, 1, 2] cur = 0 arr.map { |i| ((cur -= 1) &lt;= 0) ? cur = i : nil }.compact I'm sure there's a way to do this without the `cur` temp variable, but I didn't chase this too far. Breaking it down: * `arr.map`: this walks through the array and returns a new array with the same number of elements as the original, with each element replaced with the result of the block passed to `map` for that element * `((cur -= 1) &lt;= 0) ? cur = i ? nil`: decrement `cur`, if the result is less than or equal to 0 set `cur` to the current element (this also returns the current element as the result of the block), otherwise return `nil`. * `.compact`: the array returned by `map` will now contain the elements you want along with `nil` for those you don't. `compact` will remove the `nil` elements leaving the final result. Some further notes: * Initializing `cur` to 0 dictates which element of the array to grab first. * The `&lt;=` in the conditional makes sure this doesn't explode on an array that contains 0. * The problem doesn't stipulate if you could expect negative numbers, so I assumed all numbers `&gt;=0`.
 array = [2, 1, 3, 2, 5, 1, 2, 6, 2, 7, 1, 5, 6, 3, 2, 6, 2, 1, 2] result = [] result &lt;&lt; array.shift(array .first).first until array .empty? result #=&gt; [2, 3, 1, 2, 2, 1, 5, 2, 2]
Golfed to l=-&gt;((h,*t)){h ?[h,*l[t[h-1..]]]:h} l[[2, 1, 3, 2, 5, 1, 2, 6, 2, 7, 1, 5, 6, 3, 2, 6, 2, 1, 2]] #=&gt; [2, 3, 1, 2, 2, 1, 5, 2, 2]
Thanks man! Very cool! I will take a look! 👌
You had 10 upvotes on crypto in ruby and I was personally surprised. I went through your profile and it seems like you frequently have 5-10 upvotes with no comments or 1 comment made by you. I am not saying that you bot 10 upvotes every post, but it sure looks that way.
So many of your posts have between 5-10 upvotes with no comments or one comment made by you. Weird, especially in r/ruby where almost every post in new has comments on it, ones with less upvotes. The only two posts on the front page with no comments are yours. This seems like a trend on your account.
This would be cool except for the fact that there is no code to show for this whole thing.
I had a similar solution to yours and a similar bug in my code. The problem is a off-by-one in the comparing with the size of a1. Your's should be `until idx &gt;= a1.length`. You can test this with this input: `[2, 1, 3, 2, 5, 1]` I had a similar problem in my code. ``` a = [2, 1, 3, 2, 5, 1] b=[] i=0 while i &lt; a.size # this was i &lt;= a.size b&lt;&lt;a[i] i+=a[i] end puts "#{b}" ```
`size_splitter` doesn't sort the way you would think it should. The sorting is for the outer array, not for the arrays inside. ``` [[10,2,3],[5,1,2]].sort # =&gt; [[5, 1, 2], [10, 2, 3]] [[10,2,3],[5,1,2]].map &amp;:sort! # =&gt; [[2, 3, 10], [1, 2, 5]] ```
I used this stackoverflow answer to learn about blocks and `yield`: https://stackoverflow.com/a/3066939 And this is what I came up with: ``` def block_splitter(array) a,b = [],[] if block_given? array.each do |el| yield(el) ? a &lt;&lt; el : b &lt;&lt; el end end [a,b] end ``` simple test: ``` block_splitter([1,2,3,4]){|x| x &gt; 2 } # =&gt; [[3, 4], [1, 2]] block_splitter([1,2,3,4]){|x| x % 2 == 0 } # =&gt; [[2, 4], [1, 3]] ``` You could now implement your `size_splitter` method by calling the `block_splitter`.
okay but before i can sort it i am having trouble just splitting it into arrays. when i try in irb i can get it to return the size of the words, but when i try to use the size to sort them into two seperate arrays it wont work. so if i say map the array and try to push words whos length == 3, it wont work, and i think there i am first messing up. array = ["dog", "cat", "data", "ask", "win", "deal", "one", "two", "cow", "beer"] array.map do |word| word.length == 3 ? puts word : puts "no" end didnt work but array = ["dog", "cat", "data", "ask", "win", "deal", "one", "two", "cow", "beer"] array.map do |word| puts word.length end will work. i think there is something going wrong specifically when i am trying to make an array with two arrays. then i can try sorting it correctly.
Your version of `size_splitter` has a return inside the `map` loop. Don't do that.
&gt; 'backdoor' as a synonym for 'security vulnerability that allows remote code execution'. Specifically for a RCE vuln that was intentionally created and disguised as a well know cookie param. I haven't seen the link in the blog post, but look at the [Github Issue](https://github.com/twbs/bootstrap-sass/issues/1195). This was intentionally planted backdoor. If you deployed this version of the gem on this day, everyone can easily compromise your server.
You could use Enumerable#group\_by which is almost this, except how the result is formatted. ``` [1,2,3,4].group_by { |x| x &gt; 2 }.yield_self { |hsh| [hsh[true], hsh[false]] } =&gt; [[3, 4], [1, 2]] ```
I think implementing the block splitter is a bit too complex right now, I haven't even begun to start to solve for it and I am meant to solve the first method by itself anyway
Ok, your `size_spitter` implementation does a lot wrong. - Use `each` instead of `map`. - Depending on the word length append to the correct array. - Sort right before you return the result. Sort each of `ary1` and `ary2` individually
great explanation! this for some reason doesnt pass my second test but i at least understand it... heres the block array.each do |word| word.length == size ? ary1.push(word) : ary2.push(word) array = [ary1.sort, ary2.sort] end thanks for all your input!
you still sort both arrays for every word. Don't do that. It's more than enough to sort once. ``` def size_splitter(array, size) ary1, ary2 = [], [] array.each do |word| word.length == size ? ary1 &lt;&lt; word : ary2 &lt;&lt; word end [ary1.sort, ary2.sort] end ```
You can use `select` under the hood to do the heavy lifting. ``` def size_splitter(array, size) matched = array.select { |a| a.size == size } leftover = array - matched [matched.sort, leftover.sort] end ``` ``` def block_splitter(array) matched = array.select { |a| yield(a) } leftover = array - matched [matched, leftover] end ```
That server was supposed to be my first (and only due to nature of my jobs) opensource contribution. Wrote a pluggable authentication system for it and the project went on a hiatus :( Would do it again though. It was fun and the experience still lets me push for proper authentication and authorization reasoning in my work.
 def op_true( stack ) stack.push( 1 ) end That's a very strange style in ruby. While people are different, I have a slight feeling that the one writing the code originally was not a rubyist; and/or, the editor influences that style a lot. Most ruby code I see does not use ' ' around arguments. Or omits () altogether; but this strange hybrid style is very, very rare to see. I think there must be some visual reason for why the author uses that strange style.
https://ruby-doc.org/core-2.6.2/Enumerable.html#method-i-partition
Let's see if he responds to this!
I'm ambivalent on implicit returns. If your method is really only ~5 lines or less, and only has one return point, they are great. We can fantasize all our methods will be like that, but they aren't. I tend to use explicit return whenever my method is not like that -- but this is a very unpopular choice. Avoiding empty parens -- you'll get used to this quick. I agree that `foo = bar` is the most potentially confusing place they are. Although `bar` can't be _anything_, it can be a method call or a local variable, that's it. You will be pretty much the only person using parens on no-arg method calls (or definitions!) if you choose to. private in same line as declared methods -- this didn't use to be _possible_, in older rubies, is I think why it is not the popular convention. I think this is the one you will be least alone with, I feel like maybe it's catching on? could just be my dream though. :) Increasing numbers of projects are using rubocop to enforce certain style consistencies. If you're doing that, there is no longer developer choice involved for some of these things. I think it has plusses and minuses.
Oh yeah, I use select and map _all the time_, and I think you will too if you think about where to, and find it makes perfectly readable code with many fewer lines.
shevy-ruby has well known hostility to everything that isn't shevy-ruby.
Why are people interested in building out features that are already in rspec in minitest, instead of just using rspec?
Can you explain why the two reverses are not identical?
Thanks for sharing
U can find more patterns here [https://github.com/infinum/rails-handbook/tree/master/Design%20Patterns](https://github.com/infinum/rails-handbook/tree/master/Design%20Patterns)
&gt; We have established the goal of discussing the future of the &gt; bundler and rubygems integration with ruby-core at &gt; Ruby Kaigi. Huh? Isn't that in the future? Or does he mean talking AT the kaigi about it? &gt; Besides that, I think all these efforts have led to the core team have &gt; a better and more consensual vision of the changes that will be &gt; made and their motivations. Well, the core team is one thing; and matz as the boss is another thing. And yet a third thing is ... the users. Evidently rubygems (and bundler) have to be useful to the users. And since these numbers are high, in my opinion that is where most of the focus for improvements go. The "activation" of gems is very confusing to me, though. I remember having recompiled a new version on GoboLinux and when I removed an old ruby, suddenly things where no longer found e. g. an error such as "gem could not be activated". That confused the hell out of me. I don't think it should be that way. It is not intuitive. It is actually surprising behaviour - and it is different to what I get when I use oldschool setup.rb. setup.rb was much simpler. I don't know rubygems well enough to change it, and I know bundler even less, but IMO things should be straightforward at all times. Ideally we could completely get rid of having to "activate" or let rubygems "activate" any gem, because this leads to assumptions that may not always work in every setup or scenario. I assume it is done mostly to be able to find a specific version, but ... it's still confusing. How many of you can explain this out of the box without having to look at some guide or the code? &gt; The default Rails binstub. I started a discussion in Rails about &gt; whether it should become a standard bundler binstub, thus &gt; making maintenance easier and conflicts less likely. I can not speak for rails but I find it confusing when there are arbitrary differences between bin/bundle and bin/bundler, or rails (or any other gem) telling me "Hey I am just a stub and thus useless!". Ideally everything should be as modular as possible - but also default to a "batteries included" variant. Then whoever wants to cut down on stuff, could remove things (the debian team is notorious here, including splitting up packages into 50000 separate packages) whereas the lazier folks could just keep on using things as they are (and hopefully not get confused about it, ever).
Will hammers kill off screwdrivers? Find out next in my clickbait article!
Never.
This is hilarious :D
I am just confused, most people aren't even down with the code, but 17 upvotes?! His github seems legit, lots of posts tons of stars, but 18 upvotes at 77% but all the comments are negative? In all my years of reddit and modding on reddit this sticks out heavily.
It does make the job done as it is. Will probably need minor upgrades to be used with newer Ruby versions.
Banned where?
[ruby-ll](https://rubygems.org/gems/ruby-ll) might also be an option if your grammar is LL(1).
I don't like this comparison at all. Superficial statements and no facts. &amp;#x200B; "Incredibly easy to deploy" And Django not? Why? &amp;#x200B; "Scalable caching system?" And Rails caching is not scalable why? &amp;#x200B; "Really overkill for smaller projects" And Rails not? Why? &amp;#x200B; "Everything gets deployed together?" And in Rails not? &amp;#x200B; \+ the sh\*t title that does not make any sense either.....
That subreddit was probably unrelated to Hanami the framework, the one you're looking for is https://www.reddit.com/r/hanamirb/
I saw that someone, quite justifiably, wrote another Ruby implementation called CASino. I assumed people would move to that, but seems like the CASino project stalled a few years ago. GitHub needs to come up with a better system for allowing others to take over abandoned projects. Right now a hard fork seems to be the only option, and this tends to only add confusion for potential users with no easy way to tell which fork to pick up on.
Should also have answered the second question: yes, it's possible to extend with other output formatters. The open log puts plain text entries to a file that's continuously flushed, so that no matter what happens you have something. When the log is closed, method `dispose` converts the text to XML. It could just as well convert to any other format that has structure: HTML or JSON, for example.
&gt;u/jamesgolicku/ViralInfection My main motivation for building this sort of thing was to be able to structure a test with nested Ruby blocks, then have that same nested structure in the test log. I'm interested to know how I would do that with rspec.
That's why the method checks first for `obj.respond_to?(:each_pair)`, because if true, that's likely the best way to handle the data. For most collections, that would be false, and `:each_pair` would not be used.
Hmm. An account with 0 comment karma. I think it is not worthwhile to comment to people who are not genuine. However had, for the pure merit alone for the question in itself - different languages have different niches and use cases. While ruby and python admittedly have a very similar niche, I don't feel that they have the same target group. For example, I feel that ruby is much closer to perl and the original perl users than python ever is (due to a different philosophy). There is also momentum and python has a lot of momentum right now. So it is a pretty useless trick question, where the one who asked the question has no interest in discussing anything - please do not upvote him.
I believe you'd nested with `context` blocks, then use the [documentation formatter](https://relishapp.com/rspec/rspec-core/v/2-5/docs/command-line/format-option) (for nesting), or write your own formatter (for XML) using [rspec's formatter/reporter plugin API](https://ieftimov.com/post/how-to-write-rspec-formatters-from-scratch/). It wouldn't shock me if there's an XML reporter/formatter around somewhere already.
Type checks and object capability checks are almost always a smell, and indicate design issues. That aside, you were talking about collections. Not hashes specifically. I don't know what significance `Hash#each_pair` has in terms of collections, which is what I tried pointing out. There is also `#transform_values`, `#transform_keys`, `#keys`, `#values`, `#each_key`, `#each_value` and other hash methods. Why do you care about `:each_pair` specifically? &gt; that's likely the best way to handle the data Can you not redesign the system so that you ask the objects passed in to do what you need from them, and they implement things the way they see fit. This probably would mean that you can't handle primitive types but you would need to have custom types passed in. Without this the code feels feature envy plus it reimplements polymorphism.
An other way would be to refine the built in types, with the capabalities you need. Like to_json does it just without global monkey patching
TLDR: really bad article. Looks like some ideas that are on the internet about ruby python, then rails, django and then, let make an art.
Maybe he write functions lik that as a way to remind himself that that they are functions, not variables...
Yes, jrochkind, I see what you mean (having look at [https://relishapp.com/rspec/rspec-core/v/2-6/docs/example-groups/basic-structure-describe-it](https://relishapp.com/rspec/rspec-core/v/2-6/docs/example-groups/basic-structure-describe-it)). Thanks for info.
`Array#reverse` returns a new array, so removing elements from array2 doesn't modify the iteration, but `reverse_each` is iterating backwards over the original array1, so removing elements can change the iterator's next item. c.f. https://github.com/ruby/ruby/blob/e3b6c7c7ebca1b051dbaa6f33494e92f5638fcc9/array.c#L2148
No real content, just an ad
A quick glance at the page shows that there's a linked [sample chapter](https://shop.jcoglan.com/building-git/history.pdf) if you'd like to take a look.
was already posted (by me) but quite very good especially the source code of jit itself: [https://github.com/jcoglan/jit](https://github.com/jcoglan/jit)
`array.select &amp;100.method(:&gt;)`
Easy on the hashtags please, Reddit is not Twitter or Instagram.
thats on the definition, not an invocation.
I am looking forward to the announcement for DragonRuby from /u/amirrajan https://rubykaigi.org/2019/presentations/amirrajan.html#apr19 and Sorbet.rb https://rubykaigi.org/2019/presentations/jez.html#apr19
And was already recently posted: https://www.reddit.com/r/ruby/comments/bbf1q9/jit_git_implemented_in_ruby_all_described_in/
Nice writing, I really enjoyed it.
[48 comments](https://www.reddit.com/r/programming/search?q=Moving+from+Ruby+to+Rust+) **submitted 1 month ago** by steveklabnik1
_Moving a core algorithm within our Ruby app to Rust_ **FTFY**
Nice, and a good write-up. Would be interesting to compare to the somewhat popular third-party [activerecord-import](https://github.com/zdennis/activerecord-import) gem, and see if there are still things supported by activerecord-import not supported in Rails 6 out of the box.
It seems somewhat misleading to describe `eval File.read(filename)` as "parsing". I also think that any tutorial that teaches people to use `eval` to execute arbitrary code should include a security disclaimer.
Thank you for your feedback. &amp;#x200B; Maybe I wasn't enough clear, but \`eval\` shouldn't be described as a way to "parse". I just propose to use \`eval\` in the context of our instance (so it's used in a limited scope). &amp;#x200B; Also, \`Gemfile\`s and \`gemspec\`s are evaluated using \`instance\_eval\` &amp; \`eval\` with a \`TOPLEVEL\_BINDING.dup\` hehe in bundler. &amp;#x200B; And tons of people use bundler everyday without any problem.. &amp;#x200B; Anyway, thanks again for your feedback.
&gt; I just propose to use `eval` in the context of our instance (so it's used in a limited scope). The scope of `eval`, as defined by what effects it can have, is unlimited. &gt; And tons of people use bundler everyday without any problem.. That's specifically because the file that is eval'd has the same level of trust as the rest of the Ruby code in the system, which is not necessarily true here. (If it is, you could easily add a disclaimer to that effect.) If you don't see the difference between what you are doing and what Bundler is doing then that is concerning.
"concerning" means?.. &amp;#x200B; I totally see the difference.. 🙃🙂 &amp;#x200B; I just believe that the Rubyists are enough aware to not use \`eval\` in an unsafe context (As it is reminded in every Ruby books since a looong time..). &amp;#x200B; After, we're not here to argue about something that I agree with 🙂
&gt; I just believe that the Rubyists are enough aware to not use `eval` in an unsafe context And yet arbitrary code execution is still one of the top 10 vulnerabilities in 2019. Again, I think you have a responsibility to inform your users of the security implications of the code you are instructing them to use.
There is a difference between using an \`eval\` in a controller action. And evaluating a DSL contained in a specific file.. This evaluation is only processed through this file. So if an untrust developer get access to this file, then you'll probably encounter some other serious issues.. Anyway, I'll repeat myself: I AGREE WITH YOU 🙂
&gt; So if an untrust developer get access to this file, then you'll probably encounter some other serious issues.. Nowhere in your post do you make it clear that the file you are "parsing" must be trusted. If you had done so, we wouldn't be having this conversation, since that is all I am asking you to do. &gt; Anyway, I'll repeat myself: I AGREE WITH YOU Then why don't you add a security disclaimer to your post?
I just added a security disclaimer where I describe the file evaluation.
Thank you!
Thank you for the link 😉
It’ll be a pretty interesting presentational say the least :-)
 \`activerecord-import\`, for example, supports validations and callbacks for mass inserts; Rails doesn't; I think, that's the main difference (though I never used \`activerecord-import\`, maybe, there are more subtle differences)
There used to be some packaging that literally packaged the whole ruby interpreter too. I forgot the name; never needed it. IMO it may be best to just use gems or even just put everything into a single gem. I am not sure what you mean with "distribute the binaries" ... do you use something to compile some C code? While fpm is great, I myself would not use any .deb package. Gems should be the way to go, not distribution-specific solo-solutions really.
Honestly I like it. I would suggest one extra change which is to take a literal value OR a block, so you can make lookup tables quickly with: lookup = large_array.map_to true
I wrote about ruby-packer here: [http://nts.strzibny.name/making-a-ruby-executable-with-ruby-packer/](http://nts.strzibny.name/making-a-ruby-executable-with-ruby-packer/)
asdf 😂
I would create docker images with ruby + gems + your files. That has the downside of introducing docker into the mix. Which might be a huge task in itself, depending on how your environment. Or it might be relatively easy. But I think the docker ecosystem has more documentation, testing, and best practices than traveling ruby or ruby-packer or similar projects.
Well in that specific case you should do `large_array.to_set` but sure, that seems like a reasonable addition.
It sounds like you're maybe thinking of [Traveling Ruby](http://phusion.github.io/traveling-ruby/). (It does ship the interpreter.)
mruby would be a great fit here if you only have to deal with a single target platform. It has some limitations (library selection can be slim), but it is very easy to package up into a single binary.
very nice! keep up the good work, this is very easy to read.
Cool. How have you found Lambda overall? I’ve been toying with the idea of using for some image processing but never quite got there.
OCRA packages the interpreter
I've built standalone applications with Ocra. It works well but only creates Windows executables or installers (using Innosetup).
The scripts are mainly for system administration. Is it possible to integrate Docker container with the existing system?
This sounds like a perfect fit. I have no idea how i missed it.
In this case I care only for linux x86\_64 systems. I see there is mruby in Ubuntu repos. Nice!
I think of something similar to compiled Go script. Traveling Ruby is packaging interpreter and the script.
I never fully understood why we need rvm and rbenv. Yes, sure, I understand that e. g. debian cripples ruby by default and uncrippling things is annoying in particular there. But why even use debian in the first place? Why not actually go about managing different versions OF EVERY PROGRAM on your computer, anyway? That's precisely what GoboLinux did many years ago. I do this for all programs too (although admittedly, I actually use a hybrid system mostly because I am very lazy and often can not spend any time debugging why something may not work properly, so I just dump it into /usr and move on doing other things instead; time is a very limited resource). &gt; It is important to note that RVM and rbenv cannot be installed at the same time because of the &gt; way RVM handles the 'gem' command. And these clowns still have the same old problem. That has NOTHING to do how they "handle" gem - it is the old problem that the FHS has. That is also why debian is using clutches such as /etc/alternatives/ or having a symlink pointing to /usr/bin/ruby/ since there can not be two programs installed with the same name (and gem is often very specific for the ruby version installed, or has anyone tried to use a very old "gem" on a recent ruby?). &gt; RVM overrides cd and gem commands to enable some of its functionality. "What about those &gt; commands?" you ask. To which I reply: if that is an issue then rbenv might be a better fit. Or simply install ruby under e. g. /Programs/Ruby/2.6.2/ and et-voila. And literally do that with every other program too. It beats the other methods because it works for all programs. &gt; There has been quite a bit of controversy surrounding the rbenv/rvm divide. There is no divide - they both suck and are unnecessary. Admittedly when you are stuck with debian then these are better than the debian way of slicing things up into 10000 packages and forcing you to find out what you have to do to uncripple it. Or is there an easy way to tell debian to stop breaking things? Why is mkmf not available by default? Total clowns. No wonder dpkg is written in perl - dinosaurs hackers who once wrote scripts then moved away anyway. Now nobody is maintaining this mess anymore, unsurprisingly so.
Check this ST package [https://packagecontrol.io/packages/RSpec%20Buddy](https://packagecontrol.io/packages/RSpec%20Buddy), it even generates describe blocks for spec files..
Sounds like you could use a private gem repository.
https://github.com/pmq20/ruby-packer
I agree with your point. I think the stack overflow survey takes care of that because the chef users that don’t know they are writing ruby wouldn’t list ruby as a technology they use.
I don’t want to start another debate about this, but I’d consider rails developers ruby developers.
I don't really care that much about your religious convictions. If you hate Debian, you can probably find like minded people somewhere else to talk to about that. If you have a better option for binary version management that can help rubyists and that works in osx, Debian, arch, fedora etc, I suggest you talk about that solution instead of how bad you think some other software is. As it stands now your post is mostly just /r/iamverysmart material.
Or Cheung. Or uru. There's quite a few of them now.
&gt; Traveling Ruby seems like a perfect solution, but TR itself is quite outdated. I am considering creating deb packages with fpm if there is no existing pyinstaller alternative. You could ship the scripts in a tarball and run them in a Ruby docker image. It's not quite single binary as your hosts would still need Docker
Preach.
Shouldn't get rubies for rbenv be like: rbenv install -v 2.6.2 rbenv global 2.6.2 For the gems it would be more like: gem install rails -v 5.2.3 rbenv rehash rails -v
The exception tells you that at line 9 (`test.rb:9`) you have an undefined local variable (or method) called `messages`. If you check your code, you'll see that you in fact don't have a variable called `messages`. You have a variable called `@messages`, but that's an instance variable, which is different from a local variable. You can either make both local variables called `messages` or use an instance variable both times (`@messages`).
ah sorry, that was after I tried mucking with it. This is the unmeddled code and error. 3 begin 4 5 message = Array.new 6 colour = Array.new 7 messages = Dir["#{File.expand_path File.dirname(__FILE__)}/messages/*"] 8 9 File.readlines("#{messages.sample}").each do |line| 10 message.push(line.chomp) 11 end Exception `NoMethodError' at test.rb:9 - undefined method `sample' for #&lt;Array:0x7f589abac530&gt;
I think you might be thinking of omnibus, it's what chef uses to distribute chef
Lines starting with four spaces are treated like code
Could you please explain what the /1/2 syntax you have when describing method definitions (e.g. ".with/1") is about? Also, are Recursive CTE's possible? There aren't any examples. Thanks :)
 begin message = Array.new colour = Array.new messages = Dir["#{File.expand_path(File.dirname(__FILE__))}/messages/*"] File.readlines("#{messages.sample}").each do |line| message.push(line.chomp) end
It threw the same error Exception `NoMethodError' at test.rb:9 - undefined method `sample' for #&lt;Array:0x7fd31af74528&gt;
Yes, sorry, I was just formatting it. I'm on mobile, was gonna take a look when I got on my laptop.
Do you mean "rails developers are the only kind of ruby developers and all the people who use it for things like Chef aren't real Ruby developers"? I'm saying that under the pie chart called "ruby developers" a good probably 60% (or more) are Rails devs. The _REST OF THE PIE CHART_ are "Ruby developers who don't use rails". Your insistence that "Rails revs are Ruby devs" says to me that you think "Rails revs are the _ONLY_ Ruby devs" because literally no one is saying "Rails devs are _not_ ruby devs". So either you disagree with the statement "there's more to ruby development than rails" or you're agreeing with me in a highly combative and contrarian way. Also, there's no "debate" here. There is, in fact (if you agree or not), more to Ruby development than just Rails. You can, in fact, do things with Ruby _without_ using Rails. Using Rails is still using Ruby. These are all facts and not up for "debate" The fact that you're posting "I'm not looking for a debate" bs after three days indicates you ARE looking for a fight.
Its short hand notation for dictating the number of required arguments... In `.with`'s case, it requires a Hash.
If docker is out of scope, what about using capistrano? &amp;#x200B; From the README &amp;#x200B; &gt;When you run cap, Capistrano dutifully connects to your server(s) via SSH and executes the steps necessary to deploy your project. You can define those steps yourself by writing [Rake](https://github.com/ruby/rake) tasks, or by using pre-built task libraries provided by the Capistrano community. &amp;#x200B; &amp;#x200B; [https://github.com/capistrano/capistrano](https://github.com/capistrano/capistrano)
What is the value for `messages` at line 7? For readability enclose nested functions in line 7 with brackets messages = Dir["#{File.expand_path(File.dirname(__FILE_))}/messages/*"] Also since you are using a object in line 9 you don't need to enclose it in "#{}" begin message = Array.new messages = Dir["#{File.expand_path(File.dirname(__FILE__))}/messages/*"] File.readlines(messages.sample).each do |line| message &lt;&lt; line.chomp end
Good point. Kind of odd that AR default won't let you do full models with validations and callbacks, but still bulk insert SQL. I wonder if a PR would be entertained...
messages gets set to a directory path, which contains a set of files to randomly cat. Modified the script as per, but same error
I give it a try, thanks!
This is what I'd use
I think you might want to reject 100 too. array.reject { |i| i &gt;= 100 }
What? Sorry man maybe I did t explain myself correctly. I just meant that I’d also count rails developers as ruby developers for the sake of this estimation. Maybe I should not call it ruby developers, but developers that know ruby.
Thx, will check it out.
This is probably because you're using Ruby 1.8, the `Array#sample` method didn't exist under that name but rather under `Array#choice`. If you change messages.sample to be messages.choice it should work, however, you should look into upgrading your Ruby version.
Don't forget chruby. I think there is nothing to recommend rbenv over chruby. Either take the giant Microsoft Word of ruby version managers, rvm, or take the lean mean one, chruby. rbenv somewhere in the middle, mostly doesn't do anything chruby does, but with much more complicated implementation to do it, nah.
&gt; Also note that in Rails 6 if UUID is used as primary key, created_at column is used by default for implicit ordering. No, it doesn't. That PR was closed unmerged.
none. chruby all the way.
Most likely it's that Rails watches a lot of files in development mode which causes issues with how docker shares volumes on mac os. There are a few mac specific mount options you can try: https://docs.docker.com/docker-for-mac/osxfs-caching/
Anything that reads/writes files, esp. to mounted volumes is the slowest in my experience. I once made the mistake of trying to cache my bundled gems using a mounted volume and that slowed things to a crawl. Maybe turning off logging will help? Also using spring will make all but the first run much faster for things like guard/rspec/rake tasks.
Interesting, I'll try `cached` option
Amazing! I can't praise it enough. Never going EC2 again for 80% or our apps.
How about considering LXC? If you need alternative that need technical skills, I can suggest to install Ubuntu and create a LXC container with LXC/LXD with ZFS file system. You could use ReFind to dual boot between macOS and Linux.
This helped us quite a bit when I worked at a place where we used docker: https://github.com/codekitchen/dinghy
How is this different than a default scope with `order`?
It allows you to change the implicit order without changing the rest of the codebase to use 'reorder'.
Seconded the spring idea. Any idea why new releases for spring are not being released despite having commit activity?
Not sure, maybe they'll do a new release once Rails 6 is out?
It’s frustrating that they had their last release in May 2017 and nothing after that.
I'll second this. With a good sized rails project our performance with docker was abysmal. It was pretty much directly tied with the dumb file sync strategy docker for mac was doing. We solved our problem by using [http://docker-sync.io/](http://docker-sync.io/). I can't speak to the link moomaka suggested, as that wasn't available when I worked on the problem. If you try the docker-sync option, try to specify excluding syncing directories that may have high IO churn. Here is an example I used, mind you it is a couple years old now, and there may be some newer ways of doing this [https://gist.github.com/mrinterweb/1e84c8882251b7dd906b87dc61c0aa53](https://gist.github.com/mrinterweb/1e84c8882251b7dd906b87dc61c0aa53) &amp;#x200B; In my opinion, Docker for Mac default file sync strategy is just plain bad. It can cause terrible performance. I don't know why Docker shipped the software as it is.
First of all, calling `class &lt;&lt; SpecialRoboto` within an instance_method definition is not the right approach to access the singleton class. *My recommendation* is to use `Module#remove_method` to remove a method from being called again: ``` class SpecialRoboto def return_key return nil if @no_more_keys @no_more_keys = true undefine_method :return_key @roboto_active_code.dup end private def undefine_method(id) self.class.send(:remove_method, id) end end ``` However, read through [the docs](https://ruby-doc.org/core-2.2.0/Module.html#method-i-remove_method) to make an informed decision regarding `Module#remove_method` vs `Module#undef_method` as best suited for your use-case
I imagine you want `return_key` to only return once per instance, not once ever? class SelfDestruct def return_once class &lt;&lt; self undef_method :return_once end return 5 end end sd1 = SelfDestruct.new p first: sd1.return_once p second: begin; sd1.return_once; rescue NoMethodError; $!; end sd2 = SelfDestruct.new p third: sd2.return_once Runs as: {:first=&gt;5} {:second=&gt;#&lt;NoMethodError: undefined method `return_once' for #&lt;SelfDestruct:0x00007fbcff8c07a8&gt;&gt;} {:third=&gt;5} You can't use `remove_method` because you can only remove a method from a class and the singleton class doesn't have the `return_once` method defined. Instead you need to tell the singleton class of the instance that the method is undefined with `undef_method` so it raises NoMethodError on lookup.
`data.group_by { |h| h[:name] }.map { |_, values| values.last }`
What is the Singleton class you're talking about ? `SpecialRoboto` ? I thought Singleton classes in Ruby were created by using the `Singleton` module?( .. f.e. using `include Singleton` in your class definition )
Thanks , the only thing I don't understand is the *Singleton* class you guys are referring to.
When you call `class &lt;&lt; SpecialRoboto` you're actually accessing the singleton class of the class `SpecialRoboto`. An alternate syntax is to use `self`: `class &lt;&lt; self`
"the singleton class of the class SpecialRoboto" ... okay?... Kind of confusing, but your example makes the logic clear. In regards to this solution which I mindlessly used from SO , why was it I necessary to use the Singleton context to remove the method. In their case of \*\*removing a method from\*\* \`class FooA\` from \`class FooB\` . Im reading more about the Eigen class that Ruby uses.
Given this code: class A def m 1 end end a = A.new b = A.new def b.m 2 end p a: a.m p b: b.m Runs as: {:a=&gt;1} {:b=&gt;2} In this example the `m` method defined on the `b` instance of A is stored in a "singleton class" that exists only for `b`. The method lookup order for `m` is the singleton class for instance `b` of class A, class A, … If you added `c = A.new; def c.m; end` the `c` instance would get its own singleton class. The singleton class holds methods that exist only for one instance.
&gt; An alternate syntax is to use self: class &lt;&lt; self For the original code `class &lt;&lt; self` does not switch the same singleton class as `class &lt;&lt; SpecialRoboto` because it is running in the scope of an instance, not the class.
Linking to the particular SO thread would help. Nevertheless, the need to invoke a Singleton context is because we're \*removing\* a method from within the Class and not from within a particular "instance" of that class. \*I'll try and make things clearer with an example and inline comments..\* \`\`\` \# Invoke a class object class Foo \# We're now in the singleton class / Eigenclass of \`Foo\` \# i.e. \`self\` refers to the class Foo. puts self.inspect \# This allows us to call "class methods" or \`singleton\_methods\` of Foo without a reciever. \# For example: attr\_reader :bar &amp;#x200B; \# or define class constants: LIPSUM = "lorem ipsum dolor".freeze &amp;#x200B; \# or define class methods def self.reboot puts "Rebooting.." end &amp;#x200B; \# or define instance methods def initialize(bar) \# Now, we're inside an instance of the class Foo. \# i.e. \`self\` refers to the instance. puts self.inspect &amp;#x200B; \# To access singleton methods, we need to call them with Foo as the receiver Foo.reboot \# or \`self.class\` self.class.reboot &amp;#x200B; @bar = bar end \`\`\`
I agree, you're right about this.
This is definitely a first pass, but I really wanted to dig around this one and see what initial reactions were. I intend to do a more detailed runthrough as this one meanders a bit as I was reading along.
Excellent work! One tiny thing I missed is in the "Dot metacharacter" section: There could be a [pointer to `\X`](https://idiosyncratic-ruby.com/11-regular-extremism.html#match-characters-that-belong-together), which will match for any [grapheme clusters](https://idiosyncratic-ruby.com/66-ruby-has-character.html#grapheme-clusters) rather than just codepoints. Imho, `\X` is superior and its use belongs encouraged ;)
thanks a lot for the feedback :) my Unicode game is poor, mostly due to lack of real world experience - will add `\X` to next version, thanks again also, the linked regex resource is nice - have to add conditional grouping and relative backreferences (had already come across this recently while writing a chapter on PCRE)
See also https://medium.com/@baweaver/ruby-2-7-pattern-matching-first-impressions-cdb93c6246e6
just because you can doesnt mean you should. &gt; I'm trying to remove a function after its called once. but why? what are you trying to accomplish?
Thanks for writing this up! I'm having trouble following the new syntax. It would be good to see the equivalent in older syntax for some of these.
Thanks.. It definitely won't hurt to have more readings than not enough but I will admit that I don't get this one.. I saw pattern matching like method calls based on the signature.. Context examples (rather than just the syntax definition) will be good as well. I'm waiting for the follow up..
I wrote an article on this before, hope this helps Ruby has no class methods https://dev.to/edisonywh/ruby-has-no-class-methods-39l5
I hope you will enjoy it! You can get the preview without subscription here [http://pdabrowski.com/blog/wp-content/uploads/2019/04/rails\_patterns\_preview.pdf](http://pdabrowski.com/blog/wp-content/uploads/2019/04/rails_patterns_preview.pdf)
ah yeah we're running 1.8. Thank you!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [Ruby 2.7 — Pattern Matching — First Impressions](https://www.reddit.com/r/RubyLang/comments/be7lfw/ruby_27_pattern_matching_first_impressions/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
The pin operator is meant to allow you to use the value previously bound to the variable as a literal match (rather than destructuring the match value and binding it to the variable). It basically lets you variablize your match patterns Not sure how I feel about this. Overloading `case` to support this seems strange to me and I would've perhaps preferred to see a `match` function specifically dedicated to this. What happens when you have multiple `in` and `when` clauses? The assignment mappings bit seems weird to me and I'm not sure where that is inspired from Are the guard clauses ambiguous? In Erlang you have a predefined set of low-level guard clauses you can use. I assume that in Ruby you would be able to have arbitrary guard clauses because of how the execution works out Also curious if this means we might be getting pattern matching in method signatures which would be really cool
Thanks for taking such an early shot at it! Like many others who are out of the loop with discussions among Ruby contributors, I don't know what is the problem it is trying to solve or what the equivalent 'old way' of doing it would be. When I saw 'pattern matching' I thought of method dispatch.
I kinda think ruby already has enough language features.
&gt; when The article doesn't really answer this question... It implicitly indicates "you should *always* add a foreign key constraint", which isn't true.
That is the main issue for me as well. Performance is great if I build the code into a layer.
Spring has a _lot_ of issues that are fundamental to how it works and has fallen out of favor due to this. Bootsnap in combination with performance improvements in Rails / Ruby are now almost as fast as using Spring without all the issues.
I'll check it out
Christ I've been writing Ruby since 1.8 and none of that code made any sense. We already have pattern matching, its called regular expressions?
I didn't know earlier, but there do seem to be working packaging tools for Ruby: https://github.com/pmq20/ruby-packer http://phusion.github.io/traveling-ruby/ https://github.com/stephan-nordnes-eriksen/ruby_ship
I would suggest having a `RedisKey` class which you can call statically, e.g. class RedisKey def initialize(id, klass) # need to spell this way to avoid collision with Class @id = id @klass = klass end def self.key_for(*args) new(*args).call end def call [prefix, id].join('-') end private attr_reader :id, klass def prefix klass.name.split('::').last.underscore end end Then in your calling class you can write: key = key_for(id, self)
That's not really accurate. I would suggest reading into pattern matching in Elixir, Scala, and Haskell. It's a very different concept. I'd outlined a lot of it in various posts to a prior pattern matching issue: https://bugs.ruby-lang.org/issues/14709
I'll be attempting to clear up the what and why in the follow up article. I just need this to hit Nightly so I can play with it and port a ton of examples I'd been using with Qo. The thing to remember about some of the 2.6 and 2.7 features is that they're very heavily rooted in FP, meaning they're going to look very foreign to people that haven't actively used a language like Scala, Elixir, or Haskell. Nothing wrong with that, but a lot of chance for pretention on both sides. One side would say it's unnecessary because they can't see a use, and the other would say its use is obvious without explaining a thing. Both just make it harder to find out how new features work and breed animosity.
I believe method signatures were a no go for now. Matz had mentioned something to that effect, but I could see ways to make it work through some metaprogramming on top of this. Can't say I know yet on the guards. I'll be experimenting tonight on that. The case overload is interesting, I wonder if mix and match will work or if that breaks. Personally I'd have been fond of match too, but this isn't bad all things considered. Assignment mapping feels backwards, yeah, and will be real interesting with kwargs. I kinda want to see where that breaks. Ah, so pin is like Elixir, gotcha.
Are there issues with it?
Yeah, it's on the way. I just need a few hours to play with it in Nightly when that comes out. The trick of new paradigms is grounding them in practical examples.
I'll add some of those as well. I'd intended to use Qo to demo current techniques and how they map over too.
There are a few. For ex, it does not work with Circle CI. The issue is fixed in master branch. But spring requires a gem to be installed directly instead of a github link in gem file. Without a new release, I've had to resort to hacks to make it work.
Funny, I think a lot of the features in the last 10 years have been duds but pattern matching is one of the major features I would like to see.
 case [0, 1, 2, 3, 4, 5] in [0..1, 0...2, 0.., 0..., (...5), (..5)] true end &gt; It’s amusing that they’ve included beginningless and endless ranges in the example, as &gt; that could be very useful later on Looks quite shit so far. :) I think pattern matching is still a good idea, though. For some reason, new additions to ruby very often do not fit into other (older) syntax parts. I used to think that I was the only one who has had that impression but on ruby-reddit there were others who have had a somewhat similar impression. Not all syntax-changes have the same "weight" either. For example, I have no qualm with the SYNTAX itself for endless or startless range - hard to DISLIKE the syntax per se, since it is ... an omission of syntax. But I don't think it makes SENSE, to indicate infinity upon omission suddenly. I much prefer oldschool ruby there: START .. END Makes for a happier brain. Also, extending case/when is good anyway. I still want it to be a first-class citizen though.
Thank you and good luck..
I think in that particular example it was very much inspired by elixir. Otherwise I agree with you - I often have the same impression about some suggestions. Although in some OTHER suggestions, the use case is clearly described. May also be due to the command over the english language; I guess japanese folks simply prefer japanese all the time. Some of them have excellent english language skills whereas others don't. I haven't yet fully understood the use cases for pattern matching, so I can not even comment on how useful (or not) this may be. If in doubt, I tend to prefer to oldschool ruby mostly, though. Less to memorize too - more power to laziness. ;)
Overall, a really good article. Latency is the key thing to monitor. I had only one quibble: &gt; Queue size – the number of messages on the queue. This metric is highly correlated with queue latency. Your processing **throughput** will determine latency: If you have 1000 workers, consuming 1000 items/sec, and your queue size is 1000 your latency will be ~1.0 sec. If you have 1 worker, consuming 1 item/sec, and your queue size is 1000 your latency will be ~1000.0 sec. Latency is inversely related to the throughput and consume size; it should be independent of queue size.
Hate to be "that guy", but this is REALLY weird. After years of discussion, the feature looks like designed in a complete vacuum, like it is not in established and widely used language, but some new experimental one, designed from scratch. It seemingly breaks any convention and intuition it can find. Fitting better pattern matching (better than we already had with `===`, `case` and `grep`) in Ruby was obviously a tight call, and I imagined it was especially tight because of trying to be consistent with all the other features we have. But it turns out you can at some point just say "screw the consistency, it will be that way". OK, I guess.
I actually sort of agree with you. Though there are always some changes that might make ruby more useful to a subset of users. It depends a lot on the change as such. But even then I still sort of agree with you and upvoted your comment. In fairness, though - nobody can force you or anyone to use any of these changes. I have no particular feeling against pattern matching as such, but there are a few other changes that I think are not good, and I outright ban them. One day I may extend on this in some more details but right now I am way too lazy to write much at all - only the heroic shapeshifting beaver-lemur has had the time to write something about it! Although what is yet missing is his final conclusio about the change. Guess that may take a while before he can write about how useful he finds it.
I don't have a particularly strong opinion about pattern matching per se, but it's quite curious because different people appreciate feature added abc, but absolutely hate feature added def. My favourite discussion was in regards to @1, @2 etc.. People would reason how it "leads to sloppy code". I don't know how they infer that if you write @1 or @2 in your code base, you will be a sloppy hacker. Beats me. I see no connection here. The only connection I see is that someone dislikes the feature (which is perfectly fine), to then make comments and assumptions about the personal dislike (or like) and come up with "leads to sloppy programming", which I think is not based on ... anything really. There were more fun examples, such as how it MUST be "this feature MUST not be added, but I will suggest an ALTERNATIVE than then MUST be added". It totally beats me why it has to be exclusive. Not that I meant to say that both variants have to be added; I just found it strange how people build up on something without knowing that this HAS to be the way they describe it - at the least matz has not stated anything like that. Human beings are extremely strange computers, often not very logical.
I am still not entirely sure whether the use case is now clear or clearer. I think what people will ask, not just DrVladimir is ... what to do with it in ruby? It may be awesome in Elixir, Scala and Haskell but this is from the point of view of ruby.
nobody can force you to use or not use anything (except your boss/team lead/open source committer maybe), but we all work with code we didn't write too. The ecosystem and things a language makes possible/easy or not/hard matter. In fact, ruby's pretty good (especially for it's time) stdlib, with things that work together in certain ways, is a large part of ruby's success I think. Nobody can _force_ you to use blocks either, for example, but even if you can write great readable maintainable code without blocks, you aren't going to be able to look at any open source code without seeing them. Because they are a fundamental part of how the community of ruby programmers write ruby. Whether new features become such or not is hard to predict, but it's almost just as bad if they _don't_, because then when you run into a complicated thing that nobody uses, you're like "crap, this thing I hardly ever see and don't understand but now have to figure out how it works to understand this code." (*cough* fibers *cough*)
This is a good write-up, and imo provides a lot better examples of the syntax than the original issue did. I was skeptical reading the issue because it was looking a lot like Perl and its unreadable syntax. If your article reflects the standard syntax, I think it's going to be great! Thanks for sharing this.
It would be useful (for me) to have a paragraph addressing the concept.
One of the most common cases I've found is when you may have to do an operation based on multiple different inputs. This might be more common in Elixir because functions are typically expected to return multiple values (like a success/fail symbol and some extra info). An example of this is in Elixir is the FizzBuzz challenge. It's not the prettiest example, but it does demonstrate "real world" pattern matching. I rewrote it in Ruby 2.7 syntax here (this will actually run if you install the nightly ruby): (1..100).map do |n| case [n.modulo(3), n.modulo(5), n] in [0, 0, _] "FizzBuzz" in [0, _, _] "Fizz" in [_, 0, _] "Buzz" in [_, _, n] n end end &gt; (irb):2: warning: Pattern matching is experimental, and the behavior may change in future versions of Ruby! &gt; =&gt; [1, 2, "Fizz", 4, "Buzz", "Fizz", 7, 8, "Fizz", "Buzz", 11, "Fizz", 13, 14, "FizzBuzz", 16, 17, "Fizz", 19, "Buzz", "Fizz", 22, 23, "Fizz", "Buzz", 26, "Fizz", 28, 29, "FizzBuzz", 31, 32, "Fizz", 34, "Buzz", "Fizz", 37, 38, "Fizz", "Buzz", 41, "Fizz", 43, 44, "FizzBuzz", 46, 47, "Fizz", 49, "Buzz", "Fizz", 52, 53, "Fizz", "Buzz", 56, "Fizz", 58, 59, "FizzBuzz", 61, 62, "Fizz", 64, "Buzz", "Fizz", 67, 68, "Fizz", "Buzz", 71, "Fizz", 73, 74, "FizzBuzz", 76, 77, "Fizz", 79, "Buzz", "Fizz", 82, 83, "Fizz", "Buzz", 86, "Fizz", 88, 89, "FizzBuzz", 91, 92, "Fizz", 94, "Buzz", "Fizz", 97, 98, "Fizz", "Buzz"]
Test public methods only, if you want to test private methods either you test them through the public ones that use them or extract them to another class to cut off the dependecy.
Pattern matching is not regular expressions.
I really enjoyed pattern matching when writing Elixir so to see this come to Ruby is fantastic.
\&gt; Latency is inversely related to the throughput and consume size; it should be independent of queue size. that is a very good point. I hadn't consider things in these terms before. thanks! &amp;#x200B; \&gt; This metric is highly correlated with queue latency. I think what I wanted to convey was that whenever latency increases due to consume rate being lower than produce rate, queue size is likely to increase as well.
Every object in Ruby has its own object-specific class (called its singleton class). It is dynamically generated and allows you to write methods specific to a specific object. Classes are objects, so you can create class methods by adding methods to the class's singleton class
Nice. Looks like a very good implementation. Even has punning, which elixir currently lacks
This is a really cool example! Thanks for posting this
Also check out \`binding.irb\` in Ruby 2.4+. It's part of the standard library, so you don't need to install anything extra to use it; but it's pretty basic and doesn't have the features that \`pry\` does.
This is awesome! I've been working from an older version of Ruby (2.3.3), will definitely start using binding.irb! Thanks for sharing!
The new Japanese era makes me feel excited until I realize it’s a date format
Yes, it's a very bad idea for a number of reasons. Why would you not just use `options_for_select`?
I'm a bit confused about the utility of this. I don't doubt there's utility, I just can't immediately figure it out. If anyone wants to explain I'd appreciate it.
Maybe my post wasn't clear, but the option choices for select are derived dynamically by querying models in my database. It doesn't look like `options_for_select` would help me in this case... &amp;#x200B; So why is using a global variable bad in this case?
The way that [Wikipedia describes the new era](https://en.wikipedia.org/wiki/Reiwa_period), it seems to be something that is _expected_ to start on 1 May, but is not set in stone yet. It seems premature to release software that expects this, what if it doesn't happen on that day as expected? Or would it be worse to release the change on or after the era begins?
Wow, we're getting pattern matching? It feels like Christmas came early - although it's probably slated for Christmas release, as usual, right?
Well, to use a global variable here you'd have to wrap it in some sort of lock. Or else half way through rendering on one thread, another thread could change the variable and the initial render would finish rendering with the wrong value. It sounds like you're trying to render some html? Perhaps creating a custom helper is the way to go, instead of leaning on collection_select?
This is quite awesome; thank you! &amp;#x200B; I'd love to see a follow-up for other flavors of pry and using 'rescue' to handle uncaught exceptions. &amp;#x200B; You rock!
This is one of the more practical experiments, playing with objects. Interesting stuff, but the entire bit on keywords is slightly annoying. I may write a third article on Qo parity and a fourth on breaking it.
Anything you can do with pattern matching you can do with other techniques. It just makes things a little more declarative. This isn't safe or tested, but a small example I came up with is if I wanted to make a really simple web app, I could add restful routing to Rack with something like... class Router DELIMITER = '/' class &lt;&lt; self def call(env) new.call(env) end end def call(env) req = Rack::Request.new(env) res = Rack::Response.new(env) path = req.path.split(DELIMITER).tap { |path| path.reject!(&amp;:empty?) } case [req.request_method, path] in ['POST', ['users']] res.status = 201 in ['GET', ['users']] res.status = 200 in ['GET', ['users', id]] res.status = 200 else res.status = 404 end end end App = Rack::Builder.new do run Router end
I am not familiar with the Japanese era system and haven't read any notes on exactly what was done in ruby to support it, but what with the Japanese-center of ruby core development, I am confident they knew what they were doing.
I agree, the team is most likely to know what they’re doing here, I’m just hoping to understand the reasoning. [This](https://github.com/ruby/ruby/compare/v2_6_2...v2_6_3#diff-3991f2801546530eb23774963a10fa94R7042) is where the new logic is, it displays the letter "R" for the new era. It cuts off the previous era ("H") at a specific date. I believe the value is days since epoch.
Aha, and now i understand the new test I saw in the ruby diff. The new Japanese era name, which was just announced a few weeks ago, can be represented by either two existing kanji, or a newly invented kanji that combines them. Some Unicode canonicalization algorithms will transform between the two-kanji version and the one-kanji version. So that's exactly what is being tested in the new test. While the unicode codepoint was reserved last September, the new era name wasn't announced until a few weeks ago, so the two existing kanji weren't known, and the unicode codetables couldn't include it. But they've got to definitely get it out before the era change happens, probably May 1, as a deadline. So, yeah, just in time really.
That it is, I'm just horrid at waiting so I always take a peek at the presents early.
If you don’t write private methods you won’t need to test them. how do you do that? If you have more than one set behavior in a class such that you need to mark some of it “private” then move that behavior to its own class that the first collaborates with.
Because it's an expression you could also write: ```ruby status = case ['POST', ['users']] in 'POST', %w(users) then 201 in 'GET', %w(users) then 200 in 'GET', %w(users id) then 200 else 404 end =&gt; 201 ```
Because it allows state to live beyond the lifetime of a single request. If your server allows concurrency it will cause errors when two requests both use the same global.
....what are YOU trying to accomplish?
So basically the point of the Singleton / Eigen class is to represent *the* class and it's definition , as an accessible object? Essentially it's an object that represents your class that you can edit by need to beware of the context your'e accessing it.
I don't understand what you mean by *.. beware of the context your'e accessing it*, though. Singleton classes need to be fully understood to realize their use. Singleton classes exist not for a Class but also for a Module. ``` class Foo def self.bar puts "foo" end end ``` ``` module Lipsum def self.lorem puts "ipsum" end end ``` The above two objects allow sending the following calls: ``` Foo.bar # note its not Foo.new.bar ``` ``` Lipsum.lorem ```
Anyone seeing characters from the previous line appended to Pry output? Makes it unusable for me.
We did this at my last job. It’s worth doing, but the documentation does not make it easy. There are no tutorials out there for this either AFAIK, so maybe you should write one once you figure it out! You will want to use server side authentication as detailed here: https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html#amazon-cognito-user-pools-server-side-authentication-flow
Could you just use an omniauth strategy? https://github.com/Sage/omniauth-cognito-idp/blob/master/README.md
This is cool - I had no idea this was added
Great article! I love seeing thorough exploration of this where other people can see it. Pattern matching is one of the absolute best things about Elixir and every time I'm writing Ruby I miss it. That said, some of the functionality here is really good, but the `case...in` syntax is too verbose for general destructuring. I hope they add the in-line functionality that was discussed, because I don't think this will get used as much as one line matching. If we can destructure like this... case Point.new(0, 1) in [x, y] then Point.new(x, y + 1) end Then ideally we could skip the case and destructure like this: [x, y] = Point.new(0, 1) I do like that we can do deep destructuring, which the #14912 issue said may not happen: case [1, 2, [3, 4]] in [a, b, [3, d]] then "success" end =&gt; "success" &gt;&gt; d =&gt; 4
FYI, your keyword destructuring section is accurate but not complete (and "Keywords are not Variable Assignments" is not technically correct). In your example, you're matching on both `x` and `y`, so they're not bound, just matched. You *can* destructure a keyword without a matching argument and use it as part of the statement just like a non-keyword argument. e.g. case Point.new(0, 1) in x: 0 =&gt; x, y: then Point.new(x, y + 1) end =&gt; #&lt;struct Point x=0, y=2&gt; &gt;&gt; y =&gt; 1
Thank you so much! I think once I start creating tests for my code, I'll be using 'rescue'. Coincidentally, I found a gem called pry-rescue, haha!
Hi there, I'm not sure what you're trying to `match` but you need to pass an argument, so instead of `'Hi there James'.match /\b\w{4}\b/`, it should be something like 'Hi there James'.match('James')` or something along that lines.
I'm trying to help you not write garbage code. What is your use case? Can it be accomplished differently?
&gt; Is it generally bad practice to use global variables in RoR? Global variables may be useful sometimes in the sense of when you don't want any form of access control. But they can conflict with other global variables, so the net result of using more and more global variables may be conflicts. I myself use some global variables, such as $stdin, every now and then, but if you can, you could always use something like this: module Foobar @foo = 42 def self.foo? @foo end And you can also use toplevel method setters to set to another value. So in short, you can use them to avoid global variables easily - just be sure to know what you put into where exactly. Stay simple whenever possible.
I think the problem was that moomaka did not explain why it was bad.
Did I not rectify that deficiency?
Class variables are worse than global variables because evaluation order within the inheritance hierarchy matters. Why did you even bring them up⁈ Global state wrapped up in a method is just as bad as a global variable because you risk any state resets being forgotten across requests and overwritten states with concurrent access. Comments will not save you from global state in a multi-user system.
Why am I getting down-voted for this? It's no different than any of hundreds of other comments I've read here over the last *ten years* on Reddit. I have absolutely no connection with the author, publisher, or otherwise. As a writer myself, I lament the demise of intelligent reading that we've seen in the last few decades, not just here. Careful, bros; you might learn something if you don't watch out. And empathy is necessary for successful careers, but *so* dreadfully out of fashion.
I've seen this when running unicorn and trying to pry.
 SyntaxError: unexpected '|' in name: -&gt; { |n| n.size &gt; 3 } =&gt; name, age:... This isn't valid lambda syntax even without these enhancements. The correct syntax would be -&gt;(n) { n.size &gt; 3 }
The regex is the argument. In fact the &lt;arg&gt;.match &lt;subject&gt; order doesn't matter. Anyway, my question is about Pry, not the content of the code.
Okay well that makes sense. To begin with it was more of an experiment. Im not working on a project, but just messing with Ruby. I had a class that had a unique key value that can only be returned once (i.e. getter can only be called once). After it is called, it returns the value, then you delete the method ... originally used a flag but had the idea of removing the method. So I searched for a solution.
so, essentially a like a Java static method.
Ahhh I see. It's weird because I get just `nil` when I copy your code into Pry. I also tested in IRB and get the same return.
I have always had performance issues running rails or node in dev mode within docker. Usually just end up running the core services in docker but keeping ruby on the host machine. We drop a bin/docker-env file in our projects that you can source: ``` #!/bin/bash machine_ip="127.0.0.1" function get_compose_service_port { container_id=$(docker-compose ps -q $1) docker port $container_id $2/${3:-tcp} | cut -d ':' -f 2 } pg_port=$(get_compose_service_port db 5432) redis_port=$(get_compose_service_port redis 6379) # Export env compatible w/ rails export DATABASE_URL="postgresql://app:secret@$machine_ip:$pg_port" export REDIS_URL="redis://$machine_ip:$redis_port" ```
Using meta-programming to solve a data access problem seems like a bad idea. If your data structure is a hash, you can use `delete`. ``` data = { once: 'test' } =&gt; {:once=&gt;"test"} data.delete(:once) =&gt; "test" data =&gt; {} ``` and could implement it like this: ``` class Example def initialize(data = {}) @data = data end def once @data.delete(:once) end end example = Example.new(once: 'test') puts example.once # =&gt; "test" puts example.once # =&gt; nil ```
What is punning?
As someone learning Rust, I agree with this comment on the bug tracker: &gt; Btw, won't it better to introduce a new expression named match than to extend case? Seems to me this will make the use of patter matching clearer, and I assume it's also going to simplify the implementation. &gt; \- bozhidar https://bugs.ruby-lang.org/projects/ruby-trunk/activity?from=2018-08-12
&gt; that Wikipedia looks way more complex than the idea actually is) Unfortunately that happened to many wikipedia articles - they became too complex. :( It kinda is killing wikipedia slowly. On the bright side, that means that OTHER sites have a good chance to provide BETTER information than wikipedia does, in particular when it comes to EXPLAINING something. Wikipedia is still good for carrying together resources though. Scientific articles range from good to terrible on wikipedia in regards to intrinsic complexity.
Heh, figures that I missed something in there. Will fix it tonight, good catch.
The ruby core team semi-sneakily adds features that are useful right into ruby itself. :D
This is an instant upvote answer. And for every class that has both unit tests and private methods, I will wager that studying the unit tests will reveal some awkwardness in the implementation.
I will second this. We ended up with a relatively simple solution, but the docs didn't make it easy. Be ready to struggle. TBH, even if I have the experience now, I'm not sure I'd choose Cognito again 🤷‍♂️
&gt; But probably my most important problem with this proposal is that it does not let me have multiple functions defined with different type signatures, ruled by pattern matching. This echoes my sentiment. Ruby isn't an FP language, it's an OO language. And by OO I mean it's about sending messages to objects, not classes or class hierarchies. I welcome language features from the FP world where they can be added sensibly, but in this case I don't see a viable way to make ruby actually better.
&gt; Maybe my post wasn't clear, but the option choices for select are derived dynamically by querying models in my database. It doesn't look like options_for_select would help me in this case... `options_for_select` takes simple values so I don't understand why it wouldn't, what do you think `collection_select` does internally that you can't do with simple Ruby?
Not just a bad practice, but a guarantee that Bad Things Will Happen because Rails is unbeknownst to you a threaded stack. The closest you should allow yourself to get is `https://api.rubyonrails.org/classes/ActiveSupport/CurrentAttributes.html`. Even this should be used very sparingly because it's almost an admission of architectural incompetence. I have it for thing only: `belongs_to :user, default -&gt; { Current.user }` Suggest you post your actual code rather than trying to describe it.
Amongst CS topics 'why not to use global variables' has perhaps the high volume of content written about it. I don't see the need to reiterate it when there are volumes of information a simple google search away.
It is true I haven't worked in a language with pattern matching before. But I can not figure out what the heck this is supposed to mean: case [1, 2, 3, d: 4, e: 5, f: 6] in a, *b, c, d:, e: Integer | Float =&gt; i, **f &gt; First of all, the code is ugly in a way that makes it hard to reason about. Indeed. I am not a fan.
This is wonderful. Fantastic work.
I believe it's being used for visual emphasis on how the underlying mechanism works (the one that's trying to be explained via code). &amp;#x200B; I don't think the aim was standard ruby style, but instead to use ruby's flexibility to illustrate the system being described.
To be fair to the language, that *is* a rather esoteric way to demonstrate it. I'd mentioned as `as` an alternative to hash rockets, but it'd require a new reserved word: case person # `as` to assign in name: /^S/ as name, age: 20.. as age # ...or imply from names: in name: /^S/, age: 20.. end
I totally echo this sentiment. The syntax feels like an idiom that doesn’t match the meaning.
Conceptually it's very healthy to think in terms of message passing, but mechanically in Ruby we do invoke methods. Duck typing is what's enabling this, not a first-class inter-object messaging behaviour. There's literally no mention of message-passing in any Ruby docs or source code. The first giveaway is that `Kernel#send` is invoked on the recipient; there's no `Object#receive`. The second giveaway is that overriding `#send` in objects doesn't change regular method dispatch. The final giveaway is the absence of a first-class `Message` object. If I had any spare time, I'd be interested in designing an experimental Rubylike that is truly message-passing with objects fully encapsulated and self-determining w.r.t. dispatch of incoming messages.
Having some experience with Elixir's pattern matching, I have to admit that Ruby's proposed Pattern Matching definitely doesn't click.
I much prefer `=~` personally. I thought our Rubocop config preferred it as well but I may be wrong (or it may be a customization on our part)
It's mapping by slots, and they're both just made-up arrays of *stuff* that is going to be run through. Check the comments in the `p` lines below it: * `a=1` * `b=[2]` # splat operator returns array * `c=3` # same as `a=1` * `d=4` # `d:` and `d: 4` match up and keep things plain * `i=5` # like `d:` up top, but the, uh, template? returns just "i" # from all that bitwise XOR, which I'm guessing is either that # same "i" from the expression, or is some return from the # hodgepodge, like how `Object.to_i` in Rails is always 4 # or whatever * `f=6` # Lastly, the `**f` (double-splat) hashifies the `f: 6`
Technically the trade-off is between `match?` being faster and `=~` populating `Regexp.last_match`. If your guiding principle is minimalism, maybe only use `=~` everywhere (or only use `#match` everywhere), but if it's optimization, use the fastest one that suits your needs at the moment.
Punning is a shortcut for naming variables during pattern matching and destructuring. x = {a: 1, b: 2, c: 3} $(a:, b:, c: foo) = x a # =&gt; 1 b # =&gt; 2 c # =&gt; NameError: undefined local variable or method `c' for main:Object foo # =&gt; 3 `a` and `b` are being punned, which is to say destructured into variables named according to their key. `c` is not being punned, it is being assigned to `foo` This is a feature elixir, a language that helped popularize pattern matching, lacks, although there [is ongoing discussion](https://elixirforum.com/t/proposal-add-field-puns-map-shorthand-to-elixir/15452). Javascript destructuring heavily features punning
Weird they’d feature main since that’s not a thing in Ruby. Plus why wouldn’t the method puts hello world instead of setting a useless variable just to return it to nothing. Makes me wonder what the content is actually like.
You're welcome! rescue is a very cool gem, indeed. Let me know how it goes for you. I think IIRC that pry-rescue dumps you into pry when there's an unhandled exception. I've played around with it but sometimes Ruby couldn't find the gem and as I was under an unrelated deadline I gave up. If you dig deeper and use it please grace us with another post. Hey, and message me in case I miss your posting. Cheers!
Alan Kay wrote this: &gt; OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I'm not aware of them. And: &gt; The big idea is "messaging" - that is what the kernal of Smalltalk/Squeak is all about Neither Smalltalk or LISP has first class Message classes, so clearly he was not suggesting a Message class as a requirement for messaging. Ruby *does* on the other hand support all of the above. Largely because it has copied the Smalltalk model to a great extent. From the documentation of Pharo Smalltalk: &gt; The message is not a piece of code: it is nothing but a name and a list of arguments. .. as in Ruby. And as in Ruby, the sending machinery by default looks up methods, but then dispatches a special message if the method is not found, to allow the object to dynamically handle the message: &gt;What happens if the method we are looking for is not found? &gt; Suppose we send the message foo to our ellipse. First the normal method lookup would go through the inheritance chain all the way up to Object (or rather ProtoObject) looking for this method. When this method is not found, the virtual machine will cause the object to send self doesNotUnderstand: #foo. The point of message passing is not that you are literally passing message objects, but that the system is acting in a way where the object you invoke a method on can control dispatch. In Smalltalk as in Ruby you can do this by the same combination of altering which methods a class *or a specific object* (via the metaclass) responds to, and you can define a fallback. Given that Alan Kay defined these terms to apply to Smalltalk, and Ruby supports the same mechanisms as Smalltalk, Ruby most definitively supports message passing.
I've made all these arguments myself and then realised they were bollocks.
&gt;meta-programming is \`remove\_method\` meta-programming? why does it seem like a bad idea?
Apart from returning position of match (or nil if match isn't found), `=~` will also set regexp related global variables I'd suggest to use `match?` if you just need `true/false`
&gt; Bottom line: there's no mention of message passing in the Ruby source code. And no, the tenuous name of the "send" method doesn't qualify. Irrelevant. What matters is what it actually does, and it does the same as pretty much every Smalltalk implementation. &gt; The actual machinery is method calls with a catch-all. The same is true for Smalltalk, and yet Alan Kay defined that as message passing. Actually passing specific "message" objects is extremely rare, and post-dates Alan Kays definition by many years (decades?) Look at e.g. GNU Smalltalk, and you will see that the VMs low level "send" machinery does almost *exactly* the same as MRI - it looks up the method in the class chain and falls back on a catch-all. The relevant code can be found in libgst/interp-jit.inl in the GNU smalltalk source. So does pretty much every other Smalltalk implementation too, because it is how Smalltalk semantics are defined. &gt; Finally, I strongly doubt that Alan Kay was suggesting that Smalltalk's implementation of OO is the definitive standard for OOP. No, he has in fact made the argument that he is disappointed it has not been changed more, but he *has* made clear that he stands by the definition of OO that I quoted when asked. And the argument is not over the "definitive standard for OOP", but over whether or not Ruby's behaviour meets the criteria for message passing. And unless you are going to argue that Smalltalk is not message passing, then Ruby is, as the behaviour is near identical. If you *do* argue that Smalltalk is not, then you're using the term in a way pretty much nobody else does, and the discussion is pointless. &gt; I'm only too happy to point out that Ruby's method dispatch has late binding (because it's at runtime), but not extreme late binding because the caller can control exactly which method is invoked and it's almost impossible for an object to evade this. The caller can only exceptionally control exactly what is invoked in Ruby. Objects can alias and undefine and override methods on itself via its meta-class, the same way Smalltalk can (e.g. via "define_singleton_method") or more brutally by doing the same on its *class*. If Ruby does not have extreme late binding, then Smalltalk doesn't either. Here is a class that overrides it's own method while in that method so that repeated calls get different results: ``` class Foo def bar puts "Hello" define_singleton_method(:bar) do puts "Nope" end end end ``` In case you consider objecting that defining singleton methods does not override methods obtained via "#method", that's a flawed argument: the method object encapsulates a closure of the code of the method in question over the instance it was obtained from; you're not calling the method on the original receiver, but on the method object. And *that* object can redefine it's own methods, and any method calls inside that closure on the original object are still under control of the original object. Yes, this allows the circumventing subsequent changes the object does - if you consider that a problem, you can of course override '#method' -, but again: so does Smalltalk.
Sorbet is a great inspiring project. Hopefully, open source soon. FYI: sruby - that is (secure) ruby[1] - is an alternative ruby (subset) with an alternative (optional) type annotation syntax e.g. Sorbet's `sig {params(x: Integer).returns(String)}` becomes `sig Integer =&gt; String` or `sig [Integer] =&gt; [String]`. Note: Since the sig is just (regular) ruby code you can create an alias for types e.g. I = Integer, S = String and than use sig I=&gt;S, for example. [1]: https://github.com/s6ruby
We're collaborating with @yukihiro_matz, @mametter, @soutaro and Jeff Forster to make sure that types are not disruptive to Ruby. Thus, types are optional. The intention is to deliver value for unmodified Ruby programs. Hear more from Matz at https://youtu.be/cmOt9HhszCI?t=2148
Sorbet is a great inspiring project. Hopefully, open source soon. FYI: [sruby - that is (secure) ruby](https://github.com/s6ruby) - is an alternative ruby (subset) with an alternative (optional) type annotation syntax e.g. Sorbet's `sig {params(x: Integer).returns(String)}` becomes `sig Integer =&gt; String` or `sig [Integer] =&gt; [String]`. Note: Since the sig is just (regular) ruby code you can create an alias for types e.g. I = Integer, S = String and than use sig I=&gt;S, for example.
I really like sruby's syntax for type definitions :(
Thanks for your kind words. The credit goes to the inspiring and helpful sources. See Learn me a bitcoin - http://learnmeabitcoin.com/glossary/script and Programming Bitcoin from Scratch (in Python) - https://github.com/jimmysong/programmingbitcoin/blob/master/ch06.asciidoc
Using Arrays for type definitions (in secure ruby) is inspired by Python (and Scala) :-).
FYI: As a head start you can add the missing Bool type today :-), use the safebool library / gem - https://github.com/s6ruby/safebool
Really love the .rbi file approach!! :)
None of this changes the simple fact that its a mechanical method call. Tying yourself in knots with a wall of text doesn’t change that simple fact. Like I said, I’ve made these arguments myself, then realised they are bollocks. Hence my proposal.
Ruby’s behaviour does not meet the standard for message passing, and neither did Smalltalk’s. I believe I already set out my three criteria. Not actually sure what your purpose here is.
The choice depends on your Ruby version and the particular use-case. `#match?` was only introduced in Ruby 2.4.0. So if your project has not dropped support for older Rubies, then you should prefer `=~` over `#match`. If locking to Ruby 2.4 and above is fine, then using `#match?` vs `=~` depends on the use context. Prefer `=~` when you want the regex to match and later call methods on the `match` / `$1` / `$2`, etc Prefer the faster `#match?` over `=~` when you need just a `true` / `false` result.
Please don't kill ruby with your type-shit. Actually - the title is completely misleading because matz said several times that he will not add types in the sense of what people usually associate with ruby. So if I ignore this crap-title here, then I do not have a problem since what matz said is very different, also a few days ago in another presentation he made. So please, folks - don't use shitty titles.
wow this sounds really cool
&gt; First of all, the code is ugly in a way that makes it hard to reason about. Somewhat true. Unfortunately this is the case with many additions to ruby in the last ~3-4 years or so. The biggest problem is that there is a limitation in the syntax we can use and we already use the pretty things. So if we run out of pretty things, we can not really add prettier syntax. Then the question is ... do we add something or not? That's admittedly controversial since you can always find advantages and disadvantages. At the same time, though, let's ignore ugly syntax for the moment - when you add syntactic NEW elements, you also add NEW features. &gt; It looks like being added on top of a language which was not designed to &gt; support pattern matching (which is exactly the case). Yup, very true. However had - there are other examples where syntactically things do not fit that much. The "-&gt;" operator always felt very alien to the rest of the ruby code that I write. Ultimately there is simply no alternative for YOU to decide whether you want to use something or not. &gt; This might not be important in the long run, when people get used to &gt; it - but here it is, in the second impressions round. Actually syntax is hugely important. When the syntax is shitty then I can not and will not use it. I do not have that strong an objection to the syntax in this regard, but my biggest problem is ... why would I actually need pattern matching? And I mean this independent of the syntax. I don't really seem to need it and it would slightly change my style of writing and thinking and I just don't see any point in having to do so. So most likely I will not use it - but admittedly I still haven't fully understood it either. &gt; it would be better to have a possibility to define a type union like &gt; in Pony. For example: &gt; number = typeunion(Integer | Float) Actually, no - that also looks like total crap. It's funny that people who dislike something, which I can understand, come up with ugly shit of their own that they want to add. But sorry, if your proposed change is also terrible, then it should NOT be added. &gt; Besides that it's good, especially for getting things out of hashes. It has the very same problem - it is horribly ugly. &gt; Basically it would be like introducing proper types to Ruby Ok good - then this must be banned. Because we don't need your type-shit in ruby, thank you sir. &gt; It needs to allow having one method defined mutiple times in &gt; one class, but without shadowing previous definitions. THAT is actually WORSE than the feature request for pattern matching at the bug tracker! People need to stop making bad ideas even worse with their own changes. &gt; I don't think that Ruby will ever go this way, yet this is something &gt; that would clean up my code in few places significantly. Phew, hopefully not indeed - too many clowns out there trying to ruin ruby with their changes. Now, some changes added to ruby were not good, yes, but at the end of the day matz is still doing quality control nonetheless. Imagine some random guys suddenly designing ruby - that would be pure madness. &gt; I also realised that while working on Noaidi – my implementation &gt; of pattern matching. I don't really want plain pattern matching &gt; somewhere in the code, as I can make most cases work with &gt; good old case in Ruby. Yup, completely agree here. Guess I am not the only one who does not completely get pattern matching in ruby. &gt; And this is being made possible in Noaidi. I have an experimental &gt; branch enabling this and I hope I will be able to finish it some &gt; day. Such module would look like this: module Math extend Noaidi::DSL fun(:fib, 0..1) { 1 } fun(:fib, Integer) { |n| add(fib(n-1), fib(n-2)) } fun(:fib, Object) { raise NotImplementedError } funp(:add, Integer, Integer) { |a,b| a + b } Quite awful. I guess the problem is that the existing syntax in ruby does not easily allow for this style of programming. It fits much better into elixir/erlang. It's very difficult to translate ideas 1:1 from different languages into ruby's existing structure. &gt; Verdinct: I'm kind of disappointed. The quest is not over yet. Yeah - but that also applies to your suggested changes, and Noaidi, too. ;) In my opinion the best changes in the last ~3-4 years came mostly from SMALL changes that seemed insignificant but were quite useful. The larger changes, though, are ... very strange really.
What did he actually say? Can you write a short summary or link to the presentation?
Also downvoted and unpopular you are - of course - right. The headline should be rewritten to "Ruby 3 will have **(optional)** type interfaces / annotations" - the key word being optional (and **in a separate "interface" .rbi file** if you do not want annotation in your script itself).
I am not sure this would be a good approach either, to just add "as" solely for pattern matching when case was retrofitted. My biggest problem is still that I don't entirely understand why I would need pattern matching in ruby. But I was not the one who suggested it either, so I ultimately don't care that much - it is just highly unlikely that I will use it. Admittedly I also still have not fully understood it, even after reading your explanations. My biggest question still is where I would need it, in real code, where I could not already use existing code for the problem domain at hand. I don't even need automatic setting of local variables either since it is quite rare that I use many local variables; mostly I just use them for temporary storage. Important things get stored in @ivars, and if there are too many of them, I switch to an internal hash e. g. for storing flags and commandline options and so forth.
 If you `require: rubocop-performance` in your `.rubocop.yml` you will be referred to [https://github.com/JuanitoFatas/fast-ruby#regexp-vs-stringmatch-vs-string-vs-stringmatch-code-](https://github.com/JuanitoFatas/fast-ruby#regexp-vs-stringmatch-vs-string-vs-stringmatch-code-)
\&gt; But I was not the one who suggested it either, so I ultimately don't care that much - it is just highly unlikely that I will use it. &amp;#x200B; You can still encounter it in someone else code, a colleague perhaps. It's not like it's possible to fully escape parts of language we don't like. So I guess even people who are not going to use given feature should have something to say.
&gt;Ok good - then this must be banned. Because we don't need your type-shit in ruby, thank you sir. I'm afraid I have some [really bad news](https://www.reddit.com/r/ruby/comments/bewmwl/ruby3_will_have_types/) for you...
While I agree in regards to pattern matching not being too terribly useful (at the least not with that proposal), and I agree that ruby's strongest point is OOP, I have to correct you in one regards: - Ruby was ALWAYS multi-paradigm, even many years ago. See "-&gt;", lambda, proc. So people who say that ruby is ONLY OOP, despite me preferring ruby in exactly that way, are, sorry to say, simply wrong. I assume you may not have used ruby back in the days when the first pickaxe came out, as otherwise you might know that ruby was always multi-paradigm, which exactly follows from the "more than one way". See also the old interview by matz from 2003. I understand that +15 years later newer folks may not remember it, which is why lots of people make incorrect statements about ruby. Although I also agree that there have been lots of strange changes added to ruby in the last 3-5 years or so.
Alan Kay is rather more of an authority on what qualifies as message passing than you are unless you're Alan Kay. As such when you're pushing a definition pretty much nobody uses, don't expect people to just accept that. On the contrary, it serves to create confusion about a subject that is already deeply misunderstood. And arguments such as yours contributes to that confusion. &gt;Not actually sure what your purpose here is. I'm not sure what *yours* is. You're using a definition that nobody else is using to make an argument that would render the common definition meaningless if anyone cared, without actually presenting any meaningful reasons for why anyone should use your obscure definition instead of the standard one. &gt;I think we can do better Then suggest a better way rather than argue against the common definitions of established terms.
lol. NO.
I don't love it but I don't hate the approach either. What I do, however had, hate is the title that darkdimius picked, since it is completely at odds with the content. Even before RubyKaigi matz gave several presentations and the .rbi approach is completely in line what he has said before, so the title chosen here "Ruyb3 will have types" is a flat out lie. I am sorry to pick so harsh words but this is the only accurate evaluation of this terrible title. You can see the presentation by matz here: https://www.youtube.com/watch?v=cmOt9HhszCI The RubyKaigi presentation will probably be made available at a later time just like the years before. The presentation is actually about 10000x better than the title AND the description given in this top-link by darkdimius.
This is one of the only ways Ruby can remain relevant, and they know that. Don’t worry, you don’t have to use it. But for people know that this is absolutely more powerful on bigger teams, we will adopt this immediately
The title is def crap. Ruby is strongly typed. It has very clear types. Static types are a whole different story. I’m pro static types btw. Here, they’ll be optional, so if you don’t like it, don’t use it.
If we can just get value types after this, Ruby will remain relevant for a long time. Thats been my fear lately. Ruby is lagging behind the newer generation of languages.
I can’t say I like the way it looks tho. Is that how it’s going to be in the final release?
This would be pretty cool.
&gt; And no, the tenuous name of the "send" method doesn't qualify. It absolutely does. You SEND the MESSAGE to an OBJECT, in ruby. See - the very name .send itself is a give-away to this. It's amusing that you go to great lengths insinuating that this has nothing at all to do with sending a message at all. :) Ruby's OOP is different to smalltalk's OOP though. There are many other differences too - biggest one is syntax-wise. It was syntax that led to smalltalk's failure. Alan Kay is awesome but I think he never fully understood the importance of syntax. Other differences are the "scripting" family approach. Ruby is much closer to, say python, perl, php, than smalltalk was to the latter. &gt; Everyone should write their Ruby code as though it is a message-passing system, but &gt; the hard reality is that it isn't. The actual machinery is method calls with a catch-all. You complain about the above being bollocks but I call your claim here bollocks. People should not write as if ruby is a "message-passing system". They should write ruby in whatever way they prefer to. There is indeed no fine-grained control or "tuning" over these messages in ruby; see .send() versus .public_send() or private/protected/public - which does not make a whole lot of send in ruby anyway. &gt; Finally, I strongly doubt that Alan Kay was suggesting that Smalltalk's implementation of &gt; OO is the definitive standard for OOP. Here I agree. In fact Alan actually said that one inspiration he took was from biology since he also studied the latter (and you can tell in his talks, too). I don't know of any programming language that has been designed in a way that may take concepts from cell biology - erlang comes somewhat close to this in some ways (fault tolerance for example), but where erlang fails COMPLETELY is syntax-wise. Even elixir isn't that awesome syntax-wise but it improved on erlang. &gt; But I'm totally on board with his definition of OOP Here is the problem - different languages all use different definitions. It was c++ and java in particular that coined the "mainstream" OOP definition, which I think is rubbish. But different languages will use different definitions and you can't say that one is "worse" per se - it's just different. &gt; not extreme late binding because the caller can control exactly which method is invoked and &gt; it's almost impossible for an object to evade this. How should it work that an object can "evade" a message? Actually you can already do so e. g. via clearning all (or most) methods, then using method_missing and channeling all received messages, but I find that to be utterly pointless.
Yup - in0pinatus got confused there. By the way you can indent the ruby code via e. g. 4 spaces (or 6 spaces, after having used 4 spaces) - right now your code is all spaced out on a single line, which is making this odd to read here.
show me a design pattern that includes changing method definitions at runtime.
That syntax is ugly on a whole new level. PLZ FIX.
You mean it is not even open source? Why do we promote closed source here? If they want to promote closed source they should really go and do so elsewhere, way outside of the ruby community. &gt; you can create an alias for types e.g. I = Integer, S = &gt; String and than use sig I=&gt;S, for example. It is best to not use I and S spread all over ruby code. It leads to gibberish rubbish.
Why the downvotes? This is true.
Huh? What "standard"? Is there now a standards committee that defines what is valid and what is invalid when it comes to message passing? Note that Alan Kay's definition is quite simple and rubygeek referred to it primarily.
It's not open source for now but will be this summer. https://sorbet.run/talks/RubyKaigi2019/#/45
I feel like this is going to be a painful upgrade
Crystal? Not that isn’t neat though!
I really hope we can get a better interface system than what has been demonstrated so far. I'd love something like Go's, I don't want to explicitly declare that something conforms to an interface, I should just conform to it... Fooable = Interface.new(:foo/0) class Good def foo end end class AlsoGood def foo end end def visit_foo(Fooable fooable) fooable.foo end I can live with something like that. I'm not a huge fan of the way Crystal (and Sorbet) do things where you use a mixin to conform to an interface. # typed: true module Fooable extend T::Sig abstract! sig {abstract.void} def foo end end class GoodFooable include Fooable def foo end end class BadFooable include Fooable end
If you think types give a universal value then you’re not taking advantage of ruby. Confident Ruby by Avdi Grimm is full of examples that address this topic
What is going on in this thread? Ruby is about messages not types.
Benchmark for reference: https://github.com/JuanitoFatas/fast-ruby/tree/38f49f95fc7574d929de60b71791d09129c2588c#regexp-vs-stringmatch-vs-string-vs-stringmatch-code-
Perl 6 has a very powerful type system...
Yeah - it was not matz who suggested the syntax either. The thing is that people will have to select what they want to use and ignore what they don't want to use whenever it comes to any of these changes. You may be able to find yourself in a similar position, reversed - e. g. you may like an addition, and others dislike it. Of course it may also be the possibility that you dislike ALL the changes that are coming - but in that case you have to reason that ruby was already perfect at the (prior) moment in time. Since no further change possible would make it better. :) Or you would propose a change, and then OF COURSE be totally in favour of your OWN suggestion ... which also happens a lot on the bug tracker. ;) My favourite ones are still epic claims such as "this will lead to terrible code and should not be added" or "sloppy style of programming" and so on. People definitely have an opinion.
And ‘def main’ is not a Ruby thing.
Sometimes it's nice to be certain ahead of time that an object you receive will always respond to the messages you plan to send to it.
I actually don’t know why we need to use def main in ruby but this is what lecturer said. Main is the procedure
Perl 6 has very powerful pattern matching. Dare I say, equivalent to Haskell...
That’s why we have ‘respond_to?’.
Ruby has more or less done a great job of incorporating concepts from other paradigms. However, it's core strength is as an OO language. Underneath my comment is some brimming frustration that rubyists have abandoned OO because they confused ORMVC web apps (i.e. rails) for OO.
I really wish there was first class support for something like Rubex. A layer between Ruby and C. You could write your super dynamic code in Ruby, if you want more safety or performance, you drop down a layer where there is a static subset of Ruby. If you need to do something where you have even more control of the machine, you then drop down another layer to C. Red did something like this, where there is Red, a dynamic language, that sits on top of Red/System, which sits on top of C. The language itself has zero focus but I quite enjoyed this way of doing things. Instead of making one language be good at all the things, you and several that were really good at their particular niche and all play together seamlessly.
Hm, odd, it was showing perfectly fine for me, but I did see it weirdly indented at some point earlier. Tried editing it again to see if that changes anything, but can't reproduce here now.
And that's one of my favorite books! I'm just not sure what you mean - I wasn't talking about static types, though I also enjoy static types. I said "Value Types" which is a very specific thing. Value types prevent shared mutable state, which is rampant in Ruby. Value types are copied by default in other languages, so you can't have more than 1 reference to an instance, ever. It has a great simplifying effect on programs, in my opinion.
It’s not. I would find a different resource. I watched a bit and would not recommend this.
MRI has pretty much the same value types as Java, as it uses type-tagging for things like integers, true/false/nil, Sybol etc. &amp;#x200B; We could benefit from some more advanced auto-unboxing of instance variables, but that's really an optimization more than anything, and one that \*can\* be done. E.g. my (very much unfinished/buggy) Ruby compiler does create C++ like instance structures rather than a hash, and while those fields contains object references now, automatically adding guards on assignment to instance variables and be able to auto-unbox things like integers with a fallback case is definitively possible. The hard part is not doing that, but figuring out when it is more efficient to do that than leaving the values boxed (using type tagging like MRI does would solve that, but at the cost of overhead on every method call - I hesitate to do that as I think in many cases it's possible to solve this better by analyzing code flows and auto-unboxing, but I won't know until I try). Selective type annotations \*will\* allow massively simplifying the analysis needed for auto-unboxing. E.g. if annotations tells me a give ivar can only ever contain integers, then auto-unboxing becomes trivial. I'm not a fan of type annotations myself, but sparingly used they might be worthwhile.
Can't say I'm a fan of them caving to this. I understand the arguments for types. I generally disagree with them. They're annoying and cause more frustration than they're worth. At least they're optional, but, I have a feeling that caving this far, they'll keep adding more and more ways to make it less optional and then developers will fall back to using a type system as a crutch for not educating less skilled developers and for doing less documentation work.
Fuck, too real
If you use `bundle install` to install the gems, you'd use `bundle exec ...` to run a binary provided by one of those gems. Hacking the PATH is not the correct way.
Beginner Question - How would you type check a bool in Sorbet? Or how would you type check a (byte) string buffer vs a (frozen) string for example? Is a String a String? Or can you use lets say String, Bytes and Buffer?
The `case` example was actually a huge "thank you" moment for me when I first discovered it. Coming from Lisp and Erlang, I'm used to the `cond` expression (simply `if` in Erlang), which works like this: Lisp: (cond ((eql foo 1) ...) ((eql bar 2) ...) (t "default case")) Erlang: if Foo == 1 -&gt; ... Bar == 2 -&gt; ... true -&gt; "default case" end Explicit if-else chains have always been incredibly ugly to me, so this is a huge relief.
Why method call returns result, it’s not a message anymore
Of course, since all Ruby versions so far had types.
&gt; Using `bundle exec` interprets log.txt as a positional argument rather than the target of the stderr redirection. Specifically: ``` $ bundle exec asciidoctor-pdf test.adoc -o test.pdf 2&gt;&amp;1 log.txt asciidoctor: FAILED: input file log.txt is missing ``` Is there a better way to reproducibly install a bunch of ruby tools for use in a repo than using bundler?
=~ is very common. match? is very very rare. I'd go with the former.
FYI: The [RubyKaigi 2019 Progress Report on Ruby 3 Talk Slides](https://docs.google.com/presentation/d/1z_5JT0-MJySGn6UGrtdafK1oj9kGSO5sGlTtEQJz0JU/view#slide=id.g57cf166414_14_5) have more (from the source) info. See the slides titled "Static Analysis" [1] Ruby 3 static analysis will have four items: 1. Type signature format 2. Level-1 type checking tool 3. Type signature profiling / prototyping tool 4. Level-2 type checking tools and so on.
You should know what you are asking for in a query method (ie active record). Again, we have respond_to? and conversion methods available.
If there are 3 of those at the top of each method, that’s just awful though.
That's being slightly obtuse; respond_to is not a substitute for type checking of arguments, not that I'm defending that as necessary.
I agree, if you are relying on types too do th
I agree with this.
I already made a concrete proposal. You just responded with a series of lunatic rants. I’ve had enough - welcome to my block list.
We have conversion methods if that’s what you want. Generally, we are expecting messages with our arguments so yes, responds_to? Is applicable.
Excellent! Optional weak typing is something that I have loved using in JS and I have wondered when it was coming to ruby. Good work :)
We also have implicit conversion methods. If you wanted an object that was a cousin to Integer you can use \`.to\_int\` and it fails if it's not. \`\`\` irb(main):001:0&gt; nil.to\_i =&gt; 0 irb(main):002:0&gt; nil.to\_int NoMethodError: undefined method \`to\_int' for nil:NilClass \`\`\`
The use of separate `.rbi` files is something that I can see either making or breaking Sorbet. Having to maintain separate files is a chore, and all too easy to forget. This means it's also unlikely for large projects (e.g. Rails) to provide official support, meaning Sorbet would lag behind (though Rails API changes are not that common). I also wonder how they're going to deal with different versions of the same library. Looking at [this directory](https://github.com/sorbet/sorbet-typed/tree/master/lib/activerecord/~%3E5.2) it seems at least the `.rbi` files are versioned (though it appears to not be used for all of them), but I'm curious to see how they determine which one to use. You could use Gemfile(.lock) for this, but that only works if you actually have one. I ran into all these issues with [ruby-lint](https://rubygems.org/gems/ruby-lint) several years back. Looking back at that, I think the only long term way to make gradual type checking work is to bake it directly into the language's syntax (e.g. like Python). This makes it easier to maintain, and less likely to be forgotten. With that all said, I'm excited to see how Sorbet turns out!
The proposed syntax is actually even more horrific to my eyes.
Right, Java doesn’t have real value types. I’m taking about something like Swift structs, which are copied on assignment so they can never have more than one reference.
Agreed. I get \_why\_ they did this, but it's not pretty. Still, I'm personally really happy to have types available. My code base is far too large (and old) to not have types on a lot of things.
You like Ruby and want a production-ready (i.e., *not* Crystal) language that supports optional typing (static *and* dynamic –and duck typing) and has massive amount of tooling and libraries? I have an answer: It's called [Groovy](http://www.groovy-lang.org). You more or less already know it: class A { // Types are optional def name def whatever // But must specify String here def methodMissing(String name, def args) { println "You called $name with $args" } } def a = new A(name: "sshaw") a.whatever = "🤓" println a.name // sshaw a.iDontExist 123, 456 // You called iDontExist with [123, 456] def aLambda = { it * 2 } // "it" is default variable println aLambda.call(1_000) // also valid: aLambda(1_000) [1,2,3].collect { it * 2 } // [2 4 6] // Or [1,2,3].collect { element -&gt; element * 2 } // explicit variable def castAHashToAClass = [name: "sshaw", whatever: 123] as A println castAHashToAClass.class // class A String explicitType = castAHashToAClass.name println castAHashToAClass.name // "sshaw" interface Foo { String bar(String s) } class Baz { void iAcceptAFoo(Foo f) { println "Calling bar: ${f.bar()}" } } def baz = new Baz() def foo = { "Groovy casts me to the interface type Foo" } as Foo baz.iAcceptAFoo(foo) Foo foo2 = { "Another way to cast" } baz.iAcceptAFoo(foo2) def testType(int x) { x ** 100 } def x = "123" testType(x) // Error, testType accepts a String
 sig {params(x: Integer).returns(String)} why this syntax
`bundle exec 'asciidoctor-pdf test.adoc -o test.pdf' &gt; log.txt 2&gt;&amp;1`
Shevy, mate, you've reached a new low here. Making a recommendation based upon how often a method occurs in an unspecified sample of source code despite the fact that others have already given sound advice based on use case and pointed to performance data. Sheesh!
Did I understand correctly that the Ruby team has given up on freezing strings in Ruby 3?
crystal what?
It's not intended to be completely written by developers. They're planning on these files being generated by the runtime, and then you can go edit them, tune them up, add a few things, but the intention is that they are majority machine-generated.
Ok.... ok..... i understand why..... 😶😓
Crystal is a statically typed programming language inspired by Ruby: https://crystal-lang.org/ Kind of like having the concurrency and performance of Go with the syntax of ruby. It overall looks really great though I have little hope of it ever being more than a niche hobbyist language.
After writing a bunch of Jenkins pipelines in Groovy, I have to say: it doesn't even close to comparing.
Please elaborate.
The way nearly every discussion anywhere about Ruby involves someone talking about the advantages of Crystal is to me a symbol of a language that can't stand on its own. It's a kind of evangelism strike force.
Groovy contains none of the joy of Ruby and often feels like java.
Saw this recently and I'm already interested. http://deliveroo.engineering/2019/02/14/moving-from-ruby-to-rust.html
Have you looked at https://github.com/intridea/hashie? I read through your post pretty briefly (so I might've missed something) but what you describe seems very similar to https://github.com/intridea/hashie#mash)
Crystal Lang has a syntax inspired by ruby, but it’s far more than “ruby with types”. It is compiled, has a macro system, and a really sweet DSL for working with C directly.
Is not type per se, but inference, and type hinting aiming mainly at tools like IDE's: https://youtu.be/cmOt9HhszCI?t=1756. The title of this thread is completely misleading.
If you are adding more and more objects as arguments to methods, then there is likely a flaw in your design, this should not happen with proper OO. I think what could be helpful is to not just think about the objects you need, but what messages should be sent to each object. For example, if I think about the DiscordChannel object, it might respond to #messages, which I expect to be a query message to ask the DiscordChannel to return an array of messages sent in it. No idea what actual problem you are solving for, but thinking about the public interfaces for the objects (what messages they can receive) can help guide you in terms of what they are responsible for. If you are looking for more in-depth resources, Practical Object-Oriented Design in Ruby (https://www.poodr.com/) is the most influential programming book that I have ever read.
Well if people actually started using it instead of waiting for it be popular first... 😉 but that’s the same argument other failed-to-catch-on tech uses so I see your point. It fills all of my dream lang reqs even if it doesn’t for others so I use it.
Okay, I think I get what you're asking. You've got a bunch of different types of objects that are all required to have knowledge about the state of the other objects. Rather than making your method signatures longer and more complex, you are trying to figure out a more elegant way to share this information with other objects. I don't know the specifics of what you're working on; there could be a bunch of ways to accomplish this depending on what you're doing. One idea that comes to mind is using a publish subscribe pattern. You have event objects that contain some specific information about an event. The "publishers" will broadcast this event. Any object that is subscribed to this event type will receive that event object and act accordingly. Using this method, each of your different objects don't actually need to know what the other objects are. They just know they need some specific information whenever a specific thing happens, then they can make whatever changes they need to themselves. Here is a link to a gem that does just that: https://github.com/krisleech/wisper However, if you really do just need to execute your code in the scope of another object, then check out the `instance_eval` method. It takes a block and the code inside that block will be executed within the scope of the object it is called on. This is how a lot of DSLs are made in ruby. ``` class Foo def do_stuff puts "hello" end end f = Foo.new f.instance_eval do do_stuff end ``` This will print out "hello". I hope that helps!
Well yes, Java code is valid Groovy code so it certainly can "feel like Java". It _can_ be Java! But this depends on the author's style: one can also write Java in Perl or not write idiomatic Ruby. But there **definitely are similarities to Ruby** and, in some cases, I'd say improvements: // s = "sshaw" too def s = "sshaw" s &lt;&lt; "!" s += "@#$" s[0..2] s[-1] s = "sshaw" s &lt;&lt; "!" s += "@#$" s[0..2] s[-1] [1,2,3].each { e -&gt; println e ** e} [1,2,3].each { |a| puts e ** e} [1,2,3].collect { e -&gt; e ** e } [1,2,3].collect { |e| e ** e } [1,2,3] + ["A"] // same in both def fx = { e -&gt; e ** e } fx.call(10) fx(10) fx = -&gt; (e) { e ** e } fx.call(10) fx.(10) def fx = { total, e -&gt; total += e ** e } [1,2,3].inject(100, fx) fx = -&gt; (total, e) { total += e ** e } [1,2,3].inject(100, &amp;fx) class A { def name def whatever def capitalize() { name.toUpperCase() } } def a = new A(name: "sshaw") a.sshaw a.capitalize() class A attr_accessor :name attr_accessor :whatever def initialize(options = {}) @name = options[:name] @whatever = options[:whatever] end def capitalize name.capitalize end end a = A.new(name: "sshaw") a.sshaw a.capitalize def hash = [foo:1, bar:2] hash["foo"] hash.foo hash = {foo:1, bar:2} hash["foo"] hash.foo # needs OpenStruct Sorbet types are awkward. Does it feel like Ruby? extend T::Sig sig {void} def foo puts "foo" end sig {params(x: Integer).returns(String)} def bar(x) x.to_s end sig {params(a: T::Hash[Symbol, Integer], b: Symbol).void} def baz(a, b) a[b] += 1_000 end Groovy with types is a first class citizen and are much cleaner: void foo() { println "foo" } // Can also use: int x String bar(Integer x) { x.toString() } void baz(Map&lt;String, Integer&gt; a, String b) { a[b] += 1_000 }
And yes, I understand the types can be generated and can be in separate file.
As example I need to check if a user command is present in my discord channel. If it is, prevails over a recently cached command. If is not, the recently cached command prevails over a time based condition. If no recently cached command and no user command are present, then the time based condition triggers reading of data from my data source. A fourth object is my status check. Deciding if conditions are right to proceed at collecting data, sending messages and so on. Discord needs to access the scope of Cache to check the cached command. Cache needs to access Discord to notify the most recent command has been stored. Or a validity period trigger has purged it. Or status check needs to access the scope of both Discord and Cache. I gave methods sensible functions about the object they represent - save this, retrieve that, initialize connection etc - but as you wrote probably I need to rethink the interplay of them.
Pattern matching looks promising !
Was checking publish-subscribe pattern before posting. The problem is my objects should subscribe each other since there’s not a single status I have to broadcast. Cache reads Discord. Discord reads Cache. Status check reads both of them and then passes over to the data source. Who posts to Discord.
mash looks closer to an OpenStruct but thanks for the link, they do seem to do interesting things (I would put them in the "custom class" column :) )
I still don't understand how people keep on using the term "functional". At which point have methods been called functional, if they were attached to objects? And, even more so, since you can detach methods in ruby at "run"time anyway, even that distinction doesn't make a whole lot of sense either. I also don't understand this: &gt; I need to pass multiple objects as arguments because an object scope doesn’t &gt; include other objects scope - obviously. &gt; I can see how adding more and more objects will lead to adding even more objects &gt; as arguments because I need their scope. There’s a standard solution to this problem? I have no real idea what he is trying to do, but there are obviously several ways that could be used: - You can always store state in the toplevel "namespace", such as: module Foobar @use_colours = true def self.use_colours? @use_colours Objects can be stored there as well. This may be simpler if you have to re-use functionality among different classes, so you initialize once, and then query lateron only. You can also pass lots of objects via * such as in: def foobar(*i) Not sure if this is needed; the described problem scenario already seems weird, but if you have to, you can pass in the object, and then inside that method check what these objects do, who they are, what they respond to etc... and then add code to handle these cases. Other solutions may include to simply have one "parent" that handles all these other objects, and then simply invoke that. Use methods as makes sense and document these so that people know how to use that. I think the biggest confusion I have is why people keep on calling oldschool OOP "functional" suddenly. Turning toplevel-procedural code in ruby into OOP is trivial - just write proper classes instead. It achieves just about the very same, but it is a lot easier to re-use. (You could also use a module rather than a class but I found that a bit more cumbersome; usually it is simpler to use a class, and if you then need toplevel-methods you can always add these to the main module.)
&gt; As example I need to check if a user command is present in my discord channel. Then simply add appropriate methods to the toplevel class that can handle all the other classes. In ruby-gtk you usually see this structure, where widgets are defined, customized and usually a child to the Gtk::Window "master" widget. &gt; The jump from functional - where everything is within one scope - clearly forces &gt; to rethink structures. Not really, it's just about the same. There is no truly meaningful distinction between OOP-centric design and non-OOPC centric design in ruby. It's inferior languages such as java that desperately try to enforce this model onto people's mindset. When you have a language as flexible as ruby, that distinction loses most of its meaning. See .send() versus .public_send, and private/protected/public. When you use "functional", for example, the methods defined become a private method on class Object by default. So it's still a method actually. You can store state anywhere, even on class Object itself by the way (not that I recommend it, but the example above Object.colours? would work fine). What I recommend is to simply use a module that makes sense for your project, and then see what you may have to store there, on TOP of using classes for that.
someone also mentioned it on discord so I went through the readme: I guess the `Hashie::Extensions::MethodAccess` is the closest but doesn't do deep conversion and adds some "?" methods and some writers (e.g. `a=`), also has `Hashie::Extensions::IndifferentAccess` which is similar to what I'm using from activesupport, I like `Hashie::Clash` but it's a completely different use case. some interesting ideas, still prefer my way.
Reading your answers made me doubt the correctness of describing a bunch of functions (without defining any class) in a script as “functional programming”. Short internet research confirmed my doubt. It is clearer if I correct my previous from “functional” to “procedural”? Sorry about that.
As mentioned above I mistakenly called “functional“ what really is “procedural” programming. Got carried away by the fact in the first implementation was using only functions I guess. For the rest isn’t the first occasion somebody suggested to use modules. It’s still not clear to me how may help - read they serve to share methods and isn’t what I am looking for - but will get there.
Answer: all the time. Next question
it is hard to help you out in this question without reading your case and having a clear understanding of the your use case. I am also checking the [publish/subscribe pattern](https://www.toptal.com/ruby-on-rails/the-publish-subscribe-pattern-on-rails) I believe your options are: 1) Change your current architecture and avoid having `Cache` directly read `Discord` and vice-versa, instead build a parent object which manages Cache and Discord 2) Adapt to the pub/sub architecture I would add a clear ruby example to your code and read more about `publish/subscribe` pattern
I generally lean towards adding foreign key constraints whenever possible. This position comes from the pain of dealing with historical databases which lack the constraints, and the data integrity issues which exist as a result. Where would you avoid them, and why? Obviously polymorphic associations, where they aren't possible (unless I'm missing something).
Checkout [class2](https://github.com/sshaw/class2).
Awesome! This looks really good! Thank you for releasing it, I'm going to try it out. Have you tried combining it with `graphql-preload` with any success?
Nice. Is this a gem you work on?
I'd argue that `Mash` is closer to a `Hash` than `OpenStruct; a `Hash` with indifferent access and method access. `Mash` supports `Hash` methods like `keys`, `values`, `key?`, `zip` etc. Regardless, I'd personally be careful with classes that inherit from `Hash`. PORO is best to me. I prefer staying away from things that are actually one thing, aka a `Hash` in this case but try to act like more like a PORO. u/shaw_'s suggestion seems like a nice idea. Some interesting posts from the past you might be interested in: https://tenderlovemaking.com/2014/06/02/yagni-methods-are-killing-me.html https://www.schneems.com/2014/12/15/hashie-considered-harmful.html https://www.reddit.com/r/ruby/comments/2pkzec/hashie_considered_harmful_an_ode_to_hash_and/
sounds cool but this would create a lot of extra classes, and in my case I'm dealing with highly unstructured data coming from external services so would be a lot of work (if even possible) to declare all the structures
thanks, looked at it, but it doesn't seem to fit most of the requirements. for instance `Clazz.new(a: 1, b: 2)` or `Clazz[a: 1, b: 2]` (class need to be created like struct and then it becomes a global)
I prefer "standing on the shoulders on giants" than making classes this complex from scratch (most of my classes are just `class Something::A &lt; Something::Base` or just regular ruby classes). for your posts: - tenderlove: YAGNI: hmmm I actually do need these methods, memory leaks: I'm not introducing new ones, that was just a bug, - schneems: `Foo.new.spellning` would raise in my case, and `Foo.new.spellning = ..` would raise too :). `result = hash.merge(hashie); result.name` works for me as I'm staying in sync with the keys, and yes I'm not using Hashie, it has too much and too permissive for me. also my allocations are basically the same as Hash, nothing crazy. (those are great links, thanks)
I do agree that your class being more constrained than `Hashie::Mash` is a plus. In my case, most uses of these types of utility classes have been when receiving a JSON payload (which can be hard to solidify as PORO objects if they are very dynamic). In those cases I'd probably go in this order of my preference: 1. Just use the `Hash`. 2. In cases I **really** need method access, I reach for `JSON.parse(payload, object_class: OpenStruct)`. It gives you the deeply nested `OpenStruct`s. 3. Otherwise if I just wanted indifferent access, with the availability of methods like `Hash#dig`, I'd just use the `HashWithIndifferentAccess` directly. To me, seeing the same payload accessed in multiple ways (with keys &amp; methods) is confusing. To someone looking in a file that only accesses it via methods, they have no clue that this is actually a `Hash` and vice versa. Flexibility comes at the cost of clarity IMO. By the way, I'm not criticizing your code or anything; this is more about the general approach that I've seen in codebases I've worked on. The approach of having dual(/multi)-behavior objects all to get some small convenience.
in my case all JSON (database (jsonb) or external services) gets translated to SimpleHash, then I access attributes with \`.name\` or \`.try(:name)\`, and when dynamic access is needed I use \`\[key\]\` / \`fetch(key, ...)\` (never \`\[:name\]\` directly.
I had this edit in my last post. Figured I'd post it here if you didn't see: I'd also call out somewhere that this class is mostly meant as a convenience while reading, not for writing. Since things like: &gt; user = SimpleHash[emails: [{ domain: "localhost.dev" }]] &gt; user.emails.first.merge!(domain2: 'google.com') will seem to work without error, and the `merge!` won't have any effect on the original `user`.
I'm not a particularly big fan of static typing (particularly in Ruby) but this isn't a great example. It's very easy to implement your example in Go, or Scala or any language that supports structural typing. Reaching for Java is convenient due to its popularity, but it has a very anemic type system so it's really punching down when it comes to type system comparisons.
Isn't this just pointing out a case for interfaces? Instead of `File.read` being annotated by `Pathname` or `Object`, shouldn't it be annotated with something like `ImplementsToString`? Disclosure: I haven't looked into what types will look like in Ruby 3 so I might be missing something.
hmmm yes you would need to do `user[:emails].first.merge!(domain3: 'example.com')` I fixed it by adding `.freeze` to the converted simple hash. will update the code. thanks for the bug report :)
Nice, will prevent someone from scratching their head in the future with "but the code to update the hash is the right there!!!" :p
Yes and no. It's really a call for duck typing, which is called 'structural typing' in static typing land. Say you define your interface, `ImplementsToString` such that it requires a single function `to_s` that returns `String`. In Java, which has 'nominal typing', you have explicitly define all classes you would want to use with `File.read` to implement `ImplementsToString`. This is a huge PITA because you may no even have control over all these type definitions, they may come from libraries, etc. And even if you do control them, you end up with ridiculous class definitions that implement a dozen or more interfaces. In contrast, if your language supports structural typing (Go, Scala, etc) then you don't have to explicitly state that any given type implements an 'interface', as long as they type has the needed functions then it's considered compatible and everything compiles just fine. An example in Go: type ImplementsToString interface { toString() string } func print(input ImplementsToString) { fmt.Println(input.toString()) } // Define a new type, note that it doesn't explicitly implement ImplementsToString type MyType struct {} func (t MyType) toString() string { return "Hello World" } print(MyType{}) // Outputs 'Hello World'
Main reason it's wrong is because typing in Ruby 3 will be optional, so there's nothing to be worried about.
Right, makes sense. I have looked into Go's interfaces before &amp; I understood how it's interfaces worked. What I did not know before is that is called structural typing! Seems like structural typing might be a good fit for a language like Ruby (as to prevent the headache of needing to sprinkle `ImplementsToString` into a million classes).
Something like this is never really optional. Either it will see wide adoption in the community and every job you look at will be using it (thus you have no choice), or it won't be and no one will use it. There is no practical in-between outcome.
Personally I'd like to see something more analogous to Clojure Spec (https://clojure.org/guides/spec). It's written in clojure obviously so it's not the easiest thing to read but the basic gist is the ability to define arbitrary 'validators' for the input and output of functions that can either be evaluated at 'compile' time or 'runtime'.
I tend to think that’s true, too. Hard not to see adding it to Ruby-proper as an endorsement to do things that way.
That’s fair on punching down, but was looking for something easily digestible. I saw your Go example in the other comment. While interesting, that doesn’t seem to be the direction Ruby’s headed, just looking at the examples they’re drawing inspiration from: https://github.com/soutaro/steep and https://sorbet.org. My point isn’t that you can’t do typing well. More that shoe-horning it into Ruby the way we’re proposing is worse than leaving it as is.
I'll not do nitpicking and point out the dialect or anything, or question the usefulness of the video, but there is one problem: if (x &gt; y); puts "x is larger than y" In my opinion, if someone shows code like the above, and has this unnecessary ';' there, then in most cases I can think of, it must have come from someone who has NOT been using ruby for at the least some time. Because otherwise you would instantly spot the problem. Now you can say taht this is nitpicking but ... this is a question of writing idiomatic code; or writing code that is "efficient" for your typing. Is the use of ';' efficient there? Nope. There is no need for it, so why is it there? And, while normally I would not care, this is a video FOR other people - so we would want to expect higher quality standards from videos like such one. Still, props for the effort. Another thing I wonder is ... 4 minutes. Is that like a teaser and trailer and advertiser only? I don't mean excessive length either but I know of many other videos that are in the range of 2-4 minutes and are just ad-platforms for closed content behind paywalls.
Yea, Sorbet implements a nominal type system as far as I can tell, which I think is a major mistake. Perhaps a good topic for a blog post :)
Here's come the type posts
It is very clear that whoever wrote the code, is not a ruby user - see my example of **if(x &gt; y);**. Ruby folks do not use such a strange style. The person writing it MUST have used another language before extensively.
Neat, I often have a little class like that when I'm writing command line tools. I won't have HashWithIndifferentAccess in those tools though, so it would be nicer if it didn't have that dependency.
doesn't work on my code, but you could do something like this: https://gist.github.com/localhostdotdev/3c978fe76511a5b9223fa725829e93b
```ruby class MyClass def self.yield_once_with(*args) yield *args end def self.yield_twice_with(*args) 2.times { yield *args } end def self.raw_yield yield end def self.dont_yield end end ``` the methods use `yield` so for example ```ruby # using a proc proc_printer = Proc.new {|x| puts x } MyClass.yield_once_with([1,2,3], &amp;proc_printer) #=&gt; 1 #=&gt; 2 #=&gt; 3 # or passing a block MyClass.yield_once_with([1,2,3]) {|x| puts x } #=&gt; 1 #=&gt; 2 #=&gt; 3 ``` what the code is doing, is iterating and passing the subroutine `{|x| puts x }` inside the `yield_once_with` method which would look something like ``` class MyClass def self.yield_once_with(*args) args.each {|x| puts x } end end ```` but it is a little bit more complex then this.. and [the Ruby Programming Language from David Flanagan and ‎Yukihiro Matsumoto](https://books.google.it/books?id=jcUbTcr5XWwC&amp;printsec=frontcover&amp;dq=the+ruby+programming+language&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjf8c64pd_hAhXR2qQKHYdaBf8Q6AEIKzAA) explain it better in the chapter Blocks and altering control flow about your code ```ruby def array [1, 2, 3] end def array_of_tuples [[:a, :b], [:c, :d]] end RSpec.describe "yield_successive_args matcher" do specify { expect { |b| array.each(&amp;b) }.to yield_successive_args(1, 2, 3) } specify { expect { |b| array_of_tuples.each(&amp;b) }.to yield_successive_args([:a, :b], [:c, :d]) } end ``` `|b| array.each(&amp;b)` does not really matter `b` as the expectation is on the arguments passed and not the `block` or `proc` called. The expectation is just checking that the block will be executed three time with the following arguments first time 1 second time 2 third time 3
You’re splitting on spaces, meaning you’ll loop over words. You want to loop over each character. I’d do something like string.each_char.with_index so you can loop per char and use the index to decide whether or not to upcase.
What you want to do is: 1. Split your characters into an array to loop through 2. Iterate through that array 3. Check if the current iteration (character) is alpha 4. If it is, and your index is odd, capitalize it 5. If your character is alpha, increase your index 6. Add iteration new string This won't win you any stylepoints, and can be trimmed down even further (which I challenge you to do), but for clarity: class String def spongebobcase i = 0 new_string = '' self.chars.each do |char| if char =~ /[[:alpha:]]/ if i.odd? char.capitalize! end i += 1 end new_string &lt;&lt; char end new_string end end puts "hello how are you?".spongebobcase # hElLo HoW aRe YoU?
&gt; And if you give it something that can’t be coerced into a string (doesn’t define a to_str method), it’ll blow chunks at runtime class File def read: (pathname: Object responds_to? :to_str) -&gt; String end Types can be a lot more than just class names. Don't discount all typing just because of Java's type system. There's lots of different ways to do types that are either [more flexible](https://en.wikipedia.org/wiki/Structural_type_system) or more expressive. I expect that anything ruby chooses to implement will look more like structural typing than nominative typing.
```ruby def alt_capitalize(str) str.chars.map.with_index {|c, i| i.odd? ? c.capitalize : c }.join end ```
non-alpha characters may/will be odd and thus capitalized, breaking the chain
True. But I don’t suppose that was asked for.
Don't give up so quickly! A large part of software development is figuring out algorithms to solve problems. By giving up so quickly and asking for help, you are not getting the practice you need. "Joshmn" gave an excellent example of how you should first think about the problem and write out the steps. After that, you turn those steps into code. After you understand how to solve it, it will become more natural to optimize it in a way that "valadil" and "ikhurramraza" showed.
YARD already provides a concept for describing things who implement an interface: ```ruby # @param [#to_s] thing def foo(thing) thing.to_s end ``` We obviously need such a thing in a real type system that might see the light of day, so we as the community should raise these issues with the people working on the features. Done the right way, it could be incredibly powerful. Also people, remember, type lists are a thing. You don't have to just say one.
I have to agree with ikhurramraza here. It says "characters", which to me includes non-alpha characters as well.
Understood - thank you!
This is exactly what I needed! Thank you, joshmn
Good luck!
Not sure what you mean: irb \[2.3.7\] (class2)$ class2 :clazz =&gt; %w\[a b\] =&gt; nil irb \[2.3.7\] (class2)$ k = [Clazz.new](https://Clazz.new)(a: 1, b: 2) =&gt; #&lt;Clazz:0x00007f963c16c0b8 @a=1, @b=2&gt; irb \[2.3.7\] (class2)$ k.a =&gt; 1 irb \[2.3.7\] (class2)$ k.to\_h =&gt; {:a=&gt;1, :b=&gt;2} &amp;#x200B; Pretty much supports everything in your table except \`#keys\`, \`#values\` and \`#\[\]\`.
&gt; (class need to be created like struct and then it becomes a global) Okay, this is problem for you.
`chars` returns whole characters even if the character has multiple codepoints (like emojis / chinese characters) so this works fine. I would just use `upcase` instead of `capitalize` (which is from active support I think)
Thus far, the examples of direction we’ve seen are nominative typing. It’s hard to cover everything in a short post, but part of what I’m asking is if Ruby had always had the type system we’re proposing adding, would we have gotten the `File#read` we have today? Or countless other true-to-the-soul-of-Ruby examples that above all else exalt expressive, concise, flexible, beautiful code? I’m definitely not discounting typing. And I’m not saying all type systems get you Java style code. But typing isn’t free either. At the very least you’re maintaining these rbi files. But I suspect it’ll influence design, too. I think you can hold both of these things true: 1) Static typing is a powerful technique and lots of languages implement their types in expressive and flexible ways and 2) Dynamic typing is a powerful technique and it’s worth preserving Ruby’s implementation.
what does it mean if a character is alpha?
Thank you - I appreciate the good vibes! It's been a rough journey, but I feel it will be worth it. :-)
Thanks for the credit &amp; the platinum!
That would be the equivalent of: def sPoNgEbObCaSe spongebobcase end Looks like he is just having fun. :-)
Is this what will come baked into ruby 3? I was a bit confused about the announcement/tweet the other day. Or is this inspiring what will become a native language feature in ruby 3?
`capitalize` is ruby core.
full article: [https://www.globalapptesting.com/blog/picking-apart-stackoverflow-what-bugs-developers-the-most](https://www.globalapptesting.com/blog/picking-apart-stackoverflow-what-bugs-developers-the-most) (that animation of ruby leaving the top 10 though)
How does one capitalize a non-alpha character and what's result?
Excuse me shevy-ruby first of all. There are different way of writing code. As long as the code is working and the code is useful. I don’t care how the code is written. Btw I keep it around 4 mins because my requirements for this video is under 5 mins. I should title this my reflective video for my programming class. Also that I clearly stated that this is my reflective video for my programming class. If you care that semi column than how you suppose to use programming as a tool to make a program that can help the world the become a better place? How you gonna solve other people’s problem if you can’t even focus on the big problem? Semi column not even consider a problem. Shevy-ruby please be respectful. I respect your opinion but your comment really is useless.
def bobcase(src) 1.step(:by =&gt; 2, :to =&gt; src.size - 1).inject(src.dup) { |s, i| s\[i\] = src\[i\].upcase; s } end
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
The ultimate Ruby question: "Rails string array difference method vs get file hash using gem."
you probably meant "rails rails rails rails rails rails rails rails rails rails rails rails rails rails rails rails"
something should reverse engineer the wasm compiled version on [sorbet.run](https://sorbet.run) :D
&gt; (that animation of ruby leaving the top 10 though) Care to explain why you think this is a bad thing?
My understanding is that it’s not exactly what will make it in, but the team behind this is working with core on what will actually ship. I could be wrong though.
lol, ok. :-)
I am beyond excited for this. It’s what’s keeping me from trying to get away from Ruby right now.
even if I like to think most people don't have issues with ruby and/or issues are already answered and/or issues are discussed elsewhere, I still think that proportionate usage is low (e.g. everybody is doing javascript/python these days). wouldn't hurt to have more ruby users IMHO (making it work well on windows could help :) )
Try a regular expression. def bobcase(str) str.gsub(/([[:alpha:]][^[:alpha]]*?)([[:alpha:]])/) { $1 + $2.upcase } end bobcase('hello how are you?') # =&gt; "hElLo HoW aRe YoU?"
Has this been delivered? If so is it online somewhere?
The talk has been recorded but won’t be available for viewing until a week or two later.
‘def main’? Designed for Ruby?
Hey. Sorry for such a late response. I've been in Japan for RubyKaigi i haven't had time to visit Reddit. First of all: thank YOU for using Karafka :) It's people like you that inspire me to do a further development and to fight for more performance. I'm glad it was of use to someone and to maintain someones job? Wow! The best place to track Karafka changes is: - The github page and the issues: https://github.com/karafka/karafka - My personal blog: https://mensfeld.pl/ - Gitter (I announce there all the significant changes): https://gitter.im/karafka/karafka Glad you enjoy this lib and don't hesitate to ping me in case of any troubles / questions, etc!
seems like it was breaking enough of the ecosystem that they feared it would hurt 3.0 adoption. sucks, but it’s a serious consideration nowadays.
it seems they iterated through simpler schemes before settling in this kind of “builder” syntax. it’s actually more oop in flavor than the simpler, seemingly more intuitive ones.
It just returns the character unchanged
true, but consuming other people’s libraries without any ide support or sane errors is kinda limiting. i think this is good for methods where different teams interact. i’m just guessing we can ignore types as well for stubbing etc.
No. This will not be the approach Ruby core is taking. Matz said he doesn't like that it requires a separate C++ program, for one.
I’m not familiar with test reports. for those of us using specs with describe blocks, is this something that can take advantage of that nested structure?
link doesn’t work on Apollo?
 sig {params(x: Integer).returns(String)} def bar(x) x.to_s end IMHO better is to use more short form, like in f\*ing Haskell: bar : Integer -&gt; String def bar(x) x.to_s end
I had the exact same thought. I wish something like typescript would br available for ruby. You can say what you want about the javascript eco system. But typescript is one of the best things that happened to javascript in my opinion. Something similar for ruby would be amazing.
Is Rubex is being developed though? &amp;#x200B; I wished for something like that as well, and more Stdlibs are written in a subset of Ruby, that can be shared among different Ruby implementation.
But of course! Should’ve added that a long time ago.
So you're judging the python community based on two people? None of them threw shit in the fan, they gave you advice and you got mad because it wasn't exactly what you wanted to hear. Chill dude.
&gt;Chill dude. Will do. Almost there, actually. Just taking a moment to appreciate Ruby.
I also did see that you edited your response in the python subreddit. Props for stepping up.
What's being developed is a type profiler not a type checker, there's nothing you can you now that you won't be able to do in the future.
&gt; The community starts throwing shit in the fan, ranting about how &gt; &lt;1024-bit keys are insecure and all I would not confuse this with "the community". There are always idiots who do not help solve a problem and instead side track issues. I have seen that happen on KDE-reddit recently. I then point out that these time vampires do not help the original poster and then I explain that this is exactly why StackOverflow was a success, since people get help, rather than have to get side tracked by wasting their time. My primary advice is to, in general, avoid these time vampires after calling them useless folks which admittedly does not help much - but if you can't change them from being time vampires they will just keep on being idiots. Ruby is indeed very different to python though. The biggest difference by far is simply the philosophy; syntax wise it is not even that much a difference (if we ignore the MOST HORRIBLE mistake Guido made - the one being of explicit self, where you have to tell python where self is, all the time, because python is too stupid to know that on its own). I use both ruby and python by the way; evidently a lot more ruby but I Have no problem writing python either. I just honestly think that ruby is the better language for various reasons. Even though this evidently is not reflected in the amount of users. :) Matz is pretty awesome indeed.
It's not up to you to evaluate it. He asked for help, so either you can help, or you don't.
&gt; I'm less excited about Ruby with types Good! Nobody needs this shit anyway. I am glad to not be the only one. (Note that, despite what the type-addicts claim, mandatory types won't come to ruby anyway. We just have to stop these type-addicts early on, since otherwise there may be any possibility for their stupid suggestions to leak into ruby itself.) Note that the article doesn't have much to do with what was proposed at RubyKaigi though. I think a huge majority dislikes the type-shit that was suggested by that private company (and someone else said they did not even open source it, so they should be completely banned altogether), but none of this will go into ruby anyway. It is also important to mention this, because otherwise people who don't know, may assume that type-shit will infiltrate ruby - and this is actually not the case. And from a purely IDEA-driven approach, suggesting types is also fine - just not ADDING/IMPLEMENTING this crap. Also note that .rbi is different to .rb; you could decide to not use .rbi just fine.
&gt; None of them threw shit in the fan, they gave you advice Actually no - while I agree on the other part of your statement, none of them helped him with the so-called "advice". I saw that happen over and over again. It's not advice, and "chilling" does not help resolve the issue at hand, so your statement is completely useless too.
Typically the `expect` method takes a normal value like this: expect(x) But some RSpec matchers, like `yield_successive_args`, require that you give a block to `expect` like this: expect { x } The block above takes no arguments, but RSpec does actually provide an argument. expect { |b| puts(b.class) } Running the above says that the argument is a `RSpec::Matchers::BuiltIn::YieldProbe`. It's some special thing that RSpec uses to implement matchers that test yielding behaviour. So back to your usage: expect { |b| array.each(&amp;b) }.to yield_successive_args(1, 2, 3) This passes the `YieldProbe` object into `Array#each` as the block argument, using the `&amp;` syntax. When this happens, if the object isn't already a `Proc`, it is converted into one by calling the `#to_proc` method. Here is [the to_proc method for YieldProbe](https://github.com/rspec/rspec-expectations/blob/49fcbeebd6ea3e74ab542087b9d767dbc4691251/lib/rspec/matchers/built_in/yield.rb#L38-L49). You don't have to understand the details about how it works, but you can see that it returns a `Proc` which somehow works with the `yield_successive_args` matcher.
You sound very immature. Take this is a positive light to grow. Nothing that you described sounds remotely egregious, and your use of language is a bit uncalled for, even given the frustration that you might have felt.
A political prisoner. Arrested merely because he knows Assange and hasn't been allowed to speak to an attorney. The new Ecuador government looks to be pretty corrupt.
Why do you think Ruby is better than Python?
The example on their homepage is absolutely awful - both of their error cases are errors MRI already throws exceptions for without any additional annotation, as both arity checks and method name checks happens today. If they're trying to sell this they might at least try to put an example up to where it's actually providing value.
Similar: you’re sitting in a Python REPL and type exit or quit, and it replies “type ctrl-D to quit”. I’m like “Bitch you know what I wanna do, just DO it for me! Don’t scold me to do it your one approved way!”
While I get what you say, I'm not all that much against that, actually - Ruby could use a better separation of "parse-time" and "runtime", as it'd make compiling Ruby far easier. Even if it was purely opt-in as a signal that "if I have a `main` method, you can treat everything before it is called as parse-time/compile-time" it'd be a plus (I'm toying with an ahead of time Ruby compiler, and this distinction is one I've basically punted on because it's basically impossible to get right without some kind of annotation - e.g. is that dynamically constructed string fed to 'require' meant as a way to let people add plugins at runtime, or just a convenience to avoid listing every file? Can't tell currently, because there's no way of making the distinction).
Ummm... exit() python doesn’t auto call functions so u need the parentheses.
I'd suggest in that case something more like: def bar(x) : Integer -&gt; String x.to_s end But my problem with this in general is the idea of equating types with classes. The above arbitrarily limits x even though any object with a `to_s` method matches the type of the expressions in `bar`. My experience is that when developers adds such restrictions, they are often overly restrictive for no good reason. While I can accept the sentiment of wanting to convey an intent, there is no reason here for `bar` to be required to be an `Integer`. A better restriction here would be to simply require an object responding to `to_s`, or introducing some interface concept so you could more explicitly say "an object that matches this interface". So to me the syntax is the smallest problem here. The bigger problem is that their examples point to a view of typing that are the kind I'd expect from a C++ or Java developer, rather than being reflective of more modern type checking. I dislike Go in general, but Go's structurally typed interfaces are much closer to being a Ruby-ish approach to typing than what Sorbet's signatures are.
Rails overshadows way too much.
yes, this is even better. Also Python types can inspire an idea. About `x`: my personal "like" is for DOTNET design. You can find how is it done in F#: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/constraints, also C# constraints, as for me, looks good (with `where` expressions). In the Haskell world it can be something like `ToS a =&gt; a -&gt; String` where `ToS` is type-class with `to_s` method. In C# style it can looks like `def bar(x) : a -&gt; String where a : Stringable`
Seems like a legit SO question to me!
I think you're roughly correct. Type systems affect design, not because of technical limitations, but because programmers write different code when they're thinking in terms of a type system. Yes, more-advanced type systems can handle the `File.read` situation OP wrote about, but that's not the point. The point is that if a type system existed at the time that `File.read` was designed an implemented, it would have been designed and implemented differently. Whether or not that is a good thing is a subject of debate.
&gt; I still think that proportionate usage is low (e.g. everybody is doing javascript/python &gt; these days). wouldn't hurt to have more ruby users IMHO While I do not necessarily disagree with you, and yup, ruby needs more users (and so do many other programming languages), I would not put too much value onto SO. I stopped using it actively after it turned out to have not only idiotic mods but a totally flawed ranking system, where legitimate questions can be insta-shotted down. This use case is not one for everyone, naturally, but there will be a MASSIVE bias in what kind of people any given platform attracts. So I would not assume that because few questions are asked about ruby, to AUTOMATICALLY mean that there is a lack of ruby users, since the REASONS for e. g. not using StackOverflow can have a lot to do with many different factors (even if, on a general basis, I agree - more users, more questions. Seems logical. But not to 1:1 parity.)
Now the idea from Sorbet is pretty horrible - but the code you linked in even beats that: (s/valid? #(&gt; % 5) 10) We don't need lisp. We don't need java. We just need ruby. (s/explain-data ::name-or-id :foo) We are going to run out of () soon if we keep on trying to take syntax from lisp here. (s/def ::id keyword?) Wow - clojure even has two :. I guess one is not enough. Unfortunately ruby also has @@foo ... (s/def :dog/breed string?) You can model hierarchies in OOP just as well. Single-inheritance is a bit problematic though. In biology there is no clear-cut "species" concept other than the question as to whether two individuals can produce viable offspring or not (excluding those who just divide through binary fission). Every other species-concept is absolutely useless and completely made up. Why must it be viable offspring? Because otherwise it is a dead-end in evolution. There can not be changes if you can not have viable offspring. It does not even have to be "incompatible" genomes as such; could also happen because during meiosis the chromosomes would be distributed inequally (so it would not have much to do with the genes per say, since it is related to chromosome biology instead; infertility often is the consequence of inequal segregation during prophase I of meiosis). (s/valid? :event/event {:event/type :event/error :event/timestamp 1463970123000 :error/message "Invalid host" :error/code 500}) This is funny to me because lisp-lovers often say the () are not important, yet here he spreads it out since it is so unreadable. (s/def ::vnum3 (s/coll-of number? :kind vector? :count 3 :distinct true :into #{})) Lisp failed hard at syntax - and never understood why. Let sleeping dragons rest. (s/def ::ingredient (s/cat :quantity number? :unit keyword?)) The horror continues. (s/conform ::config ["-server" "foo" "-verbose" true "-user" "joe"]) Man ... I am without words ... (s/def ::player (s/keys :req [::name ::score ::hand])) Now the () are no longer enough - the lispers need both : and :: so you must look carefully with your eyes to not get confused. Lisp is such a massively overrated joke of a language. I never understood why people are in awe of lisp. It failed so hard that even TIOBE, as useless as it is, mentions lisp far far away only. I think it is important to NOT re-use every idea from other languages out there and try to make it retrofit into ruby. That just does not work. It did not work with pattern matching in ruby either, from elixir. Just syntax alone.
The TOOWTDI cornerstone of the Python community tends to lead to whatever the dev equivalent of manplaining is.
Your example shows a wonderful lack of understanding ruby. For example: &gt; would we have gotten the File#read we have today? That shows that you don't understand the OOP philosophy in ruby. Of COURSE we would be able to read a File object as-is! Why would you think this is not the case? We don't have these terrible type terror for a reason - it is NOT NECESSARY. It is for stupid people whose brain is too addicted to types. Free your mind rather than retrofitting syntax to fit to the model in your brain. &gt; Or countless other true-to-the-soul-of-Ruby examples &gt; that above all else exalt expressive, concise, &gt; flexible, beautiful code? There is one general rule valid for all type systems: - They lead to MORE and MORE VERBOSE code. So in short, uglier code. &gt; At the very least you’re maintaining these rbi files. Yes, that is true. The clowns who will use typing should feel the additional pain for their alleged "promise" of being able to do something they evidently fail already (because they are incompetent noobs). Of course it will influence design but since these are incompetent hackers anyway, their design was already inferior to begin with. &gt; I think you can hold both of these things true: 1) Static typing is a powerful &gt; technique and lots of languages implement their types in expressive and &gt; flexible ways Nope. It is a terrible kludge that originated from an era where people had to be as efficient as possible EVERYWHERE. Efficiency is still a good thing, so is speed - but the damage to the mind of people is given. Type addicts are idiots - no exception. They think that types makes things better. Let's assume this is true (even though it is not) - IT COMES WITH A DISTINCT COST: By slapping type shit onto languages that don't need them, you lose an advantage that these languages already have. So out with this shit. Ban these people. I am not even kidding, I mean this 100%. I used to get highly annoyed about the functional crowd leaking shitty ideas into ruby, but the type addicts are even worse. They are the leaders of idiocy. &gt; Dynamic typing is a powerful technique and it’s worth preserving Ruby’s &gt; implementation. Now finally this is where I can agree with you. I'll monitor these type clowns very carefully though. You sort of have to keep ruby as sane as possible (even though it is not always possible and all decisions are ultimately up to matz, anyway).
Don't know -- I've never used specs. For unit testing (all failures repaired immediately) the test reports won't be useful. When building new tests for legacy software (which is what I've mostly done), the reports help manage low-priority failures that won't be repaired anytime soon.
Why not just let monster and item card inherit from card?
Precisely! You need to tell this to people who keep on using those terrible names to reddit, such as "ruby 3 will have types" - that is a BLATANT LIE. People who write this should be perma-banned for deliberate falseness.
Hello /u/Mistr25, thank you for your response. Could explain a little bit? I agree that monster and item should inherit from card in the OO representation, but I'm using a relational database to persist the data. As the fields for monster and item are distinct, I want to use a different table for each one.
It may be worse way to go about it, I am not experienced. If you create the item and monster card which will inherit from card, activemodel in rails should support this even DB - wise, not sure I think I saw a glimpse about it in some rails guides. Then you just do has_many :item_cards, :monster_cards and you dodge polymorhic relation.
Is the purpose of this feature to test what an object does with a block parameter? E.g. this: args = nil some_method(1, 2) do |*a| args = a end assert(args == [1, 2])
True - for the most part. Rails is also not bad for ruby right? Except when 99% of the people using ruby do so only because of rails. So the context matters immensely, as moomaka correctly pointed out.
Polymorphic associations refer to polymorphism in regards to when an entity can belong to different types of other entities. For example, if a `card` could belong to a `person` or a `deck` that'd be something where you could use rails' notion of polymorphic associations. Although somewhat similar, what you're describing here, that a `card` can be a variety of types which based on the type will have different attributes is **STI** (Single Table Inheritance). This means that each row of the `cards` table has a column for each and every attribute for any type of `card`. As the gitlab link you posted says, this disallows you to put non null constraints on the attribute columns, since they are forced to be null for some types of cards which doesn't have a particular attribute etc. The alternative approach to implementing what you're describing is **MTI** (Multiple Table Inheritance). MTI has one table per type of card (in your example, there would be a `monster_cards` table &amp; `item_cards` table. Each table only has the columns that are necessary for that type of `card`. My descriptions of STI and MTI were quite brief, so you can google for STI vs MTI; there should be numerous resources to read on the topic. I've looked at this specific link before in terms of how to implement MTI cleanly Rails (https://www.belighted.com/blog/implementing-multiple-table-inheritance-in-rails which actually uses a mix of STI &amp; MTI). Fair disclosure though, I've yet to actually use the exact approach the article suggests in my own code, so there might be pitfalls there I'm not aware of.
Single Table Inheritance https://edgeguides.rubyonrails.org/association_basics.html#single-table-inheritance
Agreed. It can be a slow gradual process where the type-monkeys want to punish everyone via types. The sooner they are stopped the better.
That article doesn't make much sense to me. I'd use polymorphic associations.
Yes, this, thank you
A lot of the arguments made in that gitlab article might be valid once you reach "gitlab" scale, but if you're basically still developing/prototyping your application then I think being concernced with them is silly. Seems like you're developing a CCG ... you're unlikely to go over a million `card` records for some time, if ever. (Sorry I'm making some assumptions here). So you space concerns, and index performance aren't a concern. You can refactor all this in the future when the application becomes successful, *IF* it ever becomes a real problem. Some design questions to consider: Are you planning to add more types of cards? relic_cards, hero_cards, mana_cards, etc? If yes, then polymorphic seems ideal. Are you likely to be querying across the entire card set frequently against columns on the base cards table? Will most of the applications core business logic be built around the generic card model? If yes to both, of these then polymorphic seems ideal. Another factor is how many columns/attributes will be on cards tables vs monster_cards or item cards. Like if the cards table really only has a two or three columns while most of the columns exist, and are unique to monsters and items, then there is less of an argument for polymorhpic associations. I disagree with the sentiment that polymorphic associations are evil and shouldn't be used or considered.
I made some edits to the original post after seeing your table diagram which wasn't loading properly for me originally. Wanted to make sure I didn't mislead you /u/Diademajin
Thanks for explaining. I agree, it can feel cumbersome to avoid shared mutable state in Ruby.
I'd use single table inheritance like so: class Card &lt; ActiveRecord::Base belongs_to :deck end class MonsterCard &lt; Card include HasPower end class ItemCard &lt; Card include HasPrice end or something similar, where HasPower and HasPrice are mixins that add validations, damage calculation, etc as needed. To set up STI, you need a 'type' column in your cards database table, and after that, Rails will just make it work. The reason I like this approach is that you are unlikely to have too many single-use columns (the bane of STI, where you end up with huge model tables with mostly null columns), and you're likely to have a need in the future for a half-monster, half-item card or similar where you can just add both mixins and create your purchasable killer parakeet or whatever.
Just for the sake of the context - because Ruby solved my problem silently, while dealing with Python added more stress.
My quick thoughts on it: Polymorphic associations are fine and good and often necessary. They represent the real world problem as it exists. Often groups are made up of heterogenous things, so modeling it to match is appropriate. &amp;#x200B; On the other hand, Single Table Inheritance (STI) is almost never a good thing. I try to avoid it almost at all costs. The only time STI is ok, is when the persisted data is identical across all STI types. If you run into a case where one type of an STI needs additional/different data from the rest, STI is no longer a good solution and should be avoided.
Some thoughts from Jeremy Evans, creator of [Sequel](http://sequel.jeremyevans.net/), on the topic: * https://groups.google.com/forum/#!topic/sequel-talk/L80VZxjhDb4 * https://groups.google.com/forum/#!topic/sequel-talk/bErga6TA5ms
Indeed, I am. Will correct my attitude in nearest future.
I think it's respectable that you not only answered to the best of your ability, but also edited it to be more accurate after new information came to light. I upvoted you, but I wanted to point it out here too because I think more of us should do that too.
hello from RubyConfBy :)
&gt;\_Svejk\_ hello and thanks for remembering my talk :)
FYI: The [RubyKaigi 2019 Progress Report on Ruby 3 Talk Slides](https://docs.google.com/presentation/d/1z_5JT0-MJySGn6UGrtdafK1oj9kGSO5sGlTtEQJz0JU/view#slide=id.g57cf166414_14_5) have more (from the source) info. See the slides titled "Static Analysis" [1] Ruby 3 static analysis will have four items: 1. Type signature format 2. Level-1 type checking tool 3. Type signature profiling / prototyping tool 4. Level-2 type checking tools and so on.
FYI: (secure) ruby uses an alternative syntax: sig Integer =&gt; String, def bar(x) x.to_s end The bonus - this is "Yes, it's Just Ruby" too. See https://github.com/s6ruby/ruby-to-michelson/blob/master/contracts/token.rb#L32 for a running sample.
When I use STI I will usually have a table 90% overlap of needed data, anything that is different I store in a json blob. That blob has different forms for different still classes but underlying db structure is the same.
I'd use STI and create a new column called 'data' or something like that as a jsonb column (assuming a postgres db here), you can store price or power or whatever else eventually makes these cards that are still cards unique from each other in there. Just my personal preference, this has been a pattern which has worked well for me in the past. Surely others will disagree 🤷
I just assumed it was because he violated Oracle’s TOS for the JVM.
I would use kind to the "type" and a jsonb for "extras" attributes
I'm sorry, can you explain that acronym for me?
"There's Only One Way To Do It" which is pretty much the opposite of the perl slogan ruby inherited: "There's More Than One Way to Do It"
Keep in mind there are some weird behaviors when combining polymorphic has_many / belongs_to and STI(mainly that when storing the association_type value it uses the base class, instead of the subclass). And/or full on bugs in ActiveRecord regarding it(have a search through the GitHub issues for STI, often the bugs are closed for inactivity not actually fixed). These are not deal breaker issues, but it's considerably trickier than regular ActiveRecord assocs.
&gt; ...you should first think about the problem and write out the steps. After that, you turn those steps into code. After you understand how to solve it, it will become more natural to optimize it... I admit I could have worded the whole response better, and emphasized my "helpful" bit above. No harm or discouragement was meant. With practice at pseudocoding, maybe future questions will be more like "How can I loop through each character of a string in Ruby?". I stand by my "evaluation" as trying to help. I want them to succeed. But like I said, I could have worded it better.
Much love, here's some anti-love towards pyShit too. Can't stand python and their communities. Love Ruby. It's too bad languages get these strange general complexes as I've known (and know) about 150 python guys who have generally been assholes. Don't know if the language attracts them or it turns them into that, but it's a problem and needs to be said.
Hahahaha, no, don't change a thing. It's good to have real people here who say what they think and mean what they say. Just because you've got the cajones to say it makes you the better man. Cheers!
I'm curious, you said you met Matz *and* drank sake last year; did he drink sake with you? The reason I ask is because I thought Matz didn't drink. He's a member of the Church of Jesus Christ of Latter-day Saints (AKA "Mormons") and they... well, they have a reputation for avoiding alcohol.
Nope, I cannot say I drank *with* Matz, but alcohol helped me reduce my anxiety and speak with him for a few minutes. Didn’t mean to confuse anyone, rather just excited about the fact 🙂
Ah, ok, I see. No worries, thanks for clearing that up.
I didn’t know he is a “mormon”, thanks for a fun fact.
Yeah, I happen to be one too. That's the reason for my curiosity :) Another fun fact: Ruby's design was actually influenced by his religious beliefs. [Matz once said, with reference to Ruby:](https://www.artima.com/intv/ruby3.html) &gt; You want to enjoy life, don't you? If you get your job done quickly and your job is fun, that's good isn't it? That's the purpose of life, partly. Your life is better. And in the Book of Mormon (which is where we get our nickname), [it says:](https://www.lds.org/scriptures/bofm/2-ne/2.25?lang=eng) &gt; Adam fell that men might be; and men are, that they might have joy. So, in my opinion, Ruby's emphasis on programmer happiness is no accident.
I’m quite much of an unreligious person, but I think my list of religions that I like just got a new member 🤔 That’s some great info!
I'm glad to have piqued your interest so!
Why are you joking about this? This is a serious issue and I am shocked it's not generating any discussion at all.
Ah, I figured, I just couldn't make the words match up - I don't normally count prepositions when doing acronyms 😂
Thanks I appreciate the sentiment!
looks like it's a work in progress: [https://github.com/typesigs/typesig](https://github.com/typesigs/typesig)
Chill, dude.
very sad day.
Pretty much. It checks what args were yielded, across multiple calls to the block. def abc yield :a yield :b yield :c end expect{ |b| abc(&amp;b) }.to yield_successive_args(:a, :b, :c)
New features this release: &amp;#x200B; \* More ergonomic table initialization syntax: you can now specify columns directly as varargs rather than having to pass an array to the \`columns:\` option (the latter is now deprecated) \* New \`#pack\` method to autosize columns, which caps total table width at terminal width by default (replaces the now-deprecated \`#shrinkwrap!\`) \* Ability to set table-level defaults for column header and body cell alignments \* Accessor methods for \`source\` attribute, representing the underlying collection being tabulated, facilitating reuse of the same table to tabulate different collections \* Documentation improvements &amp;#x200B; For overall summary of Tabulo features, see [https://github.com/matt-harvey/tabulo#features](https://github.com/matt-harvey/tabulo#features). &amp;#x200B; For motivation / comparison with other gems, see [https://github.com/matt-harvey/tabulo#motivation](https://github.com/matt-harvey/tabulo#motivation).
I think _generally_ single-table-inheritance is preferable to a polymorphic association (they can both be used in similar ways, but are different table structures -- but both are best avoided except when they really are useful. Polymorphic assoications can make eager loading to avoid n+1 queries challenging or impossible, whereas Single Table Inheritance's whole advantage is basically in making efficient SQL possible. But to start out investigating if you need either one --how would you model this _without_ using either one? (I'm not sure, and don't totally understand your domain or diagram). What sorts of queries are you going to need to make, and how would you make them under the various design choices? (The goal being making sure you can fetch everything you need for most/all use cases with at most one SQL statement per table).
They're not evil, but they are often overused, and they have some nasty trade-offs. You probably want to use them as a last resort, not as the first thing you try. Alternatives to MTI in your case are: * Use a single table. Unnecessary columns are just null. * Separate tables per card type, with a compound key in the deck. * An entity-component-system (ECS) type of architecture. Cards are just an id, and they can have a monster component and/or an item component. Each component is a separate table. I would probably try the ECS option first.
You don't need a Card object, you don't need polymorphism, and you don't need STI. Just create a Card concern and include it the MonsterCard and ItemCard. class Deck &lt; ApplicationRecord has_many :monster_cards has_many :item_cards def cards monster_cards + items_cards end end module Card extend ActiveSupport::Concern included do belongs_to :deck end # ... generic Card methods end class MonsterCard &lt; ApplicationRecord include Card # ...Monster specific methods... end class ItemCard &lt; ApplicationRecord include Card # ...Item specific methods... end That gitlab document is inconsistent, poorly argued, inaccurate in places, depends on a very rigid view of ORM mapping, and introduces a whole bunch of other issues. Polymorphic associations are super helpful in a variety of circumstances, but they're not needed at all in this case. It's STI you should be super wary of.
Hey man, I downloaded your book and tried the query object pattern. You've mentioned on **One class - multiple methods** section that we can chain methods with this eg `query =` [`UsersQuery.new`](https://UsersQuery.new) `query.deleted.pending` &amp;#x200B; `query.deleted` returns a User object instead of UsersQuery object so there is no way that `query.deleted.pending` will execute . Help me clear this confusion
Hello! Thank you for the comment, you are right. I will update this fragment and include a complete and working code example.
Hey man, thanks for the effort. If I wrap the return of the deleted method with [UsersQuery.new](https://UsersQuery.new)() then i can chain methods.
The madness does not stop. There is a reason why I still think ruby 1.8.x was the best ruby ever. Can't we just ban this type madness altogether?
Agreed, but I'm more concerned by the upvotes the snark got. Appalling.
There is unfortunately quite a large hype train for types :( https://twitter.com/darkdimius What is even more annoying is that this hype train comes from companies. It's quite amusing to read, though, the people who express their unconditional love and support for tainting ruby with types. :)
I like your fresh approach to data initialization. Any reason you decided against contributing to tty-table? I would welcome new ideas with open arms. Especially since I wanted to provide a streaming API. But like with any OSS project, time is a scarce commodity.
Hi, and thanks for the feedback! \&gt; Any reason you decided against contributing to tty-table? Fair question. To be honest, Tabulo started out initially as a toy project, without much thought of whether it would be useful to others. As I added new features over time, and having received some positive feedback, I felt motivated to continue developing it "properly". When I compared Tabulo with other libraries, it seemed like its overall approach and architecture was distinctive enough that it was worthwhile continuing to develop it as a separate project. I have a lot of admiration for the `tty-` suite of libraries. It's a really impressive body of work. I'll seriously consider contributing in future. Thanks again!
Amazing! I'm new at Ruby on Rails, I still learn about the tricks that I can do with it. This certainly could solve the problem of the model of my post, but actually my model is a little bit more complex than I posted so if I use this solution maybe I will face some limitations But thank you very much for share !
Nice! I didn't knew about STI Actually I realize that at least artifact gamepedia, seems uses it on their database as we can see on this page [https://artifact.gamepedia.com/Heroes](https://artifact.gamepedia.com/Heroes) SELECT CONCAT(name) AS `name`,CONCAT(image) AS `image` FROM `cargo__card_data` WHERE type LIKE "Hero%" AND type NOT LIKE "%%Ability"
Probably you are right I've just find out that Artifact gamepedia seems use STI to store their data (btw I didn't know what was STI before this post :D ) [https://artifact.gamepedia.com/Heroes](https://artifact.gamepedia.com/Heroes) SELECT CONCAT(name) AS `name`,CONCAT(image) AS `image` FROM `cargo__card_data` WHERE type LIKE "Hero%" AND type NOT LIKE "%%Ability"
A lot of people are recommending STI maybe it is the right choise
Hey /u/electrostat thank you very much I learnt a lot with your post. I didn't know about STI and MTI It seems like STI is the right way to solve the problem
What the h***? I mean it's fun for first april as it competes with TempleOS as the primary platform for games, obviously - but other than that ... I don't even think it is that amusing as a joke. SDL is quite ok. What we are missing in ruby is a high-level abstraction API that is extremely simple. We have too much low-level stuff when we really should not need this. Rails showed how you could get things done on the www in their DSL (no matter if you like the DSL or not; I don't but that is besides the point).
Actually my application is quite simple It is just a deck database for a game that for now, has less then 500 cards (Artifact). I don't think the model or the type of cards will become so much complex and certainly will note have millions of registers, mainly because is just a project that I'm creating to learn Ruby on Rails. But when I started to scratch the model I thought about Polymorphic Association and I remember what my friend usually said about it, so as I'm doing this project to learn I was think what is the 'right' way to do it. &amp;#x200B; After all I also Polymorphic Association not seems a bad idea
The general advice I have, is start out with the simplest possible thing you don't know won't work. You may want to or have to refactor later, just part of the deal, especially if you don't have lots of experience to guide you.
\&gt; Edit: I should add that if you're doing this for fun, then don't worry too much about it. The most important thing is that you're learning and maintaining your motivation to work on the project. Exactly, is just a project to learn Ruby on Rails and software engineering But it was a good discussion, now I learn STI, MTI and that Polymorphic Association their applications =D
Thanks!
I'll be a contrarian here. It's probably worth pausing, stepping back, and considering just how much the design of your code is about to be influenced by how you model your database schema. There is an alternative: consider not using an ORM at all. You can leverage powerful database libraries like [sequel](https://github.com/jeremyevans/sequel), or even try a web framework like [Hanami](https://github.com/hanami/hanami) which, as I understanding, integrates database tooling without imposing an ORM. I should note that I haven't personally had a chance to use Hanami, so I'd double check that it meets your needs. However you proceed with ActiveRecord, there will be warts in your implementation. Objects sometimes just cannot map to tables without introducing design warts in the code; when features polymorphic associations and STI start looking attractive, you likely have found yourself in that scenario. Changing your database schema later on will be expensive and difficult, so I recommend slowing down and making doubly sure you're getting the next step right.
Ah, I see, thanks!
waho such a bad marketing and pricing model. cool to be blasting about the team credentials, but why 4-5 paragraphs? It’s just cringy. No GitHub link. No playable game. No 3d support. It seems all the work will be left to us. The licensing option is confusing. How much I am going to play if I want a team of 3 being to able to push games to all platforms including console? Most of the game engines - including Unity and Unreal - are free to play with and they seems to be highly profitable. Why not go the same route? Anyway sending &lt;3 to you guys. Definitely want you to succeed. Please rethink whoever is in charge of marketing and business strategy.
It's not clear to me if changes being committed recently to master will make it into a Rails 6, which is already in `rc` releases?
Maybe I'm whining because $$. But React Native, Nativescript, NSvue the like beat Ruby Motion and are free. Sure Ruby is a nice language but adding a barrier to even try is pretty low. We have Godot. http://godotengine.org
What am failing to understand? What about my example show a lack of understanding Ruby or its OOP philosophy?
Is this an evolution of Ruby Motion?
It's part of an evolution. RubyMotion is being rebranded. You can read more in the [news post](http://www.rubymotion.com/news/2019/04/19/plans-for-rubymotion.html) if you'd like.
Gotta say, the fact that I need to fork over $40 just to do Hello World makes me highly suspect. It seems like the entire business model is designed to extract as much money from starting developers as possible, and then to either pump up their GameJam site or their educational course site. I'm curious to see how well it works. Most experienced indie devs already have a platform they like to use, and beginner indie devs are not likely to want to fork over the money for an unknown experience.
what the fuck is wrong with you?
Are you executing that command line directly via Ruby? Redirection like that only works within a shell, so you'd need to do something like `/bin/bash -c "bundle exec ..."`
It depends on what and why you think you need this. I
Yes, it's a work in progress. You're invited to join in :-).
What's your take / opinion on enum types? See https://github.com/typesigs/enums
I have to agree. I'm all for any attempt to make Ruby more popular with game devs, but $40 and no example of a finished product is a bit off-putting. For $40, I could wait until RPG Maker VX Ace was on sale and have a Ruby-powered game engine with assets and tools already provided. Sure, it's way slower than DragonRuby, but if the intent is to market it to game jammers, something like VX Ace holds a lot more value. That said, I also agree that I hope this sees some success. Anything that furthers Ruby is alright by me, and I want to see this grow. But a price tag like this basically ruins adoption before it even begins.
Not sure why there’s so much complaining going on, but I think this is really cool. Sure, it’s not the Ruby on Rails of gaming, and yes, maybe these guys don’t have the luxury of giving away their time and efforts for free. But that shouldn’t detract from what this is trying to accomplishment: making Ruby a (perhaps even more) viable platform for writing games! I, for one, applaud these efforts and hope to have the opportunity to make use of this one day.
While I agree that they should have a free version (maybe make it unable to publish a game without paying, or add a large watermark at compilation?), Unreal and Unity charge a royalty fee. Unreal's is 5% after $3000 every quarter. So, say your game makes $4000, 200 copies sold at $20 each. You've already spent more than your DragonRuby license would have been.
I guess any performance improvement may help, if only to get people to stop thinking that ruby is slower than perl, python and php in the past ruby 1.8.x era.
$40 doesn’t allow you to push everywhere and your game is open sourced. It’s $500+ for each seat for similar licensing features as Unreal. So in this example, you are paying $1,500+ (whatever plus means) against $50 for Unity.
It doesn't allow you to push everywhere? I watched the video and it looks like it compiles to a .app/.exe/.bin... why can't I just take that and put it wherever I want? I'm not saying you're wrong, I clearly don't have the right understanding of how they're trying to make this work.
As a beginning/hobby indie dev, I am willing to fork over money to play with new stuff. I've used bits of and pieces of unity and pico-8 so far and this looks as good or better than those. 40 dollars is not much for something that might make it easier to make a game in my not ample spare time.
Comment completely irrelevant to the actual new Rails features being discussed.
If you shared your actual problem, I hope we could still find simple solutions based on composition.
This is very shady. They’ve just removed the options that were more than $40.
I think there’s whining because people want to see an initiative like this succeed, but attaching a price tag to it with no chance of trial or with few examples beyond a mobile game means it’s less likely to catch on outside of the Ruby community. Most of us would like it to *expand* the Ruby community, so that’s where the frustration stems from.
No, it's in bash.
Nope. This treats the entire string as if it's the name of a gem.
I've worked around it a stupid way but there really must be a better one. ```bash bash -c "bundle exec asciidoctor-pdf test.adoc -o test.pdf" 2&gt;&amp;1 log.txt ```
If only Ruby for Godot. One can dream.
Ruby does work on Windows ... eventually. Making it _easy to install_ on Windows would be the bomb. Stories abound of programming bootcamps where an entire day was lost for some students struggling to get Ruby going on their family laptop.
To add on, it's not fully battle tested and lacking support in some areas. Check out the post's in itch. HTML5 (coming soon). unconventional $dragon.require (still forgivable) Bugs to iron out. Not enough docs, examples It's a good attempt but slapping a price tag to an unfinished product to create Hello World. I'd think twice before trying.
All other comments aside, my main issue is the source code is fully readable in any game you distribute. This would be a deal breaker for my needs / a commercial game.
I've never heard of the \`records\` gem. That's exactly what I've been looking for recently! Thanks for sharing.
Man this announcement was kinda sad. I mean some was cool, but I was really hurt when it seemed that this doesn't play with rubymotion itself yet. They're going after the 2d market entirely and forgetting about the need for 3d or *reality. This kinda sounds crazy but joining forces with Unreal (or hell, even Unity) or some other big`ish player would have been the killer move for these guys because ruby would be a killer language for these big players to have available. Meh, oh well, if anything it made me like rubymotion itself less now and I've lost a lot of hope in the platform going forward at least in the NEAR term. :`(
This is pretty right, except price isn't the problem. The problem is in the vision. This sideways move is really strange and probably should have been held back until they had some more substantial decoupling or bigger things ready. This kind of microrelease of a concept I think does more to hurt what their goal is and probably will cause some to really question commitment to the platform. YES, we have hopes for the bigger and more awesome stuff they're hoping to achieve, but..... when? They would have been better plugging along until some more stuff came together (or they had some chunks to open source and to ask the community to come on in for help).
Projecting much, friend?
I'd have plunked down $40 in a hot flash if this wasn't a new thing and instead worked WITH rubymotion instead of being something new. I don't care about the name, sure, change it, but I want to use this WITH what I already use and love. :&lt;
First thoughts: Glad to see some more development in the Rubymotion world and being able to make cross platform games looks great. Shame about the initial price though.
What can we do to help?
Does anyone know the story behind this move?
Draper's valuable primarily because of the work it does to expose the request context (and consequently, view helpers) to the decorator. It enables us to easily build presenters for a model, allowing us to encapsulate model-specific view logic behind a nice interface while keeping the model itself pure and without polluting a global module with a bunch of one-off helpers. If you just need to decorate an object, sure, you can delegate easily enough, but don't shortsell what Draper does for you.
Maybe not The story, but you can look here https://bugs.ruby-lang.org/issues/14632 (and in previous tickets by "Related" links) for some context.
There have been suggestions before to move to git and the core team often said that the net benefit for using git is too little, as opposed to keeping the current workflow. I guess that changed when more and more people were using git + github. Git is like the 1000 pounds gorilla at this point. I am afraid this means that the other version control systems will die out in the long run ...
Wrong thread it seems.
Did you mean to post this somewhere else? Because this here is about git, not draper or whatever ...
Personally I'm looking forward to the centralized ones dying out; I do not in any way miss svn. Those who want to can easily enough emulate the svn workflow easily enough with git with some aliases, but the ability to never depend on access to a remote repo unless/until you need to push/merge your changes is so much better. There will be others. And eventually one will beat out git. But the centralized ones are likely to continue fading away.
What actually is the syntax? Are you talking about the sig thing, or is there something in the video?
I was pretty sceptic, tough it died somewhere along the way. Seeing those slides gave me hope again and I understand the reasons behind the closed-development. I have really high hopes for this project.
It's always the case that if you can just arrange your objects according to a particular design pattern, rather than importing a framework, do so. The result is simpler programs. Nitpick: Decorators should be named after the responsibility they take care of, not the class of the object they decorate. That's a recipe for a burgeoning parallel hierarchy. Yes, I know Draper does it. That's another reason I don't use Draper.
I had to check the date honestly. Having used both for many years, I don’t get why you’d stick with SVN when git is so much better at things like branch management and merge resolution. Unless SVN has come on a lot since I last used it? I’d be very interested to know the reasoning behind this. (And yes I know git is a terribly documented UI shitshow, but that’s it’s only drawback for me)
I think you meant to post here: https://www.reddit.com/r/ruby/comments/bgdffb/your_own_decorator_pattern_almost_3_times_faster/
Re. Nitpick: Yes!! I have never understood the point of simply having a parallel hierarchy of decorator classes, one for each model class. Having worked with projects where this was the consistent pattern&amp;mdash;where every class Thing must have a corresponding ThingDecorator "because separation of concerns"&amp;mdash;the maintenance hassle, and additional complexity, seemed to me to far outweigh whatever benefit was supposedly derived from this "separation of concerns"&amp;mdash;not to mention any performance cost.
Finally the Japanese got the translation on how to use git.
:(
I didn’t think anyone was using subversion these days. This actually surprises me.
Heh, not sure how I got the tabs mixed up...
Draper's valuable primarily because of the work it does to expose the request context (and consequently, view helpers) to the decorator. It enables us to easily build presenters for a model, allowing us to encapsulate model-specific view logic behind a nice interface while keeping the model itself pure and without polluting a global module with a bunch of one-off helpers. I think marketing it as a "decorator" library rather than a "presenter" or "view model" library is a bit of a misstep, but what it does is valuable and nontrivial. If you just need to decorate an object, sure, you can wire your own up with delegate easily enough, but don't shortsell what Draper does for you.
Now aside from the general awfulness of types and the hilarious attempt to name them "awesome" - there are a few problems with this dumpster-listing. For example: "Contracts for Ruby (contracts.ruby) :octocat:, gem - a contract is one line of code that you write above a method definition; it validates the arguments to the method, and validates the return value of the method" Actually, contracts existed since the ancient days in OOP (aspect-oriented programming to give one example). Contracts are also not necessarily limited to types - you could have (re-usable) interface declarations for methods for instance. Matz spoke about something related to adding interfaces but the idea was not finished yet. Then we have the clown-company called stripes. They still have not open sourced their code, so why is this shit advertised for? Simply call it what it is - a promo idea by a selfish company that is working completely outside of the community (look at the licences used in the rubygems.org ecosystem and tell me how many are closed source there - answer: almost 0). Then there is more crap such as "Bool". Yes, we know what a "Bool" entails too. Ruby has no concept of a Bool: If you write puts Bool, you will get: uninitialized constant Bool (NameError) Enums is also something completely different to types. I wonder about this geraldbauer account. Has that account ever actually WRITTEN anything here on reddit or is it just a link-bot? Structs are mentioned but structs have nothing to do with types. Then we can look at: https://github.com/s6ruby/safestruct And you can instantly tell that noobs wrote this. String '' or String.zero What should the method ".zero" be for a string such as "abc"? That's the same crap that actiev* has via .blank (or .blank? whatever) Then the link writes this: "Crystal" "Ruby with 100 % static types compiled to binaries via LLVM" But Crystal is NOT ruby. I am getting very annoyed at the type people. At the least stay accurate in what you write. When you write "Crystal Ruby with 100 %" anything then you are already WRONG. Yes, the two languages are very close but they are not the same, neither syntax-wise nor elsewhere. IT IS ANOTHER LANGUAGE. Then the reference to python - python is not typed either. They suffer from similar clowns who demand that types are slapped onto python but thankfully python devs aren't stupid enough to retrofit the language after ~25 years just to please closed source companies with a private interest.
A friend's company just switched from *CVS* to Git... last year. 😱
Rails' view helpers are fine 95% of the time. The other 5% you should just rollout your own classes. Rails models get bloated enough. Do we really need to add _presentation layer_ methods to them‽ This is just wrong –especially if your application _is_ BIG. # controller def show @article = Article.find(params[:id]) end # ArticleHelper def publication_status(article) if article.published? "Published at #{article.published_at.strftime('%A, %B %e')}" else "Unpublished" end end # view &lt;%= publication_status(@article) %&gt; There is really 0.0 wrong with this. **Nothing!** With Draper, we get: # controller def show @article = Article.find(params[:id]).decorate # thanks for the pollution end # "decorator" class ArticleDecorator &lt; Draper::Decorator delegate_all def publication_status if published? "Published at #{published_at}" else "Unpublished" end end def published_at object.published_at.strftime("%A, %B %e") end end # view &lt;%= @article.publication_status %&gt; This seems like a lot of needless abstractions, class pollution (nebulous methods spread across models), layer violations, and what really seems to be completely unnecessary code. Ah, but [Draper tells you](https://github.com/drapergem/draper/tree/d44c86f1e560afc0cf0dad4ae09bfaa3f10a1759#why-use-a-decorator): &gt; ... it makes you a little uncomfortable. publication_status lives in a nebulous namespace spread across all controllers and view. Down the road, you might want to display the publication status of a Book. And, of course, your design calls for a slightly different formatting to the date for a Book ("uncomfortable", heh). Helper pollution, this is true, but Rails has a built-in solution. I think in Rails 1 or 2 `ActionController` used to do `helper :all`. This was removed (in 3, maybe) and all is now the default. The built-in –easy– solution? [`clear_helpers`](https://api.rubyonrails.org/classes/AbstractController/Helpers/ClassMethods.html#method-i-clear_helpers): &gt; Clears up all existing helpers in this class, only keeping the helper with the same name as this class. Now you can have one `publication_status` scoped to articles and one scoped to books. Problem solved. --- While I don't code under this paradigm (I prefer the procedural view approach 95% of the time), your view _is_ your "view model": # some view &lt;%= self.class %&gt; #&lt;Class:0x00007fe1e3af03f8&gt; &lt;%= self.is_a?(ArticleHelper) %&gt; # true So you can do this: # controller clear_helpers def show @article = Article.find(params[:id]) end # ArticleHelper def publication_status if @article.published? "Published at #{@article.published_at.strftime('%A, %B %e')}" else "Unpublished" end end # view &lt;%= publication_status %&gt; # Or if you really want to FEEEEEL the "view model": &lt;%= self.publication_status %&gt; I don't code like this because **1**) procedural approach is fine and **2**) having an instance variable as your interface is bad. One can argue that, given the untraditional approach of how "view models" are constructed (anonymous `Class.new`), that it's okay to depend on the instance variables. But there's also the what I'll call RSpec `let` camp that loves it when the interpreter prevents their typos. Fine. So maybe do: # controller attr_accessor :article helper_method :article protected :article # controller def show self.article = Article.find(params[:id]) end # ArticleHelper def publication_status # use article and not @article end # view &lt;%= self.publication_status %&gt; 💥`bundle remove draper` As for the 5% time I use extra classes in my views, here's an example (the names have been changed to protect the guilty, sorry). Each product has data groupings that differ across formats and labels: class SomeTypeOfLabel def initialize(product) @product = product @label_data = product.data_to_be_displayed # &lt;snip&gt; Boring code to find the format standard # ... @cfg = LabelConfig.for_standard(standard) end def format @product.attribute_to_get_format end def grouping_a @grouping_a ||= @label_data.map do |spec| spec.data.select { |d| @cfg[d.nutrient_id].grouping_a? }.sort_by! { |d| @cfg[d.nutrient_id].display_position } end end def grouping_b @grouping_b ||= @label_data.map do |spec| spec.data.select { |d| @cfg[d.nutrient_id] &amp;&amp; !@cfg[d.nutrient_id].grouping_b? }.sort_by! { |d| @cfg[d.nutrient_id].display_position } end end end # controller def show @product = Product.find(params[:id]) @label = create_label(@product.info_to_determine_standard) end # view &lt;%= @product.name %&gt; &lt;% @label.grouping_a.each do |group| %&gt; # format group a accordingly &lt;% end %&gt;
OpenBSD still uses CVS. Don't underestimate the inertia behind a complex build and development setup with dozens (or _tens of thousands_ in the case of Google, MS, etc) of developers. It's a very deep dependency and painful to change.
Decorators are often the trash collectors when things should be neither in the model or a helper. The same goes for helpers, but often these type of objects are often abused for something which should be a code smell to a developer. SimpleDelegators are useful, but Draper is a travesty and don't belong in any project.
&gt; Don't underestimate the inertia behind a complex build and development setup with dozens (or tens of thousands in the case of Google, MS, etc) of developers. Microsoft switched the entire Windows codebase from TFS to Git a year or two ago.
Yes, Paying 40 $ without any reviews, demo or prototype is too much.
https://freeolabini.org/en/
&gt; I wonder about this geraldbauer account. Has that account ever actually WRITTEN anything here on reddit or is it just a link-bot? Not sure what I can add to your rant. How about a link :-) ? &gt; If you write puts Bool, you will get: &gt; uninitialized constant Bool (NameError) If you install / use the safebool library / gem, see https://github.com/typesigs/safebool If you write puts Bool, you will get: Bool Cheers. Prost.
Haha, such opinion was really very popular when was created Mercurial. And was agreed with this, but today, after the shit called "git", I think centralized vcs are fine. You can use centralized vcs as distributed
Especially because much of the value of the pattern is that you can implement multiple decorators for a single class.
You really can't for anything but the very simplest type of scenarios, while the reverse is trivial.
Lucky bastards, they skipped svn.
The company I'm at now switched from CVS straight to Git, but that was right before I joined, in 2013. I had been at a company using Svn for several years, and I hated it. I used Hg for all my personal projects, so I was ready to work somewhere that used a DVCS.
I don't follow. can you give a concrete example of what you mean by this?
* https://www.graphiti.dev/ * https://github.com/graphiti-api/graphiti
Very interesting post. It seems to solve a few issues that GraphQL struggles with, like caching and intelligent sort/filter. Curious to see if the project gains steam as a hybrid between REST and GraphQL. One point I missed on initial read - it's not an alternative to `GraphQL for Rails`... it's an alternative to `GraphQL` for `Rails`...
thx for the edit note. changed it.
Actually, the biggest reason against the type-madness by the type clown is the extra verbosity in syntax. include Dry.Types(:strict, :nominal, :coercible) Types::Kernel::String hash_schema = Types::Hash.schema(email: Types::String, name?: Types::String, age?: Types::Integer) Admittedly this madness is quite entertaining. I can't wait for people to add the syntactic noise to their ruby code and then complain bitterly about HOW VERBOSE RUBY has become.
&gt; the centralized ones dying out well the issue is that for most people git == github. And it's basically centralized. I mean, when for example github takes down whole chain of forks because of issues with the original without contacting the forks... I'm not sure it's that much better then centrilized solutions given how most people use it.
&gt; OpenBSD still uses CVS and tbh I'm glad for that; thanks to them using cvs, it's fairly trivial to track my patched version of one of their programs compared to if they would use git instead.
What argument are you responding to? Dry-rb and its predecessors have been around for years and have seen plenty of use before the idea of typed Ruby arose. If you dislike the \`Types::\` prefix I bet you could just include the module, I think I've done that a couple years back when I was using Virtus. Adding typing to your code is syntactic signal, not noise.
It's worth noting, you'd use this kind of tooling at the edges to enforce data contracts (e.g. validating an AJAX post), not literally everywhere.
There is always some people who doesn't get it and will try to use it everywhere, let's just hope it doesn't get too popular :P
Every tool can and will be misused, whether it's a hammer or a Ruby library.
Rack. One of the [most popular gems](https://rubygems.org/stats) of all time. Rack applications &amp; middleware embody the [Chain of Responsibility pattern](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) without ever mentioning it explicitly or depending on a gem to hang off.
Thank you for the work on this!
Is there something specific you want to know? We've wanted to move to git for quite a while, just there were so many build scripts etc that depended on svn. Thanks to the hard work of hsbt, kokubun, naruse, and mame all that stuff has been ported to git! :D
Love it, may I suggest you add decorate_collection to the gem readme? I do like the gem, but for something as simple as this, implementing MyDecorator or "SimpleDecorator" in my own codebase would improve visibility.
Thanks so much for your works. We've replaced Rails with \`roda\` + \`dry-rb\` + \`rom-rb\` stack. Not only this stack is way faster, we have also a very nicer, cleaner and well tested code base overall.
&gt; You can now use key names ending with ? to denote an optional key. Here’s how it looks in practice in a struct definition: How do you handle hashes with keys containing `?` now? This looks like an oversight, but I'm sure there's a workaround for the `{key?: 2}` case? &gt; Previously it was only possible to append a constructor function. This was too limiting because it wasn’t easy to extend and re-use existing constructors. Now it’s possible to either append or prepend a new constructor: Nice, as you said – this makes composition easier. For anyone wanting to extend their Haskell foo: These functions are called `rmap` (=`fmap`) and `lmap` and are defined in [Data.Profunctor](http://hackage.haskell.org/package/profunctors-5.3/docs/Data-Profunctor.html#g:1).
It's rather interesting. By the way, you have a typo there: you wrote "checkout" instead of "check out" (these words have a different meaning, although they sound similar).
Do you have a plan for dry-types with the upcoming optional type system in Ruby 3?
I won't lie to you - I had no idea that GitHub *wasn't* the canonical source repository, and I got sucked into the "GitHub…just a mirror" bullet point rather than the meat of the announcement 😳 Not a trivial change in any case. Great work all!
I'm happy to hear the gem reached 1.0. Congrats!
At [no small cost](https://vfsforgit.org/).
I don't follow. Can you give a concrete example of what you mean by, "Decorators should be named after the responsibility they take care of"?
I use [https://github.com/trailblazer/cells](cells) all the time Now I use it in most page content templates &amp; meta tags (plus some helper calls for modifying layout)
+1 for such a well documented, comprehensive answer. I would ordinarily give you a +1 for the use of an interobang, but, apparently +2 is not permitted.
I'd be interesting in reading more about this. i'm interested in how the application logic is organized, specifically. I've thought about going this route with a couple of small services / internal applications at work but haven't had the time to really delve into it.
A cache that wraps around another object to cache the results of method calls -&gt; Memo (or MemoDecorator). I'll use a Memo wrapper around things like API client objects when doing lots of lookup. `Memo.new(object, :methods...)`. Do that once and then you can pass it around inside the application and the other parts are none the wise. An object that wraps any IO-like object for compression -&gt; ZlibCompression (or CompressionDecorator). An object that wraps any model posessing firstname/lastname-like attributes to add a `#name` method returning a `Name` whole-value object instead -&gt; NameDecorator. I used this recently as a prop during an extending refactoring with a bunch of polymorphic associations.
Bro. I just looked at your post history. I can't tell if you're a troll or you just think everyone in the world is wrong except for you.
/r/rubyonrails
Looks really promising, as others have said. We'll keep an eye on it for when it's no longer ActiveRecord-only (as far as local SQLish persistence layers go). I'd love to see a Sequel or ROM adapter; even if they implement support for a different SQLish back end (what?), comparing that to the existing AR adapter would show how such support could be added. Until then, it's inside the Rails walled garden.
Heh. You gave me an idea: https://github.com/sshaw/interrobang
We went that route (Roda + dry-rb + Sequel in our case) a couple of years ago (late 2016/early 2017), and have since moved on to Hanami as our app framework (replacing Roda). It's *amazing* what you can do with tools that *help* you build clean architecture in your apps! We were big fans of interactors (first [ActiveInteraction](https://github.com/AaronLasseigne/active_interaction), then [Hanami Interactors](https://guides.hanamirb.org/architecture/interactors/) until *very* recently; we're now experimenting with dry-monads' [`do` notation](https://dry-rb.org/gems/dry-monads/1.0/do-notation/). Interactors (of whatever flavour) allow you to extract your domain logic essentially completely from your controllers, leaving thin controllers that simply perform structure/format validation of parameters to HTTP endpoints, set flash messages, handle redirects, and such tasks that can only sensibly be done by a controller. Reasoning about any given piece of code becomes much easier and, as a direct result, testing it becomes much easier. What dry-monads' `do` notation gives us that interactors don't is a more flexible, fine-grained way of building logic as a sequence of steps; reusing steps between modules; yet making it explicitly obvious which steps are shared and from where. This has allowed us to change how we think about the structure of our domain logic: whereas an interactor encapsulated an identifiable domain-logic activity or supporting task, the new monadic modules accessed from controllers are Jacobson *use cases*.
That's true, but it's also a lot simpler to fix for Github given that git by its very nature ensures that users have copies of the history too, not just current files, so even when people are dumb enough not to take precautions, chances of full repos surviving are much higher.
If you want to give it a try, I have developed a framework to organize business logic and it's currently running on production on several projects: [https://github.com/pabloh/pathway/](https://github.com/pabloh/pathway/).
Ouch. Sorry
This is really very interesting. Thank you so much for sharing! I'm going to have to sleep on this blog post and let it simmer for a little bit. I'm going to play with this on my 10% this Friday!
First time I've EVER seen an account with negative overall karma lol
I'd call it an intentional oversight. I'm interested in the use case where people pass around schemas with question-marked keys :) It won't be hard to support this case anyway.
Following Ruby convention + serializing an object containing boolean flags naturally leads to a Hash containing `?` keys. JSON also allows for `?` in keys. I don't know whether it was intentional or not. I'd like to know whether there's a workaround, though. Other libraries solve this required/optional problem by using higher ordered schemas/decoders/coercers instead of giving a subset of strings a different behavior: `required(:active?, Boolean)`, `optional(:active?, Boolean)`.
**Redirects to MORIOH.COM**
It's merely syntax sugar, nothing in dry-types internals depends on it. As I said, it's possible to support this case once someone comes up with a clear need for this. Keys can be constructed manually: ```ruby schema = Types::Hash.schema(\[Dry::Types::Schema::Key.new(Types::Integer, :foo?)\]) schema.(foo?: 1) # =&gt; {:foo?=&gt;1} ```
Thank you for sharing this!
I’ve written a book about how to use some of the dry-rb libraries with Rails that you might be interested in reading. It’s called Exploding Rails: leanpub.com/explodingrails
What's roda? An even lighter Sinatra?
This unfortunately manages to miss what I suspect is the major use case of Draper: to have presentational decorators that include Rails' view helpers. &amp;#x200B; Fortunately Rails made a change a few years ago that made it very easy to access the template context object. So you can create a custom decorator with `SimpleDelegator` as in the original blog post. Then extend it by supplying the `view_context` when the decorator is initialised in the controller or view. I generally wrap this as a controller method like so: # app/controllers/application_controller.rb def present(record_or_array, klass) if record_or_array.respond_to?(:map) record_or_array.map {|item| klass.new(item, view_context) else klass.new(record_or_array, view_context) end end helper_method :present &amp;#x200B; Call with: `present(authors, AuthorDecorator)` &amp;#x200B; It could be done with more magic, a la Draper, but I'm happy to specify things concretely. &amp;#x200B; You can see a [gist of my full simple presenter pattern](https://gist.github.com/Odaeus/92a9f78df479ffa9bd09).
Rom-rb uses the Sequel gem in the background out of interest.
Unchanged from its original publication [in August 2011](https://adrianmejia.com/blog/2011/08/11/ruby-on-rails-architectural-design/); i.e., back when Rails was new and shiny and its implementation of MVC was seen as solving old problems without causing new ones. A quaint bit of archaeology.
Thank you for the appreciation! Let me know how your experiments go!
Thanks, fixed it.
I thought /r/rails was the main one.
You could reimplement the Active Storage's representations controller, e.g: # config/routes.rb Rails.application.routes.draw do # ... resources :users do member { get :avatar } end # ... end # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def avatar redirect_to @user.avatar.variant(...).processed.service_url end end
Pretty cool, but I assume this does not work with headless browsers like `cuprite` or `chromedriver`?
It's inspired by the simplicity of Sinatra, but the routing approach is different, inspired by [Cuba](https://github.com/soveran/cuba). I try to explain the difference in my [Introduction to Roda](https://twin.github.io/introduction-to-roda/).
Congrats on your first open source project! I envy you. You went all the way with it, blog post and all. Be proud, you deserve it.
I also want to know this
Thank you! Would I just call &lt;%= avatar %&gt; from views and it will create a static html for the image no matter what the file is?
No, not really. I don't think a type system in Ruby itself will make `dry-types` obsolete. This library provides way more than just type-checking after all.
You would have to generate your own URL to the image (because it’s your own controller action), you wouldn’t use Active Storage URLs anymore. I’m not sure what you mean by “static HTML”, but the URL would stay the same in my example, even if the avatar changed.
I would add some simpler toplevel APIs and change other parts. For example: Linux and macOS users can optionally provide a display or input device number as input: ':99'. Default is :0 on Linux and 1 on macOS. I don't think the user should have to remember any of this. A simpler name should suffice rather than magic numbers like 0 and 1 to remember. Some method perhaps. Also: ScreenRecorder::Desktop.new(output: 'recording.mkv') If the main toplevel name is ScreenRecorder, I would add something like: ScreenRecorder.record ScreenRecorder.start ScreenRecorder.run (To otherwise combine this: @recorder = ScreenRecorder::Desktop.new(output: 'recording.mkv') @recorder.start; if you need to provide a name, you could always do so via block syntax such as: ScreenRecorder.record { filename: 'foobar.avi' } (or may have to be a hash in this case with another syntax aka the extra {}): ScreenRecorder.record {{ filename: 'foobar.avi' }} (But please no method with trailing !, I absolute hate these ... optionparser has .parse! and people often do: end.parse!(ARGV) I hate that for many reasons. In general the easier you make it the better for people to use it as-is. Otherwise good effort. PSS: I got an error FFMPEG::Error ([x11grab @ 0xc4bb80] Cannot open display :0, error 1.) :0: Input/output error I did not test it much though. echo $DISPLAY shows :7 ... perhaps you could check for this via ENV[] ? But no real idea how it works within that ffmpeg wrapper.
🙏 Sorry to ask, but can you explain how I will generate my own URL. I can’t yet out this together in my head fully.
Sure, I was actually hoping that by using dry-types maybe under the hood you'd also define the optional types, that way this would be usable with whatever tooling gets developed that uses the canonical ruby type system
I'd recommend The Well-Grounded Rubyist by David Black and Joesph Leo, though it covers Ruby, rather than Rails.
I'd start here: https://guides.rubyonrails.org/ If staring at the screen is not your thing just print to PDF.
Like you would for any other custom controller action, possibly with `avatar_user_url` or `user_avatar_url`, to which you pass the user record. I haven’t used Rails for a long time so I don’t remember exactly. Look at the RepresentationsController in the ActiveStorage source code, maybe it will help in understanding.
Very nice. 👍 Quick suggestions: * There are other exceptions than can be raised [here](https://github.com/kapoorlakshya/screen-recorder/blob/e5c22b9704324a34181d87eda76c9bf37487026c/lib/screen-recorder/common.rb#L70). I think `IOError` is one * For elapsed time you should probably use [monotonic time](https://ruby-doc.org/core-2.6.3/Process.html#method-c-clock_gettime) * If you can get by without it, great as it has a C dependency but you should checkout [childprocess](https://rubygems.org/gems/childprocess). * For turing Ruby hash arguments into command line arguments you should checkout [output](https://github.com/sshaw/optout) (author here 😬)
Controller to View to Cell to Cell's view to Helper. This leads to carpal tunnel.
&gt; ... to have presentational decorators that include Rails' view helpers. And why would someone need to do this?
If I have a price to display with a currency, I'd rather define it once in a decorator, using Rails' currency formatter, to provide a convenient and consistent output across views without having to remember to use the formatter in every template, supply the same options multiple times, or pollute the global namespace with a method.
This is interesting. I was just thinking about something like this for dealing with the "do I accept an account or account_id?" dilemma
&gt; ... pollute the global namespace with a method. [This is a myth](https://www.reddit.com/r/ruby/comments/bgdffb/your_own_decorator_pattern_almost_3_times_faster/elkzxko/).
Not a rebuttal I'm going to take seriously when you link to your 100% opinion-based post and call the standard behaviour of Rails mythical 😆
Of course but was also hoping for design patterns, how to think in Ruby/Rails, and lessons that people learned from using Rails
How does this compare to [openstruct](https://ruby-doc.org/stdlib-2.6.2/libdoc/ostruct/rdoc/OpenStruct.html) from stdlib?
good that you ask, I actually made a comparaison table: [https://localhostdotdev.com/simple\_hash](https://localhostdotdev.com/simple_hash/) (doesn't work well on mobile safari, it's also in a gist: [https://gist.github.com/localhostdotdev/e6b5470b4e1a63394f8f30bb35b0d8ed#file-3-results-table-md](https://gist.github.com/localhostdotdev/e6b5470b4e1a63394f8f30bb35b0d8ed#file-3-results-table-md))
It supports recording through `xvfb` or `xvfb-run` (see [wiki post](https://github.com/kapoorlakshya/screen-recorder/wiki/xvfb-or-headless-Capture)), but I haven't had a chance to play with headless Chrome or learn about it enough to implement support for it. Quick Google search didn't yield any examples of recording headless Chrome with FFmpeg, so I'll have to do some research on this.
Thank you for the kind words! :)
https://www.railstutorial.org/ . It's very complete including Git, TDD and even deployement with Heroku.
Thanks for all the links! I avoided as many dependencies as possible to have full control of the code (and bugs). However, it might be nice to use `output`.
Thanks for the suggestions! I'll respond again more thoroughly in the evening when I have some free time.
&gt; ... your 100% opinion-based post Actually there are a lot of facts in that post. Nevertheless I'll do you a favor this one time and save you from reading it –or the manual: &gt; The built-in –easy– solution? clear_helpers: &gt; Clears up all existing helpers in this class, only keeping the helper with the same name as this class. &gt; Now you can have one publication_status scoped to articles and one scoped to books. Problem solved.
&gt; ... call the standard behaviour of Rails mythical 😆 The myth is that you need Draper to solve the "pollute the global namespace with a method." This can be solved using "the standard behaviour of Rails".
Yes, good to not force people to install a shitload of dependencies. I wish more gem authors considered this. 👍
I might be stupid, but I don't understand the point.. why not just do user = User.find(1)
this isn't the best example, a better example would be network requests, you want to have the objects ready but not actually make the network requests until you need it, e.g.: require 'open-uri' require 'nokogiri' require 'date' user = Simple::Lazy('shayhtfc') { |name| Nokogiri::HTML(open("https://www.reddit.com/user/#{name}").read }) user.value # =&gt; shayhtfc karma = user.css('#profile--id-card--highlight-tooltip--karma').text.to_i cakeday = Date.parse(user.css('#profile--id-card--highlight-tooltip--cakeday").text) then imagine you have a list of 1000 users, you might want to filter by name and then get the karma/cakeday of only those. not sure if others will find it useful, it was just useful for me as I had objects who had attributes that would need to be lazily loaded (e.g. sub-ressources).
I like it and I'm already using it on a couple of projects. I'd state more clearly/loudly that it freezes the va;ues and you can't change the hash after initialization. It is basically a value object.
Very nice work! My team is excited about Truffle and we're excited to see greater adoption of it. This will definitely help increase adoption.
yes, not sure how to avoid that, I removed the global freeze but sub-values (e.g. hashes converted to Simple::Hash) are still frozen
I hope the MRI team sees this work and tries to catch up. Having a fast startup is important for CLI applications. If your application only executes for 50ms but the interpreter needs 50ms to start, that's a significant overhead.
I don't think it will. Why not? Because it requires people to use java. JRuby has the same problem. Now you can think that java is great because it is widely used, yes - but ... in my linux stack, I honestly do not need java. I have C, C++ and ... ruby. Why should I add java to the stack? There are no compelling reasons for wanting to do so (I actually do have the java SDK here, mostly for testing, but I just do not really need java). Ruby actually "manages" the system aka I use it to compile literally everything (aka these C and C++ programs). Truthfully I am reluctant to add any other language too, so there is no Go stack, no Rust stack etc... (although, I have to admit too that I actually have both running as well; Rust is needed for e. g. librsvg unfortunately these days, so without rust I could not get librsvg + stack running depending on it; nice addiction system in place but hopefully the rust virus can be stopped before it is too late). I also have slight suspicions of that article. Why would it be so much faster than JRuby? That seems fishy. Guess we'd have to let headius make a comment about that eventually. Personally I think there are lots of other areas where ruby could be improved, e. g. a much richer and more extensive ecosystem. Or ideas to make ruby more effective in terms of productivity.
The third edition of [The Well-Grounded Rubyist](https://www.manning.com/books/the-well-grounded-rubyist-third-edition) would be a good place to start.
thx for the reply. I'm reading now, about modules(include, pretend, extend)
Nice
Extremely exciting and good to see this moving in the right direction. Very well written and detailed article.
Which bundle do you suggest?
[Well, there are actually *two* versions of TruffleRuby.](https://github.com/oracle/truffleruby#truffleruby-configurations) There's a native and JVM configuration. Click the link if you want to learn more; don't worry, it won't bite. You are apparently unaware of this fact, because the entire premise of your comment is that TruffleRuby requires Java, which is false. &gt; I also have slight suspicions of that article. Why would it be so much faster than JRuby? Because JRuby ≠ TruffleRuby. They are implemented quite differently. There is a plethora of source code and documentation for you to go through if you wish to dispute this. For instance and as a starter, [watch this video.](https://www.youtube.com/watch?v=YLtjkP9bD_U) [Then maybe this one.](https://www.youtube.com/watch?v=mRKjWrNJ8DI) &gt; Personally I think there are lots of other areas where ruby could be improved, e. g. a much richer and more extensive ecosystem. TruffleRuby adds to the ecosystem very greatly, addressing very serious performance issues in other Ruby implementations including the flagship MRI. &gt; Or ideas to make ruby more effective in terms of productivity. Productivity and performance are inextricably and intimately related.
Not sure what you are insinuating @BluePizzaPill. But like I said before I did discover this project some time ago and seeing it in HN made me take another look. It looks very interesting and my team is going to take a deeper dive and see if it fits what we are building. Sorry to burst your bubble.
Mordern? That's almost german ... mördern! Well, not quite. But anyway to the question itself - I am not sure what "modern ruby" is. I guess if you just write a lot of ruby code and publish e. g. as gem, you will see what code may work and what may not. It is true that old ruby code tends to look quite different in some ways, even by the same author, e. g. 15 years lateron or something like that. I don't think the differences are that large though. Ruby allows for a lot of different language constructs and people have different preferences. I think the more important thing is to DOCUMENT and comment appropriately, make sure code works, test it (reasonably, not excessively) and keep on making updates to at the least the projects you are interested and care (or, when you no longer do, announce that the project may be inactive and ideally find a replacement if that is possible; that should be much simpler admittedly ... right now there isn't a lot of opportunity to e. g. announce pleas for take over on rubygems.org). I used the old pickaxe from ancient days ago and then just kept on writing more code. There are also lots of things I don't use in ruby for various reasons. I like keeping things simple - those with the big brains can write meta-mega-awesome code. I stick to what's simple, works and is elegant (which also means rejecting numerous additions ... don't even get me started on the type madness that is the current addiction-wave ...)
I'm just trying to get my lib folder into gems :D
I don't think the headless browsers work with `xvfb`. I used it myself until ~3 years ago when I found lightweight alternatives. I would not put much time into this, I think something like [capybara-screenshot](https://github.com/mattheworiordan/capybara-screenshot) is enough for 99% of people that test headless.
Have a upvote. But you have to agree that it looks suspicious? Multiple posts that mention stuff that is not linked at all and then there is a discussion going on.. Well I hope you guys can use the lib to its full potential and your deep dive is successful.