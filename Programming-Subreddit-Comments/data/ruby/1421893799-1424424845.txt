but... but... i just got all my code to pass on Rubocop!
Thanks, most of what you say is true, and without doubt you folks are doing an awesome job with JRuby. As I said earlier, its fundamentally superior, and I really want to love JRuby, but most of the frustrations come from experiences using it with Rails apps (as recently as Rails 4.1).
_Never!_
Escape it. Or use a heredoc or the %q() syntax. 
Good stuff. I've enjoyed Neo4jrb a lot. Those guys are super resoonsive/helpful and write damn fine code. Good work.
Haha. Well to be fair some people still get asked the question. Good source of learning for IF functions though! Nice name haha ಠ_ಠ
That's pretty wicked. Learned some js thanks to that! 
There are times when interpolation is not so clear. Particularly when dealing with ruby's compact interpolation of instance and global variables: the value of `"#$0"` may be surprising to you, but `'#$0'` is not. It's also not just string interpolation that is different between single- and double-quoted strings. They also escape differently. A double-quoted string has a lot of escape sequences - `\\`, `\"`, `\a`, `\b`, `\r`, `\n`, `\s`, and `\t`. By contrast, single quoted strings have only `\\` and `\'`. Point being single quoted strings can be useful when you just don't want any surprises, especially when you have string literals with a lot of symbols in them.
Oh man, great reference!
&gt; You don't want your model layer to be coupled to your caching layer. True. &gt; Russian Doll caching in your views. Coupling your view templates (which really should be side effect free functions of the form `Some Object -&gt; HTML`) to caching is just as bad, isn't it? Caching should always(!) be outside of the thing it caches (usually a project object works fine). Otherwise reasoning about the actual code becomes much harder and you can't even disable caching easily.
Then you use ', %(, %q(, %Q( or whatever. There are (way too) many ways to skin this cat.
You usually want to separate your caching from the other stuff as much as possible, but caching in views is generally accepted in webdevelopment. Fragment caching is both seen in rails, django and other places. Caching is not considered a *real* side effect. 37signals blog post explaining it is a good read: https://signalvnoise.com/posts/3690-the-performance-impact-of-russian-doll-caching
&gt; generally accepted in webdevelopment That doesn't imply it's a good idea, though. &gt; Caching is not considered a real side effect. What is it then? It's accidental state which makes reasoning harder. &gt; 37signals blog post explaining it is a good read: I understand russian doll caching and used it several times in Rails. I also don't see a way to separate caching and view rendering in Rails without getting rid of templates (which designers will complain about).
 &gt;That doesn't imply it's a good idea, though. But it's currently one of the best methods we have. And practicallity beats purity (as written in the zen of python). &gt;What is it then? It's accidental state which makes reasoning harder. Yes, it is state and it complicates things, but boy can it speed up your pages. Caching is a trade-off. It is increasing cognitive load to decrease computational load. &gt; I also don't see a way to separate caching and view rendering in Rails without getting rid of templates (which designers will complain about). There is edge caching (or complete view caching) but they don't work well on highly dynamic stuff. Fragment caching is a current best effort attempt till some better solution is found. In the meantime, it is a reasonable way to share cached results between users. With full page caching this can be hard or impossible, unless everything is the same for all users and you should use an edge cache instead. 
LOL. I'll reply to whatever post I want. Deal with it.
what's heredoc
And that's why you say "I can find all the info in &lt;name two or three resources&gt; in minutes, and that's why I don't use them unless really needed". The reaction will let you know whether you talk with people, that solve actual problems. Also, in my opinion a person reasoning for their lack of immediate knowledge and ways to solve it looks better than "I've memorised everything just for this interview" know-it-all.
blocks procs and lambdas are not that interesting. Better things: * executable class bodies and 'macro' methods (i.e attr_accessible, belongs_to, etc) * Metaprogramming abilities * Open classes and refinements * DSLs * Enumerable and Enumerator * Exploring a code-base with Pry (&amp; repl-driven development with pry in general) * web page debugging with better_errors 
If I cared about speed of string instantiation, I wouldn't use Ruby. There's also this old mantra: "Code defensively". Which means defence from your own mistakes too. If you need a literal string with no guessing involved, use single-quotes. Because in ruby ('\1' == "\1") == false.
Hi cheebs_, I'm glad you liked the article. I've followed your advice and updated one of the examples (the second one in the "Wrap text in html tags" section). Do you think this is a better choice?
This doesn't make sense in Ruby. Just fail on nil: def cities_in_region(region_id) bounding_box = region_bounding_box region_id cities_data(bounding_box).map{ |hash| City.new hash } end def region_bounding_box(region_id) region = Regions.lookup(region_id) or fail "Couldn't find region #{region_id}" region.bounding_box or fail "Region #{region_id} doesn't have a bounding box" rescue GeoNames::ApiError =&gt; e fail "Error looking up region #{region_id}: #{e.message}" end def cities_data(bounding_box) GeoNames.search_cities(bounding_box).fetch 'cities', [] rescue GeoNames::ApiError =&gt; e fail "Error searching cities in #{bounding_box}: #{e.message}" end 
Cool! Nice job on the article, I'll be showing this to my co-workers.
What? first of all, I would argue (and I think most rubyists I have met would agree with me) that it is absolutely not cleaner. Secondly, "this is a #{string}" does not have the same meaning as %q(thi s is a string) Thirdly, you said "what if a string contains quotes" which "this is a #{string}" isn't relevant to. 
&gt; blocks procs and lambdas are not that interesting. Still they are a very basic and powerful feature of the language that is used all over the place - certainly more than metaprogramming. I do agree though that some basic understanding of metaprogramming (e.g. how does attr_accessor work?) should be part of the curriculum.
I'll just add that "another programmer" can also be yourself a month later. It's nice when scanning code I wrote a month ago to be able to see a single quoted string and know that it's just a string and I don't have to give it much thought. It makes the code more readable. The idea that performance is a substantial issue is a straw man argument, and time spent deciding if a string will or won't use interpolation is time well spent anyway.
This seems like a really poor argument in their favour, though. First, you read a line of code a *lot* more often than you write it, so even trivial differences in the readability of the single- vs double-quote characters would completely negate the question of which took an extra shift key-press to type. Also, who the hell even consciously notices themselves pressing the shift-key to generate a character when they're typing? Second, I suspect you also tend to *edit* a line of code a lot more than you write it for the first time ever, and editing a string (eg, to add a variable to an output string for debugging purposes, etc) is a lot less painful with double-quotes than single-quotes (where you not only have to add the interpolated variable, but *also* have to change the quotes delimiting the string, *and* possibly escape/unescape any quote characters already used inside the string, and...). Honestly the only reasons to use single-quotes (aside from subjective preference) seem to be: * You don't have to escape as many characters if you're representing a string that involves a lot of double-quotes or braces, or * It's supposed to be faster The first one is deeply context-dependent (and hence irrelevant for a general guideline), and we now know the second one is statistically insignificant. Regardless of personal preference, I'd say the argument's pretty much over, and double-quoted strings have carried the day.
But they're not unique to Ruby -- every language has procs/lambdas. Perhaps blocks are a little unique, syntactically anyway, but nothing that someone using any langauge that supports first class functions will be particularly impressed by. Though you could mention non-local returns, which is somewhat unique to ruby
Surely you want to "sell" Ruby somewhat? If you just show features every language already has then no one is going to be interested, i think. Also i assume the audience are not noob developers who need to know about the ABCs of a language, they most likely want to hear about the advanced features and what the language can offer them over the ones they already know :)
 "Ruby is Python done right." I think I get that as a t-shirt just to mess with my pythonesque colleagues... That should be fun. Right? 
You can look at using [Mongrel](http://mongrel2.org/) as a web server. It might do what you want it to do.
If there is different functionality, e.g. one site is eBay and one site is pinterest, those should be completely different rails applications that model different domains. You may host them on the same server, but they would run as separate process, would be deployed separately, etc. If it's the same functionality with minor differences such as custom branding or minor changes in language, design, functionality, etc. it can likely be accomplished with a single rails application taking advantage of routing constraints. My suggestion is to be very wary of diverging functionality based on routing in a single app because it is very easy for that to turn into a giant mess.
I prefer it because it differentiates between simple strings and "complex" strings for me. I see your point that it isn't a big switch to change a non-interpolated string to one that is. But that is something that matters more flow wise. Whether or not a hash field for instance is dynamic or not. But anyway I do see your point there. I do like knowing when a string is more complex and I guess I like the look of the single quote. It is interesting that the Ruby Style Guide shows both but does choose the single quotes for *most* of their simple literal strings. https://github.com/bbatsov/ruby-style-guide#strings One of the issues with having so many ways to do things is there will be these discussions. I would actually prefer a recommended or standard way.
I program a lot in python, ruby, and bash, but identify myself as a Pythonista. I wrote [a bit about when I prefer one or the other]( http://changedmy.name/2010/08/03/differing-usage-of-python-and-ruby.html), but that was four years ago, so let me expand on it, or specifically on the things I like about ruby. Ruby is *fun*. I don't understand why, but it is. Python is wonderful, but it's entire philosophy is based on being boring; simple is better than clever, and the language is essentially executable psuedocode. Essentially everything in ruby is an object, and that makes life a lot easier, because you don't have stupid things like `three(one(foo).two())`. The ability to have question marks and exclamation marks in method names, and the conventions that go with them, is a wonderful source of documentation. It's *much* easier to use ruby as a glue language due to easier ways of throwing commands into the shell and getting back the output, and having regex matching be so built-in. Creating a rubygem requires a lot less dicking around than python packaging. Monkey-patching can be extremely useful for fixing other people's bugs in a temporary and constrained way.
&gt; Also, in my opinion a person reasoning for their lack of immediate knowledge and ways to solve it looks better than "I've memorised everything just for this interview" know-it-all. I would say this only holds true if the interviewers are aware that the latter doesn't actually know it all.
It's the second example you have provided. One single application with different branding. I'm a systems guy, I am not particularly familiar with ruby. Could you please point me to an example of routing constraints or documentation? Thanks.
Search for 'constraints' on this page http://guides.rubyonrails.org/routing.html
A good explanation. A better question is: Why doesn't every other language have them! 
That's not 100% true, I've set up systems where the overall functionality is 99% the same but depending on the hostname branding is changed and certain features may become enabled/disabled. With that said, assume you should never do this unless you have really thought it through. Once you go down this rabbit hole it's too easy to get yourself into a real mess.
&gt;Ruby’s blocks are easily the biggest hurdle most newbies to the language have to overcome. Even for people with years of experience in other languages, the the concept of blocks is often an elusive one at first. Couldn't disagree more. Blocks are conceptually quite simple, and not really that difficult to explain or learn. Will newbies have some problems with them? Sure. Will they be the largest hurdle to overcome? I honestly don't think so.
 f = File.open "path/to/file" a = f.map do |field| key, val = field.split(" ") # split return an array of two values. EG [Jane, 1.23] #^^^^^^^^ hopefully this makes sense. Take key and val and assign the two array values. {key =&gt; val} # create hash end Edit: arg! This creates a hash for each pair. Try this. f = File.open "path/to/file" hash = {} a = f.each do |field| key, val = field.split(" ") hash[key] = val end
This is a neat introduction to some functional programming ideas which have a lot of traction in, for instance, the Haskell world. They are however not idiomatic Ruby. [edit: the readme for the gem actually makes it clear that the authors understand they will burn in hell for this: http://blog.txus.io/kleisli/]
You know nothing!
I would agree, if you have any reason to believe these sites will diverge I would suggest approaching them as separate apps. Any code that is shared between them can be packaged as gems and versioned the way any other external dependency is. [Travis CI](https://github.com/travis-ci) is an example of an app that has been broken into many smaller pieces. This will add development overhead up front but may result in code that is ultimately easier to maintain over time. Deciding that trade-off is what takes a lot of skill and experience.
&gt; Models easily become a conflated interface for instantiation, validation, persistence, and retrieval, which are all separate concerns. A minor quibble -- they are not *inherently* separate concerns. They aren't *inherently* similar concerns, either. It all depends on the point of view you take when you design your implementation. For *many* applications, it is expedient to separate these concerns at the object level, because the design is *simplified* by organizing them apart from each other. In some trivial cases, separating validation from persistence will be more sensibly accomplished by separating out methods. In some really complex cases, you might need entirely different *services* to handle both. But the only inherent truths in your codebase are those tethered to the law of physics and your domain itself. All other opinions are subject to context. It is your choice to view validation and persistence as separate objects, for example. Your experience as a designer of software is what makes that call. I think a lot of people miss this when they delve into OOP (Uncle Bob, Sandi Metz, etc)
[I'm doing my part!](http://munificent.github.io/wren/functions.html)
More Rubyish than using `each` would be `inject` / `reduce`: hash = File.open("path/to/file").inject({}) do |memo, field| key, val = field.split(" ") memo[key] = val memo end I think /u/wschroed had an even cleaner answer though.
Huh, I'm a seasoned Ruby and JS developer, and I've never thought about blocks that way before (purely as syntactic sugar). Neat! 
This is why I use single-quotes unless needed. In addition my editor color scheme uses a different shade of the same color for single and double quoted strings, which makes it even more apparent where the interpolation is happening. I like the clarity.
They are: irb(main):001:0&gt; def f(&amp;b) p b.class; b.call end =&gt; nil irb(main):002:0&gt; f { puts 123 } Proc 123 =&gt; nil 
&gt; Surely you want to "sell" Ruby somewhat? Probably. :-) &gt; If you just show features every language already has then no one is going to be interested, i think. Yes, but on the other hand you must not leave out a fundamental feature of the language like blocks which is used for so many cool things (metaprogramming among them). Also, I would not count that as a feature that "every language already has". Functions as objects or similar things are present in many languages, but the syntax in Ruby really makes all the difference.
&gt; Also, I would not count that as a feature that "every language already has" I already pre-empted you in my prior comment: "Perhaps blocks are a little unique, syntactically anyway, but nothing that someone using any language that supports first class functions will be particularly impressed by." 
Fixed (without null object): animals.compact.each{ |animal| puts animal.name } Bad code example for using null object because puts would output what? An empty line? Better example: class Animal; def print; puts name; end; end animals.each{ |animal| animal.print }
Maybe you find [this](http://blog.rubybestpractices.com/posts/rklemme/001-Using_blocks_for_Robustness.html) and [this](http://blog.rubybestpractices.com/posts/rklemme/002_Writing_Block_Methods.html) helpful, too.
I was just messing around in IRB and I wondered what would happen if I modified the array I was iterating over. Turns out the behavior is not what I expected.
Many programmers attempt to improve their code quality by adopting specific OOP practices when instead they should be learning critical thinking and design skills.
If it's just different assets being served to handle the look of the site (images/css) then I would agree with the others that you should look in to routing constraints. Nginx or Apache should be able handle that for static assets.
Saved. Very cool. I'm just diving into ruby but am familiar with GCode. I look forward to messing around with this in the future. Thanks.
I really feel that Ruby methods that mutate the receiver should end in a bang... or have an alias with a bang. [I even wrote a little library to allow this.](https://github.com/pmarreck/ruby-snippets/blob/master/bang_all_the_things.rb)
 a = (1..10).to_a a.each_with_index { |x, i| puts "x:#{x } i:#{i} \n a:#{a}"; a.shift } # &gt;&gt; x:1 i:0 # &gt;&gt; a:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # &gt;&gt; x:3 i:1 # &gt;&gt; a:[2, 3, 4, 5, 6, 7, 8, 9, 10] # &gt;&gt; x:5 i:2 # &gt;&gt; a:[3, 4, 5, 6, 7, 8, 9, 10] # &gt;&gt; x:7 i:3 # &gt;&gt; a:[4, 5, 6, 7, 8, 9, 10] # &gt;&gt; x:9 i:4 # &gt;&gt; a:[5, 6, 7, 8, 9, 10] 
How do you handle the case when you want to deploy one service but another is not in a good state?
I hear this argument a lot. &gt; "What if you tomorrow decided not to use Rails?", "If you tomorrow didn't use Rails, you can still use the services and things we have written" Yeah you know? If I decided against Rails, I might not even choose Ruby and then all the decoupling didn't help anyway. I don't understand the drive away from the Rails way.
Work on different services in different branches and deploy separately? I don't think they are saying that all services must be deployed together.
Really damning rspec with faint praise. The article reads like one Seattle rubyist telling another Seattle rubyist to include a damned binstub with minitest already :) And that is a good thing. I agree with the critique. Rspec's binary is really, really good compared to minitest. Don't even get me started on `Rake::TestTask`.
 ^/u/stefioan gives a beer to ^/u/joelparkerhenderson worth __^Ɍ1000 ^Reddcoins__ 
What do you mean by the "Seattle Rubyist" reference?
+/u/reddtipbot pizza
 ^/u/stefioan serves ^/u/kobaltzz a freshly baked pizza worth __^Ɍ3000 ^Reddcoins__ 
There's nothing that prevents an OO language from using _Maybe/Option_ instead of nulls. The trouble is actually including it after the fact, as you'll never know if the code is new or old or if it uses nulls or not. If you build the language from the ground up without nulls and use _Maybe/Option_ instead there won't be any difficulties. There are actually libraries that implement this for Java and C#, for instance. And it fits nicely with other objects, as Scala has shown.
It definitely takes some time to get used to the _magic_ of RSpec, but I really enjoy it. And the failures producing one liners I can just copy and paste to run again are *priceless*. Much better user experience, IMHO.
I really like RSpec for the reporting and ability to nest tests.
Minitest was made by Ryan Davis who is a pretty prominent member of the Seattle Ruby community. Tenderlove is Aaron Patterson who's also from Seattle and a big member of the Ruby community. He's also the number one contributor to Rails and works on it full-time I think.
I had noticed that error before, and changed it to the correct "fav1.to_i" but it still wasn't working. I needed to turn back into string to make it work. What ended up finally working for me was - puts 'why not ' + (fav1.to_i * 2).to_s + ' ? its twice as good!' Thank you though! 
/u/I_Am_My_Own_God changed the operation being done, but he was right about how your string interpolation should be set up. You got to an answer, just be sure why you got there. Your code was attempting to multiply a string by 2. 'fav1.to_i' * 2 What you wanted was just fav1.to_i * 2, which is what you ended up at. A cleaner way to do it though, is how he did it above, using string interpolation and performing the operation directly. Just my 2 cents.
I started with RSpec when first going through Hartl's tutorial and it was fine. Setting up Guard was nice. I then learned Minitest later and never really found a reason to switch back. I like to use RubyTest in SublimeText to just run tests in Sublime as well as running individual tests as needed. All with keyboard shortcuts (CTRL+SHIFT+E, R or T), no real typing necessary. Also RubyTest gives you colored outputs and if you really prefer the English-like DSL, MiniTest has that as well. I think Aaron makes a good point - who cares what testing framework you really use as long as you test your code. It's like emacs vs vim - I don't see why people get so riled up over these things sometimes.
&gt; calc.rb:3:in '+': no implicit conversion of fixnum into String &lt;TypeError&gt; from calc.rb:3:in '&lt;main&gt; Line 3 of your code in `calc.rb` you're trying to multiply a number with a string as well as add that number to other strings. `'fav1_to.i' * 2` more generally is like doing `'5' * 2`. Do the math before converting it into a string. String interpolation is a good idea here then you can just write your string output like so: `puts "why not #{fav1_to.i * 2}? It's twice as good!"` You avoid having to do a `.to_s` and using multiple `+`'s to build your string. Make sure to use the double quotes as you can't use string interpolation with single quotes.
Both will work. Remember, there is always more than one way to do something in Ruby. I used string interpolation above, which is the preferred method of Rubyists but what you did achieves the same goal.
Well, to be fair, we spend a good amount of time at our day jobs writing tests, and we generally don't get to choose the framework.
You almost make it sound like those two things are at odds with each other and cannot be applied simultaneously.
 Thank you for clearing that up. Really makes more sense when you break it down that way. I haven't gotten to interpolation yet, but when I get there I'll be prepared now. Thank you!!
&gt; Quick, which is correct: &gt; [..] &gt; And why is the top one correct? Because of how rspec's internals are designed. It makes no sense and is a huge stumbling block to people learning it for the first time. IMO that's a pretty weak argument against RSpec. MiniTest has the same kind of problems: Is it `assert_equal` or `assert_equals`? Is it `assert(expected, actual)` or `assert(actual, expected)`? In fact: I still mix up the order of `actual` and `expected` while I have no problem remembering that it's `to_not`. 
Hah! Shimmer is both a floor wax AND a dessert topping!
Oh, test unit syntax (from which `Minitest::Test` is inspired) has its wrinkles. I don't think it is fantastic, but it is at least *simple*. Funny thing to me is that I actually view rspec 1.x as showing signs of credible improvement, but modern rspec is a huge step back. I've often thought about trying out a combination of test unit classes/`test_` methods with `must_*` and `wont_*` style asserts for clearer assertion. However, I have `assert expected, actual` down pat, so it's not a big need for me.
They aren't at odds at all. Good design will often take the form of tried and true patterns. But design patterns and practices are the shadows in the cave. They aren't the platonic ideal itself. Calling out separate concerns as if is their manifest destiny to live in different objects is an overboard position I've seen advocated in the ruby community frequently these days. In fact, I'm not sure that's what you actually implied, and I'm also not sure I'm adding anything anymore to this thread other than my usual curmudgeonly delivered opinions.
I find the syntax of RSpec to be abominable. . . it "should blah blah blah" do That doesn't help me much. I just want to assert truthy/falsy things.
Well, the point of the word "should" is to ensure that the test expresses an *opinion* about the behavior of the software. One example of why this is important is for answering the age old "can I delete this test?" question. Other than that, I agree entirely. Human language is highly expressive but unsuitable for providing instructions to computers. Programming languages are hardly expressive at all, but have the virtue of being able to tell computers what to do. RSpec has the downsides of both, and the advantages of neither.
One of the Good Things™ about RSpec is its drop-dead simple DSL (both pre- and post-RSpec 3.0) that lets you define custom matchers. Instead of including a dozen lines of setup in your spec that don't materially aid understanding of what's being done and why, wrap them into a more semantic package. Win! One of the Good Things™ about Minitest::Spec is that it lets you use bespoke classes that provide semantic wrapping for your spec setup/execution. Instead of including a dozen lines of setup in your spec that don't materially aid understanding of what's being done, wrap them into a class whose method semantics make it (hopefully) obvious what's being done and why. Win!
one big thing missing in minitest, which we had in test/unit, is the bility to ctrl+c tests and still get reasonable output :(
&gt; RSpec is a DSL for writing tests. I think this is probably RSpec’s largest weakness. I am a programmer, I can read code, so I don’t particularly care whether or not my test code “reads like English”. This is where I forcibly part ways with his viewpoint. I've found two things to be true over the course of a (very) long career, neither of which are original to me: 1. Any well-written program, in any language, implements and uses its own internal DSL. That DSL codifies the domain understanding held by the developers of that program; 1. A program is a conversation between two developers, that happens to be executable by a computer. Anything that makes that conversation more effective, more nuanced and efficient, is an improvement to the software. Or, to quote Knuth, "programming is a literary act". One of the most reliable indicators of project risk I have yet seen is a development team that do not share literacy and fluency in a (human) language to the point of metaphor and nuance among themselves, or with their customers and other stakeholders. And if you *do* share that common language, why not use it as effectively as possible? What I *love* about Ruby, more than any of the literally dozens of other languages I've developed in over my career, is that good Ruby *reads well*. It doesn't read like a love child of FORTRAN and APL as does, say, typical PHP. I can read Ruby code and understand it with fewer language-induced WTFs than almost any other language I have yet encountered. The power lets you easily construct "magical" DSLs, which is the most common complaint against RSpec. But to list that as *a fault of the language* is highly narcissistic at best.
same here. and seems there is an alternative, see [the post below](http://www.reddit.com/r/ruby/comments/2tfnw9/my_experience_with_minitest_and_rspec/cnz6lzt)
`Hash[*File.read('file1').split]`
Awesome reading! Thank you.
Right so as long as you're testing your code well then use whatever framework you like or what you use at work! I've yet to really try Cucumber but I hear about it pretty often.
Using it for about a month. Happy so far. 
Practicing is always good, try some of these: https://www.bloc.io/ruby-warrior http://coderbyte.com/ http://www.codewars.com/ http://exercism.io/ http://www.rubeque.com/problems Learning material: http://www.rubytapas.com/ (videos) https://practicingruby.com/ http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104 http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330 http://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452 If you don't have a CS background reading about algorithms and data structures can also be beneficial for you: http://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X 
Not a direct answer to your question, but learn a radically different language well. It will make you a better rubyist.
You mean, give it a spin.
Custom matchers in minitest: def assert_custom_property expected, actual assert expected.custom &gt; actual.custom, "ugh, the custom property had this weird problem" end You can use `assert` to build any matcher you want. I frankly like that more than having to learn RSpec's matcher engine.
I am seeing a disconnect between what you are objecting to, and what he is saying. In some ways I agree with both of you. It is easy to cause ruby to read really, really well. But, to me, that is a strength of test unit syntax in ruby as well. And the ability to make "DSLs" is nice, but that doesn't mean a DSL for testing is all that valuable to every programmer. A limitation evident with the more elaborate ruby DSLs is that you don't get to define new grammar or syntax. Imagine the sequence diagram of `expect(my_hash).to eq({})`. The purpose of `#expect` and `#to` are unclear. Does `#expect` do any actual expecting? What does `#to` actually do? IMO RSpec has made things way more confusing by dropping `#should`. `my_hash.should eq({})` was way more easy to digest, and read better. I can get behind a useful DSL, but RSpec doesn't bring enough goods to justify it. Every time I make this mistake the error message makes me want to shoot myself: describe "something" do expect(thing).to eq "hey" end Say hello to Nested::Core::ExampleGroup::Group1 in your stack trace. Pinocchio's strings have been cut. I get really crazy about this issue because I love writing code professionally in ruby, and wonder if I'll ever get to experience the simplicity of test/unit syntax again at a day job. I get that there area many thoughtful programmers who dig RSpec. That's fine to me. But it irks me that it has become the "default" for the community, and it's not even up for discussion anymore. Really glad that Tenderlove is bringing that discussion back.
&gt; What I love about Ruby...is that good Ruby reads well. But that's exactly the problem with rspec as I see it, that `expect(something).to_not eq :something_else` *does not* "read well" precisely because it is no longer *Ruby* - instead, I feel like I am entering someone else's twisted world when I read this. 
The post really doesn't seem to be much about RSpec vs Minitest. Things like *a better command line* and *copy/paste commands from the output* are only rubber duckies. The real problem for the author here is DSL vs Test Class, and let's discuss that. The historical problem with class-based test cases (e.g. JUnit, Minitest::Test, Test::Unit, etc) is that classes are flat. Now what if I need a small bunch of tests which need some **additional** setup? This is an extremely common testing scenario. A DSL allows you to: describe A do before :each do # initialize some common variables end describe "something else" do before :each do # some other variables for this small group of tests end end end There's simply no elegant way you can group a bunch of methods inside a single class. The traditional ways have been: * Use method annotations to somehow group methods, and then have various setup methods which are configured to run on these annotations * Use test class inheritance, and in subclasses don't run superclass tests once again * Have helper methods lumped in the class, invert the flow of control and make test cases initialize themselves. i.e. describe 1 { before 1 { ... } spec11 { ... } spec 12 { ... } ... } describe 2 { before 2 { ... } spec21 { ... } spec 22 { ... } ... } becomes: def before1 { ... } def spec11 { // manually call before1 } def spec12 { // manually call before1 } def before2 { ... } def spec21 { // manually call before2 } def spec22 { // manually call before2 } All the above are cumbersome, and force you to work extra hard. That's why DSLs outshine flat classes for testing. Try writing test cases for a variety of different combinations using a flat class and you'll understand. The whole list of the author's questions - helper methods, inheritance, etc - are the result of preferring a Flat class instead of a nested DSL. If you properly use a DSL, you don't have these problems.
I'm a big fan of https://upcase.com!
Cucumber is actually pretty cool, but I would say only very advanced teams should be using it.
We're trying to talk our vendors into supplying Docker containers for the web apps we run. They constantly complain about what versions of OSes we run and support in house, and it's a dumb argument to have every 6 months when we need to upgrade something. It would be so much nicer to have a container that I can stick anywhere.
You need decent buy in from your product owner or analyst that signs off on the gherkin stories, otherwise cucumber just gets the way. In other words, if only your engineering team is looking at the tests, stick with RSpec feature specs
I hear you, I have some programming knowledge myself (final year computing student) and have decided to give ruby a try. From my experience its seems like a laid back language in terms of not needing ';' at the end of statements etc Right now I am having a quick play with rubygems and I am setting up rails as we speak to have a play for a week or two before I have to crack on with something else.
I consistently mix up the order when I'm using something that isn't _rspec_, which is one more reason for me to love it. I just can't get it wrong there.
_it "should ..." do_ is actually not the ideal way to declare stuff anymore, you won't find _should_ anywhere in the current rspec docs.
Experiment with Sinatra. Just read a bit of the readme and you'll be good to go. I'd caution against making things too complicated with Rails and all. 
This is exactly what I wanted without even knowing it. I've been writing bash scripts to spin up my VMs. I've been told cucumber is better, but this seems to solve more then just installation automation. Sweet
I'd go with Sinatra, Rails, or Shoes
See : https://www.phusionpassenger.com/documentation/Users%20guide%20Apache.html#_deploying_a_rack_based_ruby_application I'd read that whole manual, but section 3.3 covers what you're trying to do. Cheers.
I settled on plain `assert` inside my BDD-style `describe`/`it` blocks in minitest. That to me represents the best of both worlds.
This. Rails has a much steeper learning curve than sinatra, and for this case, I can't imagine any benefit (except just learning rails).
Oh hey! It's you! 
Shoes is terrible. Web is the quickest way to go, and you might as well know HTML/some sort of templating by now anyway.
Isn't the main thing that before strong params if you didn't attr_accessor anything you could just set all attributes by default?
You meant Capistrano, not Cucumber.
You could take a look at [Oga](https://github.com/YorickPeterse/oga). I've started using it a while ago. I don't know if it offers anything Nokogiri doesn't but I found it easy to use. Oh and the [creator](https://www.reddit.com/user/yorickpeterse) is active here.
Try spinach. It's all the good parts of cucumber, but the definitions are modules, so they aren't shared. Also no regex. I think spinach is better Ruby. 
Undisciplined teams will get off the rails easily with cucumber, leading to tests that look like this: Given I am mocking twitter's API And there is a user with the following attributes: name | John Doe age | 18 You'll see test setup artifacts like these seep into the gherkin. This is just one of many examples of the litany of problems introduced into cukes by inexperienced testers. Another big one is the use of capybara. Ugh, don't even get me started on that quagmire.
&gt; One of the main points of Strong Parameters is to move the responsibility outside of the model and into the controller I agree with you. This implementation is, however, no closer to the models than it is in the controller. I happen to like to put them in the models folder, since they usually correspond pretty closely to a model. You could put them in app/params or app/permitted_params or anywhere else instead. &gt; for some controllers with nested params duplication, this may be fine, but this is a rare circumstance. The thing I like about this that it is a way of separating the permitted params logic from the controller. Sometimes its for nested-params or complex user permissions, and I don't use this every time. There is definitely drawbacks to this approach and Ryan Bates addresses some of them in his screencast [Strong Parameters #371](http://railscasts.com/episodes/371-strong-parameters (paywall)) [0] (paywall). Some examples I found in discourse: Long permit list [1](https://github.com/discourse/discourse/blob/9fcaf090ec7b32474a8c35d468f33726c437b55a/app/controllers/categories_controller.rb#L144-155), [2](https://github.com/discourse/discourse/blob/6734a51b6add70d576f25b29afbebc85f79bdc2f/app/controllers/admin/site_customizations_controller.rb#L55-59 ), [3] (https://github.com/discourse/discourse/blob/5d711db45df1a4d615255a7bf9288e7571bc477c/app/controllers/users_controller.rb#L595-601) Complex permit logic [4](https://github.com/discourse/discourse/blob/0cbdf6f5bb27ccc4239cd996c3936f3dd9460141/app/controllers/admin/badges_controller.rb#L94-97) [0] http://railscasts.com/episodes/371-strong-parameters (paywall)
Sorry, but I've got a lot of criticism for you: The memoized version of fib is so simple to implement, I'm surprised you didn't use it. Then, you wrap that inside a loop. I'd be surprised if this ever runs to completion in a reasonable amount of time for large N. I think the style is alright - like you said, could be more concise maybe, but it's fine for now. tl;dr: Your style isn't as big a deal as your choice of algorithm.
I'm not saying that anyone should ever code like me, but here's how I'd do it: def fibs(limit) [0,1].tap do |_fibs| while _fibs.last &lt; limit do _fibs &lt;&lt; _fibs.last(2).reduce(:+) end end end fibs(limit).find_all{ |n| n.even? }.reduce(:+) You can easily make `fibs` into a memoized version by adding a class variable, I just didn't bother because it seems that the point is just to find the 1 answer. 
This is great. Thanks.
No need to keep the whole array in memory either. You only need to keep track of the last two numbers. fib_generator = Enumerator.new do |fib| fib_arr = [1, 2] while true fib_arr &lt;&lt; fib_arr.sum fib.yield fib_arr.shift end end
Thanks. I actually found [this pretty good article](http://rayhightower.com/blog/2014/04/12/recursion-and-memoization/) from your suggestion. It is definitely going to be useful if I ever get asked this again (or make some kind of non-database calculation in a model or something). **EDIT**: One note. I feel like he didn't need to store a symbol :notcalculated for a size = n array. Couldn't he just use the 'truthiness' of nil and check elsif @scratchpad and that would return true if there is a value and false for nil?
Perfect. I'm gonna keep refining it so that I can learn little Ruby-specific things like this. Thank you!
The best practice in any language is not to use classes if you do not need them.
Yeah my edit note worked out. Here's the code: **Code** class FibMemo attr_accessor :fibs def initialize @fibs = [] end def fib_memo(n) if n &lt;= 1 return n elsif fibs[n] return fibs[n] else fibs[n] = fib_memo(n-2) + fib_memo(n-1) end return fibs[n] end end **Testing Performance** describe "Fib" do context '#fib' do it "returns the correct fib using recursion" do expect(Fib.new.fib(32)).to eq(2178309) end it "returns the correct fib using memoization" do expect(FibMemo.new.fib_memo(32)).to eq(2178309) end end end **Results** $ rspec -fd spec/spec_performance.rb --profile Top 2 slowest examples (0.94786 seconds, 99.9% of total time): Fib #fib returns the correct fib using recursion 0.9477 seconds ./spec/spec_performance.rb:7 Fib #fib returns the correct fib using memoization 0.00015 seconds ./spec/spec_performance.rb:11 **That is a 6318X increase in performance**! Holy crap...... Recursively, it hung the console on any n &gt; 32. 
I issued a pull request! Let me know if you have troubles integrating it. - first, wrote tests for it (see test_linked_list.rb) - added a short #insert_between method to Node (see node.rb) - refactored LinkedList (see [linked_list.rb](https://github.com/soumyaray/ruby-intro/blob/master/linked_list.rb)) You'll see that the new linked_list.rb is about 20 lines shorter and more readable.
It's generally a bad idea to manipulate a collection while iterating because that can create all sorts of unwanted effects like the one you demonstrate here.
Without reading your code too closely, a first suggestion I'd make is to just write a function to translate single words (call it translate_word maybe), and then have a translate_sentence function split the sentence into words and use map on the list of words (with translate_word). Encapsulating the logic of the word translation into a single testable function will make the overall logic of your program much clearer and easier to debug, and is just good practice.
I'd start by writing something like def translate_word(word) # logic to translate the word here return translated_word end Write that function, and test it until you know it works for any word you give it, then you can write a second function: def translate_sentence(sentence) # logic to generate a list of words here translated_words = words.map translate_word # logic to combine the words back together here return translated_sentence end This is just a sort of schematic of the approach, but should get you started. Encapsulating the word translation logic in a separate function is good coding style, and will make your life a lot easier.
Explanation, maybe the algorithm is helpful to OP: `/([^\Waeiou]*)(\w+)/, '\2\1ay'` * Add any sequence of consonants (no punctuation/whitespace/vowels) from the start of the word to the first group * Add the rest of the word to the second group * Switch them around and add `ay` to the end The `qu` bit is a special case that you have to check for specifically, otherwise `u` and any following consonants aren't carried to the end of the word.
Why? Or rather: where?
Indeed, I don't think you win much by wrapping ActiveRecord into your own classes. I have yet to see it work at least.
I'm more partial to carrots and kale myself. They seem to have much better nutritional value. Cucumber is mostly just water and spinach doesn't really have as much iron in it as Popeye would like us to believe.
You may want to post this to [/r/rails](http://www.reddit.com/r/rails) instead.
A great idiomatic solution was offered [last time this problem was discussed](https://www.reddit.com/r/ruby/comments/2d8i85/would_like_feedback_on_my_code_to_a_given_problem/cjnabdb).
You might want to look at a gem like https://github.com/stefankroes/ancestry or https://github.com/amerine/acts_as_tree, which might provide the functionality you need out of the box. Check for instance https://github.com/stefankroes/ancestry#arrangement Now, looking at your example, we have [ ["parent - Tree 1", ["Tree 2", "Tree 4", "Tree 5"] ], ["parent - Tree 2", ["Tree 3"] ], ["parent - Tree 3", ["Tree 6"] ] ] Can you please format the output that you really want? Edit: Since you are not replying, you'll probably want to use something of the form def get_subtrees [self] + sub_trees.map(&amp;:get_subtrees) end Going even more functional, you could define the following class OrganizationTree def map(&amp;block) [block.call(self)] + sub_trees.map { |t| t.map(&amp;block) } end def get_subtrees map { |t| t } end end
Short answer is don't think too much about it, "just jump to 2.2", and this book will get you there. There are no significant/breaking changes from 2.0 to 2.2 at the language level, nor are there from 1.9 to 2.0 for that matter. From [the book's website](https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0): &gt; About Ruby 2.0 &gt; Ruby 2.0 is a minor update to Ruby 1.9, unlike the more major updates from Ruby 1.8 to Ruby 1.9. &gt; The major language changes in Ruby 2.0 are the addition of keyword arguments and the change to use UTF-8 as the default source file encoding. &gt; There are a number of additions to the standard library, including: &gt; Enumerator::Lazy, which adds support for lazy access to potentially infinite lists. Refinements allow you to encapsulate changes to third-party classes, and scope their application to individual source files, preventing your changes from polluting the global application. &gt; You’ll also find that Ruby 2 is faster, and has memory management improvements that make it more server-friendly. &gt; All told, there are over 110 sections of the book that have been flagged and cross-linked to indicate 2.0 content.
Thank you! I haven't opened the book yet to read this part... I'll forward this to my buddy
The true ruby way is to install the sum_of_even_fibonacci_ninja gem :)
+1 for adding keywords, that's a rather nice touch! &gt; The problem is that for the specs I need a default tenant in the database to run all of the application's normal specs (which don't know about multi-tenancy) against. Which specs? For the whole app? The controller specs? Model specs? Is this a specific app? Do you want to test behavior with and without the plugin? Etc. Do you want to test the behavior of the application as a whole or of the plugin? If there is test specific stuff you want to expose to the user/developer, then you could add a `plugin_gem/rspec` file that can be included in the `spec_helper`, then you could add something like RSpec.configure do |config| config.around(:each) do |example| PluginGem.with_default_tenant do example.run end end end Edit: Also have a look here: https://github.com/influitive/apartment/wiki/Testing-Your-Application It details how you can test apps which use apartment. You can do something along those lines. 
This is gold - thanks!
Thanks for the answer! I want to run the controller and feature specs for the whole app including the other plugins. The app itself has a separate CI job without any plugins where everything is tested. Then there's an extra job for the app combined with a certain set of plugins. The plugins disable core specs which they would break because they change the behaviour in those cases and add their own version of the spec instead. That approach doesn't really work with this multi-tenancy plugin, though, of course. Especially as in the default case everything is supposed to work as if it weren't there. I think I will really just go with that `plugin_gem/rspec` approach.
This is a good point, because humans never make mistakes.
The link is wrong, you submitted the url to localhost: http://localhost:4000/blog/2015/01/25/simple-user-authentication-with-cuba/
Yeah, but this is in context of [Euler problem 2](https://projecteuler.net/problem=2). Their series starts with 1, 2, 3, 5, ...
Here's how I did it. Although it doesn't solve the problem of punctuation/capitalization, it should give you an idea of how to pass information between functions. Let me know if you have any questions about what I did and as a disclaimer I'm still learning myself. http://hastebin.com/elucoxepot.rb
Great link. Everyone upvote this man for his fantastic contribution to the community.
This man deserves so many upvotes. Fantastic link!
This kind of authentication works! There will never someone in the system who shouldn't... 
OP here, [this is the link](http://andy4thehuynh.github.io/blog/2015/01/25/simple-user-authentication-with-cuba/). Got my derp moment checked off for the day ;)
Ruby on Rails, obviously 
I wrote this because I was writing wrappers constantly and needed a way to build objects more quickly. This is very much a "WIP" so PR's are welcome. Thanks for looking!
Take a look at https://github.com/mceachen/closure_tree. Does what you're looking to do highly efficiently. If you wanted to roll your own as an academic exercise, take a look at the source for this and the gems /u/cmd-t suggested as a source of inspiration.
What are segfault errors? I've only encountered basic syntax errors
It seems like an xpath style approach would be superior. Consider the cost of substituting an object tree created by ClassyJSON: OpenStruct.new(:results =&gt; OpenStruct.new(:job =&gt; OpenStruct.new(:name =&gt; "Code Club")) There is a lot of message passing between those objects. Now consider an xpath style approach. Suppose you can access the company name deep within the JSON response like this: results = XPathStyle.convert resp, "job" results["job.company"] # "Code Club" You can double that `results` object with a simple, flat `Hash`: { "job.company" =&gt; "Code Club" } I prefer deseralizing big responses into one (or a few) objects, and building APIs to help get the data you need out of it. Building a deeply nested object hierarchy behind the scenes is actually fine, as long as you don't have to "reach" into it. The obvious value of making the whole response accessible by a single public API is obvious: we can double the `results` object with a `Hash` and experience fast, robust, mock free tests. But there's something less obvious; we can *extend* those results the same way we'd extend a `Hash`. Maybe we introduce a caching layer. That caching layer just has to expose a `Hash` as well. The code doesn't know the data came from `Redis` or the API itself; by using a single common ruby duck type, we have a very extensible implementation with way less code.
You say you don't really believe in objectification, Why?
How would you recommend doing that? Wiki page? A sibling github project? I had considered a demo app, but wasn't sure the best way to go about it.
Do you have any advice for getting better at coding problems? I went through all the intro prepwork, but felt stumped even at the first 2 "easy" practice questions, and had to look at the answer. It actually took me a while to understand how the answer worked... I feel like programming requires a certain amount of innate creativity
This is really interesting, thank you for sharing! 
I'm chiming in as someone new to Ruby (3 months now), having done Perl, Java and Python in the past... I think what makes Ruby truly unique is that it's the only language that truly prioritizes programmer happiness. This is an esoteric, subjective thing, but if you come from a Unix/Linux background and have worked with Perl and shell scripting, Ruby just feels terrific. It's very expressive (you can accomplish a lot in very little code), there are lots of high level methods that other languages don't bother providing, and the level of dynamic-ness lets you do things that seem magical. It's a great balance of being a strong, modern object-oriented language while keeping things easy to do. That's a huge and unique strength, in my opinion, but like most things, it can cut both ways. Ruby libraries and frameworks are obsessed with creating DSLs, and they tend to abuse Ruby's syntax and do tricks with scope/evaluation to do so. In effect, you have to learn a new language every time you configure something, and you can't look up normal API documentation to figure out how: you have to go by weird examples to figure out the right place to stick a method, argument, symbol, or block. 
How'd the test go?
thank you for the help
I was able to borrow the idea from you and Jaeemsuh to complete the assignment. Though is does still need to be cleaned up quite a bit, this is what i came up with: https://gist.github.com/nix12/41dba19ffd81ab1f1b23
I'll give you a non-enthusiast's perspective... What stands out most to me is the left-to-right reading of code and a general avoidance of non-alphanumeric symbols for syntax. This is huge and may actually turn out to be one of the biggest wins for maintainability in large codebases, provided people write in idiomatic Ruby. The reading feature comes from method-chaining, since almost (bah "yield") every expression is also an object. In comparison, I would say that Perl comes close to providing this via things like Moose::Autobox, but there is extra noise involved, including mashing "sub {}" everywhere vs Ruby's block syntax. Clojure (and any Lisp that implements them) has a rough approximation with the "-&gt;" and "-&gt;&gt;" macros, and idiomatic Haskell gives you left-to-right reading while sacrificing readable English word flow. Also, I want to note that jruby provides a practical layer on top of the JVM, bringing portable applications to the table. I cannot say I side with the other suggested features. This is going to sound contrary because I am directly addressing other features mentioned, but I only intend to keep things in perspective across the popular to semi-popular languages... * metaprogramming - not unique here: Lisp, Template Haskell, any language with a MOP (such as Perl's Moose) or decent macro facilities * ActiveRecord - As far as I can tell, this project continues to follow the "active record" pattern towards ORMs, as opposed to the "data mapper" approach, and the most obvious code smell involved is the mapping of table fields to class methods; you cannot use fields whose names may match methods used by ActiveRecord or any of its parent classes (https://en.wikibooks.org/wiki/Ruby_on_Rails/ActiveRecord/Naming). The ruby DataMapper project (http://datamapper.org/) seems promising but lacks strong community support. For most basic CRUD applications, though, active record is sufficient and simple to understand. * Stubbing code in testing - supported by every dynamic language I've played with; for example, Perl's Test::MockModule and Test::MockObject, convenience wrappers around the language's symbol manipulation features that include scoped restoration of definitions * Almost every language considered a "scripting language" excludes the need for a "main" function; so do several non-scripting languages, such as the Lisp family, although you do need to specify an entrypoint function if you wish to build standalone runnable images. This is a debatable feature, though; the lack of some kind of wrapper around an entrypoint presents difficulties to testing the code in scripts without being forced to run them from start. All that said, it's nice to not have to write the boilerplate for simple scripts, and most people abstract their main code out of scripts and into class files before they grow too large. * I'd agree that "gems" are a reasonable language feature similar in comparison to Perl's CPAN, except the community still needs an automated test site for all gems (akin to cpantesters); the point is that almost any task you can think of is likely represented in a gem, and simultaneously, that implementation may be terrible or great, but it's a starting point. Also note that rubyforge recently went down, breaking a ton of links when you are digging around the gem aggregators. To close on an especially positive note, I have to admit it's nice to do things like call "my_object.methods.grep /method_I_am_looking_for/" vs the syntactic backflips I have to pull in Perl (grep {...} keys %{My::Package::}) or the right-to-left nonfunctional shenanigans in Common Lisp (http://cl-cookbook.sourceforge.net/packages.html). Combined with good tooling in an editor, and you can get an integrated experience similar to what the Lisp+Emacs folks enjoy.
I wrote a blog post a couple years ago that talks about the things that keep me coming back to Ruby. The topmost reason is metaprogramming. People are mentioning Ruby on Rails and ActiveRecord ... but really, those are just specific instances of metaprogramming being used for awesome. The ability to build very simple languages with almost a completely custom syntax ... and build them quickly and with high quality. That is Ruby's biggest strength. Full post here: http://www.lee-dohm.com/2013/05/05/thoughts-on-why-ruby-is-awesome.html
Everyone can make a mistake, please don't be mean, we don't do that here.
LongElm, maybe you can delete and repost with the correct link? I think that would be quite acceptable and helpful.
&gt; you have to learn a new language every time you configure something, and you can't look up normal API documentation to figure out how: you have to go by weird examples to figure out the right place to stick a method, argument, symbol, or block. Wow, never codified this thought but I experience this on a weekly/monthly basis. Ruby programmer for five years.
Or if you want to go really deep, search for Joe Celko's articles on tree hierarchies (or buy his book http://store.elsevier.com/Joe-Celkos-Trees-and-Hierarchies-in-SQL-for-Smarties/Joe-Celko/isbn-9780123877338/). I'm not a shill for Joe Celko's stuff. But I found his articles illuminating back in the day when I used to develop databases for a living.
A huge strength overall is speed of development / speed of prototyping. You can start solving most problems with very little code and iterate your way through the challenging stuff before refactoring once you understand your problem domain better. What it has over Python, for me, is that the language &amp; libraries are consistently designed. This could be due to the language designers deciding to focus on building an object oriented language from the very early on as opposed to Python trying to bolt it on later. Whatever the reason, I prefer to not have the inconsistencies that Python has because it's wasted mental cycles to have to retrieve them.
New to the testing part of Ruby. When you use terminology like, "stub out ANYTHING" does "stub" in this context mean creating a test scenario in Rspec (or whatever testing suite you're using) with assertions, etc.?
By stubbing I mean taking a method and replacing it with a simpler method of my own creation. This usually happens inside a test scenario with assertions, but the stubbing is a very particular part. Let's say I have a Logger class. When I pass it a message, it should prepend the current time, and then output it to a file. So if I say "This is a message" it should write "2015-01-27 00:05:09 -0800 This is a message" Doing the simplest thing that can work, I simply prepend the result of Time.now to the string and write it out. But then it comes time to test, and now I have a problem. You see sometimes the Logger class calls Time.now just a little bit before the assertion. This doesn't always happen (we're at one second granularity here) but often enough to be a flaky test. This is not a problem in Ruby -- I can re-open the Time class for modification, and tell it "next time your now method gets called, you return this specific date and time." So that's what it means to stub a method. And you can do this for all sorts of things -- random number generation, database calls, you can say "Take this real object, this real system object, and change its behavior within the context of this test." RSpec can do this, because Ruby is amazing. Not every language lets you stub out methods on system objects.
Besides all the programmer-sugar already commented, one thing that kept me in Ruby was the huge resourses available thru Rubygems. But now I begin to see the same value in NPM...
Do you have a real example of SQS use ? 
Thanks for the detailed explanation. Just so I make sure I'm clear then, it sounds like you are taking something, class/method/object/etc., and saying "for purposes of this test, forget your normal behavior, and instead behave this specific way within the scope of this particular test." With the purpose of that typically being to generate particular input/output to keep the test controlled and accurate. Is that more or less on point?
I suspect there are multiple things wrong here. You say that the result is wrong for two examples that look correct, to me. e.g. The string "a" certainly does not have a letter "z" in it at all, so the method should in fact return false, which it does. In fact, the one that is not working is the example for "z". If you read the problem prompt, it states that all of the output should print "true". So you are working under a false premise. Maybe that will help you out. I see issues with the code as well, but I'll give you an opportunity to figure it out. Check back if you still have problems.
Is there some prohibition on using a regexp? That's by far the easiest way to solve this.
Yeah that's more or less correct. I like to imagine it as taking a chainsaw to one of the "arms" of the software object and then attaching a dedicated tool to the "stub." That said, you rarely use the "stub" keyword in RSpec. Rather, you often mix stubbing with an expectation. Like you might write thing.should_receive(:method_name).with(:arguments).and_return(:value_for_test) Now you can say that whatever tested_thing is, it should get a call on method_name, with the specified arguments, and if it does not, the test fails. If it DOES get those calls, you'd want it to return the specified value. character.should_receive(:save).and_return(true) This acts both as a test (that the character was saved) and a stub (because you don't execute the saving code, you just return the true value.)
I actually haven't delved into regexp, but I looked into it just now and got the following: def nearby_az(string) if /az/.match(string) return true elsif /a[a-z]z/.match(string) return true elsif /a[a-z][a-z]z/.match(string) return true end end And I got the correct results! :D Thank you!
This is very true. I've written my own DSL in Ruby for fun, and it's so easy to do! So my job got easier, but if you ever wanted to use my project, you need to learn a new thing! Ruby trusts the programmer a lot. Java feels like blunt safety scissors compared to Ruby, which will let you do many bad-wrong-evil things. That can be a huge pain when someone ELSE on your team, or the author of a library you need, has a different definition of bad-wrong-evil.
That certainly sounds like you're on the right track! As another user suggested, regexps would be useful here as well, and sounds like you've got that working quite nicely. Good luck!
Hmm, doesn't look like that's actually correct. I think you're actually confused about your testing output here. Every single test output should end with true. The last three actually check that the method *rejects* strings that don't fit the pattern. Your output should really look like this: nearby_az("baz") == true: true nearby_az("abz") == true: true nearby_az("abcz") == true: true nearby_az("a") == false: true nearby_az("z") == false: true nearby_az("za") == false: true If the last three say "false: false", your method is approving strings that don't actually match. Anyway, with regards to the regexp, try using the {} expression. Here's a quick rundown on various regexp operators, including {}: https://www.gnu.org/software/gawk/manual/html_node/Regexp-Operators.html
Yeah, again, feel free to check back with any questions. One thing that may be tripping you up is your understanding of how blocks vs methods work (blocks are really tricky if you're new to them!). Remember, a `return` will exit the current _method_, `next` in a loop will iterate, and `break` will exit the loop. As a hint, in your original code, see what happens on the first iteration of the loop--turns out, it will return from the method no matter what! That's not what you want; you need to be able to iterate over the entire string to check each possibility.
I like how you're addressing characters in the string like it's an array and I think you've got the gist of what this exercise is suppose to teach. I'll make two suggestions for you to look into when you refactor this (because they should be teaching you to refactor anything you write once it's working): 1) Ruby enumerables are fantastic. You're already using the #each method. Is there another enumerable method that also gives you the index of the items you're iterating over so you don't have to manage that yourself? 2) have you worked with ranges yet? Look at ranges and see how you might be able to address a range of elements from an array. Maybe this will help remove duplicated code? http://www.ruby-doc.org/core-2.2.0/ has everything you need. :) 
I'm stuck.. This is currently what I have: !!/[a([a-y]{0,2})?&amp;&amp;z]/.match(string) My thought process was it needed to have a minimum of "az" to return `true`. So I stuck an "a" at the start and "&amp;&amp;z" at the end. Then I tried to put in an option `( )?` in-between. The optional can contain `[a-y]` not including z because it'll always contain a "z" at the end if returning true. The optional letters can contain up to 2 characters, so I used `{0,2}`. Can you tell me which part(s) I should rethink and any hints?
Good point! It takes key value pairs as arguments to the constructor and assigns them to attributes in the class.
Well, first of all, you don't need to use &amp; at all. Also, you have your entire expression wrapped in [], which is for specifying a character range (not really what you want to do here). Let's go back to your previous expressions: /az/ /a[a-z]z/ /a[a-z][a-z]z/ You're on the right track here. Think about how you could simplify these three expressions together into one expression. Keep in mind that the [] expression only matches a single character (well, you can make it match more with grouping, but ignore that for now). Now, how many times do you want to match that character? So how do you express that using {} ? 
I think I got it!! !!/a([a-z]{0,2})?z/.match(string) 
OpenStruct is the correct answer! 
The nil is just initial value. After it run, value will change to other.
This adds attr_accessors to MyClass for *every instance* of MyClass, which is extremely expensive for a number of reasons, one of which is: flushing the global method cache.
 2.1.2 :003 &gt; ['b', 'w33', 'a2'].max_by{|e| e.size} =&gt; "w33" You may use this simple code. I think you need to understand the while statement more. It's a cycle until the last word.
&gt; it'd be better if there were challenges or some form of objectives to keep me going, like course work. You say you are working with ruby professionally and as a hobby -- so you probably have projects you are working on? Why do you need coursework if you have projects, what about your projects in ruby is keeping you from learning more about ruby by working on them? That you think coursework would do better at? Do you make sure you understand everything you're coding, and why it does what it does? Do you look at your code and wonder if you can make it more readable, or more maintainable? Do you go read the rdocs for stdlib classes you are using, to see if there are useful methods you didn't already know about, but might remember next time? Have you ever profiled code for performance, to identify bottlenecks, and try to make them faster? Have you run into a bug in a gem you are using? If you have, have you tried to submit a pull request to fix the bug yourself (with tests)? Or a feature that was missing that you wanted from a gem you are using? I think these are the sorts of things good programmers do, and it's doing these sorts of things that makes you into a good programmer. If you're already basically comfortable using ruby professionally and as a hobby -- I don't think doing more coursework is going to take you to the next level, what will is trying to write better code with the things you are already working on. If your professional projects are boring and don't provide opportunity to improve your craft, then start a hobby project that will. 
actually after staring at the answer for some 15 minutes more, I think I get it now, so if I have a string "Ruby is a language", it breaks down into ["Ruby", "is", "a", "language"] then when it starts the loop, words(idx[0]) which is "Ruby", goes through the first "if" statement, so for the first loop since longest word was set to nil, "Ruby" will be the longest word, but then for the rest of the loop, it will go to elsif branch right? With both "is" and "a" becoming the new "current word", but since both of them are shorter in length then "Ruby", "Ruby" stays the longest word for the (idx[1]) and (idx[2]) loops, but then for (idx[3]), because "programming" is longer in length then "Ruby", "programming" becomes the new longest word, and gets returned at the end. Is the way I thought this through correct? Now the hard part is even being able to come up with something like this, just started the prepwork about 3 weeks ago, had no experience programming or coding whatsoever before that... maybe programming isn't for me. :( 
:D awesome work. What sort of a laser will you use?
I have my eye on a 450-500mW 405nm 5V 500mA laser. The laser costs about 100USD and the Mount/Heatsink about 3USD. I'm not planning on cutting through anything major, but rather wood engravings. With the slow speed of the stepper motors and the threaded rods, I figure that it wouldn't be too bad of a choice. Kind of sad that the laser, module, driver, safety glasses and mount/heatsink will cost as much as I built the CNC for. I am opting for really high OD5-6 glasses that will fit around my eye glasses since loss of eyesight is one of my greatest fears. The laser requires like a OD2.9 and the glasses that I'm getting cover 190-449nm OD5+ : 450-532nm OD6+. They are certified and will run about 90USD. 
Nope, that part is fine. The part I'm talking about is this: ([a-z]{0,2})? What exactly does that expression mean, in English? Try breaking it down piece by piece. What does the expression `f{0,2}` mean? What does the expression `(foo)?` mean? What does the expression `(foo){0,1}` mean?
Definitely thought it was interesting. I left a comment on the blog post but will repost it here. I'm a big fan of tech communities, would you be interested in x-posting this on http://www.ugtastic.com, a site dedicated to User-Group communities? I'd even welcome User-Group organizers to add their groups to the User-Group List at https://ugl.st too. :)
Congratulation！At least you know more than ever. 
&gt; it's not super performant or memory efficient. That is an understatement, it busts the method cache every time one is instantiated :) although not useful in this case because the attrs are being set dynamically there is a possible alternative for future reference. https://github.com/charliesome/fast_open_struct is a drop-in alternative.
oh, i've just realized that's exactly what suggestions are - "asynchronous" creation. So 200 for successfull update and 202 for suggestion sounds reasonable. But what about response body?
to me, you should POST to an endpoint like /api/posts/:id/suggestions if you want to create a new suggestion and PUT to /api/posts/:id to update a post. now you aren't trying to hide a create suggestion action behind an update post. follow?
3 is really the only acceptable way if you really want your api to be restfull. You could do nested resources in this case resources :posts do resources :suggestions end The user than does a post/create request to `/api/posts/1/suggestions/`.
The endpoint should be suggestions for non admins and posts for non admins. Don't try to be too clever. With a 200 response on success in both cases.
Just be careful with stubbing. I'm at the point where I avoid it in nearly all code because it has created more problems than it has solved. The general issue is when you replace a method, you can also replace its signature. It's easy when refactoring to have tests that pass when they shouldn't because the caller is making a bad call, but it's calling into a stub that wasn't updated when the method it's stubbing was, so the tests still pass. Having to provide an implementation of a method avoids this problem. *Edit: grammar*
Just a reminder that South East Asia comprises Brunei, Cambodia, East Timor, Indonesia, Laos, Malaysia, Myanmar, Philippines, Singapore, Thailand, and Vietnam. Clicked on link for South East Asia, got Cambodia and Malaysia only. Was disappoint.
I'd go for the regexp solution as well - it's the shortest and most efficient. One remark to the original code: new_str = string.split('').map{|s| s} The #map is completely superfluous as it does not modify the block argument in any way. You could use #dup instead to retain copying but that is not needed since #split creates a new Array anyway. The name *new_str* is also a bit misleading because it is an Array of Strings. Note, you can also do chars = string.each_char.to_a But: this is not really needed: you can access substrings of length 1 via the original String just as well. You just need to replace *new_string* with *string*.
If you're interested about the Philippine Ruby scene, there's PhRUG which holds [regular meetups in Manila](http://pinoyrb.org/events), and there's also the upcoming [RubyConfPH](http://rubyconf.ph/). &lt;/shamelessplug&gt;
 [a-z]{,2} ahh I see.. I removed the `( )?` because it's the same as saying a range of `{0, x}`. I thought the `( )?` was necessary because it means that whatever is inside is optional. I thought the braces `{ }` meant it had to contain up to `x` amount of the preceding character. So `{0,x}` means x or less. Cool!
Programming is hard when you are starting out. Once you have a year or two (or even a month) it will get a lot easier. Right now youre prob learning syntax with many other concepts like indexes, functions, classes, methods, along with random tricks like setting that init value to nil. With all these concepts in your head, trying to come up with a solution is hard. Because your brain is already doing a lot if work! It will get easier, just keep at it.
Sounds right. I think you're on the right path -- get out a paper and pencil, and go through the code as if you were the computer. Go through each line, what does it do? Make a box for each variable, at the point it's encountered. Every time the value of the variable changes, erase what's in the box and write the new value in there. Go through line by line -- if you get to an 'if', does the condition evaluate to true? Then drop into the block, else skip it and go on to the next line. If there's a point you don't know what to do becuase you don't understand what the code on that line does -- figure it out by googling. Yep, this is really how many of us learned how to code (except many of us had to do it before google and stackoverflow!)
This is a fair counterpoint. You should stub when you HAVE to, because the call that you're making is impossible to run. You should also have coverage from other types of acceptance tests. Like many whitebox tools, stubs should be used as little as possible. But it's nice to be able to use it when you must.
Well, I guess the first step is understanding the provided solution, indeed. I think you're probably on the right path? Not sure what you're looking for here?
I like this answer: str = "a sentence with some really long words or actually not so many" words = str.split() longest = words.inject("") { |acc, word| (word.length &gt; acc.length) ? word : acc }
good catch! i merged in a PR to namespace everything to within the module, should be protected from this now :)
you ever heard about [http status codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes), you could/should be returning these codes, plus potential values (preferred in JSON format)
Looks pretty reasonable to me how you have it. Beware of false DRY -- just because the same code repeats doesn't mean it's not DRY, sometimes it just _happens_ to repeat because of current context/configuration, but it's not intrinsic that it will always repeat. But even if it's not like that, there are diminishing returns -- sounds like your hypothetical solution might add more lines of code than it removes, which is a signal to me that, well, there's certainly no reason to do it "just because", unless you actually have some pain you are trying to solve. But I've also never had much truck with automated 'code quality' tools. 
I had almost the same idea: module Csvthingy def from_csv(row) new self::CSV_ATTR_MAP.each_with_object({}){ |(k, v), h| h[k] = row[v] } end end class InspectionData CSV_ATTR_MAP = { orig_key: 'serial_number', ... } extend Csvthingy end def inspections map_csv 'restaurant_inspections.csv', InspectionData.method(:from_csv) end
Yeah, this is what I'm watching out for. This code is 'configuration', like you say.
Okay, so it's important to know that the CSV data is going to be coming from multiple from external sources and they're not integral to your internal system. Knowing that, I might architect the software so that the calls look something like: inspection_data_hashes = Adapter::LasVegas.inspection_data(csv_path) inspection_datas = InspectionData.array_from_hashes(inspection_data_hashes) `Adapter::LasVegas.inspection_data` can be changed if they change their file format or their CSV format version. It can also be configured with optional parameters if necessary. `inspection_data_hashes` is created as an intermediate variable because now you can inspect/print/pass the parsed data in a still-serialized way. It's kind of like how console commands are designed to continuously pipe human-readable data to each other. `InspectionData.array_from_hashes` shouldn't need to change when new locations are added, when new formats are added, when new file versions are used, etc. At this point, data is clean, parsed, and internal to your application logic. If there is a lot of complex csv logic that's common amongst different adapters, you can have it extracted into a CSV parsing class that the different `Adapter`s make use of. `InspectionData` shouldn't have anything to do with that data parsing/file format at all. **edit** If the csv files and `inspection_data_hashes` starts getting really big, you might have to start doing: inspection_data_reader = Adapter::LasVegas.inspection_data_reader(csv_path) # file prepared but not loaded yet inspection_datas = InspectionData.array_from_reader(inspection_data_reader) # reader knows how to read the file and array_from_reader will ask reader to interpret the file
I would take just about anything CodeClimate says with a ~~grain~~ big pile of salt. I've seen it *insist* that casting user input to an integer won't protect against SQL injection attacks. I'd love to hear the author of their engine explain how, exactly, he thinks that `"'; --DROP TABLE students;"` is going to survive through a cast to a numeric type. I have a gut feeling that the rest of their code is equally naïve.
Hello! I just completed the codeacademy on ruby earlier today and I attempted some of the project euler ones. This is how I personally did #2 if you are still interested. Note, I'm not sure if this would be considered a ruby way or if it is very basic but it worked out for me x = 1 y = 2 z = 2 while x &lt; 4_000_000 || y &lt; 4_000_000 if x&lt;y x += y if x % 2 == 0 z+=x end else y+=x if y % 2 == 0 z+=y end end end puts z If it helps you just let me know! BTW sorry if the formatting is poor! Not sure how this reddit thing works.
It's good advice because otherwise you end up having multiple different methods of sanitisation for different input types.
We are all guilty of writing bad code!
&gt; It was purely functional You probably didn't actually mean that the code was [functional](http://en.wikipedia.org/wiki/Functional_programming) since actually, functional code is some of the easiest to debug and maintain. In any case, congratulations on your path towards good, tested, maintainable code!
Beat me to it. I'm guessing OP wrote imperative or procedural code, possibly using some form of functional decomposition, but not functional code. Functional code is not just any code that uses functions and is not object oriented. Functional in the programming sense refers to the fact that it is like mathematics, and one input correlates to one output. Also that where a function is called you could simply replace it with it's return value and the program would still execute properly. It's generally very difficult for people who haven't been exposed to a lot of functional code or mathematics to be able to express ideas as functional code at all, much less by accident. When it is though it tends to be some of the best code written, at least from a purely academic standpoint.
I would cater for stream processing: def inspections return to_enum(:inspections) unless block_given? CSV.foreach('restaurant_inspections.csv') do |row| yield InspectionData.new(orig_key: row['serial_number'], business_orig_key: row['permit_number'], score: row['inspection_grade'], date: row['inspection_date']) end end
Hi, my name is Martin and I write bad code.
Procedural more accurately fits what I did, thanks for clarifying.
 *chorus* Hi Martin
You and me both. I have to do a lot of data massaging and transformation for stuff that already exists in a database. So it seems it often lends itself to it more clearly than entirely OO approach. 
I agree. Sometimes OO just isn't the right tool for the right job. Like let's say you're writing a thin layer between a database and a front end, which sure happens a lot with WebDev, for example. Nowadays it seems to be more and more acceptable to use the right tool for the right job, though. I started programming in the mid-90s and it seems that right up till about 2010 doing anything non-OO was considered as bad as using GOTO or being a neo-Nazi.
Man, that's pretty cool. I've actually been looking for an open source project to contribute to, but I'm not sure my math skills are up to par for something like this.
Well, we could use people who are interested in working on our visualization software. We still haven't found a great Ruby answer to matplotlib, though we have a few prototypes that are pretty cool. Honestly, my math wasn't that great when I started writing NMatrix. It's getting better — because of my job, mostly.
welcome :-)
I didn't know about software packaging...so I used PowerShell to write sometimes 100+ line scripts to wrap around my install files. I feel so badly for whomever has inherited that environment.
What does that entail?
I'm following you little boy.
http://exercism.io http://projecteuler.net
I would reccomend a text-based Connect Four game. Something simple for two human players. Each turn, it would print out the board and the player would type in the column that they want to play in. The computer would check for a winner after each turn. An example board would look like: Player 1's Turn: [ ][ ][ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ][ ][ ] [ ][ ][x][ ][ ][ ][ ] [ ][x][o][ ][ ][ ][ ] [x][o][o][ ][ ][ ][ ] 0 1 2 3 4 5 6 It may seem simple, but it was a valuable learning excersize for me! It requires printing, logic, iteration... EDIT: It may be better to make a Tic-Tac-Toe implementation before Connect Four.
Reviewing student applications, checking in with students daily to weekly to see how they're doing (some require more contact, some are very independent), checking to make sure they're writing code. It's not a ton of work. In exchange, Google will cover most or all of airfare and lodging for two mentors to the GSoC mentor summit at the Googleplex. There's also a $500 stipend, but most of our mentors donate that to our org — or use it to cover what remains of plane tickets if they're flying in from overseas.
Thanks this was really helpful, I have one other question: It seems just from going over the first few practice problems that there are easier and shorter ways to do them if you have a more in-depth knowledge of the various Ruby methods, since the knowledge in the prepwork they give you isn't that comprehensive. Is it a good idea to try to just learn more of Ruby yourself from codeacademy/rubymonk, books, etc to give yourself a hypothetical advantage when eventually taking the coding challenges? Or will they expect you to be able to solve all the problems they give you during the interview with only the knowledge contained the prepwork? 
Thanks this was really helpful, I have one other question: It seems just from going over the first few practice problems that there are easier and shorter ways to do them if you have a more in-depth knowledge of the various Ruby methods, since the knowledge in the prepwork they give you isn't that comprehensive. Is it a good idea to try to just learn more of Ruby yourself from codeacademy/rubymonk, books, etc to give yourself a hypothetical advantage when eventually taking the coding challenges? Or will they expect you to be able to solve all the problems they give you during the interview with only the knowledge contained the prepwork? 
Can you share your code for review?
One of the great unsung innovations of Ruby 2.*x* is [refinements](http://timelessrepo.com/refinements-in-ruby). Never, ever do brute-force, world-mangling monkey-patches again.
To demonstrate the power of Ruby, beyond what is normally done with the language, check out https://www.github.com/kobaltz/rotor. It is a gem that I wrote to control servos and motors for a CNC project that I am working on. Pictures: http://imgur.com/a/B7wEy Video: CNC Plotter - Raspberry Pi Logo (Third Plot Attempt): http://youtu.be/-XWgvHnS8a0
I actually just changed my Monkey-patches to use DelegateClass instead, I was getting some weird behavior where my monkey patch was actually creating a new Class
We do share some gems, so maybe it's in there. Thank you for the insight.
Sinatra is a lot of fun and can make very basic or very involved web applications. I LOVE Sinatra! The cool thing is that this will not only get you more familiar with Ruby as a language, but also with the basics of routing on the web (which is important to use larger frameworks like Rails) You can quite literally make an app in only a few lines that actually DOES STUFF. It's so cool :) Check it out: http://www.sinatrarb.com/intro.html http://code.tutsplus.com/tutorials/singing-with-sinatra--net-18965
Sometime... I do that when using the pry debugger, I type stuff around, then make a typo and not notice that it was an actual command and now pry is asking me for a file name to save some output or whatever. 10 eternities later, I discover that a file *nil?* has been added to my repo because yes, I also *git add .* and not always review the commit. I feel better with this off my chest.
Ha. *Somehow* that file still hasn't made it's way into VC yet. Just checked now and I also have a file called `stdout` that's a dump of my Redis log. Programming's weird.
Is that the provided solution? Because it's not at all idiomatic. There's a lot of ways to crack this particular nut in Ruby, and most of them are one liners. Here's what came to my mind first: def longest_word(sentence) sentence.split(/ /).sort_by { |word| word.length }.last end Another way would be this, but I don't think it makes as much sense to a beginner (but read up on the spaceship operator anyway): def longest_word(sentence) sentence.split(/ /).sort {|a,b| b &lt;=&gt; a }.first end And one more as a bonus: def longest_word(sentence) sentence.split(/ /).reduce {|a,b| a &gt; b ? a : b } end
You can also do `string.chars`
awesome_print is awesome indeed :) 
Looks like everyone missed the fact that there is a number of obstacles to preserve... Reminds me of the joke about there being two hard problems in programming: cache invalidation, naming, and off by one errors. Fellow ruby noob here. I wrote a proof of concept for 1.9.3; some lazy structure features were introduced in a later version of ruby, but I thought it was a fun exercise to implement my own. I felt that your Point class deserved to be a useful data type in its own right, so I implemented a minimum set of object comparison features for flexibility of use in many situations: class Point attr_accessor :x, :y def initialize (x,y) @x, @y = x, y end include Comparable def &lt;=&gt;(other) # This definition is a simplistic hack; there is more mathematically sound point comparison cmp = self.x &lt;=&gt; other.x cmp.zero? ? self.y &lt;=&gt; other.y : cmp end def eql?(other) (self &lt;=&gt; other).zero? end def hash self.x.hash ^ self.y.hash end end random_points = Enumerator.new do |results| min_x = 1 max_x = 10 min_y = 1 max_y = 10 range_x, range_y = (min_x..max_x), (min_y..max_y) loop { results &lt;&lt; Point.new(rand(range_x), rand(range_y)) } end num_obstacles = 100 random_points.take(num_obstacles).sort.uniq.each do |x| p x end Points are a more complicated subject, though; how would we extend this to support 3D points? Maybe we should name this class Point2D. What about any dimension? What benefits should we get from having a dedicated Point class over Arrays or Structs (tuples)?
Interesting article - it's nice to see common bits of ruby examined in more depth than I'd normally bother to read in the documentation. However, I'm not entirely convinced by the "use case" that's given: expect(result.first.error).to eq(RefundNotAllowed.new) Instead, why not just do something like: expect(result.first.error).to be_a_kind_of(RefundNotAllowed) ([rspec docs](http://apidock.com/rspec/Spec/Matchers/be_a_kind_of)) - and then your whole problem of using the #== operator is gone!
I don't think there's anything ruby (or probably even tk) specific about this. AFAIK, you're going to want to use the win32api to send certain messages to explorer. IIRC, minimizing to the tray is not a real function; you actually want 3 independent actions a) minimize the window, b) prevent it being listed on the taskbar, c) create a systray icon with whatever behavior for your app.
i think there's a bug when the limit is 3 million instead of 4 million. for 4 million, the last number in array is greater than 4 million, but it's odd (5,702,887), so it doesn't get included when summing the even numbers. but with 3 million, the last number is greater than 3 million (3,524,578) and even, and it incorrectly gets added into even sum. 
You shouldn't split by a regex, it's much much slower than a simple string. The best solution was [already mentioned](http://www.reddit.com/r/ruby/comments/2twyhd/trouble_understanding_solution/co342h7), though personally I prefer using`length` for strings and `size` for arrays: sentence.split.max_by &amp;:length I agree the provided solution is horrendous, they're probably encouraging an imperative style so students understand what's going on 'behind the scenes', but it's just bad practice. Look at [this one](https://github.com/appacademy/prep-work/blob/master/coding-test-1/practice-problems/solutions/20-num-repeats.rb) for example... so many ways to solve it in one line I couldn't resist trying... (ruby 2.2.0+) string.chars.group_by(&amp;:itself).count{ |_, dups| dups.size &gt; 1 } It looks like they decided to solve [every problem](https://github.com/appacademy/prep-work/tree/master/coding-test-1/practice-problems/solutions) in python and just port 'em to ruby!
I still use them all the time, FWIW. I don't think most Rubyists will have a difficult time understanding if you declare an `attr_reader :foo` and manually `def foo= new_foo`.
If it comes from Phusion, I trust it, they create rock solid products. I wonder what the barriers are to making it work on Windows too? Would be a lot more useful to me if it could -- Windows is of course the hardest place for end-users to get ruby installed. 
The == definition is how I'd expect, I wouldn't expect two exceptions with different backtraces to be considered equal. If all you want to compare is class, why don't you do that? exception.class == SomeExceptionClass exception.kind_of? SomeExceptionClass # if a sub-class is okay, as it probably should be, except perhaps in testing exception.class == otherException.class 
Does anyone have any examples of this being applied in the wild? I'd love to look over some more examples.
If you're using Postgres, I recommend using [que](https://github.com/chanks/que) as it already has priority levels baked in and you don't have to risk losing important jobs w/ the Redis alternatives.
Do you have any data about one vs the other? I've been looking to use redis for an application of mine that I haven't quite built, but if que is more reliable, I'm not sold on redis.
What version ruby do you use? It works here. 2.1.2 :001 &gt; earthquake_ Richter_scale = [1, 5, 9.1, 9.3, 9.5] =&gt; [1, 5, 9.1, 9.3, 9.5] 2.1.2 :002 &gt; 2.1.2 :003 &gt; earthquake_ Richter_scale.each do |power| 2.1.2 :004 &gt; j = 10**((1.5 * power) + 4.8) 2.1.2 :005?&gt; gj = j/1000000 2.1.2 :006?&gt; puts " Richter level #{power} earthquake = #{gj.round(3)} Gigajoules" 2.1.2 :007?&gt; end Richter level 1 earthquake = 1.995 Gigajoules Richter level 5 earthquake = 1995262.315 Gigajoules Richter level 9.1 earthquake = 2818382931264.449 Gigajoules Richter level 9.3 earthquake = 5623413251903.491 Gigajoules Richter level 9.5 earthquake = 11220184543019.652 Gigajoules =&gt; [1, 5, 9.1, 9.3, 9.5] 2.1.2 :008 &gt; 
My bad, I fixed it on the description.
Could you run in irb like me and post the screenshot like me? power is a variable, when you use a variable you must define it first.
[Imgur](http://i.imgur.com/fC0cpkc.png)
pry
What's wrong with dnsmasq? I've heard people using it with good results. Yes, RubyDNS can be used to do what dnsmasq does.
Nothing, its just rather heavy for some light-weight DNS remapping, and you have to set local loopback as a DNS server. Not sure if I could manage this without the latter hack, but I know that Pow does it, so it must be possible (or they use commandline tools to add the loopback)
Tomorrow I'll take a look through Pow's source code again. I've opened a few PRs that fixed some issues on Mavericks/Lion, and got them merged, so I'd imagine I could probably find it in there somewhere. Its just coffeescript, so its easy enough to read
Awesome, at the very least we can start thinking about how to add the functionality :)
I know a few in the NYC area. If you're interested, shoot me a PM and I'll help you get situated.
Just out of curiosity. Why did you decide to write a DNS server in Ruby? It seems like an odd choice of projects. There are a lot of very robust and well proven DNS servers out there already does this one offer something they don't? 
Not sure what you're trying to achieve with your example and in what context you want to apply it but you could simple define a method called "c" that lies in the same scope as bar. class Foobar @c = nil def c=(x) puts "got c = #{x}" @c = x end def foo(a,b) self.c = a + b end end &gt; f = Foobar.new =&gt; #&lt;Foobar:0x00000002a51728&gt; &gt; f.foo(1,2) got c = 3 =&gt; 3 But that's probably not what you meant?
Yes, it's possible, have a look at the binding_of_caller gem: https://github.com/banister/binding_of_caller. In your case, I think putting `binding.of_caller(1).eval('c = a + b')` into `bar` would work. Althrough, unless you have a very good reason to do this, it doesn't sound like a good idea.
This isn't really a DNS server, it can do that just fine, but it's actually just a general tool for processing DNS requests. For example, you can make a "DNS server" that responds to requests by looking up wikipedia. https://github.com/ioquatix/rubydns/blob/master/examples/wikipedia-dns.rb The original reason I started it was to make something both simple and flexible, I don't feel that is offered by any existing DNS solutions, which are mostly very heavy weight. RubyDNS is incredibly light weight and can do things that other DNS servers struggle to do. https://twitter.com/jkassemi/status/442048280768167936
[**@jkassemi**](https://twitter.com/jkassemi/) &gt; [2014-03-07 21:24:57 UTC](https://twitter.com/jkassemi/status/442048280768167936) &gt; Configure bind to overwrite TTL values from upstream responses: hours. Use rubydns: 10 mins. \#opensource is awesome https://github.com/jkassemi/zerottl ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I'll have to try that.
No my question was about injecting into the scope of the function.
That's a class level variable. I was looking for the local scope answer.
Again: *While I can see a few approaches to "inject" a local variable I can not see this ever being a "good idea"TM ; may I ask why you want to do that?* I replied as I did because your question sounds like one that a newcomer to programming would ask and it is seldom a good idea to hand a loaded gun to a child ;). If you really need to do this then [this thread](http://stackoverflow.com/questions/1356749/can-you-eval-code-in-the-context-of-a-caller-in-ruby) has some interesting discussion.
I tend to use `attr_whatever`s for the instance variables I have in the setup, as I think it defines the public API nicely. I tend to use small, single-responsibility methods, so there isn't often a need for a custom getter/setter. It also helps my OCD by keeping @ signs out of the code :) Here's a quick, dumb, contrived gist of what I mean: https://gist.github.com/revdan/fa6d16d667d1a4ca44ec
Any ruby firms in Miami Fl area?
doesn't work for me :( it shows - stream now found. Anyone else?
The following links show, how it is down with Python: http://stackoverflow.com/a/758422 http://www.blog.pythonlibrary.org/2013/07/12/wxpython-how-to-minimize-to-system-tray/ http://www.brunningonline.net/simon/blog/archives/SysTrayIcon.py.html You have to port it to the corresponding Ruby wrappers for e.g. wx or qt
Where are you located?
If you rely on the API, your tests are not really tests, because they depend on the status of the API. If you have no internet, those tests will not work. Your tests should only test your own code, not the response of the API. Construct the tests in a way that the requests to a specific uri always results in the same result, so you can actually test.
You could put the key information in environment variables, set that to be default, and instruct your gem's users to set those.
I know a few folks who have had success on Hired, and I'm currently trying it out next week. Here's my [referral link](http://join.hired.com/x/93NygT) (or it's just hired.com if you prefer the non-referral variety). I've also heard great things about [AngelList](http://angel.co) for Ruby devs looking for startups. Feel free to orangered me if you have any questions about either. If by some stretch you live in or are willing to relocated to North Carolina, I could hook you up locally as well. (No, I'm not a recruiter. Just a rubydev.)
[Ansible](https://github.com/ansible/ansible) is an open source product under the GPL v3 license. It can be used to manage nodes from cli. The product they charge you for is Ansible Tower, a web based GUI that you can use to manage up to 100 nodes. 
Aha, thanks for that. Not very obvious on the website.
That's right. On the very beginning I also thought that is a paid tool, but eventually it occurs to be totally free. Paid is only Ansible Tower which is UI management tool for Ansible.
Look into the "vcr" gem. It's a wonderful bit of tooling. 
I used Ansible for a bit. But now with Chef 12 the snazzy new management console is free for 25 nodes. 
Remember that your credentials can be saved in your .bash_history if you do it through the commandline.
I am on the verge of switching to ansible from puppet, but someone I look up to very much suggested saltstack. I never know the right answer in these situations. 
True, and that's my normal methodology for code that is alright with missing values. In this case we did actually want an exception to be thrown, though (as it will prompt an alert email to the customer service folks that can fix an obvious missing detail in the customer records). Most of these specific issues were related to a customer not having a company rep tied to their account (which, in the real world, is a huge issue).
You are right - it's easy to abuse "try". Especially, I don't like "train of tries" - post.try(:user).try(:address).try(:street)
That assumes that you have ActiveSupport. If you do not you can whip up your own version of the [NullObject pattern](http://devblog.avdi.org/2011/05/30/null-objects-and-falsiness/) or you can use a somewhat ugly solution only using Hash#fetch: some_hash.fetch(:attr) { Hash.new }.fetch(:attr2) { nil }
Nice write-up OP! Here are some possibly helpful additions that I've learned in the field: In cases like #5, I like using [ActiveRecord enums](http://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html) instead. They're more efficient than the equivalent string representation and they also automatically define some handy scopes and whatnot. For #7, you can actually future-proof references to models in your migrations if you duplicate their class definition in the migration. Andrey Koleshko has a [good blog post](http://railsguides.net/change-data-in-migrations-like-a-boss/) on how this works. 
I have to disagree here. Deleting migrations is more work and more error-prone than just [future-proofing](http://railsguides.net/change-data-in-migrations-like-a-boss/) them.
[This]( http://www.eriktrautman.com/posts/ruby-explained-blocks-procs-and-lambdas-aka-closures ) is a pretty good explanation. They are both anonymous functions with different abilities.
Sorry, are you disagreeing with me, or with the article? I think we're in agreement: there is NOT a problem with using code in migrations; it's much simpler than the proposed alternative (rake tasks); and there are some simple tactics to not screw it up (like that gem you linked to). I think we agree :-)
I did it! I think. Here's my new code: require 'JSON' hash_of_words = {} text = File.open('birdbook.txt').read.downcase.gsub(/[^\p{Alnum}\p{Space}]/, '').split.each do end text.each do |n| if !hash_of_words.include? n hash_of_words[n] = 1 else hash_of_words[n] += 1 end end puts hash_of_words.to_json.gsub(/[,]/,",\n")
If you have a copy of the pickaxe book (Thomas), it covers them pretty well.
Doesn't "try()" just perpetuate bad design?
Thanks for this - was a very useful blog post, and I shared it with my classmates. I think I hit at least half of these in the past week alone!
How about? def self.next_trains 
i am trying to turn this into a gem, i would need a module so the user would not need to instantiate the class to make API calls. Also, with this implementation i can't make that standard call that i see in all api wrappers WMATA.api . 
i guess i could turn all the methods into class methods but i have seen that it is better practice to use module so maybe i can include later other piece to that module too.
&gt;Again: While I can see a few approaches to "inject" a local variable I can not see this ever being a "good idea"TM ; may I ask why you want to do that? Because it's there? I mean why not? As long as there is a clear contract I don't see what's what's wrong with it. &gt;I replied as I did because your question sounds like one that a newcomer to programming would ask and it is seldom a good idea to hand a loaded gun to a child ;). do you really think a noob would know enough to ask such a specific question? 
Don't want to thread jack but I'm also searching for places in Southern California
I never considered deleting migrations, thinking about them as "immutable". Now I see it was a wrong assumption. You are right - I can delete migration the same as I can delete Rake task. This is an added value of writing a blog post - I learned a new thing!
actually yes, because it's a very unusual thing to do
`fetch` takes the second argument and returns it if the key wasn't found: some_hash.fetch(:attr, {}).fetch(:attr2, nil) That's a tad easier to read. I don't see the point in using `fetch(:key, nil)` though, since it's equivalent to `[]`.
yeah, I disagree with #7, "write a rake task then delete it" makes as much sense as "write a migration then delete it". Writing something like `Post.migrate_to_new_structure!` and using that from a migration is the best option for me, and has the advantage of allowing you to actually unit test the code. 
&gt; +1 binding_of_caller is a work of genius . . ;) Or a twisted mind I'd say ;)
Why would you prefer `WMATA.api = "xxxx"` over your current implementation (`#initialize(api_key)`)? Mutable global state is just asking for trouble.
I'm in Greensboro, actually. I have family in Charlotte but nothing on the business side. Sorry!
You wouldn't delete a schema migration, you would only delete the part which migrates existing data (e.g. `full_name = first_name + " " + last_name`). Removing schema migrations is indeed a bad thing to do since `schema.rb` and the `db/migrations` files will get out of sync.
I've never been a fan of require farms. Why is that even a thing? It feels much more natural to require what you require where you require it.
That's because "the right answer" really depends on a number of variables unique to your project and your organization. It also changes over time.
Nice! What is the `gsub(/[^\p{Alnum}\p{Space}]/, '')` for?
Hehe, I like the term "require farm".
Zed Shaw, is that you? /lol
Zing!!!!
Good arguments. Yeah, it also came to my mind that you could forget to require a dependency, if it's already required somewhere else. That's why it's good to do isolated testing, where you only require the class you're testing. But in general I don't think it's important if you forgot the require. One place where I find that the "require what you require" approach really shines is ActiveSupport. Because they follow that convention, you are now able to easily require any part of ActiveSupport, without requiring the rest. There are errors, however, Rails team sometimes forgets some requires, so sometimes PRs are needed. I think this approach in general helps you to keep what depends on what in your head. It's starts to be really important in larger codebases. Then you might also want to reach for `autoload`, which is dead simple to do when you follow this convention.
My point is, the two have co-existed for more than a decade, and both have a strong personality. And his reply proved my point. He didn't know about him. Not because Tim hasn't built a book called Learn xyz the hard way that it means he's a nobody. Which he kinda implied. 
If I came across as arrogant I'm sorry; I didn't mean to. Both have done a lot of good stuff. I just wanted to point out that Zed Shaw isn't the only one with a strong personality.
Looking at you, [httparty](https://github.com/jnunemaker/httparty/pull/321)
Not everyone uses bundler? For me personally, if I'm sitting around high on caffeine and decide to build something like this, it's easier just to whip up a quick gem, then have to go through the politics of getting a new feature merged.
Well, a key problem is that if it's JRuby it won't work with NMatrix. So ideally, yeah, either pure MRI/YARV, or relying on client–server architecture, or something like that. In other words, I suppose if it were client–server, the client could be JRuby provided the server is pure Ruby.
&gt; a) does no harm, If I am testing a single class in a file that requires something I can require the file in my test_file and only load what I need to instead of loading a boatload of other stuff that slows down testing or possibly interfere with the testing. In the above I either have to (A) require the main file which requires everything and the kitchen sink or (B) do the requires in my test file. 
You should check out the statesman gem. The devs are very responsive and the code in very good IMO. I've used it w/o issue in my projects for ~ a year now. https://github.com/gocardless/statesman
How's this? def divide(x, y) x.send("/", y) end Sheesh. Was trying to think outside the box.
This worked for me: def divide(a, b) num = a counter = 0 while num &gt;= b do num -= b counter += 1 end counter end I'm still pretty new to ruby so not sure if this can be simplified. 
Your answer is absolutely correct, but this is essentially a homework problem. Even worse there answer to your question should be obvious. Simply declare a variable, i (iterations), to 0. Then enter your loop conditionally enter your loop (x &gt; y; the dividend is greater than the divisor). With the block simply subtracts x from y and increase I by 1. At the end of the loop, you have i which represents the quotient, x is now the remainder, and y is still the divisor. Also, the modulo function is, both, cheating and can't possibly give you the correct answer. Modulo uses the division function (so cheating) and then it throws away the quotient to return just the remainder.
We're talking about integer division, right? Sure hope so, because floating point division would be a real bitch to implement. Anyway, lots of ways to do it. Some of them good, some not so good. Here's a *terrible* one, but it's at least functional programming style! def divide(x,y) (1..x.to_i.abs).group_by{ |q| q % y }.values.map(&amp;:size).min.to_i * ( x*y &gt;= 0 ? 1 : -1 ) end Note that this doesn't handle negative numbers *quite* correctly, since Ruby handles integer division with a negative result by flooring the floating point result, but whatev.
You can do this pretty easily and not too inefficiently by repeatedly doubling the denominator (left shift) until it is too big, then half it (right shift), subtract, and try again. If you count the number of doublings, and add them together when you subtract from the numerator, you can compute the number of times the denominator goes into the numerator and your left with the remainder. An implementation and overview is here: http://www.codeotaku.com/journal/2010-08/rsa-encryption/index 
 def divide(x, y) x.send(47.chr, y) end FTFY.
You could always implement long division. That would only require modulus and subtraction.
&gt;There's never any such thing when you violate language level conventions which is why heavy meta-programming dependent code can be a bit of a head scratcher to debug at times. If a language has a feature then using that feature is not a violation of it's conventions. That's like saying you should buy a car with a trunk but never put anything in it. Every feature of Ruby was put there by the designers on purpose. They are there for you to use. Who are you say that they should not? What if I decided if statements were evil and went around telling everybody they are evil because use if statements? How can you rail against meta programming when virtually every ruby gem has some meta programming it it? Honestly who are you to tell me what I can and can't do? Take your sanctimonious church lady attitude elsewhere dude. 
&gt; Every feature of Ruby was put there by the designers on purpose. There's the answer to your question - you're asking to do something which (for most Ruby versions) requires a C extension in order to traverse the YARV stack. i.e. this is NOT a feature of the language. &gt; What if I decided if statements were evil Then I'd advise you to look at a functional language, because, [they can be]( http://stackoverflow.com/questions/1554180/why-is-the-if-statement-considered-evil). &gt; How can you rail against meta programming when virtually every ruby gem has some meta programming it it? Who's railing? It's a simple statement of fact that code that relies heavily on meta-programming is sometimes less straightforward to understand. &gt; Honestly who are you to tell me what I can and can't do? Take your sanctimonious church lady attitude elsewhere dude. To quote *" may I ask why you want to do that?" "Because it's there? "Perfectly acceptable and more power to you then."* MINASWAN
Thanks for the info! Will give Hired.com and AngelList a shot! I've also pm'd you. 
It's the coder equivalent of a Dad Joke. It's harmless, but still makes you cringe.
&gt; you're asking to do something which (for most Ruby versions) requires a C extension in order to traverse the YARV stack. i.e. this is NOT a feature of the language. Do you know how many gems use a C extension?
That's immaterial - a gem using a C extension is not a language feature.
Oh.. I'm so glad that didn't start it's own thread.. :) Thanks. I see this is your hobby. 
&gt; I guess I've pretty much trained my brain to deal with the vast quantities of unnecessary output from many Unix programs Which really is unfortunate since 'silence is golden' is one of the [core parts of the unix philosophy](http://www.linfo.org/rule_of_silence.html). 
awesome response
Looks awesome - I don't see a reason to assign a to variable num though. Other than that this is exactly what I was looking for - thanks!
Definitely leans towards clever coding as opposed to best practices, but still some good reading. Thanks!
`a` isn't reused though, so you could decrement that.
Nice! This is what I came up with: def divide(x,y) (1..x.to_i.abs).each_slice(y.to_i.abs).collect { |n| n if n.length == y }.compact.count end I'm not sure if it works. 
And the world will ignore your hypothetical gem. And this one. If there was a bundler flag at least somebody would use it.
Is anyone else bothered by the fact that this gem has an annoying post install message?
Tim needs to switch to decaf.
We're hiring: http://mojotech.com/jobs
soo... https://www.youtube.com/watch?v=4_RJu_TrqO0&amp;feature=youtu.be&amp;t=8h6m40s ?
FYI: I've also started a [Jekyll Theme of the Month series](http://planetjekyll.github.io/themes) @ Planet Jekyll - the first entries include: #2015.1 - Poole and #2015.2 - Shiori. New theme entries welcome.
So especially because even self-admittedly, &gt; It’s a bit of a quick hack I think it's a good idea to stop advocating these types of approaches by creating and publishing examples of it. IMO, if the change was _that_ temporary and isolated, then just code the conditional into the scope of the `if` statement. If soft launching is to be a permanent feature in your app, then might as well do it right. (Which, btw, would be a post I would love to see an example of.)
http://rubular.com/ it's a lifesaver.
Count me in the "just load all the damned gems once" camp. For my side projects, I develop out of a pry console, where all my gem dependencies are loaded. When I want to run the tests, I then have a test runner fork, load my code, and run the test suite. You should not be spraying code that couples to gems all over your codebase, but I don't need training wheels anymore to avoid doing that. Having the extra `require` boilerplate on each file is annoying and stupid when you are already mindful of your dependencies. The big win of this setup is that you can typically run your entire test suite with very minimal overhead. When you do the "explicit" requires, you can get really fast test feedback for *one* file, but seldom for the whole suite.
quick question, what do you mean by power user?
*I also think my != nil is wrong* Rule of thumb: any time you can say if foo != nil you can and should say just if foo —that actually means the exact same thing, because if you're testing whether something is nil, anything but nil will return non-nil.
Rollout is a pretty good library for this https://github.com/FetLife/rollout
... This actually made me wtflol. Isn't this what IRB and console is for?
I took your requirement at face value, that every *letter* in your string should be surrounded by plusses, and I looked for strings that were NOT that case. Basically, I formed a regex that looks at the left and right side of letters for no plus or end-of-string. str.match(/((^|[^+])[A-Za-z])|([A-Za-z]([^+]|$))/).nil? By the way, if you really do not want to keep the captures, you can use "?:", as in /(?:remaining regex)/. Also, this may be a more readable approach: str.match(/ ( (^|[^+]) # Left of letter is start of string or nonplus [A-Za-z] # Letter ) | # OR ( [A-Za-z] # Letter ([^+]|$) # Right of letter is end of string or nonplus ) /x).nil? 
First thing to do is sign up for NYC-rb: http://www.meetup.com/NYC-rb/. I've been a member for a few months and never actually been to a meetup due to constant schedule conflicts, but there are very regular emails to the entire group that discuss different aspects of finding work. There are discussions about how to improve a resume or get experience and fairly regular messages from people seeking both jobs and team members. I found my current job from one of these emails and I wasn't even looking for something! Beyond that, though, the classic responses: Github, StackOverflow, personal projects. Make stuff, interact with people, do as much as you can. When you're just getting started, code you've actually written and shipped is so much more valuable than a resume. Get on Twitter. It's a great way to see what other people are working on and interact with people who have shared interests all over the world. There are a lot of NYC devs on it. You can find me as @subvertallmedia if you're looking for somewhere to start. More than anything else, though, just... code because you love to do it. Push yourself, learn as much as you can, share when it's appropriate, make friends in the community for the sake of making friends, and be awesome for the sake of being awesome. The tireless pursuit of doing cool stuff combined with a genuine interest in others leads to success more often than not, as far as I'm concerned. Oh yeah, if you're at all interested in the graph database Neo4j, I'm leading a class on using it in conjunction with [Neo4j.rb](https://github.com/neo4jrb/neo4j) tomorrow night up near Times Square. [http://www.meetup.com/nycneo4j/events/220034049/](http://www.meetup.com/nycneo4j/events/220034049/). It'll be all (or at least mostly) Ruby devs and totally hands-on, so it'll hopefully be a cool experience no matter what.
Rubular is an even tighter feedback loop since it reacts immediately. IRB you have to keep hitting up-arrow, edit, return or similar.
It also has a list of the common characters for those of us mere mortals who don't memorize regex's.
I'm a beginner, Rubular is really helpful.
I am of the opinion that JS should be written in a more functional style. Trying to write JS as an OO language can get hairy quick. 
In Denver I think Sendgrid is hiring and they are a great company to work for. Worth checking out for sure!
So we both agree already about the hackiness of the solution, that's good :-) I would argue the following though: - just hard-coding the IF statement wouldn't have been the same. I wanted to be able to "unlock" the feature without re-deploying code with all its overhead. So I pulled out the customer IDs into something external to the code. In this case Heroku environment variables seemed a perfect fit. Could as well been something more sophisticated but that wouldn't have gotten me any more customers. And I've done 15 minutes more work of making it reusable at least for a few other cases and not having it hard-coded on the spot, especially since the code around it was actually proper production code and not a hack. So, this was a very straight shot to the simplest solution that worked for me for this very moment. - I think if we want to make such a general statement as "stop advocating these types of approaches" we should define a bit of a context for that. If we're talking about proper software engineering and architecture and design and all, be my guest, yeah, stop advocating it. We have done this in a startup, very early stage, where we wanted to iterated quick and cheap. Doing it "right" (from an engineering POV) didn't feel like the right call in the situation. If that makes sense. Having said all that, I'd love to see better examples as well (which is also why I'll tahnk JustingCambell below now for his framework link, hehe)
i am not an expert as well but i would start like this: (\+[a-zA-Z]){count}\+ so you capture every + Letter combination count times then only the last + is missing...
Actually, I see what you mean. I don't know if it seems that way from that blog post, but I didn't mean that each file should strictly require *all* of its external and internal dependencies. External (gems) yes, but internal (parts of the current gem) not strictly. I would like to take [Faraday](https://github.com/lostisland/faraday) for example. Instead of lib/faraday.rb requiring everything, I think that e.g. it should require lib/faraday/adapter.rb, and lib/faraday/adapter.rb should then require all Faraday adapters in lib/faraday/adapter/*.rb. Each adapter will inherit from `Faraday::Adapter`, but they don't need to each require lib/faraday/adapter.rb. I was just against having all requires in a single place.
The regex you put down is essentially saying if q is there, return that you found q else return saying you didn't find anything. so q followed by anything or nothing will match. As /u/vsalikhov mentioned, the shortest regex for this is /\^(q|quit)$/
Anchors! Of course I needed anchors! Thank you for the fast help, friend!
A simple explanation like this is the best starting point, I think - you can worry about the details of procs vs lambdas, etc, later. As a simple example, suppose I have: NOW = Time.now puts NOW sleep 1 puts NOW Then the constant *NOW* is set, and cannot be changed unless I redefine it. So both *puts* statements print the same thing. However, if I did this: NOW = -&gt;{Time.now} puts NOW.call sleep 1 puts NOW.call ...Then the function *Time.now* is getting **re-evaluated** each time. In other words, you can dynamically call and re-define functions inside your code. The example above is not exactly a "good" use case for this; it's purely to demonstrate how a lambda can be used. Here's a real-world (Rails) example in a bit of code I rote the other day: validates :attachment, file_size: { maximum: -&gt;{max_file_size} } I used a lambda here, because *max_file_size* is not a constant value; it depends on which type of user is saving an attachment. By using a lambda, and evaluating it at run-time, I can effectively "re-define" the constant in this validation.
It it *possible*? Yes, with some crazy binding.of_caller hack. But you almost certainly **should not be going this**!! If you write code like this, without a very good (very unusual) reason, you're going to confuse the hell out of other developers reading your code. It's not "clever" to write code that no one understands! Use a return value, or a class variable. Maybe, in some very rare cases, you'd need to use a global variable, or an environment variable, or whatever. But don't use pointless dirty hacks like this, or your co-workers will all hate you.
There are some great resources available to you, such as Shiraj. Shiraj is a group thats been here in NYC for several months at this point, but has already amassed an ardent following of students. There is usually a wait to get seen, a couple of students tend to monopolize the time, but definitely worth it in the end. Also, Ashi Ashi Ashi, Oy Oy Oy. I can't say it enough. Huge JS resource.
Definitely go to every meetup you can find, especially for the groups that focus on your languages and technologies of interest. These are where you will meet startup founders, fellow rubyists, and the like. Approach these as a chance to learn, to share your passions, and only then to find a job. You'll be much happier if you go in there with that mindset, as every single meetup will be a success for you. I'm currently looking to move to NYC as one of my potential next steps, and believe me when I say that I wish I had the ability to just go to the meetups and network (currently in NC). As someone who works in Ruby and wants to make the jump to NYC, there is no better place to find potential openings. Best of luck!
Using a 'case' statement didn't even cross my mind, and using '.downcase' is so obvious now that I see it. Thanks for the advice!
Interesting idea for a gem - thanks for sharing.
&gt; Now you have a ton of code strewn all over your codebase, gems you don't need, and a bloated database. What do you do? Spend hours to carefully remove all of the changes you made? Sorry, clients don't really like spending money for you to do things that don't result in another fancy demo at the next executive meeting. So you do what a lot of programmers (myself included) typically do: leave it. Sure, you might comment out a route or remove a button in a view, but that's it. The "feature" remains, lurking beneath the surface like a hideous creature, just waiting to leap out and bite a chunk out of you or another programmer when you later come along refactoring code and cleaning up cruft. Wow. What is this? The 70's? $ git status -bs ## master $ git checkout -b feature-a # hack, hack, hack... uh-oh. need to focus on feature-b! $ git checkout - $ git checkout -b feature-b # work on feature-b Who the hell comments out code these days?
I made a ping pong table in-use detector for my office. Now that a more powerful version has come out, I may rework it to have better accuracy. The pi took in audio samples, processed them, and displayed whether or not it thought people were playing on a web page it hosted. I called it the Raspberry Spi. Unfortunately the USB ports got stripped out by people tripping on the microphone cable, causing it's untimely demise. Rails App: https://github.com/jusroberts/rails-sound-spy Audio processing gem: https://github.com/jusroberts/spectrum-analyzer
Quite an unusual, but very cool application that was developed for the original Raspberry Pi, but worked better with a faster processor - so it will be interesting to see what can be achieved using RP2! http://sonic-pi.net/ The code you write is actually all just ruby, with lots of clever stuff going on behind the scenes for threading and perfect timing.
I have a friend who insists there should be a "λ" key on every programmer's keyboard.
Awesome. Have to give it a try myself now.
Thanks for the word of assurance and pointing to your gem file.
This is quite interesting. Had no idea about this. Since ruby is primarily used in web app development along with rails, hence was skeptical as to how powerful/ easy it would be to use with pi. Thanks again.
this is really neat! 
When I write an object that collaborates with some piece of code outside the project, I tend to make it pretty obvious, e.g. `class RedisAdapter`. Spraying references to a constant defined in a gem like`redis` throughout a project is almost always poor design practice.
You don't need to count patterns, you can do this all in one regexp. First you need some example that will match and some that won't so it's clear in your head what you are trying to match. First lets assume that by letters you mean [a-zA-Z] and nothing else. Good patterns: +a+ +a++b++c+ Bad patterns: ++a+ &lt;An empty string&gt; +a++b+c+ a+b+c+ +a+b+c &lt;Anything with a newline&gt; The regexp that matches these is: /\A(\+[a-zA-Z]\+)+\z/ \A - Start of pattern, don't use ^ which is start of line as you may have newlines ( ) - group this stuff into one sub pattern \+ - a literal '+', without the backslash '+' is a meta char. [a-zA-Z] - a class containing letters in lower and upper case. + - One or more of the preceding thing. \z - End of pattern, don't use $ which is end of line. You want: str = &lt;The string under test&gt; if str.match(/\A(\+[a-zA-Z]\+)+\z/) then true else false end Edit: Thanks for messing with my formatting reddit. 
&gt; For stuff like this, it sometimes becomes best to leave the RegEx at home and actually loop through the string, because the RegEx can get too confusing. /\A(+[a-zA-Z]+)+\z/ is not too confusing.
This is cool and I dig it. Your readme needs a little more information. The pic is nice but isn't really showing me anything other than an update to date system. Cool none the less. From a code standpoint you should be able to abstract out some type of message service. I see a ton of calls like puts "#{Tty.red} - Skipped.#{Tty.reset}" this should be a helper that takes in a color and a message as params. maybe give the colors meaningful names by mapping "warning" to red and "info" to another color. I should be able to send the color or the type of message. eg: blotter('success', 'some message') or blotter('green', 'some message') and finally the [ruby class self idiom](http://stackoverflow.com/questions/2505067/class-self-idiom-in-ruby) is: class Whatever class &lt;&lt; self def cool_method cool_code end end end
 Or you could use \A and \z and anchors to match the start and end of the pattern. /\A(\+[a-zA-Z]\+)+\z/ looks more elegant to me at least. 
I'm not familiar with right_aws, but I'd need a pretty slick reason to go against an official gem as feature complete as the aws gem. I'll keep an eye on this thread to see if I get one.
This is my favourite example of what can be achieved with sonic-pi: https://gist.github.com/xavriley/87ef7548039d1ee301bb I genuinely think it would be possible to create some sort of "open source, community effort" top 40 single with this thing, which would be incredible!
One last thing; tests. I like the expressive nature of [rspec](http://rspec.info/) but [minitest](http://blog.teamtreehouse.com/short-introduction-minitest) is preferred. I guess...
The next things I would do are: * Move all your code into a *./lib* directory * Remove all the dirty monkey patches, like: . class String def undent gsub(/^.{#{(slice(/^ +/) || '').length}}/, '') end end (These can be fun to play around with, but shouldn't be put into "production" code! You can use things like [refinements](http://www.ruby-doc.org/core-2.1.2/doc/syntax/refinements_rdoc.html), or [delegators](http://www.ruby-doc.org/stdlib-2.2.0/libdoc/delegate/rdoc/Delegator.html), or just some helper function if you like - but try not to "pollute" the core classes!) * Wrap up the code into a ruby gem! This is actually quite easy to do; just follow [this guide](http://guides.rubygems.org/make-your-own-gem/). You can then configure bundler to create an executable script as part of the gem, meaning it can be executed from any location on your system. * Consider replacing some of your code with existing solutions - e.g. your TTY class seems to just be doing something like [this](https://github.com/fazibear/colorize). * **Write some tests!!** You can consider looking into tools like [Travis CI](http://guides.rubygems.org/make-your-own-gem/), and various test coverage/code analysis tools, if you want. * Publish your gem, making it much easier to install and use :)
Indeed, my day job as a Jr/Rails dev I should have started writing tests a long time ago, though unfortunately it was hard to get direction of the project until I built the majority of it. I'll most likely go with Rspec out of familiarity :)
 I am making a Simon game in Rails for my first project on the Pi. Here is a demo of it. http://instagram.com/p/yYjl6LkpUd/
https://github.com/cbarratt/mac_system_update/blob/master/rbenv.rb#L9 Isn't there a `cd` too many on this line? &gt; Open3.popen3('cd ~/.rbenv &amp;&amp; git pull &amp;&amp; **cd cd** plugins/ruby-build/ &amp;&amp; git pull')
Agreed. * Monkey patches are a big no-no in Ruby 2.0+. Instead, use *refinements*; there's a good write-up [here](http://timelessrepo.com/refinements-in-ruby); * Travis is cool if you can make it work; we've had better success with [CodeShip](https://codeship.com), who I now recommend enthusiastically. They're free for open-source projects; * Working with a Gem that *isn't* published (via RubyGems or wherever) is a royal pain; needlessly painful experience down on its knees begging to happen. It won't have to beg long. * Of course, a Gem that isn't visibly tested in an automated fashion (with good coverage and green bars), or isn't publicly deployed isn't going to get the use it might. Fool me once, shame on you... * Finally, "move all your code into a `./lib` directory" should probably be read as "learn and use Gem coding conventions, to make using your Gem as painless and consistent with expectations as practicable".
Yes, as it currently stands, it's no big deal - although I'd still encourage "best practices" such as using refinements. If nothing else, it would be a good learning experience. Furthermore, if this code is wrapped up into a gem then it may one day be used as a dependency of other gems - at which point you *definitely* shouldn't be monkey patching core classes without good reason!
Great spot! I need to get my work colleagues who use rbenv to run the script, fixed in latest push
you just did that nvm
Not familiar with both, but just in general I would choose the official gem for 2 reasons. 1) it has a higher chance of not being dropped as a side project. B/c it is their own product. 2) They will continue to support and fix issues as they arise. Also be helpful in debugging if you face something weird. 
Thanks for the tips! So far I've moved it all into the lib directory - I will look into fixing it all up into a gem and using correct file structure. I'll get onto using a refinements for the string hacks, appreciate the direction on that one! I've just stripped out all the Tty hacks (which were actually stolen from Homebrew, and now using colorize). Tests coming soon :D I'll pipe them through CircleCI
https://gist.github.com/t0nyshier/671785e0350994156885
Was also curious, so looked into it. first off, right_aws is deprecated in favor of right_aws_api - looks similar though. The first commit of right_aws is from 2007, whereas the amazon gem wasn't released until 2011. I'm guessing that this is a legacy project that the company is continuing to maintain b/c they needed to build it prior to the amazon gem existing. The docs mention that the gem is really just a lightweight container around the actual calls, meaning the calls just get translated into routes and the actual data sent is whatever you give it. That's probably why the gem continues to work and isn't too much work to maintain, since amazon versions their api by date, your calls would just continue to work based on the data you sent. I'm not a fan of that approach, as I enjoy abstractions as long as I'm confident the abstraction will be maintained for me (which in the aws case it will be since it's an official gem). I don't like having to know the actual API syntax and would rather just let the gem worry about setting permissions, etc... for me. Also, I always want to be using the newest API endpoints, and since I"m just using the abstractions, I can let amazon worry about translating that into the appropriate api calls. so there's my 2 cents. Legacy project that was written well enough to warrant not having to swap it out for the company that's officially maintaining it. I'll stick with the official gem.
Thanks! Just the answer I was looking for. I guess aws gem wasn't ripe yet when the decision was made to use right_aws. I think I'll switch to aws if it won't cause too much trouble, and will definitely use it for upcoming features. Cheers
Yeah, `autoload` is really fuzzy in my head. They wanted to remove it because they couldn't make it thread safe, but I have a feeling that I read somewhere that they managed to fix it and it's staying.
i'm sure! apparently I was the one who came off as arrogant :-(
Personally, i would _not_ use the new gem for upcoming features while keeping existing code using the old gem. Both gems at once gives you too much to understand, too much to debug, too much surface area. Either switch the app to use the newer gem, or keep using the older one consistently. Is what I'd do. 
Thanks. I use all of those myself, so this will be handy! If you don't mind, I'll jump in and contribute if I spot something that I can help with.
Looks to be the use of Refinements changed a lot over the course of Ruby 2.0 -&gt; 2.1. I'll go back to the drawing board and go back to using it differently! Sorry about that
True, but if we have to start dodging interstitial punctuation or spaces, we have a problem. It all depends on OP's problem domain.
Very cool. I'd be interested in setting one of these up in our office. Can you give any more info on what you did to get this setup? What mic/parts should I buy? Thanks!
Well thank you for watching and providing feedback. I practice as much as I can before recording, and I record many takes. But, like all coding, keeping mistakes from slipping in is tough. Also, I agree that typing code can be an arduous way to convey information. Sort of makes you wonder why, after 70 years, we still program with massive strings of text. I believe Lisps hold the next step, and Clojure is a great place to start. If you're interested in learning Clojure in a more familiar screencast format, I would recommend LispCasts' Intro to Clojure series: [http://www.purelyfunctional.tv](http://www.purelyfunctional.tv).
Great! This is an awesome tool. I tried a few things out and I see that my `{count}` doesn't work with the regex. I'm trying to figure out a way to use regex a certain amount of times, where the amount of times == my variable count. 
Thank you for your input :) The only thing is that I need the regex to test for all the letters in a given string where the string can contain multiple symbols, letters, and spaces. Just a jumble of everything x.x
In that case, I would say that (just) regexes are the wrong tool for the job. In one sentence, regexes are best at matching regular language patterns. There are a lot of string patterns which are not ["regular" in the formal language sense](http://en.wikipedia.org/wiki/Regular_language), e.g. XML and HTML. While your string is technically regular, it's not "regular-like", so the regex you'll need is pretty convoluted. (Something like, `/\A([^a-zA-Z]*(\+[a-zA-Z])+\+[^a-zA-Z]*)*\z/`, but I didn't really check my work too deeply) My suggestion is to use the `String#split` method with the regex `/[a-z][A-Z]/` and handle the three possible cases instead, which'll make for more readable code too. **edit** Actually I think that regex should work. Main parts of it are: * `[^a-zA-Z]*`, twice, allowing anything not letters * `(\+[a-zA-Z])+\+`, the only place letters can appear * `\A()*\z`, whole string must match the inside pattern repeated any number of times Still, unless you/your team consider it particularly easy to read and understand, might be worth avoiding.
I believe the point about mixins was that it would be easier to remove (if the feature was killed or postponed), or at the very least it would all be contained in a few files/locations, rather than scattered across the existing core models and controllers in your codebase.
I like to write an integration test first with capybara then TDD each model to make the capybara test pass. I literally just go error message to error message. Once i get everything passing commit and refactor. I think if you are actually TDDing you have a leg up on most devs out there. 
Well, that may just inspire me to give Clojure another try. :-)
 #I am going to make this call which will inject a,b,c into the namespace of this funtion do_something_and_inject_binding(:a, :b, :c) puts a, b, c Voila! Confusion ended 
&gt; Remove the need for .new in Ruby. You should probably never use this. At least he's honest about it :P
When I saw the title I thought the article would be about creating your own types in Ruby. I was intrigued because Ruby code doesn't generally worry too much about the type as long as the object has the right method. This leads to problems like the one that the author had. I guess that I was assuming what he was talking about, but I want to share something that I realized after reading the article. You can create your own "typecasting" methods just like the built-in ones. I tested this code, and saw that it worked: class Type &lt; BasicObject def initialize *args @var = args.to_s end def main "I am a new instance of Type created with #{@var}" end end def Type *args Type.new(*args) end object = Type("test",1,2,3,nil,Object.new) puts object.main #&gt;I am a new instance of Type created with ["test", 1, 2, 3, nil, #&lt;Object:0x160&gt;] This example is useless, but demonstrates that you can have a class and a method with the same name edit: I just saw another post to this subreddit which links to [newk](https://github.com/justincampbell/newk), which automatically creates these methods for you. I would not want to use this for every class, but there are many times when it might be useful to make your syntax cleaner. 
&gt;If you need to write a comment to explain how the code works, you should probably write different code. If I have to write comments then yes I am presuming you can't understand it. &gt;What happens when you do this 30 times in a project? Write 30 comments? I guess I do if you can't understand what is going on. &gt;What happens when someone renames variable c but doesn't update the comment? How is that my problem? &gt;What happens when some obscure change to the core ruby library next year breaks your code, and it requires some complex back-end changes to fix? You change your code. Obscure changes to ruby can break any code. &gt;Just don't do this. Not unless you have a really good, exceptional reason. Things like this are fine to play around with, but should never be put into "real" code. I think I'll do it just to piss off guys like you.
I actually like seeing fun messages like that. Only if they keep it to 1 line max.
If you took away sterile, precise and efficient... You would have PHP.
Also, and perhaps a more interesting question, why *not*? In other words, why does Ruby *not* work this way already?
In my experience all of these (`Array()`, `Hash()`, etc) have corner cases just like the one the author mentioned regarding `Integer()` at the end of the article, which render them unreliable and thus kinda useless - i.e. there is no safety without 100% use-case reliability.
Because some classes define a class method #() to do something other than new. I guess that's not really the 'why', since if ruby had been written to use #() as a constructor instead of #new, then of course no classes would define #() as a class method to do something else. It's just kind of arbitrary whether the constructor is called #new or #(). I don't know why Matz chose #new. Because he didn't want ruby to end up being too much punctuation and looking like unreadable perl? Does smalltalk use `new`? Who knows, who cares, but I think `new` is probably more readable and understandable than `()`, perhaps Matz just agreed. 
In this case, his unit tests still exersize a class, it's the `Authentication` class, isn't it? In this case, test-driven development led him to create a class that he might not have created otherwise -- and creating that class was good design, that led to a class existing at the proper level of abstraction. I agree this is good design and good testing practice, but it doesn't actually illustrate "not a class", it's still a unit test suite covering a class. Rather it illustrates defining classes at the proper level of abstraction for composibility, DRY, and law of demeter. (I do agree that it sometimes makes sense to write a test suite that isn't focused on a particular class, and I don't really care whether you call that test suite 'unit' tests or not -- test what it makes sense to test, sure.)
Does it matter? Class or function, the result is the same - an object is created and returned to the caller.
&gt; I find just using ||= to be more readable and _less error prone_ That's true until some values are `false`.
This is the type of stuff I think should be in the Readme. Stuff along the lines of what ruby is this compatible with. 
As u/vsalikhov alluded, you cannot define a class method with parens to mimic this behaviour. Instead, you define a method on Kernel with the same name as the class. Although Array() and Hash() are defined in C, you can still see where they are defined with the method method: &gt; Array(nil) = [] &gt; method(:Array) = #&lt;Method: Object(Kernel)#Array&gt; So, how you define a similar method is: class Person; end module Kernel def Person(*args) Person.new(*args) end end
Don't try with `sudo`. Using rbenv allows for you to use a ruby and rubygems instance that is not global.
Apparently you don't work on inherited codebases very often. :) If you're lucky enough to work in an environment that understands Git branches, does Agile/sprint planning, etc., hats off to you!
Exactly.
One could debate which method is "all that jazz". Your way is an excellent way to accomplish the task. It could simply be a matter of prefference, clarity of intent, and experience.
This is not recommended. 
How does the solution in the OP help with that situation? We are talking about a value that is expected to be either nil or an array. If it ends up false instead somehow, I believe the solution in the OP will also break. 
As a Ruby→Clojure convert, just saying thanks for getting more people interested. Clojure sure is gaining a lot of Ruby users, though. For example, Russ Olsen, of Eloquent Ruby fame, now works for Cognitect, which is the company backing Clojure and Datomic.
agree. use `rbenv or rvm`. sorry for the wrong information 
I assume the deleted comment was regarding your typos, and was rude and obnoxious. Sorry about that. There's no need to be an asshole when criticizing something. That said, I do think that you would benefit from typing practice. I've noticed that my own typing has become much more error prone lately so I've started to use a typing test in emacs. It's definitely helped. Typos do happen, but they don't need to happen *that* frequently, and frankly I did find it very distracting while trying to watch the screencast.
I've built my first one last month. The hardest part was to come up with an idea.
I empathize with the mistakes being distracting. For a bit of backstory, I went past the length of the background track three times before this take. And I think you can see my frustration when I rushed through the introductory comments. I find my typing accuracy suffers most when I don't give myself small pauses to think before starting to type. (I also think there's an interesting parallel here, regarding how people speak) Once I'm warmed up I hit a better pace and spend the appropriate time resting instead of frantically backspacing. I think these little pauses are also beneficial for the pacing of the material. While I feel it's important to present a mastery over my material and tooling, I'm also interested in how human it is to see mistakes and feel that frustration through the screencast. While many have empathized with this, feeling similarities in their own software, others have found it distracting. I don't think that a take has to be flawless in order to be worth using. That said, I strongly agree that this screencasts has too many typos. As the saying goes, slow is smooth and smooth is fast. Thank you for your thoughtful feedback, I've taken it to heart and I'm working to improve the pacing in future screencasts.
Awesome, thank you!
Without even knowing which country you pay taxes in, it's impossible to say.
The US.
I find that "complex example" *very* difficult to visually parse. With that small example, I would prefer this refactoring: def parse_dir(dir) mp3_paths = Dir.glob("#{dir}/**/*.mp3").map { |p| Pathname.new(p) } mp3s_by_playlist = mp3_paths.group_by(&amp;:dirname).map do |dirpath, mp3_group| parent_dir_name = dirpath.basename.to_s m3u = parent_dir_name.parameterize("_").to_s + ".m3u" mp3_file_hashes = mp3_group.map do |mp3_path| { path: mp3_path.realpath.to_s, filename: mp3_path.basename.to_s, } end [m3u, { files: mp3_file_hashes }] end Hash[mp3s_by_playlist] end Also, since this is likely to get more complicated and/or the containers get really large (as I'd expect the production code would), why not avoid the deeply nested "array-of-hashes-in-an-hash-in-a-hash" structure in favor of dedicated, serializable `Playlist` and `Mp3Path` classes?
Sort of related: is there a canonical way to build a gem from a source release of a ruby project? Like the equivalent of './configure &amp;&amp; make'. It seems like every project has a different process, which makes things like packaging difficult.
The use of the `Pathname` methods (`dirname`, `basename`, `realpath`) were just to avoid raw string manipulation of paths, since doing so is sometimes problematic (worrying about windows/unix slashes, improperly formatted paths, symlinked/relative paths, etc). What remains is just the conversion of ruby code from the "iteratively append to initialized container" form: results_arr = [] results_hash = {} data_source.each do |data| results_arr &lt;&lt; data.process results_hash[data.get_key] = data.process end where you have to worry about whether or not `results_hash` and `results_arr` are properly initialized, which is the whole point of the blog article. In its place, I'm proposing a way to avoid that problem altogether with the "map collection of elements" form: results_arr = data_source.map(&amp;:process) results_hash = Hash[data_source.map do |data| [data.key, data.process] end] *addendum The hash in the original example is used to group together files from the same directory. I use `Enumerable#group_by` instead.
dont you have to do a "gem build &lt;name&gt;" before you publish it?
gem build &lt;repo&gt;.gemspec Anything more than that is typically unnecessary. 
You can itemize training as a work expense. Only makes sense if your total itemized deductions is &gt; the standard deduction though. One year I bought a Macbook, upgraded my PC, started playing with a dedicated server. It came out to more than the itemized deduction, so I got a bigger return than with the standard.
I can relate, even if I don't particularly agree. RSpec has its warts, and it's easy to argue that being presented with a `Widget::Thingie::Dunsel::Frobulator::Kitchen::Sink::Drain::Expediter#twiddle!` in error dumps indicates that you've lethal conceptual problems in your design, but still. I'm going to do my next project using `MiniTest::Spec` and see if that brings enough of what I love about RSpec (highly expressive BDD specs) while not forcing me into a continual mental context shift between RSpec-like BDD expression and `Test::Unit`-style nuts and bolts. It's the difference between "insert Tab A into Slot B; is Slot B occupied?" and "wave hands (because the test doesn't care how things are set up); is the assembly complete (and oh, by the way, for it to *be* complete, there has to be something in Slot B)?" It's a question of bottom-up vs top-down; of how you think about tests and code. Not saying that one's universally better than the other; I *do* mean to say that, once you've picked a paradigm, you should be able to immerse yourself in it without forced context shifts. *That's* the "ideal" tool that I still think *should* be buildable (by people better at that sort of thing than me).
I just finished the Codecademy Ruby course... and I have no idea what this is. How do I use these resources? What can I make with them? 
Get the $299 Bundle for only $49! Seen here: https://www.railstutorial.org/#pricing $299.00 HTML, EBOOKS, SCREENCAST VIDEOS, ALL PREVIOUS VERSIONS The full Ruby on Rails Tutorial screencast series (3rd edition) DRM-free copies of the 3rd Edition Ruby on Rails Tutorial ebooks Free copy of the Solutions Manual Copies of all previous versions of the Ruby on Rails Tutorial ebooks (Rails 4.0 version, 2nd edition, 1st edition, Rails 2.3 version) Copies of all previous editions of the Ruby on Rails Tutorial screencasts (4.0 supplement, 2nd edition, 1st edition) Over 2000 pages of content and over 40 hours of video Crazy deal! Get it [here](http://www.appsumo.com/~ozQqd/)
Will do thanks!
Good stuff! I've joined the chat :)
Yeah, that sounds good. My ruby-toolbox usage has devolved to "what were apparently-popular alternatives to (this very well-known Gem) a few months/years ago?" This gives me at least that much information, concisely and clearly. I've also found a couple of new items for my "check this out" list in a few minutes of browsing Awesome Ruby. It's been a *long* time since that happened on ruby-toolbox.
It doesn't matter what your work environment is. If you can install git on your workstation, you can use it. That's the beauty of distributed version control. git-svn / git-cvs / git-p4 etc. exist for the external interface. The commands above are entirely local. edit: unless of course your code isn't in *any* repository. in which case it doesn't exist so there's no issue :P
Also it tends to be surprisingly out-of-date a lot of the time.
It's been a while since I browsed through the Codecademy course, but I believe they just cover the rough basics of Ruby. Gems are pretty much scripts and libraries that people have made in order to make it easier to get some stuff. It allows you to code without having to reinvent the wheel and allow great modularity. Here's a couple of resources, that may help you get started with using RubyGems. * http://guides.rubygems.org/ * https://www.digitalocean.com/community/tutorials/how-to-work-with-the-ruby-package-manager-rubygems-getting-started * http://www.gotealeaf.com/books/ruby/read/preparations#whatarerubygems
Here's a trick for you: puts %w[Draw Loss Win][rand(3) - gets.to_i.pred] Just using the input number to index the array, with the random number modifying which of the three is chosen. Wrapped up to resemble your code: puts "1. Rock\n2. Paper\n3. Scissors" opts = %w[Rock Paper Scissors] score = {draw: 0, rng: 0, player: 0} while %w[1 2 3].include? gets.chomp player = $_.to_i.pred rng = rand 3 result = %w[Draw You\ lose You\ win][rng - player] score[score.keys[rng - player]] += 1 puts "Player: #{opts[player]}\nComputer: #{opts[rng]}" puts "#{result} - #{score[:player]}:#{score[:rng]}" end There are many ways to write this, I did it this way to show off the concept.
&gt; If i learn ruby or rubymotion am i destined for only webapps? Rubymotion isn't used for writing webapps. It's for iOS apps.
I definitely agree with this. Perhaps shockingly, I am also a fan of BDD, as well. On some projects I throw this in `test/test_helper.rb`: Minitest::Test.singleton_class.class_eval do def should sentence, &amp;block method_name = "test_should_" method_name.&lt;&lt; sentence.gsub /\s+/, '_' block ||= -&gt;{skip} define_method method_name, &amp;block end end With that one method, I feel I get enough of what I think is fantastic about BDD, without adding any complexity to plain test unit style testing: class UserTest &lt; Minitest::Test should "authenticate a username/password combination" do # ... authenticated_user = User.authenticate "realntl", "password" refute_nil authenticated_user end end I find I can look at that sentence and see the "opinion" expressed by it. The implementation details of the test are documentation for the *how* of the object, and the test name itself is a documentation of the *why*. I am invited to challenge that "why", and ask myself, "well, *should* the user object be authenticating username/password combinations?" In this way, practicing BDD helps me realize "oh, right, authentication shouldn't belong to the User object. That's an SRP violation." When I discover that I disagree with the opinion expressed in the specification, I know I can delete that test with confidence. To me, the expression of the specification of your interface in the form of opinionated sentences is actually fantastic, and one of the things I have come to dislike about the tests written by inexperienced rspec users. Something like this: describe User do describe ".authenticate" do it "authenticates against a username/password combination" do # ... expect(User.authenticate("realntl", "password")).to be_a User end end end The actual sentence that gets spit out by rspec (through the assertions) ends up mixing up the implementation details of the test with the broader "sentence" describing what it does. In reality, you can use rspec to practice BDD, but you have to ditch a lot of the "best practices" that have cropped up. I would do this in rspec: describe User do it "should authenticate a username/password combination" do # ... end end In the end, the value of BDD isn't in syntactic sugar or DSLs; it's a mindset, first and foremost, and then a conscious decision to align our use of tools with that mindset. Anyways, I appreciate your thoughts.
I need to tell an interesting story here: On July 3, 2014; there were two "awesome-ruby" projects launched and pushed on Github: Serdar's (https://github.com/Sdogruyol/awesome-ruby) and Marc's (linked above). There was no communication between them but in the same day, within 2 hours (here are first commits of both projects): &gt;commit 693*** &gt;Author: Serdar *** &gt;Date: Thu Jul 3 13:33:50 2014 +0300 (**10:33 GMT**) &gt;commit 97f*** &gt;Author: Marc *** &gt;Date: Thu Jul 3 14:31:18 2014 +0200 (**12:31 GMT**) I was contributing Serdar's project, during search on Github, I recognized Marc's project. I've confused that both projects started in the same day. Then Serdar &amp; Marc have communicated each other about this situation, after some discussion, both decide to go on their way. I've made some contributes Serdar's one, it now stuck about 600 stars. I think, Marc have promoted better than us and he has more time to contribute his own list. So, he's about 3k stars.
We're looking for remote Rails devs at Cyanna (http://cyanna.com)
&gt; Im in schhol for computer engineering anf realize its largely hardware oriented or uses C for software programming. At the vast majority of higher education institutions, Computer Engineering is going to be primarily hardware-oriented. In terms of the code you'll be writing, most of it will probably be written in Verilog or VHDL. If you are studying embedded systems, then you'll probably write some good old C as well. There aren't a lot of higher-level languages involved with computer *engineering.* If what you really love is writing software, you might be tempted to switch to the Computer Science department at the same institution. Be aware, though, that at most institutions, the CS department is primarily focused on the *mathematical theories* which underpin how computers work -- set theory, Turing machines, information theory *a la* Claude Shannon, number theory, complexity, algorithms, etc. If you want to go far in a CS department, you'll want to be comfortable writing out abstract mathematical proofs. If you're more of a hands-on, applied-knowledge kind of guy, you might not be happy in the CS department. So if you can't study software in the CE department and you can't study software in the CS department, what's a software guy to do? Well, first of all, don't despair. Just because neither of these might match your wishes exactly doesn't mean you can't have a great career in software with a degree from either department. I myself got a degree in Computer Engineering (with an emphasis in Embedded Systems) and I've been working on large-scale enterprise web applications ever since, so don't fall into the trap of thinking that what you're studying now will be what you're doing for the rest of your life. If you don't *hate* the work you're doing in school, you don't *need* to change majors in order to have the software career you want eventually. (If you really want to study only *precisely* the things you hope to do for your career, you might be better served by a programming class at a technical college -- but you'll be a more well-rounded, more employable developer if you stick with either CE or CS as a major, even though neither of them may be quite your cup of tea.) Now, regarding Ruby specifically: Ruby was designed from the ground up to be a remarkably versatile language. Certainly, the popular Rails framework for web applications is the "killer app" that drives a huge portion of the Ruby community, but it's also often used as a scripting language, it has been used to develop desktop and mobile apps, and is usually pretty easy to apply to other fields as well. There's almost no practical limit to the number of problems that you could solve with Ruby. However, Ruby is a very-high-level language, and it needs a ruby interpreter to run. That interpreter program relies on the low-level kernel and driver code on the system to handle any interactions with hardware. So it doesn't make sense to try to write those low-level interactions in Ruby, because to run a Ruby program at all, those low-level interactions must already be present and working. Also, much of the power and elegance of Ruby comes from how easy it is to abstract away the gritty details of what you're working on. Most of the code you'll write if you're working with embedded systems *needs* to deal with those lower-level details, so even if you *could* write embedded code in Ruby, it wouldn't be the best choice. For these reasons, Ruby doesn't really meet the needs of Computer Engineers. It's a little bit like bringing a linear-accelerated, supercharged nail gun to the table when what you really need is just a hammer. **TL;DR:** You won't be using Ruby in your Comp Eng classes, no. But if what you want in the end is to be using Ruby in your career, sticking with Comp Eng may still be the best way to get there from here.
It could be various sites automatically mirroring any new gems?
Got it down to 12 lines (with all the previous logic) http://pastie.org/9890424 hands = %w(ROCK PAPER SCISSORS) lc = { 'h' =&gt; 0, 'cpu' =&gt; 1 } c = { 0 =&gt; 0, 1 =&gt; 0, 2 =&gt; 0 } lr = 1 puts 'Choose: 1. ROCK, 2. PAPER, 3. SCISSORS, other: QUIT ' while [0,1,2].include? h = gets.chomp.to_i - 1 cpu = [lc['h'], rand(3), [[0, 1, 2] - [lc['h'], lc['cpu']]][0]].flatten[lr] lr = (h - cpu - 2)%3 c[lr] += 1 puts "Cpu: #{hands[cpu]}, Player: #{hands[h]} #{%w(CPU NOBODY PLAYER)[lr]} won. [CPU: #{c[0]}, Drawn: #{c[1]} Player #{c[2]}]" lc = { 'h' =&gt; h, 'cpu' =&gt; cpu } end
I'm at work (and on reddit, like everyone else ever), so I'll try this later, but I do love the idea of modeling real world stuff in programming languages. My first real Java course in college was modeling and rolling a pair of dice to prove 7 was the most common number rolled. 
I actually just wrote an article on this as well, to be posted on the Engine Yard blog sometime this month.
&gt; Then it got merged and suddenly Kevin the unicorn wanted to be friends. What does that mean?
I don't even know what that means, what's wrong with Lambda in python? Care to elaborate? Edit: I'm not against Ruby or any other language, I just feel more comfortable with Python.
It's just a silly joke.
I can live with that. Thanks for the clarification. 
Thanks a lot! 
Yes, an excellent point. It's just in the past few years that Software Engineering has begun to be recognized as its own fully-fledged engineering discipline by a handful of educational institutions. (As usual, the engineers figured out what was going on about three decades before management did.) If you're lucky enough to be at one of those schools, it might be the best bet. Or not. It's a little early yet IMHO to tell how well those programs are doing at molding young engineers.
Can you link to your PR?
actually... please get started on `Rake::TestTask`. I use my own test task from Hoe, but maybe it is time for it to move over to Minitest and provide more/cleaner functionality. Where does Rake's task fall down for you? Where does it excel?
Have you filed an issue? (hint: no)
test/unit was undetermined order. AFAIK, minitest was the first test framework in wide use (in any language?) to default to random order.
Good timing - [this gem](http://www.reddit.com/r/ruby/comments/2uwuug/content_management_for_jekyll_blogs/) (also on the front page) is a CMS for Jekyll.
Hi guys, we, Bear Metal, have been working on a solution for GC tuning - https://tunemygc.com . Works with Ruby 2.1, 2.2 and Rails. Instructions for getting started with the agent: https://github.com/bear-metal/tunemygc#tunemygc---optimal-mri-ruby-21-garbage-collection What Discourse looks like without tuning: https://tunemygc.com/configs/c5214cfa00b3bf429badd2161c4b6a08 How we made it better: https://tunemygc.com/configs/e129791f94159a8c75bef3a636c05798 - the cubs
Can you provide some examples? That sounds super interesting. I do something similarly. I wrote a wrapper that generates sql queries for me from ruby templates. Works great, took minimal effort. Ruby for life.
You could, for example, have a group of digital engineers who write VHDL with comments that are parseable by a script they use into an XML document that describes the interfaces they're designing. That XML document now needs to be used by different software groups that use the the FPGAs and what have you to create a nice interface to the hardware. So the XML could say "Register X" has bitfields Y and Z. Bitfield Y is strobable. Bitfield Z is settable and clearable. So now we can automatically generate code that allows us to use a C function like registerXfieldY_strobe(). Instead of having to write, by hand, register access functions for every single one, for every bitfield, with every enum you might be interested in defining for valid values for a given settings bitfield. I hope that's a little more explicative.
I see. The way Ive been doing it is to store my parameters of interest in an excel spreadsheet, then I have my code generate SQL based on those tables (I copy paste them out of excel so theyre tab delimitated at that point). I could see how I could just easily storage the params as a JSON/YAML or similar markup. I thought you were talking about a specific tool, you were just illustrating a mindset. 
Certainly not a publicly available tool. :/ Just about as specific as I'm comfortable getting. It's really not all that different than what you're talking about though. Just instead of SQL, I'm generating C that makes interfacing with custom hardware tons easier and instead of tab-delimited files I'm yanking all the object creation data from XML representations of hardware.
Nope, but what is its advantage over using Jekyll? Have you used it?
Hi, [websocket gem](https://rubygems.org/gems/websocket) author here. I'm using several different implementations on large scale applications - from commercial [Pusher](https://pusher.com), cross platform [Socket.IO](http://socket.io), popular [Em-Websocket](https://github.com/igrigorik/em-websocket) all the way to in-house implementations of [client](https://github.com/imanel/websocket-eventmachine-client) and [server](https://github.com/imanel/websocket-eventmachine-server). Each of them have different strong and weak points and application type they target - I don't think that there is one tool for all situations. If you're interested in understanding protocol and how everything is working then I would advise starting with as simple solution as possible - complex tools like Pusher and Socket.IO hide large part of protocol under their API and fallbacks. Sure - you will have it working, but probably without learning as much as with starting from scratch. Unless you have some deadlines of course ;) For learning from scratch there are [getting started article](https://www.igvita.com/2009/12/22/ruby-websockets-tcp-for-the-browser/) (by Ilya Grigorik - author of Em-Websocket) and [little more advanced](http://www.slideshare.net/ismasan/websockets-and-ruby-eventmachine) (by Ismael Celis - part of New Bamboo team, guys behind Pusher). You can also find nice examples in each websocket-related project ([1](https://github.com/igrigorik/em-websocket/tree/master/examples), [2](https://github.com/imanel/websocket-eventmachine-server/tree/master/examples), [3](https://github.com/imanel/websocket-eventmachine-client/tree/master/examples), [4](https://github.com/faye/faye-websocket-ruby)). As for question "which of mentioned tools is best" I honestly can't say - all of them are doing their job well (and sometimes I'm handling pretty insane amounts of data). I would say just ask yourself what you need - something simple and requiring zero-maintenance? Use Pusher, optionally with [open source server implementation](https://github.com/search?q=pusher+server) if you have something agains giving your data to third-party. Want to be in control? Use one of mentioned open source server/client implementations. In any case please don't hesitate to ping me if you have more questions.
&gt; so it's important my URLs match, and/or had proper redirects I had this exact same problem before migration. So, I wrote [this](http://pastebin.com/vv41S3xP) small redirection `php` script on my existing server, so it will forward existing *indexed* urls to my new blog adding `.html` at the end.
Now you can do all of that, but from web!
Every website needs a Web-Server. That's what makes it a website. A Jekyll generated site has no explicit web server since it's just a bunch of static files. But it expects to be moved into some web server provided by some hosting provider for it to start working online.
Does a complex framework really help fighting complexity?
I'm glad you find my article useful!
This isn't golfed, just the way I would write it. hands = %w(ROCK PAPER SCISSORS) count, prev_choice = { won:0, lost:0, drawn:0 }, { } cpu_result = :drawn puts 'Choose number: 1. ROCK, 2. PAPER, 3. SCISSORS, other: QUIT ' while (choice_human = gets.chomp.to_i - 1).between?(0, 2) choice_cpu = case cpu_result when :drawn; rand(3) when :won; ([0, 1, 2] - prev_choice.values)[0] else; prev_choice[:cpu]; end cpu_result = case choice_cpu - choice_human when 0; :drawn when 1, -2; :won else; :lost; end count[cpu_result] += 1 print "cpu chose #{hands[choice_cpu]} \t", "human chose #{hands[choice_human]}\t", "cpu #{cpu_result} \tCPU: #{count[:won]} Player #{count[:lost]}\n" prev_choice[:human], prev_choice[:cpu] = choice_human, choice_cpu end 
That is so cool :)
prahladyeri was comparing Ghost with Jekyll on account of a node.js server. I was simply pointing out that turning a bunch of static pages into a full-featured blog requires a web-server. NOTE: Also found this project which allows one to have a ghost UI along with the simplicity of static-pages deployment model [Reference](https://github.com/axitkhurana/buster)
I thought it was a choice (i.e. like not having a colored output formatter builtin) not a bug, so no I didn't. Do you want me to?
Yeah- I saw ActionController::Live and was not too impressed. From what I've been hearing though, most folks are using frameworks other than Rails like EM-Websocket, Faye and a couple of others too.
Yeah, a big part of Open Source is just creating a solution for a problem you can't find a solution for online, and then sharing said solution.
The idea sounds good. Gonna bookmark it and tell myself to check it later, which I will, probably, I think....
I think the key difference is Sinatra and Padrino allow you to make those convention decisions yourself, where as it seems like in Rails if you started going in your own direction you'd be fighting Rails the whole time.
It's a good sign that it's the Clean Ruby guy doing a DSL handbook. "Clean" isn't always the first word that comes to mind for DSLs :-)
Yes, let's decrease the Wordpress population, but not kill anybody. ;) (decrease/decease typo) Great work!
Authoring content in Jekyll has been painful, having to keep filenames, permalink dates, etc in sync. This looks promising!
I remember using Em-Websocket in Rails, and it took about 30 minutes to configure and implement. Not sure it gets simpler than that. The application was not, however, a websocket-based app. I was augmenting the app with real-time features.
Hey can you tell me what tool did you use to create that GIF from a screen record?
I was literally just reading about static vs dynamic websites and ran into the following website for creating a blog using Github. [Jekyll bootstrap](http://jekyllbootstrap.com/) And the author went into explaining the difference of static vs dynamic and the benefits of static: [Static vs Dynamic Websites](http://nilclass.com/courses/what-is-a-static-website/) Sadly I'm not very savvy with tech yet and I don't understand all of it :( Anyways, I'm looking forward to building my own blog and starting up on github once I finish some of the prep work I have planned out for myself for learning programming :)
Yes please
[x-post from /r/voltframework](http://www.reddit.com/r/voltframework/comments/2v002o/ruby_rogues_193_the_volt_framework_with_ryan_stout/)
You don't need an automated test that walks through an entire "happy path" to be part of your automated test suite. It can be helpful for some to drive the *development* of a feature that way, though. &gt; So, where I would imagine you might write a view test that asserts that a submit button is on the page, and then write a controller test that asserts that the form was submitted correctly, we just write a feature test that submits the form. This, to me, feels pretty natural. It is natural if your focus is on testing the user interface, and your assumption is that there may not be any coherence between the objects your UI talks to and the UI itself. I operate from the assumption that there is strong cohesion between the two -- in your specific example, I write an object to represent the action taken by the application when you click submit button *itself*. The test for *that* object does not require a browser. Correspondingly, the presence of an `&lt;input type="submit" /&gt;` element on the page is now a concern of the *document* being used to represent the web page. It's not something that I get much value out of testing anymore. Once your UI is glued into your application through objects that *represent* that interface, you no longer need to exercise the UI in order to test your application.
I would say here are my problems with `Rake::TestTask`: 1. Rake itself is pretty slow to boot up. In most projects you'll also be forced to use the version of rake in the `Gemfile`, so you're paying the bundler tax, too. 1. If you have a `test_helper.rb` file, you typically add `test` to the load path so your test files can `require "test_helper"`. But then you need to add `-I test/` when you run tests via ruby directly. I end up wanting to specify individual tests via `export TEST=test/my_test.rb`. This is annoying because of the time penalty of firing up rake. It'd be nice to configure the test runner to always load a ruby file before running the test suite for setup purposes. 1. I use `-n /test_regex/` and `-s 23445` a lot. You have to export them through `TESTOPTS`. It's clumsy. 1. The `-l 42` thing in rspec is nice because I can tell my text editor to fire off the test that the current cursor is hovering over. I often add a `bin/test_runner` binstub to my projects just to invoke `Minitest.run` directly. In larger projects I'll usually invoke `Minitest.run` from within a pry session (reloading my code on the fly using e.g. `Object.send :remove_const, :MyProject`. After giving this more thought, I think my problems with `Rake::TestTask` largely stem from running it through `rake`. `Minitest.run` is designed to take in ARGV, so it is nicer to have a separate test runner invoke it directly instead of through rake.
I want to upvote this more than once.
 class Clock def self.set_to(x,y) new(x,y) end end
I agree. I really like padrino for that flexibility, and I have heard people complain that rails is too opinionated. I sometimes wish the Sinatra/padrino extensions community was bigger. 
Maybe I should rephrase it. Sometimes it comes down to using the right tool for the job. I feel like padrino is lightweight but maybe if I'd used rails it would do some heavy lifting for me. Like I said to the other commenter I wish the padrino community was bigger. 
I find it is generally simpler to use `OpenStruct` to double a query interface: dog = Dog.new(OpenStruct.new(:first_name =&gt; 'Santa', :last_name =&gt; 'Simpson')) assert_equal 'Santa Simpson', dog.full_name This does not require any stubbing at all. For commands, I either use a null object, or the command itself. That is a larger discussion, though. You have to be designing your command objects a certain way in order to be able to take this approach.
Yeah, you can't actually change the name of new, but you can define your own class methods to do whatever you want, and it's often reasonable to have one or two alternates to construct objects with different defaults or different sorts of arguments. Personally, if all I was doing was changing the name of the method, I wouldn't bother, I'd leave it `new`, because that's what rubyists expect. But if you do want to just make `set_to` an alias for `new`, here's another way: class Clock self &lt;&lt; class alias_method :set_to, :new end end 
Classes are not just storage containers for your methods. [Give this a read](https://en.wikibooks.org/wiki/Object_Oriented_Programming), it should help explain why classes are so important.
I don't think there is magic that applies to programming compared to learning other things - although learning a lot of it at once certainly can be overwhelming! The key to retaining things you learn, very broadly speaking, is to make sure you grasp the underlying concept(s) at work, relate those concepts to ones you already know about, and practice those concepts repeatedly. Unfortunately for the new student the full theory of programming and computer science covers a whole hell of a lot of ground - so even thought people may act like it is trivial, actually understanding everything that happens in a "hello, world" program is quite an undertaking. This is why there are a lot of math and theory classes that come along with a computer science education. So, in no particular order: * Don't beat yourself up because you don't "get it". This shit is complicated, even a "hello, world" has a ton of theory behind it. * Don't be afraid of repetition. You may have to write many similar "hello, world" programs in Ruby before the ideas stick. That is OK too. * Relate details to the theory as much as you can. Just as knowing the "rules" of chess can help you understand an almost infinite number of individual games, you want to know the "rules" of programming so that the individual programs end up making sense - don't treat it like a list of specifics to memorize, treat it like a set of principles to understand. * Don't be afraid to buy a few books. Programming is hard, your time is worth something, and spending a few bucks on a good book can make a world of difference. * Be consistent. If you are committed to learning how to program, make time for it every day, even if just a half hour. This keeps it from going "stale" as you work on it. * Consider other tutorials. You didn't mention which you actually tried, but if one tutorial or lesson just isn't helping you, [try another](http://learncodethehardway.org/ruby/). edit: I have no idea why^the^markdown^is^indenting^my^last^bullet 
Picked this up, enjoyed Clean Ruby. One gripe though, make one of the "Start Hacking" buttons read: Buy.
Ha! Looking "forward". Because he always writes about `Forwardable`! I lol'd.
If you can boot your rails app on jRuby I cannot recommend using Torqbox for web sockets enough. Torqbox wraps the JVM JBoss server in a great ruby interface. It offers full rack-support as well as clustering, caching, &amp; messaging. It also wraps a service called STOMP which is a web socket compatible service. We have had great success with it in large production environments. We also just love jRuby for all deployments!
Thanks for the screencast! Keep up the great work. I personally didn't mind your typos. It made you seem more human. Too many screencasts IMHO act like programming is some perfect art where no one makes mistakes. Just keep practising and you'll nail them soon.
The thing I've found is that no one learns from tutorials. Not really. Tutorials can help you pick up a big picture idea of things, can help cement ideas, or point you towards good tricks and best practices, and that's great. But most your real learning is going to come from trying to do something. Pick some simple starting project, and figure out how to make it work. If you haven't got any ideas, figure out how to write a program that takes an input in english and outputs pig latin. That's always a fun one. Once you've done that, write one that turns pig latin back into english. Make sure that you get the same thing back when you run both! Take a first, shot at the project on your own. You'll probably find it impossible. Now watch a good tutorial and try again. You'll do better. Those are tricky tasks for a first time programmer, and it might take you a while, and lots of time googling how to do things, but if you figure out how to do these tasks you'll have come a long way.
One reason people create classes is to give meaningful names to chunks of code and data so that you don't have to think as much while using that code. For example, let's say you have a library of code that knows about image file formats. Presumably you'd want to be able to ask a gif file how many frames there are. So image = ImageFile.new("some_gif.gif") image.frames =&gt; 38 may be a reasonable and meaningful bit of code if you've written the ImageFile class and the #frames instance method. But this is just one area where embracing OOP is useful/helpful.
Thanks &lt;3
The built-in solution includes the [net/http library](http://ruby-doc.org/stdlib-2.2.0/libdoc/net/http/rdoc/Net/HTTP.html) Gems that might interest you include Faraday and HTTParty
yea i have been looking at that. but I have no idea what to do even if i get the token. so i have some huge HEX string. then i send it back as a post request? the bla.post_to{} implies i know how many parameters to pass etc. 
If you want to be a Rails developer, get a handle on Git, SQL, a bit of bash in the unix console, a continuous integration system, and a familiarity with nginx and passenger and unicorn before you learn C. If you want to be really outstanding as a Rails developer get a good handle of Java as I've seen it required alongside Rails on job requirements as it's a good segue into Android development. Java is also stupidly common amongst CS graduates and people who might be interviewing you, it helps if you can speak their language--especially their non-Rails datatypes liked linked lists and binary trees...I've noticed interviewers LOVE bullshitting you with binary tree questions. You can learn the CS fundamentals that they might be expecting in almost any language. C is just too low level to be used frequently in Rails shops, and not enough people are good enough at Rails and C for it to be incorporated into projects often. C would be a nice foundation into Objective C for iOS development, but a shop big enough to be doing mobile development will have silo'd those two roles out. 
[prose.io](http://prose.io) has been around for a while. Found it useful, but had already switched to nanoc for personal stuff. Anything that avoids Wordpress has got to be a good thing. I have a bunch of essentially static sites set up for clients - converting them to Jekyll and throwing them octodmin doesn't look like too much of an ask. 
I would focus on JavaScript in addition to Ruby right now if I was you, for the obvious ROI reasons and relevance to web development. Learn it really, really well (not many do). Maybe revisit C when you have landed a job *and* are on top of things.
Level 0 appears to tell you how to get a token, and that you need to submit it on all subsequent requests in the form of a header. Whichever API helper library you use, including net/http, will allow you send an Authorization header, which is how that token is meant to be sent. From there, it looks like you just start requesting subsequent levels via that API. But I'm on my phone and only scanned the docs. Still, this seems pretty standard fare for an API based challenge, and may be an uphill battle if you're tripped up this early. All the info you need really is on that page. Edit: Woke up, came back to this and took a look. Ruby may be a red herring here, as it looks like the challenge can be done with a simple REST client instead of Ruby or Python, per the sample code. 
If you want to be a rails developer... C is not going to help you. Why? IMO its all the fucking DSL's. In rails land, the entire structure of the language will be different in your various source files, duck typing and metaprogramming. That's what you need to spend your cognitive load. Nothing C specific is going to help you. Context: started with C in the 90's. Work on rails now.
If you need a really basic way to interact with the API with a UI, try using POSTMAN: https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en I got to level 4 using this approach. But honestly, if interacting with the API is giving you trouble... you're in for some heavy #crypto #pain. I know Praetorian sets the bar pretty high. Good luck!
The single best book you could read is Sandi Metz's "[Practical Object-Oriented Design in Ruby](http://www.poodr.com/)". &gt; POODR will help you: &gt; &gt; * Decide what belongs in a single class &gt; &gt; * Avoid entangling objects that should be kept separate &gt; &gt; * Define flexible interfaces among objects &gt; &gt; * Reduce programming overhead costs with duck typing &gt; &gt; * Successfully apply inheritance &gt; &gt; * Build objects via composition &gt; &gt; * Design cost-effective tests &gt; &gt; * Craft simple, straightforward, understandable code 
Rake itself is not inherently slow. There are two things that often cause a big slowdown: having to load it through either `bundle exec` or a binstub, to avoid "you are invoking rake 10.2, but your Gemfile needs rake 11.2." That causes slowness proportional to the size of the Gemfile. The other thing that can cause a big slowdown is when you do something like load the rails tasks. (I think rails is at fault here, tbh, but it nevertheless is a problem) I have never recorded it, but switching from "rake" to a custom test runner has often saved me ~200-500 ms. Regarding the `--line` issue, I see that as a problem with `Rake::TestTask` because it's inherently less extensible than code that just invokes the test suite directly. I have written code to infer the name of the test from a line number. To combine that with `Rake::TestTask` I have to cause the task to depend on another task that then pushes the test name into `ENV['TESTOPTS']`. Is there any actual value in using `Rake::TestTask`? Something like this in `bin/test_runner` works fine for me (this is scratch code, but I've written it like a zillion times): #!/usr/bin/env ruby require_relative "../test/test_helper" Dir.glob("test/**/*_test.rb").each do |test| load test unless test.start_with? ENV['TEST'].to_s end Minitest.run ARGV It even has the advantage of letting you `export TEST=test/some_directory` to run all tests in a single dir. I believe `Rake::TestTask` forces your `TEST` variable to exactly match the name of the test. `minitest-sprint` looks great, though it seems to invoke `rake` behind the scenes. I used to program C a lot, and I like the idea of running `rake` by itself being analogous to the `make` compile step, but I'm not sure it really brings much value anymore. Are you open to a PR that replaces the use of `rake` with a more direct approach?
switching to C can be hugely demoralizing for a new programmer. tasks that you could perform trivially in Ruby/Python become enormous complex tasks. reading and parsing a file in C can easily be 20-40 lines instead of 2-4. you have to get every detail perfect and there will be at least 2-3 opportunities to have off-by-one errors. knowledge of C is important. some day you'll hit an issue where reading the source of the Ruby runtime or Apache will be extremely informative!
So what you're looking for here is to use httparty or something similar. You can use libraries like this to send and receive responses from HTTP endpoints (like this API). So for example the code to login in and get the first challenge could be require 'httparty' #This does an HTTP post to a JSON endpoint. Note that you need to change the body type to_json and set the content-type header login = HTTParty.post('http://crypto.praetorian.com/api-token-auth/', :body =&gt; {:email =&gt;YOUREMAILHERE}.to_json, :headers =&gt; {'content-type' =&gt; 'application/json'}) #The first response returns some JSON so you can parse it out with rubys JSON module response_body = JSON.parse(test.body) #This sets a variable to the value of the token auth_token = response_body['token'] #This line does a GET for the first challenge and passes the value of the token in chal1 = HTTParty.get('http://crypto.praetorian.com/challenge/1/', :headers =&gt; {'Authorization' =&gt; 'JWT ' + auth_token}) 
thank you! i just wasn't sure if i was doing it correctly so in that format a guess would be like this?... guess = HTTParty.post('http://crypto.praetorian.com/challenge/1/', :body =&gt; {:guess =&gt; "praetorian"}, :headers =&gt; {'Authorization' =&gt; 'JWT ' + auth_token}) and when this value in guess is correct it will automatically run the post to get the hash?. I am just not sure because when i try that with level 0 it keeps returning a empty hash {} even with one of their answers 
That stands. And it's also true the other way around. Switching from C to Ruby, Python, C# seems like a joke in terms of syntax.
The definition of the constant is in X::Constants so X::Constants::A is defined. Then in module X you include Constants so now X::A is defined. Your first example with ( X.new {A} ) is attempting to reference a constant at the top level.
One day I will buy you gold, thank you, this was huge. Now I'm in the process of cloning a repository off github and trying to work with it on my desktop. I find Terminal pretty confusing, but we'll see
it seems wrong though, there's a condition missing Choose number: 1. ROCK, 2. PAPER, 3. SCISSORS, other: QUIT 1 cpu chose ROCK, human choose ROCK cpu drawn CPU: 0 Player 0 1 cpu chose SCISSORS, human choose ROCK cpu won CPU: 1 Player 0 I'm not thoroughly reading your code, but I guess you need the opposite condition in line 12 as well (cpu = 2, human = 0)
You need a GUI interface using Visual Basic to track down the code. 
My apologies. Let's start where we should. You will need a code-aware text editor. I suggest you stay away from the more powerful stuff like vim and emacs for now, and just get something that works and is intuitive. I say you go with [sublime](http://www.sublimetext.com/) for now. You can use it for free for a time. Editors like MS Word, Pages, and other "rich text" applications are not code aware, and will not produce usable source code. Next, code lives in source files. These files are plain text files that contain source code. You use the editor above to edit them. Rails is notorious for using a lot of files, so it might be confusing. I would suggest you get more familiar with Ruby, and then learn a little about Rails. Both are easy, and it will pay off. Trying to fiddle with a Rails app before you know either of these, or git, or how to even use any of it, will simply confuse you. Git will help you keep track of changes made to your code over time. I'm told version control is hard for newbies to pick up, so if you find it confusing, just ignore it for now, and focus on the programming part. Github is somewhat of a social application build on top of git, that allows programmers to share and discuss code, as well as collaborate on projects. I know I'll get slapped over the head for this, but I like to think of Github as Facebook for coding nerds. To run a Rails application, you will need a server. Configuring a server is not hard, but considering the kind of question you're asking, it's probably beyond what you would want to learn right now.
Really, really, appreciate this post. Thanks man. Terminal is so foreign to me, visiting that link is the first thing I'm going to do. 
Both are text editors. They will both fulfill the the requirement of allowing you to effectively edit code. Where emacs differs from most other editors is its extensibility. You can manipulate the way it functions on the fly and become significantly more productive. I use emacs in no window mode meaning that I edit my code in the terminal. I find it to be the best place since it keeps you close to the other most important tool in any Unix operating system the terminal. If you want some more details about my personal set up I can give them, but some people think you should start slow. I think you might be jumping in a bit too fast as well which is not a bad thing it's actually great it means you are ambitious. Though I will say my way of programming is not the only way to do it, but I think I conform to best practices. 
Nice article. I agree pretty much . Although, I think someone could write a similar article about any language they like which has an active community. I think Ruby has a lot to learn from functional programming. We have a few FP features but there's no reason we can't have more. I haven't explored it much, but I often think "a monad could be used for this" or "this doesn't really fit in the object oriented paradigm but I don't want to swim against the current" As Ruby becomes more optimized on the JVM and Rubinius, I expect to see people taking it more seriously. Right now it's like "build the prototype in ruby and move to a compiled language of you need to scale" Many applications need static compiled code, but I think most do not. Ignoring the philosophical arguments, it would be cool if more people felt like Ruby was "safe" or "efficient" 
Much appreciated man! Yeah, I am confident that with the right guidance (and the great resources here with you guys) I'll be able to progress just fine. Just a few months ago I would have said "programming is too hard I'll never be able to do it" but I decided to tackle some things and I like the path I'm on. I'm not 100% sure if it will be my full thing (I am more on the business side of things) but having the knowledge and ability cannot hurt. Maybe I'll even see things others can't see. 
Yeah I'm with this guy. One baby step at a time. PS: do you personally use emacs? Is it something that I should consider in the future? I mean, at the moment, I can't see how one text editor can be so much better than another, but that's also due to lack of experience. I just don't get *what* could possibly be so much better about one over another
Thanks for the awesome information and thanks for maintaining the websocket gem!
Thanks man. Would "Console Foundations" apply just as much to Terminal (I use a Mac) as it would to Windows? I'm not sure how these things differ across operating systems.
Sorry if this is in the wrong place, if it should have been in /r/jekyll or perhaps /r/latex, I'll gladly move it. I'm the one who asked the questions, and as you can tell I'm about a week into Ruby. As the dev (inukshuk) has been very friendly, I don't think I should pester him anymore -- he's clearly answering the question, but I'm just not on a level where the answer makes sense. Of the options he mentions, I'd prefer the last one -- putting this into my BibTeX file. Any and all help appreciated.
I'm not sure if this is exactly what you are looking for, but: output = `bundle install` will store the STDOUT string as a variable.
Both don't work. So there is no easy solution at the moment to get it running at ruby &gt;= 2.x?
I have a Rails app that I can package with warbler to a standalone java app (jetty web server, h2database). I'm really excited by the idea of making small useful "web apps" and distributing them as executables to non-technical users!
you are really downloaded GitHub, wow … 
Thanks a lot. I thought that might be the case. I am extremely, pedantically in to organizing my code, so that shouldn't be a problem. I guess my worry would be that if I ever want to improve to a point where I'm actually collaborating with other people / contributing to anything except my own personal hobby stuff (lofty ambition), I'm going to have to learn Rails anyway because it's more powerful and what everyone uses, so perhaps getting used to something easier would be... coddling - lulling me into a false sense of expertise. Is that possible? Or else: even though they're very different, can folks reach a point of proficiency in Sinatra that actually helps them transition more easily to Rails, given that they're both, at least, Ruby web frameworks?
Wouldn't worry about it. All learning takes place as a sequence of progressions building one thing on top of another. Just because step one is easier than step two doesn't mean you shouldn't bother with step one. And yes, Sinatra will help transition you to Rails if you ever feel the need to make that transition. You may simply never need to.
(Also a bunch of tutorials that insist on getting you to set up your testing -- worse, with rspec instead of what Rails supports out of the box, worse still with things like `guard`. I'm in favor of testing, but I think this is the wrong approach for a beginner, too many different tools to learn instead of just learning _rails_. Learn testing with minitest and a non-rails project first if you want testing right away! Or, at most, in Rails using the testing framework _built into_ Rails, from the Rails testing guide at guides.rubyonrails, instead of rspec and guard and factorygirl and all that rigamarole)
It's great to hear you think I started in the right order. I found rails so disheartening that I thought maybe it had actually been a mistake to learn ruby first! Regarding your suggestion of building simple crud apps and then systematically adding new features - this is exactly how I've been learning ruby, and it's worked really well. It seems like with rails it's really hard (for me) to even get to the first stage to start building up from though.
As sporkmonger said, this isn't something you should be worried about. If anything, learning Sinatra may make you realise how much Rails does behind the scenes - things like asset pipeline, ORM &amp; activemailer builtin. Personally, I tried to learn rails a few years go, didn't get it, over time did a couple of small projects in Sinatra, and now have come back to love Rails for client work.
I hear what your saying. I think ruby not on rails (ruby off rails?) strikes this perfect balance of abstraction for me personally. I think I could bear to persevere with Rails if I could trust that I'd reach some point where it wasn't necessary to keep learning extra, niche things because I could already implement anything I could think of with the tools I already had, and so if I then chose to use the extra stuff, I was doing so for the sake of efficiency and I knew exactly why I was making that choice. Hope that makes sense.
I saw that deal on here before. I'd probably ignore all the videos but even without them it seems like great value. I'll look into it, hopefully before that promotion ends.
Great to get some real world data that following that route works, thanks.
So here's my feedback, as one of the Rails maintainers. &gt; So, I've reached this point in Ruby where, while I'm still a total beginner, if I read a programming challenge then I'll immediately start coming up with several (inelegant but) plausible solutions, and when I don't know exactly how to implement them, which is often, I do at least know what I don't know, and I'm able to research it quickly. That's awesome! You've got everything you need to be a programmer. For any real-world scenario, the only difference between you and anybody else is time. As you get more experience, you'll find that you're coming to solutions faster. But you've got the core of what it takes to do this, and should feel really good about that. &gt; I can't even do the beginner tutorials - well, I can do them, but I never feel like I've really understood how I got things to work. So this is a really important thing, not just for Rails, but for working with code in general. Rails in particular does a *lot* of magic. You need to be able to just gloss over "how it works", and accept the rules that it sets. This is also going to be true if you work in a large legacy codebase. You'll most likely never understand how everything inside of it works, but you learn the parts you need to, and accept that the edges of what you're working on do what they need to. This is actually true of Ruby in a lot of cases, as well. Here's an example. Classes are objects. They're an instance of the `Class` class. Like all classes in Ruby, they inherit from `BasicObject`. (Specifically it's `Class &lt; Module &lt; Object &lt; BasicObject`). However, `Object` is an instance of `Class`. Which is impossible, because `Class` is a subclass of `Object`. How does it work? It doesn't matter. It's circular logic, but we just accept that the circular logic works and move on. Much of programming is just accepting arbitrary rules for no other reason than because they're the arbitrary rules that exist. &gt; Honestly, does Rails get any easier? Yes, you just need practice. Rails adds a lot of magic APIs, which you more or less just have to learn and memorize. Give it a few months. &gt; Because at the moment it seems to me like for every new task you want to accomplish, you have to learn the nuances of some new library (or just use it blindly, or else paste other people's solutions from forums and hope they work), which makes the goal of gaining any mastery over it, in general, endlessly receding. This is the result of one of the more poisonous influences that Rails has had on the Ruby community. Rails *really* likes DSL (DSL is short for "Domain Specific Language", which means when we do something that looks like it's making a new language, but isn't. `belongs_to` is a good example of a DSL that Rails creates. `routes.rb` is a more extreme example.) Part of what made Rails so successful was that people really liked how easy its DSLs made certain tasks that used to be repetitive and painful. However, then gem authors started deciding that *everything* needs to be a DSL. The downside to creating a DSL is that it doesn't often follow rules that are obvious by knowing just Ruby. You can read the docs, or even the source code, and figure it out pretty quickly, but it's less obvious than if it was just calling methods explicitly on objects (other than `self`). The problem with most of Rails APIs is that we have DSLs that aren't simple. `attr_reader` is something you can learn in about 5 seconds. `belongs_to`, not so much. This means there's a larger time investment required to be able to understand code that uses Rails' DSLs. Every gem which tries to make their APIs look similar adds the same costs. I wish I had a better answer for you than "yup, it sucks", but that's basically the gist of it. If you want to do interesting things, someone has probably made a library for it. There's a good chance it creates some kind of DSL to make it look pretty. That means reading the docs, and memorizing it (or googling whenever you work with it). I am really glad that you find blindly pasting code from forums so gross. It is. It's one of the worst things you can do, both for the code base that you're working on, and for your learning. Make sure you understand code you write (even if it's only at a surface level). &gt; Is all web development just really hard Quite the opposite! Most problems in web development are really easy, which is why Rails got so popular. It makes submitting a form, saving it to the database, and displaying it later (which is about 80% of web apps) really trivial. &gt; Should I just give up on it, at least for a good long time? Noooooooo! &gt; Should I try Sinatra instead? Yes! Or even go further, and just make a plain Rack app. Rack is the library that sits underneath both Sinatra and Rails. Sinatra has the same DSL problems that Rails does, it just has less of it. Rack is about as close as you'll get to just writing plain Ruby for the internet. I think there's a ton of value in making sure you really have a solid understanding of Ruby (a good benchmark is this: can you go through a random Ruby file on Github, and tell me what the value of `self` is on every line? And I mean *every* line, including class definitions, random code that isn't part of a class or method, etc) I hope Rails hasn't discouraged you too much. Please reach out to me, if you'd be interested in having someone give you a little guidance. PM me and I'll give you my contact info.
Honestly, I think this is a bit of a red herring. Rails 2 wasn't much simpler than Rails 3 in my opinion. What *has* changed is the amount of other services and frameworks that people commonly *use* with Rails, like RSpec, Cucumber and other testing frameworks, Heroku/AWS and other cloud/hosting systems, etc etc. I would avoid HAML like the plague, avoid Coffeescript like a slightly less virulent plague, and stick to simple MVC stuff where your model is an ActiveRecord::Base derived model, your view is just HTML + a bit of ERB &lt;% magic %&gt;, and your controllers are straight-up Ruby. Don't worry about all the crazy stuff. I'm a production Rails guy, do this for my living, and I shun about 50% of the Rails ecosystem. Also, gem city. Don't go there. Adding gems to Rails seems like it could solve so many problems, but it really adds a lot of problems too in non-obvious ways. Pick a super-simple first project (a blog, a time-tracker, a quote-of-the-day page, whatever) and try to focus on just the Rails core. Edit: I'd also avoid using the rails generate crutch. It's fine for quickly spamming out boilerplate once you're comfortable with what's being done for you, but again, all you need for a Rails model is 2 lines of code: class MyModel &lt; ActiveRecord::Base end That's it. All the Ruby simplicity you love is there, it's just surrounded by tools and tips and helpers and conventions... A simple Rails app is still simple, if you avoid all the magic helpers.
Sounds like good advice. I'm also in favour of testing early and robustly and yes, even at some point setting that all up first, because obviously I don't want to end up writing crappy code in the future. But I've noticed that quite a lot of the tutorials seem to be so intent on you learning perfect habits from the start that you're not quite sure if you're actually writing code yet or just learning to be a good citizen. Then other ones seem to be just copy-paste pointlessness. I really just want enough basic knowledge to shut the tutorial as soon as possible, open emacs and xterm and start making things happen, and solid resources to reference when I find I predictably fail, because that's how I learn. There's tons of things that hit that spot for ruby, very little for rails.
&gt; Rails 2 wasn't much simpler than Rails 3 in my opinion. Screw my cunning scheme to learn that way then - although I did think it was a pretty keen problem solving effort! &gt; I'm a production Rails guy, do this for my living, and I shun about 50% of &gt; the Rails ecosystem Genuinely very encouraging.
Looks like you can read the "Rails 4.0" version of Hartl's book online for free! http://rails-4-0.railstutorial.org/book Just the book, not the videos etc. I think just the book may be enough for you, with where you're coming from and how it sounds like you learn. I think the 4.0 version will likely be just fine, compared to the most-up-to-date 4.2 version. (And looks like a print version (of the latest?) is due out 'sometime in the spring') 
Follow Michael Hartl's Rails Tutorial. The difficulty is that Ruby gives you tools to do things, whereas Rails gives you premade do-ers. When you first learn Rails, you are a) learning the DSL (domain specific language, i.e. the railsy-ruby code) and b) learning the *convention* or Rails (and Ruby in Rails). Learning convention means you *have to follow a guide* the first time through. Others have suggested Sinatra, which I would second -- great way to learn good Vanilla Ruby. But, I would say keep up with Rails; 98% of ruby jobs work with Rails, and you solve problems in Rails that that give you a better understanding of Ruby. Also, when you get a lot more comfortable, [Owning Rails](http://owningrails.com/) was a monumentally eyeopening series to follow; showed me how Rails uses Ruby in such a way to make a very expressive framework/metalanguage. 
Ah yeah, REST/Resourceful routing sucks hard. Agreed big time on that one. Good point there. Do note that you (like me!) can avoid using restful routing. Just match '/foo' =&gt; 'controller#action' and you're good to go. But it's really REALLY going against the Rails grain... Fair points on the other two, though neither are show-stoppers. And for the asset pipeline at least, on a simple project you can just (GASP!) put your images in /public and skip the whole mess. :-)
So this response exceeded my expectations by a mile... &gt; The downside to creating a DSL is that it doesn't often follow rules that are &gt; obvious by knowing just Ruby. This was the big secret I didn't know before jumping into Rails and why I found it such a blow. &gt; You'll most likely never understand how everything inside of it works, &gt; but you learn the parts you need to, and accept that the edges of what &gt; you're working on do what they need to. That will be very challenging for me, in personality terms, pretty sure I was born without the capacity for faith. But I'm sure I can ultimately deal, as long as I have a sensible, Basic English *story* about what's happening where. &gt; can you go through a random Ruby file on Github, and tell me what the &gt; value of self is on every line? That sounds *extremely* fun, I'll start practising that, Your Rack suggestion sounds like a winner. I'd heard of it before, in passing, but not as anything I needed to concern myself with. Now, after reading about it, I'm surprised I'd heard so little - surely there must be a lot of other beginners who prefer to learn things from the ground up? Stupidly, I assumed it would be more, rather than less complicated to learn than Rails - less English and more codey, or something like that. I'll get comfortable with Rack, get comfortable with Sinatra and then yes, try Rails again, because your &gt; Noooooooo! really tugged on my heartstrings. By the way, I actually don't have a problem with Object being an instance of Class and Class being a subclass of Object. I just think of programming languages as logically possible worlds and Ruby is just a world where things can instantiate each other. As long as I can tell a sensible story I'm ok!
If I like it I'll buy the paper book. I quite like the book-on-lap / keyboard-on-knees setup I have going on. Pretty retro but it works.
I've worked through a few beginner Rails guides, and [this one is by far the best](https://www.railstutorial.org/). I'd recommend giving it a shot. Rails is a *lot* to get your head wrapped around at first. It's a massive, powerful framework that does a ton of stuff for you behind the scenes, and a lot of that is totally implicit. It takes a while, but once you get familiar with how everything is laid out, it makes a lot of sense, and is a pleasure to work with. 
&lt;3 &lt;3 &lt;3 I'm really glad I could help. With regards to the DSL piece -- I work with a lot of newer developers (most of whom are students at Turing School, here in Denver). One of the things I'm a stickler about when they're learning Ruby is the use of the word "syntax". Because once you get into Rails, we do a lot of magical things, which to a layman look like we're adding new "syntax". We can't do that, though. Rails is still just Ruby. Absurdly complex ruby, but when you see things like `belongs_to`, it's still just calling a method (on `self`, which happens to be your subclass of `ActiveRecord::Base`). &gt; I just think of programming languages as logically possible worlds and Ruby is just a world where things can instantiate each other. As long as I can tell a sensible story I'm ok! This is definitely true in Rails. It's just sometimes a convoluted process. If you'd ever like a technical explanation of exactly how anything works, let me know. And seriously, if there's any way I can help with your learning, please reach out to me. My contact info is listed at https://github.com/sgrif
I've been using Ruby pretty regularly for about 6-7 years now (mostly as a hobbyist and in support of my work—I'm not a professional programmer, but I do a lot of programming at work to automate tasks and generally make my job easier and more efficient). About a year and a half ago, I wrote my first (and so far only) Rails application. I seriously had no idea what I was doing. It was like learning a completely different language. I went through a book, building the tutorial application, and it still didn't make much sense to me, but I had enough knowledge at that point to start writing an application. So I started working on it, and realized that I wanted to customize certain behaviors. So rather than looking at the way it would be “done”, I just started poking around and figuring out how to do it on my own by applying my existing Ruby knowledge. As I started digging into the code, I began to realize what Rails was doing under the hood. Eventually, it all clicked, and all of a sudden I realized I was “getting” Rails. The end result was an application that probably isn't exactly enterprise-grade, or even terribly secure or functional, but it serves its purpose. And if I were to write another Rails application now, I'm confident I could do a much better job, because I now understand how Rails works from the outset. So stick with it. Eventually (and suddenly), it'll all make sense.
I think that is one of the strongest points of Rails, convention over configuration. 
I followed a similar Ruby--&gt;Sinatra--&gt;Rails path after writing Windows web apps for many years. One quick thing I haven't seen mentioned elsewhere: the "opinionated" nature of Rails (along with its adherence to MVC principles) makes it *very very easy* for Rails programmers to quickly be productive in Rails applications they haven't worked on before, as long as the Rails application generally follows standard Rails practices. Example: Recently I started a new job working on a company's HUGE internal Rails app. I was able to start contributing productively within a day or two because it was easy to find everything. That is a benefit of Rails that's hard to realize when you're putting together your first few sample Rails apps! As for your frustrations with Rails... oh god, yes. I share them all. The "convention over configuration" nature of Rails made it hard for me to learn. Everything was happening "magically" and when it broke, it was hard to figure out how to debug things. Don't get me wrong: Rails is very well-designed and it *does* let you diagnose problems pretty easily *once you know how.* 
Thanks, I wasn't trying to be dismissive either. I like working with Rails and appreciate the work everyone does on it. I think it's a bit tricky to learn how to use at this point from scratch, especially for inexperienced programmers, and some common advice on the internet for learning it is less than useful, and orienting people to some of the rough spots can help them find their way. Good docs are hard (as hard as good code). I've contributed a couple small documentation-only commits to Rails. Other times it's been hard for me to know the proper documentation for something under-documented to add it myself, diving into the code to try and figure it out can be tricky with indirection and sometimes intent not clear to me. 
I feel the same way. We have several programming schools in Denver, I try to be involved as a mentor in all of them. I think the best example was when one of my students told me "it's just hard to tell where Active Record ends, and my code begins." I really don't have a good solution for the bad advice out there. I feel the pains of it all the time when people open issues on rails/rails after following a bad stack overflow answer. I really appreciate your attempts to improve the docs. If you ever have a case where you can tell something is under documented, but don't know how to improve it, ping me personally. I'll see what I can do to clarify the intent. If you don't think its worth opening an issue, feel free to email me. I want to help. :)
I disagree with the one assertion per spec. You should test one thing per spec but its fine to use multiple asserts. I like to asset the before and after states if I'm testing side effects.
This is exactly where I am. I know HTML and CSS but no programming. I don't want to become a pro developer I just want to build websites. I am currently working through the Lynda Ruby on Rails after hating the Code Academy course.
I think rails is a good thing for you to learn, not just in order to make a snazzy web app, but in order to make you learn the ruby meta level. See, ruby isn't just another language with a slightly different syntax that feels easier to use. the REASON why ruby can have some of it's intuitive syntax is that it's very open to metaprogramming. i.e. you write code that redefines what your written code means. Rails uses a lot of metaprogramming, and in order to use rails effectively and neatly, you will have to do the same. This is a natural and good progression step in your becoming a more well rounded rubyist, so I definitely recommend this path. I strongly suggest you get comfortable with the class/module inheritance/extension/inclusion functionality of ruby in order to get a deeper understanding of scope of variables etc. Rails does play around a bunch with this too, and forces you to do the same if you want to include things in the lib/ directory in a neat way. Looking at the internals and source code of the gems you use can do a lot to dispel some of the magic surrounding this. Someone mentioned Sinatra as an alternative, and I both agree and disagree. If you want to become a ruby developer, sinatra isn't a step on the way learning wise. Sinatra won't challenge you to widen your horizons like rails will. If you want motivation to build stuff however, sinatra can let you build some quick and dirty web applications that can keep you interested, which is great too!
Absolutely. I think the best thing for me will be just trying to do more and more serious web dev stuff and finally getting myself to a point where I really understand why I need Rails.
The naming conventions in Rails *kill* me, but at the same time I can see how they could be really helpful if I was already comfortable with Rails. Just had a quick look at Elixir. It's definitely beautiful to look at! Ultimately I'm planning to try as many different types of language as possible. Once I get solid enough with Ruby and the object oriented way that deviating from that model won't cause me to fuck up everything I've learned so far, then I'll definitely check out Elixir / Phoenix properly.
 # Original module module SampleModule def self.sample_method p "called sample_method" end end # Monkey-patch public method module SampleModule def sample_method SampleModule.sample_method end end # Instance class A include SampleModule end a = A.new a.sample_method # Class class B extend SampleModule end B.sample_method # Monkey-patch private method module SampleModule private def sample_method SampleModule.sample_method end end # Instance class C include SampleModule end c = C.new c.send :sample_method # Class class D extend SampleModule end D.send :sample_method 
I think, not. The solution of the @smix is elegant, but it wouldn't work if you use `self` in your `sample_method`. That `self` will refer to the `SampleModule.singleton_class`, not the B, or instances of A, C, D.
Here are a couple of things that helped me! 1. It's not a magic bullet solution, but have you checked out Pry? It's the (indirect) successor to the older ruby-debugger gem. Essentially you can place a "binding.pry" call anywhere in your Ruby app and inspect pretty much everything that you need to. http://pryrepl.org/ 2. You can test Rails helper output in the Rails console without too much trouble. This was a big stumbling point for me because I find the helpers especially "magical." http://stackoverflow.com/questions/2846247/rails-check-output-of-path-helper-from-console
You're right. And I'd also note the opposite operation (extending singleton class with a "regular" module) is simple and natural.
I switched from Sublime to RubyMine a month ago as I started a new job (they were already using it). I have certainly not mastered it yet, but I do really appreciate a number of features. Caveat - this is my first real programming job and my first IDE. The project is a moderately sized Rails and Angular project with Cucumber, RSpec, and Jasmine tests. I think my favorite part of having the RubyMine IDE is the test integration. I find it much easier and quicker to debug tests when I can click through each failing test, look at the call stack, and jump directly to the file I want with one click. Then I can easily re-run only the tests that have failed without working through the command line to specify exactly which ones I want run. I also really like the git integration. I can click the "changes" window to get an overview of the files I've changed, and committing and pushing is a breeze. I never did use the GitHub GUI though, so maybe this isn't an improvement over that. There are a couple little things I like that might be possible in sublime but aren't on by default. When you close a folder structure (say app/assets/javascripts/controllers for angular) when you re-open it all of the child folders are closed. This helps me not have a mess of folders open on the left side over time. I also like the icons based on the file type. Cons: RubyMine feels a little cramped, at least for me, but that's what you get with an IDE vs text editor. I also think the package manager in sublime is more straightforward than the plugins in RubyMine. The way that RubyMine manages open tabs at the too of the screen is a little annoying - they can scroll left to right and I am just not a fan. Sorry for the somewhat stream of consciousness thoughts. Overall they're both solid options, but I'm happy with RubyMine for my small to moderate sized project. 
Disclaimer: I have little experience w/SublimeText and I don't doubt that some of these things can be achieved - more or less - with the right ST plugins. What I really like about RubyMine is the integrating of remote dev environments to the editing environment. ex. I can set up a vagrant box (VM) and point RubyMine to my config for said VM. After a few other trivial steps, I get code-completion, gem-specific syntax checking, etc for the project as it exists in that remote environment. If you add an entry to your Gemfile, it will detect and allow you to run `bundle install` on your remote machine with the click of a button. Some of the features are nice simply because it requires less windows open and thus less mental context switching as you aren't swapping to different applications (which may have individually done their jobs just fine). Mind you, many IDEs have tools to perform peripheral tasks, but they often seem like an afterthought and don't jive with other aspects of the IDE. ex. the built-in database browser creates UI elements for editing tables that work just like the code editor windows. This also applies to things you might previously have used a terminal window for, like rake tasks, rails output, running tests. I have also stopped relying on browser plugins for testing REST endpoints, as that is supported by RM, too. I know some people who like to use the VCS features - their claims are that because you've been looking at and thinking about code/files through RubyMine, so it's quicker to mark things for committing through it. I'm sure you know that many of these things can be done w/o the aid of an IDE, but they're features that have grown on me and I miss their absence when I am forced to use something else.
I've seen some people disable the tabs and project sidebar in the IDE and rely on double tapping the shift key to bring up the [search everywhere](https://www.jetbrains.com/ruby/help/searching-everywhere.html) dialog which also includes recent files.
Where is turbocaching saving its data? Could it be configured to use a redis cluster so two app-servers can share the same cache?
If you're looking at digging into other languages on the JVM then learning Rubymine won't hurt as it's essentially IntelliJ with some tweaks. I know some seriously respectable developers who use IntelliJ and swear by it. I don't use it for my Ruby work but have seen it wielded to great utility. For example: the creator of the JavaLite family of OSS tools uses IntelliJ exclusively (but then again he's focused on Java) http://javalite.io/ and I know that Micah Martin and Bob Martin are known to use IntelliJ. If you know who they are then you know they know their shit. IIRC Noel Rappin (author of Rails Test Prescriptions and recent RubyTapas contrib) is a fan of Rubymine. Personally, I'm a Vim'er but don't eschew Rubymine for any particular reason other than I'm not doing J* stuff. 
Thank you all for your kind replies. I have read them all and between them I think I have a better understanding of ruby classes, but I'm going to need to put it into practice to fully comprehend it I think. I still have a lot to learn, and what I *do* know seems to be a smaller percentage everyday. Still, I'm amazed at the generosity and willingness to help of the programming community so far, and it keeps me going :) Cheers!
I used it for a few months and feel like I barely scratched the surface of what it could do. Was using it on a huge Rails project (100k+ lines of code) and there were two features that really helped me navigate this beast of an app: 1) command-click a method takes me to that method definition. 2) Fine-grain controls for splitting windows vertically or horizontally (I would sometimes need like 8 files open at once) Cons were that overall it did not feel performant running on a Mac Mini and the auto-complete would often hang and stop displaying the characters I type in real time as it searched for auto-complete suggestions. 
&gt; Cons: RubyMine feels a little cramped http://blog.jetbrains.com/phpstorm/2013/10/full-screen-for-all-platforms-and-presentation-mode-with-phpstorm-7/ Have you tried that?
I recently switched jobs going from C# and Visual Studio to a rails shop and I was looking for an IDE I would feel comfortable in. I gave RubyMine a try, but I just don't think it works as nice as Visual Studio. For the record, I still have a ton to learn about ruby/rails, developing on a unix machine, and this type of dev in general. But RubyMine was not a replacement for Visual Studio and I feel more comfortable using Vim and Sublime for now. 
Yes. I've used RubyMine a little but mostly PhpStorm. So much so that the reason I got RubyMine was because of how amazing PhpStorm is. I think - and I mean this as nicely as possible - that if you haven't seen the benefit then you haven't learned enough of the IDE. People that I've met that said the same about PhpStorm were basically using it as a text editor. If that's the case then you are probably not going to like it. It **is** slower than any text editor. But the benefits outweigh it. For example, my company is puts a priority on code standards. First, I can set up file/code templates that automatically insert proper class/docblock format. In PHP we have a thing call PHPCS that compares your code to a standard. It's built right in and I can make sure I match as I go. Git. Vagrant. SSH. SFTP. If I extend a class the IDE will tell me which methods I've overwritten and I hop to the parent in a click. Put your cursor in a function and execute the right shortcut to see what code that method contains. It can even integrate with our issue tracker. I'm really hopping on the JetBrains bandwagon. Recently downloaded their new DB GUI and it's also fantastic. So, I've used PhpStorm, RubyMine, and the DB client. All of them wonderful. Really get into the IDE and poke around. Forget how you used to do things and see what is available. 
Im surprised that Sublime cant just import the Vim bindings. Im still newish to both, but Id see that as one of those core text editor features. 
I don't think it does. But NGINX supports storing its cache in Memcache. 
A lot of vim bindings are rubbish. The latest idea vim plugin for RubyMine is really good though
Windows, nice! 
https://www.sublimetext.com/docs/2/vintage.html
There's a little bit of a backstory behind this. Last week I went to Amsterdam.rb's [MRI Implementors Panel](http://www.meetup.com/Amsterdam-rb/events/219800841/) meetup featuring Koichi Sasada, Terence Lee and Zachary Scott. Distribution of Ruby apps came up at some point. Terence and Koichi talked about how MRuby is able to precompile Ruby apps into a single binary, and how being able to compile a single self-contained binary is the reason why so many people are moving to Go. But I was unconvinced about the value of MRuby, because MRuby is a subset of Ruby, but Ruby's main power lies in its standard library and its rich ecosystem. So I talked with Terence and with Eloy Duran (MacRuby/RubyMotion) about Traveling Ruby. They were equally unconvinced, asserting that Traveling Ruby doesn't support Windows, and can't produce a single binary. Traveling Ruby currently generates a directory with a single wrapper script, but that's not good enough for them. Then we contemplated how sad it is that so many parties are moving off Ruby towards Go. So I implemented Windows support last weekend. This is just a minimum viable product: there are lots of caveats and limitations currently in the Windows support. Next up will be the ability to produce a single binary. Hopefully at some point I can launch a large-scale marketing campaign together with the community, in the hope of preventing more people from switching to Go due to distribution issues. Or better, to convince some people to switch back.
I really like it. Best thing about it is the integrated debugger.
Add Resharper by jet brains if you don't already have it. Amazing...
I used rubymine before I started working as a ruby dev full time. After I started I saw how much better tools everyone had when they used tmux/vim/zsh/tmate and developed through an ssh session to a disposable VM. Here's my usual workflow: * $&gt; vagrant ssh * I type "work" to start a tmux session with windows for vim a shell, rails c and db console * CTRL+P opens the fuzzy file opener in vim, I search for the file I'm working on * :vsplit command in vim to split the window in half * Ctrl+l to switch to the left pane * type comma period to open the associated spec * type comma s to run that spec in same window * enter to close test results * make changes to files * comma s to run spec again What's awesome about this is I have all the scripts, plugins and tools for this workflow saved in a puppet manifest, so I can just type vagrant up to build a new VM, install and configure my tools, check out the latest copy of the code, configure all the apt dependencies, run bundler and rake db:migrate. And since we all use vim at work, we can use tmate for pairing. Now we have the exact same screen and ssh-speed refresh rate, so it's actually palatable to write code remotely on someone else's machine. If you're a rails hobbyist, it's probably fine to stick with whatever is comfortable. When you're doing it all day long, it's worth a week or two of fumbling around learning it for the enormous benefits it provides.
Web development, benefits administration SAAS.
Oh sweet googly. I did not know that. Sweet.
If you have multiple monitors you can switch the project tab to floating mode and move it to another screen.
As far as I can tell, that requires you to update a tags file every time you change something in your sourcecode. Surely that can't be right?
For public/private, you can create a method that _creates and returns_ a Module dynamically, like so: def my_module(visibility = :public) return Module.new do def sample_method "sample" end if visibility == :private private :sample_method end end end class WithPublic include my_module() end class WithPrivate include my_module(:private) end puts WithPublic.new.sample_method begin WithPrivate.new.sample_method rescue NoMethodError =&gt; e puts "Exception raised: #{e}" end For instance method vs class method, you've just got to use straight ruby `include` to get instance methods, or straight ruby `extend` to get class methods. I can think of various tricks to try and get around this, but I think they're not worth it and don't have the energy to try to code them up to see, I'll just leave you with this idea for public/private. 
Writing tooling for automating various things. I also use it in algorithm practice sessions, since I feel extremely comfortable with ruby.
Data integration with several external sources. Funneled to a Sinatra API datastore. Reported by a Rails application on the front. So.. much.. Ruby..
I think you use *continue* instead of *next*
I bought a RubyMine license and ended up going back to Sublime. I just don't need a full IDE for Ruby. I use IntelliJ for Java, though. Java without a good IDE is madness.
RubyMine is a great heavy hitter, debugging, code navigation mega-platform. It's great for somethings, but I like being able to use Sublime Text for code, gitx for code check-in, zsh for console etc. RubMine offers all these things, not as good as individual tools IMHO but it's all integrated into a single product. For this reason I find myself returning to small tools for each job. If I need to debug or navigate around a large / new project then I fire up RubyMine
 start_year = 1800 end_year = 2400 (start_year..end_year).each do |y| puts y if (y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0)) end A version broken down into individual pieces: # Wrap up our logic for determining if an integer is a leap year in a lambda leap_year = lambda { |year| (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0)) } # Delcare our start year start_year = 1800 # Declare our end year end_year = 2400 # Create a range from the start and end years years = (start_year..end_year) # Reduce our full set of years to ones that pass our leap_year lambda. # Notice we pass our lambda by reference so it is treated as a block. leap_years = years.select(&amp;leap_year) # Print what's left! leap_years.each { |year| puts year } Concepts: - [Ruby Ranges](http://www.ruby-doc.org/core-2.2.0/Range.html): (1..10) =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] - [Array#each](http://www.ruby-doc.org/core-2.2.0/Array.html#method-i-each): array.each { |array_item| ... } - [Procs/Lambdas](http://ruby-doc.org/core-2.0.0/Proc.html) Main takeaway: Take advantage of Ruby's map/reduce functionality rather than using loops and flow-control statements whenever possible. Your code will be much more concise.
Atom has a downloadable package for Vim bindings. If you're into Atom that is.
Thank you so much, keep up the good work!
Web based portal to thousands of HR documents, home grown surveys site, shared use auth and profile micro service.
I have no idea what vdebug is or how it relates to VIM. I've really good debugger support by using Pry or byebug (or both together). If you're looking for a debugger, they're great.
I really love this story. You should cross post this on Hacker News. Thanks for your hard work.
As it should be, my mistake.
your not incrementing your start_year before you hit "next" in your elsif conditional. That being said, /u/FYIAV solution is how I would go. Been using Ruby for years, and can probably count the times I've used while loops on 1 hand.
I put together a 5-email course/preview in a signup form on the site. Sample chapters will be released when I've finished the manuscript.
Well, the acronym isn't exactly new. It's featured quite prominently in her 2012 book "Practical Object Oriented Ruby". But what *I* like about the TRUE acronym is that it focuses attention on the relationship/coupling of both the code and the people who are working within it and maintaining it. A lot of other acronyms and heuristics focus on the relationships within code (open-closed, etc), whereas I really appreciate the humaneness of TRUE. I actually talk about TRUE quite a bit with my team during code reviews. Especially with "Exemplary" code, it is really good for asking people "Given the constraints (time, resources, unchangeable previous technical decisions), is this something you're proud of? Is this something you'd want turned in by another team member for you to review?" I'm definitely a softy when it comes to team dynamics, but I think TRUE helps build empathy and understanding with other team members.
It's also fairly good, compared to some other vim bindings I've used.
Information security. I use it for all sorts of things.
nope.. ruby only has next, break, redo and retry. No continue. That's for C.
Yes.
I've used it for a lot of things, from small shell scripts to large distributed web applications with hundreds of thousands of daily users. I think it shines most in two situations. First, when getting things working quickly is a priority. Second, when the algorithms or business logic of a problem are so complex that the expressiveness of the language makes it possible to reason about things that would be too difficult or clunky to express in other languages. Above all I find that Ruby's greatest strength is that it lets me write very clean abstractions that make it easier to think.
you find a reason to need an IDE as code editor then you start customizing and eventually find there are other small advantages here and there. for me i wanted code completion at first and then found the interface customization features to be quite satisfying. it makes the coding experience more personal.
I'm a system admin who does a lot of dev, I use it mostly for automation of everyday tasks. i.e. * This is something that causes a lot of tickets to be raised and it's very repetitive, I'll automate something to automatically check for this issue every day and fix it. * Where existing software doesn't fill the gap I need it to, sometimes I need to extend software (e.g. Puppet) or write my own integration between other applications (e.g. Backup scripts)
You of course couldn't use your gem for building someting like Rails migration or AREL though, it really does only build what I've seen called a 'builder'. (Like Rails XML builder) 
It's interesting to look at the different philosophies each framework uses. Rails has a web DSL, Django is "just Python". Convention over configuration vs explicit is better than implicit. etc, etc, etc.... There's a Python way of doing things and there's a Ruby way of doing things. Devs can choose which they like better. I think both are successful because they each stick to their philosophies and the community embraces the philosophies. I've been using R a lot at work for data manipulation. I like R, but I wish there was an "R way" instead Pearl's TMTOWTDI (There's more than one way to do it). 
This is interesting. I have my doubts about this approach though. Using precompiled interpreters saves some effort, but it also comes with complications such as issues with native extensions. I think omnibus gets it right. Sometimes the easiest way to support multiple platforms is... well, to build a package for each platform. With software like vagrant and test kitchen it's a simple process to launch a few VMs and build natively. And when you're done, you have *actual packages* to distribute to your users for easy installation, Windows included.
They're *okay...*, but not great. I've tried it for some time, but visual block mode isn't even implemented and the whole idea of motions, which make vim's binding so powerful was not completely fleshed out when I tried it.
Thanks, that's a really thoughtful response. You're right about me trying to learn everything at once and you've given me some good ideas about breaking it down. Before I posted my rant here, my problem was that there didn't seem to be any way I could see to *avoid* learning everything all at once, if I wanted to do even the simplest web development stuff. I was mostly motivated to get into programming from my interest in the more logicky / abstract side of things. My background is in (a bit of) philosophy, rather than science or anything useful, or pragmatic whatsoever! Even with philosophy I've always been *way* better at the two poles - on the one hand the nitty-gritty and logical minutiae and on the other, the zoomed out, big-picture stuff - than I am anywhere in the middle. There's a lot of 'middle' in web development because understandably the focus has to be on solid results and useability, rather than the most elegant, rational code that no user is ever going to see. It's way out of my comfort zone but I think that's probably quite a good thing, even if it's less immediately fun. I've been playing with Sinatra for the past couple of days and honestly, it's lovely and so far I've managed to avoid using any extra gems or copy/pasting shit without understanding it, which I wasn't managing to do with Rails. Obviously my requirements are going to go up as I start doing more complex things, but hopefully by that point I'll be better able to understand what's going on beneath the hood.
P.s. I'm alright with static websites. Although I hadn't touched HTML or CSS in years, using it again now it seems not like not much has changed so that's just a matter of getting back into practice. And I actually did use to set up and mess around with MySQL, again ages ago, again for no reason except curiosity. I'm a pretty long time Slackware user and I think one of the nice things linux does when you first switch to it is give you this ridiculous amount of possibilities, out the box, for poking around and learning stuff that you're almost certainly never going to need, just for the hell of it. I have forgotten *all* of the database stuff though, so I'm definitely going to have to revisit that. Thanks for reminding me.
Of course Omnibus's approach solves all those problems, but not without significant psychological barriers. Having to spin up a bunch of VMs just to build your binaries is not something that a lot of developers want to do. My MacBook Air's SSD is small enough as it is. If I have to plug in my external hard disk every time I want to build something, that's just a pain. The Omnibus approach takes *fun* out of development. Traveling Ruby can't solve everything. It's not supposed to. But I think it can solve 90-95% of the cases. And of the cases that it can solve, it's significantly easier -- and more importantly, *more fun* -- to use than Omnibus. If you need Omnibus, just use Omnibus. Traveling Ruby is not trying to be Omnibus, by design. Frankly, I think that Omnibus's approach won't be able to prevent people from flocking to Go. Look at how easy is it for developers to produce multi-platform binaries using Go. It's **fun**. Ruby needs to be at least that easy to prevent people from switching away.
At work we run multiple rails apps with Phusion Passenger behind Nginx on VMs via Vagrant. However, there doesn't seem to be an easy way to attach a debugger using Redmine. The refactoring on Redmine is hit and miss but as others have said the code navigation is pretty good.
&gt; Supports Ruby 2.1.5 and above That seems like an odd requirement... I tried it out, and it seems to work fine with ruby 2.1.0+ (which *is* a requirement, as it uses named arguments with no defaults) I've put in a pull request to fix that!
Not a bug... have a look at your URL. Mechanize expects http://www.scouts.org.uk 
An article by /u/philnash ? Gotta upvote that!
Relying on shell expansion is pretty dangerous. "my command with arguments and $user_input" can easily turn into "my command with arguments and ; /bin/rm -rf /" 
Ahh! this is awesome! I think I'm still stuck with the mindset of using loops for everything x.x I never even thought of using boolean operators for solving this Thanks for this post. I need to refresh my memory with lambdas and procs as well ahhh
Thank you for the explanation and debug! :) 
Helpers = modules. Woah.
You can also run a series of commands as a heredoc. output = &lt;&lt;-`COMMAND` ls -l df COMMAND
`htmlcompressor`: compacts the HTML output `capistrano`: for deployment `whenever`: updating the crontab upon deployment `exception_notification`: don't know what I was doing without this - it emails you any errors that occur during the regular operation of your app. A lot of errors that I never would have known about are brought to my attention `image_optim`/`carrierwave`: asset uploading/compression `rack-mini-profiler`: for analyzing database transactions, flamegraph for stack/memory, and has a useful method for tracking code optimization `better_errors`: another 'cannot do without' - allows console access on the live instance in the browser There are others, but that's the best of the best from what I've needed.
This thread makes me sad, because I was looking into C++ and then someone diverted my attention to Ruby, and I have close to zero interest in doing web applications, which is apparently its primary use, and now I have wasted a lot of time.
Yep, that'd be command injection. Really disappointing there wasn't even a mention of security concerns over these commands. Also FYI even the safer commands that prevent command injection (because they explicitly only call one executable) can be vulnerable to argument injection if you aren't careful with your user input. For example, you could allow a user to copy a certain file as root and control the filename with a command like: cp /etc/config/file /hardcoded/path/$user_supplied_filename and a user could add a space and turn it into cp /etc/config/file /hardcoded/path/ $user_supplied_directory which would then copy both of those paths to a user controlled directory. Tons of examples of dangerous tricks you can do, like abusing chmod or ssh arguments. When allowing user input it's best to use the functions that require an array of arguments, therefore someone can only control the arguments they were meant to and aren't able to do shell tricks or add spaces to make additional arguments.
[A list of gems that rock that rocks](http://awesome-ruby.com)
Not quite. Helpers as procedural functions namespaced within modules. You're still dealing with procedural code and global state by default.
You are right I should have wrote something about security in the blog post. But why would you ever execute a user input as a shell command? If you don't know that already, a simple security warning won't stop you anyway.
IntelliJ is the de-facto gold standard for Java IDE's. Netbeans and Eclipse are the poor-house alternatives.
Well, I did download GitHub, so I'm not sure about that part
&gt; I wasn't aware of this ruby trick - it could come in handy at some point, thanks! Actually I'd rather do that with Ruby's standard library. Just collect all entries for each directory and then do set operations via Set. That is much more reliably in case file names are odd (contain newlines or other weird stuff).
Well yes, I don't particularly like this specific example since Dir["path/to/files/*"] solves the problem in a much nicer, more maintainable way. However, suppose you are just knocking together a quick ruby script, for a one-off use, and you are 'importing' a load of bash script code into it. Maybe you don't want to bother understanding exactly how each line works, and translating (re-writing) that code using Ruby's standard library. In that case, knowing this little trick might save you some time. For example, I ran the following command the other day: awk '{ print $2 }' filename | tr 'A-Z' 'a-z' | sort | uniq -c | sort -nr | head -n 20 Could I re-write that in ruby? Yes, obviously, but it would take me a few minutes. In "production" code I'd invest that time, but for a one-off script knowing this trick would come in handy!
Makes sense. TRUE has helped give you an idiom to teach your team design principles that have been around for decades. There is value in that, for sure.
It's a little more accessible than asking folks to read $200 of Christopher Alexander books and a Robinson Jeffers anthology :-) Any alternatives you'd recommend?
Aw yiss! I'm a fan of Puma; I've used it on all of my projects except my current one and have had nothing but good luck with it.
torqbox FYI
That was fast since the inital release. Using Puma every day on a 512MB box. Fast as hell. 
I recommend to you RubyLearning, the 59th batch is going to begin on 21st February, it's only US$ 44.95: http://rubylearning.org/classes/ You can pair programming with the mentors and interact in a forum. The course take 7 weeks. Some good books for developers are The Well Grounded Rubyist and Eloquent Ruby. For editors I use vim with janus, and I'm getting better everyday I use it, but use some commands first and then others, don't change completely or try to memorize all the commands at first.
Asking people to read a few books sure seems cheap next to a $40,000 education. POODR itself is essentially an amalgam of a lot of ideas that have existed for ages. It does a very good job of introducing young rubyists to those design concepts. As a starting point, it's fantastic. But there is still a tremendous gap between modeling a bicycle and real world design. PoEAA, GoF, DDD, Refactoring, etc., all help get you a few steps further, but there is still a lot of *practice* after that before the programmer is capable of building software of the same quality (and at the same cost) as a true expert. To be honest, I'm worried that the shallow level of education standards in the ruby community today will cement expert amateurism within the community permanently. I blame code academies, to be honest. I think you stepped in the middle of one of my larger rants, what you are saying makes a lot of sense. I'm just not convinced that the level of education offered by the popular sources in the ruby community is sufficient to prevent ruby disasters :)
Totally using gotos in next ruby project
Puma, isn't that for actually threaded environments like JRuby and Rubinius? I thought it was Unicorn that spawns child processes to evade GIL.
&gt; Puma, isn't that for actually threaded environments MRI still has threads. The GVL (or GIL) gets released every time you do IO. Most Ruby apps are pretty heavy IO (database calls) so there's plenty of time for multiple threads to do work. Does it work better on JRuby with only threads? Yes. Does it work on MRI too? Yes. Puma also spawns child processes, you can use it in hybrid mode to use threads and processes (which is what Heroku recommends).
Read Russ Olsen's 'Eloquent Ruby'. It'll tell you why your Ruby code should look nothing like your Java code. 
I knew about the IO bit, but hadn't yet thought through how IO-heavy a Ruby web app likely is. And I certainly didn't recall Puma's hybrid mode (if I ever knew about it to begin with). Thanks!
Thin is evented server meaning by default it has one thread serving all your requests. As long as you aren't doing anything blocking (calls to remote APIs) it will be fast - otherwise you block your single thread and everything just stops. Puma has a thread pool - one thread for each connection meaning however long it takes to service one request won't affect any if the other requests since they are running in parallel.
Excellent feedback. Thank you!
I see, that does sound interesting. I'll see if I can whip up something, I have a new framework I've been looking to play with outside of work (non ruby)
It will be -- and Passenger is awesome already -- but you only get multi-threaded dispatch with Passenger Enterprise, and this is true with Passenger 5 (raptor) too. * And multi-threaded request dispatch is what makes it deal better with the 'slow client attack' mentioned in the heroku posting as reason to use puma. (although I'm not sure it actually makes it immune. But without multi-threaded reuqest dispatch _one_ slow client -- whether an intentional attack or just a slow client -- will destroy your performance. With multi-threaded dispatch, it would take many many of them to have the same negative impact). * Passenger Enterprise is relatively affordably priced, but not free, making it unlikely it will be a heroku default recommendation. * puma is the only free (non-Java/Jruby) rack server that does clustered multi-process where each process can do multi-threaded request dispatch. I think Passenger is incredibly solid reliable high-performance software though, and is now in Passenger 4, you don't need to wait for Passenger 5. For selfish reasons, I wish the multi-threaded request dispatch were available without an Enterprise license. Of course, the passenger folks have to make money somehow, and the multi-threaded dispatch really is a killer feature -- although I don't think enough of their potential customer base realizes it! 
Can some explain why this is a problem with unicorn? From their docs, unicorn is intentionally designed to only serve fast clients and if you put Nginx in front of it, like they recommend, it is not an issue. Also I realize that puma can do multi-threading, but it seems multiple processes is good enough for most sites and not having to deal with thread-concurrency issues can be a pretty big win.
Puma is immune to slow client attacks because it also contains an IO reactor thread. If it detects that a client is sending it's request slowly, it sends the client to the IO reactor thread to be waited on until it finishes sending the request. The IO reactor thread can handle thousands of slow clients because it uses a simple IO detection loop. When a client finally finishes sending it's data, it's put back into the thread pool to be processed.
Awesome, thanks for the clarification, that's a sophisticated solution. (Passenger also has [much the same architecture](http://www.infoq.com/news/2012/04/passenger-32). puma and passenger seem to be the most sophisticated and mature rack servers)
Am I the only one who doesn't know how to really write thread safe code? I don't even use a lot of gems and the only advice is go through source code of every gem and figure it out...
Nice! I was a little wary of unicorn after the [temper tantrum last year](http://bogomips.org/unicorn-public/m/20140801213202.GA2729%40dcvr.yhbt.net.html), but ultimately shrugged and settled down to using it. Puma has come a very long way since then, and I haven't had any issues with it for the past few months
doesn't github do this already?
&gt; In ruby, most people just convert the Json to a ruby hash Probably in all dynamic languages. &gt; not sure what the benefits are of converting to a class structure In ruby there isn't, but in statically typed languages the compiler maybe could help you out by enforcing that data structure. In my experience auto-generated code always feels alien because it's generated from some common (language neutral) definition (e.g. WSDL or JSON Schema). 
Why not just run a Linux VM instead? The majority of the web runs on Linux; it seems most logical to develop software on it, too!
* Run Tests, then commit to git. * ask apt for available upgrades, download in parallel and then install them * update components of my system that are not covered by apt * stupid script that tries to recover my webserver from a frozen state. It just tries to handle some standard failures and routine tasks. * back up my webserver and distribute backup data to a bunch of different stores. * etc. 
In case you're not familiar with VMs, or need to use Windows for your coding: corporate policy, dependencies on Windows-only software…
&gt; **STOP!** Do you want your code to be readable? Well, what's more readable than a book? Books know about the power of gotos, that's how you [choose your own adventure](http://weirdcanada.com/tag/choose-your-own-adventure/). Haha, brilliant! Not only is this really informative, but it's been extremely well written. Thanks for the good read, Josh!
Of course there will be some exceptions, but (in my opinion?) any one of those justifications is a real cause for concern, for a professional web developer. (Who are, I assume, the main target audience of this post.) It's good information to share, especially for people (e.g. students) who just want to play around with RoR without setting up a dual boot drive/VM/whatever, but from my experience it's always been way less painful to develop "complex" RoR applications on Linux.
That's the thing, the main target audience is not professional web developers; it's anybody who wants to run Ruby and Rails on Windows. There are millions who use Windows as their primary and only OS, and this guide enables them to start with these tools without having to dive into the whole VM and Linux world first.
As I understood, you can also run Puma only multi-process, so you can use it just like Unicorn. For most sites multi-process is good enough, most sites aren't popular. If you always use Puma, then you will get great performance whether your site is popular or not ;) Also, threads use very little memory in comparison to processes. That's why Sidekiq performs so well, because most other background-job solutions use processes, but Sidekiq uses threads. As for multi-threading problem, I think people are too afraid of that. Just don't change global variables inside of controllers, and you should be fine. You don't have a problem until you have a problem ;)
Well, in fact Rainbows also can hybrid multiprocessor+multithreaded mode. Why everyone forgot about Rainbows?
In that case, why not preface the blog with something like: &gt; Warning: RoR works better in a unix-like operating system. You will likely encounter obscure bugs, incompatibilities and unsupported features when trying to develop a large-scale RoR application on Windows. This guide is recommended to be used as a quick way to try out RoR, without investing the time to set up a virtual machine or dual boot drive. And frankly, if the guide becomes too long and complicated, with a long list of steps to work around common Windows issues, then it actually becomes easier to just set up a VM!! (Which is actually very simple, but just takes a while to download+install the software.)
Cliff notes to writing thread safe code: 1. Don't use class-level variables, and ensure your objects are immutable. 2. If you have to violate #1 above, then don't share objects between threads if the threads modify the internal state of the objects 3. If you have to violate #2 above, make sure the modifications are guarded using the appropriate concurrent modification structures. By doing these simple things (not sharing state unless absolutely required, and then only doing so through threadsafe code) you can prevent most concurrency-related issues.
Because it is scary enough to try out a whole new language and framework, I don't want to turn people out with more new concepts and caveats. Furthermore, the path to a cleaner and more productive environment in Windows is more people using it, filing bugs and improving it.
&gt; Crack on with Sinatra. What you'll probably find is that you'll discover which &gt; things you'll need that Sinatra doesn't provide. So can't imagine this happening *any* time soon but yeah, eventually 'outgrowing' Sinatra is my goal. Regarding Erb / Haml. I tried them both out but then settled on Slim for the moment. I'm not fond of things that care about whitespace (I was thinking about learning Python before I tried Ruby but I knew I'd find the strict formatting requirements really stressful) but it's very intuitive in Slim, plus I always indented plain HTML pretty rigourously anyway, since it is *hideous* to look at if you don't. Slim's way of inserting ruby code is attractive and makes sense to me and it's a relief to be able drop all the ugly brackets.
Given that setting up Rails requires a lot of familiarity with the command line, and other non-trivial parts of computing, I hardly think that setting up Vagrant with a VM will scare people away. On the other hand, I'd love to see Rails become more standard on Windows.
I'm all for UI tools, I started out with Photoshop and Dreamweaver, and deploying meant uploading an index.html file to a server, and it just worked. But I'm beginning to see the strength of the command line. And it annoys me that commands and functionalities are changed in apps. Github for Windows for instance. Why isn't it commit, pull and push, but rather commit and then sync? - which I'm assuming goes both ways. I only recently discovered that I can add existing repos on my drive to the app by dragging them into the window. A hidden feature I had been looking for for ages. But I think I'll check out the other two apps too. See if it easier/better than running Vagrant :-)
If you need any help, just ask :)
I have previous experience with ruby and other languages. I also have many learning "gaps" in fundamental programming terms and OOP and I want to read everything from the beginning. Just dig deep in the language, the deepest I can go and be an expert. Cover everything that keeps me back. 
heh heh heh.
&gt; And I can't figure out for the life of me how to create a dev environment for Ruby on ubuntu...course maybe I just need it to be a LAMP stack. A LAMP stack is for PHP (which is the P in LAMP). You should get the instructions for setting up RoR in your environment [here](https://gorails.com/setup). CodeSchool's resources are pretty good if you like to learn step-by-step via videos. If you prefer books, I'd start with [The Well Grounded Rubyist](http://www.amazon.com/The-Well-Grounded-Rubyist-David-Black/dp/1617291692/ref=dp_ob_image_bk).
Ruby or rails? ruby: http://learnrubythehardway.org/book/ rails: https://www.railstutorial.org/book both free
Rainbows just spawns many processes, each could be multithreaded (if you choose ThreadPool or ThreadSpawn concurency). Hidded behind something like nginx for slowloris protection, it could we very relyable. I used Rainbows with EventMachine concurency option, and it works pretty well, cause our custom framework were built around eventmachine and em-synchrony.
Well, it should put the lotion on its skin, and I expect it to, but usually it raises the hose again.
As previously mentioned, check out https://www.railstutorial.org/book
What he mess is that? `person.send_email`, really? What does this say exactly? should this person send email to someone? Or email should be send to this guy using a service that you just told it to use? Why not: person = Person.find 1 mailer = WelcomeMailer.new # inited via IoC or via inherited #transport which is coming from config mailer.send_to person # ask this guy his address, that's that needs to be known. May be a person or a company Why you would want to return self instead of returning `true`? Ladder logic/chainable calls? I already imagine this as an ugly `Person.find(1).set_mailer(mailer).send_mail`. I love composition and concatenative languages, but this is so much far from that.
even NOTHING is an OBJECT!
 def it(what, str) send(what, "#{__method__} #{what.to_s} #{str}") end it :puts, "the lotion on it's skin or else it goes the hose again!" Gotta be a more clever and sugary way to do that.
Decent env setup guide for Ubuntu - [https://gorails.com/setup/ubuntu/14.10](https://gorails.com/setup/ubuntu/14.10)
So leave feedback? Could make a Github integrated app maybe, link to it under prs or something 
A ruby ide could at least give typehints if the class isn't constructed via meta-programming. Also some people may prefer dot notation vs [key] indexing notation but you could probably add that behavior to hashes if you wanted to.
Can't argue with that 
Thanks for that. I've not tried Slim, but it looks pretty nice. Sort of halfway between ERB and Haml. I know what you mean about the whitespace thing, but it's ok in small doses. BTW, if you want to be doing fairly strict MVC, try not to get too carried away with using Ruby code in your templates. With MVC, you're not supposed to be working like you would with JSP, PHP, etc... where code and markup gets intermixed. What you're *ideally* supposed to be doing is putting all of your logic and gnarly Ruby code into your "controller", or with Sinatra the "script" side of things, and putting ALL of the nice presentation-related stuff into your "View" or template. In this case, your Slim template (View) should be almost *all* markup that will produce HTML, and with a small amount of Ruby; just enough Ruby to pull information out of the objects that you've set up in your controller. The concept is very strange at first, but once you get the hang of it, it's quite nice. The reason why this approach is often used is because it means that the Views can be designed by designers (possibly made by designers too), and the devs concentrate on the programming side. The devs would tell the designers what object can be used, and how to pull data from them. In my own code, I set up lists of data items and things in hashes and arrays, any object like @docList will be available in the View. In the View, I then use just enough Ruby to iterate over the objects and generate the appropriate HTML or whatever. You shouldn't be doing much, if any calculations or other complex processing in the View; move that back up into the Controller (or Model if you've got 'em). Also, splitting the Controller logic and View into two like this means that you can choose to output different views, if necessary, from the same Controller. For example, you might want to have specific Views for desktop, mobile, Excel, Text, PDF, image output, etc... 
 &gt; nil.class NilClass &lt; Object Good god.
If you really want to blow your mind, go work on the Ruby Koans. The Googles will guide you.
It's a lot more verbose, but this works: class It alias_method :pretty_inspect, :inspect [:puts, :gets].each {|m| undef_method m } def initialize(&amp;block) @words = [] instance_eval &amp;block end def method_missing(word, *args) @words.unshift word.to_s.gsub '_', '' self end def it(*args) @words.unshift "it" self end def self.method_missing(word) new.send(word) end def inspect "it #{@words.join(' ')}" end end def it(&amp;block) It.new(&amp;block).inspect end it { puts the lotion on its skin _or _else it gets the hose again }
This looks correct to me. The only thing I would mention is that someone might say, "... but there's no cat #0. The first cat is cat #1." In which case you would have to adjust your answer because they are asking for which cats have hats, not what are the indexes of cats with hats.
awesome. easy fix just add 1 to each of em. thanks!
If you're a journeyman-or-better craftsman in *any* real OO language coming to Ruby, Jim Gay is one of three or four guys you'll want to read avidly, just to keep your sanity. Too much of this community has degenerated into a *WWDHHD?* way of doing things, and that's *lethal*.
The other reason to return `self` is so that you can chain methods together without worrying about Law-of-Demeter violations (which are really just defects waiting to exhibit failures): items = items_in_basket.select { |item| item.available? } current_order.new.add_items(items) .set_customer_details(current_user.as_customer) .set_delivery_provider(default_delivery_provider) .confirm! Each of these methods can be tested in isolation, ,and does *not* leak internal details out to the caller, *because* they return `self`. 
Just took a look at it, a few pointers: There's still a few quirks in your iteration through the stock prices. Right now, you're creating an empty array (*profit*) and sticking it in (*buy*). While pushing a value into *profit* later on in the loop will modify it in *buy* also because it's referencing the same object, doing it this way is kind of sneaky. Your *diff* variable is essentially an improved version of *profit* since it filters out the invalid buy/sell date pairs. I'd lose *profit* all together. Likewise, a lot of the the work your code is doing after you've gone through the stock prices could be made a lot simpler if you do it as you go the prices the first time. I'd keep track of the best profit (and buy/sell dates) yet seen as you go along, and just return them at the end, rather than working through arrays with a lot of data you don't need. if you give up, I wrote a quick solution with explanation: https://gist.github.com/jshorty/f91bada616075c5bf4a9
Thanks a lot, the article looks like almost what I want. The truth is that I got interviewed last week for a (dreamy) ruby developer position in an awesome company and they told me that I need more practise to work with them. They told me to read until I fall to the ground for six months and then come again. If the time justifies the progress I've made, they'll hire me. So I am looking to do that, become an expert in six months. I know you'll laugh but is an extreme challenge and I will sell my soul to Ruby to win this game. I'm a CS graduate with some years experience in programming and freelancing but I need to cover every step missed, every term mis-educated. Many thanks.
Can't recommend this book enough. My ruby was mediocre before I read it and now I am contributing to Ruby projects on GitHub.
Now just output the names of those cats. ;-)
What really helped me understand *how* they work was playing around with classes and instantiation. Fire up irb/pry, and create simple classes. Make them funny and give them funny attributes, that might make it more memorable. Make them with attr_accessor, make them with attr_writer only, make them with attr_reader only, make them with none of them, etc. Then keep instantiating and calling/setting properties and seeing what works. Seriously, do that right now and keep doing it until you start to see the relationships between how you set up your classes and the objects you create. 
When you're designing a class, it's really handy to be able to just expose values publicly. In languages like Java, you can do that -- let callers get at your class's instance variables directly. However, there's a snag with doing that -- at some point you might want to add some validation, or make field value changes have side effects. For instance, you might have a class which wraps a REST API which returns a list of values. Initially, you just call the API and return the array you parse out. At some point, though, you'll probably find that performance is a problem if you are referring to this list a lot and searching it. So, you might want to change the implementation, and use a more elaborate data structure inside that caches the data rather than doing an HTTP call every time, and builds some sort of index and allows fast searches through additional methods. In Java, you wouldn't be able to do this easily starting from your field-based approach, because replacing a public field with a public method requires changing the syntax used by the code accessing the value: // Field syntax final List&lt;String&gt; foo = obj.value; // get obj.value = bar; // set // Accessor method syntax final List&lt;String&gt; foo = obj.getValue(); // get obj.setValue(bar); // set So in Java, best practice is never to expose fields directly, in case you ever need to change the implementation. That way the people using your code are less likely to need to go back and change all their code. In Ruby, the Java best practice is the standard behavior -- Ruby doesn't have a way to make your class's instance variables public directly. Instead, you need to have an accessor method. However, Ruby's syntax makes a no-parameter accessor method _look like_ direct field access: # These two lines are equivalent foo = obj.value foo = obj.value() # And so are these foo.value = bar foo.value=(bar) The latter is a call to a method called `value=`. Basically, what looks like field access in Ruby is just syntactic sugar for method access. This was a clever approach, but left Ruby with a minor problem: Writing accessor methods is a pain in the butt. So `attr_accessor`is a bit of syntactic sugar to make it easier to add a pair of accessor methods for any given instance variable. Functionally, attr_accessor :value is exactly the same as writing def value=(x) @value = x end def value return @value end In reality, using attr_accessor lets MRI do some optimizations which make it faster, but semantically it's the same. It's such a good idea that people keep proposing to add something like it to Java, and there are [third party libraries which do it](http://projectlombok.org/features/GetterSetter.html)...
I can't help but comment that 'git-like' is about as far away from 'awesome' as it's possible to get in a command line interface. It might sell better if a different example was chosen...
why?
Something makes me think that this would be better expressed using rspec.
thanks for that.
I see. Yeah, you're right. Decisions on a big app are sometimes much different than little toy apps. Unfortunately, I'm not sure how you'd replicate that without working for a company that has a busy app.
Doesn't seem like a reasonable expectation. If I were, I'd continue your search at a place that might be looking for someone less senior so you can continue your learning. 
Unfortunately, from a business perspective, you can't trust Passenger as a company to accurately and truthfully communicate with you. At this point, anything they publish -- performance metrics, specs, responses to bug reports -- should be taken with a big grain of salt. EDIT: Downvoters, I have some oceanfront property in Kansas you might be interested in.
&gt; He's resisting pressure to move development to a proprietary platform. I agree it doesn't qualify as a "temper tantrum," but this is a little bit of a misinterpretation. He's resisting pressure to *provide easy-to-use tools for cross-developer communication and collaboration* based on the flimsy ~~logic~~ assumption that doing so would *implicitly require* him to move his development to a proprietary platform. Sure, the guy who started the thread asked about Github specifically, but that doesn't mean that Github is the only option. He had a valid point: the current setup made it hard for people, especially people who hadn't been there since the beginning, to search the repo, fork it, make changes, report issues, and generally manage the source. I agree that Github has its drawbacks, but what's wrong with wanting to minimize the friction of the development and collaboration process? There are parts of the open-source community that see any attempt to make that community more easy-to-use and developer-friendly as a threat to its existence. Instead, IMHO, the open-source community needs to consider not just the UI/UX of their applications, but the UI/UX of their developer community -- the DI/DX, if you will. Poor developer experience drives developers/contributors away, just as poor user experience drives potential users/customers away. It's sad to see so many people in the OSS movement, like this guy that /u/Paradox linked to, fail to understand this. His project is going to suffer (has already suffered) as a result. ^(EDIT: Typos.)
Sure, we should make things easier. But the problem is that people specifically push GitHub as the one and only place that software should be hosted.
Not sure if it's the best way to do it but you can set the path of the gem to point to the one you've cloned. I.e. gem 'mechanize', :path =&gt; '/path/to/gem' 
so is @MeikaLeak right ?
you could as well do t.menu_items.new but let me check if &lt;&lt; operator shouldn't be working.. EDIT: Nope, not working for me either. the &lt;&lt; operand is inherited from array and doesn't do anything extra like associate the objects. You would need to manually set the id's and save the ticket. It's pretty nice though, it'll set things just the way you want them. item = mybox.items.new item.box # =&gt; mybox this works on any collection, and brings any requirements on that collection into the created object. item = Item.where(color: :red).create item.color # =&gt; :red also works on scopes! item = mybox.red_items.create item.box # =&gt; mybox item.color # =&gt; :red also, I reccomend using .count rather than .length.
Sure, but my point was that most often when you group by :first you can instead group by :shift. I have seen the group_by(&amp;:first)+map used very often where group by :shift would have done the job with much less code.
on top of what everyone else has said, you can also simply install your git cloned gem. Just run rake install (if mechanize has a rakefile that contains the bundler tasks that is). 
Pretty slick. One thing to keep in mind though: the shift operation modifies the original array. Of course that's a big part of the trick. I will be using it. Thanks.
Thanks for your help. I am working on a codebase built by a new rails developer and it turned out he was doing this: class Ticket &lt; ActiveRecord::Base has_many :ticket_items def ticket_items ticket_items = Array.new TicketItem.where(['ticket_id = ? AND enabled = TRUE', self.id]).each do |ticket_item| ticket_items.push(ticket_item) end return ticket_items end end yeah... Def did not see that coming.
solved here http://www.reddit.com/r/ruby/comments/2vsp50/active_record_model_isnt_being_added_to_has_many/col00w0
Ok so hopefully this isnt too late of a reply to this thread. I see alot of paid/unpaid virtual rails interships online... Mainly chegg.com. Does anyone have any experience with getting a ruby internship or a better question is what level of knowledge does an intership require. I am thinking a github with a few websites but does it need to be original sites? Uber noob questions.
Could someone having used both Jekyll and Middleman please share your experience of advantages/disadvantages of one vs the other?
Not gender, but related to offending people (Django is a web framework for Python): https://github.com/django/django/pull/2692 And here's a talk on sexism at LA Rubyconf 2014: https://www.youtube.com/watch?v=xxqIw_oL-Go I have my opinions on both matters if you wish to know them.
are u going to 'map-reduce'? Then try val.each_with_object({}){|v,h| h[v[0]]=(h[v[0]]||[]).concat(v[1..-1])} Or val.each_with_object({}){|v,h| h[v[0]]=(h[v[0]]||[]) &lt;&lt; v[1..-1]} 
It only makes sense to prevent checking the return value of these methods on caller side. You only need return values is rare cases. It is mentioned in the topic.
It’s such a shame that all links to RubyForge projects are broken. This includes links to the documentation for many popular Ruby gems. Please help fix this by contributing redirects.
I like Middleman a bit more because it seems more powerful. * Jekyll uses the Liquid templating system, which is friendly but not as powerful as ERB. Middleman supports a range of templating systems, including ERB. If you have a designer in your team who is not a programmer, then Liquid is a good choice. But if everybody in your team is a programmer then may as well go for ERB. The fact that I could use ERB means I embed complex logic in the HTML generation. * Middleman allows you to write arbitrary Rails-like helper methods, which you could call from ERB. * I haven't found a way to map subdirectories to sub-URLs in Jekyll. For example, if I make a file 'foo/bar/baz.md', then Jekyll doesn't generate foo/bar/baz.html for me. No idea why. Middleman works pretty much as expected. But my use case is to create static websites. I haven't used either of them for blogging, so no idea how they compare for that use case.
Thanks. Will try it out. Cheers.
Great.
:( If it makes you feel better, I have a front-end guy who is overriding &lt;ol&gt; elements and writing his numbers in manually.
That's a valid point. I'll change that. Thanks!
For the avoidance of doubt, OP is [floehopper](https://github.com/floehopper/), not [tom stuart](https://github.com/tomstuart/). 
I can't take any credit. This was the work of Tom Stuart [1]. Hopefully Ruby Central will see the wisdom of pointing the rubyforge.org DNS at the instance of this app running on Heroku. [1]: http://codon.com/ [2]: http://rubyforge-redirects.herokuapp.com/
What these are asking is whether or not boolean_1, boolean_2, and boolean_3 are true or false. In order to determine this, you have to understand what is meant by the logical operators AND, OR, and NOT. Ruby uses &amp;&amp; for AND, || for OR and ! for not. I am not certain where your knowledge level of logic stands, so forgive me if I go too fast or too slow. We'll start with the ! operator. It means (roughly) what "not" means in English. Therefore: !true = false !false = true The &amp;&amp; symbol means AND. It is testing whether the statements on the left and right of it are true or not. If BOTH the left AND the right side are true then the whole statement is true. true &amp;&amp; true is true. false &amp;&amp; false, true &amp;&amp; false, false &amp;&amp; true are all false. The || operator roughly stands in for "or" in english. If *either or both* of the statements surrounding the || are true then the whole statement is true. true || true, true || false, false || true all evaluate to true. false || false evaluates to false. Let's look at some examples in English. Horses are mammals AND Violets are fish. This evaluates to false. Horses are mammals, but violets are NOT fish. When AND is the operator, *both sides* of the statement must be true for the statement as a whole to be true. Socks are worn on your hands OR Horses are mammals. This evaluates to true. One or both of the statements on either side of the or must be true in order for the whole statement to be true. Now let's break down your problems: boolean_1 = ( 3 &lt; 4 || false ) &amp;&amp; ( false || true ) Three *is* less than four, so the statement 3 &lt; 4 evaluates to true. Therefore we can re-express the statement as: boolean_1 = ( true || false) &amp;&amp; ( false || true ) true OR false evaluates to true, as only one of the statements on either side of the || needs to be true for the entire statement to be true. false OR true also evaluates to true for the same reason. So we can re-express the statement as: boolean_1 = true &amp;&amp; true In order for a statement of the form "A and B" to be true, both statements A and B must be true. This is the case here. true &amp;&amp; true evaluates to: true. Therefore, the final re-expression of the statement is: boolean_1 = true boolean_2 can quickly be seen to be false. In order for a statement of the form "A AND B" to be true, both A and B (whatever they are) must be true. In boolean_2 we can quickly see that the left side, !true, will evaluate to false. So whether or not the parenthetical statement on the right is true, we know that the whole statement is false. What about boolean_3?
https://www.youtube.com/watch?v=g37HT4-EtzE
where did you see "lots of brackets, temporary variables"? My variant contains one function call anstead of chain in origin, so it is simpler. And my variant is obviously optimal both in CPU and memory concern. If you one of those men who claims that ruby is fast enough, than you may write slow and memory hungry programs. I am a man, who thinks that ruby can be fast, if i understand how it works and use it strong sides.
knowledge is kinda irrelevant in this scenario, as a slightly more experienced ruby dev isn't that much better than you in the grand scheme of things. they just want to know that you're motivated to learn more about ruby and that you'll be a good addition to their culture. go for it, there's no reason not to
There are 10 pairs of brackets, for a "one liner" method. That is too many, especially for ruby! Your code may be efficient compared to a more aesthetic solution for the same problem, but if you're really THAT concerned about speed then you should probably be using a different language to begin with. 
Just to add (your answer is right) another thing that you should be aware of which a lot of people overlook initially is [operator precedence](http://www.techotopia.com/index.php/Ruby_Operator_Precedence). First, let's cover some basic technical terms: * || is called an **operator** * values which an operator acts on are called **operands** * when put together correctly, it forms an **expression** * an expression is any valid code that resolves to a **value** More visually, it looks like this: x = true || false ^ ^ ^ ^ ^ | | | | | | | | | +-&gt; operand | | | | +-----&gt; operator | | | +----------&gt; operand |&lt;---expression | +-------------&gt; operator | +---------------&gt; operand | You'll notice there are actually two operators there. However || gets evaluated before = does. This is because the precedence of || is higher than the precedence of =. It's an important concept to understand because as you can see, expressions are not always evaluated from left to right.
Bad parts: no tests, 4 spaces indentation, explicit return, manually creating tempfiles, rm_rf and exit piece repeated, error,output goes to stdout. But all of this do not matter that much if the gem does it job well and is not planned to be extended in the future.
People usually have no idea what sudo is, and 'why is apt-get install x not working' is a very popular question. So probably this need to be left as just "you need to install lcov", since there are dozens of different yum/apt/pacman/emerge/pkg options to install that lcov on different systems, but this gem will work just the same way.
This is a fantastic answer. It's also worth pointing out that Ruby is lazy when it comes to Boolean operators. If the first term of a || statement is true, the second is not evaluated. If the first term of an &amp;&amp; statement is false, the second is not evaluated either. This is especially important to understand if OP tries Rails, but there are some clever uses of Boolean logic that take advantage of this fact.
I've used the bullet gem to find and optimize n+1 and frivolous eager associations. Goldiloader should be fine in a small project, but eager loading everything doesn't sound like a scalable solution. It's quite trivial to call #include on associations you want to eager load, so so consider using bullet to fine tune your code manually. 
Yea, I saw that after I posted. =/ I still think it's cool ;)
It's worth noting that in the case of `boolean_3`, it does not matter what is on the right side of the `||` operator. Similarly, the same is true of `boolean_2`. If the left-hand side of an `&amp;&amp;` expression is false, Ruby (and many other languages) will simply not even bother to evaluate the right-hand side, because the whole expression is false by virtue of the left-hand side. Likewise, if the left-hand side of an `||` expression is true, Ruby (among others) won't bother to evaluate the right-hand side, because the whole expression is true y virtue of the left-hand side. This is called **short-circuiting** and is commonplace. So, for example, if you have an expression like `f() || g()` (where `f` and `g` are functions that take a while to return a result), then if `f()` returns true, `g()` will *never* be called, because its result will never be used.
An unpaid software development internship is most likely some sort of scam. Software developers are in such high demand that even interns earn a decent (often hourly) wage. Keep that in mind.
To be clear for those going "the heck does nmatrix have to do with linear algebra?", this has nothing to do with the nmatrix site used for nzb's from usenet.
The basic routing and app initialization looks exactly like Sinatra, which has more documentation for advanced usage. You could probably switch to Sinatra without changing much of any code at this point. Not sure yet what advantage you could get from NYNY
2. Yep, two spaces. There are other style errors, but not that severe. 3. In ruby the result of calculation of last statement in method is a returned value, you do not have to explicitly return it. You even have to sometimes prevent it. I will watch the repo, so get ready for more.
The problem with frameworks like this is that you'll find they simply don't have what you need when you go to build more complicated applications. Rails and similar frameworks are a lot more "everything and the kitchen sink too" which makes them more intimidating, but when you need a tool it's often already there. They also do nothing to assist with structure, which will appeal to some, but ultimately might be a significant hurdle for a novice.
This is a neat way to look at it.
If you read the article he outlines what guesses those are. The principle he's arguing is that in more cases than not, query speed improves from eager loading in the way he's describing more often than it's detrimental. Just like one can misuse indexes or other performance optimizations, I think the insight of this approach is that broadly, many projects suffer more from not using eager loading than they do because of using it. Every project should obviously benchmark their project before and after with this gem before using it. My point of posting this here was hopefully to start collecting data on other production projects to see if it helped others in the dramatic way it helped our app.
nzb's? Now I'm one of those going, what other NMatrix is there?
&gt; And I can't figure out for the life of me how to create a dev environment for Ruby on ubuntu I wrote up a [short spiel to answer some similar questions](http://www.reddit.com/r/rails/comments/2la27p/super_noob_here_hopefully_you_guys_can_help_me/cltclkj). &gt; I know what I want to build just don't know how to use Ruby to do it. The first book you need to read: [The RSpec Book: Behaviour Driven Development with RSpec, Cucumber, and Friends](https://pragprog.com/book/achbd/the-rspec-book). The test code examples are a little dated but you can learn the syntax differences easily enough (they're minor, and it's good to recognize both because you will see both). The important topics are the concepts the book covers: how to write tests and use TDD/BDD. The second book you must read is: [Practical Object-Oriented Design in Ruby](http://www.poodr.com) by Sandi Metz. This will get you thinking about writing better software and will help reduce the amount of spaghetti code you write. [It's also worth watching any talks she's given](http://confreaks.tv/presenters/sandi-metz). They get you to start thinking about things you wouldn't have otherwise and give a good jumping off point for other resources. The other second book you'll want to read is: [Michael Hartl's Rails Tutorial](https://www.railstutorial.org/book). There's a reason people keep recommending it. Last word of advice: *Learn Git*. [Hartl's book has a section on it](https://www.railstutorial.org/book/beginning#sec-version_control) that will get you started with the basics. Google and SO will fill in the blanks.
Like you said, the block you're passing into `signal_connect` is holding a reference to `label_loop` rather the value of `label_loop` at the moment the block is defined. Try getting rid of the earlier definition of `label_loop` (which is not in the code you provided) and doing this instead: 0.upto($counter) do |label_loop| $my_label[label_loop] = Gtk::Label.new "#{$collection[label_loop].name})" $delete_buttons[label_loop] = Gtk::Button.new :label =&gt;"Delete" $delete_buttons[label_loop].signal_connect "clicked" do $counter -= 1 $collection.delete_at(label_loop) show_all end $grid2.attach $my_label[label_loop],0,label_loop,1,1 $grid2.attach $delete_buttons[label_loop],1,label_loop,1,1 end
For more info about what's happening w/ your code, check out: http://en.wikipedia.org/wiki/Closure_%28computer_programming%29
This is a band-aid at best. You should be endeavoring to fix these problems the right way, by hand.
Optimizing queries on the fly is exactly the kind of thing that we should be engineering solutions for. These same people trolled knives when they were invented, because if you know what you are doing, you should be manually tearing apart animals with your teeth.
We use ruby without Rails and SQL, and serve 100k requests by 7 common servers (one query to in-memory database + some calculations). Yeah, CPU is almost idle, so we could write "less optimized" code. But why? Now we sure that we could serve 500k requests, and may be more. Why should we slow our application and loose this insurance? Two days ago a guy came to me and said: "we make a query to 20000 rows and then we do calculations. With ActiveRecord it takes several seconds. But if i go to the database by simple Ruby scripts, it takes less than second." At this moments you realize, how inefficient code could be written. And language doesn't matter. ActiveRecord has a ton of functionality, and it is very-very-very slow. Take a Sequel http://sequel.jeremyevans.net/ - it is almost as functionality-full as ActiveRecord, but it is a way way faster. Cause Jeremy Evans thinks about places, where Ruby spent CPU time and memory. Look at http://blog.kaspth.com/2015/02/02/Giving-Rails-a-Speedy-Contribution.html - the guy just take a moment to think, and instead of "making more functionality" he gives a bit of quality! ActiveRecord, ActiveSupport and friends have a lots of places, where functionality is built without thinking of speed. That is why "Rails is slow". That is why Twitter ran to Scala, and many go to Go. If every peace of every library were rethought in term of speed after functionality stabilized, then Ruby will be reliable platform. But now there is more "take other language for speed" thinking, and rush for functionality at any price. And Ruby is loosing its auditory cause of this. 
Yeah, I would recommend Sinatra over this. Sinatra isn't exactly a model for complexity.
That fixed it for me. Thank you. I don't have time right now, but later I'll read through that link, because right now I don't quite understand why.
I just did this same thing in my latest project. As Borris said, create a bin folder and a file which act as your executable. Checkout my gem here: https://github.com/markphelps/tictac bin/tictac creates a new instance of my main class and runs it Bundle install and you should be good to go
A dutch LL(1) parser, I like it!
Ah, I didn't know that about methods in Ruby. Thank you!
The number that you post shows that my methods always faster, cause `group_by(&amp;:shift)` has same result as my fastest code. But my fastest code is safe at the same time and at least as readable. When you measure that one line of code, than "0.1 sec for 100000 loop iteration" looks small. But it *is* 10%. And if one always writes code like this, than it is always 10% of *loosed performance*: 10% more response time, 10% more servers, 10% more power comsumption. I were "performance seeker" for a long time. Now I know, that code should not be always as performant as possible. But still: if couple of minutes of thinking can make your code faster without loose of understandability, than you should spend this minutes instead of rushing further.
ripper-tags is better for ruby source as it detects more ruby subtleties like :: Install gem-ripper-tags and vim-bundler for the ultimate goodness.
Roughly a year it seems? https://www.reddit.com/search?q=nmatrix&amp;sort=relevance&amp;t=all Though I doubt they would be angry or anything like that, it's just that the usenet nmatrix will probably be much higher in google rankings than yours.
It helps with managing responsibilities. If you can ask an object questions about itself, you can perform actions on behalf of it, instead of merely making a method on that object which does what you want.
Thats quite tempting but i am having a hard time believing the only requirement for ruby web development jobs is to know a little ruby. Is it because of its ease or the scarcity of ruby developers? 
Hi! I started learning Ruby not long ago, so we may have things in common. Also, check out the people I'm following, I guess I have plenty of the big names in the Ruby community covered. 😊 My handle: @lcjlls
Personally I have no problem with, and even prefer, explicit returns on methods that are more than 2 lines or so. 
You should probably write down your Twitter handle here too so people can follow you easily. 😉
Because you can't use an assignment operator that way. I'm still pretty new at this stuff, myself. Even so, I'm a lot more comfortable doing: object.varname = value Than I am doing: object.varname(value) That's because I don't need to waste a lot of effort remembering the details of how the varname method is implemented and whether or not I stuffed other functions in there. I can just outright set it with the same kind of assignment operators I'm using the next line up or down in my code. It's really easy to keep a natural flow going and I can tell exactly what's happening even at a glance. If it's been a month since I touched that particular piece of code and I wrote it when I was on a 36 hour no-sleep bender I'll have to stop and look up what varname(value) is doing just to be sure I'm remembering it right. Also... varname is the method that returns the current value of varname by default. By doing varname(value) you're overwriting varname. Now you need to add some more complexity or come up with a way to differentiate it. Whether that's: def varname(value=nil) if value @varname = value else @varname end end # Or: def varname_get @varname end ...I've got extra headaches in my project now. Edit: Consider that if it does allow an assignment operator off varname(value), how does Ruby know that specific method gets one? Do you want every method to have a function with an assignment operator or will you just have to include an extra command in the method, or...? Edit 2: *facepalm* Just realized I can do that example better. But I do think it would be a bit more of a headache having to parse (and type) the added parenthesis everywhere.
Depends if you go to school or not, then an internship is pretty much required.
I don't now where you live but here in the Netherlands unpaid internships are pretty rare. Hell, we only have internships for school basically. Otherwise you just apply for a junior level job. Basically, unpaid internships are a scam to get cheap devs.
Because calling "o.varname" should return the value of varname (it's the getter method). Using an = sign allows ruby to differenciate between a setter and getter method.
&gt; But I always need to dig through the man pages and tutorials before I can do anything with them. I read that as "I'm lazy and I don't care about performance." Which, to be fair, [can be an entirely reasonable thing](http://xkcd.com/1205/), but you should definitely understand that this approach will typically result in execution time on the order of "I'm going to go make a sandwich and come back in a bit." Fine for one-off tasks, but probably not a good solution for automation. If you never need to automate anything, not having `sed` and `awk` in your toolbox is fine. If you do, then it's probably worth spending some time to learn how to use them. In practice, `sed`, `awk`, and unix pipes are among the most performant special-purpose ways to implement batch processing of text and data, and `split` and `parallel` give powerful options for parallelizing tasks in addition to the built-in parallelization you get for free with a pipe.
[Image](http://imgs.xkcd.com/comics/is_it_worth_the_time.png) **Title:** Is It Worth the Time? **Title-text:** Don't forget the time you spend finding the chart to look up what you save. And the time spent reading this reminder about the time spent. And the time trying to figure out if either of those actually make sense. Remember, every second counts toward your life total, including these right now. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1205#Explanation) **Stats:** This comic has been referenced 161 times, representing 0.3099% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_comynvj)
I can't get this to work, probably because it's messing around with some deep ruby-internals! (*if* is a reserved word?) I just get the error: &gt; SyntaxError: unexpected '{', expecting keyword_then or ';' or '\n' However, you can instead define your *own* if method such as: def my_if(expr, &amp;co) expr.call if co end my_if(true) { puts "Brackets!!" }
Yeah, I'm using alt+255 after the if, so it's actually if with a space after. So it is, technically, different than the original reserved if. And it works!
Well phusion passenger did used to be called mod_rails.
Yep, that's where I got inspiration! Except no need for utf-8 for this one
What would be the other requirements? Spinning plates on your nose? Unless you are getting into a certain industry (banking etc) that requires specialized knowledge out side of programming, you'll be fine. There is no "once you reach level x you are officially a programmer." Any person who writes hello world qualifies. What you need to do is learn the very basics and then make it clear to your potential employer that you are on a mission to learn because you love programming. Tell them you study on your own but want to work with other devs so you can get ideas from other people and see how they work etc. Make sure they understand you don't necessarily want someone to hold your hand but just need guidance for when you happen upon situations you don't understand. you can spend 2 months learning on your own and be 6 months ahead of someone who is just being told what to do. The bottom line is; you have to put the effort in. You will probably find a low paying dev gig and love it until you lean more about the industry and are that this place is total shit. you can then take you year of experience and hustle into something new. One you have a couple years under your belt you shouldn't have a problem finding a job.
I live in Chicago (a ruby mecca) and a degree is absolutely not needed. Just show you 'get it' and your fine.
I'm sorry, I corrected the mistake. My question targets to why use an equal sign and what's the difference when executing the code.
That's pretty cool, wish it was like that here. Although, what I meant was that studies sometimes require you to do an internship (or two).
To do this in Vim, I found the easiest way is: In insert mode, enter \^VO255, or \^V160 (see [here](http://www.fileformat.info/info/unicode/char/00a0/index.htm) and [here](http://vim.wikia.com/wiki/Entering_special_characters]) for more info)
https://help.github.com/articles/set-up-git/ Installing a gem 'from a git repository' is not the same as 'installing git'. Check github's help site above for doing the latter, that's probably what you want.
Thanks for your time. What I am asking is what's the difference between `def prop=(p)` and `def prop(p)`. Why use the "=" sign? I have a C++ background where every method should be called as function(attribute) and not function=(attribute). 
&gt; It still confuses me How? In C++ or whatever, you use the name `set_prop` to signal the method is a setter, in ruby, you'd use `prop=` to do that. And you get some nice syntactic sugar for free. I don't really understand how that's so confusing. So if you can explain why you are confused, I might be able to explain it better.
You made a ruby gem and then used apt and pip to distribute it? Why?
Let me start with one way of using Twitter: * Think of it as a geek party * You don't need to read everything * Inspiration is important * By default, follow everyone related to the topic - keep unfollowing if you find someone annoying * Unfollow those who don't tweet - Twitter has a follower limit You can read more about this Twitter strategy in my blog post: http://andrzejonsoftware.blogspot.com/2014/01/twitter-as-geek-party.html Finally, consider following me - [@andrzejkrzywda](http://twitter.com/andrzejkrzywda) - I tweet about many Ruby/Rails related topics.
Sorry, your about to discover that the first step is undertanding what's going on, and what you want to do. "how to get a git installed" doesn't really mean anything, the question doesn't make sense. Git is the name of a piece of software used by developers to track changes over time in the software they are developed. Software using git to do this lives in a "git repository". You can also use the git software to check software out of a git repository, even if you don't plan to change it. Do you already have git, the software installed? A ruby "gem" is some ruby code that is packaged up as a reusable library, for other developers to use. Not all ruby code is a gem, just things that have been packaged as gems. Ordinarily you don't need to use git to install gems, you install them with the command line `gem install gemname`, and you can also choose to install specific released versions of the gem, if there are more than one. You can also install gems with the ruby 'Bundler' software. Bundler is software that lets you track _which_ gems your project is using, and in particular which _versions_ of those gems. It can also automatically install all the gems your project needs (with the right versions) when on a new machine. The [bundler website](http://bundler.io) is pretty good docs. So normally you don't install gems from git directly, but use the `gem` command line, or bundler, both of which will get a particular version of a gem from rubygems.org, the hosting site for ruby gems. But sometimes you need a version of a gem that hasn't been released yet, and in those cases you can check out the gem directly from git to use different in-development or not-yet-released versions. Bundler makes this a lot easier to do. Ruby software you find in a git repo may or may not be a gem. If it's not a gem at all, then you use it just by checking it out of git and using it however it's meant to be used -- or by other install instructions the software gives you, like downloading a zip or something. If the software you found on github is a gem, then you still might not need to use git to use it -- you found the software's source control repository on github, but if it's a gem, you still ordinarily use it simply by `git install whatever` or by using Bundler. You only need to use git directly if the software hasnt' yet been officially released or you want a version of it that has not yet been officially released. And then you'd normally use bundler to manage this for you. (Or you might want to check it out from git if you wanted to help develop it, send changes back as contributions). So, with all of that out of the way -- what is it you actually are trying to do? 
Almost. I didn't get the syntax on your first line, sorry :)
Well [the Rails core developers](http://rubyonrails.org/core/) seems like an interesting bunch to follow, followed by the authors of your favourite gems and holders of your favourite talks.
It's a git repository that is a ruby gem. 
ok I'll check this out, thanks
Thanks
And is there a reason you want to install it directly from the git repository, instead of using a released gem through the normal mechanisms? If you understand the question, and there is such a reason, then your answer is bundler. http://bundler.io/git.html But if you don't have a reason to do that, you should use the gem through the ordinary means of using gems, not directly from the git repository. 
Cute, but scope doesn't work quite the same way. Variables created inside the block won't be available outside of it. As long as you create your variables before the conditional it should work though.
How about an object oriented if statement, that doesn't internally use a conditional? Define, say, `Object#yields` that always executes its block, then override it for FalseClass and NilClass to always discard the block.
No but it's been my understanding so far that's what I have to do. All I'm trying to do is run the program that's presented in a particular gir repository, don't care how I do it I just want it to run. 
Yoooo that's kinda cool. EDIT: As I think about it, it's actually kind of surprising that Ruby doesn't have this. I don't think I've ever used a `for` or `while` loop in my production code, because Ruby provides OO iterators, and encourages their usage. It's actually a bit of a surprise to me, given that, that Ruby didn't commit and provide that same feature for conditions. I guess you can sort of emulate an OO and algebraic implementation that doesn't require keywords by short-circuiting...
Then you just want to include the gem in your Gemfile and run bundle install. It doesn't matter that it's sourcecode is on github, it doesn't matter where it's source code is located or presented. All that matters is that it's a released gem. You include released gems in your project by including references to them in your Gemfile. Also, "run a program" isn't really an accurate description of what you do with a ruby gem. Gems are code libraries, typically they include code that you can use in your app by writing code to use it, you can't just "run a program" with it. Sorry, there's some contextual stuff you will have to learn to be effective at developing Rails apps. Rails is a toolkit for developers to write software, it's not an application you can just install and twiddle some configuration for. 
Thanks!
Short answer: flexibility and sanitization. Long answer: Cocaine provides different command line running engines. There is a backticks runner, a popen runner, a POSIX::Spawn runner, and a Process.spawn runner. And these runners can log STDOUT and STDERR, and capture error codes. Cocaine also does input sanitization for options automatically. Look through the [Cocaine Readme](https://github.com/thoughtbot/cocaine/blob/master/README.md) and some of Cocaine's [tests](https://github.com/thoughtbot/cocaine/blob/master/spec/cocaine/command_line_spec.rb) to see how that can be potentially useful. I'll be the first to admit I haven't used *all* of the features of Cocaine in this gem, but I predict that I will sometime in the future. 
How did you start with PHP? The way forward is probably not all that dissimilar. Write code, and involve yourself with groups that use the same language. Surround yourself with people smarter than you are and listen to what they have to say. As with any language, don't start by building mission critical production apps. You're just going to shoot yourself in the foot. Ruby has a lot of neat subtleties that aren't always immediately obvious. It takes time to learn these things, and how to use them to your advantage. Start with non-critical personal projects that scratch itches that are important to you, and allow yourself room to make some mistakes. As for "best libraries" - knowing this is just something that comes with time. Often the "best library" is going to start only as the one which meets your expectations. As you gain more experience, you'll start to understand which libraries are the best for you in a given situation. Don't worry too much about it initially.
Ruby Toolbox (https://www.ruby-toolbox.com/) might be a good start, at least in seeing what your options are. They give a reasonable clue on the relative popularity of different packages. As an example, if you look at Authorisation packages you'll see Devise stand out as the most popular package (see https://www.ruby-toolbox.com/categories/rails_authentication). Don't take this as gospel, but it should give you reasonable insight into what other people are using. The thing to remember is that many of the tools you are familiar with in PHP already have an established history in Ruby. In fact, you'll probably find a lot of them were influenced by what had already been built in Ruby land. I think this is more a function of the expressiveness of the language, but it also points to the emphasis on testing and architecture in Ruby. For instance, if you've been using Behat in PHP, Cucumber in Ruby will make sense to you. If you're familiar with Laravel, Rails won't seem too scary. And don't be afraid ask questions. When I started in Ruby a decade ago I found the community very helpful and made the whole experience pretty painless, even when I was a helpless noob. Welcome aboard.
Hey, I've been in the same situation some time ago! &gt; With PHP I know what package managers to use, what the best authorisation libraries are, what active record or persistence libraries I should use (Eloquent or Doctrine for example). I know what testing tools do a good job I find it much easier to find answers to those questions when using Ruby. Working as a web developer you will probably spend most of your time using Rails framework. Rails is quite opinionated, which make it extremly easy to find a "correct" library (and some of them are already "built in" - as dependencies). If you are not sure what to use and looking for the most popular libraries in certain category, I recomment the Ruby Toolbox - it gives you useful usage statistics and can be a great starting point when doing research https://www.ruby-toolbox.com/categories/rails_authorization &gt; Ruby has always appealed to me but I honestly haven't known where to start I'n my opinion a great place to start is: 1. [Programming Ruby](https://pragprog.com/book/ruby/programming-ruby) (also known as The Pickaxe Book) - great book about... programming in Ruby. Easy to read and understand, explains things really well. 2. The [Ruby on Rails guide](http://guides.rubyonrails.org/getting_started.html) I recommend using those to resources to create a simple Rails app. Some people jump straight to Rails without learning about the Ruby language first, but I think it's often a mistake. Some magical and confusing things about the framework will become easy and straightforward if you take a few moments to learn about ruby. If you prefer to start with something simpler and lightweight I recommend Sinatra. It's another Ruby framework very small and compact. The basic structure and philosophy is, IMO, really easy to understand if you come from the PHP background. Oh, and there is also a /r/rails subreddit!
Personally I think this is reversed logic - "test everything marked as 'public'", not "mark everything as 'private' that you don't test". Whether something is public or not depends on whether you want it to be, i.e., whether you want others to call it or not (and, by consequence, whether you are willing to secure against / deal with regressions and other breakage when the thing needs to change).
ty :)
This is wrong. `private` is a terrible tool for future proofing your code. It's an even worse tool for preventing coupling. The `rack` api asks consumers to implement one single public method -- `#call`. But yet the surface area of that API is huge, because of the enormous amount of variability of the input to that method (the dreaded `env` hash). A `private` method here and there makes sense circumstantially. Practice refactoring and design for awhile and it will become apparent that "private" methods used more than sparingly are symptoms of larger code design smells.
A few critiques, in no particular order: 1. In the final example, eliminate all the accessors and just have your methods grab the info like `#min_bottles` directly from `configuration`. If you depend on a config object with particular methods, you might as well be explicit about it at the callsite. You win nothing by splitting the `configuration` parameter into a bunch of small ivars. 1. You still have just as much of an open/closed violation as when you started. Hint: your `#verses` method just outputs a string. If you want to be able to extend the behavior without having to modify the implementation, you need a more flexible output. 1. You don't need the delegators. Just write factory methods that emit `OpenStruct` objects directly. Those delegators are useless. 1. Possible the most important critique. The *nature* of 100 bottles of beer is a concept inherent to a single, individual song. Inventing additional songs where beer is replaced with wine is unsound. You are literally adding complexity to an implementation of a song that *does* exist in order to model a song that *doesn't*. I don't mean to be offensive, but I do mean to be blunt: this is not a valuable piece of education.
Author of the post here, thanks for the link! Much appreciated. I sometimes put these on reddit, but also don't want to look like a spammer. 
I think /u/dunnowins is essentially right. But, I also wanna add to this. You're taking some of it seriously--using travis ci, etc, but you're taking some of it in a very caviler manner. I sometimes review people's githubs and interview them for my firm, and when I look at this, well, it's mystifying to me. I see all of that up top, the code climate, the coverage for it, and so on, for this small personal project, and I say, this guy seems to know what he's doing. Then I scroll down not half a page, and it just seems like you're half assing the rest of it. And, the conclusion that I reach, and this might just be me, but it looks to me like you're copying what you see other people doing without really understanding why you're doing it. Glancing over the code, I don't think that's true. But, if I were looking at the readme, and thinking about hiring you, I probably wouldn't get to the code. I'd probably say, this guy doesn't really know what he's doing. Maybe I'm wrong about this, I haven't tried to run it and I've only glanced over the code, but the readme gives me the impression that it doesn't work. You should, in the readme (or elsewhere, but linked), give a roadmap of the future development. It doesn't have to have deadlines, but give me a general idea of what you need to do. The cleanup you need in order to get this presentable isn't huge, but it would make it look so much better. I'd also echo /u/dunnowins comment that you should invite others to contribute. A roadmap would be good, and contribution guidelines would also be great. What you have isn't quite good enough to invite contributors.
Number 2 isn't correct. You can make new drink songs without modifying existing code, which is the whole point of open/closed. That wasn't possible at the start, so I don't get how there could be "just as much of an open/closed violation as when you started." Number 4 doesn't even make sense to me. What does "inventing additional songs where beer is replaced with wine is unsound" even mean? I can't say to my boss "oh, you want to add feature X? Sorry, feature X is unsound." It doesn't mean anything beyond "because I said so."
I'm not so concerned about how I appear to hiring managers at the moment, but I can see the merit of taking that into account should I consider looking for other developer positions in the future. This project is something I'm doing on the side with a friend for shits and giggles, and may or may not be opened up to other developers in the future. It's more of a vehicle for me to work on my application architecture, and to learn about the inner machinations of sound production. To that end, any comments or suggestions would be highly appreciated :) Thanks!
That's fair. I'm not a hiring manager. I'm an engineer, I just sometimes review stuff. So, we can extend it. You're asking for help on this, and this is how it appears to me.
The kind of assessment I would consider preferable is more to do with the code itself, but I do appreciate feedback of any kind. edit:clarification
No, not really. It's usually not important enough to care about.
Just a last question: Is the equal sign between the name of the method and the parenthesis only used for setters ? Or do I have to think this way for every method? 
Mocha gem can do this. You just say MyClass.expects(:method).never Or for an instance method: MyClass.any_instance.expects(:method).never
I did something similar, and started with https://www.railstutorial.org/book/beginning
This is annoyingly light on details. The only real mention of Emacs there is "I got sick of Emacs for OSX causing my CPU to spin once again". Well, file a bug, or whatever.
I agree that this stuff is all debatable. Ultimately one's choice of editor is a personal preference. I will say that browsing the Emacs package list can be confusing. How many autocomplete packages are there at the moment? How many Javascript modes (Do I use JS mode, JS2-mode, Web mode?). Etc. Prelude helps a lot here, but I think it's still confusing once you need to add additional modules. I should mention that I still like Emacs, and that I still think Emacs is GOOD. I just think that Ruby Mine is better for my use case. 
I posted [this](http://www.reddit.com/r/ruby/comments/2vb7du/is_rubymine_worth_it/) the other day to gauge people's feelings on RubyMine cause I was considering a switch from Sublime. Since then, I'm using it more and more, maybe 40-50% of the time now. The features I like the most are the ones missing from this post: * The ability to immediately locate the origin of a method, even if it's in a dependency. * Refactoring tools: extract method, promote up, promote down. SUCH a nice little feature. * Its code completion, syntax highlighting, revealing of methods not used is just fantastic. At this point, I'm not really sure why I'm not using it all the time.
&gt; The main problem with Emacs is that it isn't opinionated enough. Now, that's my personal take. Some people loving spending hours tweaking their Emacs config, I'm not one of them Okay then, then RubyMine is probably better for you. From what I hear, it's a solid piece of software.
emacs bindings in Rubymine FTW! There's a VIM plugin as well.
Very very carefully. . . :)
I see what you're saying, but that seems like a bit of a sneaky way of justifying the change that doesn't actually pan out in practice. In reality, different APIs will have different method names. So you won't be able to just plug and play a new API--you'll either have to go change the code that calls the API or add a shim to the new API. I still think it's backwards to make changes to the code based on how you want to test it (although I agree that having trouble testing something is often a code smell). What would adding an API arg to the initializer accomplish, really? I don't want the caller to worry about what API to use, so that's not useful. So maybe I'll make the API arg be optional with a default to the desired one. But then what is that even doing? Nothing.
For the last part of your questions, it's not: responds_to? but: respond_to? See: (http://ruby-doc.org/core-2.2.0/Object.html#method-i-respond_to-3F)
Thanks!
tldr I philosophically prefer IDEs, but it took me seven years to find that out.
Did you read the error? It says you're calling `#each` on something that's `nil`. Look at your own code. What are you calling `#each` on?
We can't debug fictional code. If you want help, show us the actual code that you are running, not some half-redacted, half-changed version of it.
This is what I'm running, it's not redacted/changed, it's from the book. The book doesn't tell you how to run it, it just goes on explaining the concepts of duck typing.
It was brief as, when I originally wrote it I found I was going a bit too deep and repeating myself far too often. I wanted to touch on a few, so I kept it to a point. Thanks for the feedback though, I'll keep in mind that going in depth on certain topics might be better.
I made my comment because this happens **all the time** in IRC. Someone comes in and says "my code doesn't work" and then pastes example code that doesn't actually exhibit the problem. In this case, you've obfuscated the issue by not giving us a stack trace. With the revised code: `t.prepare([m])` you get a [different stack trace](https://gist.github.com/latortuga/93970669e7978b265d43). Notice how the error actually tells you exactly where the exception occurs?
Good call. I recently updated `active_model_serializers` from 0.8.3 to 0.9.3 which actually changes a few things including the ordering or the returned parameters (don't know what the order is based on now, but tests broke) and using string keys instead of hashes. Not a lot of work to update everything, but a lot more complex than a simple `bundle update`.
great post, thanks! Hmm, is trailblazer essentially the new version/evolution of 'Cells'? Looks like yes, more or less. https://github.com/apotonick/cells I always liked the approach Cells took over the Rails out-of-the-box, but was nervous about adopting something that would likely break in successive versions of Rails and need constant integration maintenance, based on being burned before with things like that. 
So, theoretically, if all your dependencies are using [semver](http://semver.org/), don't have bugs, and you lock to the proper semantic version (For instance `~&gt;` to two digits like `"~&gt; 3.3"`, then `bundle update` will always keep you working, since you'll only have updated to backwards compatible versions. Of course, that's a lot of "ifs", and we're not there yet, but we keep getting closer. If you have good test coverage, then to me _starting_ with `bundle update` and running your tests is the way to go -- I think it should in fact be the recommended default behavior, not something to recommend against. This is what I generally do, and I try to do it frequently, on nearly any non-trivial commit. If it fails in non-obvious ways, I can always revert to the old `Gemfile.lock` from before I ran `bundle update` (your Gemfile.lock is in git, isn't it?), and then update specific gems individually instead to find the problem ones. Only ever updating individual gems is a lot more time consuming, and also a lot more subject to forgetting to update something in error, and missing a bug fix, security patch, performance upgrade, etc. (Note that if you run `bundle update some_gem_name` you actually get most recent versions allowed by your specification of that gem _and_ any dependencies it declares in it's gemspec). If I'm developing a gem, I run `bundle update` before running tests nearly _every_ time, to make sure my gem really still works with the latest versions of all dependencies allowed by it's gemspec. (And this is essentially what travis testing will do, because travis testing runs a `bundle install` from scratch every time. `bundle update` is essentially the same thing as running `bundle install` from scratch, modulo bugs in bundler, which occasionally appear). Oh, and Rails does _not_ do semver, I always lock to X.Y.* on Rails, eg "~&gt; 4.1.0", allowing any 4.1.x, not allowing any 4.x. This way from 4.1 to 4.2 takes an edit to my Gemfile, I don't want it updating with `bundle update` without an edit to the Gemfile (but do want it updating from eg 4.1.0 to 4.1.3 on `bundle update`). If you are actually intentional and careful with what you lock to in your Gemfile, then `bundle update` (everything) tends to do what you want, in my experience. 
Thanks - much appreciated!
well, if bundle update fucks your stuff up, you have clear evidence that you are using old syntax. It IS an agressive update strategy, but it will only come back and bite you if you do it too seldom, or if you use gems with bad versioning manners. I've been working on too many projects that were afraid of a full bundle update, and the common denominator was that EVERY SINGLE ONE had some issue or other where we had to build on top of old crap because updating the old crap meant too much work around gem dependencies. In my opinion, the only way to NOT get issues with gem versions, sooner or later, is to diligently update EVERYTHING as often as possible. This does include rails.
Eventually, you're going to have to learn how to debug code yourself, and understand error messages, not just come to reddit or stackoverflow and have someone debug it for you. For the most part, those were pretty clear error messages. If you don't understand what the error messages mean, maybe try phrasing your question in terms of that, asking people to help you understand what the error messages mean, how you might go about understanding what they mean and what to do about them, instead of just asking people to debug your code for you. You can complete all the online and offline ruby tutorials you want, but if you can't figure out on your own what to do when you make a typo or other error, you haven't learned to write ruby yet. Highly experienced and skilled programmers still get error messages like this _all the time_ too, don't think an experienced programmer never writes code with a typo or other error. Seeing error messages like this and knowing how to respond to them is part of learning to program -- and the right way to do it isn't just by randomly changing parts of your code to see if the error message goes away. You have to understand what the error message means. Or at least try. 
I'd be more inclined to subclass the class under test and change `API` there. module MockAPI def self.foo raise 'ohnoes you tried to spend money' end end class ThingDoerWithMockAPI &lt; ThingDoer API = MockAPI end it 'does not call the api' do ThingDoerWithMockAPI.do_a_thing(dont_call_api: true) end 
Ok, basically if there's a program on gitHub that I want to run, and it's written with Ruby on Rails I won't be able to run it as an application? 
Or Goliath (with its bare-bones API). Or Grape on top of Goliath.
async_sinatra, on the other hand, has been abandoned.
Although looking back, really I'd add another thing -- &gt; Then I realized that when I execute ruby example.rb to test my corrections, The best way to do this is probably adding tests right in the mechanize source code, and running the tests. Perhaps with a debugger when you need to. Rather than creating a separate example.rb script. You're going to need/want tests eventually, and most of us have found that starting with them, especially in this sort of situation, is actually _pleasurable_ and more quickly leads working and better code. And then you don't need bundler or anything else at all. 
Cuba is active and still been used a lot. The guys behind the framework are just very conservative about adding new features. 
This looks so fucking cool.
Thanks, good to know.
Hey! This is awesome. I knew it could be done more simply, but in the alternate versions I tried, I just wasn't getting the kind of performance I was looking for. I thought your use of Enumerable#max_by was pretty novel, so I tried your solution this evening and found it to be WAY faster than any of the simple solutions I had tried. Enumerable#max_by helps, but the real speed up actually came from using String#split without any arguments. I haven't dug into why it's the case, but calling NUMBER.split instead of NUMBER.split("") or NUMBER.split(//) is actually shockingly faster; like two orders of magnitude faster. I put together this gist demonstrating the difference: https://gist.github.com/tdg5/85a0660f5f86f1415f3b I guess all of the simple solutions I tried must have used other methods of breaking the String into its individual characters. With the bottleneck of breaking the number into its individual digits out of the way, the difference in performance of the more complex solution I presented and the simple solution you offered is only about 5-7%. With the difference in performance so dramatically reduced, I think the simple solution is the obvious choice over the slightly faster, but much more complex solution I suggested. I'll update the post with a note to this effect tomorrow. Thanks for reading and thanks for sharing your approach!
I would agree that for a client-side GUI app, Ruby is definitely not the best choice. I think in this type of situation a lot of Ruby devs will target more of a web-app solution using Rails instead of a native client. This works, but is obviously not optimal and can be pretty heavy handed depending on the situation.
I've definitely heard war stories of people running into problems with long running Ruby processes. I don't remember the details, but for some reason I thought this was more of a 1.9 issue and the 2.0+ series of Rubies have been better about this. Depending on the availability of Ruby 2.0+ in your environment of choice, I could definitely see this being a deal breaker. It's a little old, but this thread has some discussion about long running Ruby processes: https://www.reddit.com/r/ruby/comments/1scadl/what_are_the_best_practices_as_far_as_longrunning/
We're on 2.0+ so it's not that -- it might have something to do with sidekiq. But honestly, I don't blame Ruby. It made sense to use it for the task because of code reuse so restarting the workers regularly to reclaim swap isn't so bad.
If you like Cuba but question the pace of development, you may find Jeremy Evans' [Roda](http://roda.jeremyevans.net/) more to your liking; it started as a fork of Cuba. Routing trees make the Web easier to deal with.
Thanks for the perspective!
I look at REST similar to procfs on Linux. HTTP was originally designed to serve up somewhat limited version of a distributed filesystem of sorts (though that is a great oversimplification). REST is a way to use those "filesystem-ish" semantics as the underpinnings for a an API to your application. The end result is a lot like procfs: `cat /proc/cpuinfo` isn't any different to a bash script than `cat ~/documents/shopping_list.txt`, yet it directly interfaces with a complex software application (the Linux kernel). In theory, REST APIs ought to enable tooling to eliminate the need for a lot of rigamarole associated with HTTP API integrations -- for example, extracting IDs from strings and using them to bang out URLs via string concatenation. In practice, there are two things that sort of act as a buzzkill for REST. Number one, rails' notion of rest really serves as a set of conventions that ultimately deepen the connection between your database schema and your interface to the outside world. In other words, what rails calls "RESTful" is really just a set of conventions it imposes in order to align your routes, controller actions, and ultimately your API schema with your database schema. The other buzzkill I've found with REST is that there is no standardization around formats. Siren, `json-api`, etc., all come with limitations. Only some allow you to build templatized links (analogous to what `&lt;FORM&gt;` tags do in HTML), but those are immature. The most popular ones merely let you expose read only data to `GET` requests. In the end, we end up doing what we've all done since abandoning SOAP years ago -- manually parse JSON, manually bang out URLs, collect form parameters for `POST` requests by hand, and couple our client implementations to hard coded external resources. The tooling isn't good enough to make it worth while. This is unlike `procfs`, which works wonders because your UNIX shell environment (and userland libraries) all understand how to work with files and filesystems natively.
Interesting. Thanks.
Confirm that you are in no way associated wit h rubymine please. The thing read like a bad ad
I had a look why the empty split is so much faster. If you look at the ruby C code at https://www.omniref.com/ruby/2.2.0/symbols/String/split?#line=6344 you'll see that if no arguments were passed, then splat is NIL and split_type is set to awk which has a really simple (and fast) implementation in C. If it's an empty string, the split_type is set to string and another strategy is used. Cool stuff. 
Don't be that guy. Plus, a quick look at various dictionaries shows that you are wrong: http://www.merriam-webster.com/dictionary/alternate http://www.oxforddictionaries.com/definition/english/alternate http://www.collinsdictionary.com/dictionary/english/alternate 
I personally like to use an explicit return if there's an if/else or case statement that will determine what gets returned.
I met one of the developers of cuba at RubyConf Uruguay. They have a huge problem with that assumption. The low code churn in Cuba is a feature. They are done, in the good sense of "finshed and usable".
Only sith deal in absolutes.
Welp, indeed, I thought "blah".split would result in ["b","l","a","h"], but I was wrong. I must have copy/pasted the wrong line when testing stuff in irb. Edit: I've done some more testing. It looks like the use of blocks (and Procs) is the main reason the simpler implementation is so slow. Also, a lot of arrays get initialized in the simpler version (each_cons initializes almost a 1000 arrays). The optimized version doesn't use blocks and only uses one extra array. That's where the 'raw' speed comes from.
Nope. It is possible to just like a product enough to write about it. Haven't received any payment or other favors from them. 
*puts on Mary Poppins outfit* Never say nev.... STOP CALLING ME MRS. DOUBTFIRE! ;)
It sounds like you are a smart person and you have been doing some self teaching. This is great! You can find all kinds of free or inexpensive material online. Have you considered a boot camp? They are sort of trade schools for developers. I have several friends and colleagues who have gone through a program and while junior in skill level, they have all if the makings of a great developer. Some even guarantee job placement or will refund part of your tuition.
I treat it like an optional refactoring - once every few days I look at the Gemfile and try to update something and see what happens. Also, sometimes just poking around the Gemfile leads to noticing a gem which is no longer used, which is always nice. I think another question might be - when you upgrade a gem, do you modify your app to use any new features? Or do you just upgrade and do enough to keep things working? I think I mostly do the latter because it's not always clear what the new capabilities are, or how I can make my app take advantage of them. Hm, there's probably a blog post in there somewhere...
The same. Btw which podcast were you listening to? 
I'm mostly convinced--I just tend to be skeptical of adding code that isn't necessary but "adds flexibility" or "futureproofs". Although I'm familiar with Sandi Metz and listened to several of her talks, I still haven't read that book. I'll have find some time to do so. Edit: Also, the "shim" I was talking about is the abstraction you're talking about, I believe. I don't see how it's any more convenient because you'll still have to make code changes.
JavaScript Jabber. I know it's not related to ruby, but they were talking about developing web apps.
There are a bunch of basic [ruby style guide ](https://github.com/styleguide/ruby) points that you are not conforming to, such as always using soft tabs (2 space indent), avoiding multi-line if/then/else, mis-matched def/end indents, writing *self* everywhere, using *attr_accessor* unnecessarily, writing *return* unnecessarily, unused variables, use of "or/and" vs "||/&amp;&amp;"... Obviously that's a lot to take in, but it would definitely be worth mastering these basics before trying anything too complicated - otherwise your code could become an absolute nightmare to debug! Speaking of which... I have no idea what error you're even seeing, since you haven't provided the file: /home/hayden/journal.txt ;)
Build some sites/tools for your portfolio and/or contribute to some open source projects. If they are at least reasonably good you will get work regardless of your past background.
Thanks, I had more time to look through it. Following your suggestions I realize now that "self" was passing the Trip object into prepare_trip and that was raising the error. When I change the code to pass the correct object it works: class Trip attr_reader :bicycles, :customers, :vehicle def prepare(preparers) preparers.each do |preparer| preparer.prepare_trip(preparer) # self changed to preparer end end end I think that is the reason it wasn't working... The book has it as "self" so I'm assuming it is a typo? Please let me know if that is not the true source of the error or if you see something else that I missed. Thanks!
Awesome, thanks!
Erm... okay, let me rephrase: I was resistant to even attempt debugging this, given that I didn't know what your program was supposed to do! There is no example input, or "expected output", or comments saying what any of the code does. Some of this is obvious, sure, but - especially since the code is broken - it's not so obvious what lines like: until res.include?(".") do res &lt;&lt; " #{self.get_next_word(res.split(' ').last) or self.get_next_word(res.split(' ').sample)}" end or if res.length == 1 then return res.to_a.at(0).at(0) else return res.to_a.sample.at(0) end ...are *supposed* to do, let alone what they actually do! Honestly, I'd be glad to help you out with this. Heck, if you just give me an example input/output then I could rewrite the whole thing in a few minutes!
As I said, both sides are arguable. Any further debate is really futile in my book. :)
Well, what's considered an error depends on what the intentioned functionality is - something I'm not really clear on. It looks like what's supposed to happen: * `Trip` appears to be a class that contains all trip-specific data, e.g. the bicycles and vehicles used, and the customers involved * Many different kinds of people, called `preparers` will prepare this trip. Each `preparer` will need access to the respective trip-specific data they are to operate on, so `trip` will pass itself to each respective `preparer`. * `Mechanic` will `prepare_trip` by accessing `trip.bicycles` * `TripCoordinator` will `prepare_trip` by accessing `trip.customers` * `Driver` will `prepare_trip` by accessing `trip.vehicle` * To prepare a trip, you pass an array of `preparers` to `trip.prepare()` _However_, that's not what's actually happening when you run your code. * `bicycle` data is stored inside `Mechanic` (`Trip` has a bicycle accessor, but no bicycle data to speak of). All bicycles stored by any `Mechanic` (`Mechanic#bicycle`) will always be `[1, 2]`. * You've changed `preparer.prepare_trip(self) # self is the current trip` to `preparer.prepare_trip(preparer)`, i.e. each `preparer` is to prepare itself. * This worked for `Mechanic` because the mechanic will receive itself in its `prepare_trip` method as the variable `trip`. It will get bicycle data from itself (which works only because bicycles are now stored in `Mechanic`) and prepare them. * None of the other preparers, `TripCoordinator` nor `Driver` is storing their own data to operate on though. Now, are you intending for all trip data to be stored in `Trip`, to be accessed by `preparers`? Or are you intending for each preparer to store and operate their own data and to just have `Trip` administrate, telling them to do so?
Mackenziechild.me
I think you mean [tryruby.org](http://tryruby.org/).
You want every url to go to the same page, regardless of what urls you're given. Its a simple way to avoid 404s, although probably not the best practice
Text adventure games, MUDS.
If you see by number os issues, stars, forks etc Padrino is the second most used alternative, after Sinatra.
The OP did not ask about simple video playback.
Also you might to better posting about rails in /r/rails
Ok so this is going to be a bit harder than I anticipated but I am happy that it is gonna mean learning new stuff. 
Yep. I think there is a middle ground we haven't discovered yet, though. Where the standards have enough thought put into them that our tools can take away a lot of the pain, without adding the bloat of SOAP.
OK this is kind of cool. But, let's say I'm building a Web app and handling some User data. What would be some good Uses of the concepts explained in this article? I'm looking to stir up my creative pot a bit. 
Are you using rvm? Maybe you need to [generate docs](https://rvm.io/rubies/docs]
Thanks for the tip! I'll endeavor to read that book.
I use it when I have a scenario when I want to do an Array#include? on multiple terms. A slightly truncated version of a real use case in one of my models in my current project: NAME_COLS = [ :first_name, :last_name, :middle_name, :suffix ] before_save do |model| model.update_dependencies if model.name_changed? end def name_changed? (self.changes.keys &amp; NAME_COLS).present? end This basically lets me ask if `model.changes.keys` `#include?`s any of the target column names. If it does, we're golden. In my particular case, I like this because I define the `before_save` and `#name_changed?` on a parent model, and I inherit having to only redefine the constant in the children.
First reaction: WTF is ri? *Tries it in command line* So it's like ruby-doc.org, but local? What's the point? In my opinion, any time you'd spend getting ri to work properly would be a waste. If you ever need to know how anything works, just Google it. The results will almost always turn up a result to ruby-doc.org, which will give you more than enough information. If it's a really complicated concept, you'll probably get a link to Stackoverflow as well, which nine out of ten times will solve your problem.
Nice, this is basically just a slightly shorter/faster way of writing: self.changes.keys.any? { |key| NAME_COLS.include? key }
I've already done many of those but solving others' problems has nothing to do with our minds. I've built a web scraper and a couple of websites in Rails, but it didn't help much. In a recent Ruby developer interview I failed hard because I was missing fundamental knowledge about OOP and problem solving patterns. I need to get my hands really dirty and I am not willing to stop until I've build a serious leven in 6 months. I don't mean to underestimate others' blood sweat and tears to learn tough things in years (what a rhyme :) ) but for me "serious" = the more I can until I fall down. 
`ri --help` Ri is a really awesome tool, I'm using it all the time. So, something like `ri require` doesn't work for you? Ri is definitely the quickest tool for reading Ruby documentation: you just enter the method you want docs for, and you get it. And, unlike ruby-doc.org, you can get documentation for any method on any Ruby gem, not just Ruby core and standard library. I highly recommend reading this short blog post, it made me realize I want to switch from ruby-doc.org to ri: http://www.jstorimer.com/blogs/workingwithcode/7766081-5-reasons-you-should-use-ri-to-read-ruby-documentation
Thanks! 
Haha, also true!
Lolwut.
This article seems to use 'tail recursion' to mean simply 'recursion'. I have never used a Ruby compiled with TCO, but from those code examples it doesn't appear to me that the recursive call is always in tail position.
awesome! two of my favorite things: ruby and infosec. really hope this takes off!
I wouldn't start with rails or sinatra (never heard of volt) because these frameworks change the language that much ... I'd write some smallish terminal applications for the first step...
I don't have complete lack of knowledge on OOP (passed many programming exams in the university on c++). I just missed some terms which may be part of fundamentals due to lack of experience and the need to "Refresh" my knowledge. The truth is that I am very good at connecting dots and present a selection of solutions in a very small amount of time. From what I say I believe it's obvious that If I don't know something it's not about inability or unwillingness but the opposite. I am willing to learn and read more than anything else. It's just that all these years after graduating (almost 5) I was working in a difference section and I was creating websites for friends and clients for a few money and as a personal passion. But If you're a full stack engineer/developer you'll know that you need to possess knowledge in various things in order to complete a project. For example, for a simple blog you need to know linux administration &amp; commands, ruby, rails, html, css (&amp; may be scss), javascript (&amp; maybe coffeescript), git, nginx or apache (and maybe passenger) etc. So it's either possible that you know everything well (most unlikely) or you're working on one thing (only sql or only ruby etc.). I chose the first path because I needed to get some clients (and small businesses) and maybe got a Junior developer job in a good company - then having the chance to build the experience there in "one" section and become an expert. Maybe I didn't know why protected attributes exist (it took me 30 seconds to remember) but I know how to set everything up in order to create a small application with forms, beautiful UI with ajax and css and secure on a well administered server. I missed questions as why do we use "protected" attributes in a class, or what indexes should you choose in an sql table in order to fast search a table. These ain't so hard to understand or learn - I just don't have the write-code-till-you-collapse experience which would help me understand what does a small/medium scale company would need. Sorry for the length of the reply. I have a very strong passion for programming and I am not intended to stop until I'll become the best.
Probably because sinatra works in async way without async_sinatra.
tx i will need some help with the wiki and such, so if anyone likes to voluntier let me know.
Ruby does a lot of performance optimisation by passing values by reference (or making "shallow copies", or "passing by pointer" in some other languages). Usually this is not even noticeable, but it can occasionally give you very weird bugs - which is why it's often a good idea to *freeze* values that should never be changed, to at least catch these errors where they happen! The ruby style guide is a good place to start learning some best practices, but beyond that it really depends how much knowledge/experience you already have... Are you a proficient programmer in other languages? How much do you know about OOP, TDD, CI, etc? Do you want to learn about the Rails framework, or just the ruby language? 
I agree, in fact is well known that ActiveRecord conceptually violates the SRP, so it's pretty difficult to apply SRP or other patterns so rigidly. If someone prefer a more clean OOP approach, they should use a datamapper instead AR. Anyway. IMHO, things that should go in AR models are simple validations, scopes and relationships. The instance methods probably should be distributed around services or other ideas like the one pointed out in the article from codeclimate. Rails also offers things like delegates, alias attributes, inline callbacks, etc, so your models don't get so bloated with methods.
You can try gsub and capitalize like this: "tony mega-stark".gsub(/\w+/, &amp;:capitalize) =&gt; "Tony Mega-Stark"
ive used ubuntu on a old laptop and loved it however windows has visual studio and many games. is proggramming in ruby on rails on ubuntu that much better than on windows ?
Fortunately, it's not an either/or thing. You can have both on the same machine. Google dual boot. Windows for games, Ubuntu for development (also reduces temptation to play games)
Oooh! You can install Virtualbox with Cask. Never heard of Cask, this will be nice to have.
Ruby Science by the folks at thoughtbot. 
Got to have [Metaprogramming Ruby 2nd Ed](https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2).
The official solution for the certificate error is at https://gist.github.com/luislavena/f064211759ee0f806c88
Of course. Many people do and are perfectly happy with it. 
It is passing because the a and the b match. I'm not sure what your exact specs are but this one will satisfy "match on strings which contain only characters from the character class" \A[abc]{,4}\z This is checking that the line starts and ends with a, b or c with no other characters. You might even be able to simplify it to \A[abc]+\z [rubular.com](http://rubular.com) is good for playing around with regexes. Hope it helped!
Both of which are methods that merge ruby hashes, no?
Intimately familiar with common lisp and scheme, dabbledp in Racket. I've no use for rails, Web dev makes my soul hurt. I am going to eventually build an analytics platform in ruby. All the niceties that come with ruby like tdd and oop, are mostly new to me. I have trouble "thinking" Oop. 
Cool, thanks for your help. I'm actually trying to match a longer string, with a character class in the regex. However, strings are passing that contain characters outside of the character class = /
This works: \^[abcd]+$ It will match strings containing only letters in [abcd] in any combo I'm not using 1.9.3, but I verified in Rubular using 1.9.3 and it works the same. 2.1.3 :016 &gt; str = "azb" 2.1.3 :017 &gt; puts "ugh" if /\^[abcd]+$/ =~ str =&gt; nil 2.1.3 :018 &gt; str2 = "ababaa" 2.1.3 :019 &gt; puts "ugh" if /\^[abcd]+$/ =~ str2 ugh 2.1.3 :020 &gt; str3 = "abbcdlolcdabcd" =&gt; "abbcdlolcdabcd" 2.1.3 :021 &gt; puts "ugh" if /\^[abcd]+$/ =~ str3 =&gt; nil
Another way to write it is /^[abcd]{,4}$/ 
my recomendations are: - [Rails Antipatterns](http://www.amazon.com/Rails-AntiPatterns-Refactoring-Addison-Wesley-Professional/dp/0321604814) Old but the ideas are still applicable to modern Rails - [Confident Ruby](http://www.amazon.com/Confident-Ruby-Patterns-Joyful-Coding-ebook/dp/B00ETE0D2S) A book with a loot of advanced patterns in ruby. 
Well, one of the examples has this recursive method call: v.deep_compact.empty? `deep_compact` is not in tail position, the call to `empty?` is. Thinking in terms of Lisp, this code would look like: (empty? (deep-compact v)) This shows more clearly that deep compact is not in tail position, and each recursive call adds a new stack frame. Perhaps in Ruby this is not so, and I'd love to be corrected if I'm not understanding something about how Ruby works. Anyway, neat article nonetheless!
Like jrochkind said, a lot of rails dev tools are built for Linux/Mac. I was working on an open-source Sinatra app, and realized I had to 'work magic' to get it to run on Windows. Switched fully to Ubuntu, really happy with it. I don't play games that often on my laptop. But putting Linux on it improved not only the game performance, but the in-game mouse performance too :)
Rails development will always be easiest on Linux, because that's where everyone deploys Rails apps. That means that every gem will install and work cleanly, because a gem you can't deploy is useless. Lots of Rails developers, including several core developers, use Mac. That means Rails development on Mac will always go pretty smoothly. But it won't be as simple as Linux, because it's OK if setting up a desktop dev environment has some rough edges - you only do it occasionally, and you've always got a developer there who can afford a few extra minutes of tweaking to get stuff to work. In all of this, Windows is basically just a third-class citizen. It's not even in the same OS family as the other two. Doing Rails development on Windows is like doing .NET development on Linux. It's possible, but why bother?
Isn't str supposed to go on left side of the =~?
ARGV is an array containing all of the parameters (arguments) to the program execution. There are very few cases where you would use $stdin explicitly, but the author probably wanted to demonstrate that 'gets' is really a shorthand for '$stdin.gets'. $stdin just happens to be the default file descriptor for 'gets'. In fact you could use 'gets' on other file descriptors too by using them explicitly like in this code.
Thanks! I see your point there. If we drop the `empty?` method we can still have it remove all the nils but it will leave the empty hashes. Also `delete_if` expects the last thing to be a true or false value so `nil?` still needs to be called after the recursion for it to work. Thinking about it; the stack may be getting deeper rather than handing off the appropriate amount of work. So that example may be flawed (as far as tail call methods are meant to be).
I'd recommend finding some gems that you use and read the code. seeing how other people solved their problems with code can teach a lot. Keep ruby documentation handy so you can look up anything you don't understand.
You could use a wildcard catch-all to setup common resources, and then 'pass' so that a more specific route can handle it next. but I only really use it to alert people accessing an old api version (e.g., /api/v1/*)
+1 to this. Such a great book and it really helps you understand how Ruby works under the hood. Well written.
Yes, I agree that this solution is not perfect, my idea was to inject validator to the model so that's why using validates_with the only way, but I agree that having it completely separated would be better. It was my experiment, it started the discussion about the issue and possible solutions, thats all. We are planning to blog about another solution, using similar approach, but having it really separated from the model. So stay tuned.
Sinatra. Gets you off the ground with simple routing. You do the rest.
Excellent book, I own it too, but to me it's not clear is it essential or intermediate :)
Very nice read! Would be awesome if you can also post a follow up on deployment... By the way, does hot code reloading also work? There used to be issues with that on Mac... 
Hello, I've put together [a collection of Ruby books](http://planetruby.github.io/books) @ Planet Ruby. You might try the new edition of the upcoming classic "The Ruby Way" or "Ruby Best Practices" or "Eloquent Ruby" or for a deep dive "Ruby under a Microscope". Cheers. PS: If you want to learn something new try Learn Your a Haskell for Great Good or Learn You Some Erlang ;-)
Great tip. FYI: I've started a [gem of the week series](http://planetruby.github.io/gems) @ Planet Ruby. So far the gems presented include: factbook, hoe, slideshow, schemadoc, gli, kramdown, and more. Cheers.