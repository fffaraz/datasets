Yeah, this stuff is just hard. Switching to something else isn't going to make it any easier. Totally guessing, but the issues you're having might be more with how the entire internet works overall - DB theory, HTTP, etc - because once you understand those things it doesn't get much easier than Rails.
Have you programmed at all before without Rails? Have you programmed for the web before? 
Really strange article, in fact. Storing executables in `exe` folder; using OptionParser instead of slop or something similar; specs supposedly using real (but in fact not real) site... Can't understand, what it tries to demonstrate.
I had a similar experience with Rails. Tried following the tutorials but none of it made much sense. Then I decided to give Sinatra a try, which made more sense to me somehow. It let/made me learn how to do stuff on my own, which has been a great learning experience. A year later I tried Rails again, and everything they talk about in tutorials now makes sense to me. Still don't like Rails though. 
meet you at the marketplace
Finally getting a good explanation of :get vs :post got me the ah-ha moment I needed. Also getting a firm understanding of MVC helped.
I've brainstormed a lot about how to teach something like Rails. Below is a rough idea I've had where the goal is to have accomplishable steps at each phase that don't involve a huge tech stack. Could use some feedback to =D 1. (HTML/CSS) Rewrite resume in straight html/css 2. (Basic Webhosting) Deploy simple site on github io 3. (Basic interaction with the web) Write a crawler that will grab everybody's resumes, parse and try to find specific information in it. 4. (Database) Put that information into a database somewhere. Deploy said database. 5. (Using an REST Api, DB and Model Layer) Use information to construct a chart/map/etc. that uses a public API 6. (Building a REST Api, Controller Layer) Have the crawler now serve the information via a simple REST api with maybe something like Sinatra 7. (Javascripting) Add JS to the resume that will, using the Api created in previous step, show nearest neighbor style information 8. (Full Stack finally) Build a simple CRUD interface for adding new resumes into system 
It's been said in other comments, sort of. But the best way to learn is to make something useful for yourself. It won't matter if you use Ruby on Rails or Python on Django. Make something. Every time a problem pops up, you will need to search for the answer, and you will learn a lot fast. To give you a perosnal anecdote, I've been doing ruby for over 10 years professionally. But I've always worked as part of a software development team. Just about a month ago I found something I needed to build for me personally. And i built an app to do it. I was amazed at how much I learned about things I hadn't ever tackled on my own before. Just getting started on my own was so much harder than starting out on a team project.
Switching to Django framework won't help you, unless you are substantially more experienced in Python. On fundamental basis, both frameworks work in the same way (requests handling, database models, views, urls routing, templates etc.) and you should understand the abstraction behind anyway. It's maybe just me, but I like Rails much more because find extending existing Django apps more cumbersome and dislike its templating system which find too limiting and rather half-baked. It just stands more in my way.
Agreed. I'll also add that after doing the standard things, moving off heroku is by far the best performance improvement you will find. It's really quite easy to run directly on EC2 now and you'll be rather amazed how slow the non PX dynos actually are, and even the PX dynos are fairly slow. 
FWIW, I think it *is* Heroku specific because 50% of the post deals with memory constraints. Heroku is an *extremely* memory restrictive environment where you're forced to scale horizontally, not vertically. Other environments allow a lot more memory headroom if you want to pay for it. I know there's PX dynes now, but they're so expensive that they're out of reach for most people.
Specifically, the ActiveRecord JDBC adapter is not yet fully Rails 4.2 compatible. Not sure if it's fair to say that "JRuby" isn't Rails 4.2 compatible -- but it's true that a crucial component you need to run Rails under JRuby doesn't yet work _completely_ with Rails 4.2. Nevertheless, I've had pretty good luck with using AR-JDBC in Rails 4.2. The discrepencies you run into can usually be worked around. It is annoying to run into any discrepencies at all, and have to work around them, but it's worth it if you actually need Jruby for something (such as no GIL for better performance under heavy load). I agree that if I don't really need JRuby though, this would make me think hard about using it with Rails. Still, the fact that even work-around-able discrepencies are so striking -- speaks to how often we have been able to expect something that works in MRI to Just Work in JRuby too, which is really a pretty amazing feat, especially when MRI's behavior isn't really formally specified in any way (not even an official test suite), and 'ruby' isn't really formally specified in any way beyond "what MRI does". 
thanks, this makes sense to me. as you can see by how long i came back to your post, time is my biggest problem. it's killing me that i don't have more time to work on this stuff. when i was out of work earlier this year i was blowing through this book. back to work, and back to misery lol. i'm doin my best to hang in there. thanks for the help! 
I like the idea of your website. I am trying to learn ruby/ror, and it seems your site actually has some fun tutorials to try. I don't really like to learn a new language from tutorial sites that start with the basics (hopefully yours isn't that way), but I like to just dive into a (simple) project. Hangman and the todo looks good for someone new to ruby. Also, this part made me sad &gt;even though you **mkdir best_idea_ever** on Saturday morning you end your weekend with **sudo rm -rf ./best_idea_ever** 
&gt; The hurdle that I've currently got is that the subclass isn't yet loaded while the base class is being interpreted. Base class is always interpreted prior to its subclasses from principle of mutual relationship and definition. &gt; want to make sure that certain methods do get implemented in the child classes. This is a broad request. You may check if method is defined on specific class with `Class#method_defined?`, you may raise custom exception (other then standard NoMethodError`) in base class method about need to be implemented etc. 
then require the base class in the file that contains the subclass, this will ensure the baseclass loads first.
&gt; I ... want to make sure that certain methods do get implemented in the child classes. I feel like you're overcomplicating things. You can just do: class MyAbstractClass def foo fail "Implement me!" end end
[**@lazaru_s**](https://twitter.com/lazaru_s): &gt;[2015-07-24 23:23:00 UTC](https://twitter.com/lazaru_s/status/624721474176319488) &gt;We don't have secrets. [#ruby](https://twitter.com/search?q=%23ruby) [*pic.twitter.com*](http://pbs.twimg.com/media/CKt03pgW8AAOdSS.png) [^[Imgur]](http://i.imgur.com/w6CAgeX.png) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/3ek2vb%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Interestingly: irb(main):001:0&gt; module Foo end =&gt; nil irb(main):002:0&gt; module Foo irb(main):003:1&gt; public == private irb(main):004:1&gt; end =&gt; true irb(main):005:0&gt; module Foo irb(main):006:1&gt; public === private irb(main):007:1&gt; end =&gt; false
Thank you!!
Not interesting. `===` just doesn't work the same as `==`. Since the return value of `public` is `Foo` then `===` only returns true if the RHS is an instance of `Foo`, which it isn't, since it's also `Foo`.
Fuck crystal, stop the spam.
Please note that none of the main developers of the language are posting this to reddit (in fact, we never, ever, post things to reddit, hackernews or any other social media except our twitter). These posts are merely because people are discovering Crystal and probably they don't notice there's an existing mention to it the homepage... Sorry for the unintentional noise.
That seems confusing; I was under the impression `===` simply meant "equal and identical to". It seems strange to me that `a === b` can be false when `a.object_id === b.object_id` is true.
Yeah, you just need to open a book and read about the `===` operator. It's really quite different and unique. Quite an interesting operator :) EDIT: The operator you are looking for that means "identical to" is the `equal?` method
&gt; But then you are still dealing with dozens of gems which have or can promote those problems SomeHTTPApiWrapperGem.raise_exception_on_bad_request = true SomeDBLibrary.host = "localhost" WHY????/////
yeah pretty much.
&gt; 2-10x runtime performance gain is too little to think about abandoning so rich and production proven ecosystem built around Ruby. I can't say where I used to work for big corporate reasons, but let's just say it was Very Large Company™ which bought Medium Size Startup™ (which is where I worked), we had a large Rails stack and the servers had to be killed and restarted every few minutes due to memory and other issues. It was kind of gross. It also took 40 seconds (!!) to load the stack, and most efforts to reduce that failed due to ending up needing to rewrite the whole damn thing due to massive interdependencies. I [championed Elixir here](https://www.reddit.com/r/elixir/comments/3dwph3/elixirphoenix_talkingselling_points/) but here's an excerpt from the performance section: Phoenix, the Rails-equivalent web API, has come out of the gate swinging with a 2 to 10x performance improvement over Rails (depending on... various variables such as the skill of the developer making the code) using a fraction of the CPU load: http://www.littlelines.com/blog/2014/07/08/elixir-vs-ruby-showdown-phoenix-vs-rails/
`===` has a totally different meaning for different types [1]. It's rather unfortunate that the operator is represented by three equal signs. It doesn't have much in common with equality. Often times the relation isn't even symmetric nor reflexive [2]. [1] * `(0..3) === 2` is the same as `(0..3).include?(2)` * `String === a` is the same as `a.is_a?(String)` [2] `(String === String) == false`, `(2 === (0..3)) == false`
Sometimes I wonder what they were smoking when they built ActiveRecord. Thanks for the article, it made me a little smarter today and may save future me some trouble :)
Most people, regardless of the language, will write terrible code.
Wish they were all like you, then!
If "CryptoJS" refers to [this application](https://code.google.com/p/crypto-js/) I'm going to leave my standard warnings. *The project is inactive, as stated on the above link. That's not what you want in a crypto project. *The default encryption mode is unauthenticated CBC, that's not what you want in encryption. *Issue #32 is actually a request to insert a padding oracle vulnerability, which was accepted. 
You didn't want any type annotations at all? How would you do multiple dispatch?
Ubuntu 15.04 uses 2.1.2 now.
foo.js: $.getJSON('foo', function(json) { ... }); app.rb: get '/foo' do content_type :json {foo: 1, bar: 2}.to_json end
Thanks! This fixed everything!
If I'm not wrong, you are supposed to create a path like /getJSON which returns the json (Ruby) and then simply make an api call through jquery to get it.
Does this really, really have to be a Word document? If we were talking about a website it would be an easy task. But .docx, will be a world of pain.
Most vague question ever. All you're asking for is a create action on a random model like Page. 
docx is XML, so you could look for placeholders and replace them. 
But some languages make it *a lot* easier than others.
are you serious ? I have a relatively modest experience qith ruby and all I learn amazes me, like : wow, RoR does wonders! 
&gt; why shouldn't it be posted in /r/ruby Attached to a post saying - *"Hey, there's a fundraiser"* it is every bit as bad as any other marketing spam. I could do with 3 months funding for my project, should I post it here? What about all the other OS devs who similarly need funding? Legitimate posts about the language, e.g. comparing it to Ruby, providing some benchmarks, use cases, interesting observations I'd be fine with. As it is, this is just spam wrapped up in a deceitful Ruby coloured wrapper. 
Honestly, this is not a problem I would reach to Ruby for as the first choice - rather I'd look at C#or another language targeting the runtime. That said https://github.com/chrahunt/docx and as /u/reactormonk has pointed out, docx is XML hence there is a wealth of tools once you understand the format.
I'm sorry you feel that way. I'm in no way affiliated with the Crystal devs. I'm just a ruby dev trying to support a language that will eliminate the need for me to write a C extension in order to get the speed I'd like for some specific use cases. I've tried Go, Elixir, Rust and Scala to rewrite a part of my application, but all those languages required me to get used to the language a lot. That's and expected requirement when you pick up a new language. The same goes for Crystal. It just really surprised me how quickly I got used to it having quite a bit of Ruby knowledge. But I'll try to make my next post about Crystal containing something that you're fine with :-)
letting USERS to create the page, not me. 
No critique, just wanted to show off my 242 byte version: a,b,e=ARGF.read,[c=d=f=0],[] (t=a[d] t[?.]&amp;&amp;$&gt;&lt;&lt;b[c].chr t[?+]&amp;&amp;b[c]+=1 t[?-]&amp;&amp;b[c]-=1 t[?&gt;]&amp;&amp;(c+=1;b&lt;&lt;0) t[?&lt;]&amp;&amp;c-=1 t[?]]&amp;&amp;(o=e.pop;d=o-1if b[c]&gt;0) t[?[]&amp;&amp;(b[c]&gt;0?e&lt;&lt;d :loop{t[?[]&amp;&amp;f+=1 t[?]]&amp;&amp;f-=1 f&gt;0||break t=a[d+=1]}) d+=1)while a.size&gt;d
That's a good point. And surely there will be newer languages emerging all the time. And I'm still drunk on the functional kool-aid (having just mounted the learning curve a few months ago). ;)
Looks nice, doesn't seem to work for cat - does it take input from stdin or a file? 
Lots of people modify the GC settings to squeeze more performance or save memory as described here http://stackoverflow.com/questions/4985310/garbage-collector-tuning-in-ruby-1-9 The settings and GC in general that worked for 1.9 are different from 2.2 http://ruby-doc.org/core-1.9.3/GC.html http://ruby-doc.org/core-2.2.0/GC.html
As a Rubyist (among other languages) who hasn't yet written a line of Crystal, that's an easy question. Crystal exists now. Rails 3 will likely exist next year, and may well include some form of type hinting or annotation (whatever "soft typing" means). Personally, I think the most exciting news for Rubyists isn't Crystal, or even the hype around what might be in Ruby 3, but rather is something that also exists right now: [JRuby 9.0.0.0 has been released](http://jruby.org/2015/07/22/jruby-9-0-0-0.html). Multithreaded, performant code in modern Ruby just got practical.
You're still misunderstanding. I can read programs fine, but brainfuck has both and input and an output stream. Your program does not seem to be able to consume input.
Oh, now I get it. My short implementation doesn't support input (,).
Rspec and Capybara
&gt; but they still remain conventionally accessible. Why is that a *good* thing? IMHO using the YAGNI, you should focus on what you need *now*. If you don't need that API now, why implement it publically? Having it public, even tucked away in a module, means you have to test it in isolation, it has to be documented (somewhat) and most of all, be kept working and be kept stable. I'd rather implement a unit-test that assured "after updating, the associated Order is touched", and leave it at that. Rather then having to test a public `touch_assocated_order` in all sorts of *currenly impossible* edgecases. Because at some point, when it is public, someone is going to use it. In cases you never thought of or specced out. Yet, when you spec them out, make it work in many future edge-cases, instead of developing a small and quick `after_update -&gt; { order.try(:touch) }` which satisfies the immediate business-need, you are now building a system that updates orders and whatnot for all sorts of cases. 
Yes, but the ease at which a language lets you shoot yourself in the foot is not a valuable metric for everyone. I personally don't care; I'd rather try to place myself on engineering teams of a high enough caliber that it's not a worry.
So you never use third party libraries...? Or ever contribute to open source? Why bother with Ruby then?
MiniTest, Fixtures, Capybara
Thanks for your response. So if I want to automate the following workflow: (1. SSH into co-worker's computer via Terminal, 2. Run a preexisting script to download a .CSV), I can do this in Ruby?
I find that docker makes it pretty easy to make your application portable. I made a gem to help deploy docker containers called freighter, if that helps.
Scripting languages refer to lighter, generally interpreted languages that are well-suited for writing small, personal scripts. Compare to a language like Java, which is more used for writing large, enterprise-scale programs.
Short version: calling Ruby and Python "scripting languages" is probably a little misleading. While both are used for scripting, neither is primarily a scripting language any more. Strictly speaking, a "scripting language" is a language (generally interpreted rather than compiled) designed for automating tasks in a specific run-time environement (see [wikipedia](https://en.wikipedia.org/wiki/Scripting_language)). Since scripting languages are more or less invariably interpreted, and back in the old days when computers were slow, interpreted languages were used almost exclusively for scripting, the terms "scripting language" and "interpreted language" are often used interchangeably. Still, it's not really correct to refer to Ruby and Python as "scripting languages" since both are general purpose programming languages.
It really has more to do with scripting languages vs compiled languages. 
Both Ruby and Python are also compiled to bytecode.
I tried to set this up for a coworker a while ago. I was unable to really get it anywhere in a usable state -- it really is just basic vim keybinding and does not seem to go very deep.
Please do so! Many of us *are* interested, but immediately pointing out the fundraiser is ... well, a bit rude I might say.
Scripting basically means interpreted (as opposed to compiled). In practice, most popular languages that used to be interpreted are now JIT compiled. I would probably define the modern difference between scripting and non-scripting to talk about how coupled logic is from form. Most (all?) scripting languages have `eval` functions built in where they can interpret dynamic code. Variables are effectively looked up as a mapping from (string) label to value (which often can be serialized very easily ala JSON).
I use ruby like this. Instead of writing bash or shell code (and using its complex syntax) I just write ruby and call system commands, and capture the output into ruby for further processing, or to pass it along to the next command. I use ruby as a sort of glue that makes it easily readable. The negative is that instead of pure shell which will run almost anywhere, I have to make sure ruby and any gems are available on the target system.
Do you have a recommended ference/tutorial online for learning stuff like this? There's so much out there, I'm not sure which one would be best for my purposes.
I think there's a plug in that will launch your favorite editor. When you save, it just updates the file in the IDE. 
Construct the link URI in such a way that it contains the parameter you want to use in the query. To get the data out of the URI, you have a couple choices. The simplest thing may be to make it part of the route. http://www.sinatrarb.com/intro.html (search for "params hash") How you would use that parameter to construct an SQL query depends on the database library you're using.
MiniTest::Spec (after 3 years with RSpec) and Capybara. We don't use fixtures *per se* anymore; we use classes to generate test data — that themselves have their own MiniTest specs. We also have a *very* firm conceptual boundary between "stuff that has to subclass Rails classes" and code that doesn't, as well as a strong preference for composition over inheritance. Both of these have affected our testing strategies profoundly yet often subtly.
Yours looks very nice - probably more idiomatic than mine! Vivaldi looks like a nice lang. Do you know much about it?
Rails 3 has been out for a while. :-) I know what you meant. For me the problem with Crystal is that it is similar enough to feel familiar, but just about far enough way in key areas (e.g. different types of integer), that porting could be painful even when I have good test coverage under me, and I'm not sure why I'd go through that pain. JRuby 9000 looks interesting, and JRuby as a project excites me, but alas at work we have too many projects with ffi libs to make it an option.
Good answer. I would only add that while scripting generally implies interpreted, the inverse is not generally true. (There are of course exceptions)
Are you still having that problem?
I couldn't be bothered to do both files, but I've made you a little pull request for one ;)
Should have been Rails 5; oops. Keyboards and lack of sleep are a *dangerous* combination. I think you're right about Crystal being too close but not being close enough. If you're going to learn Crystal as anything other than a lark, and haven't already mastered (say) Elixir and Clojure and Rust (as well as the obvious Ruby), I'd really wonder about your priorities. As far as FFI, there's this from the blog post announcing the announcement: &gt; JRuby 9000 now uses native operations for much of IO and almost all of Process. This makes us the first POSIX-friendly JVM language, with full support for spawning processes, inheriting open streams, perfoming nonblocking operations on all types of IO, and generally fitting well into a POSIX environment. I would expect that proper support for FFI *has* to be a high priority, as it's one of the few obvious pain points remaining. I expect we'll kick the tires during maintenance of several apps over the next year, and I can't imagine starting a new non-toy project that's MRI-only in our app space. But I can definitely see FFI as a deal-breaker until it's fixed. Have fun.
Oh... And also, I didn't bother including this in the pull request, but here's a quick little script I made to translate that cryptic line of BF in the middle of the code! #!/usr/bin/ruby input = ARGV[0].split('.') asciiVal = 0 def pos_or_neg(char) char == "+" ? 1 : -1 end puts input.map do |chars| asciiVal += chars.length * pos_or_neg(chars[0]) asciiVal.chr end
I guess that technically, It's possible to do all the programming in vim and use RubyMine just for debugging and refactoring. But before that, I'm trying to find a more elegant way.
Love the implementation man! Any thoughts on how this could be implemented into a Rails app?
Mostly Rspec and Capybara - but I plan to go all MiniTest once Rails 5 comes out so I've been converting my toy apps.
I also find [Gemnasium](https://gemnasium.com) to be very useful. I find the security feature most useful, it will notify you of any CVEs effecting any gems in your apps and let you know what versions contain the fix.
[Janus](https://github.com/carlhuda/janus) is a great Vim distro for Ruby/JS development if anyone wants a vim setup that's closer to Rubymine. :-)
I tend to prefer Minitest for unit tests and straight Selenium Webdriver for browser tests. Minitest is great because it's such a concise library. It has some hair and could use some easier extensions in places, but I appreciate its simplicity and ease to hack
This doesn't really contribute to discussion, but. . . The text in this post uses the least 'ruby' sounding language that I've seen in this subreddit. Are you sure you're in the right place?
I stated I wasn't contributing to the discussion, I should probably delete it but I'm not a fan of deleted comments. Since you asked. . . The content of your post sounds really *enterprizy*(?). It feels as if you're coming to this community with the culture of another language in mind (feels like something I'd read over in a .NET forum). This makes me (unnecessarily) suspicious of you. You don't feel like you're from around here, what do you want? Are you here to get free information from people and use it to try to make money off of them (not that that's inherently a bad thing)? You ask for information about, "a 'dream' Ruby eCommerce Application design," but I feel that the ruby community is so open about it's goals and ideas that if you took part in it you'd either know this answer or know where to look for this answer (there are various open source e-commerce platforms already written in Ruby, you could look at what they're chasing after?). . . So it seems like you come from another community and you're here to bring some of what's been profitable there to this community and try to profit in that way. (Specifically: In the .NET world it is common to write a library that solves a problem and charge money for it. It feels like you've come from a community like that and saw that no one (well, not many) is doing that here and felt it could be a profitable idea. (Not that this is a bad thing.)) When something sounds out of place it can raise eyebrows, there were no comments here so I thought I'd point out that my, "eyebrow had risen."
The differences are minimal enough to just read the docs about it, or ignore them. They are either a few new features you can just look up blog posts for. Or fairly subtle under-documented changes that end up breaking backwards compat, which some new version of a book is unlikely to cover anyway. (Is there even a newer version of PragProg?)
Hint noted: what is already written is noted; it is what could be assembled using these 'step change' tools that is of interest...
Yep, but he still uses rubymine sometimes to help him uptake/learn new codebases I think.
I would suggest that instead of using janus, it is probably a better idea to take a look at it and build the plugins and settings you find useful into your own vimrc. Janus is huge (large number of plugins) and modifies a ton of settings a lot of them are not at all optimal and would need to be modified. Just for frame of reference I am also of the opionion that grabbing a random's vimrc off of github and using it as your own is a bad idea. Your ability to utilize plugins and vim settings/keybindings is greatly enhanced if you slowly and purposefully enchance your vimrc with changes that incrementally solve your problems -- so you commit those enhancements to muscle memory and optimize for your usage. Just for example janus out of the box has a pretty "meh" autocomplete/snippit integration -- where one built with YCM/Supertab/Ultisnips/ctags and proper tab bindings is 100x better. 
&gt; Proof is based on JWT, or Json Web Tokens. JWT combines the ease of use of JSON with rock-solid encryption technology "rock-solid" depending on whether your implementation has logic bugs: https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/ I feel the way the standard is designed, it encourages these sorts of bugs. Unfortunately the "alg" field remains mandatory on messages for now (but oddly, not for keys, where it belongs) All that said, JOSE/JWT is sadly the best least common denominator option right now.
MiniTest with FactoryGirl. Emphasis on model and controller tests, occasional view tests when absolutely necessary, and the barest minimum of feature/integration tests with Capybara (emphasis on headless browser, and only using Selenium only when absolutely necessary). 
I guess my real question is when documentation is written as SomeClass#AThirdThing does what comes after the # imply being be a method? I have seen the same style for writing documentation in other places of Ruby.
JWT is based on "rock-solid encryption technology", HMAC and SHA are industry standards. This library is a thin wrapper over the 'jwt' library, heavily customized to work out of the box with Rails. I know for a fact that the 'jwt' library doesn't suffer from the logic bugs discussed in the article.
From the [RDoc guidelines](http://ruby-doc.org/documentation-guidelines.html): &gt;Use `::` for describing class methods, `#` for describing instance methods, and use `.` for example code. Your methods are both instance methods, so `#` is correct. Arity doesn't matter.
Thank you very much, that helps a lot.
That's the point, you can implement JWT in Sinatra or another web framework. This is a Rails Gem that makes using it in rails applications way easier.
That is true, I'll add that to the website and README.md. I assumed my audience was as well-read on JWT as I was :0! Thanks for the suggestion :).
I'm aware, this should only be used with HTTPS connections. Luckily, it can be easily modified for more advanced authentication methods if need be.
Hey thanks for the plug! I'm one of the creators of Coveralls
Yes, security on gems is very important. I will add Gemmasium to the article as "bonus" tool. Can I mention you on the article? Thanks you!
Thanks you for develop Coveralls, I use it in a lot of projects :)
You're welcome! Sorry about the downtime last week, we had to move off of Digital Ocean to AWS because they couldn't support our DB size anymore and couldn't tell us when they'd be upgrading their service.
 $ gem uninstall rspec But yeah, if you use bundler then multiple versions installed where you want to use one that isn't the latest is no longer a problem. 
&gt; JWT is based on "rock-solid encryption technology", HMAC and SHA are industry standards. But these algorithms are mere building material in the scope of a standard like JOSE/JWT, which has its own problems. Your constant downplaying of these attacks, rather than a willingness to accept, acknowledge, and try to learn from them and prevent them, is a **HUGE WARNING SIGN** to me that you don't know what you're doing. You've made multiple, scary, baseless claims like "proof of security" when in fact the opposite is true, and cryptography professionals (like me) are in fact rather scared of them because of the problems I've just spelled out for you that you've written off with specious reasoning. You really need to adopt a different stance about your building material, or I'm going to sound the alarm and tell people not to use this stuff. I wouldn't ordinarily do that, but you're repeatedly demonstrating you don't take these attacks seriously.
Thank you, I will look into the bundler.
Because that's the [new convention](http://bundler.io/blog/2015/03/20/moving-bins-to-exe.html).
Vivaldi was just a toy language a guy, jeorgun, posted to Hacker News about 6 months ago, https://news.ycombinator.com/item?id=9053694. I saw that he had a few examples and thought it would be cool to chock him by implementing a brainfuck interpreter in his, 22 day, toy language :) It was a lot of fun and led to the immortal comment: https://github.com/jeorgun/Vivaldi/issues/1#issuecomment-74442296. tl;dr He had forgot to implement a charAt method. I've never blogged or anything in my entire life, but almost started just so I could tell that story :) edit: Also my version is based on the excellent blog post http://howistart.org/posts/nim/1, which I highly recommend reading. It also goes further by actually generating real nim code from the brainfuck source code. I wanted to go that far, but never got around doing it :)
Just now saw the gem is named 'proof-rails'. Carry on
You're confusing bugs with bugclasses. Individual bugs may not affect your code (or rather, so you claim), but the bugclasses can potentially affect your code. &gt; large teams of cryptographers That's not an argument. That's an appeal to authority. I'd self-identify as a cryptographer, who is also friends with *reputable* cryptographers, and generally we dislike JOSE/JWT. Does that make JOSE/JWT bad? No. But it does make it **controversial**. And this library is yet a another data point where people such as you are trying to downplay the controversy and make JWT sound like god's gift to bearer tokens, which is certainly is **NOT**. I'd generally describe JWT as **bad**. But I'm one person.
I'm not confusing bugs with bugclasses, you're inventing a word (bugclass) and changing your argument, because your original argument was wrong. The "Appeal to authority" card was in response to your arrogant "I'm a cryptographer and I'll tell my friends not to use JWT, muahahahah! Your library will be screwed!" Honestly, link me to one article saying JWT is bad, or prone to bugs. The only one you've given me is from perhaps the biggest proponent of JWT, auth0, pointing out issues in JWT implementations, not JWT itself. You may think JWT is bad, but for the type of application I target - Single-Page Apps with Disparate APIs - you pretty much have to use Token authentication in some form, and JWT is one of the best solutions in that regard. NOTE: I fully understand the "bugclass" you seem to be obsessed with, and like how JWT isn't a fix-all solution for all authentication, that type of bug isn't a fuck-all problem that makes any use of JWT insecure.
Yes, that's a known issue; it's a workaround from the beginning to the end, and it has its limitations. For example, you can't do [1, 2].map(&amp;2 * _) which is even worse in my opinion. But still, I think it's pretty cool.
Alright, this is getting pedantic. Here's my perspective on the issue: * I'm working hard to address any security issues people bring up, even if I don't believe they're big problems. * Regardless of if JWT is good or not, I made a library to interface with it, which simplifies the workflow for people who do decide to use JWT. * I fucking **wish** you could use cookies securely cross-origin (like with Single Page Applications), but you can't at this point. That's why people use tokens in the first place. Have fun going on a vendetta against my library! I actually made it for myself and others that need to use JWT, people *who've already thought about the tradeoffs with JWT and who decided to use it.* Maybe one day they'll make a movie about you - *They took his family, and his staunch belief that token-based authentication is terrible, in every scenario. Now, he's getting back, by posting "Don't use this JWT library" on twitter!*
Interesting. Why use this over something like doorkeeper-jwt?
OAuth is overkill for my applications.
Sorry, it's late, unsure which part you mean.
In my opinion, easy to read code is the most important metric and I often find 80 character width code annoying to read, but I also find 200 character width code annoying to read. In practice I use 120 characters as a max unless there is a very good readability reason to make it wider. I find that most of my code naturally ends up around 100 characters wide. &gt; We live in an era where the average screen size is 1920x1080 or thereabouts, and so an 80 characters in a sane font like Consolas or Source Code Pro doesn't even take 40% of the horizontal screen space. Many of us use 2 column layouts in text editors for this reason. At least part of why a lot of my code probably ends up being ~100 characters wide is that 2 100 characters columns fit quite nicely on a 2560 x 1440 screen. Also ~120 characters is all that will fit in a github PR and horizontal scrolling there is really annoying. 
Purely a personal preference at this point, in my opinion.
Issue I was having was that bot.run was blocking. After looking around a bit it appears that the ideal solution is to have the bot declare a webhook as part of an initializer and then just instantiate an instance of the bot whenever that webhook is hit. 
I like the way this looks too, but that gets you in trouble with the style guide's requirement to use the new syntax (`key: value` rather than `key =&gt; value`)
&gt; "rock-solid encryption technology", HMAC and SHA are industry standards. Neither of these is an encryption technology. And SHA could do with some clarification - SHA-1 is considered weak. 
Thanks for the suggestion this plugin looks awesome!
Well it is just a guide after all. All the engineers at my work have agreed to pretty much exclusively use hash rockets - just a preference thing :)
&gt; Neither of these is an encryption technology. Haha. You're kidding, right? &gt; And SHA could do with some clarification. It's SHA-2.
Yes, I know there's a difference between hashes and encryption. But hashes are often used to encrypt data. Also, HMAC is by definition an encryption technology. Google it.
That's all kinds of wanna-be-perl non-sense. If you want perl, then you should write perl.
It's a long story, but it boils down to there being lot of line-of-business stuff written in ruby, but it was spaghettitastic and impossible to maintain. This led to to a fire drill when something broke, and someone suggested a rewrite, following the style guide as a standard. So it was added to the test suite, but then ~~the fire nation attacked~~ some fool far-removed from how coding actually works decided that zero warnings were better than 0+n warnings, despite how invalid those warnings might be. It's dumb. Really, really dumb.
I'm using most of the plugging you mentioned, but still missing a proper way to debug or to refactor a method name across the project. Also, some little things like 'Find usages' are very specific and depended on the project structure. I figured out that Vim is not an IDE like a lot of people mentioned. 
`# rubocop:disable` (kidding)
Its not that dumb actually. 0 warnings is a good thing to have, you just need to get together and decide which warnings you should disable.
As important as hundred years ago. This is an established standard for typography. 
Now you can name the method differently. https://github.com/shockone/uberscore#name-conflict
One simple phrase about usage: use an underscore instead of a block parameter name. One simple phrase about implementation: collect method calls on a dummy object with `method_missing` and then replay them replacing the dummy with what's yielded to the block. 
if you like your colleagues, then you should not write line longer then 80, cause scrolling horizontal is a pain
AKA "Don't make me horizontal scroll you cretin"
[Kudos](https://en.wiktionary.org/wiki/kudos)?
This looks really cool and like something I would try using in a future Rails API. Can I offer some feedback on the website? This is free open source software, right? Something about the copy ("Insanely", "Stunningly", "Incredibly", "Why you'll love" it), animations, and general vibe that I'm being sold something doesn't feel quite right. All in all though, thank you for your hard work.
&gt; * The average screen size is far from 1920x1080. According to http://gs.statcounter.com/#desktop-resolution-ww-monthly-201406-201506-bar it's actually closer to 1366x768, though I don't know how accurate it is. Either way, lots of people use laptops which usually have smaller resolutions. The 13" MacBook Air has a native resolution of 1440x900. The 13" Retina MacBook Pro has a native effective resolution of 1280x800 (though it scales up to 1680x1050). Those are the standard models where I work. My impression is that 13" MacBooks are very common/popular with developers these days. Small, low-resolution displays are a real thing for developers concerned with mobility. 
Yes, it's free and open source. I'm used to designing websites that do sell something :/! i also feel like there's a lot of players in the rails a!uthentication space, and I want to convince people to use this method. As I've mentioned in other comments, I do think I'm going to change the copy slightly to seem less like it's selling something. Thanks for your feedback :)
So here's the thing: would you rather argue about standards, or would you rather program? Everyone has different styles, meaning everyone has different opinions on how Rubocop should be configured. For you, it's line length. For someone else, it's spaces inside hashes, or trailing commas. Accepting the defaults means no long arguments over which cops to enable. The decision was made for you by someone who established a widely-accepted community standard, so you can spend your time programming instead of debating pedantry. 
yep i know it works out of the box :) so, `:` means symbol, but `&amp;` should use that as an argument to translating into a block. so why introduce new operators/characters?
&gt; commas on the last line are a code smell I invite you to lookup the Code Smell definition: https://en.wikipedia.org/wiki/Code_smell Code Smells can be a lot of things, but not purely syntactic. &gt; vertical alignment helps comprehention. I really don't see how. Having so much space between the key and the value make my eyes need to "jump" that gap.
maybe i will :) ill let ya know if it actually goes anywhere. mostly i wanna see this in ruby: http://buffered.io/posts/point-free-style-what-is-it-good-for/
I've really really loved using Sequel in my non-rails projects. Jeremy is a such a hero.
Out of curiosity, why is it a code smell? I know the RSG recommends against it, but what's the practical reasoning?
ok, not code smell, syntax smell. it raises noise-to-signal ratio and that is objectively a bad thing. &gt; Having so much space between the key and the value make my eyes need to "jump" then maybe you have too much space? unnecessarily long keys/identifiers are also a syntax smell. as for jumping the gap - yes, you do have to jump but as a tradeoff you get much more "scannable" code. in the end you never actually "read" it, you jump all the time. if keys and values are clumped together - it makes you read. reading is slow. scanning is fast. it helps comprehension.
This really makes me want to try converting a couple apps I'm working on to Sequel. ActiveRecord has never really impressed me.
`&amp;` calls the `to_proc` method of an object. `Symbol#to_proc` is already defined in the standard library. I think it's a bad idea to redefine this method.
Why not bypass the hodgepodge psuedo-IDE and just use something like RubyMine - an actual IDE?
&gt; This means that you can simply replace all your ugly LIKE queries with beautiful regular expressions! elicited a chuckle
the same. I actually disklike ActiveRecord soooo muchhhh
I'm really surprised by all the negative comments. OP obviously put a lot of work into this. I'd like to remind folks that we want to encourage people to work on open source. If you feel so strongly about OP's implementation then submit a PR or open an issue and discuss like professionals. OP, thanks for all your hard work. I'm looking forward to taking for a spin!
&gt; much more stable &gt; more performant I wonder how it was measured
Thank you for presenting a very interesting fresh approach; have not heard of this before; skim read so far, will read closely later.
There are plenty of ways to do project wide function/method renames in vim from argdo to plugins. For example check out unite+qfreplace (I don't use these but I ave seen them in action). https://vimeo.com/24700977 
+1 - Metaprogramming awfulness can be found in many a language. I've seen it done in C++ -- and it was f*cking annoying to debug.
This looks more like Scala than Perl.
There are times when I want to write in something closer to "point-free" style than Ruby currently allows, but I think this is one of those things that you can't just throw into your project as a gem because there's too much risk of alienating other developers (as demonstrated by some of the comments here). It could work as a language-level feature of Ruby itself though.
1) *Performance* There is a [public benchmark](https://github.com/jeremyevans/simple_orm_benchmark) created by Jeremy Evans, on my machine Sequel performs better in every case. I forgot to add a link to it in the blog post, added it now. I also meant it because of the sequel\_pg gem, which adds significant performance improvements. 2) *Stability* I meant that because Sequel maintains 0 open issues, and ActiveRecord 300 open issues. Also I felt this when I was writing code (when compared to ActiveRecord), but I can't measure that :)
what's the pay like? Most ruby devs are used to salaries of at least 80K USD/year, can you match that?
Says you. Two hundred bucks is nothing when it's how you make your living. And thirty minutes is not enough time to really evaluate a piece of software. It took me a while to fully get used to PhpStorm (the PHP flavor of the same software) but now you couldn't take it away from me. Hey, maybe a full IDE just doesn't suit your needs right now. But to say they suck is pretty short-sighted.
Currently well over a billion records
As I am from the UK and previously a contractor, I can tell you it's not. Each economy had its own price points for certain skill sets, in keeping with the local currency and demand. Fortunately the U.S. does not set worldwide rates :)
Ok, well, after my experience as a remote dev and the ease of getting remote jobs, i wouldn't personally accept any local job that pays less than i would get working remotely. If they did offer less, i would just go back to getting a remote job that pays according to american rates. Maybe you last worked as a UK contractor before remote dev positions took off?
I like lining things up, too, but think typing hash rockets is a waste of energy. Fortunately they're not strictly necessary! def initialize ApplicationAPI::Connect( user: @username, password: @password, host: @host ).status end
thanks!
Thanks, methods don't look as bad as arrays, where providing type(s) is mandatory.
Sequel is simply better than ActiveRecord and the only reason why ActiveRecord is still more popular is because it's the default choice in Rails. Apart from quite obvious advantages in terms of the features and especially its query DSL it is worth to mention that Sequel has also much better internal design than ActiveRecord. The most complex functionality for building queries is implemented as Dataset API which is used by the model layer with a couple of model-specific additions like association DSL, validations and everything else that the AR pattern required. This great attention to proper design of lower level APIs enabled me to use Sequel as the backend for SQL in ROM for which I'm really grateful &lt;3 Having said that - I don't think it's the end of the SQL story in Ruby. There's still a lot to be done to improve how things are working. In example I would love to see a pure SQL generator with a really thin DSL layer on top of it. Such a thing could be used by both AR, Sequel, ROM and probably many other projects. Anyway, if you're OK with Active Record pattern and you start a new ruby project or have already experienced issues with AR in Rails in some existing project - don't wait, just switch to Sequel, it's freaking amazing.
Do you do the work permit paperwork?
I really enjoy the Active Record design pattern for hooking random tools into legacy systems. "schema =&gt; object" gives me quick and dirty procedural access to any database.
That worked. But you don't typically have to be wrapping parens around puts 'foo'. 
Are there any good guides on porting apps (specifically Rails apps) from ActiveRecord to Sequel? Changes in workflow, tooling, and so on? I appreciate his bit about &gt; &amp;hellip;with Sequel you can write very readable migrations, without having to redefine your models&amp;hellip; but a comparative example (or link to same) would have been Very Helpful. ---- **EDIT 29/7 @ 13:07 (GMT+8):** OK; I've found [`sequel-rails`](https://talentbox.github.io/sequel-rails/), which *appears to* render my original question largely irrelevant without directly answering it (and would have been useful to include in the OP). I'm still curious what was meant by "readable migrations, without having to redefine your models".
&gt; Did you know that PostgresSQL and MySQL have support for POSIX regular expressions? Neither did I. No one uses it because regex matching is horrifically slow even on an indexed column.
How did you know I wanted to learn elixir?? Get out of my head. I'll pull the repo this week.
Side note, just because you can do something in one line doesn't mean you should. This seems like a poor case for the ternary operator to me.
Actually, searching for `Tmdb::Search.movie('min')` doesn't find *Terminator* nor *A beautiful mind*. This is what I got: Min Sykkelen Min Tell Me Who You Are Brother of Mine Kroppen min Cageman Country Folk Min and Bill Min kone fra Paris Minions Mio in the Land of Faraway Message From The Future Golden Horseshoes Just Go With It Kundo: Age of the Rampant Children of the Revolution My So-Called Father Min mamma hade 14 barn The Sea Is Behind My Skinny Sister
It's to do with parenthesis and just a quirk of the language. You cant always leave parentheses out - the following is not legal: If foo bar 3 You'd need to write If foo (bar (3)) There is probably a similar restriction for the ternary operator. Also I'll echo other people's comments about this not being a typical use case for the ternary operator.
I do, but again, I'm a professional, so I don't get to choose.
More precisely it can't decide if colon is here a separator of ternary statement part or hash/keyword argument to puts: &lt;condition&gt; ? puts('true') : puts('false') vs &lt;condition&gt; ? puts('true' : puts) 'false' … vs &lt;condition&gt; ? puts('true' : puts('false')) … 
 &gt;1. Do you really need to be asserting valid parameters here? What's wrong with invalid parameters just being ignored? Ermm, I didn't think about it. I guess it makes no difference, accept that it let the user know he did something wrong or perhaps spelled a symbol wrong. &gt;2. Do you really need to include the if params.has_key?(:paramX) logic? What's wrong with just filling in fields with nil? I guess the only side effect of that is that Capybara accessing each elements, which might slightly impact performance. &gt;3. Why are you passing in an array which contains a hash? It looks to me params should just be a Hash! I don't know really, I expected the user to `fill_form(param1: 'foo', param2: 'baz', param3: 'bar')` - which creates an array. Is there any standard to it? most users will use what I wrote when using symbols or pass a hash? &gt;4. Rather than asserting required parameters in another method, you could just be using Hash#fetch to raise an exception Awesome :-) will do that. &gt;5. Do you really need to be using XPaths here, at all? Well, it depends. Some elements are very simple. Which means an `id` for `first_name` element will indeed just be `first_name`. However, some elements use unique identifiers and much use more complex xPath queries. EDIT: I should indeed upgrade to 2.x soon. It just that a quick try broke some gems we are currently using and require more time and research to fix things. I'm interested - how is it handled in Ruby 2.X? 
&gt; This is why we have tests :) Well, this is a test code. To be precise, and attempt to create an automation framework for few project. The consumer of those methods are Cucumber tests. I guess it's not that important to let the tester know he used the API wrong. &gt; Even so, you might be able to come up with a neater way of doing this Even if I do, I need to do some run time translation mechanism to translate the symbol name to string I guess? fill_in('Email', :with =&gt; params[:email]) means I need a method that turns `:email` into `Email`, and this getting more complex if the string is `e mail` or `e-mail`?
&gt; means I need a method that turns :email into Email, and this getting more complex if the string is e mail or e-mail? Yep, there's no easy answer to your problem if the form is using inconsistent parameters for each input id! Normally, you should just be able to do some [simple, consistent conversion](http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html) to get from one to the other.
No, now when I sign up, the site merely reloads the sign up page.
Have more stuff like this somewhere?
Check what each library is setting as the "User-Agent" header. Faraday is probably being more honest and the site being scraped is blocking anything that doesn't claim to be a web browser.
If you want to explicitly check arguments, here's probably how I'd write it: class PageObject def fill_form(params) fail(ArgumentError, "fill_form requires #{required}") unless (required - params.keys).empty? fail(ArgumentError, "fill_form only accepts #{valid}") unless (params.keys - valid).empty? # fill in ... end private def required [:param1, :param2, :param3] end def valid [:param1, :param2, :param3, :param4, :param5, :param6] end end
Thanks for the quick response. Tried this both with Faraday, using the following: response = connection.get do |req| req.url options[:url] req.params = options[:params] req.headers['User-Agent'] = 'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.4a) Gecko/20030401' end and, in Python, using the following: r = s.get(url, headers={'User-Agent': "Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.4a) Gecko/20030401"}) Unfortunately, still running into the same problem on both fronts, so I'm either not completely understanding the User-Agent header or it's something else. Also, just noticed that when trying to use Faraday, the status code returned is actually a 302 for a redirect. Not sure what the significance of this is.
maybe ruby/sinatra/cuba vs python/flask as for the easiest, if you know ruby then sinatra/cuba, otherwise flask with python :) 
It definitely appears that the cookies are the key after examining the request headers made in the actual browser vs. what's done in Mechanize vs. Faraday. I haven't used HTTPClient before. My main concern is speed, as the Mechanize version of the script takes nearly three hours to complete all the requests (and threading isn't safe using Mechanize it seems) compared to the "20 - 30 minutes" the previous user of the script quoted, although I was not able to confirm that. Any quick help on how to get a session and using cookies up-and-running with HTTPClient would be greatly appreciated!
Ok, I think I'll give it a go with HTTPClient. I'm essentially hitting a bunch of API endpoints and have no need for parsing of any sort, so Mechanize is completely unnecessary, but its automatic handling of sessions and cookies via the form login was a big plus that made it possible in the first place, so if I can replicate that with another package, that should be fine. I think my initial assessment that this was a result of the site actively trying to block me was a bit misinformed (although, this wasn't a problem with the script until recently, so maybe they have made some efforts on their end).
As a very recent new subscriber - we did it guys! And to make this not entirely facetious, can anyone suggest a little project for someone who has just finished up with the basics of Ruby and looking to put them into practice?
Agree with other posters that Flask looks more similar to Sinatra than Rails (the Python equivalent to Rails is Django). Honestly - stop hesitating and pick one. Both will work. Throw a dice if you need.
I think my big point of confusion is how exactly I get and set the cookies. I realize from a high-level perspective that when I submit the log-in details through the form, the cookies are set in my browser, but I don't understand how I can manually do that in something other than Mechanize. Do I have to submit a request to the endpoint to which the log-in details are posted and get the cookies from that response, or is there another way to approach this?
Yet, very little activity here. We should be more active (myself included)
Feel like you night get some biased answers asking if you should use Ruby on /r/ruby
There are some decent projects in here to choose from, I think, especially if Ruby is your first language: http://www.theodinproject.com/ruby-programming If you're already a programmer might be a bit elementary. 
So, first, I'd recommend reading up on how cookies work in HTTP. If you use HTTPClient, it'll handle it for you. If you use a single HTTPClient instance, it will receive cookies sent by the server, and send them back again on subsequent requests. HTTPClient is _definitely_ not the only way to do that. I just know it will, and by default. There's probably a way to get Faraday to do it too. 
A form login is at least one thing that isn't just hitting API endpoints. If you only need to get the cookies set after form login, and then send back those same cookies on all subsequent requests -- If you read up on how HTTP Cookies, you can probalby figure out how to do that yourself fairly easily. HTTP Cookies are basically just HTTP headers. The server sets cookies in headers in the HTTP response; the client sends them back on subsequent requests in headers in the HTTP request. 
Can't go wrong with the Agile Web Development with Rails 4: https://pragprog.com/book/rails4/agile-web-development-with-rails-4 It was *THE* book on how to learn Rails before it was cool. It's the granddaddy oldschoolcool if you will. 
dude it's an online book!
It calls the function again, this time with 10-1 = 9 as param, so the function will run, check again if num is &lt; 0 (no) and if num &lt;= 1 (still no) and now call 9 * factorial(9-1). Repeat as above, until you reach the point where it call factorial(2-1). Now the point is reached where num &lt;= 1, so instead of calling factorial again it simply returns 1. This value is returned, multiplied with 2 (from the previous call), so we return 2 now, which then is multiplied with 3 (giving 6, which we return again, all the chain backwards.
I think he just wants to support Hartl.
There isn't to much magic under the hood, if you want to handle cookies manually, you just need to look at the HTTP headers to see what values are set in `Set-Cookie`header, and then send them back in subsequent requests as `Cookie` header. At least in theory. There may be lots of details that end up getting in the way, depending on what the server is doing exactly (how often it resets cookies and if it needs them reset, if it uses more than one domain), that might eventually make you realize you should just use a client which already has cookie-handling features. I dunno. You'd just have to try to it. There is probably some way to get Faraday to handle cookies. I just googled 'faraday cookies' and it looks like there's a plug-in. I haven't used it. I don't use faraday. There is nothing special being done on form submit. The form is just being submitted. Either GET or POST depending on the form's `method` attribute, with whatever html `&lt;input&gt;` values are present in the form (including hidden ones). The tool I would use to see what is being done is Chrome Dev Tools in your browser. Submit the form in the browser, use Chrome Dev Tools network tab to see exactly what HTTP request the client is sending -- HTTP method, URI, and HTTP body (a form POST has a body). Maybe the headers too, just in case it is doing user-agent or referrer sniffing or what have you. Then you duplicate that request with your programmatic http request. That's it. Or if there is some weird AJAX request(s) happenign on form submit, you'll see those in dev tools too. You've just got to reverse engineer it. First understand how HTTP works, then reverse engineer what the browser is doing, then do it. 
make a valid xml, and try it again 
In pull request comments mostly.
Great! Of course, regex isn't terribly difficult once you learn which characters you need to escape and look up whatever weird control characters your crazy scheme is going to need. (I say about a language feature that reads like encrypted gibberish and requires a reference dictionary to use...)
AH amazing - this totally makes sense. Thank you all!!
Hey there - I just went through this. The final challenge has a small error where the instructions say 6 numbers rather than 7 - the repetition operator has to be changed to 7 to capture correctly and complete the challenge.
You're not taking into account: * Think time. You're assuming each request comes in neatly after the other, in serial order. 60ms later another request, then another, etc. Reality looks much, much different than that. * 95th percentile times. Real traffic isn't *all* 60ms requests, it's a distribution. If just one request takes 5s instead of 60ms, you've just queued up 83 requests (!!!) behind that slow one. All of those 83 requests are now, on average, 2.5 seconds slower thanks to that 1 slow request. Read the section at the end of this article about "doing the math" again. Note that Envato only operates at 25% of their theoretical maximum and Shopify operates at just 5%. The theoretical maximum, while a useful back-of-the-envelope calculation, cannot replace accurate queue time calculation in a production environment.
Bit confused by what you mean with: &gt; Hence I can't also modify it with Nokogiri. Are you looking for how to wrap the document with a superroot? For a small file, you can just read it into a string, then put it inside of a super root: file = File.open("sadxml", "rb") contents = file.read contents = "&lt;superroot&gt;" + contents + "&lt;/superroot&gt;" Alternatively, you could just do a preprocess phase of splitting the xml data you get.
&gt; thin's default configuration access to the application code is serialized Ah! I was struggling with a way to put this. That's a great way of describing how Thin works - serialized access. I struggled with how to describe Thin - you're right, it's not multithreaded in the way Puma is, but I was trying to convey that it *uses more than one thread of execution*, unlike Webrick. &gt; It can accept requests, but the application code will not process them till it's done with the previous request. This I didn't know. I'll have to do more digging. &gt; It doesn't spawn a thread 'with a copy of your application' Copy was clearly a bad word to use - I realize that it's not *duplicating an object* here. &gt; Well, you don't have to modify anything if your entire application is thread safe. If it's not, then your in for some trouble. I think I have to do some more learning about evented I/O, it was my understanding that this was not the case. Thanks for your corrections.
&gt; Can't a single rails process serve up 1000rpm A single process with p95 60ms response @ 1000rpm is possible, if your making good use of caching and not doing silly things in band. e.g. don't send file uploads directly to your app server. A single server with multiple processes can do far more. &gt; It's a bit of a pain to spin up an EC2 instance with Ubuntu/ruby/etc., but it's only an afternoon's worth of pain. If your not particularly devops inclined and your rails app is fairly standard then amazon elastic beanstalk works well with minimal config. 
Since you have to do 80 column lines anyway, why don't you try editing with a vertical split for a couple months?
I didn't write it, a friend/former co-worker of mine did. I suggested he write another one about Kernel.system vs Open3 and how to properly handle stdout/stdin/etc, I'll post it if he writes it up!
I really wish we were more active. I have a hard time finding places to talk with other Ruby devs. I join IRC or slack chats, but I really do not enjoy the format. I go away for a few hours and come back to hundreds of missed messages. I need threads with organized replies.
&gt; I think I have to do some more learning about evented I/O, it was my understanding that this was not the case. &gt; If you want to do actual evented 'concurrency' in your app -- you have to do all kinds of crazy things, it's true. I'm not sure if the 'evented' part of thin is kept inside thin's black box, or if it needs to effect your code too. I have no experience with thin. But I think you were right the first time maybe. Which is maybe why thin's default request handling is serialized, you can turn it evented-concurrent if you build your app for EventMachine, which is not the same as it just being thread safe. I think @moomaka meant that for _Puma_ you don't need to modify your application -- as long as it's thread-safe. Which is basically about avoiding modifying any state that could be shared between requests (global or class-level state). 
Use ordinary `def` by default. Only use define_method if you need it, if you don't know you need it, then you don't need it. :) I don't know why some tutorial is using it by default. 
Another great resource with video tutorials similar to RailsCasts is [GoRails](https://gorails.com/).
&gt; Because of the GIL, they can't be on separate cores This isn't entirely true. Any Ruby code is limited to a single thread at a time. But, MRI's threads are OS level native threads, the GIL limits access to the _interpreter_ to one thread at a time, but off interpreter operations can execute concurrently on other cores. e.g. IO and some processing in C extensions can run on other cores. This is fundamentally how things like thin work, they put actions (IO mostly) that don't need the GIL into threads then call back to the code that needs the GIL when it's done. 
This one comes up from time to time. My opinion is that it's not a technical issue. Go to Google and type "optimal characters per line". For aesthetic reasons, people (and not just programmers) have tended to keep characters per column even lower than that. It's easier to read for *people*. Not just VT100 terminals. 
Wonderful news, thanks!
can you give more details about node.js and how you handle this amount of requests. I also, want to build an api, and remove ruby and move to node or go
Most of what I see here is either goofy, nuanced shit I'll never use professionally or self-promotion.
Have you looked into using [Spinach](https://github.com/codegram/spinach)? Like Cucumber, it uses the [Gherkin language](https://github.com/codegram/gherkin-ruby). However, it has a much better object-oriented design: features map to their own classes; their steps are just methods of that class. This encourages better encapsulation and step re-usability. However, it's still - like you said - only worth implementing if "business people" will actually read the tests. At my current company, this actually does happen since integration tests are mostly written by a QA employee, who focuses almost entirely on end-user behaviour of the system.
Jesus, most people would kill for a Rails application that gets p95 response of 60ms.
FWIW I think the "performance overhead" of Rails is overblown. A post for another day. Any Rails app can scale to 1000 req/min if you through enough servers at it. Scaling to 1000 req/min *efficiently* with the least amount of servers possible is what this article is about.
They seem to be looking for Rails developers lately. What was the interview process like? Do they ask trick questions?
You might not like videos, but I did a few on various things 2.x introduced. Enumerator::Lazy: https://www.youtube.com/watch?v=Kg4aWWIsszw TracePoint: https://www.youtube.com/watch?v=V_dZQ6AeZDE Keyword arguments: https://www.youtube.com/watch?v=u8Q6Of_mScI I also have a PDF of a small book I wrote about 2.0 vs 1.9: http://no.gd/r2wt.pdf - note it only covers 2.0, not 2.1 and 2.2 which each added other things.
I don't think you're going to find an objective answer beyond "whichever language you're more familiar with." Both are fully capable of doing what you're looking for (even once you decide on Rails vs. Sinatra), and neither is in the position where anyone could definitively say that you should learn it if you already know the other language.
You're looking for 'rescue'. def your_method(foo) ... rescue StandardError =&gt; e ... e is the exception you're getting... end Thing is, you don't want to rescue from StandardError, really, so be as specific as you can with defining that error. http://stackoverflow.com/questions/10048173/why-is-it-bad-style-to-rescue-exception-e-in-ruby
I didn't get any trick questions. It was fair for me.
Excellent! Coming from a JavaScript background the *def* method is way more intuitive to me. Thanks! 
Well, I don't use Rails, but maybe I can find pure Ruby equivalent to Inflector. thanks!
That is helpful and got me one step closer, thank you! So I did this and it works: def es_check_repo(es_repo_name) begin @client.snapshot.get_repository repository: es_repo_name rescue StandardError =&gt; e p e end end The output I get from the above is: #&lt;Elasticsearch::Transport::Transport::Errors::NotFound: [404] {"error":"RepositoryMissingException[[dasdsa] missing]","status":404}&gt; I agree wholeheartedly that I should be more specific and not just rescue everything. So I figure I gotta write the code so that it only rescues when the gem's error handling returns that `[404]`, but I don't know how to. I tried some dumb stuff to see if it would work, like this: if e.to_s.include? "\"status\":404" puts "The repo does not exist" exit 1 end And yes, that works, but of course that's an ugly hack. **Edit**: never mind, figured it out! It was a simple as this: begin @client.snapshot.get_repository repository: es_repo_name rescue Elasticsearch::Transport::Transport::Errors::NotFound puts "The repo does not exist" exit 1 end
Exactly. You got it. In the main method, you don't need 'begin' btw. def is essentially a begin. You do have to use it if you're in a loop or if somewhere else. Good job!
&lt;&lt; is significantly faster than .join I could not get concat working in ruby, but ill give it a shot in rails. Rehearsal ------------------------------------------- &lt;&lt; 0.000000 0.000000 0.000000 ( 0.000148) join 0.000000 0.000000 0.000000 ( 0.001132) ---------------------------------- total: 0.000000sec user system total real &lt;&lt; 0.000000 0.000000 0.000000 ( 0.000120) join 0.000000 0.000000 0.000000 ( 0.000464) Code: require 'benchmark' require 'action_view' # include ActionView::Context # include ActionView::Helpers::TextHelper a = 'a' b = 'b' arr = %w(a b) Benchmark.bmbm(7) do |bm| bm.report('&lt;&lt;') do 1000.times do a &lt;&lt; b end end # bm.report('concat') do # 1000.times do # a concat b # end # end bm.report('join') do 1000.times do arr.join end end end
Good to know, thanks again! 
Might be worth tossing `Array#+` in there too. Concat modifies the og array, + returns a new array.
OP is talking about `String` operations, not `Array` operations. `&lt;&lt;` and `concat` are aliased for `String`. 
To clear things up: OP is talking about operations on `String`, not on `Array`. A couple notes: `a &lt;&lt; b` and `a.concat b` are aliased, they should perform the same unless there is some hidden dispatch cost. `[a, b].join` will probably be a lot slower as it has to allocate an `Array` and creates a new `String` instead of mutating `a`. The `concat` you linked isn't the `concat` your talking about. You should never need to use the `concat` you linked in Rails, as the docs note. The `concat` your asking about is: http://ruby-doc.org/core-2.2.0/String.html#method-i-concat In regards to `html_safe`, I'm not sure what you want to do here but you probably don't want to be calling `html_safe` unless you have good reason. Rails escapes all strings rendered in views by default, when you call `html_safe` on a String your telling Rails _not_ to escape it, which you don't want to do unless you have some special use case. Calling `html_safe` means 'hey Rails, this String is safe, trust me, render it exactly how it is'. 
Thanks. Ill take a look. I know this may seem like a simple question but I came across it trying to DRY up some helpers. 
I just added a bit on the `html_safe` part that is important to check out if you didn't catch it. 
Looks really good, and...it's FAST! I click on a nav link and it loads the new page so quickly it feels like a localhost. Great job. :)
Thanks, glad you like it! This is served statically by nginx, and the layout is started from scratch so uncluttered, this may help :-) Apart from ImageOptim, I didn't do too much speed optimization. Bootstrap is even served from nginx rather than a CDN (I prefer that, for security reasons). All in all, glad you like it!
I don't know of anything like that, but it seems like it probably wouldn't be too hard to build. If you want it 'like PHP', you just want when a request comes in, the path maps directly to a file on disk -- say an .erb file -- and that file is executed. Perhaps you add in some helper methods by default. You could probably just build something like that on top of Rack in a couple hundreds lines of code. Give it the Sequel gem for database access, I dunno. No doubt it'd end up more complicated than it seems. But at any rate, I don't know of anything like that. 
Don't choose only just for performance. What's the context of your usage? `&lt;&lt;` also mutates the original string, which you may want to avoid. 
Yea, JavaScript is for this, with no external libraries required. 
Sorry, reading this on my phone, if it was described I didn't notice. How are you storing images related to the article?
&gt; stick in a few PHP tags with stuff like "date_default_timezone_set("America/Los_Angeles"); echo date('l');" and now the page can say things like "it's a beautiful Sunday here in San Francisco." Stuff like that, just use Javascript. If what you really want it 'no backend knowledge required' then you should probably consider Meteor or something similar. 
[I did a write up a while back about setting up the ruby part](https://www.reddit.com/r/rails/comments/2la27p/super_noob_here_hopefully_you_guys_can_help_me/cltclkj). Feel free to skip the parts that aren't relevant. For postgres, you'll want to install postgres through your package manager (or brew if on a mac). Then you'll need to [edit the `pg_hba.conf` file](http://www.postgresql.org/docs/9.4/static/auth-pg-hba-conf.html) and add `local all all trust`. That lets any user connecting to a database locally do it without a password. It's greatly convenient and you don't need anything more secure for your development computer. You need to `sudo service postgresql restart` after you change config files. Then you should be able to `psql template1` to get in one of the template databases. From here you'll be able to create more databases, postgres users, etc. That also doesn't cover an *entire* stack. There are web frameworks such as Rails, Sinatra, [others](https://encrypted.google.com/search?hl=en&amp;q=ruby%20web%20frameworks). There's also [Rack](https://rack.github.io/) which is at a lower level. For the rest, I personally use Rails with Apache and [Passenger](https://www.phusionpassenger.com/), but there are lots of options here. It's late and that was all from memory, so feel free to ask me to clarify/correct anything. Also here is that post copied and pasted for convenience ([post for context](https://www.reddit.com/r/rails/comments/2la27p/super_noob_here_hopefully_you_guys_can_help_me/cltclkj)): --- &gt; It seems like all the downloads are on a central server that all users download from, rather than a third party website. Exactly. Each distribution hosts their own software repositories. The repository has the packages built for the particular version of the distro. An excellent introduction [can be found here](http://www.howtogeek.com/117579/htg-explains-how-software-installation-package-managers-work-on-linux/). That's not the end all be all though. You can sometimes find .deb files on websites and install them. If you've ever seen ```$ sudo dpkg -i path/to/package.deb``` That installs a deb file, although since that doesn't install it through the package manager, you won't get updates through the package manager. You can also add repository sources for packages. These are locations to other servers not managed by the distribution with packages built for the specific distro. If you've ever edited /etc/apt/sources.list or used ```add-apt-repository```, that's what's going on there. For example, the [netflix-desktop package](http://www.compholio.com/netflix-desktop/) is installed like that. And of course, you can also download files off the internet, often bash scripts, that act similar to a windows installer. They usually download a bunch of other files and modify others (for example, adding ```export PATH="$PATH:$HOME/.rvm/bin"``` to your ~/.profile which adds the location of the downloaded executable to your path). In fact, this is [exactly what RVM does](http://rvm.io/rvm/install), although a bit streamlined. Instead of you downloading a file and running it manually, those commands use curl (type ```man curl``` in a terminal window for more info) to download the installation script [then pipes it](http://linuxcommand.org/lts0060.php) to bash which immediately executes it. This effectively creates a one-liner for installing RVM. I'll circle back to RVM, but I want to get to your other points &gt; Why isn't it showing up as default under 'developer tools' when python does Since the individual distributions manage their repositories, not every package ever will appear in there (as mentioned above, there are more ways to get executables). There's a few reasons rails isn't available in the package manager (and if it is, why it's probably not recommended to install it from there). * Packages in official repositories lag behind what is really up to date since changes need to get pushed to them. For many packages, this doesn't happen nearly as often as changes are made. No one wants to start a project with an older version of rails than is necessary. * Rails updates can break existing apps when doing a major version change (Rails 2 to 3, or 3 to 4). It would be unfortunate to update rails through a package manager, only to have it break your development environment. * Over time, you'll have different apps that require different versions of rails and ruby. That project from a year and a half ago? That's still on rails 3 and ruby 1.9, and you don't have time/want to update it. But your new shiny side project is a rails 4 app with ruby 2.1. Installing a system ruby and rails makes it (almost?) impossible to develop both. As for python, it's a slower moving target (I'm guessing; I don't really know much about python). It's much easier to have a version in the official repositories which is up to date (this is mostly a guess). Now, circling back to RVM, ruby and rails, install RVM from the link above. I'm thinking you'll probably want this: ```$ \curl -sSL https://get.rvm.io | bash -s stable --rails``` I believe this will install the most up to date version of rails as a global gem for the most up to date version of ruby, which it also installs. It also makes an addition to either ~/.profile or ~/.bash_profile to add the location of rvm to your path. To get a feel for how this works, check out ~/.rvm (or wherever it was installed, but it was probably installed in ~). Particular ~/.rvm/rubies and ~/.rvm/gems. You won't see much, yet. Something similar to ruby-2.1.3-head in the rubies directory and gems directory. The former holds the ruby binary for the particular version and the latter holds all the gems installed globally for that version, which is where rails is installed (as a gem). Now the magic. $ mkdir awesome_new_project $ cd awesome_new_project $ echo 2.1.3 &amp;gt;&amp;gt; .ruby-version $ echo awesome_new_project &amp;gt;&amp;gt; .ruby-gemset $ cd .. $ cd awesome_new_project What we're doing is creating a new directory, adding 2 magic files, .ruby-version and .ruby-gemset which specify what ruby we want to use and what name to give our gemset. We ```cd``` out and back in so RVM kicks in (it checks for .ruby-version and .ruby-gemsets every time you ```cd```). You should get a message from RVM saying it created the gemset and is using a particular ruby. It will also say where it created that gemset. Check out that path (it should be the same as earlier) and you'll notice the newly created directory. RVM does crazy magic where it tracks what ruby and what gems you're using based on your .ruby-version and .ruby-gemset files. Every project should have it's own directory with it's own set of those two files. The gemset name is usually the name of the app because that's nice and easy. You can check what ruby and gemset you're currently using with ```rvm current``` You can check what gems you have installed with ``` gem list &amp;lt;gemset name&amp;gt;```, e.g. ```gem list ruby-2.1.3``` You should see rails listed when you run the gem list command. In fact, I think you can even ```rails new awesome_project``` then. Be sure to include .ruby-version and .ruby-gemset in every rails (or even plain ruby) project you make! And final cautionary word, make sure when you're using the rails version you want when creating a new project. ```rails -v``` will tell you what version of rails you're using. This was a crazy ride, hope it was useful. Please ask follow up questions! Some of this was off of memory and might not be the most clear/correct. --- 
Glad I could be of help :-)
It's not clear in the post :-) The images are stored under [_assets/images](https://github.com/wisecash/wisecash-support/tree/master/_assets/images), directly in the git repository. The "_assets" folder is handled by jekyll-assets, a gem that adds assets related features to jekyll, such as resizing images, and also adding a md5 timestamp at the end of assets names, to support automatic assets expiration (when the content of the image changes, the link also changes). To link to an image, I use the `image` liquid filter provided by jekyll-assets, via a [reusable include](https://github.com/wisecash/wisecash-support/blob/master/_includes/screenshot.html). For animated gif I avoid the resizing of the file and [just resize using CSS](https://github.com/wisecash/wisecash-support/blob/master/_includes/animation.html), to avoid compression issues. When building the site with jekyll, jekyll-assets will replace the link to something like "/help/assets/burn-chart-forecast-b42afc76ece428e10d928df377fbc89e.png". So for now the images are served directly by my server and not by a CDN. If this becomes an issue (very unlikely), I will move those to a CDN, which is afaik also supported by jekyll-assets. Hope this is clearer, and let me know otherwise :-)
I use it to see if something will work. Like, can I call map on a hash? What happens when I define a class twice? How do i merge hashes again? Getting regex patterns just right. Bare in mind i always have at least one terminal window open usually with multiple tabs or tmux running. &lt;3 shell 
I use irb for debugging all the time. Instead of puts statements I use awesome_print and then `ap something` this is most useful when dealing with nils which otherwise show up as blank space
I find BDD/TDD hard when starting from acceptance tests. Write a failing acceptance test is normally followed by many failing unit tests and the acceptance test can be red all day. I.e. being strict I think the test 'when i visit the home page I should see welcome message' should be written before rails new. The failing acceptance test is also normally only a small part of the feature and trying to write unit tests that are only relevant to that acceptance test and not the one I am going to write next is annoying. Sometimes I write 5 acceptance tests and then work to build the feature I have found I can only follow the red green refactor cycle at a relatively low level of test 
I really like the active record pattern and have never really forgiven rails for co-oping the name. It makes looking for the best way to use active record 'the pattern' almost impossible
Also the ffi gem can do this. Is this a native part of Ruby and as such ffi is depricated or at least an alternative?
Yeah, you'd think i *would* be able to build it myself, but i'm not really all that confident in my abilities. Maybe this will be my first gem.
Hm what's strange is that you installed it through homebrew, before rvm was installed. And its still looking in your .rvm/gems/ruby-2.2.1 directory. Try running rvm reinstall ruby 2.2.1 rvm use 2.2.1 rvm gemset use global gem install pry This might also work an be quicker. rvm use 2.1 rvm gemset use global gem install pry
A couple problems I notice: Your using Triple DES(DES-EDE3) on the Ruby side but single DES on the Java side. Need to start with the same cipher :) cipher = des.update(str) + des.final I don't understand this line, why are you appending here? Your code should probably look something like: des = OpenSSL::Cipher.new("DES-EDE3-CBC") des.encrypt des.key = params2 des.iv = iv des.update(data) pp Base64.strict_encode64(des.final) Just an aside, DES is broken so this is very much insecure, if you have control of the Java code, use a different cipher. 
I use it to check my logic for something that isn't working. I do what I'm trying to do in my project with dummy value just to make sure what I think that code is actually what it does. It's saved me from quite a few dumb mistakes. 
I would probably just leave it. If you can remove it with homebrew then you should be fine to remove it with rvm as well using `rvm remove x.x.x` , otherwise there is probably still some system reference to it somewhere which is probably why it made that directory to begin with. If you just want to have a specific Ruby be your default you can use. `rvm use 2.1 --default`
Here's a talk that introduces REPL-driven development with Pry: http://confreaks.tv/videos/rubyconf2013-repl-driven-development-with-pry
Actually, I should do something about it. I just relaunched Terminal and it's not responding to the pry command. It looks like I'm going to have to do what you suggested each time I want to run Ruby -- which would be annoying! Any subsequent tips?
Still does't work unfortunately. As soon as I enter "pry," I get the same error in my original post :-/ 
try removing pry (before selecting a ruby version) and installing it again.
if any more problems pop up, i recommend running `gem clean` and start from a clean slate. I think you uninstalled Ruby while it had some things installed in your bin folders which is annoying since it doesn't remove those.
Good to know. Thanks again, much appreciated.
I exclusively use pry for REPLing/binding.pry, and only that. I kinda had a feeling I was missing out on other features...your comment has prompted me to look into what else I can be doing with it.
 c = a.select { |e| b.include? e }
I try to replace a.length.times with just a.each and get the error. I thought a.each would allow me to loop through each array element, but I get an error. Sorry if I am being dense. EDIT: Oh, ok, I think I get it now. Ruby gives me the array element as the declared variable. I think I was thinking about it from a JS mindframe... like 'for(i=0; i&lt;a.length; i++){}' would be the same as 'a.each {|i| }' when really it would be like 'for(j=0;j&lt;a.length;j++){i=a[j]; }'
I'm just trying to test my knowledge and ability. I am still very new.
Nice find! I've been using sidekiq for years and never noticed that.
yes.. Next time include the error message, we'll be able to help more accruately!
haha, very complete, thanks! Personally I like #2 the best for readability. Maybe that's just because I am still new.
Haha, thanks!
same, that is amazing.
haha I can't believe I've never thought of this. 
Eventually you'll probably see the first one as the most readable and most "ruby".
You mean `Array#each`, the `#` indicates instance method, whereas `Array.each` implies each is a class method, which it isn't.
There used to be a snowman in every single rails request, so that anything that touched the params would be encoded as UTF-8 http://stackoverflow.com/questions/3222013/what-is-the-snowman-param-in-ruby-on-rails-3-forms-for it was later changed to a UTF-8 check mark.
Where is the best place to find out the current state of the rack next debate?
\#2 is how you'd often see it written by new programmers... But it's very verbose and unnecessarily complex. However, in this case the simplest way is to just use the built-in set intersection method: From: array.c (C Method): Owner: Array Visibility: public Signature: &amp;(arg1) Number of lines: 4 Set Intersection---Returns a new array containing elements common to the two arrays, with no duplicates. [ 1, 1, 3, 5 ] &amp; [ 1, 2, 3 ] #=&gt; [ 1, 3 ] I.e. you could have just done: puts "Please enter your first array, separated by spaces:" a = gets.chomp.downcase.split(" ") puts "Please enter your second array, separated by spaces:" b = gets.chomp.downcase.split(" ") c = a &amp; b puts "The two arrays you entered have the following elements in common:" puts c Method \#1 above is syntax that can be used to solve a more generic problem, and is generally considered a better/more "ruby" way of doing it.
Some other high quality content similar to this article: http://javieracero.com/blog/starting-with-eventmachine-i http://merbist.com/2011/02/22/concurrency-in-ruby-explained http://rubylearning.com/blog/2010/10/01/an-introduction-to-eventmachine-and-how-to-avoid-callback-spaghetti 
There doesn't seem to a be a single place yet that I've seen. If you interested here are some links to follow: [Rack effective 'end of development' annoucement](https://groups.google.com/forum/#!topic/rack-devel/P8oOycVBaH0) https://github.com/Wardrop/Rack-Next https://github.com/tenderlove/the_metal
I've personally found EventMachine to be a nightmare to work with, among other things it's buggy as hell and barely has any active development ongoing. Everyone I've talked to that has stepped into it's internals has come out bug eyed. If you need evented IO, I would recommend taking a look at [Celluloid](https://celluloid.io). 
Ah thanks, yeah my experience with EM is not high load situations, just in handling somewhat infrequent hardware io (serial port) and UI elements, and I haven't run into issues like that.
I agree with you there. I already switched to Celluloid some time ago, but I explored EventMachine's source code and wrote an article about it as a learning exercise. I'm currently writing a blog post about Celluloid's approach to concurrency and its internals and I can tell by looking at it source code that it's a much more well-thought out project and more powerful library, but also much more complex. 
Yes, you're right. :) I was simply citing the things provided in the linked article. I also prefer to keep the language at least above link and button level of abstraction if I do use Cucumber. If and only if someone except for developers is reading those things, then yes, they might have value.
I feel that list is missing a lot of commonly used ActiveSupport features, e.g. `HashWithIndifferentAccess`. Also, several listed are deprecated as of Rails 5, e.g. `Module#alias_method_chain`. 
cant you do this with `ls -l` etc in pry right now?
Hi! Thanks, I will modify the list. I created it based on my personal experience, I know I will need to update it :)
why not extend the core functionality with an additional flag? like `-v` for verbose?
This is the second or third time you've referenced this bug hunt. What was the bug?
Wow, someone reposted Disc to r/ruby! Nice to see, I'm the author. :) To your question: I started running some benchmarks yesterday - more for fun than to try to prove anything - but I found that Disc appears to be significantly faster: I enqueued and executed 150k simple jobs, for the enqueuing part Sidekiq took around 39 seconds compared to only 13 for Disc, when I fired up workers Sidekiq needed 276~ seconds to complete all jobs, while Disc was done in 33 seconds. Honestly nobody is as surprised as I am with this result because performance was never really a consideration, my intuition tells me that most of the difference must come from Disc having a more specialised backend in Disque as opposed to Sidekiq having to wrestle with Redis to do its thing, but there may also be some overhead on Sidekiq itself as well. Anyway, I'll do more exhaustive testing and organise my findings in a blog post soon, thanks for the interest!
Why was `ENV` being used to transfer anything related to an HTTP request? Do you mean the request env? i.e. `request.env` ? 
Not a bad pattern when your input doesn't line up to a model, but there is no need to reinvent a bunch of logic, just `include ActiveModel::Validations` in the form class and use the same validators you're used to from your models. 
Second time we've seen this here. I think Disque is interesting and I don't think this gem is poorly coded as stands, but it has a long way to go before it's remotely production ready, so be careful. The most obvious issue is that there is no way to safely shut this down, i.e. there is no signal handling, you send SIGTERM to a worker process and all workers die in place, possibly leaving jobs in half processed states. They'll timeout on Disque and be rerun but how much has already been done? Resque for example catches SIGQUIT and allows the worker to finish it's current job before shutting down. Also concerning is that there are no job timeout controls. If you have a single job that hits something like an infinite loop in the worker it will never be killed, the disque timeout will be hit, the job will be resent, and over time you'll just end up with all worker threads stuck. 
think of each as 'each element' if you want the index, there is [Array#each_index](http://ruby-doc.org/core-2.2.0/Array.html#method-i-each_index)
Trust me from experience, it hasn't been stable for a while. ANd unless there's been significant work done on it, shoes is an . . . . interesting codebase in that i wouldn't trust it in any significantly important program. If you're just testing ruby or shoes or just want to make a small program, i believe green shoes is what I used and it worked decently well (except for some memory problems). after shoes or if you just want to jump to something bigger, try one of the more established gui frameworks. Qt works well although i haven't tried it with ruby yet, it works great with python/c++. It should be fine with ruby. That being all said and done, shoes is a great program and I really hope that they get somewhere signficant with it. Even the unstable shoes i worked with a couple years ago was beautiful and exceeded my expectations. if only more gui frameworks were like shoes but more established.
Sorry, I was talking about the Rack middleware "env" argument that is passed between middlewares.
I meant the "Rack middleware env" and not the ENV. My bad. I've edited my replies.
Consider using Opal, the Ruby-to-Javascript transpiler. You'll be able to write ruby code to interact with the browser canvas, and if you like you can make it run "natively" (not in browser) by using node-webkit. [This](https://github.com/domgetter/dare/wiki/Ruby-Tutorial) game library following that concept looks decent and is based on Gosu, I believe.
This is a good post. Higher quality that most of what I see being posted. Kudos to you and thanks. 
It's undoubtedly good advice to avoid overusing hashes and arrays to represent various concepts in your code. That said, I'm not sure about the term Data Object as it is used in the article. The definition ("Data Objects contain data; they don’t implement any behaviour") may encourage one to overlook a major benefit of creating a class to represent some concept in your code - it becomes an obvious place to add related behaviour as needed. Objects which contain only data and accessor methods often become the victim of [feature envy](https://sourcemaking.com/refactoring/feature-envy). In fact, the similar term [Data Class](https://sourcemaking.com/refactoring/data-class) is sometimes used pejoratively to describe this antipattern. Of course there are cases where such objects are legitimately useful, and the article uses a common example: working with APIs. In this context the more established term [Data Transfer Object](http://martinfowler.com/eaaCatalog/dataTransferObject.html) may be preferable.
I think the pain of overusing Hashes is overstated. Primitive obsession is a thing, but people forget that any object can implement the `Hash` duck type: class Foo def [] key; end def []= key, val; end end This means any `Hash` in your code can be swapped out with an object oriented substitute. IMO `Hash` is a better duck type to represent bags of data than `Struct` or `OpenStruct`.
Are you talking about dumping the data out from the database and processing it with Ruby instead? That's definitely doable, and fine if you're only going to do this once, but SQL has a lot of features built-in that'll make your life easier in the long run. For example, would you want to write Ruby to match up rows between two or more tables based on a particular field? What about the case where multiple rows from table A match one row on table B? or when no rows match the row on table B? In SQL, you just have to use one of the JOIN statements (INNER JOIN, LEFT/RIGHT OUTER JOIN). Plus, take any opportunity you can to learn another language; it'll make you a better programmer. Another thing, see if you can get access to a copy of the database or set up a read-only follower instead of getting direct access to the live production database. This will protect you from accidentally deleting data as well as avoiding any impact on the production database in case you happen to run a really slow query.
If you're dealing with large datasets, learning the SQL syntax that you can use in PG will help you greatly as you can find yourself hammering a DB with ruby and many queries, but one query if you figure it out. Your DB guys will thank you.
The article mentions: "Using an object also leads to a nicer syntax and better error messages". You can also get better error messages if you use `fetch` instead of `[]` to read from your hash. **Example**: user_hash.fetch(:signup_time).to_date #=&gt; KeyError: key not found: :signup_time http://devdocs.io/ruby/hash#method-i-fetch
It's always easier to learn one thing at a time than two. I've taught a couple people SQL and Ruby but never at the same time. The beauty of SQL is that it's largely portable and will be useful no matter what programming language or framework you use. It's kind of timeless and based on some [well proven mathematical theories](https://en.wikipedia.org/wiki/Relational_database). In the past twenty years of my career languages ebb and flow but SQL endures.
It's also a lot less simple than it seems. Sure, there's just one method, `call`, with one argument, `env`, but that doesn't tell the whole story. There is like a universe of variable data inside `env`.
Solid advice. If you know raw SQL you can inject it anywhere.
Those benchmarks are the job equivalent of the "hello world" web server benchmarks. In reality, no one enqueues 150k jobs and expects them to take 30 seconds. Jobs typically take many milliseconds to execute and so benchmarking dispatch overhead isn't terribly useful. Make each job "sleep 0.1" and post those numbers. :-) I don't doubt Disc will be faster but Sidekiq provides many features which Disc does not, adding overhead, e.g. real-time metrics and middleware.
Briefly looked through the code and it looks very nice and very straightforward. I'll have to give it a try /hattip.
Absolutely, they are in no way formal benchmarks, and I wasn't even planning on measuring enqueuing time either, I just noticed it taking longer and thought I'd run it with `time` in front. I'm setting up a repo so it's easy to reproduce the tests and I was actually planning on sending you an email for feedback, to see if there are things I can do better. Would it be ok if I give you access? Anyway, people don't often take the chance to say stuff like this but: thanks for writing Sidekiq, I've been using it for years and its by far the best job/worker implementation I've used, I think it's very noticeable how much of Disc it inspired. :)
Hmm that's what's I am trying to avoid. I'd like to have a setup where images related to a post are kept together with the post itself instead of having one large image dump.
To encapsulating data is the reason objects exist :)
ayy lmao
Sports stats, cell phone specs, stock prices, census data, local treasurer/property sales.
&gt; Jobs are assumed to be idempotent just as in Sidekiq, which they should be anyway considering that jobs can often fail and be retried in all of Sidekiq, Resque and Disc. There is a big difference between a job that as a whole is idempotent, and a job that is idempotent at every stage, i.e. that can be interrupted at an arbitrary stage yet still maintains idempotence at the job level. The former is much easier to achieve and the later rarely exists in practice. Even outside this issue, killing a process without allowing for any cleanup is still not a great idea. For example your quite possibly leaving dangling resources that may or may not clean up after themselves reasonably when the process just dies. 
I don't see the difference. The `valid?` method from ActiveModel checks all validations defined, be they attribute validations or method validators. There is no functional difference between defining those validations using ActiveModel what your describing except AM provides a cleaner API. 
Sure, hook me up.
thanks, definitely inspiring me with some cool ideas!
Whenever I'm getting familiar with a new framework or language I tend to build an API that wraps one that already exists via scraping. Hacker News is a great one to do. Just write some failing integration specs to start for each of your main endpoints, and go from there. I would also heavily recommend giving the make-an-api chapter at the end of "Rails 4 In Action" a read.
Sunlight Foundation's API
&gt; It works by wrapping libffi, a popular C library that allows code written in one language to call methods written in another. So it is more or less just an abstraction over FFI to make it more convenient.
Did you read the first article on value objects. I never shared a link here but you can get to it from the form object article. If you still think its much the same I will have to try and write a gist or think harder and work out if in fact they are and I dont see it 
Didn't know if this might also belong in the rails descussion. It's very much a commentary on the way I used to work with ActiveRecord. Also as a solution it is completely compatible with the rails stack. I didn't want to spam so chose just this one. right call?
If anyone is looking for a ruby mumble bot to use/look at, I'll just shamelessly self promote and leave this here: [Mumblecop](https://bitbucket.org/Flandoo/mumblecop)
Thanks! Of course it's not nearly as well documented/commented as it should be, but hopefully it will make sense.
Thanks, purchased this, and a Kobo to read the eBook. I am overdue an eReader anyhow. Also added Metaprogramming with Ruby, which might be useful, since I still think procedurally most of the time.
I agree with the author that "fat model, skinny controller" is sometimes misinterpreted as "fat ActiveRecord, skinny controller". The word "model" in this context really refers to the entire business-logic layer of an application, which happens to include DB interaction. Sometimes people forget ROR is still Ruby, and disregard SOLID OOP. Keeping objects *within* the model layer small and cohesive is very important, like the author proposes in the example (UserRecord vs User). Thanks for the share, cheers!
Sure, why not? &gt; Again, the goal is basic scripting with an added bonus of developing programming skills and it seems like R is a pretty good choice for this, and I do know some folks in my field who use Ruby quite a bit. You realize `R` and `ruby` are two different unrelated things, right? 
This is my *first submission* so obvious no history. Don't scare off new users with premature assumption :)
I'd go with python. Pandas, numpy, scipy etc are much more mature for data analysis. 
Well for data analysis I don't plan on using either since I stay in R/Matlab for that. 
For something like this, I think it's important for you to like the language, so I'd go with Ruby. However, would you ever need to share this stuff with anyone else? I come from the engineering world, which is heavy in Python, so anything I might share would probably be written in Python.
Just curious, why do you use BitBucket? Have you compared it to GitHub? Things you like better?
I have no idea what you're talking about. 
[Scriptster](https://github.com/pazdera/scriptster)?
I enjoy writing Ruby but I loathe the community's habit of writing hyper-simplistic documentation and articles. It's hard for a newbie to the language or programming in general to absorb useful information from blogs when half of the content available is "Look how easy this library is! if 'foo' puts 'bar' end It's so easy!" If you're going to take the time to write a technical article at least write somewhat useful content. 
Bad developers can make even the best tools look like shit. 
I think what /u/odoyle489 and /u/synt4x are kind of getting at is that its great to write a blog post talking about a gem, but for a gem like this if you take it to a detailed enough example that shows what types of problems it could solve it helps devs of all levels get a "aha" moment for a gem. The level of detail you go into really does not trigger a watershed moment for the gem, as someone that is familiar with init like /u/synt4x is implying. Just taking it a little farther into here is a problem I was able to solve would get your readers there. 
Well, at the moment it's mostly just because I've used it for a long time. The reason why I started was because I liked using mercurial over git (and I still prefer mercurial a bit) although I'm comfortable enough with git now. I also have a lot of private repositories, because when I was starting out I was too embarrassed to open source any of my work :) again though, I'd open source almost all of my current work. Do you think I should make the switch over? Github does look much nicer.
I think the bottom line is GitHub has a lot more people and so putting your work up there is going to have a higher chance of being seen. If you want to contribute to anyone else's GitHub project you'll need an account anyway. Also, some websites let you sign in with GitHub OAuth which is convenient. For example www.codeeval.com The big factor is not having private repos.
┬──┬◡ﾉ(° -°ﾉ) Calm down, yo.
thanks I needed that.
It's a double-edged sword, though. While performance will bring great benefits, it'll also confuse the hell out of people. For example you have tests for your model validations and behavior, API, web and what not. Only one or two categories have failing tests. My first reaction would be, why only X category fails and Y doesn't. It would require me to pay extra attention to the way test model instances are created. Definitely a good article nevertheless, but just have the above point-of-view in mind.
Yeah exactly. You can also do some tricks like mounting partition with the db in ramfs and get a major performance boost. I remember when travis configured pg (or mysql, can't remember exactly) to run in-memory and specs for datamapper started running as fast as for `sqlite::memory` setup. Also *not using heavy factories* speeds things up :)
I think the problem is people think, "`Hash` is a primitive. I need an `Object` in order to write better object oriented code." The problem is that `Hash` *is* an object, and it's how you use it that determines if you've violated OOP principles.
It's never possible to use FG without its dependencies, which loads all the rails stuff anyway, and causes no less than a 3-5 second load time at the start of tests. Calling .build instead of .create is only slightly better. You've still got a mountain of bloat you may or may not use just by including that gem. Slow tests are the death of TDD. Everyone hates testing when it takes forever to run. 
Doubles / Mocks, method stubs, constant stubs (stub_const), etc. never persist anything to the test DB (you're basically including tests of your ORM at that point) and never load spec_helper (because it almost always loads rails stuff which makes tests take forever). I state this advice because I've done all these bad things and suffer to this day some brutally long test suites. I no longer add to the problem and I try to refactor old tests time permitting, but I'll never recover many lost hours of my life sat waiting on these damn tests to run. Don't be me kids. Don't use FG. 
You're assuming that .Create always hits a database. FactoryGirl is configurable to make it do whatever you need. While it may not be great for unit tests, it is fantastic for integration tests. 
glad you found it, I would have posted the link but I was on mobile and was being lazy. ;)
I must admit I don't understand anything about ROM from the [rom-rb.org](http://rom-rb.org/) website, and I did at some point write my own Object-Mapper (don't worry, it's obsolete now). Perhaps a bit of examples of how "ROM" is meant to be used?
&gt; ActiveSupport Dependencies https://github.com/rails/rails/blob/master/activesupport/lib/active_support/dependencies.rb Want to keep going? 
Actually, FactoryGirl is not ideal for integration tests. You should not be operating at an abstraction level below your testing surface, regardless of the kind of test you're implementing. Bypassing your application's interface by injecting database state opens you up to tests that either break when they shouldn't, or don't break when they should. Integration tests should test the interface to your application. If your only interface is a web UI, as you get with stock rails, then you have to fire up capybara. If you build an interface beneath the GUI, for instance if you employ DCI, then you should use that to test your application end to end. It's very poor practice to look at your application, decide it'd be hard to actually test it thanks to poor design, and start concocting highly coupled, elaborate "tests" that exercise untold swaths of your code at the cost of making even an ounce of sense. I find that once organizations decide to legitimize this practice by calling it "integration," "acceptance," or "end to end" testing, they're about 6-18 months away from the rewrite that TDD was supposed to help avoid.
I think /u/Misiato is saying that tools can and should at least be partially judged by common usage patterns. This should be a given. In fact, the tool should be judged *mostly* by its common usage patterns.
 source: (params[:card].empty? ? nil : params[:card])
And I'm saying the factory girl isn't thr cause of slowness regarding DB operations because all it does is call 'save!' on the model. 
Would [this](https://github.com/enocom/json-api/tree/control-flow-repo) be an example of decoupling? 
Well `#save!` in this case means "please take me and my associated objects and shove them all in the database," irrespective of what you're using underneath FactoryGirl.
If you are using Rails, then it's OK to ask for a key that doesn't exist on the `params` hash. It should just return `nil` for nonexistent keys. Maybe the exception you encountered had a different cause? We'd probably have to see more of your code and the error message, to be sure.
Yes, pretty much, repository hides AR and exposes POROs.
do i press the plus key as well or just ctrl and /? 
Ctrl and / or Cmd and / on Mac
/u/simkessy, I was responding to a comment you added, but it seems to have been deleted. The error message you included looked like what happens when you think you have a Hash, but it's really `nil`. Don't know if that helps. 
source: params.fetch(:card, nil) 
Thanks for the effort! I think the guides are good as a kind of dive-in once you have "bought it", but I feel the Overview section lack more tasters to get you hooked into the philosophy. At first it just sounds like you have renamed ModelViewController. Overview just explains Adapters, Relations and Mappers (as in the guides), but without any code or figures - I need more meat here for me to to be "convinced" so to speak.
Doing what you specifically asked: customer_params = { customer: current_user.stripe_id, amount: booking_total.to_i * 100, description: "Purchase booking #{availability.id}", currency: "CAD" } unless params[:card].empty? customer_params[:source] = params[:card] end charge = Stripe::Customer.create(customer_params) However, what you probably want is this: charge = Strip::Customer.create( customer: current_user.stripe_id, source: params[:card].presence, amount: booking_total.to_i * 100, description: "Purchase booking #{availability.id}", currency: "CAD" )
This article was very helpful. Thanks!
Whats a midlevel Rails dev expect to make in London these days? I'm currently looking there from the US, not sure what salary to aim for. Also they would be sponsoring my visa so tricky situation. Dont want to aim too high and not get any offers.
I'm going to assume that you didn't actually read any of those. &gt; https://coderwall.com/p/kxfobg/taking-the-factorygirl-out-of-factorygirl-create Has absolutely nothing at all to do with the point your trying to argue. Nor does: &gt; http://brandonhilkert.com/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/ The majority of the rest focus on _not hitting the database_. Your earlier comment in regards to this issues was: &gt; Calling .build instead of .create is only slightly better. So, I don't think you have a leg to stand on in this argument.
Sure. It comes in handy whenever you have something to do quickly, something like prototyping or working with part of the whole data. Of course, R and Ruby are completely different thing. And I suggest that you keep doing what you do with R, and also, think about / doing (depending on the time you have) it in ruby. This will help a lot! :)
F1 stats, all the way! :P
&gt; Hard copy to flip through every so often Exactly how I feel about every programming book! :+1:
To offer the counter point: don't listen to any of this. End to end tests are the most important tests you have, don't limit them. Write more end-to-end test than unit tests. Why? because good end to end test actually test the user experience, not what the programmer thinks is 'good enough and fast'. I should also note that it doesn't matter who the user is here, i.e. it doesn't matter if this is a library where the 'user' is another programmer or a web app where the 'user' is an outside person in a browser, the user's interaction is the most important thing. I don't have a clue why the parent is sitting around waiting for tests to run, configure guard correctly to only run the related tests and let your CI server do the full test while your off doing other things.
ELI5 -- What are we looking at?
&gt;Software projects are displayed by Gource as an animated tree with the root directory of the project at its centre. Directories appear as branches with files as leaves. Developers can be seen working on the tree at the times they contributed to the project. https://code.google.com/p/gource/
Which mode could allow for c to be comment?
 params[:card] = nil params[:card].empty? ? nil : params[:card] =&gt; NoMethodError: undefined method `empty?' for nil:NilClass
Type-checking that we have is done a) by hands and b) late. It IS NOT (always) the flaw, but it IS definitive characteristic of our language and similar ones. If we have a method like: def something_complicated(arg1, arg2) end ...and it is called from many places in code, it is possible to have lately (like "in production") to have it called with just wrong type of arguments and everything fails with fancy `NoMethodError: NilClass have no +`. If Ruby had some type annotation/checking feature, we'd can at least catch this earlier (on tests, maybe) and have more meaningful errors, like: def something_compicated(arg1: String) end something_compicated(1) # bang: ArgumentError: something_complicated expects String, Fixnum got If Ruby had some kind of "static" type checking, you'd even don't need tests for obvious errors. Though, type checking limits language flexibility -- which can be clearly seen when looking at Crystal, started as a "statically typed Ruby". It's a beautiful language, though some of the most useful Ruby features are just not possible in Crystal. EDIT: various typos
A lot of the benchmarks are very close. It would be nice if they could be arranged by the gains, showing the largest gains at the top.
Alternatively, don't daemonize and use the init system: http://www.mikeperham.com/2014/09/22/dont-daemonize-your-daemons/
I know about contracts (and there's [several](https://github.com/gogotanaka/Rubype) [other](https://github.com/janlelis/sig) [implementations](https://github.com/plexus/typecheck), [tons](https://github.com/plum-umd/rtc) of them). Neither of them seems to be widely used. They all seem just excercises in metaprogramming. I've just tried to explain what it means "ruby have no typechecking". IMO, typechecking is rather a discipline &amp; paradigm, not feature or library. Either you use types as a basic "building block" or not (the same thing as with [pattern matching](http://zverok.github.io/blog/2015-07-18-matchish.html) -- there's also several implementations in Ruby, including mine, yet neither of them create a new approach to programming in Ruby). For practical purposes like "those domain objects should control input/output values" things like [virtus](https://github.com/solnic/virtus) or [ROM](http://rom-rb.org/) are much more natural for Ruby developers.
If you make the assumption that this is 100% of your tests, yes they become brittle and prone to error. But, the point here is that a unit test, one that is responsible for ensuring a model has a specific attribute set and calls out to save, works correctly. Integration tests which ensure the entire application works properly have their place in a test suite as well, this approach is not for those tests. Testing ActiveRecord is not the job of your application, why would you do it in your unit tests?
We have the same book then. Did you read the conclusion? IMO Ghost Inspector is a different kind of test. Regarding to `sleep(60)`, it's how email/SMTP works, it isn't in real time.
This test is brittle and there's a huge chance it won't fail when something breaks completely. I'm not sure what else should I write to convince you, maybe a short example will do: before_save { some_code_that_mutates_object_further_so_it_is_no_longer_in_the_expected_state } The test will pass because the callback which has side-effects never gets triggered as `save!` was stubbed in the test. Which is also a nice example why lifecycle callbacks are a horrible idea.
Instead of dx = (to_x - from_x) &lt;=&gt; 0 why not dx = to_x &lt;=&gt; from_x ? edit: formatting
questions is, is it an interview for a software engineer (in the US sense), then all is fine, want to become a developer, you should answer the question self, and very important did you have a code of conduct (also, only US specific; in europe, implicitness don't need to write down, people can think)
Excellent point. Obvious in retrospect! Thanks for pointing it out.
Good ol' standard lib.
If you ever want to know a better way to do something cool you just discovered you should definitely show said discovery to this sub.
You beauty! a chmod and bundle install did the trick. Somehow that wasn't mentioned on any of the sites I looked at. now, the code runs but doesn't work, so the tangled web continues!
http://radek.io/2015/07/13/ruby-scripting/
That's interesting. They both appear to be from Shell::CommandProcessor, though `exists?` is clearly not listed in the docs there. 2.2.0 :006 &gt; require "shell" =&gt; true 2.2.0 :007 &gt; sh = Shell.cd "/tmp" =&gt; #&lt;Shell:0x007ffd7a7a9188&gt; 2.2.0 :009 &gt; exists = sh.method :exists? =&gt; #&lt;Method: Shell#exists?&gt; 2.2.0 :010 &gt; exists.source_location =&gt; ["/Users/jemminger/.rvm/rubies/ruby-2.2.0/lib/ruby/2.2.0/shell/command-processor.rb", 592] 2.2.0 :012 &gt; open = sh.method :open =&gt; #&lt;Method: Shell#open&gt; 2.2.0 :013 &gt; open.source_location =&gt; ["/Users/jemminger/.rvm/rubies/ruby-2.2.0/lib/ruby/2.2.0/shell/command-processor.rb", 592] 2.2.0 :014 &gt; 
Yep, looks like documentation for that is missing. For now, you can check the source here for those methods: http://rxr.whitequark.org/mri/source/lib/shell/command-processor.rb?v=2.1.2#478
I was offered a job :) As far as I know, there are no companies, which are using Elixir in Russia. Do you think Elixir will replace Erlang in the future?
Almost never worth it imo unless you've identified the code as being a bottleneck or running in a super tight loop, which is pretty rare in our IO bound world. Better to code for clarity Also I assume this for the YARV? There are probably more gains to be had by trying jruby, rubinus, rbx, etc
I see a lot of words
Trippy. I love watching Gource videos, but at a certain level of complexity, it becomes a single abstract blob.
Correct me if I'm wrong, but aren't implementations of the spaceship operator 'allowed' to return any positive or negative number? Not that this would affect this particular case, since `Numeric#&lt;=&gt;` is not going to.
It seems like the author hasn't read the pickaxe. Kind of amazing.
I actually also code in this way when coding Java in my leisure time It makes my classes clearer When I read the source code for a API method (public methods which is built for external use), I don't want to read every small variables (details), but only the important bits (logic, high level data). If I want to know more, I can always go deeper (into private methods or other objects)
It is completely interoperable. Elixir is respected in the Erlang community. It is not going away.
Erlang has more terse and more elegant syntax. Elixir is overly verbose IMHO. 
https://www.reddit.com/r/ruby/comments/3fss8s/visualization_of_last_decade_of_rails_development/
&gt; This article was originally published by Pat Shaughnessy on his personal blog. With his kind permission, we’re sharing it here for Codeship readers. I'm guessing that they thought it'd be interesting and relevant to their readers that may not have seen it. 
Keyword was 'seems'. I sincerely doubt anyone writing a blog about Ruby hasn't cracked open the pickaxe. I wasn't aware of Jamis before this post. He certainly has some great work out there Net::SSH and Capistrano, really impressive and the focus on maze generation looks interesting as well. Makes this post all the more quizzical.
FYI, typo: &gt; I’m going to show you how *you I* did it,
But you never make any mistakes, do ya, chief? 
How is that different than me reposting blog posts and posting them to reddit?
I don't suppose their is much difference and I don't think there'd really be any problem with that. So long as you are reposting it for a good reason and with permission of the author then that'd be great. 
&gt; Life with Ruby would be so much easier if Strings were immutable. Easier? maybe. Faster? Probably not. There's plenty of times when I was able to save object allocations by mutating the same string: https://github.com/mime-types/ruby-mime-types/pull/93. The main benefit of languages that only have immutable datatypes is the ability to run components in parallel since they have no side effects. For web programming there is very little we can truly parallelize, quite a few actions must be made sequentially, in those cases the savings of object re-use is likely greater than the ability to write side-effect free programs. What I wish all string literals were lazily immutable by default. I.e. the interpreter would do a copy/allocation of the string only when it's written to. I hate littering my code with `.freeze`. It's also worth nothing that the majority of the speed here came from getting rid of arrays and hashes. While strings might make the bulk of the allocations, they're pretty cheap to allocate. It takes about 70K strings to take up 1ms of run time (as benchmarked on a mac book air). 
The 'leader election' bit sounds sketchy. It sounds like an attempt to implement exactly once semantics on top of a system that is inherently at most once, but it's hard to tell without more information.
Not sure I understand. With a "single master" system like Redis, it's not that hard to implement. All Sidekiq processes are talking to a single shared Redis datastore. http://redis.io/commands/setnx
If you prefer open source tools to closed source subscriptions, there are some pretty good options for [scheduling](https://github.com/tomykaira/clockwork), [unique jobs](https://github.com/mhenrixon/sidekiq-unique-jobs), and [rate limiting](https://github.com/gevans/sidekiq-throttler) that work well with Sidekiq OSS ("Hobbyists" edition, as it is now called).
Thanks, fixed :heart:
Thanks, though I've always thought of myself as a sidekiq ;)
we were just discussing, what if anything we gain w/ unique jobs (enterprise) vs sidekiq-unique-jobs (w/ pro) which we currently use. Heroku scheduler stinks, I'm always looking at alternates, but not my domain, so I just randomly complain about it ;)
Thanks!
I don't know exactly what you asking but the original Hobix docs are archived here: http://redcloth.org/hobix.com RedCloth has grown quite a bit since _why_ disappeared. 
If a process can't contact Redis, it's not going to become leader, right?
&gt; I assumed it was user error. Thank you. It's not, the docs are a little funky here. Shell mixes in a bunch of functionality from `File` and `FileTest` in a way that it doesn't appear in ruby-docs. See: https://github.com/ruby/ruby/blob/trunk/lib/shell/command-processor.rb#L484
I realize that, but there is also http://hobix.github.io which kind of looks like the old site but actually has newer stuff, so I wanted to know where that came from.
Great idea - I'll do just that! Thanks
Unless there is something hidden in the implementation it sounds like your reliant on clock synchronization to avoid multiple leaders. i.e. If the current leader is responsible for stepping down in absence of a redis connection then it presumably does this based on some clock value which may be be skewed from the redis / following instances. It could still be running when one of the followers takes over leadership. 
Check out [chake](https://gitlab.com/terceiro/chake). It's essentially a wrapper around chef-solo that allows you apply recipes over ssh without having to install chef-client first. I find it easier to use for small-scale projects than chef server/client. 
You might not like this answer but here goes: Stay away from chef. It's an overcomplicated mess that relies on an overcomplicated and insecure by default server setup. It makes everything too hard and makes changing configuration after setup unreasonably difficult. You don't even want to think about the 15 levels of attributes overwriting attributes. Also using chef with vagrant is a nightmare that depends heavily on the setup of your host, breaking the whole point of vagrant. And the chef documentation is a mess. It's unreasonably hard to find correct documentation on the current version. Errors are everywhere. Use Ansible and if you can't use that then use puppet. Both have far less overhead both in terms of required infrastructure, and in terms of the effort required to setup your servers. 
Or use ansible which just uses SSH.
For me thats just the ruby way for uranus
I show that Ansible works better with python (or is it built on python). I don't want to mess things with ruby and pip/virtualenv etc. so I thought that Chef is the most "tied to Ruby" tool for automation. Isn't puppet commercial ?
Of course you'd want to protect it in some way with some kind of auth, to prevent other people you don't know from spamming your actioncable. I guess you'd need to do that if you were pushing just to redis too, except it would probably be with a firewall in that case. But I still think this is the 'right' way to do it, rather than try to reverse engineer ActionCable. 
I've always wondered this about commercial bundles of open source: what happens if people integrate the free tools, and package/distribute that integration?
I can envision scenarios where you're around a 20 or 60 second boundary and you've temporarily got multiple leaders. There's no way around CAP, and even if there were, it wouldn't be based on redis, for sure.
I'm using Rubinius in production. No global lock allows it to go single-process, many threads better than MRI. Behaves like MRI in most other aspects, though, without needing its own special set up compatible gems like JRuby. Plus the devs are really good about pushing through fixes. Using Puma server, which runs best without a GIL. Also using rails-websockets in my own little branch to run the websockets in-process (without Thin). Takes a step out of the whole setup. Puma's also got a decent init.d file that it can install on remote servers, though it needs some modifications to make it work on newer Ubuntu's &amp; with RVM. I should probably do a pull request to fix those issues, if they haven't been fixed already in a newer version...
Duh. That's probably the simple solution I have been overlooking this whole time, thank you!
Yep they are for strings that will never change http://tmm1.net/ruby21-fstrings/. Read about some practical applications here: http://www.sitepoint.com/unraveling-string-key-performance-ruby-2-2/ This is what i would consider a micro optimization. It only helps if we save thousands of allocations. in this case we eliminated hotspots that were generating a few thousand strings per request. 
Additionally, your method for finding all factors for a number can be sped up greatly... There's no need to re-invent the wheel here with a more complex algorithm; just use ruby's standard library: [Prime#prime_division](http://ruby-doc.org/stdlib-1.9.3/libdoc/prime/rdoc/Prime.html#method-i-prime_division) will be significantly more efficient.
yeap ...
Is your rails-websockets branch public? I'm very interested in such a thing.
[Stackoverflow is your friend](http://stackoverflow.com/questions/3398159/all-factors-of-a-given-number)
It's rough around the edges and I'm only maintaining it for myself, but it's working quite well in production so far: https://github.com/Yakrware/websocket-rails The one big catch is that right now it only supports single socket. I haven't gotten it to work with redis to synchronize between different server instances. I also haven't worked on that, so that's not saying too much. Feel free to make PR's to it as well.
You don't need to specify the generator; that's just the *default value*, which you can override if you need to. (And in this case, you have no such need!) A quick [google](https://www.google.co.uk/search?q=ruby+find+all+factors+of+number) gave me this method: require 'prime' def factors_of(number) primes, powers = number.prime_division.transpose exponents = powers.map{|i| (0..i).to_a} divisors = exponents.shift.product(*exponents).map do |powers| primes.zip(powers).map{|prime, power| prime ** power}.inject(:*) end divisors.sort.map{|div| [div, number / div]} end Now, that method does indeed look a bit crazy! You could go through it step-by-step to understand it, or if that's too much effort you could just resort to a [much simpler approach](http://stackoverflow.com/a/20394988/1954610) (which very similar to yours, but still significantly faster.)
Puppet isn't commercial any more than Chef or Ansible, but I think they made a huge mistake by inventing their own language to define configuration. I moved from Puppet to Salt about a year ago and I think I'd rather just use shell scripts than use Puppet again.
Yeah, I saw that explanation. It was too crazy for me to understand so I didn't feel good about using it. Sure, I might get the right answer, but I wouldn't learn anything. I ended up going with an answer from SO that someone else suggested. It was a lot closer to my solution, but it modified the Integer class and was a lot cleaner than my code.
Rails is bigger framework than Sinatra, so it is more complicated. It is not harder to learn than any other framework.
in small its like 0-100, over that is larger
thanks
&gt; Is Rails better to use than Sinatra if I want to make a larger scale application? In terms of transactions per second, no, sinatra is more performant. In terms of number of routes, perhaps cuba or roda would be better (but still not rails). Not everything is about scale. The reason to use rails is that it integrates the most common components of a web application. You can do this with sinatra and a selection of other gems (I have), but you have to do a lot of integration work along the way.
0-100 what? potatoes per sec?
100 models, 100 requests per seconds, 100 dabases?
Well, usually, first you write a lexer to convert a string into a token stream, then you write a parser to build an abstract syntax tree out of the token stream, and then you either make an interpreter to traverse the AST and execute instructions directly, or you write a code generator to convert the AST to some other representation, such as LLVM IR or JavaScript, which is then passed off to *that* language's interpreter or compiler, or maybe you just emit a finished binary for your target OS and CPU architecture. I think that's all, but I've never actually done it, so I probably left out some details.
I agree … but Mercedes ist better as BMW, and this is not a question, it's a fact :)
A better question would be why. What do you think you could add to the lexicon of languages and compilers that doesn't already exist and, more importantly, can't be added to those that exist? If what you are doing is purely for your own educational pursuits, fine, do whatever you want. However, we have to be cognizant of the fact that our industry suffers from a strong sense of NIH (not invented here) and that kind of thinking and wasted work is what keeps us from moving forward more quickly.
Are you talking about a coding language or a domain specific language?
A lot of those styles that optimize for runtime sacrifices readability. If there's no concern about readability, why bother with Ruby at all?
Interested if you did cared benchmark response times against MRI or these are just expectations. I've lost lot of time toying with Rubinius with following setup: nginx -&gt; puma -&gt; rails -&gt; spree &lt;- postgresql and was quite disappointed. Response times were about 30% slower then CRuby 2.1. Same config, same data, warmed-up by lot of requests. Btw. GIL won't affect most IO operations or other code running inside C extensions, aware of freeing the lock.
You don't have to install chef server, you can use https://manage.chef.io/login for free. It's a great way to start it's practically zero configuration for you. you just sign up and download the keys. I use chef for everything, both for vagrant VM's and our entire production environment, everything is configured with chef and reusable. Vagrants are configured on developers machine and managed with chef server so I can see which developer is running an older version and push an upgrade (say for some database configuration). chef-solo is a good option to start as well. Checkout https://github.com/gogobot/devbox and https://github.com/gogobot/devbox/blob/master/site-cookbooks/gogobot-packages/recipes/default.rb as samples of how to manage a Vagrant machine with chef. 
The issue with GIL is with websocket-rails, which is fully running in its own thread, concurrent with other code. I don't have websocket sync over redis working and until I do, it's essential that I be able to scale vertically using only a single server instance. MRI always is only able to take advantage of a single core if you are running a single server instance, even if you're using a threaded server like Puma. I haven't done benchmarks yet. My biggest question is if you were using a single core server to run your rubinius benchmarks or if you were using a multi-core server. That will have a substantial effect on the response times as Puma on Rubinius can legitimately handle concurrent requests while on MRI it behaves more like a nodejs server, thread switching during IO. I'm not going to be the Puma/Rubinius evangelist here: I'm using it for a very specific use case. I also enjoyed having rbx around during the ruby 2.0 switch over when byebug was buggy for me. You'll have to talk to the Rubinius guys (who already posted in this thread) to get them to run some up to date, real world benchmarks.
As long as you follow the LGPL license that Sidekiq is distributed under, it's all good.
Rails is a large jump away from Sinatra. I enjoy Sinatra for it's extreme customization, whilst I also enjoy Rails for being a lot sturdier as a framework. You could always split right down the middle and choose [Padrino](http://www.padrinorb.com/), but whatever you choose will take time to learn. Who knows anyhow, you could just be a 15 year old kid who just graduated from Flatiron. Edit : and for you information, Objective C is one of the most difficult languages to learn (nearly the opposite of ruby)
Thanks for the comprehensive answer. I'd admit it may take the edge in specific cases where lot of independent threads may improve performance and/or reduce memory usage. I did (naively) expected some gains running our rails app on puma. Experimented with various counts of worker instances and threads per instance, tuned GC settings (limits, grow factors etc.). IBM server with dual Xeon 8-core CPUs, more then 16GB RAM available. I don't blame Rubinius, it just didn't worked in my case as a straight replacement. 
Nope. What if it's single page js app? No need for rails whatsoever.
&gt; Is Rails better to use than Sinatra if I want to make a larger scale application? Single page js app is not exactly what I would call "larger scale application". If you are talking about JS app with API backend, it depends on the scale and further integration requirements. If you are talking about simple single page JS without API, you don't need sinatra either.
Yeah, running multiple worker instances is where you make a lot of gains using MRI (as straight-up rbx is a hair slower than MRI). That skirts the GIL by giving you multiple GIL's to work with.
0-100 users 
Don't we already? There is/was backgroundrb, sucker_punch, starling, resque, delayed job, hand-rolled solutions on top of Redis or AMQP, etc. Have you considered why most of them are buggy or not actively developed? I'm guessing that the fact that Sidekiq's author can do it as a full time job has a lot to do with why Sidekiq is well-maintained.
This always turn into a bit of a holy war, but here are my thoughts: Sinatra is a great minimalist framework for advanced developers to use. It's a terribly framework for new or junior developers to use. Sinatra leaves a lot up to the user to handle themselves in order to create something production ready. The issue I see most often with Sinatra apps built by newer developers is that of security. Sinatra leaves many common attack vectors open for you to deal with (or not deal with as is often the case). The litmus test I usually use with people whom ask me if they should use Sinatra or Rails is to ask them to list off the security concerns they need to be aware of and defend against in an Sinatra app that Rails offers reasonable (not perfect of course) defense for out of the box. There is an introduction to some of these issues here: http://blog.fil.vasilak.is/securing-the-sinatra-micro-framework/
Is this powered by the ruby advisories gem?
Yes absolutely. Erlang has cleaner and more terse syntax.
Interesting! Is there a particular syntactic construct or pattern that you find to be especially illustrative of this point?
Users that press F5 once a second or users that sign up and then never return?
Fascinating... This is actually the first time I've heard of Project Euler before. Are there similar sites like this that present software problems/exercises like this?
http://www.codewars.com Has programming exercises in a variety of languages. You complete the exercise in the browser, and it is run against a test suite giving you instant feedback on whether or not you've solved the problem. Once you do solve it, you can see solutions by other people. You have to complete a basic exercise to sign up, though, and not every question is in every language.
I use Rubinius in production along with Puma, and it has worked quite well for the past year, with some very heavy traffic spikes. It's great with Sidekiq too. The only downside with this stack is an apparent [memory leak](https://github.com/puma/puma/issues/342) which requires periodic Puma restarts. Schneems' [Puma Worker Killer](https://github.com/schneems/puma_worker_killer) might help with that, but we haven't tried it yet.
+1 puppet is terribly designed. The only reason they're so dominant is that they have been around for so long.
replace it in reverse. user_string.gsub!(/dogecoin/, 'u') user_string.gsub!(/meme/, 'o') user_string.gsub!(/dank/, 'i') user_string.gsub!(/lmao/, 'e') user_string.gsub!(/ayy/, 'a') print "Your decrypted string is: #{user_string}" in reverse because all instances of `u` would've been replaced by `dogecoin` after `a` was replaced by `ayy`, meaning to decrypt it you have to go backwards in the hierarchical ladder. (For instance, `ye` would turn into `ylmameme` because `e` turns into `y-lmao`, which then also turns the `o` into `y-lma-meme`, so you have to make it back into `y-lmao` to turn it back into `ye`, further it doesn't turn into `y-lm-ayy-m-lm-ayy-lm-ayy-lm-ayy...` by replacing the `a` and `e` from `lmao` and `meme` because the `e` and `a` replaces have already happened in the heirarchy).
I don't use IDE often. If you insist to use IDE, try: 0. Some cloud IDE such as Cloud9 1. Rubymine (local) 2. Aptana (local) 
http://elixir-lang.org/crash-course.html
Strings (like everything else) are immutable in Erlang, yet it's probably the only language that gets accused of being slow (in terms of straight line performance) moreso than Ruby.
It depends on your goal and skill level. I literally learnt Ruby (from puts up) doing the [Matasano Challenge](http://cryptopals.com/) set, but depending on your background, that may be far more maths than you're interested in. You search github for results (including mine) if you don't mind spoilers.
Are you talking about terminating modules and functions with "end"?
thank you
thank you 
What have tried so far?
 word_fiber = Fiber.new do %w{text with fifty words or so}.shuffle.cycle.each{|word| Fiber.yield word} end my_var = word_fiber.resume ... my_var = word_fiber.resume ... EDIT: Naturally it will reuse words once you pulled 50 words out of it ... what else can the poor bastard do? EDIT2: The use of Fiber is a bit unnecessary here but I wanted to use it so badly in one of these questions already. Simpler way would be to just do: words = %w{text with fifty words or so}.shuffle.cycle my_var = words.next .... EDIT3: Something like this could be fun too ... depending on how to interpret your question OP class RandoCycle &lt; Array def initialize(words, ir=3) @words = words.shuffle @ir = @words.size / ir end def next word = @words.pop @words.insert(rand(0..@ir), word) word end end rc = RandoCycle.new(%w{hello world this is a weird question to be honest}) 300.times.map{rc.next}.join(' ')
https://github.com/rubysec/bundler-audit
For x in search_word can for all intents and purposes be translated into 2.times do. Can you see why? It has 2 elements, so it runs your word count block twice, once for each x in search_word. You'll want to iterate over array_of_text, including an equivalence check in the block. 
Forget the loop, simply iterate. array_of_text.each do |word| if search_word.include?(word) then hsh[word] += 1 end end It's best practice to simply avoid things like 'loop do' and 'for' statements. Edit: to comment on your solution so you have more clarity, you don't have a conditional statement in your code that checks the current word against your search words. You are simply looping for each element in search_word. So your #each line is run twice. hsh[word] += 1 is being executed for each iteration, no matter what. Which is why you get result like "car" =&gt; 4. Two instances of "car" in array_of_text times 2 loops.
Assuming you have an array of the 50+ words in `words`: random_word = words.shuffle!.pop Keep in mind #pop and #shuffle! are both destructive methods that will change your `words` array. You have to use #shuffle! rather than the non-destructive version #shuffle, because calling `words.shuffle` will return a new array, and when you #pop from that, `words` will still have all the same original words allowing a slim chance of re-using a word, which you say you don't want to do.
gmail? single page large scale web app since 2004. there are plenty others. facebook. come on...
I don't understand what are we arguing about?
 &gt; matches = array_of_text.select { |word| search_word.include?(word) } =&gt; ["car", "car", "door"] &gt; match_counts = matches.group_by { |x| x }.map { |x, xs| [x, xs.count] } =&gt; [["car", 2], ["door", 1]] &gt; Hash[match_counts] =&gt; {"car"=&gt;2, "door"=&gt;1} ?
You can implement this simply: search_word = ["car", "door"] array_of_text = ["I","have","a","car","and","the","car","door","is","broken"] histogram = Hash.new(0) array_of_text.each { |word| histogram[word] += 1 if search_word.include?(word) } However, this method is not optimal because the Array#include? method will iterate over your search_word array for every word in your array of text. This is O(N*M) performance (worst-case) where N is length of search_word and M is length of array_of_text. A much better way to do this is to use a Set or Hash to implement the search_words: search_word = {"car" =&gt; true, "door" =&gt; true} array_of_text = ["I","have","a","car","and","the","car","door","is","broken"] histogram = Hash.new(0) array_of_text.each { |word| histogram[word] += 1 if search_word[word] } Because Hash lookup is O(1), constant time, the complexity of this search is linear to the length of your text array -- O(M). Keep in mind that this will be a very narrow match. While "car" will match, "Car" will not. You can solve that with Regular expressions or using String#downcase.
\&gt; Because Hash lookup is O(1) \&gt; `search_word = {"car" =&gt; true, "door" =&gt; true}` Wow. Never thought of that. Thanks.
For small arrays a lot of these solutions will work. For large arrays you should try Set. Here's a benchmark. require 'benchmark/ips' require 'set' search_word_set = Set.new ["car", "door"] search_word = ["car", "door"] array_of_text = ["I","have","a","car","and","the","car","door","is","broken"] hsh = Hash.new(0) # SMALL SETS Benchmark.ips do |x| x.report("nested") do search_word.each do |word| array_of_text.each do |txt| hsh[word] += 1 if txt == word end end end x.report("iterate each time") do array_of_text.each do |word| hsh[word] += 1 if search_word.include? word end end x.report("iterate each time with set") do array_of_text.each do |word| hsh[word] += 1 if search_word_set.include? word end end x.compare! end range = [*'0'..'9',*'A'..'Z',*'a'..'z'] l = -&gt; {(0...100).map{ range.sample }.join} search_word_set = Set.new 50.times.map { l.call } search_word = 50.times.map { l.call } array_of_text = ["I","have","a","car","and","the","car","door","is","broken"] hsh = Hash.new(0) # SMALL SETS Benchmark.ips do |x| x.report("nested") do search_word.each do |word| array_of_text.each do |txt| hsh[word] += 1 if txt == word end end end x.report("iterate each time") do array_of_text.each do |word| hsh[word] += 1 if search_word.include? word end end x.report("iterate each time with set") do array_of_text.each do |word| hsh[word] += 1 if search_word_set.include? word end end x.compare! end **Results:** λ ~\Drop\Tyle\pers\proj\ruby\scratch ruby .\counting_hash.rb Calculating ------------------------------------- nested 38.618k i/100ms iterate each time 39.921k i/100ms iterate each time with set 44.743k i/100ms ------------------------------------------------- nested 483.804k (A± 2.5%) i/s - 2.433M iterate each time 492.838k (A± 2.2%) i/s - 2.475M iterate each time with set 546.925k (A± 2.8%) i/s - 2.774M Comparison: iterate each time with set: 546924.7 i/s iterate each time: 492837.8 i/s - 1.11x slower nested: 483803.9 i/s - 1.13x slower cvVZxPbuafGByEpBagnwyjGMF389LZChE47cXvZluNJcKgKzk5bysi1bV1ZRnAmenp1LpcxJMPXqZkgkNkgM04OSIyzOpkmdsXGs Calculating ------------------------------------- nested 2.921k i/100ms iterate each time 5.439k i/100ms iterate each time with set 50.663k i/100ms ------------------------------------------------- nested 30.086k (A± 2.6%) i/s - 151.892k iterate each time 56.420k (A± 4.0%) i/s - 282.828k iterate each time with set 638.318k (A± 2.7%) i/s - 3.192M Comparison: iterate each time with set: 638318.3 i/s iterate each time: 56420.5 i/s - 11.31x slower nested: 30085.7 i/s - 21.22x slower
Facebook is not a SPA.
Amongst other things yes. 
You said you wouldn't call spa large scale, i gave you examples of very much large scale spas.
&gt; With very few exceptions, code written to run on any Perl released since 2000 (38 stable releases of Perl in that time period, eight of them major releases) runs without modification So rather than move forward as a language, they kept everything around? (I'm not a perl guy, but I have to imagine in 28 releases some syntax should have normally been deprecated and removed, looking at other languages)
Perl has been stuck at version 5 for at least 15 years. Perl 6 is a death by committee. So yes shit is still compatible and that's not a good thing
Why not just Array#sample?
SPA without API is not a large project, but gmail does not fit this definition. I said &gt; If you are talking about JS app with API backend, it depends on the scale and further integration requirements. Even then, if you were to implement only JS client (even for gmail) there are arguments for using something other then rails. You could very well have gmail client done as separate project that only uses gmail API and have it as spa done in sinatra. You don't need any rails features for JS client.
More perspective on how mruby is: it doesn't have `require`, but there's a `mrbgem` for it.
Is there a gem for this?
The Linux kernel ships with a style guide checker for patches written in Perl. The kernel is written in C, and developers have no intention of having to install Ruby or whatever else just to check their style guide. They particularly don't want to deal with version inconsistencies. It's preinstalled on every minimal distribution. Moreover, an average CentOS user doesn't have to deal with a repository shipping a version so old no one codes for it any more - you can write Perl now and it's going to work fine on a ten year old deployment. Perl is literally the only platform suitable for that style checker.
wat
Duuuude I'm in Flatiron's software engineering course right now in NYC.
Does it preserve the original behavior of the signal? I recommend against trapping signals, as your code is never guaranteed to run, but when you do trap signals, you should always re-raise the original behavior. https://devcenter.heroku.com/articles/what-happens-to-ruby-apps-when-they-are-restarted
Works for me? $ ruby -v ruby 2.2.2p95 (2015-04-13 revision 50295) [x86_64-darwin14] 2.2.2 /tmp $ cat scratch.rb thread = Thread.new do begin while true sleep 1 end ensure puts "ensure called" end end current_pid = Process.pid signal = "SIGTERM" Process.kill(signal, current_pid) 2.2.2 /tmp $ ruby scratch.rb ensure called Terminated: 15 2.2.2 /tmp $ irb irb(main):001:0&gt; thread = Thread.new do irb(main):002:1* begin irb(main):003:2* while true irb(main):004:3&gt; sleep 1 irb(main):005:3&gt; end irb(main):006:2&gt; ensure irb(main):007:2* puts "ensure called" irb(main):008:2&gt; end irb(main):009:1&gt; end =&gt; #&lt;Thread:0x007fb5e14d6338@(irb):1 run&gt; irb(main):010:0&gt; irb(main):011:0* current_pid = Process.pid =&gt; 92152 irb(main):012:0&gt; signal = "SIGTERM" =&gt; "SIGTERM" irb(main):013:0&gt; Process.kill(signal, current_pid) ensure called Terminated: 15 
&gt; So rather than move forward as a language, they kept everything around? No. There've been a handful of deprecations and removals, but few of them are substantial.
 #each with a block returns the original hash, *not what is evaluated inside the block.* See Hash#each in the docs. Since the #each line is the last line in your method, your method is simply returning the frequencies hash object. #puts sends strings to the console (put string). It is not for converting objects to strings wtihin your application. Rspec does not evaluate what is printed to the console, but rather *it evaluates what the method returns.* If you would like your method to return frequencies as a string simply make this your last line: frequencies.to_s This will have other side effects though if you have other double quoted strings inside your hash. see Hash#to_s in the docs for an example. Also, why are you using define_method? That's a metaprogramming practice (typically used used to dynamically define methods) that doesn't apply here. Also, also: its best practice in ruby to drop empty parenths. Edit: words. 
since the topic is rails vs sinatra it's pretty obvious that i meant SPA with API. examples i've given also indicate SPA with API. you said &gt; If you are talking about JS app with API backend, it depends on the scale and further integration requirements. isn't it a bit of a truism? large scale application does depend on the scale, that's in the definition. bottom line: SPA with API can be large scale. it can be rails. it can be sinatra. all things are possible.
Weird, I wonder if there's some interaction with zsh (i'm using stock bash). Maybe try it with ``` $ /usr/bin/env bash -c "ruby scratch.rb" ``` BTW `ccat` is pretty cool, i've never seen it before. What do you have your pallet set to? `$ ccat --palette`?
what you are saying about #puts makes sense. I'm in a coding bootcamp and right now they are just drilling how to write simple methods. They have informed us that things will start to change and get more complex but for now it's just a practice thing (as I've been told). it's also why we are doing things like writing do/end vs using curly braces and ending each method with (). I think it's more of a drill thing than standard practice. Ninja edit: Thanks. I got everything to work correctly. I was even able to run it in Sinatra with no issues. I had been tearing my hair out for quite a while on what is a pretty easy problem to fix. I just haven't worked much with hashes.
I like doing it this way: def foo(some_number) raise "argument is not integer" unless some_number.is_a? Integer print some_number end 
Wrong sub but I'm not complaining
extend self is a way to make instance methods into class methods... so, you're right about that.
I just wrote an article comparing 4 different non-Rails Ruby frameworks. Maybe it'll be of use to this conversation? I tried to talk about when it might be better to use one over another one. http://blog.codeship.com/a-survey-of-non-rails-frameworks-in-ruby-cuba-sinatra-padrino-lotus
Wow, awesome, love the idea!
 erb :index, :locals =&gt; { 'greeting' =&gt; greeting, 'name' =&gt; name } Curly braces instead of parenthesis
Thank you!
This domain driven thing is brand new to me...as I've had my head in the sand for too long it appears. Is it specific to ruby/ruby on rails? I saved the link &amp; will be boring down into it ... any suggestions on which posts to read first? I've only read a thing or two on oop with ruby specifically, but hail from two decent sized projects in c++ &amp; dabbling in various php frameworks.
I was wondering much the same thing. The author has given a definition and starting point here: http://insights.workshop14.io/2015/07/14/domain-driven-design-introduction.html
Opal is sick but I just can't justify using it along with just about anything, ruby included. I think developers should know JavaScript. Use CoffeeScript if you like (I don't) Opal is an answer to a question no one has asked.
In the section about associations in the top answer, the author seems to have missed that he was done after the original model definitions (except that the self.published method would typically be implemented as a scope in modern Rails). This is even better adherence to the Law of Demeter; the User class doesn't have to know about the published attribute or scope in Post. class User &lt; ActiveRecord::Base has_many :posts end class Post &lt; ActiveRecord::Base belongs_to :user scope :published, -&gt; { where(published: true) } end # usage user = User.first user.posts.published
Microsoft provides a great deal of resources about DDD. They're mostly targeting C# and .NET but the principles and patterns are easy to project on any other OO language. Example: https://msdn.microsoft.com/en-us/magazine/dn342868.aspx
Thank you - I did notice MS was all over these blogs for DDD, with your link I'll read it - as previous I thought it was just MS being MS &amp; ignored it.
Can I write an entire dynamic web application in Ruby?
&gt; if my buisness is international then maybe we shouldn’t be deciding the season on month alone. There are concepts like region (location) and seasons. These would be part of the domain model and likely you would have classes for each.
The intention of that example is that it is perfectly possible for you to be writing a system that is for surf lesson in the south west of england only and a season method is allowed. If your domain is any other domain then it might not be possible to define a simple season method anywhere. Domain driven design people often say well because I don't know your domain I can't tell you what to do. This is admittedly not very helpful but does contain some truth. To try and give some more advice I try to avoid to many inheritance chains. Also value objects should be simple examples are, money, email, name etc. A sophisticated weather module would probably look more like a service. You might give it a location and a date and it could return average temperature, wind speed and precipitation. But just to reiterate one more time the key point about DDD is that you first talk to the client or customers or stakeholders and find out what they need and then work your damndest to implement that be it a trivial value object or sophisticated service. 
I might be missing something but doesn't Opal just "compile" into regular ole JS? If so, why not just do javascript? How are you going to debug opal applications client-side if the code they generate (judging from Opal I'm familiar with) is hard to read on the best of days?
&gt; and find out what they need and then work your damndest to implement that be it a trivial value object or sophisticated service. In my wildest dreams I would have never thought about seasons in the lower hemisphere while programming. Never would have thought to ask the client - who would have never known I need to adjust my database integrity checks for it ... how do programmers learn to ask about this stuff?
Also missing Eldr - a neat one with lots of documentation and examples. In fact, the guy has a book on building the thing. My problem with microframeworks is that every time I get my hands on one (or try to make one of my own) I just end up implementing stuff already present in Rails. I want rendering, I want helpers, I want controller-level stuff and, in fact, I want controllers. For APIs these things would probably be ideal. Cuba is pretty darn fast, but then again if you want pure performance I'm not sure Ruby is the first choice.
I'm not an expert either, but I've learned a whole whole lot from [this brilliant programmer](https://www.youtube.com/results?search_query=sandi+metz&amp;page=&amp;utm_source=opensearch).
Volt
Ah, of course! Thank you so much! I knew I had to be missing something.
Such an exciting future for Volt!
It does compile to JS, but there are good reasons to use it anyways. As /u/cocoabean mentioned, source maps are really useful for debugging. Also, for a very good explanation of the reduced complexity, check out this RubyConf talk from Ryan Stout (skip to 9:39). https://youtu.be/7i6AL7Walc4?t=9m39s
Goliath is pretty neat and on part with Nodejs perfomance wise. It's just that nobody gives a fuck about anything other than Rails in the ruby community. So good stuff don't develop a good ecosystem.
These are all evil. Rails is forever. Do not stray from the path. :trollface:
I was talking just yesterday about DDD and the comment I got was &gt; Talking to the customer and splitting up your code is just common sense. It all seemed like great ideas, but nothing very... revolutionary...? It is common sense but that doesn't mean its not worth talking about. When working with clients I insist that they are as responsive to emails as they expect me to be so that when I think of something to ask I don't have to wait till our next meeting and assume in the meantime but that I can start getting there input straight away
Exactly. To all those saying "but I have to add stuff that's already in Rails anyway", that's true — but nobody ever had to add *all* of what's bolted onto various bits of Rails.
*People* do, the Great DHH Marketing Machine&amp;trade; expends great effort and treasure to ensure that those who aren't neck-deep in it believe The Message. Those who *do* realise that they're up to their eyeballs in the radioactively toxic sludge left over from over-exuberant recreation of a single 2006-era app are handily silenced by managers enforcing the primacy of sunk costs. Dogmatic religious extremism is at the root of many of the world's ills. Rails is little different.
You forgot *Ignorance is Strength.*
One action per class for example.
Goliath is ok but it's kinda barebones. Though this is manageable with a couple of simple helpers. I think the bigger problem is that it relies on what seems to be a poorly maintained library (EM). HTTP parts seem to be ok but there's some weird shit inside last time I checked.
Thing is Hello, world benchmark is pretty much irrelevant. Real applications include DB access, external API access, parsing, complex rendering and serialization.
I know. It has a more powerful router and everything else is a plugin, which is lovely. I also love the fact an app instance is frozen and it doesn't pollute objects with many methods.
Presumably if you just wanted to serve "Hello World" you'd do so via nginx; any website using an interpreter is going to be doing some more interesting things than that, and the base frameworks will have executed many statements preparing them for that function. It's probably not a great benchmark for concluding anything other than which framework does the least before passing control to you (particularly if you need to bolt that stuff onto the 'higher performing' frameworks to make them useful).
&gt; implicit rendering and so on I'm not defending rails , i'm not a fan but if you're talking about models that know how to render themselves then there is nothing really magic about it. AFAIK models implement a specific behavior for that feature to be possible. You can't automatically render everything.
In theory DDD is possible with Rails and active record. In practice the repository pattern and active record are totally redundant. &gt; Design Overkill That's exactly what i'm saying . And for most rails projects it is. For large projects , a microservice architecture where a specific service is only concerned with DB persistance is a better option. A fundamental problem with Rails is that it isn't built with dependency injection in mind, it relies on Ruby mixins and monkey patching. It doesn't sit well with DDD that relies on dependency injection to decouple domains and the database. (ie to create a true DB free domain model, the data access layer needs to be injected in the repositories managing business objects persistance ). Rails users also forget that Rails was invented because dependency injection Java style led to verbose code and complicated architectures (J2E, early Spring , Struts , XML config everywhere). It's funny how Rails devs are now trying to go back to what Rails intended to change. Was Rails wrong at first place and was that decoupling necessary afer all ? In PHP land, 2 of the most important frameworks are Zend and Symfony. Both were heavily inspired by Rails before reverting to Java style inversion of control in their next version , precisely to allow clean DDD, and total separation of concerns between the business logic layer and the data access layer. I'm not saying one way is better than the other. Just that the Rails way is fundamentally incompatible with "pure" DDD, given its architecture not relying on IoC but on specific Ruby features.
Well, with many ways to reuse code in Ruby it's not such a big a deal but still.
FYI: I've put together an [awesome web frameworks page](https://github.com/planetruby/awesome-webframeworks) incl. Cuba, Sinatra, Padrino, Lotus, Roda, New York New York, Nancy, Volt, and many more. Cheers.
Just a guess, but maybe opening the file with "append" instead of "write" privileges might solve it.
Whats with the policing of speech going on seemingly everywhere?
So contrary to the title, your real question is with reading the file in chunks, not writing it. I'm not certain if you can do that with the open-uri library you are using, but probably. open-uri is somewhat poorly documented, but theoretically returns an [IO](http://ruby-doc.org/core-2.2.2/IO.html) object. So the problem is how to read an IO object in chunks. It definitely ought to be possible, but I haven't done it before and don't know the API. Writing in chunks in straighforward, you can just continually call `f.print chunk`, before `f.close` when you're done, on your open filehandle. If somehow there's no good way to do it with the IO object returned by open-uri (perhaps open-uri insists on reading the whole thing into memory first), there are other libraries you can use to read from remote URLs, some of which will definitely allow reading in chunks. But I think open-uri probably ought to work. Sorry no code example, but hopefully this gives you a framework for research and further questions. 
&gt; Does Ruby's standard library provide a way to do this? Yes, see the documentation for `Net::Http` response streaming, the example code does exactly what your asking for: http://ruby-doc.org/stdlib-2.2.2/libdoc/net/http/rdoc/Net/HTTP.html#class-Net::HTTP-label-Streaming+Response+Bodies 
I recommend you to not run your program through sublime. Write your program, save it as a file and use installed interpreter from command line (ruby my_file.rb). This way you will learn how to use ruby in a "normal" way (editors does change, command line not) and it will give you opportunity to familiarize yourself with ruby ecosystem (for example how to use rubygems, bundler, rake and other tools).
`IO#read` and `IO.write` both take an optional `length` parameter: File.open "source", "r" do |source| File.open "dest", "w" do |dest| until source.eof? chunk = source.read 1024 dest.write chunk end end end
This seems like a great answer to help solve https://www.reddit.com/r/dailyprogrammer/comments/3f9o7k/20150731_challenge_225_intermediate_diagonal_maze/ . I'll add it to my daily programmer gem repertoire.
Happy to be disagreed with here. But my thinking is that as long as dependencies all go one way that is all I need. My delivery mechanism (rails sinatra) depends on the interactors (normally coded in and not dependency injected. It means I can reuse the domain and change the delivery mechanism. But I can't reuse the rails code and change the domain. But once all business logic is separated the delivery mechanism is simple. So I cant swap it with one a really quick change. but I know for sure what I need to change and its not that hard. Same with the tie to my ORM. The repository will need some painful changes to change the ORM but I know every other bit is saved from needed to be changed
Thank you, that was the next lesson! I've actually switched over to Ubuntu after getting the wifi working on my VM, just need to decide on a text editor and I'm off :D
Here's another gem that makes use of AsciiTree. It defines some trees in its tests to check the expected behaviour. It's a good use case for it: https://github.com/whichdigital/tree_delta/blob/master/spec/black_box/add_and_delete_nodes_spec.rb
&gt; just need to decide on a text editor and I'm off :D I'd still recommend Sublime Text to start, it runs on win, osx and linux. I also think you're best off in a linux VM, windows is rather wonky to work with for Ruby development. 
Yeah, that was the general consensus I read online. I dabbled around with Vim for an hour or so earlier but couldn't really get the hang of it. I settled with Sublime, my dev environment is all set up now and I'm ready to crack on with my learning tomorrow! When I've completed my initial work, I think I'm going to complete Codecademy's command line course too.
&gt; They currently recommend Puma, but it suffers with unfixed memory leakage with recent CRuby versions 2.1 and 2.2 and workers need to be restarted after they get out of control. Could you clarify this? I'm not aware of any memory leaks with Puma on 2.1 or 2.2. Both 2.1 and 2.2 have generational GC which you may need to adjust the tuning on for your particular workload. This could appear to be leaks, but it isn't. 
1. Watch this video: https://www.youtube.com/watch?v=Dji9ALCgfpM 2. Best Ruby IDE is RubyMine, especially for learning (unfortunately there's no community edition as with PyCharm or IDEA, so install 30-day trial for now...). 3. Go to hackerrank.com and start solving challenges. 4. PROFIT!?
You actually don't need to manually implement reading in chunks, Ruby has a (lesser-known) method just for that: File.open(dest, 'w') { |file| IO.copy_stream(open(URI), file) } This will do the transfer in the most performant way (since it's implemented in C). This works with any IO object, so StringIO as well. What is nice is that this also works with file paths, so you can write it in an even shorter way: IO.copy_stream(open(URI), dest) (Learned this from RubyTapas :))
Thank you
Fibers suck. Don't use 'em. * \* I trailblazed using Fibers for concurrency before Goliath existed. http://www.mikeperham.com/2010/04/03/introducing-phat-an-asynchronous-rails-app/
&gt; Let me be perfectly clear about where I stand on em-synchrony and Fibered EM today, after spending a year working with the technology: &gt; It's one giant hack and should not be used. Why is Mike Perham saying that ? what is wrong that cannot be fixed ? 
Snark is the last refuge of the petulant.
Yes.
Threads are probably not even the best for performance in ruby because of the GIL - at least with MRI Ruby. Spawning separate processes might be the only way to fully take advantage of multi-core modern day systems. I learned a ton by reading http://www.toptal.com/ruby/ruby-concurrency-and-parallelism-a-practical-primer on this whole topic.
It's a hackathon/programming competition - you/your team have 48 hours to create a rails app from scratch.
Most of Ruby coders think that Ruby = Rails. Explaining them the opposite is hopeless.
Right, not found a notice about integrated revproxy on phussionpassenger.com site. Only about free version is limited to only 1 thread per worker.
Vagrant fixes this pretty neatly does it not?
See [issue #342](https://github.com/puma/puma/issues/342) . I've tested the deployment and it seemed I'm not affected by this, but by an unclear reason one of the workers (4 workers/16 threads) suddenly got out of control a grow infinitely. There is also a talk about on Heroku discussions. Still not solved.
Thanks for clarification, fixed in the OP.
I don't get it. `rbenv` and bin stubs solve 85% of this and is setting up the test db that hard? You have a section on it in the project readme...right?
Why does the problem exist in the first place, though? It's always easy to add tools to solve problems caused by other tools, but then your stack grows more complicated.
&gt; But the whole Rails workflow, what with the git commits and the bundle execs and Capistrano deploys, while elegant (I guess), is fairly fragile. None of that is Rails specific, nor is it an uncommon workflow on non-rails Ruby projects...
It tends to not be after a couple of years of inactivity. Consider the noise created by something as trivial as a new OSX version released! Then also consider different versions of say Postgres, Redis, Selenium, what have you... or OSX vs Linux.
Every Ruby and Ruby-on-Rails dev environment should require just 4 steps: 1. git clone 2. bundle install 3. rake db:setup 4. rake (which runs all your tests/specs) Follow that convention in your projects and you'll be fine, 98% of the time. If your project can't be set up and verified in four steps, then take the time now to fix it. I don't feel much empathy for Grimm. He's not being too professional with his configuration.
This is where he begins to go off the rails: &gt; The hacker edits the project’s Gemfile to specify the exact patch version of Ruby 2.1 currently installed. But this is where he really blows it: &gt; the port number shown in the error message is wrong... Never mess with config like database ports. No need to make your app a special snowflake. You're setting yourself up for tricky configuration. ESPECIALLY in your dev environment. 
I think the missed component here is that when you've been working in another language for a while, and you come back to Rails, you forget the simply stuff. It takes a while for the lizard mind to remember how you used to work with it. I've found this to be true coming back from node, where gulp/yo/grunt/bower rule the land, or from GoLang, where Makefiles are the norm, and vice versa. This is normal. It happens with any switch. It's just the frustration level that needed venting I'm sure.
Encrypt it? As long as it runs, someone can just load up a debugger and step through the code.
Neither of the `has_many` examples are good tests. The first, using `reflect_on_association` means you're testing an implementation detail rather than the external behaviour. The second, using shoulda-matchers version isn't any better – it's basically a mirror image of the implementation code, so you lose out on the 'double bookkeeping' benefit that proper tests would give. A more useful approach, without shoulda-matchers, would be something like: it "can store multiple phone numbers" do contact = Contact.new contact.phones &lt;&lt; [phone_1, phone_2] contact.save result = Contact.last.phones expect(result).to eq([phone_1, phone_2]) end it "destroys each associated phone number when the contact is destroyed" do # ... end This would allow for the implementation to refactored without breaking the tests. I think many of the shoulda-matchers matchers are useful for avoiding overly-repetitive test code, but there are some which takes things too far.
Of course, but let's just not get into this debate over and over: we know already that there is no complete protection if one is really motivated and knows what they need to know. Obfuscation would make things just a little bit harder for non experts, and that's what I am after.
6 months you say? How about coming back after 2 years to work on an extension where the Ruby C api has changed! Functions missing, GC updates and even the development environment must be adjusted for the project to compile (it's a Windows extension for Ruby; you probably know how bad Ruby support is on Windows, let alone developing gems with extensions)
Adding `require 'debug'` to the first line of an obfuscated `.rb` file isn't that hard ;)
Protips: 1. Never specify the version of `rake` in the `Gemfile`. Any version will do. 2. Never specify the required ruby version in the `Gemfile`. Configure the ruby version via heroku and use a `.ruby-version` in development. 3. Add `gem: --no-rdoc --no-ri --env-shebang` to your `~/.gemrc`. This will force rubygems to emit `#!/usr/bin/env ruby` instead of `#!/absolute/path/to/ruby-2.1.1`. 4. Keep a `.env` file of `export`'ed environment variables and explicitly `source` it when entering a project. Also consider using the dotenv gem. 5. Write and test a `bin/setup` script. It should install necessary dependencies, generate any missing configuration files, create and migrate the database. This has kept my blood pressure low.
You can try RubyEncoder. It costs money. Vagrant uses it to obfuscate their VMWare plugin. I heard Github Enterprise uses it too.
Better yet, take the time to make your app do the required setup for `rake db:setup`. That works out of the box with rails, and it's not hard to keep it working as new db changes are made. Conform to the convention and little documentation is necessary. 
https://github.com/capistrano/sshkit/blob/master/sshkit.gemspec#L20
Exactly. And why have a local env configuration file just for test? That defeats the whole point of the dotenv idea, just use the default rails test configuration file instead. Also how did he get by without Nokogiri 6 months ago? 
Yeah but there's "seeing the code" and "seeing readable code". Variables named oO00O and o00OO lead to code that isn't usefully readable.
1.1. vagrant up &amp;&amp; vagrant ssh 1.2. cd /vagrant
Also very acceptable, and what I use for my complex projects. My `vagrant up` shell recipe ends by running the specs w/in the VM. Essentially, it proves to me that it's set things up perfectly.
He seems to have deleted the Ruby version he had last been using, or is doing dev on a new machine. But he was begging for trouble by _changing the Gemfile_ to use a newer Ruby — instead of installing the older, known-working Ruby version. Here, though, this particular risky step didn't bite him. But it indicates he's not playing it safe. 
&gt; Why do I need the parent: :voice? If I remove that and proceed with my tests, it returns a NameError: uninitialized constant InvalidVoice error. Factory Girl determines the name of the model from the name of the factory. e.g. `factory :voice` will result in FG looking for a `Voice` model. `factory :invalid_voice` will result in FG looking for an `InvalidVoice` model, which doesn't exist, hence the error. Your getting around this by explicitly setting `parent:` but there are better ways to do this, one is nesting factories, i.e. put the `:invalid_voice` factory inside the `:voice` factory. This just sets the `parent` automatically for you. But, personally I prefer traits for this type of thing: FactoryGirl.define do factory :voice do title "MyString" opinion "MyText" trait :without_title do title nil end # You can define factories like this or just call `create(:voice, :without_title)` factory :invalid_voice, traits: [:without_title] end end 
This is how we lost Why. 
I see, didn't know that FG will look for models. thanks for the lesson learned!
I don't know. And there might be more unknowns that I don't know about yet.
4 steps? Perhaps, but not necessarily exactly those four. Big projects often accrue complexities that will prompt the creation of a custom setup task that in turn probably call rake db:setup.
That doesn't seems very RESTful, having a `GET` action that also performs a `DELETE`! ...But if that's what you really want to do, you could always use an `after_action` callback?
thanks! It seems I had stopped reading at 'further reading' because I thought they were done :)
&gt;If you want to learn more about why public - private is important It's really simple. Private methods are implementation details and can be changed at any time. Public methods are the public api that you expose to clients. You should try to expose only what is necessary and keep the public api simple and clean.
... Or more to the point.... Why?!?! I'd find [1,2].map {|x| x+2} **much** easier to read!! Nevertheless, purely from a "just for fun" perspective, I do think OP's method is interesting.
One additional tip: if you have any `protected` methods, they should sit between the `public` and `private` sections to indicate their relative visibility.
Partial application is when you supply some of the parameters to a function and get a function back that is ready to take the rest of the parameters. As you can see, `Symbol#with` returns a lambda with the parameters you had passed in already applied, ready to take in more when map calls it for each element in the array.
I haven't seen anyone claim that you can't determine the type of an object at runtime. That would be pretty silly, since obviously you can. What I have seen are claims that Ruby is not *statically* typechecked (at *compile-time*), which is true.
My co-worker and I created this out of a want to automatically log function parameters, since we would wind up writing these log lines manually in many classes, most notably in sidekiq jobs. Hopefully some others find it useful.
In context, these are microsecond differences in a render cycle that is probably 6 orders of magnitude slower. You would have to do about a million of these for it to have a noticeable effect. *Don't. Worry. About. It.*
Just attempted the bonus solution too; Extend your Deaf Grandma program: What if grandma doesn't want you to leave? When you shout BYE, she could pretend not to hear you. Change your previous program so that you have to shout BYE three times in a row. Make sure to test your program: if you shout BYE three times, but not in a row, you should still be talking to grandma. http://prntscr.com/849yrm Seems to require 5 BYE's to end, any comments on this one?
Nevermind, I thought the `log(:success) 'Customer Signup Complete!'` stuff was real. Of course it's just a syntax error, the docs should read `log(:success, 'Customer Signup Complete!')`. Metaprogramming is necessary, but it can be cleaner: def method_params params_method = 'method(__method__).parameters' @current_binding.eval(params_method).inject({}) do |a, param| value = @current_binding.eval(param.last.to_s) a[param.last.to_s] = value if value a end end To: def method_params params_method = 'method(__method__).parameters' @current_binding.eval(params_method).map do |_, param| [param.to_s, @current_binding.local_variable_get(param)] end.to_h end Again, as far as I can tell there is no need to output a hash here anyway.
The backtrace indicates you are using Ruby 2.0.0 with gems built for 2.2.1 No idea how you managed that, but you should probably just wipe out RVM completely and set it up again from scratch. 
Google desk check programming. It's a method of human checking your code to ensure its working right. You write out each thing that happens and make tables of your variables and how they change on paper. It really helps you see where you make mistakes.
Ah yeah there are those errors in the README. Thanks for the suggested refactors, we'll definitely be changing it. :)
Thank you for providing this link it helped me out so much.
Your code ignores the case where the user responds with a mixed case string. Instead of using an elsif to check if the given response is all caps, I would do something like: &gt;if response == response.upcase &gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;puts "not since #{1930+rand(50)}" &gt;else &gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; puts "speak up" &gt;end Edit: reddit formatting indentation shenanigans
Maybe contributing to FactoryGirl would've been a good idea :S
Starred!
O good point. Only thing is, three of those gems are in production products I've made, and I know for a fact 1 of them is in quite a few products. It takes a genius and friendly Ruby developer like you to look at a structure and call it pollution. Thanks for your "wisdom" and enjoy ending up in Microsoft with your winning personality :D
:) I was surprised by that as well. The most brought up alternative was to write private methods directly bellow the public methods so they are in kind of context chunks. Please have a look on the section "Context indented methods" of the article as an example. 
Thanks! Just downloaded [Sonic Pi](http://sonic-pi.net/) and it is soooooo much fun.
Been solving similar demand in the past, but no satisfying solution was found. One commercial solution required distribution of modified runtime along with the encrypted code and even then, there was a simple way how to retrieve the original source back. So far the best "protection" from copy&amp;paste of your code is comments stripping, identifiers obfuscation and when possible distribute raw VM's instruction sequence with a trivial loader instead of sources. Be aware due to highly dynamic nature of Ruby it is almost impossible to do it in practice, as object identifiers can be set until during a runtime and all possible states can't be resolved beforehand. Automated obfuscation requires use of "restriced" Ruby in a module, ie. without use of metaprogramming techniques, else manual identifiers mangling is involved.
I wrote an overview of the current features in opal-irb, because it was apparent that most people didn't know about them here http://funkworks.blogspot.com/2015/08/an-overview-of-opal-irbs-features.html - takes a little time to load all the embedded iframes w/live examples
What CSS issues did you have? I might incorporate your changes back into the project
Really? Heroku uses erlang for its routing, that team measures their performance in nanoseconds. I've always thought of erlang as pretty fast. 
Its extraordinarily low latency was a major design goal relating to its use in telecoms. It's also concurrent in a way that's just embarrassing to Node.JS fans that make an issue of concurrency. So it's certainly "fast" in the way you described. That said, in micro-benchmarks measuring straight line performance, it's not generally at the top.
To view Sidebar on Alien Blue: http://i.imgur.com/LHykgPc.png http://i.imgur.com/os0ZZNJ.png
What? Alien blue has sidebar functionality.
No worries, I definitely didn't want to come across as critical of Erlang, in fact I chose it for my most recent project. And I was actually accused of faking the output because it's so fast in my use case :) That said, I made a significant optimisation by replacing jsx (which, although instinct based on the name tells me relates to ReactJS, is actually a pure Erlang JSON parser) with Jiffy (which is written in C). "Immutability" doesn't make it great for string parsing, as an example. 
Am i taking crazy pills? This is just ripping off Metaprogramming Ruby 2. The examples are slightly different, and the diagrams are just redrawn, and the writing style is nearly identical. Except, I sincerely suspect Paolo didn't write this post.
It's ironic. One of the principle "advantages" of JS I keep hearing about is how many more people are pushing crap to npm. It's interesting seeing the differing views groups have on things.
Don't be lazy dude, it's much more fun to watch than to be told.
I had to stop reading before I even got into the main content of the article, at the `to_alphanumeric` example. If you ever write a `to_` method that isn't used for explicit type conversion, you should be beaten over the head with a copy of the Pickaxe Book.
Good example of relatively useless self-promotion.
I have left reddit for [Voat](https://voat.co/) due to years of admin/mod abuse and preferential treatment for certain subreddits and users holding certain political and ideological views. This account was over five years old, and this site one of my favorites. It has officially started bringing more negativity than positivity into my life. As an act of protest, I have chosen to redact all the comments I've ever made on reddit, overwriting them with this message. If you would like to do the same, install [TamperMonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo) for Chrome, [GreaseMonkey](https://addons.mozilla.org/en-us/firefox/addon/greasemonkey/) for Firefox, [NinjaKit](https://github.com/os0x/NinjaKit) for Safari, [Violent Monkey](https://addons.opera.com/en/extensions/details/violent-monkey/) for Opera, or [AdGuard](http://adguard.com/) for Internet Explorer (in Advanced Mode), then add [this GreaseMonkey script](https://greasyfork.org/en/scripts/10905-reddit-overwrite-extended). Finally, click on your username at the top right corner of reddit, click on comments, and click on the new OVERWRITE button at the top of the page. You may need to scroll down to multiple comment pages if you have commented a lot. After doing all of the above, you are welcome to join me on [Voat](https://voat.co/)! So long, and thanks for all the fish!
I instead just remove `Bundler.require` from config/application.rb ([post](http://myronmars.to/n/dev-blog/2012/12/5-reasons-to-avoid-bundler-require)), and load each gem manually. However, I noticed through my experience that a lot of my gems have a Railtie, so you have to require them in config/application.rb, in other words you still have to require them at startup. But when you have a lot of non-Rails gems, you can get a significant boot time boost. I totally agree with you about Spring, I was psyched when it first came out, but was pretty dissapointed with its constant instability. And the reason for that is that hacks are never stable, which is what Spring is.
http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_12-4/124_ssh.html https://tools.ietf.org/html/rfc4253 and http://ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/TCPServer.html you might be interested in making your own kind of protocol with something like telnet
It's... different. That's fair enough, though.
Good advise, a nice side effect is that if you are strict about requiring libraries in the files which uses them then you can locate all places a gem is used should you question if it can be removed from Gemfile.
You could just do it with [sockets](http://ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/Socket.html). I wrote an IRC bot with sockets. It wasn't hard at all.
config/environments/test.rb can contain config.eager_load = true which will eager load all your code in tests before running it, which will trigger requiring those gems anyway. You can disable it, but then you won't be testing the code loaded in the same order as rails eager loads in production but in the order the classes are autoloaded by name in your tests. The article says that it gives you faster TDD but doesn't prove it with a reproducible benchmark.
 file.each_line.each_with_index.map { |line, i| "Line #{ i }: #{ line }" }[3, 10] Enumerable has `#with_index`, so you don't need to use `#each_with_index` if you already have an enumerator like the one you have from `each_line`. file.each_line.with_index.map { |line, i| "Line #{ i }: #{ line }" }[3, 10]
&gt; Assuming you've renamed all variables before crypting it. What part in "A nice way to obfuscate Ruby code?" you don't get?
&gt; identifiers obfuscation I was looking for at least an automated way (a gem?) to do that, but couldn't find any... &gt; distribute raw VM's instruction sequence with a trivial loader instead of sources. Could you elaborate just a bit more on how to do this? Thanks! 
Yes I knew about RubyEncoder, but as you said, it costs money. It's a bit sad that this has been the only available solution (at least to some extent) for kinda ages now...
I'm not sure who popularized the term eigenclass, but i really wish they hadn't. The idea is exotic enough, but it seems that other programmers can easily grasp the fact when you tell them that every object (and every class) has a Singleton class. When you throw around odd terms like 'eigen', they'll put up wtf detectors.
Awesome extract, thanks. I just read the second edition of that book. Incredibly good, I read it in two sittings because i couldn't put it down.
His "making class methods private" example is something we see a lot of, but I've found it easier to teach new developers how to do that a different way. This is more explicit/less "magical" and simply extends what a greener-than-grass Rubyist already probably knows: class Foo # Internal methods neither affecting nor depending on state module Internals def self.speak 'Hello' end end private_constant :Internals def hello Internals.speak end end Foo::Internals.speak # =&gt; NameError: private constant Foo::Internals referenced Foo.new.hello # =&gt; "Hello" The biggest new concept in *that* mess is that yes, Ruby can have private constants — and why not?
What I mind about slow tests is that, if I find a workflow where I don't have to wait for them, and at some point I get a notification of a test failing, I'm already doing something else. I feel like I would need to make big mental switches to maintain that workflow. I want to work on something, finish it, and then work on something else. Waiting for slow tests are making these boundaries blurry.
&gt; &gt; RECIPE_TIME = 12.freeze &gt; cooking_time = gets.chomp.to_i &gt; puts 'You are ready' if RECIPE_TIME = cooking_time Is that kinda what you are looking for?
Hmm, not quite? Say cooking_time as given by user is 10, and the Recipe_time is 8. As we bake the cookie, cooking_time -= 1, and once it hits 2 i.e. reached recipe_time, the cookies will be ready and user prompted to take them out or not? If not, cooking_time will continue to decrease which will result in the cookies being burnt.
I don't quite follow, you say you don't write tests first, but you use the 'red green loop'? The 'red' part of that loop specifically means to write a failing test first. http://www.jamesshore.com/Blog/Red-Green-Refactor.html
At first when I tried to learn Rails I couldn't because I didn't get the syntax and how all those things could possibly work. It was much easier to go with AWDWR after reading http://ruby-doc.com/docs/ProgrammingRuby/ . I also enjoyed very much https://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming to understand the metaprogramming concepts highly used by rails internals.
 class PageObjects::Common::UserSection::ClassName # stuff end The only downside is, all of the parent modules need to already exist before you call this. 
Wouldn't that be impossible to handle? you always need to make sure the module was created before, and when changing files, you could easily break it?
Is there a chance OP will be able to implement this in a secure way? Why do gerrit, Gitlab, gitolite are all using openssh as a building block instead of reimplementing ssh protocol on heir own?
It depends on how you structure your project. Often if you have a directory /foo somewhere in your code, it is common to create a file foo.rb in the same directory that contains foo, that defines module Foo and loads the files in /foo. But that's a design decision, not one enforced by the language. 
Beginning Ruby did it for me. I also struggled with understanding syntax in Rails books before reading this book. I haven't read the others
Can we stop monkey patching primitives to build esoteric DSLs? Thanks.
I think of things like "Interactors" as being useful for teams that don't feel comfortable establishing boundaries beyond what the framework gives them. In essence, Interactors are a framework extension for something I think ought to be out of scope for the framework. Need a DCI style approach? Like Nike says, just do it.
Watch this video before you make any bad Rails decisions. https://www.youtube.com/watch?v=WpkDN78P884&amp;index=2&amp;list=PLWg3XdBs49uvCIbUFSaU77F0vxlAvhQoD
You may want to look at the Ruby/Rails learning path here: [Teach yourself web development from scratch with Ruby, Python or C#](http://www.nicoschuele.com/posts/teach-yourself-web-development-from-scratch-with-ruby-python-or-c).
&gt; I was looking for at least an automated way (a gem?) to do that, but couldn't find any... Neither I did. We are using an in-house tool, unfortunately may not be published. &gt; Could you elaborate just a bit more on how to do this? Thanks! See [official docs](http://ruby-doc.org/core-2.2.2/RubyVM/InstructionSequence.html). Build instruction sequence for source code, convert to an array, serialize with `Marshall.dump`. Opposite process involves deserializing with `Marshall.load`, rebuild instr. sequence with `RubyVM::InstructionSequence.load` (need to be enabled) then execute with its `#eval` method.
I did something similar but without dynamic allocation to speed up test suite in our project. I created gem for that, here is my blog post about it http://blog.lunarlogic.io/2014/parallel-your-specs-and-dont-waste-time/ The knapsack gem works with rspec, cucumber and minitest.
I find Ruby much harder to get into than Python, mainly because Python documentation is awesome, and Ruby documentation sucks.
The Well-Grounded Rubyist is a great book. For pure Ruby, I like The Well Grounded Rubyist -&gt; Eloquent Ruby and then using the Pickaxe as a reference along the way.
The Well-Grounded Rubyist is good for start. Don't start with Eloquent Ruby, it assumes that you already familiar with language and provides best practices and hints, so I think you'll be overwhelmed by that. Rails 4 Test Prescriptions is also pretty good to continue with Rails after Hartl. 
I would suggest anything from Pragmatic Bookshelf (publisher). They are written very well. It's also the first series to have a Matz approved Ruby book. They have good Rails books. I would suggest going through the Getting Started on Rails Guides. That entire site has all you need for most Rails applications. Complicated concepts can be solved from blog posts others make.
In https://github.com/bennacer860/conway_s_game_of_life/blob/master/lib/world.rb I'd abstract out the specific configurations of the rules to a separate hash so that it's easier to read and so you can tweak those rules later on if you want. world.rb should be given a hash of configurations and run with that instead of hard-coding them imo.
this is awesome. I really appreciate your time for the feedback. i am gonna find another way to seed the data.
I'll say "The Well-Grounded Rubyist" is quite good for beginners
Cool, glad it was useful! 
There's a pattern I use very often, which you might like. It's in a similar vein to /u/r_notfound's advice. def number_of_alive_cells_around(row,column) directions = [[-1, -1], [-1, 0], [-1, 1], [ 0, -1], [ 0, 1], [ 1, -1], [ 1, 0], [ 1, 1]] directions.count do |dr, dc| alive?(row + dr, column + dc) end end Directions are data, just iterate through them and test each direction. You could easily modify this to only include the 4 cardinal directions instead, without changing any non-data code. Or say you change `alive?` to take an array instead of 2 numbers, that would only take one change here instead of 8 of the same change.
I disagree with /u/realnti on the usefulness of abstraction, particularly as your app diverges from the circa-2006-Basecamp ideal that Rails is patterned after. I would, however, point out that there are [several](https://github.com/markets/awesome-ruby#abstraction) good off-the-shelf Gems that make this even easier, as well as an another architectural feature which you may prefer: form objects. I found [this blog post](http://insights.workshop14.io/2015/07/23/application-border-control-with-ruby-form-objects.html) from Workshop 14 and [this one](http://codingwithaxe.com/my-take-on-form-objects/) by Janis Miezitis to be excellent discussions, as was [Railscast #416](http://railscasts.com/episodes/416-form-objects). You really don't want to fall into the trap of having every problem look like a nail because all you have is a hammer… that happens to be [lousy at pounding in nails](http://img.photobucket.com/albums/v80/harnett65/Album%208/hammer22.jpg) anyway.
Well-Grounded Rubyist is good. You should also look at Learn Ruby the Hard Way.
First understand that the GIL is unique to the official Ruby implementation MRI/YARV. There are other Ruby interpreters that use different threading models. With YARV, Ruby's Threads are implemented as native OS threads. The trouble with this is that (practically) every Ruby function shares some state: the Ruby VM itself. A bunch of native OS threads all sharing state is a recipe for trouble since you need to worry about that state being modified simultaneously from different contexts. The simple solution for this was the GIL (or GVL for Global VM Lock), which is basically a mutex on the whole VM to ensure that it's only accessed from one context at a time. I cover this a bit in the Threads section of my book [The Definitive Guide to Ruby's C API](http://silverhammermba.github.io/emberb/c/#threading). If you really want to see how the GVL is implemented, I recommend reading the source code itself. A good place to start is the `call_without_gvl` function in [thread.c](https://github.com/ruby/ruby/blob/trunk/thread.c#L1287).
Safest not to use the default value in the first place.
@banister I want to compile ruby without GIL but i need to learn GIL internal, how it works 
You should adopt 2-space tabs first, lots of people will stop reading it just for that. Get rid of those global variables.
&gt; In this case, we assign a new value for the default key by merely accessing it, and this works as expected. &gt; &gt; However, this might not be a very wise idea, modifying a hash when someone tries to read a value seem like a pretty unexpected behaviour and might confuse your fellow developers, or future you. So, don't use it that way. (An aside, I don't buy the argument, especially because this is fairly close to Ruby101.) Instead of: hash = Hash.new { |hash, key| hash[key] = [] } Just do: hash = Hash.new { [] } However, you'll have to use some form of assignment to initialize the h[:foo]. For example you won't be able to do the following. hash[:foo] &lt;&lt; 'baz' Without first doing this: hash[:foo] += ['bar'] hash[:foo] &lt;&lt; 'baz'
Note that the gotcha only really applies to mutable objects. It generally works fine to do `h = Hash.new(0)`, for instance.
You're instantiating the chess and monopoly classes inside of the chess class. Otherwise, great post.
Global variables is brutal, so, as suggested, get rid of those. Also: if event.isSigning == true &amp;&amp; create_spell_book(new_book, event.getPlayer) == false then can be turned into if event.isSigning &amp;&amp; !create_spell_book(new_book, event.getPlayer) You don't require to compare booleans in instances like this. Your onCommand method can use a case/switch instead of many if-then-else.
This is the best into to Ruby threading: http://www.jstorimer.com/products/working-with-ruby-threads
I use Vim and set the tab key to equal 2 spaces. Most sites, I've seen, default a tab to 8 char in length. IDEs should have the option under settings. Some even let you customize per language. 
Have you considered using the command pattern for the onCommand method instead? https://github.com/TheBlasfem/ruby-patterns#command
The onCommand isn't my own method, it's a callback from the Bukkit plugin I'm using.
I think the best thing here is that you are using Ruby style alongside Java. I've seen some, when coming from Java or related, not use snake case for objects/methods and Upper Camel Case for classes. Ruby has a mantra to be elegant, and following the suggested style helps. (You can read more at the community Ruby Style Guide on Github.)
I just changed it in my IDE. It was set to tab characters instead of spaces.
Thank you for the suggestion though, I've not heard of that pattern before.
Besides all the other advice here, you have 5 boolean variables that you have in init_globals, that appear to just be a mapping of the event. I'm pretty sure you can remove all of them and use if $event == SomeEvent. Then instead of having 5 functions(spell_init, spell_run, etc...), you can have just one check_spell, that takes another event to check $event against using a closure or something. Also stuff like this is really hard to understand: &gt;event.getEntity.getItemStack.getItemMeta.getLore[1] &gt;@spell_books[cur_block.getMetadata("reich")[0].value] Use something to make these things nicer and easier to read and use. Make little wrapper functions or mixins or something.
Try running [RuboCop](https://github.com/bbatsov/rubocop) against your code.. it will give you multiple hints and suggestions about the "recommended" Ruby style guide. Here you can see the results I got running it on your file: https://gist.github.com/TiuTalk/c1cbd401cf036e7998d8
Hrm, is this just jRuby? Or some other way of getting ruby into bukkit? I never really thought to try the former.
It's standard to use "soft tabs", too, which are actually 2 spaces (not a tab character).
It's a plugin called RubyBukkit that wraps JRuby and lets you write plugins in Ruby for Bukkit.
A few changes at http://pastebin.com/4JxnH0ey A few goals I had in mind: * Reduced verbosity in conditionals. Idiomatic ruby prefers letting false things be false and true things be true, rather than checking explicitly. Eg: if foo.get_value != nil is better written just foo.get_value * Stored globals in a single object called $vals, rather than store a bunch of them. This might help if you ever wanted to write tests; there's one object to swap out. * Similarly with the case logic in onCommand - with them broken out into short methods, they can be reasoned about more easily. Overall though, it does not suck. Nicely done.
Nice. I'll have to try that
I'd recommend reading "Design Patterns in Ruby" by Russ Olsen. I'm working through it and writing up blogs about each design pattern in order to gain a working knowledge of them. 
There's your mistake... Use soft tabs, not hard tabs.
&gt; Ruby is in the hipster stage. To be honest, I think the ruby "hipster stage" was way back in ~2006
I'd like to criticize on a few points: 1. I would not use inheritance to enforce adherence to a common API, most of the time. First of all, ruby is duck typed. Secondly, alternative techniques off the top of my head to consider: namespacing related classes together, object composition, mixins. 2. This post feels incomplete. `if`/`case` will still need to be used _somewhere_, which is not shown. It also does not apply the technique to the presented "generalized payment methods" and "generalized output formats" use cases.
I like how the author cautioned the possible unexpectedness of a hash-modifying block implicitly run on every "cache miss". I don't have an interpreter on me atm, but it sounds like: foo = Hash.new { |h, k| h[k] = [] } foo[:bar] # =&gt; [] foo # =&gt; { :bar =&gt; [] } # modified! An available alternative is using `fetch` to explicitly declare "defaults" on retrieval: foo = {} foo.fetch(:bar) { foo[:bar] = [] }.push "bar"
Why not use an abstract class or include those methods in the game class, and override them as needed?
The game class is the abstract class?
Deploy often is probably the best tip in there -- when I participated in the Rumble in 2007, the first thing I did after scaffolding the application was get it wired up for deploy, and continued to deploy throughout the weekend to ensure nothing was going to break along the way.
Interesting. I wasn't aware of this. It certainly seems like this might be the case, as I have no trouble generating the CSV on my development machine. Is there a way around this? Should I just include a DL link in my email, instead of a file attachment?
1. I have not heard of this. I will look into it. Thanks. EDIT: What exactly am I looking for? 2. Essentially, the Dev DB is just an old dump from a few months ago. 3. Yes they are.
it could be. I would define each of setup_board, end_of_game, etc in Game, so that each of the games could inherit those methods. Other people mentioned that you could throw a not implemented error to mimic the behavior of an interface. What's really neat about ruby, is you can have an interface and abstract class behavior in the same class. or, you could implement a generic version of display_winner (or other methods), and then all your games would inherit that that would be pretty useful, especially if your game class was in charge of the players list as well. :_)
SRP?
Also: https://www.ruby-lang.org/en/news/2015/08/18/ruby-2-1-7-released/ https://www.ruby-lang.org/en/news/2015/08/18/ruby-2-0-0-p647-released/
Yay! New Ruby!
np, thanks!
Here's a list of a bunch of them: https://www.ruby-toolbox.com/categories/packaging_to_executables A long long time ago I was using Rubyscript2exe and it got the job done, but I couldn't tell you what kind of progress has been done in this area recently. 
this is fantastic. New question, can I make an .exe on the mac and then transfer it to windows and open it up there?
No.
Spend a few hours deploying a trivial app to it. No better way than to Just Do It™. Pull in a few addons like redis and SSL and use them. They have a free tier so it'll cost you nothing.
do/end (or { }) denotes a [block](http://rubylearning.com/satishtalim/ruby_blocks.html), which is (more or less) syntactic sugar for passing anonymous functions. The pipes denote the arguments to the function. The 'each' function in your example is going to loop through the collection and call the provided block for each element, passing that element to the block.
You actually need the next line to say what you're doing: words.each do |word| #something end You are calling the `each` method on `words`, and you are passing it a block. `do` passes a block. The block you are passing has one argument, which you express with `|word|`. The block you have passed -- in between the `do` and the `end` -- with whatever code you wanted to put in it -- will be called 0 or more times by the method. How many times depends on the method and what it does. In this case, `each` will call your block once for every element in the array (or other Enumerable), each time with the argument being the next item. There are other methods that take blocks -- it's not special to `each` -- and they will have other rules for how many times, if any, the block is called and what it's for. Another way to pass a block is with curly braces: words.each {|word| something } Does the same thing as the `do... end` version, just another way to do it, still calling the `each` method and passing it a block, with one argument. A block is basically some code that you can pass to a method, for that method to then call your block according to it's own specifications. 
Thanks so much! Does the word used here have to be it's own unique term, or does it get discarded after use? For example, if I used |x| here, and then later called x, would it refer back to the |x| or do the lines make it a one-time use of the block?
Thanks for responding, Jesus. that makes a lot of sense :)
Thanks :)
Or you could just use fixtures.
Generally, the variable is scoped only to the block you've declared it. There may be some annoying exceptions, I forget. 
Are you developing on a Windows machine and deploying to a Linux server? It seems to me that when the line is split there is a space in front of the letter where it was split. As it is in this sen tence. The line-endings in Windows are new-line, carriage-return. While Linux only uses the new-line. Maybe the carriage-return renders as a space in the csv?
Comments in the style of Roda routes? Gold! :)
yep, yep, but it depends on a project, what tools the team are familiar with, and what legacy you have to work with. 
It seems that attachments are cut off at 990 characters: [https://stackoverflow.com/questions/10401863/how-to-send-a-csv-attachment-with-lines-longer-than-990-characters](https://stackoverflow.com/questions/10401863/how-to-send-a-csv-attachment-with-lines-longer-than-990-characters) I added an answer to your question on StackOverflow.
I would think a rails team could be expected to know how to use basic rails features. That said, the only time fixtures aren't practical for situations like this are where you have scores of tests that do this: def test_something record = FactoryGirl.create! :object record.some_method! assert_equal 1, Object.count end e.g. tests that expect to assert against a clean db each pass through will break.
The stand alone mappers are absolutely wonderful to work with. 
I'm fan of using both fixtures and factories along each other. Both do good job in different cases. (for examples have configuration models like Languages, Translations as fixtures, and let dynamic Users, Documents to flexible factories) Yet imagine you're a contractor for existing project and they use only FactoryGirl, you propose your case that you want to use Fixtures as well, they say no as rest of the team is not comfortable with them. Not much you can do about it. 
Thank you. Those are some good points :)
Yes, ROM blends FP with OO. That's not accidental :)
redirect "/"
https://github.com/HappyFunCorp/middleman-blog-ui
Glad to know, thanks :)
Refactoring code for database efficiency.
Indeed, thanks for the check! Fixing it.
Ah, interesting topic. Thanks for the suggestion!
Hmm, interesting. There's a lot that could be covered. Thanks for the suggestion!
Very true. Sometimes teams will prohibit use of certain tools.
this is awesome. Thanks. Are there resources that explain the type of data that Neo4j is optimized for? I'm trying to get a better idea of when to use Neo4j over Postgres for example.
Depends on what you're trying to do. .sort_by took me a bit longer to really wrap my head around fully.
Love love enumerables, miss that in other languages. For me, it was just a matter of practice using them often.
Try writing down the most naive implementation you can think of. Once you've done that and you have your tests passing, don't leave it like this, but incrementally improve it until you're satisfied. That always helps me at least when I can't wrap my head around something.
Write something to parse strings like "[{}]}{][]" If the string makes sense, meaning a { is closed by a } before any other char (same with [ and ] ), return true. Otherwise, return false. 15 minute time limit.
Man... that's good. My brain doesn't want to work that way.
Write a function that, given any array of coin values (for example [1,5,10,25]) and any target value (say 100), returns an array of the fewest coins needed to reach that value.
This is a weird way to say this but... it's not guaranteed to be inefficient. It's a bad answer to the inefficiency problem for the same reason it's a bad answer to the efficiency problem.
That's a long-term plan, what if someone has no job *right now*? Edit: Noticed you been coding for years. Your advice isn't wrong, but I'm not going to pull out years of experience out of nowhere just because I feel like it.
I would have not solved this.
When I've gotten segmentation fault restarting the computer fixed it
But if you want to chat and do a g-hangout practice interview or something, let me know. We could even live stream it for r/learnprogramming or something.
Example problem: create a "pow" method that finds n^k for parameters n and k. Don't use the built in operator, of course. You may assume k is a nonnegative integer.
I have more to learn, thanks though.
I'm far worse than I'm letting on for everyone. I'm going to stop looking at the comments, then come back in a month and PM each person who gave me a challenge.
I was asked this for my current job, so a very real interview question. I had no restrictions on how to solve it, so I told them I would give a creative answer rather than use a stack. Class String def is_closed? original_length = -1 until self.length == original_length original_length = self.length self.gsub!("{}", "") self.gsub!("[]", "") self.gsub!("()", "") end self.count &gt; 0 ? false : true end end
And then do it recursively.
It's playing Tetris with the string. It's destroying matching open close braces which are next to each other. 
Canonical answer would be put left style on the stack and if right style, pop if matching else return false I suppose?
It's framework specific, but if that's the job.... Given a rails model Widget with a "name" attribute/field how does rails make Widget.find_by_name work? If you don't know how, what are the ways it could be done? What are the advantages to the various ways?
Love the Tetris analogy.
It's not guaranteed to be inefficient for small inputs, but asymptotically it is. This is basically bogosort, and [as demonstrated here](http://www.hermann-gruber.com/pdf/fun07-final.html), bogosort is `Ω(n*n!)` in the average case and `θ(∞)` in the worst case. For sufficiently large `n`, the probability that the function will terminate in any finite number of iterations is 0.
How about iterating over all chars and always picking the last one, that was not put in the reversed string yet. This is done by constructing an array of all indices of remaining characters, reverse sorting it with bubblesort and then using the first element of the sorted array as an index into the character array. def rbubblesort(array) array = array.dup n = array.length for i in 0..(n - 2) for j in 0..(n - 2 - i) if array[j] &lt; array[j + 1] t = array[j + 1] array[j + 1] = array[j] array[j] = t end end end array end def reverse(string) chars = string.split("") n = chars.length reversed = [] for i in 0..(n - 1) indices = [] chars.each_with_index { |v, k| indices.push(k) } last = rbubblesort(indices)[0] char = chars.delete_at(last) reversed.push(char) end reversed.join end string = ARGV[0] p reverse(string) require "benchmark" N = 1000 Benchmark.bm do |bm| bm.report("built-in") { N.times { string.reverse } } bm.report("ours ") { N.times { reverse(string) } } end Benchmark example $ ruby inefficient.rb "jfl2n4pnx23j" "j32xnp4n2lfj" user system total real built-in 0.000000 0.000000 0.000000 ( 0.000211) ours 0.210000 0.000000 0.210000 ( 0.207993) 
Small questions I've been asked on a phone screen: * Explain the difference between a symbol and a string (lol, standard) * What do I mean by O(n) and O(n^2)? * What is Mocking (context: rspec/testing)? What is Stubbing? when would you use one vs the other? * What's the difference between unit, integration and feature testing, as you understand it? * Describe in detail the architecture of a recent project. * What is currying?
Incorrect. Some sorting algorithms (notably quicksort) are actually less efficient on already sorted data (a typical implementation of quicksort will check if it's sorted first, but that's another story). Want to guarantee it's inefficient? Make it only accept a sorted array on the n^2th time. That is, don't stop the algorithm until it's been sorted n^2 times.
That's a bogosort. I'm thinking of calling it bogoreverse: # Bogoreverse - a bogosort-powered implementation of a string-reversing function def bogoreverse(string) result = nil until result == string.reverse result = string.chars.shuffle.join end end 
Inefficient use of memory is delightful. I'm inclined to pre-calculate all possible permutations of the letters in the string, and then start filtering through them: permutations = string.chars.to_a.permutation.map(&amp;:join)
Looks like fun! I'm thinking back to compiler theory stuff from my degree, so my solution is to use a basic stack: def is_valid(string) return false if string !~ /^[\[\]\{\}]*$/ # pre-check for strings with invalid characters in stack = [] string.chars.each do |c| if (c == '[') || (c == '{') stack.push c elsif c == '}' return false unless stack.pop == '{' elsif c == ']' return false unless stack.pop == '[' end end stack.length == 0 end It's a bit rough around the edges: I'd want to store the 'pairs' of openers/closers in a better format if I had more time, but I knocked this up in under 5 minutes while talking to a coworker, so I'm not too unhappy. By way of explanation, what this does is: first it returns false for any string that isn't entirely comprised of [, {, }, and ] characters as obviously-invalid. Then, for each character in the string: * If it's a [ or {, it puts it on the stack. * If it's a ], it pops the top thing off the stack and if it's not a [, returns false. * If it's a }, it pops the top thing off the stack and if it's not a {, returns false. If after all of this the stack is empty, it returns true, otherwise false.
That's inventive! I've used a similar technique for a very different problem before (implementing a basic logic solver).
Actual Rails-related question (or close-to it) I've asked candidates and a shocking number of them can't see the answer (and an even-more-shocking number still can't see why the answer is important after they're told it) - ---- What's the single biggest problem, in your mind, with this code, which comes from a controller action responsible for searching for "person" records? What specifically should be changed, and how does this help the application? # Searches for people by surname, given a partial surname def search @people = Person.where("surname LIKE '%#{params[:q]}%'").all end 
This won't work. You need to do it live via Skype or in person. They (should) want to hear you think out the solution. A good interviewer wants you to talk to them while you solve it, watch you write out the algorithm and test it manually before you start coding. Algorithm / pseudo code -&gt; test it works manually -&gt; actual code. This shows them how you think, how you solve problems, and if you really do know the language / job. Let me know if you have questions.
I'm inclined to be I/O inefficient. The algorithm that first came to my mind when I thought of this question involves writing a string to a file from end to beginning, and then returning a read of that file. Another fun option would involve sending ICMP requests to some server with a packet of the current character and listening for the echo before adding it to the reversed string. Or having a listening server that will store your string in a stack, and you can push/pop at will.
LOL. Because these are the kinds of problems that most Ruby/Rails devs are solving on a regular basis... ;)
Wow. This is why I hate job interviews and have gone to great lengths to try avoiding getting into one. I've been a Ruby/Rails dev for years and have shipped numerous production apps with some pretty serious complexity, and I still wouldn't be able to answer some of these. (I think I might have heard the term currying once, but can't for the life of me remember what it is, other than an awesome Indian dish.) Why do interviewers think the rote memorization of language/coding trivia = a good programmer? Most programming is simply research, deductive problem-solving, and anticipating future problems, not memorizing trivia.
You described partial application, not currying. Currying is the process of decomposing a multi argument functions into a set of composed single argument functions. Partial application takes a curried function and applies some of the arguments of the function, which by virtue of it being curried, returns back another function. def foo(x,y,z) x^2 + y^2 + z^2 end An example of a non curried function Now using procs, a curried function foo = -&gt; (x) { -&gt; (y) { -&gt; (z) { x^2 + y^2 + z^2 } } }
Cool, I didn't realise about the single argument restriction. Thanks. Would it be right to say that a curried function (single arguments each returning a function which takes the next argument which returns a function...) is partial application but for single arguments? I mean the function (with partial application) can't resolve until all arguments are provided, anyway.
[**@yukihiro_matz**](https://twitter.com/yukihiro_matz): &gt;[2015-08-20 15:27:07 UTC](https://twitter.com/yukihiro_matz/status/634386185507311616) &gt;link: DevelopersMeeting20150820Japan \- String literals are frozen \(immutable\) by default in Ruby 3.0 &gt; &gt;[*docs.google.com*](https://docs.google.com/document/d/1e00tTj8ix2ofS8H2RiIMUhr39bABSc7AL0vk4KbtSF4/edit) ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3hqky4%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
I know! That's what I said....
thanks for clarifying.
I think it'd be better for them to rid of mutable strings entirely, but at least for non-literals I can see the value in mutable strings for cases like this. With literals it's a dangerous game though, nothing like having what you think would be a constant like module MyModule MY_FOO = "FOO" end be modified because someone used a bang! method somewhere unknowingly.
I disagree with being rid of them entirely. There are scenarios where mutable strings save a lot of memory and runtime, and I think string mutability should still be available as a non-default.
I think this is a good idea. Also, with strings being immutable, I think symbols and frozen strings should just converge and be "the same thing".
&gt; Is it going to kill people to not use bang! methods and just reassign a result? I don't have a problem doing so, but currently the bang! style methods are significantly faster due to no copying. 
Are you asking how to cause a cpu to heat up using Ruby, or are you asking how to get the temperature of the cpu via Ruby? I don't know the answer to either, but I feel the question is a little confusing. 
You could easily have `String` be immutable alongside a separate `MutableString` class. This is the strategy employed by Objective-C — pretty much every standard class (array, dictionary, etc.) has an immutable base class and a mutable subclass.
I have left reddit for [Voat](https://voat.co/) due to years of admin/mod abuse and preferential treatment for certain subreddits and users holding certain political and ideological views. This account was over five years old, and this site one of my favorites. It has officially started bringing more negativity than positivity into my life. As an act of protest, I have chosen to redact all the comments I've ever made on reddit, overwriting them with this message. If you would like to do the same, install [TamperMonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo) for Chrome, [GreaseMonkey](https://addons.mozilla.org/en-us/firefox/addon/greasemonkey/) for Firefox, [NinjaKit](https://github.com/os0x/NinjaKit) for Safari, [Violent Monkey](https://addons.opera.com/en/extensions/details/violent-monkey/) for Opera, or [AdGuard](http://adguard.com/) for Internet Explorer (in Advanced Mode), then add [this GreaseMonkey script](https://greasyfork.org/en/scripts/10905-reddit-overwrite-extended). Finally, click on your username at the top right corner of reddit, click on comments, and click on the new OVERWRITE button at the top of the page. You may need to scroll down to multiple comment pages if you have commented a lot. After doing all of the above, you are welcome to join me on [Voat](https://voat.co/)! So long, and thanks for all the fish!
But it falls in line, and in reality *ANY* string literal is by definition a constant.
I'm not happy this idea got so far and find rationales at invoca.com rather weak (optimization of literals instantiation, indirect mutation). Why not making hash literals, array literals, range literals, regexp literals also immutable by default ? Why bring the inconsistency in the language ? I'm not against making Ruby more functional. In fact I love pure functional languages, esp. Haskell. But doing it so picky way and do an exception from the rule with string literals find quite unfortunate. Exception of immutability for symbols is well founded as language's identifiers internal representation. No such legitimacy for strings :( 
No not really. Partial application has a meaning when *applying* arguments to functions. Currying has a meaning when *constructing* functions.
The #1 thing holding back MRI performance is the C API. I really wish they'd discuss what it would take to get a modern C API.
majority of 'modern' languages ==&gt; they also have things like StringBuffer, which are mutable string...
If you're on a Mac, check out [iStats](https://github.com/Chris911/iStats), it's a ruby gem that outputs some CPU stats. The implementation seems to be mostly C, but maybe you could include the gem in your project and go from there. 
If you write (or find an existing library for your platform) library you can hook into it to pull the data in. lm-sensors is a popular linux package to do this. On mac istats and or polling SMC via C is the way to go go CPU. GPU nvidia and amd both have apis that let you poll this information that you can hook to. 
Well, lets hope rubygems doesn't just pull in gems that don't have a ruby version specification
Constants are mutable. They just can't be reassigned (without a warning). ARY = [] ARY &lt;&lt; 1 ARY #=&gt; [1]
Because strings are closer to a 'primitive' type than hashes or arrays, the use case falls more in line with the numeric types in that they are used primarily for control, display and manipulation, not as data structures.
Sorry, I misread "with strings being immutable ... symbols and *frozen* strings ..." [but not all strings would be frozen?] Then `"x" + "y"` would produce a mutable String? 
So I would like to rename VendingMachine to Controller and have a VendingMachine model where I move #vend and #refund to it. I'm also not very happy with #menu being this large in LoC. What would you guys recommend?
I think we are talking past each other due to semantics. If strings are immutable, they can have all references pointing to a single memory location for equivalent strings, just like symbols. Operations on them can (optionally) have all properties of operations on symbols. Any operations on immutable strings that require checking for existence or equality would be O(1) if a hashed string table is maintained by the runtime, which can be duplicated per thread or put behind a mutex, as deemed prudent.
Finally.
Reduced garbage collection.
Ruby string literals are cloned at reference, so mutating them is a no-op.
No. The constant's binding is immutable. The constant's value is mutable.
To reduce GC costs.
Because symbols are for concepts, strings are for data.
Wow, this seems like basic programming knowledge instead of rails specifically. I'm sure anyone with a basic knowledge in ruby will be able to do all of these.
Whut? It totally does if you're making frequent enough allocations. Imagine any script whose main task is manipulating strings, there would certainly be a performance penalty if you had to copy a potentially very long sting each modification. 
Take it a step further and make all strings immutable. Symbols must die!
No they share only 21 methods: &gt;&gt; (("String".methods - Object.new.methods) &amp; (:symbol.methods - Object.new.methods)).count =&gt; 21 =&gt; [:casecmp, :[], :length, :size, :empty?, :match, :succ, :next, :upcase, :downcase, :capitalize, :swapcase, :intern, :to_sym, :slice, :encoding, :, :, :, :, :between?]
Woahhh huh, TIL then. Thanks! 
&gt; &lt;&lt; or += modify the string in place `+=` does not modify the string in place. [1] pry(main)&gt; x = "foo" =&gt; "foo" [2] pry(main)&gt; x.object_id =&gt; 28324760 [3] pry(main)&gt; x &lt;&lt; "bar" =&gt; "foobar" [4] pry(main)&gt; x.object_id =&gt; 28324760 [1] pry(main)&gt; x = "foo" =&gt; "foo" [2] pry(main)&gt; x.object_id =&gt; 19423060 [3] pry(main)&gt; x += "bar" =&gt; "foobar" [4] pry(main)&gt; x.object_id =&gt; 18587580 &gt; lets say any Ruby application that appends to a string buffer I am not questioning whether this is a common task. I am saying I don't believe that this has any significant impact on the **total** application performance. In the case of a Rails application, for example, you will almost certainly see **much** bigger performance improvements if you focus on things like database architecture, eager loading and caching.
This is also true in Java and Javascript.
There shouldn't be mistaken subjective intuition with systemic design decision with internal consistency and logic. At the subjective level, I'd disagree strings are a *'primitive'* type. They are not enough atomic as they can be decomposed to individual characters, have different encodings (internally, not way of their representation) etc. Strings in Ruby in fact correspond to Array of strings. `mystr = 'hallo'; p mystr[1] # 'a'; mystr[1] = 'e'; p mystr # 'hello'`. There is some contradiction wish strings being immutable and arrays not. At the more objective level, there really is no difference between string and other literals. Range, regular expression, hash or array literals may also be considered immutable in the same way and modifications performed only on their copies. It would be consistent across the language, help write safer concurrent code. Downside are the performance penalties and memory usage as each modification would require objects duplication, strings included. In haskell, some smart compiler like GHC can do a lot of optimizations here, because can rely on comprehensive static type system. Not imaginable at dynamic type system of Ruby.
The short answer is: Yes. But the implementation depends on your hardware. What sensors does it have? What system libraries does it have that can make use of these sensors?
&gt; Downside are the performance penalties and memory usage as each modification would require objects duplication, strings included. In haskell, some smart compiler like GHC can do a lot of optimizations here, because can rely on comprehensive static type system. Not imaginable at dynamic type system of Ruby. AFAIK GHC doesn't help much with optimising `[a]`. It's basically just a linked list, so you have structural sharing by default. For more complex data structures (e.g. arrays with fast random access) there are [persistent data structures](https://en.wikipedia.org/wiki/Persistent_data_structure) which can be used in Ruby as well.
That's by no means a given, as frozen string literals means that every operation that would previously be a mutation now needs to create new objects. Languages that avoid mutation generally create *vastly* more garbage for the gc. 
If you mean that "x='foo'" results in a new string on each run through the code, you'd be right, but that's not the problem. Consider: THIS_SHOULD_BE_CONSTANT = "foo" a = THIS_SHOULD_BE_CONSTANT ... further down: a.gsub!(...) Now THIS_SHOULD_BE_CONSTANT has changed. 
&gt; constants Ruby constants does not enforce immutability of the object assigned to them in *any* way. They just prevent you from casually re-assigning a *different* object to them. 
I think it would be a lot easier to understand if you actually created two classes of String, one mutable one not. Then you could say String literals are always of the immutable kind. If you want a mutable kind, call `#to_mutable` (or something like that, `to_` something) on it. It would be a more consistent mental model, more OO. Immutable Strings wouldnt' even have bang methods (which you could check with respond_to, consistent with other duck-typing) -- instead of frozen strings, which have mutation methods which will always raise. So you need to check to see if you have a mutable one with `! thing.frozen?`, which isn't duck-typing anymore -- so to see if you have something which duck-types as a mutable string you actually will need to check `respond_to?(:some_method) &amp;&amp; ! frozen?`. It's confusing. It's going to be especially confusing for newcomers learning the language, those of us who have been with ruby for a while can add it in to our mental models, just one more thing. But it's one more weird idiosyncracy to keep track of. If for performance and/or semantic reasons you do think it's a good idea for String literals to be immutable -- make them an actual different class, an actual OO design. (I would imagine mutable strings would be a sub-class of immutable strings, since they can do everything immutable strings can do plus more). 
Looks like a misunderstanding. I thought your point was "immutable" =&gt; "memory overhead; copying" =&gt; "can't be optimized without a smart compiler" which is in general not the case since persistent data structures can be implemented in any language and no heavy lifting of the compiler is required. As for ByteString (disclaimer: Haskell Noob): It looks like the implementation is already doing the optimization work by using ForeignPtr and offsets? https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.Internal.html#ByteString
Ruby newb here, sorry to barge into this technical discussion but the headline sounded like it was a big deal and I'm trying to understand what it means. /u/jrochkind for example mentioned that it could be confusing for newcomers. I've been coding in Ruby for a year and a half but still feel mostly like a newbie, and for the most part my Ruby code revolves around Chef rather than pure applications. So is something like the below something that would be proscribed under Ruby 3.0? a = 'foo' # stuff a = 'bar' # more stuff 
No, that would be fine. This would not be: a = "John" a &lt;&lt; " Smith" But this might be, depending on whether the string originated as a literal: a = firstname a &lt;&lt; ' ' &lt;&lt; lastname
Probably for another thread, but I like explaining. So everything in ruby is an object. A variable points to an object, but the variable is just a pointer, or 'box', or 'reference', or 'tag'. Or even you could call it a 'name' for an object. You can change what object a variable points to, but the objects remain the same. x = "This is a string" y = "This is a string" Those are actually two different strings -- two different objects -- even though they both represent the same thing. x.object_id = y.object_id # =&gt; false But: z = x z.object_id == x.object_id # =&gt; true, they both point at the exact same string In ruby, Strings are mutable, you can change them. # add content on to the end of the object pointed to by `x` x &lt;&lt; " plus more stuff" x #=&gt; "This is a string plus more stuff" # z points at the exact same object, which has been modified z #=&gt; "This is a string plus more stuff" # but y is still a different object y #=&gt; "This is a string" In ruby, you can always reassign a variable to point at a different object. There _are_ languages, pretty much always functional languages like Erlang (Or XSLT! Really!), where you can't _ever_ do this. But in ruby, you can always reassign a variable to point a different object. Which is what your example did. In ruby, can you _change_ the internal state of object, change the data in an object? Some objects you can, some you can't. This property is called 'mutability'. An mutable object can be changed, an immutable one can't. By default, all objects are mutable in ruby. But you can create immutable ones. One way is by definining a class so that it simply has no way to change it's state, once the object is created, it stays exactly the same forever. Another way is by using the built-in ruby `freeze` method on an object. Freeze is a language feature; frozen objects can't have any of their state changed, you'll get an exception if you try. (There are some gotchas where dependent objects the main object has a reference too can still be changed, we won't go further into that). You can freeze any object in ruby just by calling `freeze` on it, it's a built-in language feature -- although one that historically hasnt' been used too much in most community ruby code. Once an object has been frozen, it can't be unfrozen. That's just how the language feature works. In ruby 3.0, the current announced plan is that string _literals_, those defined in code with double quotes (or single quotes, or the other ways to do string literals) will start out frozen. Hope this helps. 
If the object is *not* mutated, there is no reason to clone it. In most Ruby code contexts, a Ruby string literal is not mutated, so we pay the GC cost of Ruby's semantics prior to Ruby 3.0: all string literals are cloned at evaluation. irb(main):001:0&gt; def f; "s"; end =&gt; nil irb(main):002:0&gt; f.object_id =&gt; 70351455453260 irb(main):003:0&gt; f.object_id =&gt; 70351447027180 In Ruby 3.0: the result of evaluating the string constant in f() would be the same immutable String object. 
Constants are *redefinable* at Module scope (with a warning) but are not redefinable in method or block body scope.
They are not even definable in a method according to a quick test I just did. edit: it's in fact a Syntax error to assign to a constant (whether or not already defined) in a method, so it's not even a runtime error
Why should it be a runtime error?
Also, frozen strings with the same value point to the same underlying object in memory in recent MRI. 
Forcing `&lt;String&gt;.dup` to avoid `&lt;Symbol&gt;.to_s` is lame. I'm against this stuff.
you should really freeze your constants ARY = [].freeze ARY &lt;&lt; 1 RuntimeError: can't modify frozen Array
Awesome, I really like focused gems like these, which solve a concrete problem. Faraday bases it's design around middlewares, and it implements its own flavor inside, it could really benefit from this gem.
&gt; Can you show me any such application on github? Rails. All your ERB templates are compiled to code which append strings to a buffer using &lt;&lt;. Static site generators like Jekyll and Middleman also use mutable strings extensively, either directly or indirectly through ERB.
&gt; In the case of a Rails application, for example There is a huge focus in Rails right now on improving performance for Rails 5. Most of what their doing is reducing object allocation, and most of those allocations are Strings. Object allocations aren't cheap.
RubyMotion is great. You can reuse some of your business logic from your other Ruby or Rails application. Downside is that knowing Ruby isn't enough. To be practical, you need to know a lot of the iOS and Android APIs. 
Use Linux, Virtual Box and Vagrant. Here is a tutorial: https://gorails.com/guides/using-vagrant-for-rails-development Windows and Rails are hard to get to work together.
I worked in startups for years. Recently I got a gig with a company that has about 50 engineers and 200 staff in total. We are desperate for more decent Ruby people (so if you happen to be in London, PM me), and I can't believe that's a unique situation. You don't need to move languages. You need to move companies. Dig around and look for larger firms with 150+ headcounts and see what you find. If you've been doing Ruby for 6 years you're probably going to be mid-to-senior level and you should be fine.
Form objects are something I resisted for well over a year, until I realised that I was spending an absolutely inexcusable amount of time and effort on forms and different actions on related data. (Authentication vs registration vs updating "profile" data and such are an obvious-in-retrospect example.) The other great benefit is, it helps you keep your application logic and (Rails) delivery-implementation logic nicely separate. SOLID, DRY code is a Wonderful Thing. The resources that helped me most were: * [*Application border control with form objects*](http://insights.workshop14.io/2015/07/23/application-border-control-with-ruby-form-objects.html) by [Peter Saxton](https://github.com/CrowdHailer) of [Workshop 14](http://workshop14.io/) (also cited on his Vulcanize [repo page](https://github.com/CrowdHailer/vulcanize)); * [*Creating Form Objects with ActiveModel and Virtus*](http://webuild.envato.com/blog/creating-form-objects-with-activemodel-and-virtus/) by [Peter Rhoades](http://webuild.envato.com/people/peter-rhoades/) of [Enviato](http://webuild.envato.com/); and of course * Railscast (Pro) #416, [*Form Objects*](http://railscasts.com/episodes/416-form-objects), by the irreplaceable Ryan Bates.
first: you should tell your girl-friend to accept your style to live and work, it is a good base for a partnership ;) second: why not both? of course you can have a stable job with ruby, there are many greater companies which are using ruby, e.g. I work at Sage, in a very cool Ruby/RoR/JS together with other teams, which are using other languages. In my opinion, one don't have to learn another language, only have to learn to understand people which are using for programming another language, means: an object in lang A, most not be the same as an object in lang B, the knowledge about the meaning is important.
Thanks for sharing this. It looks promising.
I had the same problem, You just need to change your gem source from https to http. Also, just comment out the error msg found in "dl.rb"
I don't think moving languages is relevant. If you're really good at what you do, no matter the language, you'll always find jobs. Being constantly employed &gt; "stable" (read large corporation that has money, but not much agility). I don't know where you live, but at least here in London there are loads of "stable" ruby jobs, and even if you like working for startups you can always find another one if the one you're working for fails. Having said that, it is always nice to know more than one language so you can quickly switch if you get bored with one :)
Agreed re: RubyMotion. It's the first ruby-based solution that looks like more help than harm. :-/
Definitely a good practice, but one that I find myself failing to use because all-caps makes my eyes bleed. I often misuse methods in lieu of constants for that reason...
One issue with RubyMotion - it is Mac only (and I'm a Linux user) :/
A little more refactoring: class User &lt; ActiveRecord::Base COMMENTER_MINIMUM_AGE_IN_YEARS = 13 MAXIMUM_COMMENTS_PER_HOUR = 20 def allowed_to_comment? old_enough? &amp;&amp; below_comment_threshold? end private def old_enough? age_in_years &gt;= COMMENTER_MINIMUM_AGE_IN_YEARS end def below_comment_threshold? comments_in_last_hour.size &lt;= MAXIMUM_COMMENTS_PER_HOUR end end Cool thing here is that `allowed_to_comment?` doesn't know anything about different measures of ages, nor does it know about comment threshold durations. Is this a win? I think so, but it's a matter of personal taste for at least some portion. If you ever wanted to alter the duration of comment thresholds, you wouldn't need to touch the method that checks if a user is allowed to comment. Plus you could move that out to a module seamlessly since it doesn't seem to belong in the User class anyway.
&gt; Hashes can’t have more than one value for a single key. But arrays can have as many duplicates as you like. The assoc and rassoc methods do the sensible thing in this case and return the first matching row they find. If a key is duplicated it's no longer an associative array by definition. Giving future programmers working on the code the impression that the array is associative by using `assoc` or `rassoc` is just asking for bugs.
Does seem like a way to write some shitty code, seems like there would be a lot better ways to store historical data which the blog seems to point to as why to use this. Do people really just load all their historical data into a big array? 
I've been a ruby on rails developer for 8 or 9 years now. At first I was an independent, but for the last 4 years I have been an employee at 2 companies. I've been with my current company a little over 2 years now, and we are stable and growing. I was hire #161, now I think we're about 400 employees with about 50 or 60 openings. So, yes, there is stable work out there. The down side of working in a company like mine vs startup is there are way less green field opportunities. On the other hand, I get to work with a much bigger system and learn the pros and cons of previous architectural/coding decisions.
This is pretty awesome.
OK, but you benchmarked it. In the worst case scenario the assoc method was 40,000 times slower (not a typo, nearly 40,000). If you really need more than one value per key you can have a hash with strings or symbols as keys and arrays as values. There's no advantage to this other than having to write **hash = Hash[array]**. That's it. Now you have the proper data structure which is literally better in every way. I suppose _maybe_ in an edge case if you only had to do one lookup on a very small array or something Array#assoc would be OK. There the construction time for the hash would probably be more than the lookup. And it creates one less object for the GC. So maybe in that very tiny situation would you actually want to use this, in all other cases it'll be better to use a Hash. Ruby is slow enough as it is, you don't need to help it along by using the wrong data structure.
Wait, what? Are you talking about needing 1000 characters to STORE a password on your app? If so YOU ARE DOING IT WRONG; STOP. If you allow a 1000 char password and it takes 1000 chars to store it you are most likely storing the password in plaintext or encrypted. Either way is very very bad. Stop. If you are merely commenting on the length of passwords allowed on sites, meh. 
If you want to code for iOS, you need a mac. There's no way around it since a lot of the libraries are reused (even for RubyMotion). Android is still possible, but iPhone's are out.
Random is a ruby class, RANDOM is a constant variable inside of it. Probably RANDOM is an instance of a Random. Basically Random.rand is a shortcut so you don't have to type Random.new.rand or Random.RANDOM.rand.
Yep. `Random::DEFAULT` is the default instance of `Random`, i.e. the one that is seeded when the `Random` class is loaded into the interpreter. 
Do you already have tcl/tk installed on your box? Looks like you are missing dependencies.
Programming is about practice. You start simple and try to iteratively build your project or idea. And when you are stuck you come up with solutions that will bring you closer to whatever you are trying to build. It sounds to me like you should sit down and start developing. Pick an idea and just start. It is never about the final product but the path to reach it. Think of programming like skate boarding. The mindset and progress is born through practice and a bumpy road, not through study. In my experience books are always a guide, an inspiration, a dictionary, but they will never teach you something you can only acquire through practice.
Nice tutorial. Can you please throw a link to the tutorial in the repos readme? It would be useful for reference 
That's a good idea, thank you.
I put two apps in the store using RubyMotion starting back in 2012, and had a great time doing it. The only downside I discovered is that my projects went into hibernation for a bit when I didn't touch them for nearly a year, and when I went back in the entire RubyMotion ecosystem seemed to have changed on me, to the point where literally I couldn't get my code to compile anymore. This isn't specifically a RubyMotion problem, but there is a certain instability about the whole structure once you factor in various CocoaPods and other libraries that you may have had to hack a bit to make work. You get a lot of "You need to upgrade to Rake version X to make package #1 work, but package#2 requires Rake version X-1...." stuff like that. But this was over a year ago, so it may have gotten much better. Also, I never really got Storyboards working properly, which meant that I pretty much had to create every bit of the UI by hand. That was a real pain in the neck. I have no idea if Storyboards are supported now. 
That's good, because damnit I love Ruby, and I want it to thrive. It's really got a wonderful syntax and a wonderful community.
How do you like rails-api vs something lighter like Sinatra and/or Grape?
Java 2nd, would not have guessed.
WOOHOO
and Android.
Java makes sense because of Android. There are lots and lots of Android libraries on Github. JS is only as popular as it is because of Node. I'm not particularly a fan of that whole ecosystem (I mean, how many package managers, transpilers, dependency management systems, and asset compilers do you really need? It's a confusing clusterfuck). At this point in time, the whole JS/node ecosystem is just to volatile to support long-term in production environments in my opinion. Ruby is a lot more mature. The Python community is too self absorbed in PEP-8 (it's a good guideline, but Python folks treat it like gospel...it's creepy...and I previously worked with a guy who was a PEP-8 nazi and it was a horrible experience.) and political correctness for my tastes (ie: changing documentation to use "them/there" and changing widely accepted "master/slave" terminology...and don't forget about Donglegate...ugh...)
I'm unsure if you're being serious?
You should checkout [Eloquent Ruby](http://www.amazon.com/gp/product/0321584104/]).
Maybe they thought Java would be first
bringing Enterprise Java development methodologies to Ruby! I actually don't even have the words.
I think because I haven't worked extensively with this kind of thing in Java, the examples are not sufficing for me to understand what it does and how it's used.
You're out of your element, and being kind of a dick. The context of my post is that Ruby isn't seen as sexy as it used to be (as Rails isn't seen as sexy as it used to be) and Python has eaten up some of the use cases I think Ruby would excel at (data science/scientific computing.) Rubyists are a super smart and generous community and care about syntax in way I really dig. So I am very happy to see it hold ground and potentially find uses outside of Rails. That aside, be nice.
Pretty crazy to see that it was the top language all the way from 2008 - 2012 too
Developers that need dependency injection justified to them should rethink their choice of career.
You should definitely check out Avdi Grimm's RubyTapas series. There's a new episode out 3 times a week and he touches on tons of wonderful Ruby things.
 expect(Foo).to receive(:instance).and_return foo_double What's wrong with that? I don't think that forcing paradigmas of one language onto another is a good idea. And a bean/DI *is* a singleton. I don't see a reason for making that less obvious. It's already tedious in Java. While there DI is also an artifact of testability (and thus a language defect), some try to glorify it with "oh it's so much better than a singleton!"
i know what dependency injection is, and why it can be useful (although I think it can also be over-used in unneccesary places). I don't understand how this library works. In the example, there's a `MyContainer2` class, that defines one method `get_forth_bean`. But somehow the `MyContainer` class, which does a `load_containers 'MyContainer2'`, has access to a `forth_bean` method (not `get_forth_bean`), as well as a `second_bean` and `sixth_bean`. Where do these methods come from? I don't understand what `load_containers 'MyContainer2'` is actually doing, or what you are meant to do in the example `MyContainer2` class you are loading, to provide what, how. It's obviously not meant to be the same thing as a ruby module mix-in (or you'd just use that), but I don't understand what it actually is meant to do. From the next section of examples, I also don't understand what `RubyBeans.get_bean('first_bean')` is doing -- where is it getting that `first_bean` from, defined where? This may be because I am unfamiliar with the "bean" pattern. I do know what dependency injection is; I am not sure what a "bean" is. What might be helpful is an example "bean" implementation of the very first example labelled "a better alternative to". Can you give us the actual alternative using ruby_beans, using the same classes and methods (API)? 
Theodinproject.com is good, it uses ruby monk like someone else mentioned.
You would use the operating system's task scheduler to do this. In a Unix operating system this is called Cron, I don't remember what it is on Windows. Creating it as a .app and launching it with iCal is... well, it probably works I guess? I would use Cron.
Go to hackerrank.com, register and start solving challenges in the algorithms domain.
The Sourceforge incidents pushed a ton of java projects into Github pretty quickly, so its honestly not that surprising to see java gaining ground. Also, US government has started demanding Github repos for their IT projects.
This is the only answer that makes sense. The best way to learn is to build it. The only thing else I recommend is to find a buddy who will mentor your work. Source : programmed for 20 years. Know ruby, python, PHP, c, Java, iOS, javascript, etc. 
This! I finished the Codeacademy Ruby track, Python, Javascript, and HTML/CSS but didn't know what to do after any of those but TheOdinProject has a very good curriculum with open ended projects that really solidify the things you learn from other resources.
&gt;but for certain reasons I don't like it. Really? an explanation of why might encourage people to help you...
It's not listed anywhere in the article but the gem he is referring to is https://github.com/cardmagic/classifier
https://phusion.github.io/traveling-ruby/ Best option I know of.
No, they aren't. Ruby has strong typing (meaning no implicit conversions, so (without overloading) `==` doesn't coerce types. IIRC, `puts` calls `to_s` on its arguments.
For completeness sake, a hash lookup is not done in O(1). It's a hash, not an array...
People should use SSH keys for auth. Period :P
&gt;before it can be scheduled ocra needs to run the task fully, and I don't want it to run a 24 hour task and then start scheduling it. I've no idea what you're saying here. I *suspect* that you're talking about the fact that Orca compilation requires that it runs your application once, which it does in order to determine its dependencies so it knows what to package. And you're saying that your application takes a long time to run, and therefore you think it'll take a long time to compile? If that's what you're saying, there's a workaround: so long as all of your dependencies are loaded early, like they should be, you can just put a line of code in that says "if we're being run by Orca, quit here". Then your compilation only takes as long as your dependency loading, but your full (slow) execution thereafter will run as normal.
In ruby, `7` is an instance of `Fixnum`, which inherits from the class `Integer`. It is not a string. 7 == "7" #=&gt; false The reason that `puts(7)` works is because under the hood, the input is being implicitly converted into a string. 
Any object you pass to puts, it will attempt to coerce that object into a string by calling the "to_s" method. So you can have a custom class of your own that will puts something. class Dog def say puts "woof" end def owner puts "SilverThrone" end def to_s "Manfred" end end puts Dog.new #=&gt; Manfred
This would be my highest recommendation as well. Don't have any idea what to make? Then start with a web scraper that aggregates content from sites you browse every day and stores it to file. From there you can make a simple Sinatra or Rails app to display your daily scrapes. 
uhh ya it is
Hi! I'm the author of the article :D I'm sorry to not have been clear about the gems I used, maybe it would be usefull to add a "Links" section at the end? 
Good article on the subject of `to_s` vs `to_str` and their respective versions for other object types: http://briancarper.net/blog/98/
I can't recommend this book enough. Really well written, and it's really easy to grasp.
I recommend learn to program by chris pine and the well grounded rubyist by david a. black Learn to program has a lot of exercises you can do at the end of the chapter for practice. 
* http://www.codewars.com/ * https://projecteuler.net/
Looks good. I graduated from a boot camp back in April and my demo day app was a job board (www.stpete.io). I haven't had time to play with it since graduation because I landed an awesome job and I'm loving every minute of it. Did you open source this project?
I did. According to wikipedia (and any basic computer science class at uni) (https://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann.E2.80.93Landau_notations) the big O notation is defined as 'it cannot grow further' which can be translated to 'worst case'. Now that we got this out of the way, https://github.com/ruby/ruby/blob/trunk/st.c#L356 this is the implementation code for hash collisions, which are resolved by a linked list. I rest my case. Edit: Array lookup is O(1), not O(n). I am not talking about associative array lookup, because that is O(n) as you say
You know that Hashes can use numbers as keys, right? Why would anybody even bother using arrays or why would the ruby core developers not use hash internally for that? What I think you did was mixing approximations of average with approximations of worst case. The internal hash function will have collisions, and then you usually (as ruby does) have an array to loop through. So, hash worst case is O(n) not O(1). Array lookups are extremely cheap, running with O(1). The insert is what's expensive with arrays.
Start some new ones, personal ones, putting together a portfolio of projects.
&gt; You know that Hashes can use numbers as keys, right? Why would anybody even bother using arrays or why would the ruby core developers not use hash internally for that? Because an Array is more space efficient (unless distances between index numbers are large), or because consistent order matters, or... &gt; What I think you did was mixing approximations of average with approximations of worst case. The internal hash function will have collisions, and then you usually (as ruby does) have an array to loop through. So, hash worst case is O(n) not O(1). I was not talking about worst case at all. I was as sloppy as the comment I replied to since I did not mention that. ;-) So, I talked about *average* lookup times. &gt; Array lookups are extremely cheap, running with O(1). The insert is what's expensive with arrays. Yes, but the comment where this sub thread originated specifically spoke about "hash lookup". My comments only refer to lookups. If you consider filling the data structure analysis must change of course.
$ man 7 socket
Pretty cool approach, thanks for sharing!
Great work. I'm eager to try this out.
Exactly
Currently reading Ruby Under a Microscope which covers a lot of internals. Ruby Metaprogramming a decent followup?
I'm not sure about the overlap but i've enjoyed Ruby Metaprogramming series quite a bit. It's clear and concise.
I guess he might have meant that it is terrible to write and/or read
I would: 1. Put it where it is most convenient 1. Put it where you'll remember to remove it and not accidentally check it in 
yes thank you for the tips on formatting and my error. It was my issue with closing them both with an end. 
You could always create an idempotent rake task
So, some ways to tell how maintained a gem is: Find it's github. (Does it not have a github? Bad sign. is it on rubyforge or sourceforge? Worse sign). When was the last commit? If not in the past year, bad sign. When was the last closed issue or comment on an issue? Look it up on rubygems.org, when was the last release? If not in the past year, bad sign. With open source, you get what you pay for. There certainly are gems that have not been updated in a long time, have been abandoned by their developers, and no longer work in modern environments. I'd be surprised if that's different in other languages. Although perhaps other languages (and common/popular dependencies in those languages) stay more backwards compatible than ruby (and it's popular libraries like Rails), so code that hasn't been updated in years is more likely to still work. If that's what you've found in other languages, perhaps you would be more happy using them? I can't say, only you can. Everything's a trade-off, and we all have our preferences. Certainly some gems are documented better than others. If a gems documentation is not good enough for you, you don't need to use it. There are some old tutorials out there that are outdated and won't be accurate with recent versions of software; the best tutorials might tell you what version of the main thing they are focusing on they cover, so you can check how old that is. _Generally_ ruby projects use semantic versioning, or something approximating it, so a major version change is likely to have incompatible differences, like from 1.x to 2.x, while a minor or patch version change like 1.4 to 1.5 or 1.4.1 to 1.4.2 is less likely to. If the tutorial doesn't say what versions it covers, you still might want to look at how old it was, when it was written, and if more than a year or two old, see if you can find a more recent one. There are also plenty of just plain bad blog posts and tutorials out there, written by people who don't understand enough to teach. I don't really know what else to tell you, not sure what you're looking for. Programming takes some work and dealing with dead ends in any language. But it's been a while since I was a newbie in ruby. Perhaps ruby has gotten especially frustrating in some ways, I dunno. If you like other languages better and find them less frustrating and find yourself more productive in them, then perhaps you should use them instead, indeed. Only you can make that call for yourself. 
Spam please down vote and report
this is beautiful. does it apply for ActiveSupport loggers?
Yes, it should do – ActiveSupport::Logger is just a subclass of ::Logger.
You basically have two options; 1. Write a rake task, then remove it once you've run `rake my_onetime_task` 2. Write a script that lives in `bin/` to do what you want, then remove it. [example](https://github.com/alphagov/specialist-publisher/blob/47347d9d349d9c1a76a496d7cbc4d0a6bcf0db9e/bin/republish_documents). The key lines are: #!/usr/bin/env ruby require File.expand_path("../../config/environment", __FILE__) The top line tells bash to run the script as a ruby script, the second requires the rails environment so you can use it as if it was a rake task.
I got into an argument with a coworker about this, actually. I found some of his scripts that were one off. They were poorly written, which was fine given their nature. I needed a class to do approximately the same things, but with generally better code and interface (and a very similar name). I based my work off of his file and deleted all that I didn't need. He came back a few months later and now he needs his old work. My argument was that all the old work existed in the git repo (and I found him the commit before I deleted his work). He says I should have renamed it with like a "backup" attached to it. I guess it's different schools of thought. 
&gt; is trivial to break out of I'm not so sure about that.... I thought the concern was "we're worried that there *might* be a trivial security hole" rather than "we **know** there is a trivial security hole"!! But the point you're making is totally correct. You should not rely on such a simplistic safeguard to defend against malicious users. It's far too risky.
While I don't see a use for $SAFE in my applications, I do use setuid and setuid to drop from root. And this very well could have tripped me up at some point. &gt; Ruby script is set to run setuid or setgid, $SAFE is automatically set to 1
I actually really enjoy Python for scientific stuff and ML, so this is in no way to detract from Python, but I was genuinely surprised. I've always loved Ruby for its elegance and quick ability to build things, but I always just kind of took it in stride that it was slower than Python. Maybe I've been living under a rock? 
&gt; Edit: I am still surprised it performed better on quite a few of them both in the approximation and the measurement section. "1 : At a glance" and "2 : Approximately" and "3 : Measurements" do present the same data in slightly different ways -- but none of those presentations give the impression that more of the Ruby programs were faster than the Python programs. Please do better than spread gossip.
I'm not spreading gossip. I corrected my earlier statement that "most" of the programs were faster to say that "some" of them were faster in the same comment you are critiquing. Some of them were faster. Not most. I've conceded this point. 
Ya. As I said [here:](https://www.reddit.com/r/ruby/comments/3igvhq/ruby_2_is_actually_faster_than_python_3_on_most/cugaeh2) &gt; At a further glance, in faster program measurements[1] it appears to only be faster in 4 of the programs. It is faster in SOME benchmarks, not most.
Cool. I'll take a look. 
And I've owned up to it. Would you like me to draft you a formal apology? 
You still show this flame-bait post title -- "Ruby 2 is actually faster than Python 3 on most benchmarks". Just delete the whole thing. Nobody cares about your mistake.
$SAFE Level 4 has been removed. 
good find. thanks. Free on my kindle baby.
That's true, I'll keep that in mind.
Cool, thanks!
Thanks for the key lines!
If you use any compiled gems it is most defiantly not safe at all. There are also known and published break outs without external gems being exploited. It is truly a misnomer and not recommended for executing untrusted code. https://bugs.ruby-lang.org/issues/5455 
Hahaha nice! It seems to ignore the first language flag though. $ termit fr ru "how are you?" =&gt; как дела?
I'm an android developer myself, I'll have this in mind while I'm rewriting my model layer :) thanks
 say -vPrincess $(termit en es "hello, my name is randy" | cut -d' ' -f2-)
Don't be ashamed. It was an honest appraisal of the state of things, just not what you thought you were sharing. Personally, performance isn't the main reason I stay with Ruby. I'm happy for our Python brothers that they are doing so well, and it's a yardstick for how Ruby can improve, but I wouldn't want future speed improvement to come at the cost of Ruby's expressiveness. But anyway, no harm done. A few chuckles here and there. Have a great day dude.
Haha thanks man. And I couldn't agree more. 
Ah just solved it: `print (1..10).find_all {|i| i % 3 == 0}` But if you have a better solution please let me know :)
I assume by command prompt you mean you are executing your code in irb, pry, or some other REPL. irb and pry display the result of the expression you entered, so when you say 2, it says 2, when you say something that gives you an array, it displays your array the way puts my_array.inspect would. I don't use Rubymine, but I am sure it runs the code just the way Ruby does without the REPL. That is, your result is computed and returned, but nothing gets displayed because you didn't tell it to. Wrap your snippet between puts and .inspect, you'll see what you are looking for. 
Thanks for the answer! Yes I am using IRB to test my code. What kind of IDE/text editor do you use? I really enjoy Ruby Mine right now, I am also using Brackets for HTML/CSS, mainly because of the Live Preview option and overall its a good text editor. I have tried Sublime, Atom, Notepad ++ but Brackets is my favorite for now.
https://github.com/sstephenson/rbenv#understanding-shims
NOTE: This comment has nothing to do with the book per se, but more to do with a culture of tall claims with respect to programming. Maybe i am a bit biased, but i actively hate people making over the top promises with respect to learning any programming language. Programming is an activity, and the only way to learn it is through constant practise - and no amount of book reading is going to change that - whether it's 2 hours or 21 days or by being a dummy or any similar metric. I suspect more people drop out after getting lured in by the over the top claims and getting struck in some area and giving up on the language.
Yay self-promotion.
*cheats* ? That's just name-calling. Please keep complaints specific: which particular programs and what you claim they do wrong. That way, someone here will be able to tell you that a couple of the Ruby programs use GMP and the task description states: ["In addition to language specific multiprecision arithmetic, we will accept programs that use GMP."](http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=pidigits#about)
CPython like CRuby does use internally GMP for arbitrary precision arithmetic for their standard numerical types. The linked pidigits benchmark in Python does use xmpz and f_divmod functions from gmpy2, which is not a built-in or standard library module - to get better results. *I* call this cheating, because external C-library is being benchmarked, not standard CPython implementation. Btw. By personal experience recent CPython (both 2 and 3) versions have significantly slower method calls then CRuby and when heavily used it may mean ~ 20-30% speed difference.
I would read "!(123 == 123)" as "not 123 equal to 123" Sometimes you see !!(foo.bar) which forces a true or false value for foo.bar even if it was not boolean. I would read this as "double-bang foo.bar" 
This is a pretty interesting topic. I would love to see some example code. EDIT: Also, I hope you are having fun with HL7
&gt; *I* call this cheating As above - *"we will accept programs that use GMP."* [pidigits Ruby #2 program source code](http://benchmarksgame.alioth.debian.org/u32q/program.php?test=pidigits&amp;lang=yarv&amp;id=2#measurements) &gt; significantly slower method calls Does it show up in measurements of programs rather than measurements of method calls?
I don't you if you read my the article that generated this one: https://medium.com/the-engineering-team/pragmatic-clean-code-architecture-2a60ff1c9a80 I gave a simple example on how we create those "validators" and reuse them. Meanwhile, I'm working building an app (that I will open source later) and I'm applying all the concepts and ideas that I've been talking about. It will be featured in the third part of the series of posts :) On HL7... well, I've been working with FHIR, so.. it could be worse. At the moment I'm creating a gem that will allow us to serialize an AR Model to a FHIR Resource with Data Type validation and coercion. I hope it will be useful for the community.
Awesome, thanks for pointing that out. I am not in healthcare anymore, and I have not worked with FHIR. It seems like it could alleviate some of the pains. Good luck on your gem! I think it would probably be a big benefit to the community.
Our validations are mostly performance critical and they use complicated SQL (mostly by using AR relations flavored with joins and groups) to calculate errors. Sometimes, not always. If I move those out of the models, I generate high coupling which I prefer not to have. It makes testing harder too. Ever been in a position like that? And yes, the complex validations need to stay :)
On a phone but AR does some magic with custom selects. It'll do some method_missing magic so if you alias length(orig_html) as length you should be able to call .length on the returned object. That attribute won't come up if you pp it though. 
 &gt; post = Post.select("id, length(orig_html) as size").where("length(orig_html) &gt; 20").first Post Load (0.3ms) SELECT id, length(orig_html) as size FROM `posts` WHERE (length(orig_html) &gt; 20) LIMIT 1 =&gt; #&lt;Post id: 123&gt; &gt; post.size =&gt; 28 As /u/Soliah indicated..
You just need to give your sql computed column a name (`as html_len`) for ActiveRecord to use: post = Post.first(:select =&gt; "id, length(orig_html) as html_len") post.html_len # &gt;&gt; "1000" *disclaimer - I've been using an old Ruby and old Rails version, so for you, I think it'd be: p = Post.where("length(orig_html) &gt; 0") .order("posted_at desc") .limit(1) .select(:id, :slug, :post_uid, :posted_at, "length(orig_html) as html_len" ) pp p.html_len
&gt; &gt; post = Post.select("id, length(orig_html) as size").where("length(orig_html) &gt; 20").first &gt; Post Load (0.3ms) SELECT id, length(orig_html) as size FROM `posts` WHERE (length(orig_html) &gt; 20) LIMIT 1 &gt; =&gt; #&lt;Post id: 123&gt; &gt; &gt; post.size &gt; This is it... i was leaving off the ```.first```, thus unable to access the '.length' alias, because I was calling it on the collection (ActiveRecord::Relation) instead of a single row. This is what I ended up doing: posts = Post.arel_table length = Arel::Nodes::NamedFunction.new("LENGTH", [posts[:orig_html]], 'lenn') p = Post.where("length(orig_html) &gt; 0") .order("posted_at desc") .limit(1) .select(:id, :slug, :post_uid, :posted_at, length).first pp p, p.lenn Thanks rhaikh! 
I haven't used that query syntax much. I guess `order` and `limit(1)` only returns an array of one.