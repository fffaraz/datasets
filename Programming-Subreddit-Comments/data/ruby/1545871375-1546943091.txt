Yeah I don't think I need the brackets but use them for clarity. I actually don't need the variable either. I'm hoping for a one liner that omits the variable assignation. 
Ruby is our core programming language. We tend to anticipate releases introducing incompatibilities and deal with it accordingly. In particular, we tend to expect breaking changes on "minor" updates (e.g. 2.5 to 2.6). Sure, it's a bit frustrating that ruby's versioning doesn't align with what has become a de facto standard, but I don't think it really impacts end users beyond that. Bigdecimal is a library that comes bundled in with Ruby. If both ruby itself and bigdecimal followed semver, it wouldn't be enough to prevent the issue you referenced. The ruby team would _also_ have to agree to hold off on major updates to stdlib components like bigdecimal. So, ultimately, I think the issue is less about whether the rules of semver are followed (or not) and more about whether ruby should be more conservative in it's approach to changes and backward compatibility.
the best programming language is one that will make you the thing you're most interested in. For example if you're into game dev, I wouldn't recommend ruby. The passion to complete a project will carry you through any language. So you pick a language based around completing a task you know you want.
While I understand where you are coming from, the breaking change here, removing `BigDecimal.new`, probably shouldn't be done until a major version bump. It's not holding anyone back. Adding a warning is appropriate ("This method is deprecated"). It's not about preventing the issue because of SerVer, it's that: - `BigDecimal.new` shouldn't have been removed so casually. - There should be a way to signal breaking changes to users via versioning.
you could clean up afterwards if the result could be nil. `[ do_something_1, do_something_2, do_something_3 ].compact` &amp;#x200B;
Yeah but that's dangerous if my first array has nil values as well. 
Thanks!
Pretty fun stuff Brandon! I've enjoyed the article.
If you know you'll be pasting the code into pry on a regular basis end the lines in a semicolon and pry won't mess up the paste. I use this on a few snippets I paste often
Language before frameworks...always
Comparison of the two proves nothing imo since they are both very different from each other. 
But the funny thing is, none of those examples you cite are inherently ORM-dependent. Certainly ActiveRecord has plenty of syntactic sugar to couple your persistence layer ever more tightly to your domain logic, but that's a bug, not a feature. You'll solve the problems you cite in comparable ways on ActiveRecord vs on Sequel/Hanami::Model vs any relational database _if_ you have your layers reasonably clean. Of course, that's where 99.999999% of all ActiveRecord-using apps fall down, but that's another rant. To put it another way, if it's truly ORM-dependent, how is `pat/gutentag` able to support generic non-AR persistence layers? One of the things I've learned after 39-1/2 years in this craft is that I can learn something useful and new almost every day.
This article was going somewhere really cool but the payoff was a bit of a letdown. Imo, it seems just as difficult to write ``` [1, 2, 3].map(&amp;Mf + 5) ``` as ``` [1, 2, 3].map { |x| x + 5 } ``` 
[https://www.reddit.com/r/ruby/comments/a9w8uy/sf\_abusing\_operators\_and\_method\_missing\_brandon/](https://www.reddit.com/r/ruby/comments/a9w8uy/sf_abusing_operators_and_method_missing_brandon/) &amp;#x200B; Oh it does go somewhere fun, I just don't write \_quite\_ that fast :) &amp;#x200B; Though I would encourage looking into the actual gem as it does do quite a bit more.
\_Wait wait wait, how many articles did you just write!?\_ A lot. One more until I hit 30 for the year, so here we go! To be fair some of these were half-way done already and I just wanted to finish them out. &amp;#x200B; SF is a good bit of mad fun in Ruby, hope you all enjoy!
 echo "set enable-bracketed-paste on" &gt;&gt; ~/.inputrc
Is there a way to use a proc or lambda with any of the library like `map`?
I think it will improve the Ruby development process by the core team: it will keep everyone more honest. E.g., if semantic versioned, maybe this release wouldn't be an x.y release, but an x.y.z release. 
&gt; I don't get the "hard to compose" claim I think he means _efficiently_ compose. AFAIK, there's a lot of copying going on.
Not sure what you're asking here. Can you expand on that? 
How would one use a proc, the result of one of these composition chains, in something like `map` or `filter`?
I realized your code samples had the answer I was looking for! I just didn't read far enough, thanks.
I meant hard. Here is a quote from my other comment. &gt;Well, \`\[1,2,3\].map { .. }\` can't really be composed with anything. And I can't pass an argument to \`map\` over which a block should be applied. Say you want to pass an array to map over with \`-&gt; x { x \* 2 }\`. That's not really possible without some kind of utility like I wrote and linked to in the article. Take a look at the gist linked in the end. There are usage examples which may explain this better.
Advent of Code? :) There's a much better way to check the thing you want to check. You're looking for something like this, right? s1 = 'abcdef' s2 = 'abcxef' Two strings identical but for one character? 
codefights ... i think youre right . must be identical but for one character. 
Okay. Does your input contain any duplicate strings? 
Beware, VERY unorthodox Ruby below! 2/3 of this subeddit would call this ugly, but since we with colleagues started to follow latest Ruby features, it allowed us to make code much more clean and readable (though for those not used to new features it initially doesn't look so, but it, in fact, is). What we see here reminds of "safe navigation" operator (available since 2.3), e.g. "perform something on object only if it is not `nil`". So... do_somethin_method&amp;. # ok, what now?.. Now, how to "perform something" on object in a chain-style, if "something" is not object's method? Of course, it is `then` (known as `yield_self` before 2.6, easily added to any Ruby v. with backports): do_something_method&amp;.then { |x| ary &lt;&lt; x } And now, we can "DRY up" the last statement with `method()` trick: do_something_method&amp;.then(&amp;ary.method(:&lt;&lt;)) # or this is a bit better, probably: do_something_method&amp;.then(&amp;ary.method(:push)) # ...and hopeful, once (2.7?..) we'll be able to do do_something_method&amp;.then(&amp;ary.:pus, eh) Now, how this version is "better"? The thing is, having exactly 0 intermediate variables, it shows _the flow_, eliminating the possibilities for small bugs and architectural chaos. Imagine something like this: def something_about_user(user) # ... friends_to_save &lt;&lt; u if (u = fetch_closest_friend(user)) # it is pretty easy, especially in larger method, to write something like friends_to_save &lt;&lt; user if (u = fetch_closest_friend(user)) Note that we push the WRONG user in the last line, but, depending on your testing strategies, you can find about it pretty late, and for the quick review, everything looks OK. With "variable-free" style you are more protected from this kind of errors.
Am I alone in thinking that the Proc#compose example is an unreadable mess? I feel like it's a rare thing when I see people use lambdas in Ruby in a readable manner and this example is particularly egregious.
Interesting stuff, but I feel like it breaks the kiss principal.
I love Ruby... my favorite language of all time... I wish it would have won... but I would not push a noob into it over Python...
Looks good. The only more succinct way I can think of is... ary &lt;&lt; do_something_method unless do_something_method.nil?
I haven‚Äôt seen any good examples of it yet. I poked around last night. What I was trying to get to was proc1 &gt;&gt; proc2 &gt;&gt; proc3, but it took a lot of setup to get there and I couldn‚Äôt find anything that wouldn‚Äôt get shot down in code review. 
I use Scrapy a lot in python, and one of the cool moves it has is building string processing functions for processing incoming data using [item loaders](http://doc.scrapy.org/en/latest/topics/loaders.html). The gist is that it's an object familiar with the various output attributes, and functions to help clean the data. **Pseudocode ahead! See note on bottom This is a very nice context to use function composition, as you can have a default processing chain like `default_processor = remove_special_characters &lt;&lt; strip`, but then also use that to build specialized processors like `name_formatter = default_processor &lt;&lt; titleize`. You now have a very easy-to-understand function that is also very easy to test: `assert_eq "Known Value", name_formatter.call("$$$ known value ")` In Ruby, we could previously do something similar to this, but with a different paradigm, and perhaps a bit more verbosely. Honestly, this is the only type of example I've been able to really relate to. I find the many "look, I added and then multiplied numbers!" examples unsatisfying because I can't help but think, "so what?". However my experience with Scrapy's ItemLoaders helps me recognize the benefit of this. **Pseudocode note! The examples are just pseudocode from my phone; I haven't actually used these `&lt;&lt; &gt;&gt;` things and have had a hard time remembering which is which. Also not sure about the method referencing and `&amp;`ing. I know it's needed in some capacity here, but that's the joy of pseudo code. Surely you got the point!)
Good stuff. I think your approach/design philosophy is making sense to me now. Where I'm coming from: in my experience, programmers of varying skill level and experience will often accidentally poke through any and all leaks in abstractions around concurrency. So, if one provides a team of developers with e.g. EventMachine and you'll find people accidentally introduce IO calls that aren't being scheduled by the reactor loop, introducing huge latency bubbles. Cooperative multitasking requires developers to always take care when they're writing any code that talks to the world outside the ruby process, which often renders the entire approach unfeasible. Node addressed this by prohibiting blocking IO, but I find that often takes code you can read and turns it into code that you can't. Fibers show a lot of promise towards being a very lightweight process abstraction that allows both blocking and non-blocking IO to play nicely with process scheduling, so I'm excited about your work! &gt; The typical one is select. The select system call takes a list of file descriptors and waits for an even to occur for up to a specified timeout (or indefinitely). Ah, I got you now. I thought you might have been talking about select, but since you mentioned it helps with scheduling the processes, I leaped to the conclusion that you were referring to a hypothetical system call that would help determine what process to schedule next (solving the problem of determining which process to schedule first when multiple file handles are ready). Thanks for the insight.
I feel like I can do similar with instance methods. WrapperClass.new(something).strip.remove_special_characters. I want to use new cool shit, but I don‚Äôt see the advantage over the straightforward idiomatic way yet. (Not saying it isn‚Äôt there, just that I haven‚Äôt personally been sold on it.)
Yes, I found this to be one of the most valuable insights from reading POODR. The final chapter talks about testing, and brings up this point. It was the first time I really understood clearly the value of defining a public interface, and supporting the implementation with private methods. 
I *still* need to finish that book. I read a good chunk of it and that alone helped me understand so much more about OO programming. Since I‚Äôm starting to write tests for my programs now, it looks like this will be valuable. 
I used to use "how do you test private methods?" as an interview filter question. I stopped when the number of folks replying "use `Object#send` or `#__send__`" got to be embarrassingly high. My follow-up question was then "what does a method being marked `private` _mean_?" We no longer have the level of gate-keeping in this craft that we did 20-30 years ago. While that's generally a Good Thing for employers (if not developers ourselves), it also means that we're farther from a reliable common body of knowledge (and the formal professionalism that relies on an explicit CBOK) than ever.
running that method is expensive, which is why I only want to run it once.
I just began digging into AWS lambda with ruby. Reading the conversation I managed to built a project to generate the package for a lambda layer with pg and a simple method to create a database connection. So far it works. Here it is: [https://github.com/mphsi/ruby\_lambda\_pg\_layer](https://github.com/mphsi/ruby_lambda_pg_layer) (I'm sharing it with a few friends, that's why some stuff is in spanish). What do you think? Great work. Looking forward for your tutorial!
Nice. I actually just started reading POODR a couple weeks ago because I kept hearing it recommended everywhere.
&gt; My follow-up question was then "what does a method being marked private mean?" When I'm in one of my snarky moods, my answer is "it means the programmer couldn't figure out where to put it." I don't do well at interviews, heh :)
I'm hoping I understand what you're going for. def difference(str1, str2) str1.split('').zip(str2.split('')).map do |duple| duple.first == duple.last ? nil : duple end end def differ_by_one?(str1, str2) difference(str1, str2).compact.size == 1 end I left the nils in the output of the `difference` method in case you need information like position of the differences. It's easy to modify from there.
The number one thing I see people not doing is checking exit status. I add this code to just about every project of mine that shells out: def run(cmd) out = `#{cmd}` raise "Error running #{cmd.inspect}: #{out.inspect}" unless $?.success? out end
True that. It will call the method twice, so not really appropriate if it's doing anything significant. But as I mentioned, you could always.. array &lt;&lt; some_method array.compact!
Thanks for linking that I'll take a look!
Hah. I find this kind of funny because I'd probably assume you were the idiot for asking the question in the first place unless I'd gotten some other reason to believe this was a trick question.
I agree that this is a bad interview question. Knowing that you're "not supposed to test private methods" isn't a good test of whether you should hire someone. Suppose I'm an otherwise good engineer who thinks you should test private methods if they are sufficiently complex. You have a choice: hire me and tell me "here, we don't test private methods because they are *private*" and I adjust my coding style, and everyone is happy. Or, you don't hire me and I go right good code at some other company.
I don't find 'never test private methods' to be a good _rule_, it may be a decent guideline, but not a hard rule. The example in the OP is a good example of when not to test private methods but largely this is because there is almost nothing in those private methods to test, no logic or conditionals just a bit of string interpolation. However this doesn't always hold, often it's a good idea to isolate the complexity of an algorithm in private methods and have simple public methods. This creates a problem where you may have boundary conditions in the private methods that you want to make sure are tested but creating input to the public method that will hit these boundary cases can be very contrived. Looking at the setup for the test case 6 months down the road it's almost impossible to figure out without a lengthy comment. In these cases it's often much easier to test the private methods directly since you can often clearly setup the tests for boundary conditions, it also isolates the test to a particular thing which isn't almost possible with complex input to the public method. 
If something is complex enough to warrant a test on its own, isn‚Äôt that a good indication that it may make sense to be extracted to its own class/module as a service or something similar? (Where it can be given a public interface and corresponding tests)
This is exactly how I see it. The problem isn't just testing private methods, it's the fact that the public interface is apparently too hard to test and something probably needs broken out.
Yes, at least, that's the conclusion of Sandi Metz's chapter on testing private methods (POODR).
I'm trying to organize a book club at my company for it, even though most of our devs don't use Ruby. Second edition just came out a few months ago, and I want an excuse to force myself to re-read it now that I have a lot more experience.
I can understand that feeling. It's hard to appreciate until you have the "oooooooh" moment. I felt that way about all the talk about "Wow! yield_self!!!!" I just didn't really get it, and knew that it was just because I hadn't had the right experience yet. My experience with large scraping projects and data transformation lends a certain appreciation that is hard to express. I would argue that using function composition _can_ be more straightforward in some tasks, but a lot of the examples don't do it justice because they are always so simplified, boring and obvious.
Very good summary. Might want to improve css for mobile browser :)
I know you have been downvoted mercilessly by the fanboys but you are not alone. For the big christmas day release when you hopefully get a release that justifies you hanging with ruby, while the rest of the world marches on, this was underwhelming. I'd rather they just drop the whole christmas day so we must release motivation and just wait and take their time to get out of experimental status.
What sold you on yield_self? 
It‚Äôs seriously the best. My only wish is that she made a followup that builds on that book with more advanced concepts. The way I see it, POODR is an absolute must read once you hit about 3-4 years of professional programming. That‚Äôs when I started to really see the limitations of my skill and started to hit a wall with what I could build. And the only way to break past that is to start working at it.
It feels like an unnecessary abstraction.
Nothing yet! But the conversations I had surrounding it convinced me that I just don't have the right experiences or problems to solve that it becomes relevant in. I think this is probably similar. As a personal aside, while I can appreciate the `&gt;&gt;` feature, and even have some great use cases I'm excited to try out, I dread it a little bit for new rubysists. Ruby is already such a quirky syntaxed language. I'm in the middle of advocating for my co-workers to explore Ruby more, and am reliving the pain of looking at Ruby syntax and trying to make sense of it. (Optional parens, `{|_, thing|}`, `.map &amp;:upcase` etc... `&gt;&gt;` and `&lt;&lt;` add more quirks and "oh that's a special Ruby move", so I'm a bit apprehensive for it overall. 
you could memoize the expensive method &amp;#x200B; \`\`\` def do\_something\_method @do\_something\_method ||= expensive\_calculation end \`\`\`
But can we make it even more complicated and harder to read?
Same here. I‚Äôm pretty sure I can do something with it. But if I can express the same thing in a way that doesn‚Äôt trigger someone else‚Äôs impostor syndrome, I‚Äôd prefer that. I had one thought regarding price composition. I‚Äôve bumped into a lot of metaprogrammig that saves a proc for later. It doesn‚Äôt handle multiple prices well tho. Maybe composing them could work better than sticking a bunch of them in an array. Haven‚Äôt really thought it through. 
A no-magic solution with an inline matcher. ``` describe User do def combine(one, two) eq("#{one} #{two}") end describe "#full_name" do let(:first_name) { "Foo" } let(:last_name) { "Bar" } subject { described_class.new(first_name: first_name, last_name: last_name).full_name } it { is_expected.to combine(first_name, last_name) } end describe "#full_city" do let(:city) { "Columbus, OH" } let(:zip_code) { "43202" } subject { described_class.new(city: city, zip_code: zip_code).full_city } it { is_expected.to combine(city, zip_code) } end end ``` Even though it still feels like an incredibly wrong abstraction.
To save someone else a trip to google: https://www.poodr.com/ &gt;Practical Object-Oriented Design, An Agile Primer Using Ruby (POODR) is a programmers tale about how to write object-oriented code.
This looks good at a glance! I like that you're also using the /opt/ruby/lib path for helper functions.
While I think asking a trick question is sneaky, I agree with what you‚Äôre saying. I‚Äôm looking back at my whole career so far, and frankly we‚Äôre an industry of amateurs. There‚Äôs not a lot of adults in the building and it‚Äôs definitely sad.
&gt; doesn‚Äôt trigger someone else‚Äôs impostor syndrome What a perfect statement. Thanks for the nice chat today.
Not usually, no. Also acting on such a rule would result in a sea of anemic classes. 
Thank a lot for your feedback. Is there a particular issue you had with the mobile website? Thanks again!
The title text line height is too small and the lines overlap. I would say that a bit more whitespace would be nice.
This is fair criticism‚Äîthe example provided is not improved by the changes so it‚Äôs unclear what I‚Äôm trying to communicate. I went for an extremely simple test setup but the fact that the situation doesn‚Äôt need shared examples at all makes it hard to grasp
I like this! A slick way to make a quasi-custom-matcher. I didn‚Äôt know it was that simple. Of course just concatenating two strings together is not a good candidate for this kind of abstraction, it‚Äôs just a contrived example
I like this! A slick way to make a quasi-custom-matcher. I didn‚Äôt know it was that simple. Of course just concatenating two strings together is not a good candidate for this kind of abstraction, it‚Äôs just a contrived example
I don‚Äôt test private methods and I would still answer with `send`. I would just assume that you don‚Äôt test very well, and feed you the answer I thought you were looking for. 
I like this a lot. It's a great use case that increases clarity and terseness. But its clarity seems to rely on the fact that the input and output of all functions are strings. Building off the linked article's example, once you start chaining functions that dance back and forth between different input-output types it quickly becomes horrifically confusing. Maybe that's a reasonable establishment of code smell for chaining procs like this: check that they don't have too many functions of differing inputs and outputs. Sincerely, thanks for this.
What are the security implications of this?
You should send an email to `k0kubun` https://github.com/k0kubun, https://twitter.com/k0kubun and ask him about this.
It will either improve strategy or not affect it. The current file strategy: \`.c\` \`.h\` and \`.o\` files are placed under \`/tmp\` for the life of the Ruby process. They can be left there via the \`--jit-save-temps\` flag. My proposal is to revamp the file handling strategy. One option is to continue to use \`/tmp\` but with stable filenames. So C source and object files would exist in \`tmp\` in between Ruby invocations. I see this as a development environment / interactive use scenario. I don't see an increase in security problems from this. Another option is to save these files in the source tree like many other languages do, in something like a \`.ruby-jit\` directory. I see that as a security improvement over the current file handling strategy. &amp;#x200B;
Thanks! Will do.
Hi. We already discussed a similar idea here https://bugs.ruby-lang.org/issues/14489. I hope you'll join there because it can attract more attention of core developers.
I heard from `k0kubun`, and this issue is being discussed here: https://bugs.ruby-lang.org/issues/14489 
In either case perhaps chmod those files to 0600 so they can only be read by the user who generated them. Outside of the ruby side of things, you might also get some speed ups if you use a RAM disk for the target directory so that the files are stored in memory rather than disk. They may not persist, but if you‚Äôre using a Tmp directory then what‚Äôs the difference in that case... 
The JIT already improves tight loop performance. Whether or not it helps your application depends on the application.
Many Linux distributions already put /tmp onto a tmpfs, i.e. essentially into RAM.
Running Ruby-based Lambda functions with binary dependencies can be a bit tricky because AWS Lambda expects the packages with a specific structure, and because included binaries must be built and packaged to work for the Lambda operating environment. This post describes how [Bundler](https://bundler.io/) should be configured for Lambda and how to ensure binary dependencies are available for gems such as [`pg`](https://bitbucket.org/ged/ruby-pg/wiki/Home) and [`nokogiri`](https://www.nokogiri.org/).
Exactly, I use this technique on a daily basis, and it helps a lot with compounding expectations with an `.and` that otherwise results in several lines of `it_behaves_like`. It is possible to define this as a [example group local matcher](https://relishapp.com/rspec/rspec-expectations/v/3-8/docs/custom-matchers/define-a-custom-matcher#scoped-in-an-example-group), but it comes with a drawback, it doesn't have access to example group variables (the ones defined by `let`s), e.g.: describe User do matcher :combine do |one, two| match { |actual| actual == eq("#{one} #{two}") } end this works, but once you feel that your are consistent in its usages, e.g. something like `combine_first_name_and_last_name`, you still have to pass it the expected values as arguments e.g. it { is_expected.to combine_first_name_and_last_name(first_name, last_name) } which is pointless. While if you define it as a method, you are able to skip arguments, since examples groups variables are in the scope: def combine_first_name_and_last_name eq("#{first_name} #{last_name}") end it { is_expected.to combine_first_name_and_last_name } which is more concise.
It'd be cool to see a real-world benchmark. The problem with these one-off improvements is that there could easily be regressions in other areas.
Right. A very critical person would say that the Ruby versioning is deceptive. There's nothing special about an x.y release vs. an x.y.z.
Thanks for the detail and explanation. For whatever reason it's seemed odd to me in the past to start dropping simple methods into RSpec, so I tend to reach for RSpec's constructs a bit early.
Calling a news aggregator "Fintech" is a bit of a stretch imo.
Seems like this is gets posted here every other day?
I hate to be ‚Äúthat guy‚Äù, but why don‚Äôt you just go ahead and try? Right now it is hard for everyone to gauge what is going to happen, but if you try (maybe one by one) and submit issues on the projects, you might be the pebble starting a landslide. If no one replies to your issues, you have a much better defined case and can come back here to ask people to help with your problems.
Lol üòÇ
Man what thin dependencies do you require, most everything should be in core python. If you‚Äôre in dependency hell in python! You may be doing something wrong. 
Use Python 2.
That's a good point. When you're scraping data, you are ultimately dealing with processing strings so that the values can be successfully cast into whatever data types you wish. A lot of my processing functions/methods cast the input to the expected working type first because of the issue you mention. One bit I forgot to mention is the key to the relevance being in using the `Compose` and `MapCompose` functions which are the tools you use to build that cleaning pipeline. I'll add that in an edit. Thanks for checking it out!
Yes, I haven't though about the /opt/ruby/lib path until I read about it in some article but I liked it. Thanks!
I just see this as a rallying call looking for like-minded people, part of the "being the pebble". Specifically the final note: "anyone ever use these 3 ruby libraries in conjunction?". I think is a really reasonable post, and frankly I hope it gains some traction.
That's fair, and I plan on trying. I'm simply seeing if anyone has experience gluing those three libraries together. No problem with that
These are the dependencies I've wittled down to after working through about 4 other neopixel libraries and the other handful of depsi haven't listed. Thanks for the help
You get me. I like you
It looks like there's an old version of [wiringpi](https://rubygems.org/gems/wiringpi) that might work for you... but there's nothing that seems recent or maintained. I was also thinking since [artoo](http://artoo.io) has some kind of rPi support, you could maybe hack whatever additional support you needed into it; but it also seems to be abandoned. I guess you could give those a shot but honestly you might just be signing yourself up for a different kind of problem. At very least they're jumping-off points if you're dead set on using ruby.
Sidekiq. It comes up in Google searches for Ruby background jobs readily.
They already explained in the issue why caching was not a good idea, but they will work on alternative solutions, like a multi-tiered JIT, so most methods would get a faster tier 1 JIT, and most used methods will move to tier 2. It's really interesting to see how they are working on the JIT :P
Yeah, I came across a lot, Rabbit, Iron, Sidekiq, etc, but it was hard to find which one was the simplest. Will Sidekiq be suitable with all of the workers being vanilla ruby, not rails?
For me it feels more like a guy sticking their toe in to the water and be like ‚Äúis there anyone who knows about wood, Vikings and woodcraft‚Äù because I want to go to America.
'Rubyist' ... Most of us probably had the phase where the language we are most comfortable with is the best. Get over it.
Haha :) Gotta start somewhere?
I am cross-posting my original thread here as I am using Action Cable and Rails. 
There is the problem that asking for the specific combination of 3 different libraries out of a million gems (I have no idea how many gems there are, but even with that number) especially if one of them is hardly used might lead to assholes like me, telling you to please try and do the dirty work for all to follow!
Sidekiq has no dependency on rails. Just take a look at the docs [https://github.com/mperham/sidekiq/wiki/Getting-Started](https://github.com/mperham/sidekiq/wiki/Getting-Started) Sidekiq depends on redis, not a SQL database so if that is an issue you can feel free to roll your own, though I wouldn't recommend it since there are reasons redis works better for background job processing. Resque, the next most popular Ruby background job processing framework also uses redis if that helps solidify that point.
I wouldn't say deceptive myself . I think it just comes down to complacency. as ruby falls further and further behind the community has sold itself that progress and performance is over rated. Syntax is supposed to overcome all - but it doesn't. we went kicking and screaming to node because we needed performance on a couple projects . Hated it, hated it until I could live with it until I thought it was passable , until I thought it was okay until I was used to it enough to think in it until the syntax was second nature. now that I can read Js almost as well as ruby I do the unthinkable. think of doing projects in node when I don't have to. when I see other language upgrades they give confidence the are blazing into the future opening new doors. When ruby updates its giving something (as experimental) that was available years ago in many other languages. 
Personally, I would just learn python. It's better than writing c code and if your working with neopixels on a rasPi, aren't you going to need to do circuit python anyway? Doing something similar on an arduino. My approach is to write the inboard functions in C approach trigger them from serial input. The code sending the serial output is what I would write in my fluent language.
To my mind, OP started with what seems the platform norm until issues presented themselves, then went to his/her area of experience, and next might move on to something else. There is nothing wrong with indentifying platform/ecosystems issues, like dependency issues, incompatibility between language versions, available libraries, licensing issues, performance, localization, preinstallation/ported version on target machines, etc. and looking for alternatives‚Äîespecially early in the project. Familarity and readability do affect productivity. Learning a new language/tool chain is a valuable exercise, but it comes at a cost‚Äîin initial development time and the risks associated with adding another set of tools, dependencies, vendor support, platform interfaces, etc. It seems fair to preface a request with organizational or personal preferences, to a point of diminishing returns.
I don't really think python is that different from ruby. However I'd look at C libraries you can write ruby interfaces for. It's a skill I keep meaning to pick up myself and it basically opens up any library in C. The other thing I'd consider, which is something I'm using for a project. Is writing thin python scripts to pass through commands. Python is just better for machine learning so I'm writing a simple API to a really basic service that just passes on my instructions from Ruby. 
Blub blub blub... Raspberry Pi. GPIO SPI. I think you mistook this for a big project where your point actually matters. Sure his concern is rapid deployment which is why he's asking on a sub reddit which will delay his project by at least a day. Dislike my attitude all you want it still holds true. Just using Python or C would enable him to probably finish same day as started.
I'd be happy to help unwrap some of the complexity. For that one [ws2812.py](https://ws2812.py) doesn't require numpy, it'll just be slower because it's using native code instead of doing fast matrix transformations in c.
What about all the process-specific addresses that are stored in the JIT code. What are you doing about them?
I had no idea this place was as hivemind-y as it apparently is until I read this thread. 
https://www.reddit.com/r/introvert/comments/a5q4g4/im_an_introvert_working_in_tech_support_and/ So, I clicked your name and only had to look at two posts before I saw you talking about being an introvert and asking for light hearted conversation. Take your own advice and be a little more light hearted and kind. You don't have to act like a dick with a chip on your dick-shoulder. 
https://www.reddit.com/r/introvert/comments/a5q4g4/im_an_introvert_working_in_tech_support_and/ So, I clicked your name and only had to look at two posts before I saw you talking about being an introvert and asking for light hearted conversation. Take your own advice and be a little more light hearted and kind. You don't have to act like a dick with a chip on your dick-shoulder. 
You definitely could do this with Action Cable but I would not say that it's significantly BETTER for the backend than using multiple AJAX GET requests. As to the second piece, it sounds like you're confused about the usage of Action Cable in general. It may be better to explore the specific problems you're experiencing. 
Ruby is a beginners language and while there's some very good people the majority isn't even close. If I was sick of it I'd unsub. I enjoyed being reprimanded in the end because it pushed me in the right direction while I was still a novice. Down or up it's all attention in the end.
Maybe this will be helpful (maybe not), but as a terminological point, this stuff refers more to "batching" than "lazy loading".
Looks like this could be really useful for debugging.
I made this a few years ago https://github.com/schneems/rrrretry 
Yes.
Thank god. Some of these CMS' I have seen make use of outdated php like wordpress and wanted to know if I could easily roll my own in good ol' ruby. Thanks.
IMO WebSockets really shine when you want to *push* data from the server to the client. For example, in a chat app, where the client has no way of knowing when a new message might come in. Instead of constantly asking "are there any new messages?" (i.e. polling), the server can push new messages to the client as they're created through a websocket. &amp;#x200B; Of course, WebSockets are bidirectional, and the client *could* ask the server a question, and the server could respond with an answer. That's how you'd use them to handle pagination, which is basically the problem you are trying to solve (i.e. when user scrolls to bottom of loaded data, client needs to request more data to display on the screen). To accomplish that with WebSockets, you'd implement the same frontend logic you would had you not been using WebSockets, except instead of asking for the next page via an HTTP request, you'd ask over an open WebSocket channel. Instead of responding in the open HTTP request, your backend would simply reply in the WebSocket channel. &amp;#x200B; Hopefully that clarifies *how* you'd replace a more traditional HTTP/AJAX workflow with WebSockets. &amp;#x200B; Now, why? Is there some kind of issue that you are bumping into with traditional ajax requests? If so, sharing them would help others point you in the right direction. IMO, WebSockets aren't the right solution here. If the goal is to find a way to show *new* tweets (i.e. tweets that were tweeted since the user loaded the page), then WebSockets make sense (or polling). &amp;#x200B; This line concerns me: &gt;The goal is to instead of transmitting hundreds of JSON's, we only transmit maybe 20 on the initial load and subsequently transmit more if we need to (hence lazy loading). &amp;#x200B; Focusing specifically on "if we need to" - how would the server - the entity taking the action - know when the client *needs* more tweets? The only way for it to know, would be if the client asked. If the client is asking, you could use a traditional HTTP/AJAX workflow as described above. &amp;#x200B; I think in general, we need to know *why* you want to use WebSockets to better assist. I think as others have noted, you may also not fully understand how WebSockets work, or when they're useful. Diving into some tutorials might help expose you to some use-cases. &amp;#x200B;
Oh I get it now. You're just a dick. Your early comment make a lot more sense in this context.
Exactly
Ha... you‚Äôve never tried nodejs I guess :p
Funny thing that while I worked on it, I found several new features aren't documented at all. I managed to fix some (endless range and `exception:` arg to `Integer()`) before The Release, but there are others I unfortunately noticed only last two days :(
This looks like a great resource!
I saw that when I was looking for retry implementations. It's a neat approach, with the enumerable and all. Given that we tend to run this stuff in autonomous service handlers, we need to assert that retry logic is exactly what it says it is when we're testing the handlers. So... more elaborations, like support for the Retry object being used as an injectable, substitutable dependency that records its invocations, allows for injection of a probe, does logging, and the like. I used to have a much more heartfelt relationship with our implementation before we hit the requirements for observability. Unsurprisingly, I really like its interface as compared to many of the retry libraries I'd explored. I think my typical reaction to most available retry implementations was something like, "That API seems like it goes out of the way to look like ActiveSupport". \&gt; Isn't Monkey Patching Evil? \&gt; Yes. Do as I say, not as I do. LOL! That's good stuff. That ship has sailed. But I wish that Rails had not taken monkey patching as its default design ethos rather than something like \`Time::Days.from\_now(days, now=Time.now)\`. Not sure why dot-dereferencing become synonymous with OO in Rails and ActiveSupport, and subsequently the greater part of the community at large. Oh well. Ship has sailed. Eventide runs (typically) entirely independently of Rails, so... opportunity to have the world we wish we had. Anyway, my step is always lightened to see creative uses of enumerators. Yours is cool. 
There are quite a few open source ones you can try or look at for inspiration: http://www.refinerycms.com/ is a particularly popular one
Thank you so much. I will have a look later. :)
There's [Camaleon](http://camaleon.tuzitio.com/) if you want a more full-featured CMS you can hack on, or [Comfortable Mexican Sofa](https://github.com/comfy/comfortable-mexican-sofa) as a basic set of tools to build your own features on top of. Camaleon doesn't get enough love, IMHO, given its goal of supplying everything you'd expect from a Wordpress-style CMS, but I've enjoyed using Comfy in the past as it really leaves things up to you in terms of how you want to put your CMS together. 
I feel like advanced templating in ruby is becoming less relevant with the advent of client-side libs e.g. vue/react?
This is a really great resource thanks for putting this all together! I‚Äôm curious to play with String#split with a block to see if I can get some performance from it If it‚Äôs not allocating an array under the hood. Didn‚Äôt see that change come through until this site. Thanks! 
It‚Äôs possible but to replicate Wordpress or Drupal it will take you years to build. It makes sense to build custom CMS for a specific narrow purpose. 
Does it use ruby in any way? I much prefer ruby over php or node.js
Downvoted... because "Matz is nice and so we are nice".
Yes. Both Camaleon and Comfy are Ruby/Rails CMS tools.
Great! I am going to have a look at those. Thanks a bunch.
A wonderful contribution to the language ecosystem. Thank you. I hope it will get the interest it deserves.
Thank you for your work. The most friendly article about the patch. Reason and discussion links have helped a lot.
The other commenter has already pointed out that it's not a language specific thing but rather an engineering concept Also I don't think you know what you're talking about. Arrays in Ruby are more like Dynamic Arrays: they're still stored next to each other in memory still and Ruby just provides you the abstraction (just like Java's ArrayList I believe), so you don't think about that, but the fundamental concept doesn't change - there are things that Linked List does better than normal arrays You don't need to know how it works to be a good programmer of course, we likely don't need to use a Linked List ever in Ruby too, but understanding it helps you to become better engineer and it doesn't help that you're claiming something is stupid without knowing what it is
ActionCable keeps per-connection state so it'd be pretty easy to say "just give me the next 100" over the socket. However the cost is of a long-lived connection. At scale that'll eat up memory, both on the server and in intermediate devices like load-balancers. In my world, memory's the most precious resource - more than either the network bandwidth of a slightly larger request or the CPU costs of a TLS handshake and HTTP decode. If you using WebSockets / ActionCable as a query or command vector then in a Rails application you'll end up eventually reinventing half of Action Pack as your Channel objects start more and more to resemble controllers. I've been down that road and realised I was off in the weeds when I caught myself invoking `ApplicationController#render` in channel methods. Note also that a web socket is less resilient than stateless ephemeral requests to individual server or intermediate device failure. Sure, Action Cable is pretty good at reconnecting, but tying state to the connection still means the client could now be quietly making incorrect assumptions about data currency and pagination cursors held in the server-side connection object. They also deny the rest of your infrastructure the opportunity to balance requests by load. In general, I try to use WebSockets minimally, for when I need to push notifications of data changes, and the data fetch is still an AJAX request through the front door. 
Good job
I agree that in *practice* it seems that Vue/React is taking over a lot of the view logic. However, as both a user and a programmer, I think people reach for Vue/React too quickly without realizing all of the advantages of server-side rendering. There's just another level of complexity involved with client-side rendering that completely goes away once you have (1) direct access to the database and (2) a simple request/response-cycle. There are certainly places where Vue/React is worth it, but I don't believe in a future where app is a single-page application. Tubby is kinda my way of providing a developer experience similar to React in Ruby, and I hope that it makes it easier for programmers to write composable, maintainable templates.
Thanks!
Thanks!
Freakin awesome thanks for doing this. 
Yeah, one of the reasons I did it is for myself: to understand deeper what've changed and why. TBH, it was much harder, but also much more educational than I anticipated. On the road I've found, as mentioned above, several features that lacked documentation (fixed some, working on others today), and also some of the questionable consistency -- `String#split` is the example of the latter. I'd really prefer it would be implemented in some `Enumerator`-enabling manner, not just an orphan "enhancement" with weird behavior.
Thanks!
great job! üíØ thanks!
Especially the discussion links provide such valuable insights, thanks!
It is certainly doable. There have been a number of different tools for this over the years, and I'm afraid I haven't been staying abreast of them, but you could try this: https://github.com/pmq20/ruby-packer
Thanks I will check it and try to making it work using a docker container.. Since I don't want to have heavy compiling things in my machine..
I've absolutely used nodejs. I hate npm dependency management as well. Yarn is slightly better at more reliable deployment, but it still sucks Gem dependencies are just the least shitty of all dynamically typed language dependencies. Bundler is the least painful tool for management. Personally, I only develop personal projects using bazel now
Hello, Thank you for your tool.. I have some ruby scripts that do basic bash-like stuffs in terminal (prompting user, manipulating files, executing bash commands).. Is it possible to use your packer for that? For example, considering I have this simple ruby file `your_name.rb` *that have all these kind of actions*: #!usr/bin/ruby # your_name.rb puts "What's your name?" answer = getc.chomp File.open("your_name.txt", "w") do |f| f.puts answer end %x (touch not_in_this_file.txt ) If I use your packer, will I get an executable that will give me the exact same result? If so, is this the command I should run: rubyc ./your_name.rb ./your_name.out Then, I can use this file in other machine that has not ruby installed simply by doing: ~/&gt; ./your_name.out Do I understand well the purpose of your packer? Thank you again!
I **love** what you‚Äôre doing here, /u/judofyr!
It's not my project, I only wrote about it, but yes, you can wrap your scrips to be separate executables. Only you need to do it per script so if you have many scripts the final size of all of them would increase significantly.
Thank you very much!
Documentation is an area where ruby really needs to improve. The documentation is not terrible; but it is not great either. When people learn more from blog posts than from official releases then this says a lot. :\ :{ :/
I think you gave conflicting goals, such as "lightweight solution". The only solutions I can think of include packaging ruby as-is. It may be possible to compile just one huge binary blob perhaps and ... transfer this to a remote server. :P &gt; It seems that this exact need is addressed with &gt; Traveling Ruby. But above you wrote lightweight. How is this "lightweight"? I do not use shell scripts myself; I use only ruby. But .... we have to be objective - a shell script will be more lightweight if bash is already installed and available.
Docker????? Did you not write above of a lightweight requirement? Here: *How I can easily and with a lightweight solution execute my ruby script in these cases?*
Would be quite cool. Perhaps we could do a dry run, then just re-use this lateron; a bit like ccache works. Admittedly this is all way over my head and I fear that I may not be the only one here. We should avoid making the mjit so difficult that only a few understand it and the others have no clue what is happening.
(irb):1: warning: We plan to remove a syscall function at future release. DL(Fiddle) provides safer alternative. Hmmmm.
What's wrong with just using the build-in `retry`? ```ruby begin do_something_that_might_fail rescue =&gt; e retry if should_retry(e) end ```
Sorry, I did badly explain myself.. In my development computer I have, ruby installed obviously (like python and other important stuffs).. For running scripts that are simple (just prompting in the terminal, and dome file manipulation and system command execution, really a bash replacement) the default ruby (or python or whatever) is fine.. But I don't use them for projects that require more than that (like rails for ruby).. I'm developing everything within docker container and it's really not that complicated.. My purpose is to have at the end something like an executable of a ruby script, that I can share and execute without the need of anything else (no ruby nor docker).. However, in order to get that file I can use the required toolchain ***in*** a docker container.. In this case I will try to get a functional image of that ruby-packer in a docker container, and fire up the command inside the container.. The resulting file will be available at the end. And I can simply get rid of the container.. I hope it makes sense now.
I agree with all you said.. And this is why I'm a little sad.. Meantime I watched [this presentation](https://www.youtube.com/watch?v=1mme7HiLqzA) of the author of that ruby-packer.. He gave an example with go.. where the go toolchain is able to produce a simple binary from the source .go file. Nothing else, nothing fancy.. I now that it's compiled and so on.. And if for simple file manipulation, I end up with a file of dozen of mb, I'm not interested.. Traveling Ruby, appear to be complicated to be used simply (like what go is doing) but I think that the resulting file should be lightweight. It doesn't matter if I need to have a huge toolchain in my machine in order to have that "executable".. And know I just think about it.. Isn't ruby itself an executable? What I need, is either an executable file, or a lightweight executable interpreter I can use with my ruby file. In the first case I could transfer the executables, in the second case I could transfer that interpreter with my .rb files, and after my .rb files are ran, I could get rid of that executable. What I want to avoid is to install some kind of toolchain, package, etc. in other machines.. A simple analogy with a software in the windows world is that I don't want the installer but a zip of the executable (like a portable app).. Now, I can make my scripts with bash, but really, there is no comparison at all between what I end up with ruby and what I should end up with bash, sed, awk etc.. (yet if I manage to write them) I hope my need is more clear now.
Have a look at Crystal, which is very close to Ruby in syntax and compiles. It is not exactly the same but for simple scripts it might be enough.
Hi, In fact I already "played" with crystal some times ago.. And I even [asked for this](https://www.reddit.com/r/programming/comments/8utjtr/crystal_0251_released/e1j00qt)! But I struggled a little with the "type" thing (and yet I'm a former C programmer) and in my case performance is not really a concern, so I prefer to stick with ruby... But I will give it another try..
I'll probably get downvoted for this... but stop doing it wrong. Learn to sysadmin better. Not only should you be comfortable in bash, but package managers exist for this very reason. 1. Put desired ruby rpm/deb in your repository. 2. Install it from your repository to whichever desired servers. 3. Look into config management so you can just do something like 'yum_package ruby' and the box will always have it installed. Also... learn Bash. You will need it. 
Why downvoted? I just upvoted you :) Thanks for taking the time.. In fact, I know bash a little, enough to do the basic things.. But I know that I don't know it enough.. But I mostly talking about not bash itself but all the surrounding tools (awk, sed) and many many other tools that can be difficult to master.. I don't pretend I master anything anyway.. I've also already planned to take a look at Chief (cool it's ruby) and Ansible (seems to have more traction) because in a way I believe that some of the tooling I'm written in ruby could be managed by these tools (not sure though). But after thinking about this need (having some custom script running in other machines), I'll finally go with the simplest solution, installing ruby with the package manager of the distro... I checked with fedora, ruby download size is 3,9 Mb with an installation size of 14 Mb.. I think this is simply the best thing.. Ruby is available for all the distro I know with a one liner (which might not be the case for many other tools) and I will keep making my scripts without pulling my hairs ;)
Very instructive. Thanks!
Nothing wrong with it, per se. But the devil's in the details. For example, what's the implementation of `should_retry`? Inevitably, it will end up being a state machine. So, the example is a solid illustration of the _use_ of a retry implementation, but the implementation can't be assessed for fitness without providing it as well as its requirements. If the requirements are that the solution should be generalized so that its use is consistent across many common use cases, then inlining the solution using Ruby's `retry` keyword wouldn't be a good fit. Ultimately, the code block above is an example of the _use_ or _client_ of a retry implementation. I'm not in a position to provide an informed response without knowing what the implementation is. It would be like me asking: What's better, `Retry.()` or `retry if should_retry(e)`. An example of client code is ultimately insufficient for that assessment. Also, what provisions are provided for assuring with tests that the logic retries as expected? How are backoffs specified? How are number of retries specified? The `should_retry` implementation, of course, can be elaborated to account for all of these things. But then we're right back to the considerations of whether the ultimate implementation should be a generalization, and packaging and distributing it. In the end, it's about requirements. In some cases, in-lining retry logic can be a good answer. In others, it's insufficient. For context, here's an article on doing retries at different levels of autonomous services written in Ruby: [If at First You Don‚Äôt Succeed: Retries in Eventide Microservices](https://medium.com/eventide-project/if-at-first-you-dont-succeed-retries-in-eventide-microservices-865d08914cee)
What's the rubric for categorizing classes as anemic?
I wonder what can be done to makes Ruby easier to contribute to in terms of all documentation and implementation. Moving to Github?
I love the API you chose, /u/judofyr. Explicit, but still very concise. I've been working on a gem that also tries to provide a React-style DX in Ruby, and I like your design better for rendering just HTML. It's amazing how many approaches Ruby makes possible. Would love to know if mine make sense to you: [https://github.com/chrisfrank/rack-component](https://github.com/chrisfrank/rack-component) &amp;#x200B; Please feel free to ping me on Github if you're ever looking for collaborators on Tubby . It seems like a delightful codebase to work on. Also, just wanted to flag that the link to the Tubby repo on your blog post 404s because it has an extra \`/tubby/\` in it.
I believe they are against moving to GitHub because some of the core guys are strictly pro-open software, and GitHub is commercial proprietary service. Though, I don't find contributing via bugs.ruby-lang.org that hard (and lately they are mostly OK with GitHub PRs, especially if it is PR **plus** ticket in Redmine). The decision process is a bit slow/chaotic, but generally it is not hard to get involved.
My experience of TDD over the past 20 years is that there's a lot that was known and knowable earlier in its history that is known now. Especially with regard to its concern with design rather than testing. I don't think I've typed out the word `private` in any language I've used since the early 2000s. You could probably grep for `private` in the entirety of the Eventide codebase and not find more than a few instances of its use. The ultimate issue is one of cohesion and composition. A class with a significant number of supporting methods that don't correspond to a class's principal purpose suggests that the class should be decomposed into other classes that are cohesive to a principal purpose. If you find yourself needing to test methods that support a class's principle purpose, then the tests are trying to tell you something about the design. Namely, that there a concern embedded into some class that is significant enough to be in its own class. It's that significance that is one of the most important inputs into the decision of when to create a new class (Note: It's _one_, but not _all_ inputs). That _significance_ that is signaled from client code (aka: _test code_) is the design assessment that is TDD's entire reason for being. The whole point is that we learn more about the design of something by exercising (aka: _testing_) that something. There's much undesirable in any design that goes right under our intellectual radar until we get tangibly in-touch with our designs through exercises (_tests_) of them. That's the only thing that TDD is for. If that's not where out head is at when doing TDD, then we can say that we're doing Test-First Programming, but not Test-Driven Development. Not that Test-First Programming is necessarily a bad thing, but it leave a lot on the table. So, how would I test private methods? I'd change the design until the use of `private` is no longer relevant. Experience suggests that the design that I end up with at the end of the design refinements brought by cycles of TDD and Refactoring is better, easier to work with, easier to understand, and easier to elaborate upon are better than what I started with. There's a common realization that happens along the TDD and Design Principles journey in regards to private methods: The designs that you end up with are largely unthreatened by a method that might have otherwise been private being made public. Making a method private is a matter of risk assessment: IE: What will be the harm in not making a method private? The other facet of all this is that classes should have an obvious _published_ interface. That's not the same thing as a _public_ interface. The _published_ interface is the one that is obviously the one that a developer should be interacting with. Its should be obvious (and ideally documented) so that it's clear to a user that there's a principle entry point into a class. When a class suffers from low cohesion, this single, principle entry point is not clear, and that's when we get into the kinds of troubles that push us toward using the `private` keyword. The kinds of designs that result from these design refinement processes often tend to leave methods public. The reasoning is this: _This object has such a tight, cohesive focus that if a developer were to actuate methods that aren't part of the published interface, then the repercussions are going to be contained; the blast radius is tiny or negligible, and the undesirable outcomes will be immediately evident through testing. And most importantly, the user might have a valid use case that I can't possibly imagine or predict from my vantage, so I'm not going to make it harder for the user to leverage the things I've built._ Said otherwise: If a user needs to paint outside the lines in order to address a use case that my code addresses but that I couldn't originally conceive of, then I'm not going to make it hard for them to leverage things outside of the _published_ interface. I will accept that such a user in such a circumstance is operating in _expert mode_, and that they are comfortable running with scissors and assuming liability for the outcomes. Especially because the cohesion expressed by the design naturally and obviously limits those outcomes.
Is it really so easy to call (or write) C functions from Ruby? I thought it required a lot more overhead and wrapping code! Does it remain so easy also when having to deal with non trivial pieces of C code? For example I was thinking about the TensorFlow ML library. Yes I know that someone was currently writing an official wrapper for it (as a Google Summer of Code Project), but as it's not ready yet this could be a fun way to experiment with FFI... unless it doesn't get too complicated?
&gt; and many many other tools that can be difficult to master.. You'll find you dont need to know every little bit of awk or sed. As you use it you'll find little tricks. Like finding the last column when there are a dynamic number of them. As you find the use case you figure it out and stash it somewhere for next time. &gt; Chief (cool it's ruby) and Ansible (seems to have more traction) because in a way I believe that some of the tooling I'm written in ruby could be managed by these tools (not sure though). I love it. And I'm right there with you. I used puppet for my last job. It was nice, but the DSL you write is kind of limiting. But the puppet dashboard kind of just works, which is nice. The next one I tried was chef because I'm a ruby fan. Currently we manage 6k servers using chef, and its fantastic. I use it to designate what packages get installed based on the assigned role of the server. I also lay down configuration files. The cool shit is you can create attributes, or use the default metadata. For example let's say you want to lay down a config file. But your ip address is part of it. That would differ per server. But you can use a template, and access the box metadata(ip/host/etc) to fill it in for you when it writes the config. &gt; installing ruby with the package manager of the distro That sounds like the easiest solution for now. But what you should do next is get a free account from hosted chef, and start playing with it. Dont worry about writing any ruby when you do it. Learn proper config management with chef. Only use pure ruby in recipies if you absolutely have to. The reason being, I did that too. Order of operations will fuck you. Pure ruby is interpreted first. So any actions based on a resource that's 100 lines earlier... wont actually work until the second chef run... which is a pita for my particular case. 
Something I haven't seen anyone mention is how to handle rotation of secrets in the Rails code. Obviously, a restart could do the trick, but that seems brittle to me. I'm curious how people are dealing with this...
Thanks for this feedback... A friend of me (that is a redhat instructor so maybe biased) recommend me ansible, but I'm not sure.. Anyway I will give it a try for sure..
Maybe try https://github.com/mruby/mruby if you can live with the limitations.
Yea, those redhat guys sure love their python. 
&gt; But I mostly talking about not bash itself but all the surrounding tools (awk, sed) and many many other tools that can be difficult to master.. You don't need to master them. For instance, this covers a very small portion of awk but will be incredibly useful: http://gregable.com/2010/09/why-you-should-know-just-little-awk.html
Thank you.
Thanks but I don't want to check if I'm using or not the restricted set.. And finally it seems that ruby itself is quite "light" and it's not something that will clutter the OS..
Lambda function that is triggered on credential rotation that does a rolling restart in k8s. k8s doesn't have native support for this but you can just setup an ENV variable and assign it a random value to trigger a rolling reboot. 
That's a useful bit of knowledge. I'll remember that for the future. Using ECS right now but January is the month of EKS for my team..Thanks!
I don't have experience in writing extensions using ffi. There's, however, a [list of projects](https://github.com/ffi/ffi/wiki/projects-using-ffi) that use it to write other gems.
I downvoted you because that's not the correct answer. Sometimes you cant just "install" the runtime you want to. Especially in large heterogenous environments that's almost never an option.
&gt;He gave an example with go.. where the go toolchain is able to produce a simple binary from the source .go file. Nothing else, nothing fancy.. I now that it's compiled and so on. It's anything but not fancy. It's actually pretty hard to get it right. The rest. No you can't. The closest you get would be mruby,Rubinius or GraalVM with Substrate.
Not sure why you feel that way. If you maintain the fleet, mixed or not, then you control the repo. If you control the repo, and you can build packages, the sky is the limit. 
This is nice - more alternatives are always good - but I think what I am unclear is the why it exists? Is it due to GPL versus BSD? The amount of code, aka lines of code, is not really an issue for downstream end users. Of course I get why fewer lines of code for the same or almost the same functionality are great; I am just not completely sure as to why linenoise + bindings exist here. Aka the use case, from an end user's point of view.
Because you dont always control the ‚Äúfleet‚Äù. And even if you do getting the same version of ruby working on hpux,aix,solaris,linux and windows is quite the task. Lots of systems are mission critical and should not get polluted by unnecessary runtimes and other pkgs.
I didn't realize bundler is now part of the standard library. That's cool.
Use mruby. You can compile your mruby script to a standalone executable.
This seems to assume that abstraction is good. Don't build an abstraction unless it's _very clear_ it's a meaningful and useful one. Abstractions are barriers of entry for anything reading your code, it's added work for them to understand, don't force people to understand abstractions unless it's really needed. 
Trying to 'score' code is a bad approach. If you need examples of what anemic class bullshit looks like: https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
It's pretty good as scripting, and is still very nice in the web application arena. 
&gt; I want to know what can Ruby actually be used for? Anything - it's a complete programming language. Web programming, systems programming, graphics programming, logic programming... &gt; what language does one progress to after learning Ruby? There's no ordering of programming languages like this. You can come to Ruby from any language, and you can go from Ruby to another language.
If docker is running on the remote servers, you could build a docker image of alpine + ruby + your script + any gems you need. Smallest image I've seen for ruby+alpine is 25-30MB. (Which might already be too heavyweight for you, depending on your use case.) But I've also run into a bunch of problems where you write a script assuming version N of ruby, but the server you're running it on has a much earlier version. Or you want to use a gem, so now you have your script + some version of ruby + some version of a gem, and then Bundler gets in the mix, and all of a sudden you're in dependency hell. If you throw it all in a docker image, you know know exactly what runtime it will execute in.
It absolutely should not be difficult getting the same version working. Ruby is production software. If it doesnt compile on one of those then you need to be submitting an issue. You should check out travisci, it would be a pita to setup initially but once it's done, it shouldn't require much maintenance. As far as the software that goes to environments we dont control, that's why you have "supported distros". When you get enough demand, you add more. But so far rpm/deb/source has served us fine.
Agreed. Asking what language to go to after Ruby is like asking 'what tool do I learn after I've learned to use a hammer?' different tools are for different things. Although most programming languages can do most things, everyone is better at certain things. You could cut a board with a chisel, but you'd be better suited with a saw. But much like programming languages there is no order in which you need to learn tools, you learn them as you need them, or want them. 
Here's one I made a while back: https://github.com/Freaky/ruby-reattempt/ Just a couple of Enumerables that do exactly what they say on the tin and not much else.
I would like to use this for Pry (and maybe find a way to make it work for IRB). This library may be useful for those who didn't compile Ruby with Readline support and don't wan't to use rb-readline or whatnot. It also will be easier to beef it up if needed (there are forks of Linenoise that add certain functionality). Readline is set in stone and there are some issues with it: * https://github.com/pry/pry/issues/493 * https://github.com/pry/pry/issues/1275
This is honestly super exciting to me! As someone that's been making major efforts to breaking the standard Rails paradigm for what rails application architecture can look like, FaaStRuby looks like it could be an invaluable tool in bucking that concept further! Also, I'm very much a growing Crystal fanboy! So the fact that I can mix in my new favourite toy too and help develop the concepts around it's use is a boon! Will definitely be trying out both sides of this in 2019!
RabbitMQ is a broker. That's kind of an obsolete technology, to an extent - not because it's not new, but because it can be made largely irrelevant by design. Predictably, new patterns incorporate learning from the past decade that wasn't (couldn't be) taken into account when RabbitMQ was established. It's a real boon if you have a legacy integration problem, though. That's where it shines. Something to take into account with messaging technologies that are based on sending a signal (eg: an ACK) back to the message queue that says that the message has been processed: Those ACK messages have no guarantee of arriving. So when that happens, the processor's implementation needs to be prepared to detect messages that have previously been processed (aka: idempotence). In your case, because you're describing a scatter/gather pattern of many things that will happen, the potential for re-processing is a multiple of the number of different parts of the process. There's no solution for this that can be built into tools, by the way. There's never been a "simple" messaging tool that can guarantee that a processor will receive a messing _at least once_, and that can protect a processor from receiving the same message more than once. Anyway, just something to keep an eye out for.
Always nice to see eth being used in other communities 
Thanks! Rack::Component looks interesting. I haven't thought about the idea of using plain string interpolation for templates, and I must admit that it has some merit. My initial concern is (1) how to do automatic escaping and (2), not surprisingly considering the focus of Tubby, how to make them compose nicely. Feel free to open issues on the Tubby repo if you have ideas, but I'm trying to keep the API small and tidy. My dream is for it always stay on version 1.0. My next plan is to write a Rails plugin (as a separate gem) to make it more practical to use there.
Hm yeah, I think you are right. However, trying out something and then asking about specific questions usually gets you better replies and less people saying stuff like ‚Äúwhy not try‚Äù :)
What is the pricing like for FaaStRuby? I'm trying to figure it out from the site, but I think I'm missing something.
The platform is free to use at the moment. I plan to add some extra features that will be subscription based, for example more powerful function runners, some storage space, database instances (like heroku), etc. First I am just watching to see what the usage look like, so it can help me decide what‚Äôs best. The one thing I am sure of is: I want to always keep a free tier to support the community. I am also working on a self hosted revenue model. I will be speaking at RedisConf2019 in April about the platform, so I need to have all those things sorted out by then. Thanks for your question!
Thank you for your kind words! Please let me know if you have any questions, and suggestions are more than welcome!
Ah very cool!! I'm pretty excited to give it a whirl!
&gt; I want to know what can Ruby actually be used for ? I use ruby for literally everything. And I mean everything. I never understand questions that ask for specific domains. Why would ruby be limited? The only limit I can concede is speed, e. g. C will be faster - no argument here. But ruby is a lot more fun; simpler to write; faster to write. Note that I use ruby for the www too well without rails or any of the other frameworks. In fact, I came from PHP and ruby replaced all of what I was using PHP for. PHP is a horrible language. &gt; How relevant is it in the job market today and what language does one progress &gt; to after learning Ruby ? I have no idea because I don't learn languages for job market. That way I would use php and I would hate it. I think if you are capable in any language at hand, and enjoy that, then you will succeed anyway. Just build up a portfolio in a language you enjoy.
Remember on reddit there are people who recommend to learn all the languages. This is the mantra of "use the right tool for the job" which I never understood. I never understood why I would have to learn inferior languages, for example. Or how I could learn lots of languages AND use them when my time is a limited factor.
I think it depends. To me personally the API is not bad but it could be shorter. I like the focus on templates though. That could be extended e. g. let people choose from default different templates they could use quickly, within tubby itself (a bit like a "homebuilder" webpage application).
That is bad IMO because the less you use ruby, the more you will use ... *Javascript*. Which is exactly what your comment is about since you suggest e. g. react.
Good! Don't let these poor souls fall into the hands of the JavaScript monster. They will curse the day they become a JavaScript zombie-addict. I am not even kidding here. I've seen ruby projects such as go to Dart primarily because of the possibility to autogenerate javascript code.
The lemur is playing with stuff again - instead of writing real code ... :P
Nope, you are not alone at all. I expressed this myself including the bug tracker. I think it is terrible syntax shit and it is unfortunate that it was added. But I am not in charge of ruby so ... plus I can avoid it, so I don't care what OTHER people do. But yes, it is quite terrible, especially the "&gt;&gt;" and the combination-use of several &amp; in the same line. There are some strange ruby people who use other languages, functional languages in particular, and they propagate what they like and use into ruby. But feature-translations don't make as much sense 1:1. Elixir is a good example. The |&gt; is ok in elixir but in ruby it does not translate that well because the syntax is not the same, even if elixir was inspired by ruby. I feel that a lot of SOME of the ideas, not all, but some, in the last ~3 years presented by some people should have been flat-out rejected. Note that I am a bit worse off than you are, since you say that you feel that lambdas are readable. I don't think they are really, even worse, the "-&gt;" always was shitty and now it is elevated to even more shit with -&gt; &amp;: &amp; &amp;: &amp; &gt;&gt;. Now we have entered perl 2.0 stage in ruby. But ok ... the cut-off phase for me is that as long as I don't have to use any of these changes, I don't mind so much. I only want to keep the code base that I use in ruby sane and clean. And documented. The older I get, the more oldschool I become. :( (It's really just half a handful of people who suggest these terrible syntax-changes, most of who come from Haskell, scala etc... - we really need to stand united against these clueless folks there.)
I don't think anyone is encouraging you to learn all the languages, there's hundreds of them. But for example I was doing something at work the other day, we work in a Java and JS stack. I needed to add like 58 constants to a Java file based on values from an excel spreadsheet. I didn't want to do this manually, because it wouldve been tedious, slow, and I probably would have made mistakes. So I decided to write a quick script for it. Surely I could've done this in Java or Javascript. But Javascript tends to be clunky and slow down development (IMO), and Java is really verbose and I'd probably end up writing 120 lines just to do this. I wanted to get it done fast so I turned to Ruby. I grabbed a gem for excel spreadsheet reading, and had the script done in about an hour. It was like 25 lines of code, maybe 40 with whitespace. And it was easy to manipulate for other purposes, I came back to it later and used it for other things related to the ticket I was working on. This is an example of using the right tool for the job. There's certainly very little need to learn some languages that are 'inferior' as you put it. There aren't many people that are gonna recommend you learn Visual Basic these days. That being said, you should also view learning languages differently. The things you learn when you learn a new language aren't limited to that language. I.e. What you learn in one language can be applied to other languages. Working in a language like python or ruby will make you better at list comprehension type operations and that will transfer over to Java stream operations. For another example when I learned Ruby I learned of (guard clauses) [http://wiki.c2.com/?Guard Clause], which I now use extensively in Java. Even so, if you find that you have extra time just lying around (ha) learning an 'inferior' language will probably still be educational. If you learn an antiquated language and you can't figure out what makes it antiquated then you've got a problem. At the very minimum it's interesting to see how different languages tackle different problems. 
I think it is ok. For me personally rails was too boring. But I can not argue against the end result. The end result can be very nice. I know that because a local university uses RoR for all aspects related to the www; and I can compare it to about 4 other local universities which use another system. From the usability point of view, the RoR system is the most elegant. It is not the fastest, but usability wise really great. My biggest gripe with the www in general is how utterly boring it is. I can not understand how people endure this painful boredom. Ruby is great but RoR is boring like most of the rest of the www world.
This looks really cool! Happy to give it a try for production projects, would need to get some ballpark idea on pricing before committing.
If you don‚Äôt mind me asking, what are you using under the hood for FaaS component? OpenWhisk, Kubeless, OpenFaaS, Fission etc? 
You're welcome, hope it helps :)
None of them. I've built this platform from scratch!
Well at the end of the day I think whatever cost it might have will probably have to fit the market!
I wasn't really looking for examples. I'm interested in whether "anemic" is something that can be distilled as an objective metric, the way that complexity, coupling, abstractness, stability, etc, can.
Hi this is really awesome! Thanks for your hard work. 
I see Reddit (and the internet generally) as a power amplification factor, where we're able to leverage eachother's experience to avoid falling into the same traps as somebody else. As long as there is a critical mass asking smart questions **and** contributing helpful replies then we can create a flow of information to empower everyone. In this case I've done the leg work to code my project in Python, hunting through a few dozen libraries and wittling down to the free that are useful. Which I've shared back with the community by linking in the post. I've also done the legwork to find the Ruby libraries that I think will act as drop in replacements for the option libraries. That was also an hour or so of hunting. Now, before I go an spend another dozen hours (plus or minus) I wanted to know if there was anybody in the community that's ventured down the path of working with GPIO and SPI in Ruby. Obscure enough to be difficult to find a relevant post or stack overflow q/a, but not obscure enough to be totally unrealistic to think someone here might have looked this way as well. I don't believe every post needs to be as specific as "I'm trying [x] code and getting [y] error, please help". In fact, those a very small scope problems and will help fewer people than a more general discussion like this would (if it had actually generated some more concrete discussion). Also, those posts tend to be made much more often by a novice unable to simplify and debug something in their own environment. In any case, sorry for the ramble. Have a good day friend
The Lemur is on vacation, so he's allowed to screw around a merry bit :) 
The big advantage of Ruby is that it will allow you to practice some fairly advanced design patterns early on. For example, I built an ORM in Ruby only 2 months after I started coding. Good look doing that in C++ without years of of experience. Ruby is a great language for learning to program. Whenever I am faced with a daunting problem, I implement it in Ruby first. Then it's fairly easy to re-implement it in whatever language the production system is using. Ruby has really accelerated my learning curve in that way. As for the job market, what languages you know isn't as important as it used to be. And it will become even less important in future. Languages are constantly evolving, and the trend is that they are copying from each other to make up for their shortcomings. Eventually, all languages will be good at pretty much everything. The trend of virtualization also means that the choice of language will no longer be dictated by the platform you are using. Learn Ruby really well, build lots of projects, then it will be easy to progress into most other languages. 
Alright thanks for the feedback! I'm just trying to get myself upto speed as I haven't studied a CS degree, it's all self taught and I want to make my skillset as good as possible.
Gotcha! Thanks
Thank you for your kind words!
Great, thanks!
Does it run \~250 faster than serverless Ruby hosted on Amazon too?
What is the use case for this services would be useful for those haven‚Äôt explore in this area.
Indeed, almost in every server I want to do some stuffs using my scripts docker is or will be installed anyway, so the first I thought about was to run my scripts through a temporary ruby container.. As you said, the lightest ruby (eg. 2.6) is "only" 22Mb... I could pull this image and run my scripts, if I'm sure I will never run them again I can delete the image, or simply leave it, I don't have yet space constraints in the servers.. The problem is that, most of the times my scripts edit and handle some files but I'm not always sure which files they will be. So in order to get my scripts working when running in a container I think I will need to make a shared volume for almost the root (in the host side).. Which I'm not sure if it's a good idea.. I can do some analysis in order to constraint the shared volume to the minimum.. Depending on which are used in each script and share according directories only. Maybe, the directories are not that much spread so this is a complete viable solution in my case.. Thank you for pointing it.
Thanks, I heard a lot about mruby, I will give it a try.. JRuby could be an option, but I'm sure I will never do JAVA stuffs... ANd the JVM will not be isntalled.. GraalVM seems interesting, if I had no control on the servers (and docker was not installed) and my scripts were more like "softwares" than "basic scripts", this will be a relevant solution.
that's right, I went to Mandarin after Ruby
If you run Crystal on FaaStRuby it could be up to 5000x faster than Ruby on Lambda. Ruby on FaaStRuby runs up to 20x faster than Lambda. To see it for yourself, create a hello world on Lambda and get the execution time. Then create a hello world on FaaStRuby and get the execution time by passing the header "Benchmark: true". &amp;#x200B;
Nowadays people say that good use for serverless functions are background workers and glue code, among other things. I believe that really soon we will start to see whole web applications built on top of this technology. A lot of companies will actually skip the whole container thing and go straight to serverless IMO. That's my vision for FaaStRuby: develop locally with the feel of a monolith, but deploys as a distributed set of functions, and the developer does not have to do anything special - it just works. The problem with existing solutions is that they are too complicated. They say serverless but they still have to understand a lot of other moving pieces and deal with complex configuration files. A good example is the serverless framework - a great piece of software, but you still have to learn AWS and how to configure everything.
&gt; if my first array has nil values as well. You could always use .compact to eliminate nil values in the Array. Personally I favour clarity and readability. I have been a terrible golfer since my mind wants code to be super-simple at all times.
&gt; 2/3 of this subeddit would call this ugly Well, it depends. I find &amp; very ugly there, but it can indeed lead to a more concise code layout. I found the following example from some months ago: https://github.com/ruby/ruby/commit/91fc0a91037c08d56a43e852318982c9035e1c99 The old code was: f.close if f &amp;&amp; !f.closed? The new code is: f&amp;.close Both variants are actually very ugly, the first variant is ugly, and the second one is ugly. But the second one has one advantage that I can not deny - it is **significantly** shorter. My biggest problem with the initial golf example is actually a need by people to want to be super-terse and concise e. g. "all on one line". The world is not going to end if you use two lines rather than one. The newlines won't kill more trees than golfed examples. By the way: do_something_method&amp;.then(&amp;ary.:push) This is super-ugly code too. It's sad that ruby has been going in wrong ways, syntax-wise, like that. The only good thing is that the above monster can be avoided. Nobody can force people to use ruby in such a terrible way.
You have quite some conflicting goals. You want it super-terse; only once; but you yourself also added a () because you think it adds to the clarity of intent ... quite strange. :)
Any more ! you can use there?
This is very much a beginner‚Äôs refactoring. It would not pass muster at my code shop - if someone in my team committed this, I‚Äôd reverse it. The result isn‚Äôt open for extension (e.g. serialising to Excel or Google Sheets) or reuse (exporting other things). It has the serious code smell of a closure masquerading as a ‚Äúservice object‚Äù for which the giveaway is the use of `#call` outside of framework code. There are also layering violations: model-level code should not have any knowledge of rendering context. I‚Äôd send that beginner away with a copy of 99 bottles and an instruction to come back with an OOP model that properly identifies the concepts, has a clean invocation from the controller, respects layer purposes, is open for extension and reuse, and makes effective use of `Enumerator`, `yield`, `include‚Äô, and dependency injection. 
Hmm, I agree with the other poster here. Normally, I'd quibble with passing data when initializing a service object - I prefer to pass it when actually calling the object, to make it easier to extend. But I think like the other poster said that the main issue is that this service object is locked into exporting a CSV. Yes, yes, premature optimization is problematic, but in this case it wouldn't take much to actually have the service object use a CSV export via dependency injection.
That is actually a serializer, not a service object, that's why it looks weird. Besides, as some other people pointed out, it's not exactly open for extension, closed for modification. You can easily fix this by adding a few smaller objects, but for a simple serializer, I'd say it gets the job done. Also that testing style is a pain with big tests, you might want to check out [Upcase's free TDD video course](https://thoughtbot.com/upcase/fundamentals-of-tdd). Basically, it's better to have a flat structure when testing, so you know what code is executed without scrolling up and down constantly, and thinking which line runs and which doesn't. It is more repetitive, but it works surprisingly well.
Perhaps! a! little! more! excited! than! necessary!!!!!!!!! /s Honestly didn't even notice I did that truth be told. Am genuinely excited to get going with it though.
You could do "*" x num_ocurrences
Just curious why your file name is *gay.rb*...
what makes it so fast?
Got it sorted thanks!
Haha when i doing them I always write random shit soz
Like the approach.
I can only speculate, because I don't actually know the internals of AWS Lambda. It could be something about the architecture? They have a big platform that is suppose to serve multiple languages and conform to other internal products they have, like API gateway, SNS, CloudWatch, etc. That could maybe require some extra stuff that adds a few milliseconds? I don't know. FaaStRuby was built with Ruby in mind, so it is very straightforward and lightweight. &amp;#x200B;
&gt; So C source and object files would exist in _tmp_ in between Ruby invocations until a reboot. I don't see an increase in security problems from this. What‚Äôs to stop someone changing those files between invocations?
Happy to see a refactored version! üòÄ
Looks better and it's a nice introduction to refactoring. I wonder why the author didn't seem to fix n+1 queries in that code.
I don't agree with this point of view. We don't know what are the business goals for this refactoring. It may as well be done to clean the model class, which could be a valid reason to get rid of some legacy code. I don't think that kind of abstraction is needed in that code. Because why would we add DI and other stuff that you are recommending, when these classes may just be enough to get the job done at this very moment?
Well, I hate magical operators and syntax on general principle, so I won't toss my hat into this ring as there's really no case where I'd support adding more odd punctuation to a language that I treasure for readability. I hate PERL and PHP for the extraneous crap that gets between my method/variable names, which are the real content I'm scanning for when reading code.
I guess whatever stops people from doing it during invocations.
Ruby as a language is much nicer to work with because of it's consistency. I'm specifically not citing it's object orientation, which is much more thorough, because honestly I'd pick consistency over almost-pure objects. For example in ruby you would use `stuff.length` to get the number of elements in a array, or `name.length` to get the number of characters in a string. In python the equivalent would be `len(stuff)` or `len(name)` which is not consistent with OOP. The irony here is that when you look into the issue, there is no good reason for this, just a bunch of excuses, and ironically len just seems to call the argument's own \_\_len\_\_ method. So why not just dispense with the len() facade all together? Truth is, Python didn't start out as OOP pure as some would like to believe and it still carries some of those roots. &amp;#x200B; Another annoyance was the implementation of map and reduce. Ruby has an incredibly expressive implementation of both in the standard library. At the time I learned python they sort of had a map capability in list comprehensions. List comprehensions are a nice construct for defining sets, which is what it is really there for and that you can use it as a poor man's map feels almost like a side effect. The syntax of list comprehensions make it feel out of place compared to the seamless integration of ruby's version. Oh, and there was no reduce, at all, because, as far as I could tell, Guido just didn't like map reduce as a construct. I took a quick look and it *seems* like a more normal map and reduce are now implemented in the 2.5 to 3 range. I haven't worked with it, but notice that it suffers the same syntax issues as our friend `len()` does above. But the video doesn't even touch on the actual language design features, because I guess, who cares about that? &amp;#x200B; The video is right about the domains where Python is strong, specifically machine learning. That is why I learned Python, and if I had never worked with Ruby I probably would have thought it was pretty awesome, but if you are a strong Ruby developer, you are going to be disappointed with Python. Also, I don't like that they gloss over the strength of Ruby for web development. There really just isn't anything close to Rails for full capabilities out of the box for web development. I'm really sick and tired of people saying you can "pull together" everything you get from Rails by duct taping together a bunch of random libraries. You just can't. While the narrator does say verbally that Ruby/Rails is a strong web development option, they don't put it on the slide. I think this, more than anything, shows the bias of the analysis. Ruby has one clear win and they barely acknowledge it. &amp;#x200B; If you want to do web development choose Rails. If you want to do machine learning choose Python. If you want to do mobile development, watch this [https://www.youtube.com/watch?v=Xkjo7iKkQlY&amp;feature=share](https://www.youtube.com/watch?v=Xkjo7iKkQlY&amp;feature=share) and then ask yourself if you really need an entirely new application/language/stack to support mobile devices natively. If you still think you do, then you probably want none of the above.
How do you think it's magical? It's unambiguous and explicit syntactically, and it has simple semantics. What's the problem?
&gt; develop locally with the feel of a monolith, but deploys as a distributed set of functions What kinds of things feel like working with a monolith locally? Are there countermeasures included in the tools for dealing with messages arriving more than once to distributed endpoints? Are these conditions able to be simulated locally, or does the local development environment kind of "hide that away" so that the developer doesn't have to deal with it?
Those are great questions. &gt;Are there countermeasures included in the tools for dealing with messages arriving more than once to distributed endpoints? This is a inherent problem in distributed systems. I think whatever platform or framework you choose could potentially help you there, but IMHO it is the developer's responsibility to design their functions/microservices with those problems in mind. Network is unreliable, and I am afraid that if I try to hide that fact I could end up with a very complex system, with lots of rules and patterns that must be followed, taking away the developer's freedom to solve those problems their own way. I am not claiming to be right here, it is just my opinion and I can be completely wrong. I probably am! LOL All that said, there is currently no way to simulate network problems with FaaStRuby Server (the local dev environment), but that's something I will definitely think about! 
I don't like that it's a symbol. maybe if it were more explicit. Maybe something like: Foo.ref(:method) the .: used here isn't explicit or intuitive enough for me. 
I don't like the fact that if you read File.:basename, you don't realize that you're dealing with a Method object until your eye reaches the middle of the expression. It seems subtle and error prone. Agree with the one commenter on the thread that you can save just as many characters by aliasing #method to #m instead of defining a new operator.
&gt; if someone in my team committed this, I‚Äôd reverse it At minimum this code does two good things: 1. Removes handwritten CSV generation code 1. Moves report generation out of model `QuestionRow` may be unnecessary but otherwise this is much better. &gt; It has the serious code smell of a closure masquerading as a ‚Äúservice object‚Äù for which the giveaway is the use of #call Not sure about this smell but in general `#call` for a "service" is üí© ([reasons as to why](https://www.reddit.com/r/ruby/comments/80r52z/use_static_facades_when_you_dont_care_about_the/duxosnn/) &gt; OO model that properly identifies the concepts involved in tabular data export, has a clean invocation from the controller, respects layer purposes, is open for extension and reuse, and likely makes effective use of Enumerator, yield, include, and dependency injection. And I thought people hated my code reviews. How does this not `respects layer purpose` or not have `clean invocation from the controller` (aside from needless `poll` named argument)? This may be The Way to Go ‚Ñ¢Ô∏è if we have requirements for generic reporting framework or multiple formats but as is refactoring is much better. 
It's a subtle feature with a completely non-obvious purpose. Having this kind of odd syntactical sugar makes learning the language harder, makes reading new code harder. Ruby in its simplest form is elegant and intuitive. You can't tell me .: is in any way intuitive.
&gt; Where did you infer that from my post in the first place? Infer what? That you were saying ruby had performance problems compared to python? From where you said "the market deman[d]s faster languages" and ones that can "process more data and users." If that's not what you meant, I have absolutely no idea at all what you meant, your post didn't make any sense unless it meant that. 
I meant it in general compared to new languages. Python was always more popular than Ruby not because it was more performant but because of stronger backers.
I can understand your point of view there - I thought you meant something more by saying 'magical' like it was doing something obtuse or orthogonal to how Ruby usually does things, rather than you just objected to another piece of syntax, which is a reasonable thing to complain about.
I've been wanting this ages and love the syntax. So exciting!
Those things are just good Ruby style. They're not additional "abstraction" or "stuff" to "add" - quite the opposite; the code would be shorter, easier to read, and open to extend &amp; reuse if it was written in simple idiomatic Ruby to begin with. As for inventing reasons for this refactoring, if it already "got the job done" the whole thing is unnecessary.
&gt; At minimum this code does two good things: &gt; &gt; Removes handwritten CSV generation code &gt; Moves report generation out of model Yes - a beginner refactoring. 
Looks good to me. Ruby is already full of sigils and operators. It‚Äôs part of the spirit of the language, and has been since the beginning. In my opinion, this feature is better than the safe navigation operator in every way, so I don‚Äôt see why it would be a problem. 
&gt; It's a subtle feature with a completely non-obvious purpose I think this is a preposterous thing to say about method reference in 2018.
Aesthetically it looks alright, I suppose. The problem is that it doesn't "feel like" anything else in Ruby. Obviously the problem is that since Ruby has optional parentheses, we can't distinguish between calling a method, and just wanting the method. So I suppose the question is, how would I expect to be able to get a method from an object in the "same way" that I get a function from an object in JS simply by dropping the parens? We all know we can call `obj.method(:method_name)`, and of course this all makes sense since it's just normal method invocation syntax. When I see `obj.:method_name` it feels alien and out of place. But I admit that's just my feeling on the matter. It looks like I'm getting a constant value from `obj` similar to `Float::INFINITY` or the like, but that syntax calls methods too. `obj.:method_name` also opens the syntactic floodgates, so to speak. Why not have `obj."hello"` mean something? Or `obj.17` and `obj.{x: 40}`? I admit this isn't the most valid of complaints, but personally, I expect a kind of "algebraic completion" to the syntax of a language. Of course, this complaint is made weaker by the existence of `ary.[12]` being a meaningful thing. 
 puts File.read(the_file).chars.group_by(&amp;:itself).map { |c, k| '%s: %s' % [c.dump, '*' * k.count] }
&gt; has_key? is deprecated in favor of key? [Not so](https://github.com/rubocop-hq/rubocop/issues/3224). It's a matter of stylistic preference.
From the discussion, `:::` looks best to me, but I could see how it could get confused with `::`. `.:` looks downright awful lol
In some other languages, macros/templates are used to add features. I.e. Nim has both, and they serve similar but subtly different functions; mainly that you can add/invent your own operators and syntax for what you want, and distribute this syntax as a library. The discussion of the difference between them is out of scope for a comment like this, but I'll use an example from the docs to demonstrate what they basically do. In nim, `!=` is defined as template: template `!=` (a, b: untyped): untyped = not (a == b) At compile time, the compiler replaces all occurances of `a != b` with `not (a == b)`. Now, ruby isn't compiled. But thats not to say a feature like this couldn't be useful for preprocessing the language before its assembled into an AST and sent off to the runtime. To add this syntax, you could do this (theoretical) deft `a.:b` a.method(b) end This lets people experiment with new language "features" without having to get them in core. I realize you can do a _lot_ with plain ruby methods, as they're extremely flexible, but the ability to edit the "language" at parse time is one of the great features of things like Nim or Elixir. Both Nim and Elixir implement a lot of their "core" syntax sugar via macros/templates: + https://github.com/nim-lang/Nim/blob/master/lib/pure/sugar.nim + https://hexdocs.pm/elixir/Kernel.html#def/2
Might be an interesting candidate for a [refinement](http://ruby-doc.org/core-2.6/doc/syntax/refinements_rdoc.html). 
Caveat non-emptor: HexaPDF is Affero GPL licensed. Using it in a web application means you commit to distributing your source code to all users, unless you buy a commercial license. 
I second this. Looking at the code this whole gem is basically for this one custom constructor... require 'ostruct' # Converts the nested hashes to open structs too class DeepOpenStruct &lt; OpenStruct def initialize(hash) super(hash.each_with_object({}) { |(k, v), h| h[k] = v.is_a?(Hash) ? self.class.new(v) : v }) end end 
Is this a free software?
Last I checked open struct was really expensive performance wise.
Why? Justify it please. Don't get me wrong. It's pretty cool how you did what you did. I'm ALWAYS a fan of metaprogramming (at least, in theory...)! But I generally require my devs to justify their metaprogramming (we're a Chef shop so we're not always doing Ruby in the same way as everyone else...). So, what use case do you have or foresee that I would want to use this? 
ok... maybe I really don't understand ruby like I think I do... I thought methods defined in the module block were "class methods" and not accessible from an instance of the class... conversely instance methods are defined within a `class` block and only accessible to the instance... e.g.: module Foo def foo puts "in module foo" emd end class Foo def foo puts "in class foo" end end Foo.foo() # "in module foo" f = Foo.new() f.foo # in "class foo" although, having typed that out... I'm pretty sure there would be an error about module/class having same name... so perhaps I need to rethink what I'm thinking... :) Merry New Year! 
That is correct and it prominently says so directly on the landing page of the HexaPDF website.
I would try adding the url gem as a dep explicitly @0.1.14 and see if that clears things up. If not it will probably show which other dep is having a problem using this version.
looks like you know what you‚Äôre doing for this basic app, though it notably doesn‚Äôt need a model yet. if it grows into something bigger, or you need to support special cases, you‚Äôll find particular pain points you can ask about. 
I don't think that \`.:\` would be a good choice because the intention is no really clear and it is easily confusable with \`::\`. Between \`.:\` and \`:::\` I would choose the latter. Yes, it is one more character to type but it feels more straightforward. Aside from a new operator, I also like the idea of having and \`m\` alias to \`method\`. &amp;#x200B; Related things: * The introduction of the safe navigation operator \`&amp;.\` operator had a clearer use case than this. * Does anyone use the \`.()\` method for calling \`#call\` methods? I always find that syntax weird. Like I would find \`.:\` weird. However, both together, while still looking weird, at least have the same kind of weirdness: \`obj.:method.(args)\`
At this moment it is free to use. I am working on a self hosted revenue model and a cloud based as well but like I said in another reply, I plan to always keep a free tier for the cloud based one. 
About `.()` -- I haven't seen a point, but recently discovered one interesting idea: In standard library, there are a lot of methods like `Array()` and `Integer()`, and sometimes people (mee too) follow this convention in their own libraries: provide `Kernel#MyModule()` method to convert something to compatible object (I played with this in [hm](https://github.com/zverok/hm) and [time_math](https://github.com/zverok/time_math2)). It is kinda "nice", but still a hack, in a sense that the method just looks like "the same as a module", but in fact it is not. So, if you do something like: TM = TimeMath TM(Time.now) # nope, doesn't work! So, it _could_ be a good compromise: TM = TimeMath TM.(Time.now) It looks "almost like `Array(foo)`", but in some sense more "logical" (it now IS the same thing, not just pretending to be). So, the answer is "hack into language syntax, staying in the logic of language". Another idea I played with was this: https://bugs.ruby-lang.org/issues/15301 [10, 20, 30].map(&amp;:modulo.(3)) Again, it is _short_ (of course, "too short and cryptic" for some), but still logical (no new syntax, just combination of existing short syntaxes).
I asked weather its a free software. Go here https://fsf.org to know more.
Love it, I‚Äôve always been a fan of using .method to pass functions into something like map, but I hated its affect on readability. I think making this with symbols was 100% the right call because now lines like that will read much closer to prose.
That's why OP did not write an essay about how OpenStruct is the single solution to all problems. There are many circumstances where slower approaches are chosen over speedier ones.
I use Hashie::Mash for this kind of operation. But I‚Äôve also written a lot of inline code similar to the core of the snippet. Our motivation is getting large hierarchical json or xml back from services that has to be transformed into an object-like graph for Ruby clients. 
That looks really interesting, I haven't gone through the 2.6 changes to be honest. Thanks a lot!
&gt; where slower approaches are chosen over speedier ones. A lot of developers forget this. I'd rather be given readable code which is a tad slower over a cryptic mess any day.
Yes, I'm using it mainly to generate object like elements that are a bit more comprehensive or easier to use. But only when loading a configuration per environment. I had this snippet in the service but it made sense to take it out as it felt a bit weird to have it there
I use it mainly to load configurations. I'm using .env files and mapping them, however it feels a bit more intuitive if you can use `Config.database` instead of `Config[:database]` 
In my opinion, the developer should evaluate if a cryptic mess makes sense, it might be the most critical part of a service for example, and if you can reduce the response time with a significant amount, then, it might make sense.
Go with Kotlin 
Ah ok, well no. FaaStRuby is free as in free beer.
Ruby will be fine, but so will be Kotlin :),
Refinements were introduced in Ruby 2.0 (released 6 years ago ;-)). https://bugs.ruby-lang.org/issues/4085
Oh, I wasn't aware of this, thanks a lot for the info :)
If you're more comfortable with the idea of Kotlin then go with that. As far as other uses of Ruby, I use it to parse and ingest terabytes of json logs into a database which is used to serve an interactive log viewer in the browser via rails. Ruby is a general programming language so you can use it for whatever you want, just like Python and js.
Oh, also the best penetration testing tool available, [metasploit](https://github.com/rapid7/metasploit-framework), is written in Ruby.
Hashie::Mash has always felt like a bandaid looking for a wound to me. [The demonic possession of Hashie::Mash](https://code.dblock.org/2017/02/24/the-demonic-possession-of-hashie-mash.html) is worth a read. Making arbitrary nested data structures behave like objects is surprisingly fraught, and now that we have #dig, mostly unnecessary.
You summed up my opinions pretty well too! I'm learning Io while reading 7 languages in 7 weeks. It may be a dead language but it has shed a lot of light on how other prototype languages like JavaScript work.
One of the factors I would consider when evaluating these two choices is what the language‚Äôs community is like. If no one in your shop is an expert on your new language, how easy is it to access that expertise? I can‚Äôt answer that for Kotlin, but Ruby has a great community of people that want other Rubyists to thrive and want the language to thrive. 
For an example of ruby used without the web, [Eventide](https://eventide-project.org) is a framework for writing message/event based microservices.
I think the answer for you is Kotlin, but for most subs here it would be Ruby without question.
How does this compete with the lonely/safe navigation operator?
As a different consideration... Apache camel, spring integration, ws02, mulesoft esb are all specifically for this task and they use a dsl to configure not write loads of code for integration. You might need to code a bit for transformations and validation but reuse is key with service integration. Camel is widely adopted and has many connectors for a lot of infrastructure components such as rest, soap, and rabbit but also many b2b connectors like salesforce. You can wrap camel in a spring boot container with very little effort which would be my preferred approach but you can put it in jboss fuse and jee. All of the above would mean you stick with java but you would be reusing a lot of already existing open source capability and get the job done quickly and thereby reducing risk to the delivery. 
I think your deployment management on using Makefiles is really cool. I don't see that too often in the ruby web domain. 
Wow, and refinements have been in there for*ever*. TIL.
I wrote a bit about why exactly Hashie::Mash is painful to work with here: https://www.schneems.com/2014/12/15/hashie-considered-harmful.html
yeah and I totally respect that perspective (I‚Äôm aware of the mash restrictions and code around them), but I don‚Äôt know how plain Ruby object scale to hundreds of changing nested fields. If I had any control over those service returns I would pare them down to what was needed, but they change rapidly (like when someone drops in a slightly different marshaller on the Java side‚Äî yeah kids, don‚Äôt integrate with Java). If I create my own metaprogrammed recursive PORO then it just feels a lot like Mash... I don‚Äôt know, maybe it could be cleaner than Mash... but I‚Äôve looked at the marshaling performance compared to the service request time and the service time dwarfs it either way. Is it worth worrying about? Maybe in a CS theoretical way? I‚Äôm intrigued with GQL for this reason as it looks like it could pare down giant graphs to just what I want without this marshaling madness, but I‚Äôm still trying to wrap my head around implementing that for REST services (not to mention SOAP‚Äîyeah kids, we still have SOAP calls. Did I mention don‚Äôt integrate with Java?) I‚Äôm always open to better ideas, but I don‚Äôt want to spend a lot of time handcrafting POROs for a service return that changes every couple months. It‚Äôs a waste of time even though it‚Äôs more formally correct. Also don‚Äôt ask about tests in this environment, because even the service authors can‚Äôt describe what valid data looks like, except when they see it. This is what legacy enterprise integrations look like. see Savon, etc. Also, Java has the ability to generate clients and POJOs automagically from WSDL and WADL, so if you‚Äôre trying to match them with handcrafted POROs you‚Äôre going to lose... a lot. Context is probably everything when considering whether something is ‚Äúright‚Äù in a given situation. 
Yea I posted it here for that reason. There's no better people to ask than those who use it day in day out.
What's the reason you're choosing Kotlin over Java? (Being a java developer myself)
In your case I wouldn't advocate a PORO since it doesn't sound like you're doing anything other than accessing values. If that's the case I would recommend using a hash. Depending on the structure of the JSON could get clever and guard against accidentally using the wrong keys: ``` hash = JSON.parse(java_output) hash.default_proc = -&gt; (hash, key) { raise "Hash does not have key: #{key.inspect}\n #{hash.inspect}"} ``` Using an OpenStruct for such deeply nested data doesn't really buy you anything (that I can see) and it will cost you plenty in terms of performance. Instead of chaining methods with an open struct you can use Hash#dig. Sure it's not going to look as pretty, but at least it's clear to any devs looking that they're working with a "dumb" hash. 
To answer your question about non-Rails Ruby, yeah, it's great for that type of work and quite common for companies that already use Rails. I personally find Ruby to be in a sweet spot between expressiveness and flexibility, it's a joy to work with. The typical comparative downsides have been in performance and memory usage, but there have been a LOT of improvements over the last 10 years (since it really got popular with Rails) in these areas. I would choose Ruby for most projects without a strong reason to go with another tech.
Adhearsion is a great example of non-web Ruby: https://github.com/adhearsion/adhearsion
https://www.reddit.com/r/ruby/comments/42511y/til_class_self_vs_selfmethod_interesting_behavior/?st=JQEBK8DG&amp;sh=a00feaac
Right, I‚Äôm only using it for access, mostly... but sublassing Mash makes it very easy to add synthetic methods on top of the service return. So easy that it is hard to resist really. Mash really only really buys you the dot notation, which is some syntactic sugar if you have to chain a bunch of keys together: e.g. obj.some.thing.you.want vs: obj[‚Äúsome‚Äù][‚Äúthing‚Äù][‚Äúyou‚Äù][‚Äúwant‚Äù] That kind of crap will make your eyes bleed if you type it enough. So I wanted to look for something simpler. I don‚Äôt even care about the nil detection ‚Äî just assume that the keys are right or if wrong, you have to fix them. We always have to look at the service return anyway, no way to predict ‚Äúcorrectness‚Äù, so if you force me in that corner, I‚Äôll take the savings in characters typed any day. But, it‚Äôs something I wrestle with quite a bit, so I‚Äôm not sure. Just going with pure hashes would be simpler and it seems a pity to tradeoff the performance for getting dot access vs []. nil detection/mitigation isn‚Äôt really improved. So yeah, I‚Äôm more ambivalent than I was a few years ago. But as I said, service call dwarfs any marshaling done with Mash, so is it really a net loss? Back then the goal was to produce Ruby client POROs similarly to how Java produces POJOs from XSDs, I suppose another way would be to write a compiler to create POROs automatically.. but it starts to feel like Mash anyway. That‚Äôs my dilemma. In tests, I‚Äôve created view mocks with Mash that are pretty easy to mock structure... e.g. obj.some!.thing!.here!.about = 5 But again, is all the pain worth it? Maybe not. I‚Äôm in a kind of return to basics mood... trust nothing except pure Ruby. I still like the syntactic sugar too much though. 
1. Yes 2. class &lt;&lt; self opens up singleton class of Number and then you use def self.number_two to define a method on singleton class of that class. So essentially it is defined on singleton class of singleton class of Number. If you want to define it on singleton class of Number you would use def number_two inside of class &lt;&lt; self.
Is there a reason you don't use [rvm](https://rvm.io/) or [rbenv](https://github.com/rbenv/rbenv) ?
chruby uses a simpler solution, `$PATH`, when is cleaner and works better in production environments. I feel both rvm and rbenv are much too complex for what they are doing.
I know a hoard of younger mobile and web developers proficient in Swift, Kotlin, Node, Ruby, Python, etc. So newer languages. While Java is in use and a great fit as most applications we have use J2EE for the back end, I want to see how this might work from their lens, improve the Dev experience and have a showcase to advocate for introducing a more friendly language for new projects.
Agreed. Benchmarking is the Ruby developer‚Äôs friend.
 Heads up - &gt; RubyGems 3.0.1. The --ri and --rdoc options have been removed. Please use --document and --no-document options instead.
Sounds like a plan :) I write in Kotlin, java ,ruby and objective C so I'm always curious as to people's reasons for choosing a Lang. I'd personally go with Kotlin only because I like a stronger typed language.
Yep, use the tool you (and your team) are most proficient in. Especially with a tight 2 month deadline, you want to be as productive as possible right out of the gate. Kotlin for the win.
You can see the #number_two method you defined on the singleton class of Numbers like this: class &lt;&lt; Numbers number_two end #=&gt; 2 Or like this: Numbers.singleton_class.number_two #=&gt; 2
Thanks! will update.
same reason as /u/doubehyphen
I do these Docker and deployment tasks in Rakefiles. Forgot how much more elegant Makefiles are when you're only making system calls.
The class &lt;&lt; self syntax is also the only way to define private class methods, afaik. 
&gt; Ruby does seem interesting, though the only pure &gt; Ruby that's non-web I've seen is Fluentd I am using "only pure" Ruby since hmm... 2004 or so. Definitely before rails. I don't use rails. so I don't get Railsers really. &gt; I think I'm looking for other use cases where Ruby &gt; is used for integration and non-Rails products. I am not sure what you mean because I use ruby - literally - for everything. I don't understand the "ruby is a web-language" limitation claim either. &gt; Is Ruby's use in this domain not common or is it very &gt; widely used but doesn't have a lot of talks about it? My projects aren't very interesting for other people and I don't like doing promotion much at all either. These projects all solve existing problems I have - or have had. I think you are a bit worshipping too much the language aspect in itself rather than what you want to do/achieve. Syntax-wise ruby beats Kotlin with its eyes closed (if we exclude some recent changes to ruby which was unnecessary IMO; all the strange parts like .: and more). Ruby in itself is very easily malleable to your use cases. If you avoid writing super-"clever" code then ruby is very easy to "think in". I used perl and PHP before and there is just no comparison - perl and PHP are like languages from 5000 years ago in this regard. I think the use case for Kotlin is mostly to have a lighter java. Speed may be a reason in favour of Kotlin though ruby is not a slow language as such - there is just no way to compete with C, Java etc... From the description you give Kotlin would be a better fit obejctively IMO. From a language point of view, Ruby beats Kotlin with its eyes closed. By the way I think the biggest part you should talk about with the rails-co-worker is how he uses ruby for non-web related stuff. That may also indicate whether rails dumbed him down or not. :) (You can use ruby for www-stuff without rails. I did so when I switched from PHP.)
&gt; use the tool you (and your team) are most proficient in. That is funny because I also read, on reddit, to "use the right tool for the job". It always leaves me head scratching.
I've written a story about this a while ago that discusses these topics and tries to sort things out a bit, you might find it helpful: [https://medium.com/rubyinside/class-methods-in-ruby-a-thorough-review-and-why-i-define-them-using-class-self-af677ede9596](https://medium.com/rubyinside/class-methods-in-ruby-a-thorough-review-and-why-i-define-them-using-class-self-af677ede9596) &amp;#x200B;
You could use `private_class_method def self.foo` to do that as well. I find it very awkward though.
doesn't `JSON.parse(json_string, object_class: OpenStruct)` do the exact thing?
I probably didn't express it right. When my colleague suggested Ruby, I did a quick Google search for its other use cases besides Rails, whether it's to do business processes, content management or a small part of a bigger technology stack that people pay big bucks for. I thought I was missing something when the search didn't return more than a handful of results; which prompted the questions above. macOS bundles Ruby in their OS so it's gotta be dominant somewhere. Found out about JRuby this morning, which is used to built Logstash. That's pretty neat. &gt; I think you are a bit worshipping too much the language aspect in itself That's the essence of this exercise :) and also the ecosystem and community around it.
Thanks for the responses folks. As everyone suggested, best tool for the job. I'm going to try out Kotlin for this POC. I'll have a closer look at Ruby in my spare time and see where all the "Ruby as a language beats Kotlin to a pulp" praises are coming from.
Very nice little library. I'm honestly surprised some syntax like this hasn't already been added to ruby core, given how common it is. The only "built-in" way of doing anything like this, that I'm aware of, os to inherit from [`Struct`](http://ruby-doc.org/core/Struct.html) - but that's clearly flawed for a few big reasons. I also found [this old gem](https://github.com/garybernhardt/cls) which attempts to improve on that approach, but it was never updated for named arguments (in ruby 2.0). (The `let` method is also an interesting idea, as it could solve the common memoization problem.) ..And then there's the [`virtus` library](https://github.com/solnic/virtus), although that's often a big overkill -- even the library's author has, for now, [abandoned it](https://www.reddit.com/r/ruby/comments/3sjb24/virtus_to_be_abandoned_by_its_creator/) as it's become a sort of "swiss army knife" rather than a simple tool for a specific task.
I like the concise syntax, but I confess I‚Äôm puzzled by the service model pattern a bit: why .call()? If the goal is to create a service client with state (presumably to make additional calls on the stateful client), then .call() is simply a factory for the service model and either .new() or other generate method could be used. But .call() suggests that the Service Object is more like a functor, where the intent should be focused on a stateless call and returning an actual result (not a service object instance). There are other issues. By encouraging an SO instance per service (eg Faraday,etc) the domain is coupled to the service... ie I would guess that multiple service calls would end up on the SO much like a Service Client. But I thought Service Objects were supposed to be aligned to the client domain, ie if you need records for a view, you call a specific SO to return that data, without so much concern about representing all the other service returns possible. Of course, if the service and view are 1-1 already (ala REST resource) this distinction is blurred. So I‚Äôm not sure I understand the SO pattern. I read one post that seemed to suggest that the .call() convention was adopted from JavaScript convention, which would make sense, but probably doesn‚Äôt have any real objects per se and just deals with pure functions. Was something lost in the translation? I feel like I‚Äôm missing something.
Some time I wrote a blog post explaining how I work with service objects and the "call" naming scheme https://pawelurbanek.com/2018/02/12/ruby-on-rails-service-objects-and-testing-in-isolation/ Long story short, it's useful for mocking with procs and forces you to stick with single responsibility principle for each service.
I've had my try at virtus and the whole dry stack but totally agree that it's too heavyweight for this simple use case. btw please be aware that it's only mimicking the keywords syntax, but uses normal hashes. I've been trying to implement it based on keyword arguments, but it required using "eval" and allowed for code injection so gave it up. Nope, did not approach core team yet :p
&gt; I've been trying to implement it based on keyword arguments, but it required using "eval" Just glancing at your code, was the problem caused by named parameters *without a default value*? I.e. You'd like it to work more like: ``` initialize_with :arg1, keyword1: :foo, keyword2: ``` ? In which case yeah, you'd need to make changes to the ruby parser in order for that to work. It would also eliminate the need for separate `initialize_with_hash` and `initialize_with_args` methods. I think this implementation is fine for now, and as a proof-of-concept, but as I say I feel there's a core language feature that could be spun out of this.
That `let` method probably comes from rspec, which implements the same thing, so it‚Äôs a pretty logical syntax for those who use that
Yes, I'm very familiar with `rspec`. However, that's not core ruby. And it doesn't really make sense to me, to introduce a totally new core method to do *almost the same thing* as `def`, with the tiny additional memoization behaviour.
Problem with keyword arguments was they they cannot be declared using metaprogramming eg. define_method, I had to parse a raw string using "eval" and that looked like a really bad solution. As for call I am planning to add an option to customize the method name, but I am not sure about extracting it into a seperate module, 90% of time I use both features together. 
I am cooking up [something kind of similar](https://github.com/tomdalling/value_semantics), but for a different purpose. I‚Äôve been writing an [article](https://www.rubypigeon.com/pipeline/value-semantics-gem/) about it over the holidays, which I hope to publish soonish. 
This is one of _many_ versions I've seen of "gradual typing" in ruby. If you haven't seen it already, check out [`sorbet` by Stripe](https://medium.com/byteconf/stripe-is-building-a-ruby-typechecker-d6cd7cee6abf): https://sorbet.run/ The team are in ongoing discussion with ruby core, hoping to get this merged into a future version of ruby.
This is one of _many_ versions I've seen of "gradual typing" in ruby. If you haven't seen it already, check out [`sorbet` by Stripe](https://medium.com/byteconf/stripe-is-building-a-ruby-typechecker-d6cd7cee6abf): https://sorbet.run/ The team are in ongoing discussion with ruby core, hoping to get this merged into a future version of ruby.
Thanks, that helps. So, the call is intended to return an actual result rather than an instance of the SO. It looked like the example in the gem was returning an instance.
This is one of _many_ versions I've seen of "gradual typing" in ruby. If you haven't seen it already, check out [`sorbet` by Stripe](https://medium.com/byteconf/stripe-is-building-a-ruby-typechecker-d6cd7cee6abf): https://sorbet.run/ The team are in ongoing discussion with ruby core, hoping to get this merged into a future version of ruby.
I think maybe it's time to stop and ponder not if we CAN do it, but if we should?
&gt; Problem with keyword arguments was they they cannot be declared using metaprogramming Yes, they can? [1] pry(main)&gt; define_method("test") { |keyword:| puts keyword } =&gt; :test [2] pry(main)&gt; test ArgumentError: missing keyword: keyword from (pry):1:in `block in __pry__' [3] pry(main)&gt; test keyword: 123 123 However, I don't think there's a way (without `eval`) to declare them _dynamically, without default values_ - i.e. the pseudo-code I wrote above. Because you cannot declare a ruby hash where a key is not mapped to a value. Therefore, I believe this syntax would require a special-case handling by the ruby parser. &gt; I am not sure about extracting it into a separate module, 90% of time I use both features together I get what you mean, but I feel these are two totally separate ideas, bundled into one gem. Especially since it would be so trivial to just define that second method yourself each time, as needed: def self.call(*args) new(args).call end
I mean, yes... but. Refinements are still super shaky. Read up on them well, because the places where they don't work will surprise you. For instance, refinement does not work on proc coercion: refined_class.tap {|me| me.method} # here refinement works refined_class.tap(&amp;:method) # here it does not 
Yeah that's what I meant, they cannot be declared dynamically and that would be needed for the gem to work.
Argument lists are not an object. Suppose it was, actually, an instance of `ArgumentList`. How would you *initialize* an `ArgumentList`? With... Another instance of `ArgumentList`?.... That's an infinite recursion. This is what makes syntax like `foo:` possible, within a method definition.
This is awesome.
This is pretty neat. Similar to the simple_command gem
I‚Äôve always used `execute!` instead of `call`. `call` seems like it should be reserved for procs.
That's the whole point so that you can mock a service object with a simple proc in specs for the other layer. Check out the blog post linked in readme. But I like the idea of being able to rename the callable method, sth like: ``` is_callable method_name: :execute! ```
Nice! I also highly recommend `chruby` and `ruby-install`. Another method for getting them installed is through Linux homebrew (perfect for dev machine and even tested in production). https://linuxbrew.sh
Is it working now? Perhaps it was due to this issue: https://status.rubygems.org/incidents/dh3cd8fjd5qw
Yeah - Is there any kind of efficiency gained anywhere in this process?
Hitting 1.0 and staying there is a wonderful dream, one I wish more libraries would aspire to.
Men and my friends at barsoom have something similar: [https://github.com/barsoom/attr\_extras](https://github.com/barsoom/attr_extras)
I love the way React composes small functions into a complete UI. I love writing Ruby on the server. Rack::Component lets me do both those things conveniently, with the added bonus of rendering very quickly. &amp;#x200B; I'm looking for feedback on the README and API design before I publish a 1.0 release. Thanks!
Wait, I believe these are built into capybara now. I think you don't have to `Capybara.register_driver`, you can use the drivers :selenium_chrome and :selenium_chrome_headless which are built into capybara. https://github.com/teamcapybara/capybara#selenium
Ultimately it depends on what you're doing with the data. I've seen a fair number of apps where serialization and data access were a significant chunk of response time (10%+). In my experience its easier to go from a hash to an open struct (type-ish) object if you determine it's worth it. Going the other way though is much harder. As you said, it depends. That being said if you end up doing perf work on those endpoints, using open structs is likely going to jump out as being a hotspot pretty early on. 
I wish for ruby: - fibers should be more prevalent - more functional tools - we should wrote code for ruby 2.5 - more tools for ML/NLP/AI - more visibility on ruby core devs process. Currently you need to spend time on bugs.ruby-lang to get some inside - AMA with ruby people :) - more publicity from us to the language. I get sad when I see language that invent some ```cool features``` that ruby has it for 5 years - we need to become free from rails. Yes, I know this is somehow bad, but I truly like to see other libraries take off. I totally enjoy roda, sequel, shrine, falcon is a nice tool but just starting. - better documentation. I enjot more the documentation from golang, python or dlang than ruby Ruby is a good language, but I feel that we are slowly getting smaller and smaller :)
Having dealt with these kinds of libraries for years and years I've concluded that they don't provide enough to justify the overhead. There's something to be said about a PORO
Nope, you're spot on. Service objects are an anti-pattern. Most so-called Service Objects are a buggy, slow re-invention of closures being used as a junk container for procedural code. You'll see many Medium blags on the topic, and none of them look like service layers in either the Fowler or the Evans sense. The most common justification is usually based on a gross misunderstanding of the SRP. The hallmark of Bad Service Objects is invocation of `#call` outside of framework code, which I've thereby come to regard as a code smell. I've never seen a service object that wasn't better expressed as a purposeful object representation of domain concepts. 
Looks really interesting. Though my main goal with smart init was to save myself thinking when adding new services, 90% of time the same convention works for me. So many config options could be a bit too much overhead.
Service objects are an anti-pattern but some people are committed to reinventing closures for their procedural code, because it makes for a nice blag on Medium. They never, ever look like a service layer in either the Fowler or Evans sense, and they're usually accompanied by some gross misunderstanding of the SRP as justification. I've never seen a so-called service object that wasn't better written as a purposefully composed object representation of domain concepts. 
There is one insane big problem with this lib. It is based of inheritance. This should be all module you include and that is all. Also this style of writing ruby has one big hole in rails setting, you are fighting the framework to look functional while generating shitloads of side effects. This is more from experience of dealing with such approach in production. 
It still makes me angry that it was agreed and introduced to language that we have 2 different syntaxes for hashes. 
&gt; I've never seen a so-called service object that wasn't better written as a purposefully composed object representation of domain concepts. I don't know - I don't have any vendetta against service objects. I've found myself writing a lot of "functions as objects" although usually it's more like "a module of concerns with purely stateless singleton methods" What I really have an issue with is complexity that adds obscurity with little gain. Macro-style class methods are one of the harder things for newbies to grasp. Sure, it's fine if it's just your codebase or the codebase of a small strong team, but I've just dealt with patterns like inheriting from Struct just to override `initialize` and `super` so many times... Macro-methods should _really_ be worth it 
Maaaan this is good. Congratulations!
This is completely nuts. I love it!
[This](https://bugs.ruby-lang.org/issues/14982) is one thing I wished gained some traction but aparently very few people care about
You can do this in one line using the standard library: puts File.read(the_file).chars.group_by(&amp;:itself).map { |c,k| '%s: %s' % [c.dump, '*' * k.count] } 
Wat?
That bug is kind of hard to follow, but it sounds like a "doctor it hurts when i do this" issue?
rocket vs. colon (this summer on steam)
Looks like by just using strings and heredocs, this is sacrificing any kind of escaping by default, right? So, that nice [quickstart example](https://github.com/chrisfrank/rack-component#quickstart-with-sinatra) is just an injection waiting to happen. Not worth the tradeoff I think.
Thats not really unique to the language though, and they do have different semantic meaning. Colons indicate symbol keys, rockets do not. What would you do instead? { :symbol: value, } Imo thats ugly
Agreed and in rb2.3 when you use colon syntax with string keys it becomes symbols. What?
 class HelloWorld def call(env) [ 200, { "Content-Type" =&gt; "text/plain" }, ["Hello World"] ] end end
Yea it's a little bit a utility gem for a lot of different cases. But we mainly use it for a simple way to declare init params and make them not world-readable (pattr\_initialize).
I‚Äôm surprised no one has mentioned ruby serverless becoming more of a thing. Now that Amazon supports native ruby lambdas I think we‚Äôre back with the cool kids. It allows to move away from a Rails monolith (no matter how beautiful it is ;)) while still using ruby. We can pursue devops objectives keeping ruby as the core language. Super thrilled!
You're right that Rack::Component doesn't do any escaping by default, /u/himdel, and I appreciate you flagging this. I'll replace the Quickstart example with one that that does not render raw user input, and I'll add a section to the README about using `Rack::Utils.escape_html` to handle escaping when necessary. Am I right that rendering raw user input is the only place this would be a concern, or am I missing something?
Thanks!
Thank you!
I was trying to say that if the safe navigation operator is an acceptable addition to the language, then this operator should be totally fine too. 
It's much better to be safe by default and add a "unsafe_HTML" wrapper method if you do need to put raw HTML in. It's very easy to accidentally miss escaping inputs as a developer
Looks like dry-auto_inject
&gt; more functional tools When I was learning Ruby I noticed you have nice chainable methods to do some function stuff, but when I asked about them I guess "the community" frowns on using them like that. Which is a shame. I know the one way of true is sometimes a really good thing but I wonder if it's too dogmatic for it's own good sometimes.
Seems like an awkward dsl around AR::Base.transaction. To be fair there are gotchas about transactions that I always need to look up
I've got not quite ten years in Ruby experience (and will hit 40 years in software development in June), and I agree with most of these. We've been Rails-free for a couple of years now. I've been a fan of the [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) since Uncle Bob published the first version of that post. In other modern languages and frameworks, Clean Architecture is, if not the default, then at least extremely straightforward to implement, and I was long frustrated by how long it was taking the Ruby community to get with the program. I knew Rails would never, *could* never, go in that direction, given their fundamentally different view of the ecosystem and of what makes a "good app", but...seriously? Anybody? For a long time, the best we could do was a roll-our-own approach on top of [Roda](https://roda.jeremyevans.net/), making extensive use of then-early collections of [dry-rb](https://dry-rb.org/) components. We've been poking at [Hanami](https://hanamirb.org/) for a year and a half now, and have internal apps up and running that use it. We're hoping to have our first _public_, commercial app based on Hanami up during 1H 2019. Exciting stuff! ---- As far as the rest of your list: * Immutable data structures: See the aforementioned [dry-rb](https://dry-rb.org/) and [Hanami](https://hanamirb.org/) (which uses dry-rb). Done, reasonably well; * More functional tools: dry-rb is your friend. There are others out there, but this is the best one I've yet seen; * Better publicity: For several years, there were a flurry of alternative conferences and discussion groups to evangelise the language. More recently, those have mostly coalesced into RubyConf, [Keep Ruby Weird](https://keeprubyweird.com/), and one or two others that seem content to preach to the already-converted rather than energise people to go out and compete with the Cool New Languages‚Ñ¢ that also simply repackage 1970s language-design memes. I'd love to see that get shaken up, but I have no idea how, and I'm marooned in a place where the political and social status quo depend on controlling authorised innovation and other forms of expression. * Better doc/better C API/better Google visibility: any ideas?
Here's what bothers me about Amazon, serverless, and the cool kids: I'm a survivor of the industry in the 1990s, where for all intents and purposes, the "consumer-level software industry" and "Microsoft" were synonymous. When you have one (commercial, for-profit, led-by-a-well-marketed-visionary-pursuing-his-own-interests) company that defines the space available for innovation, then that innovation itself has a single point of eventual failure. I *love* the *idea* of serverless. I'll devote actual time and effort to it, and recommend that others do likewise, when the barriers to moving between serverless platform providers are shown to be trivial as a matter of course. You don't need a completely different set of tools to work on a Toyota engine than a Mercedes one. Anything that perpetuates the mythos that software development is this high and arcane art that is horribly experimental by nature and that people ought to adapt to it rather than it adapting to the needs of people, needs to be nuked from orbit at every opportunity. Serverless is no different.
Lambda's most recommended use cases are focused on workers and architectural glue code. If we could replace a monolith's core applicative logic (or any web app's core applicative logic) with Lambda, would we not have been able to do the same with any job processor, like DelayedJob, Resque, or Sidekiq? I don't mean to be a party pooper, but I think there might be some missing perspective here. Transforming a monolith into a set of services is way harder than moving existing code to self-contained runners (unless it's background job code). And it's not really Lambda's sweet spot. Just the idempotence concerns alone when dealing with AWS's message transports might be enough to turn a Ruby dev back toward monolithic architectures and ORM (not that there's anything inherently wrong with that). Lambda was ultimately created to optimize for the common cases when some trigger needed to run some utility code; to avoid having to host some minimal-but-necessary code in an entire EC2 instance or BeanStalk app, and to allow these kinds of things to be entirely on-demand. It's really cool that Lambda functions can be written in Ruby now, but I think it might be a bit of an over-simplification to hope that Lambda is a countermeasure for a monolith. At least, I'd say that based on what I've seen it used for in language environments that got to Lambda before Ruby, and what the docs and community resources tend to recommend. YMMV, of course. 
Ah - I almost missed that call (I am way too disorganized to systematically reply, so here goes. I'll not comment on all statements made, but a few comments: &gt; more functional tools I'd like less, mostly because the syntax coming from functional proponents is so AWFUL usually. ;) It's not that I dislike all aspects of "functional" programming as such. Anonymous everything is a cool idea - the best name given to something is ... no name! My favourite variable is still _ although I admit that I tend to use "i" the most in methods (due to my laziness... i for input ... yeah I don't have awesome names ...). Not all ideas are awful that come from functional programming but when I see certain proposals such as ... I dunno ... x -&gt; .foo(&amp;bla(&amp;.:ble(meh)) {|_| yay} Then I just lose it. And literally I can NOT WANT TO BE BOTHERED to have to distinguish between :&amp; &amp;: &amp; .: ... The pipe operator from elixir ... there is a secondary suggestion aka pattern matching, via case/when menu. That one I think is ok; the syntax proposal is not so bad either. (Pipe from elixir won't make it into ruby due to syntax problems .... and I have seen alternatives to it that are abysmal.) Anyway to the other comments: &gt; fibers should be more prevalent I have very little experience with threads. Most of it came from the pickaxe; and a bit via ruby-gtk bindings. IMO all of threads/fibers/mutex/threads/synchronize is a bit too complex and not easy enough to use, but your mileage may vary. I just don't like that it is so complex compared to e. g. String, Array, Hash ... or even enumerator (or is it Enumerable, I mix them up all the time). Everything should be simple, ultimately. &gt; we should wrote code for ruby 2.5 I sorta agree. Personally I am lazy. I recently switched to 2.6 (the syck-code on github actually works for 2.6, but I also finally started to rewrite my problematic yaml files - I had two ideas ... generate UTF-valid yaml files... or skipping this and writing the code directly into .rb files ... both will work, which I didn't think about before). &gt; more tools for ML/NLP/AI I don't mind, even though I poke fun at AI. But in general, ALL science-related code is GOOD. We need more people from science use ruby so I agree here anyway. &gt; more visibility on ruby core devs process. Currently &gt; you need to spend time on bugs.ruby-lang to get &gt; some inside Yeah I can understand that. I assume lots of communication happens via japanese channels. There was a change some time ago where you can suggest discussion of features and changes to the core team. It's not perfect but may be better than what we had 1-2 years ago. Personally when I had problems or suggested changes, nobu helped a lot. He is literally a superhuman beer-loving cyborg and deserves the nick patch monster too. I forgot who did a cartoon about him once but that was hilarious, like when nobu emerged from mount fuji (did I spell this even right... I did not google!). &gt; AMA with ruby people :) I don't mind. Personally, though, I think we need more varied and better gems. It's a lot of work to make a gem really great AND used by many people so I understand that not everyone feels like wanting to do so. But it's like showing "hey, I am doing this with ruby because ruby is cool", so ... there should be cool stuff written in ruby too. Not just rails alone. &gt; we need to become free from rails. Yes, I know this is &gt; somehow bad, but I truly like to see other libraries &gt; take off. I totally enjoy roda, sequel, shrine, falcon is &gt; a nice tool but just starting. 100% agree with you here. :) I don't have anything against rails at such but it is not good that it overshadows other parts of ruby. It's not all rails fault alone, people simply need to do things via ruby that others could also benefit from / use. &gt; better documentation. I enjoy more the documentation &gt; from golang, python or dlang than ruby :( Yeah. I said that too. The documentation is not awful but it is not great. It's somewhat mediocre. Perhaps ruby 4.x will have that as goal - we have to convince matz. :P We may have to phase out some doc-related tools too - I hope the rdoc and yard authors don't read this but ... :D &gt; better API to interact with c libraries Agreed. And more documentation too. C (and C++) is too important. There is no real way for me to avoid it (argh...) but I feel like I will have to spend a lot of time digging deeper into ruby. I did so many years ago already but it's a patch-set of knowledge and these days I lack time to polish these things. But yup, I agree with you. &gt; better way to find on google the ruby C API. yes, is &gt; even difficult to find it :) I can not disagree with you either. Personally I store things locally so I am not so dependent on remote sites, but I am aware that not everyone wants to do so. Takes time too. &gt; JIT pluggable. I've remember u/k0kubun when he create the first &gt; version, using llvm and it was a gem. That was a great idea. To be able &gt; to plug your choice of backend. dlang has this, DMD, GCC, LLVM, is &gt; a fantastic idea. As a gem, people will involve easier as I dont have to &gt; wait until 25 of Dec for a new major version :/ Agree too. Takashi is quite active, also on reddit, surprisingly enough. :D I think one major goal for him (and also probably others) is to get the JIT faster in general; and to have it work with rails too, all by default (at the least this is what I understood from it ... I am on 2.6.x but I am not really sure if the JIT changes a lot; although I have to say, I have this feeling that 2.6.x is a bit faster than 2.5.x in general for my code. Not sure if true or not but the response-time I have from e. g. question-trainer on the commandline, is a bit faster with 2.6.x than with 2.5.x. This may not be because of the JIT but because of other changes but I can feel some change here. May be my impression but ... I am about 80% sure that 2.6.x is actually noticable faster for me. Admittedly I also rewrote a lot of ruby code in the last 2 years, while also making it faster + adding frozen strings. That was probably the biggest factor altogether - strings are so important... &gt; language server protocol Don't have any preference or opinion here. &gt; sorbet show us that is possible to have typecheker for ruby. Yeah. And I don't like it, but again your mileage may vary. :P &gt; Ruby is a good language, but I feel that we are slowly getting &gt; smaller and smaller as a community. I think so too. I have noticed some ex-ruby folks who either quit ruby; or use other languages and ruby (but ruby less often). I myself am also using python but no worries, ruby is way better than python :) - however had, there is a worrying amplifer simply because there are definitely more python developers, which helps a LOT. Chasing python will be difficult. While I think ruby is better, the difference is not really that huge for most people. But I agree, smaller community leads to more fragmentation and disruption which is not good. I don't have a good solution either. I think the only thing that will work in the long run is if ruby itself provides a lot of "worth" to people who use it - more worth than other languages may do. Curiously enough, lots of ruby hackers went to Go. I don't fully understand it but I assume that one reason is that Go is faster (ok ...) while still somewhat simple. And people may be forced to use certain languages too, due to work/job related issues. &gt; I really like jruby, and I wish they will do more integration with java, &gt; and I hope that truffleruby will be there until is not to late :) I am more in the C/C++ family of thinking really so java does not play any real role on my linux system. But ruby + C is a pretty cool combination, now if only I would actually not suck at C this would be even greater ... I miss out on doing lots of cool things with mruby that way. Not good. :( 
I don't think that "very few people" care about it as such per se because there were other suggestions too, related to namespace/namespacing. It's not so easy to add and these (or similar) changes will probably come after 3.0. I myself want something similar but I come from another direction. I am getting tired of: require 'foo/bar/bla.rb' And then I change files and have to updated the hardcoded paths. I want a more sophisticated require-related way... and ideally some meta-tagging to know who "owns" something (but without preventing others from changing it; so purely information based). I still haven't written up a proposal. I am sorry, I am so lazy ... :( It also would probably be rejected so I hope for someone else to come up with something. :P Identity/"ownership" would help determine what has been modified and who; right now we can change everything which is great, but I'd also like to be able to restore to prior "snapshots" (of changes), and also do refinements without refinements (I am fine with refinements but the syntax is not good).
For me it is a question of syntax. Just one example - I always found the "-&gt;" lambda to be too strange and disruptive in my code so I opted to not use it. Several other suggestions are syntax-wise also strange ... As long as I can avoid them I don't mind so much but, boy, several of them are so terribly ugly.
&gt; Better publicity: For several years, there were a flurry of &gt; alternative conferences and discussion groups to evangelise &gt; the language You are quite right here. Ruby had more publicity after the pickaxe-book too for example. As for the "keep ruby weird", well. I have a bit mixed feelings here because we used to have evil.rb - yet that isn't so popular in ruby core team ... if you want to keep ruby weird, go integrate totally crazy ideas! I want shapechanging objects ... one GUI interface to rule them all e. g. class Button! :P
We do something similar in the Eventide stack: https://github.com/eventide-project/initializer It goes with a more comprehensive design guide that guides the implementation of every library in the stack: https://github.com/eventide-project/useful-objects Just an interesting little niggling point, though: The term for "Service Object" in the rest of the OO world is usually just "Object" :) It's really only in the world of ORM that we see _objects_ being conflated with data and data structures. Objects are behavioral. OO is behavioral. ORM is about data. ORM is a useful appropriation of OO to represent data. ORM is _OO with an asterisk_. Data needs to be represented somehow in an OO language, and it's inevitably going to be represented with objects. But data objects are supposed to be the exception, rather than the rule. Rails ignores the rule and focuses on the exception. The only reason we say _service objects_ is because we see data objects as a more legitimate form of object. We see data objects as a more legitimate form of object because we learned ORM before learning OO and we presumed that ORM is OO. If we could have a do-over with Rails, the word "object" might best be reserved for behavioral objects, and "data object", "data structure", or even "entity" would have been used to explicitly point out those exceptional cases when we're using objects to represent data.
https://github.com/sshaw/class2#class2
Ok so about the article - I keep this somewhat short since I had to reply to zitrusgrape (btw curious nick... isn't zitrus german too?) - I actually did not know about dry-rb. Will have to check it out before making a comment. - I knew about Hanami. Didn't spend much time into that either although it looked elegant when I looked at it for the little time I did (was ... a year ago? Or something like that). &gt; What are some of your favorite things? Personally I am still curious about the JIT the most; not only in regards to making ruby faster, but it would be pretty cool to have something like crystal, for ruby - but in ruby; even if it is not 1:1 compatible syntaxwise. &gt; However, some gems are starting to get a little stale. While it‚Äôs a bummer to see &gt; abandoned gems, it‚Äôs also an opportunity for Ruby developers to get involved in &gt; the community. A few may have also left ruby, like ... into dart. It was sass gem I think. I used to have like 130 gems or so, mostly just tiny and useless ones. I cut them down to about 90 and plan to have fewer gems, mostly because it is easier to manage fewer gems than more. Many other gems are also like from one company, and they add like 20 gems or so ... so it's not a good situation overall. I try to have fewer gems but improve the quality of the remaining ones. This will probably be the best altogether in the long run. None of these gems are very interesting though, I am sorry. :( &gt; If a gem you like using is abandoned, you can fork it or build a new gem and &gt; share it with the community. I‚Äôd certainly love to see some fresh gem ideas in 2019. I am trying this every now and then, re-using ideas from other people. Some older gems lack documentation and the code is horrible. I'd love to extend my main audio/video project with lots of more useful things including autogenerating music too but lack of time and lack of knowledge stops me. If anyone knows a lot about music, it would help to write a good gem related to audio/music here AND add documentation. That will help other people - if only to improve your API. :P &gt; Mike gives you a fantastic open source project, with the ability to pay for &gt; more ‚Äúpro‚Äù features. I imagine this helps Mike stay interested in the project. I think it depends on how you operate. My projects are hobby projects and while I would not mind donations (who would), I actually don't really want to become dependent on donations or change the focus of projects in this regard. I sort of want to keep things fun, as a hobby. I have had abandoned projects when they were no longer fun and some of these projects I never used again ... :( &gt; I‚Äôve made many messes with Ruby code. You could argue this is the language‚Äôs &gt; fault, but I would disagree. I think in my cases, it was a lack of discipline &gt; and knowledge. I am not sure. I think ruby makes it TOO EASY to write shitty code too; OR to use aspects that you don't need. Of course there is the "there is more than one way to do it"; that is fine. But many features are, IMO, unnecessary, such as @@class vars, but also other things. I think that not every feature is worth the trade off of syntax. People also get too excited about playing with it, without really needing this, which is strange. Imagine how much they could write if they would stop playing... like little kids. :P It also does not work well for ruby IMO if you have or think you may have fewer ruby users, when they go to use other languages. &gt; At times I‚Äôve wanted to move to a statically typed language. I dream of the &gt; things the computer can do for me. Wait a moment ... I can do things via ruby already. I don't need a statically typed language for this. Thankfully I have no need for a statically typed language as such in the sense that it would be a "good feature". It's grunt work that you are doing here - you tell the computer/compiler that this is of a certain type and no other type ... where is the fun in that? That is ancient shit. Future generations will look very sadly at humans who wasted their time with that (although being able to have FAST code is awesome - I just think it is a terrible trade to waste your life time as a micro-optimizing grunt). &gt; Granted, I wasn‚Äôt around for the Ruby 1.8 =&gt; 1.9 transition. I heard it was &gt; a little bumpy. However, in my experience, it‚Äôs been solid. I very much &gt; appreciate writing Ruby code with confidence. I had problems back then. Ironically the syntax changes were the least problem for me. The two biggest ones were encoding; and yaml files. Yaml files was my fault because syck didn't care about the encoding really whereas psych was always complaining about my invalid yaml files. The syck gem is still maintained though or at the least to some extent; I use the latest git source code for syck gem and it works on 2.6.0 (the gem syck right now does not work). Encoding ... well. That was annoying, even more so because I didn't have documentation back then that really helped me here. I think the default behaviour in ruby 1.8.x was better; less problems that way. I can work around the encoding problems these days but I am not a huge fan of it either. I understand why the change was made (the old way via global flags was quite ugly for japanese characters), but ... it was not great. You still have problems here even today (!): https://bugs.ruby-lang.org/issues/15497 Encoding isn't that awesome. It's been many years though ... I just move on and try to ignore that encoding monster when possible. :P (In my projects I usually define some alternative encodings so that I can switch if necessary; or allow people to switch the assumed encoding via the commandline.)
I like the way you think and I‚Äôm with you. And it‚Äôs more than simply having portability. I hope we get there one day. To be honest the best cases I‚Äôve found for now were really Amazon-related. Integrating with more of their services essentially. And it corroborates what you say too I guess. Outside of that Amazon niche, the way I see it, a ‚Äúportable lambda‚Äù is not much more than a queuing system worker.
We build evented, autonomous services with Ruby: https://eventide-project.org. There's no Rails involved since we mostly work on back end systems. I've only done a couple integration projects with Ruby. It's as fun as chewing glass :) But you've gotta do what you've gotta do when things that are disintegrated need integrating. Shipping messages around always sounds easy until the realities of at-least-once messaging set in. I burned out on brokers and such when the realization hit home that we have to implement idempotence in the applicative endpoints anyway. And then a friend said to me, "What's a queue but a degenerate form of a stream". You're not going to find something like Spring in the Ruby world. Depending on the parts of Spring that you use, you might be setting yourself up for a frustrating learning curve by not continuing with it. 
This might be relevant: https://github.com/mbklein/confstruct
I hear you. I share your ideas and concerns as well. Moving our beanstalk ‚Äúcommand host‚Äù filled with cron jobs to lambdas is not going to do anything to our monolith. Although I can‚Äôt wait to destroy that monstrosity haha The nature of our app has it that a massive portion of it is in Sidekiq and could be completely taken out. It‚Äôs just another alternative to look into now. To be honest I‚Äôd rather go with good old RabbitMQ. I kinda like devops in general and having lambda experience would help me out in my career. I guess what I‚Äôm saying is it‚Äôs just another tool in our ruby belt.
I‚Äôd recommend Kubeless as an alternative to AWS lambda ‚Äî it offers finer grained control, self hosting, and of course, is open source
Someone mentioned Eventide in this thread as well. It looks really neat, like a free ESB/MQ hybrid. What was your motivation on rolling your own implementation in Ruby?
I attended rubyconf this year and there was a lot of coverage on the JIT. Here‚Äôs my summary: it‚Äôs bad. I was very excited for the potential performance gains, but it actually makes performance worse in a lot of cases, even if you discount the warm up time. I think that choosing GCC might be the worst possible choice they could have made, and I think that the future of JIT in ruby will suffer until they rework it. It‚Äôs not ready yet, but memory and CPU usage are critical in highly available systems, and running a GCC process ruins both
The fact that the author didn‚Äôt do this by default is going to make me not even click the github link. This is a basic feature that‚Äôs a core part of literally any other widely used templating library. Use at your own risk. 
&gt; but IMHO it is the developer's responsibility to design their functions/microservices with those problems in mind Yup. I'm with you on that one. I think anyone who's done enough of this stuff would say the same. The challenge I've found is that it's not commonly understood that message transports are largely guaranteed to deliver messages more than once, and that devs are almost always surprised by this - usually after some operation is processed more than once, and repairs need to be made on production data. &gt; I could end up with a very complex system, with lots of rules and patterns that must be followed, taking away the developer's freedom to solve those problems their own way. Yup. And re-inventing RabbitMQ and ESBs along the way :) &gt; All that said, there is currently no way to simulate network problems with FaaStRuby Server (the local dev environment), but that's something I will definitely think about! There's also no way to simulate it in an operational environment :) It's hard to imagine someone expecting that kind of simulation capability. Not to mention, the network or even the transport, isn't the responsibility of the endpoint.
Caching is a feature that really should be left to the database layer/model and not bothering the views like this. Pretty cool otherwise.
&gt; Someone mentioned Eventide in this thread as well Doh! I just saw that. Oops. Didn't want to spam this thread. &gt; It looks really neat, like a free ESB/MQ hybrid Well, not so much an ESB or an MQ. It's an implementation of event stream storage, event sourcing, message handlers, consumers, and operating system process hosting. The semantics are closer to Kafka than Mule. But not Kafka (or even Kstreams). That's a tool for an extreme of scale that isn't exactly mainstream. There's a pretty sizable difference between ESB/MQ and streams. Most notably, there's no ACKs and there's no brokering. It's just straight up storage of messages in streams (and categories of streams), and an offset that the consumer tracks. Since handlers have to be idempotent anyway - even with a queue or broker that supports ACKs - the stream approach just does away with the artifice of "exactly once" insofar as ACKs are concerned, and just proceeds directly to implementing an idempotence key (usually a combination of a message's offset, and projecting state - including the last processed sequence - onto an entity using event sourcing). It's really a set of patterns meant more for SOA rather than Enterprise Application Integration. It could be useful in EAI, but it depends on the particulars. There's no routing, brokering, and those things that RabbitMQ, etc are for. So, might not be the right fit for integration of you're counting on those features from a broker. &gt; What was your motivation on rolling your own implementation in Ruby? Well, there really aren't a lot of toolkits for this kind of stuff in _any_ programming language. The Axon framework in Java is the closest, but it's got a different audience in mind, and for my tastes, it's kinda wrapped up in a lot of fads that I don't think will live as long as the applications built on it. We've heard on a couple of occasions from colleagues that work in other environments that they wish they had Eventide for their platform. We say... just use Ruby. Same thing we said in 2006 when we switched en mass from Java and .NET to Ruby and Rails. If you want a Rails, use Rails. Grails or Monorail (for example) aren't really Rails. If you want Eventide, use it :) It's a bit of a specialized audience, though. It was less of an issue of wanting to use Ruby as wanting to build an evented, autonomous services platform that reinforces SOA principles and doesn't invite the distributed monoliths that are not infrequently the result of "microservices" efforts. When it came time to to build it, we were already fluent in Ruby, and Ruby has some really nice language features for creating the APIs and abstractions that were really in the sweet spot for the kind of thing we were after. There's already a lot of ceremony in building message-based stuff, so we wanted the basic syntax for handlers, messages, entities, repositories, etc, to highlight the essence of the implementation. It's nice to have the dynamic binding (and even a little runtime code generation) without keeping the compiler fed on interface types. And ultimately, Ruby is a usually used for monolithic web apps - and a good deal of those teams are looking for other answers now. We figured we'd build some of those answers, and do so in an uncompromising way that can lead the user to SOA rather than patterns that are more problematic. So, it had to be built from scratch. There wasn't already an implementation that put the constituent parts together in the way that we were looking for.
See it as a proof of concept. It matters more to demonstrate that it doesn't break code at this point than make things fast. At that point there are any number of avenues to replace the backend. 
I hope for side effects as a result of many things in your list. I wish for sorbet turning into a thing that helps making Ruby faster. Due to ruby's nature it wont be used for things like Kubernetes or Docker anymore and unless we get Ruby's wasm and a killer framework for it I dont see Ruby catching up with the rest of the langs and ecosystems. I also hope for Rubymotion getting open sourced and being picked up by the community cc u/amirrajan 
I see a lot of "anti Rails" posts here. Although I agree Rails has its flaws, the amount of awesome gems widely available has always made it super easy to get shit done. When working with Rails, I'm always solving domain related problems. Lately I've been working on a microservice architecture; with jsonapi-resources, fast_jsonapi, BFF pattern, and React / Vue SPA's. I've been solving architecture related problems instead of domain related ones. Not cool. What I really miss these days are advanced rails helpers for frontend components. I see frontend developers creating awesome ui's using material design, and even though they need 500 lines and 1000 npm packages to create a simple form, the client is very happy with how the end result looks and feels.
Well, it's a bit more complicated than that... `escape_html` by itself is useful, but only in the context of html itself. There are different escaping rules in a `&lt;script&gt;` block, for example, or a style block, or a CDATA block. And, as /u/HaveSomeFreeKarma already mentioned, "unsafe by default" is never a good policy, it's always bettter to do the safe thing by default, and allow the unsafe thing when explicitly requested. So.. I'd suggest looking into replacing the strings with some templating engine - doesn't have to be ERB, if you want to keep the speed, maybe something like slim or hamlit could also provide decent alternatives. --- &gt; Am I right that rendering raw user input is the only place this would be a concern, or am I missing something? Well, mostly just user input, but really, any kind of non-component content whatsoever. For example, if you have article titles in the database, and one article is titled `Is 1 + 2 &lt; 3?`, you probably don't want that unclosed brace to eat the whole rest of the article. There is a very limited number of cases where you would actually want to use literal HTML, except when the HTML already comes from a component.. 
&gt; I see a lot of "anti Rails" posts here. Although I agree Rails has its flaws, the amount of awesome gems widely available has always made it super easy to get shit done. When working with Rails, I'm always solving domain related problems. The reason I personally complain about Rails is not because of its flaws (every library has flaws). What I mind that it encourages creation of Rails-specific gems, and pays little attention to other ecosystems in Ruby (e.g. Active Record vs Sequel), because why would anyone not use Rails. Want an authentication framework? Sure thing, we have Devise, Sorcery, Clearance, Authlogic... oh wait, they're all Rails-specific. As a Ruby-off-Rails developer I simply cannot use any of these libraries. (But that's ok now, because now we have [Rodauth](https://github.com/jeremyevans/rodauth), which I'm really excited about.) But the reason why I enjoy other ruby web frameworks is because I'm mainly developing JSON APIs; for full-stack apps Rails is definitely loads more convenient and unmatched by other web frameworks IMO for HTML views. In my JSON API projects I've found I don't need many of Rails features, and that a simpler web framework works equally well. That helps me to focus on choosing the best libraries (e.g. Sequel over Active Record), and upgrading is _much_ easier because I can upgrade each gem individually, as opposed to Rails which you have to upgrade all at once.
Really agree about the Rails missing batteries part (such as authentication) , even wrote about it myself: [https://medium.com/@yoelblum\_45935/rails-is-not-opinionated-enough-8435e81910a1](https://medium.com/@yoelblum_45935/rails-is-not-opinionated-enough-8435e81910a1) . Some very low hanging fruit for Rails to improve.
Operator precedence is a collection of rules that reflect conventions about which procedures to perform first in order to evaluate a given mathematical expression It‚Äôs a very important layer of any programming language. It can definitely change the way of using a language. [SEE MORE](https://medium.com/rubycademy/4-interesting-examples-of-high-precedences-operations-in-ruby-bd9e49dba52b)
&gt; Rack::Component doesn't do any escaping by default That makes the library unsuitable for 99% of real-world applications. It's a *huge* gotcha; it should be written in bold capital letters at the top of the README, if you really want to keep this in the design.
&gt; better documentation. Could you please provide some insights/examples about it? Do you mean particular clases and methods docs, or language reference-style docs, or ...?
I appreciate the shout out. Here are my two cents on all this: If someone actively depends on an open source ‚Äúthing‚Äù, it is their responsibility to understand, protect, and ensure that dependency‚Äôs long term viability. To put it another way (and as kindly as I possibly can), the problem with Ruby isn‚Äôt the language, it‚Äôs those that have used it for many years, but haven‚Äôt bothered to even attempt to build Ruby from source. So, I don‚Äôt know... dig in and get your hands dirty with some highly optimized low level C. I think Rich Hickey explains the problem fairly accurately: https://gist.github.com/richhickey/1563cddea1002958f96e7ba9519972d9
My point was that people and the Ruby community does not really care about things that are sort of niche or get in your way. RM is niche, expensive and did not get the momentum due to price therefore its community is small. How often is RM even discussed on /r/ruby ? Never ? Very few know that it exists and even less care about trying it out. And why is that ? 
&gt;My point was that people and the Ruby community does not really care about things that are sort of niche or get in your way. Again, trying my best to be kind. My extreme-for-the-sake-of-clarity point is: those that have never even bothered to clone the Ruby repo, don't get to participate in these discussions, and shouldn't have any expectation of being heard unless they (or the companies they work for) contribute time/money to Ruby. &gt;Very few know that it exists and even less care about trying it out. And why is that ? I think that's the point. I don't care if it's discussed or not (less so by those that aren't a customer). RubyMotion powers (and is sponsored by) all the stuff I've created with it. It has worked out very well for me. It may work out very well for you. A small number of people understand the value of that. I work hand-in-hand with those that use RM and make sure they succeed. And if/when they do succeed, they continue to support RM (as I do with my products). &gt;RM is niche, expensive and did not get the momentum due to price therefore its community is small. The starter version is free, and I've never said no to giving someone a full-blown license if they can't afford to pay (contributing to RM open source awards you a license too btw). LTS support costs money, which is fed back into LTS for RM. Why care about size? The owner of the product (me) eats his own dog food, and has succeeded in a non-trivial way: #1 app on the AppStore, #2 app on the Google Play, 3M downloads across his assets worldwide, a project in the works using the Tobii Eye Tracker on MacOS, and a game releasing on Nintendo Switch. Sleep on it. You've vocalized the exact problem with the state of OSS and its users. Size matters because the majority that use OSS, don't give back it in any way. So the safety net has become: "large company X built it and will guarantee maintenance of it". Which sucks.
I appreciate everyone's help in making this library safer. Sinatra does not escape output by default, but provides instructions for how to do it and for how to enable it by default. My first instinct was to do likewise, but it sounds like many of you would think that's unacceptably insecure. I'm torn between updating all of the docs with safe examples vs updating the code to run all output through a template engine. I'm fine sacrificing speed for safety ‚Äî ERB is plenty fast ‚Äî but one thing I like about the current API is that Components are agnostic about what they return. JSON? A Tilt template? A plain Ruby object? All fine. This makes them very easy to compose: one component can fetch data, the next can transform it, the next can represent it as JSON or HTML. One solution could be to escape any string accessed via the `env` reader by default, so that, for example, a component like this would render with escaping: ``` class PostView &lt; Rack::Component render do |env| &lt;&lt;~HTML &lt;h1&gt;#{env[:title]}&lt;/h1&gt; &lt;article&gt;#{env[:body]}&lt;/article&gt; HTML end end post = Post.find(some_id) PostView.call(title: post.title, body: post.body) #=&gt; safe ``` This might be too fragile, though. If `PostView` were written to fetch the post directly instead of to accept its fields as input, then it'd revert to printing unsafe output. Thanks in advance for thoughts on this approach, and for any other suggestions. I do want to make this a safe library by default, and am willing to change the pre-1.0 API substantially in pursuit of safety.
Can I ask why you think so? The memoization API is so small that it doesn't add any substantial overhead, so it's totally fine to just not use it. What I like about it is that it makes caching easy in situations where you couldn't otherwise use it, like in an environment without memcached, redis, etc.
just go the website. It looks that is from 2000. then, somehow you manage to get the api documentation, and is this https://docs.ruby-lang.org/en/2.6.0/ vs https://docs.python.org/3/library/index.html vs https://golang.org/pkg/ vs https://dlang.org/phobos/index.html UI perspective is a mess, a crazy ugly page.
&gt;but I assume that one reason is that Go is faster (ok ... Actually I think the main point is deployment. Go is compiled and makes things super simple to distrutbute as tools. &amp;#x200B; I really do think Moving to Github would have helped the development community from engagement to participation. But I read Ruby Core Dev are against using Non-Free Tools. &amp;#x200B; But I think the major problem with Ruby is actually resources. Are there any Core Dev working on Ruby Full time?
You are partially misjudging the situation. I will try to write it in a way it does not sound offending. Also beware i am writing on mobile while commuting. &gt; Again, trying my best to be kind. My extreme-for-the-sake-of-clarity point is: those that have never even bothered to clone the Ruby repo, don't get to participate in these discussions, and shouldn't have any expectation of being heard unless they (or the companies they work for) contribute time/money to Ruby. I mean this affects any kind of digital content. There are numerous factors responsible for this state of things. - people not giving a fuck - people not being competent - people not being allowed to contribute - leechers It is wishful thinking to believe the community can work like a private torrent tracker. To me it often seems it is going into extremes. It is either fully ‚Äúfree‚Äù or has a ‚Äúprice‚Äù and rarely something in between. But software is becoming more and more like a platform where the underlying operating system is ‚Äúfree‚Äù and it is the ecosystem that earns money. &gt; I think that's the point. I don't care if it's discussed or not (less so by those that aren't a customer). And that is the problem that you dont care. This is reall y off putting. &gt;RubyMotion powers (and is sponsored by) all the stuff I've created with it. It has worked out very well for me. Good for you. I hope it keeps staying alive however i dont see it having a bright feature. &gt;It may work out very well for you. I will probably never find out because I wont invest in a super niche technology. &gt;A small number of people understand the value of that. I work hand-in-hand with those that use RM and make sure they succeed. And if/when they do succeed, they continue to support RM (as I do with my products). Look. What about the people in different parts of the world? How can they expect any support at all? You do realize that people wont pick RM for all sorts of things many of which will have nothing to do with the price. You cant be online 24/7 and you wont be able to solve issues promptly either. There is loads of things that can pop up in specific scenarios and people wont know about them due to the super small community. Look at hashicorp and their ecosystem and however i dont know how sustainable or profitable their model is they seem to be doing well. They provided good products as oss tools and gained a big enough community. That is assuring and convinces companies trying them out because they know they will be able to find enough resources to solve their problems. &gt; I'm trying to figure out how to open source it in a sustainable way. But seriously (at the risk of beating a dead horse), the majority of the Ruby community hasn't even cloned the Ruby repo. That's not going to magically change if I open source RM. I am not moaning about RM being expensive for me. I can afford it. What i cannot afford is to pick the wrong tool for my team. This is not about getting a freebie and taking advantage of it. It is about RM being relevant. When we have evaluated different products we did not even consider RM as a platform for internal apps. It is just too risky to use. What if you go awol. What if you have other priorities ? Technology is becoming a commoditiy and RM is this nice shiny big iron that only few can afford to use. But for how long ? tldr: RM not having a big enough community because of its costs/ not being oss and therefore irrelevant as a technology for people sort of like a chicken egg problem. 
You can get halfway there by naming your ActiveRecord model objects like other entities: UserController &lt; ApplicationController UserMailer &lt; ApplicationMailer UserSetupJob &lt; ApplicationJob User**Record** &lt; ApplicationRecord 
&gt; it might be REST or GraphQL, or possibly both you should start by writing your API specs and then chose the stack and patterns that best suit your end goal. selecting a stack first is how people with square pegs and round holes with really jenky workarounds. hosting depends on how you plan to scale.. id probably start on heroku and switch to AWS when im ready to scale up
What is the API for? If it's to be the frontend for a database then you'll need... a database. AWS RDS can get you one of those quick, and it looks like [AWS Aurora supports a serverless mode of operation](https://aws.amazon.com/rds/aurora/serverless/) for the databases they support.
Take a look at [FaaStRuby](https://www.reddit.com/r/ruby/comments/9yc33a/faastruby_025_released_with_multiple_regions/) and [Hyperstack](https://hyperstack.org/).
Yeah the API is meant to be the interface for a database. I wasn't sure if AWS Lambda would provide the DB or not which is why I asked about a bucket. It sounds like AWS RDS/Aurora will be very useful, thanks for the suggestion. How does Lambda differ from Aurora? For what use cases would Lambda be superior to something like Aurora?
Oh wow, thanks for pointing this out. I've updated my post based on this new information.
I have a rough idea of the specs and based on that I think REST makes more sense. Assuming that I do want a REST API, would an App with ActiveRecord and Grape run with relatively little config on Heroku or do I need an additional layer to get that running? Do you recommend Heroku for the beginning because of better pricing (plus they give you free hours, thats cool) or because its easier to configure and deploy to?
heroku is cheap and allows you to go live quick. hosting shouldnt be your primary focus here unless you expect huge volume on day one
I don't expect that, Heroku looks ideal for working out all the kinks while we develop the App. Thanks for the help!
Lambda is a way to execute your code, an alternative to heroku in this case. For simple APIs on top of a database, Lambda + Aurora/DynamoDB is a very cheap setup, and also extremely scalabale. 
Funny thing is, under the bonnet ActiveRecord is not really the active record pattern. The guts of AR are basically a repository pattern that surfaces the repository, relational and DAO responsibilities through a single class. There may even be a feasible (but epic) refactoring of AR's elements such that `User &lt; ApplicationRecord` decomposes into `User`, `UserRepository` and `UsersRelation` classes. I know some people would say "just use ROM if that's what you want" but I have insurmountable philosophical issues with dry-rb. 
If I ever go awol, RM goes open source. There's essentially a dead man's switch in the acquisition agreement that the codebase _must_ be open sourced if I ever decided to dissolve the company. The IP is in "escrow". RM has been around nearly a decade now. It works. It's not new and shiny. It's battle hardened and can natively leverage all Android and iOS frameworks. I have a solid subscriber base that build real applications. But that's not the definition of success these days. Let's take a moment and be honest. There's literally nothing I can say to convince you that RM is a safe bet. Regardless of what rebuttal I give, the goal post will be moved. At the end of the day, most dev's definition of "safe" open source has become "big company X made it and will maintain it". That definition is totally valid if you're okay with giving that kind power to an entity that cares _jack shit_ about you. But at least acknowledge that as a risk you're willing to take. I'll try beating the horse one more time: _Complaining about something not being open source, and at the same time refusing to invest non-trivially to the OSS dependencies your business relies on, is absolute madness_. Take RM out of the picture completely for that statement. Most adopters of OSS only do so because there are enough _other_ people to bare the burden of maintenance, and just take the free ride. If that OSS thing that was adopted ever goes out of fashion, they'll jump ship to the next popular thing. Not sure how else I can make this clear. 
Haven't looked at that but I think what you're describing would be a main class that iterates through calling a number of individual classes?
&gt; If I ever go awol, RM goes open source. There's essentially a dead man's switch in the acquisition agreement that the codebase must be open sourced if I ever decided to dissolve the company. The IP is in "escrow". That is not the point and you know it. You might be unresponsive for a week just unwinding or rethinking strategy. RM going open source is not the point. It never was. &gt; RM has been around nearly a decade now. It works. It's not new and shiny. It's battle hardened and can natively leverage all Android and iOS frameworks. I have a solid subscriber base that build real applications. Yeah what a shame that fewer than a few thousand of people are going to ever benefit from it. &gt; But that's not the definition of success these days. Dont you see it by now ? It is Laurent‚Äôs , Amir‚Äôs and other devs success not RM‚Äôs success. &gt; Let's take a moment and be honest. There's literally nothing I can say to convince you that RM is a safe bet. Lets be honest you dont need to convince me as you said you dont care about opinions of people that do not pay subscription. I have the feeling you as a businessman are trying to convince yourself that the decisions you made are the right ones. &gt;Regardless of what rebuttal I give, the goal post will be moved. At the end of the day, most dev's definition of "safe" open source has become "big company X made it and will maintain it". Not really. I have proved that the definition of safe is large enough community that gives the sense of safety even if in your opinion not all of them contribute. I think people raising bugs, writing blogs or answering questions on SF counts as contribution and often is just as important as PR to the upstream. Numerous companies that built their product and gained traction were not a big company X. Hashicorp being an example or redis or docker etc. &gt;That definition is totally valid if you're okay with giving that kind power to an entity that cares jack shit about you. But at least acknowledge that as a risk you're willing to take. Majority agree that that is a low enough risk to take. Much lower than going with an unknown unsupported tech. &gt; I'll try beating the horse one more time: Complaining about something not being open source, and at the same time refusing to invest non-trivially to the OSS dependencies your business relies on, is absolute madness. Take RM out of the picture completely for that statement. Most adopters of OSS only do so because there are enough other people to bare the burden of maintenance, and just take the free ride. If that OSS thing that was adopted ever goes out of fashion, they'll jump ship to the next popular thing. Not sure how else I can make this clear. You are in denial if you think freeriders is not the norm and it was the norm since the dawn of the internet companies fighting for domination. The days of proprietary expensive programming languages and compilers are not coming back. If Amir feels like he cannot compete then so be it, RM stays being a niche technology for couple of enthusiasts. Again you keep reiterating on contributing to OSS or what not. I care jackshit whether RM stays closed source or goes OSS. I care jackshit if it is free or paid or you decide to sell it to the BigBadTechCompany and I still have to pay for it. I care about RM being relevant. I care about RM being used, about RM being talked about and about RM being able to compete with RN, Xamarin and native. 
Nah, maybe I explained it poorly but what I am trying to achieve is something which automizes my file. Like sidekiq or cron but I can‚Äôt get it to work. 
Or User::Record, User::Repository, and User::Relation :) Thanks for the kindness. Much appreciated.
Perhaps you're asking about the usage of Sidekiq? Sidekiq is a background job scheduler/processor. That #enqueue method is a Sidekiq method.
Yeah exactly but I can‚Äôt get it to work properly on my code so i tried to orientate on the example 
Thanks for the conversation (I genuinely mean that). I don't have anything more to say other than what's already been said frankly. Best of luck to you (again I really mean that). I'd also give Flutter a shot if you're still exploring mobile development, it's made by Google.
Hmm, well what is the problem that you're experiencing? It's been a bit since I last used sidekiq, but from what I recall you enqueue a job and then run sidekiq. Sidekiq runs as a daemon and periodically queries redis for queued jobs. You'll need to provide more information about what you've tried and what issues you're encountering.
At the moment my code looks like this but i am pretty sure i didnt understand sidekiq right and something is wrong in that code and usage of it. I would really appreciate some help. [https://repl.it/@WebSepp/HarmfulAnotherLicense](https://repl.it/@WebSepp/HarmfulAnotherLicense)
I also genuinely meant what I said. I want RM to succeed. I personally am not in mobile apps business and cant talk management to give the mobile apps to our ruby team but I hope one day RM becomes a viable alternative. Until then the company stays on Xamarin. Good luck to you as well.
If you are trying to build some sort of MVP and looking to launch quickly, then I recommend the heroku route as it is dead simple and will certainly meet your needs as far as scale for a good while. If you are running into scale issues, that can be one of those ‚Äúgood‚Äù problems that you deal with as you reach that level of success. As far as the stack is concerned, certainly many projects and companies have been built using Ruby/Rails (assuming bc you said ActiveRecord for ORM) with Grape. There‚Äôs plenty of documentation and a big community, it‚Äôll take you far. 
if youre new, dont use graphql. stick to absolute basics such as rails 5 API mode. dont bother with grape either. learn that, then move up a little and understand what makes the more advanced things work/tick. 
I‚Äôm thinking usability and developer experience. Most caching APIs are fairly consistent in regards to expiration, TTL, etc. you‚Äôre basically creating a ‚Äúnew‚Äù API which won‚Äôt have value outside the template rendering. I‚Äôd expect every senior dev to completely ignore that feature, and any noob would probably just incorrectly use it. Your docs show it almost as a primary focus feature. 
I think you‚Äôre missing a class like [Clockwork](https://github.com/adamwiggins/clockwork/blob/master/README.md) to schedule jobs. You set it up like: `every(5.minutes, 'myJob.job')` Run it with: `$ clockwork clock.rb` As long as your machine/server is running it will run your Job every 5min. 
Thanks for considering Jets. There's an API mode with the `jets new` command. Here's are some quick start commands: jets new demo --mode api cd demo jets generate scaffold Post title:string vim .env.development # edit your local database creds jets db:create db:migrate jets server # Check out site at http://localhost:8888/posts vim .env.development.remote # edit your remote database creds jets deploy That creates a JSON REST API. Once nice thing about serverless is you only get charged for requests. So extra environments are will likely be in the free tier. So you could do this: JETS_ENV_EXTRA=2 jets deploy JETS_ENV_EXTRA=3 jets deploy ... JETS_ENV_EXTRA=8 jets deploy
I dont think its good practice as just complicating things but you could easily do def function1(*args) Project::Part::Module1.function1(*args) end If you need for many functions you can do some metaprogramming of a function like includefunction(module,*functionnames) that does exactly what you are looking for
Thank you this was very useful. 
There you go https://github.com/ciconia/modulation
If you won't be using Rails, I'd consider [sequel](https://github.com/jeremyevans/sequel) instead of ActiveRecord. No opinion on the rest of your questions. 
I don't like the API that much but the idea behind this is pretty nice; It reminds me of aspect-oriented programming and I think matz, in the past, spoke about adding something similar to this in ruby some time ago. Someone should file an issue request perhaps.
&gt; Very nice little library. I'm honestly surprised some &gt; syntax like this hasn't already been added to ruby &gt; core, given how common it is. I think this has been suggested in the past and matz said something along the lines of there being a possibility of something added ... along those lines. I think it was from a suggestion from sawa on the bug tracker - that japanese guy who like had dozens of suggestions accepted in the last 10 years or so. :) (I am terrible with names ...)
I do not think that gradual typing has any real chance to be added into ruby core. The suggestion here is very different by the way since it focuses on removing boilerplate. That has a much higher chance to be accepted in one way or another; I guess syntax plays one role in whether/how you can add it to ruby.
&gt; I've been trying to implement it based on keyword arguments Keyword arguments are heavily overrated anyway. I remember I had a discussion with the author of kimurai. I proposed more flexibility in passing arguments; right now one argument only accepts keyword arguments but not a Hash, which I find limiting. People should be more flexible and the awkward thing (!) is that the keyword arguments made the API less flexible. I guess people even forget that they may omit the {} for passing of hashes in most cases .... it's sad.
&gt; Problem with keyword arguments was they they cannot &gt; be declared using metaprogramming eg. define_method, Another reason to not use them. ;) Ruby added lots of useless things in the last ~3 years ... :( The rest of ruby is still unbelievably awesome but I can not say that ruby is as great as it is compared to some years ago, syntax-wise. And the added complexity ... wow. jeremy evans pointed this out on the bug tracker with lots of bugs coming PRECISELY (!) from the keyword-hash dichotomy. It's a bad situation IMO. I am grandpa ruby now, only remembering the good old days ... 
If you can not define them dynamically then this is what pawurb wrote, didn't he?
&gt; Argument lists are not an object. Wasn't everything in ruby an object? I even want case/when menus to be objects that we can address to from anywhere in ruby code, including re-use. But I am weird ...
Hmm. The problem is that the ! there does not fit; I agree about .call otherwise, but I disagree that it should instead be .execute! I actually hate methods with !. OptionParser also uses .parse!() and I hate option parser - considering how many commandline libraries are written in ruby, I am hardly the only one disliking optionparser.
I find that highly annoying and superfluous. It reminds me of people who do this: if foo then end Or in case/when, use then. Ruby allows for a lot of syntax which I would just forbid. I would not be a good language designer. :P
Finally I agree with you! Do note that the idea in itself, not necessarily the one suggested here, is one that matz has been thinking about in the past. I forgot the name he used... method contracts or something like that...
Yes, this is quite true. As crazy as it is but I end up using ARGV and parsing this on my own rather than using e. g. optparse or get_opt_long. The default in ruby is so much prettier or easier or more straight forward to use. Ideally solutions and additions should be simple. I think the core idea is not bad. I myself want to make my code simpler and I end up writing too much boilerplate in ruby still.
Procedural code? You are not drunk are you?
The problem is - we could need something like this in core ruby. Gems will not have enough leverage. Many of us won't even ever see any of these gems, yet alone use them.
&gt; Ruby's require and include are all-or-nothing: That is quite true. I also mentioned this in the past on the bugtracker. You can try your luck on the ruby bugtracker and suggest something. You would not have been the first one; and neither the last. I have a feeling that we may see more control about what we can do in the long run, since so many people seem to use that, but ruby moves forward a bit ... slowly. They are quite focused on some core goals for ruby 3.0 and it's hard to make room for large changes that have a lot of momentum. Smaller changes are easier to do.
I have a preference of `#[]` for proc invocation. It looks cleaner and there are more alternatives that quack the same. I'm particularly fond of wrapping lambdas with a `Hash.new { |Œ∑,Œ±| Œ∑[Œ±] = Œª[Œ±] }` for cheap memoization. 
Heh, I've gotten so used to the following pattern when I need a script (but not a CLI): ``` queue = ARGV until queue.empty? case queue.shift when "--port" then port = queue.shift #... end end ```
The bang is making changes, presumably. If execute, so call, simply contains some pure functions, then no bang is needed. If it‚Äôs making an api call, or saving something to the database, then the bang tells that story. Bang is ‚Äúdestructive‚Äù usually, which explains your parse! example, as it modifies the the variable in place.
Thanks for explaining. I agree with you, mostly, although I'd the give noobs a bit more credit and I'm hoping the `memoize` API appeals to some senior devs who spend lots of time writing React.js components. The API echoes React's [PureComponent and memo](https://reactjs.org/docs/react-api.html#reactpurecomponent) APIs, and I, at least, find it useful to be able to think about memoization the same way in both contexts. But I think I will drop the parts from the README about time-based caching and network calls, seeing as they really are about caching, not memoization. Thanks again for raising this, /u/seaninhd.
Spot on. In the current industry, serverless is less about decreasing the need for persistent, stateful systems than of increasing the dependence of the software-developing public on Amazon. We've been here before, and it wasn't something any sane industry would want to ever, *ever,* think about repeating. Amazon want to be the single point of failure for the software industry, for B2C commerce, and as many B2B services as they or anybody they can copy can think of. Treat that as the existential threat that it is, and we may get somewhere worth being.
yeah I just noticed when setting up capybara JS testing in a new app, and going back to the capybara docs instead of just copy-pasting from old apps. 
The `memoize` API, which introduce _hidden global mutable state_ into the application, is by far the largest wart in your design. It makes code that invokes it untestable, probably non threadsafe, not to mention implementing `memoize` is almost trivial and should be left up to some other layer in the application and composed in. It has nothing to do with view rendering, which is all React tries to be - in fact, it's the antithesis of React, which abhors global mutable state.
Second this opinion on avoiding grape. Currently using this in production for some things and not very fond of it. There‚Äôs a lot of magic about how it works by reading your source code that can make things hard to debug. Aspects of it don‚Äôt feel like idiomatic ruby. 
Cannot recommend Postman enough in a situation like this. This has nothing to do with how you choose to implement your API but is a wonderful resource for everything else *about* your API. - promotes contract driven development - extremely easy to add examples of different HTTP and API responses - very easy to add tests to validate your implementation - documentation is a breeze - Easy to share with your team - My favorite aspect - implementation agnostic testing of your API
Yikes. RubyGems 3.0.0 was first shipped by default in 2.6.0, right? Which just came out *last week* and during the holidays which no one is updating their Ruby versions anyway. Seems like a pretty harsh backward incompatibility to ship. Glad they fixed it but not before a lot of people got bit (myself included).
As always I'll likely be writing up an article on this later, but wanted to tease the idea to get people to criticize just \_how\_ horrid of an idea it is. Considering this is the internet and this is me posting, very little time indeed :D
That design is flawed, since you cannot `initialize_with` a mixture of regular args and keyword args. But yes, I agree that this is the best option available given the current constraints of the language - unless you use `eval`. 
Looks interesting, thanks for the tip! 
This post (quite reasonably) focuses on what happened and how it's been fixed, without really going into the why -- and in doing so, leaves out some context that makes the intention far more reasonable: When you `gem install foo`, RubyGems will install the latest version of `foo` (or, say, `bundler`) _that is compatible with your Ruby version_. There's also a RubyGems version field in the gemspec, and it "should" be treated the same way. It turns out it's not. But their intention, AIUI, was that `gem install bundler` would install the latest 1.x release for everyone who didn't have RubyGems 3.0, and the new 2.x release for people who did. That sounds like a great plan to me... but sadly software has bugs (or missing features).
That does make sense and seems like a very reasonable thing to do. Thanks for the additional context. 
*Almost* everything is an object. Exceptions include: Argument lists, keywords including logical flow operators (if, case, for, while, unless, until, class, alias, begin, end, rescue,...), and more importantly blocks (but *procs* are objects). 
This will give you an index of all of the articles and everything else I've been up to in 2018.
This insecurity about using Ruby is coming up time and time again. I think it's not because of actual objective reasons, it's just a psychological thing - thinking that "what if the grass is greener somewhere else". Believe me, if Ruby starts to become irrelevant, you'll know.
Sinatra, MySQL, Ubuntu (Digital ocean) and nginx. Honestly all you need and you'll learn a lot on the way
&gt; Implementing `memoize` is almost trivial and should be left up to some other layer in the application and composed in. Thanks for weighing in. On reflection, I agree with this part of your comment, and with /u/seainhd's opinion that this API belongs in another layer of the app. I'm going to drop the `memoize` API after I deal with escaping output by default. I think you're wrong in the earlier parts of your comment, which is probably because of poor documentation on my part. If I weren't going to drop the API, I would try to write better docs. &gt; It makes code that invokes it untestable, probably non threadsafe... The API is designed to be threadsafe -- thread-safety was the fun, nontrivial part of implementing it. Maybe I missed something? I can't see how it would make code untestable. Calling a Component.memoized() with the same `env` gives you the same output; calling it with a new `env` gives you different output. In both cases, the output is just a function of `env`. &gt; ... global mutable state into the application is by far the largest wart... If by "global" you mean that the memoization caches persist for the lifetime of an app's process, then yes. A cache that didn't persist at least that long wouldn't be much use. But there is no "global" state in the sense of a hidden, top-level object. Each class that inherits from Rack::Component gets its own, threadsafe memoization cache, which lives as a class-level attribute of the inherited class. Anyway, I guess this will all be academic soon. I appreciate your feedback, and would value your opinion on escaping output after I publish a working implementation to a feature branch. 
It does make one wonder to what extent it was tested before release. The attempt to release bundler 2.0 simultaneous with 2.6.0 (because it was included _with_ 2.6.0?) probably didn't help; it might have been safer to let 2.6.0 be out for a bit before releasing bundler 2.0, but not sure how to make a release plan like that that also includes MRI coming with bundler. When bundler breaks, it's about the most disruptive thing that can break for nearly the entire community. It leaves me definitely unenthused about the [announced plan](https://bundler.io/blog/2019/01/03/announcing-bundler-2.html) to do backwards-breaking major releases once a year, and drop support for old rubies more quickly. Bundler's extreme commitment to backwards compatibility has been incredibly helpful, if there's any part of the ruby ecosystem that needs that, it's bundler. (I think it's fine to have done a release in 2019 that drops support for 1.8.7, I'm not saying _never_, but I'd rather it be more conservative than version support (and other backwards breaking changes) yearly). Also, I wonder if there was some way to fix the bug in a _bundler_ release instead of needing to wait for a whole bunch of coordinated rubygems releases. Even at the cost of temporarily rolling back some features. Basically, if there's any piece of ruby software which needs the most cautious, conservative, developer-pain-avoiding approach possible -- it's bundler. This does take more time and energy. It's possible that bundler doesn't have enough dev resources, although one would have hoped the rubytogether support of bundler would help a lot there. 
Are you an individual or a company? If an individual, sure, use Rails‚Äôs API mode. If a company, go with Grape. Rails‚Äôs API mode doesn‚Äôt give you anything special, it just strips out some things you probably won‚Äôt use. It doesn‚Äôt do anything to help you create an API, and you‚Äôre still writing a Rails app and left to solve all of the problems of an API. Grape isn‚Äôt perfect, but it is an API framework. For a company, a framework will simplify and accelerate while providing consistency. It‚Äôs opinionated nature will eliminate bikeshedding. Where it fails to meet your needs, you can address it with PRs or OSS gems. Having experienced a company going the Rails route, it was an expensive mistake, and if I were doing it again, I‚Äôd use Grape.
You're welcome. I'm glad you liked it! :) 
I mean, there's a certain elegance to the replaced solutions, but I wouldn't necessarily call the previous solutions worse. The second problem also looks incomplete, and doesn't deal with the height; would it be as elegant with that included? There's a large case to be made that the replaced solutions will be more difficult to understand when you return to the code. At least, with these examples. I'm not even sure the last example (before the real-world problem) gets rid of any "special cases". I don't think there's an argument that overly convoluted cases are bad practice, but I don't see the case being made in the examples. The real world example is just bad by design. I mean, that's a terrible way to store hours of operation. Bit fiddling has some purposes in high-performance code (games/embedded systems), but I don't think I've seen a worse way to store hours of operation in my experience coding (and I've done that kind of thing several times).
&gt; beg to differ. Switching coroutines across threads in a pool seems like a no-brainer to me, and the way context-switching works in the go M:N green thread model. But I guess we're just gonna have to agree to disagree. Not to speak that go's goroutine scheduler tries to reuse a running OS thread as much as possible, by scheduling a waiting goroutine to run in a thread when a hitherto running goroutine blocks. But yeah, you can only achieve that if (M) green threads are decoupled from (N) OS threads. Which is why I wager ruby should follow suit and make plans to have a separate Guild with no concurrency abstractions other than coroutines (reusing the expression RubyRoutine here). No ruby Threads or Fibers, just auto-scheduled coroutines all working under the hood. And, like go, no encapsulation of coroutines in objects, to cut short the users temptation of messing with deterministic scheduling. We already have most of the 'proto-ingredients': Koichi Sasada is working on Guilds and Channels (you'd need something like Guild to keep compatibility with Ruby 2 and existing C-Extensions). Eric Wong is working on auto-fibers (fibers that yield when doing a blocking operation). Now /r/ioquatix goes one step ahead with the automatic resuming of 'unblocked' fibers and abstracting fibers into tasks (go has one 'mini-scheduler' per running OS thread btw). JIT will, as per Koichi-san, provide method inlining and escape analysis. We're only missing growable stacks for couroutines (see [https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast](https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast)). That'd be a huge gain for IO-bound ruby apps (think web frameworks), a huge simplification of ruby concurrent development, and could make up for Matz's regret of introducing Threads in ruby. Make ruby great again? &amp;#x200B;
Bad idea. By defining \`to\_hash\`, ruby may treat nil values as keyword args, resulting in unexpected behavior. Consider this function: def foo(arg = 1, keyword: 2) \[arg, keyword\] end Without the monkey patch, you get \`foo(nil) == \[nil, 2\]\`. With the monkey patch, you get \`foo(nil) == \[1, 2\]\`, because nil is treated as keyword args.
Looking forward to reading this later, is an issue I've stumbled with in the past. 
Thanks ! So I hope that it'll be helpful ! :-) &amp;#x200B; Happy new year !
I believe I resolved this by looking at the difference in Avatar URLs. Also, I think the problem is the real images are PNGs, but the broken link images are SVGs that ruby can't read. I can resolve this by either putting in a conditional to treat URLs with certain syntax differently, or getting support for SVGs.
 obj1.gsub!(' ', "\t") I am not sure but I think .tr! may be faster than .gsub!. A minor thing indeed but well. 
I can understand that. I myself do not use bundler but I think the overruling reason was to get bundler into default ruby, which will benefit both gem, bundler and the ruby ecosystem as a whole (at the least so it is said; for those who bundler it may be an improvement in the long run). That does not diminish the pain points, but it sort of provides one reason as to why the change happened.
While I agree with you in principle, one part I think is not correct: &gt; it might have been safer to let 2.6.0 be out for a bit before releasing bundler 2.0, &gt; but not sure how to make a release plan like that that also includes MRI coming &gt; with bundler. If it would not have been released with 2.6.0 I can tell you what would have happened instead - you would wait for another year. Because it would have other disadvantages to want to release bundler without it being an "official" part of ruby as-is. &gt; Basically, if there's any piece of ruby software which needs the most cautious, &gt; conservative, developer-pain-avoiding approach possible -- it's bundler. This &gt; does take more time and energy. It's possible that bundler doesn't have enough &gt; dev resources, although one would have hoped the rubytogether support of &gt; bundler would help a lot there. This depends a lot on the ruby user. I use gem and oldschool setup.rb. I also manage the dependencies on my own (yikes! but I manage my whole linux system that way, and ruby is used to compile/install everything for me on that system too, from source). I have no need for bundler. I think bundler adds more to the problem than it helps but this is possibly a natural reaction for those diehards who manage their system on their own (it's actually simple, since I also use ruby to automatically check for updates; downloading all of the KDE5 plasma components requires a change in one file to increase the version; then a commandline variant to download it all, with an option to compile at once. The version-bump could happen automatically via scripts but since it is just such a minor change I still do so by hand.) Not everyone uses bundler. I think the most prevalent use case is for rails people since they seem to struggle a LOT more with dependency related problems. Resources are quite limited, we can all see that. For ruby it is Hiroshi Shibata who is doing a lot of work and he has stated in the past that it happens in his spare time. I don't know the bundler situation but I assume they did work from the bundler-side of things.
Air is enough for general Ruby/web development as long as you don't want to run a heaping pile of VMs or similar. As you know Ruby is not generally heavily threaded, so the dual core isn't much of a limitation for it specifically. You're in a perfect position to find out yourself about Rubymine RAM usage. Load up your project(s) and use vmstat and top to see how much RAM it is using. The only ruby "gotcha" I experienced working on a (now very old Macbook Air) was that OSX shipped with a very stale version of system Ruby. It was easy to install macports &amp; rbenv to set up new Ruby versions, however.
If you don't use bundler, then of course it doesn't matter to you when bundler is released with what bugs or features? But the vast majority of rubyists use it, and personally I can't imagine how you could get by without it, but whatever works for you! But if you are in the minority that is not using it, you have no stake in it at all. 
8 GB will likely not be enough I'm afraid. I struggle doing development with 16 GB sometimes.
You know... when I see medium articles linked I have an involuntary eyeroll that happens... BUT I have to say, I've really been enjoying your posts. You/your writing definitely stands out from the rest of the medium/dev.to cruft. (Although you could stand to proofread/hire a proofreader) Keep it up! Thanks!
Just do not do it. MacOS looks nice but under the hood it is piece of crap. The only good thing about it is brew which is something similar to linux package system or bsd ports. Stick with the original. GNU and Linux. This post is getting lots of downvotes because it is Ruby subreddit and macOS is very popular there. I am also not going to elaborate on more reasons why I think it is crap cos I am on mobile. It is still better than Windows tho I think. 
Thank you a lot for you feedback. Very appreciated ! :-) &amp;#x200B;
roda + sequel + rodaauth, minitest, postgres
Counterpoint, in case that post is giving you pause: I've been doing Ruby development on a Mac since around 2007 after previously trying various Windows and Linux solutions, and I've found it much better on Mac. I had not previously been a Mac user, but I'm glad I made the move. macOS with Homebrew gives you most of the benefits of Linux for development while also giving you vastly superior software options for most categories of desktop apps (for me, media production apps are important). I'd get at least 16GB of memory, since it's not upgradable and software only tends to use more over time.
It might be getting a lot of downvotes because you made a vague, acerbic, unsubstantiated claim. There are plenty of good reasons to prefer GNU/Linux to OSX, such as avoiding vendor lock-in, seeking repairable hardware, or wanting window manager choices. However OSX being "crap", or [not working for Ruby development](https://insights.stackoverflow.com/survey/2018/#technology-developers-primary-operating-systems) is not among them. 
Don't cheap out on memory. You can't upgrade it later. The use of VMs and virtualization is only going to grow over time.
I used an Air for 5 years and it was fine (IMO the MacBook Air was the best laptop ever made for general purpose use) but I don‚Äôt use an IDE and at the time I wasn‚Äôt using stuff like docker. I now have a Pro and haven‚Äôt noticed much difference performance wise. The retina screen is great though. It has 8Gb of ram and I rarely have memory issues, paging to the SSD is fast. The old adage holds though, buy the best you can afford.
Unless you really need a laptop, I think MacMini is a better value as far as a dev machine goes. And that's only if you really want to use MacOS. If you're comfortable with Linux environment I would not bother with Apple right now. MBP is garbage value and they still didn't fix shit keyboard and still adamant about including touchbar that nobody asked for.
I actually find the principal of transforming algorithm input to eliminate special cases extremely useful for writing difficult algorithms, and I've used it a few times, but I wouldn't use it if I didn't think it helped. It's just that very occasionally in a Rails app you need to write difficult code to transform, say, an array of something, and you can make the actual problem easier to reason about by altering the data up front. Then the final algorithm states the solution, which is already complicated, in the simplest possible terms. It makes it far easier to fix bugs in the final solution. It's really just a strategy for breaking up the problem. That said, I don't know that the blog examples are in good taste, but I find them totally understandable.
I'd get 16GB. Can you get 16GB on an Air? If so it'll prob be fine. 
What's even weirder is that there was no actual need to bump it. The fix was literally just changing the line specifying the required version. Apparently there's some bugfix in 3.0.0 for users, which is great, but seems like a pointless reason to bump a version requirement.
I agree that "data massaging" is a good tactic to break up problems in a function into discrete parts, particularly when you have a complicated algorithm/solution. I just question some of the approaches the examples take (and also, to be fair, the examples themselves). The first example might be made easier/clearer by just getting a default value from Array - \`0\` - via \`fetch\`. Then we don't have to offset the index of the map, or pad the data. We just say: numbers = [//lots of numbers] result = (0...numbers.size-1).map do |i| numbers.fetch(i-1,0) + numbers.fetch(i+1,0) end //I believe array .map will return an array, so .to_a is probably redundant here. I mean, to me that's a little clearer. I'm also not sure the third example is correct regarding \`map\` being a closer function conceptually; you aren't really replacing each array with another array, you are potentially changing the size of the array by adding new ones, and I honestly think inject or reduce would be a better fit in this case. I'm not sure what that example is trying to do in terms of clearing up the problem. &amp;#x200B;
Get a future-proof machine! 16Gb is a must! 
&gt;I was thinking about that but then I would need to get macOS compatible keyboard, mouse, webcam and price would be even higher and more stuff on the desk. &gt; &gt; &gt; &gt;I am happy with linux when it comes to development but small things like suddenly stopped working webcam or Bluetooth headset make me disappointed so I think macOS should be good in terms of that. 
&gt; Caching is a feature that really should be left to the database layer/model and not bothering the views like this. Why? And do you think that caching should have been left out of HTTP?
Definitely go pro. The qa dev on my team was stuck on an air for a while and it was unusable. 
RubyMine is a resource hog. 
Good stuff - I didn't know about the frozen state stuff 
 A deep copy works has a shallow copy. Please take that sentence out the back and put it out of its misery. I think what you're trying to say is something along the lines of "A deep copy starts similarly by first doing a shallow copy." or similar.
TBH unless you're doing front end stuff there is no compelling reason to switch to a Mac in your argument. FWIW I develop on Mac at work and 'nix at home. Other than keyboard shortcuts and machine form factor, there is little difference with one glaring exception. We use Office365 and you have to use the web client on Linux, same goes for other Office apps but that's our setup. I use Sublime Text (ST) but have also used github's Atom and microsoft's Visual Code Studio (both based on Electron) but always come back to ST as it's written in C++/Python so it pretty easy on memory \~ 1/3 less IME. All three are platform agnostic though... ST isn't free though. The exceptions that would be worth switching to Mac though are if you do a lot of front end stuff and need the nice tools you can run on a Mac, e.g. PhotoShop, if you need GUI tools for stuff like git, or maybe items macOS items like XCode. Also obviously if you need/want a Mac for other stuff outside of ruby development that would count too. Otherwise I think the learning curve is probably not worth investing in the switch although it's not very severe TBH and there is plenty of documentation on stuff like homebrew, etc. 
Apple soon-to-be-expatriate here, and I just want to offer a few words of warning. I have used a 2015 (thin, pre-butterfly) rMBP for three years now and I am going to switch to a ThinkPad with Linux on it. I had an iPhone and rMBP, and I am switching (back) to Android, and (back) to my favorite Linux after this time. The "ecosystem" argument worked for a while, but I still have friends who don't use Apple products, and not having integration across the aisle was a deal-breaker. Why did Linux not work for you? I'll also point at the fact that Apple has consistently been removing features that users have liked, and charging more money at the same time. Want to be able to upgrade? Nope. Everything (RAM, SSD) is soldered onto the motherboards of the newer versions. IO? Nah. Two USB-C ports is "plenty," apparently. Battery life? Okay, but ThinkPads can get up to 36 hours. "Engineering?" ThinkPads have equivalent or better "engineering" than Apple products and are built to tick all of the above boxes. They are rugged, but still arguably quite sexy, and have plenty of battery life. And they can perform quite well. I don't know who came up with the ideas Apple's floating, but this is a product philosophy I no longer buy into. Most people spend money on Apple products for the "ecosystem," and if you've survived this far without it and can handle the peer pressure there's no reason to waste your hard-earned money on a sub-par machine just to become part of the elite.
Thanks for your feedback :-)
TBH the only way I can see it becoming an issue is if you're heavily leveraging Docker/Kubernetes locally and that's sucking up all your memory. Although 16GB will be always be better and should be preferred, 8GB will be fine on all the currently supported versions of OS and it'll run better on the newer ones as they have significant memory optimizations. I develop on 8GB/Mojave and it's fine, I usually run \~ 50% memory threshold. Granted I'd rather have 16GB but I can't see 8GB being a deal breaker on a newer machine with an NVMe drive. 
Thank you for your feedback! Glad that you've learned something from my article. Happy new year !
Yep, didn't figure I'd be able to get away with it. Ah well. On to the next bad idea!
Honestly, I'd recommend against it. It might work in some cases, but break in others. For example, let's say you include only `function1` from `Module1`. But in the implementation of `function1`, it makes a call to `subFunctionFoo`. Or in the `Module1` module, it uses the `included` block like: ``` module Module1 included do attr_reader :my_attribute end end ``` and the implementation of `function1` expects the `my_attribute` reader method to exist. For each module you're thinking of including, you'll have to go through the source code to see if it's safe to selectively include only certain methods, or if you'll end up with broken or unexpected behavior.
The quickstart example now escapes output with a helper, and links to this [open issue](https://github.com/chrisfrank/rack-component/issues/4). I'd welcome your thoughts on the proposed solutions there. Thanks, /u/tomthecool.
Thanks again for your input. I've released an `h` helper for escaping, and am experimenting with escaping by default. [This open issue](https://github.com/chrisfrank/rack-component/issues/4) outlines a few proposals, which I would be grateful for your opinions on!
haha I think that's because the answer is more nuanced. There are a variety of concerns when making technical decisions, and those include but are not limited to team makeup/capability as well as capability of the language/framework/etc. For example, you wouldn't choose assembly for this particular task. But comparing Ruby and Kotlin, and given the constraints by OP, and given it seems like OP already has a preference for Kotlin (and the JVM), that seems like a fine choice.
For what it‚Äôs worth, I‚Äôve been a React dev for a while as well, and so my comments come from that context. Cool lib üëç
I updated my comment to specify ‚Äúcaching in rails‚Äù. HTTP caching is üëå What is your opinion of the API?
Wow, Jets framework looks really solid. Will try it definitely.
Thanks! Appreciate the kind words.
Ditto for this. RAM is key. I've taken to using Docker for Ruby development (after the upgrade to Mojave trashed my local dev environment) and memory on my 8Gb Pro is becoming an issue. Ironically, I'm looking to go the other way - with my next box probably a Linux machine. I'm thinking of a System76 laptop with 32Gb, as Mac Pros top out at 16Gb. Macs aren't magical development machines. I've used Mac Laptops for the past 20 years - the build quality is excellent and the OS is solid - but I'm not super impressed by the keyboards on the new laptops and the touch bar seems a little gimmicky (IMHO). Your mileage may vary, but getting one just to have the same hardware as your peers doesn't sound like a sound reason to get one on its own. But they are good machines. I don't think you'll regret getting a Mac, as long as you don't skimp on RAM.
Yeah, the "it just works" truism still holds for Macs. Never had any issues with Bluetooth, _etc_ working - whereas running Linux invariably required some farnarkling to keep it going ("why has power management just stopped working?"). But you will hit a learning curve. Tools like `brew` are community aren't part of the OS proper like `apt-get` and similar. They generally work, but there's always an odd edge case that leaves you head scratching. 
Stay with linux. I mostly use linux as an IDE, with ruby as the "glue" language for everything. Admittedly this may work on a Mac too but I don't want Apple to dictate how I use my system. I use a layout similar to GoboLinux (although a bit simpler; only the first character is upcased under /Programs/; e. g. in GoboLinux one may see /Programs/KDE-Libs/ which is a bit easier to read if you do a "ls" there; I like it simpler though and have as rule something like /Programs/Kactivities/ or /Programs/Konsole and all '-' removed so I never have to guess what name there is). Also avoid systemd, it's a braindead system that leads to a braindead linux. &gt; From one hand I don't want to pay a lot for the &gt; power which I won't use, from another hand I don't &gt; want to stick with weak hardware. Not sure what you mean here. I always buy cheap hardware, although I do look that it has quite a lot of RAM, say 8Gig or more. My current main desktop did cost me at around 300 euros, not including the monitor (which was at about 100 euros). That's somewhat cheap. Laptop models cost a bit more but apple adds like +50% apple-fee as I call it. Ultimately I can use ruby on any system and while I advocate for an oldschool linux (slackware is also good if you use e. g. the alien bob up-to-date builds), ultimately what really makes things great is not linux but ruby. I can adapt my ruby code to anything but I could not adapt to NOT being able to use ruby. (I can use everything on linux at all times; everything is the most recent stable version; I tend to avoid unstable, unless there were bugs fixed, such as I am running a binutils from git://sourceware.org/git/binutils-gdb.git because I had problems with ftp://ftp.gnu.org/gnu/binutils/binutils-2.31.1.tar.gz having a strange bug). I do however recommend to, no matter the system, get sufficient RAM. If you can, use 16. But this being apple, the apple mafia just wants to steal your money so ...
Yeah - RAM is quite important these days. All my desktop machines running linux are dirty cheap, but I look that they have at the least 8 gigs; usually 16 gigs.
I can tell you that low RAM is an issue here no my desktop machine. I have numerous tabs open, video/audio plays all the time, gazillion KDE tabs, multiple pdf files open, my editor runs ... in the kde tabs I may run different scripts ... I may have some documents open in libreoffice and the DE is not always as light as mate-desktop (e. g. using KDE5 plasma). On top of that I compile everything from source. And I can tell you ... 16 gig is definitely MUCH better than 8 gig. And I still have a fairly cheap desktop system. As others wrote - don't cheap out on memory, I agree with that notion. I even think that memory became a larger bottleneck than the amount of CPUs you have. I look that RAM is always in good supply here as otherwise things WILL be significantly slower. You can see this when you compile larger things such as gcc, llvm and so forth too.
&gt; with my next box probably a Linux machine. Yay come to us! Go to oldschool though and avoid systemd and other useless things.
&gt; I am happy with linux when it comes to development but small things &gt; like suddenly stopped working webcam or Bluetooth headset make me &gt; disappointed so I think macOS should be good in terms of that. Linux can be frustrating sometimes, in particular when things may not work - it took me quite some time before I wrote ruby scripts that handle wlan connections. The steps are simple but it's not trivial to find them. But you describe mostly minor problems in my opinion; webcam or bluetooth. I think these work on linux too? You may have to look a bit deeper to fix issues here and there. Often a recent kernel helps a LOT. I had to compile a more recent kernel for my laptop when I had wlan problems. Linux is a mixed blessing - on the one hand it is awesome (top 500 supercomputers run linux for a linux); on the other hand it can suck. That's where ruby comes to the rescue to solve every crappy problem one can possibly have. It is of course your decision and your money and it's not all lost if you go mac - you can use ruby for managing software via homebrew, which is not available on linux officially (only some other github-resident code as far as I know, not available by default on maxhomebrew).
Yeah - if I were him I'd abandon it. And stick with oldschool linux.
&gt; This post is getting lots of downvotes because it is Ruby subreddit I don't think this is the reason. Some mac os folks may downvote you but I don't think this has much to do with ruby as such. MacOS are not necessarily bad. It's just that Linux is better. And ruby makes both systems better too.
That is actually not a counterpoint at all because I have been using ruby since ... 2004 or so, all on Linux and I do not see any of the problems you described. &gt; macOS with Homebrew gives you most of the benefits of Linux And I manage my system via a set of ruby scripts that install everything too - on Linux. Without homebrew. (Although I happily admit that the quality of my code, even despite after many years, is not really good enough to see any mass adoption ... it's still just a hobby project after all those years and I am too scared to suddenly end up where I may have to put too much time into it, which I can not do). &gt; while also giving you vastly superior software options &gt; for most categories of desktop apps Which software is vastly superior? Let's compare it with KDE5 too. The terminal? Hmm, I don't think the mac terminal beats KDE konsole by a huge margin. Perhaps better emoji/unicode symbols for mac terminals out of the box. Emojis work on KDE Konsole too. I am curious where you see macOS being vastly superior here - please give specific examples. As for media production - what exactly do you need? I can do lots of things in ruby through ffmpeg + avisynth (well vaporsynth as successor http://www.vapoursynth.com/ ). Of course commandline/scripting ways to modify multimedia data is a bit different to GUI-based systems, I get that. I however had massively doubt your claim, if you ever used avisynth before (you can literally do everything through it).
&gt;ThinkPads can get up to 36 hours. Can you provide a source for this?
Can you recommend something else with similar features? Based on my experience it allows me to do my job much faster than my coworkers do: 1. It can index included libraries so `go to definition` can simple take you to any library method and show its source code right away, which sometimes saves me a lot of time. 2. GUI debugger vs pry 3. Support of docker and docker-compose really awesome, you can start any service just clicking on play in docker-compose.yml file 4. They recently added github PRs and it's really cool feature for big PR which really hard to review on github. 5. git integration is so powerful diffs, resets, rebase, solving conflicts and etc. 6. built-in REST client 7. database tool and so on (it's just a small part which came up from my head right away) I know how to do most of these things from the console, I have a big experience with vi (sun/solaris engineer in the past) but it's like modern premium car compare to old car with mechanical transmission, no power steering and etc, someone likes it but I don't :) &amp;#x200B;
This is legit. I just started using Jets framework about a week ago and I am now obsessed.
Haha. That‚Äôs awesome. üòÑ
What‚Äôs the error?
Hey guys, I have a problem when I put this in my console, after choosing the name, it says ‚Äúuninitialized constant Tod‚Äù. Do anyone know why it doesn‚Äôt work ?
Well, look for where your code mentions "Tod" . You're looking for something that will be interpreted as a constant when it shouldn't be.
Looks like "Tod" in your comparison is supposed to be a string. Put quotes around it like your puts and print statements, otherwise ruby treats it as a variable. 
just curious, is this for a college class or practice on one's own? on line 12 `name_tod == Tod`, `Tod` there has no string quotes around it, so its saying you never initialized a variable called `Tod` which is true, you don't want that right? instead of giving you the answer straight up, just curious what you think needs to be done. it basically comes down to verbalizing what are you exactly checking on line 12, and then coding it properly. It's actually very simple
Thanks and it‚Äôs to practice! But now I understand how logic it is. (Have to change from ‚Äòname_tod = Tod‚Äô to ‚Äòname_tod = ‚ÄúTod‚Äù‚Äô
correct. oh, by the way to make it like code a bit, do the ` and then the `
Chill. I wasn't arguing with you, I was offering another perspective from someone who has been on both sides of this choice. There isn't a right or wrong answer to this question, and everybody has different priorities. I was just being encouraging to OP, but to answer your questions: literally every piece of desktop software I use (email client, office apps, photo editing and graphic design apps, web browsers) is much better on Mac than the Linux equivalents IMHO, and there are very few high-quality equivalents of Pro Tools, Logic, Final Cut, Motion, Premiere, After Effects, etc. on Linux - that's what I meant by "media production". There's a much greater selection of high quality choices on Mac (and Windows). And since you wanted more detail: the font rendering is better, the UI across apps is more consistent in appearance and integration with the OS, you never have to screw with drivers for anything, the desktop is more stable and requires zero configuration (I'm not interested in choosing and configuring a window manager, I just want things to work well and look good without putting any time into it), and the list goes on and on. Besides all that, I develop iOS apps and there's only one good choice for that. I've tried the Hackintosh thing and it's not worth it. I used to build my own machines (still do for gaming) and dig into Linux config files and all that crap, but I no longer have the time or patience for tinkering; for my main machine I need everything to Just Work as much as possible, and macOS is still the king of that (IMHO). There are plenty of valid reasons to prefer macOS over Linux, whether it's best for you or not. Everybody has different priorities. There is no "best" OS (or anything else, really).
` puts "ok ok " `
that's more like it. just google reddit formatting and they show you stuff on the link/s that come up too, if you like.
I have one last question: how could I keep him from putting "oh, come on, give me another name" as long as I put something else than "Tod" and ask every time to change the name too ?
This page https://www.laptopmag.com/reviews/laptops/lenovo-thinkpad-t470 states the six cell battery goes for 17.5 hours and is hot swappable, so that would be ~36 hours IF you carried a spare battery
Just googled it, looks fine. ( didn‚Äôt know one of these )
I'm not sure i understand your question. if the user put a name other than "Tod" then it should just give line 15 output to the screen with the different name. otherwise if its "Tod" the loop doesn't end.
I‚Äôm not sure that the loop end, it just switch to the lower lines when you put "Tod".
Actually I could do it alone but I‚Äôm too tired for it, I‚Äôll sleep actually.
Not sure if this is your post or not. I'm going to assume it is with the use of my pronouns. I really think you're just talking around the idea of using a bitmask. Maybe I'm misunderstanding the intent of the problem. Your general solution presents it's self like a row of switches left to right and you toggle some on and some off with overflow on days where you roll over into the next, e.g. Fri, Sat. Where the day basically becomes longer. If you were to reverse the array and trim the padded zeros, you can abandon the array of strings idea you present and your days basically become binary numbers, which can then be made to be a integer via a bitmask. [Here was my shot at it.](https://tio.run/##zVVhb9s2EP1c/YqDhC5S5rC2mtqeUDdIlw790q2oMwxDZgiMRFvMJFIlqcVu7d@eHSkptdN16LYvM2yYou4e7@69J6nmenOn2PuGKwZHOTXsyLu/NLzCSy8rqdZwQTcewOuffn43hxlcHQ8JiacLCKBudMFykI0BIyGewlIqYFSVG6ikElysICulZhrTL85/nUOfTsY2/ZqtuNAgBcwbkeMhGEaNUSnNMqY1YiWFbJROK6p/H0CSuzrwm7MluDuz0P1FuAegKNcMztWqqZgwr5SSagD@pZRQ8FUBcglUuDTgwrAVUz7wDodUtIaP2/UW1i@wjx3hIiubnJ2FRjWshdesXJJP9WAr7eHwTTuaqAWBrdpCfHzs9hAnZ@tQRbAjuqkQh4nc2@/AQbexit2wzHQIYbh31HYLwwjP@Qw2Ih@YkmewO0TOpPiDKZNaCIeTUp1i0xG48QHs7cHJDOLTfhL95gu7FwDNbxptHK0SEZelvHX5lygPUlOlWegHH/cSd8lw6EdEG7W0Egr9x@Xjt37UloeHdwU65lPcSo1MdUiV2nRDxrEeHbml3SSMZkV6y02RupYhl7BdD/i2bcPGP39@2O46Orjnwwk4njnMZjB0t@ykXADR7xvGPmCZ0Nd4QI6rrtUWM40S4H9v5ZzvCYdVtdmcuZhrq@7F/Xx1W7wuecbCOEJ5FVuMwZoedF9Ejj8EIDeSi9BH1UZ/U9p9UTj6C7Rtkpy/fPkuRYP9eP7m1fwKbbLYJdDy0vaw8zsI/N0F0GhrzZpyVC/aQhuqzBNtZA2WNOfI@LRQ1rwZGk9I52@2zhi6HW0entIq8rxW/tg0gl/BYgCPHoH72U9gTZ1AOzAXMIoHMHo2gHg4sOrC@ADeSIwZxXWFND2tqwFM3XIU0@qLOZcN@8c5v7D8q3IwGPr6L4tmP8fFIeQpomI0jsEFB/CD4olDwjgcDAIN6279xZw5Ncl@3KKbprURmsfS48TkBb26W01ZV9CNZeOaG/tsaNMIksxEU5EHVinQKlY1CIYPcSKYtW9OeuIKd4V6wTX3OtnulYBazYmTm5NfgDaw54sVc48EJO8ESUZRanxpuPdA3RhP49bsIRbRBV@acBR5Sy5o@XkAfAuY6CGABv8t7hi7uVSyanv@Tfjdzdc2MemuHFrnGwxBVWKZtDRMCbQG3GJvrdqlwLdS9@DXA@CEkX6G2g3RPWp7OSNno8l0HI@fjf969XQ8HVtWJ/E4/m4ymewtkcz/wGVbxr8htH8t/W9Z/UThIb89K19J8d3dnw) Also if the argument is for code smell. You're dropping to hand coding a lot where you can use the built in ruby functions/constants. Like Date::ABBR\_DAYNAMES on the Date class. &amp;#x200B;
Put in other words it's related to the Null Pattern. Indeed, when possible it's a good idea to deal with `if` statements as a single instruction leaving the special case "resolving itself".
I try Linux from time to time to see if anything changed for the better but I never found a window manager that I could live with. This is surely a personal thing but I really love all the little details generally in the OS, a lot of things are thought through and I lack this feeling with Windows and all the *nix window managers I've tried. Thing is just that most people don't even know about all the tricks and details. I teach my boss that worked with macOS since 9x new tricks all the time because I'm very much a poweruser and actively search for those things. I should make a collection at some point (haven't found a comprehensive list yet).
Interesting topic. Thank you.
Man... now I'm going to be up at night worrying. :) Conceptually there are two transactions going on: the overall 'marked this as processed' and the \_inner\_ transaction of actually committing the charge. The "charges" table idea effectively encapsulates this idea. Are you proposing to actually have a \`Charge\` model to represent this, \_i.e.\_ a charge effectively \`belongs\_to\` the model that carries the \`processed/unprocessed\` flag? If that other model is already persisted you wouldn't need a unique key, just a pointer on the \`Charge\` model that you can check for when re-processing. You could put as \`has\_one\` on the main model, but that would require persisting it (and the \`Charge\` instance) which is more chatty with the DB - which I assume you want to avoid. OK, this is all off-the-cuff so it's probably not well thought out. But thanks for making me consider this, as it's similar to something I need to code up in the next couple of weeks.
Is the purpose of the product to process the credit card charges or is this your way of charging for a SaaS based product? On Drifting Ruby, I don't store the credit card information nor do I handle the payments. These transactions are sent directly to the Merchant Services. This makes life a lot easier with not having to worry much about the PCI Compliance side of things. Also, the result of the application, i.e., the user experience of the subscription is the result of webhooks and callbacks from Stripe. I let the pros handle the storing and charging of credit cards. When a user enters their card information and submits, it gets transmitted directly to the Merchant Services. They set up the customer, apply a subscription and charge the card. The MS will respond back to the application with a resulting status of the application. If the transaction is successful, the user will have the benefits of the subscription membership. Otherwise, they will be given details of the failed transaction. On the monthly recurring subscriptions, the MS will send a webhook call to the application with the status of the recurring charge. My application will determine the appropriate responses to the calls. I don't have to worry about a charge getting duplicated or failed jobs retrying non-idempotent tasks. 
Ensure your Charge entity is honestly representing the full lifecycle of a payment attempt. Unprocessed -&gt; Processed may be too simple a state machine. Pending -&gt; Processing -&gt; Complete is the minimum state machine for a payment attempt. The most complex state model I've seen went: Requested -&gt; [Rejected | Approved -&gt; Processing -&gt; [Succeeded | Failed]], with separate jobs for vetting the payment and then actually making it happen. When you said "these are transactional", you've reminded me of a classic payments oops. If you're keeping state but something downstream throws an uncaught exception, your transaction gets rolled back. Ergo, when updating the state of a payment record, don't use long-running database transactions: commit the update immediately, then start a new transaction and lock the record again. A payments job should mostly be a wrapper concerned with locking and database transactions whilst telling the Charge to proceed. The details of the payment (amount, card token, invoice), the payment state machine, the safety logic and the payments API invocation belongs to the Charge object itself. 
We've spent 4 years building this (as a payment provider). My suggestion to you is to use your payment providers recurring job engine, and not to roll your own. Spend that time on building your product and outsource payments and charging to your PSP.
Best way but hardest path from here: Don't roll your own recurring transactions, it's worth it to use a service like Recurly or Stripe etc to handle this.
Hi, a few things occur to me that can help: &gt; keeps me up at night Test-driven development is the best medicine for that. It's especially good for bug fixes: write tests which trigger the bug and fails, and then your team codes until the test stops failing. &gt; "processed" vs "unprocessed" status This sounds like a problem of weak modeling and weak typing, when an entity has a `status` attribute. Instead of, e.g., breaking this out into two types: `PendingCharges` and `ProcessedCharges`. And only a `PendingCharge` should have the code to commit a payment. These would be two separate database tables as well. It should be easy to see how this separation would rule out the kind of logic bug that can creep in when testing a boolean `status` field. In Haskell there's a saying, "Make illegal states unrepresentable". They use the strong type system to do that, but we can close in Ruby by using techniques like the above. It should be impossible in the system for a charge to be re-executed.
All of the processing is outsourced! We aren‚Äôt storing cards either. The transactions occur randomly; however, so we have to process (via an external API) the transaction requests. Unfortunately there‚Äôs no rate limiting/duplicate transaction on the other end (vendor API) or we wouldn‚Äôt have this problem! :)
We actually didn‚Äôt! We are using a service to actually charge the cards. But we still have to call that service to process the charge, and the charges change weekly. 
So a payment gateway but you rolled your own recurring transactions?
I like your thinking. We‚Äôd ideally like to get there. We do have three statuses: unprocessed, processing, processed. However, in the past it‚Äôs retry logic that failed us. The second was a race condition, which we‚Äôve since resolved (hopefully). 
The issue with that kind of blind rate limiting is trying to differentiate between valid traffic and erroneous traffic.
Thank you. Great advice. 
Great advice. Thank you!
We are already using a third party provider to store and process the transactions. These transactions aren‚Äôt for subscriptions - they change daily based on a users activity that day. 
Nope. These aren‚Äôt recurring transactions. They are dollar amounts that generate based on a users activity in the system that day. Best example I can give is charging $1 for every time someone clicks on a link, and aggregating those at the end of the day and processing the charge. 
Folks at Apple took UNIX and turned it into pile of crap. It kinda works for everything including Ruby thanks to brew. That does not mean it does not suck. 
If you‚Äôre using something that supports idempotence, like Stripe, use it. If you aren‚Äôt, then you can implement a two-stage charge, also known as an Auth+Capture. By splitting a charge into two steps, where you can commit to your database between them, you can be sure that you won‚Äôt ever take more money than you should. In the event of a failure during an auth, you can be certain that even if the auth went through, the money will be returned to the customer because it was never captured. If auth+capture isn‚Äôt supported, and in one API request you make a charge, and the API doesn‚Äôt provide any duplicate protection or idempotence, then you must implement at most once processing. to do so, BEFORE you make the charge you should (1) obtain an exclusive lock for that charge, (make sure two background jobs can‚Äôt be processing the same charge at the same time) commit to your own database about the upcoming attempt (insert a record saying a charge is pending), and then attempt the charge. If it succeeds, you can update the record you inserted to mark it as successful. If it fails gracefully, you can update the record to indicate it was failed. If it fails catastrophically (eg your web server shuts down), you will have a record in a pending state, which cannot be retried until it has been fixed. 
Cool. What's the class/model which has the `status` attribute?
Here are some screenshots of it in action. I've **never** seen a Ruby IDE work this well. I'm truly impressed. IMO this is better than Ruby Mine, better than anything I've tried in the past.
This is a lot like the system I built for a previous employer. Whenever a charge is requested it's initial state was pending, then one of the charge services tries to atomically update its status to processing. If that was successful then the service can go ahead and attempt the charge and afterwards update the status to paid. If anything went wrong then the entity would be stuck on processing, which has to be resolved manually. This is what we want, because we'd rather spend some time fixing the rare customers payment, than risking losing Goodwill and embarrassment by charging twice.
I've been trying to use Rubymine for years ... always coming back, trying it out, but the software just feels like vaporware: It never fully works. My test consists of: (1) Install a new Rubymine version, and (2) point it to a brand new, vanilla, Rails project. There are always lots of false errors, parts that it gets wrong, etc. etc. So I've never trusted it, and never wanted to invest the time (and esp. not money) in it. I haven't seen it live up to its marketing claims. And now I've discovered the Solargraph LSP project with Visual Studio Code. It's fantastic. I just posted a few screenshots - https://www.reddit.com/r/ruby/comments/acsnva/solargraph_is_crazy_good_makes_vs_code_feel_like/
Well I'm not arguing * &gt; 16 . I'm saying I have 8Gb on my macOS machine and even run docker locally without any problem. macOS is optimized for 8GB operation at it's current release, Mojave. It was one of the points in the release presentation even and is why 8GB is their stock memory config. Still if you can swing 16gb obv get 16. A bit confused why you're referencing KDE as a counter argument. FWIW there are lighter weight windowing systems for Linux, if memory is that big of an issue. I used to use Xubuntu (XFCE) with great memory reduction and then switched to the even more barebones Lubuntu (LXDE) for rails on a pretty shitty employer provided desktop and it was less than 1-2 GB for normal usage, massive tabs and all. Now at my current place my Linux box has 32 GB so I don't bother with it anymore and just stick with Ubuntu and Gnome. Also I do some development in Elixir and very occasionally haskell. The only time I've ever felt low memory usage it is on some haskell installs. 
I can't remember the podcast but I remember a Stripe engineer talking about implementing a job queue for this a while back \~1-2 years ago. IIRC they ended up going with a FIFO queue instead of a sidekiq type of solution because of a similar issue. Maybe there is some information you can find about their queue processing stack? I think using Sidekiq is wrong because Sidekiq needs idempotence. What you describe is not idempotent. Is there someway you can change it to a FIFO type of queue and still keep the performance? There are a few systems out there Fair warning complex/compound keys, the unique key idea you're referring to, in ruby can be a serious PITA. It's gotten better but when I had to do it years ago, I was ready to pull out my hair. I'm not sure it helps you here either. It might be better to get that functionality completely out of your ruby layer, if possible, and leverage the database layer to perform the operations via triggers, since atomicity is important. There is also a retry setting for sidekiq which maybe you should set to 0? If you do keep it in the ruby layer, you might want to leverage a finite state machine for the transitions similar to the [statesman gem](https://github.com/gocardless/statesman). That'll should give you guard conditions on state transfer and a way to test your transition, although doesn't guarantee atomicity/idempotence. 
I also sometimes use `#[]` for procs but only if the proc is used in a place where I there would normally be a hash. So more or less the reverse of your use-case.
Ah, so you charge tokenized cards against their API? Are you using unique references/orders or are you always creating new ones?
&gt; language server protocol Solargraph is a good implementation: https://www.reddit.com/r/ruby/comments/acsnva/solargraph_is_crazy_good_makes_vs_code_feel_like/
Could you please share your settings and which plugins should be installed? I couldn't make solargraph work.
A straightforward approach might look like this: input = [1, 3, 4, 5, 0, 1, 8] result = input.map.with_index do |_, i| if i == 0 # &lt;-- LEFT ENDPOINT input[i+1] elsif i == input.size - 1 # &lt;-- RIGHT ENDPOINT input[i-1] else input[i-1] + input[i+1] # &lt;-- GENERAL CASE end end.to_a I stopped reading right there. Anyone who has used ruby for a little while knows that this is just insanity. Not only the idiots who keep on chaining methods onto "end" (I hate this) but even more so with THIS CODE BEING UGLY AND UTTER GARBAGE. There are many real ways how to implement the above; a case/when menu instantly comes to mind, but the much more important thing is ... ruby is, despite the functional stuff added, still an OOP-centric language. So why not design around these ideas? Frankly, nobody sane in mind would ever write such a line: elsif i == input.size - 1 I am sorry but this is just total and complete garbage. And even IF you use the fake code here merely to illustrate your other point, I feel it distracts from this rather than helps. If you wish to articulate about pros/cons, begin with good code rather than fake. To the general topic about special cases - sometimes it is just the fastest solution to add a quick fix and move on. We can all be elitists and dream about the super-perfect code (as if this comes at zero cost LIKE YOU NEVER HAVE TO THINK ABOUT WRITING PERFEC CODE?) - or we can just get things done, solve something, and move on to do other things that may be more important in general.
&gt; There's a large case to be made that the replaced solutions will be &gt; more difficult to understand when you return to the code. I did not even reach that stage because I found the prior code to be fake, entirely made-up and not sane ruby code. Who in his sane mind would EVER write garbage like this please? elsif i == input.size - 1
The thing is ... in my opinion, every time you HAVE to think about operator precedence, you must be doing something wrong. Are people too scared to use () in ruby these days? The () frees your brain to not have to think about what precedence you have to use.
You used self one too many times in the second example. To the stylistic question, I myself hate the &lt;&lt; part there and only use the first variant. That means I have to write a bit more code, admittedly, since people who use the second variant may "batch"-define lots of class/module methods that way, but I like it - indeed only to avoid the &lt;&lt; part there. My personal advice, though, is that no matter which variant you prefer, stick to one and use that one consistently. I've seen code bases where both styles are used and it makes me scratch my head a lot; not because it is confusing but ... it's weird. Some people write weird code; and I mean not just that the code is weird, but that the way HOW the code is written, is weird too. Even past the newbie stage. I can come up with some explanation aside from personal experience or taste, such as that the editor players a HUGE role in how you write/read code too, but I think that would go way too off the topic at hand here.
I think the whole concept of private is a bit ... well, useless in ruby. IMO matz added this mostly so that people who like/use that distinction can feel more at home with "ruby". I find it weird because ruby is so dynamic at "runtime" that it goes at odds with any philosophy that seeks to restrict what you, as a ruby hacker, can do with ruby code. It really comes down to philosophy. Ruby's OOP model is just different to e. g. Java's OOP model (or others who seek to enforce a restrictive access model).
I would add a bit more documentation, in particular one smaller example, and a larger one (ideally a specific use-case that could exist).
Nobody uses them. :) (Well, almost nobody.) There was a slide about it years ago. I know why I don't use them but I have no idea why others don't use them. I don't think others necessarily have the same reason as I here. By the way, I disagree with the other two here that this has to be done via refinements. I think it is perfectly fine to subclass as was done here - my major head-scratcher is whether people actually really need that ... Struct and OpenStruct can be quite cool but to be honest, I ended up barely ever using them, ever. Even though it's a cool concept like: sword = OpenStruct.new(:sword) And then modifying the sword, or something like this. A bit like pure-prototypic OOP which I like ... but strangely enough, when I then go and write ruby code, I end up doing oldschool class-based OOP. I have no real idea why ... :\
Keep in mind that (almost) nobody uses them. :)
Yes, that confused me too once; I thought I understood them, until I read a bug report, and then I read up on the original definition and I realized that my expectation and assumption was not how refinements were suggested + implemented indeed.
&gt; A lot of developers forget this. I'd rather be given readable code which is a &gt; tad slower over a cryptic mess any day. Exactly! 
Using ruby for reasons of mega-speed is ... strange to me.
Always a reasonable plan. I often find just going for a short walk or taking a break can help get past something I'm stuck on. Your problem looks like it might be a homework or coursework problem, and if you are on a bootcamp or similar course I definitely recommend taking breaks. Having mentored a bootcamp before I've seen far too many people who refuse to stop until they've finished something and burn out because of it.
This is also my use case by the way. Although I call it "Configuration.method" rather than e. g. class Config. Although I can see why you named it Config too; it's a minor different preference. Foo.bar is indeed nicer to read than Foo[:bar] The awkward thing is that I ended up using oldschool class-driven OOP rather than struct/openstruct storing information.
The name is a dead-give away too. Hashie ... who comes up with such a strange name!
What does this question have to do with RoR only interviewer can know. Immediate answer is to loop through array for each number. That is O(n*n) complexity though. I‚Äôm sure there‚Äôs more efficient way to do it. 
Do not put it into memory, just make it a generator (a function you can call, which will yield the next candidate): a.combination(2).select {|c| 100 == (c[0]+c[1]) } 
I usually have to specify the gem path in the config to make it work properly.
Does your third party provider have any features that will help? If I were such a provider, I'd let you associate a unique key with each charge, and return an error if you try to make a charge with the same unique key more than once. 
For each element n, you can map it to target - n i.e `{ n =&gt; target - n }`. If target - n exists in the hash, you can return n and n-target. Is fairly fast. arr = (1..10**7).to_a n = 1500342 h = {} values = [] arr.each{|num| h[num] = n - num if h[n - num] values &lt;&lt; [num, n - num] unless num == n - num break if values.size &gt; 0 end } puts values Here's a quick and dirty version, probably can be written better.
Please for the love of god switch to dark mode. This far my only complaint with VS code is that I can‚Äôt find a scratch pad for running code when execution is stopped on a breakpoint. I can run a single line, but RubyMine has this scratch editor that allows you to write complex functions and then test how they would return within the context of the breakpoint. I hope that makes sense. 
&gt; It might be better to get that functionality completely out of your ruby layer, if possible, and leverage the database layer to perform the operations via triggers, since atomicity is important. I think you can get the same thing with logic in the ruby layer but with the ruby layer logic leaning on transactions and/or locks in the DB. 
looks good to me!
I would probably start out by looping over the array and build up a frequency table for any number below 100. Once the frequency table is completed, I can quickly run over it to compute the number of possible sets. E.g. if there are 244 occurrences of the number 12 and 190 occurrences of the number 88, then it's possible to produce 190 sets of 12 + 88. The remaining 56 occurrences of 12 are lost. I think this algorithm should perform very well, with the performance being O(n), but it may be costly on memory depending on input.
I'm on Ubuntu and just starting Ruby so this probably won't help but here's how I did it. I installed the gem solargraph prior to installing the extension and also had problems making it work. For some reason, if I opened VSCode from icon or from terminal typing code it wouldn't work, and when I type vscode it works. TLDR: Try opening VSCode from terminal with vscode command
If the target number is 10 million, the frequency table can get pretty huge.
In OP's example, the target number is 100. If the input set is small, but the range is big, you can allocate entries as you find them. This means you'll have to use a hash table instead of an array, but that may be a nice tradeoff, if the input set is only 1000, but the range is up to 100 million. For optimization, one could do a prescan of the first 1000 entries and then make a decision based on the maximum and minimum value. Of course this assumes a completely random distribution.
I suppose the complexity can get high. If the array has 10 million numbers then it is going to iterate it for each element. It is a sequential operation. Is there a better way?
You're right. I didn't understand the original question well enough. u/chakkaveenu's answer is better, but currently returns only the first pair.
I want to talk about your first statement a bit, specifically why someone might use an interview question like this for a RoR position. When interviewing a candidate for a developer position, I care a lot about the ability to understand and solve problems by writing software in an abstract sense, and very little about familiarity with a specific language or framework. Having worked in the past at companies that have had the opposite priorities, my experience tells me that this is the better approach to avoiding bad hires. A skilled developer can pick up a new technology quickly, but a sub-par one will struggle even in a familiar space. Here‚Äôs what I‚Äôd be looking for as an interviewer if I asked a question like this: 1. Can you write working code? Even if it doesn‚Äôt solve the problem well (or at all)? Many people in a first screen will fail this step. 2. Do you understand the problem well enough to begin to put together a solution? This might include asking smart clarifying questions, about the ranges of possible inputs or edge cases. It‚Äôs _extremely_ common for candidates to solve a slightly different problem than the one presented (there are several examples of this in this thread). If that does happen, are you receptive to gentle nudging in the right direction? 3. Can you come up with a working solution at all? Even if its an ugly, brute force approach, this counts for a lot. 4. Can you critically examine your solution for problems, including time and memory complexity bounds? Even if you can‚Äôt come up with an optimal solution, suggesting that there is one out there is significant. 5. Can you actually build something that both works, and is close to the optimal solution? 
I wouldn‚Äôt build out the data structure in advance. I‚Äôd loop over each number, subtract it from the target, and see if the result was in the array. For optimization I might split the array first, only looping over items that are below half the target and searching items that are above half the target. The search array should also probably be sorted and binary searched since you‚Äôll be hitting it a large number of times. 
You're getting in the right direction with your lookup couplets, but we can do better. Let's look at the first element of the array: 1. This accidentally is the first match of your lookup table as well: it is coupled with the number 99, so if 99 was in the array this couple would be your answer. Since this isn't, we can continue with the next number: 5. This one exists in your lookup table coupled with 95, so if 95 is in the array this would be your answer. 95 does not exist in this array, so we continue until we get to 43, then we find 57 and we can stop. We don't need the couplets to do this, we can just subtract the current number from our target value to get our value to search for: ``` a.each do |n| return [n, 100-n] if a.include?(100-n) # or return true, depending on the requirements end ``` This means we have to search the whole array for every number we test. This is inefficient, we can convert the array to a set first to make the lookups faster: ``` require 'set' a = a.to_set a.each do |n| # Same lookup as above end ``` (A different option would be to shorten the array we're searching: since we already excluded all the numbers on the left as possible options, there is no need to search those numbers. E.g. once we've gotten to 17, we only have to search the subarray `[43, 60, 9, 19, 57]`, the left subarray `[1, 5]` has already been excluded A different approach can be used if the array is sorted (which of course is something we can do ourselves, but "What if the array was sorted" would most likely have been the followup question). In that case we can start with two indexes, one at the first element of the array, on at the last element. ``` [1, 5, 9, 17, 19, 43, 57, 60] ^ ^ ``` Then add those two values together: if the combined value is less than 100, we have increase the sum, which can only be done by moving the left index to the right. After a few steps we end up with: ``` [1, 5, 9, 17, 19, 43, 57, 60] ^ ^ ``` Now our sum is more than 100, we have to decrease the number again. We can only do this by moving our right pointer to the left: ``` [1, 5, 9, 17, 19, 43, 57, 60] ^ ^ ``` Voila, our sum is now 100, we've found an answer. If the number was 58 instead we would have to move our right pointer again, having both pointers at 43. Both pointers at the same number would indicate the sum is impossible.
It crashes all the time for me. I'll get a few minutes of completions and then it hangs using 100+% cpu until I kill it.
Jets looks awesome! Looking forward to taking it for a test drive. I'm also daydreaming about replacing ActionCable with AWS IoT for serverless websocket pub/sub. 
Hearing this does make me feel a bit better about dropping the API. Thank you.
Solargraph has improved a lot. What's cool is its developer communicates with the developer of the general Ruby extension which has meh code completion but great debugging support. So the two extensions can be used together without ill effects. You can basically get VS Code support for Ruby just as good as Node and C# at this point.
Yeah, it's pretty flakey for me as well, though the codebase I work on is pretty damn massive.
Do you have breakpoints working by any chance? That's the one thing I can't seem to get working properly on my employer's codebase. I don't mind using binding.pry, but if I didn't have to clean up after trying to debug an issue it'd be great. üòÅ
I have seen it before, does anybody use it?
.tr is certainly faster than .gsub. See [here](https://github.com/JuanitoFatas/fast-ruby#stringgsub-vs-stringtr-code) and [here](https://github.com/rails/rails/pull/17257). I'd expect that the bang methods would follow suit.
Looks pretty awful to me. I refer to both the code and the IDE. Things such as: module Foo module Bar module Bla module Ble WHY would you want to indent four levels? It gives you absolutely NOTHING that you need. It also makes me wonder why so many modules are used? It looks to me as if this is typical rails-inspired code. Rails can be truly an abomination. To the topic of IDEs - I think it is the wrong way to go when you think that you need an IDE, but I also understand that people can find an IDE convenient so IDEs will probably be used even more in the future rather than less (I refer mostly to integrated IDEs as such, not standalone tools that can be combined on a typical oldschool Linux setup). Considering that in a somewhat recent poll, most said they use vim for ruby code (which is a mistake too but due to other reasons), I think that the amount of ruby people who naturally use non-IDEs is way larger than those who do. 
These are all pretty awful IMO. I don't use emacs or vim but matz uses emacs and lots of people use vim. I am not advocating for vim or emacs since both are terrible, but I think when a majority uses non-IDEs then perhaps they may have a very strong point (that is the one to NOT use an integrated IDE).
Light themes will never not look like Notepad to me.
Great feedback. Love this. Thanks!
Going to work on this as a version 1 idea. Thanks!
Unfortunately they don‚Äôt :(
Four levels of namespacing isn't necessarily FizzBuzzEnterpriseEdition. It can be useful for organizing code. If your problem with it is indentation vs Foo::Bar::Bla::Ble, so fucking what? It doesn't even have anything to do with this post.
Care to elaborate how vim and emacs are terrible?
It's impressive when it works, but it crashes constantly. RubyMine does not.
This is a sample Google interview question. They have a nice video on how to solve it (bonus: it‚Äôs in an interview setting). https://youtu.be/XKu_SEDAykw
Yeah that was exactly the question thrown at me. Wow. Thanks a lot. That was indeed interesting to watch. One thing I would like to know is how does one determine the complexity of an algorithm?
&gt; I have no idea why others don't use them If I was going to guess/assume, it's because they came out right when monkeypatching was falling out of favor, so people spent the next 10 years on service objects and presenters that just might have TIMTOWTDI'ed to the same general goal.
During the discussion they asked me what if the couplet is at the end of array? Wouldn't going sequentially or from the start turn it to be slower? What you proposed is really interesting. To this one can additionally search for the value of the key we got from the subtraction in the array. That way there won't be any need to further build the hash. Because if you notice, when we get to 43 as a key and the associated value gives 57, we can also do a search if that value is present in the array. And we can immediately stop. What do you think? This was indeed an interesting answer, though. Thanks.
I followed [this article](https://dev.to/dnamsons/ruby-debugging-in-vscode-3bkj), mostly, and it works for me. Here's my config: { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ { "name": "Listen for rdebug-ide", "type": "Ruby", "request": "attach", "cwd": "${file}", "remoteHost": "127.0.0.1", "remotePort": "1234", "remoteWorkspaceRoot": "${file}" } ] } &amp;#x200B;
Hey thanks for the answer. Somebody listed a google video, yours greatly match up to it. Also I am curious to know, can you please tell if u/chakkaveenu 's answer can also be considered to be equally optimal. I have added a comment to further optimize the solution. One thing more, can you tell how we can come up with the related complexity of your algorithm or in general for any algorithm?
This seems like the right approach to me. O(nlg(n)) to sort and O(n) to search for the answer. 
1. you already use bootstrap. you can carry on with that. bootstrap themes on google 2. no idea 3. multiple ways. simple way, add a boolean flag to your user table, let call it admin: true, and one your own user is admin. 4. go with heroku for now, is crazy simple, or DO + dokku
If you want to create a blog for yourself, use a static-site generator: Jekyll (Ruby), Middleman (Ruby, the closest experience to Rails), Nanoc (Ruby), Hugo (Go, very fast), Gatsby (Javascript with React), etc. Write your blog posts in markdown, run the static-site generator to turn them into html pages, deploy to GitHub Pages or to Netlify. Boom, done. &amp;#x200B; The only drawback to this is that if you want to enable comments to your articles, you‚Äôll need to jump through some extra hoops; but other than that it‚Äôs perfect!
Yes it would be slower in that case. I suppose you could sort and start moving from both ends to the middle. I built a hash to get O(1) lookups. Searching for the difference in the rest of the array will still be a linear time operation if you use include? or O(log n) if binary searching. Since your array can potentially be huge, I think a hash would be the best fit.
The solution above using set and mine are pretty much the same, since sets are like hash tables with only keys. I did not know ruby had sets though, TIL.
I just started this recently as well. I don't think you need any front-end library for a blog, seems like overkill. It's really easy to build - you don't need to use a static site generator. You'll want some simple authentication (devise is easy - you can disable registration after making your account if you want), user model, post model, maybe a comments model if you want to allow comments. I made a post on how to use markdown and code in your blog [here](https://www.xdotnil.com/posts/1-using-markdown-in-your-blog-with-ruby-on-rails) and a post on using slugs [here](https://www.xdotnil.com/posts/2-adding-slugs-to-your-model-in-ruby-on-rails).
If you loop through each item in the array and loop the remainder of the loop again your getting a time complexity of O(n)2. Loopin through the array and checking for array.includes(target - eachvalue) also has the same complexity as array.includes will also have to sift through the array looking for a value, this is essentially the same solution. You can do this in constant time with two passes over the array. One to create a map from the arrayvalue =&gt; arrayindex. Then loop over each item in the array looking for (100 - arrayvalue) in the hashmap, and when it exists in the hashmap you've found the index or the corresponding number. As hashmap lookup is O(1) you get cheap lookups. This is a common interview question. [https://leetcode.com/problems/two-sum/](https://leetcode.com/problems/two-sum/) &amp;#x200B; def two\_sum(nums, target) hash={} nums.each\_with\_index do |el,idx| if hash\[el\] return \[hash\[el\], idx\] end hash\[target - el\] = idx end end &amp;#x200B;
Check out Big O notation [https://en.wikipedia.org/wiki/Big\_O\_notation](https://en.wikipedia.org/wiki/Big_O_notation) &amp;#x200B; While it's a great idea to understand function complexity and Big O notation, the real life simplification of it all basically comes down to "does this function have constant, linear, or exponential complexity?" Answering that question will often guide you to a more efficient algorithm, if one exists. 
Any time I see a library like this the first thing I do it look for a section on the impact on consistency guarantees. In this case, it doesn't seem to exist so I assume it's not even being thought about and thus there are no consistency guarantees provided which immediately rules it out for any serious use. Side note: Updating a few million rows should be really fast, if it's not, likely your issue is elsewhere. 
ruby just doesn't do that. 
Have you read the entire concept ? The idea is to make it easier than struggling between different ways to update things up. We are not talking big companies and big resources here. Taking the whole morning to setup a migration linked to a deployment is a struggle and companies such as Shopify have their own parallel asynchronous pipes to make it work smoothly. Truth is, there's a need, but people in the middle (which aren't small projects, but not too big either) are being ignored, not only talking about this concept, they are ignored and that's why scaling is so difficult, because you're in the middle of something ...
Well if you have a million items to deal with in a problem and you do O(n\*n) you're going to cause a bottleneck in RoR or otherwise. Its checking if you understand the cost of operations on different data structures.
&gt; Have you read the entire concept ? Yes, I did, it doesn't address consistency issues which are paramount in migrations. I'm looking forward to more information on how it handles this. 
O(n) time is possible without the sort. See other answer.
Just tried a solution for this, for fun. The below works but can probably be improved a ton. The PITA is when item is half of the target number. def find_sum_of(target, arr) arr.each do |item, index| num_A = item num_B = target - item if target / 2 == item &amp;&amp; arr.count(num_B) == 2 return [num_A, num_B] elsif arr.include? num_B &amp;&amp; arr.count(num_B) != 2 return [num_A, num_B] end end end 
Just tried a solution for this, for fun. The below works but can probably be improved a ton. The PITA is when item is half of the target number. def find_sum_of(target, arr) arr.each do |item, index| num_A = item num_B = target - item if target / 2 == item &amp;&amp; arr.count(num_B) == 2 return [num_A, num_B] elsif arr.include? num_B &amp;&amp; arr.count(num_B) != 2 return [num_A, num_B] end end end 
This. There‚Äôs always much written about how it ‚Äúworks‚Äù in 5 minutes. Always lacks consistency, what happens in case of failure (failed ddl migrations probably will kill your live app), etc. My advice: if you think you need something like this, rethink and find better solutions.
I have to agree with /u/moomaka here. You will _probably_ have a bad time if you expect your web app to serve requests with a giant database migration running in the background. Even if in your particular case you got out with your skin intact, as you mention in your article, this is still a highly hazardous approach that teams should be extremely cautious about. I would probably dismiss any tooling intended to support "asynchronous" migrations as if they were a normal operating procedure. And I think what's important about his comment is that migrating your database shouldn't be slow. Why is it so slow? Following that line of questioning will likely lead you to a solution that is fast enough to not _need_ the kind of approach you're advocating.
What do you mean with ‚Äúignored‚Äù here? Are your bosses not listening to other advice to prevent the mess you‚Äôre in?
Consistency issues aren't addressed here, I'm not a wizard. The point of the gem is to turn some of your migrations asynchronous as you would use parallel rake tasks / workers but instead of building up all this you use one keyword on your migration flow to focus on writing the logic itself. For instance, instead of switching to raw SQL to avoid locking up the deployment on something that can be down "later", you just keep it in Ruby and it'll be handled by the workers instead. I actually did that because I was struggling, but a few of my friends working at startups had the same kind of issues, so I guessed it was a good idea but looking at the downvotes I guess I lost a few weeks of my time.
&gt; Consistency issues aren't addressed here, I'm not a wizard. That needs to the be the first line in the README and it needs to be in bold letters and a lot of follow up explanation as to what guarantees do or do not exist. Otherwise any cognizant reader is going to consider this library a method of playing Russian roulette with their data. 
Percona Tools is great if you're stuck on mysql and having to do `ALTER TABLE`s on really large tables. The [percona_ar](https://github.com/jamesmacwilliam/percona_ar) gem is great for this. Or just go MariaDB for non-locking alters if you have to stick to some flavor of mysql.
&gt; Otherwise any cognizant reader is going to consider this library a method of playing Russian roulette with their data. And less operationally savvy readers will look at the gem, see some github stars, decide to use it, follow the documentation, flip Frankenstein on in production, and end up with a seriously jacked up database when something goes wrong.
Yes, this is certainly the danger. I'm not arguing this is useless, it very well may be, but it's critically important that the user understand how it works, when they should use it and what safety they are giving up by using it. A 'blind' user may grab this thinking it works just like normal migrations except 'better' and destroy their data. 
Well, it's not slow because you find solutions to make it faster, and you end up scheduling a lot of things to make all that pass, that's the pain point I actually want to fight, but as I said in another comment, it's not black magic you have to actually work a lot on what you're doing, it just removes the need to work on building up new workers, new rake tasks to make it through once, you do all that faster by switching one of the migration "files" to another parallel queue
&gt; The point of the gem is to turn some of your migrations asynchronous as you would use parallel rake tasks / workers but instead of building up all this you use one keyword on your migration flow to focus on writing the logic itself. Even if it destroys the data integrity? 
Well we get to it, I actually find ways to make those deployment working but it's not so easy, there should be more guys working on this thing, but why not having multiple queues ? Technologies can do that, why everyone is building their own stuff and keep it private ? That was the idea behind this gem
It's an introduction article so people could "get it" fast and then think on what they could use it for, on the gem itself I wrote more details about failure handling, you do have to to code some layers on top of it if you want to handle things well. You can customize things up by setting your workers to never retry a failed run, it's possible thanks to this coupled with a little configuration. Then you can write a little dashboard to check it up and call up for changes. You don't have to use ActiveRecord functionalities at all as far as I know, and write up some other scripts in it. Running a parallel pipe is not a new concept, I just try to make it more smooth &amp; available with this. I didn't say you should put anything in there, don't configure shit and ignore what you know about migrating data. I hope it's more clear with those details ...
Nice. Ruby hashes are awesome. You can pass a block to be executed if you have a miss so this could be super elegant. Ruby makes dynamic programming really pretty. 
That's the kind of feedback I need to improve the documentation. You should all be aware this gem is new, I wrote the whole documentation + article in one night and I posted it here to have feedbacks and now that I see all the "warnings" I should add some educative lines to it. Migrating data isn't simple, and yes it's not magic, but it can be useful and I was the first to see the interest in some of my work, that was the purpose. I thought people who would use it know how to deal with workers and heavy migration on the first place ... But now that you point it out ... Maybe I should edit it a bit
Just updated the readme about this, thanks for your feedback
I'm sorry but after reading the code, you need to take a step back. It's riddled with consistency issues and assumptions that are not true. There are plenty of places where you can release open source stuff to help other people without much concern but database management isn't one of them. If you wish to continue this project then you need to spend some serious time understanding distributed systems problems and how to approach them. 
On a side note it is a good thing that these types of issues cause your belly to spin -- that is much better than naive implementors that do not "see" the risks around processing payments for how huge they are. &amp;#x200B; Depending on your merchant provider you can also add in layers of active checking recent transactions for duplicates and other verify state calls before you attempt to charge or move the current state forward. &amp;#x200B;
&gt; flip Frankenstein on in production My sides :D
Hi! I‚Äôm gonna pm you
Sure, I'm on Ruby 2.6.0 and didn't do anything particular to get it working. I use Fedora Linux on my dev machines, and I do my actual Ruby work in Docker Compose [using this recipe](https://github.com/dogweather/rails-docker-compose). I don't try to get solargraph running in the Docker container. Instead, I additionally do a bundle install on my host machine to get all the gems, and then do `gem install solargraph`. I launch VS Code from the work directory with `code .`, and this always works. The CS Code Solargraph plugin even detects when the gem is outdated and offers to update it for me, which also works. I use rbenv on my host machine.
Working fine for me on Fedora and Ruby 2.6.0. 
Yes, u/shevegen could you elaborate with a "because..."?
Nope! haven't tried that yet. I do it the manual way by inserting a `binding.pry` where ever I want one, but I'll try it with the VS Code support.
Yeah, that's what I and others do as well, but when I have several it's just annoying to clean them up before committing. Fortunately it shows up as a warning in VS Code due to our RoboCop settings so finding them is trivial, but still, breakpoints just feel cleaner and faster to use.
I don't think the downvotes you got are necessary: I really like a critique. &gt; WHY would you want to indent four levels? Like the other commenter said, there's the issue of indenting and then the issue of a deep namespace like that. I believe the deep namespace is the right for this code: it's part of an ETL system for scraping, parsing, and importing laws of many different jurisdictions. So there's a ton of code that's common, but then a ton of exceptions and code that's particular to a certain place. Some places need frequent updates because they change their source formats frequently. Others don't. This is the third version of this code --- I started off with nearly no namespacing, and just winging it. That resulted in a huge mess. So I have: ``` module PublicLaw # My app's namespace --- ALL my code goes in here so it's not global. module Import # All the import code of the ETL process. module Nevada # Nevada-specific code. "Adapters", and also parsers, etc. module Reformat # Specifically, functions to translate URL and HTML into the Public Law formats. ```
We manually run the `pt-online-schema-change` command for any alters we have to perform. It‚Äôs such a good tool. 
After your comments I gave lots of thought into what I did, and realised I was actually leading to a misuse compared to what I would use it for, and why I started this library. I've edited the gem documentation and the article I wrote to match a more correct use of it, with lots of warnings so people don't fuck with it by using it like they would with the classical ActiveRecord::Migration queue, because it's not the same. &amp;#x200B; Thanks for all your feedbacks.
It would be so much better if it had an accurate status bar!
Google, jumpstart rails blogger v2 There is a section on adding comments there
MY EYES THE WHITE BURNS MY EYES. I seriously don't know how people write code like this.
Im sorry but I don't understand why you'd want async migrations. What are you trying to do? If it's a data fix or database change why don't you want it done immediately as a part of your deployment? 
i have the same exact experience on mac os
I 100% agree, and have had many of these same realizations. Especially, that the people with control over Ruby's further development aren't actually major Ruby developers. They don't feel the pain of so many primitive problems with the language. I got downvoted to hell the last time I said that, so we'll see... I think the other items you list are all correct, and a result of a couple of big problems in the Ruby development process: * No semantic versioning, which means that the community gets excited about "2.6!" and triumphant posts are written. But in actuality, it's not a major release. Semantic versioning would help keep the promotional tone in check. * No planned roadmap or open process like Python's PEPs, Swift's, Golang's, etc. Improvements come in hodge-podge when someone is persuasive enough in the firehose of comments that is the Ruby issue tracker. New features and hacks get tacked on, and old ones aren't culled. It's not a very professional outfit, all told. 
But JavaScript does everything async and that‚Äôs what all the cool kids are doing, so it *must* be better. /s Honestly, I don‚Äôt get it either. 
Well, I don't agree on versioning. It seems ok to me. But yes, I absolutely agree on "persuasive enough" issue. I'm in love with ruby and it pains me to see this tendency. Of course, if you can use the word "tendency" for many years of stagnation.
Fair enough. Yeah, I think the best approach is to take a zen-like attitude, and just see that Ruby is what it is. Take it as it's presented now, and don't hold out expectations for something different in the future. That _is_ pretty disappointing - for me, the core Ruby syntax is excellent, and I deeply appreciate the MINISWAN code and subsequent rejection of US-American social justice pressure to adopt a Coc. That is deeply, deeply appreciated. I predict that in a few years, Ruby will still be mostly the same, and be in use mostly as a better Perl, which it's great at. And the Ruby app developers and professional programmers will mostly move on to Elixir/Phoenix, Python/Django, Kotlin, and Rust.
I didn't read the comments so I'm pretty sure someone suggested a better solution. Here's mine: Just loop over the array and use hash or set for checking if pairing number is found. Something like: ``` unique_numbers = {} array.each do |n| pairing_number = target - n return [pairing_number, n] if unique_numbers[pairing_number] unique_numbers[n] = true end ```
They don‚Äôt care. Dark themes needed for night hours, light for daytime.
&gt; people with some authority in ruby community (for example, Bozhidar Batsov and Brendon Weiss)
What is your point? These are just examples out of my head. If you have something to say, just say it:)
Those are great examples, FYI. The Rubocop project has done so much to level up Ruby.
maybe ruby needs this: https://lwn.net/Articles/775105/ and proper PR like pip 
I started software development with RoR and it's the best thing that could have happened in my life. RoR taught me many best practices by sheer regulation. Can't say the same for the NodeJs/frontend community. When my old company went bankrupt and I needed to switch, Ruby failed to provide me a job. Ruby usage is declining, Ruby job market is shrinking and the remaining Ruby shops needed super-senior type devs. Back then I wasn't senior.. I still continue to use Ruby for private projects but job-wise my focus lies on JS/Node and Golang.
At least up to this point Ruby has some consistency, despite being multi paradigm and having adopted a lot of features from elsewhere. I think Matz is rightfully cautious about adopting new things from all sorts of other languages. First of Ruby is an OO language, where the building block of computation is an object, with methods sent to them. In ruby we don't have functions - no we don't (or procedures either). In a functional language a function is the building block of a computation, you can reason about it just by understanding the function, it makes sense on its own, without the rest of the program. Therefore you can export just methods from haskell modules (seen this exact thing couple of days ago here on r/ruby), a ruby method does not make sense own its own. By its very design it manipulates object state, and interacts with the rest of the object. We do have some functional looking things sprinkled on the language, but as a functional language Ruby really sucks. I say this and I love Ruby. But you can't be good at everything. I think dying is too strong word. I think merely losing popularity. But this isn't Ruby's fault. These days the hip thing is functional. So ppl are won over by elixir, lesser extent haskell etc. For ruby to become one of them would have to rethink itself from the very fundamentals of the language. It would have to drop the smalltalk like object model, etc. It wouldn't be ruby anyways. &amp;#x200B; Personally I think Ruby has gone far enough. And I don't know yet what's the hip thing going to be in 2025, but probably it's not going to be functional - or not the way we know it today. Instead of being fashionable all the time, just be a good language.
Function composition in ruby - just a Proc/Method method that creates a new proc, composing `self` with `other`. It's very basic operation. And very convenient one. And it can even be implemented in pure ruby: ``` class Proc def &lt;&lt;(other) proc { |*args| self.call(other.call(*args)) } end end ``` No fancy functional programming here. Just an object composition. It doesn't affect ruby itself. It is **just a method**. And why are you so concentrated on FP anyway? Many people are moving on Golang, for example. This post isn't about FP in ruby. It's about Ruby being in stagnation and being designed basically by only one person.
To be honest, most language developers write C instead of working in the language itself. And this might be wildly out of date, but doesn't Matz work at Heroku which is a ruby shop? So I wouldn't say he doesn't know what's going on when it comes to ruby usage... I think what's happening (atleast the people I know) is that ruby's flexibility allows them to implement the features they want themselves. 
&gt;And why are you so concentrated on FP anyway? Personally I have spent some considerable amount of time in haskell. I know why its good, and why it's not so good. Mainly it's just different. &gt;This post isn't about FP in ruby. It's about Ruby being in stagnation and being designed basically by only one person. That's the point, I think it's related. There is a paradigm shift going on in terms of popularity, and Ruby is on the wrong side of the fence. That's why people yearn for elixir/haskell features in Ruby, and reluctance to adopt them is not mainly because the core team is not capable to give these features in one form or another in a much faster pace, but because there needs to be a careful consideration that these features don't go too much against the core language features like smalltalk like OO. &amp;#x200B; Quite a while back we adopted the { a: 1} hash syntax. I believe that was a mistake, now, half newcomers don't understand the difference between a hash and an object. The way we are going Ruby might become a mish-mash where it would be hard to explain the difference between a method and a function. There is a danger in this, and most seem to me completely oblivious to it.
I don't agree with you at all. But I hear you. Thank you for pointing this out, it's interesting opinion. I hope there will be more people with interesting points
You should really take a walk through https://www.railstutorial.org/book - it will answer most of your questions and give you an idea of what you need to do. It also covers deployment with Heroku which I found really easy as a beginner. Use namecheap for your domain if you don't have one already.
After the first iteration I listed two disjunct possible improvements: replace the linear array lookup with a hash-based lookup (with an example), and remove the duplicate pair checks by using subarrays (without example). The code of /u/chakkaveenu combines this two improvements, making it the better solution. I would have used a set instead of a hash there, but that's already been explained. I haven't done any format complexity analysis since university, I just used some rules of thumb to decrease the complexity. 1. Prevent unnecessary operations. The lookup table was a step in the right direction, by showing that we need tuples of 2 numbers that add up to 100. You already noticed yourself that this would be very inefficient if we were searching for a sum much bigger that 100, so start by determining what could be improved here. A possible improvement here would be seeing that the order of the tuples does not matter: `(1, 99)` is the same as `(99, 1)`, this would split the lookup table in half, but that's not good enough (just double the sum value and we're back were we started). Next step: we calculated `(2, 98)` (and `(98, 2)`), but both 2 and 98 do not exist in the list, this means we would be able to calculate a lookup purely based on the value of a (something like `a.map { |n| [n, 100-n] }`). This is an improvement, but only because `a` is small compared to the sum value. What more can we skip? Look at the first calculated tuple: `(1, 99)`, we know that `1` is in our list, so we only need the value `99`. I guess this is the moment where most people realise that there's no need to generate a lookup table in advance, you can calculate the lookup value on the fly. As an exercise: imagine a list with repeated values, is there anything we could do to skip calculating them again, and would it be worth doing that? 2. Prevent slow repeated operations. The repeating operation here is checking the array for the other value of the couplet. Checking if an element is in an array does mean a linear scan, we have to check every value. One improvement here would be to check only subarrays, this is an improvement but not by much, and the resulting code would be far from pretty. Another option would be to sort the list, the linear search can be replaced by a binary search, but having a sorted array does often mean there will be a more efficient algorithm (leading to the double pointer solution explained earlier). Can we do better than a binary search? Yes, a set would be a better data structure than an array, lookups are now more or less in constant time. But what if the array would is very large, this would mean we construct a very large set of it, can we create the set incrementally? Yes, and now we end up with code similar to that of /u/chakkaveenu. Would you ever need this code at your job? Very unlikely. For a job interviewer the resulting code is not very interesting (and if I had to write the code for the double pointer algorithm on a whiteboard, I wouldn't be surprised if it contained an off by one error). But it's not about the destination, it's about the journey (or more precisely: the thought process). Describing the iterative process of improving the code gives the interviewer insight in the way you're thinking, and it kills the uncomfortable silences as well. It also makes it easier for the interviewer to point you in the right direction: when starting with a lookup table, the way to make people realise this isn't the right way is "but what if the sum would be really big". If you had started by sorting the array, the response would most likely have been "but what if the array would be very large". And once you have a solution, you'll get a followup question with a slight modification of the original problem. What if the array was sorted, what if the array may contain duplicates, what if we're searching for triplets? Having all those intermediate versions of the algorithm allows you to start with a less efficient version that works (or is easily adaptable to a working version) for the new case, and you can have a look at all previous improvement steps to see if they're applicable in the new scenario. And writing down the problem mutation of duplicates made me realise a lot of versions here have a bug, if the array contains 50, it would yield the solution `(50, 50)`, but we only have a single 50 available.
And honestly, I hadn't realised the improvements "Set lookup" and "Subarray lookup" could be combined until I saw the implementation that did that.
My idea was similar to yours, with a few additional observations. * Skip for numbers &gt; target. * I'm thinking you don't need to store both numbers (`num` and `n-num`) in the checking hash, for better use of memory. I tried using the Set class, as it uses Hash storage, but with a sort of "key-only" API. Then I looked at the source for Set.new and Set#add. It looks like they just use `true` for the value side. At least that's smaller than arbitrary-sized numbers, I would think. require 'set' def find_first_pair(target, a) set = Set.new a.each do |el| next unless el &lt; target return [target - el, el] if set.include?(el) set.add(target - el) end return nil end 
&gt; During the discussion they asked me what if the couplet is at the end of array? Wouldn't going sequentially or from the start turn it to be slower? I think no matter where you start from in the array, the couplet could be "somewhere else." If you had more information about the array, like if you knew it was already sorted or ordered somehow, that would help. Additionally, if you add code to pre-sort the array, it would spend more processing time doing the pre-sort than it would take to just find the couplet by /u/chakkaveenu's method. It definitely seems like they were gauging your skills related to algorithmic complexity, as others have noted.
&gt; It's about Ruby being in stagnation and being designed basically by only one person. No matter how brilliant that person is, a single point of dependency is *always* a single point of eventual failure. I'll have been in software development for 40 years come June, and the next project I see that doesn't follow this will be the first since, oh, [VisiCalc](https://en.wikipedia.org/wiki/VisiCalc).
I said this multiple times ( I search back history turns out it was 2015 ), but I kept forgetting the answer, there are a few Ruby Core who absolutely loathe Non-Free Development tools like Github. In fact even free tools like Gitlab had a hard time. ( I would much rather they stick to redmine then Gitlab ) . &amp;#x200B; So that is not going to happen anytime soon.
`callcc` is a very convenient feature for some use cases (resumable exceptions are awesome!) but it's also unused by 99.9% of the ruby code. It would make sense to remove it, but it was added just because matz did not push back in the early years of ruby. Having too much stuff in the core is an issue, and it makes sense to push back _especially_ for stuff like function composition that can be implemented in ruby itself. Ruby is evolving slowly maybe, but a lot of development does not need to happen in core. 
then is fine. in near future ruby will be used by them. Ruby is not java to be baked by big companies that will maintain they legacy software for decades. i don't want to be pessimistic, but this is the reality. My current job, we are predominant ruby job, I'm the CTO, but we start looking to other tools. We are using jruby, and ruby, but my problem is finding people, and the ecosystem that is smaller and smaller. Why should I use ruby, when I can use kotlin, for example? or go, or even python? anyway, I dont want to become more turbulent here, I already complain, I even tell this to matz at Wien, but fine. I'm a small adagio to the ecosystem.
It has absolutely nothing to do with that, at all.
Retrospection and introspection is always good.. Plus constructive criticism are always good too (which seems the case here). Always +1 for this kind of "rant"! Before I mostly adopt ruby (vs pyhton) (as a former embedded c developer) one choice for me was about the language long term orientation.. At that time I've heard things about Guido stating that *he* will decide what evolution the language will adopt.. I'd not hear something equivalent for ruby... Now I'm thinking if it was not the other way... I rather have expectation for ruby 3... Wait and see..
When you have very heavy updates (understand altering some entries with complex conditions) which are needed you usually try to make it pass in the migrations via Ruby or outside through some tasks / workers, I usually go for raw SQL to make it faster too but this is actually not so easy to handle because it's usually less simple in SQL to build up this logic. The idea is to keep it in the migration flow for the coder but putting it outside of the deployment itself so we're "done with it" as for the restart of the instances (for example) and it can propagate the changes slowly on another queue ... What people don't seem to understand is that I didn't create this concept, I just want to make it more available for smaller projects than what it's usually implemented in. 
To me, "programmer-friendly" also means being careful and slow to make sure what you introduce is right, and maintaining long-term backwards compatibility (which is related, because once you introduce something, you're stuck with it). There's no free lunch. 
Good point, sir. Thank you:) However, I think we just need to speed up the process without losing quality
Sure, I want everything to always be high performance, do everything I'd ever want, do it perfectly, be finished quickly, and at low cost, all the time, too. :)
Also see every bug tracker issue in the last 10 years on $SAFE.
Hi All, This is not the solution but I want to share what another open source project do for a long time. the Blender.org SDLC could be a great inspiration: Blender includes projects for developing specific list features and every project use fundraising from the community and/or sponsors. In this way, Blender keeps in touch with the community requirements nearly every 6 months create a new great version solving real problems. Off course this is a different scenario and the community of Blender is most artists/CG geek but I felt that this can still somehow helps this discussion. &amp;#x200B; Have a great weekend! &amp;#x200B; Marco
I am a total newbie with only 3-4 months of learning ruby mainly for Sinatra usage for the time being. I started ruby cause I wanted it to teach me better OO so as to become a better developer to java which is my main language to go but it is not that much of a scripting one (verbose darling...) Ruby has the best tutorials and one of the most cool and inviting communities but the elephant in the room is RAILS. Ruby has to overcome it's usage to the web and start making more developments regarding to AI and deep web. As for jobs it is declining fast as people prefer python due to its dominance to everything but web (Django is good enough but I don't think it is yet at the standard of ruby) . Ruby needs to step up not as a language but as a general purpose language that it is and try to expand and be the go to language to new fields whether that is embedded systems (which cool things already exist) or to the hype of our era AI :)
Maybe try CMS? There are engines for RoR like RefineryCMS
I think the original idea of Ruby being developed mainly for ‚Äúdev‚Äôs happiness‚Äù is a bit outdated at this point. I would say you can get only that much happy with the lang itself and there are more pressing issues with Ruby per se than its ergonomics. The number one question that should be asked is ‚Äúwhat kind of problems does it solve ? And are these problems still relevant to people ?‚Äù 
I'm not super familiar with the Swift and Go ecosystems, but in my opinion, PEPs have turned Python into an abomination of design-by-committee. I don't agree with Matz and the core dev team 100% of the time, or even the majority of the time, but even so I think they've done a pretty decent job of advancing the language without turning into yes-men for whatever proposal seems semi-popular on the mailing lists that month.
&gt; Take it as it's presented now, and don't hold out expectations for something different in the future. This is really good advice. It goes for frameworks, libraries, languages and so on. A (really) long time ago, I fought really hard to make Drupal something it was not, nor wanted to be (a development framework, alike the -back then- brand new Rails). Until I realised that there already was such a thing: Rails! I stopped fighting and started using Rails instead. Same now: I need lots of really heavy data-processing stuff done (OpenStreetMap and Gis and such). I did use Ruby for data processing [Kiba](https://www.kiba-etl.org/) is fantastic! And I did write some small tools to react to events on Ethereum using [Event Sourcery](https://github.com/envato/event_sourcery) and [ethereum.rb](https://github.com/EthWorks/ethereum.rb#receiving-contract-events). Fantastic PoCs! Ruby is still great for that. But instead of fighting Ruby, and making it do stuff that its not very good at, nor wants to do, I chose to learn Go to write some preprocess tools. And am currently learning rust to build some tools handling and processing events; both in a much simpler, and much faster way. This is what keeps me happy. And Ruby is all about making programmers happy!
We have been saying this since the 1.9 release. Ruby is not managed by people who use the language. 
This was exactly it. Thank you 
Way back when, similar sentiments were expressed about Rails. Lots of devs were upset with changes DHH was making and blogged/tweeted about it. DHH responded with this: https://dhh.dk//2012/rails-is-omakase.html Of course it‚Äôs not the same thing. People were complaining about DHH‚Äôs additions and changes and you are discussing Matz‚Äôs non-changes. But what he writes at the end about his opinion vs yours is probably what Matz would say too to the idea of a consortium. It provides insight into the way a creator looks at his work. All that said, it‚Äôs time to recognize that Ruby is a legacy language at this point. And I say that as someone who codes only in Ruby, uses only Rails, and (stupidly) hasn‚Äôt expanded his skillset yet. The writing on the wall is so clear. Think: when is the last time somebody wrote a great new Ruby gem? I can‚Äôt even remember. 5-6 years ago there were amazing new gems coming out weekly. It‚Äôs time for all of us to move on, unfortunately. 
I agree with a lot of what you said, but I think you‚Äôre skipping a major component of cycling back to functional languages, concurrency and parallelism. As hardware scales horizontally FP is the way to go, if CPU were the current driving factor then OOP has more of a place. It‚Äôs less about being cool IMO, although I‚Äôm sure that does play a small part in some people‚Äôs reasoning. 
maybe many people won't agree with me on this but I think ruby is great in cases you need to write something very fast. For example, a prototype of some system. And when it is in production and business is going you can start replacing some system parts (services) in other languages, that are more suitable for this (golang as most popular example). BTW, in this case having many utility-features in language (like said compositions and `then`) is a good idea (unless they break everything or making people write bad code).
I disagree with this. I dont think a great new gem indicates anything would not say Ruby is a legacy. It‚Äôs people having unrealistic demands for a lot of things. 
My point is talented developers don‚Äôt seem to be working anymore in Ruby. Hence the lack of great new gems, blog posts, ideas etc - otherwise why has it all dried up? Bc ‚Äúit‚Äôs all been done‚Äù?
Matz has said time and again that the most important thing about ruby is its community. He and the core team do listen to people, and theirs is a difficult task, balancing the old (stability) and the new (break-through innovation). Great things have this quality, eg you know a Mercedes when you see one, either a vintage model or a brand new one. Think Lean: one strives for many small, continuous daily improvements (kaizen) and few radical changes once in a while (kaikaku). I do think ruby needs a radical change; ruby 3 provides the opportunity. Options: * Being more functional? `dry-rb` project seems to be gaining some traction with the existing toolset (even have monads); they've recently joined efforts with the hanami web framework. And... we do have `module_function` and `proc`, the former used extensively in [ruby core](https://github.com/ruby/ruby/search?q=module_function&amp;unscoped_q=module_function), the latter being just an encapsulation over a block of code. Pretty close to pure functions... Immutability is actively being pursued (`deep_freeze`) within the Channel/Guild implementation by Koichi Sasada. * Sheer speed? Current `JIT` is a start, aimed at betterment. There's talk about 2-tiered `JIT`, default first tier with fast compilation and less optimized code, second tier (slower) gcc compilation for a handful of methods producing optimized code. * Better concurrency? We DO need IMHO a better abstraction to leverage multi-core CPU's *and* optimize IO-bound programs like web frameworks, micro-services architectures, database drivers, and whatnot. `Guild`s are aimed at parallelism and frankly that alone doesn't cut it. Some people are turning to `Fiber`s in the meanwhile (`Async` project, `Threadlet`) to achieve more or less automated non-blocking processing. \[rant\] I say we should embrace the go way and aim for fully auto-scheduled coroutines supported by the VM, using channels as the preferred sync mechanism. We could perhaps take the work already done with `Guild`s to design a separated context in runtime, where the coroutines would be *deterministically scheduled* to run on 'decoupled' OS threads; blocking coroutines would (automatically) be yielded and a queued couroutine run in that OS thread instead. Blocking OS threads implies the (automatic) re-scheduling of queued coroutines on another running thread. All this under the hood. I know this sounds a bit crazy, but this (single) Guild would not support ruby `Thread`s, `Fiber`s, nor... GVL. Those in the know say Go concurrency model is one of the language best features, not in theory, but because it makes developer reasoning about concurrency simple! I say ruby could benefit from it to make a huge leap forward, and still retain its essence.
Maybe check out Crystal? Very ruby like. The core team is very receptive and things are fast moving. Additionally, the standard library is written in Crystal, making contribution very easy for the average dev. It‚Äôs a young language, but is making great strides. I‚Äôm really excited about where Crystal is going.
Thanks for the kind words! IoT and websockets would be super cool. It‚Äôs possible now since API Gateway supports it! Haven‚Äôt played with websocket a while. Will probably do so in time again. üéä
&gt; but because it makes developer reasoning about concurrency simple For extremely basic cases, sure, but for any real-world use you still end up fiddling with locks and semaphores because channels aren't a panacea, and god forbid you actually want to manage cancellation properly and ensure orderly shutdown of all your goroutines... Eventually you have a hand-rolled re-implementation of some task-related features of Ada, and maybe a few things there and there similar to that of Erlang/OTP and [Trio](https://github.com/python-trio/trio).
To some extent yes. The low hanging fruits are all gone. The problem is that the unrealistic expectations we have. Look at JIT for example. Anyway I would not say it‚Äôs the end of it. We are just hitting the end of development with no tech giant being invested too much in Ruby.The closest you get is with Stripe and perhaps Shopify. The driving force behind gargantuan projects will always be a use case and that can clearly be seen in Stripe‚Äôs effort on sorbet. I would say the main issue with Ruby is its design ( so the things that we love about it ). We need a subset of strongly typed and performant ruby to explore other use cases. JIT and guilds are nice but i cant think of an app that I would not use a different language because of Ruby‚Äôs shortcomings.
(honest question) We'd still be better off than current Thread/Fiber (and future multi-Guild setup), no? 
The runtime of Go is great, but as for the ergonomics of the concurrency features, well, there's the select statement that allows a few neat things, otherwise it's very similar to what you'd do in python and ruby: put locks everywhere (the defer statement helps though), make sure you don't create a deadlock with your channels, do a major refactor because you want to introduce cancellation, make sure you don't leak goroutines, write your own restart logic of long-running daemon threads, etc. It's still hard to reason about concurrency in Go, and writing type-safe packages to alleviate that can be impossible due to the lack of generics
Never heard of a hot swappable laptop battery before. It's super obvious now that I've read about it. Very cool feature. 
Fair enough, many thanks for the detailed answer! The advantage of being a latecomer is one can learn from the shortcomings (such as cancellations as you pointed out) and do something about it. 
It's such a shame ruby doesn't have better concurrency features despite what the language itself is capable of: the standard's library thread times are buggy (I got bitten by that!), celluloid, according to its documentation, can't be used on calls that make block indefinitely like on sockets, https://github.com/socketry is doing interesting things but has limited resources, etc. Meanwhile even freaking *perl 5* doesn't suffer from a GIL and doesn't share variables between threads unless you explicitly mark each variable as shared.
Oh wow. Sounds so familiar. I've been working as a Rails web dev for some years. Ruby is my first language of choice. And last year May I lost my job at a startup. Ever since I had started looking for a new job I got only one Rails interview which I, unfortunately, failed thus not landing the job - senior level devs were preferred. And I am not one of them. Right now I'm considering Rails remote job opportunities - the path I did not want to follow initially, but I am running out of options over here. In the meantime, I've been learning various languages, like Python, Go. Played with Scala a bit. Leaning towards learning Java. And thinking of working in a bit more established companies than startups (maybe not as fun, but definitely more secure)
What about other Ruby implementations besides MRI? JRuby looks good, no Gil. Also, did you check Graal Truffle compiler? Really great performance. And just found the Rinda for concurrency dev, based on the object space Linda impl. http://ruby-doc.org/stdlib-2.5.1/libdoc/rinda/rdoc/Rinda.html
&gt;I think dying is too strong word. I think merely losing popularity. But this isn't Ruby's fault. These days the hip thing is functional. So ppl are won over by elixir, lesser extent haskell etc. hip isn't translating to real usage uptake though. elixir is making limited gains for all the buzz about it. GO and JS (node) are the languages dominating and though people hat to admit it - php is still going strong. 
No, I was just being facetious. Perhaps your sarcasm detector is in need of adjustment. I read the article, and it appears to be in fact a way of running migrations asynchronously during a Capistrano deployment, in order to not lock up the deploy process too much. Which does raise the question why that‚Äôs even an issue. It‚Äôs mentioned that there are some migrations which insert a lot of data, but generally, migrations are not really designed for that. I‚Äôm sure someone‚Äôs already told you that, however.
&gt;All that said, it‚Äôs time to recognize that Ruby is a legacy language at this point. Agreed . It is not dying as in close to death. Its more like a 35+ year old couple that can't have kids and won't adopt. Still lots of life in it but no ongoing future for the name. When I saw the last christmas release with its two headline experimental features being hailed as major release I realized as you did time to let go and move on &gt; The writing on the wall is so clear. Think: when is the last time somebody wrote a great new Ruby gem? I can‚Äôt even remember. 5-6 years ago there were amazing new gems coming out weekly. and github is littered with old projects no one wants to update anymore.
Some data take time to be updated and can be abstracted somewhere else so I did that to do it, that's an arguable topic but I'll use it anyhow and wanted to share it as well My sarcasm detector is malfunctioning on this thread because I'm very careful of what everyone says here to collect opinions and maybe improve my idea 
lol looks like we got some management material here bois.
At least that is gone now, right?
Right. Basically, your gem turns any migration into a background job so it will be run from your worker machine instead of the deployment process. I‚Äôd say it‚Äôs a clever hack on top of another hack (i.e. using migrations to insert data). Perhaps it would have been simpler to just turn `rake db:seed` into a job, optionally using something like seed-fu to make writing idempotent migrations a bit more palatable.
I had to learn quite a lot about the internal mechanism of ActiveRecord::Migration and that was pretty interesting indeed Now that you talk about rake db:seed if that's a better and more accepted approach, why not apply the same principle on it yes, maybe for a next gem then
Basically, Ruby is not Javascript, nor it needs to be like Javascript. 
I initially mapped the difference thinking I'd return both the key and value, then forgot about it halfway through. But yeah mapping it to true or just using a set would be better.
Matz is employed there, but his position is symbolic. In something like 7+ years, Matz has never touched a single non-trivial Ruby codebase within Heroku. (My information is a little out of date now, but I know that this was true for at least 5 years from first-hand information, and I highly doubt anything has changed.) This was always a little disappointing to me because many of the major improvements and features coming out of Python (admittedly, observing from the outside) seemed to be at least partly inspired by Guido having joined Dropbox and presumably having seen what working in a large Python codebase was actually like. For example, it's not necessarily obvious that type annotations and type static analysis that conveys similar advantages to a compiler (e.g., MyPy) are of critical importance even to a dynamic language, but you start to realize that they are as soon as you're in a large codebase where whatever guarantees that your test suite is providing are no longer enough, and Python now has both these features. Matz has been talking about them for 5 years now, but there's been no movement during that time. I've always suspected that if Matz or any of Ruby's major decision makers was actually forced to work in a large Ruby codebase for a little while, they'd realize the language's major deficiencies very quickly and start pushing for the improvements that it really needs. Unfortunately, as mentioned elsewhere in this thread, they're C programmers and not Ruby programmers, so no such luck so far.
Why would I use the security cops over something like Brakeman?
I suspect this to be a problem as well. 
I would argue that people switched to Elixir because of its runtime the other features were just icing on top of that cake. 
This is my first article after a 6-month break, I hope you will find it useful. It is good to back!
That's why I started this post. I suggested "consortium" and wanna see people's suggestion.
DHH Doesn't think it is a problem. [https://twitter.com/dhh/status/1034481397430251521](https://twitter.com/dhh/status/1034481397430251521)
&gt;stupidly May be not stupid, just stubborn. Which I guess is the same as a lot of others.
\&gt;Anyway I would not say it‚Äôs the end of it. We are just hitting the end of development with no tech giant being invested too much in Ruby.The closest you get is with Stripe and perhaps Shopify. The driving force behind gargantuan projects will always be a use case and that can clearly be seen in Stripe‚Äôs effort on sorbet. &amp;#x200B; Nicely put. We are hitting the end curve of what is possible for languages improvement by volunteer based community without significant resources backing. Not too bad if you think of it that way. 
&gt;balancing the old (stability) and the new (break-through innovation). I have been wondering if Backward compatibility is holding Ruby back in some cases. And I wonder if it is possible to use JIT to as an incentive to remove any old code. Example JIT would not support certain features, and then one version later the feature would give warning in mainline VM, before it is finally being depreciated. 
Welcome back!
Try to run benchmark in Ruby 2.6. It seems that Hash creation has been optimized and now Hash is the fastest.
Thank you, I will check this
Just for the record, both `dry-rb` (and `rom-rb` too, FWIW) are heading towards more concurrent code in your Ruby apps, so it's pretty much related to your last point. That's why we've embraced `concurrent-ruby` project extensively, that's why we promote reduction of mutable state and focusing more on simple data processing (which *can* be implemented quite beautifuly with a blend of OO &amp; FP).
I think many existing Ruby shops are too invested in Ruby to rewrite everything. So perhaps you're talking about new companies? I'm betting many of them still choose Ruby. Yes it's a nichy language but it still has a robust employment market, something I can't say about Elixir.
I tried today to incorporate your solution into an AWS Ruby lambda function. It also required the use of libruby.so.2.5 in the lib folder, but still I can't seem to get it working. This is what I get now: { "errorMessage": "Error loading the 'postgresql' Active Record adapter. Missing a gem it depends on? incompatible library version - /opt/ruby/2.5.0/gems/pg-1.1.3/lib/pg\_ext.so", "errorType": "Function&lt;LoadError&gt;", "stackTrace": \[ ...\] } I tried using ruby 2.5.0, 2.5.3, reinstalling all the gems, running gem pristine pg --version 1.13, but nothing seems to be working and I am unable to connect to the database using ActiveRecord::Base.establish\_connection. I am running out of ideas :( &amp;#x200B; Any thoughts on this would be much appreciated. Thank you.
oh boi
After installing the gem, I tried to run the example code given in the readme, but I get this error: `/System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:127:in \require': cannot load such file -- tensor_stream/graph_serializers/pbtext (LoadError)\`` Any ideas what I'm doing wrong?
That's odd, not able to replicate that, is it possible the gem did not install completely hence the missing file? Would uninstalling and reinstall the gem fix it?
&gt;ActiveRecord::Base.establish\_connection I guess that in order to use ActiveRecord you would have to include that gem along with all its dependencies. I haven't tried it yet but I think you really don't need to. Are you requiring the activerecord gem? I'm using PG.connect to open the connection to the database. You can see the docs here [https://www.rubydoc.info/gems/pg/PG#connect-class\_method](https://www.rubydoc.info/gems/pg/PG#connect-class_method). I defined a helper method in [https://github.com/mphsi/ruby\_lambda\_pg\_layer/blob/master/ruby/lib/database\_connection.rb](https://github.com/mphsi/ruby_lambda_pg_layer/blob/master/ruby/lib/database_connection.rb) so I can call it and save the connection in variable. Then in my lambda function I can query the database this way: `result_set = connection.exec(%{select * from table_name}).map{ |row| row }.first` I'm curious about why you also had to require the libruby.so.2.5 library
Unfortunately sad but true. Unless something changes and Ruby gets out of the loop of I am a framework language it will continue to decline and after some time die :(
Ok then why not play around and try Python. For that reason?
Your post shows a lot of wrong assumptions; however had, on the general notion I can not necessarily disagree on all points. There is some inertia indeed. It is, however had, totally RUBBISH to assume or claim this is due to matz or the core team alone. Let me give you specific examples: - You cite this or that issue here and there, and "no need movement" in it. Well, many of these proposals and suggestions come with disadvantages. Take the proposal to extend case/when with pattern matching but also others. Matz and others gave examples where and how the proposal should be improved. ADDITIONALLY you can make your case and suggest this for discussion in any of the ~12 dev meetings per year. So what is your excuse to not GO AND INVEST TIME TO PUSH FEATURES YOU WANT TO SEE FORWARD? Not all features come for "free". Many proposals add shitty syntax for example. Why should it be TO THE BURDEN of matz or the ruby dev team alone to make use of INCOMPLETE or flawed suggestions to, in their team, "improve upon"? They have all the work, all the responsibility, and people don't even have proper commitment to make their case stronger. &gt; Let's take a look into composition feature in bugtracker. The issue was created more than &gt; 6 years ago. It took six years (!!!) to introduce such basic functionality to &gt; "wannabe programmer-friendly" language. First off - if nobody argues in favour of an issue for a long time, it won't be added much at all since nobody reasons in favour of it. The dev-meeting has been introduced perhaps ~2 years ago or so, so people have a more realistic time frame of how/if changes are to be made. Then about the "basic functionality" that you claim. I do NOT think that yield_self/then is basic at all. I find it both complex and unnecessary. The crappy name yield_self is a dead give-away that this shouldn't be part of ruby; "then" is a better name because it is shorter, but it is also non-descript. Best would have been to flat out reject it. And actually, I think many other suggestions should have been rejected altogether. If it were up to me I'd throw the whole "functional" crowd out of the window due to being so incompetent when it comes to elegant code alone. But ruby is not my language so I can not do anything other than point out where there are shortcomings. So when you claim it is "basic functionality" - nope, I think it not basic at all. I think it is pretty bad. It's not as bad as the other proposals like .: but still. &gt; Many features require Matz to accept them. And Matz said (I heard it at least &gt; once on a conference) that he is not a ruby programmer but C programmer &gt; since mostly he works on ruby itself. I watched almost all the available matz conferences in the last ~10 years or so, at the least the major ones when he is a keynote speaker. And your quote is ABSOLUTELY WRONG. Matz uses both C and Ruby. Of course he writes a lot more C than he does write ruby but he uses ruby too. And he designed ruby from the get go. You can like that or not but it is a fact. When you write "I heard him say that" - nope, you did not hear him say that he does not use ruby. But if you want to, I ask you: please bring a video URL link + time where he said that he does not use ruby. I could be wrong, so this is your possibility to reinforce your claim. It is true that the core team writes a lot of code in C so naturally they will use C more than ruby. But they don't write FOR C - they write for ruby and use IN ruby. Ruby is a language but it also includes a philosophy and specific ideas, e. g. the ideas that come with the particular implementation at hand. I assume you did not read this old interview: https://www.artima.com/intv/ruby.html If people were only to read that ... that alone would dispel a lot of misconceptions that they may have. Do also note that it is not "just" ruby that necessarily struggles. For example, this google trend: https://trends.google.com/trends/explore?date=today%205-y&amp;q=Ruby%20-%20Programming%20language,Perl%20-%20Programming%20language,PHP%20-%20Programming%20language,Python%20-%20Programming%20language,JavaScript%20-%20Programming%20language That graph shows that ALL "scripting" languages lost in the last, well perhaps 2 years; python is about the same now if you compare it to 2 years ago; ruby, perl, php AND javascript (!) show a downwards trend. The google trend is not saying that much but what we can see is that all "scripting" languages struggle right now to some extent. Of course python is sitting on top of the foodchain here right now so it is the current king. The others have to think about how more people should use these languages - to this part I agree. &gt; So, basically, the person who is 100% responsible for language design &gt; doesn't really work with the language itself. Does it sound right to &gt; you? And he is still just one person. Please do not write this shitty FUD. As to the design process in itself - I think it is a good thing that someone clever is in charge of a language. I'd actually prefer if matz would be more conservative and reject most recent proposals. :P This depends a lot on WHO is making the suggestion, and even more importantly, the content. For example, sawa in general makes very good proposals; jeremy evans reasons very well in his proposals too; and so on, and so forth. I don't like the "functional crowd" at all but if you read the above interview, you know that ruby is not solely an OOP language. It has it as main focus but ruby is multi-paradigm. I don't like the functional crowd but it makes sense that ruby supports different philosophies too, if people want to use it (and if these are real suggestions - some suggestions seem to be just trollollollings). &gt; For instance, let's take a look into #yield_self that many people were waiting for. Many people? Who? The half dozen on the bug tracker? I can easily give you half dozen there too who were against it. So these "metrics" are irrelevant. It also is completely stupid from you to assume that because xyz want something it SHOULD be added. There are numerous reasons as to why something should NOT make it into a language - and ultimately, you have to convince the main designer of ruby about the benefits of your suggestion. There is no way to bypass any of this, so I reject your whole premise here altogether. And I mean this even when I say that I do not always agree with matz' decision either; I just think your proposed "alternative" is a total and utter joke. &gt; And why did it take so long to introduce it? Let's revert this decision and remove it. Nobody who really uses ruby needed this functionality really. The functional crowd is not really existing. Why? Because they would use e. g. haskell anyway or any such other language. I know these people don't use ruby because they write totally non-idomatic code to begin with. I could even give examples as names here on reddit but I think it may be better to not give names as to who is doing things "wrong". And when I write "wrong", again - the ultimate authority is not my style guide; neither rubocop. The ultimate authority is the ruby parser - what it accepts and what it rejects. &gt; Mostly, because Matz couldn't decide what naming ruby should adopt Giving things proper names is hard. You are talking big but don't come up with a good name yourself. I don't see you making comments on the bug tracker either, so perhaps it may be better for you to, rather than write such strange statements here to ACTUALLY GET INVOLVED rather than sit on the fence, as part of a peanut gallery? Getting involved is not so easy, I get this; it takes time and effort. &gt; Two years ago people started to write something like "I don't care &gt; about naming, just introduce it already, please". There are usually two steps from how I see something: - approval/rejection of an IDEA/FUNCTIONALITY - naming this idea as an expression VIA SYNTAX Often the first step is somewhat simple but giving a good name and a good syntax is VERY, very hard. This has many reasons, also the fact that we are limited to ASCII. The core of ruby is super-elegant, concise, expressive. Many other parts of ruby, in particular in the last ~3 years, aren't that elegant. However had, it also is rubbish to assume that EITHER THE ADDITION OF THESE, or the "slowness of evolution", would lead to many people not using ruby. I have a much simpler explanation - the competition became harder and there are more alternatives these days. You can see this if you compare javascript to PHP - php is losing even more share than ruby. So why isn't that a topic for you?
[CONTINUED - reddit annoys me claiming that what I write is too long. Quality is long, I can not help it.] &gt; In the end, Matz chose yield_self and now in 2.6 #then alias &gt; was introduced because name yield_self sucks. #then is indeed better but the whole thing is unnecessary. The functional crowd is just bored and suggests totally rubbish proposals. &gt; At this rate jokes "ruby is dead" are gonna be less and less of &gt; a joke. Ruby is in stagnation. Ok - please enlighten us here. A faster evolution will have only benefits, no drawbacks, and lead to an influx of a gazillion of people .... HOW EXACTLY? We want to hear your crystal ball working. Fence sitters have it easy - they sit on the sideline, make general comments and essentially do nothing productive other than just making general comments. My first suggestion to you this is - GO AND GET INVOLVED, at the least on the bugtracker; even better if you know C (which is one bottleneck here by the way - people who know only ruby but no C will admittedly have a much harder time. It would be nice if we could modify all of ruby in ruby, without any speed penalty, but let's face it - C is the king of programming languages, even if Java is ranked above C). &gt; I think we need some Ruby Consortium that will include some &gt; people with some authority in ruby community First, please make real suggestions. We waste time here. &gt; (for example, Bozhidar Batsov and Brendon Weiss) Second, I would suggest to you to stop writing in the name of others. I have not heard Batsov nor Weiss who want to replace matz. What we hear is Nondv who wants to form a committe but does not list himself as part of that committe. &gt; and they can take some design decisions off Matz' shoulders. &gt; Just via voting. Total joke. Rejected. &gt; Or maybe I am wrong and everything is as it is supposed to be? Alright - I rejected most of your claims, but it is not that I necessarily disagree with all parts as such. I reject the part that you need a committe to want to bypass matz - having matz is awesome. Having him motivated is important too - look at guido throwing in the towel when it came to python not some time ago. While admittedly the proposal for adding := to python was rubbish, guido giving up as a consequence because of trolls is much, much worse. Don't let the trolls win. As for "decline", or "stagnation", well it depends. It depends a lot on what you measure, how you measure ... do you measure github? I am very active when it comes to ruby, but I am not active at this Microsoft site. Not everyone wants to use ruby; some are happy using e. g. Javascript or Go. Python is the king right now from among the "scripting" languages and competing with python is not easy. Ruby is the more elegant and better language, despite the jokes coming from the functional crowd, but python is, in some ways, while awkward, also concise and elegant. Python is a strange language but it is acceptable; and in some ways it is a simpler language than ruby (ruby can be quite complex in some ways). Ruby also has some problems. I think documentation is still only ... average or so. We may have to move past rdoc, yard etc... and come up with something that is BETTER, while RETAINING all that is good in rdoc/yard. This is not easy. Often we may have a third replacement that does not include all awesome features. People also need to do more AWESOME stuff in ruby. I write ruby just about daily and it solves problems I have, but I happily admit that most of my projects are utterly boring to other people. I can't help that. I am not a hype machine like rails, which is actually one thing that rails did very well - it generated a lot of interest. Ruby also has to do more to get people interested in ruby. At universities here, it is about 5x as likely to see a python course rather than a ruby course. In fact, the only course I found was one related to ... rails. Yikes. In fairness, perl is also not really taught at universities; neither PHP. Only python actually has a few courses here and I think this will increase rather than decrease.
I don't think you realize that tweet is highly ironic. (Not only the emoji provides a hint, but) If you read the small letters you'll see that's a reply-by-mocking to [a post](https://news.ycombinator.com/item?id=17856314&amp;p=2) on Hacker News. 
&gt; They don't feel the pain of so many primitive problems with the language. I got downvoted &gt; to hell the last time I said that, so we'll see... Because it is not true. Take proposals such as not requiring 'pp'; or the did-you-mean gem. Yes, they came from suggestions outside of the core team but both was accepted. And I could give many more examples here. The point is that what you claim is SIMPLY NOT CORRECT. You claim that "good proposals" are not accepted because the core team does not use ruby (which is, by the way, mostly wrong; it depends a lot on the individual at hand. You are aware that in order to modify the core of ruby, you DO have to use C, right? It's not an ideal situation, but this is simply how things are right now.) &gt; I think the other items you list are all correct, No, they are not; I don't even think you read what he wrote. Otherwise, why should a committe be formed??? &gt; No semantic versioning, which means that the community gets excited &gt; about "2.6!" and triumphant posts are written. But in actuality, it's not a &gt; major release. It is a fairly large release on the one hand; and it is not a breaking-changes release on the other hand. I think this is good. People complain about changes that break things. Take the proposal to remove @@class variables. I myself am in favour of eliminating this but there are others who use it, and don't want to see it gone. SO what to do now? Either way you go about it someone will not like it. So the least friction path is to retain them for now (and probably in the future). To claim that this is the wrong way AND THEN GO AND WANT TO LECTURE OTHERS ABOUT YOUR ONLY TRUE WAY, is simply wrong. I don't like @@ but the thing is ... I don't use them either. I keep my code base clean and consistent with what I use (when we keep the time in mind when I wrote that code, obviously old code that I wrote is not as good as code I tend to write these days). &gt; Semantic versioning would help keep the inflated tone in check. Bullshit. The versioning is hugely arbitrarily anyway. &gt; in the form of posts about micro-improvements here and there in 2.6. See - ruby got faster compared to 2.0. Nobody can deny this. You want more improvements? Well, SOMEONE HAS TO GO AND ADD THEM. Fence sitters annoy the hell out of me. It took a long time for the JIT to go about being implemented. It's not trivial. You don't expect people to be superhumans and add things over night? &gt; But the huge gap in logic is that other changes might have hurt performance, &gt; and cancels out these localized gains. Because these are orthogonal design goals. You want a super fast language? Go use C. It's fast. The syntax is not as good and clean as in ruby but it will be faster. You want an elegant language with a nice syntax? Go use Ruby. It also inspired Crystal and Elixir, syntax-wise, to some extent. Actually using crystal may be an option since it is somewhere between C and Ruby, with speed closer to C than Ruby. &gt; And in real world testing that's being done with 2.6, that seems to be &gt; exactly the case. I already reported that I feel that ruby got significantly faster. I can not relate to the benchmarks that claim that this is not the case. In fact, one of my projects for e. g. asking exam questions, actually is significantly faster now. For me 2.6 works very well. I have no idea how people do benchmarks and come up with a slower ruby (???) but my bet is that these people test fake code bases rather than real ones. And rails will become faster too eventually - why do you fence sitters sit on the fence, complain about things, not do anything... are you even using ruby altogether? Because the way you word these things make me think that you don't even use ruby altogether. At the least SOME from within the functional crowd do use ruby, even in very strange ugly ways. &gt; No planned roadmap or open process like Python's PEPs, Thankfully there are no PEPs in ruby. I'd hate that. The PEPs in python are like from a military school; so overly long and boring to read. No thanks - I'd rather read suggestions that are, in the end, fairly simple. &gt; Improvements come in hodge-podge when someone is persuasive &gt; enough in the firehose of comments that is the Ruby issue tracker. Aside from your propaganda-words here, where is the problem? People can reason in favour or against a suggestion. That works wondefully well. You sound like someone who proposed something awful, then got pissed when people shot down your rubbish idea. Man up - and write better proposals. &gt; New features and hacks get tacked on, and old ones aren't culled. There are not so many new features really; I mean you yourself wrote that, so now you complain about new features ... hmm. And old ones being "culled" - aside from this stupid word (you cull animals right? Are you like from a state with lots of cows? Texas?), again - removing functionality isn't always great, in particular when it affects people who depend/use it. This is simply a trade-off that a language designer has to decide upon. Ultimately perhaps ruby may not be for you? I used to be confused about haskell not wanting everyone to use haskell, but boy - when I read things like this, perhaps it's actually better to not have every average joe and his grandma use ruby simply to exclude people who have AWFUL IDEAS or massive misconceptions. If the python PEPs are better, why don't you actually stay with python? &gt; It's not a very professional outfit, all told. You mean building artificial barriers around the process? No thank you. I like the way things are. &gt; But it's a friendly and fun one. I have no idea if it is, but ruby as a language is a very, very good language. &gt; I don't begrudge Matz and his core group. Somehow your words above state otherwise. &gt; The important notes are in Japanese, and it's a cool project that he &gt; likes for his personal reasons Please don't write FUD like this. If it were only personal, why would he give talks and jet around the world? He would not have to invest any of his personal time into getting to talk to other people. I think matz simply likes talking to other people. It fits the philosophy of ruby and what he wrote too. There are more aspects to ruby. Of course the primary one is that it is a programming language; and languages should solve problems that people may have. The other part is the philosophy though - this is actually what makes ruby totally different to python. It's the biggest difference altogether. Python follows another philosophy. &gt; But the insular (and really, Japanese) style around the core team isn't aimed &gt; at producing something on the level of a Rust, Golang, Kotlin, Swift, Python... Rust? You mean an ugly language added by a company that is unable to find competent C++ hackers and touts it as a language that will remove all of C and C++? Golang? You mean a language created by an evil corporation that profits from people's data? Kotlin? Well, Kotlin is not bad; but its use case was to make Java prettier. In some ways Kotlin is somewhat related to the "scripting" family spirit. I don't see where Kotlin is run better than Ruby. Or where Kotlin is used by more people? Swift? Apple's effort to get rid of Objective C. It achieves that goal but swift is kind of ... meh. Better than Obj C, worse than Ruby and Python. Python? Actually that is the only real contender that I agree with from the END RESULT in popularity, NOT from the processes. I don't like the python processes, but we all agree that python is presently the king of the "scripting" family languages. And others can learn from it - but I am sure we two would heartily disagree with as to why python is popular. I massively doubt that python PEPs are the reason why python is so popular. If perl were to have these PEPs, would you assume perl would be used by more people? Of course not. Look at perl 5 versus perl 6. 
&gt; I'm not very familiar with the Swift and Go ecosystems, but in my opinion, &gt; PEPs have turned Python into an abomination of design-by-committee Yup, fully agreed. It reminds me of over-bureaucracy. C++ has it even harder. Even Bjarne had to admit/mention this. Cthulhu took over the C++ committee. People think there are other reasons like establishing complexity so you have to hire people who tell you how to sort that mess - but IMO, they are just worshipping minions of Cthulhu. Eventually they invoke Yog-Sothoth because nobody with a sane mind undertands what the committee is doing. Although I also have to admit that not all that was added into C++ was bad - some was ok, compared to e. g. the state of C++ in 2000 or so. &gt; I don't agree with Matz and the core dev team 100% of the time, or even the &gt; majority of the time, but even so I think they've done a pretty decent job of &gt; advancing the language with some substantial features (string encodings, &gt; YARV, keyword arguments, incremental GC, Ruby-JIT) without turning into &gt; yes-men for whatever proposal seems semi-popular on the mailing lists that &gt; month. Agree too. Not with all your comments e. g. I disagree with keyword arguments, see what jeremy evans wrote here in regards to bugs on the bug tracker - and to that I agree. But, if we do not focus on the minor parts, yup, I agree with you here.
&gt; subsequent rejection of US-American social justice &gt; pressure to adopt a Coc. Huh? Ruby has a CoC. Of course it is totally useless but still. I don't think the existance of any CoC or not has any real impact on the popularity, though. I agree to your point that one should see that ruby is what it is (at the time of using it e. g. as it is presented now). &gt; I predict that in a few years, Ruby will still be mostly the same, &gt; and be in use mostly as a better Perl, which it's great at. It's good if ruby stays the same. I want it to stay the same as it is. I use it since 2004 or so and it is still a great language. &gt; And the Ruby app developers and professional programmers will mostly &gt; move on to Elixir/Phoenix, Python/Django, Kotlin, and Rust. (After 10 &gt; years of Ruby, that's what I'm doing.) Wait - you claim you use all these languages? Every day? Other than that, I reject your claim that everyone will "move on". I did not "move on" but I had indeed other use cases. People who only got into ruby because of rails, evidently will just keep on flocking to whatever they want to use. They like the hype. It's a bit like an addiction. Meanwhile the boring old folks will keep on using ruby and be super happy. People are so eager to keep on claiming how things die the moment hype dwindles down. :)
Hey, shevegen, just a quick heads-up: **existance** is actually spelled **existence**. You can remember it by **ends with -ence**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
&gt; And am currently learning rust to build some tools handling and &gt; processing events; both in a much simpler, and much faster way. Faster possibly. Simpler? I highly doubt your claim that Rust is simpler than Ruby. :) What is coming next - a claim that C++ is simpler than Ruby? 
This only covers a part, e. g. people who use a language because of some existing needs (e. g. in your case of a company that already uses ruby a lot). But the world is bigger than just companies. There are people too. And they have to, or may, decide on languages to use. This is one reason why python is very popular; and once people e. g. use python, they often don't look to use any other language; not ruby, not php, not perl etc... It is a myth to assume that people know and use 100 different languages. It follows based from this awful "use the right tool for the job" mantra which says NOTHING at all.
Exactly!
You list orthogonal goals here. You claim to know matz and watched his presentations. I don't think you ever did. Why? Because if you would, YOU KNOW KNOW WHY HE CHOSE TO NOT BREAK BACKWARDS COMPATIBILITY towards ruby 3.0. Hint: he mentioned this several times. It has to do with ruby 1.8.x to ruby 1.9.x
You claim that a "consortium", whatever that even is, would do things "better". In reality what I read is that you want to replace matz. The thing is this - ruby comes with a licence that permits you to easily fork it, build your awesome committee of the people you mentioned (and hopefully they all agreed with you prior to you naming them, because it would be very unfair if you would just randomly cite people without asking them first) - and then this super-committee can do EVERYTHING better than the current core team. Linus always said "talk is cheap, show me the code". Perhaps it is time for you to show that committee? And, by the way - if you wonder why I am so sceptical, I really doubt things work that way. Your whole assumption lies on the basis that the whole process will automatically be better if any random committee is suddenly put in charge. But for what? If you have a specific issue that you wish to see discussed, added etc... then make your case; reason for it; ideally show code too. And most importantly BE PREPARED TO ANSWER TO THOSE WHO DO NOT LIKE YOUR SUGGESTION. Because in many suggestions, not all, but many, there will be people who will be affected by it, just as jrochkind wrote.
At this point I claim that Nondv is not even using ruby.
Well said.
I've just skimmed the README.md and I am completely turn off by the messy style of source code examples. Nowadays many platforms provide auto formatters, style guides on how to write a good, readable code. Ruby has no official guide per-se, but Bozhidar Batsov and his guide provided a great value for the community. Code in the examples here can't even follow consistent indentation, variable names are horrible and everything in general makes me want to puke. I am really sorry for being harsh, but the README is the landing page for the product and its sole marketing channel. If you can't attract developers there, your project is going nowhere. If you believe that all this does not matter, because you are doing awesome work, then sorry, but you are totally wrong.
There are a few problems with what you write: 1) Matz can overview the general process of ruby as-is, including changes to how it is used. This is one reason and goal for mruby, for example. Mruby has to remain lean and focus on speed by default. MRI has a bit more freedom here, and more people use MRI. Ideally mruby and MRI could be merged to offer both (and people could sort of "select" what variant of ruby to use; then people could still use MRI of course ... in practice there would probably not be a huge gain, but I think it would be better if mruby and MRI would be one unified codebase ideally.) 2) It assumes that matz never writes any ruby code. I am pretty sure that this is wrong. He uses debian so I am sure he does write ruby code to get things done too. 
So the reason that rich_text is stored in a separate table, so it's possible to link uploaded AS attachments to it? 
Why and how exactly? First, I think the claim that matz does not use ruby is wrong. But even well aside from that, I think it is totally wrong to assume that suggestions are rejected because matz were not to use ruby "enough"; many suggestions come with trade offs. 
I think callcc is mostly dead by now. I am sure we may see a removal of it eventually - removal doesn't have a huge priority though.
$SAFE is gone isn't it?
I did not downvote or upvote you think I think your comment makes sense, from your perspective. I myself would never use e. g. Node or Go because of job requirements. I remember I had a good offer for PHP a few years ago and I happily rejected it because I just hate PHP too much to want to use it. I did not use ruby because of rails, though, so rails does not factor into me using ruby at all whatsoever. I am super-happy with ruby too after all the years - only a few suggestions made in the last three years by the functional crowd should have been flat out rejected; and not all syntax changes were good, in the least 2-3 years or so IMO.
Do people take DHH seriously? I have nothing against him but rails has always been hype-promoted way too much for me. Actually I did buy a rails book once and used it for a while, then got totally bored by it. It's not solely rails fault alone; the book was also quite terrible, and I think the larger issue is that web-dev is totally broken on every aspect (but too important too neglect, I always said that).
A very good comment from you - I completely agree. Very nice said. &gt; Personally I think Ruby has gone far enough. And I don't know yet what's &gt; the hip thing going to be in 2025, but probably it's not going to be &gt; functional - or not the way we know it today. Instead of being fashionable &gt; all the time, just be a good language. I agree too, to 99%. I think the thing is that ruby could still improve in some areas; documentation being one; getting people to know ruby too AS AN ALTERNATIVE to python (yes, yes, a bit hard right now but you can't let the snake roll over all the other scripting languages as it does right now PYTHONS ARE NOT CUDDLY at the least not in a loving non-choking way). Some other improvements too; take require 'pp' not being necessary. That could have easily been added years ago. And so on... But by and large I concur.
Ah, the functional crowd is striking again. class Proc def &lt;&lt;(other) proc { |*args| self.call(other.call(*args)) } end end Please, you folks need to use another language. Try haskell or so. Don't ruin ruby with this crap. Matz even added this and you still express how unhappy you are. This is another reason why the functional crowd should not be using ruby. Please use another language. Please please please. I never understood the haskell folks before, but now I do - they are just careful that people don't ruin haskell. So now I am careful of people to not ruin ruby.
&gt; Personally I have spent some considerable amount of &gt; time in haskell. I know why its good, and why it's not &gt; so good. Mainly it's just different. See, this is fine - but people should use haskell for when they really want functional programming from the get go. Ruby is multi-paradigm, yes, but the main focus is still OOP really. &gt; There is a paradigm shift going on in terms of &gt; popularity, and Ruby is on the wrong side of &gt; the fence. Well ... python is popular and it uses OOP too. At the least it claims. So I doubt your claim here. &gt; Quite a while back we adopted the { a: 1} hash syntax. I &gt; believe that was a mistake, now, half newcomers don't &gt; understand the difference between a hash and an objec I mostly hate all syntax changes, but I like the notation there. I agree with you that the old variant is easier, simpler and more consistent. People just keep on using =&gt; and internally that is the default syntax. But there is ONE simple advantage for a: :foobar which is good - which is that it is much shorter than the other variant. There are even proposals to not require "," which would be nice. People are lazy. That can be useful. I do however had agree that syntax changes can always be a trade off. That is why people have to keep their own code bases sane and consistent. Nobody prevents you from just using =&gt; consistently. &gt; The way we are going Ruby might become a mish-mash &gt; where it would be hard to explain the difference between &gt; a method and a function. There is no real difference. Less so in ruby. We have UnboundMethod too, so really - what is the difference? 
I think this may be correct to some extent. Elixir made Erlang usable due to a sane syntax. People also love elixir pipes - you can see them with those who suggest it to add it into ruby, while not understanding why 1:1 syntax translation does not work as-is. But erlang is pretty cool. I would like a language such as a mix of ruby, elixir, a bit of Io, and optionally speed like C (so like crystal but where we can decide on our own which variant to use, e. g. with types or without etc... - crystal code is worse than ruby IMO).
I don't think people will necessarily disagree with you - just that the alternative "logic" can not apply either. Or do you think that any random committee formed will be better because "there are 100 people designing the language"? We have that with C++ and it is a giant mess.
PHP has been declining in the last years though, largely due to javascript: https://trends.google.com/trends/explore?date=today%205-y&amp;q=Ruby%20-%20Programming%20language,Perl%20-%20Programming%20language,PHP%20-%20Programming%20language,Python%20-%20Programming%20language,JavaScript%20-%20Programming%20language It started higher than ruby, yes, higher point in a peak, but it also actually lost more than ruby did, yet people barely talk about this.
&gt; I have been wondering if Backward compatibility is holding Ruby back in some cases. Matz himself said publicly he doesn't want another Python 3 schism. &amp;#x200B; &gt; use JIT to as an incentive to remove any old code JIT development is important enough not to be interfered with by artificial, forced deprecations. We should go for the positive side, and a new concurrency model is badly needed: we ought to squeeze out more from CPU cores waiting idle for IO. Supporting immutability, better coroutine primitives a la golang, novel concurrency management a la Python trio (inspiration from /u/bemend above). Learning from the good ideas and avoid pitfalls experienced by others. 
&gt; And are these problems still relevant to people ?‚Äù That depends on your use case. My use cases are solved with ruby just fine.
&gt; BTW, in this case having many utility-features in language (like said &gt; compositions and then) is a good idea (unless they break everything &gt; or making people write bad code). This sounds nice in paper but it adds cost. It adds complexity; time spent; and even more importantly, WHAT do people really use this for? Solving what and where? Do we see new gems as a consequence that really solve an existing problem, other than the author is just playing around with it? Lots of people only want to play around rather than solve anything. I understand this but it also means that they have less time writing high quality + documented ruby code. I myself am currently wasting time refuting the various points made here .... I should write ruby code instead. 
No, thank you. These python PEPs are just terrible. Convoluted, super long, super boring, awful. Redmine is perfectly fine. It could be better, yes, but it's perfectly fine. &gt; they should remove that crap redmine, and move all the stuff on github. No, thank you. I am not active on that Microsoft shit site and I do not want to be forced to have an account there as a Microsoft worker drone. It is MUCH MUCH better if ruby remains as independent as that is possible. I understand that people need to work for a living, but your requirement for people to have to use ruby in order to contribute. Nah. Rejected.
&gt; So that is not going to happen anytime soon. And that is GOOD! I think you refer to normalperson mostly. I did not understand his opinion, until Microsoft greedily bulldozered over everyone, assimilated GitHub just so that they can have more control. It did not make any sense for me to continue to use a site that is operated by Microsoft. Not because I hate Microsoft, but simply because I would not have used GitHub back then if it were created and controlled by Microsoft - so I had no real reason to continue using it. Past that point I can also understand people like normalperson a LOT better (and RMS to some extent, even though he is too much of a hermit-preacher thingy). You give away control and freedom. And I really really really don't want that. Imagine if Poettering would replace Linus on the kernel. Do you think this would make the kernel better? The kernel would quickly become a part of systemd. We don't want this erosion of quality control to happen, no sorry.
The error does not seem to be related to the ActiveRecord gem, but to the PG one. Still. I'll give a try with PG connect and see what I end up with. Without the libruby.so.2.5 added, it kept complaining that: No such file or directory - /opt/ruby/2.5.0/gems/pg-1.1.3/lib/pg_ext.so even though printing the content from the /opt folder did display that file as present. 
&gt; Ruby has to overcome it's usage to the web and start making more &gt; developments regarding to AI and deep web. Wait a moment ... overcome it's usage to the web ... and making more developments regarding the deeb **web**. Hmmmmmmmmmmmmmmmmmmmmmmmm. :) I agree to many of your points by the way; I just find it funny that ruby has to overcome the web but use it more at the same time hehe. Focusing on the www is important, though - it's the biggest driving force IMO. Way bigger than AI. AI is just a big buzzword but the www is something that will remain since it impacts literally EVERYONE. And even more people will use the www in the future so there is no way around it. 
The examples are still readable though? Get off your high horse.
The Ruby community used to be the trendsetter. Even tho I don't work with Ruby on a daily basis anymore, I can easily learn new stuff. Express.js? Is a copy of Sinatra. Behavior Driven Development (RSpec)? Copied by Jasmine, Jest etc. Task runners like Rake? Was copied by Gulp. Ruby brought us GitHub, CI, CD, Cloud (Heroku). The non-corporate, open-source Ruby community changed the industry. Most people overlook these facts.
&gt; All that said, it‚Äôs time to recognize that Ruby is a legacy language at this point. I am always amused about such comments. :) I don't feel where it is "legacy". And how. &gt; And I say that as someone who codes only in Ruby I do too so perhaps we just have different opinions here. &gt; uses only Rails Ah - THERE is your problem. Now I understand. :) I think people who use rails never really use ruby. Rails code always felt totally alien to me. I don't even think it is real ruby code (of course it is "real" because it works, through the same ruby parser). &gt; It‚Äôs time for all of us to move on, unfortunately. LOL. :) Nope. But I have to be honest - I don't mind "losing" the rails people ultimately. While rails is not bad, I think it attracted people who should never have been there in the first place. People who use ruby because of ruby don't have anywhere near the same opinion for the most part - even though I admit that people switched languages, e. g. to Go. But that is for other reasons, most of which have to do with work, some with speed. &gt; and (stupidly) hasn‚Äôt expanded his skillset yet What is "stupid"? Do you feel inferior? I don't. &gt; The writing on the wall is so clear. It isn't to me. &gt; Think: when is the last time somebody wrote a great new Ruby gem? I do all the time! Of course most people won't think so because they have other use cases, I understand this. I mostly try to make my existing projects better rather than just randomly add new gems. High quality projects are more important than ad-hoc hacks that get abandoned quickly. &gt; 5-6 years ago there were amazing new gems coming out weekly. Which ones? I don't remember anyone. Those that come from rails are boring to no ends. I liked kimurai because I could download javascript-generated content which helps me a lot. I still think the www-world is pretty much a terrible mess. zedshaw once wrote that rails is a ghetto but I think the whole www is such a giant mess that it should be called a ghetto. No wonder people are depressed - they all come from the www world. My pity goes to them. &gt; It‚Äôs time for all of us to move on, unfortunately. Not really. :) But I have to admit, again - the rails people should probably move on, simply because they can be quite whiney. And the functional crowd also should move on - they want to turn ruby into some monster and abomination, for no real gain (and no, there IS no real gain - nobody coming from FP will use ruby when there are so many other "pure" FP languages out there).
&gt; My point is talented developers don‚Äôt seem to be working anymore in Ruby. I am talented - and I use ruby. Lots of others are talented and use ruby too. Some people have requirements where they must use any random language in order to meet a job requirement. &gt; Hence the lack of great new gems, blog posts, ideas etc - I see numerous great ideas and gems. Are you perhaps not looking? &gt; otherwise why has it all dried up? Dried up how exactly? To rails people perhaps. For others - not so much. Some have struggled with problems such as e. g. qt/kde becoming bigger and bigger, so language bindings lag behind - people have to write them in their spare time. This is not ideal. Ruby-gnome bindings work a bit better but there are few people. That has been the same in the last 15 years ago or so, by the way, so it's not as if this were totally new?
Big companies will use any language though. It's just not the same as comparing that to average joe who may be a developer. &gt; I would say the main issue with Ruby is its design That is by the philosophy - and that is great. &gt; JIT and guilds are nice but i cant think of an app that &gt; I would not use a different language because of &gt; Ruby's shortcomings What for, how and why? I don't see what "shortcomings" prevent you from using an application? If the app works, where is the problem exactly?
&gt; We are hitting the end curve of what is possible for languages improvement by volunteer based community without significant resources backing. You mean terrible languages such as Go, Rust and Dart? No thank you - I don't want corporations design such jokes. (Mozilla is a corporation too by the way; don't care about the legal mumbo jumbo; foundations are corporations too, just with a requirement to do a percentage of re-investment, at the benefit of paying fewer taxes.) &gt; Someday Crystal will fill that niche. Nope. Crystal is not Ruby. It's great that crystal exists but to assume that everyone will use crystal merely because it is faster (and not mention any drawbacks), is simply incorrect.
&gt; Its more like a 35+ year old couple that can't have kids and won't adopt. You mean the only true way to live is to have kids? All other styles are not valid? &gt; Still lots of life in it but no ongoing future for the name You mean a programming language "dies"? I agree that any language will change depending on the people that use it. I see C still going strong. How many of the creators are still alive? So how does your analogy apply to any programming language then? &gt; When I saw the last christmas release with its two headline &gt; experimental features being hailed as major release I realized as you did This is mind boggling. Are you clueless? Allow me to remind you: matz said that he does not want to have the 3.0 release be disruptive as the 1.8.x to, ultimately, 2.0. You can discuss pros or cons here BUT THIS WAS A DELIBERATELY DECISION. To then go ahead and assume that "ruby is dead", based on that decision, IS TOTALLY RUBBISH. What are you people doing here - are you all not using ruby and not reading stuff related to ruby? Not watching what matz says? And this has nothing to do whether I agree with it or not - I simply understand matz' opinion here. You write as if you do not even KNOW that decision ... &gt; time to let go and move on Not really. But best luck to your future ways. :) &gt; and github is littered with old projects no one wants to update anymore. Indeed. This is a general problem. It's a graveyard. I am not even there anymore; github uses a funny pacman ghost for people who suggested things. I found that sort of funny...
&gt; Additionally, the standard library is written in Crystal, making contribution &gt; very easy for the average dev. I did not upvote/downvote your comment. While I do not necessarily agree to the rest of your comment, I think that particular statement is very valid. It would be great if we could contribute to ruby via ruby code. That would lower the barrier quite a lot. Right now only competent C hackers can contribute to the core of ruby, which excludes many people. There is a lot of ruby code too, of course, but the major parts are just C.
Still don't think it should be part of Rails core. It should be a separate gem.
I agree. I am glad to see more people who like introspection. (I am not sure what retrospection is, but I feel in love with introspection when I used the Io language; Io is not hugely active anymore but I liked it; my biggest complaint was with its syntax ... I absolutely hate := too, both in Io and in Python ... ) &gt; Before I mostly adopt ruby (vs pyhton) (as a former &gt; embedded c developer) one choice for me was about &gt; the language long term orientation. Nice to see C hackers use ruby. Most use python, which means python gets simply more people who can contribute code, write code ... &gt; At that time I've heard things about Guido stating that &gt; he will decide what evolution the language will adopt.. &gt; I'd not hear something equivalent for ruby... Yeah, but guido also threw in the towel, which is bad. Matz is still motivated, at the least from what I can see. I think it can be super-frustrating. If I were in charge of any language, I'd reject so many proposals it wouldn't even be funny. So I'd rather not want to do that and try to focus on things that I like (and ignore the rest).
And by repetition alone this becomes true ... how exactly?
My major gripe with guild is that ... they make things more complicated. I have this with the whole lot altogether - fiber, threads, mutex, syncing ... then guild. It does not seem to become any simpler, ever. :( By the way, you are incorrect in one regard - you write that 3.0 would be a super-step forward including backwards incompatible change. This would contradict what matz said. This is not me having a preference, mind you; I am simply referring as to what matz said in this regard. He wants to avoid a situation like 1.8.x to 1.9.x to 2.0.
But we would have to add something new, which people would have to learn; and it is not super-simple ... So we end up with: https://xkcd.com/927/
&gt; And I wonder if it is possible to use JIT to as an incentive to remove any old code. While this may be possible in theory, I highly doubt that the JIT would ever be misused as you suggest. Why do I use the word misuse? Because matz is in charge of ruby. You can't leverage the JIT to bypass what matz suggests. As for new or changed functionality, well - one problem is that matz will want to keep ruby consistent. Either something is to be used; then it can be added. Or it is not to be used. Lots of things are already experimental and it is not sure if these will remain as-is. Even refinements are still experimental as far as I know.
You spoke to them? Can we confirm this? I want to know whether you asked them before naming them as part of your committee.
I do not necessarily disagree as such, hence why I did not upvote/downvote your comment. But one question: - Does Nondv speak for the Rubocop project?
How much is this a Ruby thing? I think companies are piling more and more requirements and don't like mentoring developers into their stack. They want you to have 5 years experience in anything and everything they happen to do. This is especially true in the brutal world of startups where employees come and go at a high speed - why should they invest? How many junior spring jobs or c++ jobs are out there? &amp;#x200B;
I think the other implementations lag behind or lost momentum. JRuby is one exception possibly but headius is very active, also on the mailing list. I don't want to talk for him, so I think this is best directed at him to answer rather than others make comments in this regard.
It's quite ok. I would make the tables stand out a bit more, perhaps with a thin border; and make the central width a bit longer, but these are mostly tiny cosmetic suggestions, less so on the content itself which I find ok. Perhaps in regards to openstruct being slower, you could add a short benchmark. On the ruby issue tracker I sometimes read that people avoid openstruct because it tends to be extremely slow, whereas Struct is not as slow.
Totally exaggerated, especially in the US. believe it or not my linkedin is showing me more ruby jobs in the US than PHP jobs (that's very different than Europe btw). I just don't see why a startup would prefer Java, Elixir or Django over Rails, the case for Rails is still strong.
That is not to say I don't condone learning other stacks or even switching to a new stack. I'm just saying everyone is saying what their gut feeling is, which is interesting in itself but it's not facts.
Most Ruby shops where I had an interview were mature and had growth pains. They needed senior devs with dual-triple-stack experience (e.g. Ruby+Elixir+JS combo; Ruby+GoLang+JS etc.). The ones that didn't require dual-triple stack devs asked me ridiculous questions. For example, they asked me to explain certain helpers, which are documented on RailsGuides. In my opinion, it's inefficient to memorize stuff what you can lookup in 10s with Dash. We in Europe have Blue Cards (similar to H1B). Juniors are competing with top devs from EE, South America, North Africa, Balkans who are all senior but are willing to work for a Junior salary. Sucks.
Confirm what? I said these are just examples out of my head. I don't even think that they'd even agree with me on the topic nor wanted to be in such group. I just wanted to add examples of people with "some authority". I failed, apparently. I even "merged" Brandon Weiss and Justin Weiss into the one person:b
At the _very least_ they should make the editor configurable. We use Basecamp at work and I don't like how little control you have over Trix even as a user.
&gt;By the way, you are incorrect in one regard - you write that 3.0 would be a super-step forward including backwards incompatible change. This would contradict what matz said. Sorry if I sounded misleading, I meant ruby 3 is an opportunity be a super-step forward, *in terms of timing*. I did not propose backwards incompatible change, on the contrary: * leveraging the Guild concept, create 2 Guilds (contexts) in runtime. * one Guild (call it 'hyde') basically has auto-scheduled coroutines, concurrency management primitives, no Treads, Fibers nor GVL. * the other Guild ('jekyll') retains the currently intended behaviour, that is support for Threads, Fibers and GVL. This allows for backwards compatibility with \~2.x code, C extensions etc. People could slowly and surely migrate their codebases from jekyll into hyde, or not migrate at all. There are communication primitives in the making (Channels) to provide communication between Guilds. (disclaimer: I just came out with this jekyll &amp; hyde metaphor to illustrate the idea :-) )
Question: I have been using the Scenic gem and it is great for maintaining views, but one of the tradeoffs to using Scenic, as opposed to creating and writing the view in a migration file, is that I have not been able to use string interpolation in the SQL view (since scenic creates a SQL file to be used for writing the view). I am going to try changing the file extension to .rb and then using a heredoc for the SQL view and see if that works, but I appreciate any input someone might have.
&gt;I just don't see why a startup would prefer Java, Elixir or Django over Rails, the case for Rails is still strong. I am not a fan but even I know the advantages of elixir over ruby. If you don't know the selling points of elixir you haven't read very much on it. 
12 years in C++; won't disagree with you one bit. The first thing any new C++ project has to decide is "which subset of which version of C++"; no sane language, Ruby included, wants to be within twelve time zones of that clusterfox. OTOH, look at Python: they have a BDFL exercising executive control and putting a (single) human face on the brand, while a core team manages the community and keeps things moving forward. If calamity struck and Guido got bus-factored, I'd look for the (small, focused) core team to be much more visible until there's consensus on a symbolic successor. We could do far worse.
Thanks for the feedback, the example originally came from a python tensorflow example and early on I wanted to make minimal changes to show how python sources can be ported easily hence the weird format. &amp;#x200B; Though my goals have changed and neglected to make some style changes which I will be fixing soon.
Agreed 100%. Why can't they package it as a separate gem? Same goes for ActiveStorage. I don't understand why they cram everything into a single codebase. 
First of all, thanks for your answers (even though sometimes you didn't actually provide any arguments but used the "you are wrong" technic). You made some great points. I will try to answer only important (in my perspective) parts of your question or we will end up arguing about things not related to what I tried to express in this post. &gt; https://www.artima.com/intv/ruby.html Thanks, this is really great. However, I don't see how it breaks my suggestion. I think I need to make a statement for you right here: I **do not** dislike Matz. Quite the opposite, I like where ruby is going. I just don't like the speed it's going with. &gt; As to the design process in itself - I think it is a good thing that someone clever is in charge of a language. I'd actually prefer if matz would be more conservative and reject most recent proposals. :P Well, in an ideal situation the group ("consortium") will have N brilliant people. 1 clever person vs N ones. I understand that forming this group is a really hard job (if even solvable) and I couldn't even provide proper examples. However, there're people much smarter than me who could give it a shot:) Mostly, I just wanted to see what people think and I am having a nice time reading the discussions. &gt; I can easily give you half dozen there too who were against it. Well, any feature has people who want it and people who hate it. So what? Decision should be made anyway. And why should main designer waste his time on minor feature like this when it may be done by the group of other people (not random people, btw). That is the point of my committee suggestion. &gt; functional crowd You are hating them in some of your answers. Could you elaborate on this? You didn't provide any examples or arguments against FP. Just hatred like "screw them". &gt; Often the first step is somewhat simple but giving a good name and a good syntax is VERY, very hard I said that. It's obvious. You just discovered America. And this lies on shoulders of one person (I might be wrong here, however). &gt; Giving things proper names is hard. You are talking big but don't come up with a good name yourself. I don't see you making comments on the bug tracker either, so perhaps it may be better for you to, rather than write such strange statements here to ACTUALLY GET INVOLVED rather than sit on the fence, as part of a peanut gallery? I believe there are much smarter people than me and even Matz. This is why I think it's a good idea to form a group of such people (as I said, it's not easy) and allow them to make at least some minor decisions. However, this is actually a valid point. I didn't really read bugtracker much in last couple of years. &gt; First, please make real suggestions. We waste time here. &gt; &gt; Total joke. Rejected. &gt; &gt; Alright - I rejected most of your claims Well, thanks for that:) It's kinda hard to quote your points so I will stop now. I think that many disagreements with me made on a wrong assumption that I don't like where ruby is going and that I want to replace Matz (or whoever is making decisions at the moment). It's not like that. I love ruby. I want it to stay great. But I think that the process of evolution would be much faster with said "consortium" without actually losing the quality (as you said yourself it depends on who is making decisions). Wouldn't you think that if we had two of Matz it would be better? Two heads better than one (at least, if they are clever). P.S. Obviously, I don't really speak english and my expressions are pretty limited. So, sorry for that:)
If you were genuinely interested in this project you would actually contribute by making a PR, given the trivial nature of the changes you propose, and explain your reasons for them in a constructive GitHub comment, instead of wasting your and our time writing toxic posts on Reddit.
Of course, unless it is used a LOT in a tight loop, that speed difference is miniscule. Use whatever works best for the developer, unless you have measured it in a specific use case and need to optimize.
I do believe the comment was constructive. I‚Äôve tried to explain the reasons for the criticism best I can. As you can see author partially explained the reasoning behind this format of examples, although I don‚Äôt believe basic errors like the inconsistent indentation were there in original examples. I am not at all interested in the project, however I would be more then happy if it succeed, simply because its Ruby. I am sure there are many less strict/direct ways to explain the impact of basic neglect, but I also believe such ways do not work most of the time. If someone ignored that in the first place he/she must believe its not important at all. And if that‚Äôs the case, indirect polite hints about the issue do not usually have any impact. 
&gt;You mean the only true way to live is to have kids? All other styles are not valid? oh look a fanboy is getting so upset he is confusing an analogy with real life. but ermm yeah the only true way to have the family name continue among living humans is to have kids or adopt. wow me with some other way. &gt;You mean a programming language "dies"? no longer used much or not thriving why yes. nothing is forever unless it adapts &gt;I see C still going strong. How many of the creators are still alive? So how does your analogy apply to any programming language then? here the poor fanboy is still lost as to the fact that an analogy is a...well an analogy. C is fine because c is more performant and used across a much wider spectrum than ruby .it therefore continues to attract a significant amount of next gen users where ruby isn't attracting many new users and many of those who did use it have moved on. Fact of life based on hard data. I love ruby. its been good to me but programmer happiness misses one thing. if you have to invest in another language when you need performance (particularly computational power) then achieving your goals makes you happy and having invested in that language it becomes more second nature to you and thus you get pretty happy using that language. At that point you can be mighty happy using things you at first thought would never dream you could be happy with - gasp even Javascript (okay ummm not entirely) and thats why most of the people who have moved on are not coming back just for programmer happiness. &gt;This is mind boggling. Are you clueless? &gt; &gt;Allow me to remind you: matz said that he does not want to have the 3.0 release be disruptive as the 1.8.x to, ultimately, 2.0. You can discuss pros or cons here BUT THIS WAS A DELIBERATELY DECISION. lol...thanks for demonstrating your own cluelessness. How does it being a deliberate decision mean anything? I am already on record that I wish they would do away with the whole contrived christmas day there must be a release tradition. I would have been happy to wait a few more months to see if JIT was useful but as long as you hold to that schedule and tradition then you live by the sword and you die by it. SInce you are the one truly clueless this whole thread exists because of a dissatisfaction with the last release **in terms of overall progress.** Its not entirely about the last release - not even close. the last release is a catalyst (go look the word up). Are you that clueless you can't see that its therefore a real issue in the community? or do fanboys just stick their head in the sand for a living? &gt;To then go ahead and assume that "ruby is dead", based on that decision, IS TOTALLY RUBBISH. well all you have really done in your post is demonstrate what a rubbish nitwit you are. I in fact stated that its not dead and like a relatively young 30 something couple but in your reading comprehension circuit glitches you missed basic english. You need reprogramming or a new motherboard. &gt;And this has nothing to do whether I agree with it or not - I simply understand matz' opinion here. You write as if you do not even KNOW that decision ... Yawn.... .no comprehension more than paper width depth. the last release is a catalyst and for some like me a wake up point NOT the entire issue. No one is saying everything was peachy with progress but now they are upset over the last release and that decision. Quite the opposite. They are saying its symptomatic (if you need to you can look that up too). &gt;Not really. But best luck to your future ways. :) As of now already present tense like most of the developing world. Will always love Ruby though and still use it for some small projects. Theres a glimmer of hope in crystal but just a glimmer. &gt;Indeed. This is a general problem. It's a graveyard. I am not even there anymore; nah I hardly ever run into the amount of dead projects in JS as I do in ruby. It might be because here so many options (admittedly JS is way over to the other extreme)
I don't understand -- Batsov created Rubocop.
I guess it depends on what kind of work you're doing. I can't afford to be a boring old folk - I need to stay relevant and produce apps more efficiently and with fewer bugs. Yeah, i use these daily: * Python --- data science, teaching and mentoring - it's where the demand is. * Elixir/Phoenix --- I do all new API and web app dev in these for my startup instead of Rails. Far nicer dev environment and less dev time I can measure in weeks. * Haskell --- Data import and backend tasks where a solid no-nils data model is great to have. * Kotlin / Rust / Go --- deciding which to use for CLI apps - evaluating.
My startup is using other languages where it can, by treating Ruby and Rails as legacy code: building interfaces using JSON and HTTP. Spreedly is a well known company with a huge Ruby investment which is doing all new development in Elixir.
Use the right tool for the job, 100%. ;-) Because my "job" is to deliver business value, not to deliver code. 
I'd like it if the Ruby team had to remove an old legacy feature for every new feature they introduce. :-) 
&gt; This book is the reference for the Ruby programming language. Can you explain this sentence? I admit I'm skeptical, because there's no support for it on that page. The documents look comprehensive, but who is their author? What makes this collection _the_ Ruby reference? If it's _the_ reference, why isn't it at an official URL, like [the Python reference is?](https://docs.python.org/3.7/reference/index.html)
&gt; The documents look comprehensive, but who is their author? The answer is there too: "Most of the reference content is taken directly from Ruby documentation and reorganized for easier reading. The core docs were augumented with some quotes from the Ruby website, and some missing content that is written specifically for the book." I should add here that most of the custom content I found out it is necessary to write (because it couldn't be found in official docs), I re-contribute back to official docs. &gt; What makes this collection _the_ Ruby reference? I believe that it is just the _only_ Ruby Reference currently existing (and corresponding to latest Ruby version, and covering the whole language). &gt; If it's the reference, why isn't it at an official URL, There is currently no "official" reference, for all I can judge (check yourself: https://www.ruby-lang.org/en/documentation/). TBH, my initial plan (when I finished the previous version for Ruby 2.5 ~ April 2018) was to propose this reference as the official one. Then I decided I'll polish it for a bit and wait for the next Ruby version (to check that my assumption that having it always actual is easy with chosen approach), and only then propose it to Ruby maintainers. Now I am on my way towards it. Hope this answers some of your doubts.
Python by chance won the academic world and gained massive usage from hundred of thousands of students (many of whom won't become professional developers), it has nothing to do with all the shiny features we are seeing lately. And in fact, if you aren't into data science but just a plain web developer, I'm not sure Python will give you such a brighter future than Ruby.
I'm working on big monolithic crud apps with very a pretty complicated domain logic that was sometimes rushed and not refactored enough. You can try breaking into micro services and encounter many more micro problems. Anyway the language isn't our problem, neither is the framework. Concurrency wouldn't do much for us and neither would static types.
What sucks about Struct is that there seems to be no clean way of turning a Hash into a Struct object like you can with OpenStruct: h = {x: 1, y: 2} OpenStruct.new(h) # Nice Struct.new(\*h.keys).new(\*h.values) # Fugly
Thanks for coming to wroc\_love.rb. Your talk was great. Indeed, our conference is not really that much about Rails or The Rails Way - I hope you didn't feel bad because of it.
Like I said I am not a fan of elixir but when you say you can't see why a startup would choose elixir - there ARE obvious reasons. They might not fit your project but concurrency is a really big bonus for some apps ( and I agree concurrency is overrated for many/most apps) . Some prefer functional languages and there are some benefits. For me they just don't yet outweigh OOP for what we do.
It's not even about Elixir - I wouldn't bet my startup on a new ecosystem no matter what, it's just not worth it imo. And yes, if Rails was 5 years old I wouldn't bet my startup on it back in the day. It is SOOO much better now than it was back in the early days. 
&gt;Wait a moment ... overcome it's usage to the web ... and making more developments regarding the deeb web. &gt;Hmmmmmmmmmmmmmmmmmmmmmmmm. &gt;:) Yeah I edited it I meant deep learning AI etc still I laughed a bit hard on my typo hahahaha AI is a buzz word for sure but generally RoR has to find some other big field to be used extensively. DevOs and penetration skills is a cool market but not that big etc P.S. I want to learn more about Ruby/RoR/sinatra etc due good books regarding OOP (s.mendez), excellent documentation and the clear structure to learn the programming language and frameworks given by The Odin Project but, I am really struggling not to refocus to python and it is a potty :(
Who is doing this awesome work?
&gt; I highly doubt your claim that Rust is simpler than Ruby. Thats what you get from writing too fast comments :). No, the rust code Rust is not simpler; though not *that* much harder. Especially since the Ruby version did all sorts of thread and forking management inline. That said: the rust deamons are *easier* to deploy, service and monitor. A lot. Since they are compiled, pushing the binaries to some servers and creating a systemd unit is all there is to provisioning: no gems, no rvm, no bluepill/god/whatever to manage the processes. No complex capistrano set-up, just copy the build over from a CI and start it; then kill the old one. I was really astonished by the ease: heroku-level easy deployments on my own server farm.
This is cool, although quite similar to https://github.com/activeadmin/arbre
A few other plugins that I use for Rails development : * [syntastic](https://github.com/vim-syntastic/syntastic) * [vim-indent-guides](https://github.com/nathanaelkane/vim-indent-guides) * [vim-javascript](https://github.com/pangloss/vim-javascript) * [vim-coffee-script](https://github.com/kchmck/vim-coffee-script) * [vim-gitgutter](https://github.com/airblade/vim-gitgutter) * [vim-surround](https://github.com/tpope/vim-surround) * [vim-ack](https://github.com/mileszs/ack.vim) * [AnsiEsc](https://github.com/vim-scripts/AnsiEsc.vim) (to view logs) * [vim-ragtag](https://github.com/tpope/vim-ragtag)
elixir is about 8 years old as I recall and its based on Elrang which has been around for decades. The only ting that would give me pause was if I needed packages and/or support for them. Their ecosystem in that regard is smaller but in terms of risk I don't see a huge risk in using Elixir. I'd definitely consider it if I had a project that had to potentially accommodate a lot of concurrent users but then I'd also consider Go as well. I would NOT write such an app in Ruby. Could it be done? Of course. Would it be optimal? nope.
Oh, I'm so sorry! I didn't realize it, but obviously I'm a whiney Rails developer, a user of boring-to-no-end gems, part of the pathetic www ghetto. I apologize for allowing my worthless opinion to get in your way, oh Mighty One. I'm so sorry. And thank you for your bestowing your pity upon me, I appreciate it truly.
&gt; There is currently no "official" reference Then please consider changing the text to _This book is a reference for the Ruby programming language_. The current text is misleading.
Done. ¬Ø\\\_(„ÉÑ)_/¬Ø
Where do you live now? And how many years experience do you have? Yes competition is fierce but companies are still struggling to find people. And if you stay several years in some European company you will always be more attractive to companies there than an immigrant from across the globe. P.S if you want to try the Netherlands let me know, the company I work in is hiring all levels.
LOL you should hit up Matz on twitter and ask him if he'll endorse it. worth a shot. 
Very good read, thanks for the writeup! &gt; Incorrect parameters handling Once I stopped using Rails, I started disliking `HashWithIndifferentAccess`. If I want to access the params hash with symbol keys (in Rack, the `params` hash has string keys), then I'd rather use something like `symbolize_keys`. In general, now that Symbols are garbage collected too, and we have `frozen-string-literal` feature, it would be nice if Ruby made `Symbol == String`. I don't see a reason why they need to be different classes anymore, and as you said it would remove ton of errors like these. Btw, `Hash#fetch` could also be used for early and explicit failures, which could increase the chance of catching the bug before production. &gt; Missing or incorrect timeout settings I'm vary of `rack-timeout`, because the `timeout` standard library can introduce inconsistent state, due to the fact that an exception can be raised at any point of the execution, even during an `ensure` block, which means that if you want to be safe you need to wrap each ensure block in `Thread.handle_interrupt`, which is not very feasible (as gems you use will likely not do it). One alternative solution might be to have some global timer tied to the current request, which is set to the web server worker timeout (e.g. 30 seconds on Heroku). Then each time you do an HTTP request or any other IO call which supports a timeout, you pass the time remaining as that call's timeout. In that case it would be good to introduce some wiggle room, let's say set the timer to 25 seconds if worker timeout is 30 seconds. I'm wondering how well that approach would work, I've never tried it. In my previous project I really needed it, because we were dealing with many Elasticsearch calls with _loads_ of data, and Elasticsearch queries are just HTTP calls, so you can set a per-request timeout. But I didn't think of it at that time.
Of course, not; I felt good) Next time I‚Äôll prepare less Railsy talk) Thanks for having me!
What I love about this talk is although it is ruby code, her principles work in any OO language. Great find and thanks for sharing!
Post in question: https://www.reddit.com/r/ruby/comments/ad46f9/whining_ruby_evolution_is_taking_too_long/
This is why funding is important and projects like Truffle Ruby are so critical since they have such funding.
I am still asking myself whether or not you were being sarcastic... If so, you did a great job. Ruby devs must become aware of what the consequences of the attitude you described might be.
\#MINSWAN Never forget! :)
IIRC it's because OpenStruct uses method missing to fill the keys/values which is also why it's slower than Struct.
Why does it all have to be black or white? Couldn't there be a consortium in which Matz works along with other \*peer\* devs trusted by the ruby community?
Wtg Matz. I‚Äôve met him a couple of times at Ruby conf. He‚Äôs awesome. He‚Äôs also not wrong. Ruby isn‚Äôt a ‚Äúback button‚Äù . 
Did you overrode the GEM\_PATH variable in your lambda's configuration? As indicated here [https://medium.com/devopslinks/how-to-use-aws-lambda-layers-f4fe6624aff1](https://medium.com/devopslinks/how-to-use-aws-lambda-layers-f4fe6624aff1) you should make the GEM\_PATH variable point out to the /opt/ruby/2.5.0 dir because the Lambda layer changes something. Keep in mind that if you override the GEM\_PATH variable your activerecord implementation would probably stop working out. Personally I decided not to use activerecord in order to keep my pg layer as lightweight possible. Did you managed to get any progress?
Hey, did you ever figure this out? I'm hitting the same problems and it's been driving me mad.
what's the licensing situation with projects like Truffle? And why isn't there more adoption of Truffle within the ruby community? Perhaps there is and I'm just missing it?
&gt; We‚Äôre mere mortals... Please be constructive. Don‚Äôt ruin our lives. I love this man. 
Admirable
[Anybody else remember](http://blog.steveklabnik.com/posts/2011-08-19-matz-is-nice-so-we-are-nice) "Matz is nice so we are nice"?
\&gt; Ruby devs must become aware of what the consequences of the attitude you described might be. I really hope they do.
Truffle doeesn't run Rails yet, which answers the adoption question. As for licensing, [here it is](https://github.com/oracle/truffleruby/blob/master/LICENCE.md)
&gt;Some have struggled with problems such as e. g. qt/kde becoming bigger and bigger, so language bindings lag behind - people have to write them in their spare time. &gt; &gt;This is not ideal. Ruby-gnome bindings work a bit better but there are few people. That has been the same in the last 15 years ago or so, by the way, so it's not as if this were totally new? &amp;#x200B; Excellent point you made, now go compare this to, say Python GUI libraries, and tell me you're not envious...
Hi, genuine question, may I ask what languages you are using as of now which are making you achieving your goals? Thanks!
&gt; We sometimes feel sick.
A word of warning. Your opening statement ends with the phrase "Happy Hacking". This friendly salutation is attributed to Richard Stallman and by quoting Stallman your entire project is therefore under the GPL. _/s_
To those who got really frustrated for the lack of a good, solid ruby ML framework at least equivalent to TensorFlow, here is one latest reason not to leave... or to delay departure... [TensorStream: Bringing Machine Learning to Ruby](https://medium.com/@joseph.dayo/tensorstream-bringing-machine-learning-to-ruby-114582060e3d) [https://github.com/jedld/tensor\_stream](https://github.com/jedld/tensor_stream) &amp;#x200B; Yes, I know it sucks when this happens the exact moment you've started packing stuff :P &amp;#x200B;
But... the post about "Ruby development being too slow" was about... "Ruby development being too slow", not about replacing Matz altogether... and it was about possibly forming a consortium of ruby developers trusted by the ruby community of which Matz could be part, because as the author pointed somewhere in another comment, wouldn't it be better if we had not one, but two Matz, so that Ruby language development could happen at a faster pace? I am just trying to provide more context... however I think reading and commenting under the [original post](https://www.reddit.com/r/ruby/comments/ad46f9/whining_ruby_evolution_is_taking_too_long/) would be a much better idea than splitting the question and the answer, as if there were two teams competing... &amp;#x200B;
Should have pluggable implementations, as with ActiveJob and ActiveRecord. Seems to be a trend with recent Rails additions. Getting PostgreSQL included as a backend for ActionCable (to remove the Redis dependency) took a bunch of pleading. 
Thank you!
Thanks all! I read everything. Very helpful.
This is Matz reply... &amp;#x200B; I think nobody was criticizing Matz as a Ruby developer (and author). Rather, the critique was aimed at how slowly the language is evolving, given there's just one person who is ultimately in charge for that. And about the fact that, in any system, it's not optimal to have a single point of failure. It's exactly because Matz is a great \*mere mortal\* Ruby developer that the community respects his work and is not expecting him to have superpowers and make miracles... &amp;#x200B;
The original poster did not ask "what can we do to make Ruby development faster?" or "what does Matz want/need?" or even "does the core team want to speed up Ruby development, and if so, what would they prioritize?". Instead, they came in guns a-blazing with solutions to THEIR biggest problems. Matz made ruby. Matz still makes Ruby. If he wants a consortium of Ruby developers then he will build one. If you want to speed up his development of Ruby, then make him spend less time advocating for why he's doing what he's doing...and let him build Ruby. It would be easier to "speed up Ruby development", but it doesn't matter how fast you're going if you're going in the wrong direction. If the core team needs help, ask them how they want to be helped. &gt; however I think reading and commenting under the original post would be a much better idea than splitting the question and the answer as if there were two teams competing... Unfortunately, with the way that Reddit works, that comment thread is mostly there for history now. Most people will never see it. 
Right. I'm not sure if those tweets are in reference to the Reddit post. If they are... Then Matz really need to take a vacation and get some help. He's emotional, not making much sense, and not communicating professionally. One critical Reddit post which he has obligation to read is ruining his life? If the CEO of my company said that I'd immediately start looking for a new job. 
This is getting a bit shallow... He is nice. We are nice. But the main reason we consider him so - above all reasons - is because he created Ruby. If Ruby does not stays relevant, it will not be a thing anymore... then what is left? Being nice for the sake of just being nice? 
He sounds unhinged and needs help. One Reddit post which he's not obligated to read, and which is merely questioning the development process... Is RUINING his life?
You're also spot on about the Twitter reply vs. Reddit. He doesn't appear to be open to discussion about the process. 
&gt; He's emotional, not making much sense, and not communicating professionally. What? Have you met Matz or listened to his talks? This is his cadence, this is the way he talks. He told a story from his past, related it to a semi-recent event (Guido quitting), and then asked for empathy. &gt; If the CEO of my company said that I'd immediately start looking for a new job. I hope your CEO appreciates what decisions are important to the company and how past decisions shape the ones that we make today. I hope they acknowledge and accept the parts of our career that we cannot change, such as burnout, and actively work towards working at a sustainable and maintainable pace. I hope they respect the efforts that their employees must take to stave off burnout. Most importantly I hope they fight and advocate for you every step of the way. 
If this is truly a response to that thread, then it's condescending: "others have tried this before and failed and you will too. You have no idea how much work this is." Very disappointing to see that attitude. It also misses the entire point: Every prog language has these constraints but some are able to rise above and adapt to the modern world. We'd love Ruby to do the same. 
we were doing a lot of front end work and then a project came up where we need a lot more speed so we dived into nodejs. still did some ruby and even some laravel because of some legacy apps.
Heroku has sponsored Matz and Nobu to work on Ruby core for over half a decade. Cookpad hired Koichi recently (previously he worked for Heroku as well). Other companies pay for other core/contributors ARM Treasure Data pays for k0kubun (who implemented made MJIT). Vladimir Makarov is paid by Red Hat to work on GCC and now CRuby.
Wasn't there a big fight in which the MRI team refused to commit to a language spec? And wanted to keep it at " The MRI interpreter's behavior is the spec."
I think It's not on display in these tweets: they're very condescending. We're not 13-year olds. We're professionals making informed decisions and wishing we could continue with Ruby. 
Yes, but I totally forgot about that juicy RVM drama. (I use `rbenv` to this day...)
It's a man speaking from experience. Maybe he could have been a little more tactful, but it's a tweet, and English is not his native language. Anybody who's ever been a team member on a popular FOSS project can tell you it's a _lot_ of damn work, and ain't as easy as it looks.
I don‚Äôt think it‚Äôs too slow at all. I just feel like having a sad rant about work, so here I go: We‚Äôre using AWS OpsWorks, so we‚Äôre stuck on Ruby 2.3.x until we get enough time to use Chef to alter the environment or move to ElasticBeanstalk. I keep seeing the versions going by and all the nice new syntax that I can‚Äôt use yet and worry I‚Äôm going to forget about it. Man. Not to knock 2.3, but damn I want to get us on newer Rubies soon. I‚Äôm jealous of the new toys and I‚Äôm bored at work. 
 ruby being slow is such bullshit. I wish it would go away. There is a place for languages like ruby and python. They have very similar performance characteristics. They are fast enough for what they are used for, although nobody ever complained about better performance. I don't think anyone is using python instead of ruby because it's faster. They are both still very successful languages. Python seems to have more popularity. I have no idea why, but I haven't seen any reason to think it's because python is faster. (If anyone has any reason to think that please do share). But python's current success totally shows there is a place for something in the position of ruby or python -- they both more similar to each other than they are to anything else, and have very similar performance characteristics. It is a problem for me that the ruby community/ecosystem has shrunk. Like it worries me, I'm not sure that everything is fine. It is not a problem for me that ruby is too slow. And I don't think ruby's performance characteristics explain the shrunk community. 
If it takes one programmer one month to complete a project, it will take two programmers two months to complete the same project. (or the corollary nine women can't make a baby in a month) I think we need two Torvalds. We need two Matz. (if not load balanced then at least for fail over) But just by virtue of having two wouldn't make development any faster necessarily (and might arguably take longer... unless it was a clone, but then we're talking sci-fi...)
True, but (IIUC) areas where the two differ importantly include their respective views (npi) of "components" and "context". In Arbre, components are subclasses of `Arbre::Component` and *must* call `.builder_method` to define "the method that will be called to build this component when using the DSL". In Rubyoshka, the example uses a `Proc` that returns a template (document fragment); it's trivial to see that being adapted to PORO methods or whatever. The meanings they assign to the term "context" are even more different. In Arbre, a context is "an object in which Arbre DSL is interpreted, providing a root for the Ruby DOM that can be searched and manipulated"; the example code they give, though trivial, is quite clear. Rubyoshka has global and local contexts that are simple Hashes containing values to "plug into" templates. I don't have a knee-jerk "one is better than the other" reaction (for context, I did several projects using the late, lamented [Fortitude](https://github.com/ageweke/fortitude) "views are code" library). Which you choose for your project will depend on how well each fits into your preferred code/architectural style: projects that are heavily class-oriented will probably prefer Arbre, with functional/message-oriented code likely preferring Rubyoshka. After years of poking around, we're happy-for-now with our current view-rendering stack (Slim and Hanami Views), but I've watched both projects.
on the other hand, if you really do want "public domain" -- no rights reserved at all, anyone can do anything they want with it, there's this: https://creativecommons.org/share-your-work/public-domain/cc0/ Which might be appropriate for something which already has... what, MIT licensing? You can't enforce restrictions on something you didn't own the rights to in the first place. I don't even know how it all plays out in this case, but if you really want public domain, you don't even gotta worry about it, just CC0. I agree that an official license or waiver of rights, that was vetted by lawyers for general use like CC stuff, is a good idea for clarity and for people to rely on it with confidence. 
Being paid to write software does not ‚Äúprofessional behavior‚Äù make. 
I think there is some issue because of `\` and `\&amp;` being next to each other, I will try to find out why You can use block form as a workaround &gt;&gt; s = "This isn't a big issue." =&gt; "This isn't a big issue." &gt;&gt; puts s.gsub(/[^a-z\n]/i) { '\\' + $&amp; } This\ isn\'t\ a\ big\ issue\. 
It's OK, keep it honest!
What is this "RVM drama" ?
From the couple times I have met him, he is a very nice person, smart and gentle. There should be balance in everything, and there should ALSO be someone on the core team that pulls towards going a little faster. I don't think that is unfeasible or unreasonable. 
Yeah, I'd like to know as well. I use it all the time and don't have any issues with it
But this is fractionalized to some degree. There needs to be a greater degree of concerted effort in some very specific areas. Due to the complexity of the internals it may be worth even focusing on bringing in talent in this specific area.
Often criticism such as this post isn't *really* about what it says it is about. It's similar to the X/Y problem, only more fuzzy. There probably were people worried about their career, other who wanted to see more focus on some parts of the language/stdlib because of real everyday issues, other who actually don't know where the language is headed and would like more announcements (maybe they already exist but aren't easy to find), etc.
I think Matz is really feeling the burnout if not i cant explain such reply. People realize the complexity of the features they want (and they want them now) but dont really know how long will it take. There is the 3x3 but that much performance wont make Ruby what it once was. Ruby‚Äôs usage us really regional. You wont find jobs in specific regions because Ruby already disappeared from those places. People realized that they could switch to different langs but they just dont want because Ruby makes them happy. People are simply sad about losing Ruby that is the reality.
It is in their direct profit to develop language that most of their users use to push projects that generate revenue for them. It is more of an investment for verily than charity.
I did change the GEM\_PATH and in that ruby folder, I also added activerecord. I will get back to you after I try using only the PG gem and see what I come up with.
Thanks for that. Reading comments I feel like I am some hater:) I actually thought that Matz should be above this group. Just letting them make decisions on some minor issues and consulting with them on others. And of course he should have right to interfere and cancel their decisions. Just because he did such a great job so far.
Now I keep getting: { "errorMessage": "uninitialized constant PG", "errorType": "Function&lt;NameError&gt;", "stackTrace": \[ "/var/task/lambda\_function.rb:11:in \`lambda\_handler'" \] } &amp;#x200B; This is my code: `require 'json'` `# puts require 'pg'` `puts require 'workflow'` `def lambda_handler(event:, context:)` `puts Dir["/opt/**/*.*"]` `puts '------------------------------------------------------------------------'` `PG.connect(host: ENV['host'], dbname: ENV['database'], user: ENV['username'], password: ENV['password'])` `puts '------------------------------------------------------------------------'` `end` I also added the workflow gem just so that I can check that it's getting loaded and I get true when doing `puts require 'workflow'`, but I get an error when requiring 'pg': { "errorMessage": "cannot load such file -- pg", "errorType": "Init&lt;LoadError&gt;", "stackTrace": \[ "/var/lang/lib/ruby/2.5.0/rubygems/core\_ext/kernel\_require.rb:59:in \`require'", "/var/lang/lib/ruby/2.5.0/rubygems/core\_ext/kernel\_require.rb:59:in \`require'", "/var/task/lambda\_function.rb:3:in \`&lt;top (required)&gt;'", "/var/lang/lib/ruby/2.5.0/rubygems/core\_ext/kernel\_require.rb:59:in \`require'", "/var/lang/lib/ruby/2.5.0/rubygems/core\_ext/kernel\_require.rb:59:in \`require'" \] } &amp;#x200B; I really don't understand what is going on. I installed pg v1.1.3. &amp;#x200B; &amp;#x200B;
Ok, well you asked for it... RVM was released in [2009](https://github.com/rvm/rvm/releases?after=0.0.93) by a gentleman by the name of Wayne Seguin. It was at the time revolutionary, it was to Ruby what perlbrew or virtualenv were to Perl and Python at the time. It was truly revolutionary because at the time installing and configuring Ruby was a bit of a PITA (especially on Windows I believe, but was never a Windows developer). However, it was a bit heavy handed, rather opinionated, and came with its own faults (see the [below linked](https://news.ycombinator.com/item?id=2874862) hacker news thread). It did some strange things like redefining the shells buitin `cd` command to execute a function which essentially ran arbitrary code. In ~mid 2011 this [raised](http://batkin.tumblr.com/post/8847990062/on-rvms-cd-script) some [criticism](https://news.ycombinator.com/item?id=2876874) in the Ruby community (I really don't care to go read through old mailing list archives, but I'm sure you could find some of the conversations). In the midst of the drama, Sam Stephenson releases [`rbenv`](https://news.ycombinator.com/item?id=2874862), which among other things [took aim at RVM](https://github.com/rbenv/rbenv/commit/a804b5eb21d6623b91a13ccf3281276d65ba45d6), note the comment about redefining `cd` as being "obnoxious" (this was actually changed [soonish after](https://web.archive.org/web/20121223054512/https://github.com/sstephenson/rbenv) again, not digging for the specific commit). It essentially replaced large portions of RVM but wasn't a drop in replacement as it didn't do the actual building of Ruby. Anyway, apparently Mr. Seguin found the above linked hackernews thread introducing rbenv which was rather critical of RVM and lead to him [quitting RVM](https://web.archive.org/web/20111017045549im_/http://www.rubyinside.com/wp-content/uploads/2011/08/wayne.png). This lead to a campaign to donate to his [Pledgie](https://web.archive.org/web/20111004051445/http://pledgie.com/campaigns/9822) which ended up raising $13,400.00 overall (I'm actually thinking the pledgie was setup before the drama, but there was an online "push" with tweets, etc. to get people to donate... my brain is a bit fuzzy and I was unable to find any relevant tweets from that time). Mr. Stephenson did [issue a reply](https://web.archive.org/web/20111017045212im_/http://www.rubyinside.com/wp-content/uploads/2011/08/Screen-shot-2011-08-12-at-16.00.59.png) to Mr. Seguin. TL;DR people [criticize RVM](https://news.ycombinator.com/item?id=2874862), [Wayne Seguin quits Ruby](https://web.archive.org/web/20111017045549im_/http://www.rubyinside.com/wp-content/uploads/2011/08/wayne.png)(creator of RVM).
[here you go](https://www.reddit.com/r/ruby/comments/ado2wb/matz_replies_to_post_from_this_sub_about_ruby/edjp0c1/)
Actually, I explicitly asked what people think of situation and what ideas they have. And I didn't try to undermine (gosh I hope this is a right word) Matz in any way. I just shared my feelings at the moment and wanted people's opinions. And I actually saw some interesting ones. So the post achieved its goal (in my perspective). And I really wasn't expecting him to answer this shit (I assume he answers not my post specifically, but many similar ones). And I sure hope that he didn't take it personally. I wish I added a disclaimer saying that I really like what he is doing so people woudn't think I question his authority.
Thanks, good point. Anyway, it's hard to know how would things go:(
Business America (tm) at its worst... Ever so demanding and giving so little in return. I suspect you and your employer are not paying Matz nor the core team to make a product to suit your professional/business needs. You know ruby's technical constraints. You have made your point about the process. You are free to pursue your gold rush West with faster-better-cheaper pick-and-shovels. Or you (and your employer) can also pitch in and help (Matz says how). Delivering business value comes at a cost. Showing a bit of good will not as much.
So the big difference, API-wise, between struct and openstruct, is that struct is locked-down to the attributes you choose when you define it? I really like that feature --- having some control over what gets in it. And I'm guessing that the whole advantage of openstruct is, it's essentially a hash with more access options. (?) E.g., you can say `mystruct.thing` instead of `mystruct[thing]`. Is that it?
The 80% of texts are just extracted from Ruby codebase and ruby-lang.org website. The rest (structuring, formatting, additional texts): https://github.com/rubyreferences/rubyref/graphs/contributors
Thanks for the suggestion, I'll look into it. I was a bit vague about this part indeed, just wanting to say "I don't want to enforce any limitations at all".
&gt; Being nice for the sake of just being nice? Is this supposed to be a bad thing?
It would be really helpful to see ever so brief comparison with 10 of other existing "tags-as-blocks" Ruby gems.
This phrase was coined by prag-dave mostly. I never understood it fully. I get the "matz is nice" part but I fail to see how this should relate into behaviour. It reminds me of Code of Conducts too. People need to stop assuming wanting to encourage other people to behave in certain ways. I think matz is awesome but I could not care about any "xyz is nice so I must be nice" either. Not that I am stating the opposite, either, by the way; neither with Code of Conducts. This is a bit difficult to explain as well. For example, I mostly don't use animals as food source. But I am not a vegan nor a vegetarian. Why? Because the terminology just does not apply; the word does not fit. Often you superimpose all sorts of health-related aspects aka "vegans live a healthy lifestyle" and similar things. None of this applies to me; not that the opposite applies to me either. It's just that the term, and the assumptions, simply don't fit. With prag-dav and such phrases, you have to be careful to put them into proper context, because some of them are misquoted or put out of context. What you can rely most on is what matz has been saying for a long time. For example, he does not focus on the "matz is nice part" for various reasons (including that not every suggestion makes him super-happy, in particular when the suggestion is not a real one) - but more importantly because he actually said to focus on ruby itself, as a language; and as means to achieve/leverage it according to (a) philosophy, in particular the "to help people solve things". So when it comes to quotes, I think the by far best ones are those THAT COME DIRECTLY FROM MATZ HIMSELF - not from anyone else. There are some people who do not understand it, partially because they are trolling, and partially because they only read prag-dave but don't listen to what matz said. To give another example - matz never spoke about THE principle of least surprise as if it were a universal thing. People are different, they have different expectations. There is no one universal THE principle of least surprise. I am not saying that there isn't a specific inner consistency in ruby, mind you. I am just saying that there has not been THE principle of THE least surprise.
I think all of these tools are just absolutely useless crutches. I also explained this in the past. I don't need any "version manager" for ruby because ALL MY PROGRAMS are already versioned at all times. I use a setup that is very close as to what GoboLinux uses. https://gobolinux.org/documentation.html I did use several ruby versions side by side under /Programs/Ruby/ but these days I just keep on using the latest stable and that works for me. (I don't use unstable ruby versions, other for quick testing, mostly because when I publish gems, I think people expect only stable ruby releases really, since unstable variants can sometimes break, which just isn't fun for anyone.)
&gt; It was truly revolutionary because at the time installing &gt; and configuring Ruby was a bit of a PITA and managing &gt; multiple versions was just a headache. No, sorry. Managing multiple versions is TRIVIAL. I do so on my linux system. For every program. I understand that GoboLinux isn't known by many people these days, also due to loss of momentum, but I use a similar variant on my system. I just change a single symlink and have that version work just fine. I think RVM but also rbenv are just pointless. I understand that if you are locked down in using a specific distribution then indeed, you are a prisoner of this system and have to adhere to it. But that is the beauty with linux + ruby - you can literally change EVERYTHING. And manage the whole system having any version you want to. NixOS is doing something vaguely similar, although I don't like the hashed names for directories they gave, the complexity of the nix language and, most importantly, their addiction to system which completely defeated the point of using linux (if you steal the flexibility that you had before systemd). I will never understand why people are stuck in their box and thinking that rvm or rbenv are important. Both should not exist. It's a similar battle between vim and emacs. People just stop thinking outside of the box. I could never go back to use a FHS-limited system as such that does not give me easy control over all programs, at all times, without depending on crippled package managers (e. g. see debian modifying packages, like removing mkmf from ruby by default; yes you can uncripple it but remember that you have to uncripple the whole system, in order to use it. Debian is such a heavily overrated distribution. If people want to REALLY learn something they should learn from LFS/BLFS because that project is really a wonderful one. And they could need more maintainers too. http://www.linuxfromscratch.org/blfs/view/cvs/introduction/changelog.html )
I have no idea how you come to these "conclusions" other than the obvious one that you are trolling. But even leaving that aside, I am not sure how it were to prevent you from using ruby? I am using ruby just fine. Can you explain how this prevents you from using ruby? Not that I think you do but perhaps you have a cat next to your keyboard that whacks at your fingers and stares at you now. That may be a valid reason perhaps.
Very true. The reverse applies too, though. You can NOT be paied and still show a "professional" behaviour - whatever that even means (I did not define the term, I am just referring to the same context of how you may have used the word "professional").
[Ruby has the kindest programming community](https://dev.to/ben/ruby-has-the-kindest-programming-community-and-i-have-the-data-to-prove-it-4f60) 
I found this always a very useless abbreviation. I found matz cool well without minswan. I also think he is a great language designer. That does not necessarily mean that ruby is perfect nor that everything in ruby (as a language) is great. By the way, even matz plays with new/different ideas e. g. streem. I don't like the syntax in streem that much but I understand a different model for manipulating/focusing based on stream (and stream-like events). I still remember avisynth - I'd love an object oriented pipe from the get go for the whole lot of doing programming-related tasks (or rather, tasks that can be automated).
I actually partially to your first paragraph, although I don't use ruby to "make me happy". I find that a very flawed assumption. I use ruby because ruby solves my use cases; and because it is a VERY, very good language. Now to your next paragraph - that one is totally awful. What does it even mean "stay relevant"? Relevant as to ... how? Go? Dart? Rust? First, these are awful languages. But even MORE importantly, they aren't even in the same niche setting. Ruby fits into the world of python, perl, php, even lua and perhaps a bit nim (even though nim is compiled); and probably julia and crystal too (again, even though the latter is compiled). I don't think ruby fits that much into Rust at all or Go. I don't see what is "relevant" about them. That it is controlled by any fat megacorporation? That makes a language ... great? Java? Why are people so annoyed about Oracle's licence then? Why does Oracle not receive as much love and affection, if you can infer such from written text alone, as would Sun? I never read as many complaints about Sun as I did about Oracle; and many complaints are probably also well deserved in regarsd to Oracle. &gt; Being nice for the sake of just being nice? This assumes that the MINSWAN saying has any real relevance. I don't think it ever had to begin with. But again - just because that statement has been made, doesn't change the fact that ruby is either useful (to you) or it is not. To me ruby is super-useful. And I don't use ruby because matz is nice or matz is cool - I use ruby because it solves my needs and does so in a really great, elegant manner. Of course I also reject syntax that is awful, so I only use a subset of ruby. But that subset is wonderful. I could not do the same with PHP. I'd have to use awful syntax all the time, with awful ad-hoc spaghetti design non-stop. That would just kill my sanity and my time would be wasted too much. I actually think that many programmers don't even notice that they are wasting time too.
I managed to get it working using this article: [https://www.stevenringo.com/ruby-in-aws-lambda-with-postgresql-nokogiri/](https://www.stevenringo.com/ruby-in-aws-lambda-with-postgresql-nokogiri/) &amp;#x200B; Thank you for your assistance.
Funding is obviously important but it can also create problems. Not with ruby but ... take the Linux Foundation writing an eulogy in support of Microsoft assimilating github. Microsoft sends a lot of money into the Linux Foundation, which is used as means to re-distribute the money to, well, you know. I have no problem with the flow of money there, by the way - that part is fine. What I have a HUGE problem with is this PAID ADVERTISEMENT and influencing of OTHERS with that money, such as what the Linux Foundation did. And anyone claiming that the eulogy would have come without money ... nope, sorry. I am not totally stupid either. But again - this is a more general comment, NOT one related to ruby. I have no problem with the way how ruby is presently handled and I agree that funding is important in general when it comes to open source too. We all saw how a lack of funding can lead to people abandoning projects; and I know how e. g. twitch-streemers playing games get a lot of money as support. If people can pay for watchin games, it should be theoretically possible to at the least re-distribute some funding into open source related software with permissive licences.
It's sort of both. I mean, I do not disagree with you necessarily but look at guido throwing in the towel when he lost having fun with python. And matz also referred to this. Now I think matz is not like guido; and ruby is not like python, so I don't think these situations can be compared 1:1. But you should include that when you put monetary incentives as primary motivation (or your assumption of it). We also have languages completely run/dominated by companies. Would you prefer an ecosystem that is operated whatever random private interests these companies may have or want to pursue? Also note that money alone won't buy a great design. You can throw in a lot of money and still end up with an ABSOLUTELY HORRIBLE language. I mean, take Erlang - it took Elixir to make erlang prettier. And elixir was heavily inspired by ruby, syntax-wise. Not as much as crystal but still.
Several reasons. A big one is, I think, that barely anyone know truffle. Another one may be that they think truffle is more a beta-project. For me personally, Java is a no-go. I have no huge problem as such with it but ... I sort of live in the C/C++ world really. I don't need java. I read from https://github.com/oracle/truffleruby that one can ... opt to not have java installed? Or something? Not sure if this is true. But when it requires of me to use java, then I won't use it. I just don't need java and am happy to not have to. I don't have any really strong feelings against java, other than its addiction to verbosity, but I really don't want to have to use it. To me MRI is really really just perfect. So my example here probably is not valid for many other people, but I do happen to think that many other people are very fine with MRI and use it without a problem. A smaller reason may also be that side projects tend to be abandoned or lose momentum e. g. rubinius. I think what we can come up with is that, no matter from where you are coming from, ruby lacks a bit of momentum right now. Not in regards to the core devs per se, but probably from the ecosystem, which may also be partially related to the influx of younger people not being that strong (as opposed to, say, people using python or javascript first perhaps). However had, I am speculating here really. I don't know for sure. I am most definitely not among the young folks anymore myself. :(
I find your claim hilarious considering there is an ISO spec. But anyway, despite your trolloll-rolling, I'll make a few comments on this. We have to keep in mind that e. g. prior to rubinius being started, there just was no real need to any spec since the way how ruby was run worked fine for many years. So a lot of pushing for a spec came because of that other project. Who knows if we'd still have a spec today without rubinius, I don't know. Another partial answer is that the test-related code is, to some extent, a spec too, which then becomes as being the (documented and verifiable) specification. Obviously specifications don't stand still when a language is moving. I don't know how relevant the specifications are these days. From my perspective, most people by far use MRI and are fine with it. These days I am not proposing many new features myself due to several reasons (lack of time is a big reason, but another big one is that I have no real qualms myself that I'd like to change; only one that is on my todo list is to be able to use another way to add code, other than hardcoded paths to .rb files).