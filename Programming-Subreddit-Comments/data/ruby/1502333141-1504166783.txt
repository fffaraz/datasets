Yep. I have a better understanding of a lot of concepts I learned about in undergrad thanks to my usage of Ruby.
You're probably looking for the `select!` and `reject!` methods.
Hear, hear!
Show us the code! And ideally the text file, too. (With any sensitive data removed/redacted if necessary) 
Are you forcing UTF-8 encoding for user text input?
No they're not, because my Rails app is built by competent developers. Any half-decent Rails developer understands what is happening with the database when they construct ActiveRecord queries. If your Rails app has scaled to the point where N+1 queries are a problem and you have developers who write N+1 queries, then the developers are the problem.
You might find some insight in the docs under the [IO::new method](https://ruby-doc.org/core-2.3.0/IO.html#method-c-new). Essentially you can provide hints or outright force Ruby to expect or produce a particular encoding.
this may be more geared towards self-taughts / boot-camp grads. (but I agree with you)
Rails makes it exceptionally easy to introduce N+1 query problems. There's no warning whatsoever, nothing. As such you can't only blame this on developers as even competent ones can add them by mistake.
Wow that's a very narrow topic for a book.
`select!` and `reject!` only return the elements that remain in the array. The goal was to return the elements being removed, like `delete` does for a single element.
Take a look at your developer console once in a while and you'll notice if a bunch of queries scroll by. I use Goldiloader as it kills a few N+1 queries that would be difficult for me to resolve but I also disable it on occasion to ensure I haven't introduced more. 
As a follow-up to what /u/yorickpeterse said, [ROM](http://rom-rb.org/) is the most well-known Ruby database library which actually doesn't allow N+1 queries, by design it's just not possible to produce N+1 queries.
Notes i have on Rubys Blocks, Procs and Lambdas from my last two weeks in Ruby Land. Corrections welcome, suggestions, differing opinions welcome. Lambdas are functions used as data. Which means they can be passed around as data. In order to pass a function around the function call itself is delayed until explicitly called. Different languages have different rules about delay. Ruby's Blocks and Procs have a subset of the functionality of the Lambda. Cons of Ruby Lambdas: 1) Ruby solves the half of the Expression problem by allowing for polymorphism through objects. This means that if you want to runtime dispatch on a function you will need to do it through an object. Which means your lambdas can't do runtime dispatch, which makes them less useful then you might find in languages that do allow for it. 2) The syntax for ruby lambdas differs from other functions, making it somewhat awkward to write large lambdas (more then a single line). 3) Ruby doesn't make it as easy to compose functions as some other languages, which means you end up writing longer lambdas then you might other wise. 
`#partition` is probably the best thing to use (mentioned in the article). It creates a copy rather than modifies in place, but that's probably just as fast if you are removing lots of elements, as doing that involves copying anyway.
Right, my bad. I thought you just wanted to modify the array in-place. I also don't like that `select!` and `reject!` sometimes returns an array, and sometimes returns nil. It seems inconsistent to me.
It's also impossible to have N+1 queries when using SQL directly, so this is a problem manufactured entirely by ORMs. The same goes for "strong parameters." It's a solution to yet another problem manufactured by ActiveRecord. What's interesting is that so many rails shops seem to regard these concepts as being somehow inherent to programming general, or at least web development. They ask interview questions about them. They install gems to help them discover N+1 queries as if they just sort of accept that N+1 queries are going to somehow happen _to them_ from time to time.
 allow(client).to receive(:find_organizations).with("foo@bar.com", "1c2c408c-b370-40cb-9d84-23f9b283469f").and_return(whatever) https://relishapp.com/rspec/rspec-mocks/v/3-5/docs/setting-constraints/matching-arguments
Totally, I just didn't want to look up why and then talk about it for 5 minutes like I knew what I was talking about the whole time. Though your comment prompted me to actually look it up, and...REM does something different than I thought. So thanks!
I've written SQL directly before in code still lazily-loads data (using SQL directly) on demand. I think it was appropriate for my use case. N+1 queries are still possible. They are not unique to ActiveRecord, they are part of most ORMs, and any system that will lazily load data whether considered an ORM or not. You can make the argument that lazily loading data from an rdbms is never an appropriate pattern (I won't agree, but you can make it), but that's not quite the same as just hating on AR specifically. Despite knowing exactly what's going on and how to do it right, and not learning much from the OP -- I've still sometimes accidentally done N+1s in my AR. In disagreement with original downvoted comment. 
I was hoping it was going to go into the per-form tokens in a "deep dive", that's the part I understand least! Still useful to get a refresher on the rest. And good on them for mentioning it is more complicated with per-form tokens but they're not going to go into that, instead of just pretending like it doesn't exist. :)
I actually suggest learning recursion through a language which is statically typed. I used to always rely on iterations until I started learning Haskell in university, then I saw how great recursion could be. Take this example of the factorial for example: fact :: Int -&gt; Int fact 0 = 1 fact x = x * fact (x-1) So factorial is a function that takes and integer and returns an integer. So what's happening? Write out the steps of doing fact(4) for example: fact 4 = 4 * fact (4-1) fact 4 = 4 * fact 3 So now doing fact 3: fact 4 = 4 * (3 * fact (3-1)) fact 4 = 4 * (3 * fact 2) And so on... until: fact 4 = 4 * 3 * 2 * fact 1 fact 4 = 4 * 3 * 2 * (1 * fact 0) But we defined that fact 0 = 1. This is the base case (or terminating condition), and the key to every recursive function is that it requires a base case. So we have: fact 4 = 4 * 3 * 2 * 1 * 1 = 24 If you're interested with Haskell, I have some resources from my University's functional programming course. But anyway, you can still do it in Ruby. I don't have any other resources to give, but I suggest just looking at examples of other recursive functions. One recursive function which might make it easier for you to visualise what's happening in recursion, is the [flood-fill algorithm](https://en.wikipedia.org/wiki/Flood_fill). This wikipedia page also has the pseudocode for it, which describes what is happening. Also just a note on recursion; if some code you want to right seems doable with iteration, don't try and force yourself to write it recursively if it won't make it easier. Although since you're learning, I recommend writing as many recursive functions as possible. Even ones that would be super basic with iteration, it's good practice!
I'm personally more of a fan of using selenium-webdriver, it supports javascript enabled sites perfectly and you can watch the interaction of the page (making it easier to debug)
This is kind of a shitty attitude to have. You're not wrong, of course, but not every dev can know every thing. 
1) Everyone needs to install Rack Mini Profiler &amp; use it in production 2) Read this https://blog.heroku.com/solving-n-plus-one-queries 
I'm going to go ahead and disagree with you. Performance issues like this being a "developer problem" the same way "SQL injection" is a "developer problem". Technically it's the developer who introduced the bug, true - but more than that it's a system that enabled the bug to be easily introduced. In real life if people keep driving off a cliff, we don't say "well they should drive better" we post signs, put up guard rails, add rumble strips. Sure none of these things completely stop someone from having a bad time with that corner, but it's much better with them than without them. In this case I think the system can do a better job of showing people when this is happening, it's why I proposed introducing rack mini profiler into the default stack. We can add visability and tooling to make the issue better. 
That was my thought. Totally unrelated except that it's functional: what I REALLY want is a proc that does not retain or use current scope üòç. Basically an immutable anon function. 
You can use `delete_if` which takes a block https://ruby-doc.org/core-2.4.1/Array.html#method-i-delete_if
The post mentions that `delete_if` is essentially an alias for `reject` that will always return the existing array even if nothing was deleted, whereas `reject` will return nil.
Can you expand a little on 1? I'm not clear on what you're trying to say with &gt; This means that if you want to runtime dispatch on a function you will need to do it through an object. Which means your lambdas can't do runtime dispatch, which makes them less useful then you might find in languages that do allow for it. and not sure it's correct (it might be, but I'm not confident I fully understand the point you're trying to make). 
Yep, i commented before I saw what OP wanted from the method.
Agreed and also regarding "true computer scientists": [No true Scotsman](https://en.wikipedia.org/wiki/No_true_Scotsman). These kind of articles should die, because Ruby surely isn't.
Some additional good listens and reads https://www.youtube.com/watch?v=ktZLpjCanvg&amp;feature=youtu.be&amp;t=4m27s https://rossta.net/blog/n+1-is-a-rails-feature.html
I wouldn't have downvoted the original comment personally. My argument is not that AR is somehow unique among ORMs in being responsible for N+1 problems; as you mention, N+1 can happen without an ORM: def get_line_item(id) pg.execute("SELECT * FROM line_items WHERE id = ?", id) end # ... line_items = line_item_ids.map do |id| get_line_item(id) end The root cause of N+1 is comingling data access with other unrelated logic. In the above example, a simple query method is executed in a loop as part of some larger procedure -- with a proper design, all of the data needed by the procedure would be retrieved _before_ starting out. ActiveRecord can be used in this way, too -- for instance, you can load all the data needed by a view template in a rails controller, so that rendering the view doesn't depend on the database. The problem always comes down to us programmers -- do we choose tools like ActiveRecord that offer great convenience, but increase our propensity for mistakes? Or do we structure our programs in a way that heads potential bugs off at the pass? My comment was pointed in an even different direction -- teams of web programmers with zero experience outside of web/MVC/ORM often don't _perceive_ the root cause of problems like N+1 and instead accept them as the norm.
Man, I should write a book on uses for `&amp;.`
can you expand on number 3? What's difficult about the way ruby does it?
You can certainly learn things about lower-level computer architecture with C and assembler that you can't easily learn with ruby. I have no idea if that's what they meant by "true paradigms of computer science". My own undergrad CS curriculum was mostly in scheme. There's very little you can do or learn with scheme you can't do with ruby. I want to say they were probably quoted out of context, and I'm really curious what languages they think "introduce the true paradigms of computer science", if they're going low (assembler/C) or high (scheme), but I dunno. 
It might be nice if there was a deep-duplicate method that duplicated a `Proc` and its captured scopes.
Where is this uploaded file coming from, uploaded how, Rails? What character encoding is it in? This is my favorite intro to character encodings, you need to understand that character encodings are a thing and how they work to fix your problem in a reliable way. http://kunststube.net/encoding/ "Chinese characters" could actually be in a number of encodings. UTF-8 would be the easiest if you have control over it. But since "\xE5" isn't valid UTF-8, it seems like it might be in a different encoding, you will need to figure out what one. And if your users won't always be using the same encoding, you'll either need them to select an encoding on upload, or write or use some code to try and guess what encoding it is. (Or just tell them they gotta use UTF-8). You need to know what character encoding text is in order to handle it. Or I guess there's one more possibility, you could just treat the text as "binary" (which is what ASCII-8BIT is, basically just a bunch of bytes with no encoding), if you can still gsub in it like you want and just return it. You'd have to play around with it. If you want to do that, you want to know how to get Rails (or whatever file uploading gem you are using, depending on where the error is coming from), to treat the uploaded file as the binary encoding. 
 class Array def remove!(&amp;block) [].tap do |removed| self.each_with_index do |item, i| removed &lt;&lt; delete_at(i) if yield item end end end end require 'minitest/benchmark' require 'minitest/autorun' describe 'Array#remove!' do it do a = [1,2,3,4,5,6,7,8] removed = a.remove! { |i| i.even? } removed.must_equal [2,4,6,8] a.must_equal [1,3,5,7] end end describe 'Array#remove! Bench' do bench_performance_linear 'is O(n)' do |n| (0..n).to_a.remove! { |i| i.even? } end end Probably a few edges cases you may want to handle differently, e.g. when no block is given. Also not sure how portable this is outside MRI. Mutating the array while iterating it is...interesting...
I appreciate the detailed response! I specifically was looking to not monkey patch, but this is a cool solution.
Big caveat here, goldiloader doesn't work for multiple table polymorphic relationships (like, target/subject/object relation on a record that functions as an audit trail)
What's wrong with strong parameters?
I have been using Clojure for over a year now and stepping back into Ruby I had to re-learn a lot. I know understand more about programming languages then the last time i programmed in Ruby so i spent some time focusing on Rubys functional aspects. Its possible i just dont see the most idiomatic ruby ways of accomplishing things. A somewhat direct example of composition that i enjoyed in Clojure but couldn't quickly find int Ruby was the `comp` function. Which lets me compose together functions: Clojure user=&gt; (map (comp #(* 2 %) #(+ 1 %)) [1 2 3]) (4 6 8) Ruby eqv [7] pry(main)&gt; [1, 2, 3].map { |x| x + 1 }.map { |y| y * 2} =&gt; [4, 6, 8] Its very possible you can do this in ruby. I would be excited to see the example.
This [blog post on the Expression Problem](http://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/) explains it better then i could. I, as you suggest, might not understand the situation. For a quick example of what i was refering to, in ruby i can't use a proc/function to dispatch to different actions: foo(x) if x is a string were going to add a "1" to the end foo(x) if x is a number were going to square it. The only way i can get this behavior from foo is if i have two classes that implment foo in different ways: stringer.foo(x) if x is a string were going to add a "1" to the end number.foo(x) if x is a number were going to square it. 
Ah, yeah. Effectively there's a distinction in Ruby between "method dispatching" and "thing-dispatched-to". Procs, blocks, and lambdas are all things-dispatched-to, and so are not where you would look to impact method dispatching. Ruby instead approaches the expression problem via things like open classes and dynamic method dispatch at runtime, so it's not quite true that "The only way i can get this behavior from foo is if i have two classes that implment foo in different ways". You could do things like have one class with different methods defined on the eigenclass of the class instance, or forward invocations to different blocks at runtime based on arguments (there are a couple of different ruby multimethod gems implementing this idea), etc
The Ruby Facets gem has what you're looking for as an extension to Proc: https://github.com/rubyworks/facets/blob/master/lib/core/facets/proc/compose.rb
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [rubyworks/facets/.../**compose.rb** (master ‚Üí e799e41)](https://github.com/rubyworks/facets/blob/e799e413fd05584b2dfda5dad98d349b1d7e8ae5/lib/core/facets/proc/compose.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlgdm0g.)^.
That makes sense. I wasn't trying to make a point about the complete set of ways you could get that behavior. More that its not easily built into the language. I can get any behavior i want from any language with enough elbow grease. I never thought to look for a gem. Thats a cool idea. Thanks!
Wouldn't that just be a pure lambda function?
Thats great. I might try that out!
Why are they necessary?
How else would you recursively filter out unwanted paremeters? 
Huh. Neat. I would like to see ruby implement a pipe syntax like what elixir has. I think that'd allow for some really interesting stuff.
For instance: def submit_form(foo: nil, bar: nil, baz: nil) # ... end class SomeController def update submit_form(**params) end end Is the `submit_form` method vulnerable to unwanted parameters?
If you need to whitelist attributes in a nested hash. Also, it's a huge anti pattern to have giant lists of formal parameters
what just happened?
Mind pointing me at an example? I'm not well educated on elixir
Here are a few: https://elixirforum.com/t/pipe-operator-and-functions-not-function-calls/782/2 
I'm self-taught and I bet you a pound to a pinch of shit that I'd give you a run for your money.
What's do you have to base that but on?
What do you have to base that bet on? (FTFY) The fact that you assume yourself to be better at programming than people who learned a different way than you, I often find that people who have the confidence to assume themselves better than someone else have ill-founded confidence.
To be fair on this.. "classic" type code, like I use in Sinatra username = params['username'] password = params['password'] ActiveRecord @user = User.new(user_params) private def user_params params.require(:user).permit(:username, :password) I have a very hard time with the view that the latter is better. It's far more verbose, and it's only "more secure" based on the assumption that we're going to be using the Active Record pattern regardless.
rather than cross posting the question here as well as stackoverflow, it might be better to include more info on the question. All it is right now is your code and the statement "what am I missing". You should say what exactly is not working. 
I am confused ... reject does not return nil if nothing was deleted. It returns a new array with the same values as the original . `[1].reject {}.to_a == [1]`
The mistake the author made which let him discover the bad parts was simply taking symbols for granted. It doesn't mention anything fundamentally wrong with using symbols.
How about a more reasonable 20 fields? Your examples thus far are trivial :/ I have no problem with what you're doing for ~3 fields. And what if you use some better param organization that throwing everything in the top level
While I agree with you, you're demonstrating quite the level of arrogance. But anyway, my original comment is based on what I've witnessed with bootramps grads and self taught people in general being very junior. Nothing wrong with that. I was also very junior coming out of college. The reason why specifically called out these two groups of people over all new developers is that I tend to see a yet-to-be-learned understanding of what is going on underneath the frameworks they're using -- a computer science and software engineering shaped hole in their hearts has barely started to be filled. I was not saying that across the board all people are a certain way all the time, that's rediculous. One my best friend has taught him self to code, and he's doing very well, and also very focussed on the computer science side of things.
Your example of the "old vs new hash" syntax is confusing and wrong: &gt; `my_hash = {user_name: 'Tom Cruise', age: 52}` &gt; `my_ugly_hash = {'user_name' =&gt; 'Tom Cruise', age =&gt; 52}` * `'user_name' =&gt; ...`is a **string** key, not a symbol. * `age =&gt; ...` is a variable/method (?!), which you have not defined. You should have written: my_ugly_hash = {:user_name =&gt; 'Tom Cruise', :age=&gt; 52} --- Also, by the way, the `key =&gt; value` syntax originated in **perl** I believe. Ruby and PHP both took inspiration from this older language; Ruby did not copy PHP here (and vice versa).
Thanks for noticing Tom I corrected the article.
I actually just made a benchmark yesterday comparing hash access where the keys could be: symbol, immutable string, mutable string Symbols are the fastest.
Would be happy to link to it if you want to put it online
You're still missing the point, a little... The following hashes are **equivalent**: {user_name: 'Tom Cruise', age: 52} {'user_name': 'Tom Cruise', 'age': 52} {:user_name =&gt; 'Tom Cruise', :age=&gt; 52} These are all using **symbols** as keys. The `key: value` syntax was added in ruby version `1.9` by the way, not `2.0`. This hash is **different**: {'user_name' =&gt; 'Tom Cruise', age =&gt; 52} This is using **strings** as keys.
I understand Tom, I think I wrote exactly that in the article 
What I tried to emphasise is that the new way ALWAYS uses symbols as keys while the old way usually used strings (though it could have used symbols as well as you wrote). Hope it's clearer now :)
A 20 field example then includes a 20 field permit function. It may end up being less characters but I'm not convinced it ends up being easier to read or write.
The old way did not "usually use strings" The `key =&gt; value` syntax is generic; you can use **any** object as the key. You can use integers, or arrays, or other hashes, or regexes, or classes, or essentially *any object*. (Technically, any object that responds to the `#hash` method.) Developers would still prefer symbols over strings when possible, though - for precisely the reasons you outlined in the blog post.
Apologies. Forgot the bang on those rejects. `delete_if` is an alias for `reject` that does the same thing. `reject!` will return nil of nothing was removed.
i dont get the article. he made a wrong assumption about de/serialization and that's about it. Btw. JSON.parse has :symbolize_names for this. RoR has Hash#symbolize_keys. But Yaml.load has nothing :)
https://gist.github.com/NullVoxPopuli/2cfbc5c28e2170530b25f279b7e8375d
so, you prefer pulling every value you want to use in a hash out to a variable?
 x.report('symbols') { symbols[:a] } x.report('string') { strings['a'] } Your benchmark is a little mis-leading, because the first line is re-using the existing `:a` symbol, whereas the second line is creating a new `'a'` string for each lookup. So in other words, you're not just timing the hash lookups; you're timing *creating the object, and then* performing a hash lookup. In addition, this part of the test is pointless: strings = { 'a'.freeze =&gt; 1 } un_frozen_strings = { "a" =&gt; 1 } Ruby will *automatically freeze the strings* when used as hash keys. (Have a play in the console if you don't believe me!) --- ... To be fair, real-world code probably *would* create new `String` objects for each hash lookup - so your results are actually useful. I just wanted to clarify exactly what these benchmarks are showing.
I'm totally open to updates to the gist, if you want to copy/modify, and paste your updated results :-) But, I did notice that the benchmark runs in certain scenarios were very close to another, and what you explained explains that behavior. thanks!
Maybe later... I'm very busy at work today; I probably shouldn't be on reddit :D
I think that posting the link is better because all the answers end in the same place.. the post is pretty clear IMHO.
This isn't an advertising platform for drumming up support for your question.
Eh, what are you using for serialization? I believe if you are using AR with type :json or :jsonb in MySQL or postgres, it actually WILL let you access the hash with "indifferent access". I could go and check this instead of lazily making this comment without being sure... but why didn't the OP even include code on _how_ he's serializing json to the db (manually or using what framework features) -- that matters to how it will behave! But yeah, you do have to be aware of the semantics of the data you are using with regard to strings vs symbols. 
I've seen questions about usage of gems or related in the subreddit.. that doesn't mean to spam here with questions every week.
I guess? You can't do it right now. Basically I want this to raise an error: a = "hello" pure_lambda do puts a end.call Right now you can modify the output of the blocks by modifying the outside context. I talk a bit about why I want this in this talk towards the end https://www.youtube.com/watch?v=xii1oyad_kc 
No, in Vietnam, ruby on rails jobs (with angular/react) is not much compare with c# / java, but they keep rising.
It most definitely will not , at least not the pg gem used with AR. I think that autometically converting everything to HashWithIndifferentAccess is too big a performance hit, Rails can't just decide to do that for all applications.
&gt; How about a more reasonable 20 fields? Your examples thus far are trivial :/ We can solve that problem the same way we always solve that problem in software: use a data structure.
My example isn't meant to be considered a valid approach; it was meant to be the shortest way to demonstrate that a simple method dispatch can inherently filter out unwanted parameters. Strong parameters are a countermeasure to a problem that doesn't _need_ to exist.
AFAIK the JSON(B) Postgres type can only save JSON data, so no symbols (as they don't exist in JSON) and no HashWithIndifferentAccess (as you can only serialize primitive objects into JSON).
Yep, you're right, I just tested. I had seen some code when source spelunking that made me think it did, hmm... Looks like ActiveRecord::Type::Json and ActiveRecordType::Jsonb [use the](https://github.com/rails/rails/blob/0e94a1d3380b50f01b3217bbc5a5edc154ebfc4c/activerecord/lib/active_record/type/json.rb#L26) `ActiveRecord::Store::StringKeyedHashAccessor` Looks like it's factored such that you could probably easily make your own type class that used the already existing [ActiveRecord::Store::IndifferentHashAccessor](https://github.com/rails/rails/blob/15ef55efb591e5379486ccf53dd3e13f416564f6/activerecord/lib/active_record/store.rb#L170-L179) instead. I doubt it would have any impact on performance other than when reading attributes, and probably only slight there. But maybe i'm wrong, and there's probably some reason they didn't choose this as default (but still oddly included the pieces to do it!). I've been messing around with the ActiveModel::Type::Value stuff for my (possibly to be renamed) [json_attribute](https://github.com/jrochkind/json_attribute) gem for json-serialized attributes on your AR models, supporting nesting/compound strutured models serialized to json. 
This seems more like _the bad part of dealing with json_ than the _bad part about dealing with symbols_
but then we're back at strong parameters?
I believe that with JSONB, the content is only parsed when saving, while JSON column are also parsed every time it is loaded. Functionally they are the same.
Not at all: class UsersController def update update = Update.new params.each do |name, value| update[name] = value end # ... end Update = Struct.new(:username, :password) end
But that then serves the same purpose and similar usage as strong parameters, so what's the difference?
Yaml preserves symbols so it doesn't need it.
I disagree, I don't think you'd run into this problem in java, javascript or php. Simply because hash keys are strings, there's no alternate symbol syntax.
Yes, this x100. 
It serves a completely different purpose. Strong parameters are only needed because it's common to feed params directly into ActiveRecord methods like `update` that accept an arbitrary hash. Strong parameters is a workaround, not a feature. It allows primitives (i.e. a list of symbols) to control an otherwise uncontrollable API centered around yet more primitives. The better approach, 100% of the time, is to encapsulate the form submission handler. You have to understand the presumption that strong parameters makes -- that the underlying model layer is controlled via a giant hash API that is allowed to trove through a relational database schema. That is a horrendous assumption for a controller to make about the implementation details underneath.
Tautology incoming: The right length for the method is _the right length for the method_. Rather than setting rules or goals for LoC per method, it's best to consider each method independently. Methods that "do one thing well" might be 20 lines long, under some circumstances. Conversely, I've seen some two line methods are handling two entirely distinct concerns and suggests the design may need to be reworked.
Strictly speaking, if you don't know how the text is encoded, you don't know what it says. You can't reliably gsub it as that would assume it to be a superset of ASCII. You can't serve it to humans, because you cannot reliably transcode it to whatever encoding your (HTML) view uses.
I don't pass params directly to models. I have 'services' (I call them operations) that then determine what to make the model out of. The controller always whitelists before sending to the operations. I still don't understand the difference between your approach and strong parameters, they're doing the exact same thing. Is your argumen just that you don't like how most people use strong parameters?
Do you mean that in java, javascript, and php, you'd always be dealing with strings, so you don't encounter it? That's not a problem with symbols. If you have a hash with integer keys, those are going to be converted to strings when serialized. Is that a bad thing about integers or about serializing to json?
&gt; be aware of the semantics of the data This is really the key here. Using symbols is no different than using integer keys. Both of them are converted to strings when serialized to json.
No, my argument is that the feature is unnecessary. It is unnecessary to use an ad-hoc parameter filter. That's what strong parameters are. Strong parameters are only necessary as long as the _receiver_ of the user input allows unfettered access to the entire database. If you change the thing that receives the user input such that it is only capable of changing what is relevant, you don't need strong parameters.
In general I agree, which is why I didn't think of it til the end, but if the case is trying to remove timecodes from a formatted 'subtitle' file, and the timecodes are strictly ascii, you might be able to get away with it. 
But you just gave several examples of parameter filters? Do you not like the feature bloat of adding strong parameters to rails?
With permissions, I would think that the permissions object should be a dependency of the command, not the user. The command example has to _ask_ the user if the user is authorized for the command, which seems wrong. It should _tell_ the permissions object to authorize an action, e.g. class Command def initialize(user, permissions) @user, @permissions = user, permissions end def call @permissions.authorize(@user) do # etc. end end end
I didn't give examples of parameter filters. I gave examples of approaches that don't require parameter filters, because there is no interface underneath that allows unfettered access to the entire database. This isn't about feature bloat, it's about an elaboration that is unnecessary. To put this another way: why aren't strong parameters a necessity for general purpose programming? What is it specifically that causes Rails to benefit from the feature? It's because `some_activerecord_model.update(params)` _could_ conceivably change anything about the underlying database, including unrelated tables that can be traversed over nested associations.
yup. You can use rubocop rules as a guide if you like, but slavishly following them is neither necessary nor sufficient for good code. I am not a fan of the cult of rubocop. 
is this a rant about symbols, or about ruby hashes not directly serializing to JSON and vice versa? 
Agreed. I've never found rubocop useful. In my experience, practices and habits are best disseminated through face to face collaboration.
["Considered Harmful" Essays Considered Harmful](http://meyerweb.com/eric/comment/chech.html)
Every year, +5 articles are posted about the ActiveRecord and N+1 issue. It's as boring as mixing "ruby" and "webscale" in the title. I've had to describe it at least in 2 interviews. IMO if the rails team hasn't addressed this yet, it's on them. Countless libraries have been in use for years to solve this, like bullet or rack mini profiler. Just add it to the standard Gemfile, other useless libraries have been added for less. 
If this article was shorter, I would have had an easier time understanding its points.
Rubocop helped me change some stuff that worked but could be refactored to be a bit better. I don't follow the length guides strictly though. 
Title is shit but I avoid editorializing things I submit. However the content is worth reading.
Yeah, the article isn't bad, but the title is gross. Thanks for posting!
Small Articles Considered Harmful
I'm also about to try for the first time a javascript framework on top of Rails 5. I still don't know which framework I will try. I am getting really tired of writing soupy jquery stuff and I definitely feel like some standard boilerplate code would really be a help. Did you ever get your React with Rails going ? Want to share any links for documentation ?
Unfortunately, what I learned back in 2006-2009 might not be as applicable as it used to be. I don't want to learn that language again lol
attr_accessor instead of accessories? 
Sorry, I think that was autocorrect. I am on the phone. I think the problem is I need to person.age = 25 Now I can puts person.age
Remove equals sign from the second line. See [attr_acessor](http://ruby-doc.org/core-2.0.0/Module.html#method-i-attr_accessor) docs.
attr_accessor is a method, you are passing it a symbol argument, do not use equal sign.
Sorry, I didn't have the equal sign in my code
Sorry added that on the post by accident
Actually, attr_accessor generates only reader and writer methods but it doesn't generate constructor. Thus, you have to provide constructor if you need. There is a common idiom to generate class with attributes and constructor with positional arguments: Person = Struct.new(:age) person = Person.new(25) person.age #=&gt; 25 person.age = 27 person.age #=&gt; 27 But providing explicit constructor look a way better.
pls it's important
It seems your user doesn't have permission to modify the files in your ruby-2.0.0 install. You can either try: sudo gem install compass which is not really advised in general (since you're installing as root) or you can chown the directory (REPLACE &lt;user&gt; and &lt;group&gt; with your current user and group!): sudo chown -R &lt;user&gt;:&lt;group&gt; /Library/Ruby/Gems/2.0.0 # now you can install compass since you own the folder gem install compass
Maybe this one? https://github.com/DamirSvrtan/fasterer/issues/44#issuecomment-321390399
That helps, thanks
&gt; FIXED IT, I FORGOT TO RESTART THE TERMINAL :)) 
I would checkout [rvm](https://rvm.io/) for gem management as I believe it would just solve this issue. I think that brew (while awesome for most things) has a few problems that are pretty annoying in general specifically regarding permissions. In this case that ruby package does not seem to be properly configured for some reason (or does not expect installations of further gems).
Doesn't really make sense, honestly. They're generally dependencies for a reason. 
Through a different discussion, I think I have it narrowed down to [react-rails](https://github.com/reactjs/react-rails), but I've not set it up yet. Failing that, I guess I'll try creating a separate React app for the front end, and calling Rails API endpoints. Maybe the Vue integration is more straightforward.
Seems to be simple enough to understand how it works under the hood. NOW, how did you find it?
Thanks, I saved the link for later. I still cannot make up my mind which framework to invest in : Angular, Vue or React .. and then there is all the different flavors and ecosystems of each one.... I write midsize to small projects (200k lines code to 5k), I know I need use one of them eventually, but which one is still up for debate for me 
In my experience, the issue is that method line length or algorithmic complexity factors do _usually_ point out code that could be improved by refactoring. But you can refactor to make the metrics happy while actually making the code _worse_, just by sort of robotically extracting methods and classes. Arriving at the sort of thing mentioned in the OP. _Or_ you can spend a lot more time really thinking it through, thinking about your developer use cases to really get the right abstraction, and meet metrics with an architectural improvement. The second one is _hard_, and as the OP makes takes domain knowledge you might not have yet, and even if it's right for "now" may make refactoring later _harder_ if you didn't get the abstractions right. And it might just not be _worth it_ even if you do manage to come up with something better that will stand the test of time. The previous code might have been _good enough_ despite failing rubocop or other metrics (or might not be, you've got to use your human brain). So the "correct" decision might be "Yeah, it _could_ be made better, _if_ I was sure what the right abstractions were, but it's _good enough_ for now, it's not disastrous code." But human nature is to prefer the easy way out, and to prefer _not_ to mark a code as ignored-by-this-rubocop-test, cause that feels like an admission of defeat. I think the only corrective is establishing the shared understanding that rubocop is a _guide_, and that just meeting rubocop metrics doens't neccesarily result in good code/architecture, and can actually make it _worse_ if you are just programming to the metric. (It actually just occurred to me that this is another example of that principle where people working to metrics effects results and makes the metrics no longer valid measurements. I forget and can't find the name of that principle, anyone? A more common example is with educational testing). 
I think it makes most sense to contibute to projects you personally use. So you can go over the list of gems in your Gemfile, and check on GitHub whether the ones you actively use need any help.
From my point of view, contributing to monster/mature gems is not the right way to contribute as a beginner. Just by checking the lib folder of 'mail' or 'prawn' to get a sense that someone not used to code and/or read complex applications will have a hard time, even if they use them consistently with Rails.
The talk helped me understand better what you were asking about and how its different from what i suggested. Very interesting stuff.
Yes. attr_accessor expands to both a getter method and a setter method. It does not setup an initialize. You have to set that up on your own if you want to initialize with defaults.
A good read. From experience I would say that they trend to small functions is a symptom of a poor understanding (or lazy application) of OOD. I've seen many programmers with an inability to recognise when a set of functions are cohesive and provide a valuable abstraction, or that they are indicative of a domain type - indeed small functions and primitive obsession tend to go hand in hand.
I'm using it on every of my commit... :)
Janko is right. Found a gem you use, with issues, maintainer and "simple" codebase. 
This reminds me of why, in areas generally outside tech, I've long called myself an "anti-extremist extremist". Too easy to fall into extremes of slavishly following the tools, though. RuboCop and ESlint have easily cost me two staff-weeks this year alone.
thank you for this "gem" ( ;) ), I will definitely check it out; looks useful
Can it properly handle composite keys in database now?
This is also largely a legacy issue. The reason `JSON.parse` defaults to string keys is because Ruby didn't used to GC symbols so an external attacker (or a bug) sending a bunch of random JSON keys to your app could run you out of memory.
&gt; Your benchmark is a little mis-leading, because the first line is re-using the existing :a symbol, whereas the second line is creating a new 'a' string for each lookup. That's not true if you are on a relatively recent version of MRI (&gt;= 2.2). A string used as a literal hash key is frozen and reused. `1000.times { my_hash['a_key'] }` will only allocation the `'a_key'` string once. 
Usually you do something like this: In your model: `serialize :my_jsonb_column, JsonWithIndifferentAccess` In `lib/json_with_indifferent_access.rb` class JsonWithIndifferentAccess def self.load(data) self.indifferent_access(data) end def self.dump(obj) Oj.dump(obj, mode: :compat) end private def self.indifferent_access(obj) if obj.is_a? Array obj.map!{|o| self.indifferent_access(o)} elsif obj.is_a? Hash obj.with_indifferent_access else obj end end end 
The code does work ... 
Yes, I got it working now. Thanks
yep, me too.
&gt; The syntax for ruby lambdas differs from other functions, making it somewhat awkward to write large lambdas (more then a single line). Nah. lambda do |arg, keyword:, **whatever| #as many lines as you want # you can even: return whatever end Doesn't really differ much, not really awkward. Are you talking about the `{|arg| }` syntax or the "stabby" `-&gt; {` syntax? yeah, some of the syntaxes are move convenient than others depending on what you're doing. 
Yeah... still not buying it... This kind of article says... yea... small functions and DRY code are good in 99% of cases... but be on the lookout for that all important 1% where it is not... I find it a stretch of Sandi Metz talking about duplication being better than the wrong abstraction... I think the point Sandi was trying to make is that a little duplication is ok while you are initially solving the problem, but then the 'design' gets better because your testing allows you to make code that is easier to 'change'... and in order to change it... it has to be easier to understand. Platitudes like 'use common sense' don't really help someone new at code tackle complex problems... TDD / BDD / Small Functions / DRY are things people can grasp quickly and use their entire coding lifetime... 'use common sense' is about as productive as 'work hard'... or 'be attractive'... or 'don't be unattractive'
My understanding is different to this. When you use a string as a hash symbol, ruby will *duplicate the object*, and freeze it. This has been the case for a very long time; probably even since `1.8`: original_string = 'foo' =&gt; "foo" original_string.object_id =&gt; 70190539540580 original_string.frozen? =&gt; false hash = { original_string =&gt; 'bar' } =&gt; {"foo"=&gt;"bar"} hash.keys.first.object_id =&gt; 70190540064200 hash.keys.first.frozen? =&gt; true The purpose of this object freezing is not to "allocate the string only once", but rather to ensure that the hash keys *cannot be mutated* (even by accident). If you do somehow mutate a hash key, then you'll need to call `Hash#rehash` in order to reindex it: a = [ "a", "b" ] c = [ "c", "d" ] hash = { a =&gt; 100, c =&gt; 300 } hash[a] #=&gt; 100 a[0] = "z" hash[a] #=&gt; nil hash.rehash #=&gt; {["z", "b"]=&gt;100, ["c", "d"]=&gt;300} hash[a] #=&gt; 100 It is due to this inconvenience that string keys are treated specially by duplicating and cloning them. (But if you use an already-frozen string as a hash key, then it doesn't get duplicated.) --- With that aside, re-read my original comment that you quoted: &gt; [...] whereas the second line is creating a new 'a' string **for each lookup** My point was simply that when performing a **lookup** with `my_hash['a_key']`, you are creating a new `'a_key'` string each time! However, I suspect that the difference is so negligible (and may even get optimised away somehow??) that it will have little-to-no affect on results. 
&gt; My point was simply that when performing a lookup with my_hash['a_key'], you are creating a new 'a_key' string each time! I don't think you are understanding what I'm saying. When you directly use a string literal as a hash key: `my_hash['my_key']` or `{ 'my_key' =&gt; 6 }` The interpreter detects this and will freeze the string so it is only allocation once no matter how many times those lines are hit. Here is the commit: https://github.com/ruby/ruby/commit/779ae78995977305aa5aec9cb5b562dcf54c22e7 
Ahh... Yeah OK, fair enough. The parser does optimise this: https://github.com/ruby/ruby/commit/779ae78995977305aa5aec9cb5b562dcf54c22e7#diff-6d840db07406437770b610102b284273R4917 $1-&gt;nd_lit = rb_fstring($1-&gt;nd_lit); You can still force it to create a new string if you define this as a non-literal though. It looks like this optimisation was added to ruby `2.1`?
&gt; It looks like this optimisation was added to ruby 2.1? It was added in 2.2. require 'benchmark/ips' hash = { a: 1, 'a' =&gt; 2 } Benchmark.ips do |x| x.config(time: 5, warmup: 2, iterations: 1) x.report('symbols') { hash[:a] } x.report('string') { hash['a'] } x.compare! end # 2.1.5 Calculating ------------------------------------- symbols 149.741k i/100ms string 130.289k i/100ms ------------------------------------------------- symbols 8.922M (¬± 4.8%) i/s - 44.623M string 4.739M (¬± 4.1%) i/s - 23.713M Comparison: symbols: 8921602.8 i/s string: 4738597.1 i/s - 1.88x slower # 2.2.3 Calculating ------------------------------------- symbols 146.333k i/100ms string 146.272k i/100ms ------------------------------------------------- symbols 9.033M (¬± 3.9%) i/s - 45.217M string 7.784M (¬± 5.5%) i/s - 38.762M Comparison: symbols: 9033282.1 i/s string: 7784288.4 i/s - 1.16x slower
&gt; Are you talking about the {|arg| } syntax or the "stabby" -&gt; { syntax? yeah, some of the syntaxes are move convenient than others depending on what you're doing. I was and I was unaware you could write lambdas using the long form block syntax (or whatever its called). All the examples I saw were the other way. This is an improvement as it improves readability. 
hey, send me a PM. We hiring interns. Most of the time, we are searching via universities, rails girls/ and workgroup around the world. For the last few years, we get interns, male and woman and we try to help them. least I can help you. We are not a big company :). And if we don't have any free space this year, I will give you some help for free. Edit: I edit because it sound that we biased against males, so I don't want any PC replies :) Edit1: Position is irrelevant 
Yep, it's ruby "block" syntax. It can be done with `{|args| ... }` syntax or `do |args| ... end` syntax. The only difference is the order of operator precedence, they both create a block. You're right that `{}` is usually used for one-liners, `do... end` usually for longer ones. You _can_ use `{}` with a multi-line body, but I agree it doesn't look right, and it's order-of-precedence for parsing may make it apply to a different method than you want, unless you use parenthesis further making the code look obtuse. There are many ruby methods that take blocks. Such as the common `each`. A block is a _syntactical_ construct for passing a closure to a method. # same thing some_list.each { |a| puts a } some_list.each do |a| puts a end `lambda` is a built-in method that takes a block and reifies it into data that can be held in a variable. my_closure = lambda { |a| puts a } my_closure.call("foo") # =&gt; "foo" to stdout via `puts` # pass a block arg to `each`, where the block does nothing but # delegate to the closure we just created: some_list.each {|a| my_closure.call(a) } # or a shortcut, turn a lambda back into a block argument for `each` # method directly: some_list.each &amp;my_closure `proc` is another built-in method that does the same thing, although there are some semantic differences between a "proc" and a "lambda", with regard to internal `return` and argument checking. But they are both built-in functions that take a block argument, and reify it. (The other way to "reify" a block into data is in a method that takes a block argument, it can include `&amp;param_name` at the end of it's argument list, to reify it's block argument into that local argument variable. This will be of 'proc'-type rather than 'lambda'-type. The 'proc'-type closure is really designed for block arguments, and it's weird semantics are designed to make them more convenient. 'lambda'-type behaves more traditionally like one would expect for a closure referenced in a variable). I assume the OP book will explain all of this, but I haven't read it. :) But yeah, I can see the purpose of a relatively short book focused on ruby closures. They are actually kind of the heart of the language, I think the block argument syntax is a lot of what makes ruby ruby. 
That is really nice of you to both personally engage with young folks to help them with their development problems - and to be upfront with regards to your employment policies vis-a-vis women in workplace getting preference. Hopefully you are not based in the US - since this is probably grounds for discrimination (don't know whether it applies at the intern level, though) Good luck, though.
I am a bit busy now - but will be relatively free by the end of the week - when i would be happy to help you add those features to your rails app. (either pull requests or through a co-development session ) But i could post some links specifically relating to adding oauth support to devise (and the respective gems) + API development with rails (which is built in to rails 5) if you think it will be helpful. Let me know...
Is not 100% female. Last 3 years was like this: - male - female - female - male - male - female Every one is doing a six month period. We have a pool from different universities. I'm looking at rails girls to see if there are any people willing to start. I do not try to discriminate based on sex, I just try to help inclusion of woman in tech. Is this make me a bad person? Also, paying for pizza and attend to rails girls makes me a bad person... As I told, we are a small team, currently in a perfect ratio of male/woman. 
your statement that you prefer to hire *women* is discriminatory and creepy.
Ok, I will re phase it to make it less creepy :) I do now want to sound discriminatory and creepy
That's good. As someone who has mentored folks for more than 20+ years now (am a bit old :-) i usually try to give preference to folks who really are interested in coding and problem-solving and usually i find men more interested in coding, but i also found that women tend to bring an emotional maturity to the task at hand which is invaluable in the long run. I found that one key to a diverse workplace is to set a good culture and put a lot of emphasis on respecting each other - since we all bring a diverse set of skills to work. You probably have evolved your own culture - good luck with that.
that's correct, people with strong problem solving are great, we do put a lot of emphasis in respect. And is really nice to have a diverse team. Men and woman, different cultures, it make us better :)
1. Write a program that interfaces with the barcode machine to read information about officers from their Entry cards (this all depends on what kind of interface the barcode machine offers) 2. Make your program store the information (sequel, activerecord, mongoid, ..) 3. Make it run in the background (sidekiq, resque, ..) 4. Add a GUI or CLI (rails, padrino, fxruby, clamp, gli, optionparser, ..) 
Wow! Thanks folks, I really appreciate it! &lt;3 Oh, and any Ruby enthusiast who wants to have a coffee-chat, please write me as well! :-)
I would have just settled for a much simpler (asymmetric) timeline. Something like: 1 day before, 3 days before, 7 days before, 1 month before, 6 months before, .... I'm not sure why you'd need more frequent reminders further away from the event. Still, looks like a fun algorithm to solve your requirement!
Most barcode readers present as a keyboard, so I'd recommend getting such a device, rather than one which presents in a proprietary format. The benefits of doing so are numerous: * It makes it easier to test the software (since you can just key in the code manually) * It makes it easier to cope when a barcode is unreadable (faded or fractured card, for example) - again you can just type it in with a regular keyboard * It makes it easier to switch out when the reader part fails
To meet Ruby folks in Berlin, it's always a good idea to visit the monthly Berlin Ruby User Group meetup called [RUG::B](http://www.rug-b.de/). You will find the many of Berlin's Ruby people there to have a chat or even give a talk. A lot of the people organizing local code schools or Berlin's Rails Girls chapter can usually be found there and can help you find an internship or even a junior position. The meetup is always on the first Thursday of each month.
You're assuming [`Array#[]`](https://ruby-doc.org/core-2.4.0/Array.html#method-i-5B-5D) but it's actually [`Integer#[]`](https://ruby-doc.org/core-2.4.0/Integer.html#method-i-5B-5D) which gets the integer's nth bit. If you actually need this, go with a more rubyish solution [like the one in your link](https://stackoverflow.com/a/8377194): `[0, 1].repeated_permutation(8).to_a`
I totally took the repeated_permutation method as the "built-in" ruby solution for permutations. But was far more interested to see how they solved it without using a built-in method. Thanks for the Bit Reference api reference.
Answer: By using spring ;)
Or why they don't collect all necessary information during checkout.
Kind of a lackluster line-up. I don't think I'll go to this one.
I do not know what I have expected... 
I started working on a gem and a bit of background on it's purpose. I'm a fan of some of the things React components can do. However, I am not a fan of the javascript involved. I'm also not a fan of Javascript Frameworks. While I do see the benefits of them and have used/willing to use them, there is some applications where the added architecture is just not needed. So, with Simple Bind, which is really just a PoC at the moment, I'm aiming to give the frontend a sprinkle of unobtrusive JS with data binding form inputs to other elements. It is definitely a WIP. TODOs is to build out functionality of all different input types as well as some customization for what the bind updates. Also looking to build some html helpers around the binds. Also need to write the specs for various form helpers (i.e., simple_form and formtastic) as well as Turbolinks (which should be supported out of the box).
Looking forward to this one!
Some time ago, I've [published](http://zverok.github.io/blog/2017-01-22-dry-rspec.html) an article with several ideas on what could be added to RSpec to make specs DRYer. Now some of the parts are battle-tested on several projects, tested, documented and released as a gem.
Thanks! I'll check it out! :-)
I can't wait for the next blog post of this series, "how I fixed a weird flaky test by turning off spring." :-)
I got used to running `spring stop` when something misbehaves.
I actually think the lineup is good for a regional conference. The session titles already listed show a pretty good amount of technical talks, compared to a lot of other conferences.
You kidding? That top two rows are already full of some amazing speakers. It only gets better when you scroll down. 
I dont have a copy but I think this might get you by https://web.archive.org/web/20160310160256fw_/http://www.brpreiss.com:80/books/opus8/html/book.html
It's the second half of the year, I want to hear from Ruby core devs, not nitpicking crybaby bloggers like Avdi. You realize the good stuff usually happens around christmas? I've been around Ruby for more than a decade and a half, so I kinda see some of the patterns. Conferences like this will be littered with non-technical, uninteresting blog posts masquerading as talks. I love ruby, I really do, probably more than most of this subreddit. I just hate that the community has devolved to the point where someone writes a RESTful wrapper of something and are paraded around like viking developer warriors. On top of ALL that, it's across the entire country and is only a day and a half long, and is $200 a head. Downvote all you want I suppose, and I appreciate hearing the /r/ruby perspective on it, but by any objective description it is a boring lineup.
I don't know. I kinda love the Ruby community for taking non technical talks seriously. Programming is the easiest thing I do all day, the rest of it is me struggling with trying to be a great individual to the rest of a team. I love to hear a technical talk then hear about some feels. Have it oscillate for a couple of days and: BOOM. Conf over. Although, I live in a place with sane housing pricing so my drive is about as long as your flight. 
&gt; Some kinds of those services require plenty of additional data as well. We don‚Äôt ask for them before purchase because that would lower the conversion. 
&gt; but by any objective description it is a boring lineup. I completely disagree. I think it's a great lineup. I run a conf. Ernie spoke there, it was an amazing talk. I've seen Avdi and Kinsey. Both great speakers. BTW keynotes are supposed to be non-technical. I go to talks to hear from speakers who have unique stories. I want to hear storytellers, not have someone recite a readme to me. If you want to hear from Ruby core devs, you go to where they live: Japan Ruby Kaigi is in September. I'm a waitlist speaker i'll be going. Then I'm flying to speak at Rails Club in Moscow right after. If you want to change the community try organizing your own conference, or submitting to speak at conferences. Or both! It's what I did. If you want to see extremely technical talks, go to an extremely technical conference. Posting in order to "yuck" the TN Ruby developer's "yum" isn't terribly productive. 
I don't install spring altogether `rails new --skip-spring ...`
Is Structure correct? Or did you mean to type Struct?
Sure, it should be struct 
This blog post could have been one sentence. &gt; I added the spring-commands-rspec gem found here: https://github.com/jonleighton/spring-commands-rspec .
Drawers, skinny controllers ;)
This question has been answered countless times. Ah, the good ol neglected search bar
Solidus/Spree ?
It's a common and simple tool, and it seems like a frequent occurrence where I run into a pain point and can resolve it with a common and simple tool. I love the ruby community. 
TL;DR spring-commands-rspec gem. https://github.com/jonleighton/spring-commands-rspec 
It‚Äôs always nice to see new, simple gems appear. I would have loved to know early on though that it‚Äôs only for Rails. Rails may be highly popular but it‚Äôs far from being the only server-side framework in the Ruby ecosystem. On your gem‚Äôs website, the reader only learns at the About page that it depends on Rails. To provide better context, maybe consider mentioning that requirement in the docs too, if not even on the start page? 
I plan on making it more agnostic to the framework later; supporting Sinatra as well. Haven‚Äôt gotten around to it yet though. Until then, you‚Äôre right!
I would love to get your help on some little projects of mine, but I'm not sure if you're looking for larger projects?
Yes, I'm in. I'm looking for some small projects for now, as I've to get some time from my full time job. Assuming that these are public repositories.
Not sure with C# but a load of Java, especially with the gaming industry here (Betson, NetEnt, King, Etc).
There's a website called https://www.codetriage.com, it's been built exactly for searching for os projects to contribute :-)
Needs more details
Rails itself. 
Improve test suite speed by 500% by not using factories everywhere.
I met Steve at a RubyConf a few years ago and told him how frustrated I was that an open source project of his monkey-patched NilClass. He laughed at me. I didn't know him well but met him a few times after that and he was one of the most welcoming and encouraging people I've ever met.
Changed the title to "The Longest Email I Ever Sent (Programmatically)" but can't modify it on Reddit. It's a blog post about a bug that caused a super long email to be sent out from a service I run. I go through how the bug existed, how I found it and how I mitigated it. There's some lessons learned stuff in there at the end if you are sending out emails in a background worker. 
For me the biggest win has always been [parallel_tests](https://github.com/grosser/parallel_tests). Using all 8 cores sweeps away all the other minor optimizations.
Maybe an unpopular opinion, but I use fixtures on the largest app I work on (over 60,000 LOC). I don't really know, are fixtures considered too old/lame nowadays? I've heard people complain about them, and we do use factories on some other apps, but fixtures just seem so easy/fast. Also for randomness we can use Faker.
I really don't want any randomness in my tests.
Me neither honestly, for most fields. Overzealous devs have fucked up the suite on multiple occasions by putting faker in things we need to be static like api keys... I was mostly wondering if any of y'all use fixtures still.
You and I are now best friends.
parallel_tests is awesome. Just a bit hard to get stdout looking good with it.
Goodbye Steph. You were one of my oldest "ruby friends", I will miss you. Thank you for everything. Rest well, friend. 
So I suppose I just want to rant. I ran into a bug in Bunny, the RabbitMQ client. I wasn't able to effectively debug this myself so I headed to google to search for the errors I was seeing. I found several threads from people with the same errors, in each case the developer had explained that instances of a particular object must not be shared between threads. Unfortunately, in my case, my application only has one thread. I couldn't find any more information, so I filed a bug report on Github, clearly explaining that I was seeing this error, that I had already looked at the issues with thread safety, and that in this case my application only had one thread (plus any threads that the Bunny library created). I provided a stack trace of the error including a stack trace of all running threads at the time of the error. Hopefully the issue has already been fixed, and my bug report was a duplicate, however the response from the developer has upset me as I feel that I went to a lot of effort to report a bug and request assistance in the correct manner.
It's alright, though it's not really helpful for beginners - there's nothing really out there that makes it easy for projects to help levels of users - plus - codetriage doesn't factor in time since last update - for instance - some of the projects listed haven't been updated for spree.
I've seen the question answered repeatedly but never in a way that is all that helpful...some projects you'd have to invest hours upon hours just to come up to speed to help.
I have a slow growing (cause I could use some active help) project called [code connection](https://github.com/jemagee/code_connection/) that I could really use some active input on. If you read the *mission statement* you'll see what I'm trying to do, but it is moving slowly...most of the people I found interested in helping were primarily from the JS world intimidated by rails, and the one primary outside contribution I got (username for devise) i believe was just copied and pasted from somewhere else...if you read through the issues, I kind of used them to describe what I'm thinking. I am anxious to get this going but the size of the project kind of freaks me out to work on on my own and I need to be better at using Rails (and JS/Ajax for somethings) at the same time. Anyone is truly invited to help actually
Does that location exist ? 
Looks like he woke up on the wrong side of the bed that morning, can't see anything you did to warrant those kinds of responses, I'd just ignore it and move on, no point in getting angry.
Not everything is supposed to be or going to be easy...... 
It's super hard to keep up with the datastructure when scraping the dom. They make one css tweak and the whole thing starts failing (given data validation is there somewhere). The dom would be ok if they versioned it, but more simply versioning is done at the API level. Edit: I'm not knocking scraping. It's a really useful and powerful tool in the toolbox. Just throwing out my thoughts whenever I consider using it.
Fixtures are fast, right. But, IMO, it is the only advantage. Fixtures are much harder to maintain (and doesn't depend on LOC but on the number of models and associations between them). It's also impossible to use custom _constructors_ with fixtures. And it's a little bit harder to read tests with fixtures - you often have to switch between fixtures YAMLs and test files to figure out what's going on. So, for me _classic_ fixtures don't work. That's why I've built [AnyFixture](https://github.com/palkan/test-prof/tree/master/guides/any_fixture.md)) To sum up, I don't like this "factories vs. fixtures" stuff; they both have pros and cons, why not using them altogether?
I like your blog, it's always something nice to read during breakfast :)
Randomness in tests can be good, e.g. the order in which tests run shouldn't matter at all, so let them run in random order to make sure that it indeed doesn't matter, another example that is good in my mind is quickcheck in Haskell, it can check properties by generating random inputs meaning that you get tests for the cases that you didn't think of. Note that in both cases you can reproduce failures caused by the randomness by writing down the seed and rerunning it with that seed, allowing you to debug things when randomness brings to light tests that sometimes fail. What's not good is flaky tests where you have no control at all about when things fail, so you can't debug things and worse you can't test that you have fixed things.
Should block out some of those emails
I have a multithreaded app but went through great lengths to ensure the client wasn't shared across threads... and still ended up with bugs that couldn't be replicated, random disconnects, and so on. Ended up ditching Rabbit entirely for Redis PubSub and it has been rock-solid since.
You could use the modulo operator to wrap your index. Something like: adjusted_index = (index + offset) % 26 With the index for 'z' being 25 (Ruby uses zero-based arrays by default IIRC) this formula would yield (25 + 3) % 26 = 2. The adjusted_index variable would then point you to the letter 'c'.
I'm the CTO of a company that helps newcomers (currently only in Sweden) with job opportunities. We're 100% open source, you can find our main rails app @ https://github.com/justarrived/just_match_api :) EDIT: Fix link
I'd start relatively simple. I would make a separate class to handle each 'thing', that you maybe call like `EmailSender.new(user).call`. Once you've got that, whatever you do can probably be pretty easily changed later if you need, so if you start there, I think you'll be good. But then I'd probably make an 'aggregator' class that calls all these. `AfterAccountCreationEvents.new(user).call`. Or 'user registration', or whatever. That class could really just explicitly list the things it's calling in code, no need for fancy observers/DI for now. def call SendUserGift.new(user).call SendNewUserEmail.new(user).call # etc end I'd call that 'aggregator' class in the controller. I think this will give you the right amount of structure that you can add more later, refactor, whatever, if you need it, with changes localized. Instead of over-engineering in an attempt to guess what you will need. 
The problem with the parallel_tests gem is that it's wasteful in how it slices. Instead of splitting on features to distribute work it should split on scenarios.
Factories aren't slow, per se. Unintended database interactions make tests slow. Just like we must learn to not write n+1 queries, try not to write features that require database persistence to test.
How would you even test controllers without having non-persisted records? You can maybe test models without persisting them, but that's not a lot of tests.
Everybody who is shitting on fixtures generally don't use them correctly. You can absolutely have a horrible unmaintainable mess because of that. Fixtures should represent absolutely *minimal* representation of your app. For a blog it would be a *one* user, *one* post, *one* comment. If you need to test something that is different than your default fixture, you mutate it instead of adding more crap to yaml files. Alternatively you can use factory to create state you need. http://brandonhilkert.com/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/
That approach isn't particularly robust against failure. If you need each action taken in response to a user signup to happen _at least once_, I would consider using a messaging system that allows each step to be backed by a durable message. That way if any user signup process is aborted, it can resume where it left off.
Does `RECORD_RUNTIME` help with that? I should set it up on our app and see; we have one large feature spec and a bunch of smaller ones so it would fit the profile.
There's always the option of mocking the ORM finders to always return a non-persisted test entity. If going full OO doesn't upset your stomach, it's also possible to wrap all DB interactions in a service object that could be injected into the controller. It's a balancing act between a few guardrails: 1. Inadvertently testing 3rd party code. In this instance, the ORM finders. 2. Creating obscene layers of abstraction just to make the tests more performent.
I did this in two different ways as I developed a couple of different applications. First, I just used a mailer class that was fired from the controller when a user signed up, exactly as /u/jrochkind suggested in an earlier comment. Much of this functionality is built into a framework like Padrino and can be easily integrated with even a microframework like Sinatra. The problem with that approach is that it's blocking -- meaning that your request will wait to return while these other things are going on. And, with web applications that means more time for the user to wait for the page to load. In more recent applications, I started using Sidekiq for this. The approach is the same (you still make a mailer class) just that you call the *worker* from the controller / model instead of the Mailer itself. This queues the work which is then performed in the background and it doesn't block your requests.
The previous code is compatible with queuing messages. There's no reference to how each `call` invocation is implemented. My only complain is with the name of the method `.call`. I would rename the service objects so that their main "verb" becomes their main call: NewUserGift.new(user).send NewUserEmail.new(user).send The reason for this change is: even if now it isn't needed, in the future it might be useful to call several methods in the same Service Object (you could have `NewUserGift::cancel` or `NewUserGift::retry`, for example). If this happens, with the previous implementation, one of them will be called `call` and the other something else, more specific, like `retry`. I think it is more future-proof if you start with the more specific methods right away (you can still have one-verb-per-service for now). 
I would never mock stuff like that. You wouldn't want to directly test 3rd party code, but you definitely want that code to be active in your tests. Otherwise updates to those dependencies can result in a broken app that still has all tests passing.
Yes, good point, using a bg job queue of some kind is a good idea. Not just for robustness, but to get that stuff off of the request-response loop delaying your response. If you are using Rails, ActiveJob with redis/Sidekiq (or just Sidekiq) is a good idea. You still gotta structure how you're going to call these. I'd still, to start, avoid 'observers` or DI. Since the OP asked about that, that's what was in my head. If you were using ActiveJob or sidekiq, I think I would make those job classes the 'SendUserGift` classes I mention, I probably wouldn't bother with a very thin wrapper on top of them. If you are relatively new to this stuff, and wanna get a simple MVP/proof of concept up fast, I think you could skip the job queue to begin with, but leave an issue/note for yourself in the project plan that it oughta be added soon. 
Way back in the day, I used to use work with WebObjects, and it's Enterprise Objects Framework ORM. (Originally NeXT and ObjC, Apple and Java by the time I used it, now gone, but I think EOF lives on in an evolution that's part of Cocoa or something? I dunno, I don't Cocoa). ActiveRecord is _very_ similar to EOF in many ways. So much that I suspect dhh or whoever wrote it must have had exposure to it, or something else influenced by it. But lazy batch loading was something built into EOF that has never made it into AR. I occasionally miss that feature in AR. 
I've found other advantages using fixtures. We have a shitload (hundreds) of models, all associated with each other, I just didn't wanna count that so I did a quick `rake stats`. I guess ya, the multiple yaml files can be annoying, but I rarely need to open fixtures up. You shouldn't have 30 fixtures for each model or anything, so all the stuff is already in there. All the "characters" in our app are nice because they're easy to remember and follow a theme. We had an app where all the characters were from Harry Potter, another where they were all from LOTR, etc. I might take a look at that gem you wrote.
Also consider "Dr Strangelove, or How I learned to stop worrying and love long emails"
This looks really cool. I've been using GraphQL::Batch which has been fantastic (promises in ruby seem weird at first, but I have found them to be very powerful). The name ("GraphQL"), and the fact that it uses promises have made me reluctant to include it in our REST API though. I might check this out.
In the various applications I've worked on, I do use persisted records in controller tests. But I also **don't write lots of controller tests**. Controllers are supposed to be small and simple; the tests should be too. "Check 200 response; check record was created; check record was deleted; check that you need to be signed in; ..." -- just do some really basic, high-level tests. Any complex business logic, or query parameters, or asynchronous processing, or permission checking, .... should be handled in other classes. Which often *won't* need persisted records in order to be well tested.
An honest functional test should catch your 3rd-party dependency scenario. *I think we're approaching a Devil's Advocate discussion here...* but if you were really concerned about the 3rd-party API changing, I would suggest wrapping that code in its own service class (*as mentioned above*). Then only testing the behavior of the integration, once, rather than multiple times across many controllers.
This is less about testing and more about not having fat controllers. But you're right, controller testing is just testing if requests don't explode. You normally should not have business logic in controllers.
Ha. Yeah. This is oddly the least read blog post i've written in maybe a year+. I think i screwed up majorly somewhere, i'm not getting much feedback though. One person said "they didn't understand what it was about so didn't open my newsletter. So I changed my title. In retrospect I could have written a better intro, my first paragraph doesn't really do a good job of introducing the problem or framing what the blog post is going to be about. 
But for example, I've *commonly* seen applications with relatively complex user models, where it was decided that "the only way to be sure" your permissions work correctly is to do all tests at a controller/request level. So for example, suppose you have 5 permission levels "per client" (e.g. View-Only-User, Normal-User, Power-User, Admin, Super-Admin) and you also need to ensure that one client user cannot see another client's data. That means you could have **10** different tests on *each* controller action; each of which could require a whole orchestration of other records to check permissions properly. I would just test this with some shared context policy specs, using stubbed records. But 100s (or even 1000s) of lines of controller tests to deal with this is an anti-pattern that I've come across far too many times.
you're probably not going to find many projects where you won't need to put a solid chunk of work to come up to speed, unless it's a project you're already actively using
there has to be something done, because I'm a 45 year old with a masters in molecular biology self teaching myself and I find all that stuff vastly intimidating. On twitter chats for codenewbie you constantly hear the refrain that getting started in open source for new folk can be incredibly intimidating, so either you're writing your own projects, or getting lucky to find one up and running. I'm wondering if there's some way some of us could come together to come up with a more friendly way to let people in (there's my first pull request, but I don't really think that's awesome). Find a way to create legitimate issues but issues a beginner could handle...perhaps even create something that's broken for a newbie to find - i don't know...i have lots of weird ideas :)
this exists - you just have to find the community. Netlify has an open source CMS (React/Redux/GraphQL, so diff. stack) and they have a staff member whose job is to manage that community, so he helps out newbies, coaches people through issues, etc. I wasn't suggesting that it doesn't exist, just that you have to dig to find it. It's just part of the process, unfortunately. It's also super frustrating when you really want to get started. I'd suggest taking a tool you use to develop, like Pry or Rubocop or something, and dig deep into an issue, reach out to the maintainers, etc., make it known you want to help out, and see where that gets you. To the more experienced, I think /u/NeuroAtypicalCodeer makes a good point that those with more experience should try to reach out and help beginners make their way into the OSS community.
Not a bad suggestion in general, but I would not define a method named `send` in ruby, to avoid conflict/confusion with builtin `Object#send`.
ok we're going to need a stack dump for context. Alternatively you can grep the source code and gems to see where this error is thrown, and under what circumstances.
Part of my code connection project in my long term thinking was that it would help newbies find ways to contribute. Sure there are many applications out there that help people find projects that need help, but they aren't curated....I envision a sort of 'job board' where you post about your project and what sort of help you're looking for - with tags and links and such - that way you're more likely to see active projects get listed...most of the automatic sites don't really take into account dormant stuff. My problem is that, yes, I'm neuroatypical (and didn't see the extra e in my screen name when I made it), uncomfortable in crowds, and while not a true hermit, Im pretty introverted stay at home avoid socialization - which of course is horrible personality traits for someone who wants to write code with people - I know :)
https://yourfirstpr.github.io/ https://github.com/MunGell/awesome-for-beginners https://medium.com/@kentcdodds/what-open-source-project-should-i-contribute-to-7d50ecfe1cb4. http://up-for-grabs.net/#/
What do you get when you run the task with `--trace`?
Instead of "looping back" to A, you could simply create a map that matches the order of the alphabet. In other words, create a shifted alphabet. With this you can simply iterate through your string and find the cipher character by index. [Here's a simple example](https://repl.it/KNOG/0).
Has this position been filled now?
I get this but I'ma be honest, I don't know what I'm looking for...never compiled a gem before jose@jose-desktop:~/Workspace/Ruby/ruby-unf_ext (master)$ rake native gem --trace ** Invoke native (first_time) ** Invoke native:x86_64-linux (first_time) ** Invoke native:unf_ext:x86_64-linux (first_time) ** Invoke tmp/x86_64-linux/stage/lib/unf_ext.so (first_time) ** Invoke copy:unf_ext:x86_64-linux:2.3.1 (first_time) ** Invoke lib (first_time, not_needed) ** Invoke tmp/x86_64-linux/unf_ext/2.3.1/unf_ext.so (first_time, not_needed) ** Invoke tmp/x86_64-linux/unf_ext/2.3.1 (first_time, not_needed) ** Invoke tmp/x86_64-linux/unf_ext/2.3.1/Makefile (first_time, not_needed) ** Invoke tmp/x86_64-linux/unf_ext/2.3.1 (not_needed) ** Invoke ext/unf_ext/extconf.rb (first_time, not_needed) ** Invoke ext/unf_ext/unf.cc (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/lib (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/.document (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage (first_time, not_needed) ** Invoke .document (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/.gitignore (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage (not_needed) ** Invoke .gitignore (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/.travis.yml (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage (not_needed) ** Invoke .travis.yml (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/CHANGELOG.md (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage (not_needed) ** Invoke CHANGELOG.md (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/Gemfile (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage (not_needed) ** Invoke Gemfile (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/LICENSE.txt (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage (not_needed) ** Invoke LICENSE.txt (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/README.md (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage (not_needed) ** Invoke README.md (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/Rakefile (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage (not_needed) ** Invoke Rakefile (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/extconf.rb (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext (first_time, not_needed) ** Invoke ext/unf_ext/extconf.rb (not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf.cc (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext (not_needed) ** Invoke ext/unf_ext/unf.cc (not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf/normalizer.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf (first_time, not_needed) ** Invoke ext/unf_ext/unf/normalizer.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf/table.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf (not_needed) ** Invoke ext/unf_ext/unf/table.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf/trie/char_stream.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf/trie (first_time, not_needed) ** Invoke ext/unf_ext/unf/trie/char_stream.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf/trie/node.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf/trie (not_needed) ** Invoke ext/unf_ext/unf/trie/node.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf/trie/searcher.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf/trie (not_needed) ** Invoke ext/unf_ext/unf/trie/searcher.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf/util.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/ext/unf_ext/unf (not_needed) ** Invoke ext/unf_ext/unf/util.hh (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/lib/unf_ext.rb (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/lib (not_needed) ** Invoke lib/unf_ext.rb (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/lib/unf_ext/version.rb (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/lib/unf_ext (first_time, not_needed) ** Invoke lib/unf_ext/version.rb (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/test/helper.rb (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/test (first_time, not_needed) ** Invoke test/helper.rb (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/test/normalization-test.txt (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/test (not_needed) ** Invoke test/normalization-test.txt (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/test/test_unf_ext.rb (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/test (not_needed) ** Invoke test/test_unf_ext.rb (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage/unf_ext.gemspec (first_time, not_needed) ** Invoke tmp/x86_64-linux/stage (not_needed) ** Invoke unf_ext.gemspec (first_time, not_needed) ** Execute copy:unf_ext:x86_64-linux:2.3.1 install -c tmp/x86_64-linux/unf_ext/2.3.1/unf_ext.so lib/unf_ext.so cp tmp/x86_64-linux/unf_ext/2.3.1/unf_ext.so tmp/x86_64-linux/stage/lib/unf_ext.so ** Execute tmp/x86_64-linux/stage/lib/unf_ext.so ** Execute native:unf_ext:x86_64-linux rake aborted! NoMethodError: undefined method `split' for nil:NilClass /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-compiler-1.0.4/lib/rake/extensiontask.rb:515:in `ruby_api_version' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-compiler-1.0.4/lib/rake/extensiontask.rb:262:in `block in define_native_tasks' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:250:in `block in execute' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:250:in `each' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:250:in `execute' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:194:in `block in invoke_with_call_chain' /home/jose/.rbenv/versions/2.3.1/lib/ruby/2.3.0/monitor.rb:214:in `mon_synchronize' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:187:in `invoke_with_call_chain' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:216:in `block in invoke_prerequisites' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:214:in `each' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:214:in `invoke_prerequisites' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:193:in `block in invoke_with_call_chain' /home/jose/.rbenv/versions/2.3.1/lib/ruby/2.3.0/monitor.rb:214:in `mon_synchronize' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:187:in `invoke_with_call_chain' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:216:in `block in invoke_prerequisites' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:214:in `each' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:214:in `invoke_prerequisites' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:193:in `block in invoke_with_call_chain' /home/jose/.rbenv/versions/2.3.1/lib/ruby/2.3.0/monitor.rb:214:in `mon_synchronize' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:187:in `invoke_with_call_chain' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/task.rb:180:in `invoke' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/application.rb:152:in `invoke_task' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/application.rb:108:in `block (2 levels) in top_level' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/application.rb:108:in `each' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/application.rb:108:in `block in top_level' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/application.rb:117:in `run_with_threads' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/application.rb:102:in `top_level' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/application.rb:80:in `block in run' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/application.rb:178:in `standard_exception_handling' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/lib/rake/application.rb:77:in `run' /home/jose/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/rake-12.0.0/exe/rake:27:in `&lt;top (required)&gt;' /home/jose/.rbenv/versions/2.3.1/bin/rake:23:in `load' /home/jose/.rbenv/versions/2.3.1/bin/rake:23:in `&lt;main&gt;' Tasks: TOP =&gt; native =&gt; native:x86_64-linux =&gt; native:unf_ext:x86_64-linux 
The stack trace says the error is coming from [this line](https://github.com/rake-compiler/rake-compiler/blob/v1.0.4/lib/rake/extensiontask.rb#L515) in rake-compiler. Seems like the Ruby version / platform is not getting set (I'm not familiar with rake-compiler, so just guessing from skimming the code). Does the gemspec of the gem you're trying to build specify a platform like [the example](https://github.com/rake-compiler/rake-compiler#generating-native-rubygems) in the rake-compiler readme?
For the stack dump - I'm guessing this isn't the only line of output, but that you trimmed this - dont trim, post it, or send the link to a gist on github (if you don't know what that is, google it, its pretty easy) For the grep - your code might contain this particular, or this line is in one of the gems your code relies on. Grep is a simple search utility - any tool that can navigate through a directory tree, and look in all the files for a phrase, could be likened to "grep" - again google "grep" to get a handle on what it does, than use whatever your favourite equivalent is, to find a file that has the error line - then look in that file to try to work out why it said that - was it a permissions error ? was it a parsing error ? you'll have to do some interogating and analysis.
Agree! Maybe we could use `mail` instead.
Yeah, this worked good thanks, although to allow the user to select their own offset i did offset.times do will_push_to_end = cipher[0] cipher.shift cipher.push(push_to_end)
also how did the other guy who commented do the different font and background for code thing on the comment
Top comment [last time this was posted](https://www.reddit.com/r/ruby/comments/6abbrp/ruby_vs_elixir_projects_people_edition/): &gt; &gt; Frankly, I think we really need Ruby 3 to come sooner rather than later, not for any technical reasons, but for a marketing and enthusiasm bump for Ruby and Rails &gt; &gt; Worst reason ever to release a new version of a language.
Another approach, using SimpleDelegator instead of method_missing: https://bibwild.wordpress.com/2012/12/19/the-simplest-rails-decorator-implementation-that-just-might-work/ I think they are both fine. In the context of Rails apps _presenters_ though, since then I've definitely embraced Draper myself, having access to Rails helper methods and routing path helpers turns out to be super convenient and helpful. I used to be scared of the hacks Draper had to do to make this so, but it's such a mature and well-adopted gem at this point that I just role with it. Although I suppose the other option would be just making your decorator-presenters always take a required `view_context` arg, that would work too. 
Yeah, it's not really about emails at all, it's about background jobs and idempotency! And is interesting and useful about that. I know the new hip thing is clickbait titles that encourage the reader to click without actually telling them what the article is really about, but I still like an accurate title myself. :) "Idempotency" might be a technical word people don't recognize that puts them off, but I would have gone with something like "How a background job that wasn't safe to retry resulted in some incredibly long emails" It's actually a useful lesson-example about bg jobs in general, not so much about email. 
&gt; I know the new hip thing is clickbait titles that encourage the reader to click without actually telling them what the article is really about, but I still like an accurate title myself. sadly i've done this for five years (on and off) and I can say that there is a non-trivial cost to using "non-click bait titles". I would almost argue that the click-bait-y-ness of the title is more important than the content for things like social reach, open rates, and "virality". I went with purely factual titles for a very long while and my readership dropped substantially. As much as people (like myself) hate them, we keep clicking. I usually either write my titles first (title driven development) or wait until the end. I struggled with this one. I have another that's like it where a thing messed up and I fixed it. I'm thinking of prefacing it with "War stories: My Auth-pocalypse" or something. Better than "A thing broke, then I fixed it: My Auth-pocalypse". Though now that I write that out, it might just be cheeky enough to work. 
It is a sad world. Maybe for this one there could be a click baity title that still mentioned BG jobs, which I think is really what it's about. And maybe that would have actually increased clicks? Since the current title apparently failed at clickbaityness. People might be interested in bg jobs, and not in long emails. On my blog, I use factual titles. I get plenty of readers, including continuing clicks to some of my years-old blog posts. But I don't know if my "plenty" is your "plenty", i'm not actually doing much analytics or trying to monetize/convert in any way, I just check out the wordpress analytics from time to time. 
I've never heard of rake-compiler, it may be that it's not a very used gem and has bugs. What is your goal, what are you actually trying to do? There may be a better solution. I've never "compiled a gem" in the way you seem to be trying to do, myself. 
Actually reading the article, it occurs to me that there was something in WebObjects/EOF batching that is missing from this solution, but could maybe be added. In EOF batching, the stand-in objects (I think they called them 'faults', I forget), were _linked together_ in batches. So you didn't have to do `BatchLoader.sync!(serialized_posts)` to load them all, you defined them as related batches when fetching the original objects, and could just call `thing.user` and it would not only load that user, but also load all the other `thing.users` it was batched with. Lazily, on-demand, not until you asked for one -- at the point you asked for _one_, the others would be batch loaded, without you needing to keep track of the batch yourself at the call site, or even know it was a batch. Not sure how/if this would be useful for these use cases, I don't completely follow them and don't use GraphQL, just thinking on my experiences with EOF and the occasional times I've missed lazy batch loading in AR. (I realize the OP isn't really focused on AR, but is a general purpose solution that could probably be used with it too). I bet it could be pretty easily added though, since this tool is already idempotent and won't load things already loaded. It might simply require a way to assign "Here's your list of peers in the batch" to each model, so you can have a method that automatically triggers batch loading of the list of peers, and have your accessor call that method if the current model is not yet loaded. 
Yup. I feel like the path forward is to keep improving MRI, keep making Rails better, keep answering questions on SO, etc... just make the existing ecosystem better and better.
I mean, they're both great.
petergate... take a look. ;) https://rubygems.org/gems/petergate
The decorate helper doesn't really add much. `Decorator.new(object)` isn't much longer than `decorate(object, Decorator)`. The view shouldn't be doing the decorating anyway. Decorate the object before you pass it to the view.
Just use both
Full Disclosure: I'm one of the PMs for RubyMine. I only use [presentation assistant](https://plugins.jetbrains.com/plugin/7345-presentation-assistant) that displays my keyboard manipulations (shortcuts mostly; that's needed for my job), and [AngularJS](https://plugins.jetbrains.com/plugin/6971-angularjs). I also know [.gitignore](https://plugins.jetbrains.com/plugin/7495--ignore) is quite popular, and those who are into VIM really love the [IdeaVIM](https://plugins.jetbrains.com/plugin/164-ideavim) plugin. You should probably ask /r/rails as there seems to be many RubyMine users there according to my experience, and join [RubyMine Slack](http://slack.rubymine.org/) as its probably the best place for such questions.
Awesome, thanks for the suggestions, man. Thanks for working on RM by the way, it's such a joy to use.
Great to hear that, thank you! Oh and thanks for using RM of course :)
Well, I need to install a gem on a production machine. These production machines don't have gcc installed, so I need to be able to compile the gem and install it without having to compile the native extensions on production.
It still happens even if I add to it myself though, so that's kind of odd. I've posted an error to their github page. I don't suppose you have a good tutorial on how to precompile gems? 
So it's basically like `-Wall` etc. for ruby code, right? If so, that's neat.
`||=` is not very far from other operators or other languages. Just like `+=`. You may be more surprised when seeing safe navigator `&amp;.` which also exists in other languages as well. On `rescue X =&gt; e`, it's just a syntax. Some languages choose different way to do that. I read jt as rescue X and take the exception to variable `e` so it's easy to follow. I do think ruby shines at enum methods like `map` or `join`. Ruby: `list.join(',')` Python: `'.'.join(list)` Elixir: `Enum.join(list, ",")` Anyway syntax should not be deal breaker when you choose languages. Take a look on ecosystem, performance, pros and cons of languages and so on. 
The `=&gt;` operator is the "association" operator - if you look at the Ruby source, you'll see it's defined as a token called `tASSOC` (if memory serves). That's what it's doing in both hash literals (associating a key with a value) and `rescue` clauses (associating a exception with a variable). For something roughly similar, consider Python's `as`. It's used to alias certain things, like in import statements (`import foo as bar`), it's used in context managers (`with open(file) as f`), and it's used exception handlers in the same way Ruby uses the rocket: `except FooException as f`.
Thanks for the response, chulkilee! I should emphasize that the syntax doesn't bug me by itself. Not understanding is what bugs me. If things are arbitrary, I can live with that, but grasping at patterns that aren't really there, well, that'll drive me crazy :-).
I don't understand - what is it about `||=` that you find strange? I also find the `=&gt;` in exceptions a bit strange though. But it's just part of the `rescue` statement. It's not an operator on its own in this context.
You can see `a ||= 10` as `a = a || 10`. Similar to seeing `a += 10` as `a = a + 10`. Edit: This is not correct. Please read the replies below.
Thinly veiled advertisement for vile.io 
Hey chrisgseaton. I think ||= is a little odd because of the way I heard it explained. If it were simply an operator in Ruby, I'd leave it alone and wouldn't care. However, I read it's actually sort of an... ehm, "hack", as opposed to a deliberate language feature. (Idiom was the word that was used.) Anyway, this idiom is said to work because of one feature of Ruby's, and that is "In Ruby, if an assignment appears in a statement, a variable is created and set to nil, even if the assignment isn't actually executed." For that reason, not only does the above work, but the following examples work. foo = foo bar = 20 if false That said, the following will **not** work if a is undefined initially a || a = 10 I think it's weird that the above will not work, yet ||= works fine. I don't get what sort of magic is going on that makes ||= a statement, yet the above is not.
I use both. Ruby and elixir have different things they are each good at. Rapid prototyping is easier with ruby and rails, the thousands of gems, and the amazing ecosystem. Elixir is fast, great with socket connections, parallel computing, rock solid platform. Not all applications need to be blazing fast so choose the best tool for the job.
Exactly this. At work we manage things that need a lot of load, very fast performance, and high concurrency, through elixir AND sometimes phoenix. And things that may change more, are less dependent on database and/or can be cached easier. Basically: + shopping cart: elixir + chat: absolutely elixir + authentication: elixir + store pages: rails + settings pages: rails + homepage: rails + most of the api: rails With elixir, I feel that tools like Phoenix are much less critical than in ruby, where if you want a web app you either choose Rails, or something that accomplishes the same goal. In elixir, you can just throw together an OTP app pretty fast that will do exactly what you need, with minimal dependence on third-party Hexes 
`a ||= 10` is not the same as `a || a = 10` - it's more like `defined?(a) || a = 10`. That's why it behaves differently. If you're looking for more reason to this you aren't going to get it - that's the way `||=` is defined and that's that. But it does indicate the feature was intentional - they didn't accidentally add the `defined?` keyword. But none of this is really anything to do with the grammar. You're arguing the semantics here, not the grammar.
&gt; With elixir, I feel that tools like Phoenix are much less critical than in ruby, where if you want a web app you either choose Rails, or something that accomplishes the same goal. In elixir, you can just throw together an OTP app pretty fast that will do exactly what you need, with minimal dependence on third-party Hexes I guess this isn't your experience, but for me, I take the approach you describe for elixir with every project I undertake, regardless of the programming language. I think you're describing a mentality more than a technical distinction.
I guess what I was trying to say was elixir has a much more powerful standard lib than ruby. Ruby has a *very good* stdlib, don't get me wrong, its leagues better than many other languages, but it just seems like Elixir's is so much more powerful for actually difficult things. Take GenStage for example. Lets you implement a fairly simple load balancer and rate limiter in about a half-dozen lines of code, and then take that and scale it up to thousands of machines across multiple data centers in different locations. Sure, there are some things I wish the stdlib had that ruby's did, a Decimal/BigDecimal being the most notable, but for the most part I don't want/need to use as many third party libraries as I would in ruby. Maybe its because in ruby they're more mature, but i really don't feel i need them, whereas in ruby of course i'd use something like the money gem
Here's my favorites: * Railways: Adds a "Routes" pane to Rubymine where you can view and search your app's routes * Grep Console: Highlights lines in your console with words like "error" or "warning" * Markdown Navigator: Full featured Markdown editor with live preview * RegexpTester: Adds a "Regex Tester" pane where you can create and test regexes against strings * ReST Console: Adds a "ReST Console" pane where you can test HTTP requests and inspect responses * String Manipulation: Helpful string editing commands like advanced case changes, multilingual escape/unescape, encode/decode, advanced sorting, whitespace alignment, etc. * Unicode Browser: Browse and search for Unicode character data
Those aren't really the same thing, though, and it could definitely be confusing for a beginner. The `+=` syntax is a bit easier than `||=`, in my opinion. For the OP: `a ||= 10` can be read as `if a.nil? then a = 10 else a`
Judging from the docs, not even close. `-Wall` gives you (sometimes) useful information about what your code is like *right now;* tools like Vile track churn, complexity, duplication, known code smells, outdated dependencies, etc., both at the moment and over time. Metrics like churn are highly useful and inherently involve a period of time; "how many times has &lt;this class&gt; been modified in the last month?" or "what dependencies were updated between tag `v1.4` and now?" are Useful questions of the sort that teams *should* be getting answers to regularly. This just (looks like it) brings all that together differently than tools the developers (and I) have seen before. Not connected to Forthright in any way; just took a brief read through the docs and added this to my "look at this more, soon" list.
How so? AFAICT, vile.io mostly wraps a Web interface around their [OSS command-line tool](https://github.com/forthright/vile). Am I missing something, or is it just hip to slam people who hope to make a living from their work?
This is incorrect. `a ||= 10` behaves like `a || a = 10` http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html
Hadn't heard of Railways. Gonna check it out. 
If you want a nice theme Material Theme EAP is solid. All of my tools have the same look and feel now and I love it. 
Am I a plebe if I just like the Darcula theme? What is great about other themes?
It's just personal preference. This is the first time we've had a well supported alternative to the default themes. 
Is this basically an Identity Map?
So is it something like Rubocop or is it something else?
This was a great read. Thanks.
Good post, the guys at Arkency have been killing it lately. I'm subscribed to their newsletter and they continue to put out great content. 
Well, except that it doesn't if a is not yet defined either, because then the first `a` in `a || a = 10` would be a method call.
The main README could use more info. I've looked through the docs and read this post and I'm still only guessing at what it's supposed to do. 
Not true if `a` is false it will also assign 10, and if `a` was not yet a variable then it will call the method `a` or raise an error if there is no such method.
And in the article he covers that. 
TY for the excellent clarification!
Yes, but not really to my satisfaction. He's correct in saying that it's not like `a = a || 10` he is not correct in claiming that it's like `a || a = 10` instead. In reality it's its own thing.
I learned it via code academy it's free too I feel they touch all the things I want to know 
I really liked [Pragmatic Studio's Ruby course](https://pragmaticstudio.com/ruby), which is already on your radar. I found it fit my learning style better than something like CodeAcademy.
I love the comment: &gt; Thanks for writing about my library and helping explain a complicated portion of the code. Would you mind adding a link to the github page somewhere in the article?
What worked for me, so far is basically creating flashcards for each of the main topics, and also for single methods. In each of these flashcards I wrote down a series of tasks and questions that I had to respond correctly. I created a simple script that allows me to enter multiple urls for each given topic. One thing you will probably notice, is that is much better to have multiple sources explaining the same topic (even simple methods or syntactic sugar), I've read and studied 3 ruby books for beginners and intermediate, completed rubymonk, codeacademy courses. MANY times you will think you understood something, just to later realize you didn't or you simply forgot. I do not believe there's the "ultimate" course that you do once and you are able to create complex gems and contribute to mature open source projects. Here are some tips: - practice different parts of ruby syntax every single day - Come up with simple projects that use important libraries of ruby, such as File, Logger, everything that is built-in should come first. - Create other projects that include database gems, webserver gems - Do not try to read and understand mature gems until you tinker with them quite a lot. - Learn a couple of new methods everyday, write them down, but do not write the exact name, but rather a question like "how do I move all elements in an array a certain position?" - There are topics like unit testing and design patterns whose concepts can be grasped only if you've been coding for a while. - You must create a to-do list and include that list in a calendar. - Do code challenges, but if you can't figure them out at all after several minutes, don't insist, many of these challenges are completed by people with plenty of experience - Math does help. If you don't force your mind to first internalize the single parts first and then practice them as a whole, you will not get far.
It's a pet-peeve of mine when an author titles their blog post "XYZ Considered Harmful." The implication is that the **industry** has largely adopted such a viewpoint. But really, most of these authors are just stating their **personal** preferences. I wish instead they'd say something like "Why I Dislike Small Functions". I'd still read it, and it's much more honest. NOTE: This is a criticism of the article's actual author, not so much OP.
An identity map on steroids :) I'd say a lazy identity map with batching.
I think the majority of people titling their articles as such these days are at least a bit tongue in cheek, at least i hope.
Thanks for your feedback! I'll think about implicit syncing, whether it'll have too much "magic" or not :)
Oh, ok. I only took a cursory look at it so I didn't know that it does all that extra stuff.
I honestly think that could have benefited from some code examples. Maybe I wasn't concentrating hard enough, but I think her points would be more convicting with actual examples. I agree with some of the points, but I think code examples could have made the arguments that much stronger.
The small function thing could be sustainable if Ruby was statically typed, but its not. So the author of this is 100% right IMO. Good luck having the argument with the team about changing the Rubocop rules though. Ruby developers are mighty cultish. So instead, leave that team. Start writing statically typed functional programming in a different language. Learn to love IDEs and generally find happiness (and performance) again, elsewhere.
AceJump https://github.com/johnlindquist/AceJump
Somewhat unrelated but don't waste your time on the crap optparse is. You need some [Trollop](https://github.com/ManageIQ/trollop) awesomeness.
What leads you to believe it's being skipped? I took your code and added puts to the end and the options are being set just fine. require 'optionparser' options = {} OptionParser.new do |opts| opts.banner = "Usage: get_overrides.rb [options]" opts.on('-t', '--token', 'Search token') { |v| options[:search_token] = v } opts.on('-m', '--materialset', 'Odin material set') { |v| options[:odin_material_set] = v } opts.on('-e', '--extregion', 'External region') { |v| options[:external_region] = v } opts.on('-i', '--intregion', 'Internal region') { |v| options[:internal_region] = v } end.parse! puts options Running it it like so: ruby opts.rb -t -m -e -i Gives this output: {:search_token=&gt;true, :odin_material_set=&gt;true, :external_region=&gt;true, :internal_region=&gt;true} 
I don't understand why using small functions would be related to whether a language is statically typed or not?
You know, I tried this and it was super laggy for me. QuickJump on the other hand works great for me.
Jesus, that's terribly written. It starts off as if the author just had a class on writing essays, then finishes as if they had a stroke. The intro is so formulaic, it's cringe-worthy, while he whole section at the end about "When do smaller functions actually make sense" makes almost no sense, and hardly goes into the matter at all.
Weird, my puts are showing empty vars. I'll make sure I compare it more carefully. Can I add general put statements in site the '...new do...' block? Might try that just to validate the block is entered.
Interesting, I'll have a look!
For the library itself? Technically, yes. :-) However, it has a much larger scope than Rubocop (ex: code coverage, outdated gems, etc) and can generate lower level data (ex: code complexity, similar code) that can be more easily post-analyzed by the lib and vile.io, while also supporting general maintainability and style issues that encapsulated quality tools like Rubocop report. Another example (and awesome project) is RubyCritic and its plugin. It can generate Vile data for similar/duplicate code and even churn data, but also report general warnings for things like code smells.
Is there anything that comes to mind that you think could be improved specifically? For one: I plan to put more about plugins in the README as the hosted docs are currently more geared towards setting up Vile with vile.io and your CI service. Thanks!
Just wanted to sign up, but apparently my email is invalid :'D
Just on the topic alone, I don‚Äôt agree. Sure I guess having a single line function is not always necessary. ‚Äò‚Äò‚Äò def this_thing object.thing end ‚Äò‚Äò‚Äò Could be done as ‚Äòthis_thing = object.method‚Äò but many times just throwing in an extra method to clear something up really really saves other devs time. I‚Äôm not big on commenting my code because I try and make my variable names and methods explain comment themselves. If I have to have a method name that‚Äôs 30 characters long then I will. 
Nailed it! I mean, there is a lot to do horizontally and vertically for both the lib and hosted service, but those sorts of questions are ones I want to help make answerable. :-)
They make even less sense when looking at them in isolation if you don‚Äôt know the types of things.
In addition, it provides a location to shim in future calculations, event triggering, validation, whatever. For example, I often have something like: class Order def shippable? @status == :shippable end end Or whatever. The thing is, very often, I end up adding further tests, later functionality, all that within that simple interobang. When I do, I don't need to refactor my code to change all the places where I checked order.status == :shippable. Methods are the verbs of your object. They hide internals and express an external truth. Sometimes all that's needed internally is a small one or two line method. And that's as it should be.
Always notate your methods return values, AT LEAST. @return [Array&lt;String&gt;] def it_all %w[please for the love of humanity] end
dup, posted last week. https://www.reddit.com/r/ruby/comments/6t2t0s/small_functions_considered_harmful/
&gt; Yeah... still not buying it... This kind of article says... yea... small functions and DRY code are good in 99% of cases... but be on the lookout for that all important 1% where it is not... My experience is the reverse, small functions and DRY are great only 1% of the time, when the design happens to be 'good' for the future. &gt; Platitudes like 'use common sense' don't really help someone new at code tackle complex problems... TDD / BDD / Small Functions / DRY are things people can grasp quickly and use their entire coding lifetime... Teaching bad programmers to write short functions just results in more bad code. I'd rather refactor a 500 line method than 500 bad abstractions. 
I think it depends on your style of learning. If you're good an studying on your own, I'm sure others can recommend good courses. If you learn better by having someone to ask questions to, or to hold you accountable for work, then you might want to look at Bloc.io. It's an online bootcamp where you can set your pace and you work with a mentor for the whole course, 1-3 times a week. Cost is about 5k for 3 months, depending on pace. I work as a mentor, so I can answer questions if you have any. 
Sure, I write 500 line functions sometimes... I'll even make them 500 characters wide sometimes... and use whitespace that makes other people feel all funny... I am not a zealot about testing 100% of the time either... As someone who has dug thru 300K lines of duplicate (and very bad) PERL code... I just can't say how much the DRY concept has helped me... and as all libraries are about DRY, I can't imagine using an OS that was not based on it... (even with the DLL hell that windows has become, and the mess that GEMs can be or all the goofy Linux libs out there...) I don't think teaching them small functions is the point of small functions as much as a more understandable namespace and less for the new guy to keep in his working memory at one time.... But if it works for you, full steam ahead... ;)
Try CodeSchool. It's free this weekend. https://www.codeschool.com/free-weekend
THe "hard way" (learn ruby the hard way) method isn't that bad either...the issue isn't learning the foundations it's reinforcing the foundations and building upon them...the ruby docs is extremely helpful to learn specific things as well. The practice is the issue
"Rails" logs. Not Ruby. TL;DR Use timber.io and ruby gem. And try running a Java app if you REALLY want "log noise" problem.
... I just .... Hogwash.
Yea great point. I‚Äôve never heard newbies to my company's code complain that a file is 200 lines (there‚Äôs a ton of room to refactor but that‚Äôs a different story). I‚Äôve only ever heard them complain about the class with the 50 line method of weird symbols and unintelligible variable names.
Had this discussion on Hacker News like a week ago. Pretty much only fools think small functions are harmful, fools on the order of "gotos are good". There is a time and place for both large functions and gotos, but they are so infrequent that one should consider the other options carefully.
Thanks for the answer. When you say "batching", do you mean eager loading of associated data?
The authors assertion that many small functions make the code harder to change is mind boggling. It is the exact opposite of what I've observed in over a decade of professional development.
There's hardly anything better than [The Odin Project](https://www.theodinproject.com/). If you are interested in web development follow the whole curriculum. If you are only interested in Ruby, then you can just follow the backend section of [Web Development 101](https://www.theodinproject.com/courses/web-development-101) and then [Ruby Programming](https://www.theodinproject.com/courses/ruby-programming). As others mentioned Code School is free for this weekend and the Ruby track is very good. I'd start there since The Odin Project is always free.
Small functions are harmful. Large functions are harmful. What‚Äôs next, all functions are harmful?
http://awesome-ruby.com/ i'm new to ruby myself (started yesterday LOL)... this site seems useful getting to know stuff in the ecosystem
The curses library is what you're looking for
 %r{.*@.*} Anything beyond that is just overkill...
Caution: possibly not the optimal solution. You can use the backspace character to clear text. Backslash b.
What's the use case? Why should I use this? What does this do better than all of the other (presumably) similar tools? Basically, you need to sales pitch it a bit. ;) 
Man it's been a while since I wrote a native extension, so I could be far off here. The only thing that jumped out at me is that your native `rb_scan_args` is scanning for arguments differently than your Ruby method is defined. This has two required parameters, none optional, an arguments list and a hash: def loc_test server, host, *others, **hash vs. `"11*:"` saying 1 required argument, 1 optional argument, an arguments list and a hash. test(required, optional=?, *others, **hash) I imagine that extra optional argument is causing the issue, because it's trying to chomp an extra argument that isn't there. Have you tried `"2*:"`? ~~`"1*:"`~~ Check out the spec for `rb_scan_args` here, I think it will help: https://docs.ruby-lang.org/en/2.0.0/README_EXT.html#label-Method+Definition
Curses can be pretty hellish though. `libtcod` might be worth looking at if you're trying out the roguelike thing. There's a ruby binding, though it's a few years old. http://www.roguebasin.com/index.php?title=Libtcod
https://pastebin.com/tNDzzciD everything except the last one (`11*:`) works as expected, I feel like I must be missing something. Maybe it's time to dive into the source :/
&gt; I've just chalked it up to being its own operator, as opposed to it being a clever idiom that someone came up with. That's exactly what it is, although it's supposed to remind you of an `||` combined with an `=`, it is indeed it's own operator that works by being defined as such. &gt; rescue SomeException =&gt; e Yeah, sorry, not a hash, you just gotta deal with it. There's only so much punctuation to go around! I suppose it could have been defined in the grammar to be like `rescue SomeException e` instead, but I don't know why that would be better, now a space can mean anything!!! haha. I find the hash rocket more readable. But yes, it's got nothing to do with hash literals, just a re-use of `=&gt;` in the grammar, you're right. If you're looking for a _concise_ and _parsimonious_ grammar, you're not going to find it in ruby. Matz was, I think, really influenced by Perl in some ways, and the language design also prioritizes readability of code (in Matz's opinion, but I think others agreeing lead to popularity of language) over parsimony of grammar. If you're looking for parsimony and simplicity of grammar, other things may annoy you: The fact that parenthesis on method definitions as well as calls is optional; or the two ways to do blocks (`do |args| ... end` or `{ |args| ... }`, with the `|args|` being optional in both cases!); or heck, maybe the existence of blocks at all instead of just passing a proc value as an argument; probably many more. I like ruby a lot and think it works out, but concise and parsimonious and consistent grammar is not what ruby was aiming for. If you want that, maybe go try scheme or something, heh. 
I'm pretty sure it is indeed simply an operator, and whatever else you read is wrong. But i haven't looked at the MRI C source code for the parser or anything, maybe i'm wrong. But regardless it works fine for your mental model to just think of it as simply an operator, there's no more ruby understanding to get, I don't think, than thinking of it as simply an operator of it's own. At least I've done fine for 10 years of ruby like that. (But I would bet it really _is_ simply an independent operator, not any kind of hack other than that). 
Neat trick, but... why? I'd rather at least insist it was a certain class _and_ matched a message. 
That's a good point you're making, regarding class &amp; message. We built this because we saw a pattern, specially with some exceptions from the std lib, that we'd have a rescue clause with an if/else inside. This was our attempt to get rid of that. 
Ah that was a mistake on my part, `"1*:"` should be `"2*:"`. This one is on the right track: 1*: |"s", "h", license: "l" |"s", ["h"], {:license=&gt;"l"} You're not taking in 1 required argument, you're taking in 2. It should probably be `"2*:"`. That means "two required arguments". The result should be something like `"s", "h", [], {:license=&gt;"l"}`
Oh I got that, but the `host` is supposed to be optional. I have overlooked that in my ruby version (my bad). At the moment I'm leaning towards this being bug in ruby. When I recompile ruby with `-O0` it starts working as expected even for `11*:` so I will probably take this upstream to see what's what.
Thanks, jrochkind! This is exactly what I was looking for. The big thing for me was the fear that I was "missing it" or overlooking some patterns that were obvious to everyone else. This alleviates that fear a little bit. :-D
OP here - Just wanted to say thank you to everyone who replied! I appreciate all of the insight.
When you get to "wtf is `&amp;:symbol`?", I've got a reddit answer somewhere on that to dig up. That one really _is_ just combining some language features to do something neat, not it's own special operator. (although I think plenty of people use it without understanding it). But yeah, so far you aren't missing anything. 
At the very simplest, you can just use a carriage return `\r` or cursor control characters to move the cursor and overwrite the line. Thats how a lot of simple progress bars work
I'd probably rather call this Trailblazer + GraphQL. Sinatra communicates arch agnosticism, trailblazer does not.
"How WE...." oh gotcha
```class::method``` is class method ```class#method``` is instance method
https://stackoverflow.com/questions/1192186/subtracting-one-array-from-another-in-ruby
Thanks. I did search for it last night but didn't see this. 
Got it thanks!!
I think the main problem here is that your yield block is being returned from the double function instead of the x * 2 result. The return of the puts is generally nil and so printing nil prints nothing. When I run your code I see: 2.3.1 :001 &gt; def double (parameter) 2.3.1 :002?&gt; parameter *2 2.3.1 :003?&gt; yield 2.3.1 :004?&gt; end =&gt; :double 2.3.1 :005 &gt; puts double(10) {puts "this is in a block"} this is in a block =&gt; nil . I think the only change you're expecting is for double(x) to return x * 2 which is done with a simple flip: 2.3.1 :013 &gt; def double(p) 2.3.1 :014?&gt; yield 2.3.1 :015?&gt; p * 2 2.3.1 :016?&gt; end =&gt; :double 2.3.1 :017 &gt; puts double(10) { puts 'hi' } hi 20 =&gt; nil 
keep in mind this will literally only remove entries in the array entry of ONE space since it uses a literal comparison.
Take a look at how https://github.com/piotrmurach/tty-spinner does this :)
The multiplication takes place just fine, simply add a "puts" in the "parameter * 2" line and you will see the explicit return of the operation. Also, as 4rch3r shows in its code, you are using puts twice, the first within the block called by yield, and the other puts, the one used for the fuction, is actually being applied to nil rather than the function return.
Hey! When I say "batching", I mean loading data in batch when it's needed. This is different from preloading data in advance. Check out the first 3 code examples in the README https://github.com/exAspArk/batch-loader/blob/master/README.md. They demonstrate the difference between eager loading and batching with the timeline in some ASCII charts :)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [exAspArk/batch-loader/.../**README.md** (master ‚Üí c656868)](https://github.com/exAspArk/batch-loader/blob/c65686840f54ea355910bb230b9dcdde84b8bb2b/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlvnv2a.)^.
I explained blocks and yield a bit just now on your question at codecademy, hope it helps
Can you provide a little more information? What is the task and what is the content of the Hello.rb file?
We have plenty of cool gems, but what are you looking to do?
to be sincere, I'm a little upset that from outside it looks like rails eats the ruby world. I just want to see if there different libraries there
You need some kind of server to receive the HTTP post. You can either write your own custom one with Rack, or use something simple like Sinatra. require 'sinatra' get '/form' do erb :form end post '/object' do # access the form fields with `params` params[:field_1] # do whatever you want with the form content end rename "object" to whatever you're saving.
It's also quite common to see `.` for class methods, like `class.method`. For example, here's some output of `ls` in Pry. Object.methods: yaml_tag Object#methods: __binding__ as_json duplicable? instance_values presence_in psych_to_yaml to_yaml `yaml_tag` is a class method, and the others are instance methods.
When I'm working on a web app, I'm always glad that Ruby has much more robust web development libraries than Python does. In my experience, Python has a lot better random libraries, but Ruby has much better web-based ecosystem. Ruby has [nyan-cat-formatter](https://github.com/mattsears/nyan-cat-formatter) for rspec. There's [gosu](https://github.com/gosu/gosu) which is a ruby/C++ game engine. I've never used it. Try https://github.com/markets/awesome-ruby for a big list?
Again, there are, but it's easier to think of them if you mention a specific purpose. At the very list, I guess, you can check out the gem Thursday posts.
 &gt; "4rch3r is wrong".chars - [" "] =&gt; ["4", "r", "c", "h", "3", "r", "i", "s", "w", "r", "o", "n", "g"]
thx for that!
thx
Can I do it with webrick or puma instead of sinatra?
What's "it" that you want to do? You need some kind of code to capture the POST request, there's no getting around that. `puma` and `webrick` just serve and receive HTTP requests, but it's up to your code to do something with those requests. Sinatra is probably the simplest way to do that. If you insist on getting even closer to the metal, you can write a simple Rack app. # config.ru app = Proc.new do |env| req = Rack::Request.new(env) post_data = req.body.read ['200', {'Content-Type' =&gt; 'text/html'}, [post_data]] end run app This takes in requests, reads the POST body, and then responds with it. Then you can use puma or webrick or thin or shotgun or whatever you want to actually serve the HTTP requests.
Yield is useful when you need to vary an algorithm. Imagine this situation: you have a long and somewhat complicated algorithm. Maybe it's contained in a class and broken into small methods; it doesn't really matter. At some point in the future, you realize that you need to change part of the algorithm in the middle, but only in certain situations. You can add a parameter, and use a switch statement, but that gets stinky really fast. You could use inheritance to vary that class functionality, but that's also pretty stinky: eventually, you'll have a unique class for each slightly different problem, one for each change in the calling code. Ick. It can be better to push responsibility to the calling code. Yield to a block, and now the variation in the algorithm can be in the same class that required a slightly different pattern. Keep in mind that this pattern is best used when the complex algorithm is only likely to be varied in one specific spot; otherwise, it's probably better to break down the class further and seek other solutions. I've also used yield for situations where I want to catch and report errors at specific break points, but continue the algorithm afterward. Wrap the code that is likely to break in a block, pass it to the error handler, then continue with the rest after.
On a side note, if you are starting out with Ruby, you should use the current line, 2.4. 2.0 has been EOL'ed for a while now.
Are you trying to do this in rails and you want the form data to not go into the database? Just be acted on and posted back to the web page?
I think he meant something along the lines of &gt; [" ", " "] - [" "] =&gt; [" "]
keep in mind the original post had: array_spaces NOT a string... Strings can be represented as an array of 1 character elements as you've shown, but if the array has strings like so: ["4rch3r", " ", "is", " ", "wrong"] it will definitely NOT delete the spaces: 2.3.1 :030 &gt; ["4rch3r", " ", "is", " ", "wrong"] - [" "] =&gt; ["4rch3r", " ", "is", " ", "wrong"] 
you have to be careful when opening pandora's box, some people might find that `__getobj__` thing useful
 $ tail -f logs/test.log
The author quotes the Ruby documentation to support the idea that `==` is always identity equality. &gt; Equality ‚Äî At the Object level, == returns true only if obj and other are the same object. But doesn't quote the very next sentence! &gt; Typically, this method is overridden in descendant classes to provide class-specific meaning. So it doesn't have to be identity equality! Basic classes like `Array` override `==` to not be identity equality. It's very normal in Ruby.
Got it thanks 
Cool good to know thanks!
The best way to test this is to stub the function and test to see if it's getting passed the correct args. Functionality-wise it's up to the logging library to test its functionality.
Touch√©! I didn't see the original post, just what is there now.
I think your argument is valid, and `Delegator` was intentionally designed this way. It is normal in Ruby or any OOP language to override `==` to provide class-specific meaning of equality; and only `Object.equal?` can guarantee real identity equality. But it does not make the implementation of `==` in Delegator look right to me. IMHO, `Delegator.new(a) == a` doesn't make sense because: 1) Delegator of a is not a. (unequal identities) 2) Delegator of a has nothing to do with a, it is not a subclass or a parent class. (unequal inheritance/class) Let's go with the really extreme example with a delegator of `nil`. foo = FooDelegator.new(nil) if foo puts "something" else puts "nothing" end # =&gt; "something" if foo != nil puts "something" else puts "nothing" end # =&gt; "nothing" Anyway, just to make myself clear. The main point I want to speak out throughout the article is not about ranting at Ruby, but about these features in Ruby might sometimes bite you back really hard, so use them with caution and care.
`==` means value equality, not object equality. Yes, that is how Object defines it, but that's because Object doesn't have any kind of value semantics. `Array.new.push(1) == Array.new.unshift(1)` despite being different objects, because they have the same value. The value of a delegator is the object it's delegating to, thus `MyDelegator.new(v) == v`. Delegation is as core a part of OOP as inheritance (if not more so than). What *is* confusing, and what I think is a flaw in Ruby, is the example you posted. `if` doesn't use a message to evaluate it's condition, it just checks if the value is nil or false. A better implementation would be to have `falsey?` or `truthy?` messages. Also, related to this, `nil == MyDelegator.new(nil)` returns false, even though the reverse is true. In practice, delegation isn't often used with primitives like nil or false so it's not a huge deal, but I've run into it before.
Ernm Class Hello def log $logger.info "hello" end End
&gt; 1. The [] method Using `[]` for access to both indexed objects (arrays, strings) and maps is common in many languages so I don't get what is confusing here. Using it to call a proc is supported but not commonly used, there are cases where it is useful though. &gt; 2. The % operator Is also commonly use for modulo arithmetic and string formatting in many languages so I don't get what is confusing here. It's also extremely rare to use it for string formatting in Ruby. &gt; 3. The Integer#zero? method The `==` could do literally anything since `==` is often overridden and you're calling the version from `number`. It's likely preferable to throw an exception when `number` isn't `Numeric`. &gt; 4. The $[number] global variables These exist for use when using Ruby as a `sed`/ `awk` alternative via `-n` / `-p` / `-e` / etc. If you aren't doing this then don't use them. &gt; 5. The masterpiece of the omnipotent God: Time.parse I don't get it, read the docs, it's pretty clear what it does. If you want a more strict parsing there are a number of tools available to you like `strptime`. `Time.parse` is great as a lenient parser, if you don't want that, don't use it. &gt; 6. Delegator `==` means 'Value Equality', if you want Object equality you should use `equal?`. You also, rather deceptively, cherry picked the docs here. You quoted: &gt; Equality ‚Äî At the Object level, == returns true only if obj and other are the same object. - Ruby documentation. The actual docs are much more complete: https://ruby-doc.org/core-2.4.1/Object.html#method-i-eql-3F 
Learn Ruby the Hard Way
&gt; Delegator of a is not a But it's supposed to be pretending to be a. That's the whole point. It delegates all questions back to a, including the question of equality.
Hmm. Which means I can't do like expect(logger).to eq "hello" ?
Among other things in this post, I'm _particularly_ baffled by what could possibly be confusing about the `Integer#zero?` (or more accurately, `Numeric#zero?`) method. That shouldn't be any more baffling than `String#upcase`. In both cases, they're methods that only apply to certain types of objects. They're not methods of `Object`, so you should not assume they can be used on all objects.
Is the :) because you already know that tty-spinner actually uses https://github.com/piotrmurach/tty-cursor for the cursor movements?
Yeah, I agree. Coming from python ruby is a much nicer language, it's pretty and cool and great and everything but it seems like everyone forgets that it can do things other than web which means that it is sort of sold short as a shitty JavaScript, when in reality it is so much more than that.
What exactly do you mean by "showing empty vars"? If things aren't being set, then the `options` hash should be completely empty, not showing empty variables inside of it. The code as you originally posted it works fine and looks fine. If that's not the exact code that you're running, what _is_ the code that you're running that doesn't work for you?
Introduction to Algorithms by cormen is the one I'm slowly drilling. Of course, creating Algorithms is not something you are good at at a single language....one ring to rule them all.
expect($logger).to receive(:info).with "hello"
RSpec has an `output` matcher designed for testing whether stdout or stderr has been written to. https://relishapp.com/rspec/rspec-expectations/docs/built-in-matchers/output-matcher I don't know where `$logger` is coming from, so it's hard to say, but most likely the output matcher will work for you. Assuming your `$logger.info` method writes to stdout, here's an example: class Hello def log $logger.info "hello" end end it "had me at hello" do expect(Hellow.new.log).to output("hello").to_stdout end
Interesting. Kind of like duck typing, for exceptions. What was your use case for designing this? I can't think of any time I would have wanted this.
Anytime we see a rescue with an if right after it, switching on the message or some attribute of the exception. I personally saw this pattern a lot when interacting with third party gems and their exceptions. EDIT: When I get to the office I'll see if I can find a concrete example.
Thanks!
Not sure if it fits exactly what you're looking for, but *Metaprogramming in Ruby* is a good book for coding things in a way that some languages don't allow. Was really helpful for me coming from a Java background, and I apply some of the concepts to JS as well as Ruby.
1) that sounds fair 2) Could you show me which languages are they? I could only think of Python. 3) Yes preferably, but my point is why don't we just use `== 0` instead of using `.zero?`, which your comment didn't really pinpoint on. 4) 5) Yes that is exactly the whole point in this article, when we use then we should understand what the consequences could be. 6) I have extended my explanation somewhere in he comments.
Thanks for the reply. I'm going to check it out for sure :-)
Just need rack
Hmm, the author didn't really mention Java, and didn't say Java logs aren't/are noisy. Why bring in a language that has nothing to do with the blog post? The blog does bring a solution (in a way), even though it sounds really promotional.
The options var is entirely empty when I put it. The code I pasted is verbatim what I'm running. Very odd.
Wow.. I will try this out.. I have another solution about using StringIO to keep the logger and use it to expect to the one we want..
We at [SciRuby](https://github.com/sciruby) try to develop a set of scientific libs for Ruby.
It works really well, and it uses StringIO [behind the scenes](https://github.com/rspec/rspec-expectations/blob/add9b271ecb1d65f7da5bc8a9dd8c64d81d92303/lib/rspec/matchers/built_in/output.rb). No need to do it manually!
&gt; Ruby has [nyan-cat-formatter](https://github.com/mattsears/nyan-cat-formatter) for rspec. For things like this is why I love the Ruby community.
This looks interesting. I've also used https://github.com/ruby-concurrency/concurrent-ruby which is worth checking out.
[A Common-Sense Guide to Data Structures and Algorithms]( https://pragprog.com/book/jwdsal/a-common-sense-guide-to-data-structures-and-algorithms) appears to use Ruby from looking at the samples. I haven't read it yet though. Edit: It says "examples in the book are in JavaScript, Python, and Ruby."
üëè Ruby üëè Has üëè Threads üëè
Hey, I implemented the implicit syncing. Thanks for the idea! :) https://github.com/exAspArk/batch-loader/blob/master/CHANGELOG.md#v100--2017-08-21
what is the diff between this and sequel? 
If you're starting a new project, then yes check out sequel or rom. This would only be useful in a large, established ActiveRecord app that is running into perf issues and running out of options.
I haven't dug into this, i'm curious how the event loop actually works in Ruby. I.e. how does it know when the current task is doing IO? What mechanism does it use to come back and finish the rest of the task after IO is done.
There's reasons to using event driven architecture. In a single core case or one process per CPU, it's actually faster than multiple threads because there's no overhead to thread context switching. I love me some threads, and while they can accomplish similar things, they're not perfect drop in replacements for each other. There are tradeoffs. Source: I just finished a master class in operating systems. 
While you are correct, Ruby (well MRI) has the GIL that makes threads much less performant also on mpu architectutes. Multi-process is more effective there.
This is nothing special in the library, let alone in Ruby. This is how select works and has been for a couple of decades now [1]. Tl;dr you just don't block on file handles :) [1] - https://linux.die.net/man/2/select
I mentioned the case of using a single core or only one process per CPU, so adding extra processes wouldn't be more effective, it would just add more memory overhead. The only time you would be able to context switch to another process would be when it is blocked on IO, which is the same place that the GIL is released which would allow you to execute another thread. A hybrid approach is the "most" effective. Multi processes to take advantage of multiple cores, then within those processes multi threaded or event-driven will give let you max out your CPU load by not blocking on IO. 
In ruby IO.select will block, so how do you execute multiple of them? I understand how you can do it with threads, but I don't understand how you would do it from within the same thread? I've written multithreaded code in multiple languages, but I've never written event-ed code in any lang. 
You're right I missed the "one process per cpu". So I basically repeated you on that. Sorry! Every single ruby app I have seen in production though is IO bound. If you need computation performance Ruby would be a bad choice anyway. Given that many ruby apps use IO through C extensions (eg postgres) many are fully blocked by the GIL while waiting on the C extension doing IO. This is why in Ruby app multiple threads don't really work in practice. When doing IO without the GIL I agree that a hybrid approach using multiple threads and processes can reach the best throughput.
I've tried React after mostly working with jQuery. It's... Not awful.
The GVL (new hot name for GIL) can be released in C extensions. You can do it with `rb_thread_call_without_gvl` (just looked it up). Take a look at how the mysql2 gem does it https://github.com/brianmario/mysql2/search?utf8=%E2%9C%93&amp;q=rb_thread_call_without_gvl&amp;type= Here's a stack overflow link https://stackoverflow.com/questions/36245878/releasing-the-global-vm-lock-in-a-c-extension-without-using-another-function/36378254 
The reactor blocks but only for the time until the next timeout. https://github.com/socketry/async/blob/e3293ca5c87b54ab7a46fee666bd4649b0622ed2/lib/async/reactor.rb#L128-L151 Line 143 is specifically where it blocks waiting for events on any IO that is scheduled with the reactor. It's possible to do timers using the IO monitor too, but a separate system called `timers` is used because it's hard to get compatibility between unix, windows and the JVM.
Threads and event-based run-loops are not mutually exclusive. In fact, [async-container](https://github.com/socketry/async-container) can run your event loop using either threads or forked processes as a policy decision. The best performance IMHO is to use 1 process per CPU core, rather than one thread, provided you don't need to share data between connections (or it is done via a backend database). This works fine for, say, a DNS server or HTTP server. The benefits of Fibers over Threads w.r.t. an async reactor: - Fibers are cooperatively scheduled so if you do have shared resources within reactor (e.g. a memoized cache) you don't need any locking. - Fibers are deterministic (of course, IO is not). - Fibers have less scheduler overhead (in the best case it's about the same as a function call to resume a Fiber) Of course, if you need actual processing power, Threads are great. So, that's why one reactor per thread per processor core is the best strategy for throughput.
Seems interesting. Starred and bookmarked.
No one is really wrong in this thread. Yes, the GVL sucks. But, many of it's problems can be avoided. And to a certain extent it does solve a problem within Ruby. In my testing, with `async-http` on my desktop 4-core i7: - 100,000 req/s with keep-alive. - 30,000 conn/s with separate connections. I also compared with a [similar C++ framework](https://github.com/kurocha/async-http), and I got the same throughput on one thread, that I get with 8 processes on Ruby. So, for what it's worth, Ruby is about ~10x slower than C++ in this space. When I hooked `falcon` up to a real existing rack application, the req/s went down to about 2000. This was similar to Puma. Because it turns out the cost in the rack app is really high, so the web server is significantly faster than the rack middleware. This wasn't unexpected. So, what's the benefit of `async` you may ask? Because of async's composable design, you can nest non-blocking code efficiency, e.g. HTTP client requests, they won't block the entire server. There is one other problem. A true M-N (thread-fiber) implementation maintains a thread-pool and schedules fibers onto threads. If a fiber does block, it won't block the entire server as there may be other threads available for IO processing. A server which almost uses this model is [yahns](https://yhbt.net/yahns/yahns.txt). I think it's better to keep blocking behaviour out of the reactor - but sometimes it's not possible, even stuff like `File.open` might block. But, with the GVL, it might even block the entire interpreter, so you really need multi-process. A true M-N model might be a goal for the future, if it makes sense given all the other issues. It does make the design of the system much more complex, as you expose client code to multi-threaded environments and you can no longer use a multi-process model. It's not a pure improvement but more of an option which mitigates some of the effects of blocking code in the reactor loop (insofar as you have threads available). There is some interesting discussion here https://bugs.ruby-lang.org/issues/13618 The biggest issue as I see it with `async` is that it is hard to integrate with existing C extensions because Ruby lacks exposing the appropriate APIs. It would be interesting if this were made possible. The GVL is not really an issue here, it could be removed and it wouldn't affect the design of `async`.
Upvote just for the creative name.
Another difference between multi-thread and multi-process design is latency. Having a single thread accepting connections and a work pool (e.g. puma) is quite high latency compared to a fiber which accepts the connection and immediately begins processing it. puma -w 8 % wrk -c 32 -t 32 -d 10 http://localhost:9292/wiki/index Running 10s test @ http://localhost:9292/wiki/index 32 threads and 32 connections Thread Stats Avg Stdev Max +/- Stdev Latency 40.90ms 25.46ms 228.79ms 68.09% Req/Sec 25.60 17.39 131.00 96.08% 8146 requests in 10.10s, 27.17MB read Requests/sec: 806.54 Transfer/sec: 2.69MB async-http with 8 processes using forked model % wrk -c 32 -t 32 -d 10 http://localhost:9292/wiki/index Running 10s test @ http://localhost:9292/wiki/index 32 threads and 32 connections Thread Stats Avg Stdev Max +/- Stdev Latency 9.96ms 6.08ms 119.85ms 98.30% Req/Sec 99.50 28.28 130.00 90.18% 8626 requests in 10.10s, 28.89MB read Socket errors: connect 0, read 0, write 0, timeout 0 Requests/sec: 854.35 Transfer/sec: 2.86MB Compare the latency of the above tests for example.
The event loop is implemented using [`nio4r`](https://github.com/socketry/nio4r) which is just an IO selector, and [`timers`](https://github.com/socketry/timers). On Linux, `nio4r` uses `epoll`, on macOS it uses `select` because kqueue is (apparently) broken. There is a discussion to expose timers directly from the event loop. In addition, we could probably build `async` on top of `libuv` or `libev` with no visible changes to the upper level API.
&gt; This would only be useful in a large, established ActiveRecord app that is running into perf issues and running out of options. Isn't that about the time the programmers should be updating their LinkedIn profiles, not worrying about improving query performance? ;-)
`concurrent-ruby` is awesome but `async` tries to avoid exposing client code to a multi-threaded environment as part of the API. However, if you have processor-heavy work, my suggestion is to use `async` for the IO and a work queue for the job processing. This works very well in my experience.
There is also a (admittedly small) contingent of developers who are best at going in and fixing/saving those situations
And to be clear, not necessarily b/c it's "bad", but just when there's tons of data that you need to load &amp; eager load, more than ActiveRecord was designed to handle.
Sometimes data is messy. I kinda don't hate this.
Just to be clear, the options hash is still empty when you set some of those flags from the command line? I ask this because if you're not setting those options via the command line, it won't add the keys to the hash with false values, so you'll end up with an empty options hash if you don't set any of those command line options. That's it working correctly. It'll only add them as true if you set them. It works this way because you still get a false-y return value (nil) from a hash if the key doesn't even exist.
Cool.. thanks mate 
It's also worth to point out the downsides of using fibers, specifically: - can't be used across threads (are bound to the thread they were created in); - are implemented using threads in JRuby (JVM doesn't support coroutines); So fibers are a very frustrating tool if you are targeting multiple rubies, and limited when targeting threads. I'd say that the second reason is why it never took off really.
Alright so this is going to sound really stupid: * Yes I was testing with inputs from the CLI * At first * Turns out that pressing up-arrow and re-running a command without verifying it includes said arguments is a recipe for fail Apparently I had a problem, then fixed it but didn't realize it because I kept testing with no arguments. I'm the dumbest motherfucker on my block right now, I guarantee it
They are both good points. Fibers can be transited across threads. It's just a limitation of Ruby AFAIK, thought I've never tested it. I've implemented Fibers in C++ and it's possible to transit them between threads but it also makes it more complex to use them. There are pros/cons both ways. Also, see https://bugs.ruby-lang.org/issues/13618 for a discussion about Fibers which work much the same way as they do in `async`, only implemented in MRI directly. The implementation in the JVM is a limit of the JVM, which is unfortunate, but it may eventually be possible to support native fibers. Honestly, I've played around with JRuby and found it fairly buggy when it comes to actual IO, e.g. https://github.com/jruby/jruby/pull/4684 - so this and other issues make it... uh.. hard to target for any serious general work - MRI is still sort of the "gold standard".
Ok so the website says it's more flexible than paperclip but from the website alone I don't really see what Shrine does better than paperclip. I guess I have to try it out some time to really form an opinion.
Yes, I chose not to provide this explanation in the README, because I would also have to compare it with the rest of the file upload libraries (CarrierWave, Refile, Dragonfly etc), not just Paperclip. That's why I decided to start a series of [blog posts](https://twin.github.io/) which thoroughly explains all the advantages of Shrine. But I can summarize here some of the advantages of Shrine over Paperclip: * Support for ORMs other than ActiveRecord (I use Sequel, so I cannot even use Paperclip) * Retaining uploaded file in case of validation errors * Ability for AJAX uploads to your app or directly to the storage service * Proper implementation of backgrounding processing/re-uploading *and* deleting files (see [this post](https://twin.github.io/file-uploads-asynchronous-world/) for more details) * Can parallelize uploading of processed versions * Design allows using [VIPS](https://jcupitt.github.io/libvips/) or [ImageFlow](http://www.imageflow.io/) for image processing, not just ImageMagick * Avoids the [unstable](https://github.com/thoughtbot/paperclip/issues?utf8=%E2%9C%93&amp;q=label%3A%22Spoof%20related%20or%20Mime%20types%22%20) MIME type spoofing detection * Support for resumable uploads (see [this post](https://twin.github.io/resumable-file-uploads-in-ruby/) and [paperclip#1560](https://github.com/thoughtbot/paperclip/issues/1560)) * No unnecessary file copying, and cleans up temporary files (see [paperclip#1326](https://github.com/thoughtbot/paperclip/issues/1326)) * Ability to extract custom metadata and do custom file validations (useful e.g. for videos) * *Much* simpler and more flexible storage abstraction, which makes it easier to write new storages * It's still maintained (see [paperclip#2477](https://github.com/thoughtbot/paperclip/issues/2477))
Really cool features. Thanks for the detailed reply. Now I totally got to try it! :)
I think he was saying that even rails logs aren't all that noisy compared to others (Java.)
Would you know of an example that uses Shrine with Froala? I currently have uploads for things like user avatars via Carrierwave but Shrine looks really nice. Think it will come down to which one I can get to play nicest with Froala. 
Seems a bit convoluted. At the end of the article, you essentially settle on initializing factories with known data (traits for the win, here). Long read for that, and you still don't end up with the best solution.
At the start of this year I needed to implement recurring events in a scheduling Rails app at work that uses Full Calendar. I ended up implementing it almost exactly the same as this, and it has worked out very well for us, except that I was not aware of the "ice_cube" gem and so I ended up implementing the recurrence rules and it's supporting pieces as POROs. It was a fun experience and I learned quite a bit. And it's nice, now, to have a little bit of validation of the implementation/design (besides the fact that it's been hammered by our users for half of a year or so).
Great to hear. It's definitely one of the most full featured calendar libraries that i've seen.
&gt;Support for ORMs other than ActiveRecord Hohohoho! Are you using Rails? How are you using Sequel instead of AR? I really would like to know.
I'm not using Rails. My preferred web framework is Roda, and at work we use Cuba. In Rails it's probably easiest to use Sequel with [sequel-rails](https://github.com/TalentBox/sequel-rails), which automatically adds migration Rake tasks and similar things.
I don't e.g. see why I can't use concurrent-ruby to create a globally available Concurrent::Array in an initializer, and a TimerTask which flushes out the contents of that array periodically, so long as that TimerTask fires off it's HTTP request to pusher async (a facility their ruby lib provides).
Are you sure you're using Sidekiq correctly? Sidekiq with Redis is basically a message queue with async processing. You can specify as many concurrent processes as your machine can handle to speed up the processing. You can add more hardware / worker nodes all running your sidekiq workers to scale it up even more. 
Yes, so we can scale up Sidekiq, but we aren't able to leverage the fact that we can send more than 1 message to Pusher at a time. So, what would be preferable in our case is a periodic job which flushes out as many queued messages as possible in a go. With Sidekiq we'll also be at 1 message : 1 sidekiq job.
Try this: https://github.com/gzigzigzeo/sidekiq-grouping It should allow you to write a worker that groups 10 Pusher calls into one job and let you hit Pusher's maximum notifications/call limit.
Oh my god, thank you! I cannot tell you how much I have wanted to use something but I **don't use activerecord** You may have just saved my bacon.
Personally I use Padrino (which is like Rails-lite) a lot and Sinatra as well.
&gt; Finally, this method is very challenging to test. In order to write a simple unit test we either have to mock all of these dependencies, write an integration test instead, or just give up out of frustration. Frustration when writing tests is a huge, glowing red flag: it‚Äôs telling you, ‚ÄúHey! Stop! There‚Äôs something wrong with the code you‚Äôre trying to test.‚Äù I generally write pretty short functions, but that's a byproduct of the above. I seriously rage the fuck out when I'm trying to write a test and 3/4 of the test code is establishing context to a) make the method callable or b) have an assortment of objects to test side effects of the method under test. There are absolutely positive situations where testing of side effects and external state is required--maybe even desirable, but that's no way to live when that kind of testing is not absolutely required. I started TDD with C#, and while those tools have vastly improved over the years, the way to design testable code required smaller and more isolated units. I think Ruby and dynamic languages in general do not require you to be so thoughtful in how you are able to put your code under test. So, if you haven't spent a lot of time outside of that kind of ecosystem, then some of these design decisions may not make the most sense. However, it's still very important to me that a test is easy to set up and that is has clear expectations. There are times when that's not possible, and you have to deal with that accordingly. But, your general approach should consider testability and extensibility (for OCP). Of course, these are just my opinions. There are many different ways to approach software design and many opinions exist for how to do it best. 
LPUSH the message to Redis. LPUSH returns the new size of the list. Create a Sidekiq job to drain the list when it reaches 10. amt = Sidekiq.redis {|conn| conn.lpush "pusher-data", "my-msg" } DrainPusher.perform_async if amt &gt;= 10 
Please note there are a dozen error edge cases here that can be tricky to handle. Tread carefully.
Advice here applies to pretty much any library. I remember talking to Neeraj Singh way back before his BigBinary days and he was describing digging through Rails code to figure out how something actually worked; tracing it line by line was and still is the right idea.
I hear you. I work in some code bases with lots of truly enormous functions. I'm talking 200-300 line monsters of procedural code. It's virtually impossible to test, which means I'm terrified to change anything for fear that I'll break something.
I don't know of any Ruby specific algorithm books off the top of my head. Still, I would recommend finding a good algorithm book regardless of what language it's in and try writing/re-writing the exercises and examples in Ruby. That's a good way to both learn how the algorithms work and improve/reinforce your Ruby knowledge.
how is this better than paperclip?
Happens to all of us sometimes. Glad it worked out!
Hm. That still sounds like gibberish to me but I get the general idea. Still don't understand why we don't do everything with methods :) 
Thanks! 
Thanks! 
Interesting, though now changes to the XML will require changing 3 (or more) places instead of 2. Small changes in your examples but may be a problem as the application grows old and the API evolves. Why not just use YAML/XML with ERB? (For loading fixtures you may want to [check this out](https://gist.github.com/sshaw/f9bad743bb53d2439501d03fb6056a4c)). Also, what did you use to map/extract data from the eBay XML? 
I've had success stepping into Rails code with byebug. When you find yourself thinking "wtf is Rails doing that?", you can just set a breakpoint and see exactly what it's doing.
For instance, both puma and passenger, I believe, use a reactor-based architecture (not this library, perhaps EventMachine in puma? in passenger I think it may be straight C) for handling actual client connections, but a work queue (multi-threaded in Passenger Enterprise or any puma, multi-process in passenger non-enterprise) for actual application request processing. This is indeed a pretty normal thing to do. Although the reactor/evented stuff is these days usually kept pretty black-boxed in infrastructure away from business logic. You don't even have to know puma or passenger is doing it. There was a period where everyone was trying to use EventMachine for their actual business logic, you don't hear much about that anymore. In part because the need to be 'reactor-aware' ends up being kind of 'viral', pretty soon everything you're touching (at least if it does IO) ends up needing to be written to be evented, and most ruby open source is not. But there is a place for evented code, as puma and passenger show. I'm curious what the authors of this new thing see as it's sweet spot, how they plan to use it or expect it to be used, how it differs from previous efforts like EventMachine. 
It really depends on your work load and I certainly appreciate why puma and passenger took this route. The problem here is that using a thread per request isn't efficient when you are IO bound. A situation where this becomes apparent is if you make further network requests (e.g. accessing a remote API). If you say, have 16 threads for processing requests, and your upstream request takes a few seconds to complete, very quickly all 16 threads will be blocked on IO, even though CPU usage will be essentially 0. `async` avoids this because the web server exposes the asynchronous processing as part of the request/response handling. So, in the rack middleware, you can use `Async::HTTP::Client` to make an upstream request and while that is happening, other requests can be processed. Both approaches have their merits - I built and maintain a Vulkan renderer as a web service in C++, and we use async IO for handling the requests, but a thread pool for doing the actual renders. There is no silver bullet. In my experience, the model followed by `async` is the most general, and not only that, because it is still essentially sequential/procedural, you don't need a different cognitive model (e.g. callbacks, async/await) for writing IO code, so it's easier to use/less likely to have bugs.
&gt; While you are correct, Ruby (well MRI) has the GIL that makes threads much less performant also on mpu architectutes. Multi-process is more effective there. Well, not neccesarily. It depends on what you are doing. If what you are doing is very IO-heavy, the overhead of multi-process is NOT likely to be more 'effective' than threading. There are _definitely_ places where threads are very effective on MRI. The GIL _does not_ prevent threads waiting on IO from being switched out and another thread scheduled. (Threads existed in unix OSs and were used even before most servers were multi-core!). There are also places where async/evented/reactor-based code is effective. I'm less sure what they are. 
Is there any reason you can't have hundreds of threads in your worker queue though? I've done that before with puma, with requests that are seriously IO-bound. It worked. What you describe as doing with your Vulkan renderer sounds pretty similar too. It does seem to be a pretty widespread pattern. There was a period trying to use evented stuff in ruby web apps was popular, using [EventMachine](https://github.com/eventmachine/eventmachine). I think we don't hear about it too much anymore, because of the way that so much of your code needed to become EM-aware. You can't just use ActiveRecord, you needed to use a patched EM-aware AR (which of course was hard to keep maintained). (Probably true of Sequel too, you'd have to use something that was designed from the start to be evented). You can't just use the standard http libraries, you need to use ones that are EM-aware. Anything that does IO, needs to be EM-aware. Evented works without headache when built on an ecosystem assuming/enforcing it from the start (say, Node.js). But in ruby people found it to be a headache -- unless keeping it black-boxed handling some specific sorts of IO where the actual 'business logic' doesn't really need to know about it. Like puma, or I think like what you describe in your renderer. I am curious where/how people that developed _this_ library are using it, and a compare/contrast with EventMachine. 
Which program did you decide on, if you don't mind my asking? As far as prep, the program likely provides some pre-work for you to do, or a list of books you'll be using. Absolutely do all pre-work, but outside of that my advice would be to enjoy the free time you currently have. It's easy to get burned out in intensive programs.
Launch Academy in Philadelphia. Thanks for the response.
&gt; Is there any reason you can't have hundreds of threads in your worker queue though? I've done that before with puma, with requests that are seriously IO-bound. It worked. Threads are great and I would be the first to advocate that each thing has it's place. If you compare the same workload, with threads and fibers, there are some differences: - Threads need synchronisation primitives for shared resources, but fibers don't if they are running in a single threaded reactor. - Threads are less deterministic/fibers are more deterministic. - Threads use more resources in the kernel than fibers. - Threads take longer to context switch. A good fiber implementation is not much slower than a function call. - Thread-per-request is less likely to have issues with head-of-line blocking or blocking APIs, e.g. `File.open`. - Threads work better for CPU bound workloads and Fibers work better with IO bound workloads. &gt; What you describe as doing with your Vulkan renderer sounds pretty similar too. It does seem to be a pretty widespread pattern. Agreed. &gt; There was a period trying to use evented stuff in ruby web apps was popular, using EventMachine. I think we don't hear about it too much anymore, because of the way that so much of your code needed to become EM-aware. You can't just use ActiveRecord, you needed to use a patched EM-aware AR (which of course was hard to keep maintained). (Probably true of Sequel too, you'd have to use something that was designed from the start to be evented). You can't just use the standard http libraries, you need to use ones that are EM-aware. Anything that does IO, needs to be EM-aware. I understand this pain. There is discussion here about integrating such a model directly into Ruby: https://bugs.ruby-lang.org/issues/13618 that would allow existing things to just work with no modification. `Async` is not that different from EventMachine at present - you need to use it's socket wrappers. However, as discussed above, it would be ideal if `async` could hook into the Ruby APIs for waiting on IO and processes. &gt; Evented works without headache when built on an ecosystem assuming/enforcing it from the start (say, Node.js). But in ruby people found it to be a headache -- unless keeping it black-boxed handling some specific sorts of IO where the actual 'business logic' doesn't really need to know about it. Like puma, or I think like what you describe in your renderer. The above bug report, there is a specific discussion about how to build it directly into MRI and the specific benefits you mention. &gt; I am curious where/how people that developed this library are using it, and a compare/contrast with EventMachine. Since I'm the developer of Async, I can probably answer your question. The first thing I'd encourage you to do is read the motivation section: https://github.com/socketry/async#motivation as it specifically discusses some of these points. Some more specifics: EventMachine up until recently didn't support IPv6. It was also buggy and crashed under load. It has a bit of an unusual callback system, and the API is pretty clunky at best. RubyDNS (my DNS server) used EventMachine for a number of years, and lots of projects are still pinned to the last release that used EventMachine, despite it being super old. I think `async` is the right way forward.
thanks!
Fair enough. I didn't see the point until I had that situation, and suddenly it made sense :D
Haha, I guess that's the wisest thing to say ^^
I already [answered](https://www.reddit.com/r/ruby/comments/6v9mcg/rails_uploading_images_confidently_with_shrinerb/dlymd7b/) this question above ;)
Great article! &gt; Devise is the way to go when it comes to Rails, however it could be overkill for an API-only application I'm always a bit confused when I see someone saying this. Don't you need more-or-less the same authentication features in a JSON API as you do in a full-stack app?
Hello, I've put together a [webservice gem](https://github.com/rubylibs/webservice) - yet another Sinatra-style HTTP JSON API builder ([in about 100 lines of ruby](https://github.com/rubylibs/webservice/blob/master/lib/webservice/base.rb)). Why? Why not ;-) The main "innovation" is easy dynamic loading of services e.g. use `Webservice.load_file()` to get a ready-to-use web services (rack) app. Example: # service.rb get '/' do 'Hello, world!' end and # server.rb require 'webservice' App = Webservice.load_file( './service.rb' ) App.run! and to run type $ ruby ./server.rb Cheers. PS: Inspired by [Almost Sinatra (Sinatra in 6 lines of ruby)](https://github.com/geraldb/talks/blob/master/almost_sinatra.md) and New York, New York, Nancy, Rum, Cuba, and other Sinatra-like micro libraries.
&gt; How can I get my work reviewed every now and then to have a different set of eyes spot my bad habits and suggest better ways of doing things so I can improve as a programmer? &gt; I've thought about starting contributing regularly to some ruby-based open source project. Are code-reviews and/or other forms of feedback something that can be expected in any open-source projects? Yes, open source is a good place to expect code reviews -- but not all projects, unfortunately. Some of the authors just will accept "anything that works", others just "reject anything they don't like"; there are some that accept only your ideas and then reimplement it themselves... Some advices to consider: * take a look at [Google Summer of Code organizations](https://summerofcode.withgoogle.com/organizations/?sp-search=ruby) and other similar initiatives -- the fact they are accepting students for the summer and mentor them typically means they are open to contributions from people with different experience and are ready to review and explain; * when you'll find some project you like, start with small PR with explicit statement about the fact you are eager to see the reviews (some maintainers are shy to do the detailed reviews because they are afraid to offend/alienate contributors); * take a look at their open and merged/rejected PRs and how they are typically communicating with contributors. And, to end this, some shameless self-promotion: 1. We at [SciRuby](https://github.com/sciruby) (scientific Ruby) org are open to contributions and ready for providing detailed reviews; 2. Also, if some of my personal gems ([here](https://github.com/zverok) and [there](https://github.com/molybdenum-99)) are clicking with you -- I have a decent of experience in Ruby _and_ in mentoring/reviewing. Both of those suggestions are somewhat far from usual Rails/web domain, though we are currently working on alliance of scientific libraries with Rails.
You could post to: * /r/codereview * /r/reviewmycode * /r/critiquemycode * [Code Review Stack Exchange](https://codereview.stackexchange.com/)
Focus on the basics. Make sure of your HTML, CSS and JavaScript basics: anyone who hires you as a junior dev is going to expect to train you up in their preferred language/framework/whatever, your best bet is to have a solid understanding of the *logic* behind object oriented programming so you're easily trained. Learn your workflow practice: GitHub, Bitbucket, etc... pick one and get your workflow habits down to best practise as best you can. Training a junior is *far* better if you're not spending time on merge conflicts, etc... Learn how to effectively use a command line interface *now*. Don't get caught up in the latest popular framework that comes out; there's always going to be another React coming through the pipes... basics first! Work on your communication; being a concise communicator is a huge asset in development. Last thing that springs to mind: **READ THE DOCS** 
You might be interested in [exercism.io](http://exercism.io). It only covers relatively simple programming problems, but after you've submitted your solution, you can see everyone else's solutions and give/receive code reviews. Seeing all the different approaches to a single problem, and comparing them to your own, is a pretty good way to learn. As for reviews of larger changes, like adding a feature to a Rails app, I'm not sure. 
Good ol' "I'll retell the official docs in my own words and make a nice blog post". ¬Ø\\\_(„ÉÑ)_/¬Ø Always good, never gets old.
I'm in Philly too. If you ever want to chat I went through a bootcamp a few years ago (not Launch academy) just DM me. I currently work in the city at a startup.
Thank you very much! It was stuff like this I was looking for. At a quick glance it wasn't that much ruby in the sub-reddits, but I'll do what I can to change that. :) 
Sometimes it's not _really_ overriding the gem in stdlib, but namespace lookup is resulting in you getting say Something::String, instead of the top-level String. `::String` is how you insist on the top-level (eg) String. Otherwise, if it really is overriding -- I don't think there's a solution. Other than no longer using the gem (or changing the gem to not do that anymore). It's bad practice on the gem's part. I'd file a GH issue on the gem with the nature of the problem. The gem _could_ use the newish ruby "refinements" feature. But that would require changes to the gem code. If I were the author, I wouldn't bother with refinements, I'd just have the gem _not_ override stdlib classes. 
Where did you get the name "case equality" for the `===` operator?
I'd clarify one thing: &gt; Threads work better for CPU bound workloads Sadly, not in MRI, because of the GIL. There's little purpose to using threads for CPU-bound workloads in MRI. But using threads for IO-bound workloads can be quite profitable, I do it all the time. The most recent thing I did with threads, uploading a bunch of files to S3, multi-threading it. Worked out well, greatly increased total bytes/second to s3 over a single-threaded implementation. (Fibers can indeed be even better for IO-bound workloads, I agree -- if you can manage it! Fibers are great performance-wise in the right circumstances, they just sometimes require more widespread code changes than threads. But fibers can get you to insane levels of performance beyond what threads can.)
! somewhat related :D I recently just began learning ruby...I wanted to use a more popular language than some of the languages i've been using the last give or take 10 years. I am really really enjoying ruby so far, but I feel like resources are all from 3-4 or more years ago, even books on ruby have seemed to flatline. As a ruby newbie what do you think are the best resources today? I've also found some nice resources that i think I might try to get moderators to add to the links on the right... to help others new to ruby get started. Once I get my toes a bit more wet though SciRuby is on my list to get more familiar with, so thanks for contributing to it :D 
Also, find a local development group ( meetup.com can help find them ). Even if there is not a ruby specific, any programming group will help improve knowledge
Way behind Python 
In `case` statements, this operator is used behind the scenes to compare the `case` argument with the `when` clauses. 
You are absolutely right. I was talking in a general sense, not the gimped "Thread" model implemented by MRI. Thanks for the added clarifications.
There's also a relatively new startup at pullrequests.com if you want to spend money
I'm not totally sure I follow your logic, the double negative at 2am is giving me a bit of a brain storm. Excepting my possibly incorrect understanding of your comment, on Linux, with the ability to have multiple processes bind to the same port, I've seen multi-process work better than multi-thread, especially for MRI. I think we are in agreement :)
Sorry, my language was confusing (this stuff is confusing to talk about!). I think we're actually not totally agreeing. I think it probably depends on what you're doing. It's true that MRI has the GIL that will prevent more than one thread in a process from using a core simultaneously. But for IO-bound work, threads can still work out well, and have much lower RAM overhead, and overhead of 'inter-thingy communication' where the thingy can be a thread or process. Threads when first implemented at the OS level were sometimes called "light-weight processes". I think it depends on what you're doing. If you're talking about a network server, using MRI, a multi-process model is pretty crucial for maximizing performance, because of the GIL. (Although a hybrid model with multi-process, each with multi-thread internally can be even better, as both puma and passenger enterprise can do). But let's say i want to fetch 1000 HTTP get responses. A thread-pool is a very appropriate tool for this job, even in MRI. 
I think that `async` provides the next level: in your example, using `async` would mean you don't need any locking but probably the same level of throughput, and in some cases lower latency.
You think current MRI threading model is limited, feel lucky we don't have the "green thread" model from MRI 1.8 anymore! In modern MRI, threads actually work pretty darn well in actual practice for many kinds of IO-bound workloads. Fibers can get even more performance, but there are lots of cases where that more performance won't really matter, your actual workload is going to take up so much time dwarfing the extra performance you'd get from avoiding context-switching by using fibers. But there are also cases where it does matter. :)
You are right on all counts. But it's not just about performance. I prefer sequential programming model without thread mutex/lock/conditions. With `async` your code would just be basically a loop - no locking required.
I have personally found it much more difficult to get my ruby code working with an async reactor-evented model, requiring heavier dependencies, and more changes to more parts of my code. This may be in part because I've spent so much time in my career already learning how to do multi-threaded concurrency though. It's not like multi-threaded concurrency is _easy_, I just already know the patterns to do it as painlessly as possible (and ruby-concurrent helps a lot), what the categories of failure modes are and how to recognize and deal with them, etc. Often "probably the same level of throughput and in some cases lower latency" is not enough advantage for what, to me, can be a much more challenging implementation. I agree that if more support for reactor-evented were built into MRI, it would change the cost-benefit calculation for many. But I think a lot of people got burned by dependency on EM, whose support and ecosystem kind of languished. (Obviously in node.js, async evented is essentially the _only_ way to go, and the entire ecosystem assumes it. Very different cost-benefit. It's not just about the theoretical advantages of each model on a blank slate, it's about platform and ecosystem and practicalities of actually writing code too. If you want to do multi-threaded concurrency in node.js, you're pretty much out of luck!). But for the times you really _do_ want/need reactor-evented (say, puma's actual client-handling code), your contribution to the ecosystem will hopefully make it a lot easier (compared to languishing EM), and expand the places where it makes sense to a given developer in a given context to use it, so thanks! If I'm spending lots of time writing caveats, it's because I know the tendency of some parts of the ruby community to read something saying (eg) "evented is better in these circumstances", and just cargo-cult it trying to use it everywhere and run into much pain. :)
can you enumerate a list where it's behind, maybe people would be encouraged to help if they found one of the area's interesting 
I believe it's actually extending the stdlib module, but overriding the function I'm using. I did try the `::` operator as you suggested but had no luck. I'll have to look into the tools we're using to test and if there're any other options. Thanks
Yep, I think you'll have to fix it to _not_ do that in the sourcecode of the gem that's doing it, or stop using that gem. You could try to get a reference to the original method before loading the gem, before the gem monkey-patches or overrides it. That would allow you to restore the original implementation... but that'd probably break the gem. There might be some hacky way to get things to work, but nothing straightforward and simple that I can think of, nothing that avoids having to pay attention to every place calling this method and what it expects from it. Want to share what the method being overridden is, and what the gem is doing it, for our curiosity? :) 
[sucker-punch](http://brandonhilkert.com/blog/why-i-wrote-the-sucker-punch-gem/) might be an option to send your messages to pusher in a separate thread. 
https://ruby-doc.org/core-2.4.1/Object.html#method-i-3D-3D-3D ;) 
I think it is more about the whole data scientist ecosystem: Python: - pandas - numpy - scipy - scikit-learn - jupyter notebook (I use jupyter notebook with Ruby, best thing ever!) [edited] - pyspark Ruby: - sciruby [edited] - DaRu - nltk - Sage After doing some machine learning work at my job, I think the major missing points are the lack of a dataframe and comprehensive machine learning library in Ruby. Also the fact that py and rb syntax are so close, it is unclear if the "market" or people should create those libraries in Ruby. [I know that syntax is just a part of the language similarity; Ruby shines in metaprogramming design pattern and also the Enumerator class is amazing; while in Python, there are some design patterns in Py that are expressive than in Ruby, such as factory or delegator design patterns] Jumping to a broader view of the Language ecosystems, py and rb maybe are both losing great ground to JS. The amount of innovations and new libraries for the Node.JS ecosystem is amazing. I back this up from the development of blockchain and Dapp (distributed applications) point of view. I don't have a good framework to rely on in Ruby nor Python for that, but in JS, there is the RoR of smart contracts called Embark Ethereum. I think the current programming world is that for each "fad" or technology shift, there is the emergence of a programming language that has enough traction to become the main point for that "fad". For machine learning, python is the go to ecosystem. In the past, for web development, it was Ruby. Now, with blockchain and smart contracts, it is JS (Solidity, the preferred language to build Ethereum smart contract, is a derived version of JS). At the end, we, as developers, software engineers, product managers, have to own the decision if we should invest time in another ecosystem or stick to what we are used to. In my case, depending on the stuff I need to create, I have to use different language and tools. The only fear is that for how long I can keep it up for whatever the next fad or tech shift is. 
I prefer any library in ruby than I do in python because I find ruby easier to work in...
lol sorry....thanks :)
So I'm trying to test that invalid utf8 is being handled correctly in a JSON.parse, as this would normally cause an exception. The json gem parse doesn't throw an exception in the same circumstances, which is unfortunately throwing off the tests
Wait a minute. Base.rb is over 200 lines.... Not that it matters. I'm not going to start using almost_sinatra because of LOC. But if it's one of your main selling points, probably better to be transparent about how you come to the conclusion that 100 lines = 275 lines.
Numpy's vector computation optimizations are a huge differentiator. You could probably implement its functions in Ruby or JS and it'd _look_ similar but performance would be way off. [This article](http://ipython-books.github.io/featured-01/) describes some pieces of it.
Good point. Depends on what you include ;-) In your case did you include all blank lines and comments in your count? Did you include the (inline) helpers module? Should really move the helpers to its own file, shouldn't I? Just kidding, of course. Anyways, as you already said - it doesn't matter. 6 lines or 100 or 200. Still better than 2 000 or 17 000 ;-) Cheers. PS: For the record - the Base core (please count with me ;-): class Base class &lt;&lt; self # Note: for now defining a `GET` handler also automatically defines # a `HEAD` handler (follows sinatra convention) def get( pattern, &amp;block) route( GET, pattern, &amp;block ) route( HEAD, pattern, &amp;block ) end def post( pattern, &amp;block) route( POST, pattern, &amp;block ); end def patch( pattern, &amp;block) route( PATCH, pattern, &amp;block ); end def put( pattern, &amp;block) route( PUT, pattern, &amp;block ); end def delete( pattern, &amp;block) route( DELETE, pattern, &amp;block ); end def head( pattern, &amp;block) route( HEAD, pattern, &amp;block ); end def options( pattern, &amp;block) route( OPTIONS, pattern, &amp;block ); end def route( method, pattern, &amp;block ) puts "[debug] Webservice::Base.#{method.downcase} - add route #{method} '#{pattern}' to #&lt;#{self.name}:#{self.object_id}&gt; : #{self.class.name}" ## note: for now use the sintatra-style patterns (with mustermann) routes[method] &lt;&lt; [Mustermann::Sinatra.new(pattern), block] end def routes @routes ||= Hash.new { |hash, key| hash[key]=[] } end ## convenience method def run! puts "[debug] Webservice::Base.run! - self = #&lt;#{self.name}:#{self.object_id}&gt; : #{self.class.name}" # note: assumes self is class app = self.new ## note: use self; will be derived class (e.g. App and not Base) port = 4567 Rack::Handler::WEBrick.run( app, Port:port ) do |server| ## todo: add traps here - why, why not?? end end end ## class &lt;&lt; self attr_reader :request attr_reader :response attr_reader :params attr_reader :env def call(env) dup.call!(env) end def call!(env) env['PATH_INFO'] = '/' if env['PATH_INFO'].empty? @request = Rack::Request.new(env) @response = Rack::Response.new @params = request.params @env = env route_eval @response.finish end def halt( *args ) response.status = args.detect{|arg| arg.is_a?(Fixnum) } || 200 response.header.merge!(args.detect{|arg| arg.is_a?(Hash) } || {}) response.body = [args.detect{|arg| arg.is_a?(String) } || ''] throw :halt, response end private def route_eval catch(:halt) do self.class.routes[request.request_method].each do |pattern, block| ## puts "trying matching route &gt;#{request.path_info}&lt;..." url_params = pattern.params( request.path_info ) if url_params ## note: params returns nil if no match ## puts " BINGO! url_params: #{url_params.inspect}" if !url_params.empty? ## url_params hash NOT empty (e.g. {}) merge with req params ## todo/fix: check merge order - params overwrites url_params - why? why not?? @params = url_params.merge( params ) end handle_response( instance_eval( &amp;block )) return end end halt 404 end end def handle_response( obj ) puts "[Webservice::Base#handle_response (#{request.path_info}) params: #{params.inspect}] - obj : #{obj.class.name}" pp obj ... end # method handle_response end # class Base
What makes you think this is something overriding a base class method? It does not sound like it to me initially. 
I'm trying to deconstruct this `code` method, but failing ... can you explain how it works
You left out at least nltk and sage in your list. :) Scientists usually don't have building maintainable large-scale systems in mind. Running one-off analyses etc. is much more important. In such a situation, ease of prototyping and setup, availability of libraries etc. are much more important differentiators than, say, an Enumerator interface, block syntax or metaprogramming. I don't see any reason for a scientist to use Ruby (or JavaScript) right now. It's worse on every metric that matters *for them*. I also don't know why we cannot accept that there are multiple languages each with their pros and cons instead of wanting to do everything in one language, particularly JavaScript.
Your comment could be phrased more constructively, but I don't get the downvotes. You're right. Python (and also R, but that language I find painful to work with) is lightyears ahead in terms of data science libraries. At some point we as professionals should look beyond our personal preferences and understand that it's not particularly useful to insist on using language A for a task that language B is clearly more suitable for. That said, I still applaud the effort of trying to create better scientific libraries for Ruby. But I wouldn't advise to use them for anything serious yet.
Let's try. So we have this template for example: foo %{if true} hello #{'world'}! %{end} bar We simply convert this template code to this Ruby code: output = %{foo} if true output &lt;&lt; %{hello #{'world'}!} end output &lt;&lt; %{bar} Then we eval() this Ruby code.
Someone just shared with me this morning and was pretty excited to see this moving. Android support yet to be added, but this is pretty cool nonetheless. 
oh damn ... that's clever
For more data-science related ruby tools, check out this list (previously posted here): https://github.com/arbox/data-science-with-ruby
Also left off pyspark. I love ruby. It's my goto language where a decade ago I would have used perl. But it's clearly not overtaking python (or even scala/java) in the data science space.
fair enough :) code's very readable. +1
AFAIU, DaRu is dataframes for ruby (under the sciruby umbrella) https://github.com/SciRuby/daru but I don't know how good it is. 
I did Launch in Boston about a year ago. I'd advise starting to learn the skills you're supposed to learn at Launch right now. It looks like they're still doing Ruby/Rails/React, so you should start learning Ruby and Rails now. As far as free resources go, I like [Learn Ruby the Hard Way](https://learnrubythehardway.org/book/), and [this is a really nice Rails tutorial](https://www.railstutorial.org/book). Don't worry about looking at jobs yet. Focus on developing your skills. In my cohort, there were a few people whose technical skills were clearly superior to the others, and they easily found jobs. The people with worse technical skills really struggled to find jobs, and it seemed pretty random which people in the middle found jobs easily. Hiring partners will be seeing you right next to all of your cohort mates, so if you want a job quick, you need to look good compared to everyone else. You get out of the program what you put into it, and you'll pay for any shortcuts you take during the program once you start the job search.
As a Mac user (and ruby user) I use Tweetbot which so far does not show me promoted tweets. Perhaps given the targeted audience this could be a bit of an explanation ("power users" using clients muting promoted tweets) of why those performs less than organic ones or it's just that their system is not good at all :)
Fun read! Thanks
Cannot +1 this more than once. Focus on the basics . Learn javascript - its a glue for nearly all frameworks . git best practices . RTFM Sums up the foundations and any good starting point 
You should also check out `async` which was discussed here yesterday: https://www.reddit.com/r/ruby/comments/6v2f6k/async_composable_asynchronous_io_for_ruby/
Near the very end of the article you say: &gt; Twitter also offers different kinds of advertising that I haven‚Äôt looked into, for the hypothetical book example, they have a ‚Äúwebsite clicks or conversions‚Äù Ad type. If you are going to measure success by click through rate, then you really should run pay-per-click campaign. Additionally, both of your tweets look like click-bait. That's fine for your followers - they are in on the joke. But seeing a promoted tweet that looks like click-bait may have not appealed as much to other people.
Do you think there's a possibility of Twitter's targeting having shown the promoted tweet to lots of people who have already read those articles? I think they would be far less likely to click through. Since the articles are almost a month old, plenty of good targets may have read your article prior to seeing your promoted tweet. I'm curious what the data would look like with similarly enticing tweets, if those tweets (and accompanying article) were brand new.
I hate to say it, but the SciRuby project looks a little abandoned. No updates since 2016 for it or the packages. 
Well - if you want a simple game - go with rock paper scissors - player versus computer You can do it simply by passing in the choice as a one time one or make it more complicated with a score so that the player can see how they do...persisting the ruby file No math really involved If you decide you want to get more complicated, try tic tac toe or battleship
I did the Ad buys close-ish to when the articles came out. It just took me awhile to write about it. 
You're in a common spot for beginners, the "I don't even know where to start or what the first thing I should do is" phase. Taking those first/early steps can be very overwhelming since, as a beginner, it's hard to look at any project and not see some giant task that seems beyond you. If you're interested writing plain Ruby apps and have some spending money, I would recommend that you look into the Pragmatic Studio Ruby course. Some of the material will just be refresher content for you but the way they teach it is what I think you really need right now: they show you how to build a full program from the ground up, starting with basic Ruby syntax and going through test-driven development and packaging a Ruby app as a Ruby gem that can be published for others to use. Their courses aren't exactly cheap, though. I think their Ruby course is around $100-125. It's certainly worth the money but I know that kind of price isn't always affordable. If you can't/don't want to spend that sort of money right now, then I think a simple game is a great place to start. A basic game isn't too high scale for a beginner; you just have to break it down and work on one thing at a time. Start by writing a few paragraphs describing how the game will play. Then re-read what you wrote and try to identify nouns that could be describing classes and verbs that could be describing actions/methods. Write out those classes: what attributes will they need? What methods will they have? Then you can start writing the code to build those classes. Once you get the ball rolling, things will come together better because you'll start seeing how your classes will interact in your game. Alternatively, if you're interested in building web applications, you could start learning the basics of Rails. It's pretty easy to get started with and it has a great feedback loop for beginners, which makes it fun to learn. I initially found Rails apps easier to conceptualize as a beginner than regular Ruby programs ‚Äì still do, really. I might also suggest looking into the book Practical Object-Oriented Design In Ruby. Read it slowly: it can be pretty dense for beginners. Even starting with just the first three chapters may help spark some insights for how to design/construct Ruby programs (or OO programs of any language). EDIT: Just saw this in a comment on a different post and thought it might help you too. Try looking at [exercism.io](http://exercism.io/). They have coding exercises for a bunch of different languages ‚Äì Ruby included ‚Äì and a community that can provide feedback on each other's solutions. All the exercises use a test-driven approach too, which is good coding practice to learn. Test-driven programming is especially good for the "where do I start/what do I do next?" phases: the tests tell you what the first/next step is.
ooh that name is so terrible. I understand it's in the docs tho. would prefer docs called it "***when equality***" or "***when operator***" over string-implying "case equality" 
If you are going to measure success by CTR you really shouldn't be running ads. Source: do this for a living
Schneems, I normally love your stuff, but this piece is painting a poor picture because you fell into the trap many beginner advertisers of not optimizing or tracking to your end goals. You can hardly tell if this was a success or not based on CTR. Also, you need to spend a lot more to gauge whether it was successful or not. Targeting is a big piece as well. For example, you might have a lot more success by making lookalike audiences based on your existing customers: https://business.twitter.com/en/targeting/tailored-audiences.html Feel free to ping me if you want any additional help. I do this for a living and am happy to answer any questions (or you can pop over to /r/ppc)
Totally agree, you have my upvote.
Try look for some Ruby groups, meetup.com is probably a good place. 
Yeah sorry, was on a mobile. Ruby is missing the equivalent of good NLP, Pandas, NumPy . Maybe the last is the most important, since others are built using it. 
You don't need all the features all the time. The progress of SciRuby, DaRu, and other libraries means that many (increasingly) rudimentary analytic and ML tasks can be done in Ruby without shipping it out to a Python or R process. So while I don't see Ruby breaking into the forefront of ML research, it would be nice if Ruby web apps/jobs could simply hold their ground in terms of delivering simple analytic functionality as part of their service.
i think it gets a shot in the arm every summer or so as part of Google's Summer of Code. But yeah, sad it see it doesn't have regular maintainers.
&gt; Fibers can be transited across threads. I meant, Ruby Fibers can't be transited across Ruby Threads. &gt; I've played around with JRuby and found it fairly buggy... Not the TCP APIs, they should work fairly well. JRuby does have issues with UDP APIs, and more specifically with `jruby-openssl` (I maintain a netsnmp library which is unusable in JRuby due to these limitations). I would say that this is due to lack of resources and optimizing for the main use case (in Ruby's case, "run rails"). I read your linked ruby feature report, and it appears that some kind of "goroutine" variant is being sorted out. If I understood it correctly, it's a much welcome discussion. Ruby excels as an high level language, yet it gives me acccess to low level tools like Threads and Fibers and Mutexes, IO blocking/non-blocking APIs, instead of providing an high level abstraction for those. I dislike Fibers because they hardly play out with IO code which the programmer can't control the flow of.
If you are not willing to stay out of the confort zone for a VERY long time, it's going to be impossible to become good at anything. Specially when it comes to programming languages and other frameworks, it just takes a lot of effort, repetition and daily training to finally absorb and make your brain "click" and recognize patters, come up with solutions. But as I said, it's a craft, and since there are so many crafters out there, your only choice is to be good at it.
If Ruby changed their underlying implementation of Fibers they could transit across threads. But sure I understand where you are coming from. The linked bug report is more like an alternative to `async` which is part of MRI directly, rather than as a gem. It essentially makes it possible to automatically yield fibers when the call blocking `IO` or `Process.wait` functions. &gt; I dislike Fibers because they hardly play out with IO code which the programmer can't control the flow of. I'm not sure I understand what you are trying to say here.
[The Odin Project](https://www.theodinproject.com). In the back-end section of [Web Development 101](https://www.theodinproject.com/courses/web-development-101) and the [Ruby Section](https://www.theodinproject.com/courses/ruby-programming) you have a good amount of learning materials with a good amount of interesting Ruby projects to do. Don't forget the [chat](https://gitter.im/TheOdinProject/theodinproject) if you need help.
Just by way of comparison and to share some data.. with the sponsored links we run in Ruby Weekly, flat out commercial type stuff (e.g. "we are X service, sign up for us") can end up anywhere from $1-$5 CPC equivalent (though we charge flat) and more content driven stuff (like the stuff in this post) can be anywhere as low as 20¬¢ CPC up to a dollar or two most.
&gt; If Ruby changed their underlying implementation of Fibers they could transit across threads. Indeed, but it's not a simple task. This has been suggested long before (if I recall, Celluloid never implemented true M:N because of this), and I assume that there are internal details which make it hard (same reason why we still have the GIL). &gt; I'm not sure I understand what you are trying to say here. Fibers are for preemptive scheduling, sure, but its main use case was to make EM callback-spaghetti more maintainable (if IO not available, pause fiber, do something else, select on IOs, whatever's ready gets resumed). It worked reasonably well for EM, but the main problem remained: most libraries don't provide the required APIs to integrate with custom scheduling. 
I don't think there is much interest in implementing h2 support in Rack. You get 90% of the improvements of h2 by having an h2 proxy in front of rack and everyone should be running a proxy in front of rack anyway. The remaining bit that you need support for is Push, but that has it's own can of worms associated with it. Current approaches use new h1 response codes from the app server and cookies to track resources (see h2o for example). There is some support needed in Rack for this which is planned for Rack 3.0 last I knew. More here: https://youtu.be/GnCJO8Ax1qg?t=1266 As for the general architecture of Rack - It sucks and no one is happy with it. But, changing it's fundamentals would shatter backward compatibility and folks are sensitive to dividing the Ruby / gem community in half; some fear that it would cause a Python 2 / Python 3 type of split. Basically Rack sucks to work with but you can do pretty much everything you need to even though it may require socket highjacking. The tradeoff of a major API break vs less hacky code doesn't seem to be worth it at the moment.
I've seen this sentiment before. "Rack sucks" etc. I have no idea what goes on in the layers below Rails... Why exactly do people feel that way about Rack?
Rack doesn't suck. Its design is limiting, especially for streaming and async work flows. It does an excellent job solving the problem it was set out to solve. An alternative is needed to solve other problems though.
That proc syntax is really janky. It's the kind of thing 14 year old me would implement to show its possible only to find out it looks really stupid. 
&gt; FTFY I *haven't* seen this sentiment before. &gt; My opinion Agreed. I don't think Rack sucks. It served and serves a very important purpose providing a uniform interface for applications to target. Granted, request / response doesn't make a lot of sense in a HTTP2 world. But nevertheless, Rack solved a very important problem and enabled a ridiculous explosion of options for serving Ruby and Ruby on Rails applications. 
Rack's strength is that it's very simple and permissive. Rack's weakness is that it's very simple and permissive. For example, the `env` hash that's passed around is mutable. Any code can change anything in it at any time. (my understanding, I'm not a rack expert)
FWIW here's [some pretty good discussion in the same ballpark](https://www.reddit.com/r/ruby/comments/6tv7nu/testprof_a_good_doctor_for_slow_ruby_tests/). And [parallel_tests](https://github.com/grosser/parallel_tests) continues to do great things for me...
I usually catch it myself - it's just one of those things I gotta remember, use .now if using render. Now, what would be cool is a method that detected whether it was a render or a redirect and then handled flash appropriately :)
Kinda interesting, from way back in 2011, a [monkeypatch to ActionController::Flash](https://www.perfectline.co/blog/2011/11/adding-flash-message-capability-to-your-render-calls-in-rails-3/) to do flash setting and rendering in one line. Old enough that's it's not `flash.now`-aware though.
Two major issues with Rack: 1) It only deals with fully buffered requests / responses, it has no support for streaming. This means it can't support WebSockets, Streaming HTTP Responses, etc. The workaround for this is socket highjacking where the application basically says 'piss off rack, just give me the raw network socket and I'll deal with it'. This means the application may have to reimplement stuff that should be handled by Rack e.g. HTTP chunk encoding. This is not to say that a streaming based model doesn't have it's downsides. It can make a lot of things more difficult which is part of why there is concern that switching to a stream based API could cause a Python 2/3 style split. 2) It passes the world around in one big mutable Hash. A 'Rack App' is really just a single method that takes an environment hash and return a tuple of `(status, headers, body)`. The problem is that everything is stuffed in the `env` Hash and it's mutable. If you look at a default rack middleware setup for a rails app there are ~25 middlewares any of which can mutate the `env` Hash at any time and in many cases there are implicit ordering dependencies to ensure data is stuffed into the hash at the right time and in the right place. It's analogous to storing all your application state in one global hash and mutating it from dozens of places; leads to bugs and hard to reason about code.
I actually find this a kind of cool idea - but my knowledge of the internal workings of rails - and flash - is difficult - would it be possible to create such a method / gem to handle this? I mean - it'd be kind of cool from a starter project - maybe?
i'm not really concerned about the market or whatever, i'm just curious about whats missing so people interested can go add it :) 
&gt; Granted, request / response doesn't make a lot of sense in a HTTP2 world. I don't think that is true, at least not at the app server level which is why there isn't a lot of interest in it. The two features that break the concept of request/response are pipelining and push. Pipeling: The app server really doesn't need to care about this, the web facing proxy can make multiple requests to the app and combine transparently. Push: This is (maybe) the most talked about feature but also one of the most awkward to use. The usual example given is pushing assets, i.e. when you load `index.html` push `application.css` and `application.js` along with it. Sounds great but the problem with this example is that you're now serving assets from your app server which a highly questionable practice. Is this actually faster than loading the assets h1 style from a globally distributed CDN? I would guess probably not for most people. Maybe if their app servers are also globally distributed, they have latency based DNS setup, and they have a good static cache in front of their app to handle the load efficiently...but this is probably rare. Really the only way this approach works well is for a CDN vendor to implement something like h2o's link header / cookie approach and have all requests to your app proxy through the CDN. But this means Rack can still think in a simple request / response world and only needs to populate link headers and set the special http code. 
Interesting, and a couple of bits I didn‚Äôt know about. Using tap like that, though, is confusing as hell unless you know what it does. I‚Äôd avoid it, personally, to make sure the code is easy for others to understand at first glance.
I wrote https://github.com/markets/maily to test/preview emails. The approach is totally different: you should prepare data for emails in a config file but then you can easily navigate through **all** your emails without sending them.
It is great that you read RubyWeekly (as we do), but not that great you don't read this same reddit before posting :( This link was here 2 days ago, and is still on the first page.
I think we'd need to do some kind of usage analysis to catch it automatically. We'd need to check for the occurrence of a message send of `[]` to a `Flash` object instance and then, in the same basic block, with no intervening calls to `Flash#now`, a call to `render`. I *think* we'd need to do this at runtime since it would be challenging to statically identify the receivers of those method invocations. Definitely a challenge...
Oh weird. Why do you think it let me resubmit it? 
Don't use any of those. None of that code is good to hand it over to other developers. It's a good thing to know the full api of the language, and there might be places where it makes sense to write code like that, but all examples make code worse than the option they replace. The only case where it doesnt, bsearch, is based on something even worse: avoid, at all costs, to perform searches in arrays.
Not downvoting, in hopes that everyone will see this and all the comments against these practices.
Yeah this code starts kinda ugly and he then makes it harder to understand without Google.
I swear I see this exact post every 6 or so monthes here. Spaceship is pretty useful when sortin arrays of hashes by keys though.
I concur. It's as if the author of the article loves working with primitives, rather than objects.
I disagree, what's confusing about `flat_map`? edit: even the Array block isn't really that strange, and the spaceship operator is no more confusing than a ternary operation.
Not sure the point of this post. Geocoder is popular and has been around forever. 
What's confusing about that usage of `tap`? I really don't get this "ugh, I'm confused, run away mentality". Learn to use your tools, you'll be a better programmer for it.
Are Ruby's logs hard to use? This service looks nice but I'm not sure what problem it solves. What's missing in regular logs?
There is nothing wrong with any of these methods. Maybe you should consider this an opportunity to improve your skills and take that step from junior to intermediate.
&gt; 1) It only deals with fully buffered requests / responses, it has no support for streaming. This means it can't support WebSockets, Streaming HTTP Responses, etc. Is that really true? If you take a look at Unicorn and Passenger, they use a `(Unicorn|Passenger)::TeeInput` class for the `rack.input` (= request body), which is an IO object that dynamically reads from the TCP socket, caching the read content into a temporary file so that it can be rewinded (Unicorn even has `Unicorn::StreamInput` that doesn't cache read content). That means as long as you don't buffer requests on the application server, you should have streaming requests. Of course, in that case slow clients can affect the request throughput, in which case you should either have a lot of web workers or use EventMachine/Goliath. As for streaming HTTP responses, if you return an `Enumerator` that yields chunks for the Rack response body, every web server I know will stream the yielded chunks to the TCP socket (and automatically handle chunked encodings). I use this in [Shrine](https://github.com/janko-m/shrine) and [tus-ruby-server](https://github.com/janko-m/tus-ruby-server). Of course, some web servers might implemented in a way that they keep the web worker busy until the whole content has been written (and if I'm not mistaken writing is constrained by client's connection bandwidth); but I think Puma streams the response outside of the web worker. &gt; 2) It passes the world around in one big mutable Hash. I actually really like this simplicity, that the `env` hash defines the whole request, and that you can additionally use it to essentially communicate between the app and surrounding Rack middlewares. I didn't find any downside to that so far, I like that you can mutate it so that you can cache things in it. I think Rack middlewares need to be ordered in a certain way regardless of the `env` mutation, depending on what they do. For example, `Rack::CommonLogger` should ideally wrap all the other middlewares, so that it also measures time spent in all middlewares, not just the app.
I didn't say it was wrong. I said it's more complicated, at the expense of readablity. I have used those methods before, and knew them before the article. What I do think is wrong is to publish these methods as some sort of illumination for juniors (?). The use cases in 3 and 5 are contrived to say the least (clocks are implemented everywhere, and if you do a join select you can get the array to look like the final result way easier), and the others just generate harder to read code, with no benefit. I think seniority is demonstrated by writing cleaner code and not by trying to look smart by using every single method in the api just to prove you know them. edit: typo and wording.
Maybe you should take that step from intermediate to senior and realize that these methods _at best_ have an extremely limited capacity to actually improve projects.
Can someone explain the benefit of using these? I use Slim which seems to accomplish the same thing with less code. Am I missing something?
Ah, good question. To add more clarity, I was half referring to Ruby's lack of logging best practices, and half referring to using those logs in the context of a logging service. To expand on the former: 1. Ruby's logs are prefixed with a format that looks like: "I, [2017-06-04T18:04:53.672231 #42348] INFO -- :" This is not easily parseable or recognized by any log service that I know of. We did add custom support for this format in [Timber](https://timber.io) though. 2. To solve the lack of context, Rails provides an ActiveSupport::TaggedLogging module, which is not ideal. Tags are formatted like `[tag1] [tag2] [tag3]...`. Again, this is not easily parseable and only conducive for full text searching. 3. Ruby lacks structured data support, which is pretty useful if you want to search, alert, or graph your logs. Timber solves: 1. The traditionally difficult nature of setting up centralized logging for Ruby apps. It can be setup very quickly with `bundle exec timber install`. 2. The lack of log context. It integrates with Rails and other popular libraries to give you rich context out of the box (ex: http requests IDs or user IDs). 3. The lack of structured data support. 4. Making your logs readable and easy to use. Developers actually look at, and read, their logs. Readability is much more important in this context. All of that adds up to productive use of your logs. As a ruby developer myself, I always found services like exception reporting or APMs to be sort of anti-pattern. If logs were easy to use and graph, I wouldn't have as much of a need for those services. It provides raw, clean, open insight into my application. That is essentially the goal of Timber.
&gt; Using tap like that When you say "like that", do you mean "at all"? Cause that's about the most straightforward example of using `tap`, it's what `tap` is for, no?
/u/leanucci has said it below. Clever code can be harder for someone else to read. Think about the person who comes after you, or the junior dev who‚Äôs learning by fixing something in your code. Ruby is an expressive language that is easy to read. Tap is awesome, but instantly clear to a beginner, it isn‚Äôt. Obviously how you code is up to you. This is just my viewpoint :)
Yeah, I probably mean ‚Äúat all‚Äù, for the sake of readability.
Flat_map seems pretty handy and is well named for what it does, so I‚Äôll probably use that now I know about it.
Thank you for explaining this. Makes sense now. I'm gonna give it a try. 
&gt; Is that really true? If you take a look at Unicorn and Passenger, they use a (Unicorn|Passenger)::TeeInput class for the rack.input (= request body), which is an IO object that dynamically reads from the TCP socket, caching the read content into a temporary file so that it can be rewinded (Unicorn even has Unicorn::StreamInput that doesn't cache read content). That means as long as you don't buffer requests on the application server, you should have streaming requests. It does give you a stream so technically you can stream the request body, but you're entirely on your own to parse it. Something is likely to call `Rack::Request.new(env)` somewhere which will load the entire request body. You can hack around this but really as a 'fix' this is similar to socket hijacking, Rack is just handing the problem over to the app to deal with. If all you care about is file uploads, this is probably not a concern but there isn't much reason to be sending file uploads to your app server in the first place (send to S3 or whatever directly). &gt; As for streaming HTTP responses, if you return an Enumerator that yields chunks for the Rack response body, every web server I know will stream the yielded chunks to the TCP socket (and automatically handle chunked encodings). Unfortunately in many cases it isn't terribly useful. One of the details here is that you often use Rack middleware for things like setup and teardown of requests. For example you may grab a connection from a database connection pool at the start of a request and return it afterward. You may need that connection during the calls to `each` on the body but the middleware is unaware of this since it for a long time had no concept of what the enumerator was doing. This is actually one major improvement in Rack as of 2.0 via `Rack::Events`. &gt; I actually really like this simplicity, that the env hash defines the whole request, and that you can additionally use it to essentially communicate between the app and surrounding Rack middlewares. That's great, until some middleware decide to use the same keys or otherwise collide in some unexpected way, then you have a mess. &gt; For example, Rack::CommonLogger should ideally wrap all the other middlewares, so that it also measures time spent in all middlewares, not just the app. A great example of the wonky API. For a long time Rack didn't record request times correctly if the response body was an enumerator. This is because the middleware API is only really exposed to `call` so it could only time how long it took for `call` to execute in levels under it, i.e. the time it took to setup the enumerator, not the time it took to execute it. This was fixed by basically monkey patching in a wrapper with some state that pretends to be the body so the timers work: https://github.com/rack/rack/blob/master/lib/rack/body_proxy.rb. Unfortunately similar things are needed in a fair number of middlewares so you quickly end up with a nested mess. 
It's part of the stdlib, why not use it? Do we have to write only for mediocre-to-poor developers? 
I‚Äôd say ‚Äúless experienced‚Äù, and yes, we should. Compare flat_map; it‚Äôs clearly named and unclutters the code. I‚Äôd certainly use that. In the example given, tap just makes the code harder to read (yay, let‚Äôs use a block for an assignment) and doesn‚Äôt explain what it does to someone who doesn‚Äôt already know how tap works. The ‚Äúbefore‚Äù example is *way* clearer at expressing what‚Äôs actually going on. Maintenance is important, and there are more junior devs than senior. So yes, I prefer to keep it simple, myself.
Same here, I've had instances where I wish I knew about it
For folks newer to ruby?
I know dumbing your code down to the level of your juniors is a popular opinion (cough github cough) and I'm sure it's great if your boss wants to keep your salaries low, but where I work we believe we will be more effective if we level up our devs and not be afraid to use the tools properly. 
It's nice to know everything he mentioned in the post. However, his example of flat_map is a classic example of a Rails developer afraid to touch the database. You can avoid multiple DB requests and loading a ton of ruby objects by joining and grouping a few tables in the DB. There's a comment on the blog with the solution to this.
why would they not just learn what `tap` does? It's not complicated. Should one avoid `collect` and instead write it out with a temporary accumulator array? Where do you stop? tap is built into ruby! 
How do we know what's instantly clear to a beginner? How beginner? Tap is built into ruby. Should we avoid `collect` and instead write: result = [] array.each { |e| result &lt;&lt; e.something } Because it's more clear to someone that thinks ruby is php and hasn't seen `collect` before? Or go further, avoid `each` and use a weird `for` loop instead? Why wouldn't the beginner just learn what `tap` does and never be confused again? It's not complicated, what tap does. Should the beginner stay beginner forever? If the beginner is afraid to just look up what `tap` does a few times until they remember it, I guess they will. (Me, I admit I _still_ don't really understand how to use `zip` and don't use it myself much, but if I see it in a codebase I look up the `zip` docs again and figure it out. `tap` is simple though!) I'm actually kind of surprised this seems to be a popular opinion here. While meanwhile people are unafraid to pile on the gem dependencies to do simple things you could have written yourself -- gem dependencies that a beginner will have a _heck_ of a time debugging when they go wrong. I'd rather work with beginners that are learning how to write ruby, than beginners learning how to pile on giant stacks of gems instead of reading and writing code. I wonder what domains this code is written for and what it looks like, these codebases that contain nothing that a beginner could not have written. 
It is more intuitive and easier to do nested tags specially inside forms. 
Does the number of these blog posts indicate that most Ruby programmers don't RTFM? 
Maybe I'll try a page both ways. I'm able to do forms quickly with slim. 
Fair enough. It's not an article or tutorial on how to use it. Just a link to the repo with no other info. It's a great library though. 
I don't think this criticism applies to anything except the #tap example.
Never use tap. Just write your code the longer way. It is much easier to read. Even if you know what tap does, I promise it isn't an improvement. Edit: It is such a short method name that is actually hard to google too. It just causes junior devs grief for **no readability gain**. Good parts: I have had to search pre-sorted arrays in long-running loops before and bsearch is great to know about rather than writing your own (but I knew it was the algorithm I needed for the situation). The flat_map example is stupid, why in God's name would you not fetch all that stuff in one query, but it's a good method to know. Spaceship operator and Comparable are great to know about if you want to make your own value types like a custom numerical thing. (e.g. money, dates) Which isn't that often, but Ruby has got your back when you do. I have done this a few times in rails apps for integer columns where each value had a special meaning (like an ordered enum). [Rubytapas](https://www.rubytapas.com/) actually turned me onto that, so angry props to Avdi.
I disagree that `flat_map` is clearly named. Less experienced developers usually use `each` for everything, and have to be taught to use `map`, `select` and `reduce`. `flat_map` is a totally foreign concept unless they come from a functional language first. If that's the case, should `flat_map` be avoided? I personally don't think so, but it's definitely open to the argument "less experienced developers won't understand it".
On the flip side, their capacity to worsen a codebase is also extremely limited.
Say every dev on the planet knows what `#tap` does. I'm still not seeing how the example in the article is, in any way, preferrable. With this refactor, we've introduced: 1. an additional method call 1. a new scope, within the block 1. the necessity of naming our block parameter In exchange for... being able to one-line our method? At that point, you may as well just write `params[:foo] = 'bar'; params`. This would be a fine example in a doc, it's a terrible example for a prescriptive text aimed at less-experienced developers.
Should I? 
&gt; It does give you a stream so technically you can stream the request body, but you're entirely on your own to parse it. Is there any body parser in any stack which can handle body streams? AFAIK node has the same issues. In which use cases besides multipart/uploads would this be a thing? And calling `Rack::Request.new(env)`doesn't load the entire body, but calling `params` on it might. &gt; (Streaming Responses) Unfortunately in many cases it isn't terribly useful. I'm almost agreeing with you, but I don't agree with the next statements. Teardown (and database pool connection check-in, for that matter), is mostly handled wrapping responses with `BodyProxy`, just like you explained for the `CommonLogger` case. Of course, multi-layer nesting is what you get. But it does fulfill the promise "body must respond to #each". I mostly agree with you because there is no possibility to send headers as early as possible, which means that the response array must go up and down the middleware stack **fully** before headers can be sent, and then you lost most benefits. &gt; This is actually one major improvement in Rack as of 2.0 via Rack::Events Do you know of any project where that has been used? I haven't seen any yet. &gt; A great example of the wonky API. 1000x this. I'd add, a great example of the "everything is a middleware" fallacy. 
&gt; I don't think there is much interest in implementing h2 support in Rack. I think that rack already supports h2, in that it provides a (yes, very brittle) representation of a request/response scenario. The rest would be the parsing layer. But yes, rack sucks. It's the best showcase in the ruby ecosystem of "primitive obsession" in a pure OO language, no server fully or correctly implements the spec (maybe passenger), and for all its perceived simplicity, it's fairly monolithic: it's a server interface spec, it's a server interface implementation, it's a middleware stack, it's a router, it's a (gulp...) process manager, it's a command line script (`rackup`), it's an HTTP library... 
You don't need a mentor. Contribute to an open-source project is probably the best thing to do. Find one you like, sleep with it, and start solving issues. Regarding "typical job requirements" ‚Äî they're there mostly to flush out people like yourself so that the recruiters/companies don't waste time with people who aren't fully-invested in themselves and their work ;) don't let them deter you, just know that they are simply mind games. Find a niche you like, build something for it, push it to production. I see you like basketball. I, too, like the sport (if you couldn't tell); go make college recruiting tool for NCAA athletes. This doesn't mean you need to form an LLC, accept payments, or even have clients. Have you and a bunch of buddies use it ‚Äî say, "hey, let's all be the coach of a D1 program and recruit people..." ‚Äî mini-fantasy style.
`break` 
How about this example I just had yesterday at my work? user = User.spawn device = Device.spawn old_device = Device.spawn old_device.update(created_at: Time.now - 24*60*60) stream = Stream.spawn vs user = User.spawn device = Device.spawn old_device = Device.spawn.tap { |d| d.update(created_at: Time.now - 24*60*60) } stream = Stream.spawn I couldn't pass `created_at` during creation because that particular ORM doesn't support overriding `created_at` at that time. I find the second version much more elegant and symmetrical.
It's really only ever meant to be used in case statements: divisible_by_3 = -&gt;(n) { n.modulo?(3).zero? } divisible_by_5 = -&gt;(n) {n.modulo?(5) }.zero? } divisible_by_15 = -&gt;(n){ divisible_by_3[n] &amp;&amp; divisible_by_5[n] } case number when divisible_by_3 puts "FIZZ" when divisible_by_5 puts "BUZZ" when divisible_by_15 puts "FIZZBUZZ" else puts number end 
This is an application of a function, not a method call: json = -&gt; m, c, u { "{'message': '#{m}', 'created_at': '#{c}', 'updated_at': '#{u}'}" } # =&gt; #&lt;Proc ...&gt; json.('a message', Time.now, Time.now) # =&gt; "{'message': 'a message', 'created_at': '2017-08-25 13:45:40 +0300', 'updated_at': '2017-08-25 13:45:40 +0300'}"
Check out https://www.bloc.io. I know good Devs that have mentored for them
That is honestly the best example of `tap` I've seen. The examples given in articles and other places are usually worse and less readable with `tap`.
Thanks! That clearly explained where and why I could use #tap.
Have you tried/done building simple webapps using ruby along with other gems?. A bootcamp will sure yield better results if you previously warmed up. As you say, you cannot be an expert on the entire stack, but imo you need to master the basics of each technology (js, css3, html5 ), plus other tools such as everything related to the command line. Repetition, practice, is the only factor that you will help you retain your knowledge. You can even say out loud the eact definition of each keyword or obscure ruby syntax, but as long as you don't try putting the pieces together (the most basic ones at first) you will not know what to do.
Thank you. I have heard this "don't write this, juniors won't understand it" argument before. At this point, why not write everything in PHP? There are definitely more PHP devs than Ruby ones.
Ruby translates `.()` to `.call` internally so you can make procs and lambdas feel more like first-class functions. It even works on your own classes: class Foo def call(bar) puts "Called Foo with #{bar.inspect}" end end foo = Foo.new foo.(:baz)
Ive been unclear. If there are two ways of doing something with equal level of performance, use the simpler method. I'm not saying dont learn it. I'm not sating " use a little of the api as possible so less experienced people can understand". Im saying "only use it if there is benefit". The article says "you should be using tap". Do. Not. Use. Tap. To. Populate. A. Hash. Even if you know it, you have to think about it when you see it. What it does. What it returns. You are assigning the variables anyway. Default values for arrays. God help you if you have to debug that crap two months after writing it, and cant figure out why it's returning something when nothing is being put into it. You'll have to search for its definition, and be able to find it. The arricle says "should be using". I say " hey, dev who didnt know these things: they exist. Use when appropriate. Ther are uncommon for a reason".
That post is not using any of those tools properly. Examplea are contrived, or code looks uglier than the replaced piece of code. 
Don't be surprised too much. After each RubyWeekly issue there are some direct reposts from there (In RubyWeekly it had a comment "A very long standing project but kept very much up to date."... though also not really sure why it was there)
Don't want to sound like an asshole, but to be honest, I find an idea of reposting half of RubyWeekly to /r/ruby pretty strange in any case.
In fact, it is sciruby.com that is being outdated, not project itself. If you look at GitHub org: https://github.com/sciruby -- you'll find a lot of recently updated repos. And currently we are finishing 3 excellent projects done during Google Summer Of Code (two of them bring SciRuby values closer to Rails/generic web ecosystem), they'll be published soon. In fact, last two years were pretty productive for SciRuby, we just still have not enough resources to keep the site up-to-date... Which is definitely bad.
(One of SciRuby maintainers here) Yep, definitely. If somebody will ask the question "Should I use Ruby or Python for science" the answer would be "Most probably, Python". But If the question is "I am Rubyist and need to integrate some stats/science in my app, should I integrate with Python/R immeditately" -- well... We are working hard so the answer could be "No, Ruby has much less libraries, but there are some". And maybe in a few years we'll be able to compare Ruby and Python approaches to data science and look where they lead, like a healthy competition, not just chasing the leader.
That's wrong, it's a call to the `.call` method. The fact that the Proc/Lambda implicitly defines this method does not make `.()` any less of a method call.
To be honest, I feel like that today, like in any other days, the most useful resources are: 1. Official docs 2. Google 3. Other's code 4. Willing to experiment and check everything yourself, until fully understood Maybe it is just me. :) The good book for starters is (and I believe always would be) "Programming Ruby" from Pragmatic Programmers, and having it + official docs as the reference, and curious mind will be more actual advice than any particular resource/list of resources.
Sounds a lot more like you need a real project to work on. Not example stuff or demo apps. * You could try to find an entry job, or similar work at that level. * You could try to find an internship. * You could find an open source project you find interesting, and work on that.
I think tap is the simpler method. 
I am a big fan of learning by official docs; and I do believe each language could have one book to really define whats needed (When I learned haskell I only used one book by graham hutton) so I'll give that one a try.. So far the language is really easy to get a hold of and I'm enjoying it and I'm using other ruby code to learn from since that is always a great way to do it.. If you're this zverok(http://zverok.github.io/) then I've also been using your code for learning purposes and entertainment (worldize is cool) so thnx for all that stuff :) I will say being new to the ecosystem [awesome-ruby](http://awesome-ruby.com/) has been useful especially since I've been able to get off the ground and make useful things so quickly. 
Yeah, I am that zverok :) Thanks for your kind words!
Yeah, I can understand why you might feel that way. Let me give you my rationale, would be interested to hear your feedback. If I see good Ruby content that hasn't been submitted here, I'll share it. The most concentrated source of Ruby content for me is Ruby Weekly. Is your read that most folks here are already subscribed to Ruby weekly? 
No doubt, I just found this to be a very inappropriate case for busting out with "you're a a beginner and I'm an expert" posturing. Although, I'll also argue that the article is largely focused on methods for primitives, and teams that develop a primitive obsession are definitely prone to worsening codebases a great deal.
Tap is preferable because it uses lexical scope instead of external side effects/mutations to perform work on an object. At the risk of sounding like a purist this is the more functional way. By itself it's not going to guarantee any benefits and Ruby doesn't protect you from this type of behavior, but that doesn't mean following principals of lexically scoped operations are for naught. Seeing everything that happens to a object within a block rather than following imperative style assignment and operations over time make a program much easier to understand than the 5 minute speed bump to google and grok Enumerable#tap. I'd argue, especially for junior programmers.
Yep. I agree with both points.
I'll admit that the example is not the best one, but what is "clear" and "easy" depends on what you're used to. Using `tap` I can see code more in terms of transformations and expressions as opposed to sequences of statements. It's up to you whether you like this style or not. I would also say though that in this case, IMHO the much better way to do this would be def updated_params(params) params.merge(foo: :bar) end but that depends on whether you're a fan of minimising mutability or not.
It's a function application. Since any value in Ruby exists in a form of an object, any operation with a value comes down to a method call on the object which represents this value. The function in Ruby is also an object (the Proc object), thus the operation of a function application is a call of the corresponding method for the functional object. However, `.()` is a special syntax for the operation of a function application itself, not for the `.call` method this operation boils down to.
Dunno why you'rebeing downvoted. The way the bsearch thing was presented bugged me, only because I've worked with people who would read that and then sort the array only to use bsearch because it's 'faster.'
Aside from their use in views, they're also useful if you want to build up html in a helper method in a more readable fashion (blocks vs. overuse of building up tags from strings)
There is a Brakeman check that does something similar. Essentially it would be: * Find `Flash#[]` call * Find `Flash#now` call in same method * Find `render` call in same method * Compare line numbers
Well, I dunno, honestly, what to say. As I am not a moderator of /r/ruby, I probably have no authority to say someone what to post and what not :) All in all, Reddit has a pretty decent feedback system to show which posts are good and which are not that good. So, please forgive my arrogance, it was absolutely redundant.
I've never heard of this method and the name has me confused. I kind of get what it does, but why is it called tap?
Much appreciate the apology, but don't think it's necessary. I admit that it does *feel* weird to do so. I work for Twilio and often share things from our blog, and also from my personal blog. So, one of the reasons I submit other content is to be a good citizen and to stay within the 10:1 "other people's stuff" to "your stuff" ratio. If your spidey-sense is tingling, perhaps that's why. 
The hard part of the static analysis is you can imagine tricky cases like: def update if something flash[:error] = "nope" elsif something_else flash.now[:error] = "bad" render :edit end end This may be solvable with heuristics like "last call wins", but, seems kind of hit or miss. Some details on an alternate approach: * Use `Module#prepend` to wrap `render` * Run the tests, assuming there's coverage of that controller action * When the `render` wrapper is invoked, check the `Flash` instance to see if there's an associated `FlashNow`. The downside of course is that it's no longer a static analysis check and requires tests that exercise that code path. The upside is that I *think* that would eliminate false positives.
It should be like this I believe : http://termbin.com/nllk
yup, it's nothing more or less than `json.call(@message, :created_at, :updated_at)`, that object `json` has a method `call` (either because it's a proc or because it just defines that method, could be anything at all that responds to `call` method), nothing more nothing less. I am personally not a fan of this syntax fairly recently added, ruby doesn't need yet more ways to do the same things, it's got enough. But if you just remember `object.()` is exactly the same thing as `object.call()`, that's all there is to it, just a shortcut for calling the method/sending the message `call`. 
I've updated the OP. Sorry for the confusion. I understand that I can include Const in Jojo and this will work. I don't understand why it doesn't work as above. 
I guess if you want to refer to any method-call in ruby at all as 'function application', you can. But this is no different than any other method call in ruby. `.()` is special syntax for `.call()`, not anything weirder or more complicated than that. &gt; Note that prc.() invokes prc.call() with the parameters given. It‚Äôs a syntax sugar to hide ‚Äúcall‚Äù. https://ruby-doc.org/core-1.9.3/Proc.html#method-i-call
the fact that you define a class/module inside another is nothing more than a namespace - it doesn't mean any functionality is shared. There are two main approaches for importing definitions from one class/module to another - include/extend and inheritance. So as you've said it works when you include Bobo into Jojo. You could also use inheritance as shown below: module Taco class Const BURRITO = 'yum' end class Jojo &lt; Const def bobo self.class::BURRITO end end end At first I didn't understand why your first example, as shown below, worked at all: module Bobo BURRITO = 'yum' class Jojo def bobo BURRITO end end end but I realized that it's because of lexical closure. If you're not sure what this is, look as follows: def make_array a = [] 3.times { |i| a.push i } a end b = make_array puts defined? a # nil see how `a` is available inside the `3.times` block, but it still only exists internally to `make_array`? Module/class/constant definitions have the same behavior as `a`, even if they're not really variables. It wouldn't work if you split it up into two blocks: module Bobo BURRITO = 'yum' end/ class Bobo::Jojo def bobo BURRITO end end Also, for the same reason, `class Jojo &lt; Const` in my first example wouldn't work if I split the class definitions into two blocks. It would need to be `class Jojo &lt;&lt; Bobo::Const` By the way, although it's good to understand this stuff, it's a common antipattern to create huge classes/modules which import a lot of functionality. It's better to keep them split up some times. 
you are not the only one that gets confused by this, I think it ends up being one of the most confusing parts of ruby. 
I might be wrong but isn't #tap mostly intended for "hacking in" some (debug) logging? At least the [documentation for #tap](https://ruby-doc.org/core-2.4.1/Object.html#method-i-tap) shows pretty sane (imho) use of that. Example: def foo bar do_something_with(bar) end Uhh I need some logging right now def foo bar result = do_something_with(bar) log(result) result end Use tap def foo bar do_something_with(bar).tap {|result| log(result) } end It feels as though most people saying here "don't use tap" actually want to say "don't use tap to mutate things".
Would you mind providing a source to that statement? I feel like the following kinda shows that the regular method dispatch is at play, but perhaps you know something I don't? [1] pry(main)&gt; class Sup [1] pry(main)* def call [1] pry(main)* "called from Sup" [1] pry(main)* end [1] pry(main)* end =&gt; :call [2] pry(main)&gt; class Sub &lt; Sup [2] pry(main)* end =&gt; nil [3] pry(main)&gt; Sub.new.() =&gt; "called from Sup" 
:+1: great explanation :) beat me to it
The Rails Guides actually include [a very comprehensive discussion of how constant lookup works in Ruby](http://edgeguides.rubyonrails.org/autoloading_and_reloading_constants.html). The relevant portion is copied below. In order to understand it, you'll need to read one of the preceding sections [to get a sense of how **nesting** works](http://edgeguides.rubyonrails.org/autoloading_and_reloading_constants.html#nesting). In your examples, the nesting on line 18 is `[Taco, Jojo]`, and the absolute path of the constant you're trying to access is `Taco::Const::BURRITO`. &gt; #### 2.4.1 Resolution Algorithm for Relative Constants &gt; &gt; At any given place in the code, let's define _cref_ to be the first element of the nesting if it is not empty, or `Object` otherwise. &gt; _[cref = `Taco`]_ &gt; &gt; Without getting too much into the details, the resolution algorithm for relative constant references goes like this: &gt; &gt; 1. If the nesting is not empty the constant is looked up in its elements and in order. The ancestors of those elements are ignored. &gt; _[MRI searches for `Taco::BURRITO` and `Jojo::BURRITO`, and finds neither.]_ &gt; &gt; 2. If not found, then the algorithm walks up the ancestor chain of the cref. &gt; ~~_[`Taco` has no ancestors, so this step is skipped.]_~~ &gt; &gt; 3. If not found and the cref is a module, the constant is looked up in `Object`. &gt; _[Not there, either.]_ &gt; &gt; 4. If not found, `const_missing` is invoked on the cref. The default implementation of `const_missing` raises `NameError`, but it can be overridden. &gt; _[Hence your `uninitialized constant` error.]_ Unfortunately this doesn't examine the implementation details, so I have no evidence that this conceptual model matches what's going on under the hood, but I trust the Rails team to get this right. --- **EDIT:** Actually, it looks like `Taco` does have `Taco::Const` in its ancestor chain. In that case, your sample code appears to contradict this description of the constant lookup algorithm. It's a real head-scratcher. :\
I had been thinking Taco was the ancestor to Jojo and that, as a result of the 'include' contained BURRITO. I now understand that I was relying on a closure thanks to /u/isolatrum . Thanks!
&gt; It wouldn't work if you split it up into two blocks This is not quite correct. Per the explanation I posted in my top-level comment, constants can still be looked up in ancestor classes. Use class inheritance instead of namespacing, and it works just fine: class Bobo BURRITO = 'yum' end class Jojo &lt; Bobo # note the inheritance from Bobo here def bobo # returns 'yum' BURRITO end end
I'd like to give some context (and an an attempt for some clarification of what you probably mean). Ruby doesn't have first-class functions (or functions at all). In Ruby, everything is an Object and you can define and call methods on those objects (or more technically correct: send messages to objects which might cause a method to be called). Now, Ruby has a concept which in certain ways can act like a first-class function: a Proc. When defining a proc, you are always defining some behavior and a closure which provides the code in the proc access to its lexical scope (and thus e.g. variables defined outside of the proc). In many ways, you can use a Proc object just like you would a function is other languages like JavaScript. You can pass it around, assign it to a variable and call it multiple times. Again: a Proc object is still a regular object in Ruby but it can be used mostly like a function would. In order to allow a Proc object to look and integrate more naturally in Ruby code, Ruby has some syntactic sugar to make `my_proc.call(arg1, arg2)` equivalent to `my_proc.(arg1, arg2)`. This looks almost like a regular old method call and thus blurs the line between methods and "functions". The syntactic sugar is available on any class which allows you to define other classes than just the built-in proc which can behave more or less like functions in other languages. It doesn't change how the language and the method dispatch works. But it changes how using the language to write programs looks and feels. For Matz, this is usually one of the (if not THE) most important aspect when designing language features.
I don't think the closures explanation is right ‚Äî constants and local variables aren't the same thing, and shouldn't work the same way. At the same time, I totally missed the `include Const` line, which does indeed make `Taco::Const` an ancestor of `Taco`. Now, I need some clarification myself.
The `.()` operator is implemented as a method call (like many other operators). That's why you observe this behavior.
You're right! module Bobo BURRITO='yum' end module Bobo class Jojo def bobo BURRITO end end end Bobo::Jojo.new.bobo #=&gt; 'yum'
The difference there is your use of the Bobo::Jojo syntax rather than using nesting. If you nest a Jojo class under the Bobo module with a re-open it works just fine.
It's especially confusing that this works: module Child module Const BURRITO='aw yea' end include Const class Sized def bobo Child::BURRITO end end end 
Oh yeah, there's a big difference between "I just need to find this thing once" and "I need to find things in this array repeatedly many hundreds of times per request, and the data was already sorted by the database". It's mainly a situation I've gotten into when writing reports in Rails that were not performance sensitive. I really needed the ActiveRecord objects because a project had a lot of crazy logic involving dates and metadata about dates, so I couldn't just do it in SQL, and all the joins and inclusions were way more than ActiveRecord could do automatically/easily because I was joining about 12 tables. So I fetched all the records I needed in separate arrays and did "joins" in Ruby using bsearch. So yeah boring war story, and if it needed to be fast I'd do it in SQL at a cost of 50 more hours of dev time, but it works fine for what the client needs.
&gt; It doesn't change how the language and the method dispatch works. But it changes how using the language to write programs looks and feels. Exactly right. This is a _conceptual_ feature which was put down onto an already existed object-oriented foundation.
Yeah, Bloc, Firehose, a hundred other online bootcamps. They look good on paper, but then I start seeing some negative reviews and the 100% positive ones that are all in the same formatting, come from the same few people on different site like Quora and Switchup, it makes me suspicious. How can I check these devs out that you speak of to see if this is legit?
I really want an internship!!! It seems like the absolute best option for me. How do I get myself applicable for one? Do I just bite down and do the demo apps to show them? Exercism is one open source project that's very interesting and they're very open to contributions, but it's written by seasoned, knowledgeable people. Do I just jump right in with amateur PR's or wait on some super basic bugs, docs edits to fix?
Ok, so how about this one. I love the online music databse Discogs.com. I see there is a Ruby wrapper for the site's API. https://github.com/buntine/discogs What can I do with it?
I've done the classic Hartl tutorial, I've done some of the McKenzie Childs' apps. Again, I didn't enjoy any of it too much, because it didn't feel very "life-like". I've tried making my own, but I really overreached with ambitions, because I wanted it to have a solid recommendation engine, maybe even dabble in some machine learning. I was expecting too much. Maybe the trick is to thinking of the kind of project that I can see myself use, yet it is not extremely involved that I get burned out on it?
Maybe it's like you already hold the object but then you tap it and do something upon it
This debate started because you stated `.()` is not a method call. 
The code change in question actually makes the design of the code worse. A dependency, "Person Educator," starts manipulating state of the "Person" that should be encapsulated (i.e. the education level). Whether the author's use of RSpec features reduced the work load inherent to maintaining the test is irrelevant. The change was _wrong_. Furthermore, excessive use of the RSpec DSL caused the resulting test to be more confusing than it should be. Consider: it { is_expected.to eq education_level + 1 } Versus: test "Increases the education level" do assert(subject.education_level == education_level + 1) end I'll make a promise: whatever chopped and screwed version of English gets churned out by the first example will still be less clear than the straightforward prose of the second example. And holy hell a simple `assert` is so much easier to read than the RSpec expect syntax. It's not even `expect(...)` anymore, it's some bizarre Yoda version set in the passive tense.
If the topic starter asked if `%x{argument}` is a valid syntax for a method call in Ruby, what would you answer? Would you call this construct a method call?
This strikes me as a bad idea. The array would live within the puma process? What happens when you need to restart puma, would it wait until the array was empty? What would you do with new requests while waiting for the array to clean out? If you want to go down this route, use Redis with a custom backend process. Puma would LPUSH onto some array. The background process would BLPOP off that array in an infinite loop. Basically move that array out of memory and into redis where it will be persistent. I don't know if that would actually solve your problem though. He only advantage over sidekick would be avoiding the sidekick overhead, which is probably really minimal anyway. 
Using an example: module M WHAT = 'yup' end module N include M end class A TACO = 'hi' end module N class B &lt; A def taco puts Module.nesting puts TACO end def what puts Module.nesting puts WHAT end end end N::B.new.taco =&gt; N::B =&gt; N =&gt; hi N::B.new.what =&gt; N::B =&gt; N =&gt; NameError: uninitialized constant N::B::WHAT =&gt; Did you mean? N::WHAT It's actually `Module.nesting` that defines the constant lookup chain with a caveat: Ruby will only consult the inheritance of the first thing in the module nesting. So in the example it will check `N::B` then it will check `N` and then it will check the ancestors of `N::B`, notably `A` which defines `TACO`. It will _not_ check the ancestors of `N`, notably it will not look at `M` which defines `WHAT`. This is why this version fails. The reason `N::WHAT` (or `Child::BURRITO` below) would work is that you are looking up `N` in the current context, which is found, then you're asking `N` to lookup `WHAT` from it's context which, since `N` would then be the first entry in it's module nesting context, would walk the ancestor chain to `M`. Another way to state this is: Ruby will check the module nesting first, then check the ancestors of the current context. As an example: module A FIVE = 5 end class B FIVE = 6 end module A class C &lt; B puts FIVE end end =&gt; 5 It could have found `FIVE` either in `B` or `A` but it looks at module nesting first so chose the constant from `A`. I think some of the confusion is that the docs on `append_features` aren't great. `include` doesn't really 'add' anything directly to the `class` / `module` it's called in, it adds an entry to it's ancestors which means accessing anything is dependent on the lookup logic in play. 
What about the saying bye 3 times part is confusing you? What have you tried already? 
Hint: the answer is related to variables and incrementing/resetting numbers
I've tried something like: https://pastebin.com/embed_iframe/7XRaTzs1 but it simply doesn't work. I'm lost on this one.
This is similar to the lazy teenager on project Euler. You can definitely find sample solutions in ruby on their site. You just need a case structure, not sure if ruby has this or not, or and if, elsif, else structure. I reread about the BYE 3 times in a row. You will need some counter to increment or revert to 0 if it isn't in a row. BTW, I have just started learning ruby. I did perl for the last 2 yrs but want to learn OO so I am picking up ruby. I was thinking to start Project Euler if you want to do it together. I did it with perl about a year ago, not the whole thing of course. Anyway you can pm me.
Thanks for replying! I agree with you regarding the encapsulation of `Person#education_level`- I've updated the post and the examples accordingly. Indeed, unwanted mutability! Regarding the latter part of your comment, well, I guess it has to do a lot with one's attitude to RSpec in general. Honestly, I find it's syntax very prosaic. The RSpec community is quite large and the syntax I chose is deeply influenced by some best-practices composed by many of those people on [BetterSpecs](http://www.betterspecs.org/).
What can't you do with it?
Truth is you will never get your first job, as an employee or freelancer, and expect to deliver a massive webapp full of features. Start with a shopping list, if you DO know the language, you will be able to pull it out in half an hour, if it takes you much longer, trying to recall methods you should or should not use, then you need to keep doing those sorts of webapps.
Sorry if I'm stating the obvious or missing something; I'm not really a Ruby person. It doesn't look like you're sanitizing the input path string before you shell out. If someone can give an arbitary string as a filepath, they can do anything, eg. `avconv -y -i ; rm -rf * ; blah blah;` `foo.wav; rm-rf *` is a legal filename. Even if it isn't a security concern now, it could be in the future or for other people who reuse the snippet from your blog. The backticks in ruby also start a subshell which is unnecessary for what you want to do and a security hazard. `avconv` is the less popular and worse maintained fork of `ffmpeg`. (As a complete aside, for what it's worth, you shouldn't have an apostrophe on "Mp3's" in your blog post title.)
&gt; It does give you a stream so technically you can stream the request body, but you're entirely on your own to parse it. Something is likely to call Rack::Request.new(env) somewhere which will load the entire request body. As far as I know, the only Rack middleware that will read the `rack.input` is `Rack::MethodOverride`, which isn't needed with JSON APIs (`rails new --api` excludes it from the stack). &gt; If all you care about is file uploads, this is probably not a concern but there isn't much reason to be sending file uploads to your app server in the first place (send to S3 or whatever directly). If you're uploading large files, you can achieve [resumable uploads](https://github.com/janko-m/tus-ruby-server) if you're uploading to your app. It isn't a common scenario, I know, but still there are benefits even if you're only doing file uploads. &gt; That's great, until some middleware decide to use the same keys or otherwise collide in some unexpected way, then you have a mess. Yes, of course, but I think a convention has already been established where you prefix new keys with `&lt;identifier&gt;.&lt;something&gt;`, so I think it's unlikely that something will collide. But maybe I'm just not seeing a better alternative in my head which will make me realize that this is not good.
.tap is great for debugging, and sometimes ok for prod code
Start from your original program and try to get the 'saying BYE once' criteria met first. That'll put you in a stronger starting position.
This is true of literally 99% of problems at this level. This comment is not helpful.
You have something better, dick?
As /u/avapoet mentioned, start with your original program and add the bye once functionality to it. From there, as others have suggested, just use a counter to count how many byes you have, but remember to reset when you're supposed to. 
/u/thillsd is right, this is considered a Dangerous Send. You should be doing something like input_filepath = "/Users/username/Downloads/init.mp3" output_filepath = "/Users/username/Downloads/out.mp3" system("ffmpeg", "-y", "-i", input_filepath, "-vn", "-qscale:a", "4", output_filepath) Using `system` will return true if it executed correctly, otherwise it will return false. The example of this output is (i don't have avconv on my computer so I changed it to ffmpeg for my case) ffmpeg version 3.3.3 Copyright (c) 2000-2017 the FFmpeg developers built with Apple LLVM version 8.1.0 (clang-802.0.42) configuration: --prefix=/usr/local/Cellar/ffmpeg/3.3.3 --enable-shared --enable-pthreads --enable-gpl --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --host-cflags= --host-ldflags= --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --disable-lzma --enable-vda libavutil 55. 58.100 / 55. 58.100 libavcodec 57. 89.100 / 57. 89.100 libavformat 57. 71.100 / 57. 71.100 libavdevice 57. 6.100 / 57. 6.100 libavfilter 6. 82.100 / 6. 82.100 libavresample 3. 5. 0 / 3. 5. 0 libswscale 4. 6.100 / 4. 6.100 libswresample 2. 7.100 / 2. 7.100 libpostproc 54. 5.100 / 54. 5.100 Input #0, mp3, from '/Users/username/Downloads/init.mp3': Metadata: encoder : Lavf57.56.100 Duration: 00:03:36.66, start: 0.025057, bitrate: 246 kb/s Stream #0:0: Audio: mp3, 44100 Hz, stereo, s16p, 246 kb/s Metadata: encoder : Lavc57.64 Stream mapping: Stream #0:0 -&gt; #0:0 (mp3 (native) -&gt; mp3 (libmp3lame)) Press [q] to stop, [?] for help Output #0, mp3, to '/Users/username/Downloads/out.mp3': Metadata: TSSE : Lavf57.71.100 Stream #0:0: Audio: mp3 (libmp3lame), 44100 Hz, stereo, s16p Metadata: encoder : Lavc57.89.100 libmp3lame size= 3849kB time=00:03:36.63 bitrate= 145.6kbits/s speed=68.4x video:0kB audio:3849kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 0.006419% =&gt; true
One small piece of advice since I think others have already set you in the right direction: I would rename that `bye` variable to `bye_count`. I might also rename your `tell_gmaw` variable to something like `user_input`. Little things like that can make it a lot easier to follow your own code, and easier for other people to quickly grasp what you're doing. 
The reason people aren't just giving the answer is because it's clear the OP is trying to get help with their homework. Just typing out the answer for them isn't going to help.
I never said to type out the answer. I just said that the advice given was so vague as to be useless. It only serves to further confuse or frustrate the student.
I'm confused if OP figured out why "pool.wait_for_termination" is not doing what is expected and why. I couldn't tell from OP. That is alarming. I haven't encountered that before. I wonder if the problem really is in `thread_pool_executor.send(:initialize)`, I don't understand what that does, sending a private message seems like a warning sign that it may not be a good thing to do, but I'm not sure exactly what that referenced `Executor` class is. I would have just thread-safely created a new `Executor` instead. Although doing that thread-safely can be tricky, concurrent-ruby gives you the tools. (I like using a Delay there). Which makes me wonder if `thread_pool_executor.send(:initialize)` is thread-safe in the first place, and if it matters in that context. 
For running external processes like this, I recommend [tty-command](https://github.com/piotrmurach/tty-command). backticks/system seem simple at first, but at production scale you run into _so many_ edge case and error condition things you want to take care of that are difficult with backticks/system, that tty-command will take care of for you. Including sanitization (which you can have `system` do for you if you use it right, but not backtics), and capturing stderr/stdout if you need em, say for logging in a formatted way on failure (which are a pain to do as separate streams otherwise, you gotta use like popen3 or something), while keeping them out of your master process $stdout/$stderr muddling up your logs. That's a surprisingly tricky wheel to reinvent. tty-command just does everything you're gonna need with a simple API. 
&gt; thread_pool_executor.send(:initialize) Yes, I'm not sure this use-case of the API is supported, or if it's reasonable to expect it to be supported.
I was able to get that far, but I still don't know where to continue. https://pastebin.com/embed_iframe/KpTPn9m9
Thanks for this. In our app, I thought it would be ok, being a private method and the input file is actually never user defined, in our case. But you bring up a very good point. I'm sharing this code and for others, in their context, this could be a major security concern depending on how they used it. So with that said, I'm going to refactor my code and add an edit to the blog post. We started off using ffmpeg and ran into a lot of issues getting it to play nicely with Heroku. The avconv fork played much more nicely with heroku
Like, the actual public API of ruby-concurrent thread executors is that once you `shutdown`, the thing is done and no longer usable. Trying to get around that by sending messages to private API... that'd definitely at least be my first guess when something mysterious is going wrong. Concurrency can be difficult or confusing, first rule is stick to the documented API and concurrency contracts of the things you are using! There might be bugs even in the documented contracts, but once you go off-road, all bets are off! 
OP here - yes, please note that the send was just to a custom wrapper over concurrent-ruby which basically did: `@executor = Concurrent::ThreadPoolExecutor.new` i.e. standard documented concurrent-ruby API. in a gist: wait for the thread pool to finish its "jobs" then just replace it with a new one. (I'll update the article with more explicit logic)
oh, that's better! If you are writing a custom wrapper, why not give it public API instead of a weird `send(:initialize)`, but that's your business! Any leads at all on what was going wrong? It's disturbing if shutdown is really not working. Do your thread pool worker blocks kick off any _other_ threads that they might not have waited on? The capybara/database-cleaner dance [ends up being so complicated](https://bibwild.wordpress.com/2016/02/18/struggling-towards-reliable-capybara-javascript-testing/), I feel it's more likely something other than a bug in concurrent-ruby threadpoolexecutor, but who knows. I wonder if it's possible your own `@executor = Concurrent::ThreadPoolExecutor.new` is not being done in a thread-safe way, but is being called by multiple threads, so more than one `Concurrent::ThreadPoolExecutor`gets created and has jobs given to it, but only one actually winds up remembered in `@executor` and given a `shutdown`. Concurrency can be tricky! 
It's not complete in the sense you still need to pay for an external geocode provide?
Would it not be possible to just use the ImmediateExecutor provided by concurrent ruby for this case?
+1; this is how I do it in my Ruby workers. I make an accessor for the executor and partially stub it.
Hello, I've updated the [beer.db web service starter sample](https://github.com/beerkit/beer.db.starter) that gets you started building your own HTTP JSON API using the beer.db (and friends). What's news? The starter sample now uses the new [webservice library](https://github.com/rubylibs/webservice) (a simplified sinatra 2.0-style library for HTTP JSON APIs). Example: class StarterApp &lt; Webservice::Base include BeerDb::Models # e.g. Beer, Brewery, Brand, etc. # try special (reserved) keys for random beer first get '/beer/(r|rnd|rand|random)' do Beer.rnd end get '/beer/:key' do Beer.find_by! key: params[ 'key' ] end ... end Enjoy. Cheers. Prost. 
&gt; I'm confused if OP figured out why "pool.wait_for_termination" is not doing what is expected and why. I couldn't tell from OP. That is alarming. I haven't encountered that before. OP didn't clarify what 'fails' means, but one thing that catches my eye is that `shutdown` causes the executor to reject additional tasks and only finish what is already in the queue. Problem may be that sometimes the tasks in the queue need to queue other tasks on the same executor and those tasks are being rejected. May be able to fix this by setting the `:fallback_policy` of the executor to `:caller_runs` which will then run the rejected tasks immediately in the caller thread allowing everything to complete.
I looked at Spree a number of years ago but ultimately decided against using it as at the time they had virtually no concurrency controls in place. All manor of race conditions in the DB were possible including transaction deadlocks; didn't even have basic optimistic locking in place. The person we were talking to at Spree shrugged it off as "that's unlikely to happen" which is not really what I want to hear for code that is ultimately managing money. Has this been improved? 
I agree in some respects, but I think these two suggestions are fine: Comparable is a great module for making custom value types (such as money, dates, or something specific to a customer's data) and it mostly depends on implementing &lt;=&gt;. It's an advanced use of Ruby, but this sort of thing is exactly what Ruby is great at and why I love it. Searching arrays is fine if you don't have to do it many times in a loop, and the size of the array is fairly limited. In fact searching even a huge array once in an algorithm is not a big deal. bsearch is great if the data is pre-sorted OR you need to find an element in the Array so many times it is worth the time to sort the array first, which requires some profiling to find the cut-off point. You can also use a Hash of course. I don't know which is faster. Of course the thing here is, if you've had basic comp sci you will already know when you have sorted data and a binary search might be the thing to use and accidentally write your own without realizing that Ruby provides it.
Pipelining is in HTTP/1.1 already, right? Is there a new improvement to pipelining in HTTP/2?
&gt; Pipelining is in HTTP/1.1 already, right? Technically yes, practically no. A lot of proxies / servers don't handle h1 pipelining correctly and it requires complete responses to be placed on the wire in order causing head of line blocking. Due to these issues no major browsers support h1 pipelining, at least not without setting a dev flag. h2 allows multiple requests to be in-flight at the same time, they can be responded to out of order and content can be chunked and intermingled on the wire. This async multiplexing fixes the head of line blocking problem and the hope is that a new protocol requiring new implementations on servers/proxies will result in correct implementations.
&gt; 2. a new scope, within the block This is an advantage, limiting the scope of local variables to smallest possible unit results in cleaner code IMO, as does group similar actions into a block. &gt; 3. the necessity of naming our block parameter Depending on the usage, `tap` doesn't introduce anything new. e.g. I use it for things like this quite often: def my_method(stuff) [].tap do |accumulator| stuff.each do # do something non-trivial accumulator &lt;&lt; value end end end def my_method accumulator = [] stuff.each do # do something non-trivial accumulator &lt;&lt; value end accumulator end 
Thanks for this response. Cheers!
That's clever, but not idiomatic. What you've outlined is an ideal use-case for [#reduce](https://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-reduce) or the similar [#each_with_object](https://ruby-doc.org/core-2.1.0/Enumerator.html#method-i-each_with_object).
Great alternative to my messy monkey patching - small note: it doesn't work with: `{ dup_on_deref: true, freeze_on_deref: true }` options for Futures. In any case thanks for the tip - another article update on the way :-) 
&gt; That's clever, but not idiomatic. I see it used all the time so it's unclear how you define 'idiomatic' here. &gt; What you've outlined is an ideal use-case for #reduce or the similar #each_with_object. You're correct for my contrived example but that was the point of `# do something non-trivial`. It's easy to create really bad performance issues just chaining together enumerable methods, for small data it doesn't matter but I'm often dealing with large data sets. 
Regarding the fail part - the logic that executes in async mode basically ends with a database insert - the fail in my case is those inserts not happening on very rare cases on my machine and constantly on Heroku's CI. Note that if I try to re-run them using the same seed - they just work, I haven't been able to replicate and isolate them so I can run something like rspec --bisect.
&gt; It's disturbing if shutdown is really not working. Maybe it's not clear in the post but I really doubt the shutdown is the issue but more how the various dependencies interact whilst testing which adds at least two more deps. to the mix. In any case the amount of useful feedback in this thread will probably result in a more clear update to the post.
Good call, that could be. Hard to say without all the code and debugging and knowing what 'fails' looks like. Concurrency can be _tricky_. I'll note out of pride that I [filed the issue](https://github.com/ruby-concurrency/concurrent-ruby/issues/192) that resulted in the behavior where posting to a shutdown pool triggers configured `fallback_policy` behavior. :) [Looks like](https://github.com/ruby-concurrency/concurrent-ruby/commit/8bea918f0d949c3a13d74864efaa3c53c3cbc6ad) you get that from 1.0. 
By non-idiomatic, I mean that there's a method specifically designed for constructing enumerables with a accumulator, and it's not `#tap`. Even if `#tap` is more performant that the methods I linked (which I would be glad learn, if I'm wrong here), the second example with the explicit return reads better because it introduces less nesting.
&gt; Note that if I try to re-run them using the same seed - they just work, I haven't been able to replicate and isolate them so I can run something like rspec --bisect. It's entirely possible the execution order is just allowing enough time for the needed tasks to queue other needed tasks before the `shutdown`. 
&gt; By non-idiomatic, I mean that there's a method specifically designed for constructing enumerables with a accumulator, and it's not #tap. Again, my example was greatly simplified, assume `# do something non-trivial` expands to code that makes using `each_with_object` or `reduce` ugly. &gt; Even if #tap is more performant that the methods I linked (which I would be glad learn, if I'm wrong here) `tap` is faster than `reduce` or `each_with_object`, the latter being the slowest but that isn't really what I was referring to. In non-trivial cases I often see enumerable methods chained together to replace using an accumulator + manual logic and that often results in a lot of memory allocation and looping. &gt; the second example with the explicit return reads better because it introduces less nesting. That is subjective, I prefer to scope locals to the smallest unit so having the local only present in the block is a bonus. 
Are you trying to use Ruby like you would use a PHP script? https://github.com/charliesome/charlie.bz/blob/master/posts/how-to-use-ruby-like-php.md (probably outdated)
Just my 2c: I'd have called it 'yard-sale' :P
Good choice, yep. It was `junkyard` initially but at the last minute turned out `yard` allows only `yard-.*` for plugin names. ¬Ø\\\_(„ÉÑ)_/¬Ø
Wow, that's cool. Good job.
Thanks!
Non-web Ruby! Cool.
im learning ruby this semester, this is cool
There's also the [solidus](https://solidus.io/) fork of spree. At the time solidus forked, I believe spree appeared unmaintained, and the fork was done by people with certain ideas of where to take spree for easier maintainability. But with the rejuvenation of spree (presumably by people with different ideas than the solidus team)... two alternatives I guess?
I actually didn't know about it! 
Lol! Is your name choice supposed to be an oxymoron? If so, I love it :)
Have you ever needed to geocode anything? Check out http://awesome-ruby.com/ for other gems you might not be aware of. :)
Yeah I actually started learning Ruby before Rails became a hot thing. The code always looked so beautiful with it.
Thanks. I wish I had Ruby back in college!
It's actually the opposite. Femto is a unit prefix in the metric measurement system, smaller than nano and pico, two editors that already exist for Unix systems. So it's like saying this is even smaller in terms of an editor. :-P
What's the memory and system resource of Femto? Is it less than nano? That's the joke I was getting at. That a piece of software written in Ruby is more lightweight than the same written in C. ;)
Oh you are right. I never thought of it in terms of resources but more like what you should expect from the editor in terms of features, stability, etc.
Ah ;)
There is only way for a junior dev to become a senior dev. Learn. If we all just write code for the lowest common denominator then our software will be garbage and run like garbage. At some point this attitude has to stop and your juniors have to buck up and learn something new. It's good for them and it's good for the industry. The mystery of #tap can be solved by one Google search to go right to the documentation immediately. Sure, if we're talking about complex patterns that require diagrams just to scope out, maybe you have a point. But with a simple method with standard Ruby syntax, your point falls flat and sounds like your fighting for us to just stop learning new things. And if #tap is preventing your junior engineers from being productive, then I'd recommend finding new junior engineers. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/elixir] [Is Phoenix really that faster than Rails?](https://np.reddit.com/r/elixir/comments/6whx2b/is_phoenix_really_that_faster_than_rails/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Lots of misconfiguration on both sides in there. Compared both personally and got ~10x speedup compared to rails(with puma) in various scenarios. Also keep in mind the more you use database the less difference is
I ran some tests myself and I found phoenix to be about the same speed as roda. With jruby roda was a little faster. When you hit the database it becomes all about object creation and database drivers. If you use sequel without models it's very fast. 
What do you mean by Sequel without Models? the Sequel Gem? or you means SQL by Sequel?
So if an application is io heavy (using the database heavily), it won't make much difference using either Rails or Phoenix? What about Go?
Sequel gem. Just run queries and use the resultset, no ORM.
Why is this on /ruby? 
imo, elixir gets more exciting as you move to more distributed architectures and tasks. if you just want to scale a monolith, stick to the framework that is easiest for your team to make and maintain today. 
I fixed a subtle bug and removed the requirement for Ruby 2.4
Heya! Author of the blog post here. I'm a bit late, but I'd be happy to answer any questions too! I've been using Shrine in production for a while now and have been very happy with it. As mentioned in my post, Shrine's configurability (plugins) and integrations (ruby, rack, etc) is where it really shines! :D
I think it will be similar no matter which library you choose on the backend. However it may be easier to dissect or validate the file params with Shrine, and/or upload directly to S3/cloudfront and return the response to Froala. As with my Dropzone example, it hits the rails controller to upload the image, and then returns a custom response. I'd be more than happy to create a working example for any library/framework when I have the time as well. Feel free to message me.
`input.scan(/\bBYE\b/).size == 3`
I didn't say it was better, but it's definitely more flexible than other solutions from personal experience. I also feel like @janko-m cares a lot about the current state of file uploading in ruby. :D Let me know if I can help!
This is an exercise for learning Ruby (taken from Chris Pine's "Learn to Program") and I really don't think he should be using regex to form a solution.
Yes, but you probably don't need the speed.
Homebrew is written in Ruby. I know Ruby is 90% associated with the web and Rails, but I also learned it making command line scripts which it's also amazing at.
No, everybody needs the speed. But I was curious if it's really faster or not. Please look at my question at HashNode which explains why I'm curious about the speed of these two frameworks. https://hashnode.com/post/which-one-between-phoenix-and-rails-should-i-choose-for-our-next-project-cj6vej6k800uflkwtfu5ez47j
Please look at my question at hashnode which explains why I asked this question at reddit. https://hashnode.com/post/which-one-between-phoenix-and-rails-should-i-choose-for-our-next-project-cj6vej6k800uflkwtfu5ez47j
&gt; What about Go? Same thing. When you spend most of your time waiting for the DB/hard drives/network, doesn't really matter if the code waiting for them is blazing fast C++ or slow as hell bash; you're still waiting for the DB.
But Go's GC is faster and using websockets with it is cheaper. That was the reason I asked the original question. I thought Elixir's GC will be better than Ruby's
I'm learning a lot from the tests in your application themselves. Thank you
https://www.reddit.com/user/_tomekw It looks like it was posted to a bunch of places.
But even C++ or C has to stop and wait for a database call to complete or HTTP response to come back.
In general, an Erlang server (Which include Elixir) is not designed to go super fast on one request, what it should do is provide a very level throughput under heavy load. So what you want to ask is how will this perform when it is being hit by 10,000 requests/second or 100,000 That being said I have often had an average response time on Erlang web servers that was 2ms +/- epsilon. 
This is a blog post I wrote on how ruby tokenizes, parses, and compiles programs. I would love some feedback on it.
I'd recommend doing something involving text or XML parsing since it forces you to use external gems like Nokogiri while also getting comfortable with object manipulation. Also, do the Ruby Koans
fine ... without regex then `input.each_char.each_cons(3).map(&amp;:join).count('BYE') == 3`
There is a cool library called Gosu, which lets you create 2-D games. I wrote an arcade game in Ruby using it.
If OP's real question is [the one in hashnode](https://hashnode.com/post/which-one-between-phoenix-and-rails-should-i-choose-for-our-next-project-cj6vej6k800uflkwtfu5ez47j) then, it doesn't matter what other people say in their benchmark. Each application is different in its own way. Best way to determine which platform is most suitable for your application is by doing a proof of concept in all and run a benchmark on your own. 8K concurrent users is not a lot. You can achieve that with just a well architectured monolith written in Ruby, PHP, Python or whatever language your team has the most experience with.
I think all that's needed is a counter that increments by 1 every time the user's input is equal to "BYE", and resets to 0 when it doesn't. This way, if the counter is equal to 3, they can stop talking to Grandma.
My main non-web, production use for Ruby is definitely data processing &amp; ETL (Extract Transform Load). I use my gem [Kiba ETL](http://www.kiba-etl.org) for a wide variety of data processing tasks, including enterprise data exchange, reformatting, data migrations, fun mashups etc. You can see a screencast explaining how this works [here](http://thibautbarrere.com/2015/11/09/video-processing-data-with-kiba-etl/). Another quite frequent (for me) &amp; useful non-web use-case is writing specs for server setups (using [ServerSpec](http://serverspec.org) or [InSpec](https://www.inspec.io)). Lastly, Ruby remains my preferred language for all types of scripts (analysing files, quick SQL queries, small numerical simulations, etc etc).
Cool!
&gt; Ruby remains my preferred language for all types of scripts Me too! I'm just playing around for fun mostly, but was wondering where to look outside Rails/web dev.
This is probably relevant to the discussion too: http://blog.plataformatec.com.br/2017/07/the-fallacies-of-web-application-performance/ Even if you don't need the performance in production, you can leverage many of Elixir and Phoenix features for a better development and deployment experience.
Check out Vagrant and Homebrew, they're popular non-Rails applications
For single thread applications, sure. But web requests are very parallizable and Go and Elixir come ahead with better concurrency support and semantics than Ruby. So while one request is waiting the database, your CPUs should be working on the next request.
I came to pitch Kiba, and data transformation as well. I find ruby very pleasant to work with in terms of text based data wrangling. Thibaut has a lot of great examples of using ruby for ETL and I found this a refreshing respite from typical Rails land. One of my favorite "man I'm glad I learned Ruby" things is to dive into pry and connect to my db to identify and correct data. As an example, I had around 120 stored procedures in a DB of about 500 that all needed to be checked for something, and then modified to include the new something if missing. This could have been an all day task, but with Ruby, it took about 30 minutes. The power of leveraging a full programming language instead of strictly TSQL is absolutely wonderful. I also use it often for making small command line apps, again for helping me keep tabs on data. My favorite tool is one that checks for certain conditions in a non-ruby, actively running data acquisition task, and leverages the Slack API to send a push notification to my phone in the event of "bad stuff" for high profile situations. As an aside to OP: I've recently read two books that feature ruby in a non-web environment that you may enjoy if data is your PBnJam: - [Text Processing with Ruby](https://pragprog.com/book/rmtpruby/text-processing-with-ruby) - [Build Awesome Command-Line Applications in Ruby 2](https://pragprog.com/book/dccar2/build-awesome-command-line-applications-in-ruby-2) I really appreciated that the words "let's make a blog" were nowhere within the pages of these books. Nothing against Rails. I love and use it. But there's more to Ruby than google would have you believe.
sounds like rvm is not installed properly You shouldn't sudo install gems if you have rvm setup correctly.
I can't fully help you because I don't know the ins and outs - but I know when Apple released El Capitan that my entire gem set homebrew went to hell. It took me a while to find a good source at the time but this article [here](https://digitizor.com/install-homebrew-osx-el-capitan/) walks you through how to deal with El Capitan. I don't know what OS your computer started with or has now, but since it's a permission error I think you might be running into that and have to 'start over' on your gem sets / homebrew as the article instructs It was the one time in 35+ years I've really been pissed at Apple
Glad you like my ETL examples! I plan to post more in the near future. Your example is great - typically using Ruby as a glue (easier to connect to whatever you need thanks to all the existing ruby gems) works really well! I can also encourage anyone doing such things to check out [Sequel](http://sequel.jeremyevans.net), which is very powerful &amp; flexible in such scripts.
I wrote a (non-web) application that manages the video encoding queue for the place I work. 
Metasploit Framework is an exploitation framework with command-line, console and web interfaces, and does a lot of non-typical stuff.
I second the mention of Sequel. It is, hands down, the best SQL DSL I've ever used and the maintainer, [Jeremy Evans](http://code.jeremyevans.net/) is one of the nicest, smartest people I've met. Also, the code in Sequel is very well written, documented, and tested. It's a great Gem to read through.
Chef, too.
Fluentd and the whole ecosystem of plugins 
See if there's a missing feature that you think might find useful. I noticed in the search results on Discogs, you can filter by year which also gives you duplicate Category #s from the same seller example: https://www.discogs.com/sell/list?year1=1985&amp;year2=1987&amp;sort=seller%2Casc&amp;currency=USD&amp;limit=25&amp;artist_id=246650&amp;ev=ab&amp;condition=Near+Mint+%28NM+or+M-%29 It would be nice to filter by year and only have unique Category #s in the results. 
* Minitest - Perfect example of how elegant and simple a "framework" can be. Esp. when compared to "that other testing framework", Rspec. * Mocha - Nice example showing of the power of metaprogramming and overrides and inheritance of Ruby. * Fog - neatly organised, large framework, showing some Patterns in practice: Adapter Pattern mostly. Also showing some good practices on how to organise "lots" of modular, code. * Fluentd - the living example that "Ruby is slow", is a nonsense-argument (edit: without actual, practical, use-cases on the benchmark). Fluentd handles millions of events in our stack and it is not even close to becoming a bottleneck. Nice to read the code too, because it shows some nice patterns to keep Ruby running lean. * [timetrap](https://github.com/samg/timetrap) - usefull. And some nice examples on how to test a CLI app.
Do you have some details or even link to issue report ? Used Spree based solution and never experienced something like race conditions at DB access, which is handled mostly outside of Spree code anyway. Running on PostgreSQL with pg gem.
http://bitboxer.de/2015/11/05/ruby-gt-web/ Some of them have already been mentioned, but some haven't. 
Thanks!
Using techniques like named parameters certainly help make booleans more readable. I'd go one step further and consider the smell that the function/class has more than one responsibility, so we might think about breaking it up into two functions. Otherwise, as the code grows over time, you end with other smells, like long parameter list or a case statement that does one of many things depending on the input.
Similarly, there's the Ruby wrapper around Simple DirectMedia Layer (SDL), [ruby/sdl](https://www.kmc.gr.jp/~ohai/rubysdl.en.html).
Why would he need autkmated server provisioning as a new comer?
Yes. A lightweight framework written in a compiled language leveraging concurrency, and parallelism across multiple threads is faster than a bloated framework written in an uncompiled language that runs in a single thread. That should not be surprising. Yup - there is (fill in the non-MRI Ruby variant here). No one cares. Speed was never a reason to use Ruby or Rails.
You say that - but in 10 years as a Rails developer I never once saw a non-trivial response in less than 2ms. I routinely see Erlang services respond in Œºs.
I haven't done it yet (or even looked into its feasibility as I'm a noob too) but one application I wanted to write for practice would look into a certain folder on my computer (specifically the folder where my wife's phone dumps the ten zillion photos she look since she last synced), grabs the photos there, makes a new folder inside of an attached external HDD (named with the date of the file dump), drops all the photos in there and then deletes them from my computer. 
Haha, the same devs who left (or been fired from SC) claimed at Solidus birth more better though-out design and stable API. The same who were blamed for its constant breakage and structural changes (db, views), even within a major branch. A bit ludicrous from my PoV. Current 3.1+ versions are more settled and polished then anytime since I had touch their code (since 2-1 branch).
Great gem! Just one gentle reminder, though: always measure before and after, in an environment as close as possible from your production, to verify that the changes improve the situation. In some cases, fewer larger queries can end up taking more time, etc.
Mine are some: https://github.com/molybdenum-99/infoboxer, https://github.com/molybdenum-99/reality, https://github.com/zverok/worldize for example. SciRuby had also lot of good attention lately: https://github.com/sciruby
GitHub links: - [Minitest](https://github.com/seattlerb/minitest) - [Mocha](https://github.com/freerange/mocha) - [Fog](https://github.com/fog/fog) - [Fluentd](https://github.com/fluent/fluentd)
Great idea!!!
&gt; never experienced something like race conditions at DB access, which is handled mostly outside of Spree code anyway. I don't think you're understanding what I mean by 'race condition'. Take for example two users editing a Product record at the same time, without some form of locking the last writer wins and may clobber all (or part) of the changes made by the other user. Something simple like this would generally be handled with optimistic locking. Situations like this are not up to the database driver / PG to somehow 'deal with', it's domain specific. Transaction deadlocks are also up to the user to avoid. &gt; Do you have some details or even link to issue report ? I sent a list of example concerns to the person we were talking with at Spree about various types of commercial support, this was in early 2014 as I recall. But it doesn't take much effort to find issues on their github project, search for 'race condition' or 'deadlock'. 
I like the post, it's a good primer to the process. I would consider going into more explanation of the compile step: teaching people how to read the compilation output gives them a tool to explore further on their own.
I'll give a plug to the [padgem](https://github.com/nicoschuele/pad_gem) gem that my friend made. It's a simple tool for generating Ruby gems, basically setting up the directory structure and necessary files for you ‚Äì quite a nice little time saver.
Take a look to this collection http://awesome-ruby.com. You can build a lot things using Ruby :)
Awesome!!
Can you explain why I might choose this approach over ActiveRecord' s batch size parameters and methods? Or the includes or pluck method?
I have made command line tools with Thor and found that fairly enjoyable 
Thanks! I totally agree. You should never optimize performance blindly. Make sure that you found a bottleneck and that your changes improve the situation :)
Yeah, good question. Using AR is easy, but it doesn't always work, for example: * It's impossible to avoid N+1 queries with just an ORM if you use data from other sources. Sometimes it's required to make requests to other DBs or services through HTTP (see the example of HTTP batching in the README). * If you don't want to preload whole association with "includes", only specific records (e.g. to optimize memory consumption). In this case, people usually use "pluck" to get ids, load the records with "where", then pass them down. BatchLoader allows to define this logic right in the place where you need these records, no need to share the data explicitly or pass it through variables. * With GraphQL, backend describes schema with fields (and associations). So, the client can ask for any fields described in the schema. Because of this flexibility, it's hard to preload data in advance on the server, since clients can ask for any allowed associations. With batching you can load data in a batch where it's necessary and only if a client asked for it in a query (not in advance).
I created a extendable, scaling automation tool for my work. It has just a simple REST interface (via Sinatra) and runs a variety of tedious tasks with Selenium that you'd otherwise have to do manually and usually takes around 40 minutes. It also sends Slack messages letting you know when each task had completed, and gives you estimates on how long it'll take to complete.
Check out the [Guard/Listen gem](https://github.com/guard/listen). It watches a directory for files added or changed and allows you to do whatever you want from there. You can check out a gem I was working on that utilizes the Listen gem to automatically optimize new images that are added to a directory. Feel free to use it as a reference [here](https://github.com/chrislabarge/tinify_new_image/blob/master/lib/tinify_new_image.rb)
Thank you!
I know the solidus fork of spree that xblakeb makes fun of below spent some time on trying to improve this situation, eg with the [OrderMutex](https://github.com/solidusio/solidus/blob/054e4bd75c65166d316f3f63be85efb48736bcdb/core/app/models/spree/order_mutex.rb) class. (race conditions in _orders_, actual purchases, are clearly the worst of all and highest priority, compared to two admins editing a product simultaneously or whatever.) Things definitely still weren't perfect when I last used solidus (don't currently use it), and sometimes traded performance issues and deadlocks for race conditions, but definitely improved. Spree doesn't have that OrderMutex class, it occured in solidus after the fork, but I don't know if spree does something else to try to deal with it. 
&gt; Maybe the trick is to thinking of the kind of project that I can see myself use, yet it is not extremely involved that I get burned out on it? Yep! Easier said than done maybe, but that's the trick I think too! Can you scale back your original idea into a less ambitious MVP, does it have any point without a recommendation engine?
This was just the right level of complexity (or simplicity) that I needed. I had tried looking into this before but would always get lost when I'd read more complex "introductions". Thanks.
Thanks :)
&gt; Also, do the Ruby Koans On it!
Yeah, this. You should never have to sudo to work with Ruby via rvm. You probably need to fix permissions on some folders. If you're feeling really frustrated, maybe consider bailing on rvm and switching to rbenv. Follow the git checkout instructions, it's very quick and easy. 
just anecdata but I've been porting a rails application to Elixir and its not even close, even on the endpoints that are basically a line-for-line port. When I'm in services that actually make use of facilities like OTP, it jumps a couple orders of magnitude faster. I loadtested one endpoint that comprises maybe 75-80% of my traffic in a realistic pattern of read-write-readresult, and what took 10-20 heroku dynos to handle my peak load during my busy season I was able to serve up with just a basic dyno, which then went on to serve up 3x my peak load in terms of requests handled. One of the things Elixir and Phoenix do really well at that Rails does really poorly at is elastic scaling (i.e. slashdotting, hug-of-death scenarios). if your application is nothing but cacheable reads then Rails might do ok, but real interactions get expensive really quickly. Elixir just handles it. Requests might take longer to complete once you surpass your database connection pool, but it doesn't just fall over.
I recall a few years ago chatting with a friend who did rails, he nearly fell off his chair when I said "If a response takes less than 10ms I start to optimize" I don't think my logs messured microseconds
Have a counter set to 0. If you say bye and it is upper case, add one to the counter. If you don't say bye in upper case, set the counter back to 0. If the counter reaches 3, you can leave or whatever you want the program to do once you satisfy the 3 byes requirement. 
Write an app that pulls reviews and usernames from these review sites or Quora, etc and assign each bootcamp a score based on real review likelihood. Or something like that 
I'm using it to automate tests, like SOAP, HTTP requests, then SSH to collect logs, database changes, etc. 
Erlang/Elixir does GC on a per process basis. So unlike in say Java there is no Stop the World Garbage collection. Large binaries are done in a different way (ref counting). The other thing to note is that switching between processes on the Erlang VM takes about 10-20 machine instructions and it also is very good at doing all the right things on Multi Core. So if you put your Elixir app on one of the XEON chips with 36 cores it will be able to use them all with you having to do very little extra work. 
Why not just use AR when prototyping, and then optimize later for N+1 by eager loading with ```includes```, and then optimize further by writing custom SQL that grabs only what you need if you run into issues like too much memory consumption?
I love crafting command line tools. I always bring in a new gem to try out.
OP's goal is "to get better at Ruby". Reading Chef sourcecode and writing recipes might very well help with that.
And of course keep in mind that when the volume of data changes this may affect the relative performance of 1 query vs. N+1 queries. But in general it's better starting off with fewer queries and trying to optimize them.
I liked your article. Especially loved the `def add(x,y)` animation. It was short enough to understand something, but honestly, I hoped for a little bit more. Also, the `Parsing` section shows two representations of the same AST: code &amp; visual. However, I couldn't really comprehend what those six `nil`s are and how they are represented in the tree. 
This is a usual flow. But batching is not a technique opposite to custom SQL queries, they can be used together. There are some cases when using just custom SQLs may not work or be complicated: optimizing N+1 HTTP queries; sharing or passing preloaded data as variables may be a problem if you need to pass data several layers below; you couple your parent which should know which data to load in advance; with GraphQL it's hard to predict which data user is going to ask in a query, etc.
Thank you all for the feedback! It sounds like I could do some work on adding more detail to the parsing and compile step portion of the blog post. Perhaps I will explore each in further depth in a separate post. Thanks again!
Use a variable to count how many times in a row you've said "BYE". * Initialise the variable at zero. * Every time you say "BYE", increment it by 1. * Every time you say something else, reset it to zero. * If the variable == 3, use `break` to exit the loop.
&gt; I'll make a promise: whatever chopped and screwed version of English gets churned out by the first example will still be less clear than the straightforward prose of the second example. I don't understand this argument. "it is expected to equal education_level + 1" Is much closer to proper english than "test Increases the education level assert subject's education_level equals education_level + 1" If we're gonna pick on `rspec` DSL usage, `subject` and `described_class` would be my first targets. They are pointless indirection most of the time. I never use `described_class` and only use `subject` when the `it is_expected` DSL makes sense, otherwise you're just forcing the reader to scroll back up through the file to figure out what `subject` actually is.
&gt; You shouldn't sudo install gems if you have rvm setup correctly. Further, you should never use `sudo` to install anything on OSX. If you find it's 'needed', something else is wrong. 
Sounds like you installed `rvm` with `sudo` which isn't going to work. It can be made to work but there is no good reason for it. Remove `rvm`, which may require some manual steps, `rvmsudo implode` _may_ work, not sure. Then install `rvm` without `sudo`.
Seems more like an advert for Logz.io than anything remotely useful to read about logging, but maybe I'm being a bit harsh!
&gt; You probably need to fix permissions on some folders. https://stackoverflow.com/a/11644182/1954610 This *might* work: sudo chown -R username:group ~/.rvm sudo chown -R username:group ~/.gem ...Or if your issues get more convoluted, just reinstall rvm. As a general rule, it's a bad habit to use `sudo`/`root` all the time, even when it's not needed. You'll end up screwing with permissions like this.
We don't read code like we read English prose. We scan it and interpret it. `Trying.to(:turn) { "SourceCode" }.into_english { is_a?(fools_errand) }`
Is there a list of eCommerce development consulting agencies that work w/ Spree and Ruby floating around anywhere?
It's fair - the content is created for Logz.io with the idea of exposing the Ruby community to what we are doing.
we do at https://redpanthers.co, but ya I understand what you mean. I don't think there is a comprehensive list, and I also think if there is a list I don't think it would be complete as there are a lot of companies that work in ruby across the globe.
If you're using rbenv: rbenv versions --bare | while read ruby; do rbenv shell $ruby; gem update --system; done
Actually, this project heavily relates to all efforts by SciRuby. SciRuby is not dead by any means. And I hope it'll stay as one of centers for the Ruby community. Ruby should be a general purpose language, not an implementation language for the (by the way a really good) Rails framework.
How easy is putting Go to work to consume all the 36 cores (in your example)? Would that require more work?
you mean more than 10ms?
Is it possible to do an upgrade like this on Heroku?
It will be fairly basic, with just users selecting "interested"/"not interested" for events in their area, but yeah, I feel that's the way out of the slump. 
It is unfortunate that the RG team chose not to post Issue or PR numbers w/ this security announcement as they do with other releases.
A very welcomed release! Looking forward to using rails 5.1 and ruby 4!
Or how about CVEs? As of this writing it's not listed in https://rubysec.com/advisories either, which is unfortunate, that feed can give people automated warnings. Poor release management for vulnerability info for software used by nearly everyone using ruby. :(
Not sure whom you think "we" is but writing code in such a way that reads similar to english is very common in Ruby; Perhaps you meant "I".
The build pack for ruby is what includes the rubygems installation along with the ruby installation and bundler. So they'd be the ones responsible for updating it (or you could fork heroku-buildpack-ruby, patch it yourself and use a custom BUILDPACK_URL). Maybe file a github issue on https://github.com/heroku/heroku-buildpack-ruby ?
"We" is all of us who read source code. We simply don't read code like English prose. If we did, then this would seem like a normal sentence to us: "Class users controller application controller def create user equals user create params user." English doesn't have hierarchical indentation structures that nest context, allowing more precise concepts to remain distinct from broader, more general ones. That's why heavy use of the RSpec DSL often proves so problematic -- it leads to these extremely dense rat's nests of contorted prose stuffed with symbols and inevitable grammatical awkwardness. When given structure and space, on the other hand, our trained minds can ignore nitty gritty details when we need a higher level view, and set aside the big picture when we're trying to understanding something specific. I don't mind if you disagree. I won't even downvote you for it :)
&gt; "We" is all of us who read source code. Which is demonstrably false, because plenty of people have no problem with it. If you have an opinion, that is fine, but don't pretend to speak for 'all of us whom read source code'.
"Having no problem with it" is irrelevant. My claim is not that excessive RSpec use renders code somehow unreadable, it's that it leaves it harder to read than it could be. And I'm not speaking _for_ anyone. I'm speaking about the way our brains process source code. There might be many reasons why we feel a sense of satisfaction when looking at a line of code we just wrote. When we feel that satisfaction, we start to develop habits and preferences. That's not exactly the same thing as what I'm talking about, and it certainly doesn't refute it.
&gt; I'm speaking about the way our brains process source code. Citation needed.
I like writing command line tools in Ruby, in which case long startup and warmup times are deal breakers. I gave up on JRuby and will likely not consider TruffleRuby in this role.
Your attitude strikes me as either either resentful or smug (I can't tell which) -- I'll just say that I really didn't intend to offend you if I have (and if I've read you wrong, I apologize). I also don't see where I'm saying anything uncommon, either. When we gauge the quality of source code, we look for exactly the qualities I'm talking about. We want to see the concrete details nested within abstract structural artifacts, so that our brains don't have to understand everything all at once. I don't see what's so outlandish about wanting to hold our test code to the same standard. What is it that you're arguing for? Is it that some people prefer to read source code that strongly resembles English prose, and that's okay, too? Fair enough, I guess, though I don't see how that's possible given that the ability to make the rest of our ruby code read just like English has been around for a long time, but it's never really caught on. Why, then, is it of so much benefit for our test assertions?
Tobias doesn't mention it in his post, but we have a new virtual machine we also target with TruffleRuby called the SubstrateVM. It's a bit funky in how it works, but the SubstrateVM has a companion native binary generator that ahead-of-time compiles a Java application and links the VM into the resulting binary. The net result is our startup time is currently around 120ms (down from 2.5s) when run with the SubstrateVM and we're looking to further reduce that. If you want more details, I wrote a [blog post](http://nirvdrum.com/2017/02/15/truffleruby-on-the-substrate-vm.html) about it several months back and will be presenting on it at RubyKaigi in a couple weeks.
I have no idea, i have never looked at Go. I started doing Erlang before Go was around and really liked it from the start
Yes, more than 10ms
Great post! I added your blog feed to https://engineered.at, looking forward to more stuff like this!
[This](https://www.youtube.com/watch?v=KA9i5IGS-oU) is for you!
Haha, this is one of my favorite talks! Here's another [one](https://www.youtube.com/watch?v=PJjHfa5yxlU) :) 
Video linked by /u/throughactions: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [RailsConf 2016 - Get a Whiff of This by Sandi Metz](https://youtube.com/watch?v=PJjHfa5yxlU)|Confreaks|2016-05-28|0:38:15|314+ (99%)|16,278 &gt; Get a Whiff of This by Sandi Metz Most code is a mess.... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/throughactions ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dmbbqlh\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
Yeah... Sandi is pretty awesome too..
:) I was going to comment that here, thanks /u/nirvdrum ! Also nice to see it's still going, I hadn't heard of the SubtrateVM progress in a while so was fearing it hit some sort of dead end. Might edit that in :) Also, when you're in the market for CLI tools you could give [crystal](https://crystal-lang.org/) a shot. Cross compilation, no need to have something installed + startup time. With bigger CLI tools (just ask sferik about t) the startup time can get troublesome even on CRuby.
Here's the question: Why would you pass `nil` if a function expects a boolean value? Like, honestly. You know, you can also call the function with a Hash, Array, Class or Module instead of a simple boolean. Why though?
All my performance issues are in the database. I've never wished Ruby was faster for my needs.
I am using imgix as well in a few projects and I am very happy so far with it.
Great write-up! I've dug through the Ruby source code at one point myself and found it took a lot of effort to find what I was looking for. Are there any books or articles you could recommend that can help ease oneself into understanding the MRI source?
Rails move too fast to write a book for that framework. I suggest you to abstract from Rails or Ruby and read a good books about web and all related stuff. here is an example https://hpbn.co/ 
[POODR](http://www.poodr.com/)? Sandi Metz is a fantastic teacher.
* http://www.poodr.com/ * http://www.confidentruby.com/ * http://exceptionalruby.com/ Are some that I would recommend that focus on knowing good programming patterns, from a ruby specific point of view that help you break beyond the "do it like this because rails says", and make decisions for yourself along the lines of "we can do it multiple ways, but we'll choose this one because of these tradeoffs/advantages".
I would also add `Metaprogramming Ruby` (on the sidebar) to the suggestions of /u/internetinsomniac
This. Seems like unnecessarily complicating class code to handle edge cases that shouldn't happen. 
https://docs.docker.com/machine/ ? I think there is some confusion when you're linking the MI's that run the containers and the stuff that runs in the containers. These are separate things. You would have a workflow that makes the boxes for containers to run in, and one that manages standing up a series of containers that are your app. It's also 4am and I don't even know anything anymore.
I'm trying to understand how urgent I have to upgrade my production environment. Can anyone give a basic explanation on how these vulnerabilities could be exploited?
Thank you!
Two good one are Pat Eyler's [Ruby Under a Microscope](http://patshaughnessy.net/ruby-under-a-microscope) and Paolo Perrotta's [Metaprogramming Ruby](https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2). edit: oops I see /u/AnimusNecandi already suggested "Metaprogramming Ruby".... well, seconded! Also, Jim Gay's [Clean Ruby](http://www.clean-ruby.com/).
I have multiple copies of POODR just so I can loan them out.
Sorry about that. We should get better about having Ruby-specific release notes with each of the GraalVM releases. We release roughly on a monthly basis and in each release improvements are made to both the SubstrateVM and the Ruby integration. GraalVM 0.27 had a sizable reduction in startup time over GraalVM 0.26 due to improved handling of loading RubyGems (an implicitly required library).
Here're the commit SHAs at least: https://twitter.com/_shanecav/status/902885773653012480 **Update:** I made a PR for the blog post to include links to the commits https://github.com/rubygems/rubygems.github.com/pull/27/ 
Heroku already supports the patched RubyGems version (2.6.13), but only if you specify `ruby 2.4.1` in your Gemfile https://devcenter.heroku.com/articles/ruby-support#supported-runtimes
It's very hard to tell, especially from the amount of info given. I _think_ that it's probably okay as long as you don't do any gem dependency updates until you update rubygems. I mean, realistically it's probably okay even if you do, but I wouldn't to be safe. This is not like a rails vulnerability where someone can attack your running server; it's vulnerabilities that can be taken advantage of by code that has to be already installed on your server, or during a gem installation process. I _think_. Best guess! I could be wrong! Vulnerabilities can sometimes be utilized together to do things you wouldn't expect from them individually. We didn't drop everything to update when we saw this yesterday, but did update last night. I feel like the way this was released indicates not enough developer resources on rubygems, to do it right. 
Why'd you give up on JRuby? I've been pretty happy with it, in some contexts. Oh, the long startup times? Yeah, those are painful. 
HN discussion https://news.ycombinator.com/item?id=15128482
I would upgrade ASAP. One exploit allows installing malicious code, another allows overwriting arbitrary files. See https://github.com/rubygems/rubygems.github.com/pull/27/ for links to the commits with more details. More info here: https://news.ycombinator.com/item?id=15129430
It's been years since I've read them, but "Design Patterns in Ruby" and "Eloquent Ruby", both by Russ Olsen, were really great. I also second anything by Sandi Metz. POODR was fantastic, and I'm looking forward to reading 99 bottles of OOP soon.
Would it be possible to start up say 4 JVMs preemptively, then put them to sleep. Then when invoking a JRuby process, a sleeping JVM process can be used. Wouldn't this improve JRuby startup? What's the toughest drawback of this approach?
That's what the Drip tool does. And there was Nailgun before that which started lots of different Java applications in a single VM. Both have various annoying practical problems and people don't seem to use them much any more.
So much broken English and a distinct lack of understanding of functional programming make this hard to take seriously 
There's Pat Eyler's [Ruby Under a Microscope](http://patshaughnessy.net/ruby-under-a-microscope).
I came here to reply exactly that :-) Pat's articles (even old ones) are an entertaining read on the topic: - http://patshaughnessy.net/2012/12/3/a-high-level-code-walk-through-ruby-mri - http://patshaughnessy.net/2013/1/23/ruby-mri-source-code-idioms-1-accessing-data-via-macros
Yes, I think there are tool(s) that do more or less that, in fact. I haven't used em. It's like what [spring](https://github.com/rails/spring) does for Rails on MRI. But I know I've seen non-rails-specific general purpose tools meant for JRuby that do that. `spring` ends up being annoying sometimes, having old versions of state you didn't mean to have etc. 
I second the recommendation for Russ Olsen's Eloquent Ruby. POODR is good, but it won't help you learn Ruby. It will help you learn OOP concepts/design (regardless of the language).
OP didn't mention Rails. And Ruby isn't changing as fast as Rails. We don't expect Ruby 3 for a few more years.
Nice, I didn't know about that point-in-time rollback capability, that could be super-handy in a pinch.
This is what I do. I use Rails as an API server for React and Ionic front ends. If it's a simple project that doesn't need a front end JS framework and doesn't need mobile apps I'll just use traditional Rails and render everything on the server.
Almost all of my bugs these days are about not planning for exceptions or exceptional conditions properly. Certainly all of my worst bugs! I try to remember now to think about when writing each function and each method, what could go wrong, what will this method do if it goes wrong. Especially for external services, which _do_ go down sometimes. 
Yeah, we have a hybrid app that's moving to the SPA area. Right now it's a mix of multiple Vue apps with a bunch of traditional rails pages. Works well for a transition period, no problem with several Vue apps on the page at once.
I just write tests to make it fail and then update the code to gracefully handle those failures. Saves me a lot of time spent pondering. 
A few months ago, I encountered an obscure bug that turned out to be caused by saving an xlsx file containing a backspace (`\b`) character. Apparently, there are certain obscure characters that spreadsheets cannot handle. I had no idea that was a thing. If I'd *known* about this limitation, then preventing a bug via TDD would have been easy. But that's precisely what jrochkind was talking about: You *don't always know* what obscure issues could pop up.
If you can write failing tests for everything that might go wrong without some pondering/thinking about what might go wrong to write tests for, you're different than me! 
This is great. I've been playing with Rails + React and Rails + Vue and I really like the direction Rails is heading re: frontend stuff. I never liked having to run a separate dev server for my assets, because it added annoying extra steps to restart my app, which lead me to start using foreman + a Procfile.dev, which interfered with my debugger. I'm glad they've worked hard to make it unnecessary.
I think `GitHubBub` and/or the GitHub API hold some responsibility here. https://github.com/schneems/git_hub_bub/blob/master/lib/git_hub_bub/request.rb#L95 Wrapping all failures as a single exception type is bound to cause issues like this. A 5xx is not the same as a 4xx unless you really just don't care what happened. According to the API docs (https://developer.github.com/v3/oauth_authorizations/#check-an-authorization) only a 404 means 'invalid token'. Considering the nature of the request: `https://#{ENV['GITHUB_APP_ID']}:#{ENV['GITHUB_APP_SECRET']}@api.github.com` You could probably wipe the entire database of tokens if you happened to fat finger a change to either `GITHUB_APP_ID` or `GITHUB_APP_SECRET` since I would assuming github would respond with something other than a 2xx for all tokens. Granted it's also possible that Github's downtime was incorrectly returning 404 instead of 5xx due to server issues, but really `GitHubBub` should be returning enough information about the type of error that the user can respond appropriately.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [schneems/git_hub_bub/.../**request.rb#L95** (master ‚Üí 39f2d9e)](https://github.com/schneems/git_hub_bub/blob/39f2d9e999f6158c9025ea2f0b72f1013cca9c5c/lib/git_hub_bub/request.rb#L95) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmcsdud.)^.
I know you said non-web, I assume for web development, but using Ruby with Selenium for automated testing is very common. 
I touched on that a bit over at lobsters https://lobste.rs/s/repgmo/how_i_lost_17000_github_auth_tokens_one#c_wvyozk Edit: In short I agree. The way I designed the lib raises exceptions for any non 200 status codes and doesn't distinguish between different reasons for failure. If I were to do it today I would certainly bake that ability in from the beginning, which is what I was alluding to with the wrapper object comment on lobsters. 
Yea returning 404 there is a bit weird, but likely 'correct' from a REST perspective given the path construction. There is also a conflict in the usage of 401 for an endpoint like this, does it refer to the token or the app auth? Though I think 410 for a previously existing but now invalid token would have been semantically correct. But, I also imagine they chose to not differentiate between 'Not Found' and 'Invalid Token' to prevent brute force token fishing. All that said I'm still curious if they were replying with a 5xx during the downtime.
Sounds like some nice improvements, though I find the most annoying aspect of using AWS via Ruby is that it's still machine generated. It's always had a very non-Ruby feel to it; it often feels like writing Python in Ruby.
It may still be machine-generated, but this sounds like it may make it less obviously seeming so: &gt; These new service-specific gems use statically generated code, rather than runtime-generated clients and types. This provides human-readable stack traces and code for API clients. Won't change the APIs to be more ruby-like though. Honestly, while the API's are sometimes not ruby-like, it's hard enough to find docs and examples on em now, at least now if I find em for another language I can usually translate em to ruby. 
There's also a thing where you write you functions small enough and limit your inputs tight enough that you're only testing a few possibilities. As you get better and write more tests, your factories and fixtures become more robust and make it easier to test further possible inputs. The problem is when you have these massive catch all functions that are taking 1000 different input possibilities. Of course it's impossible to test everything when the function accepts any input and you're starting your test suite from scratch. But that's generally a sign you have smelly code (which you can pick up with a static longer or code sniffer). And the more experienced you get writing tests, the better you get at writing code that avoids those bugs next time. 
How is this advice meaningfully different than "Why don't you just write the code without bugs?"
Why would someone pick that over the official SDK, Octokit?
There are a lot of details on this particular problem which are omitted. Having worked a lot in the past with `net-ssh` in a concurrent scenario, I can give you some hints: * known host verification is a bottleneck. The default verification strategy will usually require 3 fds for every connection you establish (1 read for the global kh file, 1 read and 1 write for the user kh file). The more kh keys you have, the slower the seek will be. You can improve this by selecting another strategy or disabling the feature. Version 4 allows you to add your custom strategy, if I recall. * Use channels to send multiple commands concurrently (if they are independent from one another). * If you want to use threads, set one connection per thread (channels aren't thread-safe). 
yeah, thanks. I did implement some logic with ```Threads```, and it definitely helped. Now it connects only 3 times (cause I'm doing several command on the same servers). I've tried to disable autentication options that are not critical but take time. Will look further for other bottlenecks. And channels are not really suitable for my use case. I might though add a flag to swich between ```sync``` and ```async``` modes. Will definitely check the keys logic, maybe I can cache them.
[This](https://gist.github.com/jonforums/2202048) is a nice implementation with a lot of exceptions handling. Notice that HTTP get has a read_body method that accepts a chunk block which you can concatenate in order to perform a progressive download
Thanks, I will take a look
 task warn_invalid_token: :environment do User.find_each(conditions: "token is null") do |user| next unless Date.today.thursday? ::UserMailer.invalid_token(user).deliver end end Why do you check for the date in every iteration?