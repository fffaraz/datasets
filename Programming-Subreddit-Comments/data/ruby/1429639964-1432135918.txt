[Your confusion is justified.](https://github.com/jnunemaker/httparty/issues/285#issuecomment-44484150)
`gem install` without a version will try to install the latest version of a gem, which it retrieves from the index file. If the index has been updated, it just doesn't try to retrieve that yanked gem. However, if you specified the `--version` flag, you could install it. In contrast, Bundler will only install gem versions available in the index. So the Gemfile.lock works a bit differently than `gem install --version` does. If you've locked down a version that's been yanked, you can't install it. Unless you use one of the non-gem sources (e. g., `path` or `git`).
So the weird thing is, I changed the Gender on users#show to a hash because the value of female was a 2. However, even though the user has that value (I checked via the Rails console) it won't show up in the best_in_place gem to be edited in the view. 
I've actually run into situations where a yanked gem prevented us from upgrading the bundle altogether... So it's not quite that simple 
`include` loads the ruby file and executes it directly on the page, pretty much as if it were included directly on the page at the point you put the `include`. You don't see `include` very often in most ruby code, it's rarely used. `require`, on the other hand, is the standard way to load dependencies from other files, and you'll see it all over the place. If you `require` the same file more than once it will still only be loaded once. `require` is only useable on gems, it can be used on any files at all. It will look for the files named, by going through the currently set `$LOAD_PATH`. Gems loaded are automatically added to the load path. But you can manipulate the load path yourself to add local lib dirs, if they aren't already on there. Try googling for ruby require, you'll get lots of information. Did you try that at all before coming here? 
This is wrong. You see `include` in Ruby code all the time because it is a language construct not a file-level construct like you are implying. Here is the simplest explanation I could find quickly via [stackoverflow](http://stackoverflow.com/questions/318144/what-is-the-difference-between-include-and-require-in-ruby): &gt; The include and require methods do very different things. &gt; The require method does what include does in most other programming languages: run another file. It also tracks what you've required in the past and won't require the same file twice. To run another file without this added functionality, you can use the load method. &gt; The include method takes all the methods from another module and includes them into the current module. This is a language-level thing as opposed to a file-level thing as with require. The include method is the primary way to "extend" classes with other modules (usually referred to as mix-ins). For example, if your class defines the method "each", you can include the mixin module Enumerable and it can act as a collection. This can be confusing as the include verb is used very differently in other languages.
`require` searches the load path for the library and evals it into the interpreter. Say you have a class defined in some file then you `require` that file, the class becomes available to your code. `require` will only eval a file once even if there are multiple calls to `require` for the same file. `load` also evals files but doesn't have the 'only once' check so the file will be eval'd every time there is a `load` call for it. For example, Rails uses `load` in development so that any changes you make are automatically picked up without having to restart the app. `require_relative` does the same thing that `require` does except it takes a relative path to the file rather than searching the load path. Gems generally register themselves with the load path, but you could have some file of your own that isn't in a gem and isn't added to the load path by your framework, `require_relative` is one way to use that file. `include` has nothing to do with either of these. It doesn't take a file name but rather a `module` and includes a module in a class. You also should look at `extend` or just google for 'ruby include vs extend' to get more examples of how modules work in ruby, but here in a simple example of using `include`. module MyModule def hi puts 'hi' end end class MyClass include MyModule end my_object = MyClass.new my_object.hi =&gt; hi A final note: `require`, `require_relative` and `load` can be placed anywhere in the code, but it doesn't matter, they aren't bound in any way to the location they are required. They are always evaluated in the global scope. class MyClass require 'my_thing' end is perfectly valid and doesn't in any way 'scope' the `require` to the class or anything like that. It's generally idiomatic to put the `require` statements at the top of the file outside any other code but it can be useful to `require` stuff in a loop.
This is still wrong. `require`, `load`, etc don't execute the file in the context of the statement, it causes the interpreter to eval to contents of the file in the global scope, regardless of where the call to `require`/`load` is made. To my knowledge, Ruby doesn't have a version of `include` that your thinking of from other languages. i.e. there is no built in way to eval the contents of a file in the context of the call. But, you could do this very easily if you wanted to for some reason. 
Thanks for the thorough answer. That was so good I'll share it with my co-workers. I certainly see things clearer now. Thanks!
Obviously, when you ask 'why?' enough time to every answer you get to the crux: 'I barely remember. This was from a long time ago'. :D
The next thing to check is the state of a user in the database. If the user has the correct gender for what you used upon creation, then the problem is likely in the code for best_in_place. If it doesn't, then the problem is in the initial creation of the user. Are you sure, for example, that you're setting the value of the user's gender in the create action of the users controller?
Thanks a ton! That was it! I guess I need to watch it more carefully next time. 
I don't blame you for missing it. He was like "oh, by the way you need to do....and on to the next topic!". Glad this is working for you, and I might totally use this in my projects!
require and include don't do anything similar. * require: load and run an .rb just one time. * load: load and run an .rb every time load is called. * include: add all the methods from a loaded module as methods right where I am.
Really excited about the data provider API being the next priority for Volt! I always felt that being forced into using a document database limited Volt's potential applications. [This article](http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/) by Sarah Mei, despite its provocative title, explains the problem best. Volt is much bigger than mongodb to me - I want to use it to build applications whose data happens to be relational and does not fit into the document model (i.e. most applications). EDIT: Great, and now there's this, at the number one position on hackernews today: [Call me maybe: MongoDB stale reads](https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads). My objection to was to document databases in general (on the grounds that most data most of the time turns out to be mostly relational in the final analysis), but MongoDB in particular is just a turn-off in itself, and it keeps delivering unpleasant surprises year after year it seems.
There is a good amount of code in the book. The book continues down the path of the example used in the free email course. Sign up for that if you're unsure. It should give you a good taste of what to expect in the book.
Relational data can be stored as a document and vice versa..
If you store relational data as linked documents, you *are* implementing a relational database. Most likely *poorly* at best.
Care to explain why that is poorly?
Has anyone explored the level of concurrent users that can be connected to one volt instance. This is my biggest question about volt. I want to know what to expect when scaling volt.
&gt; It seems like there's no way to make Array#product return an enumerable, so no laziness AFAICT. Hope someone else can chime in on that... class Array alias_method :old_product, :product def product(*arrays) return enum_for(:product, *arrays) unless block_given? old_product(*arrays) { |p| yield p } end end EDIT: This gets you an enumerable, but not a lazy enumerable. I'm not really sure how you could realistically implement a lazy enumerable for a `product` operation.
Wondering how Volt is going to fit into the Rails 5 landscape with the seeming isomorphic capabilities (??) of the new Turbolinks 3 + ActionCable???
Do you have any links to share re Turbolinks 3 and ActionCable? I assume the "isomorphic capabilities" you are referring to are in Turbolinks 3? What's that about?
That would also do. Thank you.
From what the docs show, you need to pass an instance of a Digest, not just a string. (And note the order of the parameters) OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha1'), secret, signature_data) http://ruby-doc.org/stdlib-2.1.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html#method-c-digest
I realize they've already stated: &gt; We’re pretty close to having a fully implemented “data provider api” that would allow anyone to easily implement a store adaptor for any database or data provider. Is there some preview of what this might look like? 
[**@CodeFancier**](https://twitter.com/CodeFancier/) &gt; [2015-04-12 01:10 UTC](https://twitter.com/CodeFancier/status/587060068606050305) &gt; I would love to have some \#codereview of my \#opensource \#ruby gem at https://github.com/stevecj/client_for_poslynx. Please RT. ---- [**@CodeFancier**](https://twitter.com/CodeFancier/) &gt; [2015-04-21 17:06 UTC](https://twitter.com/CodeFancier/status/590562180199751680) &gt; \#ruby \#rubygems \#codereview I would appreciate code review for my new time_scales gem at https://github.com/stevecj/time_scales . ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Rails towards version 5.0, is probably still the best web development framework around. This article explains how image management in Rails is solved using Cloudinary's cloud-based solution. Ruby sample code included for image upload directly from the browser, and for embedding dynamically manipulated images with optimized delivery. Disclaimer: I'm one of the co-founders of Cloudinary.
[StackOverflow discussion](http://stackoverflow.com/questions/318144/what-is-the-difference-between-include-and-require-in-ruby), circa 2008
I think that turbolinks 3 and Cables are only partial solutions based on the talk. There's still room for a framework that focuses on those things from the ground up. After all Sinatra and Grape still exist.
Thank you very much for the link - I will very likely end up using embulk from kiba (as a post-processor once the ETL job is done). This is great, thanks again!
After reading this article, I still don't really understand the difference. Would've helped if the author provided some explicit equivalences and direct examples, instead of all these indirect FactoryGirl examples and tangents. Is it the case that the following two calls are equivalent? my_obj.instance_eval(&amp;block) my_obj.instance_exec(&amp;block) and then with arguments, that these two are equivalent? foo = "foo" argless_block = lambda { puts foo } arg_block = lambda { |foo| puts foo } my_obj.instance_eval(&amp;argless_block) my_obj.instance_exec("foo", &amp;arg_block)
Yes, Ruby is a good language for a beginner. So are a dozen others. Pick one, learn it, then learn another, and then another, and soon enough, you'll know what their strengths and weaknesses are, and you'll gravitate towards one or the other.
Ruby is great as a first language. The Codecademy course is good for getting a basic feel, though it's somewhat lacking in terms of the bridge to application. There are three resources I like: First is [Chris Pine's book](https://pine.fm/LearnToProgram/) -- he's got a great conversational style and you'll get to see lots of good examples of code (it's worth it to pick up the book). Second is [Learn Ruby the Hard Way](http://learnrubythehardway.org/book/) -- these are guided exercises. The pedagogy isn't as solid, but it's nice to see working examples. Last, consider the [Odin Project](http://www.theodinproject.com/ruby-programming) -- this is more a guide for self-study than an actual course, but it's a reasonably thorough overview of the tools you'd use as a professional. It'll also help you bridge into creating Ruby on Rails applications if you decide you want to build web applications. The thing I love about Ruby is that there's not much boilerplate that you have to do. Instead, you can get down to the business of writing code. The hard thing about Ruby (in particular, but this is true of most programming languages) is that you'll occasionally see very clever but not very readable lines of code. TL;DR: Ruby is great! So are lots of other languages. I'll suggest starting with Ruby unless you have a friend who knows software development and is willing to occasionally help you debug, in which case pick a language they recommend. Barring that, Ruby is pretty cool.
It'd be one of the best first languages in my opinion, and that's obviously subjective. Some people fall in love with JavaScript, others Python, and still others Ruby. All in all it's an easy, readable language with lots of syntactic sugar and helpful core methods. Learning it? Learn Ruby the hard way. The well rounded rubyist, Chris pine's learn to programme, etc... Just google learning Ruby and you'll get some good results to explore. 
I'd really like volt to become the new 'rails'. DHH SAYING, fine I'll begrudgingly give you an easy to generate a rails api, but what you really want is turbolinks 3... In my opinion, is not a viable solution to the current web development landscape. Volt is an interesting solution to questions not even yet being asked in rails. 
Personally I like measurable results. So I would recommend https://www.railstutorial.org/. It goes over ruby, rails, and git. So you get a running start to making cool things. Also check out your local meetups. Learning should be fun more than not. 
I think it was a better first language in ruby 1.8 than it is in ruby 2.2 -- they've added too many different ways to do the same thing in the fundamental syntax. But it's still probably pretty decent. And don't go learning ruby 1.8 even if was a better first language, it's not worth learning outdated technology. I am a fan of Learn Ruby the Hard Way, it's targetted at people learning a first language. http://learnrubythehardway.org/book/
To expand on your metaphor: If your car breaks down you can open up the hood, look at all the parts, use resources to find out what they do and you can fix it yourself if you feel inclined to do so.
People fall in love with JavaScript? Wow.
thanks for making this! I added a couple.
I'll give it a try, and see what I think.
Regarding dependency injection vs inheritance, I like your thinking, but I'm not sure exactly what kind of DI pattern you have in mind. Could you scribble out a few lines of example of what you're thinking? I'll respond to the question in your last paragraph above later this evening when I have more time to type.
Two things -- you've got a question mark in the URL in the Ruby version, and you've also got the signature_data and secret params around the wrong way in the hash method. Try this: uri = Addressable::URI.new uri.query_values = {:foo =&gt; 'bar'} secret = '123abc' signature_data = uri.to_s.sub(/^\?/, '') + secret signature_data = OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha1'), secret, signature_data) signature = Base64.encode64(signature_data) 
…I also would not recommend C++ or Java as first languages since they are both rather poor examples of how OOP is supposed to work. Not that one should never learn or use those languages, just probably not as 1st languages.
How so?
&gt; My guess is that you're saying it's an "awful language" because you heard it was. Can you explain why it's an awful language in your own words? You're recommending a book that is literally about separating the good and bad parts of JavaScript, and you're going to ask this guy why he thinks JavaScript is awful? &gt; JavaScript is an effective tool for this learning process. Why tell someone to read an entire book about how to write proper JavaScript when you could just recommend a language that isn't full of landmines? Programming is hard enough to get into when you have a reasonably sane language.
Why does process_payment call deliver_cart? That isn't very intuitive IMO.
I wouldn't say those things to a beginner. I just would never recommend C++ or Java as 1st languages for those reasons (that and the fact that it's hard to write code in C++ that isn't a terrible rat's nest, and the fact that I think one should gain a firm grounding in C before learning C++). I guess everyone's experiences differ. I've always had terrible luck trying to get help with things that I don't understand or don't work as advertised in Java, whereas I can pretty much always find someone to help answer a question about a Ruby gem.
&gt;assembly You monster.
Ruby is like any other language in that it has merits and flaws. Ruby *feels* goddamn amazing to code in and is an excellent utility language. Plan to become reasonably proficient in several languages though, with halfish of them being "hard" lower-level languages. If you were to only learn Ruby, you'd be missing out on a ton of other valuable perspective.
Let me second Chris Pine's book -- "Learn to Program". I've taught a half-dozen people to program using it. They all came out competent programmers for functional purposes, with good habits and a good understanding of the fundamentals. It's a great foundational book and is an easy way to jump in.
Going to third the notion on Pine's book. Is that a thing? Thirding something or do you stop at seconding? D:
&gt; My guess is that you're saying it's an "awful language" because you heard it was No, I'm saying that because when I have to write javascript I always end up wanting to kill myself. That doesn't happen when I use a sane language. &gt; I agree that the language design isn't ideal; I prefer using TypeScript when I can. I've never used TypeScript, but have looked longingly at it's form and function on numerous occasions. It seems like a very reasonable language. If I could snap my fingers and make everything JS magically become TS, I would be a happier man! -- and then I would happily go along with recommending TS as a first language because, I agree, making web pages do cool things would be a pretty satisfying way to learn to code.
It gets even more out of control when you start seeing solutions that involve metaprogramming. The rule I've set for myself (and for my students) is to write code that someone who is reasonably familiar with programming (regardless of whether it's Ruby or another language) can pretty quickly figure out. Some of this comes from good variable and method names, and a lot of it comes from breaking the fancy stuff out into the smallest possible pieces (or avoiding it altogether when a simpler solution exists). Sometimes I'll come across a code snippet that's so clean and elegant that it's almost a religious experience. Most of the time, though, really snazzy code snippets feel like someone is trying really hard to be clever.
No. I'm an expert in neither but I know the difference. 
&gt; too many different ways to do the same thing in the fundamental syntax What do you see as the most egregious examples of this phenomenon?
There's 2 sides to this question: 1) Will Ruby be easy to learn for someone who knows nothing about programming - Yes. 2) Will learning Ruby help me learn the fundamental parts of programming - Maybe. Ruby is really simple to program in. It generally reads like English. You don't have to know the difference between a string and an integer, you simply know that writing 12 is the number 12. You can pick up Ruby and accomplish things very quickly, with a minimum of boiler plater. To the second point, though, a lot of Ruby's ease of use comes with potential pitfalls as you move into other languages. Types will confuse the crap out of you if you go from Ruby to C#. Other languages missing some of the more functional aspects of Ruby will make you want to tear out your hair. The difference between passing a parameter by value and by reference will seem like an impossible to grok black box of pain and suffering. Don't let that dissuade you from Ruby as a first language! It will be great for you to pick up and work with. Just understand that there will be a lot of concepts to pick up if you want to move onto other languages.
Can you give an example of what you mean then? Illustrating your point with some code would really help :)
I would kinda agree with you on C/C++, but Java? What about java is lower level than Ruby? The only thing I can think of is that older versions of Java had syntax closer to how assembly would look like (e.g., for loops translate pretty directly into assembly). But with newer versions of Java, they even favor map/reduce, lambdas, and other metaphors that Ruby has long used. C on the other hand provides closer to metal understanding of what goes on at a lower level. Whats even more awesome is that you can quickly see who any Ruby methods are implemented in C. OP, my recommendation is to start learning Ruby, not Ruby-on-Rails. Make basic command line apps, then Sinatra apps, and then question whether you need more.
By that token, if you want to learn good Ruby programming, just read Eloquent Ruby. It doesn't have to distill out bad parts because those are much harder to come by in Ruby than JS (imo). Rather, it shows you how to write elegantly and powerfully using advanced constructs of the language (eigenclasses, metaprogramming, etc.). Every chapter of that book fills you with a sense of beauty rather than having to warn you of landmines.
There is much more to driving than getting from point A to point B, as is in programming. Speed, safety, comfort, pleasure are things that come to mind. I said Ruby is likened to an automatic, but it could be an SUV, and it happens that SUVs don't have good mileage compared to other cars. (This car analogy is getting out of hand :)) That said, there's really nothing wrong with learning to drive with an SUV. It's just like any other car with 4 wheels. It's got weight, it runs, you have to pay attention to road signs, watch other cars, etc. I'm only saying that there are other cars around that allow you to get a close feel to your engine, suspensions, tires, with no built-in electronics and to get a real appreciation for them. I'm actually not entirely serious here, but I think there's some truth to this. I should also add that I think Ruby is absolutely fucking great if the goal is indeed to get from point A to B and for many other reasons too!
Fourth on Chris Pine's book. Aside from what everybody said, the way he writes isn't intimidating at all, which is very important for beginners, especially when I started. I highly recommend this book.
You're right, I should have titled it message authentication. I am still new with much of this and did not do the most thorough research before posting my problem. I appreciate the clarification!
My first reaction was to down vote you, but after some inflection, there is some truth to what you say from my experience... For instance elements.map{|item| item.value} Or is it elements.map(&amp;:item) Or maybe collect elements.collect do |item| item.value end What does this mean for initialization methods: item = variable || default Why not just write it they way it works item = variable.nil? ? default : variable Sure... one could say there are a million ways for things like this... but have you really been exposed to many other languages. They are all the same in this regard. Sure some are more dogmatic and preach on high about the right way to code, but ruby gives you elegance for how you see things.
Please show us your amazing and completely flawless C code, oh great one.
No, `my_obj.instance_eval(&amp;argless_block)` is an error, try it and see. The author of the article neglected to mention that `instance_eval` actually yields self to the block -- so passing a lambda of arity 0 will result in an error as it will be passed an arg, and lambdas don't like argument mis-matches (procs, however, don't care, so if you replace `lambda { puts foo }` with `proc { puts foo }` it will work without error.
Neat. Tried creating ebooks in Ruby a long time ago using [ruby and hpub](http://rubyredbricks.com/blog/2013/10/02/ruby-and-hpub/), but not caching websites and nothing as clever as this. Enjoy your time off the internet.
This. For starters I've been programming for 20 years and I've forgotten more languages than most programmers ever learn. Ruby as a first language will screw you up for other languages. If you plan to make a career then plan on learning other languages. OTOH it's easy to learn Ruby and be productive and Ruby is a joy to program with. So I guess it really depends on what your goals are. This may sound crazy but I'm beginning to think Swift is a great language to start with. I'm really loving it. It has bits of all the modern programming concepts out there and abstracts you from things like which will slow down your learning. Learning C doesn't really teach you anything special. People think it's a "serious" language that will force you to learn the fundamentals but that's just not true. Modern C is just crappier version of Rust or Swift and operating system and memory management fundamentals are all abstracted by the operating system anyway. C is cool if you want to write a kernel C++ is a pain in the ass Java and C# are great if you want to become a corporate slave Ruby will get you a decent paying job fairly quickly but without discipline you may always be a copy-paste-from-stackoverflow coder Rust and Go likely won't pay your bills Swift will get you a great paying job in an exciting field Python can pay the bills if you also have a biology, math, or geology degree 
JS is hot right now. i met a guy recently who was telling me, "Javascript is going to be the one to rule them all. 2000 years in future, when we're flying to the center of the galaxy at the speed of light, you better bet those spaceships are going to have Javascript". In all seriousness, Javascript's future is looking bright with es6. They took a lot of cues from Coffeescript to be sure, but by es7, it's going to be a lot more attractive. Too bad we'll all still be transpiling for ie6.
Because they want to bypass the limitations of the Heroku free tier without actually paying money.
Perhaps so, especially if they gravitate back towards languages like Java. But if they want to move onto Scala, Swift, Elixir, Python, then I'd feel that Ruby would hold them in much better standing than a Java background. It was a joy to see Swift upon release -- I could almost read it almost flawlessly thanks to the common idioms of Ruby/Scala found throughout. Not to mention how Rails/Sinatra like the web frameworks of other languages have become.
Why certainly! It has `irb` which let's you quickly test ideas, a solid Object Orientated foundation, meta-programming, and functional-ish features such as lambdas and closures.
"Actually I made up the term 'object-oriented', and I can tell you I did not have C++ in mind." -- [Alan Kay](https://en.wikiquote.org/wiki/Alan_Kay)
6 years ago he would be saying "Prototype, scriptalicious, or mootools"
Nah driving manual comes naturally pretty quick. Manual is better for racing (over 'standard' autos). As C is over (say) Ruby because it's stricter and can work at a lower level.
you ask a tricky question. the way I see it, ruby is absolutely awesome at letting you just get off the ground and do something with code. On the other hand, the metaprogramming of ruby is on another level from most languages I've seen, and can be confusing and hard. to take someone else's car analogy... ruby is the automatic transmission car, that let's you drive on two wheels or swap out the car seats while driving at the flick of a dashboard switch. No function is set in stone, and any behaviour of the things you already have can be changed by just loading a plug-in. so yes and no. if you want a good introduction to computer science, and what makes a program tick, ruby will be confusing and require a lot of effort to understand well. if you want to get cracking with programming, and take your time with the theory, ruby is great. especially with the very solid Web frameworks rails or sinatra that lets you create something tangible that can be accessed by a browser with very little more than just following a tutorial. I know some 10ish languages so far, and ruby is definitely my favourite. 
+1 for Chris Pine's book. It's what got me into programming in 2009. Now my sister is asking for it to learn programming herself, with zero prior influence on my side.
If you like podcasts I recommending listening to the Ruby Rogues episode where they talk about Heroku (I think it was http://devchat.tv/ruby-rogues/140-rr-heroku-with-richard-schneeman ). They discuss this "hack" in some details. From what I remember your free Heroku account will got to "sleep mode" if nobody is visiting your website. Then, when the first vistor comes it might take I moment for your service to "wake up". You can avoid this problem by constantly pinging you web app (same as constantly pressing a button on your laptop to prevent it from shutting down). This affects only free Heroku accounts - normal accounts don't go to sleep. Right now Heroku looks the other way, because a relatively small percent of users behaves that way. But if it becomes the standard they might have to add other restrictions.
Bear with me - I'm going to take a very controversial position on /r/ruby, and say "no". **Ruby is a fantastic language to program in**. No, I mean it - it's freaking *amazing*. The syntax is expressive and intuitive, the low-level concepts and primitives in the language are well-chosen and map neatly onto almost any problem-space, it's as flexible as hell and morphs itself nicely to fit whatever task you put it to. That's the problem. Learning it as a first language is like learning to drive in a Tesla or losing your virginity to a supermodel - it's all downhill from there. Any decent programmer should learn *at least* a handful of different languages to a competent standard, and program idiomatically in each. If you learn Ruby then your entire career is going to be one long series of frustrations that those other languages don't let you structure things as flexibly and expressively as ruby. That's a problem, because it will obscure the things those other languages *do* get right, and the concepts and ideas they offer that Ruby doesn't necessarily offer (or at least, doesn't really make obvious or explicit). It will also discourage you from learning other languages unless someone puts a gun to your head, with the result you risk never becoming as good a developer as you could otherwise be, instead turning into a one-trick pony. **Ruby's syntax is unnecessarily comfusing** compared to other languages. That's partly born of its flexibility and power, but also a few bone-headed or just pointless design decisions that increased confusion and cognitive overhead for developers without necessarily any real benefit. Examples: optional brackets around function parameters, {}/do-end for blocks, implied hashes, multiple different types of "anonymous functions", or similar construct (block/Proc/lambda), etc, etc. All these things require more cognitive overhead for the developer to parse the code compared to a more structured, constrained-syntax language like python or javascript or C. Sure it's obvious to *us* experienced devs that this is a function-call and how many parameters are passed to it, but to a learner it's just word-salad: my_func 1, "two", three: "four", five: :six, :seven =&gt; "eight" Come to think of it, *to a learner* why is: my_func "one", two: "three", four: "five" ok, but my_func two: "three", four: "five", "one" a syntax error? Without brackets around function parameter lists, what's the difference to a learner between: my_func_1 myfunc_2 1, 2, 3 and my_func_1 myfunc_2, 1, 2, 3 ? Ruby gets a lot of things right, and it's a truly, wonderfully, amazingly versatile tool. Nevertheless, I would think twice about giving it to a learner for their first experience of programming for the same reason I'd be sketchy about handing power-tools to a toddler for their first experience of woodwork - because it's a Big Boy tool that requires some experience to get right, and *until* you have enough experience to get the benefit of them power-tools only offer a faster, more efficient way for learners to accidentally lop off fingers.
Ruby was the first language I learned in any sort of real depth. It's a fantastic place to start. I hear Python shares a lot in common, so that's a good place to start as well. For a beginner, I HIGHLY recommend the Ruby course from Pragmatic Studio. Not cheap, but it's easily the best thing out there. I also got to meet Mike and Nicole Clark, and they are the nicest, humblest, and most amazing people EVER.
I haven't tried Swift yet, but I'm looking forward to it.
I mean, you are also an inconsiderate opportunist if you litter, grab a fry when no one is looking, or leave places messy. Or you are ruining it for the rest of us.
Curious, what are you doing in this subreddit then? But I guess I go thru other langs reddits myself sometimes. 
Well, I love programming? I'm subbed to many languages, even if I don't actively used them. I enjoy toying with different programming languages all the time, so why not. :)
April 1st... 
I've used a pinger before to demo apps for people. As others have stated must people don't understand the app is sleeping and simply assume something's wrong or broken. Of course I understand this isn't good for business so I usually limit the pinging to a day or less while showcasing the app. However this definitely leaves the door open for opportunists. Hopefully, heroku can offer a better solution for this sort of situation. Such as a 12 hour demo period per app or a more logically tiered pricing system.
Yes, I actually meant Ruby. You can have the car with the ABS and all that, but still have the option to look into it deeply. I was trying to counter his point, but I suppose I didn't do a good job at it.
Great post! In line with how I view iceberg classes -- as in your second example, sure, you've got the "extract method" refactor jam going on, and yes your methods are all under 5 lines, but you've failed to improved the design of the code. In this particular case, you've got a few other choices for where to put the logging code, which I think go beyond the intended scope of your article, but what the hell anyways, right? **You can apply inversion of control on the logging interface**. In other words, pass the responsibility of logging up the chain. The caller of this object must decide to log. This can lead to rather messy application code that has to corral all those dependencies, but has the effect of completely removing the concern of logging altogether (at least from the code in question). Excessive IoC will lead to the need for complex dependency management systems, and bloated `#initialize` methods that accept every service dependency under the sun. Another approach would be pub/sub. **Pub/sub**. Example: include Observable def process_payment amount gateway.authorize_and_charge amount do deliver_cart end changed notify_observers "handling payment: #{amount}" notify_observers "cart delivered: #{id}" end And you would likely want to further change those strings you're emitting to actual objects, e.g. `notify_observers :cart_delivered, self`. I like pub/sub here. We know that logging is likely not an essential aspect of this objects' responsibilities, and yet it's hard to imagine which layer of abstraction ought to manage it. Logging wants to occur right where the event takes place, and not a moment after that.
Not everything that gets posted on April 1st is a joke. I was invited to the new beta pricing and it is indeed limited on the free tier.
I dunno, I don't even think it's inconsiderate. Heroku used the free tier as a way to get people in the door and then eventually paying way more money (such as myself). Just because they don't like it *now* doesn't mean it didn't help them out a huge deal. It's like saying people who buy the cheap "loss leader" deals at Walmart are inconsiderate but ultimately they end up profiting from them in the end.
I've been pretty happy with `sitemap_generator` - it's got a little internal DSL that makes it easy to add pages, it pings Google and Bing, gzips the sitemap file, generally seems solid.
It's more like a free sample at a grocery store. At the store, it would be considered rude to stay at the free sample stand indefinitely eating the samples. Granted, that Heroku does not prevent users from keeping their apps from getting spun down. They are cool like that. Ensuring that your app can not become backgrounded consumes more of the free service Heroku provides, and ultimately costs Heroku money.
Please don't give DHH credit for this. He's just a figurehead. It is my understanding that a large amount of the vision that is now Rails 5 came from Yehuda Katz when he was a core contributor.
The figurehead came up with most of the essential parts of RoR, oh, and RoR too! What did you come up or contribute to RoR?
Is this the 'Shy Tory factor' we hear about with regards to the 'major political party' you were working for?
&gt; If you wanted to use a clutch and switch your own gears you'd learn Java or C/++. Totally disagree with that. All mentioned technologies present as large abstraction over hardware, as ruby does, only in different manner. The only difference imo, is that c/++ and java are kept down in its development by standardization and common rigid-minded communities. BTW, learning ruby as a first language has major side-effect -- learning weak designed technologies (python, for example) will make you vomit, literally. 
&gt; Manual is better for racing Non of the truly professional cars (Formula One, for instance) have a conventional manual gear box, those are more like semi-automatic. How do you rephrase your statement, having that in mind? 
Where do people get all this info on Rails 5? I've searched the web but I couldn't find release date for Rails 5 or any specific info.
hacker as in http://www.catb.org/jargon/html/H/hacker.html
&gt; He extracted Rails from Basecamp, which was great. Thanks DHH. You say that as if he wasn't hired to write Basecamp in the first place. He *wrote* RoR
Well, the way you wrote it sounded sarcastic first, so I wasn't sure the meaning, but going from essential parts of RoR to "he extracted it from rails" sounds like you are implying he didn't write it, just open sourced an existing framework.
I'm not sarcastic. I've been using rails for 6+ years now and I've seen it grow incredibly. In a number of ways it has little to do with what it used to be. Rails changed the face of the world, but objectively, when you look at how it was implemented, it was absolutely horrible. This is of course not surprising: any first release will suck. Rails held together and allowed incredible new prototyping speeds. Rails is a good thing. Yet objectively looking at the ecosystem, its success may only last another few years. This is another conversation. DHH's opinions have caused good ideas to not be merged into Rails core for years. Go back to the core mailing list and read. If Merb had taken off instead of Rails, we may all be using the Datamapper pattern instead of the active record pattern, and the world would be very different. Merb by the way... Spearheaded by Katz.
The idea for TimeScales comes from having had to solve a number of similar problems in different projects. In one case, the application involves commissions computed quarterly, but paid monthly, so in each 3rd quarter, there is a true-up across all 3. It's nice to be able to simply ask whether a month ls the last in its quarter, enumerate the months in the quarter, etc. It's also nice to be able to query the database for time values that fall within a month. AR allows using a range value in a `#where` call and pays attention to whether the ending value is included or excluded. In another project, I needed to deal with bi-weekly periods starting on an unusual day of the week. That is something that time_scales does not yet address, but I hope to have it do so soon. Including other time units is just to make the gem more useful to a wider audience and/or support future use cases of mine, since I'm bothering to write the gem at all.
I see what you're getting at. I think it's not actually an improvement as it stands, but if I take that one step farther, and make each unit constant refer to an instance rather than be a singleton, then that seems like it should be really nice. :) 
The === operator is there to allow the unit to be easily matched by its symbol when a symbol is given as one of the arguments for fetching a frame type.
&gt;Yes, it's called settling Or maybe people have different experiences, perspectives, and tastes than yourself. Just a thought for consideration...
Regarding client_for_poslynx, I guess the main thing I'm looking at is whether there are ways to tidy up code and tests for the NET::... API layers. I'm building off of EventMachine because trying to handle asynchronous APIs without that in Ruby is a major challenge. Unfortunately, EventMachine is also not particularly OOP, so it's hard to wrap code around it without creating some tangles (the EM_Connector layer). Since the usage of the API is mostly synchronous, even though there are important asynchronous things that must be accommodated, I'm using Ruby fibers to wrap a synchronous API, then using "detached" state exceptions to deal with the asynchronous cases. There is an inherent complexity to using fibers in this way that cannot be eliminated. I get the feeling, however, that if I could just figure out a better way of slicing up the responsibilities, then the code and tests for all of that could be made much easier to read and maintain.
&gt; Rails has given yeoman service as a cautionary tale in that respect, and other framework authors have generally at least tried to heed that lesson. Could you please elaborate on this a little? I cannot parse that sentence into anything meaningful.
Because my response was not for the extreme racing of Formula One (there are many other more amateur types of racing available for the non professional). Maybe Rally Driving (amateur level) would be a better analogy, or track day cars. If the analogy of my theory was applied to a Formula One then the programming would get done at a much lower level such as assembly langauge or a bespoke language for dealing with performance on hardware clusters. But what I meant was, with driving manual you get a feel of what gear you need to be in for a given situation, which gets you understanding the relationship between the mechanical systems, analogus to how in Java you need to define your variable type and not just declare it assuming the lanaguage will treat it as you expect. Of course thats a basic example, the difference between C and Ruby are similar to driving a manual vs auto, further a double clutched auto you get on the more modern cars or formula one cars would be overkill in my basic example and only you took it to the extreme, OP asked about Ruby as a beginner language. I did say 'conventional auto' (as opposed to 'also the dsg' types too) vs manual.
&gt; long term it can be a liability. True. But not really the problem people make it out to be, IMHO. If you have an app or site that "Just Works", why upgrade? I'm running several rails 3 and one rails 2 apps, still. I just [apply a security patch](http://weblog.rubyonrails.org/2013/2/24/maintenance-policy-for-ruby-on-rails/) a few times per year and that's that. And quite some of the sites I delivered to customers are probably still running the old rails version. Why fix something that ain't broken? The other category is the sites that you actively maintain and keep developing on. For these, you can *choose* to upgrade: but here too: you could develop a proper app in Rails 3, so why upgrade to 4? This is a choice. Too many people choose to follow latest versions, upgrade every few weeks and then bitch about having to upgrade every few weeks. And whine about how gems become incomatible and so on. But keep forgetting that it them who *chose* to follow latests versions. Edit: added link to maintenance policy
I agree with you on the UX, and I'd add that requiring multiple client platforms (mobile, desktop, external consumers of a public API, etc.) also plays a big role in defining if it's best to go with a SPA or a more traditional approach. When multiple clients are needed, isolating the API prevents duplication and, IMO, makes for a much more concise architecture.
Author of Kiba here. If you have any questions, let me know and I'll do my best (working on a little coding guide for Kiba at the moment). Also, no matter if you know what ETL is or not, if you want to process and move data around, I'll be blogging more about that [here](http://thibautbarrere.com), subscribe there for updates.
The group_by enumerable is interesting, I did not know about that one.
You are doing it wrong. We learned after Rails 2 that monolithic applications are cancerous, growing and growing until it kills any developer who works in it. Build small modular things. Build them using SOA, and documented interfaces. Build them fast and furious and throw them away when they are obsolete. Building websites for me has become more like building presentations thanks to Rails. I knock out an application a week and when I realize it could have been done better, I trash the whole thing and start over (it amazes me how many developers forget how to use Copy-And-Paste). Need feature X from old-app Y? Copy and Paste - done. Programming is writing, not architecture. Authors rewrite chapters all the time. If it feels like you are moving mountains then it's already too late, and you probably have a big-ass mountain to throw away. Good Luck!
Are you arguing for micro services or even just services? That's all well and good if you have the luxury of knowing exactly when and where the seams of your code will be and the time to build separate services with a proper API between the two. More often than not, your business has to make money, so you end up having to start with a larger codebase. Unless you're arguing that you don't need a large codebase to make money. I guess I just don't know what you mean. Can you help me understand?
I feel like SQL does this better and faster than Ruby ever will. Would you consider contributing to MariaDB? I've worked on large projects where row-by-row Ruby data processing took hours, dropped in a few lines of SQL (literally a few), replacing hundreds of lines of Ruby. I've turned 12 hours into less than 5 minutes. I love Ruby but SQL is the tool I use for ETL, especially LOAD DATA INFILE.
where did you get stuck?
Still bad analogy. Here's mine. Coding in ruby -- is like driving Bentley in the city, you can enjoy every last car industry achievements, but you can't go fast for obvious reason. Coding in C/++ -- is like driving steam locomotive, you have to learn the purpose of every last switch and arm, you have to toss a coil, keep an eye out on water level and steam temperature. If you miss any of that, you get a boiler blast off, but if you don't you can go really fast. 
You can definitely use LOAD DATA INFILE or raw SQL in a Kiba ETL job! The idea behind Kiba is not to do everything in Ruby, but to use Ruby as a "master of ceremony", which can delegate part of the processing to relevant tools (e.g. embulk, mysql stream source etc etc) when you need to optimize your job processing time. In an upcoming article, I'll likely show how to use a staging table in which you bulk load the processed data, then use a "merge" statement to upsert the data from the staging table to the final table.
Forget the "yeoman service" phrase. It's just a confusing way of saying "dutiful service" in this case. I think he's saying that despite Rails _best efforts_ to be both simple and customizable, easy to use for simple cases and configurable to be used for nearly any case -- it hasn't neccesarily succeeded, and can be a pain for both simple and less conventional cases. It's a cautionary tale, and the lesson we should learn is that software is hard. I don't neccesarily agree that the lesson is simply "don't let one person be the feature/architecture dictator", as they imply. If anything, design by committee can makes the challenge even harder. And I think Rails sometimes exhibits some design by committee issues too -- it's not really true that dhh controls all Rails development or architectural decisions, although he does have the final word when he wants it. 
Well, on the rails 4 upgrade I ended up changing roughly 100k lines of code myself. It's just a really large app. 
I think you're assuming a single database environment in a pure data load. That can be efficiently handled in a bulk manner but it doesn't address heterogeneous environments or even simple business logic. LOAD DATA INFILE is a final step in a single node of an ETL process.
SOA Is not a cure all. It comes with costs. Heavy costs in terms of manpower and coordination. If you're at a large company, that's great. But there are tradeoffs to every architecture. Monoliths are easier to maintain (generalization to be sure) for a small team. Especially when you have several long running apps. I rarely agree with dhh, but on his monolith discussion at rails conf he made some great points about how monoliths aren't a bad thing. Getting into services means a lot of moving parts. And if you have to make changes to one you end up making changes to more than one app at times. It can be frustrating when you think you addressed all of the apps using that service only to find in production that you've missed an obscure corner nobody remembered. I think it's disingenuous to trivialize a problem like that. It's easy to criticize a situation from the outside, but when you're in the trenches a short blithe remark like that shows little consideration for the challenges being faced. We don't all get to choose how things are built or how they are built or what we work on. Sorry for the rant. 
i am getting stuck while trying to set up a postgresql database and make it show a webpage, everything else i can do
Rubymine, vim, emacs, sublime text 3.. Take your pick. Ruby has irb and a gem called pry. In fact you may want to look up a talk called repl-driven development in pry.
i have set up and configured postfix and cloned the application 'QAmail' if you can make a clearer command guide then the person on the bitbucket page i will reward you :)
which operating system are you using? did you successfully manage to install postgres?
i am using ubuntu 14.04, yes i sucesfully installed everything (ruby, rails, postgre, the application itself, postfix maildir) i just need to create the data base and make it appear on a webpage
what is the output of running ``` rake db:create ``` in the git repo?
Did you run 'bundle install' in your got repo top directory?
yes but i do get this error /home/ubuntu/.rvm/rubies/ruby-2.2.1/bin/ruby -r ./siteconf20150424-12410-1siqbpv.rb extconf.rb checking for pg_config... yes Using config values from /usr/bin/pg_config You need to install postgresql-server-dev-X.Y for building a server-side extension or libpq-dev for building a client-side application. You need to install postgresql-server-dev-X.Y for building a server-side extension or libpq-dev for building a client-side application. checking for libpq-fe.h... no Can't find the 'libpq-fe.h header *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers. Check the mkmf.log file for more details. You may need configuration options. Provided configuration options: --with-opt-dir --without-opt-dir --with-opt-include --without-opt-include=${opt-dir}/include --with-opt-lib --without-opt-lib=${opt-dir}/lib --with-make-prog --without-make-prog --srcdir=. --curdir --ruby=/home/ubuntu/.rvm/rubies/ruby-2.2.1/bin/$(RUBY_BASE_NAME) --with-pg --without-pg --enable-windows-cross --disable-windows-cross --with-pg-config --without-pg-config --with-pg_config --without-pg_config --with-pg-dir --without-pg-dir --with-pg-include --without-pg-include=${pg-dir}/include --with-pg-lib --without-pg-lib=${pg-dir}/lib extconf failed, exit code 1 Gem files will remain installed in /home/ubuntu/.rvm/gems/ruby-2.2.1/gems/pg-0.18.1 for inspection. Results logged to /home/ubuntu/.rvm/gems/ruby-2.2.1/extensions/x86_64-linux/2.2.0/pg-0.18.1/gem_make.out An error occurred while installing pg (0.18.1), and Bundler cannot continue. Make sure that `gem install pg -v '0.18.1'` succeeds before bundling. 
say no if you cant be bothered but could you try yourself on a free ubuntu 14.04 instance. if you can do it, put together a step by step and ill pay you for your time?
Your analogy is not even on the same analogy of auto vs manual, comparing a bentley with a steam locomotive is different. But I do get your analogy.
that guide would be the most helpful thing in the world but i will keep going at it trying myself, i will pay you for the time you spent on the guide kind sir :)
thanks for the clear explanation and time, the bundle was sucessful but i have run into another problem, it seems to be with the database users now output when i run rake db:create ubuntu@ip-172-31-33-52:/home/qamail/qamail$ rake db:create Creating database... rake aborted! PG::ConnectionBad: FATAL: password authentication failed for user "db_user" 
I haven't tried Volt, but at least their promise of writing logic (say validations) once in Ruby and having access to it client side seems fairly promising. It will be interesting how they lay it out. Just spitballing I'd like to see some "unobtrusive Ruby" for forms, with the option to extend or overwrite on the backend. I think that would save some time.
You need to write the username and password of the `postgres` user in `settings.yml` You already have a user postgres. You might need to set him a password. `sudo -u postgres psql -c "ALTER USER postgres PASSWORD 'postgres';"` NOTE: your postgresql might not be configured for user/pass authentication. It is probably using peer auth. Google that.
Sublime is an excellent all-purpose editor which handles both Ruby and Python admirably.
Thank you for the feedback, I've updated the Blog with this solution
I like the principles she's getting at, but don't really agree with some of the conclusions TBH. The if_true/if_false stuff seems like kind of a useless exercise in triviality, and while the whole 'nothing is something' idea is super important, the null object pattern as she presents it seems like it could lead to a ton of weird cruft boilerplate (`GuaranteedAnimal` is a clunky API, to say the least) I'm more a fan of the [Option type](http://en.wikipedia.org/wiki/Option_type) from the functional domain - it goes by different names in other languages (often `Some`/`None` or `Just`/`Nothing`), but its a more generic way of dealing with the same issue without repeating it for every object in your domain. I've used the [possibly](https://github.com/rap1ds/ruby-possibly) gem in a Ruby project, which lets you do like irb(main):002:0&gt; Maybe(4).map { |x| x * 2 } =&gt; #&lt;Maybe::Some @value=8&gt; irb(main):003:0&gt; Maybe(nil).map { |x| x * 2 } =&gt; #&lt;Maybe::None&gt; It also supports method chaining like Maybe(User.find_by_id("123")).username.downcase.or_else { "N/A" } One may or may not like the way that particular gem works, but I think the idea is much more solid / cleaner in principle.
GuarnateedAnimal is just an example for wrapping a preexisting API with null object pattern, not a serious suggestion for OO design. 
I get it - the point I was trying to make is that I prefer a single generic pattern rather than defining/dropping in different null objects in a bunch of places
If you think about how you can use map/filter/detect etc on collections chained together you get a good feel for what APIs without conditionals feel like. Really Importantly, composing them into pipelines of data transformation dynamically (think scopes being chained based on params in a rails controller) makes life easier. If_true etc is just a thought excercise on how removing the If statement would feel, much as iterators/etc have changed the need for a For loop. 
FWIW, RMagick lives on at https://github.com/gemhome/rmagick
Wow, I hadn't heard about that fork. That's reassuring. Thanks for pointing it out. 
All your points about upgrading are good imput when you make a balanced decision about upgrading, keeping with the latest version and so on. But they, by no means, force you to follow along. They also don't force you to keep at the very latest version always (as opposed to staying 6 months behind always, or choosing to upgrade only at mayor releases). There is a reason people are still running XP, dragging COBOL apps along and so on: upgrading is expensive. And there are many good reasons to stay with a version if that "just works". But quite often, the balance will tip to "keeping with the latests versions of Rails". And in that case: go for it, but know that you'll have to live with the downsides of your decision.
That was very well presented, thanks for sharing! It looks like there's also a module-based solution being discussed here: https://gist.github.com/joshsz/1ccb901e6a632ea6d86c Continuing on Sandi's example, let's say a request comes in for a `RandomScreamingEchoHouse`, where `Screaming` means `parts.map(&amp;:upcase)`. Would it make sense to create `ScreamingFormatter` and a `MultipleFormatter` and use it like this: House.new(orderer: RandomOrder.new, formatter: MultipleFormatter.new(EchoFormatter.new, ScreamingFormatter.new) Or should the base `House` be split even further, e.g: House.new(orderer: RandomOrder.new, formatter: EchoFormatter.new, transformer: ScreamingTransformer.new) 
She just did a version of this talk on Thursday at RailsConf with a new ending. She absolutely killed it. I was in the middle of the talk, got a point she was making about finding and naming variations, and had a finally understood a design problem that's been nagging me for months. Confreaks hasn't cut an individual video yet, but you can see it in the livestream [starting at 7:34:30](https://youtu.be/LdWMcs9EEOE?t=7h34m30s). And here's [her slides](https://speakerdeck.com/skmetz/nothing-is-something-railsconf). Shameless plug: here's [my talk](https://www.youtube.com/watch?v=pjqXMqHzIZs) from earlier in the day. A lot of my experimentation and a big chunk of my presentation was inspired by Sandi's talk [The Magic Tricks of Testing](https://www.youtube.com/watch?v=URSWYvyc42M).
I think the if_true/if_false is about removing special forms from the language, making many forms of higher-order and metaprogramming easier/possible. I guess if you spend enough time in a language with very few special forms it never seems normal to have so many around.
You mention the template pattern and explain the difference, but where's the example? I think it would be important for those that don't have a strong understanding of these patterns to compare the two.
Taking over a new app once where the old migrations didn't quite work, I used the trick of making a new starting point by copying schema.rb into a new migration. I neglected to remove the `:force =&gt; true` options from the `create_table` calls, however. Oops!
Hey, thanks for checking it out! In the intro (the first paragraph) I link to one of my blog posts that I've written about the TMP. But, I guess most of the people will miss it so I added the link again after the paragraph about the TMP. 
Thanks!!!
Why does she combine the composition of objects with the null object pattern? 
Maybe to replace your bash scripts with Ruby? Like, take some script you run a lot and see what it takes to re-write it in Ruby. 
Just forget about Rails (lucky you if you haven't picked it up in the first place) and you have it. Regular O'Reilly Ruby books, I believe the latest edition is titled "Ruby 2.0" or something-something but the 1.9 ones will do just fine too. 
Try Cloud9 then. Heh.. "The version of Nitrous you are currently using will be sunset on July 1st, 2015." I guess it's time to try C9 for me as well.
There is one on Amazon called "Practical Ruby for System Administration"
From personal direct experience of using the author's skills, he is extremely well versed in the Ruby idiom and has wide full stack experience to knowledgely support this focussed subject. Defintely recommend. p.s. His humourous tellings, observations and asides lightens the load...
Don't have time to make a pull request right now, but I'm surprised there's no mention of LRUG (London Ruby User Group) on that list! 
My favorite is Chocolate editor on Mac. It's nice for small projects. Typing cmd+R; Call terminal.app and run a script you are coding.
I love this. It was posted on Hacker News and someone commented with [this](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition), which is really funny. I recommend reading some of the issues.
One of the best ruby articles Ive ever read in my life. 
Just read this. Its getting up there in age now (2007), so some of the content is a bit aged, but still a good read to get an idea of how a oo language like ruby can benefit a sysadmin.
This is totally unusable on an iPhone... Just FYI
Nitrous is garbage, they used to be Action.io, which was better, then they rebranded everything, got greedy, and it's just been a mess since then. I've also had files go missing, but I wouldn't necessarily be quick to blame Nitrous before Git.
Hello, no rush - whenever you have time ;-) Great to hear there's a Ruby group in London. Cheers.
Alrighty. So, this is the array we're selecting from: [ ['Fizz', -&gt;(i){ i % 3 == 0 }], ['Buzz', -&gt;(i){ i % 5 == 0 }], ['Zazz', -&gt;(i){ i &lt; 10 }] ] When you perform the select on this array like this: array.select { |first_value, second_value| ... } And each element in that array is an array itself, ruby will automagically assign the first, and second values of each array to first_value &amp; second_value respectively. As you probably know, the [Array#select](http://ruby-doc.org/core-2.2.0/Array.html#method-i-select) method runs the given block per element of the array, and when it completes it returns a 'filtered' array of all elements that returned a 'truthy' value when run against that block. So in this case: parts = triggers.select{ |(_, predicate)| predicate.call(i) } The value of `_` would be 'Fizz' or 'Buzz' or 'Zazz'; the first value in inner array elements. The value of `predicate` would be the anonymous function; the second value in inner array elements. Which means the return value of our anonymous functions will be used to determine whether or not a 'trigger' is selected. So, when `i = 3`, the return value of the select would be: [ ['Fizz', -&gt;(i){ i % 3 == 0 }], ['Zazz', -&gt;(i){ i &lt; 10 }] ] So when we call the following on the result: parts.map(&amp;:first).join We are iterating through the array, calling the `.first` function on each element (which would return something like this: `['Fizz', 'Zazz']`), and then calling `.join`, which when called on an array of strings will work out to be something like: `'FizzZazz'` I hope my explanation made sense. To **tl;dr** it: The select is calling each anonymous function, to filter the array based on the return value of those anonymous functions, given `i`. The map then grabs the string value ('Fizz', etc.) for each of the returned values (In this case, something like `['Fizz', -&gt;(i){ ... }]`), and joins the resulting strings together.
Wow, the new free tier is limited to 2 hours per day. I don't think I could honestly recommend nitrous to anyone learning Ruby/rails any longer. Cloud9 it it then. 
Ask a better question and I'll be glad to help, as for now I have no idea what you want. Do you want me to write some code? Point you to some material on recursion? Teach you what a factorial is? I genuinely don't know.
sorry for the confusion. Please see my edit. I want to know if it is possible to store results in an array within a recursive method
rake is not rails specific. The example here is a rails one but the principle is universal.
While technically fine due to the license, have you talked to anybody on the core team about this? 
Flew threw codecademy for basic syntax, Michael Hartl's ROR tutorial (but not a ton of ruby there).
Thanks! This is great!!
Metaprogramming nice
I'd say the #1 biggest thing to know about Ruby is how blocks work. They're used constantly and I've seen a few people stumble on them. A block is a chunk of code passed to an argument to a method (a function that belongs to an object is called a method, and because everything in Ruby is an object, there are no regular functions, *only* methods). Wherever the method uses the word `yield`, the code from the block is injected. Ruby uses this, just as one example, to iterate over something, replacing `for` loops completely (it is a taboo to use a `for` loop in Ruby). ['Apollo', 'Starbuck', 'Helo', 'Hot Dog'].each do |pilot| print(pilot.reverse + ", ") end will output `ollopA, kcubratS, goD toH, `. You can use this when defining your own methods. def speak print("Hello. ") yield print("Goodbye. ") end speak do print("What's up? ") end output: `Hello. What's up? Goodbye.` PM me if you want and I can share my notes on Ruby.
Great! Thank you. Recursion still hurts my brain haha I just tried it on another problem just to reinforce the idea: def fib(num) if num == 0 [0] elsif num == 1 [0, 1] else fib_next = fib(num - 1) fib_next &lt;&lt; fib_next[-1] + fib_next[-2] fib_next end end 
Generally, I would advise on not returning a different type than you pass as an argument. It's just plain bad style. Also, the factorial_recursion function is superfluous. Just use your factorial function where you need to collect sets from arbitrary input – it makes it that much more reusable and easier to grasp. def factorial(namba) return 1 if namba == 0 || namba == 1 namba * factorial(namba - 1) end n = 10 set = [] for i in n set &lt;&lt; factorial(i) end
So, what's the issue? You want it to output the value of `array.inject(:+)` to terminal, when you run `ruby name_of_file.rb`? All you should have to do is change the last line to `puts array.inject(:+)` Correct me if I'm wrong, but AFAIK it shouldn't output to terminal without the use of `puts`.
Well, not quite. You don't pass an object in, you pass chunks of code in. It doesn't save you from inheriting stuff from classes, it saves you from writing loops and the like. Say that you have a list/array: people = ["George", "Jerry", "Elaine", "Kramer"] And you want to read it out. In Python, you'd probably write for person in people: print(person) In JavaScript, you'd write for(var i=0; i&lt;people.length; i++) { console.log(people[i]); } In Ruby, you'd write people.each do |person| print person end The stuff between `do` and `end` is the block. `each` is a special method that takes a block, but it's not the only one; *lots* of methods take blocks. File.open('diary.txt','w') do |d| d.print("Dear Diary. Today I saw a goat...") print("My diary is #{d.size} bytes long.") end When you open a file, you pass a block of things to do with that file. The `|d|` specified at the top is the 'block variable' which you name, and which represents something within the block (unique depending on the method). Or if you want to turn an array into a new array: numbers = [2, 4, 6, 8] numbers.map! do |num| num*10 end `numbers` is now the array `[20, 40, 60, 80]`. It's just being able to pass a chunk of code around as the argument to a method, which comes in handy a lot. It's something that's simple but unusual and probably the biggest thing people new to Ruby find weird.
Cool, you should check out [antelope](https://GitHub.com/medcat/antelope), which is like a bison port to ruby.
Yes, I feel recursion should be applied sparingly. I think I've only used recursion once in the past 3-5 years. I would challenge you to write your factorial method (say, returning only a number) without using recursion!
I haven't, do you think I should have? I mean, I said that it's taken from ActiveSupport (although I had to change a lot of things), so I gave the credit. I think that core members want to keep everything inside of ActiveSupport, so I'm not sure what would I talk to them about. The reason why I didn't just submit a PR to ActiveSupport attempting to isolate just this feature was (a) I don't want to have ActiveSupport as dependency, and (b) I don't like how magically ActiveSupport::Duration is implemented; `1.day.instance_of?(Fixum)` equals to true, beause that method is [specifically overriden](https://github.com/rails/rails/blob/master/activesupport/lib/active_support/duration.rb#L36-L43), which makes debugging hard.
Thanks for the pointer, added the library on github!
It does, thank you. I wonder if there is any kind of middle ground (and very much suspect that Rails may just be that middle ground if there's ever been any). In the meantime, let the architecture pendulum swing :)
What do you mean exactly saying "explicit"? Could you please show couple examples on both Python and Ruby, where one is "explicit" and other is not?
ruby noob here, coming from python, I always find myself having trouble finding out where an identifier comes from when reading code since often a name is not qualified, and a *require* can "import" any names into the global namespace. Do experience ruby users have any tips about this problem?
&gt; but not a ton of ruby there I'm not sure exactly what your referring to here, but I think you'll find that virtually all of Rails is just plane old ruby. It probably doesn't look like it, but that is the power of ruby's metaprogramming and dsl construction capabilities at play. e.g. things you may think are some sort of special config syntax like the routes file, or the Gemfile, are actually just plain old ruby constructed into a dsl. 
This is great. Good to see! I'd be curious to know how many Rubyists actually encountered FizzBuzz in an interview. I'm ramping up to be able to know this for any interviews I might have, so seeing several different ways to do this is neat. Now I just have to work on understanding the principals behind them.
All procs and lambdas are anonymous functions. An anonymous function isn't a function that isn't referenced by a variable, it's a function without an identifier.
It's been interesting to see the SPAs that are frontend first - https://github.com/osmlab/to-fix / http://osmlab.github.io/to-fix/#/task/unconnected_major for example gets it right and is compact enough to be hosted... on github(!) The backend server is a different story - almost completely underwhelming - https://github.com/osmlab/to-fix-backend/blob/master/index.js The thing that is wonderful is how neatly composed this is - when you want to go edit; it takes you to an editing component at a different URL with all of the params injected. When you want to work with the mapping layer - well, that's a component hosted almost entirely elsewhere. 
Compact enough to be hosted on Github? The JS alone is 1.6MB gzipped, 6.1MB total and Github Pages lets you host anything you want. Not sure what you mean by that statement.
I'm not sure I understand the problem, do you have some example code that illustrates it?
In my anecdotal experience, turbolinks has had issues with Fwd and Back buttons too. I helped a Rails newbie debug their first Rails app that was broken because of turbolinks. Not trying to hate. It's just a little weird, that's all. 
I'm glad it's not the new hotness anymore too. It's dependable and I've got almost a decade of experience with it now. 90% of these SPA frameworks will be gone and forgotten in a few years.
I don't know about DHH, but I think there's something flawed about a webpage that is basically a &lt;script&gt; tag. There's a simple beauty and logic in simple html that you enhance with css and js. It also happens to be semantic. 
I can't speak to the veracity of that, but it sounds very likely because it answers a question I've had: Why are Rails's new features so banal (unified queuing API, moar Turbolinks, etc.) Why isn't it focusing on a great API story, something like Grape, that would keep Rails relevant for mobile apps, SPA's, as well as ajax heavy HTML pages? At this point I've pretty much given up on Rails for web *applications* of any complexity. Just give me Grape + ActiveRecord running on Rack, and I'll write a Web client for it. Rails could totally go that direction, but I suspect you're right that it's founder is too defensive to embrace it.
 User interactions can happen instantly and handle the server interaction in the background I agree that the quick interaction is pretty nice. The thing that worries me is error handling. User clicks delete button, row disappears, server errors out, now we need to restore the row. But maybe I'm making it more of a big deal than it actually is. I have had good results with a SPA for a complex admin page for an app; only reloading parts I needed saved lots of large and expensive requests. Overall a much better experience.
I've suspected that one motivator is that there are a lot more js devs than back-end ones.
One of these days I'll write up a decent README and wiki...
lol
&gt; Complex state and cache held both client- and server-side leads to CAP theorem issues typical to distributed software. You have the problem whether it's a SPA or not and I don't find that it's any worse in SPAs.
Well, it's difficult to say. It's relatively new, but I would recommend [Roda](http://roda.jeremyevans.net/index.html). The core is minimal (but featureful) so you get close to now overhead. And when you want something more advanced, you can just require those features from the framework via [plugins](http://roda.jeremyevans.net/documentation.html#plugins), which have you covered in some pretty advanced use cases. So, you get the best of both worlds, small core that you can start out with, and progressively you can require more things as your needs advance.
&gt; The thing that worries me is error handling. User clicks delete button, row disappears, server errors out, now we need to restore the row. Meteor does this automatically. That is, it assumes the delete will go through, removes the row, and if the delete fails on the server the row is added back. Still a debatable user experience, but my point it is that the rare but hard to think about aspect can and should be handled by the framework.
Meteor uses the same JS code in both server and browser. My favorite Meteor selling point. I agree that with a Ruby back end, this is a problem.
&gt; User clicks delete button, row disappears, server errors out, now we need to restore the row. This is where I only remove the row once it's confirmed to be gone. While having to wait for a response, using a spinner or loading bar sucks, it's better than something disappearing and re-appearing.
Mildly off-topic, but... how was the edX course? Did you find it difficult? What was your prior programming background? How much time did you devote to it each week? 
I don't think he has explained exactly why he dislikes them. Could be a good laundry list. I assume that JavaScript applications have problems that stem from breaking with the HTML standard that DHH prefers. The HTML standard likely considered that JavaScript should not be used for more than 10% of a site's needs. Basically JavaScript should be used for scripting the site and not much more. With the HTML standard you could keep the interface simpler and more textual, which plays well with server-side generation of the HTML. With the HTML standard you would have a truer distributed system on which neither the client nor the server would have too much "global" state to deal with, except for the state of the database and caches. If we forfeit the HTML standard, we start to go in the direction of client-server applications that can be more problematic to deal with and by creating a new kind of reality on the browser with JavaScript one would also be increasing the maintenance costs. So yes, DHH is likely going to defend the HTML standard to the end of his days. The JavaScript standard is a bit chaotic nowadays. People want to code entire games in JavaScript nowadays as the browsers have been dropping the support for plugins. So the JavaScript standard will continue to grow in importance. But it will likely never fully replace the HTML standard that will be important to host those JavaScript applications on the bigger sites, blogs, etc.
I have only played with reel+celluloid a bit, but I think celluloid is the way to go in ruby nowadays. JMO.
Another issue to think about is that of security. You have to make sure every endpoint you expose to the outside world checks it's inputs for malicious data. Add data races to an already complex concurrency situation and you end up with a security disaster.
You can probably look into Ruby Koans and Exercism problems, they use testing extensively and it's worth looking into how they implement it.
Good call with Exercism; also check out www.codingame.com!
I completely agree with your logic here, as well as /u/mrinterweb answer. I currently work on a web app that a large part is viewed on janky 3G browsers with terrible network coverage. SPAs would cause this to be an awful experience. That being said, I think the place we are going is SPAs. We are at a weird time where now that people are getting used to the internet (I'm referring to the older generation of people here, but internet babies apply to this theory as well) we are missing on a huge detail of instantaneous feedback that is provided from SPA's, and many MV* frameworks. As internet speed is always increasing, people are going to expect that internet interaction speeds to continue to decrease as speeds increase. Even the leanest server applications are going to lose out on this ability because they won't be able to have the speed of a client side application. Progressive enhancement is great. It will always be there. But I believe we are going to get to a point where the lowest enhancement is dealing with a SPA, or some form of a full client side app.
Definitely encouraging. I'll be curious to see how they implement it. Grape is first-in-class, especially with parameter handling. Hopefully Rails can pull in some of those ideas.
I started looking at making that change, and the reasoning broke down. The only reason the methods exist on the base class is as documentation for what methods the child classes should have. They could be removed, and have no effect on the functionality (just make the code harder to maintain). Converting the base class methods into delegators, then doesn't seem to add anything helpful.
I saw a couple of talks at a frontend conference recently, a aside from one guy, who talked about Ember, they where all about making a simple page, something that doesn't break without js, what you can do with the first handshake, how the web looks on a mobile in reality and other topics that basically all said: SPA's are not worth it.
It's already released. https://github.com/rails-api/rails-api It's just that it is getting folded into Rails proper with Rails 5. Here's a performance comparison between Rails::API and Grape. http://blog.backupify.com/2013/09/30/a-framework-comparison-of-grape-vs-railsapi-part-1-performance/ Seems useful if you're doing an API-intensive app but still need other Rails features too.
[Citation Needed] for practically everything.
I do not understand framework dedicated only to API. How does it connect to the existing DB/business logic? What use is there for an API disconnected from the business logic?
Sounds like a reasonable coding style, I've just never heard of it, which defeats the purpose if the intention is to be intuitive. Either way I plan on incorporating the idea into my code and see how it looks in practice.
The thing is, a database ORM isn't part of a web framework. It's just a library that you use for interacting with the database. You can still use ActiveRecord in Roda, you just need to interface with it directly. And vice versa, you can use Rails with another ORM which isn't ActiveRecord, for example Sequel. Interfacing with ORMs directly is still very simple, so you don't lose much of the convenience that you have in Rails, because the ORM gem itself is still doing most of the work. It also took me time to realize that an ORM and a web framework are two separate things.
http://ruby-doc.com/docs/ProgrammingRuby/html/taint.html#S1 http://stackoverflow.com/questions/6074915/ruby-creating-a-sandboxed-eval
So, getting no/partial data is considered to be awful but getting no/partial HTML/CSS isn't? With an SPA you're transferring a lot less data, if anything it should make a 3G connection better.
what the heck, if i wanted to post the whole code, i have to indent Every line, thats craycray
http://guides.rubyonrails.org/form_helpers.html#making-select-boxes-with-ease
yeah, I guess I always look at intuition as expecting something to behave a certain way based on previous experience around similar things. Maybe that's a fairly common practice and I've just never noticed.
Very handy, thanks!
https://github.com/c42/secure 
Hey! I'm the author of the article! Really cool to find it on Reddit, and also that it's been useful to someone :)
I usually stick a "processing" class on the element, that, depending on the UX language, dims, fades, or adds an animated (moving stripes) background to indicate something is being done. When its finished, usually I either remove the bar from the dom, or flash it yellow or whatever
First thing that comes into my mind is that I wanna be able to write servers and give them to my friends. My friends use Windows and have no idea what Ruby is. I want to make an exe for them. What is out there to this? "Ocra". Ok, but will it work if I add in more stuff? Like a gui? The more complicated is your code, the less the chances it will. There is an alternative, "Travelling Ruby" but it presently needs a Linux machine to generate a Windows executable... and I am not even sure it will work, it's a new project, and it's not yet that big or popular..... This is where frustrations start to grow when using Ruby, a language that I love that was supposed to be fun. Well the language itself is fun. But what you may have to go through to develop a real word application (except the typical Rails web app.. ) may prove itself not fun anymore. This is just the beginning of it... Continuing from the idea of wanting to have an easy to run double clickable executable for your friends... .. going down this road: "hey but I could use JRuby! Problem solved! They just need a Java VM which is reasonably common! Cool! Except your TK GUI code is not good anymore because it's a library using C extensions which is not supported by JRuby. So, "good morning, hey wasn't you supposed to finish last night ? What went wrong with your cute funny little client-server rubie thing, dear?" Oh! You're now studying Swing (most used Java GUI library) the Swing EDT which is the Event Dispatch Thread which is the thread that you have to be sure to be on when you are executing non-blocking GUI stuff, in Swing. Wait a second but, as in the article above, we can see that socket have a blocking behavior so hmm I'm seeing we could be up for a total refactoring if we want them to play good with Swing..! Oh, and you also notice that "a SwingWorker would be more appropriate than a thread". ..... Welcome to the point where your code becomes a real hybrid. By this point you will find yourself in a cold land where the examples are rare and most of the times do not fit what you actually want to do, or you only get to see one way to do it, which breaks that Ruby flexibility feeling we really used too, and start making you feeling like "hey this is very fragile, don't change this line, it's the only way it will work". And again you will have no official big community to go to and nowhere to go to look at and see how everything is beautiful and simple and flexible and fun, anymore. Ruby is not Ruby anymore! Well the syntax could still be, but all the other benefits you are used to, are totally lost. At this point you can see yourself as a solitary person looking for very rare things no one is really interested in looking for, or should I say "not yet but hopefully they will be" ? But the present is that by now you either go and ask for your very rare things to Java people or you go ask Ruby people. And both of them could only help you with one side of it, leaving to you the idea of making a solid thing out of it. JRuby is not a community thing, at least not yet.. So... at some point that moment arrive. It arrives that moment when you start asking yourself: maybe it would all been nicer if I started all this in Java already? Plenty of examples and good practice to follow that everyone is using everyday....... And you start feeling shivers when thinking to have to wave your hand at Ruby to say bye. But I don't want to! Oh but with Java you will also be able to do Android apps and do 3D things / games you never could with Ruby! ENDLINE: Matz Ruby/JRuby/Any other Ruby implementation, do something before it's too late!!!!! 
Curious. Do you have any articles on this? I'd love to read more about it. While I agree with the concept that it would require less work due to not having to reinitiate several requests, I wonder how it works in theory (especially with African phones). I wish Google had a better answer for our analytics besides "not set", since it seems to be the largest category for us. My other fear is just the non-javascript user in general. We still do ~2% in IE7 or less and ~12% in IE8 or less. While browser doesn't specify that they aren't using javascript or not, I always tend to sway on the "javascript is too slow or just doesn't work" side.
It's been a while since I've read any on it but in a nutshell: Using a manifest you can make everything but your data persist on the client. From that point on your only network traffic is ajax calls that return json. So having a flaky connection means the ajax call fails and the app can detect and deal with it. Contrast that with something that get's it's HTML but no javascript or CSS downloaded...
A good reminder that we should be moving away from executables that "just work".
so in the array: 1 2 3 4 5 6 7 8 **6** is the third greatest number. In the array: 1 9 6 3 7 2 8 **7** is the third greatest Look at the example given: puts( 'third_greatest([5, 3, 7]) == 3: ' + (third_greatest([5, 3, 7]) == 3).to_s ) puts( 'third_greatest([5, 3, 7, 4]) == 4: ' + (third_greatest([5, 3, 7, 4]) == 4).to_s ) puts( 'third_greatest([2, 3, 7, 4]) == 3: ' + (third_greatest([2, 3, 7, 4]) == 3).to_s ) First Array: 3 5 7 = 3 Second: 3 4 5 7 = 4 Third: 2 3 4 7 = 3 
&gt; I thought by "third greatest," they meant third largest number in the array. I don't understand why you would doubt this interpretation.
It spawns a new process and uses kernel-level protection mechanisms. So depending on how the game is implemented, this gem might not be fast enough. Also, I'm a bit wary of $SAFE. The concept itself just screams for something going wrong somewhere. I remember all the Perl exploits w.r.t. handling tainted strings. It may be theoretically sound, but actually making a secure implementation is hard.
https://gist.github.com
I'll be 100% brutally honest with you: Almost no one cares about running ruby on windows, and it is highly unlikely to change any time soon. The fact that ruby runs on windows at all is more of a fluke than anything. 
I just started using Nitrous.io on the 20th and I have no plans to continue using them. I signed up for a paid plan and 3 days later they launch their new 'Nitrous Pro.' The service I signed up for is now considered 'Nitrous Lite' and will not be supported after July. I'm really glad they let me sign up for a soon to be dead service with no option of moving my 3 day old plan to their new plan.
Oh it's definitely a pattern for modern browsers. Often you don't have a choice, you MUST support legacy browsers. My only point was that given an SPA and a server rendered version of the same app the SPA app would be more tolerant of spotty network connections than a traditional server rendered app.
This is not the shared opinion of the Ruby community, please do not pretend it is. It is just the consequence of the resources being limited. If there were more resources (Ruby is nowhere close as far as it goes to backing compared to big players like Java and .Net) Windows could be a first class citizen too for Ruby. Bringing attention to that is an important part for this to eventually happen. More importantly, my post was not just about that. The same arguments I made could still hold true for a similar "real world app" for a Linux end user because Ruby tooling is not yet as complete as the other ecosystems I mentioned. Please don't discourage other people with such a delusional attitute. I somewhat feel it, but saying it's unlikely to ever happen that Windows will be properly suppoerted does not help the cause at all.
Community driven projects can receive funding too from big subjects/corps. Being that Ruby is relatively newer than other technologies, the fact that didn't happen yet, does not prove it is highly unlikely it won't.
What does working in Barcelona look like for Spanish non-speakers?
rails and js guy here. Very interested in relocating to Spain. Don't speak Spanish though (can speak some French, for what it's worth).
Thanks for all of your thoughts on this. You've given me a lot to dive into and research. This was in one of my weekly articles and thought it was quite amusing in light of the JS conversation: http://kryogenix.org/code/browser/everyonehasjs.html I would love it if I didn't have to worry about any of this and everyone was just using Google Chrome, haha.
Poor hardware support. This is specifically referencing interfacing with GPIO pins on parallel ports and Raspberry Pi GPIOs. I had to rewrite existing libraries because they were no longer maintained and had to write a bunch of new ones to get my project running.
Ruby and JS developer here, also fully bilingual (Spanish). What's the situation with the visas? Would the company take care of work permit or visas? 
Guy from Barcelona here. If you can't speak Spanish you may struggle at the beginning, but most of the companies hire Spanish professors to help non speakers to get a decent level. I've been working the last 6 years with tons of people from so many countries and when they come , most of them stays here. Barcelona is an international city and people con help you with the language, but your integration will be much easier if you learn some basic Spanish (and even more if you learn Catalan) but if you don't, you can still manage to live here without many issues. 
I've found the same thing. It reminds me of this: https://twitter.com/codinghorror/status/574013790506762240 &gt; Love Ruby, but hard to imagine a more hostile dev environment for someone on a Windows box. I think it would punch me if it could. 
I would say that it scales, but not cheaply. If you're talking about scaling something web-related to handle more load, you scale it by adding more hardware. Ruby is slow, so you add more hardware. You want to get around the GIL, so you spin up extra processes, which chew up memory, so you add more hardware. It's not ideal, but it works. If you're talking about scaling up the size of a codebase and the number of developers, the same thing probably still applies. You have to slow down a bit, test more, and architect the codebase better, but you have the same problems with all large multi-developer projects, regardless of whether the language has dynamic typing. On the static vs dynamic debate, the jury [is] (http://sequoia.cs.byu.edu/lab/files/pubs/Delorey2007a.pdf) [still] (https://courses.cs.washington.edu/courses/cse590n/10au/hanenberg-oopsla2010.pdf) [out](http://pleiad.dcc.uchile.cl/papers/2012/kleinschmagerAl-icpc2012.pdf). The existing empirical research in our field is pretty sucky, unfortunately.
RailsInstaller and its devkit improved things regarding that. The problem really occurs because of Gems using native C-extensions, and less so because of the language itself.
The preference for curly brackets is diminishing thanks to a newer generation of python/rubyists. I consider myself in this camp, and I am far more interested in elixir/coffeescript style syntax, than a language with curly brackets.
I agree with not cheaply. Having a slow language means I spend a ridiculous amount of time optimizing simple Rails apps to add caching, etc. When I start to think about the lost time on performance optimization, I begin to question its convenience. Then again, this might just be the "grass is greener" effect.
My biggest problem is that the cool parts of my app which are hard IS the front-end Javascript MVC. The Rails part is increasingly becoming the easier component. This more than anything explains why Node is growing. You can only learn so much, the biggest payoff comes from JS expertise.
HTML web components will be the most major change occurring to the web right now. Ecmascript 6 will be a fundamental part of browser functionality in the future.
Funny thing about monkey-patching is that some developers go like "you shouldn't really do this", and then if the language supports it like JavaScript, they do it anyway. The creator of BabelJS warned like that and then used it for Babel-ESlint. To me, sometimes monkey-patching may help with not forking a code base that you want to extend right away. I'm not yet certain how forking code bases and distributing the forked versions goes with package managers like RubyGems and npm. But yes, "don't do that" if you can help it. :-)
brace yourself, jruby 9k is coming!
Some do, talk to them and ask :)
Will do, thanks!
I'm a member of some of them, you can check their dates here: * www.meetup.com/BarcelonaJS/ * http://www.meetup.com/Barcelona-on-Rails/ 
I don't agree. I see no reason for an exception to the rule even for Hash objects. Why should Ruby make an coercion here, when symbols and strings are instances of quite distinct classes ?
Does this count as Over 9000?
*Thank you!* Finally, someone *gets it*. SOLID isn't "just" about methods, or classes; it applies to *every layer* of your app. This isn't 2003, when a legion of disillusioned wannabe-ex-PHPers was casting about for something, *anything*, that had sensible defaults that you could still go in and monkey with if you needed to. The Web apps most teams are building now are so much more than what was then, and we're coming to realise that we need "boring" "old" design principles like SOLID if we don't want to live 24/7 at the keyboard with managers/customers messaging us every three minutes asking, "is it done yet?" There's more to architecture than (what now passes itself off as) MVC. A lot of people who've realised that have left Ruby entirely (Twitter being the poster child). Others have gone out and led their own new-tool teams, a blessed few of which are starting to get decent traction. Rails started out being extracted from *one* app by *one* guy who, to hear him speak, write and Tweet, cares a lot less about long-term maintainability and quality than about throwing something together fast enough to sell to the investors and then moving onto the next thing. That mentality's tanked our industry at least twice (anybody remember dot-bomb?) We certainly should have learned our lessons by now.
&gt; Also, in Ruby we like regular expressions I BEG YOUR PARDON? THAT'S FIGHTING TALK! ;)
I will, thanks!
Three of these aren't podcasts.
JRuby is already a lot faster for many workloads compared to MRI.
Yep. It wouldn't really be 'greenfield', I'd probably still copy-and-paste a lot of code, but yeah I'd start with a freshly generated app. Hopefully there'd be existing tests that could be salvaged too, especially integration tests would be worth adjusting to work with rails5 if neccesary, even if it's work. 
It's more Rails specific thing - too much magic inside libraries. That makes things easy to use but hard to understand especially since there is no good way to navigate Ruby projects. One specific example that lots of people who dug into Rails probably seen is that functions try to make sense of whatever arguments they get instead of just throwing an exception.
My excuse: Since the person i was originally responding to is clearly a relatively inexperienced ruby developer, why would i want to confuse them with this technical detail? Students are constantly taught things that are technically "wrong", and then corrected once they are experienced enough to not be too confused by the "full" explanation. Would you try to tell a child about general relativity, when they don't yet understand the basics of (Newtonian) gravity? I'd hope not! One step at a time. I think it's much better to scope your response for the target audience. 
Put the turtle on a beach and call it a desert with an ocean view.
My biggest issues are with the community. In particular, I feel like people trot out "The Ruby Way" as an excuse for writing code that doesn't perform well. Faced with two options, one that's idiomatic Ruby and inefficient or one that's faster but a little ugly, many Rubyists will go with the pretty option and then argue that "that's just how it's done." I think that there's a balance that can be maintained but if you're writing code that people depend on and might be used in busy environments, you should always prioritize performance. Separately, I feel like there's a culture of "There's a gem for that!" that can be taken to extremes. This is particularly true in the Rails world, where devs become overly reliant on magic and never get good enough at the language to contribute back to open source.
Calling Gary's screencasts a podcast (and a rails specific one at that) really does a disservice to it. I highly recommend those screencasts, they are one of the single biggest factors in my current development style. I would be a far worse developer if I had never watched those.
Can someone explain things that make Volt preferable to Meteor other than "it's Ruby"?
You can easily use CoffeeScript (or other compile-to-JS languages) with Meteor. Therefore, I read your answer to my question as "No, there's no reason to choose Volt other than so you can avoid JavaScript. So if you don't mind JavaScript (or CoffeeScript, et al.), then please ignore Volt."
I would guess that its because the env is immutable in Java, much like the current working directory. You can shadow the value to give it the appearance of mutability, but some parts of Java will still access the original value. 
&gt; Eh, adding type checks to fail fast isn't worth it in ruby There's been an awful lot of discussion around it, since PHP's recent debacle of a strict type hinting option. Thing is, PHP's awful coercion system led to a lot of very real bugs and issues. You can't fix that without changing the language so... enter types. Ruby may be dynamically typed, but it's still strongly typed. The classic argument as to why we need strict types: 2.2.2 :001 &gt; puts 5 + 7 + "A" Is because that would output rubbish in PHP and just continue on its way. Ruby however: TypeError: String can't be coerced into Fixnum Which is no different to a function erroring out because it was called with an invalid type. 
This is actually a great reason! 
&gt; Eh, adding type checks to fail fast isn't worth it in ruby. Apparently you missed the entire part of my post that describes how these sorts of systems don't have to fail fast. Perhaps you should try reading it again? I don't think you comprehended what I was actually trying to say.
Actually that's a terrible reason to make an entirely new framework, especially considering that you're not even really writing Ruby (at least for the client-side portions), you're just writing Ruby that converts to JavaScript anyway.
The closest thing I know of is: [Ransack](https://github.com/activerecord-hackery/ransack) You can see a demo of a pretty straightforward but powerful form [here](http://ransack-demo.herokuapp.com/users/advanced_search). Not sure it'll do everything out of the box but maybe work extending...
Opal-derived Javascript isn't like CoffeScript-derived Javascript. You don't have to fight Opal to make the JS you want, and generally, you don't have to think in terms of the JS it's going to produce, since it's really running a Ruby-esque runtime in JS anyway.
Yet.
You should probably just use the distro you're most familiar with. Barring that use whatever your servers are running. 
Doesn't really make a difference for Ruby development, any distro will do you fine. There'll be differences in exactly what libraries you need to download from the distro's repository before building C extensions, but that's something you can Google in 30 seconds and only need to think about once. If you're doing Rails/Sinatra or web stuff, some of the web server configuration differs between distros too, but again, not in a major way. Go with whatever you like best. If you haven't used Linux before I would go with Mint or Ubuntu; they're polished, accessible, and two of the most popular so there's plenty of support and tutorials available.
Sweet! Yea, I have Ubuntu on a Virtual Box so I'm most familiar with it and the CentOS that's on my VPS. Ubuntu it is! Thank you very much :)
Ok. I'll try ELI5... Let's say you have the following a_warrior = Warrior.new This means you have an *instance* of the class `Warrior`. Whenever you define a method using `def method_name`, you are defining an *instance* method. Instance methods, as the name suggests, are methods that can only be used on an *instance* of a class, and perform actions using/on the instance of that class. Like our `a_warrior`. Now, here's an important bit about *context*. When you call: a_warrior.take_damage(5) You are operating on the *instance* `a_warrior`, so when you refer to `self` inside the `take_damage` method, you are referring to the `a_warrior` instance itself. So, calling `self.health` is actually the same as calling `a_warrior.health` outside of the `take_damage` method. So, now that we've got that background, what's the difference between @variable, and self.variable, when we're dealing with an instance? When you call `self.health` you are actually referring to a method called `health` (or `health=`) on your `a_warrior` instance. These getters &amp; setters are automatically created for you in (recent versions of) Rails, or when you use `attr_accessor :health` on a Ruby class. And these methods actually end up directly referring to the `@health` variable themselves, to change the value. (A decent explanation of this can be found here: http://stackoverflow.com/a/5046915/1787232) When you use `@health`, you are directly referring to the instance variable itself. A lot of the time, you won't notice any difference between the two. But, as an experiment, you should try do this on your warrior class: class Warrior ... def take_damage(dmg) self.health -= dmg #OR: @health -= dmg end def health= value puts "I'll appear every time you set health via self.health!" @health = value end ... end You'll notice that every time you set the value of `health` via the `self.health =` format, it'll output that `puts` message. But if you set it via `@health`, it will not.
&gt; Yet. Both comical and potentially very, very accurate. No one was hiring 'Rails developers' in 2005. No one was hiring 'Django developers' in 2006. No one was hiring 'not-exclusively-client-side JavaScript developers' in 2010. Or hiring 'Angular developers' in 2012. Or hiring 'Play developers' in 2012-ish. No one was hiring Volt Developers in 2015? As a 'first impression' post I think the point is to acknowledge Volt (and Opal!) as an exemplary case of potential evolution in Ruby's applicability and efficacy rather than framing it as a competitor to or replacement of existing technologies.
I haven't included it in any gemfiles. But i have installed it on the production server. That's ~200Mb of memory being taken up on the server, when one would (in other languages) expect the entire server to require less memory than this! 
Next! &gt; What does using "self.class.name_of_method" do? So, given my previous post, we understand that when we are operating inside an *instance*, `self` refers *to* that instance. So when we call `self.class`, we are calling the `class` method on the instance. In all cases (except where you very dangerously override it), the `class` method will return the class that the instance is made from. So, if you called `a_warrior.class`, it would return `Warrior`. Now that you have your `Warrior` class, you can do with it everything you would do by calling `Warrior` normally. You could do: a_warrior.class.new # Now you've got a new warrior! Equivalent to Warrior.new a_warrior.class.description # Will call the method defined by `def self.description`. Equivalent to Warrior.description Etc, etc. You can use this any time you need to refer to the class of an object, within the instance of that object. &gt; And, what about "def self.method_name" where self is called in the define method line? So, here is where *context* is, again, important. As /u/ryanplant-au mentioned, everything in Ruby is an Object. Object is an Object. Class is an Object. 1 is an Object. "I'm not an object" is an Object. `self` will always refer to the Object who's *context* you are currently operating in. So, when you call: class Warrior ... end While you're *inside* the class definition of Warrior, `self` will refer to that Warrior class Object. So when you do `def self.a_method`, you're saying you want to define a method *on* that class. When you leave out the `self` call, it instead defines a method that will be available on every *instance* you make from that class.
I think one of the things with Ruby is you're generally encouraged to use rvm and build it from source. The impact of that is that you're not really affected by your distribution. In PHP land, people groan about CentOS because the shipped RPMs are a few versions back. You *could* go and compile it from source, but it's an exercise in frustration. You could also use a third party repo, at which point, why use CentOS? Ruby really does encourage you to use latest builds by default. I don't know many developers choosing to use Ruby 1.8 today just because that's what CentOS ships with. The choice tends to be independent of the OS.
&gt; ... as an exemplary case of potential evolution in Ruby's applicability and efficacy rather than framing it as a competitor to or replacement of existing technologies +1000 if I could. This has nothing to do with either Rails or Meteor. It's a thing on its own. Let it be that.
I mean, the main reason really is: It's Ruby everywhere. That's generally enough for most Ruby developers, since they like thinking in terms of Ruby anyway. To each their own :)
Come oooon Truffle and Graal
It isn't even 1.0 yet. All frameworks have to start somewhere.
The term 'bloated' is so loaded as to be fairly meaningless, unless it's defined at the time of use; being 'small and quick' isn't necessarily better than being 'bloated' (which just means something is large, not slow) if you're going to have to implement most of the functionality that's already available in a larger framework yourself. I'd be interested in hearing about the areas where Volt excels and the edge cases that Volt doesn't yet cover, so that I can learn where it may be preferable to one of the larger frameworks. I'm a bit wary of magic code on the front-end, but there are many applications where the control trade-off is worth it.
Check out the [examples in their test suite](https://github.com/voltrb/volt/tree/master/spec/apps). There are also some tutorials on github that are very basic. It's pretty easy to get started by just poking around, too.
So in your code sample, you've got: require 'open-uri' This brings in a module called OpenURI that ships with Ruby. OpenURI methods let you open a URI/URL and get the text back from it -- because all webpages are just a type of text called HTML (push CTRL+U in Chrome to see the HTML for this page). page = open(url).read This uses OpenURI's `open` method, and passes in a given URL. What you get back is called a Tempfile, and you call `read` on that to get the actual text, which you save to the `page` variable. page.scan(pattern) This is the part you want to focus on. `scan` is a method that takes something called a regular expression. Regular expressions are a way of describing patterns in text; you can say "A piece of text that's a capital letter followed by two numbers followed by anything other than a number, as long as all of this is at the very end of the line", or whatever other elaborat arrangement you want. You can apply a regular expression to the text you get back from a page and use it to capture matching portions of the page -- that's what `scan` does, checks for matches and returns them all to you as an array. You can read about regular expressions [here](http://regexone.com/). They can get quite complicated, but you can use simple ones for the problem you're talking about. If they are really printed in plain text in the form MM/DD/YY # - # - # - # - # - #, then the regular expression would be `/\d+ - \d+ - \d+ - \d+ - \d+ - \d+/`. The two slashes at the beginning and end show where the regular expression begins; `\d` means "any digit"; `+` means "at least one of the previous". So it winds up meaning "return a piece of text that matches this pattern: at least one digit, space, hyphen, space, at least one digit, space, hyphen, space, at least one digit, space, hyphen, space, at least one digit, space, hyphen, space, at least one digit, space, hyphen, space, at least one digit." You may find that on many webpages, the data is not in a simple text form but actually split across multiple HTML elements. For example, [right-click the winning numbers on this lottery page and click 'inspect element', look at the highlighted markup that appears](https://tatts.com/nswlotteries/results/latest-results). Each element is in a `div class='drawn-number'` element. I don't know if you know HTML or not, but if you're at least passingly familiar with it, you may want to try a dedicated web scraping tool like [Nokogiri](http://www.nokogiri.org/). Nokogiri is a gem (a bunch of additional Ruby code you can download and make use of by typing `gem install nokogiri` into your console) that lets you query a webpage, get its HTML, and then access parts of it using the same selectors you use to write CSS rules. If I wanted to display the winning numbers from that page, my program would be: require 'nokogiri' require 'open-uri' Nokogiri::HTML(open('https://tatts.com/nswlotteries/results/latest-results')) .css('.draw-details')[0] .css('.drawn-number') .each { |n| print "#{n.text} " } Which reads: 1. Open the results page. 2. From that page, get the first element of class draw-details (the first drawing) 3. From that element, get the drawn numbers 4. Print each drawn number followed by a space.
As an 'application-to-be-upgraded' owner, who is not a developer, would anyone have a comment on a volt/opal plus ROM/Ruby Object Mapper combo (or is this not at all sensible/advantageous)?
That's awesome, tyvm for the reply. Model handling is definitely a pain point in Meteor. When I started out with Meteor I tried to make model objects for everything that handled the database interaction internally. I forget why since this was a while ago, but basically that isn't possible to do correctly in Meteor so I had to make a more procedural interface for everything, whereas it sounds like this is supported in Volt. Correspondingly, it sounds like Volt's testing story is better and I'd be able to unit test my models more easily. I'm trying to pick back up my Meteor project (which I actually basically abandoned a while ago because of Meteor's lack of unit testing) and if the testing story isn't significantly better now I may give Volt a shot. Thanks again.
Thank you for these comments. They cleared up a couple of the hazier things for me.
My biggest gripe has perhaps more to do with dynamic languages in general than Ruby in particular, but I got incredibly frustrated with always having a low degree of confidence in my code. I was constantly paranoid of type errors going unnoticed until potentially way down the line at runtime, or maybe a forgotten check for nil, and having an _insane_ degree of unit test coverage just to check that anything worked/held together. I found that most bugs I chased down would have been prevented by a rudimentary compiler/type system in the first place. And refactoring large amounts of Ruby is a nightmare. I write Clojure for my day job currently, so I'm not really writing this from the other side of the fence; there are a million reasons to write Ruby of course, and I do love it, but that was my biggest frustration.
elsif - REALLY? also the GIL
&gt; This does not require "zero cost" to configure. As I have said many times, we make no claims about the cost to integrate an InfraRuby project into your configuration (throughout your repeated logic). I said (two weeks ago!) there is zero switching cost *from* InfraRuby not *to* InfraRuby. Obviously, our claims are about our tools, but if you are using other tools we can give you advice on how to configure those tools to use the InfraRuby runtime or a Ruby interpreter, with a flag set through a configuration file or through the environment, or in some other way. &gt; Suppose that I do want to remove all the pointless return statements at the end of methods I just told you that the explicit return statements are optional in InfraRuby. &gt; Suppose I do want to remove the type annotations, as they are considered boilerplate comments that may go out of date. If you prefer to remove useful documentation because it "may go out of date" then that's your problem. &gt; It could be some contractor [...] That's still your problem. &gt; However, these are precisely the sorts of things that any real-world developer DOES need to consider. Thanks for your concern. &gt; You can upgrade from ruby v1.8.6 to ruby v2.2.2 at "zero cost". [...] This is a false analogy. In the real world, you would use a Ruby interpreter for development and testing of your InfraRuby projects. Then you can *know* that you can use a Ruby interpreter with zero switching cost, because you are already doing that! 
For me the worst thing about Ruby is the lack of deep understanding of how to grow a Ruby project. This can lead to some nasty tech debt (we've all seen plenty of 2000+ line models with a bunch of mixins and hooks). I think it's because people don't understand how to write clean Ruby code. The object model is fairly complicated compared to most languages, and maybe that has something to do with it. Ruby also attracts a lot of junior programmers because of the syntax and tooling. The truth about Ruby is that it has lots of powerful tools that can bite you hard if you use them wrong
[This book](http://www.poodr.com/) is gold for OO design with Ruby. Break the problem into discrete tasks. Model your data with classes and modules. Break problems into subproblems recursively until everything seems pretty tractable. Consider [making a gem](http://guides.rubygems.org/make-your-own-gem/) and then a small application that uses the gem. The structure that a gem provides is helpful for getting started. Write tests. Whether they're written before or after the code is far less important than that you write them.
Thank you for the detailed response! I have a few more questions haha.. Can class methods be instantiated any other way besides using "def self.method_name"? Can these methods with "self" in them be used by variables? Just to make sure I'm understanding correctly: &gt; So when you define an instance method (def explode), you are specifying what methods the objects produced by your class-object (Firework) should have When I "create" a method within a class, this method is basically a child of the class. It can only be used within this class. Also, using ".new" on an object, ".new" is a class method which is part of another parent class? Edit: One more! The example you used for the Date class. "Date.new" can take multiple number of arguments (given the numbers from largest (year) to smallest (millisecond). So can I visualize this as "def self.new(*args)" for class Date. Also, "Date.parse("2015-04-30")" can be seen as "def self.parse(string)" for class Date. 
Thank you for your reply. I ran into a bug :( how can I call on: def take_damage(dmg) self.health -= dmg end I initialized my instance with "@health = 100", but when trying to run the above, I get an undefined method error 'health'.
Ah! In that case, you probably don't have the `health` getter &amp; setter defined. So, for those methods to exist, you would need one of the following: If you're using Rails (or ActiveRecord), your warrior Model will likely look like the code segment below. If that's the case, then getters and setters will automatically be defined for all attributes in the schema for the Warrior model. class Warrior &lt; ActiveRecord::Base ... end With the following approach, `attr_accessor` will automatically add the `health` and `health=` methods for you. class Warrior attr_accessor :health ... end And the following approach is manually defining the getter/setter yourself. There's no point doing this over `attr_accessor` unless you want your getter &amp; setter to do something more complex than just getting/setting the value. class Warrior def health @health end def health= value @health = value end end Edit: To add some extra detail, the reason people have suggested either @health or self.health is likely because they are developing in Rails. If you are simply creating a standard Ruby class, I would recommend just using @health to modify your health variable, while inside your Warrior instance. Unless you have a need to be able to get/set the value of health *outside* your Warrior instance (i.e. `a_warrior.health = 10`), there's no need to expose public accessors for it (which is what `attr_accessor` will do)
Awesome thank you for this explanation. Just to clarify the information you put in your edit, would using an attr_accessor with instance variables like @health be similar to something like "self.health"? 
That's pretty much exactly what it would be! So, all `attr_accessor :health` does is define two instance methods on your class. And they are pretty much exactly: def health @health end def health= value @health = value end These methods will be publicly accessible. Meaning, if you have an instance `a_warrior = Warrior.new`, you can call `a_warrior.health` to retrieve the @health variable, or `a_warrior.health -= 10` to set the @health variable to be 10 less than it currently is (this also applies to `self` when operating inside the instance of your Warrior). If you don't need to be able to specifically retrieve/modify the health variable when *outside* of your warrior instance, then there's no need to define these, and you can just use `@health` to refer it when inside the instance, instead of `self.health`. Edit: So, I guess to summarise to make everything super clear: `@variable` is an instance variable. `self.variable` is a method to *get* an instance variable. `self.variable=` is a method to *set* an instance variable. `@variable` is technically *only* accessible while inside your object instance, but `.variable`, like all instance methods, *can* be used both inside AND outside the instance (`self.variable` &amp; `a_warrior.variable`) So, try not to view the `self.health` as anything special. It is simply a method (like any you could define with `def method_name`) to interact with `@health`.
Repost of https://www.reddit.com/r/ruby/comments/34aw26/an_open_letter_to_matz_on_ruby_type_systems/ that was posted only yesterday. Might as well keep discussion centralised
Generally a good list but I disagree with the example used in the last one. The nesting is pretty much the entire point of how rspec tests are organised. 
&gt; As I have said many times, we make no claims about the cost to integrate an InfraRuby project into your configuration (throughout your repeated logic) As I have said over. And over. And over. I know. I am not even discussing this claim. I am discussing what a "zero cost" would mean in the **real world**, and not simply under your idealist definition. &gt; explicit return statements are optional in InfraRuby I made that comment in regard to your [many examples](http://infraruby.com/examples/framework) on the website. Not only is the code horribly unidiomatic for ruby (hard tabs, and method calls like `@response = Java::org.jboss.netty.handler.codec.http.DefaultHttpResponse.new(Java::org.jboss.netty.handler.codec.http.HttpVersion::HTTP_1_1, Java::org.jboss.netty.handler.codec.http.HttpResponseStatus::OK)`), but it's full of `return` statements in all sort of weird places, such as `initialize` methods. These `return` statements *are* pretty much necessary, in order to create a method signature for the InfraRuby compiler. So rather than just shrugging off this ugly code as being "optional", or "not your problem", a much better solution would be to actually provide some means of removing it. &gt; That's still your problem Okay, so you agree that there is no zero cost switch possible in many real world situations then. I'm glad we finally agree.
Agreed, that last item is nonsensical. "Look at how complicated this RSpec test is! Here's a trivial class definition instead." Well yeah, lol. How about actually attempting to refactor said code?
It's an ongoing thing. I upload a video every day (although I haven't been able to upload recently due to internet issues at home, but I'm still making the videos), and every day the application grows and progresses to completion. Yes, the index.html.erb has Hello World right now, but that's going to change as the application grows. The idea is to teach people how real world application development is done (although I have to admit, I forgot to branch off a few times). You'll see me running into bugs, and then going about how to bust through the bugs, and my approach to debugging. You'll also see automated testing, polymorphic associations, single table inheritance, authorization, and etc that you'll see in a decently sized rails application codebase.
Interesting: If we remember the last twenty times we jumped onto a bandwagon that went nowhere, we might be more cautious next time Of course the hard part is telling what's a bandwagon and what's the next wave - e.g., coffeescript, which is it? 
That's absolutely what's happened. The gem has grown into an "all-in-one" solution, which is great except for how bloated it's become! The problem is, this is exactly what happens to **lots** of projects. So even if this issue is resolved, you'll probably find your production server's code base bloated by something else instead. For example, all it takes is one foolish developer to add `ActiveSupport` as a gem dependency and suddenly your (non-rails) project bloats massively! Of course every time such a "bloat" appears it can be fixed, but my issue with ruby is how *easy* it is for your code base to bloat in the first place.
Personally, I dislike metered billing, especially for something like SMS. Honestly, if you were going to bill for SMS Inbound/Outbound, do it in packages. For example, 1st Tier - $1/month to rent SMS Number and SMS are sold at $7.50 per month per 1000SMS which unused carry over to following months. This way, you can better project your income as well as providing users to project their expenses.
you don't mind: Are you gonna do about it at first.
"Most papers in computer science describe how their author learned what someone else already knew." – Peter Landin "Mathematicians stand on each others' shoulders and computer scientists stand on each others' toes." – Richard Hamming
True. But (to extend my earlier analogy), even a child quickly learns that you don't *want* to eat only candy, all the time. Wouldn't you really rather have a good hamburger with all the trimmings or, better still, ready access to a well-stocked kitchen where you can prepare a variety of meals, not just the same thing all the time? Rails was, at the time, a bold stand against the fragmentation and confusion seen in the industry. (Over a period of ~5 years in the early 2000s, I worked on 9 different PHP projects using *six* highly dissimilar "framework" toolkits. I know people who were far more thinly spread at the time.) Fragmentation *for the sake of "variety"* is *really bad*, but I think we're learning that *differentiation*, choosing different tools for use in different circumstances, is a Good Thing. We shouldn't treat Rails (or *any* software artefact) as a religious icon; it's a very nice hammer, but not every problem is a nail appropriate for that tool. We'd be a lot more effective, and almost certainly a lot happier with the tools we use, if we didn't insist on twisting every app into something that can be expressed in The Rails Way, or vice versa. I've made the crack several times over the last couple of years that "when your work is devoted to *mitigating* Rails, rather than shipping your Next Great Feature&amp;trade;, to any significant degree, you have A Problem". We as a craft community need a *much* better read on this.
or ifttt
The craptastic C "API".
Can I make a suggestion? Sync your mysql to an elasticsearch and use the elasticsearch api for queries. It will do your aggregates but much faster, and the api is already done.
You did well, don't use sudo. You might have missed a step in that tutorial, or something went wrong with your installation, and you're still on OSX's default ruby. Try rynning `rbenv versions`. You should see something like: system * 2.2.2 (set by /Users/%username%/.rbenv/version) In your case, the active (marked with *) will probably be the system ruby. Try running `rbenv global 2.2.2` - that will set the version for your user. You might also try `rbenv local 2.2.2` which will only affect the current directory and subdirectories.
There is a gem simple_universe, it's way too much for your needs but it's a start, you can then restrict to Universe.dimensions.time.in_years.range([1970..Date.today.year]) which will give you a nice easy to process array with all the years from 1970 to present. You can then just put those years in the database with Rails (rails g model Year year:integer and then in the migration, after the table creation, just take the list you got from the simple_universe list and iterate over the years to then build a Year model for each value, such as range.each { |year| Year.create! year: year }. Now it's in your DB and you can just do Year.count to count all the years, or even do Year.find_by_year(1970) to say retrieve one year (1970 in this example). Hope this helps! PS: I'm sure you can see how your problem could be described better so that someone can actually help. What is a year? And why would you want to store it in a database?
Thanks!
Why not just allow the user to enter a date (text field) and just verify that its within the range of 1970-2015?
I think this helper is exactly what is being asked for. select_year helper: http://apidock.com/rails/ActionView/Helpers/DateHelper/select_year It is actually built into rails so you don't need a gem. But it not only gives you the list of years, it even creates the drop down for you.
Okay, I think you might be missing rbenv's shims. Shims are small binaries that forward your commands to the correct version of ruby. If they are missing or PATH is not set up correctly, the commands will fall back to the next available binary in the PATH chain. first, try running `rbenv rehash` to generate the shims. I am fairly certain that that should do it. If it doesn't, the first thing to check would be PATH: `echo $PATH` should look similar to this: /User/bassneck/.rbenv/shims:/User/bassneck/.rbenv/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin Binaries are looked up in the chain from left to right. So, it's important that `.rbenv/shims` comes before `/usr/local/:/usr/bin` Hope that helps. Also, here is what I think to be [a better guide to installing ruby/rails on osx](https://mattbrictson.com/rails-osx-setup-guide).
How do you know when people are relying too much on pre-packaged libraries? When they *start* by asking for a whole gem just to create a simple array of sequential numbers. :-/
Well, yes and no. The solution could be either language-level or IDE-level or the two working together. I mean, in Java there are annotations, I can easily imagine how that could be done using those and it would need both the (pre)parser and Eclipse to work together to provide a smooth experience. 
How would you do it purely at the language level? I don't think it's possible to do things like that with text without your editor being aware of the protocol.
Have you tried Artoo? http://artoo.io/
What's the reason for even doing that? If you have tests for the method, you shouldnt worry about printing the value. If you want to save it, you should use another db table..
This is what a stacktrace is for. If your code encounters an exception or if you use one of the available ruby debuggers, you'll see the 'rewind' method in the trace. No need to manually output the string 'rewind()' from the code itself...
This sounds a lot simpler than what I had in my head! :)
It is, and it will work.
Yes to helper and to helpful redditors :)
How are you debugging in Sublime, VIM, TextMate etc. ? Use an IDE if you want the best debugger available. 
I run a unit test. If I need a debugger to examine state deep inside a method, that is a code smell. Break up the method and test the state of the subcomponents/suboperations in a unit test.
OP should probably use a real logger, but the same question could have been asked about `puts blah if @debug` or `logger.debug blah`.
This is not an answer to my question. Unit tests are not a replacement for the debugger. You can't try out real time evaluation of new functions by running a unit test. But you sure can set a breakpoint and open up the code evaluator in ruby mine and spike on how you might write a new feature while other necessary values / variables are accessible from memory. Then once you have a rough draft you can write your test and write the code. 
The "core" is all the modules (plus more fundamental things, like syntax) that are always there taking up memory in Ruby and you can't get rid of them. The "standard library" is a collection of modules that ship with Ruby, but you have to `require` them explicitly or else they won't be loaded into memory. A "gem" is a collection of one or more modules that is not part of Ruby, but which is conveniently packaged for download. The core and standard library are controlled by a relatively small group of experts and change slowly, but anyone can publish a new gem at any time. So mostly the core and standard libraries are known quantities whereas there are always new and exciting gems coming out. That's why Ruby programmers talk about gems so much.
oh. that did not even occur to me. I don't like hidden things :)
Yes, good point
I don't think you're pickin' up what I'm puttin' down. If you are erecting a complex state which you describe needing to examine in a debugger, this implies complex code. I'm not saying a debugger isn't useful- I'm saying it alleviates a pain that should be felt, which is the complexity of your code. I've had to do a lot of technical debt paydown and code refactoring so I am familiar with this. I've honestly never missed having an IDE, and this is coming from a guy who used the first versions of Visual Studio for a couple years. You can code in a way that reduces dependency on debuggers. To demonstrate it to you, I'd have to see the code in question. Happy to do so at your leisure.
If you're a professional programmer, then you're familiar with non-disclosure agreements. I can't show you the company's code, so the invitation to have you take a look is a dead-end and you knew it when you typed it. I take it as exceedingly disingenuous to post such a statement for other subscribers to this sub to read giving the impression that you're offering to be helpful fully knowing that no one is in a position to post corporate-owned code with impunity.
I am just recreating the problem and call it with the right parameters and put a binding.pry in the code.
I dunno, that's pretty arbitrary. "Program" isn't a very coherent unit. Say, for example, you're already a professional object-oriented programmer. How many programs would it take you to get comfortable with RoR? Exactly one full-time gig in a Rails shop, which may very well be one "program" if you're working on delivering a single application to production. If we're talking about going from not knowing how to write code to being comfortable with RoR, assuming RoR is where you start, it again depends on the depth and complexity of your software. It is definitely possible to learn Rails writing exactly one program, ever, if it's sufficiently rich and you are sufficiently methodical in your practice. If you're just assembling a bunch of short practice apps to learn things, like contrivedly feature-poor blogs or whatever, I guess I could see it taking a hundred applications. Basically what I'm saying is that the scale of a "program" varies WAY too much to have a meaningful answer here. I would argue that a better version of this question would be how many hours of working on code would it take to get competent. That I have zero anecdotal experience to tell you. I started writing software when I was 8, and I didn't exactly log my practice hours. I keep hearing that it takes about 10,000 hours of practice to become an "expert" in something, though.
Yes, there's really no black and white answer to it. I just want to get to the point where I'm proficient enough to write something w/o looking at tutorials.
Like I say, I think that's more of a question of hours than number of programs, but even that will be immensely variable. For what it's worth, though, I don't know a single developer (in any environment, in any language) who doesn't basically live with their relevant documentation viewable. When I'm starting work for the day I open up APIDock, and I probably reference it half a dozen times a day. So does my lead engineer, who has been building Rails for like seven years.
Good info, I'll start reading documentation daily too. Thanks.
Will not ever happen. I reference tutorials and documentation constantly, and I'm an employed developer. Whenever you get to the point that you're banging code out without looking anything up, you're not learning anything new. Learning new stuff is how you progress, and you should always be progressing.
&gt; Say, for example, you're already a professional object-oriented programmer. How many programs would it take you to get comfortable with RoR? Exactly one full-time gig in a Rails shop I doubt that. Ruby is 'object oriented' in a very different way than most OO languages are. It's OO in the smalltalk sense which is actually very rare and can be difficult to comprehend for many developers.
~~&gt; Use an IDE if you want the best debugger available.~~ Use pry if you want the best debugger available. 
To the contrary RubyMotion is an incredibly powerful and robust enterprise GUI framework for ruby: http://www.rubymotion.com/ It supports native iOS, OS X, and android applications all in ruby, using LLVM to target native bytecode. 
Missing full code coverage of ruby codebase so that it can be used as a definition for the language itself. I would love such a thing because you can start saying how much are you sticking with official ruby implementation even as a percentage, quite nice.
There is literally no way for us to answer this OP. It depends on so many factors that anything we guess for you is going to be wrong. If I were you I wouldn't worry about never having to look at tutorials, just get on a build shit. I've got 7 years experience (albeit in another language) and I *still* look at tutorials sometimes.
I've worked with people who have been programmers for 15+ years and they still frequently look at the docs or google their questions. Being a great programmer is more about how you think and approach a problem, not about how well you've memorised a language. :)
Why not just use SQL and 'select', which is supported by activerecord? Is it the concern of instantiating ARb objects at all?
:)
&gt; Aspect Oriented Programming has no popularity in the Ruby community at all. Really? Weird. Seems like a really cool concept to me, even if I am still pretty new to this programming thing. I've been practicing on pre-existing code that's an absolute freaking nightmare of dependencies and type checks all over the place. Getting sick of those kinds of problems in a hurry and I haven't even been doing this for all that long yet.
*Here's the Urban Dictionary definition of* [***Stomache***](http://www.urbandictionary.com/define.php?term=stomache) : --- &gt;An idiot who can't spell "stomach". --- _Guy1: Man, my stomache is killing me._ _Guy2: It's stomach, dumbass._ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/ruby/comments/34smp6/how_to_refactor_out_if_statements_using/cqxtys4) ^| ^(**Summon**: urbanbot, what is something?)
I'd argue most of the time when you don't need multiple instances of a class, you should still be allowing and creating them. Partly or largely just because of [these arguments from Bryan Helmkamp](http://blog.codeclimate.com/blog/2012/11/14/why-ruby-class-methods-resist-refactoring/), but also because sometimes you're wrong in thinking you won't need more than one of these. I recently refactored my technical debt gem debt_ceiling to substantially to eliminate all but the basic entry point from being module/class methods, and I think the code is much better now. The hardest part may have been coming up with a reasonable name for the class instances extracted from the body of the DebtCeiling class, which started off just having a 'calculate' method. First I extracted an accounting class, but still had a lot of logic in the module. Once I thought to call the entire process an audit, I liked the idea of each run being a new instance of an audit. Here's [before](https://github.com/bglusman/debt_ceiling/tree/v0.1.1) and [after](https://github.com/bglusman/debt_ceiling/) links, tell me which you think is better :-) (though this is after I extracted Accounting class, and before I extracted Audit class... possibly I should find a much smaller diff to link to, because there were a ton of other extractions/changes here too... some of the closed pull requests might be better snippets to look at I think)
If your concern is performance, I would love it if there were some performance metrics in your readme somewhere indicating the gain from using the gem.
This has been posted several times before. The last one was less than two weeks ago. Literally all this guy does here is spam his blog posts and videos, and he does it under two different accounts. Any time he receives criticism, he brushes it off by claiming association with prominent Rubyists and/or bragging about how much money he makes. [He's](http://www.reddit.com/r/rails/comments/33941b/want_to_learn_how_to_remove_conditionals_from_ruby/) been [called](http://www.reddit.com/r/ruby/comments/241qz7/as_a_new_rubyist_what_can_i_do_to_become_a_master/) out [on](http://www.reddit.com/r/ruby/comments/2406a3/why_i_can_tdd_and_why_dhh_cant/) it [before](http://www.reddit.com/r/ruby/comments/23x9o8/tdd_isnt_dead_because_dhh_sucks_at_it/). Copies of this link: * This one * [13 days ago](http://www.reddit.com/r/rails/comments/33941b/want_to_learn_how_to_remove_conditionals_from_ruby/) * [19 days ago](http://www.reddit.com/r/ruby/comments/32lg57/replacing_conditionals_with_concretions/) * [11 months ago](http://www.reddit.com/r/ruby/comments/26yh77/refactoring_conditionals_out_of_your_code/)
You're right that the kind of module methods you're talking to are the same thing as 'static' methods in Java/C#. It can make sense to use static methods like this, it's sort of a more functional style. It an also make sense to use a more OO style. But I agree that there's no benefit to simply taking the same utility-style methods you've got now and `including` them into your classes, winding up with instances that have dozens of unrelated methods are mixed in. (Module mix-in is really nothing but multiple inheritance, by the way). The more OO way to approach it would be to make individual 'service' objects of some kind(s) responsible for doing certain focused things. 
If everyone did this, the world would be a better place. 
The simplest thing to do would be to use [Mechanize](https://github.com/sparklemotion/mechanize). Mechanize instances work like a web browser; you tell them a URL to go to, then query them to see what the body of the page they're currently on looks like. You can tell it to click a specific thing, return a list of links, input things into a form, etc. It will save you a lot of the time and effort you'd spend opening a URI, parsing the response, storing cookies, making a new request with those cookies, etc.
I just installed it and was running it against a new class I wrote that basically creates a hash for Elasticsearch from URL params. It definitely helped a bit cleaning up things and keep a consistent style. At other places things became a bit difficult. As an example this class needs a lot of mostly static hashes that can become quite long, easily violating the ten lines rule. I would have to split a static piece of data into smaller chunks to get this work. But whatever, overall the results are quite good, especially being reminded to keep methods small and not too complex. Would still be nice if there would be some kind of comment syntax to disable some checks just for a single file or even method. Also atom-lint made Atom freeze for me. The normal linter worked fine though. At least at my working machine, at home I get some stupid error message.
&gt; As an example this class needs a lot of mostly static hashes that can become quite long, easily violating the ten lines rule. Create a file named `.rubocop.yml` either in your home directory (global) or the project directory (local only) and add this: Metrics/MethodLength: Enabled: false That is one of the dumb default cops in rubocops. I also recommend: # No I don't need to document every class Style/Documentation: Enabled: false # This is a horrible metric and plays very badly with block initializers which are really common Metrics/AbcSize: Enabled: false # 100 line classes, nope. Metrics/ClassLength: Enabled: false # I care much more about clear code than line length Metrics/LineLength: Enabled: false # this one is debatable, but I do a lot of dirty data processing in ruby and it's painful to do without Style/RescueModifier: Enabled: false
Thanks for that. I knew about the .rubocop.yml. Just wasn't sure which rules to ignore. Good to see that you are talking about nearly exactly the same rules that annoyed me the most. Documentation: I write those libs only for internal use. It's quite clear what they do from the name. MethodLength: 10 lines may be a good rule of thumb but difficult to enforce AbcSize: Similar, the error is a good hint, but it looks like a lot of ?: stuff already triggers it Linelength? Yes, 80 chars is nice, but something like some_very_useful_name.each.with_object({}) {|variable, object| do_something_smart} already triggers it.
There's also [houndci](https://houndci.com/), which does that plus a bunch of other languages and is free for OSS. The [whole app](https://github.com/thoughtbot/hound) is open source, too.
It's pretty useful for processing byte-aligned binary data. For example, if you want to read some metadata about a [FAT16 disk image](http://www.maverick-os.dk/FileSystemFormats/FAT16_FileSystem.html), packing/unpacking would allow you to do it easily. You could decode all of these fields into an Array with just one line of code: ```0016h 2 bytes Sectors per FAT``` ```0018h 2 bytes Sectors per Track``` ```001Ah 2 bytes Number of Heads``` I have also found it useful for processing binary data received over the network. Building a TCP-based server is pretty trivial with Ruby, and you can efficiently communicate your data by resorting to a binary representation (vs a text-based one like JSON/XML).
As soon as you type `elsif`, delete the whole thing and write a `case` statement.
Part of what I don't like about rubocop is that it doesn't have, as far as I can find, the concept of 'warn vs error'. The closest you can get to it is using cascading configs with a separate `.rubocup.yml` for each directory which becomes cumbersome and makes it difficult to have it be a 'hard fail' part of the build/test. I should note that you don't have to completely disable the cop, you can change it's trigger point as well. e.g. I've set the method length cop to 25 or 30 at times vs completely disabling it, but over time I've found that hard limits for that type of thing don't produce the most readable code, which for me anyway, is the entire point. Some more comments of my own on each: &gt; Documentation Not all classes need documentation. Rails controller mostly don't, unless your going something crazy. Further the rule only requires 'top level classes / modules' to have documentation. But, it's very common to have modules spread across multiple files, it's often not the top level module I need documented, it's really just the namespace. It's the stuff inside that module that needs to be documented but that isn't what this cop enforces. &gt; AbcSize I don't know why this would ever be calculated for ruby. It's way too common to use blocks for initializing complex object and this thing trips on that all the time. I'd much rather look at an initialization block than a call to new with 20 hash params after it which rubocop is fine with. &gt; Linelength This is a holy war so I'll just say that readable code is more important than meeting some arbitrary width limit.
Go back a few to the 200th episode, it was really good. They talked about their favorite moments in 2014 and gave some good overviews of what the show is about. The show is more about general development, but everyone happens to code ruby/rails.
Some people aren't programmers, but merely arrangers of things.
Not really, it focuses entirely on aesthetic principles. Mostly, projects that end up frustrating to work on fail due to neglecting design principles. A terrible, flawed analogy: brushing your teeth is good hygiene, and poor hygiene will lead to some long term issues, but getting someone to start brushing their teeth will not make them healthy. Smoking, poor diet, lack of exercise are all much more important to health, and we should not delude people into thinking that brushing their teeth improve their health.
&gt; When I just started to learn C#, I was told by many veterans to avoid using static methods. The reason for that is because static classes denies some very basic inheritance principles like using interfaces instead of concrete classes or dependency injection. That is because C# is statically typed and inheritance / interfaces are the only tools it has for polymorphism. Ruby is duck typed, there are no special hurdles to jump through to get polymorphism, these arguments don't apply to Ruby. If you don't need to store state, don't instantiate a class instance, use 'static' methods freely.
&gt; Partly or largely just because of these arguments from Bryan Helmkamp That is a pretty empty argument. His only real point, is this: &gt; This is a little better the original, but doesn’t feel right. It’s certainly not object oriented. Which appears to be the summation of the article, 'it doesn't feel right', whatever that means. I'd argue that creating internal state when none is needed is a far worse idea, but of course, to each their own. I'd also argue with his definition of 'object oriented programming'. 
I've found this sheet before and it's very helpful, but I still struggle every time I use pack/unpack. I find the terms themselves to be confusing, they should be reversed by my logic. I am unpacking some binary data and packing a string, but I guess others could see it differently.
I do generally work with Rails apps but I appreciate a view into just how simple it can be to integrate Opal into a Ruby webapp. Thanks 2!
Thank you, will be checking those links :)
Interesting. Thank you bglusman, I'll be checking the article and your before/after code :)
I agree with /u/realntl - at least regarding the point that: &gt; Mostly, projects that end up frustrating to work on fail due to neglecting design principles. Whilst maintaining a consistent white space/variable naming/punctuation/file naming/etc style is certainly helpful, from my experience this is a fairly insignificant issue when fixing "bad code".
I like how you use every opportunity to cover Ruby and rails principles. Great video for someone who already know another language and is learning rails.
"This video cannot be played on a different domain."
Nice, I like this video a lot more than your previous two. You have focused on one specific problem and provided a simple, clean solution - which is great. A couple of nit-picking points: You say that a `Range` is an `Enumerator` (around 6:48), which it is not. The class does include the [Enumerable module](http://ruby-doc.org/core-2.2.2/Enumerable.html), but this is NOT the same thing as the [Enumerator class](http://ruby-doc.org/core-2.2.2/Enumerator.html). Also, your use of `in_groups_of` is unnecessary here - you could have just used `Enumerable#each_cons(7)`([link](http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-each_cons)) (which, ironically, DOES return an `Enumerator`!) -- however, one might argue this is bad practice for this sort of application, since the method behaves slightly funny when your `Enumerable` object does not divide evenly. (But in this case, it always will!)
Wow, this video must be using ruby v1.8.7 -- because since v1.9, `Object.superclass # =&gt; BasicObject`! (FYI, Ruby 1.9 was first released on 25 December **2007**, and extended maintenance of Ruby 1.9.3 ended on February 23, 2015)
I think you were looking for [`Enumerable#each_slice`](http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-each_slice).
Awesome video. I have built several calendars and its not always fun or an easy thing to do. You made it approachable and it shows just how powerful ruby and rails can be. Can't wait to check out your next screencasts.
Guard watches the filesystem and does things when files change. Usually it's easy to configure it to be intelligent about what happens, so when you modify a file in your test suite, it runs that one file, instead of the whole suite.
I really don't understand why there are so few current calendar gems for ruby! Nice video!
I wouldn't really call Ruby a lightweight stack. Its uses span far beyond web applications. Though it is a scripting language, there are several packages that allows for more advanced deployment scenarios. I have had experience with a few use cases where Ruby has been the language to accomplish different tasks. RubyMotion - Native iOS, OSX and Android applications - Used RubyMotion to create a native iOS application for a SaaS application. Ocra - Compile Ruby Scripts to Windows Executables - Used Ocra in two separate instances. The first is a video conversion tool that takes GoToMeeting videos and strips the proprietary codec from the videos and then uploads them to a LMS site. The second is a ETL tool which is installed on a Windows server. The tool extracts data from a MS SQL Server and translates it to a different importable format for a SaaS application. The software periodically uploads changed datasets to the SaaS application. In both instances, Ocra was used to compile the Ruby scripts so that they can be installed as a Windows Service. CNC - I built a CNC machine from some stepper motors and driven by a Raspberry Pi. I used Ruby to interpret the GCODE files (plot points) and translate that into stepper movements. The Ruby script controls the motors and will eventually create the finished product. So far, I've tested with engravings, milling and plotting. So these are just a few examples on the power of Ruby. Far from a lightweight stack in my opinion. Its uses are versatile and powerful. Granted you could accomplish any of these tasks with another language, but none of them cost me more than 1 month of work.
I've heard good things about [Play](https://www.playframework.com/), a Java framework. I do Rails, it's great. You generate a project and have pretty much everything setup to start building your app. Adding auth stuff? Add on omniauth, doorkeeper, devise, cancan, etc. And you pretty much have everything ready to go. ActiveRecord is hands-down the best ORM I've ever used. So far, I haven't used anything that comes close to the overall magic awesomeness of Rails. It has examples and gems for everything under the sun. If you're doing lots of projects, Rails is definitely a great choice. If you're supporting long-term projects I think pretty much all frameworks are gonna end up being mostly the same. Dependency management with Ruby is generally done with bundler. It's awesome. The only other package manager I like more than bundler is npm, which is used for javascript (mostly node/iojs, a bit for browser code in recent years).
thanks! I have also heard about play, but I would really like to get away from the JVM just to learn something new. You know how brain craves for novelty. I have heard some podcasts with Matz and I really like his attitude. 
Try out Rails! All you need is right on their [getting started](http://guides.rubyonrails.org/getting_started.html) page! 
Gemsets are used to isolate various gem versions to specific applications. For example, if you are working in a new app that is running Rails 4.2 and another legacy Rails 3 app, you can use gemsets to logically separate not just the different versions of the Rails gem, bit also wall the dependant gems as well. In its simplest form, gemsets allow you to avoid having to run all gem commands with `bundle exec` before it. For your purposes, you can just using the global gemset that RVM initializes with the Ruby version.
There's frustrating or annoying things to deal with in nearly any platform. The only answer to your question is really give it a try and find out. There is not very much "XML and all other boilerplate code" in Rails, if that's what you're asking. I'm sure there are other things you will find to be pain points. You can do more with ruby than Rails, if that's what you're asking. 
No. Ignore it if you aren't seeing any need for it. I don't use rvm. 
rbenv does the same thing right?
RVM isn't complicated once you understand it. And yes, I would start with RVM. If you want to make a second Rails app in the future, it's a great way to isolate the projects. #Install It's easiest to install RVM on a Mac or Linux box. Just execute this in a terminal: gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 \ &amp;&amp; \curl -sSL https://get.rvm.io | bash Then **exit the terminal and create a new one**. This is the easiest way to make sure you all of your environment variables set properly. Next we need to use RVM to install ruby: `rvm install ruby-2.2.2-dev` This will get an isolated version of Ruby for you to use. You can use `rvm list` to see it. #Gemsets Now that you have a ruby on your machine you can create a bunch of different gemsets. Let's make sure we are using the right ruby with `rvm use 2.2.2-dev` and make a gemset with `rvm gemset create myproject`. So we are using the ruby we just downloaded and using the gemset "myproject". If you ever want to get back to this gemset, run `rvm use 2.2.2-dev@myproject`. It's of the format "ruby-version@gemset". If you want every terminal to "use" this gemset when it is opened, run `rvm use --default 2.2.2-dev@myproject`. This "--default" flag tells RVM that you want this ruby/gemset to be the default when you open a new terminal. #Getting Gems Just use `gem install asdfqwer` to install the gem you want into the gemset you currently have selected. #Wrap Up So, for the meantime, don't worry about global gemsets, JRuby, or any of the other stuff on the website. I know it can be daunting. I was in you shoes years ago. Here are the main things you need to know: - Install versions of ruby with `rvm install xyz` - Create gemsets with `rvm gemset create xyz` - Don't forget to make sure you are using the correct ruby version! `rvm use RUBY-VERSION` - Use `rvm list` to see the current ruby that you have selected - Install gems with `gem install xyz` Let me know if you have other questions.
awesome! learn yourself some Ruby and rails then. learning oop again on Ruby was a real breath of fresh air after doing Java. but keep in mind that you can still target the jvm using jruby. 
Hi, i followed a install rails tutorial and it actually installed rbenv, do i still need rvm if i already have rbevn? it seems like they are both version control systems
thanks, i was following a tutorial and installed rmv after i already had rbenv and it actually had some bugs after and it works fine after i uninstalled rmv
To avoid typing `bundle exec`, create binstubs via Bundler and add the project's bin directory to your $PATH. (I use [this method](https://twitter.com/tpope/status/165631968996900865) by Tim Pope).
[**@tpope**](https://twitter.com/tpope/) &gt; [2012-02-04 03:05 UTC](https://twitter.com/tpope/status/165631968996900865) &gt; PATH=".git/safe/../../bin:$PATH" and do mkdir .git/safe in the root of repositories that you trust. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
It fulfills the same purpose, there are some differences of course.
Probably nothing will be able to parse date from your first scenario. You have two dates in one string. You will have to select those cases somehow and split them beforehand. Edit: From quick look again, it looks like your strings are in specific format. `&lt;optional day&gt;&lt;space&gt;&lt;month&gt;&lt;space&gt;&lt;year&gt;`. You could probably do something like regex match it beforehand and then create new Date manually.
I tried chronic, tickle, nikel but none of them worked.
&gt; how do I know whether a number is month or year, like Dec 12 &gt; &gt; Here 12 can be 2012 or 12 December What?! Do you not see the absurdity of your question, then? If *you* don't even know what date it is, then how is ruby supposed to know? The best you could hope for is to return a list of all possible matches.
&gt; I was going to tell you how until I realized you were telling me how ;) :) What would you suggest to newcomers?
Didn't work how, what about them didn't work? What did you try? 
Do you think programming is magic? 
Ruby won't match the performance of Java (jruby will get you closer, but there are some compatibility issues occasionally). It's an interpreted language with janky garbage collection (which is getting better though). Make sure you follow some performance tuning guides when deploying to the web server, and that you're using Passenger. What Ruby WILL get you is developer performance. Ruby is the "get s~~hit~~tuff done" language. It's very expressive and abstracts away a lot of the nit-picky boiler-plate type stuff you find yourself doing in most other languages. You will be able to quickly get your designs translated into executable code, and be able to iterate on those ideas quickly. Rails is the elephant in the room in terms of web frameworks for ruby, but there are others. Evaluate them to see how/if they fit your needs before jumping directly to Rails. Rails is good ... but it's big and may be more than you need ... but it also has a huge amount of libraries, etc... available from the community.
Thanks this was actually what I'm looking towards to. Most of my clients just need a simple website and Java EE seems overkill. 
Yuck. This approach gets really cumbersome really fast, not to mention you now have two models that you need to match the interface of (the real and 'Null' implementations). If you have a place where a 'Null' model makes sense, like the 'NullUser' from this blog post, then chances are you have something more meaningful than 'null' and should just represent it correctly. e.g. The 'NullUser' in this blog isn't a 'null' anything, it's an Anonymous User and should be represented as such, not as a 'null thing' with magic properties. 
Yes, Ruby is perfect for this kind of situation ... especially if you're essentially building a low-traffic site, you can probably just deploy it and forget it. Ruby can even handle very high volume, but you'll need to turn a careful eye toward caching and performance tuning. If the best-case scenario hits and you happen to build the next Twitter ... if you've been building with modularity in mind ... it's very easy to swap out the bottlenecked areas with more performant code. In my shop, we've got Ruby on Rails essentially exposing a JSON API which stitches together many other back-end services written in whatever language/technology that best suits their purpose. We started out with a "traditional monolithic rails app" that allowed us to quickly iterate on ideas. Once the functionality was nailed down, bits that made sense to re-implement for performance were taken one at a time.
I recommend rbenv over RVM, but either way you don't need gemsets for anything anymore, just use bundler with binstubs. 
Can you help me to get it right? [Ryan](http://railscasts.com/episodes/190-screen-scraping-with-nokogiri?view=asciicast) uses it as a rake task. But how do my rails app know it should run this rake task? Do I call it in a controller or in a view? And how to call it?
The "Looping over arrays" section really should be called "Iterating over arrays." None of those things loop. And then there's this: &gt; There is also a map! (notice the exclamation point) method which will modify the array directly, but in general the simpler version is prefered because it allows you to chain methods. The map! method allows you to chain methods just fine. And then this: &gt; Another thing that may come in handy is converting an array to a hash: &gt; `Hash["john", 1, "david", 2]` That's not an array, those are arguments. With an array: &gt; Hash[["john", 1, "david", 2]] TypeError: can't convert Array into Hash You need to splat the array out. Hash[*["john", 1, "david", 2]] Further, there is a very important difference between users.concat(new_users) and these users = users + new_users users += new_users `Array#concat` concatenates *in place*, whereas adding them with the `+` operator will copy them into a new array, even if you are assigning the result back to the original array. This distinction becomes very important performance-wise when you start dealing with large arrays. Overall a pretty sloppy article.
How many records makes a project large vs small? When should I consider stop using pgsearch?
Way back in the day, I found that writing a text adventure (like Zork etc) was an interesting exercise in design.
Another good place to start while your thinking of the project you want to start building is to go back and refactor some old code. Creating code from scratch and trying to massage non OO code into code that has good OO design are two different processes that benefit a programmer in different ways. 
It's true for long running processes overall runtime speed of Oracle's Java→JVM outperforms all known Ruby implementations, however for web applications, there are so many factors and other then programming language bottlenecks (db queries, caching algorithms, static files serving, http server tuning, …), that it often does not matter. Btw. JRuby likely won't get you closer, current ref. CRuby implementations found usually ~ 5-10% faster at my deployments. JRuby got the only upper-hand when run on java based Torquebox, so it was not about a ruby implementation but the underlaying framework.
That's a terrible example, because both `.concat` and `+=` modify the arrays in question. From my experiments, it [doesn't matter which one you use](https://gist.github.com/medcat/8b9da4b2718f841da9dc) in terms of speed. ~~I'm going to write another one to determine memory usage, though.~~ I updated the gist to contain memory usage.
Go is good for system programming. It's used in some popular up and coming projects like Docker. https://github.com/docker/docker/blob/master/api/common.go
Yep, Ruby really improved since REE 1.8.7 with the new VM and latest generational GC but unfortunately not yet near the performance of Google's V8 for Javascript, for example. 
Not O'Reily but Eloquent Ruby is a phenomenal book and well worth purchasing
Chosen from among the books to which this discount will apply: * [Ruby Under a Microscope](http://shop.oreilly.com/product/9781593275273.do) - ruby internals * [Understanding Computation](http://shop.oreilly.com/product/0636920025481.do) - theory of computation (using ruby) * [Ruby Cookbook](http://shop.oreilly.com/product/0636920032236.do) - a cookbook of another kind * [The Ruby Programming Language](http://shop.oreilly.com/product/9780596516178.do) - the other definitive guide, co written by matz 
Well ideally I want these to be usable anywhere in the shell. I use bundler's paradigm of using the require bundler/setup module to control the versioning of the gem. Unfortunately this results in the problem I described in the original post. 
If you are using bundler and Gemfiles, then you need to execute a shell bin as `bundle exec script_name`. That's how bundler works, I don't think there's any way around it. You don't need to use bundler, you can use standard rubygems system too. But then your code shouldn't ever be calling 'bundler/setup', you're choosing not to use bundler. If you have installed a gem, either using `gem install gem_name` or `bundle install` on a Gemfile including that gem, using default bundle args that will install to system... Then running `name_of_script` will always run the version from _latest_ installed gem that includes an executable with that name. This is how rubygems works. If you want to run a specific version that's not the latest, say version 1.2.3 when 2.0 might also be installed, you can run `name_of_script _1.2.3_`. This is also built into rubygems and just part of how rubygems works. You seem to be asking if instead you can have one version of the gem, say called `my_gem`, provide a script that installs with the name `my_gem-1.0`, and another version of the gem provide a script that installs with the name say `my_gem-2.0`. That is not the convention for how rubygems provide shell executables, *but* you can do that too, if you want, sure. Simply have the source for one provide a file bin/my_gem-1.0 that's listed in the gemspec under that name, and the source for the other use the other name. Again though, you probably don't want to be using bundler if you take this approach. Or, sure, you can just use two different gem names for these two different "versions", that might be simplest. 
/r/crystal_programming Enjoy.
Learn C.
Well, I think it's mainly the naming difference, AnonymousUser is more meaningful in terms of domain of the application than NullUser, it could be also a DeletedUser (e.g. in case the user cancelled own account, but the comment is still present) and many other usecases, but still it's about the same pattern. I wouldn't say it's cumbersome, actually, it works great and I find it really efficient. Sure, you have one extra model to maintain (or more models), but you can easily make it painless, e.g. you can use method_missing and return nil or some kind of generic null object for not implemented methods in null model, but for the ones that are defined in "original" model.
*Mind-Blown*
I would suggest scheme (or common lisp) to learn about computation (work through this: http://mitpress.mit.edu/sicp/), and C to learn about the machine. (Read K &amp; R's The C Programming Language). If you know these two languages moderately well, you can pick up most others fairly easily. If you are a Ruby developer, C is a good language to know since the MRI was implemented in C. 
Clojure would be good and pragmatic. Haskell is good as education. Anyway try some FP stuff. 
Learn something totally different. I think Java would just frustrate you, as it's conceptually similar to Ruby but a lot worse in virtually every way. Haskell is a great choice to learn functional programming, and is a more 'pure' FP experience than Scala, which has the mixed OO and FP paradigm. Scala is very easy to learn coming from Haskell, but the opposite isn't true, and Scala won't quite blow your mind like Haskell will. [This repository](https://github.com/bitemyapp/learnhaskell) is a great resource for learning Haskell.
This is mostly how I would have answered also. SICP is a great text to dive into functional programming and also introduces you to some relevant concepts if you decide to further study programming language theory. Once you're comfortable with that, moving to a low-level language like C will do a pretty good job of covering the remaining spectrum of popular languages. One note: I do think K&amp;R C is fairly detached from how most modern C is written, so if you do decide to pick it up, I'd suggest a companion piece like Learn C The Hard Way or 21st Century C. The ideas in K&amp;R are extremely valuable, but I found it wasn't enough by itself to prepare me to understand or contribute to a modern open-source project written in C. Once you are at least familiar with Lisp and C, you could start to investigate any of the new modern languages that draw inspiration from them. If you enjoyed Lisp, try looking into Elixir (especially since you know Ruby-- Elixir is a charming mixture of Ruby, Lisp, and Erlang), Clojure (for a strong Lisp flavor), Haskell (if you especially enjoyed the PLT concepts in the SICP book and are interested in type theory and formal proofs), or Scala. If you find you enjoyed C, you might check out Rust, Go, or Nim.
What do you think about Elixir? 
+1 for understanding computation. I especially recommend it to people who learned programming not in an academic environment. It's some of the really cool and interesting theory that you just don't get with the "hacking" way of learning.
Learn Node.js. Sure its JavaScript, everybody knows JavaScript right? The difference is Node is asynchronous and functional, so as far as learning new *ways* of programmer, you get two for the price of one. Finally, it's meant for back end programming.
Surprised nobody mentioned Python. I've been thinking of learning that, as it seems similar enough to be able to pick up quickly. 
It looks like the section on hash conversion was removed, I think that's a shame, you can't really master ruby arrays without splat.
I just contacted the event via the form. Maybe I can join a team remotely? I don't think I can make it on such short notice as I am going to be in Denver then doing the rounds and I am tapped out on airfare and bandwidth for rubycasts.io. Well maybe if someone wants to fly me out I could make it. If not I wish you the best of luck, the project is _awesome_
I have no idea why you got downvoted. I am in the same boat as you. I wont be able to make it but I'd love to contribute. Hopefully there is a way to allow remote teams.
But I really had the best time last year. Particularly in cooking together with your teams (Speaking of good: we taught someone to cook bacon for the first time) and the games night. Something amazing about events like *cough*dcamp*cough* this where you are stuck hanging out and interacting with the other attendees. Get to know folks you wouldn't otherwise. And yes, I am biased :-)
Denver? Let's hang out!
 Why are you being downvoted? Node is a great framework to learn. It's also very different from Ruby and Rails. If you are skilled in Rails and Node/Meteor/whatever, you will be a very well rounded developer. 
Why? 
&gt; assigning the result back to the original array. You are assigning the result back to the *variable*.
Not bad, but wouldn't that classify your first case as 4th of April 2006?
I second one month rails for newbies. GoRails (listed on the right hand sidebar here) is part of onemonthrails.
So for this case "sep 04 apr 06", I split it by space, take the count, if its even then divide by 2 and join. Seems confusing, I ll explain "sep 04 apr 06".split(" ") =&gt; ["sep", "04", "apr", "06"] ["sep", "04", "apr", "06"].count =&gt; 4 4 / 2 = 2 So split array from 2 only if division results in even number, ["sep", "04"] and ["apr", "06"] Finally join by space, so now I have two different dates.
what domain are you viewing it on? I would like to fix it if you are getting a real error
what domain are you viewing it on? I would like to fix it if you are getting a real error
WHY ARE WE YELLING!?
rubycasts.io
I absolutely agree on the C companion pieces, both excellent. In fact I would recommend those (especially Zed Shaw's Learn C the hard way) as primary material, and K &amp; R's as a companion piece.
Firstly, nodejs is a program, not a language. It happens to use javascript as a language on top of an event loop library. I think the poster is wondering what language would complement their ruby knowledge, or expand their knowledge of languages in general. I feel nodejs is inappropriate for that because it's not a language. If they were asking, "how can I better understand event loops?", perhaps mentioning nodejs would be a more appropriate answer. 
I'm in Denver as well and totally down!
First off, stop referring to yourself as a rubyist.
It's official: https://www.reddit.com/r/webdev/comments/356vq2/heroku_new_dyno_types_and_pricing_public_beta/
How cool is that? I was just about to move rubycasts.io to amazon so I can have background procs to remove my AR callbacks... Thanks Richard (for spreading the word!)
Anyone who is serious about having a website uses a pinger. Don't go spreading blame for an industry standard practice. Buy the $7 dyno.
&gt; free dynos are allowed 18 hours awake per 24 hour period
Right. So it's essentially less free for very small instances. Guess I'm standing up a VPS this weekend.
If you move away from using bundler, then yes, you will miss out on using bundler's dependency management. You'll wind up with the script using whatever the most recent version of the gem installed on the system is. Or you can use rubygems own (without bundler) method of requiring dependencies, eg: # in your actual script source code, not a Gemfile gem "some_gem", "&gt;= 1.0", "&lt; 2" However, there's a reason bundler took off, rubygems (without bundler's) own dependency management system isn't really powerful enough. If you don't use `bundle exec`, then if you execute `my_gem`, and `my_gem` is an executable installed by a gem, you will always be executing the one from the most recent version installed. But okay, you name the scripts "my_gem-1.0" and "my_gem-2.0" to get around that. Then, when your script calls 'bundler/setup', it will look for a `Gemfile` in your _current directory_, whatever directory you are in in the shell. Or possibly any parent directories of that dir, if a Gemfile is not found locally. So right away, that's not quite right for a command line executable you could be calling from anywhere. Who knows what's going on really. You could try setting `ENV['BUNDLE_GEMFILE']` to the Gemfile you want to use to resolve dependencies, set it _before_ you call `require 'bundler/setup'`. Maybe that'll work. I dunno. In general, bundler doesn't work how you want it to, sorry. You might be able to hack it out, if you understand what's going on. Done my best to share what I know here. Good luck. 
It looks like you can use cloudflare to do url redirection too https://support.cloudflare.com/hc/en-us/articles/200172286-How-do-I-perform-URL-forwarding-with-CloudFlare- it would probably be cheaper than digital ocean if price is your main concern. If price isn't your main concern, then you're only saving $2 per month per app.
Brainfart, sorry.
I can't find it now, but I could swear I remember a previous reddit thread where someone wondered if heroku considered pinging a violation of terms of service, and a heroku staff person said 'no'. At any rate, I'm sure they realized that just counting on people to "please don't ping" didn't make sense as a service model. The new one makes a lot more sense, relying on technical limitations in heroku itself, instead. But unfortunately mean if you have a small hobby project which might be up more than 18 hours in any 24, you're $7/month instead of free. $7/month is a pretty darn reasonable price, but there's a big psychological jump from `free` to anything at all, I know I have things I'd put up as public service experiments for free, but not for anything non-free. 
If your app needed only one dyno, you could get by with 'entirely free' before, and use a pinger to keep it up 24/7 without 'wake from sleep' delay. It is quite true you can no longer do this. If you need an app up 24/7, you've got to pay $7/month. Which is cheaper than the cheapest dyno before, but sure ain't free. It is painful to me because setting up my own VPS is a lot more work (and still not free, but I guess cheaper than $7/month?). But I'm sure heroku won't exactly mind losing our non-paying 'business', if you were all free before they were paying for AWS for you and not getting any money from you anyway, they won't miss us! 
i'd love to see source too, really nicely done!
An aggressive take on Conway's game of life
I have to agree with above but I would recommend different books since they're a bit more beginner friedly. Build a LISPy language with Ruby with the computation book http://computationbook.com/. C Programming: A Modern Approach http://www.amazon.com/Programming-Modern-Approach-2nd-Edition/dp/0393979504
Thank you :)
How do you know when you are testing too much? When your tests are actually a net negative, meaning that more the amount of pain they save, they cause even more pain. Here are some tips: - rarely test private methods - if the test is complicated to write, this is a nice indicator that there might be an extractable object inside of the class you are testing - instead of blindly writing tests like a well-behaved TDDer, first think about what it is and why you are testing it this way. If you do know really know the answers to this question, you are probably writing garbage test cases. - recognize that tests are not a panacea, and the permutations of outcomes in certain algorithms will have might make attempting to test all cases a useless venture. Sometimes it is better to write an informal proof, and create compatibility tests. An example of this would be many types of concurrent algorithms.
&gt; I'd be wary of generalizing an entire subreddit as having a single stance on a matter. Generalizations are dirty, but when talking about general ideas, they are par for the course. I figure that the entire lisp world does not agree with what I was told, but I was still disappointed. And Emacs, one of the most iconic lisp systems in use today, displays a somewhat introverted attitude. &gt; Chicken Scheme I did not look at scheme, but strictly at common lisp implementations. I do not remember why. Would you say scheme is acceptable for learning and using lisp? &gt; a 25kb binary is acceptably sized. I completely agree.
maybe run Docker and use it like a simplistic on-prem Heroku. you should be able to find a preinstalled AMI or ISO. I'm sure there's VPS providers that can one-click provision a Docker host OS.
That was my point and why I moved to a paid plan :)
A) That pinging is against heroku rules. I emailed and it is not. B) That 'pingers' are somehow 'wrong' and causing you to lose your 'nice stuff' Your words not mine :)
I'm curious what you're finding painful when it comes to reusing step definitions. Ate you finding that you're using a generic step like "When I Save" and then the existing definition doesn't apply in this context? If so, the spinach gem might be a viable replacement. 
Curious to hear about how your total cost changes moving everything to DO vs what you were paying on heroku vs what you would be paying under the new heroku pricing. If you do it, you should blog the numbers! 
I'm not sure what your use case is, but $7 is nominal, and if you need to have it up 24/7 then it's probably worth it.
This is nice for me because I get a worker process. My startup is doing a kickstarter soon, and we were going to move to AWS after that anyway, but now we get to test out some of our (non-essential) background job stuff in production before going to Amazon. That's pretty nice. 
Curious, what's the main driver behind the AWS move plans?
I guess it is step definitions design problem... Do you now good examples/open source projects with Cucumber? I've seen some of the projects, but those are not what I need. And thank you for telling me about this gem, I will try it out. Also, could you please tell me more about this generic step "When I Save" you mentioned? I've never heard about it. Thanks.
also the thin line where you're testing stdlib or gems more than your own app.
FYI: A line-by-line breakdown of Konstantin Haase’s Sinatra refactored in six lines of Ruby from yesterday’s Vienna.rb talk. Also available as an [all-in-one-page version](https://github.com/geraldb/talks/blob/master/almost_sinatra.md). Get inspired and build your own microframework. The world needs more New York, New Yorks, Nancies, Rums, Cubas, etc. Cheers.
Doesn't seem to work... I have three heros now, but can't choose one of them, because it's not mine... So, where can I submit a bug without using twitter? 
I've played through all the levels using the instructions at the github page, and they've worked well for me. AFAIK that game came out afterwards so not sure. 
Welcome to the ruby community! We're happy to have everybody :)
It's definitely nice to have the visual engine of modern web browsers under Ruby control.
Dunno. You can get a 5$/mo Digital Ocean VPS which gives you more control and better performance for less money. The only downside is you must manage your setup and administrative tasks yourself, which is no big deal, for me at least.
Fascinating!
I'll break down a few options for you. it looks like Amazon bandwidth is not included. I'd consider my personal server to be "busy for a private server" and it would only cost me $7-10/mo in bandwidth. I worry about usage-based billing as an attack vector. if you use AWS, **configure billing alerts**. also, turn on two-factor auth. 1) you could use a t1.micro, that's only $15/mo or $8.50/mo if you buy a 1-year chunk. I think AWS Free tier will cover that, but the free tier expires after a year, so expect to pay it. a t1.micro only has ~700MB RAM. you should be able to run a database, reverse proxy and 1-3 Rails apps on that. 2) if you wanted to splurge, a t2.medium is $40/mo or $25/mo for 1 year. ($25/mo? I'd buy two!) 2 vCPUs and 4GB of RAM makes this a low-end workhorse. you could run a few different data stores (Postgres+Mongo) and a dozen or more applications. you could even use it as a personal VPS and run random services for yourself and friends (Mumble is easy and very useful!). I'd probably buy 2 and experiment with HA, but I'm an Ops nerd. 3) you could use a non-AWS provider. there's a lot of them. I've always been impressed with Linode's pricing, upgrade schedules and operations. I have a few friends who swear by DigitalOcean ([they support CoreOS as a one-click install...](https://www.digitalocean.com/features/linux-distribution/coreos/)) generally, the $40 plans are roughly equivalent: 2+ vCPUs, 4GB RAM, 40-100GB disk, 1TB transfer (aka: way more than needed for most projects). the bandwidth allocation is much more comfortable. these smaller providers are also tend to have a better customer service experience, so minor overages have a better chance of being forgiven :P 3.5) [OVH has a budget brand with dedicated servers starting at $42/mo.](http://www.soyoustart.com/us/essential-servers/) it would be very similar to running a VPS but with a lot more lead times. probably wouldn't be able to push a button and reimage your server if you totally break it. but for $45/mo, you get a *ton* of machine: 4 core+16GB+2TB in a datacenter is a full-fledged Hacker Utopia! you could run 3 Docker VMs and give 2 to your best friends! personally, I use a colo. $40-80/mo is enough to lease 1U of datacenter floor almost everywhere and you can cram a **fuckton** of computer into 1 rack unit. there's a very large capital expenditure to buy a 1U server and you're personally on the hook for replacement parts/service... but it's probably the absolute best value in terms of dollar per compute unit.
Interesting perspective, thanks for sharing. Could you expand on how Opal makes Ruby worse? Are you referring to the experience of programming in Opal?
I will. Right now it's look like $10/mo for DO and $35/mo for Heroku.
Github pages might be a nice alternative for hosting static html. Jekyll should integrate nicely, since that's what GH pages is built off.
Activerecord-import is an awesome gem but there are some gotchas. It skips callbacks, so if there are any callbacks you actually need, you will need to run them manually. 
I like ruby, with all its flaws. I like JS, with all its flaws. The problem with coffeescript, typescript, opal, etc is that it still executes as JavaScript. You still have to understand the DOM. You still have to understand eventing. You still have to debug production errors in JS. It's like coding with one arm in a bucket of shit, and debugging with both tied behind your back. I stopped fighting JS and embraced it. Life is much better. I encourage everyone to do the same, until there is another alternative which executes natively in the browser. That's my $0.02.
I agree to a certain degree, but the introduction of source maps helps alot with the "write in X, debug in JS" problem. 
If you want to stick to Ruby on Rails long term, it might be helpful to learn Ruby before learning Ruby on Rails. I'm going to recommend the [Pickaxe, or the Pragmatic Programmer's Guide as a big one](https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0). It's a well written book that will get you started and bring you pretty far with Ruby, which will give you a pretty strong foundation to start with Rails. From there, it's a good idea to move onto [Agile Web Development with Rails 4](https://pragprog.com/book/rails4/agile-web-development-with-rails-4). Focusing on Ruby before Rails, [Eloquent Ruby](http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional-Series/dp/0321584104) is also a very nice resource to use as well. If you're not following the [Ruby Rogues podcast](http://devchat.tv/ruby-rogues/), they put out a really great podcast on various topics in Ruby, especially those more focused on the developers, rather than the language. The podcast on [Pair Programming](http://devchat.tv/ruby-rogues/026-rr-pair-programming) is one of my favorites, and if you haven't pair programmed before, doing so will really make great strides in helping you learn Ruby and Rails. Try out the [Ruby Koans](http://rubykoans.com/). One of the best ways to learn a language is, well, to use it.
It gets worse -- the timeout can trigger and raise when code execution is already in the middle of the ensure block. Then the remainder of the ensure block will not be executed, same as any other exception raised in an ensure. It's easy to demonstrate this possibility: require 'timeout' Timeout::timeout(1) do begin ensure puts "start of ensure" sleep 10 puts "end of ensure" end end
[**@katelynjperry**](https://twitter.com/katelynjperry/) &gt; [2015-02-27 02:24 UTC](https://twitter.com/katelynjperry/status/571133621597179904) &gt; the first time i made bacon was at @RubyforGood which is an unexpected skill for a conference/hackathon but the world is cool that way ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Indeed. Timeouts in `ensure` blocks caused the Ruby MongoDB driver to leak connections from its connection pools for a while, for example. https://jira.mongodb.org/browse/RUBY-473
and here's the minitest: require 'minitest/autorun' require_relative '../lib/date_munge' describe DateMunge do it "returns two text dates as 2 date object" do returns = DateMunge.parse("sep 04 apr 06") first_date = Date.parse('2004-09-01') second_date = Date.parse('2006-04-01') returns[0].must_equal(first_date) returns[1].must_equal(second_date) returns = DateMunge.parse("may 2006 may 2008") first_date = Date.parse('2006-05-01') second_date = Date.parse('2008-05-01') returns[0].must_equal(first_date) returns[1].must_equal(second_date) end it "turns one text date into a date object" do returns = DateMunge.parse("since oct 11") date = Date.parse('2011-10-01') returns[0].must_equal(date) returns = DateMunge.parse("29th may 2005") date = Date.parse('2005-05-29') returns[0].must_equal(date) end end
Dude if you want to be taken seriously as a multidisciplinary software developer, do you think calling yourself a rubyist is a good idea? Sorry I don't subscribe to the happy sunshine and farts of the ruby community, but I don't think what I'm saying is a bad idea.
Significantly cheaper, by our estimates. 
Always interested in cost break down blog posts. Server costs are easy to calculate, people costs and productivity are big variables. Keep us posted.
You have completely missed the point. Imagine that that `ensure` is 8 levels down your stack in a driver library somewhere, and you've wrapped a call to a DB operation in a timeout block. That `ensure` is responsible for releasing a leased connection back to the connection pool, except your wrapping timeout raises an exception in the thread while the driver is in the middle of what it believes to be a guaranteed release. You've just leaked that connection, and if you're using thread-pinned connections, that entire thread can never lease another DB connection. At no point in the `begin` block does the library expect throw a timeout exception, so it obviously doesn't attempt to handle exceptions it doesn't throw. Timeout throws exceptions at arbitrary points *in other threads*. jrochkind's example is a correct minimal case of where a timeout in business code could critically break library code, for example. Timeout is evil.
I love Opal. [I made a game in Ruby that runs in the browser.](http://domgetter.github.io/dare/tutorial.html) [Here is the source code of that game.](https://github.com/domgetter/dare/blob/master/examples/tutorial/tutorial.rb) [Here is how to make a game yourself.](https://github.com/domgetter/dare/wiki/Ruby-Tutorial)
Thanks for showing me the existence of /r/learnruby. I didn't see it linked in the /r/ruby sidebar so I didn't know it even existed. And thanks for the advice. I'll try to just get used to leaving out the parentheses. 
Thanks for correcting me. I'll start calling them methods from now on.
I like what /u/_Garuda (please tell me this is from Ace Combat) mentions in regard to methods that do not accept an argument. Also, the more Ruby way would be to have a method name formatted as follows, in snake_case: def my_function puts "Its mine!" end def my_function(name) puts "It belongs to #{name}!" end
Use the parenthesis when being explicit is important, or to guide code readability (think multiple nested if conditions). Ultimately if it makes sense to you, and you can do it consistently, I say go for it. This is a style thing, and everyone you ask will likely have a new opinion
You could also check out the [Ruby Style Guide]( https://github.com/bbatsov/ruby-style-guide) as a quick reference when you're uncertain and don't have a personal preference. But don't worry about it for now. Those are relatively minor details. Don't sweat getting your style right while you're learning. Just keep learning.
I phrased it badly, but I meant all "functions" are methods.
Use the parentheses or don't, it's really up to you. Eventually, you'll find times when it makes sense to and times when it doesn't. I think most Ruby programmers would opt not to use parentheses in most cases, but your code won't really stand out if you use them when they're not necessary. Personally, I never use them when defining a method with no arguments, and always use them when defining a method that does take arguments. For calling methods, I only use them when it's really necessary or improves clarity. One thing you really should get in the habit of though is using snake_case for method names instead of camelCase. This convention is nearly universal among Ruby programmers, and your code will look funny if you don't follow it. Besides, having come from using camelCase myself, I think snake_case is way more readable and flexible.
We might use heroku. We're a two-man shop and planning on working quite a lot over the summer. On the other hand we have almost no money and we need to stretch our cash as much as we can. 
Some things in Ruby aren't materialized into objects by default: blocks are distinct from the `Proc` instances you can create from them, and methods are distinct from the `Method` instances you can peel off an object.
There are a couple different ways to use the term. For instance, in C# everything is a method (you can use static classes if you want something like functions in other languages) but people talk about "pure functions" being methods with no side effects.
There are times where you'll get around some self-inflicted problems that way. class Ambiguous def x; 1; end # A method named "x". Always returns 1 def test puts x # No variable has been seen; refers to method above: prints 1 # The line below is never evaluated, because of the "if false" clause. But # the parser sees it and treats x as a variable for the rest of the method. x = 0 if false puts x # x is a variable, but has never been assigned to: prints nil x = 2 # This assignment does get evaluated puts x # So now this line prints 2 end end &gt;Flanagan, David; Matsumoto, Yukihiro (2008-01-25). The Ruby Programming Language (Kindle Locations 2669-2674). O'Reilly Media. Kindle Edition. Try sticking a puts x() at the end, see what you get. Including the parenthesis with a method that doesn't take arguments will tell Ruby that it's dealing with a method and not something else like a variable.
Then there's your first problem. E2e tests should be used *sparingly*, with the majority of things tested at a lower level. Ensuring good test coverage, maintaining tests and debugging code via e2e tests is an absolute nightmare! 
&gt; Also, could you please tell me more about this generic step "When I Save" you mentioned? I've never heard about it. Thanks. I think you misunderstood... 
Ah, I've finally got the point. You are probably trying to say, if you blindly apply something you don't quite understand, it may break the code. But this is not revealing and not specific to `Timeout` class and its methods. Once again, `ensure` *does not guarantee* it won't be interrupted by an exception, any. Your 8 levels deep ensure block may left unfinished due to other exceptions like IO errors, trapped OS signals, thread errors etc. No, Timeout is not evil when applied knowingly.
I've actually been thinking about this a fair bit recently. For beginners, it can be pretty confusing because, as you said, function calls and variables have identical syntax. The conclusion I came to was that it's probably easier if you always put the parens on the end of functions while you're learning. Functions and variables are two separate things. They behave differently, so they should look different. Once you feel you have a stronger grasp of the language, you can stop using the parens so that you fit in with the most popular style of the community. No need to rush, though. People here will tell you the opposite, because that's what they're used to, but I think they've forgotten how difficult it is to learn your first programming language.
The main reason why I prefer to omit the parens in argument-less methods is demonstrated in this great video: http://devblog.avdi.org/2012/10/01/barewords/
HA, now this is funny - I've heard people mention camel case but never actually knew what they meant. I've always used snake case in linux/sql etc so just defaulted to that. Thanks for the info though ;)
I wouldn't bother using /r/learnruby - it's dead in there. Don't be afraid of asking questions here, we're usually more than happy to help.
When you contribute to an existing project, adopt the project's style. If you're not collaborating, then style is much less important.
I hardly ever use parens in ruby.
I'm with you. Javascript has some neat aspects to its' design, but ultimately it's got too many quirks to be an effective language to design and implement larger applications. Some of the problem is being weakly typed, but I constantly find it clumsy to use lexical scope to encapsulate object state. Ruby is a better programming language. I applaud Opal's efforts.
Good point. The 44 lines is the "unobfuscated" break down. The original version is six lines (with a limit of 200 chars per line). Almost Sinatra is less than 999 bytes. Cheers.
I don't understand why you would bring up that acronym (I actually had to look up what it means, that's how fucking stupid it is) and then not give a shit about it. People like you are fascinating. Are we done yet? Sorry I hurt your feelings. Let's have a hug and shake hands. That's the Ruby way.
Thanks
What's the volt framework? 
grape is one of those ghastly "hey guise i'm a DSL lol!!11!1!" type libraries. Unless your code is extremely simple, it ends up looking like a mess in grape IMO
2007 was first time I heard about Ruby.
You're comparing a string to an integer, so you either need to convert the integer to a string, or the string to an integer: puts "What's 3*3?" math_answer = gets.chomp if math_answer.to_i == 9 puts "You smart boy, cuz it's indeed #{math_answer}!" else puts "Dude wtf" end 
Can't spell "grape" without "rape"
Thanks, will give that a try
Every time I come here and see how little activity there is on the /r/ruby sub, I feel like Ruby is going the way of the dodo. Where are all the Ruby people? Edit: down voted? Really? 
Probably node, as that was the "hip replacement" for Ruby. Others are probably doing Clojure. I'm looking forward to nim personally
I know of at least a dozen large (read: 30+ dedicated ruby developers) shops around town, and that's just in my local city. I get ruby job offers enough that it's totally annoying. Maybe it's just that this sub doesn't get much traction.
I'm not proficient, but this would be a good project to learn with. I'm in. 
Cool! Post a thread on the forums and enjoy our wonderful community, welcome to the team! :-)
Making a GET request is a lot easier than what you're trying to do. `require 'open-uri'` then `open(url)` - no Gem required. Submitting a login form, though, would be a POST request. I personally haven't tried the Mechanize approach but that's awesome if you can get it to work. If you haven't already done so, you should read about APIs. If the website you are scraping has an API, it might be easier. I'd bet there's sites out there that will block your IP address if they detect you logging in programmatically.
Your question is answered already but github gists were created to share code snippets!
Rake tasks are usually run in the terminal with `rake &lt;namespace&gt;:&lt;task&gt;` ie. `rake db:migrate`. If you want your system to run them on a schedule, you can use the [ whenever ](https://github.com/javan/whenever) gem. From [this] (http://stackoverflow.com/questions/5641747/rails-how-to-run-rake-task) stackoverflow post it appears the syntax to run them from Ruby (like a controller action, etc) is `Rake::Task['task_name'].invoke`. You could also initiate the shell command from ruby such as `exec(rake namespace:task)` (See [here](http://tech.natemurray.com/2007/03/ruby-shell-commands.html) for how to send system commands from ruby)
Beginner ruby programmer, would love to work on this project just not sure how much value I could provide.
Anyone helps! Im sure if you give it a try, theres definitely something you could do. :) go ahead and go to the forums, they would love to talk to you. :)
I am also interested in helping but after spending some time looking through the forums I honestly have no idea how to get started. It looks like that info is scattered across multiple forums and posts. Maybe I'm just bad at navigating forums, but I find them to be messy and chaotic when it comes to searching for information. I suggest gathering everything together in one place and making it easy for people to contribute. Links to download all resources, guides on how to get started, lists of development goals, progress updates, links to forums for each development goal, etc... Use the forums as support for the main development page, not as the development page. If this already exists then it should be made easier to find and you should point new developers in the direction of that instead of the forums. edit: I guess the point I'm trying to get to is that if you want more people to help, you need to have things organized so that they know how to help and can get started with the least amount of resistance.
Thanks, you mind if I copy your post and show it to the mods? I totally agree with you there. 
I would put it on GitHub if I wanted people to contribute. *Also, I'd be down to contribute but not if I have to purchase something to do it. RPGMaker doesn't appear to be free.
It's an impressive website. It used to be damn awful a few years ago, but its very nicely designed, easy to navigate and to read and very consistent now.This is a great example of what is achievable with the right team.
Yes it really is vastly improved from where it was.
I just completed a 9 week dev bootcamp mostly centered around RoR with zero previous experience coding, but here's my 2 cents. The CTO of the bootcamp said Rails was excellent to learn, because even though it's not as sexy and hyped as some JS frameworks are today, it's rock solid, its effectiveness is tried and tested and the Ruby dev community is great. Also, it's a framework used by many startups, so if you're interested in working in that world, it's an asset. On a personal note, I really like working with Ruby because of its elegance. There's just something really simple and intuitive about its syntax and general logic and I find it much less tiring pouring over Ruby than languages like JS (but then again, we didn't have much JS training so it might just be that I'm not used to it). I'm looking to learn JS in the near future, is there any ressources you recommend? Has anyone tried the team treehouse JS courses?
Rails is still used in many projects and many of the companies that started using it during the 'hype' are still using it. It's now an established technology stack and most likely that's better than being a hype if you want to get some actual work done with it. I still see a lot of gems and libraries being developed and I have no problem to get bindings and whatever for relevant technologies like say Elasticsearch or other NoSQL databases. A lot (as always) depends on what exactly you want to gain from your next learning step. If you have a specific project in mind then the best technologie for this may or may not be Rails. node has it's strengths in some areas. But depending on your expected hype level even node may already outhyped and you want to look at things like Elixir with the Phoenix framework (you would be ahead of your peers at the next local meetup for sure). 
Honestly, not sure that's the good way of approaching the problem. If you are looking for popularity (supposing we are talking web development here), you should learn C# or PHP (or Java, but you know that one already). Those language are still vastly more popular than Ruby/Node/Python/Whatever. After, I'm not sure what "worth learning" means. I think Ruby is different enough from both languages you know to make it interesting, but other languages will probably be even more different - have a look at Clojure for example. About Rails, it's no more a Hipster framework. It's stable and mature, which can make it "boring" to a lot of people. The ecosystem is great (documentation, libraries, etc), and it's still very good for its sweet spot: quick development of database based web applications (not saying it cannot do something else). If you like the Ruby language but want something simpler &amp; more flexible on the web side, have a look at Sinatra. If you want Ruby all the way down, look at Volt.
That's expected behaviour to me. I do: begin Timeout.timeout(1) do ensure puts "start of ensure" puts "end of ensure" end
Rails has passed the hype phase where everyone talks about, some people experiment with it and a few companies actually use it. The next phase, where I think it still is, is when people stop talking about it (it's no longer cool) but a lot of companies actually start using it. The result is an imbalance that favours people with knowledge/experience. While I don't think you can go wrong with either choice I would personally do Rails + Angular.
The problem is that you have to know the complete call stack below your timeout. If you are calling some_gem.some_method, you need to know what it does; if it calls other_gem.other_method and third_gem.third_method, you have to know what they do. Etc down the line. If any of them do anything in an ensure meant to clean something up, such that if it were interrupted Bad Things would happen -- it's not safe. This is not easy to figure out. Once you've figured it out, every time one of those dependencies (anywhere in the tree) releases a new version, it might change the analysis. Of course Timeout is fine when it's fine. The problem is that it requires non-local knowledge to know if it's not fine, and in 'not fine' cases you get race condition hard-to-reproduce occurs-occasionally hard-to-debug hard-to-understand bugs. Somebody else posted this example: https://jira.mongodb.org/browse/RUBY-473 I'm not sure why some in this thread are getting so aggressive in impugning the competence of those pointing out the risks of Timeout. Why are you taking it so personally? The risks of Timeout are well-known and have been discussed for years, but are easy to forget. 
It all depends on your motivation for wanting to learn. If you are looking to get something off the ground quickly that's going to be back end heavy, there is nothing better than Rails imo. I've been teaching it for a few years now, and it's the best for anyone looking to learn a server-side framework, if you know absolutely nothing or if you've been programming for years. That being said, I've switched to teaching javascript, because as someone already mentioned, it is ubiquitous across all browsers, and increasingly being used for other endeavors as well. My question is, when you say you "know" javascript and java, does that mean you've piddle around with them? or you have experience building projects with them? If it's the former, I'd say switch to Ruby on Rails and actually build something. If it's the latter, I'd say jump on a javascript SPA framework and developer your skills there. Let me know if you want some free resource, I have plenty for rails.
If you call code from any external dependency, which itself calls code from it's own external dependencies (wash rinse repeat)... how can you know whether that code "expects to be interrupted by timeout exception"? The attraction of `Timeout` is that it can be called on any arbitrary code that might take too long. If you constrain it to only being called on code which 'expects to be interrupted by a timeout exception', you probably will never be calling it on any code that includes any calls to logic from external dependencies, because you'll find few external dependencies with methods documented to expect such. Often you want to use Timeout on logic from an external dependency doing some kind of I/O. From database to http to mongodb, whatever. If the people writing such code were going to document that it expected to be interrupted by timeout exception, and very carefully make this so -- it would probably make more sense for the library method to simply provide a 'timeout' argument itself. Which is exactly what the OP recommends. If the library method providing a 'timeout' argument implements it internally with stdlib Timeout, that's it's own business, and could work, as long as it does it very very carefully (taking account of any logic it itself calls from external libraries, which may not be written to expect being interrupted by a timeout exception). Also, writing code to expect being interrupted by a timeout exception can be pretty tricky -- you probably start out by adding an ensure, then you have to very carefully consider what would happen if a timeout were raised after every line of code (or even in the middle of a line of code? I'm not sure if this is possible), and what you can do to prepare for that. 
We use PokeEssentials for the most basic work, and right now we are attempting to gather information to better serve coders like you. We have a dropbox with all our scripts, and as many coders have came and gone it has been a bit of a big bag of code. The mods know what is done, but not exactly where it is.
It certainly isnt closed per se, alot of work goes on in the background. We are aiming to reform the development of our game to be more transparent and friendly to coders.
IRB is the default with Ruby which is OK. A better alternative is [pry](https://github.com/pry/pry) which is like IRB on steroids... pretty colors, a ton of additional features...smarter all around. To install pry, run: gem install pry gem install pry-doc Then run `show-doc Integer#times` which reveals docs something [like this](http://imgur.com/A6teKph).
http://elixir-lang.org/ It looks like Ruby, but it's pure-functional, faster, has features Ruby doesn't have, and has way less cruft than Ruby, as well as being potentially massively more concurrent. It is also gaining steam. [Phoenix Framework](https://github.com/phoenixframework/phoenix) is a Rails-analogous web API written in it.
Perhaps. I have a module which represent 'Page Object'. This module has multiple UI oriented actions that this page is able to do like `fill_data`, `click_next`, `generate_table` etc. If all I want to do is to 'generate_table', there is no reason why my `fill_data`needs to be included in the object. However, I'm not sure I can make it any less tightly related? 
Thanks, that works, why does it happens though? I also don't have many methods documentation when using yari for emacs, and that I would like to use.
I know there have been a couple prior projects doing very similar, which were popular for a while but fell out of favor, but now I can't recall what they were. You mention being dissatisfied with existing options, it might be helpful if you listed them so people could compare for themselves. Or maybe even outline the different choices you made from those. 
You should consider using amazon Web services s3 in combination with route 53. It will likely be far cheaper than using digital ocean with nginx or others, though once you get more traffic you will start to pay somewhat inflated prices. 
Elixir is cool, but it's still very immature in terms of ecosystem and adoption. Not a great choice if you're looking for applicable job skills. 
Elixir looks like Ruby but is *not* purely functional, is *not* faster^* and does not seem to have less cruft, if you mean it gets in your way at solving problems or deploying your work. ^* At least on microbenchmarks like calculating nth Fibonacci number. On the same machine Elixir/OTP Erlang 17 was about 50% *slower* then CRuby 2.1. fib(N) -&gt; fib(N,0,1). fib(0,Res,_) -&gt; Res; fib(N,Res,Next) when N &gt; 0 -&gt; fib(N-1, Next, Res+Next). erlc +native +"{hipe, [o3]}" fib_test.erl vs def fib(n) curr, nxt = 0, 1 n.times { curr, nxt = nxt, curr + nxt } curr end Quite disappointing. I'm not arguing Elixir/Erlang is slower then CRuby or JRuby, but your statement about being faster is unsubstantiated, at least. Btw. by The Computer Language Benchmarks Game above language implementations are on par so ideas about rewriting Ruby based code to Elixir to gain speed are a bit naive. Speaking about raw speed. In specific cases where Erlang's concurrency mechanism can be fully utilized, it may change the game. 
If you don't put the argument in quotes, irb tries to evaluate the expression before passed to help command. In your example it was evaluated as `Integer` and comment `#times`, which was discarded. Correct syntax should then be `help 'Integer#times'`. 
Thanks for the comment! If you want to help, you can talk to either ImmunityBow or Cynadile, our head developers. They really love the game and haven't given up yet, if you send them a private message one of them should get back to you soon. I really love the enthusiasm you guys have for this project, thanks Reddit!
I think so, [SO](http://stackoverflow.com/questions/11370393/amazon-route-53-setup-and-301-redirection-setup) post on it.
Are you sure that you are using the correct ruby under emacs? Does M-! ruby -v display the version string you expect?
Really? How/where? Seems like nobody in the city I live is interested in ruby (EU). Only a couple of companies officially say that they do it, but they're not hiring at the moment.
i don't believe anyone has asked for Timeout to be 'fixed' in the OP or in this thread. Although, actually, it _was_ improved with regard to these issues in ruby 2.0. I'm not sure how well the additional interrupt control tools work, I'd never heard of them until this thread and haven't tried them. But apparently someone in ruby core agreed it was difficult to use Timeout correctly prior to 2.0, and thought it was possible to improve things. Ruby core committer Koichi Sasada agrees that interupts in ensure blocks are a problem, disagreeing with you. https://bugs.ruby-lang.org/issues/6762 Ruby core team was a lot less defensive than you are being, they didn't try to convince everyone that there was nothing to worry about and improvements would be useless. koi wrote: "Thank you for addressing this issue. ensure clause behaving properly is most important to me." Anyhow, the issue is that Timeout used in a lot of code by people who don't understand or don't realize the impact of it's extreme limitations, so education is needed. I knew how Timeout works; I've still used it in places I shouldn't, and had to go back and debug mysterious bugs. So I needed some education too. I think probably almost everyone who has used Timeout has used it without fully thinking through the ramifications of ensure blocks being no longer guaranteed to run. Multi-threaded concurrency can be tricky, and as soon as you use Timeout.timeout, you're doing concurrent programming. Worse, gem writers may not realize the issue, and suggest Timeout use with their gems in an unsafe way, or avoid providing a save 'timeout' argument (which is needed with ALL I/O code to avoid the possibility of your code hanging forever on I/O), figuring that wrapping with a Timeout.timeout is good enough. I agree with the OP that as a general rule, I/O operations ought to provide their own timeouts, in safe ways often using timeouts in the underlying C libraries where possible, or else with ruby stdlib Timeout in very carefully audited and tested isolated code -- not rely on the user of the gem to wrap in a Timeout.timeout. Even some of the stdlib does not do this however. Many people have made Timeout-related concurrency errors, including experienced skilled programmers, the mongo adapter issue was another example, where mongo adapter was _not_ safe to be used in a timeout, but clients were encouraged to wrap it in a timeout. https://jira.mongodb.org/browse/RUBY-473 I am confident the errors will keep coming. But yes, this is how Timeout works. The solutions are: educate people on the dangers of timeout; make sure low-level timeouts from C libraries are exposed in ruby API's; investigate those newer ruby 2.0 interrupt control features, I dont' know enough about them to speak to them, they haven't gotten much coverage in English language blogs, but maybe need more too. The first two of those is what the OP recommends. If in your defensiveness you're trying to convince people that they don't need to pay any attention to the very dangerous concurrent nature of Timeout.timeout, you are not doing them a service. PS: The documenttation for ruby 2.0+ Thread.handle_interupt even uses protecting your ensure block from Timeout as an example. I need to experiment with it, never heard of it before this thread, but maybe what we really need is more education on wrapping your ensure blocks in handle_interupt, which also suggests to me maybe they ought to be by default. http://ruby-doc.org/core-2.0.0/Thread.html#method-c-handle_interrupt
Sorry. Just saying the original version is six lines. Why the magic number six and not seven or fourty-two. I don't know.
I solved by building the docs with rvm.
sure
Did you just use `rvm docs generate`?
San Francisco. And my company hires contractors from Colima.
I'm a database consultant. It would be very helpful in my line of work to know more about my clients' applications.
You are free to post your version. This is best comparable implementation I've got. 
Yes. The thing about learning languages is it almost inevitably expands your skill as a programmer. Adding another tool to your repertoire usually doesn't hurt. Now the unspoken question in this is probably related to work and or job availability. I can say for example, in my area near Chicago, Ruby and Rails developers are in extremely high demand and making very good wages. 
Super trivial but super handy. I saw this other gem for plucking to a hash was trending, so I figured why not, this is less loose, much more fun and efficient.
The Erlang VM doesn't perform well for CPU intensive tasks and Elixir is not as expressive as Ruby. Besides, I think you should stick with Erlang for now.
They're all on Twitter 
Curious, what's the pay like in london for a mid/senior rails dev?
Are you thinking of [Inherited Resources](https://github.com/josevalim/inherited_resources) and the like? My take on these sorts of gems is that they are fine for the general case, but things quickly fall apart once you have to do something clever. And then all your time is taken up either working around the limitations of the gem, or trying to figure out how another team member did the same. Speaking from experience, I think if you're favouring DRY controllers over readability and maintainability you'll end up burning yourself or your team. Having said that, this gem looks relatively simple and possibly easy to override in the worst case. It doesn't appear as opinionated as similar solutions. There's probably a place for this in the toolkit, if only for simple CRUD controllers.
&gt;Until programmers stop acting like obfuscation is morally hazardous, they're not artists, just kids who don’t want their food to touch. -- _why Clever. Almost too clever. Still, interesting to see what a minimal framework looks like, obfuscated or not.
[Enumerative, procedural ("mutative") and recursive fibonacci in Ruby, with timings](https://gist.github.com/pmarreck/42cf97159e19390d37ba) [Enumerative and recursive (via TCO) fibonacci in Elixir, with timings](https://gist.github.com/pmarreck/17177a4a0666ab7cebe5) With an input of a half a million, the only Ruby version that finishes in any reasonable amount of time is the procedural one you posted, which takes nearly twice as long as *either* of the Elixir ones I posted. Here is the output straight out of my console (in my case I had to comment out the recursive Ruby implementation because it took too long for an input of 500000, although it *does* work WITH a nasty MRI hack): bash&gt;&gt; elixir fibonacci.exs Running Elixir recursive fib(500000) takes 2.374091863632202 seconds Running Elixir enumerative fib(500000) takes 2.481484889984131 seconds Running Elixir streaming fib(500000) takes 2.727456855773926 seconds bash&gt;&gt; ruby fibonacci.rb Running Ruby procedural fib(500000) takes 4.217821 seconds Running Ruby enumerative fib(500000) takes 4.257242 seconds **Now, please, tell me again how Elixir is not faster than Ruby.** :P Also: **owned** ;) (But one question: How do you format the code as code here?) Look, I'm sorry. I've done Ruby for 10 years. I have yet to find a typical Elixir implementation of an algorithm that is slower than the same (or optimal) Ruby implementation. Usually the Elixir is 2 to 5, sometimes 10 times faster.
The only thing they're catching up on is processing the output into JSON. JBuilder was a big step forward, AMS is an even bigger step.
Not really. [I commented here with both Ruby and Elixir versions with multiple approaches for each.](http://www.reddit.com/r/ruby/comments/35hb5x/does_it_still_make_sense_to_learn_ruby_andor_rails/cr4xurz)
I found one problem. You should be using the BEAM VM, not the HiPE VM. Anyway, [here's a Phoenix webserver performance showdown project comparing various web frameworks across various languages](https://github.com/mroth/phoenix-showdown#comparative-benchmark-numbers) with some interesting numbers.
You are correct that XOR means that one or the other is true, but not both. The part you're missing is that when you do a number XOR another number, it XORs each bit and then converts back to decimal. So 3 ^ 4 is the following # 3 is 0b0011 and 4 is 0b0100 # so 3 ^ 4 is 0b0111 which is 7 &gt; 3 ^ 4 =&gt; 7 &gt; 0b0011 ^ 0b0100 =&gt; 7 The stuff in @item_name.hash is just a big number, so it converts it to binary and XORs it with each of the other big numbers that come out of the other hashes. edit: changed 0b0110 to 0b0111.
Great! Thank you so much for your help :) 
Thank you for the explanation :) 
The reason for the `XOR` in this method is to combine the hashes of the constituent properties in a 'safe' way. The point of a hash is to be a (hopefully) unique identifier that represents the 'value' of the object. Ruby provides hash methods for the built in types but if you have a composite object like this and you want consistent hashing of it's 'value', you need to implement the `hash` method. One way (not the best way) to do that is to XOR the hashes of it's properties. Two questions you may ask: 1) Why do I need to do this? I use objects as keys in hashes all the time with defining hash! Yes you do and you can. The reason you would do this is if you wanted to hash on the 'value' of the object in a different way. By default Ruby hashes objects on their object_id. e.g. #without implementing hash a = MyThing.new variable_one: 5, variable_two: 10 b = MyThing.new variable_one: 5, variable_two: 10 my_hash = {} my_hash[a] = 25 my_hash[b] = 50 # the hash now looks like { &lt;Object a&gt;: 25, &lt;Object b&gt;: 50 } # with implementing hash combining the hash of the two variables a = MyThing.new variable_one: 5, variable_two: 10 b = MyThing.new variable_one: 5, variable_two: 10 my_hash = {} my_hash[a] = 25 my_hash[b] = 50 # the hash now looks like { &lt;Object a&gt;: 50 } # they hash to the same value so they are seen as being equal when inserting into the hash 2) Why use XOR to combine the hashes? Since the truth table of XOR is half 0 and half 1 it is good at combining uniformly random input and giving a uniformly random output. Since the original hashes should generally look like uniformly random input, if they are strong hashes anyway, XOR works well here. In practice directly chaining XOR like this isn't a great choice. i.e. imagine you had two fields in the object that could some times be identical, they will XOR to zero which can wreck your hash (cause collisions). A safer way to do this in Ruby is `[@variable_one, @variable_two].hash` but there may be much faster ways for a particular application.
Objects, in object-oriented languages, have their own variables (called 'properties' when they belong to an object) and functions (called 'methods' when they belong to an object -- in Ruby, ALL functions belong to an object, so they're all called methods). By default, you cannot read or modify an object's properties except within that object's methods. That is, if I have `santos = Dog.new`, I cannot say `santos.legs = 4` to set his `legs` property. The `Dog::initialize` method could do that, but I can't do it from *outside* the class. This is considered a good thing, because you know your objects can't be modified or changed in some way the class definition doesn't specify -- the only way dogs can be modified is using the methods you wrote specifically for modifying dogs. Likewise, other parts of the program can't read all of Santos's properties/variables. But sometimes, you *want* other parts of your code to be able to either read or modify your object's variables. So you write methods that let them do that. class Dog def initialize @legs = 4 end def legs return @legs end end Now each dog has a `legs` method. When you call it, it simply returns the number of legs the dog has. santos = Dog.new santos.legs # 4 It turns out that this specific example -- wanting to expose a single property, and so creating a method with the same name as it that does nothing but return that property -- is really really common. So Ruby has a shortcut for it. If you just write class Dog attr_reader :legs def initialize @legs = 4 end end That's exactly the same as the example above. It's just short-hand for creating the `legs` method. You can pass multiple names to it -- `attr_reader :legs, :breed, :age` for example. Likewise, it's also really common to write a method that does nothing but modify a property. If you write `attr_writer :legs` this is the same as def legs=(number) @legs = number end Now we could say `santos.legs= 8` and Santos would become a mutant. Just shorthand. `attr_accessor`is the same as doing *both* of the above. `attr_accessor :legs` would be the same as defining both `legs` (to retrieve) and `legs=(number)` (to modify). Neither of those things would go in an initialize method. `attr_writer` is what's called a 'setter method', and `attr_reader` is what's called a 'getter method'. These are pretty common even in other languages, Ruby just has shorthand for automatically creating them.
You do realize that all your Elixir code uses recursion, right?
Lol, whoops! Thanks for the correction, I edited it in.
&gt; But one question: How do you format the code as code here? Mark the text, click the "code" symbol (&lt;&gt;). Or indent all code lines with four space characters.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Duck typing**](https://en.wikipedia.org/wiki/Duck%20typing): [](#sfw) --- &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming) with [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming) [programming languages](https://en.wikipedia.org/wiki/Programming_language), __duck typing__ is a layer of programming language and design rules on top of [typing](https://en.wikipedia.org/wiki/Type_system). Typing is concerned with assigning a type to any object. Duck typing is concerned with establishing the suitability of an object for some purpose. With normal typing, suitability is assumed to be determined by an object's type only. In duck typing, an object's suitability is determined by the presence of certain *[methods](https://en.wikipedia.org/wiki/Method_(computer_programming\)) and properties* (with appropriate meaning), rather than the actual type of the object. &gt; --- ^Interesting: [^Type ^system](https://en.wikipedia.org/wiki/Type_system) ^| [^Boo ^\(programming ^language)](https://en.wikipedia.org/wiki/Boo_\(programming_language\)) ^| [^Polymorphic ^association](https://en.wikipedia.org/wiki/Polymorphic_association) ^| [^Operational ^definition](https://en.wikipedia.org/wiki/Operational_definition) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cr5azsd) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cr5azsd)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
i think if you are just starting out it's better to learn sinatra rather than rails. Sinatra shares tons in common with Rails so you can apply your Sinatra skills to Rails eventually. Since SInatra is more focused on the "essentials", there's less of a sense of being overwhelmed like with starting rails. Also, storage is quite a bit easier with Datamapper in Sinatra rather than ActiveRecord with Rails. 
*committer Koichi Sasada agrees that interupts in ensure blocks are a problem, disagreeing with you* Where am I claiming interrupts in ensure blocks are not a problem ? *you're trying to convince people that they don't need to pay any attention to the very dangerous concurrent nature of Timeout.timeout* Ugh, another strawman here … Discussion starts to get boring and barren. My only concern was with people scaring others with irrational, unfounded and emotional nearly religious *Timeout is evil*. How **anybody** who learned fundamentals of Ruby exception system and read Timeout.timeout documentation can even be *surprised* what can happen ? Ruby exception handling and propagation including `ensure`block is clearly described in lot of sources, like in D. Flanagan's and Matz's book The Ruby Programming Language. But those are essentials which should anybody know before start programming and claiming bold statements and conclusions. It behaves exactly as documented, not by a personal intuition which may differ between each other. That was the point. Btw. Problem with uninterruptible "atomic" resources clean-up is not specific to Ruby. There is a similar proposal for Python [PEP419](http://legacy.python.org/dev/peps/pep-0419/) 3 years old, which is not yet even accepted. It's very difficult or almost impossible to generally solve the problem, but deeper discussion is beyond this thread. Only notice it could lead to nasty deadlocks, misbehavior due to suppressed or deferred events etc. It may be partially cured with explicit per case managed signals/exceptions propagation but then we are at the beginning of this debate - (TimeoutError) exception aware/safe code.
&gt; I find Java ... to also be pretty joyful to work with. What the hell is wrong with you? Jokes aside, I'm a Java dev who became a Ruby dev. I'd struggle to go back to Java. I'd do it for the money, but my soul would tarnish.
I'm sorry, but can not confirm your results on a different platform - Linux x86_64: &gt; $ ruby fibonacci.rb &gt; Running Ruby procedural fib(1000000) takes 12.57024237 seconds &gt; Running Ruby enumerative fib(1000000) takes 12.702349421 seconds &gt; $ ruby -v &gt; ruby 2.1.6p336 (2015-04-13 revision 50298) [x86_64-linux] &gt; $ elixir fibonacci.exs &gt; Running Elixir recursive fib(1000000) takes 14.34514307975769 seconds &gt; Running Elixir enumerative fib(1000000) takes 15.581332921981812 seconds &gt; Running Elixir streaming fib(1000000) takes 15.15653109550476 seconds &gt; $ elixir -v &gt; Elixir 1.0.4 &gt; $ erl &gt; Erlang/OTP 17 [erts-6.4] [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] As a side note, in Ruby version you made a mistake and added an extra iteration in `run_enumerative`. It had to be `(1..n).inject([1,0]) { |(a,b), _| [b, a+b] }[1]` to correspond to Elixir's version. As you may see, your conclusion is not valid, at least on a different OS. I'd be interested to see results from BSDs and Windows. Even if they would be on par with your results, half runtime speed improvement is *nothing*. Compare Shooutout tests with Java, Go or C/C++ and there are 20x - 100x times differences.
Firstly, note that type checking is *usually* considered unidiomatic in ruby. The whole principle of duck typing is that you should be testing the *behaviour* of your object, not the *type*. For example, even in your own validator source code, you are writing code in this unidiomatic style: &gt; @options = options.is_a?(Hash) ? options : {} Rather than the more "ruby-style": @options ||= {} Or all over the code, you are trying to define statically typed method signatures: &gt; # param: attribute_name &lt;Symbol&gt; - name of attribute that will be validated &gt; # param: attribute_type &lt;Symbol&gt; - type for which to validate the attribute against &gt; # param: options &lt;Hash&gt; - extra options to pass along to the validator &gt; # i.e. allow_nil: true, message: 'my custom message' &gt; # return: nil There are [various tools](https://github.com/plexus/typecheck) available to tests these things more cleanly, if you really want. But like I said, it's typically considered bad practice. I will concede that there are times when this sort of thing can be useful for "sanity checks", however... In which case, I still have one key issue with your code: Why are you [only accepting a (restricted) list of symbols as arguments for type checking](https://github.com/yez/validates_type/blob/master/lib/validates_type.rb#L108-L115)? You could be doing something clever, like converting symbols`:formatted_like_this` (snake case) into class names `FormattedLikeThis`(camel case) - by using [ActiveSupport inflector](http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html). Or alternatively, why not skip this conversion entirely and just pass the class names directly in the arguments list - like [this](http://stackoverflow.com/questions/18831869/rails-validate-type-date/18833019#18833019)?
That's... weird.
Including the enumerations, underneath I guess?
&gt; How anybody who learned fundamentals of Ruby exception system and read Timeout.timeout documentation can even be surprised what can happen Clearly, the many many people who have accidentally created timeout-related bugs are all morons, including those who wrote the mongo driver linked to above. It's not hard to use correctly at all, unless you are a moron. So there is no need to educate anyone about it or promote alternate solutions, morons will be morons, everyone else will be fine. Is that your argument? 
I don't think anyone would write "fibonacci apps" in ruby or elixir/erlang since either language is not targeted at being performant on numeric workloads. This benchmark tests the bignum implementation of both languages and if you rewrote it in C using the same bignum libraries you would see roughly the same execution time. A more interesting benchmark would be of web frameworks since both languages are used primarily for web applications: https://github.com/mroth/phoenix-showdown#comparative-benchmark-numbers. The erlang virtual machine was designed to run concurrent tasks efficiently and to handle load and overload very well which shows in this benchmark. Phoenix and plug are both elixir libraries and perform more than 10x better than rails.
&gt; you still use quoted speech (example: this does not require "zero cost" to configure) as if I had said there is zero switching cost to InfraRuby No I'm not. I'm using quoted speech for emphasis. I must have clarified this fact a dozen times now. Stop going round in circles. &gt; You are now saying that changing USE_INFRARUBY_CORE = true to USE_INFRARUBY_CORE = false directly in the Rakefile, for example, is "impossibly strict", "perfectly configured", "unrealistic" and "idealist". I gave several examples of when making such a change is *non-trivial*, or even would not be possible. Your response was simply (and I *am* quoting you directly this time): **"That's still your problem."** Or in other words, InfraRuby does NOT provide a "zero cost" (I'm using quotes for emphasis this time, not quoting you) switch *from* InfraRuby under a variety of real-world scenarios. &gt; No. [Return statements are optional] &gt; If you choose to use tabs and explicit return statements, say, but you later choose differently then that is your problem: it has nothing to do with InfraRuby and it is not a cost of switching from InfraRuby, even if you decide to do that at the same time. Using the `return` keyword is optional, yes. I'm not arguing that. I'm saying that in InfraRuby, because all methods require a signature, you need to write ugly unidiomatic code such as ensuring the `initialize` method returns a known type (probably `nil`), which probably involves the use of weird `returns` stuck in your code. Even if you were to avoid using the `return` keyword, you'd still need to write `nil` at the end of a method, or have some methods defined as "returning" arbitrary types, for no good reason. In order to remove all of this ugly code, *which InfraRuby DOES require you to write, in order for the code to compile*, there is significant cost. So, I repeat: There is no "zero cost" (I'm using quotes for emphasis this time, not quoting you) switching *from* InfraRuby, in the real world.
They are very very simple. All `attr_reader :some_name` does is automatically create a method like: def some_name @some_name end That's it, that's all it does, create that method that returns the instance variable. All `attr_writer :some_name` does is create the writer method storing to the same instance method: def some_name=(value) @some_name = value end That allows you to do `obj.some_name = value`, to call that method. All `attr_accessor` does is both of those things. That's it, nothing more to it than that. They are convenience shortcuts for defining reader/writer methods, a common thing to do in ruby, since ruby only allows you to call methods on an object, you can't access instance variables directly from outside the object. (Well, technically there are ways to do it, but you ordinarily don't, you use reader/writer methods). 
I'd rather it combined all the sources in a single listing/feed, merge them all together sort by date. Not give me separate sections on the page, it's overwhelming there's too much to look at. The point of an aggregator for me to is to be able to scan a single list for for new stuff of interest. 
Thanks for your comments. Good point about the centered tags. Cheers.
are you shitting me
I wrote the article Ask me Anything about general memory use in Ruby.
Hah, no I misread
I'm pretty experienced. I've got 12 years of Java experience and about 8 years of JavaScript experience.
It depends on the Ruby version you're using. In Ruby 2.2, not much, as symbol GC was added. In older versions of Ruby the `.freeze` didn't actually use a string pool but simply modified a flag preventing you from modifying it. In more recent Rubies it actually performs an optimization in the VM/parser to not create duplicate objects. It's so similar to a symbol, some people have suggested making a symbol act as syntactic sugar for a frozen string. https://news.ycombinator.com/item?id=9197412 If you're debating using one or another, there's not really pros or cons purely on perf. I would say use a frozen string when you're interacting with a string based API so you don't have to call `to_s` on your symbol (which creates a new object). Use a symbol when you're interacting with a symbol based API. There's very little performance difference. Edit: A word, added link to HN comment
Wouldn't your more idiomatic code just nil check whereas the code you call unidiomatic would nil check and also check if @options is any non-hash type?
It's going to be a while before any other "big" players start taking over the market share of web app frameworks. I will probably get down voted by the Node/IO groupies touting Sails/Express, but the speed at which you can develop in those is still very far behind Rails. At the end of the day, it depends on what you want to do. There are still people doing Fortran today. Work with what makes you happy and you'll find a way.
I feel that Ruby violates the utility of duck typing by creating vast interfaces that it isn't reasonable to emulate. Array, for example, has 95 methods defined on it, only some of which are overrides of the 51 methods in Enumerable. So, quacking like an Array is actually a fairly high bar to meet. The easiest way is to simply decorate an Array, naturally. I could imagine that idiomatic Ruby had lots of Array-like implementations floating around and used interchangeably, but in practice, I've never seen that to be the case; devs who want an Array use an Array. The case I *have* seen is that someone passes in a String when an Array of Strings was expected. Many [cases](http://blog.codeclimate.com/blog/2014/05/06/gradual-type-checking-for-ruby/) for typing have been made, and the most common objection is that they violate the spirit of duck typing. Nonetheless, Ruby 3 will [likely have optional typing in it](https://bugs.ruby-lang.org/issues/9999), simply because the utility of have the system enforce a precondition has a lot of utility when writing production code. I see this gem as operating in a similar spirit to that progression towards 'gradual' or 'optional' typing systems layered on top of Ruby's duck typing. 
&gt; Thank you for this explanation. Just to make sure I got this, the hash method is inclusive of a hash object. Whenever you create a hash object, the values are computed with the hash method and stored given their unique identifier for that specific objects value. I would more generally say that when you use an object as a key in a `Hash` the result of `hash` is what is used as a key, although the object is still stored in the hash in full. &gt; This is different from object_id which gives a unique identifier for the object (not the value), given some exceptions like integers and boolean values (for object_id). By default, when handed an object that doesn't have a `hash` method, `Hash` takes a `hash` of the object_id to use. Integers and Booleans are actually interned and immutable. i.e. any time you have two numbers like `5` and `5` in your code, the have the same `object_id`. A better example is `String`. String in ruby are mutable and you can have different objects with the same string value but Ruby compares them 'by contents' not 'by object_id', this is handled in the same way as your example, by overriding `hash` and `eql?`. &gt; So, real use case, if I had multiple object instances of class Dog, and I wanted to get rid of any duplicates or exact same data of the objects, I would use this hash method to basically do a uniq on the data set. Because even though all these object instances all have different object_id's, we are only considering the values of each of these instances, and getting rid of the duplicates. Right? You got it. When you override `hash` your expected to override `eql?` with the same semantics, i.e. if the hashes match then eql? should return true also. This means you can also use things like `[object1, object2].uniq` and they will act the same way as `Hash` would, counting them as duplicates. &gt; Also, is the hash method used frequently? Not really, or at least not that people notice. The most common usage that goes un-noticed is `String` as mentioned above. If your working in Rails then ActiveRecord objects work similarly. They are considered equal if they represent the same row in the database even if there are two different objects. Another way to think of this in general is 'What does equal actually mean?'. The two common answers are "it's the same object" i.e. it points to the same piece of memory or 'it represents the same thing' e.g. the two strings 'hello' and 'hello' could be in completely different locations in memory but be considered equal. 
Minimal use-cases annoy me
I started learning Groovy last year, but decided it was too similar to Java. I want to learn a language that will challenge my thinking.
I started learning Angular last year, but now I'm holding off and waiting until the dust settles on Angular 2.0 to put in any more time there. For JavaScript, my next thing I'll learn is probably React, as that is picking up more and more steam.
&gt; My question is, when you say you "know" javascript and java, does that mean you've piddle around with them? or you have experience building projects with them? I've been doing Java for 12 years and JavaScript for 8. I would say I have expert-level knowledge in both, or almost-expert-level, as there are a few gaps in what I know. The team I'm on now uses JavaScript (actually CoffeeScript) for the front end, and the back end is Ruby/Rails based. So I thought now would be a good time to finally start learning Ruby so that I could better understand (or, rather, understand at all!) the server side code.
&gt; Why would you want to emulate the entire interface!??! Without knowing the details of how the object will be used, how does the client know which part of the interface to implement?
And if you use pry, there's pry-byebug; the best of both worlds.
Found some very cool tips in here! Thanks! Didn't know about - Character Class Intersections - Turn On Unicode-Matching - Continue Matching at Last Match Position and a few more but those will come in handy for sure! :D
There is a typo for the syntax of negative lookbehind regexp: `(?&lt;!X)` and not `(?!X)`
You don't have to add "require byebug" at the top of your file. You can simply write this instead where you want to start debugging: require byebug; byebug; It can even be put in views if you need to. You then have to remove one line, which is better as you might forget to remove the require at the top of your file. If you don't want to always write the whole thing, just use a code snippet who could be debug or whatever you like. It obviously depends on your editor for this.
&gt; sloppy code 50,000 LOC, 98% test coverage, code reviews, skilled co-workers and we still end up with type errors in production. Humans will always be humans and make stupid mistakes. Simply adding type signatures to each method would make refactoring so much easier and prevent a lot of stupid mistakes. (Since you only mentioned C++ and Java which are both overly verbose: Have a look at C# and Haskell to get an idea what statically typed code can look like with decent type inference.)
&gt; Humans will always be humans and make stupid mistakes Oh, so very very true. &gt; Simply adding type signatures to each method would make refactoring so much easier and prevent a lot of stupid mistakes. From my days with C, C++, Java &amp; C# (10 years back now!) I seem to recall that mistakes would still happen, but simply be of a different nature. I honestly don't see a type system as a magic bullet.
How is this different/better than `binding.pry`? 
Interesting note about "coincidental duplication" -- it usually arises from the framework you are using itself. Asking consuming code to meet the same contract over and over will often lead to code that is very similar. Since controllers are effectively the entry point of your application code, they have the most structure imposed by the framework. IOW, all you are doing by de-duplicating controllers is taking the boundary between your framework and your code and *moving* it.
What your describing is simply done with: def function(request = {}) post_to_service(request) end But if that is what your actually doing in that method, just remove the method. Do you have a more realistic example of what your trying to do? As a side note, your first example is better done with keyword arguments.
Well, the point that makes it complex is I want the shape of the argument to `#post_to_service` to depend on the presence of arguments to `#function`. Have you seen the practice of sending arguments as `(foo = bar, baz = qux)`? Is that acceptable?
I prefer keyword arguments unless the arity of the method is low, positional arguments become confusing at higher arity. In case your unfamiliar with keyword args: https://robots.thoughtbot.com/ruby-2-keyword-arguments
I have used them before, and for some reason did not in this case. They seem wholly appropriate -- thank you for your input.
Heh.. funny thing is, I started in Smalltalk and thought "this is what I want to be doing forever!" Only problem, no gigs. So, after a decade or so of writing in C++ and Delphi, finding Ruby (with its blocks and message passing) was like coming home. Anyway, good vid. As you say, nice to look outside of the language to see what we are missing.
Most of the Smalltalks had really decent IDEs. Digitalk Smalltalk was - back in the 90s - quite an awesome piece of kit, when everyone else was going "ooowww... ahhh" over Visual C++. Fools! But yeah, not sure if I wouldn't find a Smalltalk IDE limiting now. As beautiful as the language is, there's something honest about having to deal with a bunch of text files.
(off topic) Avdi Grimm sounds exactly like Phil Dunphy.
I agree only partially: lookahead and lookbehind can be really useful for creating custom anchors.
&gt; Well, the point that makes it complex is I want the shape of the argument to #post_to_service to depend on the presence of arguments to #function. Can you please describe in more detail what this is supposed to mean? Maybe present some input argument configurations and how the argument for the other method then should look like.
Lookarounds are certainly useful, yes. But these were not even on this list! The advanced feature actually listed here is *Keep* expressions (`/...\K.../`), which is like a special case for positive lookbehinds. And I'd generally avoid using them since you can achieve the same thing with "normal" positive lookbehinds anyway, and the obscure regex syntax is likely to confuse other developers.
&gt; Turn On Unicode-Matching This tip actually annoyed me slightly, because it's only pointing out the most obscure use case for what's actually a very nice feature of ruby (Onigmo) regex! From the docs: (?imxdau-imx) option on/off i: ignore case m: multi-line (dot(.) match newline) x: extended form character set option (character range option) d: Default (compatible with Ruby 1.9.3) \w, \d and \s doesn't match non-ASCII characters. \b, \B and POSIX brackets use the each encoding's rules. a: ASCII ONIG_OPTION_ASCII_RANGE option is turned on. \w, \d, \s and POSIX brackets doesn't match non-ASCII characters. \b and \B use the ASCII rules. u: Unicode ONIG_OPTION_ASCII_RANGE option is turned off. \w (\W), \d (\D), \s (\S), \b (\B) and POSIX brackets use the each encoding's rules. (?imxdau-imx:subexp) option on/off for subexp In other words, a much more useful example (which you actually might want to use!) could be: /lower (?i)mixed(?-i) UPPER/ =~ "lower MiXEd UPPER" # =&gt; 0 /lower (?i:mixed) UPPER/ =~ "lower mIXED UPPER" # =&gt; 0 Incidentally, if you `gem install regexp-examples` ([my ruby gem](https://github.com/tom-lord/regexp-examples)), then you can even do this: require 'regexp-examples' /lower (?i:mixed) UPPER/.random_example # =&gt; "lower MixED UPPER" 
Might want to remove that email address.
This seems to be PC taken to the extreme. Not the volume ("impressive portfolio") but the quality of content would be much more important for me. You could also argue that hand selected code samples that are submitted with the application can be much easier tuned to look good than a complete Github account so Github may actually play *against* the applicant. Anyway, code does not tell you how they got there; code is just a part of what to look for when hiring. This sounds really odd to me.
That's just social justice folks social justice'n. Any tech company worth their salt will check your profile. Think, would you really want to be hired by someone who doesn't give a damn about the quality of the work their people put out? 
"CIS white men often have more spare time or chose to pursue building up an impressive portfolio of code rather than women or minorities who have to deal with things like raising children or instiutionalised racism. ".... Okay wait a sec...is this guy serious? Is keeping a neat Github repo such a time consuming duty that women can't do it while they're raising children? And the next one just gets too funny? Where is this "institutional racism" coming from? Does Github deny accounts to non-white people? PS - I'm non-white
What's with the assumption that women are the ones raising the children- or the assumption that they have children at all. Rather, I'd call this out as racism and sexism on the employer's part. Most of your devs are CIS white men, no problem. It's not a bad thing to go out and aim to hire anyone who isn't a CIS white man, but at the end of the day, if the guy has better skills, you're not doing yourself a favor by excluding him. 
I don't think this is true, I think it's a false flag parody. "CIS" is not an acronym, it is not in all capitals, it's just a word, "cis" or "cisgendered". I've only heard the phrase "SocJus community" from gamergate-types, I've never seen anyone who actually cares about social justice write "SocJus" or "SocJus community". I suspect this is someone pretending to be a leftist to make leftists look bad, and is not who they say they are. At any rate, they are not representative of anything. Don't believe everything you read on the internet. Next time they'll do a better job masquerading. Googling for "eve.t.braun@gmail.com" or "Eve T. Braun" gets only this referenced post. 
That person is off their rocker, that's what. I mean, look at this crap. &gt;We used Randi Harper's (https://twitter.com/freebsdgirl) blockbot to assess applicants twitter profiles for problematic or toxic viewpoints. This may sound a bit extreme but some of the staff here suffer from Aspergers &amp; PTSD and our top priority is to ensure that they don't get put in triggering situations. *I* have Asperger's, PTSD and am trying to get severe agoraphobia under control. That one wants to talk about triggering situations? Knowing that you can't even have a single bad day in your life where you're angry at the world is a triggering situation. "Oooooh. You got angry on the internet... 6 years ago. Your toxic viewpoints interfere with our chakras. Sorry. Do you want a hug? Why doesn't this autistic stranger want a hug from me?! Discrimination!" I'll just be over ---------&gt; there talking to my transgender friends, once I finish checking my "white privilege" (not that I've ever noticed having any, with my life's history) in my black wife's purse. Good grief. I wouldn't even *want* to work at a place like that. I'd rather my sole worry be the extent of my CS skills and not have to even think about the implications of my continued existence hinging on charity workfare and special treatment.
Just a word of warning from a security POV: Magic sometimes adds security vulnerabilities. It definitely was the case with Inherited Resources: too many actions were sometimes exposed, authorization wasn't always checked. The problem there was often that with growing complexity, the maintainability went down. And thus when someone came back to magic code, she maybe didn't see immediately what was going on, and added a security problem. So if you've a way to make it clear for each action what's going on, what's exposed. A common problem will also be how to integrate authorization plugins?
Have you met "Eve T. Braun"? At any rate, if it's a real person honestly presenting their actual beliefs, they are not representative, in their language or their beliefs. shrug. But seriously, I have never ever seen anyone write "SocJus community" except people who think they are against it. "SocJus" is a term of derision created and used by the "gamergate community," not by anyone who self-describes or self-identifies themselves that way. Google "SocJus community" or "SocJus" and see what you get. This is an obvious clue, if they tried harder they could leave fewer/less obvious clues, but still be pretending to be someone they're not with beliefs they don't have, to stir things up, troll style. 
Even then, you'd probably find it easier/less confusing to just use [named properties](http://ruby-doc.org/core-2.2.2/Regexp.html#class-Regexp-label-Character+Properties). For example: "Rüby"[/\p{Word}*/] #=&gt; "Rüby" I think that's much more explicit (and easier to google) than using some obscure unicode toggling flag!
The most interesting thing was that Finder tool. Inputing "'foo'.'bar'.'foobar'" and getting the method back is so cool!
totally agree. lazy_crud isn't a controller itself, it's a concern that is included in a controller. So, if your controller already inherits from application controller (which usually has the authentication stuff), all actions are, by default, require the user to be authenticated. If you mean something like can-can, then lazy_crud is not the tool for the job - cause that adds a lot of workflow complexity. For example, in one of my projects: https://github.com/NullVoxPopuli/aeonvera/blob/custom-fields/app/controllers/hosted_events/custom_fields_controller.rb that controller requires authentication on every action. Actually!!! for authorization, one could hook in to the before_create / before_update methods, and wrap functionality in there, so long as errors are added to the resource's `errors` object - I don't think that would be too bad.
it's totally optional to use on a per-controller basis. So if you need to do something clever, that controller or action can just not utilize the gem.
yep, I think it's a troll, it's a parody representing what the 'gamergate community' thinks 'Social Justice Warriors' are like. Having it's intended effect. In other news this reminds me of, although this next is an even more disgusting example, 'gamergate' people create racist blackface parodies pretending to be 'Baltimore looters'. http://www.huffingtonpost.com/2015/04/30/baltimore-loot-crew_n_7183798.html Also, it's sadly hilarious that you and I are getting downvoted for pointing out that this person is, if not an outright false flag parody (I still think it is), most definitely unrepresentative of what they are claiming to represent. The "reddit community" is a mess. 
I'm not going to make any argument whether a github profile is in advantage to white males. It probably is to some degree, given we're privileged and are able to go to social hack nights and work on projects with strangers without scrutiny. But my main argument is going to be against this bit: &gt; Some in the SocJus community have even said that technically companies could possibly even be breaking discriminatory law by allowing peoples github profiles and publicly available code to influence their hiring decisions - watch this space. I think that is a very bad argument. It's like saying artists who have public portfolios or designers who show websites they worked on is breaking discriminatory law. It's a way of showing our work. But yes, github source should really be taken with a grain of salt. Evaluate what the person has contributed, how the code is written, etc.
Good point! Thanks
My issue as a developer is that almost all the code I've written is protected by an NDA of some sort, and can't be hosted on Github publicly for all to see. Sure I can provide sanitized samples, but its not that simple.
In this context I thought the CIS meant computer info systems, which would be an acronym in that case.
Just seems like your local group was taken over by SJWs.
Why does it bother you so much to have a label for your gender expression? Does 'man' and 'woman' bother you too, why can't we all just be humans? [It does bother some people in fact that we all need to be 'men' or 'women' and can't just be humans, but I suspect you don't sympathize with them...] But seriously, what makes "transgender" and "cisgender" "PC crap", but not "man" and "woman"? Transgendered people have a label for their gender expression whether they like it or not, of course, it probably bothers them too. But we need some way to talk about difference respectfully without labelling some people as freaks. Treating everyone as fully human involves recognizing that some people are routinely _not_ treated as fully human and doing what you can to change that, not pretending it doesn't happen or pretending difference doesn't exist. Anyway, this is another discussion. My point is mainly that the OP is probably pretending to be someone they are not having beliefs they don't have in order to make "this PC crap" look bad, because they can't even get the terminology right. 
Also, the implication that cisgendered white men can't be just as invested in their kids and families as women working in technology.
Jim, great job! I appreciate your forethought on making this a more complex application by the structure you have defined. Your coding is clear, concise, and follows the ideas of maintainable code wonderfully. To many folks are more concerned with "making it smaller" like it is some kind of contest. Your code has a good balance of readability and compactness that is easy to learn from. THANKS!
&gt;is this guy serious? While there is a point to be made here along these lines, [I'm with /u/jrochkind](https://www.reddit.com/r/ruby/comments/35ouvr/is_not_looking_at_github_profiles_becoming_the/cr6gvv6): I think this is trolling, or some kind of anti-"SJW" false flag. "Cis" isn't an acronym, and no one who would ostensibly write this would use it as such. You only see that from the gamergate types.
Actually, LRUG (London Ruby User Group) is by far the largest Ruby group in the UK, they regularly have 60+ people attend their meetings. So I guess if they're a joke that makes them the biggest joke?
Thanks, fixed!
Thanks, you are right. I've updated the example!
Tl;dr DO NOT subclass ruby core classes. Favor composition. Delegate as needed. I only had to deal with a subclass of `String` once (in WEBrick, query string params/form data is implemented as a subclass of `String`). It felt like being a party to an unnatural act. I hope I will not see another API that does that.
I always thought Smalltalk would beat Java, I just didn't know it would be called 'Ruby' when it did. -- Kent Beck 
I don't think that's good advice. You should subclass whatever you want. Just be aware of the consequences and bookkeeping. This is Ruby. There's more than one way to do it. After all, many Ruby core classes are subclasses of other core classes, and some aren't. ENV is hash-like, and Fixnum is a child of Integer. Whoopdido. Hell, Class is an instance of itself.
To answer your question, no, looking at github profiles is very much the norm and probably won't be going away for the time being.
Judging by the comments here, looks like Ruby people don't understand jokes. 
The original advice is *beware...* I may have made it a little too imperative with my *DO NOT...*, so yes ;)
The label 'woman' doesn't bother me but its accompanying trappings do. Why do I have to like pink? Why do I have to want children? Why must men be the breadwinners and the "strong" figures. It's bullshit. I'd much rather that people just be recognized for who they are rather than what society says they should be.
It shouldn't be, if it is, I would question their hiring practices.
Ruby's really handy for OS X and Linux scripting. It's also worth learning Ruby first before you try to learn Rails, just like it's worth learning JavaScript first before you start to learn a JS-based framework or jQuery.
This is a really big problem, I sympathize. So many developers have work that's not on a web application or piece of easily digested software. I have a friend who has spent 6 years developing mapping algorithm's that are heavily protected by NDA and contracts. It's hard for him to even talk about why his work is important without violating his agreements.
This has absolutely nothing to do with core vs custom classes - the problem is in the behaviors of `Array#to_a` and `rb_obj_as_string` (which the tostring instruction calls). The String class is wholly innocent here, and `Array#to_a`'s documentation [explicitly says](http://ruby-doc.org/core-2.2.0/Array.html#method-i-to_a) "if called on a subclass of Array, converts the receiver to an Array object." You actually wanted `#to_ary`, which just returns `self`. (Kernel#Array also works just fine, as it just calls `#to_ary` and `#to_a`) The headline here *should* be "make sure your assumptions match reality".
My only concern is what happens after one gets past the trivial questions (both of this questions could just be matched via regex).
I personally don't like IDEs, so this video pretty much did just the opposite.
Latest from eve: http://lists.lrug.org/pipermail/chat-lrug.org/2015-May/010949.html I'm a long time member of LRUG. I've suffered through the ever increasing pressure of social justice advocates pushing their agenda on me. People getting slaughtered on the mailing list for saying mildly insensitive things , the talk about 'micro aggressions' and now this. I'd desperately like to post to the list against this insanity but fear greatly about the career implications for opposing their agenda.
I hear tumblr is hiring.
Why learning Elixir with the Phoenix framework will me him be ahead of his peers at the next local meetup for sure? 
Why Elixir? I do not see any Elixir jobs Thanks 
Do not rage just because someone is a programmer while you aren't.
Yeah, Timeout is a mess. It doesn't even work reliably. For instance, if you want to call another command in a subshell and time out and kill it if it locks up, Timeout won't work. [Here's how to do that](https://gist.github.com/lpar/1032297).
Because everybody else will still be talking about node.js or maybe how they replaced Angular with React and got so much more productive. Elixir is a quite new language (maybe two or three years old) that still has already drawn some attention, especially in the Ruby community. It's based on Ruby, Erlang and Closure and adds interesting things from those languages. It is very much following the functional paradigm, still is nice to use like Ruby. Also it got some attention by some interesting people, especially Dave Thomas (of Ruby Pickaxe and The Pragmatic Programmer fame) who wrote a book about it (and this was the guy who had a strong part in creating the Ruby on Rails hype). Also there is a working web framework and some other interesting projects. Also it compiles to bytecode for the Erlang VM, so that adds some enterprise readyness right from the start (and makes it an interesting choice especially for everything realtime and concurrent, very strong point if you are interested not only in writing web sites but also target highly interactive mobile systems) So this still gives everybody the option to become an early adopter while at the same time making an highly interesting conversation piece.
It would be easier for us to help you if you could show us a live example of the app and/or source code. Anyway, it sounds like your problem might be related to [turbolinks](https://github.com/rails/turbolinks), try disabling that and see if that helps. If you need more specialized help you may also try your luck in /r/rails
I don't hate Ruby yet ;) https://gist.github.com/domgetter/79ce104c162008ca1f15
I'm inclined to agree, mostly because "Eve T Braun" appears to exist only on this mailing list and a single LinkedIn profile which uses a video game character avatar, and the similarity in name to "Eva Braun" (you know, Hitler's mistress) is uncanny. I'm willing to bet that the "T" stands for "Troll".
It's the latin prefix that's opposite to trans, so you're right it shouldn't be capitalized. 
Yeah, his emacs skills are pretty badass in all his screencasts.
yeah, i'd disable turbolinks. http://blog.steveklabnik.com/posts/2013-06-25-removing-turbolinks-from-rails-4
Taken from: http://stackoverflow.com/questions/198460/how-to-get-a-random-number-in-ruby What is wrong with rand(range)? From Ruby Random Numbers: If you needed a random integer to simulate a roll of a six-sided die, you'd use: 1 + rand(6). A roll in craps could be simulated with 2 + rand(6) + rand(6). Finally, if you just need a random float, just call rand with no arguments. As Marc-André Lafortune mentions in his answer below (go upvote it), Ruby 1.9.2 has its own Random class (that Marc-André himself helped to debug, hence the 1.9.2 target for that feature). For instance, in this game where you need to guess 10 numbers, you can initialize them with: 10.times.map{ 20 + Random.rand(11) } #=&gt; [26, 26, 22, 20, 30, 26, 23, 23, 25, 22] Note: Using Random.new.rand(20..30) (using Random.new) generally would not be a good idea, as explained in detail (again) by Marc-André Lafortune, in his answer (again). But if you don't use Random.new, then the class method rand only takes a max value, not a Range, as banister (energetically) points out in the comment (and as documented in the docs for Random). Only the instance method can take a Range, as illustrated by generate a random number with 7 digits. This is why the equivalent of Random.new.rand(20..30) would be 20 + Random.rand(11), since Random.rand(int) returns “a random integer greater than or equal to zero and less than the argument.” 20..30 includes 30, I need to come up with a random number between 0 and 11, excluding 11.
Why do you need to register multiple users in the same test(s)? Is there no simple way to clean the database between tests, to allow re-registering of the same username? Could you do something like using `Time. now` instead of `rand` to generate unique usernames? 
Yeah, I know. I'm just wondering where the trend of capitalizing it came from (invariably by people who don't know its root/what it means).
You're right - it is precisely because this is only an example that the provided solution is overkill. In a much larger application, I could see many classes extracting their css-styling logic into separate classes/modules, e.g. `CssStyle::Date` or `Date::CssStyle`, depending on preference/design.
Really interesting - within 5 minutes of attempting to use Smart Answers, a 3 year old project with over **7,000 commits** I came across 3 bugs. Its interesting for a number of reasons: - the bugs are all pretty obvious (date/currency/navigation issues), I'm sure users will have reported them. Its obviously an active project, why is the feedback not getting back to development? - How does a project get this many commits and still have such obvious bugs? Insufficient QA? Failure to hand test due to a reliance(policy?) on testing frameworks? - Perhaps in answer, the tests are an absolute *nightmare* - Its hard to believe there is any code review, with beauties such as : add_response dd add_response :yes add_response 1.month.ago(dd) add_response :yes add_response :yes add_response Date.parse("10 September 2012") add_response Date.parse("10 July 2012") add_response "weekly" add_response "200" add_response "weekly_starting" Also, and I may well have under counted, **FIFTEEN levels of nesting**!! - I've been considering applying to them; it's nice to see a code base in advance ;) - Rather than just complain about it, we can actually fix it!
Its not noble, but it is an effective muse. 
It seems like Turbolinks was the cause. I disabled it and it seems to be working okay now. I know its hard to debug without seeing it. If it continues to be a problem I'll try to get my app to a test environment and post a link. Thanks!
Thanks for your help that seems to have done the trick for now. I'll keep an eye on it thanks!
It seems to have fixed stuff for me so fair. What else could be the cause? A memory leak of sorts?
This must be a joke. Please let it be.
But still there is no challenges above "Easy" level. ;(
Comfortable In Skin 
You can use `SecureRandom.hex[0..3]` to generate a four character hex.
[I can't tell if you're joking.](https://en.wiktionary.org/wiki/cis-)
Oh okay, I read your comment too quickly and thought I was being helpful. The reason people think it's an acronym is simply because more often then not short words with awkward pronunciations are acronyms, there's nothing more to it then that.
Makes you register before you can compile your answer
Sorry for my lack of knowledge on the subject.. ..still learning. How would you implement this in my particular case? I'm using something to the extent of "@browser.div(:name =&gt; 'q').set 'test_username'". How would I incorporate your code into mine?
"Don't look at an applicant's GitHub profile." "We look at applicants' Twitter profiles."
My least favorite things as I came to Ruby are: **Number 2** * the year 2009 in google search results. It must have been a good year for the language and the community. So many well written blog posts rise in the rankings. They are dated enough to be an occasional impediment as one gleans ones first googlesphere understanding.
My least favorite things as I came to Ruby are: **Number 3** * the year 2011 in github search results. It must have been a productive year. So much code. So many '"last updated 7 years ago" messages. I glad most of it still works well and the rest can be forked and updated.
Interesting that the 'no no it's those darn goober grimers' coming out to claim it is a 'false flag.' They're really having a bad string of PR lately, and will try to deflect. This is the same language and concepts I heard bandied about at uni. Fortunately, these companies will fail, and these SJWs will grow up and put their toys away when they have a mortgage and car payments.
Got any proof, Alex Jones?
I think it's stretching to say that it's a violation of POLA when the behavior is literally right there in the documentation. And as [Matz said](http://www.artima.com/intv/ruby4.html): &gt; [People] come up to me and say, "I was surprised by this feature of the language, so therefore Ruby violates the principle of least surprise." Wait. Wait. The principle of least surprise is not for you only. The principle of least surprise means principle of least my surprise. I think there's a potential point in the behavior of strings WRT `rb_obj_as_string`, but even that is stretching - it's nonsensical to have a String for which #to_s is anything but itself. It would in fact be surprising for such a thing to happen!
Yep, it's all just very basic one-liner "challenges" (more like tutorials) for the core library... Not exactly what I'd call "hacking"! The fact that all challenges have &gt;99% pass rates speaks for itself.
&gt; Github profiles tend to favor CIS White men over most minorities in a number of ways. CIS white men often have more spare time or chose to pursue building up an impressive portfolio of code rather than women or minorities who have to deal with things like raising children or instiutionalised racism. What the fuck?
&gt; Firstly, you could always just render the ERB template as a plain text file sadly, the templates will contain a ton of html, and rendering to plain text will just be messy. &gt; template.scan(/(\@[a-zA-Z]\w*)/).uniq Not every variable starts with @. Specifically in my context, none of them do. :( Your solutions also don't seem to address the simple issue that calling .result(binding) without a binding that responds to all messages in the template, will abort the rendering with an exception. The template rendering in non preview mode is done with the openstruct binding method as seen on stack overflow in multiple answers, so templates have access to arbitrary local non-instance variables.
&gt; Your solutions also don't seem to address the simple issue that calling .result(binding) without a binding that responds to all messages in the template, will abort the rendering with an exception. If you look at my last solution, what I am essentially suggesting is a slightly hacky (but not as crazy as the original post :D) method of wrapping all attempts to evaluate variables in a `begin ... rescue ... end` block. You could then `rescue` on an appropriate exception (perhaps `NameError`, instead of `ActiveRecord::RecordNotFound`?), to render the variable name instead of the variable's value. In other words, your ERB templates would just need to change from this: &lt;%= foo.bar %&gt; To this: &lt;%= TryEvaluate("foo.bar") %&gt; Or maybe there's some way of wrapping the `Erb#binding` method to do this automatically, without changing any of the template files... this could be a bit tricky, so I'd have to spend more than 2 minutes playing around to see if my ideas work :P Maybe you could do something clever with `Module#prepend` to ensure that all evaluated variables in your ERB binding are wrapped by the `TryEvaluate` class.... meh, I'll let someone else figure this out :)
Hi there, I'm the author of Phusion Passenger. We very much welcome contributors. In particular, we're looking for people who can help us with documentation. We intend for Passenger to be simply the best app server, whether code-wise, usability-wise or documentation-wise. That's why we want the documentation to be "perfect" (or as closely as possible), high-quality, easy-to-read, comprehensive. Lately we've been so busy with coding that we haven't had time to update the documentation. Why does the documentation need updating? We have a lot of documentation, but it's written in book form. But because of the sheer number of programming languages, configurations and operating systems Passenger supports, this book form is hindering readability. It is too easy for users to find information that is irrelevant to them, which may confuse them or overwhelm them. Furthermore, our documentation assumes that the user has some basic knowledge of system administration, Apache, Nginx, etc. That's why the manual doesn't "hold the reader's hand" too much. For example, it doesn't guide you through the installation of Nginx. This assumption was reasonable when we started Passenger in 2008, but it's no longer reasonable. There are lots of people nowadays who have never used Nginx, and become confused by the documentation. That's why we started out on a journey to overhaul the documentation in website form. This time, we divide the documentation in tutorials, guides, references. We have separate tutorials and guides for each programming language and operating system, so that readers only see the information relevant to them. You can see our work-in-progress here: https://github.com/phusion/passenger_library It's quite an ambitious project, so we can use all the help we can get. Do you identify with our goals? Do you want to take part in a popular project, and make it even more popular? Do you value usability and quality too? If so, let me know. :)
I was going to suggest passing in a wrapped binding that used method_missing to output the method calls, but that's basically what your CallRecorder is doing. I don't think that's too fucky to use in production at all.
I'm actually using two unpersonalized github accounts (one to show, and one to bug reports), don't have a blog. It's impossible to connect my LinkedIn account to github, unless I point you to.
This project strikes me as borderline cargo cult programming.
While it looks like you've already gone pretty far with ERB, have you considered storing user templates with something like Liquid? If you started down that approach you could create custom liquid "drops" that would make it trivial to track and display user variables.
It _is_ a gotcha though; the fact that it's documented doesn't keep it from being a gotcha (and stdlib documentation quality and exhaustiveness can definitely vary). I have had troubles in these areas when sub-classing core classes before. I still do it sometimes. The issue is that the style of programming ruby encourages, and which the community tends to use, involves lots of use core classes. Many/most methods taken Strings, Arrays, Hashes, or combinations of same as arguments, this is quite common in ruby. So you often have times when you want something that really is _pretty much_ like a core class, so you can conveniently pass it to all these methods expecting such, but you need or want it to behave _slightly_ differently in some way. So sub-classing a core class seems like a good solution. But it really does lead to lots of gotchas, I think most people sub-classing core classes have run into the kinds of problems the OP talks about, even if they have spent time with the documentation. One suggestion would be that `#to_a` and similar methods _ought to behave differently_ to make sub-classes of core classes more conveniently behave in ways it turns out people usually want. But as the OP points out, the reason the methods are as they are is likely performance-related. I suppose you _could_ over-ride #to_a and similar methods on your subclass, to behave the way we usually want it to for sub-classes. It might be hard to catch exactly which methods need to be overridden in what ways to match your expectations, you might still find unexpected gotchas, and it might have non-trivial performance implications. The ruby core/stdlib definitely isn't always implemented in as consistent/DRY manner as one might expect from an OO point of view. For instance, i am regularly frustrated that while you might think `Hash#[]` would be implemented in terms of `Hash#fetch` or vice versa, and overriding one would effect the other -- in fact it does not, somehow they are completely independent and you need to override both to change their behavior consistently. These are the kinds of things that happen when you start subclassing core classes -- in this case, there is no documentation explaining the implementation relationship of `fetch` and `[]`, and maybe there should be and maybe there shouldn't be (and maybe it can even vary between ruby implementations, which could be a nightmare) -- but it's not really a documentation problem, it's that the _way it works_ is not ideal for concise, DRY, maintainable changing of behavior by overriding. You can document a system which doesn't work in a convenient way all you want, it's still a system which can be inconvenient or challenging to make work reliably, with lots of unanticipated behaviors -- I think this applies to the sorts of issues in the OP too. 
No-one should follow the these guidelines blindly, but evidence has shown that small classes and short methods lead to easier-to-maintain, better-structured code. There will be times when you need to make an exception to the rules, based on your professional experience and judgement as a developer. For these situations you can add an ignore entry to the configuration file.
I'd heard of mini profiler but not flamegraph. I'll have to give it a try
I would say most of my code naturally fits within these parameters. My comment had a different motivation. "Cargo cult programming" has a specific meaning. While it's true that programmers who have learned to write good object oriented code tend to leave commits behind that follow these constraints, that doesn't imply that following these constraints will lead to good code (or teach good object oriented design principles). Use of this tool will encourage teams to conflate the aesthetic traits expressed *by* well structured code with inherent qualities *of* well structured code. That reeks of cargo cult programming to me. The fact that the tool is actually named after Sandi Metz puts it over the top for me, like life imitating art.
The well-grounded rubyist was a fun read and really informative. Also if you have an e-reader, a lot ruby books can be obtained online
"Programming Ruby 1.9: The Pragmatic Programmers’ Guide" on the sidebar is gold. It includes 2.0 in the more recent versions, and isn't out-of-date enough to make it a poor resource.
railstutorial by michael hartl I think is the best way to learn rails. A teeny bit outdated...not sure if he's updated it recently, but you'll get the gists down. 
Seconding Well-Grounded Rubyist, it's absolutely fantastic.
Thank you for the recommendation. Will burn all notes and switch over to *learning the hard way*. ^^ba ^^^dum ^^^tss I'll probably finish up the rest of my courses (~80% done) and switch over that way I have some sort of foundation :) 
As much as I want to agree with you, at least the syntax and basics are the same. The jump isn't that extreme. 
I can't say there would be one particular bible. However, there are some books that I always recommend: [Metaprogramming Ruby](http://www.amazon.ca/Metaprogramming-Ruby-Program-Like-Pros/dp/1934356476) [Ruby under a microscope](http://patshaughnessy.net/ruby-under-a-microscope) [Ruby Hacking Guide](https://ruby-hacking-guide.github.io/) And for general object orientated programming: [Practical Object-Oriented Design in Ruby](http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330) I recommend the last one if you're a beginner. 
+1 these two. I'd also recommend [Growing Object Oriented Software Guided by Tests](http://growing-object-oriented-software.com/)
I would say Metaprogramming Ruby. It helps you understand the conceptual core of Ruby and it's object model. It helps you understand the very fundamentals of Ruby as a language. It's not a great book if you're learning the basics, such as syntax or general programming paradigms. It focues on Ruby itself and the features that distinguish it from (and is inspired by) other languages It's a great companion piece to Dave Thomas' series of [videos](https://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming). 
Just be aware that the updated garbage collection in 2.1+ isn't accounted for, and Dave Thomas has moved on to other languages at this point.
For the basics of ruby itself, probably: https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0 I haven't used this 4th edition, I used I forget the 1st or 2nd edition on ruby 1.8.7, but the 4th edition is apparently updated for ruby 2.0. (Which is probably good enough, changes between there and 2.2 are not huge). 
[Dash.app](https://kapeli.com/dash)
It depends on what you mean by a "Bible". I read Ruby books when I'm on vacation to enhance my thinking at a high level, but when I'm down in the weeds there is no book that is as useful as the reference documentation: http://ruby-doc.org/core-2.2.2/ http://ruby-doc.org/stdlib-2.2.2/
POODR.
I can do this. Msg me.
I actually use [Dash](https://kapeli.com/dash) as my ruby bible. Yeah, its standard docs, but they're tremendously well written, and having them a keystroke away (hyper-D) is super convenient. For learning, I went through the Pragmatic Programmers guide (pickaxe) and Agile web apps with rails (again, from Prag. press). I got the e-book versions, but found, once I was well versed in ruby, I didn't need a book quite so much
It's times like now I wish I was on a Mac
Why wait? http://www.r-5.org/files/books/computers/Russ_Olsen-Eloquent_Ruby-EN.pdf http://web.informare-publica.org/offers/signum-offer-complete.pdf 
This is also something I was looking for, because I had heard that the Ruby community has established a standard/code of conduct for code readability and style. Thanks!
Get to know [`Enumerable`](http://ruby-doc.org/core-2.2.2/Enumerable.html) like the back of your hand.
The term bible usually refers to the most authoritative book one can find. In my opinion, there's only one - The Ruby Programming Language by David Flanagan and Matz ( the guy who created and still maintains the ruby language ) I don't know if there is a version for 2.2 ( I doubt it ) since it requires a lot of work to write a book such as the one above. If you find the writing dense (It's meant to be authoritative) also check out the pickaxe book for a more beginner friendly intro to the language.
I would change "use #each over for loops" to "use #map over #each". In all seriousness though, that's a great style guide.
You could probably also do: rake :run do `rustc func.rs --crate-type=dylib` code = $? load 'script.rb' if code end
Didn't know about this one. Thanks!
+1 these three. GOOSGBT (?) is really a fantastic book. The London TDD Cycle absolutely changed the way I see testing and changed my whole approach to code. 
http://www.ruby-doc.org/
I have a 'build.properties' file with properties like db_dir_with_path=${dbdeploy_dir_with_path}/sql/#{environment}/${db_local_releases_dir} When I import the file to ruby with Utils::Properties.load_from_file("build.properties", true, properties) Those ${} and #{} values need to be replaced with the value of variables of equal name residing in ruby. 
Does this method work well when you have comments in your config file?
Is this the gem you're using to load the properties? http://www.rubydoc.info/gems/properties-ruby/0.0.3/Utils/Properties It looks like it evaluates references based on the existing properties object. Before you do the load_from_file, can you do something like this? properties.add_property("dbdeploy_dir_with_path", "/some/path") properties.add_property("db_local_releases_dir", "releases") Utils::Properties.load_from_file("build.properties", true, properties)
~~You are right, it does change the ${} ones. Not the #{} ones though.~~ edit: nevermind. I will just pass the variables as in your example. Thanks very much.
Thanks for the tips, I liked the variable assignment using begin..end, very cool!
Wasn't aware of OpenStruct, thanks. So the I should just stash it as Constant on the top object?
While it's still a good tip, the begin/end comment isn't strictly accurate... the code they pasted would work the exact same way even if begin/end were removed. In ruby everything returns a result, including if blocks. I do agree that in more complex situations begin/end can be useful in communicating the purpose of a block, in this case, however, its a bit confusing because it changes nothing.
If you're a beginner, I would bear in mind that there is very little difference between versions of Ruby and how the language is structured. Ruby 2 and onwards has some minor syntax differences, but most of the big changes are under the hood (garbage collection etc).
+1 dotenv-rails is great for doing this.
* Keep methods short. * Use classes not too sparingly. * Use global variables with extreme caution and avoid them where possible.
It's great, but it's not a reference book for Ruby.
Sure you can easily mock them for testing purposes. around do |example| original_config = $global_config $global_config = $global_config.deep_dup $global_config[:something] = "mocked" example.run $global_config = original_config end No? That might be another reason I'd use a global var instead of a true constant, to avoid ruby complaining when I change it. 
Right, I should have used the block. "${myvar}".gsub(/\${(.*?)\}/) { eval($1) }
You can use the built-in encryption functionality. For instance, Chef's encrypted data bags use the standard library's OpenSSL Ciphers: http://ruby-doc.org/stdlib-2.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html
Are you the one writing this up? Because.... I'd really, really like to get all the parts. lol. This is great because it has you working and learning something that isn't just a basic 'hello earth' bit and has you solving some problems that you'll run in to in real life of coding.
I use TutorialsPoint for anything quick that I don't remember right off.
Annnndddd Subbed! 
I see the point that the basic problem solved by strong parameters is one of data validation, which properly belongs in the model. But attr_accessible came from the recognition that properly validating each data field against every possible malicious value was too hard a problem for most apps to solve in practice, so we should stop the value from even getting assigned based on what source the data is coming from. And that makes it a concern that properly belongs in the controller. So I think strong parameters is a step forward in that respect. As to the complaint that the require/permit syntax is a poor man's JSON Schema and should be actual JSON Schema instead, I’m not sure I agree. There might be some value in having a lightweight version that doesn't drag in all the complexity inherent in validating data types.
Saying "an error occurs" is not so helpful for anyone trying to help. What does the error message say? The simple way to debug something like this would be to add `puts` statements after each of the important lines so that you can see the values of the variables as the program executes.
Not a book, but the Ruby Tapas screencasts (rubytapas.com) came highly recommended to me.
Thanks Andyw8 Updated the post to include the error message. The put statement returns the same phrase, 'ruby mechanize'. The whole function works only if I manually input 'ruby mechanize'.
Giles sez: strong_parameters really only makes sense if you haven't noticed basic things about the Web, like the fact that HTTP has a type system built in. Are folks building apps that use the `Content-Type` header for API versioning? I could see that happening, stands to reason... I've just never seen that happen.
CCP Games uses Content-Type to type the response data: &gt; For example, to request a JSON formatted vnd.ccp.eve.Api-v1 representation of the API entry point, the client would set the Content-Type header to "application/vnd.ccp.eve.Api-v1+json". https://developers.eveonline.com/resource/crest
Interesting, thanks!
Thank you for the quick, concise reply!
Not sure if folk etymology or backronym
From a design perspective, I think objects should (if at all possible) be initialized with their attributes and then never be mutated via setter methods. This tends to avoid bugs.
Hmm.. I'll have to try that, makes sense! Thanks. 
^This, don't set instance variables in rspec, ever, your setting yourself up for a bad time.
The reference I use the most is built right into Ruby; ri 
ActiveRecord would like to have a word with you.
Thanks for the inspiration! 
I fail to see how IRuby is a kernel - it seems more like an environment to me.
I suppose because integrated (end-to-end) tests are awfully slow and don't necessarily cover issues your unit tests should already be testing. I'm not a zealot about it one way or the other, but I'll leave you with a couple of resources on it: [INTEGRATED TESTS ARE A SCAM](http://www.jbrains.ca/series/integrated-tests-are-a-scam) -- start at bottom of article series [Martin Fowler on Integrated Tests](http://martinfowler.com/articles/microservice-testing/#testing-end-to-end-tips) (use arrow keys to move through presentation)
Modern JS development means that JS is transpiled to JS (yes, the language has reached that level of insanity *checks to ensure he didn't say that in the JS or webdev subs*). If the transpiler is reliable and provides the tools needed to debug, I wouldn't worry too much about the source language anymore. 
Who would figure that a small joke at BaRuCo would get to this! eheh... truly impressive!
Compact and inscrutable, like the Python example: s = (10**ARGV[0].to_i).times.map {|int| format "%0#{ARGV[0]}d", int}.join printf "1/%d", ((10**s.length - 1) / s.to_i) I'm not even sure what the purpose (if any) of the example is so it's hard to clear it up.
Just exaggeration. There are development gains to be had and others to be lost. 
no, in Ruby it is ARGV[0]. and $0 is what you think should be in ARGV[0]
Don't write the assertion part.
A week ago called and wants its post back. http://www.reddit.com/r/ruby/comments/35aj43/timeout_rubys_most_dangerous_api/
this is what a friend shared with me. https://github.com/alexdalitz/dnsruby/blob/master/test/test_utils.rb#L12-29
some documentation for refactoring later # grab the first parameter passed in from the command line # store it into the local variable n as a number n = ARGV[0].to_i #concatenate every n digit number in order with padded 0s #e.g. n = 1 produces "0123456789" # n = 2 produces "00010203040506...9293949596979899" # n = 3 produces "000001002003004...995996997998999" s = (10**n).times.map {|i| "%0#{n}d" % i}.join # I have no idea what the following line is supposed to do # I'll update this when I figure it out # e.g. (10000000000 - 1) / 123456789 == 81 # (100000...(100 zeros)...00000 - 1)/102030405...(from n=2 above)...949596979899 == 9801 puts "1/%d" % ((10**s.length - 1) / s.to_i)
I documented what I could up above, but I couldn't figure out a description for the last line.
Ignorants: World's Most Dangerous Species
This is *awesome*! I found out about Jupyter and wondered if there was anything for Ruby yet. Edit: The github source https://github.com/sciruby/iruby
What exactly do you mean by this? 'Functional' doesn't have a rigid definition - many languages allow you to pass around function abstractions, and Ruby is no exception. Do you mean using more immutable objects and less global state? 
You might want to watch [Tom Stuart's talk on ruby+monads](https://www.youtube.com/watch?v=J1jYlPtkrqQ).
Also, don't `rescue Exception` in your code. This will catch ALL exceptions, including - for example - SIGINTs from pressing ctrl+c. You should almost always only `rescue StandardError`, or one of its sub classes. 
Yes, I mean I am trying to reduce state as much as possible in code. I happened to see [this post](http://blog.codeship.com/ruby-class-to-write-functional-code/). Have been writing code like this for sometime, but I think this isn't exactly functional though he seems to argue so. Off-topic: For instance have a look at my [attempt](http://exercism.io/submissions/736312a54538483ea43cefdb07592e8d) to remove state; do you think removes all state? I fail to understand why its not.
&gt; I gave several examples of when making such a change is non-trivial, or even would not be possible. No, you gave these examples of costs of switching *to* InfraRuby: &gt; * What happens when there is lots of repeated logic about which rake tasks to run on deployment, inside loads of Jenkins jobs? [...] &gt; * What happens when deployments are made as a complete image to a VM, where there is a strict policy that no unused packages (i.e. InfraRuby) can be included on the disk image? &gt; * What happens when management insists that the Staging server, Demo server, VMs set up for pen testers, and so on, are configured with exactly the same setup as Production, to minimise risk? [...] For those examples, I outlined how you could use either the InfraRuby runtime or a Ruby interpreter, with a flag, and I have explained how you can *know* that you can use a Ruby interpreter with zero switching cost, by using a Ruby interpreter for development and testing. And, obviously, there is a cost to integrate an InfraRuby project into your configuration, just as there is a cost to integrate *any* project into your configuration. &gt; Your response was simply (and I am quoting you directly this time): "That's still your problem." No, my response for those examples (of switching *to* InfraRuby) was simply: we can give you advice on how to integrate an InfraRuby project into your configuration. You also gave these examples of costs that have nothing to do with InfraRuby: &gt; * What happens when someone insists on doing a "hard" switch off infraruby [...] &gt; * What happens when you get lazy [...] If you wish to change your coding style or test coverage then that is your problem: it is not a cost of switching from InfraRuby, even if you decide to do that at the same time. (And don't quote me out of context again, thanks.) &gt; I'm saying that in InfraRuby, because all methods require a signature, you need to write ugly unidiomatic code such as ensuring the initialize method returns a known type (probably nil), which probably involves the use of weird returns stuck in your code. No. &gt; Even if you were to avoid using the return keyword, you'd still need to write nil at the end of a method, or have some methods defined as "returning" arbitrary types, for no good reason. No. &gt; In order to remove all of this ugly code, which InfraRuby DOES require you to write, in order for the code to compile, there is significant cost. No, the InfraRuby compiler does not require any such code. &gt; There is no "zero cost" [...] switching from InfraRuby, in the real world. It's amazing what you can prove when you just make stuff up. 
That's how I read it :)
If you are into Ruby FP, you might dig this [blog](http://www.rubylove.io) and these [screencasts](http://rby.io/r/5509d6/e/decorating-ruby-classes-to-extend-behavior) Rubycasts.io is also listed on the right bar over there -------&gt; Admission: I am the author of both and a lover of 'lispy, immutable ruby' Keep it up and don't let the little punks on reddit get you down. It is easier to be a one liner troll than to create real content or to think deeply about something :)
Corey's 4 Simple Rules Avdi's Confident Ruby Sandi's POODR
We get it. The moment someone learns about the Maybe monad in Haskell/&lt;insert other language&gt; they have to immediately blog about it + give their own broken Ruby implementation and post to reddit. 
&gt; Using exceptions as part of the interfaces of your objects forces callers to handle those behaviors. Actually, it doesn't. You can easily deploy code to production without handling the exception (just like you could ignore `nil` cases). One way to _force_ the consumer to handle all cases is to use continuation-passing style combined with required keyword arguments like so: def find(id, found:, not_found:) # ... found.call(object) # ... not_found.call end find(2, found: lambda { |r| puts r }, not_found: lambda { puts "error" })
The other solution to the problem he's describing (again, assuming the `User` class is his/our code) is the null-object pattern, which in the context of a User object is commonly called a "guest user". The guest user has a name, no authorisation to do anything requiring any privilege at all, etc. You don't *need* monads outside FP in general and Haskell in particular. Granted, all the Kool Kids™ are cargo-culting it now, but that's been a clue to me, several times over my career, to avoid it until it gets less trendy and more useful.
This makes things a lot easier. Awesome.
Yes and no. I agree the concepts are generally more powerful and ultimately useful. That said, coming from an OO background it was really hard for me to grasp abstract functional concepts without concrete examples in a language I was familiar with (for me it was JS). But to each his own, as always. FWIW - your point about readability and idiomatic Ruby is pretty dead on. In the case of JavaScript, where solid idioms are few and far between, and functions can easily be passed around, there isn't much of a sacrifice when converting to a functional style. In Ruby, it's a much bigger decision, due to some of the more unconventional patterns you need to use.
Thank you! Yeah, looks similar in the approach :) I already had Sidekiq jobs which got more and more complex dependencies on each other so I decided to make a runner which takes care of that. Actually the Sidekiq part could be put as an adapter and made possible to write support for more backends, as gush's dependency resolving is indepdendent from actual job running. With a bit of tweaking it could easily support Resque or (for those dinosaurs out there) DelayedJob :)
Thanks for posting this. I've been looking at functional languages in a new light recently. 
Its very young, and doesn't have much chance of derailing CTags now, but I'm excited to see what it turns into! 
Happy days \o/
I'm a bit peeved that an introductory Ruby course has you using RSpec instead of something simpler like [minitest](https://github.com/seattlerb/minitest). RSpec does a lot of "magical" things with its syntax and its behavior is often surprising even to Ruby veterans. In other words, if there's something about how RSpec works that you don't understand, you're probably not alone. Don't let yourself get discouraged if it confuses you.
You don't *need* methods outside OOP, but it's still a useful tool to know about.
Yeah, I'm aware of it, unlucky coincidence because it's named after a stream (since it's workflow - &gt; flow - &gt; gush :) ) 
&gt; One of the things learning Rust has made me realize is how much I wish Ruby had sum types. Not sure how useful sum types are in a language without static type checking. For any arbitrary types `A` and `B`, you can just declare that your function accepts their sum type. For example, using YARD syntax: # @param foo [A,B] some value that is either an instance of A or an instance of B. def my_method(foo) ... end Bam, there you go. Sum types in Ruby. Or to reuse the example from the blog post: # @param foo [User,NilClass] either an instance of User, or the value nil. def my_method(foo) ... end
Okay, I'll take the bait. I find this comment very unconstructive, mean-spirited, and smug. Imagine how a new Ruby user would react to this. I learned something new, experimented with applying it to what I already knew and shared my thoughts with others. The message I get back is that it's just annoying and because I didn't solve the problem being discussed my effort and intentions are worthless and unappreciated. It doesn't matter if you've seen it before or are "tired of it." Other people may not have, and may benefit from it. The way to criticize is to point out technical flaws that you see and offer alternative ideas and viewpoints, not to roll your eyes and say, "what a noob." This is the kind of attitude that drives people away and fosters a bitter, cynical, poisonous community.
Thank you, I will check it out :-)
Interesting. Thank you, I'll give those a read! :)
Not aware about any extensive Ruby project written strictly/mostly in functional style. It may because most of gems and core/stdlib do and their API expect state alteration and procs/lambdas/methods as first-class citizen objects are used rather sparsely. After being excited by programming in Haskell (pure functional language) I started wrote in more functional although impure style in Ruby, including several plugins for a project. Unfortunately their sources may not be published. I'd deeply recommend learn Haskell to write more elegant and parallel processing ready code, even in other languages. 
I recently found out that the stuff done in the aforementioned RailsCast is part of Rails since 4.2: http://api.rubyonrails.org/classes/Rails/Application.html#method-i-config_for
Code looks simple enough and clear. Writing specs should be easy. Start with writing specs for your Parser class. Testing in a nuthsell: 1. prepare input (HTML page in your case) in spec/fixtures 2. use that input in your Parser class 3. check if your code properly extracts all the info it should from the page.
I just skimmed the code, but two things caught my eye: - don't use `puts`. Other applications using your gem may not want to log to STDOUT. Try [setting up a logger](http://stackoverflow.com/questions/11729456/how-do-i-log-correctly-inside-my-own-ruby-gem), instead. - you have a few minor [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide) violations. Check out [Rubocop](https://github.com/bbatsov/rubocop) for all your automated pedantry. And please, test all the things, both units and functional/integration, as appropriate. If you're not familiar with it, [VCR](https://github.com/vcr/vcr) is a nifty gem that will allow you to record/mock out your actual interactions with Steam. 
&gt; I often forget the exact form and go to copy an existing one This statement combined with your calling it an "incantation" belies a fundamental misunderstanding of `env`'s purpose, and even suggests that you might not realize it's just another program.
Sorry, it wasn't so much directed at you as it was directed at a general frustration with the same damn thing being blogged and posted to reddit again, and again and again. I also spent some time learning Haskell, and i found the Maybe monad interesting but I didn't write a blog post on it as "Intrepid Rubyist discovers Maybe monad for the first time" has already been done to death. I'm sure i'm not the only one sick of hearing about it. But I do apologize if it offended you, and now i notice it, your article does have some interesting discussion of Rust that makes a good read. I think maybe if you'd title'd the post more as Rust vs Ruby comparison it would have garnered more interest. Rust does look cool!
I'm assuming you are starting out, sorry if that's not correct. Congrats on putting yourself out there. It takes guts. My first code projects were really bad but it doesn't matter. Everyone starts somewhere. For learning testing, start with something simple. Write a calculator. Then write a baseball score counter. Then try to simulate baseball (without graphics). The baseball part isn't important, what's important is taking little steps without taking too much on. If you start with tests on these simple projects, and keep practicing, soon it will feel natural. I cannot work without tests. It's too much habit (which is good). That doesn't mean I just bang out code like some divine entity. It's still hard work and I make mistakes. Knowing what to test, if your tests are too much or are too little is hard. Listening to tests that might be suggesting bad design is even harder. Mocking external services is crucial. VCR is a good suggestion by @quartern. Learning VCR is kind of it's own thing. There's some weird gotchas if the external service has like time based changing checksums (amazon has this for signing). But don't worry. Just try to remember that some gems are complicated. If it seems hard, it probably is so don't get doubt-tangled. The real reason you want to learn VCR (or more techniques like this) is you have a comment in the commit "I removed tests". This isn't good. If you continue to do this you'll hit a wall. Your projects will be about the same size and same level of ambition. You won't be able to create a medium sized project. You won't be able to work on medium sized ideas. And that's what is sort of an inflection point. If you know how to test and design, then larger projects won't fall apart in your hands. You'll be more likely to change them when the world or your information changes. Let's say that you find out later that Steam has a non-rest API that lets you do game searches in a better way (just pretend for a second). Does your app make this new information (new to you) easy to deal with or does the whole project seem "un-repairable"? Sometimes big changes are big and painful no matter what. The idea of growing and learning as a developer though is to have the ability to create projects (when you need to) that have the ability to deal with change. All this is easier said than done. I can blah blah blah all day and not send you a pull request because it's easier to spectate on your project and not contribute. :) Watch some TDD and Rspec youtube videos, sign up for codeschool if you can [rspec on codeschool](https://www.codeschool.com/courses/testing-with-rspec). Nice work.
When you don't think you need something as heavyweight as Rails, go Sinatra. But Rails is pretty great for making an API.
Sinatra
Sinatra is as basic a framework as it gets. It's just a wrapper around Rack, which gives us the most low level web tooling. what exactly are you trying to achieve?
Thanks a lot for the comment. Regarding the "removed the tests" commit, I just got rid of them on the version I pushed because I was going nowhere and wanted to push the gem even though the tests werent written, I'm working on it :) I was looking for a starting point for TDD, and your codeschool link might be the one, thank you !
Don't get me wrong; I'm not discouraging output. I'm just suggesting you render your output in a way that allows users of your gem to control the output. Sometimes people want debugging output, but uncontrolled (and uncontrollable) output can be annoying.
These are things I think you could improve: - There is YARD style documentation, but it is not correct. For example, SteamStoreParser::BaseClient#page documents that it takes a Hash as a parameter, but it does not. Also something like `# @return [String] Webpage` is not particularly helpful. Maybe you want something more like `# @return [String] the HTML source of the page`. Personally I'd just get rid of the documentation for now. I only tend to add docs when the project gets very big and stable. - The common naming convention for gems is that if it is named `steam-store-parser` it would be required as `require "steam/store/parser"` and contain a Class/Module called `Steam::Store::Parser`. Also IMO, what you've built is really a Client, not a Parser. I suggest changing the name of the gem to `steam_store_client`. - The methods in `SteadStoreParser::Parameters` are redundant. Just use `SteamStoreParser::Parameters::TAGS.fetch(:casual)` and it'll raise an error if the key is not found. - In `SteamStoreParser::Parser#parse_games` you can use `times`, `map` and `flat_map` instead to clean the code up a bit. See https://gist.github.com/jnicklas/4cab971ac755ce501836. Haven't tried this code, but something like that should work. - Personally, I dislike when libraries do so much heavy lifting in the constructor. Perhaps `SteadStoreParser::Parameters#games` could do all of the work, as opposed to doing it in `initialize`? Don't fret about it though, I think you did a good job. The code reads nicely and is well structured.
* Yeah I forgot to change it, I just wanted to write a piece of YARD doc as a personal reference. * This seems weird to me, I don't know, almost like it's an official Steam gem. But you're the knowledgeable one, I'll catch up on that. * Thanks for this, I knew this wasn't DRY enough but had no idea (nor energy) to do that properly. * Same here ! * I suck at organizing my code, and there aren't really any resources about this, it only comes to experience and communication with knowledgeable people, and for this I thank you a lot :) I only want to improve, as I enjoy constructive criticism, that's really helpful, thanks ! 
I'm the author of Sidekiq. Sidekiq Pro's [Batches](https://github.com/mperham/sidekiq/wiki/Batches) are my API for creating complex workflows. I assume you've seen them and decided to build your own thing?
The person who advised you on that is incorrect. That program has no global state, you are correct. 
Ruby is awesome. I kinda wish I could always write Ruby and nothing else. It's well designed and easy to do a lot cleanly with little code.
Have you started a new rails project yet? I'm not sure what you mean by open
What distro are you on? Ruby and Git are packages and Bundler and Rails are gems. Once you have Ruby you can `gem install rails` to get Rails and Bundler.
Brightbox provides nice up-to-date apt Ruby packages for Ubuntu, which I'd guess would work perfectly on Mint: https://www.brightbox.com/docs/ruby/ubuntu/ That way your Rubies stay updated with the rest of your system via the package manager. Or if you want more flexibility check out ruby-install for installing and chruby for switching between Rubies.
static analysis isn't so useful for Ruby IME. However, you can do great things if you have a process that's wired up to the live code. Some of the magic in Pry and friends could be utilized and extended to provide some fantastic features to an editor.
Sinatra's [about page](http://www.sinatrarb.com/about.html) pays him the following homage: &gt; [**Frank Sinatra**](http://www.sinatra.com/) (chairman of the board) for having so much class he deserves a web-framework named after him. Given the library's GitHub description ("Classy web-development dressed in a DSL"), there seems little reason to suspect that the name is anything more than a tribute to a great man wrapped in what some might call a pun.
Try `\curl -sSL https://get.rvm.io | bash -s stable --rails`. This will install stable Ruby + latest Rails via RVM.
This looks really interesting but its VERY difficult to understand what it is from a quick look - can anyone supply a quick overview?
ah, /r/ProgrammerDadJokes, you never fail to amuse me
After you have installed ruby: `gem install bundler &amp;&amp; cd my_app &amp;&amp; bundle`
#!/usr/bin/env ruby is too difficult to remember?
I'm glad they acknowledge it and they're very right. The Chairman deserves a code legacy. What I like almost a little more are all the inspired-by frameworks - NancyFX in .net, for his daughter, or Martini on Go, for his favorite drink. 
I do have the text editor. I don't fully understand the terminal. I'm fairly new to it. I've been doing all my Ruby coding practice on the cloud9 website. 
You'll want to at least follow a rails tutorial if it's your first time encountering an MVC framework. While rails does a great job with organization and such, it will be very difficult trying to figure it out on your own the first time around. That said, the hartl tutorial is kind of a gold standard. 
Ruby 2.2+ needs libffi-dev as well. apt-get install libffi-dev
Congratulations! For someone that only knew HTML and SQL, that's quite an accomplishment, well done. You should definitely put your skills to test. Reading books only takes you so far. *Create something*. Think what you would like to create for yourself. Start with something really simple and work your way through, adding more features to it. You'll find that it's a lot more fun to dedicate your time and brain to something that's *yours*. When you find yourself asking the right questions, you'll realize what you'll need to learn next. Keep it up!
yeah - this was posted here in error - sorry
Grape can just mount in rack: https://github.com/intridea/grape#rack I've used Grape several times. It works pretty well. It's also highly compatible w/ swagger, which is nice if you want to have API documentation.
While I bet this tool was a bit of fun to make, you're using a sledgehammer to crack a nut... [All you're really doing](https://github.com/bglusman/shabang/blob/master/bin/shabang#L84) is prepending `"#!/usr/bin/env #{options.language}"` to the top of a file. As well as the obvious question (is this really so hard to remember/google?!), and the [obvious limitations of your script](https://github.com/bglusman/shabang/blob/master/bin/shabang#L10), you could have pretty much achieved the same result with a one-line `sed` script!!
Yup, shameless plug for [pippi](https://github.com/tcopeland/pippi#pippi) which does some of that.
Yeah, I was originally going to do that, but then I thought about supporting options and hadn't ever played with stdlib OptionParser before, so easy excuse to learn it a little bit, though I didn't find an easy way to flexibly either take the filename as ARGV[0] OR an option passed by --filename flag, depending on whether such a flag was present... but this was a 30 min project so I didn't try that hard.
Just let it go man, /r/ruby is toxic w.r.t. this stuff. Lots of smug expert beginners in here. Enjoy the FP journey but don't waste the effort posting it to /r/ruby.
Please, tell me which of my arguments aren't valid. I'm programming actively for 4 years, and the thought of having to do cross-browser testing, responsive design, frontend optimizations and writing JavaScript tests makes me dizzy. If you're managing all of that, then kudos to you. As for performance, I think that rendering templates still takes significantly longer than rendering JSON, but to be honest I haven't benchmarked. And if we assume that a JS framework renders templates with the same speed as Rails (although this is dubious assumption, since Rails has to compile always, and JS's one are cached on a CDN), then that means that server is now doing less of the work (because the browser is doing it now), so that for me means better scaling.
next, on idiosyncratic-ruby.com 10 different ways of doing the same thing!
Coming along nicely. I'm curious about the difference in relationship and repository names? You extend from `ROM::Relation[:sql]` and the repository is of type `:sql`, but is apparently named `:default`? Also, overriding `String` to be a method in the migrations seems risky, imho.
`ROM::Relation[:sql]` is a relation subclass from `:sql` adapter. It's not like in Sequel where it's name of the table. And migration DSL is Sequel's, I don't like it too. There's an alternative DSL though like `column :foo, type: String` which I should start using instead :)
LOVE IT!
You can specify `repository :one` and `repository :two` in relation classes and then just do `rom.relation(:rel_from_one).combine(rom.relation(:rel_from_two).some_method_that_knows_what_to_do)`
As a few others I also usually copy the shabang from an existing one sed -i "1i $(head -n1 /path/to/known/file_with_shabang)" your_file (the above does not work if the file is empty). [Edit] Formatting..
[Why GitHub is not your CV](https://blog.jcoglan.com/2013/11/15/why-github-is-not-your-cv/)
It means that the font is assembled _programatically_ by [this Rakefile](https://github.com/sunaku/tamzen-font/blob/master/Rakefile). In particular, each BDF font is parsed into [a Ruby data structure](https://github.com/sunaku/tamzen-font/blob/master/Rakefile#L21-L44) and some of the glyphs therein [are backported from](https://github.com/sunaku/tamzen-font/blob/master/Rakefile#L100) different versions of the font. In addition, Powerline symbols [are injected](https://github.com/sunaku/tamzen-font/blob/master/Rakefile#L149) into the fonts in a similar fashion.
Man, I don't really know what any of that means, but it seems like it's just compiled into one file from a bunch of different, pre-existing files. I guess by some definitions of "built" that makes sense, but I was thinking it was some sort of ground-up approach.
Yeah, this is more like a programmatic _remix_ (slice and dice glyphs from various versions of pre-existing font files and put them back together in a specific way) than a procedural generation of BDF fonts from scratch.
When would you need to write this and why? I've never had to do it, but I havent written many scripts.
Bit hard to say without knowing how exactly in depth you've learned your skillset. Assuming you have put the effort and are at a proficient level, I'd say try and apply anyways. I've found many of those minimum requirements are merely just there to weed out those who don't feel confident in their abilities. Other than that, diversify. Pick up some other skills outside of rails that developers commonly end up using (sql? Js etc.) 
NIH? Not in house?
*Python-ism*? This (like all the rest *zen* rules) are exactly those things that are always violated and has nothing common with how people write code in Python. Even the Python itself has nothing common with its *zen*.
Ignore the 3-5 years "requirement" and apply anyways.
All of the feedback here is really good, so I just wanted to say good job :) It took me ages to work up the courage to create my first gem :)
Fairly alarmist, but it does bring up some good points to consider.
How long ago did you start? Is Odin project your first foray into programming? Programming is something that comes with time and experience for most people. You are just learning a skill, you are learning a whole new way of thinking and problem solving. Are there specific problems you're having, or just trouble understanding broad concepts? If it's broad concepts, then I'd say just keep chugging along until you can't complete a project. It's hard for some people, but trying to understand every concept of programming before doing it is really, really tough. Concepts will make more sense if you have some context from projects.
&gt; Unfortunately, I think the only way to solve this problem is to voluntarily demand better code quality. &gt; There are a lot of things that the Ruby language allows you to do that you shouldn't. Compound this with the prevalent functionality-now-quality-later mentality, and it's easy to hit a point of no return. This is why I wrote that we need to actively poor technical solutions and encourage people to do better. This is especially true of the "things Ruby allows you to do but shouldn't category". (e.g. monkey patching). 
1) Check out how others have solved similar problems. ie Think of a game other than tic-tac-toe in places like rubyquiz. 2) Think about how you would solve this conceptually ie don't write code but write down the classes and methods that would be most helpful in solving the problem. 3) Try filling in the classes and methods above with pseudo-code ie low level english descriptions of what the methods do etc 4) Now check out how other programmers have solved the problem in rubyquiz ( or similar sites ) 5) Run different solutions from the command line to make sure it works. 6) Now try running the solution through the command line debugger and step through the code one line at a time. 7) Do step 6 multiple times till you get the hang of it. 8) Now go back to your original conceptual solution, and try to convert the pseudo code to actual code, one line at a time - and run it through a debugger. Iterate till it works - and high five an imaginary friend. :-)
Use chruby / ruby-install (from postmodern)
You need to work out how to split the task up into smaller parts. Knowing what to make a class comes with experience. I made the game a class and represented the grid as a variable of that class, other options would perhaps be making the grid itself a class. Think about the data structure you will use to represent the grid. What methods would you need to update the grid, display it to screen and handle the game logic? When you start breaking it into smaller steps a design will often come together or the flaws in your thinking will become apparent.
&gt; No, you gave these examples of costs of switching to InfraRuby Nope, those are all examples of switching **from** InfraRuby. You are just (intentionally) misinterpreting my comments to continue this false argument. *"What happens when there is lots of repeated logic about which rake tasks to run on deployment, inside loads of Jenkins jobs?"* --- I said this in reference to **removing** InfraRuby-related stuff from lots of (possibly, unfortunately, convoluted) Jenkins jobs. *"What happens when deployments are made as a complete image to a VM, where there is a strict policy that no unused packages (i.e. InfraRuby) can be included on the disk image?"* --- I said this in reference to **removing** InfraRuby from the disk image. *"What happens when management insists that the Staging server, Demo server, VMs set up for pen testers, and so on, are configured with exactly the same setup as Production, to minimise risk?"* --- I said this in reference to (first adding, and then) **removing** InfraRuby from the staging server etc. Stop repeating this false argument that I'm talking about the cost of switching *to* InfraRuby; it's only you who is talking about it. &gt; For those examples, I outlined how you could use either the InfraRuby runtime or a Ruby interpreter, with a flag ... And the examples above demonstrate that a simple 2-minute flag change is often insufficient to make such a system change in "the real world" (where the system set-up is often somewhat complex and convoluted). And as for the next part of your post... Wow, I love the irony of the blatant contradiction here... &gt; these examples of costs that have nothing to do with InfraRuby ... ["What happens when someone insists on doing a "hard" switch off infraruby?"] How has that got nothing to do with InfraRuby?! My question literally uses the word "**InfraRuby**"! At a guess, I suppose what you really meant to say here is that doing a "hard" switch like I describe is outside the scope of what tools InfraRuby should be expected to provide. Well, I disagree. For many tools this may be the case, but for a tool such as InfraRuby - which *requires* you to significantly change your coding style by adding comments all over the place and ensuring things like `initialize` methods must return `nil` (or whatever type you choose) - a "hard" switch should be considered practically a core feature. Whilst InfraRuby code may run fine of a ruby interpreter, I suspect many developers would only consider a "hard" switch (i.e. removing all the comments and crap) to be sufficient on a large project, when removing InfraRuby permanently. And if the effort of performing such a switch (*from* InfraRuby) is massive, then this somewhat negates the value of the "zero-cost switch" as you describe it. &gt; If you wish to change your [...] test coverage then that is your problem: it is not a cost of switching from InfraRuby, even if you decide to do that at the same time. But if the use of an InfraRuby compiler **was** part of your test coverage, then by switching from it to a ruby interpreter, you are *losing* test coverage. Therefore I find it easy to envision a scenario where you must write new tests to effectively **maintain** the existing test coverage when switching. Or to put it another way: The (possible) cost of switching *from* InfraRuby is a **loss** of test coverage. &gt; No. &gt; No. &gt; No, the InfraRuby compiler does not require any such code. In all of your [online examples](http://infraruby.com/examples/benchmark), you define the `initialize` methods as returning `void` (`nil`). And if I try to define `initialize` without a method signature, then: class Foo def initialize puts "Initialized!" end end Foo.new # ... ./ruby/main.rb:7: error: cannot find signature for "initialize" So rather than just saying "No, No, No", perhaps you could elaborate: How do you write valid InfraRuby code without unidiomatic method signatures (such as the one described above), which will often involve the use of ugly `return` statements?
Please post some more specific details (or PM me), but I'm sure it may be helpful to some future person if you post it publicly. Practical Object Oriented Design in Ruby by Sandi Metz is an excellent book on class design and basic OO principles. 
I'd use [padrino](http://www.padrinorb.com/) for it. Just use an ORM like Sequel plus a testing framework like rspec and omit the view templating system. Finally if you want to build a JSON API, have a look at [roar](https://github.com/apotonick/roar) and/or [representable](https://github.com/apotonick/representable). Simply use roar/representable in your controllers to 'render' your documents.
No, I don't want to support an eol Ruby version, but that's the version the prebuilt Chef Bento boxes uses on Debian 6 and old Ubuntu, and those are not eol'ed until next year. Supporting 1.9.3 is the lesser evil compared to preparing and distributing my own Vagrant boxes.
*tl;dr: completely agree, specially with "explicit over implicit part"; and the misinterpretation of the word "Agile", specially combined with the also misinterpreted "Lean" mindset is ruining it even further.* Untill this day, I just had this thought "Python seems *simpler* than Ruby". Since I'm a beginner in Python, I thought it'd be something on the syntax; more specifically, the "explicit over implicit" part. I program in Ruby for over 3 years now, and I still find it painful to read other people's code, mostly. For the most part, I'd say it's because there's *way too much naming* looking the same: is it a variable? a method? And, most importantly, where does it come from? Maybe this isn't generally agreed upon by the community, but I think we should avoid this mess whenever possible. Another point I've been having trouble with is with the Agile and Lean buzzwords. Agile [is taking its own hits](http://blog.toolshed.com/2015/05/the-failure-of-agile.html), but startups stay blind for some Lean manuals, and, some of them (I've worked for a couple only, I'm supposing there's more out there, for what I've gathered) transform Lean + Agile in "every solution must fit in a week time, because that's our sprint". They prefer fast and badly (or not-at-all) architected solutions that solve the issue instead of code that won't come back to bite you in a couple weeks - and Ruby's speed and gem-oriented current situation just reinforces to startup businessfolks that this speed is feasible, so *do it*. If this last point happens to anyone else out there, I'd love some feedback - maybe it's just me =] Lovely article.
&gt; What is the ruby way to solve this problem? Ruby doesn't really have anything to do with it... The real challenge here is to come up with a correct, efficient algorithm for solving the problem. One you've decided how your solution works, coding it in ruby is relatively easy. What have you tried so far? Can you explain your solution in words, or even in pseudocode?
This isn't the knapsack problem. The knapsack problem wants you to find the largest total you can reach that is less than or equal to a given ceiling. This problem admits much computationally simpler solutions.
Shouldn't matter what language you do this in. Go through all the bottle choices an pick the highest one that you can subtract without making the result &lt; 0. Keep doing that until you reach 0. So for 23: 10 (you have 13 left), 10 (you have 3 left), 1, 1, 1. Recursion or even just a for loop is all you need. 
Quick hack, change `ask` to the number you want results = {} [4,3,2,1].each { |x| b10 = b7 = b5 = b1 = 0 ask = 122 if x == 4 b10 = ask/10 ask = ask - (10*b10) end if x &gt;= 3 b7 = ask/7 ask = ask - (7*b7) end if x &gt;= 2 b5 = ask/5 ask = ask - (5*b5) end b1 = ask/1 total_b = b1 + b5 + b7 + b10 results[total_b] = "\n You need \n#{b10} x10lt \n#{b7} x7lt \n#{b5} x5lt \n#{b1} x1lt\n\n" } results.each { |k, v| puts v puts "Total no of bottles #{k}" } puts "Best: total #{results.min.first} bottles" puts results.min.last
It's mentioned at the end of the article, it isn't perfect solution and there is less trust in our tests. And yes, we are covering a deeper problem, which is in PhantomJS crash. We are not capable to fix PhantomJS fast and we don't want our specs to run three times longer with other engine.
Ha! so true. they're the only ones that will deliver to my house though. :(
if you want your ruby to be executable like any other program or unix utility, including being able to pipe input in and out of it... without this you have to type `ruby file.rb` but with it you can just type `file.rb` or `./file.rb`, or you can leave off the rb and no one has to case what language your program was written in :-)
How to download this font?
Junior dev? internship?
do the crazy rspec testing. really! first off, testing is the bread and butter of any serious programmer. second, building a class, trying to test it, realising the class is complicated to use and refactoring it, going back to the tests and finding errors in the class again is a very good way to get actual solid understanding of what is going on. rspec is a DSL, and the code might look like magic that just adds to your mountain of things to learn. But like everything else in ruby, it's nothing but ruby classes methods and blocks. thanks to the flexibility of ruby, rspec specs look very different from a normal class, but don't let that scare you. 
Click on [the "Download ZIP" button](https://github.com/sunaku/tamzen-font/archive/master.zip) below the Git clone URL.
go back to your job and contribute to OS projects, the code review is really very helpful
Ah you're right! Didn't think of that. I guess you could build a list of all possible combos and pick the smallest one. I'm sure there is a better way though.
That's kind of what I thought for a simple solution. You can do simple optimization by iterating through the bottle sizes with and index and recursively call the remaining amount with bottles left after dropping at that index. Would at least eliminate repeated results like 10,1,1 and 1,1,10
Yes, I'm going to apply everywhere!
Yes, I know contributing is a biggie.
Second the source code and get a meaningful stack trace for error reporting. You can't track down a bug if you don't know if its something you're doing wrong or something that is inherit in the framework that you have to work around.
This reads like a guide to the first step of dispelling. I think starting with something like ActiveRecord that uses Arel and whatnot is suicide as a beginner. I got mixed feelings about the post. It may help first timers with their approach but for everyone else it just recommends to read code.
Using rails if you have no idea about ruby and rails (which I assume since your friend is at a bootcamp) is like using a cookbook with a complicated oven. The more you use it and step by step integrate its capabilities the more you develop a feeling why things don't work. It's a game of patience and practice. Personally I do not recommend reading the source when you are a beginner. Rails is quite complicated at times and its design choices questionable or at least irritating to someone unwilling to dig through pages of github issues and pull requests. All I would tell your friend is to sometimes accept that you do not yet understand, take one problem at a time and to practice with tutorials, samples and maybe even stack overflow snippets. He will eventually get to a point when he wishes he did not understand :)
exercism.io has both
 class BottlesFinder def self.find(litres) new.find(litres) end def find(litres) @solution = litres # Worst solution recurse(litres) solution end private attr_accessor :solution def sizes @size ||= [10, 7, 5, 1] end def recurse(litres, bottles = 0) if litres &gt; 0 sizes.each { |size| recurse(litres - size, bottles + 1) } elsif litres == 0 @solution = bottles if bottles &lt; solution end end end p BottlesFinder.find(24) # 3 
I just installed it. This is amazing. Thank you for informing me about this. 
process and be running aren't methods. The method that's being invoked here is step. I'm guessing the %Q is throwing you off. It's an alternate double quote style useful for when you string contains multiple double quotes you don't want to escape. The []s are used as delimiters, you can use something else as long as the start/end match. A good breakdown of the alternate quoting styles is here: https://simpleror.wordpress.com/2009/03/15/q-q-w-w-x-r-s/ If you break down the inner method call after that you get a call to step with the string (assuming current_app is/returns the string cats): the app "cats" should be running or alternatively: the app "cats" should not be running depending on whether or not the 'not' is captured in the step definitions regex (and passed into the block). Cucumber would expect there to then be a step that matches that string.
Out of every reply, this is the one I understand. Thank you. Could you possibly answer a few more questions? I know what attr_reader, attr_writer, and attr_accessor are. However, I'm never sure which to use, so I always use attr_accessor. This is lazy. When and why would you use the other two? Also, I'm unclear on the initialize method. Why is it necessary, and when is it not necessary? What exactly is "@var = var" doing in the initialize method? When do you initialize with params, and when do you not? Again thank you for helping. Your explanation was clear and concise; and I hope you can take the time to answer these. 
You want to ["daemonize"](https://www.ruby-toolbox.com/categories/daemonizing) your script.
Definitely, a good attitude can open many doors, I've experienced that myself.
/r/DailyProgrammer has challenges you can do everyday
Here is my logic : 1. Find the number of bottles with normal simplest way possible (somehow it first comes to mind) -&gt; Find the number of bottles of 10 ltr -&gt; Then 7 ltrs -&gt; Then 5 ltrs -&gt; And finally 1 ltr --&gt; Store the ans in a variable ... let's say result1 2. Find the number of bottles just like the above method but take just use 1 less bottle of 10 ltr --&gt; Store the ans in a variable ... let's say result2 3. Take the minimum of both the resul1 and result2 ... That is the number of minimum bottles required.
I came up with one logic but not able to convert in idiomatic ruby code. My logic can be found here : http://www.reddit.com/r/ruby/comments/36henn/find_minimum_no_of_bottles_requried/crewp5z
Kudos .... this is great :) Can you explain the recurse method a bit further? Thanks :)
That's a bold statement there. I will co-sign on POODR though, great book.
This. So much this. This is how I got my current Rails job.
I'm a suuuuper nooby Ruby programmer (about 3 or 4 days in) but here's what I came up with: def test_the_volume(testing_volume, test_number) num_bottles = 0 puts "Running test number #{test_number}!" while testing_volume &gt;= 10 * test_number testing_volume -= 10 num_bottles += 1 puts "1 10 unit bottle" end while testing_volume &gt;= 7 testing_volume -= 7 num_bottles += 1 puts "1 7 unit bottle" end while testing_volume &gt;= 5 testing_volume -= 5 num_bottles += 1 puts "1 5 unit bottle" end while testing_volume &gt;= 1 testing_volume -= 1 num_bottles += 1 puts "1 1 unit bottle" end return num_bottles end print "What volume are you trying to fill? " total_volume = gets.chomp.to_i test_1 = test_the_volume(total_volume, 1) test_2 = test_the_volume(total_volume, 2) puts "Using bottle sizes of 10, 7, 5, and 1 units, it would take #{[test_1, test_2].min} to fill your container." This also catches edge cases like 24 and 14 which are advantageous to skip one of the occurrences of 10 and give multiple 7s.
I find the use of the array [4,3,2,1] a bit weird to start with, especially because iteration starting below 7 is unnecessary in this example. You could've had [4,3].each and been just as effective.
I think you forgot the link: https://github.com/tallakt/object_as
 [1, 2, 3].map {|x| x * x }.as {|array| array.reverse }.each {|x| puts x } Why not [1, 2, 3].map {|x| x * x }.reverse.each {|x| puts x } ? Could you provide a use case which makes the advantages of using `Object#as` more clear?
Well, it's just how the iplayatwork said above, I just wrote it out. It goes through every combination and stores the current best in `@solution`. I suppose you could think of the `sizes.each` loop as creating a four pronged fork in the tree of all possible solutions, if that helps. Or just get out a pen and paper and go through it an iteration at a time.
Just set yourself a target and do it. I never met any proper programmer who learned it from just books or websites.
Pretty cool, I'm looking forward for the continuation of the series! good work!
Yea, I was planning on doing just assignments/projects, but I wanted some insight from other people.
Thank you for your advice; i'll keep watching developments
As others have said: That's the command pattern and there's one drawback to it: It requires you to pass all arguments through the constructor (in order to keep a consistent interface across all commands). This forces you to keep instantiiation and usage of the object pretty close together (`Foo.new(...).execute`) and you have a hard time using some OOP techniques like decorators. Therefore I like the following approach better which separates the use case and the execution of the use case into different objects: https://cuttingedge.it/blogs/steven/pivot/entry.php?id=91 (tl;dr use rack's middleware approach to implement cross-cutting concerns)
My sympathies. I had to do the same thing to get signed, native DEB and RPM packages for [Inspeqtor](https://github.com/mperham/inspeqtor/wiki/Installation). It was a three week nightmare of terrible documentation, obscure tooling and platform bugs. Thank God for `fpm`. It is amazing how bad the Linux packaging status quo is.
Calling `population(a: nil, k: nil, t: nil)` works perfectly fine. There's no built-in way in Ruby to prevent `nil` values being passed to methods. You could use a gem like [`contracts`](http://egonschiele.github.io/contracts.ruby/) to check for preconditions, though.
You're right, for some reason I thought that would raise an error.
this might be a better example... https://github.com/olbrich/unknown/blob/master/bmi_unknown.rb https://github.com/olbrich/unknown/blob/master/bmi.rb The mandatory keyword arguments is interesting, but it doesn't prevent you from passing nils in. My primary motivation here was to avoid having to do a lot of nil checking in complex functions and focus on the math instead. Mostly using an Unknown object is going to make handling of unknown values more explicit.
I applied to speak, but if I'm not accepted I probably won't get to go :(
About your last point: tallakt's gem defines a refinement to alleviate monkey-patching side-effects.
&gt; This is a mediocre off-the-cuff example, but which code snippet would be easier to decode if you haven't looked at it for months? For me it's definitely the second one. I wouldn't need the local variables (or block parameters) for clarity. btw. In this example you don't need the first `map`, do you? I think it can be written like this: Hash[ User.active.where(status: :vip).group_by(&amp;:email).map do |email, user| [email, user.name] end ]
Becuase you might need more than one redis server, you are advocating embedding the address of one them right in the code? What happens if the address changes, you need to find it in the code, and change it? Might it be in multiple places in the code? Is it clear which of them should change? I don't think needing multiple redis servers is a reason to move from config to literals in the code. It's a reason to have two different global config values, with their keys explaining the difference between them. `redis_host` and `special_redis_host_for_that_special_thing` or whatever. Also, I'm not entirely sure you read the article, as it's got nothing to do with globals like `$redis`, I'm not sure what you're talking about has anything to do with it. 
I think you misunderstood me (I could have been clearer). Having configuration global to a gem is undesirable. Let me instantiate as many configurations as I want. Using the example in the article as a basis, this is what I mean. module Yourgem def self.configure config = Configuration.new yield config config end end # in the code that uses Yourgem $yourgem = Yourgem.configure do |config| config.some_config = "foobarbz" end That way the consumer of the gem has more flexibility in how they use the config (and ultimately the library).
More depressing to me is the wide-scoped, giving-up-attitude `rescue`. No idea what call exactly it's supposed to catch exceptions from, doesn't make the distinction between each type of possible `ArgumentError` or `TypeError`, both kinds slurped in the same rescue altogether to make it all worse. Might as well rescue `Object`.