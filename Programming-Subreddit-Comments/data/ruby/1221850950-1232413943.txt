Why? In the Rails 2.1 there's actually a rake task built in which will vendor your gems for you. rake gems:unpack DHH doesn't seem to think it's particularly terrible.
Those two chicks at the top are WAY too clothed.
Looks interesting and useful. Would have liked to see a demo of it, for example, how do you build a chart using that DSL?
Rails-Footnotes has more info, though I like the bar idea. Maybe the two could be combined. http://github.com/drnic/rails-footnotes 
Isn't CRUD basically one application? Yeah the objects always have different names and a different number of fields and different relationships, but the idea is basically the same, persistent identifiable entities with particular values. They make the analogy to unix commands, but crud is nothing like a unix command, unix commands are all about some *process* that changes inputs to outputs, not passive data sitting somewhere. 
CRUD is a controller convention that works with any resource. It is a logical and aesthetic separation of actions in your controller. However, the code in each controller will differ based on how you want your application to perform. Yes, the "idea is basically the same" because it's a convention. Beyond that, I'm not sure I understand what you're asking.
Controller: Did you just rickroll him? Model: Sure did
I still don't get it.
is this guy retarded?
Your comment is a lazy ad hominum attack but it is also just what I was wondering.
Anyone who calls himself a "webmaster" in 2008 probably is.
... No.
Well, the last commit is 3 hours ago... http://github.com/rails/rails/commits/master
I was a little surprised by the number of atheists and agnostics. Is this the norm in the computing world? It'd be interesting to find out.
To me, this looks worse that the hash syntax.
with the [new hash syntax in 1.9](http://eigenclass.org/hiki.rb?Changes+in+Ruby+1.9#l6) you could do away with method generation tricks altogether and say `attr_plus_plus {x:10, y:3, z:[1,2,3]}` edit: as pointed out, that doesn't allow for attributes without defaults. luckily, another feature is that you can have key/value pairs at the end of an arglist and they'll be collected into a hash, thus `attrpp :x, :y, z: 10, foo: ['hello', world']`
I agree. Native support for Python-like named parameters would be great, but for the time being hash syntax is quite nice idiom to use. I would never use construct like the one proposed by the author in production code. Additional (huge) disadvantage is that it prohibits you from passing "real" block to the method.
It's no surprise that a lot of Rubyists are atheists; it's no surprise that a lot of PHP coders are fundamentalist Baptists. Little known fact, that.
via: http://www.byzantinereality.com/?p=147 SOAP in Ruby 
Sure, it's a terrible hack. ...but it's a _fun_ terrible hack!
This looks nice, but I think Configatron looks a little more robust: http://github.com/markbates/configatron/tree/master
This one seems to deal with different environments a little better. Also configatron looks a lot like mash.
Totally gratuitous method_missing usage; ugh. The hash version is much more mentally parseable.
Man, I'm already stuck on the second level. How does the warrior feel thing work?
If ruby was a mountain, Ryan Bates would be the god at the summit casting down bolts of code on the unenlightened peasants. Well, maybe something less painful than bolts but equally as impressive.
I’m not sure if it’s better or anything, but I’ve been doing this like so: http://github.com/trevorturk/el-dorado/tree/master/lib/attachment_fu_extensions.rb and http://github.com/trevorturk/el-dorado/tree/master/app/models/upload.rb
I'm starting to worry that Bort is going to bloat beyond its original charm.
Programmers are exceptionally logical people, and often have more trouble than the average person in accepting a higher power. That said, this was featured on the front page of reddit, which may have skewed the results a bit. ;)
Just use Marshal.dump. Granted, that's a binary format, but it's probably quite a bit faster than ZAML even.
I’ve cobbled together a really ugly (but functional) illustration of automatic session key creation/storage using the Configurator plugin. Any improvements, suggestions, etc about this would be most welcome. You can check it out here: http://github.com/trevorturk/el-dorado/tree/config/config/environment.rb
Ya know, if you're so irritated about this, just go write your own library. Sure, there are deficiencies in the stdlib of ruby (the one that annoys me is TCPServer's listen has a hard-coded backlog of 5), but really, HTTP isn't that complex.
Holy shit I wish I had known about this before I put a bunch of shitty code in my tests.
gems sucks, therefore the entire language is not worth using. This man's powers of reasoning are astounding.
Having access to the entire Java API is a little underrated if you ask me. 
Should've been McCain has_many :things
This is awesome. I need to figure out how to use this for the project I'm working on :D
ruby programmers kick ass.
Easy as HTTP is to implement, it doesn't seem unreasonable to expect Ruby's built-in HTTP client implementation to perform roughly as well as similar implementations in other dynamic languages. That Ruby's does not is a deficiency and warrants comment. The rfuzz HTTP client implementation ended up working pretty well for me, so fortunately I was spared writing the third HTTP client implementation of my career, but it really shouldn't come to that. 
This would take about thirty seconds to write for emacs. Just sayin'.
I hate the attitude of Textmate that it has no interest in releasing versions for Windows or Linux. On a daily basis, I develop on Linux, Mac, and yes Windows. I need an editor that can run on all three. Textmate is a great editor, but I can't stand how it is tied to Mac. I also hate the idea of paying the Apple tax just to have a good text editor. There I got it all out now. // END RANT
Vim? Emacs?
People that refer to MD5 and SHA1 as "encryption" irritate me.
I use Vim frequently, but I still like my mouse from time to time. I'm not saying that I do not have a text editor of choice. I usually use Netbeans. I'm just saying I hate the exclusivity of TextMate.
I know this is 2.5 years old, but I hadn't heard of these functions so I submitted it.
Next time leave out the 'New in Rails'.
&gt;I also hate the idea of paying the Apple tax just to have a good text editor. You don't have to. See vim and emacs. If you don't think vim and emacs (or even Netbeans) are "good text editors" than the fault lies in your skill in using them effectively. I don't mean to be insulting, but vim or emacs should be able to do anything TextMate can do. It might just not look as lick-able. &gt;I'm just saying I hate the exclusivity of TextMate. Then by all means feel free to ignore it. The developer of TextMate made a rational decision to limit development to a single platform. He's apparently doing very well making money off of people who don't mind paying "the apple tax" (which is a fatuous contruct, IMHO) as well as paying around 100 USD for a text editor that essentially reinvents vim and emacs.
Well, it's new to someone!
And if you used `ed`, you wouldn't even need it!
The TextMate developers don't want to develop for Windows/Linux, and they never made any connotations of doing as such. That said, look at either the "e" text editor, or "sublime text editor" - both support .tmbundle, and "e" is a TextMate clone.
Can't wait till the editor is released!
Gee, it'd be nice if they had some benchmarks to support their claims.
No kidding. IMHO, #find\_by\_sql is a last resort. Regular #find provides you portability.
This article is mostly worthless. &gt; So the good practice is to use find_by_sql where it would be acceptable. Which is very rare. It defeats the purpose of ORM and the models altogether, creates a maintainability problem, and really isn't all that much faster. &gt; You should never put number in quotes in your queries. Unless it's actually a string... this goes without saying anyway -- use the proper type. &gt; It would be much faster if you use: Person.find_by_sql("SELECT persons.phone_number WHERE persons.name = 'Name'") Proof positive this guy has no idea what he's talking about. Ever heard of the :select option?
"Ever heard of the :select option?" thank you.
In some rare instances of eager loading and nasty joins created by the ORM, using custom SQL might be better indeed. However this article seems to cover only cases where you don't really need to go down to SQL :( (Also, note that you can specify your own joins and still use ActiveRecord.)
What would you rather it be referred to as? A hash function can be used as a one-directional cryptosystem when it has a low probability of collision. Hence, it 'encrypts' a plaintext with no decryption algorithm. SHA1 and MD5 use a hash function as an "encryption" by definition. 
"Hashing" works just fine. Encryption inherently implies that the information that has been encrypted can be retrieved if you have the proper key, which is entirely inaccurate in the case of a hash. When you hash a string, you are not encoding its data against a private key - you are simply calculating a value for which the string is a function input. The resultant hash is not a representation of the input data, which is required for encryption.
Wow. This is a horrible article. Generic claims with no explanation or benchmarks.
Less blog title, more content next time.
Serves me well for letting reddit choose the title.
And to follow it up, I did my own benchmarks. http://www.coffeepowered.net/2008/09/30/re-simple-rormysql-optimization/
I don't disagree that #find\_by\_sql is a last resort, but the "portability" argument is pretty silly unless you're building software to distribute, like a blog platform or a discussion forum. For any proprietary project, the chances of switching database server software after the project starts is close to nil.
I see your problem with the term "encryption" but it does not necessarily imply that the there needs to be a decryption, nor does it necessary mean there is a key (although the standard idea of a cryptosystem involves a key). But, by definition, SHA is a hashing algorithm used for encryption. I agree that 'encryption' usually implies that there is a retrieval algorithm, but there can be one-directional encryption, where this isn't true. And you are right, its not technically a encryption "function" because it is impossible to avoid collision for every string possible. 'Encryption' may be a bit misleading, but its not incorrect. SHA is defined as a Cryptographic Hash Function by NIST.
I can buy that. I think the reason that it usually bugs me is because when people use the term "encryption" for hashing, they really think that there's some magical key-based encryption going on (just google for "how do I decrypt a hash?") - it's misleading, and generally exposes a lack of understanding about what's happening when data is hashed. Of course, that's not to say that it wouldn't be awesome. If I could encrypt anything I wanted down to a 32-byte string, I'd make a *killing* on compression and rich media streaming technologies. :D
I understand that. I probably should have been more specific so I didn't mislead 90% of my audience, who know nothing about encryption or what a hash function is. And yes, if you could encrypt anything to any relatively small size regardless of the plaintext, I would probably be applying to work for you. haha
via: http://www.dominopower.com/newsitems/00041347.html
Sweet. That's been a bit of a pain point for me.
Configuration belongs in config files, not source. [site_config](http://www.coffeepowered.net/2008/09/25/site_config-painless-config-variables-for-rails-projects/) does Rails config in source, with multi-environment support without the need to write capistrano tasks.
Pete has an interesting take on the talk: http://rethink.unspace.ca/2008/10/2/have-you-watched-giles-bowkett-yet
lol This is the Ruby sub-reddit. Not Proggit. Ruby articles are safe here ;)
Heckle is fantastic -- when it works. I'm not sure if it has any momentum behind it because most discussion I can find of it is 2 years old.
Ruby needs more self-aggrandizing blowhards.
The "JavaScript: The Good Parts" book amuses me.
So does reddit
I definitely think that utilizing tools like this in an intelligent way can really help the development process
Add to Adblock... -&gt; http://evang.eli.st/me_at_rubyconf.jpg Phew.
Archaeopteryx is extremely fun to play with, and Giles' programming style is pretty intriguing. I like the let's-use-lambdas-for-everything idea. It works well here.
Apparently it's a great book. I still need to get around to reading it &gt;_&gt;
That's the one place I think Ruby is really lacking - allowing you to fork the process. I am not 100% on 1.9 or 2.0 if it's on the roadmap to change that though. 
Here's an article about that: http://www.elctech.com/blog/i-m-in-ur-commandline-executin-ma-commands You can just use backticks for the most part.
[Here's Jay Field's article](http://blog.jayfields.com/2006/06/ruby-kernel-system-exec-and-x.html) that gets a mention in this blog post. The differences in methods basically boil down to whether control is returned after running the command and whether the output of the command is returned.
transactional migrations == good
He started deriving the Y combinator but thought it was ugly.
Hah, you're right. I didn't even realize. I've never bothered to figure out what the Y combinator does until you replied to my post. (thanks! :P) This explained it well: http://nex-3.com/posts/43-fun-with-the-y-combinator-in-ruby
Sorry to talk about you 3rd person I wasn't sure if you were the submitter since I missed your name on the post. Cool to see a use for the Y-combinator derived from the real world.
You can turn off timestamped migrations in 2.1 too.
How do you deal with recurring dates?
This is one of the sample files that comes with the midilib Gem. Glad you liked it enough to submit it. Midilib is also used in the chapter on generating MIDI in the book "Ruby Cookbook".
What I'd love to see was a survey generated by scanning all of Rubyforge + whatever else could be found for some of the stranger edge cases. I suspect a lot of the weirder Ruby constructs will be found in the wild extremely rarely.. 
Maybe somebody will fork it and clean it up a bit. Wasn't Charles Nutter working on something like that?
It might be simpler if you left things with an ambiguous grammar, then tried some variant of packrat parsing. If the parsing was lazy (to avoid exploring all the different options) you could then have a second pass that goes through and selects the right parse (using context to resolve ambiguities). Not sure that makes sense (I've never done anything like that myself), but it might result in cleaner code. In python you might be able to implement the packrat parsing using generators - don't know if that carries across to ruby... 
Packrat parsing should work since you can merge lexing and parsing phases (I have done that with my own packrat-like parser in Common Lisp). But I'm not quite sure if the grammar would be easier. You still have to handle a lot of cases. Edit: ruby has abstractions powerful enough to implement packrat parsing, but I would worry about performance.
Like: class Player def play_turn(warrior) if (warrior.feel.empty?) warrior.walk! else warrior.attack! end end end 
Fork what, the interpreter? Aren't there half a dozen of implementations out there?
Hi. I'm glad what I said wasn't completely stupid :o) The grammar would be huge, but that seems to reflect "reality". The win would be that you isolate the feedback from the "smarts" to the lexer/parser (I may be just repeating myself here - not sure how obvious it is). The original post was worried about the feedback from parser to lexer. What I'm suggesting is that is pulled out into a separate stage that chooses the correct parse by traversing the "parse forest" that the packrat parsing generates. [Aside for people that don't know what packrat is - you generate parse tress for all the different possibilities when things are ambiguous, instead of trying to get things "correct"] When you worry about efficiency do you mean the overhead for coroutines or whatever Ruby is, or the overhead for all the work in the packrat parsing? I have no idea about Ruby, but my hope was that the packrat parser itself would be lazy, so that it wouldn't actually do the work of parsing all the alternatives, but would be "guided" by the second stage which would selectively evaluate the correct path down the tree.
[Duby](http://blog.headius.com/2008/03/duby-type-inferred-ruby-like-jvm.html). Also, [Sapphire](http://www.sapphiresteel.com/The-Sapphire-Language).
Fork the language. Ruby is a great language with some minor blemishes. There are also a lot of people who want type inference or stronger typing with ruby. Nutter was working on a ruby with annotation and type inference and the ruby-in-steel guys are also working on a fork of some sort. I don't know if any of them will go anywhere but there are two forks right there. Also rubinious guys will (hopefully) be assertive in not supporting some of these edge cases. Hell push comes to shove you can attempt it yourself. Evan will give anybody write access to the repo.
Sapphire seems like it's going to be windows only thing. Duby doesn't seem to be going anywhere. Oh well. 
Yer doin it wrong. Author should save themselves some hassle and just install *nix.
I wish there was an RLisp that didn't suck.
why is this in ruby?
See here: http://rinari.rubyforge.org/ Rinari: Ruby on Rails Minor Mode for Emacs
I'm very tempted to go work on one. If I do, I'll post up something from github. It'd be nice to be able to write some data processing routines in a schemey way.
I never would have thought someone could try python and think it wasn't as good as perl. I had the exact opposite reaction.
Yeah. There's an RLisp currently that compiles to ruby code, but it's 6-7 times slower than native ruby code. What I'm imagining is some crazy ambitious alternative syntax that runs about the same as standard ruby code. Chances are that's impossible, but a man can dream, right? :P
It's better, but does not follow the Perlish dao. Ruby does.
Yeah I'm thinking I want to write something to run on Rubinius, ideally. I'd want hindley milner typing kinda stuff, I think. Can you tell that I've no real idea? heh. Ideal would be interop with bog standard ruby code, too. And a pony. I want a pony.
Through Ruby and Rails I rediscovered the joy of programming and am now grateful to have a decent profession that is remunerative, creative and not unethical.
via: http://dysinger.net/2008/10/09/mochirest-rails-ui-and-erlangmochiweb-rest-json-service/
Mostly improvements using Ruby. I personally cringe when I see for loops in Ruby. I really prefer the concise look of .each.
To anyone who's not a programmer thats probably one of the most confusing headlines they've ever read.
Can you use Datamapper with Rails 2.0? I thought RoR was built around Active Record no? Is it time to consider a move to Merb?
In principle you can use whatever ORM you want, or none, with Rails. In practice, there's a lot of momentum behind AR, so you don't get things like native helpers for anything else. That's not to say it's especially hard, they just don't make it especially easy.
Yes, it's time. Merb is fun, try it out. I'd wait until next week when it's 1.0, though. The past few days have been full of commits.
If you're developing, you should definitely install build-essentials after a clean install. That will install gcc, g++ and other commonly used dev tools.
fo real that gte thing is kinda whack...
You can write FORTRAN in any language.
 Person.select {|p| p.age &gt;= 30} The problem with this is that I'm almost certain it has to load every record them compare then with ruby. This is INCREDIBLY bad. With gte, you pass the filtering off to the DBMS, which saves craploads of IO, and database IO is usually the bottleneck in significant applications. EDIT: Cancel that, Amibition actually seems to handle this problem sanely. &gt;&gt; SQL::User.select { |m| m.name == 'jon' &amp;&amp; m.age == 21 }.to_s =&gt; "SELECT * FROM users WHERE users.name = 'jon' AND users.age = 21" 
Nope. [Ruby's Ambition](http://ambition.rubyforge.org/) is pretty clever: it [inspects the parse tree and generates SQL](http://errtheblog.com/posts/63-full-of-ambition) to implement the query semantics expressed in Ruby. EDIT: looks like we had a race condition. I'll leave my comment for it's useful links. :)
Ambition uses ParseTree (IIRC). Changing the query-api is easy. Figuring out how to make a query definition look like pure-Ruby cheaply and in a way that will work on implementations other than MRI isn't so easy. Though I'm open to suggestions...
DBI does not provide a unified consistent interface. Which is why AR monkey-patches it to provide a unified interface for AR adapters. DataMapper does less of that. Since the driver-API is unified, there's a single base adapter in DM (for DataObjects drivers), with the concrete adapters differing mostly for the sake of differing SQL syntaxes.
[Sequel](http://sequel.rubyforge.org/) does this too.
Right now there are four competing data access layers. DBI, Squel, DM, and AR. There is also nitro (I think that's what it's called) and rBatis which are dead. I think that's a lot of duplication of effort. There was nothing wrong with DBI. The two pojects could have continued to improve without frustrating people enough to motivate them to build new access layers. It's also interesting to note that DM and sequel also have their own ORM on top of the database layers they built. Four data access layers, three ORMs. Surely there is a better way.
Since the homepage of RubyPond.com was submitted, heres the real link: http://rubypond.com/articles/2008/10/11/merbcamp---notes-from-the-edge/
Right, it started as a port from an earlier version of DM: http://groups.google.com/group/comp.lang.ruby/browse_thread/thread/657218c340c5bcd1/e5843f1873f286db?lnk=gst&amp;q=smoot+sharon#e5843f1873f286db It's just a bit incomplete since it doesn't handle the full feature set you might want during queries. I guess I just don't feel like whipping up another half-measure to satisfy someone else's personal preference...
A common mistake with a quick solution.
I posted a reply on the blog post but it seems to not have gone through so I'll post it here: This can still cause incorrect results. Because you divide by 365 you do not take into account leap years. People who are born close to the beginning of the year will be older by a year a few days before their birthdays.: &gt;&gt; today = Date.civil( 2008, 1, 3 ) # 3rd January 2008 =&gt; #&lt;Date: 4908937/2,0,2299161&gt; &gt;&gt; birthday = Date.civil(1979, 1, 4 ) # 4th January 1979 =&gt; #&lt;Date: 4887755/2,0,2299161&gt; &gt;&gt; ((today - birthday)/365).floor =&gt; 29 # Will only be 29 tomorrow, still actually 28 A correct implementation is something like: (today.year - birthday.year) - (today.yday &lt; birthday.yday ? 1 : 0)
I don't understand why you wouldn't want the API to be: Person.select (:age &gt;= 30) ...or something like that. Would there be a case where you'd need that whole |p| and p. business? I don't see what it buys you unless you need to disambiguate, like with join conditions. 
It's a neat trick, but I'm having a really hard time thinking when it might be useful. Anyone got any bright ideas?
Sequel does that. It has other kinds of candy too. 
Thanks for the reply! I've edited the blog post to show that my method isn't 100% accurate and to refer to the comments.
I'm generally a fan of the way ActiveRecord deals with it. Make some things easier, but don't abstract the whole thing.
I just use: `(Time.now - birthday) / 1.year` Isn't affected by leap year issues, either, since 1.year is 365.25 days in Rails.
Great timing! The server was down for a few minutes. It had been running flawlessly for over a year and decided to crash today! Not even because of heavy traffic. Sorry about that,it's all good now. 
When you are writing a Ruby app, it makes sense to express your queries in Ruby. That's the gist of this library. There are libraries that totally embrace doing things the SQL way (Sequel for example). And their are libraries lean more toward trying to hide the specifics of SQL (Datamapper, for example). Me? I like it. The less things I have to learn the better. Mapping a collection of ActiveRecord models should look like same as mapping a collection of pure Ruby objects. Don't make me remember all the specifics of the SQL where clause. 
True. I was looking from the perspective of "when would I ever want to swap an XPath backend for an SQL one" which is, quite clearly, wrong.
Why, oh why, make the body text a light gray on a white background? I'd really like to read this but damn if it doesn't give me a headache. /endrant.
Turn off CSS. In Firefox, it's View-&gt;Page Style-&gt;No Style. On Opera, there's a User Mode. I'm sure other browsers have it too.
Oh, sweet!
If you're using MySQL, you can just set the table\_name in your model as "db\_name.table\_name". Not sure about other DBs though.
could be cool if they add selenium and js_spec, run the tests on windows, linux, and OS X, and of course start providing private projects for $$
Merb is completely awesome, but this article sucks. It managed to insult Merb by reporting a bug without bothering to take a good look at Merb's great features. Oh, and there was a glaring typo: &gt;... developers who are unable to get past the 80 percewnt point on their Rails applications ...
I'm excited about this one, but curious to see if they'll be able to pull it off given the potential dependencies of each app. 
Indeed
see also: http://www.theamazingrando.com/blog/?p=24 Resourceful 0.2.1
Am I missing something, or did that presentation actually make the case that Merb is fast because it has a fast "hello world"?
It is making the case that passing a request through the merb stack, routing, instantiating controller, parsing parameters, initializing a session, rendering a template and returning the result of it all to the client, is way faster in merb than doing the same thing in a PHP framework. None of these frameworks is going to get faster with a more complex app. Maybe the difference will even out as the database becomes the bottleneck, but imho, this kind of benchmark still refutes the fact that PHP frameworks are inherently faster. Also there was a real world app created in different PHP frameworks and in Rails, where Rails was faster than the other PHP frameworks, and Rails is significantly slower and more memory hungry than merb is.
Alternative is a great word for it. The same thing implemented differently. I don't see the point, personally.
With the growing number of alternative web frameworks emerging in the ruby world and the exponentially increasing number of gems and other libraries for ruby I would expect that RUBY experience (outside of any framework or other DSL) would serve one better than investing all of ones efforts on Rails. If you can show that you know how to discern the best tool for the job and then apply that tool to benefit the success of your project, THATs really what will serve you well in the future. The notion that specialization in just Rails is foolish. 
Of course. Merb is all about hello-world retards. They don't know the difference between an optimized architecture v/s hello-world-trolling.
I sure fuckin hope so!
Having used both Rails and Merb fairly extensively, I agree. Merb does remove several of Rails' pain points, but there is still too much framework to deal with for my taste. For a true alternative, I'd recommend Ramaze (http://ramaze.net). It scales code base growth very nicely and is very hackable and very much embraces the spirit of Ruby. It may offer fewer bells and whistles, but it's moving in a great direction and it's a great place to contribute.
You learn something new every day...
Use Thor instead. It's a lot more friendly.
The post very clearly says that ZAML.dump is *fast enough*, making your comment outdated. And for user documents, a plain text, standardized, simple and beautiful file format (YAML) beats a big binary Ruby-interpreter-specific blob (Marshalling).
I personally masturbate every time I write a regular expression I'm proud of. Next time stay off the Ruby subreddit dumbass if you don't find regular expressions interesting. I'll bet you're some "Ruby on Rails" expert who couldn't even define a class in Ruby.
What a boring, long-winded ad.
This looks really cumbersome compared with SOAP4R and actionwebservice. You have to create your all your XML by hand for example. Also I didn't see anything in the documentation about WSDL generation although it says it supports it. I think they would be better off trying to use this as a back end to actionwebservice which is easy to use, pretty well documented although is missing some important features like optional fields.
the internetz
I forgot that one, thanks.
After the first attempt at Morse, you totally missed the opportunity to name this reMorse.rb. =)
Not here apparently.
I will sum up the post. "I do not want a powerful language". 
"I do not trust my developers and framework writers to make good choices."
I will therefore choose a language which lacks the power to let programmers do what they want. 
Debugging is easy. You need to learn how to break up the problem and narrow it down. Just because you have difficulty debugging does not make a language bad.
umm... maybe just go out and buy "the rails way" by obie fernandez? that would have spared the world from this blog post...
Ok, but how do *I* do it? What does vim- do?
is that a reference book?
it covers almost every thing you would want to know about rails... http://www.amazon.com/Rails-Way-Addison-Wesley-Professional-Ruby/dp/0321445619 
I want to be able to do the vim- trick, but I'm not quite getting how to send the results of find . -type f to the vim line. Any help? I've gotten as far as &gt; find . -type f | vim - to get a vim file with ./files, but I can't use enter to open them, or escape t, or escape enter, etc. :/
Hashes are sweet.
I think we can all agree that the solution is to write tests for your tests
This guy was kind of a Ruby nuby for not knowing Hash.new(0). Another example: The other day my coworker was doing: while 1 == 1 # do some stuff end He said something like, "I wish this loop-forever construct weren't so ugly in Ruby." So I introduced him to: loop do # do some stuff end Yep, it's usually the fault of the user, not the Ruby.
I can see how you could do a :new &lt;paste the line I'm on&gt; &lt;Enter&gt;, but I can't figure out the &lt;paste the line I'm on&gt; part. I suspect there must be a key map like map K yy:new &lt;paste&gt; Anybody know the key combo for pasting into the command line?
Nope.
i know this is just a personal anecdote, but when i first checked out rails, it was a simple "gem install rails" and then "rails my_project" and it worked... now i'm pretty damn proficient in ruby, so it really came as a surprise how when i tried to install and run merb i couldn't figure out what i was missing to make it run. now i know i could dig in more and goto IRC, and that there are answers out there. so i guess my point is for any project to make sure that the installation step always works.
Rails has too much momentum at this point. More documentation, more plugins, more books, etc, etc I do think that Merb does some things a bit better, but for the most part they are nitpicky things (mailers are a bit better, etc), there's nothing that stands out as a 'gotta have' feature.
Can't we just all get along?
It's not a competition.
&gt; This release offers a full-fledged replacement for Ruby. Wrong, a replacement for Rails. &gt; Merb has 6,000 lines of code, compared to 70,000 to 80,000 lines of code in Ruby. Again, Rails not Ruby! &gt; Merb offers Ruby programmers another choice for building Ruby applications. this should be "Web applications"
&gt; The release of Merb 1.0 makes it the first replacement for Ruby, he said. There's no combination of interpretations that makes this statement make sense. I don't think the journalist knows what he's talking about.
I think Merb is good for Rails and vice versa. Merb has encouraged Rails to become thread safe (Rails 2.2), use gems instead of plugins (plugins was just a stupid idea from the get go), and has cast a doubtful eye on ActiveRecord which will eventually lead to DataMapper for Rails. I prefer Merb personally, but I see the benefits of having two strong web frameworks for the language.
Hey man, The thing is that Merb is built to be modular, so to hold true to this, all the pieces are separate at the moment and you have to install them all individually. I was at Merbcamp, and they did say they are planning on creating releases that have some sort of base set of gems based on your needs, so keep an eye out for it.
Oh, no doubt Merb has been good for Rails. There will be a group of devs that will prefer Merb over Rails for various reasons. But the question was "Can Merb knock Ruby off it's Rails?" and for the most part the answer is 'no'.
Isn't it, in some sense? You don't write code once, run in any framework. A larger mindshare for one framework means more development in that framework. It's not a competition in the highlander sense ("there can be only one"), but there are a finite number of web developers out there with a finite amount of time. 
DataMapper is a big reason. It's considerably better designed than ActiveRecord, and last I checked, DataMapper with Rails isn't as simple to get working as DataMapper with Merb. Maybe that's changed recently, though.
Really? I don't exactly see a huge advantage (or difference) here either. Like the rest of Merb compared to Rails, DM is a little bit cleaner and little more efficient than AR, but not a game changer. Perhaps I've missed something? 
Ramaze + Sequel blow merb + dm (and rails + ar) out of the water if you know how to program Ruby (and not just RailsVB dsl's).
gem install merb should work. There might still be some issues in that (we fixed the Windows once for today's RC2 and should be getting the JRuby ones for RC3) but by and large it should work.
Hi, WSF/Ruby has WSDL mode, http://wso2.org/project/wsf/ruby/1.1.0/docs/wsdl_manual.html. This enables you to write a service starting from a WSDL. Right now WSF/Ruby doesn't have WSDL generation or WSDL2Ruby, but it is going to be supported in next comming releases. The key strength of WSF/Ruby is the support of key WS-* stack like WS-Security, WS-Reliable Messaging, MTOM which is missing in any other SOAP implementation in Ruby. 
I like to think that a proficient Ruby programmer is able to learn them both and use one or the other depending on what fits best; just like having two similar tools in your toolbox. In this case we are not talking about a hammer and a screwdriver, the difference is more subtle, perhaps like the difference between a Phillips and a flathead screwdriver.
&gt; DM is a little bit cleaner and little more efficient than AR, but not a game changer I'm not sure about a "game changer", but DM has a fundamental architecture difference to AR. DM builds up SQL statements through an intermediate AST. AR builds SQL statements through what effectively amounts to string concatenation. If you've ever done lots of work with AR, then you'll know it frequently behaves in odd ways when you begin to pull records together through associations. You can't assume that a AR class method will work correctly on an association, for instance, as its not unusual for the association conditions to disappear once you start chaining methods together. AR is fundamentally very brittle; you can't sling together ARs and associations and expect them to necessarily work. The cause of this is essentially that there is no central point for generating SQL in AR. Every method has it's own little bit to add to the SQL query, and whilst this is effective for simple queries, it begins to fall down in unintuitive ways when you start to build anything complex. There are workarounds, but it would be nice if AR would work as you'd expect it, instead of breaking when you put any stress on it. I haven't worked with DM nearly as extensively as I have AR, but it doesn't seem to suffer from the same issues as AR. Having worked through many irritating issues with AR, DM seems very nice and predictable in comparison, because its SQL generation is centralised.
_If you've ever done lots of work with AR, then you'll know it frequently behaves in odd ways when you begin to pull records together through associations. You can't assume that a AR class method will work correctly on an association, for instance, as its not unusual for the association conditions to disappear once you start chaining methods together_ I have used ActiveRecord extensively, and have even patched a few bugs in it. I can't say I've ever had a problem with 'odd' behavior' w/ associations + class methods. Can you give any examples? 
I think WSDL generation is the biggest pain in the process. I quite like the fact that actionwebservice writes the WSDL and allows me to point it at a WSDL and call the methods. Anyway good luck. Ruby needs better SOAP support and nobody is working on actionwebservice. It would be awesome if this project duplicated (and bettered) actionwebservice on rails.
I think I have it for Linux. Have not tried on Mac http://www.blog.fairanswers.com/?p=12
To clarify, I was aware of the ability to assign default values through the hash constructor. My problem with that approach (originally), was that I wanted to pass a hash into a method that would not know how the hash was defined. I couldn't rely on the client code to *know* "I need to construct this hash with a default value." It took a little thought to realize I didn't really want to be passing in raw hashes - that my object model was retarded and it would be better to rethink it. Nevertheless, thanks for the comment!
THIS IS NOT A GOOD THING.
Hello job security!
Let me guess. It leaves your code exactly as it found it.
Even easier, try the Defensio plugin for Rails! http://defensio.com/downloads/rails
I found his github site and he stores all his config info there :) http://github.com/jpalardy/etc_config/tree/master
I enjoy the RailsEnvy podcasts and I bet this is pretty awesome too. Need to see what our migration plan looks like and if it makes sense to get this now and start reading :)
i can't accept code that's over 80 character width
We had the pleasure of seeing a beta version of this presentation live at our Ruby meetup this month... It is DEFINITELY worth it! I learned things that I didn't even know were in 2.1 already.
"The style's unusual, as far as I can tell. Coming from some backgrounds, it may look very strange." is it really strange? i thought most programmers did that... just thinking out loud.
anyone got a torrent?
See also: http://arunthampi.wordpress.com/2008/01/23/activecouch-a-ruby-wrapper-for-couchdb/
Ruby is a piece of turd! Can you believe my stupid boss the other day hired some young asshole, he asked me about Ruby and I told him it's a piece of crap, it can't scale or anything! I've already learned too many things, last I need is some young asshole coming into my office and telling me oh Ruby this and Ruby that... I won't stand for it anymore! This is just another reason why Ruby sucks so much. I don't know wether to upvote this for saying Ruby sucks or downvote it because it says "Ruby" in the title?!?
Not much here that I'd expect to see discussed on reddit (and though I'm grateful for the interest!, I'm surprised that it was submitted). Anyway, I guess I could pose the question in a different light to see if it can generate good discussion: What are the merits (or drawbacks) of such an implementation? I see it as fitting better with my perception of the "feel" of Ruby, but admittedly, I haven't thought through the potential pitfalls. I tried to keep the behavior of rand the same as I knew it to be - but I didn't intend it to be the *exact* replacement, only an introduction to one. So, do you see any problems, potential improvements, or think that it's wrong philosophically?
 module Enumerable def rand slice Kernel.rand size end end This makes a hell of a lot more sense as a method on Enumerable.
Hi. Welcome to the Ruby subreddit. Fuck off.
When thinking about it from the point of view in selecting a random element, I agree. What about selecting a random number? I think the disconnect is that we want to easily tell Ruby to give me a random number between 2 other numbers, without resorting to doing the math ourselves. That leads to the thought of sending rand a Range of numbers. But that leads to the thought of "well, ranges can be things other than numbers." Which leads to the thought that we can just select an element in the range to have it work as we'd expect. Then that leads to "this makes better sense as a method on Enumerable." But it forgets the original point. I'm just thinking out loud here - not trying to accuse *you* of missing the point. Just my thought process as it goes around in circles. 
Honestly, if I'm trying to generate a number between 1 and 10, I find "(1..10).rand" to be more idiomatic than "rand(1..10)".
I'd agree if I was thinking in OO terms. But if I was thinking in terms of how I'd normally get a random number, it'd be using the Kernel method. Of course, I think Kernel seems like an odd place for rand to begin with. =)
Downmodded because testing private/protected methods rarely, if ever, makes sense. Just because Ruby makes it trivially easy doesn't mean you should. Private/Protected methods tend to be chunks of code extracted for readability (Extract Method). They should still be being called by your public methods. It's your public interface and its behaviour that you care about and this is what you should be testing. If your test coverage is good enough, any logic in your private/protected methods should be covered. The fact that private/protected method code often starts off being part of the public method body before being extracted should make this obvious yet people still seem to want to test their non-public methods. As I said in the comments in the article, if you find a class has lots of private methods and only a few public methods, then your design probably isn't quite right - there is probably a hidden class trying to get out amongst all of those private methods. If you've tested all of these non-public methods directly, all you've done is strongly couple your tests to your implementation and made it really difficult to perform an Extract Class refactoring. Test your public interface. Try not to couple your tests too strongly to your implementation, avoid stubbing non-public methods if you can and never set expectations against non-public methods.
PROTIP: Ruby is OO.
Just because a language is "object oriented" doesn't mean it forces you to be OO in your designs, nor does it mean that it is consistent in its own object orientedness. Case in point: by what OO guideline do we decide that rand is a method on a Kernel object?
Merb has Thor tasks to do this for you, as well.
I have that actually... http://www.zenspider.com/~ryand/grammar.rb that isn't all of rubyforge, but it is a good sample size. I'm gonna get my gem downloader/surveyor back up to date and do a full run soonish.
as far as i remember the reason matz switched to the -&gt; syntax was because he couldn't get default values to work with the old lambda{|x|...} syntax. Am i right to read that they finally got default values to work with the old syntax? if so, it really does seem to abrogate the -&gt; syntax...
&gt; Am i right to read that they finally got default values to work with the old syntax? Yes, with the limitation that you can't directly use the `|` operator in the value (but you can wrap it in parenthesis: `lambda {|x = (a | b)| ... }`). Last time I checked, there were still a few odd bugs pointed out by Dave Thomas, but as far as I know it's still guaranteed to be on 1.9.1 final. Koichi Sasada has been fixing them fast.
Nice... I think I love you ;) 
Upmodded because beanstalkd is that damn cool.
and of course the one comment there asks about rails. I emote a sigh.
Well to be fair, the commenter *does* have emo hair. 
Why shouldn't a developer be concerned whether their frameworks runs on a new version of the language? What would your reaction have been if someone asked whether Merb worked on 1.9.1?
your generalized perception of what I said is incorrect
Rails is Ruby's killer app. People have good reasons to care about 1.9 compatibility.
I liked ramaze better, but also I've mostly used ruby for word stuff and playing with rmagick. rails seemed like I needed to learn a whole new language, and it was full of extraneous junk. if I could suggest perhaps: "Rails is Ruby's most popular app. People have good reason to care about 1.9 compatibility."
What do you need Rails for? You're not on a fucking train
 class &lt;&lt; self include Drama end
I fully agree. Nice to see that not only Zed has had the balls to call out the passive-aggressive shit in the Ruby community. I love the language, but so help me God, I fucking HATE most of the "leaders".
Just read it through. Reloaded to check if anyone had commented, 'Page not found' Uh-oh!
[Google cache](http://209.85.173.104/search?q=cache%3Ahttp%3A%2F%2Fgilesbowkett.blogspot.com%2F2008%2F10%2Fi-vote-we-lynch-chad.html&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=org.gentoo:en-US:official&amp;client=firefox-a).
I'm going to kill myself if history remembers me only as his roommate.
Hear hear!
Is this a new game, where you play werewolf, but through your blog? It's an awesome idea! Going by Giles definition of a werewolf: "The goal of a villager is to keep conversation rational and logical. The goal of a werewolf is to mislead, cast doubt, undermine logic, and encourage paranoid suspicion." I think it's pretty clear that Giles is the werewolf. He's the one trying to mislead and cast doubt. We should vote him off! And Chad just in case too.
It's a major obstacle when advocating the merits of the language (esp. when encouraging colleagues to embrace it for projects) ... "but the community are dicks" 
Just the thing I needed
Ruby programmers boggle my mind...
If you do now, it's a guaranteed outcome.
I'm fairly new to the community. Who's being passive aggressive to whom? Over what?
Remember boys and girls, the guys who run this: http://rubycentral.org/ are consultants who have made a ton of money from Ruby's success. It's in their interest to remain 'at the top of the heap' in Rubyland.
I don't get it? Is this Giles guy just a drama queen or what? He wants to lynch a guy because he may or may not have dissed him in some super subtle passive aggressive way? Get real!
Yeah it's kind of a pot and kettle thing. Giles is pretty passive aggressive too, ergo, he's hypersensitive to it.
Looks like a combination of Lisp (in places) and ObjC. In ObjC, the function-arguments are generally lined up, like.. [blah doSomething arg1: @"Argument 1" arg2: @"Another"]
A beta version of a presentation..?
I don't know either of these guys, but just reading Giles description of events, it sure sounds like Giles is a douche.
You do realize that nearly the entire post is tongue-in-cheek right? You guys are falling for the *real* werewolf's tricks.
It sounds like classic Giles antics to me. He's being serious, I'd guess.
Playing around with this seems to indicate that some things are not implemented correctly. On each li of a ul, the inner_html method should not return the li tag, just the contents inside. Seems to be a bunch of other related problems.
Well, behind the show is a Keynote (like PowerPoint but better) presentation. Jason brought it to our meeting and delivered it live. We were able to help him correct a couple type-os, etc.
While it's nice that this kind of information is readily available, it saddens me that it doesn't accompany the release itself, for free.
OS X installation tips here: http://www.rubyinside.com/nokogiri-ruby-html-parser-and-xml-parser-1288.html
Most? Some, to be sure.
Finally, someone gets it. What is being a "leader" in the Ruby community about? To a lot of people, it's about the dollars. So, yes, from a financially competitive standpoint it is in the interest of people who have "authority" (remember, their authority is *de facto* and not *de jure*) in the Ruby community to maintain the community. The community provides them with income via consulting. However, it is also in their interest to obviate/isolate/neutralize those who they see as a threat to their business. That said, in this particular case, I fail to see how Giles is a threat to Chad. Giles has made it quite clear that he's trying to find a way to make a living off of Archaeopteryx. However, it becomes quite clear that Chad is a threat to Giles: by seeming dismissive of Giles' work, even indirectly, it devalues the stuff of which Giles would like to build his career. Of course Giles is going to be pissed about that.
&gt; What is being a "leader" in the Ruby community about? To a lot of people, it's about the dollars. To the rest of us, it's about writing solid code that other people use. Chad has done this; Giles hasn't yet. Chad's unintentional put-down hit a nerve, but I think it's more about the prestige than the cash for Giles.
This makes Ruby and Shoes look not fun.
Bowkett. Of all the strategies you *could* have picked for self-publicizing, this one fails the hardest. If you attack them, they win. Consider yourself marginalised. Oh and "geek talk of the year"? Give me a fucking break. More code, less life-story pls. Stop being a blowhard.
It sounds interesting. However now I have the question, where does Sinatra stand? I mean, I thought that was Sinatra's niche, small apps and webservices... (Out of topic, I hate when examples do a "collect" and then and "each" over the results. I feel like I'm wasting time.)
Do you have a spec for this? Might be useful to submit.
I'll see if the source is properly spec'd, if so I'll submit it as a bug report, if not I'll write specs for it and submit it. I asked a few other engineers at work what their expectation for #inner_html would be and it seemed to be in line with mine, so I'm not sure if this is a bug or a different interpretation by nokogiris authors.
101st place! Arright!
&gt; To the rest of us, it's about writing solid code that other people use. Amen, brother! I do my own little part to contribute.
woops, i meant *nokogiri*, not nokogirl. although they do seem rather girly.
Interesting. Maybe I'm taking _why's snark in a way other than he intended, but he seemed to take the 7 times faster claim personally! At any rate, if this motivates him to finish his new parser and get it out the door (which in turn motivates nokogiri to pick up their game), this whole situation is nothing but good! Especially considering that one is a drop-in replacement for the other (Nokogiri bugs notwithstanding).
&gt;Maybe I'm taking _why's snark in a way other than he intended, but he seemed to take the 7 times faster claim personally! He probably does take it a little personally but mostly that's they way he talks. He can afford it too being the mad scientists and all.
Well, the benchmark was pretty cheesy (only three XML tag pairs), as he points out.
Oh yes, I definitely agree.
Yeah they seemed pretty girly to me too, I just thought I had been reading it wrong. Well stupid me, I installed nokigiri rather than hpricot because of the claims and now I'll be using hpricot. I should have trusted \_why. :( Also, have any of you fellas tried authgasm as opposed to restful_authentication? It's pretty slick.
There's a full moon in Ruby land lately. A few days ago there was a mini uproar on the official Rails blog about advertising. Giles Bowkett posted about "lynching" Chad Fowler and has now got kicked out of RubyConf. And Rich Kilmer called for "civility" in the Ruby community on his blog which resulted in a storm in the comments. I think it's just one of those weeks for Ruby land. Everyone's feeling snarky and underappreciated. In any case, I take why's accusation of being "sensationalist" with honor, considering that he's as sensational as it gets himself. If you can get people talking, that's awesome.
While the benchmark was not anywhere near exhaustive or particular scientific, it did highlight performance differences in a very key area.. namely, initialization and small scale XML parsing. This is quite a big area to win in - not everyone is parsing 100MB XML files.
OMFG bloggers having a catfight! This is the most interesting thing ever!
&gt; Everyone's feeling snarky and underappreciated. Dude, that's just _why. Tongue firmly placed in cheek.
nokogiri has weird behavior. Calling inner_html on an element returns that element plus its internal contents. Not exactly what I or others whom I surveyed about it expected.
It's even more clear when you read the comments between _why and Aaron Patterson - he may have taken it personally, but not any more seriously than some friendly competition. 
&gt;&gt; What is being a "leader" in the Ruby community about? To a lot of people, it's about the dollars. &gt; To the rest of us, it's about writing solid code that other people use. Chad has done this; Giles hasn't yet. eh, perhaps. I've used more of Giles's code than Chad's. I've also used more of your code than Chad's
Are you sure? Chad is one of the original authors of Rubygems.
If you get a loading error: sudo gem install tmail 
well, uh, I'm a Rails developer, I only need plugins :P
Passes unescaped email addresses directly to the command line. A maliciously formed email address can execute arbitrary commands; beware.
From the comments: IO.popen("#{sendmail_binary} #{tmail.to}", "w") Um, you do know that "`rm -rf /`"@foo.bar is a perfectly valid email address, right? Really, how could that line not set off major alarm bells in your head, passing likely user-supplied data directly to the command line? Try popening another Ruby instance and execing in it, like: IO.popen("-") do |f| if f f.write(tmail.to_s) else exec(sendmail_binary, tmail.to) end end This prevents any metacharacters from being evaluated by a shell. 
...and this is why we build from source.
maybe you should submit a pull request :P
raganwald's posts make me dizzy. I got to find a copy of 'To Mock a Mockingbird' now ...
&gt;To view this blog in its web3.0 glamour and mind-bending perspective please install Consolas font and use Gecko or Opera. Apparently Web 3.0 has best-viewed-in messages just like Web 1.0. What a step forward.
What happened to the guy who was going to build the ruby benchmarks? I was really looking forward to those. Also it would have been nice to see what rubinius did.
My fix has gone in, panic over.
Be careful with using redirect_to(:back)
He forgot to benchmark Yarv :( Unless 1.9 = Yarv, which it seems to be. Ruby 1.9 Win!
1.9 *is* YARV.
Using Rails for those kinds of things is a bit like using a cannon to kill a mosquito. And I submit that we have what the author is talking about just with gems and plugins. They're the modularity and they're open-source. 
Yes, Hypocrites: indeed 3/4 of the work is done: we already have gems and plugins for most of the things, only it would be nice to have a "glue" to hold them together: be it a GUI frontend, a higher level framework or a collection of rake scripts...
Apart from the dancing chick (obnoxious, unnecessary, gross), I thought the Emacs look was pretty impressive. And I already had Consolas installed.
Ah, I see what you're saying and you have a valid point. I just don't see how Rails can have something like Drupal unless it's a plugin or a gem. Drupal you just upload to your server and you're ready to start configuring. I haven't dealt with Passenger yet, but as far as I know Rails is still pretty hard to deploy, especially in a shared environment which is, I would think, what a lot of people looking for this kind of solution would be hosting their site on. Edit: Re-reading your article you come to the same conclusion in a sense. If we could streamline deployment of a rails application, then I think you're dead on.
Everything is a one-liner if you use enough semicolons.
 "this is a test".scan(/\w+/).inject(Hash.new(0)){|a,n|a.merge(n=&gt;a[n]+1)} This is maybe a bit better in that respect.
Nicely done!
http://github.com/acangiano/ruby-benchmark-suite/tree/master Last update in July, apparently.
NO! Pulling features makes people think that Ruby is not well-thought out. We have enough problems with idiots (eg: my boss) saying that Ruby is too different and the client doesn't like it. If there's some minor problem that only some brainiac will discover I say we a) stop talking about it and b) quietly fix it. If you disagree then you are a traitor.
argh!!!! it looks like perl.. the googles!!!!
If you're really that worried about Ruby looking like Perl, code there's [English.rb](http://www.ruby-doc.org/core/files/lib/English_rb.html) that comes as part of the core libs. `$!` becomes `$ERROR_INFO` and `$@` becomes `$ERROR_POSITION`. Or you could accept that Perl really isn't that bad. It's just tailored toward those who are already experts at it.
There's a catch-22 if I ever heard one! And yeah, that's why Perl really IS that bad! -------------- "It's just tailored toward those who are already experts at it."
well i'm also familiar with use English in perl... i'm not saying that perl is bad, my main complaint is that $_ sux 
Just because it's tailored to experts, it doesn't mean that beginners can't learn it. It's just not trivial at the beginning, and requires a bit of work to learn the idiosyncrasies.
I know --- I've done it --- can't see the point though...why should an environment be any harder than necessary. It's not necessary for Perl to be so idiosyncratic. I for one have been very happy to see things like Python and Ruby as options to replace Perl.
I covered a bunch of these in a post reviewing Ruby tools as well if you want another opinion http://devver.net/blog/2008/10/ruby-tools-roundup/
&gt; It's not necessary for Perl to be so idiosyncratic. No, but it sure is fun. When working in Ruby, I find writing idiosyncratic code is just plain *fun*. You become a part of the culture, absorbing the little details until you feel as though you are one with the language. You play to the strengths of the language to the point that every single feature, every single punctuation is tailored exactly to the task at hand. Obviously, you don't want a large codebase that people will have to maintain having these types of gotchas. The fewer the idiosyncrasies, the less prominent the language's personality. You have to strike a balance between the two extremes of no idiosyncrasies and too many, and different people will find that balance in different places. That's why you have different programming languages. One example is the command line. A GUI is usually easier to explore for beginners, so why have a command line at all? Because once you're advanced in your knowledge of the command line, you have a great deal of more flexibility in certain tasks. Similarly, the idiosyncrasies of any language are there because such details allow one to more easily code toward solving a particular type of problem, and learning that language very well makes it easier to handle those types of problems. Really, I don't care if you don't like a language; we all have our own preferences. What I find strange is when people assume that everyone will agree with their preferences, and coding in any other style is the end of the world.
This looks very promising. I can't wait to try this out.
It is difficult enough to implement Ruby, but to modify *and* implement is asking people to be as smart as language designers. However, all four of those forks sound amazing.
First person to say "Ruby Enterprise Edition" loses.
You lose.
comment out #include "ZedsEgo.h"
use/mention
Yeah. The facts (i.e. saving lots of memory) do not matter, only the name does. Spoken like a true geek. Anyway, the fact is, if Ruby Enterprise Edition and Phusion Passenger are used, the memory occupied by all those compiled routes will be shared between all application processes, thus significantly reducing memory usage.
Don't use rails?
Nope.
One hundred meters is quite a bit of RAM...
I've encountered this in the past. You can get the right arity in the define_method example by using empty pipes: define_method { || ... } An annoying inconsistency, for sure.
Out of curiosity, when have people used the #arity method?
Or, you know... # In .autotest require 'autotest/growl'
It comes up in meta-programming from time to time, for example: http://github.com/raganwald/homoiconic/tree/master/2008-11-07/before_and_after_advice.rb In this case, procs are being composed together with a special rule that if a proc takes parameters, whatever it returns is passed as parameters to the next block in the chain. But if it doesn't take parameters, it is executed only for side effects.
Ooh. Very cool.
Good god, why would you try to turn javascript into something like that? What benefit can there be? It looks like Objective C? It doesn't get any static typing, or any of the other redeeming features of such a hideous language.
I quite like Objective-C myself and I guess the motivation for Objective-J is that Objective-C features and Cocoa design decisions frequently go hand in hand. It's the same reason why I find things such as RubyCocoa (the bridge, that is, not MacRuby) a bit of a non-starter.
Right, but why would you add back in things like static typing? I understand the 'feel' of it, but it's disallowing much of the nice things about javascript.
Good stuff.
It's not so much a myth as it is a problem solved.
I never thought that myth had anything to do with deployment on Apache. It's IIS and Windows where it's hard.
Whilst Rails itself maybe easier to deploy than it was - deploying a Rails application is (in my experience) quite a bit more work than deploying a similar size IIS/.NET application - especially when using Gems (that also depend on other Gems). Also, Rails not being backwards compatible introduces further complexities when distributing an app to other users - and the inadequacy of some of the error messages complicates things further especially for inexperienced users.
Mongrel wasn't particularly stable for us. Instances would stall for no apparent reason fairly periodically. It also wasn't fun to (basically) manually manage a dozen processes, Passenger has been a breath of fresh air for us, but I wish I could get get back the time I've spent dealing with Rails deployment issues before we switched over.
Not sure I am understanding your second point there? You are distributing a rails site without the version of rails frozen? I would never do that wherever possible. That also covers your first point in most cases because you can just vendor all your gems. There is even provision for it explicitly in 2.2.
Rails is the easiest thing ive ever used to deploy. how much more simple can you get when using Capistrano and Passenger.
Doubly, there's [known and good solutions](http://errtheblog.com/posts/50-vendor-everything) for vendor'ing gems in older versions of Rails.
Capistrano really helps. Investing a little time to learn the basics of capistrano and how to extend it gives you the ability to script very complicated build tasks. We have a dozen or steps for a deploy, all encapsulated in a single command that takes about 5 minutes to run.
Boring title aside, what’s the deal with Merb? The ”Merb *can* be two to four times faster than Ruby on Rails” type of statement aren’t winning me over. What I’m looking for is something that’s a bit easier to manage than Ruby on Rails. Not something that’s necessarily faster.
ORM agnostic doesn't mean shit practically speaking. You can use any ORM with Rails.
Even better, as far as I can tell in Rails 2.1, you don't even need to bother loading the paths in your env.rb -- it will automatically search in vendor/plugins for you.
Well, you can take a lot more out of merb, which is less complexity to deal with. If you're using the full stack with activerecord, there's not a huge benefit to it. A really small merb app is much, much smaller than the smallest hello-world rails app.
Isn’t the whole point of using Rails or Merb that you don’t really care what goes on at the ORM layer?
You can write a robust, front-end friendly app in merb but it will take much longer than in Rails. Merb seems to be carving out more of a niche for itself in the mini-app/background process realm -- file uploads, transcoding, emailing, scraping, etc. These don't need much front-end if anything but need environments where every last CPU cycle and MB of RAM counts. I'd say the current sweet spot is frontend app -- Rails; async processes -- Merb.
I have to disagree with your statement: "You can write a robust, front-end friendly app in merb but it will take much longer than in Rails." It was true few months ago, but with merb-stack and all the helpers plugins it's at least as easy. However you are right that Merb shines when it comes to webservices, background processing etc..
here is a good list of reasons to use Merb: http://merbist.com/2008/11/09/merb-1-0-released/ Basically, the speed and small memory footprint are just the end result of an overall clean and optimized code. Let me quote 37 signals: "Don't follow the leader Marketers (and all human beings) are well trained to follow the leader. The natural instinct is to figure out what's working for the competition and then try to outdo it — to be cheaper than your competitor who competes on price, or faster than the competitor who competes on speed. The problem is that once a consumer has bought someone else's story and believes that lie, persuading the consumer to switch is the same as persuading him to admit he was wrong. And people hate admitting that they're wrong." http://gettingreal.37signals.com/ch02_Have_an_Enemy.php To be honest, you are fine using Rails. Rails is a great framework, it has good documentation and a pretty big community. But if you want something fresh, some code you can understand, if efficiency matters which and if you need more flexibility, then use Merb.
Ezra has done a lot of work getting Rack to work with Rails as well.
What specifically do you mean by "manage", and what do you think is hard to manage? With more details, you might get better answers :)
Blog post summary: Hi, I'm DHH. Until very recently, trying to deploy rails apps has been about as much fun as tearing open your own scrotum with a fork and filling it with sulfur. We think we sorta got something that works now, so I'm going to act as if the problem has always been solved and everything is sweet. We rule, PHP sux (even though it has been stable and easy to deploy for years), lolz. 
If "thread-safety" is important to you, I hope you're using jruby. MRI 'threads' are nearly useless.
Yeah, because building and installing apache modules and rebooting the server is WAAYYY easier than dropping a .php file into a directory, right? right?
Last time I checked Apache still requires a PHP module to run PHP (unless you are using CGI). Installing Passenger takes minutes. Deploying changes doesn't even require an apache restart (touch tmp/restart.txt).
While we're on the topic of phusion passenger, does anyone know good phusion passenger hosting, besides getting a VPS and setting up your own stack?
Choose whichever suits your fancy.
The ORM part of Rails is the easiest part to replace with, for instance, DataMapper.
Why? I've only made a cursory glance and they look to be otherwise identical frameworks, except Merb feels a little more planned and less hacked together (RAILS_ENV vs. Merb.environment made me laugh). What's the big difference? Less available plugins?
I honestly don't think there's any intrinsic difference between the two at this point. However, Rails has two things going for it: amazing momentum and community enthusiasm, which translates into plugins and "standard" approaches for uncommon problems; and documentation, both unofficial and official. The latter is, as far as I recall, an conscious choice on the Merb peoples' part so that they were as API-tied as little as possible before 1.0, so it should ease up. Without an earthquake of some form, Merb will always be playing catch-up on the former, though.
He told me that EY has clients trying to use Rails 2.2 multi threaded and have some serious issues. Thread safety is hard and modifying and existing app to make is thread safe is even harder. Merb doesn't share any data and therefore doesn't use a mutex at all. You still need to be careful with your own code tho.
&gt;Whilst Rails itself maybe easier to deploy than it was - deploying a Rails application is (in my experience) quite a bit more work than deploying a similar size IIS/.NET application - especially when using Gems (that also depend on other Gems). Really? Do this just once.... rake gems:unpack:dependencies Do this every time you want to deploy. cap deploy If you have database changes do pending do this cap deploy:migrations If you want to undo your changes cap deploy:rollback Oh man that's so fucking hard!!!! Tell me how much easier it is to deploy a .net application, apply all your database changes and then roll it all back. I dare you. &gt;Also, Rails not being backwards compatible introduces further complexities when distributing an app to other users freezing your gems solves this problem too!!!!! &gt;and the inadequacy of some of the error messages complicates things further especially for inexperienced users. Nobody writes worse error messages than MS. Nobody. 
There are a lot of options out there. Ramaze, sinatra, camping etc. Rails still rules though because it has the most community behind it and it's shedding weight as time goes along. 
Couple points: 1. There is an intrinsic difference between the two. You could argue that externally they're very similar, and I wouldn't disagree, but on the inside the overall design and philosophy is pretty different. Rails is great for prototyping and building simple things really quickly. A lot of us found over time though that once you get that first 80% done, the remaining pieces can take some time and a bit of effort. It might take you a little longer to get a blog written with Merb (and even that's changed a bunch as Matt pointed out) but the last 20% should be easier to handle with Merb. 2. I also think the catch-up point is incorrect. Make no mistake, Merb learned a LOT from Rails, both what's great, and what's not so great. I think Merb's really pushing forward on new ground and innovating where it can. If you look at Rails and Rack, ORM agnosticism, and other Merb features we've had from the start, you could make the point that its actually Rails now taking back and learning from Merb. The original question is the wrong one to ask. Instead of "why X instead of Y" it should be "I need to do A, for reasons B, C, and D. What technologies are the best fit?" Who knows what you'll end up using. Hopefully whatever makes the most sense for your own reasons, not what anyone else is telling you without hearing your needs. 
1. Sorry, yes. I should have been clearer. There is little difference in the capabilities of the two frameworks, once -more and so on are taken into consideration. The way they are each written is as night and day. 2. History is filled with technically better solutions to a problem that failed for non-technical reasons. I hope that the technically-aware crowd can win the day, but ultimately right here, right now, Rails has momentum and mindshare with the marketing drones and hype merchants, and Merb does not, and that's what leads, indirectly, to community size. I don't see a general exodus from Rails to Merb happening in the immediate future. If Rails ends up nicking all of Merb's best ideas, on the other hand, so much the better for all concerned - the great ideas get an active playground to prove themselves in, and a mature ("stable") environment to be deployed into. This is all IMHO, anyway - I'll gladly be proved wrong on any of this.
True, but in Rails 2.1 you also have the option of configuring gem usage and handling freezing. Plugins are the devil. They lock code away in a Rails-centric universe when they might find reuse in other situations.
Unless you're serving, say, web requests, where one can be blocked on all different kinds of IO while the others are continuing. Anecdotally, converting rails to not block on DB access has led to 2-8x as many requests with longer requests.
Rails is under the hood a bit messy and Merb is probably cleaner and more understandable. For example, try to change the routing code in Rails, this is just black magic. In short: Merb is Rails rewritten in a clean and modular way.
Try to change the routing code in Merb. It's equally terrible.
While I think it's on its way, merb-stack is still plagued by the fact that all the components to make it useful are not maintained on the same schedule or by the same people. So, while parts of it work rather harmoniously, the other parts don't necessarily. 
The routing algorithm has some kind of inherent complexity, which you cannot avoid, but I find this quite readable http://github.com/wycats/merb/tree/master/merb-core/lib/merb-core/dispatch/router/route.rb
Dealing with blocking syscalls and IO is a big problem for getting any kind of concurrency out of a single ruby process. A great way to deal with it is to use non-blocking syscalls and IO instead, but that means having to deal with event-driven ugliness/fragility/unfamiliarity. The guys behind neverblock use Ruby 1.9 fibers (coroutines) to wrap those details in a normal synchronous-looking programming style. See http://www.espace.com.eg/neverblock/benchmarks for their benchmarks with Rails and long-running database queries. This doesn't need any Rails 'conversion' either. It's just a database driver replacement that behaves well with concurrent use.
I've done dozens of Rails sites (from very small to fairly high traffic) over several years and have never had to touch the routing code. I've only ever had to monkey patch anything inside of Rails once, and then my fix was actually later fixed in an official patch. You really never need to look inside of the core rails code if you don't want to; if the performance is enough for you, the speed benefits of development *far* outweigh the framework code complexity.
That's exactly what I was talking about, Mr. Kemper. Good links though.
In my experience, before a few months ago, i.e., before Passenger, deploying Rails on Apache was a nightmare if you were into things like keeping your application from producing 500s. It was slowly getting easier .. I remember during the period of early Rails it was particularly heinous. You'd need to killall Ruby zombie processes often .. etc. etc. oh God the bad old days.
you're right, if we talk about application development. but there are many plugins out there which try to change the framework behaviour. restful routing was first a plugin and was later added to rails.
"user merb, our code is cleaner" is a losing marketing strategy.
pick a side you ninny...
humm it takes one line to install Apache. sudo aptitude install apache2 apache2.2-common apache2-mpm-prefork apache2-utils libexpat1 ssl-cert
i think in an open, extensible language like ruby, especially where so many developers have complained about the horrors that AR wreaks on the object model, a "cleaner codebase" argument has reasonable weight.
Not really. You interact directly with the ORM after it automatically sets up database connections for you. AR and DM are quite different, and Sequel is differenter still. Personally, I love DataMapper. 
Merb clocks in at about 6000 LOC, while Rails is 60,000. I won't suggest you read _too_ much into that, but if your goal is to completely understand the underpinnings of your framework, Merb may be a better choice.
Why does this website use Flash for its headings?
Probably to be able to use non-standard fonts that not all users will have installed (Gill Sans in this case).
Interesting choice to use an optional browser plugin to display very important content just to use for an optional font.
I hate the idea, but I've seen it before. I believe it will downgrade to regular text if Flash isn't installed, but I'm not sure.
The merb stack is about 30KLOC; merb-core is half that. Rails minus Active Record is 46KLOC.
If you look at the source you'll see that it is just h*n* tags with a meaningless span in them, then the heading text. an external javascript then checks if flash is available, loads an swf with the embedded font and embeds them in each of the h*n* tags. It's a reasonably good solution for the weirdos that are obsessed with the page looking identical to everyone.
what horrors do you speak of? I've used AR heavily for numerous apps. I think the point about being cleaner has technical merit (if true), but it's not going to lead to any real traction. It's also easy to be "cleaner" when you have far fewer features. Having said that, I find merbers definition of clean a tad odd. They obsessively complain about alias_method_chain and I can't figure out why.
Heh, I must have extremely old information then. Nevermind! :)
It's not (as much) about the page looking identical, it's about being able to use decent or unique looking typefaces that will still be visible to 95% of web users. Probably the most common implementation of flash headings is sIFR, in case anyone is curious.
What the hell does this have to do with the content of the posted article?
Decent typefaces are available to a large number of users. There are non websafe fonts available on Macs, MS Office which is installed on a large fraction of windows users computers has some decent fonts. You can choose a list of typefaces you think are decent looking and specify them in the stylesheet in order of preference. I think it's a safe assumption that people who don't have a large array of fonts on their computers, probably don't care too much. My main beef is that people are more concerned about the page appearing pixel to pixel identical on different platforms than the content appearing in a useable and pleasing manner to wide variety of platforms with differing rendering abilities.
&gt;it's about being able to use decent or unique looking typefaces that will still be visible to 95% of web users. [grouchy] I *have* decent-looking typefaces, which is why I have my browser font set to one.
If by weight you mean size of the code base it is gaining from occasional binges. (recently timezone and internationalization code).
We nerds are *obsessive*.
What the hell does it matter? Do all discussions on reddit have to be on topic? I guess I missed that memo.
[grouchy devils advocate] Well, you know, when I have my designer hat on, I think I know more about how I want to convey my message than you do. My choice of typeface is a deliberate attempt to send a certain message, so enjoy it ;)
In the first line, ruby assumes that since the variable doesn't exist, you're asking for the instance variable. bar = "*** #{bar} ***" Here, ruby becomes "aware" of the local variable "bar" before it tries to access it again, so even though it has no value, it doesn't attempt to access the instance variable. I won't defend this as sane behaviour and I definitely wouldn't recommend accessing ivars without the '@', but I'm pretty sure that's what's going on. EDIT: Oh, I didn't realize bar is an accessor. What's the problem here then; what did you expect?
&gt; Decent typefaces are available to a large number of users. There are non websafe fonts available on Macs, MS Office which is installed on a large fraction of windows users computers has some decent fonts. Quite true, and indeed my preferred method of designing is to set up a massive stack of fonts. However, it is far easier and more consistent to use something like sIFR in many cases. As an example, if I wanted to use Franklin Gothic headers, I would probably not use bold as Franklin Gothic is heavy enough in its standard weight. Problem is, if a user doesn't have Franklin Gothic, the fallback fonts will not appear bold, making the headers essentially disappear. There are other problems too--fonts have varying letter-spacing, x-heights, and other such things that make it very difficult to get not only a consistent and pleasing look but also readable text across the entire font stack. This wouldn't be a problem if you could specify properties on a font-by-font basis, but that is currently not possible. The CSS3 fonts module is attempting to address some of these concerns, but obviously support ranges from extremely minimal to nonexistent. &gt;I think it's a safe assumption that people who don't have a large array of fonts on their computers, probably don't care too much. I think this is a terrible assumption, actually. Would you say it's safe to say that a person who hasn't purchased photoshop doesn't care about the look of a printed ad? You don't need to be a designer of some sort to appreciate good looking materials, and you don't need to actively appreciate good looking materials to be affected by it on a subconscious level. If this weren't the case, we wouldn't spend massive amounts of resources on the quality of our printed and electronic materials because 95% of people would be just as happy with a word document set in Times New Roman. &gt; My main beef is that people are more concerned about the page appearing pixel to pixel identical on different platforms than the content appearing in a useable and pleasing manner to wide variety of platforms with differing rendering abilities. Irrelevant to the current discussion, as sIFR is completely degradable. In fact, more accurately, it only scales up if the client is capable of both flash and javascript, otherwise the page is semantically identical and visually quite similar (as in, headers still look like headers).
&gt; Please stop crying that Rails happens to include a default choice. That's what Rails is. A collection of default choices. You accept the ones where you don't care about the answer or simply just agree, you swap out the ones where you differ.
Yet another reason that I wish either local vars had some kind of prefix (how about '%' to confuse Perl people? :) or there was a syntactic sugar for 'self.'. To get around this kind of confusion, I usually use 'self.' for any writer (and even some readers). It's not as pretty or terse, but it makes one less likely to encounter odd cases like this.
It seems like you're including whitespace, specs, and comments in your count. When you eliminate those, merb-core now clocks in around 7kloc. The important thing is that it's POSSIBLE to use just merb-core without a lot of fuss. Kindly let me know how to use a subset of Rails that's under 10kloc if I just want to build a web service?
So I think I understand now...? The first "puts bar" must look for a local variable that it doesn't find, and then checks to see if there's a method with the same name that it does find. This is the equivalent of saying "puts self.bar". There are two methods created by the attr_accessor call: the getter and setter methods. This "puts bar" call finds the getter method, which returns "testing". Then, saying "bar = whatever" creates a local variable named bar. At the time that it evaluates the expression to the right of the equals sign, the local variable bar has been created and is nil. Then when you say "puts bar" again after that, it must check (again) to see if there's a local variable named bar and use that. It never gets to the point of checking for a method named bar (self.bar) because it found the local variable. What's really confusing about this is that the first "puts bar" is doing something completely different from the second "puts bar". The two bars are actually two different things. Is that right?
merb-core + merb-more + extlib clocks in at 17,291 LOC. Rails (without ActiveRecord, ActiveResource or ActiveModel) clocks in at 47,195 LOC. http://rubyurl.com/OPWQ
const_missing and method_missing make your backtraces really messy. Debugging gets ugly when half the content of the backtraces are entirely irrelevant.
Why not Ruby 1.9?
Mootools.
Maybe I don't use those as much as many others, but I haven't had any problems with that. I rarely if ever use method_missing in my own code and I haven't had a problem with the default AR. I've built two medium code bases in rails (a bit under 10k lines of code per project not counting tests). I'm trying to imagine a situation where this would be a problem and I'm having a hard time. The backtrace will show the line in the controller or model from which you called something that failed. If it's remotely confusing to me I put a break point there and step into it. 
I did include whitespace and comments: `find */lib -name '*.rb' -exec cat {} \; | wc -l`. The order of magnitude difference in code size just smelled off me. Not that it's of any true relevance: the measurement itself could be more precise, but probably no less useless!
No. People moan about using jquery and rails because fudging the authenticity token for AJAX is a complete and utter pain in the fucking ass. There is an invisible barrier to using other JS libs.
Oops, I forgot extlib. I also exclude the bundled third-party libs in Rails, like tmail and tzinfo. So using Yehuda's measure, Rails clocks in at 24 KLOC :)
Rock on, guides.rubyonrails.org looks incredibly comprehensive and clean (minus the incredibly long article length) -- but I guess that's a good thing! And since it's all still alpha-beta docs, I'm sure they will partition out the sections. Amazing work. 
It's pretty easy, actually: http://henrik.nyh.se/2008/05/rails-authenticity-token-with-jquery A small effort to get nearly-transparent CSRF protection.
Ruby 1.9 is a bit better off than 1.8 since you can do blocking syscalls without deadlocking your green threads, but it still has a global interpreter lock: http://www.igvita.com/2008/11/13/concurrency-is-a-myth-in-ruby
First of all everybody who gives LOC counts for rails is lying. They are counting libraries which rails bundles in like tmail, 18n etc. Secondly I don't think you are going to convince anybody that rails should not have included timezone support or internationalization code. Finally rails is moving more and more stuff out (like database libraries, SOAP etc) out of the rails bundle into their own gems. 
Yah, jrails is pretty good (http://ennerchi.com/projects/jrails)
Rails has Rails.env and also helper methods like Rails.env.production? or Rails.env.development? Just goes on to show how much you know and how much FUD is there.
Well yeah. It's simple in the same way that everything is simple once you know. Do you know how to order 10 plates of assorted sashimi in Japanese in a formal context? I do, and it's easy for me. Is it trivial for you? Using another JS library in rails is just not as transparent as David is trying to make out in his post. The example given simply will not work without Henrik's hack, and not telling people this will only have them banging their head against a wall staring at their log file. 
Read the comments there too : Rails, excluding bundled libs, is 23923 LOC. Plus, if someone is making a choice based on LOC, good lord, he/she clearly is a fucking retard. Next stop of retarness : Count the number of words !
oh. finally someone doing some fixing besides complaining about bugs
I use Rails and I get DHH's point about turning a picture into a puzzle, but defending the design choice by telling people they can comment out specific parts is silly. Options are good things. Pretending something provides easy options just because you can edit the source is something else. Sure, you *can* edit the source, but exposing those options to begin with is superior. Merb does this right IMHO 
Er, why would you include lines of comments or empty lines? Presumably comments are fairly well correlated with documentation, but really are totally irrelevant to code efficiency.
I agree, but there's nothing stopping you (or anyone) from patching Rails to act more like Merb in this regard. 
Also, if "use merb, our code is cleaner" is a loser, then use the speed argument. Merb, from all indications is a lot faster than rails, and more memory efficient. There are performance gains to be had, even if you've got no interest in cleanliness :) (Ezra's caveat is worth heeding though. Don't trust anyone else's benchmarks unless you've run them yourself http://wiki.merbivore.com/faqs/performance ).
Yes. Even the usual "but I can't do it" excuse does not hold much ground here, because it's not hard to implement this, *and* Rails's target group is programmers.
Are you implying that other than the CSRF issue, there are more? Otherwise I don't see the problem. Besides, suppose that Merb has CSRF protection too (I don't know whether Merb has). Would Merb be able to solve the same problem without incurring *any* learning curve whatsoever?
Ordering sashimi in a format setting is not trivial for me; I'd love to know ;) But, I'd google it to find out! I searched for 'rails csrf jquery' and came up with a few different solutions in a matter of minutes.
He is not saying you have to comment out specific parts. In rails the configuration file is ruby code. You are configuring your application by changing the configuration file. That's how you do it in all frameworks.
read it again. apart from removing activemailer, etc. from config.frameworks in environment.rb, he *is* advocating commenting things out. He's not talking about configuration files beyond environment.rb. editing actionpack/lib/action_controller.rb != editing a config file
It isn't about being able to do it or not. Yes, any programmer worth his/her weight can do it. I just think advocating commenting things out when you could make things optional (as the aforementioned config.frameworks -= does in environment.rb) is weak. This is akin to making windows users edit the registry to remove unwanted behaviors (in windows, not rails). Just because your users should be able to do something doesn't excuse making that thing unnecessarily complicated when it could be trivial.
good article
see http://yehudakatz.com/2008/11/15/mythbusting-rails-is-not-a-monolith/ 
So, the combo of this article and these other two: http://www.loudthinking.com/posts/30-myth-1-rails-is-hard-to-deploy http://www.zedshaw.com/blog/2008-11-13.html ...finally convinced me to try Passenger out. I know I'm late to the party, but I have to say that I'm extremely impressed so far. I haven't tried Ruby Enterprise Edition yet, but using Passenger in development is awesome. No more booting up Mongrels to check things out in the browser = Awesome. Getting thing up and running on my VPS was much easier than expected as well. I'm one happy guy right now. Thanks, Phusion guys! :)
In my opinion this article is a great summary about the actual weaknesses of Rails: 1. Bundling of dependent libraries into the framework. 2. Forcing a certain directory layout. 3. Opaque hook mechanism (`alias_method_chain`). 4. Missing modularization. 5. Missing granular opt-out mechanism. I hope the Rails team is listening to these valid complaints and open their mind for some discussion, how things can be improved without much work. Most of these things are fixable. DHH even points out, that it is easy to seperate some parts of Rails, so why not simply do it? just my 2 cents
I disagree with DHH. Whilst Rails is modular to some extent, there are still many separate parts that are arbitrarily intertwined. For instance, validation in Rails is intertwined with ActiveRecord, when it could be a separate mixin. There's no reason that a custom model class that saves data to a file couldn't benefit from the Rails validation methods. Or what about the date\_select control? The function that parses the HTTP parameters date_select returns is also embedded in ActiveRecord. Surely ActiveRecord should just be for communicating with the database, not parsing parameters into a Time object. There are many more parts of Rails that have a distinctive monolithic design to them. Whilst you can separate out the big components, it's not modular in a fine-grained way. I mean, Linux has modules, but it still has a monolithic design, and that's not necessarily a bad thing. Rails is really pretty monolithic, especially compared to many 'lightweight' web frameworks.
For whoever needs a guide for OSX, I wrote up how to do [passenger](http://www.gittr.com/index.php/archive/setting-up-passenger-on-osx-for-sinatra-development/) on top of OSX a while back. There's a great control panel to make setting the virtual hosts trivial.
He is mentioning that as an example. No sane rails user would remove those parts because they are so useful. He is pointing out that Merb does not have that functionality. He is saying if you really really don't want it you can easily remove it but he says later on nobody would do that. 
in your mind, exactly what functionality is he saying merb doesn't have? The ability to comment things out? What article did you read?
He mentions them in the article. 
Passenger is the shit. those guys deserve every penny you can give them.
I'm just gonna comment on a single thing: Forcing a certain directory layout. This is a feature. A big feature. The consequence of it is less (no) configuration, and familiarity — all Rails apps are structured the same, making it easy to familiarize yourself with the works of others, or even the work of yourself six months ago. This feature will never ever be taken out, and simply asking for that is to admit that you are completely and utterly ignorant about the core philosophies behind Rails. Why even bother criticizing something you do not understand the basics of?
&gt; all Rails apps are structured the same, &gt; making it easy to familiarize yourself &gt; with the works of others, or even the work &gt; of yourself six months ago. Please read my comment or even the article carefully. This is about granular opt-out. For 95% of web apps you may use the default layout, but if you want for example a simple web service, maybe a json store, the layout is not a perfect fit for the use case. &gt; This feature will never ever be taken out, &gt; and simply asking for that is to admit that &gt; you are completely and utterly ignorant about &gt; the core philosophies behind Rails. Why even &gt; bother criticizing something you do &gt; not understand the basics of? Please stay factual. I'm using Rails since years and I loved it. The whole "convention over configuration" philosophy is great. But there are many Rubyists out there, who will agree with me, that Rails has a bit too much magic inside. If you are doing a standard web app, this is probably fine, but if you are going to introduce your own metaprogramming into your application, this is likely to get in the Rails way. So leaving out some parts of Rails really would help in some cases, hence the need for granular opt-out. 
So you think convention over configuration is great, but you don't want there to be any file structure convention? That makes lots of sense. How about unicorns, wouldn't it be great if we had unicorns? Oh, and pixie dust!
I see convention as default configuration. Convention is a general advice, what is best for 80% of use cases. It is a great way for quickstart your project and prototyping. But sometimes it happens, that the default is not the best possible configuration, so you want to change some of the defaults. If Rails defaults would fit for all cases, there wouldn't be any plugins, which change framework behaviour.
This is stupidly cool. Sinatra is an awesome spot to put your dumber 'get' actions. It is faster, and has far fewer layers to go through than the whole rails stack.
Note: there isn't supposed to be a question mark in the URL. The actual article is a bit farther down on the page.
Wow. Perfect article for someone who's been out of the loop for a few months.
*yawn*
I love that fact that merb is there and pushing rails to become better, but I'm sticking with rails for a few reasons. 1) I like that it's full stack unlike merb-core. This leads to the most successful code reuse I've ever seen which is a huge boon for productivity. 2) I've watched rails address shortcoming after shortcoming and I'm sure it will continue down that path. I expect rails to be thread safe soon (a reason people used to give for using merb). I've seen memory usage and performance improve over time as well. 3) I've invested a lot in rails and don't see a compelling enough reason to ditch it for merb or anything else given my second point. Having said that I hope merb continues to progress and give rails the competition that leads to many of these improvements in rails.
Oh I was still working on this post. But I'm glad ya'll are reading it. I'll update it again soon and add some more examples.
Well, I was looking at the Merb faq [here](http://wiki.merbivore.com/what_s_the_difference_between_rails_and_merb), but I did literally say, I've only made a cursory glance. RAILS\_ENV is _idiomatic_, tho. Here's a top line in config/environment.rb from freshly generated rails 2.1 app -- \# Uncomment below to force Rails into production mode when \# you don't control web/app server and can't set it the proper way \# ENV['RAILS_ENV'] ||= 'production' 
Because the relative difference is what's interesting, not the precise number. This is like nitpicking bogomips. The point is they scale similarly and there isn't a 10:1 difference. Of course it doesn't matter.
unintentional my ass, dude. my only goal is to go on record. chad's so subtle and so messed up that when he first starts, you think you're imagining things. that's why I laid it out like a list of exhibits in a case. 
dude, if you want to be remembered for doing something more interesting, start by talking about something more interesting. how long were we roommates? 3 months? 6? during that time you wrote some kind of crazy Haskell web thing. that's more interesting than being my roommate. that's something to talk about. also - in an earlier comment you said that I was very passive-aggressive. you think calling for somebody's death is passive-aggressive? I mean I get the aggressive part - it's the passive part that's a mystery to me. you also said that you thought I was being serious. you're smarter than that. if you think I seriously want to kill Chad, that means you also think I seriously believe Chad is a physical werewolf. not a metaphorical one, a real one. I assure you, I am aware that werewolves are mythological creatures.
I'm not trying to sound patronizing or antogonistic here, but as someone who's never used LISP, what would I do with this? Why would this be useful to me?
 return "failed #{o}" That's what.
This is the blog post I've meant to write for a while. It will walk you through the installation process and help you style your first webpage using compass and sass.
Right man, I mean that you were seriously pissed off, and seriously thought he was dogging you. Hope you're well, man. Keep hitting those conferences and doing crazy shit.
This is a quick tutorial on how to write test for your plugin when you need a database and some models.
I disagree. Ruby is more kick-ass or sweet than awesome.
Anyone doing distributed Ruby projects on reddit? What all are people using dRB, Rhinda, starling, SQS?
Clojure is :)
Three cheers for journalistic sensationalism?
Enthusiasm.
Ruby has made my job a lot more fun. And I like getting paid to write Ruby code a lot more than Java or C++.
As long as _why is around ruby will be fun. 
I would love to hear suggestions for improvements or new features.
Won't this take up a whole mongrel the whole time that they are connected?
It's still fun. It's just not fringe.
Here, let me _whyify that for you. And they went down to the well, And hauled up a bucket of rainbows. Isn't this fine? Sampling our bits in buckets? I do think I'll make a habit of this. Thank you, Ruby. You are a long green coat with pockets made of the sky.
You win the internets today. Well done.
The whole thing still seems like a polling mechanism; what exactly does comet do for you?
That is what comet is, isn't it? http://is.gd/8hMs 
I guess that's why I don't "get it" - the presentation text made it sound like comet was the solution that obviated the need for polling. In the article he said, "The periodical update ajax method is like on a car trip when the kids are saying every minute 'are we there yet?'. When the dad cracks it and says 'stop asking! i'll tell you when we get there', he's basically telling them to become Comet programmers." And I just don't see how comet is getting rid of the polling portion of the process; with his example code the kids are still asking "are we there yet"
I see now.. with the long polling the server holds the request for an extended period of time until it can send back an answer; so the connection remains open that entire time.. then when a response is sent a new long poll is created. So it's still polling its just a crazy way of limiting the frequency of the poll.
Yeah, silly analogy but rolling with it I guess the kid asks "are we there yet?" and the Dad waits until they are before he says "yes we are here" This of course is horrible because it holds up your server the whole time.
Seriously, the documentation up at http://rspec.info is completely useless. I’ve, of course, Googled around, but I haven’t been able to find anything that covers most (or preferably all) of the DSL.
Yeah, it will lock the server the minute it's routed through the dispatcher.
http://rspec.info/documentation/ That _should_ get you started. There's not much to the API. Whatever you can't find in there is readily available in the RDocs.
Not in-depth, but everything you need: [cheat rspec](http://cheat.errtheblog.com/s/rspec/).
Try http://apidock.com/
I'm loving it, thanks, man. One thing I'd like to see is a more regular way to run it on a whole project, like. Maybe a basic rake task in the docs, or the like. I'd really like to integrate it into continuous integration so I don't have to remember to run it.
What are you looking for that you don't find in the rdoc? Are you looking for usage guides, or api details for extensions/etc?
I thought Rails is now thread-safe or is this a mongrel limitation?
Awesome!
It's a neat trick, but it's using the substandard syntax. I wrote a much better version for the [github-gem project](http://github.com/defunkt/github-gem/tree/master/lib%2Fgithub%2Fextensions.rb). class Object def try self end end class NilClass klass = Class.new klass.class_eval do instance_methods.each { |meth| undef_method meth.to_sym unless meth =~ /^__(id|send)__$/ } def method_missing(*args) self end end NilProxy = klass.new def try NilProxy end end This lets you write something like `foo.try.destroy` instead of `foo.try(:destroy)`. It's especially useful when you want to pass arguments or blocks along.
Your version is much better, I read that and thought it was awesome but that it would be much better if done like you did. Sure enough though, Rails Core won't include that, just like they wouldn't include my much better routing method. Instead of: :member =&gt; {:change_something =&gt; :put, :do_something =&gt; :put} it was: :member =&gt; {:put =&gt; [:change_something, :do_something]}
Why was that rejected? The former syntax has always bothered me.
What are the chances your code will be used in rails? Also do you think code will cause problems rails. Finally. What the difference between try and andand or ick? 
[ick](http://github.com/raganwald/ick/tree/master) contains a version of the proxy version of `#try`, however it differs from the example above in that it is part of a toolbox for building proxy-based methods. You'll also find more stuff like `#maybe` and `#please` in ick as well as easy ways to build more just like it. [andand](https://github.com/raganwald/andand/tree) does not contain a version of `#try`, it is much more specific in that it handles `nil` receivers but not receivers that cannot handle a method. This is sometimes better: if you want to send the `:name` message to an object you think is either `nil` or a model that with a `:name` attribute, having a non-nil model that doesn't handle `:name` might indicate a problem with your database columns. Or maybe that's not what you want. I don't discriminate, I provide both gems :-) There is a smaller, more beautiful proxy generator in my post [Quirky Birds and Meta-Syntactic Programming](http://github.com/raganwald/homoiconic/tree/master/2008-11-04%2Fquirky_birds_and_meta_syntactic_programming.markdown), along with a fanciful comparison of the technique to combinatory logic. p.s. If you wish to experiment, [rewrite](http://github.com/raganwald/rewrite/tree) contains a version of `#try` that uses code rewriting rather than adding a proxy method to `Object`.
I have to wonder. Maybe there's a pretty obvious answer that I don't know, but why legitimize a Try? Isn't Try a code smell? When is it okay to not care if until this point variable is a nil or what you want? Sure for a quick fix inserting a object.try.method is great, but it smells, isn't? (I do like the try method much more than the described by the link.)
After a short IRC chat with DHH, he basically said that's how he wants it and it's his framework.
Why not either test for NilClass first, or even better, use begin..rescue and trap for exceptions. begin..rescue blocks are effectively try..catch blocks except a bit uglier. 
I am using ick now but only for the maybe functionality. To me your usage of try seem to do exactly the same thing. I would like to use something else though because ick has such huge dependencies and does much more than I need. I was thinking I could use your code, rename the method "maybe" and thus avoid any possible conflict with a future version of rails. Is that a good idea or a stupid one? 
&gt;The Ruby 1.9 interpreter is a little better, but is incompatible and not designed for real people to use That's wrong. 1.9 is much better, not a little better. It basically brings ruby on par with the current python interpreter. Also it's going to be the official ruby interpreter I really don't get the whole "not for real people" thing. What the hell does that mean? Every major and most minor ruby libraries and frameworks are already 1.9 compatible. Oh and he forgot to mention maglev.
Is the garbage collector in 1.9 still the same?
I really don't know. I kind of doubt it given how much the interpreter has been re-written. 
The garbage collector has been updated a little bit. They now use fixed-size heaps instead of heaps that grow by a factor of 1.8. It was shown that this approach is a little bit faster than wastes a little bit less memory. That said, the algorithm is still plain old mark-and-sweep.
It really is ruby is shit so I'll jump on the bandwagon month. Or I'm having a bad day so ruby must be shit. Or rails is better than merb. Or, oops, sorry merb is better than rails. Or ... Stop fucking whinging.
Or: "I cant be bothered to update my code so I'm not going to change it."
I consider Try to be more like deodorant covering up an existing code smell.
The version of `#try` given above is isomorphic to `#andand` or ick's `#maybe`, not to ick's `#try`. ick's `#try` and `#please` both work with objecs that are not nil but may not handle a particular message. This is a different set of semantics entirely. My suggestion is to use the [andand gem](https://github.com/raganwald/andand/tree), which will not conflict with `#try` in edge rails because the proxy-based method is called `#andand`. If you don't care for freezing a gem in your project or depending on a gem in your system, you can take this copy of [andand.rb](http://github.com/raganwald/homoiconic/tree/master/2008-11-12%2Fandand.rb) and drop it in your `config/initializers` directory. `#andand` will then be available to your rails project without messing about with gems. If you do the latter, renaming the method `#maybe` is a trivial exercise.
What's wrong with ruby.reddit?
I think the recent spate of "Ruby's not Fun Anymore" posts has more to do with a bunch of people being at a certain point in their careers than Ruby being in this state or that and with a bunch of projects now all grown up with grown-up-project-type problems. I'm still having a ball with Ruby.
It's a way of faking server-push when the underlying tech doesn't exist. It does seem gimpy the way it's implemented, but it's another tool in the arsenal that makes sense to use in some situations.
If I were implementing this, I'd have something like Sinatra sitting on top of JRuby (real threads!) to avoid locking up on any given request. And even then, I'd have to do some pretty hard core testing to make sure there aren't any lock situations. Ruby just isn't setup right now to handle lots of concurrent requests. (prove me wrong please! but be specific).
His point about the last few Christmases, however, rings true.
They seem to be programming for fun, hype and buzz. Rather than programming for a living. Programming should be fun, of course, but it's still a secondary trait. If you're constantly looking for the new fun thing that everybody is buzzing about, you're on an infinite journey, and constantly switching languages is part of that. Not because the languages become not-funny, but because the language itself is not what interested you in the first place.
Just wanted to say that the comma should come before Globals
2.3 is shaping up to be pretty nice. I've wanted default scopes since the introduction of named scopes, as just about every project I work on needs them for some reason or other. The render updates are also very very welcome, since 90% of render calls are for partials rather than file paths.
Or rubyflow.com...
If you're going to break up with Ruby, be honest and admit "it's not you, it's me."
&gt; The Sheeple’s Republic of Reddit Heresy!
Dave Thomas' talk at RubyConf encouraged forking for experimentation so it didn't have to take place on the main trunk and hold up 1.9. Hopefully we can get 1.9 and whiners will quiet down for a while. Ruby is growing a professional community. For some, this is not welcome. As Paul Graham says, technology trains leave the station at regular intervals. The next one will be along shortly. Wait for the next one if you want or help make it. I am hitching my car to the Ruby train for now.
my god! i didn't think i could love this man any more than i already did...
I hope, as a ruby developer not in the "community" and not interested in the "community," that I'm a member of a silent majority that wishes the "community" would stop talking about the "community" and just get back to work. Hopefully enough people can recognize that the vocal members of this "community" don't speak for many of us who use the language.
Thank you very much for the advice. 
This "Ruby is not fun" is more fun than "Rails can't scale" (because that's soooo old). This is as fun as "Monkeypatching is destroying Ruby" (because that was soooo ridiculous). But this is not nearly as much fun as "Hey check out this awesome library I made just for you" (because that's where things happen).
Agreed. I had no idea the Ruby "community" was suffering so much, because I was going ahead and making stuff with it. Outside of the blogosphere does anybody care about this?
I believe that is in part sort of the intent of the post... might be wrong, but at least that was my intent. Well that and that languages should not define the developers, results should. I like the comment "Developers are probably one of the few occupations that define themselves by their tools rather than what they can do with them. You rarely see classified ads for construction workers who are really great with Craftsman hammers, or plumbers that have 5+ years experience with PVC piping."
When I look at my career, Ruby only occupies a small corner of my workbench. Most of the time I was writing my "raganwald" blog, I was writing Java by day and experimenting with Ruby nights and week-ends. I certainly don't view myself as a Ruby programmer any more than I view myself as a Java programmer.
See http://www.rubyinside.com/rails-22-released-27-links-and-resources-to-get-you-going-1354.html for more.
I'm very interested in moving my apps to Ruby 1.9 so will be trying this out carefully. Hopefully the postgresql driver works OK in 1.9
A good editor for Ruby, except for the three best editors for Ruby." That pretty much nails it. It must be some kind of CS class, better encourage students to use a decent editor from the start. Which is where vim, TextMate and Emacs kicks in. You don't wanna configure vim a bit? Jesus fuckin' christ. 
I am going to let 1.9 stew for a few months before I switch to it. 
This wouldn't work in linux right? It looks like it's using COM to build the spreadsheet.
ruby-pg needs a patch to compile on latest 1.9: http://rubyforge.org/tracker/index.php?func=detail&amp;aid=22856&amp;group_id=3214&amp;atid=12396 It doesn't set string encodings correctly either (everything's treated as ASCII-8BIT). The mysql 2.8pre4 driver works out of the box, though!
It's in feature freeze now so it's time to start playing and testing, at least. Many gems need to be updated between now and official release.
Sequel is nice and doesn't get enough press but this article really doesn't tell you much about why it's nice. 
But I thought gantt charts are teh_suck
No, it works in linux, or Mac OSX, there's no COM involved. I'm codeclimber, and I wrote that code on a Mac, and deployed it to a linux box, no problems.
Latent _Semantic_ Analysis? I dunno, maybe they're the same thing; I'm not familiar with the terminology.
I think you should overload all operators - so that + is - and * is / and ! is ^ just for fun... 
Here's a quick start at that: class Fixnum alias :__minus :- alias :- :+ alias :+ :__minus alias :__mult :* alias :* :/ alias :/ :__mult end puts (3+4)/2 #=&gt; -2 EDIT: However, I personally prefer this: class Fixnum alias :__real_add :+ def +(other) self.__real_add(other).__real_add((rand &lt; 0.000001) ? 1 : 0) end end
not bang, cut!
My favorite non-terminal &amp; non-osx exclusive editors are Netbeans (IDE) and Komodo Edit. Definitely worth a look.
Reg, your last few articles have been over my head, but I really liked this one. I'm glad to see you writing again!
Quite a simple example when it comes to the scope of metaprogramming, but it's a nice example for someone that's just heard about something as wild as metaprogramming.
I'm sorry, but if he doesn't want to learn vim or plop down the $30 for TextMate he's pretty much boned, $30 for what I consider the finest text editor out there is one steal of a deal, and it has all of the no-setup fanciness he wants. Complain and get nothing, or suck it up and get something useful, take your pick.
That's great. Since it had a dependency on OLE I thought it needed COM. 
the ruby-ole library doesn't have any direct attachment to COM. ruby-ole is a library for read/write access to OLE2 structured storage files, such as those produced by Microsoft Office, eg *.doc, *.msg etc, so it can handle those formats, but it's basically a port of the windows libraries that do the same thing.
&gt; And memory-wise, we pay little cost beyond the JVM's own 20-30MB memory tax Hmm, same code, same data, very simple website using Ramaze: 69222 freaky 1 58 0 73240K 38504K select 0 0:05 13.38% ruby18 62746 freaky 3 61 0 80676K 49872K select 2 0:04 12.26% ruby19 63754 freaky 15 97 0 282M 152M select 2 0:00 49.56% java With the Java heap limited to 64MB, it's using 3x the resident memory as Ruby 1.9. This is with trunk JRuby (1.1.5 release was pretty much identical) and JDK 1.6. Of course, JRuby can do rather a lot more with that 150MB, since seperate threads can actually serve concurrent requests on-CPU, rather than just multiplexing IO. Performance is pretty much the same as 1.9 (~130ms for this page); if the heap is allowed to grow a bit bigger, it gains up to about 20% on it (~105ms). 1.8 manages about 200ms. Edit: Futher playing to avoid unnecessary eval()ing in solr-ruby and avoid recompiling templates each request gives JRuby more of an advantage. Ruby 1.9's times have increased to 150ms using json/ext instead of eval(), while JRuby has reduced to 70ms. Some optimization flags to JRuby reduce this closer to 50ms. Memory use is also not necessarily directly comparable, since it's probably mmapping .jar files and the like. If there were some memory pressure I suspect it would drop a fair bit.
Spreadsheet _is_ a very promising gem. I wish I knew more so I could help it along. Writing Excel spreadsheets through Win32OLE is awful and slow.
Unfortunately, you should probably expect haml breakage on just about every Rails release. http://github.com/nex3/haml/tree/master/lib%2Fhaml%2Fhelpers%2Faction_view_mods.rb It's doing some screwing around with the internals at a fairly deep level. 
Thank you very much.
that's what i don't like about rails... backwards-compatibility issues... especially if you're using a lot of plugins which are not part of rails itself, so you either have to upgrade (or wait for an upgrade) or fix it yourself which you shouldn't have to do in the first place.
That's what you get for living on the edge...
Doesn't actually have to be this way. I'm hoping Merb solves the issue somewhat with a public constant api, that plugins can depend on so they dont break. 
Yes, less publicity for people who are throwing fits because reality didn't meet their own marketing, please.
woot!! brian made it to reddit! this is a fantastic article that speaks up for all us jruby-ists out there!
Man I love these alternative Ruby implementations.
This looks [awfully familiar...](http://www.reddit.com/domain/syntatic.wordpress.com)
Title got it backwards. You can get the code and play with this now. Gemstone has yet to release any part of Maglev to the public afaik.
+1 because Greg is a great guy and he's giving away the book via Creative Commons ultimately.
I only made it 2/3 of the way into this talk before I stopped it after realizing it wasn't worth watching. I don't know if I am just missing the point but I didn't really see anything particularly interesting other than the standard intro to functional programming. His Ruby examples were anything but functional, I didn't even see a single lambda throughout the whole talk! 
Except for the 'Scaling Rails' talk. No worries though, I don't think the presenter ever scaled a Rails app (did he actually suggest using RSS as a interprocess message queue??)
That's going to take a lot of getting used to.
The example at the end is really good. You can clearly see the different parts that go into making up the algorthm.
Are you saying he shouldn't have submitted it to [ruby] because it was already submitted to [programming]? Also it's submitted by two different users. IMO the fault is reddits, they should handle dupes better.
Wow, why didn't I thought that? I love ruby's "if my language doesn't have this, well we can change it" attitude.
This has proved to be an invaluable resource in my quest to learn ruby. 
let the evals begin!
Yeah, this is way better than Maglev--it's available now and it's Free for anyone to use and hack.
When defining anonymous functions I've always considered lambda a better choice, sure the syntax *may* get in the way a little when you define a lot, but converting strings to procs A) takes a lot of time and B) is easily abused, so it should only be used as a last resort when nothing else works.
&gt; is easily abused. I find this to be the case with every feature of Ruby. Taken to an absurd degree, this means ditching Ruby in favour of a bondage and discipline language like Java (you are chained in the dungeon of BigCo) or Python (you are tied to a four poster bed being tickled with a goose feather).
Heh, too true
Isn't that common sense?
Give the Ruby guys a break. This whole "performance" thing is pretty new to them. (I kid, I kid.)
I [RSL] am not the author of RMagick. I wrote a method for it but Tim Hunter is the amazing and helpful author and maintainer of the library.
Interesting use of closures in combination with define_method and modules. Reminds me of the Crockford module pattern used in Javascript. I encounter this situation quite often. You want to have reusable modules to be included in some other class, but keeping things private is a problem. For example FileUtils has some `fu_helper` methods to mark them as 'private'.
[I like Crockford's module pattern!](http://weblog.raganwald.com/2007/08/block-structured-javascript.html) Both techniques share a common ancestor in Lisp's `let` macro.
We are doing a bunch of distributed Ruby coding which is pretty interesting stuff. 
We are both on reddit, so if anyone has any questions for us feel free to ask.
I like merb. An article about merb! Awesome! What could possibly go wrong? "Also, the Merb architecture is **ORM** (object-relational mapping) agnostic, giving coders a wide range of choices among **JavaScript** libraries and **template** languages, he said." ... I'll bet you he didn't.
I'll put in a resume. I've been working on rubinius lately, pretty fun. Are you doing DRb or something more exotic?
Not on DRb we used it for awhile via Rinda. Now we are using Beanstalkd and queuing our jobs to small workers across a bunch of machines
Yup, Merb is Jesus, Santa, and Paris Hilton rolled up into one. I'm currently designing my clock factory automation software in merb. You know, cause the enterprise is all about web apps. 
Does it do SOAP? If not then the answer is no. The enterprise loved that soap and ruby by and large sucks at it. 
Schedule: * 25 Dec, 2008: Ruby 1.9.1 release candidate * 25 Jan, 2009: Ruby 1.9.1 ... seriously?
I'm sure most Ruby users sit on the sidelines thinking this whole argument, and similar ones, are silly (right?). Rails is sweet. Merb is sweet. Ramaze is sweet. It's all sweet code built by talented people, and it's pretty awesome we have so much to choose from. I just shake my head when the children in the community start their little pissing match. I'm sure this won't be the last 'saga', sadly.
hmmm all of server beach just went down along with this post... So hopefully they will be back up soon. If you can't get to the post now try again later.
Yes, but note that the tool being discussed (Flog) is written by the blog's author. The use of this tool and the power that it gives developers is really the point of the article.
seems to be back up...
don't forget about http://rad.rubyforge.org/
Fair enough. I didn't really catch that before. A link from his blog post would have been useful. I just thought "flog" was some Ruby term.
furthermore, i don't think the end-user gives a rats arse about what platform the developer used or how long/short the code is as long as it works.
That's one of the most retarded PR/article I've read lately. Thanks for the laugh!
Merb may show a lot of promise as being a high performing and flexible framework. But enterprises aren't going to turn to Merb for some time, because of its immaturity and small deployment base. Big companies don't like to make risky bets like that. What will have much more of an impact on Enterprise adoption of Ruby is JRuby. Ruby on {Rails | Merb} is an excellent rapid application development platform for web interfaces. However, many enterprises have well established transaction and analytical processing systems, and many of these are written in Java, which is better suited for those types of applications. With JRuby, it is now possible for Ruby on {Merb | Rails} front ends to directly interact with J2EE back ends. Add to the fact that JRuby is truly multi-threaded today (while many Ruby libraries are still blocking on 1.9), so there are definite performance advantages, too.
Spoken like someone who knows exactly what he's talking about!
Why do people put this garbage on Reddit? Entry price (he's bitching about buying a book)? Zed's rant? Give me a break. How do you complain about buying a book as a reason to *STOP* writing rails code?
this article is asinine. when will crap like this cease?
This has nothing to do with Rails... 
Rails != RubyGems. Simple as that. You don't want to use RubyGems? Don't. Nobody's forcing you.
more stupid FUD BS
I agree. Debian has no business trying to package up every single gem as a dpkg. They just don't have the manpower so they shouldn't even try. 
Forget about it, it doesn't matter what RubyGems does, as long as it exists Debian people will always complain. They just hate foreign package managers.
You're taking the wrong approach to open source contribution. Projects aren't just code, they're also communities. It takes a bit of time to develop the sort of reputation concerning your abilities, as well as a relationship with the people who are more important to the areas of the project you want to work on. My advice to you would be to stick to one project. There's never any guarantee that your patch will be accepted, but the chances are greater as people start to recognize your name and associate it with good work. You could also look for small projects that are just starting up. These projects have a small number of contributors and it'd be a lot easier to make an impression. Also, as an early contributor, you will have had the opportunity to shape the project from a conceptual stage. Failing that, start your own project. Hire (or beg) a good designer to do a really nice homepage for it. Nine times out of ten a shiny box is a lot more important than the code when it comes to gaining users. If your code is solid, people will adopt. If your code is so-so, target managers, who will in turn force their developers to use your product. The developers will become contributors to stop the pain, and there's really no way for a potential employer to know the difference.
Yea I realized the title is a little misleading, it probably should have been more like 'patching open source' since all my stories were about rather small fixes than any major contribution to these projects. I didn't really do any of them because I just wanted to contribute to open source but because I ran into a problem with a tool I was using. But to me that makes it worse, ideally it should be easier to get these small needed patches into a project than to contribute a large piece of new functionality (something which should require you prove yourself to the community first).
Most large projects get a *lot* of patches. And 80% of them are shit. Do you enjoy reading shit code? Most people do not.
Right, I understand that's the reality a lot of the time, and my point was basically that reality sucks :) I mean thinking that there are lots of good potential contributions that never find their way into OS projects is pretty sad. I do believe that github definitely gets somewhere in terms of solving this problem, but not completely.
&gt; It crashed on BMPs (which was one of my client’s requirements) Your client wanted it to crash on BMPs? That's a rather bizarre requirement.
lol thanks, i changed the wording
The slides: http://github.com/raganwald/presentation_decks/tree/master/rubyfringe http://flickr.com/photos/raganwald/sets/72157606272767656/ And the gem: http://rewrite.rubyforge.org `sudo gem install rewrite` 
I don't see what's hard about it. The poster was able to write code and throw it on github. As far as it being frustrating, well, I can understand that...but I'd say that it's an outdated model of how stuff is supposed to work. You don't need the "maintainer" to merge it into his "canonical" repo anymore. You just put the code up somewhere, tell people about it, and move on.
The book repository is on GitHub: http://github.com/mattetti/merb-book/tree/master
Come on, vote this up!
great stuff matt, thanks for your time with this!
It's great y'all are doing this. It would be helpful to include the essential info at the top of the post - where to get the book, how to start reading it, and how to contribute.
I just switched a site over to this today. If you deploy rails apps, this is the way to go, no question. Piece of cake.
Good stuff, just what merb needs!
Absolutely. It's wonderful.
I switched earlier this week. It's worked out well so far.
&gt; My advice to you would be to stick to one project. In this case, it's not about finding a project to contribute to, it's about using tools that are broken and trying to fix them so you can get work done. It's great that those fixes can usually help others too though.
I love shoes. I feel rebellious for learning it, because everyone knows that client software is foolish. The way to get ahead is to write software that lives on a server and spits html. Meh. I don't want to get ahead.
Aye. For whatever reason, I'm really, really sick of writing web apps. Desktop apps used to be king. And now it feels somehow decadent to write them, like they're some relic from the past. Nevermind that... It's our heritage. Shoes is teh cross-platform good times, a GUI toolkit without the hellish API.
Decadent! That's the perfect word. I don't hate the web; I realize the power and reach it gives us; above all, it pays me. But sometimes I want to hack something together fast, and simple. FAST, NOT "WEB FAST". Not even Merb fast. ;) Like for instance. I was in South America, doing a CrossFit workout called Fight Gone Bad. You work out at 5 different stations for one minute each in absolutely rapid succession, for reps, and then have a minute of rest; repeat 5 times. Cool, but we all had to work out at the same time or working out would take 6 * 5 * 2 minutes instead of 6 * 5, because someone would need to be watching the clock and yelling "switch!", and then we'd have to time for *them*. So, ruby. Client-side (net access, even wireless, is an hour from this location). So, class FGB &lt; Workout name "Fight Gone Bad" rounds 5 restfor 60 def round 5.times { work 60 } end end And hook up the laptop to speakers and it uses the win32 speech and sound apis to alert us 10 seconds before a switch, do a countdown, then tell us to switch, and then to alert us for the rest and beep with a different tone. Literally, less than 10 minutes to hack up. Casual programming for the win.
That's really complicated. There's really no excuse for a build process that's more than a couple commands.
Shoes 2 is awesome. However, there are still some issues with the Net::HTTP library included with the VM. For whatever reason it won't allow me to connect to a server that includes a port number. Strange.
&gt;And hook up the laptop to speakers and it uses the win32 speech and sound apis to alert us 10 seconds before a switch, do a countdown, then tell us to switch, and then to alert us for the rest and beep with a different tone. Nice! Instant Robo-Sensai!
Getting better and better with each new release. Several books have already been announced for publication in 2009. 
Indeed, I'm quite excited for them, too many rails books :/
Jeez, at this pace of development the presentation I'm preparing for my local ruby user group is going to be heavily outdated by the time I present in Jan!
Remember that this is a new repo for the IronRuby team. This is based on their internal layout. Originally (and still currently) they also push to the SVN repo on ruby-forge. However some translations take place that allows you to literally just do "rake compile". The build process will improve as the github repo matures.
That's weird; I checked it out from SVN a few weeks ago, and I still couldn't get it to compile, though I gave up after about five minutes. Maybe it was a problem with how they use Mono.
I want to learn Merb, and I will do it soon... but for now, it doesn't tell much when someone says: "Calm down. Dependencies are good. There's no way all of us can be wrong." Of course I don't know enough about Merb to know if dependencies are fine or not. However, please don't use the "We cannot all be wrong" card.
Very interesting. Last I'd checked, JRuby was well behind even the 1.8.7 MRI; very cool to see it come as far as it has.
@eipipuz I think he's referring to the Linux world and how package management systems work. 
Indeed, I was referring to package management in general. I've noticed that people hit a few painful spots with the way ruby package management works and end up dismissing dependencies all together. I was trying to make the argument that the problem is not using dependencies but bugs and lack of features in ruby gems. 
&gt; I hate RubyGems for the same reasons that you all do I don't hate gems. What reasons are these?
Oh I see, thanks. You should put that as an appendix or something. People like me who doesn't know yet about the current dependency problem need this extra information you put here. Hoping Yehuda finds some solution to it by Monday :)
Same here. Maybe he means making gems not using them.
/me waits patiently for ruby/mri 2.0
I think the general feeling is that by the time Ruby 2.0 is available, 1.8 will have been widely replaced by 1.9. That's mostly because Matz dropped the idea that 1.9 would be an experimental/unstable step on the road to 2.0. Ruby 1.9.1 when it's released (January 25 if all goes well) will be a stable release, which many will move towards. Maybe then actual development on 2.0 will start, but we've been talking about it for years.
Hi Carl. You should come by the office again sometime and eat lunch with us. Or something.
Mono does have a few issues, I think you need to use the Head revision at the moment. Michael is right, the build process will become easier. 
Wow, that's commitment.
why's [shoes](http://shoooes.net/) rocked my ruby 2008
OK - looked everywhere but can't find anything on this topic so reddit readers, you're my last hope. There are several examples out there where you can create a nested header for a SOAP message (see for example http://dev.ctor.org/soap4r/browser/trunk/sample/soapheader/authheader/client2.rb) but I don't want that. That example produces &lt;header&gt; &lt;auth&gt; &lt;NaHi&gt;password&lt;/NaHi&gt; &lt;/auth&gt; &lt;header&gt; I want a way to produce &lt;header&gt; &lt;foo&gt;value&lt;/foo&gt; &lt;/header&gt; I.e, I want to insert elements with values into the SOAP header without nesting.... There's gotta be a simple way to do this but I can't find a single example. I assumed there would be some method on driver.headerhandler or a way to assign a value to a hashmap directly but I haven't been able to make it work. Would appreciate suggestion or ref on how to do this. Thanks
SOAP support in ruby is teh sukk. ActionWebService is dead. Soap4R is almost dead. Neither one supports soap 1.2. Neither one supports optional parameters. Both of them are a pain to use and conflict with each other. If you want soap go with jruby and use a java soap thingie.
I've done the same thing but I do miss the Rails style helpers for javascript.
Personally, I'm happy with prototype and the Rails helpers.
http://www.stackoverflow.com is a good place for questions like this.
I agree --- unfortunately nobody answered me there...but it turns out that it's quite trivial (and I'm going to post the answer to my own question at stackoverflow) in a little while. Turns out that the trivial (sigh) solution is that when you're creating a new header, the on_simple_outbound callback needs to be changed So instead of def on_simple_outbound if @sessionid { "sessionid" =&gt; @sessionid } end end I needed def on_simple_outbound if @sessionid @sessionid end end 
Vim.
Or MacVim if you are on a Mac.
So hot, want to clone the git repo.
I tried this and found it to be super slow on my iMac G5. I think it took 10 minutes to start a new rails project. FAIL!
Or vim-cocoa if you like speed.
Check out jRails (http://ennerchi.com/projects/jrails) - it provides you the same helpers.
Oh boy, tensions are high.
[Pratik](http://antoniocangiano.com/2008/12/13/learn-merb/#comment-4899) can be such a [jerk](http://antoniocangiano.com/2008/12/13/learn-merb/#comment-4904).
I love Ruby for people like Matz and the style of the old guard of Rubyists, who were friendly and cooperative, helping each other out, and living the philosophy of Ruby as a language and of its founder. I hate Ruby for the constant douchebaggery and shrivel-dick swinging of these immature college jock wannabes in the Rails and increasingly Merb communities. They're Ruby's cancer. I guess it's a battle over which camp gets to charge the more exaggerated consulting fees.
Good to see the new "shoes". I've been messing around for a while (got the book and everything\). Go Why!
&gt; I hate Ruby for the constant douchebaggery and shrivel-dick swinging of these immature college jock wannabes in the Rails and increasingly Merb communities. I don't know why would you hate Ruby for that. You can obviously completely ignore Rails/Merb and their communities and pissing contests, and still use and like Ruby. It is a programming language, not a social club, you know.
I agree. I used the "I love/hate Ruby" more for stylistic parallelism. I use and love Ruby, and ignore as much of the Rails/Merb noise as possible. Sometimes it's so intense that it's hard to drown out though. Another concern is that it can turn off newcomers (or attract an undesirable type of newcomer, "birds of a feather..." style).
isn't there a Merb subreddit? All the Merb spam here is going to force me to unsubscribe from /ruby/
Ruby has a better object system than PHP. However, PHP is still easier to deploy. Ruby is better than Java for things like string processing, and easier (in my opinion) to re-factor. Automated re-factoring tools can help here, but Java lends itself well to big design up front. However, Java wins on performance, and is more rock solid. .Net is not remotely platform independent, and c# has many of the same design lock-in issues that Java has. VB isn't bad if all you want to do is whip up a quick windows GUI app, but for serious development its made of fail. However, it's easier to make a Windows GUI app with visual studio than most other languages, I find. Ruby is, like perl before it, all about Unix integration and string processing. It's quickly becoming a great language for OSX integration as well. It has a number of excellent web frameworks, and the VMs have come a long way. But my personal reason for choosing Ruby over PHP, Java, and .net is not one I can quantify. I just like it more. Ruby's syntax and style fit my personal approach to programming far more than any other language. I spend most of my time in Java going "Ugh, I forgot you had to do that," usually forgetting some stupid XML file. I spend most of my time in Ruby going "Ohhh, I didn't know you could do that," usually before I reduce my lines of code substantially due to some neat use of blocks.
It's more a question of the right tool for the job. Just like everything else in life, your choice has benefits and consequences. In the case of Ruby, it provides very rapid development, but sometimes at a performance cost. The language itself is quite elegant. There was a great deal of effort put into making it almost zero effort to remember how to perform a task. In most cases, how ever you *think* it should be done, is exactly how it is done. This is a very great departure from Java or .Net where you often have to memorize massive standard libraries, there are often exceptions to the standard of naming conventions (depending on the library author), etc. The garbage collection isn't as strong in a lot of cases as Java, but that's being addressed. What I personally really enjoy about it is that all of its parts are open and available for modification. Not only that, but it has the ability to directly interface with compiled C/C++. So, if you don't like the performance of method X, but it appears to be as well written as possible (in Ruby), you can potentially write a custom C extension and possibly solve that problem for yourself. It's very much a scratch your own itch language. You can personalize it quickly, everything is available to you, it is super simple to use for meta programming... and above all else, it's just genuinely very enjoyable.
Also, since the introduction of [Phusion Passenger](http://www.modrails.com/), deploying Rails and Merb applications is a breeze.
And using JRuby one can get most of the benefits of the Java VM.
Ruby hits a very sweet spot, being both strongly and dynamically typed, object oriented for real, and concise. It's well organized and you don't spend hardly any time at all fighting the language itself in order to get things done.
Because Ruby doesn't make me want to remove my eyes with a melon-baller?
Between you and me, I ain't got nothing against exaggerated consulting fees either :P.
"Merb spam" should go in rails ;)
Because it's fun to work in. 
hrmm, anyone notice the huge freeking Engine Yard (you know, the guys who wrote Merb) ad banner on the blog? Anyone even consider that there may be a little bias involved? Anyway, the premise that Rails devs should "cross-train" with Merb is kinda ridiculous. If you want to expand yer horizons perhaps you should try something thats actually *different* like HAppS.
Ruby is fun, powerful and has an awesome community. 
Question needs more context: Are you asking as a programmer? As a guy doing hobby projects, or looking for a job, or a bit of both? Are you asking as a manager or CIO? Business-level concerns dominate here. In any case, you need to think about your local area, and the kind of applications you want to build. I could build a case for any of the four platforms listed, depending on your circumstances. 
I work for the venezuelan government, I develop on ruby on rails for a couple of years, however my new boss asked me to explain why i choose ruby over php, java or c#, my main reason is because i like it the most (syntax), but i guess some of you have other reasons as well.
Hey, liking a language is a good reason, even if you can't quantify it. We're not machines. You probably have to stare at this stuff close to forty hours a week. An unhappy developer brings a host of problems -- lower morale (which is infectious), probably lower productivity, and a _much_ higher likelihood you'll jump ship. Why not get your boss to explain to you why you shouldn't be using Ruby?
I'll just add to this my recent discovery of Monkeybars and Rawr. JRuby is probably going to be my default Ruby implementation within a few months because of them.
Because I've tried all of the others, and I find Ruby to be the least onerous of the bunch. Each has it's good and bad points (except PHP in my opinion... I have a deep hatred of the entire platform), but Ruby is a good place to be right now. The performance issues in Ruby are starting to (very slowly) dry up. I was benchmarking 1.9 the other day and I was seeing a 4x - 8x speed-up in project euler apps I've written, which tend to be a little more intensive than the everyday web-apps and scripts which Ruby is mainly used for. I would still use Java if I needed a close-to-real-time system for managing a lot of data, but that's more and more rare.
Take a look at Python as well. It is similar but it is wired as well into Java (Jython) and .NET (IronPython and Boo on mono). Python inspired Ruby but Python is bigger only because Google is very big on it and Django is giving Rails and Merb a run. Python is nice for me because it is also pretty game industry favored. Python currently is 3x faster in code execution and with psyco compilation it can be almost 2 times slower than gcc which is really fast considering it is a dynamic language.
If you feel that you are more productive with Ruby than other choices, you should let your manager know. It is something that he should appreciate.
PHP really went off track about PHP5. They were well-positioned to become a great web-language if they concentrated on security issues and language consistency. They didn't do that. The language is still full of inconsistencies, and generates a fairly huge number of security alerts on a regular basis. Java is an excellent language. However, if you don't need the performance, it adds a fair bit of complexity and overhead that aren't useful to the average web-app author. C# is basically just Microsoft Java... and to be fair, it does a few things better than Java does, because it really is just a reimplementation of Java, with a few tweaks. That said, you aren't going to find the sort of community around the C# web libraries that you find around RoR, PHP or even Java + Struts and such.
&gt; Ruby has a better object system than PHP. However, PHP is still easier to deploy. It's a lot more than just the object system. For example, Ruby allows you to write list processing in function oriented style. It's overall just one on the most elegant languages I've ever worked with.
&gt; PHP really went off track about PHP5. The problem with PHP is that it has evolved organically, without much guidance. This has allowed it to grow into the very incoherent language it is today. However, stopping with PHP4 was not the answer. In fact, most of the recent developments in PHP are fairly sane; It's the pile of legacy stuff that causes trouble.
I can't argue that. While I have no great love for Java the language, JRuby wins as a platform.
I haven't had to do much list processing, but just the other day I ended up having to do some work with sorting out a bunch of similar object types in a controller. The elegance with which ruby blocks let me accomplish this task was a pretty stark contrast to the kinds of problems I'd have were I working with PHP. I still think the object system though remains the definitive win for Ruby. If I could summarize why I like working with Ruby in one line, it would be: 3.days.ago 
No no, I didn't mean that they should've stopped with PHP4. I meant that they failed to address the language's crucial weaknesses (inconsistency and security/reliability) in any meaningful way with PHP5. The new object model is less awful than the old object model, and some of the database abstraction stuff is nice, but as far as I can tell, nobody on the PHP team gives a shit that their language is an operational nightmare, and has been one for years now.
By list processing I really just mean that whenever you have to do something with an array, you can use function oriented style, rather than imperative one. Eg. Instead of: $tmp = array(); foreach ($foo as $x) { if ($x-&gt;bar()) { $tmp[] = $x; } } echo join(",", $tmp); You can do stuff like: puts foo.select { |x| x.bar }.join(",") In the end it's mostly a matter of aesthetics, but it makes a huge difference when you actually have to work with the language. In the first example, I feel like I'm lacking words to describe what I mean, so I need to use an approximation. It's much like speaking in a language that you're not completely proficient in; You know what you want to say, but you can't express it in the language you're using.
In doing lots of research for potential Rails developers I seem to be hitting either: 5%: Individual developers with great online reputations, lots of blog entires, contributors to several gems/plugins as well as books; but are "not available for hire" either because they are too busy, or are somehow able to hold down a full-time job at a firm in addition to all their valuable community work. 95%: Individual developers or small development shops with nicely laid out web sites but "portfolios" that are extremely thin and/or seem to be on the very low end of the complexity scale. Have others had the same experience? Any outliers?
I think maybe the problem is that you're looking at people to hire, not at all Rails developers. I know plenty of good ones who aren't writing books and blogs, only have sporadic contributions to projects, and are relatively unknown. Of course, they're all well-employed, and aren't looking for new work.
http://www.joelonsoftware.com/items/2005/01/27.html
While I haven't been looking for Rails developers, I'd imagine it would be just like anything else. I do lots of PHP work...you want to talk about the 95/5% rule then? I'd imagine that most people don't have portfolios of complex material because Rails makes easy things really easy. It takes almost no work to get the basics up and running in no time at all. Rails lends itself towards quick and dirty projects. Another problem that I've found with getting a portfolio together: I'm not that great at graphic design. If one is given to me, I can put it together, but designs that I come up with are uninspired. Do I really want to pay someone to put something together just for a portfolio? Maybe, but it's something that's hard to justify at the beginning. Good designs don't come cheap.
Well, I'm biased, since I am one. My experience overall has been good. Many people are good, but not inspired. They will get the job done, but they aren't going to make you a billion dollars on their own. There are bad developers, but they pretty much self select out. And there are 'great' devlopers. If you want a really good developer, the safest way to get one is to hire someone that's already doing a great job. Pay them more money, or intangibles. (I, for one, would willingly accept a job on the beach in Barbados at my current salary, no questions asked) In my experience, people who complain that they can't find good talent are either not willing to pay what 'great' costs, or aren't looking in the right places. Though reddit isn't a terrible place to start.
The rails developers that I know personally have essentially no online reputation, because nobody will pay them $150/hr to blog. And they don't do low-end work either... I know of people who independently implemented many of the 'omg, wow' development in rails..
Wow that took quite a while to get online
You know, I was just writing some code today for fun, to simulate dice rolling to check out some RP mechanics. (I decided simulating a few million die rolls would be easier for a quick examination than working out the probabilities.) And yeah, array selection code for the win.
Did anybody else read "Ruby's Top Hitler in 2008"?
That was boring. Boring, unimpressive and tired.
did anybody else read "McANALly"?
I agree with most of the other comments. People who want great but have a hard time finding great aren't paying enough or are in NYC or the Valley. Intangibles are great too. I'm a family man so I'm not looking to move my family to Barbados. But if I can dip out to watch my kid's Christmas play or cut out on my wife's birthday I'm a happy camper. A big one for me is meaningful work. If the work is lame like so many projects are you wont be able to buy the kind of talent you want because the kind of talent you want is doing something better.
This series of interviews needs a new title. Judging by the content so far, it's aimed squarely at beginners who know very little about Ruby, and mostly states stuff that's widely known from those who follow Ruby at all. That doesn't make it bad, it's just not about "little known ways" to "ruby mastery". 
Exactly. I've only done one small simple Rails app, and I'm hardly an expert, but you'd still want to hire me (if I were for hire). I've done very complex Java apps, and Rails is *easy*.
I agree with what someone else said a lot of people just fail to look in the right places. For instance is there a local Ruby / Rails group that meets in your city? Find out if there is recruit from there. Actually show up to a meeting show that your interested in the technology and then talk to the people there. Chances are you will find someone. 
Like almost everything in life, the developers probably fall onto a bell curve, with 5% being spectacular, 5% being stinkers, and the majority being 'mediocre'. Naturally, when you're hiring, you want to hire the 5%, but I think that might be an unrealistic expectation. The 5% are also the most likely to have other irons in the fire. Probably the best way you get to them is by making them want to come to you, like how Google did early on by making it an awesome place to work. Whats more, I think what you will want most of the time is actually the 'mediocre' developer. This is the developer that will get the job done, meet all or most of the requirements, and so forth. This person is just fine at what he does, maybe even great, but he's not cream of the crop, but the thing is -- he'll likely be worth the investment you put into him. So, what I would do is this: focus less on attracting the vocal, visible 5%. Set up a decent compensation package and do your best to weed out the stinkers. After that, all that really matters is that you find someone who is able to learn quickly and can communicate effectively.
I'm always pleased when people discover the classic editors. Emacs and Vim have been around for years because they are *damn good editors*. They work. Pretending like they're the new thing always amuses me, but I'm happy to see others coming down into the keyboard-only fold. Thing is, I can't recall ever learning of a programmer who went back from Emacs or Vim to a graphical editor unless it was for a language-specific IDE, and even then half of them try to change the editor to be like their previous one. The customization of these old editors means that people have been working on improving efficiency with them for years. You can sit down and it feels a little weird at first, but then you start to get it, and you think, "Yeah, this starts to make sense, I can see why they did this." Then you dig a little deeper and find all sorts of new tricks and tips and you realize, "Holy crap! I never even though that was possible, this is going to change the way I code." Switch to a console editor. It will change your life. Also, Textmate is practically emacs but with a gui, isn't it?
Yes, because that's what it says.
&gt; Also, Textmate is practically emacs but with a gui, isn't it? If you ignore the most important aspect of Emacs, maybe. TextMate is a pretty nice editor, and its learning curve is excellent compared to its power. But its extensibility (or better, its configurability) is a toy compared even to vim, let alone Emacs.
Seeing Rails adopting Rack is great. People using Merb/Sinatra/Mack/Waves/Ramaze have been using this feature(Rack middleware) for a while and really appreciated it. Too bad, Rails middleware version won't be compatible with other frameworks. I would personally only use/develop standard Rack middlewares. [Edit: this was an initial commit, and it's being discussed. Things might change in the next few days]
I don't think that's fair. I know a few people who have done very complex Java apps but you wouldn't want them working on your rails project. You end up with more code than you need and way over engineered solutions. Not saying that describes you but I am saying it describes a lot of developers who are great in their native language and have only done a simple Rails app.
Wouldn't putting a Ruby interpreter on the iPhone be explicitly against the SDK terms and conditions? I think they specify no app can have the capability of dynamically running new code.
Rails supports the same middleware as everything else ala config.middleware.use Rack::MyFanaticMiddleware This is according to the comments.
I was talking about the other way around, reusing a Rails metal middleware in a different rack framework.
i believe it's enough to not provide any route for the app to get new code to run
No, sh33ple is right here: this is specifically disallowed by Apple. I think something like this would be very likely shot down. (That's not to say there's not precedent for Apple allowing this rule to be broken. [iPhone Frotz](http://code.google.com/p/iphonefrotz/) not only interprets bytecode-compiled game programs but gives you a method of downloading them to play.)
Oh, I see. Right. Although it seems modification would be trivial.
Consider the idea of Adobe releasing a "Flash Wrapper" that turns a flash "application" into a standalone iPhone application. I'm thinking Apple would shoot that down as well. I believe they (a) Don't want a back door to distributing code, and (b) Don't want someone else to control their platform.
Metal is not supposed to be middleware. Take a look at this: http://advent2008.hackruby.com/past/2008/12/15/a_collection_of_rack_middlewares/ - they're essentially small pieces of code intercepting a request BEFORE it is handed off to, say, Rails. This means that they have a great level of recyclability. Metal is more meant for end points - that is, actually generating a response to the user, which middleware rarely do. Thus piecese of metal will not be any more reusable than, say, a given controller action. And we don't really share them, do we?
I don't know if you're debating something I said, but anyway, I know what Rack middlewares are. Also, there is absolutely nothing that says middleware can't be an endpoint. Some objection to Rails' Metal was the fact that it is confusing people into thinking that Rack middleware isn't for endpoints, but it sure can be. Granted, it's obvious to me and probably many people that Metal is more for non-reusable application-specific endpoints. But there's no reason you couldn't implement that as vanilla Rack middleware, besides some syntactical improvements. Therefore, the argument was simply that the downsides of making this special metal concept which is a "dumbed down", special case middleware (namely, confusion and lack of reusability in cases where that's possible) outweigh the upshot of very slight syntactical improvements. That's how I see the debate, anyway. The debate is now mostly moot, though, as Josh has made further commits that changed how Metal is implemented that distance them more from regular middleware, so this concern is being addressed.
I hear that's one of MacRuby's goals. Compile your Cocoa app written in Ruby into a native iPhone app.
no nonsense dependency management. Finally! I love it.
In 5.3 syntax: join(",", array_filter($foo, function($x) { return $x-&gt;bar(); })); Not terribly natural, but a bit neater than an explicit loop.
And (c) don't want anyone being able to develop for their platform without buying ANOTHER of their platforms...
ok
True, but who knows when it'll be out. This has been in HEAD for ca. one year now. 5.3 is beginning to look more like vaporware every day.
Well, certainly nothing stops you defining a named function, or using create\_function() and passing that to array_filter. It still comes out prettier than doing it by hand in many cases.
I can't say I agree with that. `create_function` is `eval` in disguise, and creating a named function is really clunky.
Well, they're all clunky really, it just depends on where you want that clunkiness to be; a half-dozen line manual foreach loop with a temporary variable, a separate named function that may be awkward to place near where it's used, or a bit of hidden eval that otherwise keeps it succinct.
Best? Hardly. GoDaddy offers very limited RoR support, no shell access, and poor customer service. Why are DreamHost, EngineYard, and Joyent not on this list? 
Yep, they are all ugly.
redhanded
Can someone please cut through the jargon and explain this to me in layman's terms?
Basically it's a tool to automate big clusters. See more on Ezra's talk: http://brainspl.at/articles/2008/06/02/introducing-vertebra
I saw something exactly like this a couple of years ago, evalled, base-64-encoded ruby code, formatted as a christmas-tree. Only that code had some cool visual effects (ASCII animations, but still..) instead of just a poem. Link anyone?
Seems a bit over engineered. 
Nice writeup, but I'm curious how free variables are bound in each. *fires up irb*
I have the same feeling. He should mention external variable binding to explain closures. That said, it's a nice article.
That title is awkward, and has nothing to do with the interview.
...Not found.
http://advent2008.hackruby.com/past/2008/12/23/html_scraping_with_scrubyt_for_fun_and_profit/
I played around with CloudKit a bit last evening. It seems like a really interesting project. I'm keeping my eyes open for excuses to use it. :P
Likewise. I'd like to see some example apps built with Sinatra or similar as well.
Hope they don't mess this one up.
had to check to be sure it wasn't april first.
If you are a merbist and you are worried about the merge, check my blog post and video: http://merbist.com/2008/12/23/rails-and-merb-merge/ Merb is not dead and we won't let you down!
What should Merb or Rails programmers do to prepare for this? Is Rails 3 going to be more Merby or Railsy? Who is going to be more lost coming into Rails 3? Merb programmers or Rails programmers? 
My thought exactly. Am about to start a big new project and was planning on using Merb. Should this steer me back towards Rails (even though I'm more attracted to Merb)?
You're trying to find something divisive about this effort of unity?
Wow, I am so pumped. I love both Rails and Merb, but for different reasons. Now it'll be one big ball of joy hopefully. Also, it'll be easier to follow on github!
Great for all those times when you're in need of Rails documentation, but is nowhere near a computer.
According to Katz: &gt; To be perfectly clear: we are not abandoning the Merb project. There are many production applications running on Merb that are relying on both timely bug fixes and a clear path to the future. If you’re using Merb today, continue using Merb. If you’re considering using Merb for a project because it works better for your needs, use Merb. You will not be left in the cold and we’re going to do everything to make sure that your applications don’t get stuck in the past. And, according to Merbist: &gt; clear migration path, and upgrading to Rails 3.0 will be as trivial as upgrading from Rails 2.x to Rails 3.0
Well, the FAQ on merbist says that you should continue to use Merb because they won't leave you hanging. 
Rails 3 will be more Merby. Merb 2 will be more Railsy. No one can say who will be more lost, but I'm sure they're shooting for neither.
This is great news IMHO. It has been clear for a while now that rails is already heading in the merb direction by shedding weight, getting thread safety etc and with the use of neverblock perhaps even exceeding it in speed. At the same time merb was adding weight (via plug ins of course) because lots of people really do want a full stack framework. If you want a super light framework there is ramaze or sinatra and even rack.
Wow! Awesome!
Great news! Didn't see this coming!
Not a christmas tree, but I found this on my harddrive (I'm _not_ the author): #!/usr/bin/env ruby # Trying to top last year (ruby-talk:124391)... s="IyBUaGFua3MgZm9yIGxvb2tpbmcgYXQgbXkgY29kZS4KIwojIENvcHlyaWdodCAoQykgMjAwM iwgMjAwNCAgQ2hyaXN0aWFuIE5ldWtpcmNoZW4gPGNobmV1a2lyY2hlbkBnbWFpbC5jb20+CiMKI yBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgY W5kL29yCiMgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVib GljIExpY2Vuc2UuCgpyZXF1aXJlICdlbnVtZXJhdG9yJwpTVERPVVQuc3luYyA9IHRydWUKCmNsY XNzIFhNYXNIYWNrMjAwNQogIEhFSUdIVCA9IDYKICBXSURUSCA9IDYwCgogIEhPTUUgPSAiXGVbS CIKICBDTEV B U i A 9 I l x l W0hcZVsySi IKCiAgZGVm I G l u a X R p Y W xpemUKICAg IEBzbm93ID 0 g W z BdI C o g V 0lEVEgKICA gIG1ha2Vfb W V z c 2FnZS A i T U VSUlkgQ0hS SVNUTUFTXG 5 B T k QgQVxuS E F Q U FkgTkVXIFl FQVIhIgogI G V u Z AogICAg C i A gZGVmIHJ1b gogICAgcHJ p b n QgQ0xFQVIK I C A g IHVudGlsIH Nub3dfb3Zl c j 8 K ICAgICAgc2 5 v d 2Ryb3AhCiA gICAgIHB1d H M g dG9fcwogICA g I C B wcmludCBIT 01FCiAgICA g I H N sZWVwIDAuMDUK I C A gIGVuZAogI CAgcHV0cyB 0b19zCiAgICB0aWNrZXIgImJyb3VnaHQgdG8geW91IGJ5IGNocml zMiIKICAgI HB1dHMKICA g IHB1dHMKICBlbmQKCiAgZGVmIHNub3dfb3Zlcj8KICAgIEB zbm93LmFsb D8geyB8YXw g YSA+PSBIRUlHSFQtMSB9CiAgZW5kCiAgCiAgZGVmIH N ub3dkcm9wI QogICAgbG9 j I D0gcmFuZChXSURUSCAtIDEpCiAgICBAc25vd1 t sb2NdICs9I DEKICAKICA g I GNoYW5nZWQgPSB0cnVlCgogICAgd2hp b G UgY2hhbmdl ZAogICAgIC B j a GFuZ2VkID0gZmFsc2UKICAgIC A g QHNub3cuZW FjaF93aXRo X 2 luZGV4IHsgfGUsIGl8CiA g I C AgICAgbmV4 dCAgaWYgaS A 9 P SBXSURUSCAtIDEKICAgICAg I C BpZiBAc25v d1tpKzFdKz E g PCBlCiAgICAgICAgICBAc25vd1 t p XSAtPSAxCi AgICAgICAg I C B Ac25vd1tpKzFdICs9IDEKICAg I C AgICAgIGNo YW5nZWQgPS B 0 cnVlCiAgICAg I CAgZW5kCiAgI C A gICAgbmV4d CAgaWYgaSA 9 P SAwCiAgICA g I CAgaWYgQH N u b3dbaS0xXS sxIDwgZQog I C AgICAgI C A gQHNub3db a V 0gLT0gMQog ICAgICAgIC A g QHNub3d b a S0xXSArP S AxCiAgICAg ICAgICBjaG F uZ2Vk I D 0 gdHJ 1 Z QogICAgICA gIGVuZAogI C A gI C A g I E B zbm93W2ldI D0gMCAgIGl m I E B z b m 9 3 W2ldIDwgMA ogICAgICAgIGlmIEBzbm93W2ldID4gSEVJR0hULTEKICAgICAgICAgIEBzbm93W2ldID0gSEVJR0 hULTEKICAgICAgICAgIGNoYW5nZWQgPSB0cnVlCiAgICAgICAgZW5kCiAgICAgIH0KICAgIGVuZA ogICAgCiAgICBAc25vdwogIGVuZAoKICBkZWYgbWFrZV9tZXNzYWdlKG1lc3NhZ2UpCiAgICBAbW Vzc2FnZSA9IG1lc3NhZ2UudG9fYS5tYXAgeyB8bGluZXwKICAgICAgbGluZS5jaG9tcC5nc3ViKC 8vLCAnICcpLmNlbnRlcihXSURUSCkKICAgIH0KICAgIDIudGltZXMgewogICAgICBAbWVzc2FnZS 51bnNoaWZ0ICIgIipXSURUSAogICAgICBAbWVzc2FnZS5wdXNoICIgIipXSURUSAogICAgfQogIC AgQG1lc3NhZ2UgPSBNYXJzaGFsLmR1bXAgQG1lc3NhZ2UucmV2ZXJzZS5tYXAgeyB8bHwKICAgIC AgbC51bnBhY2soIkMqIikKICAgIH0udHJhbnNwb3NlCiAgZW5kCgogIGRlZiB0b19zCiAgICBsID 0gIiIKICAgIEBz bm93LmVhY 2hfY29ucy gyKSB7IHx hLCBifAogICAgIC BsIDw8ICJfXFw vIlthID w9PiBiX QogICAg fQogICAgbCA8PC "+#XAgQG1lc3 {R} NhZ2U {U} ucmV2 {B} ZXJzZ {Y} S5tYXAgeyB8bH #1bZUgNGXlI3N {X} hZ2Uucm {M} V2ZXJzZ {A} S5tYXAg {S} eyB8bHwKICAgIC "AiXyIKCiAgICB yID0gTWFy c2hhbC5sb 2FkKEBtZX NzYWdlKQogICAgQ HNub3cuZWFjaF93 aXRoX2luZGV 4IHsgfGgsIG l8CiAgICAgI G8gPSAobFtpXSA9P SA/XFwpID8gMCA6I DEKICAgICAgcl tpXVtoK29dID0 gaCtvID09IEhF SUdIVCA/ID9fIDogb FtpXQogICAgICAoaCtvKzEpLnVwdG8oSEVJR0hUKSB7IHxqfCByW2ldW2pdID0gKHJhbmQgPiAwL jc1KSA/ID8qIDogMzIgfQogICAgfQoKICAgIHIuZWFjaCB7IHxufCBuLnJldmVyc2UhIH0KICAgI HIudHJhbnNwb3NlLm1hcCB7IHxufCBuLnBhY2soIkMqIikgfS5qb2luKCJcbiIpCiAgZW5kCgogI GRlZiB0aWNrZXIobWVzc2FnZSkKICAgIHByaW50ICIgIiAqICgoV0lEVEgtbWVzc2FnZS5zaXplK S8yKQogICAgbWVzc2FnZS5lYWNoX2J5dGUgeyB8YnwgcHV0YyBiOyBzbGVlcCAwLjIgfQogICAgc HV0cwogIGVuZAplbmQKClhNYXNIYWNrMjAwNS5uZXcucnVuCg==";eval s.delete!(" \n").# unpack("m*")[0] # Copyright (C) 2005 Christian Neukirchen / chneukirchen.org __END__ Happy holidays, -- Christian Neukirchen &lt;chneukirchen@gmail.com&gt; http://chneukirchen.org 
I JUST DON'T KNOW ANYMORE
http://twitter.com/ezmobius/statuses/1059391701
All that reading and he didn't say what the problem was. :(
Yes!! A big win for both projects, and most importantly, for the users. Congratulations.
More direct link: http://dkoontz.wordpress.com/2008/12/22/jotbot-post-mortem-2/
sarcasm rulez O.K.
Anyone remember a very cool ruby project that could output documents in a variety of formats - pdf, docbook, I can't remember them all but it was interesting... Found it: http://www.reddit.com/r/programming/comments/7lwes/ruby_program_to_output_docs_in_plaintext_html/
Zed's such a fucking drama queen.
404ed
Good book for beginners. Would have been nice if the PDF contained the Table of Contents section. 
DHH said "there's no pleasing everyone". Why is he considered a jerk for saying this? His phrase totally makes sense. Pleasing everyone is impossible; no matter what you do, some people will never be pleased, possibly even for irrational reasons. Better to keep moving on than letting these people drag you down and decrease your productivity.
If you read the post, it's about the chilling effect that being a dick has on communication. You're wrong just the way DHH was wrong. The "i can't please everyone" argument is a straw man. Nobody has ever asked him to please everyone. That's not the point, and has never been the point. And the jerk bit is a bit of hyperbole. He was a definite jerk in the past, and his apology of sorts isn't really that much of an apology or acknowledgment. So he's still being a jerk in that regard.
Also, DHH's infamous "Fuck You" was in reality aimed towards those who at the time were saying "Rails isn't enterprise ready". People have been misquoting that to say something else ever since.
You're just being overly sensitive.
who the fuck cares? I'm tired of this soap opera highschool crap filling up my reddit homepage. If you're a giant baby and DHH hurts your feelings then please go use something else and shut the fuck up. Please take your ball and go home.
this looks a lot like the [waves](http://rubywaves.com/) framework which I've been using lately.
Thanks for the link. The routing stuff looks indeed similar to Kontrol.
Waves has different foundations you can use, and the foundations provide a certain orm or templating system. It also has a compact foundation (edit: compact is a foundation) that is nothing but the routing mechanism. I usually go this route and build up the pieces the way I want them which is why I like waves. Also, waves is a thin layer on top of rack as well. btw, I used to live in darmstadt while I was in the army. I love that place :)
go climb back under mommies skirt.
I don't care if he eats babies, Rails is still a fanfuckingtastic framework and has made everyone else who bashes it step up their game aswell even if they don't like to admit it. DHH can't help it if he knows hes the shit.. grow a pair and get over it.
No, DHH is using strawmen to characterize and marginalize other people's valid opinions. That's called stifling discussion.
I was using something else, until Merb merged with Rails.
If you don't like his work, don't use it. He owes you nothing. Quit your whining.
Boohoo. So keep using it.
There are a handful of ruby frameworks already (Sinatra, Ramaze, Camping, Waves). This blog post didn't answer the question: "why another?". I'm personally hitched to the Sinatra framework, but think that this area has lots of area for exploration and new ideas. But really, I didn't see anything to set Kontrol apart from the rest. What new ideas does this bring to the table?
That's a good question and I try to give a short answer now and update the blog post later. First of all, Kontrol just happened to be some small piece of code, which proved to be useful for me. So I extracted it out of my blog engine Shinmun, made it available via github and rubygems and wrote a blog post about it. So for my blog engine, the one important point was the Git integration. It should just run on top of a git repository and a rackup file. All the config, posts, templates and assets should live in the repo and on a push from my local machine, the application should reload its state from the repo automatically. Kontrol just does this. Kontrol is in fact very thin, just a router, a template class, Git integration and some convenience stuff. Comparing to other ruby frameworks, Kontrol is a bit like Sinatra, but uses regular expressions for routing. Another difference to Sinatra is, that a Kontrol application is basically a class tied to a set of routes and Sinatra runs without an application class. As I said, Kontrol is very thin, it uses the infrastructure of Rack and adds some extra functionality. Sinatra on the other hand duplicates many things already present in Rack, like Request and Response classes. 
It also looks a lot to Sinatra, specially the core rewrite rtomayko has been working on: http://github.com/rtomayko/sinatra/tree/hoboken
Could you outline some of the goals of the rewrite?
So fork it and quit complaining
&gt; Another difference to Sinatra is, that a Kontrol application is basically a class tied to a set of routes and Sinatra runs without an application class. This is the main thing I dislike about Sinatra. It makes is a bad rack citizen in terms of running several Sinatra apps in one process via urlmap. I'm actually stunned by this design decision. A class in Ruby is two extra lines of code. Other than that, I think Sinatra fosters good developing habits. It makes you manage complexity well through it's constraints.
Actually my routing code is derived from Rack's URLMap and Builder. So you can even use Rack middleware just for a subset of your actions, for example some administrative stuff could be protected by Rack::Auth::Basic.
The new hoboken-branch (http://github.com/rtomayko/sinatra/tree/hoboken) changes this. Take a look at this gist: http://gist.github.com/38605
Just downloaded the gem. I love what you've done so far. I've just been developing a series of applications in Sinatra, but can't run them in one process. I'm considering moving over to Kontrol. It may be too early to ask, but what are your plans going forward with the framework? It would also be fun to add lightweight libraries of helpers as simple files or gems, e.g. for i18n, relative time/dates, haml templating, etc. Some of these would work with other micro-frameworks as well. The main appeal I see in your approach is the combination of high cohesion and loose coupling. Since your framework is post-rack, it doesn't duplicate its functionality either. I haven't looked at the source in depth, but before filters, and faking put and delete from browsers would be nice too. Btw - why this and not sinatra - sinatra has my aforementioned problem (no namespace/class), and its development has slowed considerably, so I don't see this being mitigated any time soon. Not a huge issue, but indicative nonetheless. Edit/PS: Forgot to say: I love the regex/block vars routing combo - it provides full power and gives you nice local vars in the block body. Sinatra's routes are much more limited (e.g. trailing "/" are a pain, unless I'm missing something).
Thanks, this looks great. Looks like there is a decent migration path API-wise as well. Do you know anything about the roadmap/stablity of this branch?
&gt; It may be too early to ask, but what are your &gt; plans going forward with the framework? You're right, Kontrol is in an early stage, so I'm open for anything. Currently my single requirement is, that Shinmun should be able to run on Kontrol. &gt; It would also be fun to add lightweight &gt; libraries of helpers as simple files or gems, &gt; e.g. for i18n, relative time/dates, haml &gt; templating, etc. Some of these would work with &gt; other micro-frameworks as well. Loading additional functionality through gems seems like a good approach. Extending Helpers and Templates is not a big deal, but I guess, next thing should be a clear API for loading and extending templates. &gt; The main appeal I see in your approach is the &gt; combination of high cohesion and loose &gt; coupling. &gt; Since your framework is post-rack, it doesn't &gt; duplicate its functionality either. Nice to see Kontrol's advantages stated from another point of view. &gt; I haven't looked at the source in depth, but &gt; before filters, and faking put and delete &gt; from browsers would be nice too. There is already Rack middleware for faking put and delete I think. Running Filters is easy to add. &gt; I love the regex/block vars routing combo - &gt; it provides full power and gives you nice &gt; local vars in the block body. I love them, too ;) I'm not sure, why nobody uses regular expressions for routing, in this case I rather have power than simplicity. Using local variables also is cleaner than populating the parameter hash, because all you need to know can be seen at one location. In a Rails application for example, you have to look at several places to understand the relation between the routing, parameters and the controller action.
Sinatra has certainly slowed down development for a while, but it's picking back up. Several of the core people found new (and demanding) jobs, which meant less time for Sinatra. Keep an eye on the hoboken branch, it's most likely the future of Sinatra (although that hasn't been decided). The sinatra-diddies github project has a few of those handy helpers which go well with the rest of the framework. Sinatra does play with rack, just not nicely. It's impossible (currently) to run several in a single process, but rack middleware is great (and provides session, logging and more by default). Personally, I don't like the regex routes. I find them incredibly hard to go back to later, and figure out. ducktyped, if you haven't stopped by #sinatra on freenode, do so. We can help/solve your problems pretty quickly. Also there's the www.irclogger.com/sinatra logs which can answer all sorts of questions too.
Hot off the presses. Still a work in progress, so let me know if you find any bugs/areas for improvement.
Thanks, cschneid for your helpful pointers. I hang out on #ramaze from time to time. I'll stop by #sinatra next time as well.
This looks quite useful, probably I will add this to my blog engine.
What exactly does that page count really have to do with it? A lot of pages can be used to say very little, and very little can say a lot. And the chapter count, is that to tell us it's well organized?
It's still experimental. We're currently debating if/when this would become the new mainline but it's been very warmly received thus far. I'd expect to see this or something like it in a stable release sometime within the next month or so. Also, I'd very much appreciate any feedback or anecdotes related to running existing apps under the new branch. We're hoping to retain backward compatibility for the most commonly used features and scenarios.
I'm pretty happy with this thus far. Faster and less memory usage from what I have seen.
ehh, I disagree. For one, his blog mixes politics and programming which I really don't like. I could put up with it if he didn't claim to be a Ruby expert yet make some beginner mistakes. I distinctly remember a presentation he gave where he was corrected on some point by an audience member. Presenters, IMO, have a responsibility to make sure their presentations are accurate.
mistakes happen. putting together presentations is difficult. you can't invalidate the guy's knowledge just because he made a typo. I see your point about the politics/code mixture though. it's a tough balancing act: make separate blogs for each topic, or just bunch it all together? regardless, his blog is one of the few I read religiously.
&gt;I could put up with it if he didn't claim to be a Ruby expert yet make some beginner mistakes. I distinctly remember a presentation he gave where he was corrected on some point by an audience member. You must *hate* presentations, cos mistakes bite everyone.
I really dug his presentation on archeopterix. 
&gt;his blog mixes politics and programming which I really don't like What does his blog have to do with the quality of his presentations? Should his worth as a presenter also take into account his Twitter and Facebook output? &gt;I distinctly remember a presentation he gave where he was corrected on some point by an audience member. I think the worth of Giles' contribution comes more from his creativity than his technical expertise. Valuing creativity and passion is one of the things that gives the Ruby community its distinct flavor. 
Interesting changes, but I don't see this as much cleaner than the existing hash style named paramaters.
Wow, just, wow. I've been wondering if there was something like this for a merb project I've been working on.
I don't particularly subscribe to the mentality personally of loading all records into memory to show 100 records at a time. There's better ways to do that. Let the database handle that, rather than the application.
Ya that would be nutty, but the code he discusses doesn't load all records at once. It scrolls through the table fetching the records in smaller chunks. Looking at the plugin quickly it uses limit and offset under the hood.
There's one table in the database I use most often at work that's painful to work with: it has over 20 million rows, counts take a few minutes, etc. Instead of relying on a paginator which will most likely use limit and offset, I find it's much faster to add "id between ? and ?" to the conditions and step through the table in 100k chunks.
Nice to see the site is responsive. Go passenger!
 desc "run flay on everything" task :flay do sh "flay lib/**/*.rb" end 
Thanks, I figured that out :) I was thinking something that I could put into my CI artefacts with a snazzy HTML output, and maybe with colorized source. Also, a pony. Thanks for writing it though, I've been using flay pretty much daily to burn down the debt we're incurring.
I always knew I could get all of those Japanese people to remember stuff for me... but I never thought ruby bindings would exist! I guess it somehow even makes sense
Is mod_ruby the same as Passenger? I thought it was, but it's a completely different site/project..?
Seems to be a minor maintenance release. And what's the point? mod_rails / mod_rack / Passenger is where the Apache-fu is at.
Sometimes though, you may just need to add a little ruby scripting into a single web page. There is no easy way to do that with Passenger. You can have the rhtml pages ran through eruby as a cgi script, but that has performance issues. I would like to see Passenger add the ability to server up single rhtml files like mod_ruby does, but until that day I'll be glad that mod_ruby is sticking around.
It's just a reflex action.
They are not the same, Passenger was also named mod_rails. Mod_ruby is a lot older than Passenger.
Just create a single config.ru and map all requests to one lambda, which renders a rhtml file found on the requested path. For parameter processing you should provide a request variable.
This article is void of content.
Amazing, there is no eval, and I don't have a headache from looking at it!!!
That can't be his real name, can it?
Why does he have. def add_route(route_string, *args) @route_structure ||= {} @routes ||= [] .... when he has this. def initialize @routes = [] @route_structure = {} end 
At last. I was hoping someone would do this. Very cool.
Of course it is: consult your [MacLysaght](http://www.amazon.com/dp/0716523663). :)
Amazing stuff indeed. Ruby code like this is the cancer that's killing Java :)
The old RouteSet implementation is here: http://github.com/rails/rails/tree/master/actionpack/lib/action_controller/routing/route_set.rb
Using eval was a big mistake of the rails team. It was nearly impossible to extend the old routing code.
&gt; [T]he new trend is do announces on Twitter, even when you’re subscribed to the devel mailing list of the project… you need to stalk the project developers to get news. &gt; Of course, you can avoid all this spending 4 to 8 hours a day on #IRC channels, where most of the big and compatibility breaking changes are introduced and decided.
There's a much more important message there. I'd have related that in the title. It's a bit "off topic" from the twitter part of the post, but it's about release management and your stuff breaking on different platforms or Rubies.
I've found that Ask Slashdot is the most useless waste of effort ever. So many misinformed people out there combined with smart ass comments makes the whole exercise pointless.
Unfortunately my crack panel of subeditors is away this week.
Why is this in the rubby subreddit?
The shirtless guy is a nice touch, and should be a part of every programming blog.
Grats on learning HTML?
Great work going through all that and checking for relevancy.
No. Just no. There is a programming book publisher that insists on putting the faces of the authors on the cover. That's bad enough.
NM, found RailRoad.
Railroad seriously rocks. Have been using it for a long time and never looking back. Still, there is a catch: RailRoad apparently uses its own inflector, so it interprets many complex singulars/plurals wrongly (for example, it interprets Status as a plural of Statu), so sometimes you'll need to edit resulting diagrams by hand.
Yeah, I got hit with that inflection issue. Had to modify some class names... not a big deal. For the SVG output I'm using http://www.fileformat.info/convert/image/svg2raster.htm to convert to a PNG. For some reason Safari won't let me scroll around the SVG. (have to shrink it until it is unreadable to fit on my screen)
Here is the link to RailRoad: http://railroad.rubyforge.org/ 
I'm not seeing the fun part.
i think this article is a really great representation of how flexible ruby is. while many people are battling with functional vs OO programming styles, ruby gives you both AND allows you to produce code that is almost indistinguishable from Java (like in this example). i think it's the ability to warp and bend ruby code to appear like a horrible mess of camel-cased Java that gives ruby a huge lead over python and lisp. &lt;/sarcasm&gt;
Maybe that's the part where he doesn't use groups.
Maybe I'm crazy, but I don't see why anyone would be willing to pay 15 USD/mo for only two machines for software that's already free and already has a package management system. Gem is terrible, don't get me wrong: it's slow, you have to compile native extensions still, and it's S-L-O-W, but at that price point what's the benefit?
If you think that the prices are unreasonable, please contact us (Phusion) and give us some suggestions. Someone has already suggested a group discount plan, e.g. allowing a group of 10 people to purchase a single Premium plan. Needless to say we'd love to hear what your take is on a good pricing plan.
Pat is a gangster.
I fired up libxml-ruby the other day. Ten times faster than REXML. I seriously doubt anything is going to beat that.
Yikes! So much for trying to apply there.
No really, it's deader than John Travolta's son. 
Why make that class a model? Why not just a plain old class in your /lib 
I just saw Ezra tonight at Pivotal actually. He seemed in good spirits. As texmex said, Engine Yard overcharges for the services they provide, but if you want someone there to hold your hand every step of the way, it's going to cost you. Everyone I talk to about them seems to agree that although their pricing model sucks, they have a lot of cool projects going on internally.
yay!
Because it's part of your domain model? Model doesn't == ActiveRecord or stuff in your database.
I've had good experiences with them and think the expertise, experience and support is worth the price. You get what you pay for -- and with EngineYard, you're paying for peace of mind. Someone else taking care of server setup, configuration, upgrades, patches and other maintenance so that I can concentrate on the project itself? Worth a premium. Whether they charge too much of a premium is not something I can say objectively, but I have been happy with them.
I just came in to say the same thing. I'm not sure if this is still correct, but in the 1.x days, ActionMailer classes were put in /app/model as well. That being said, I don't think putting it in either place would be regarded as wrong. It's your project, put the code where you like.
"The basics"? Try hiring a good sysadmin that's available 24/7 for like $600 a month. You can't. That's the real cost benefit there.
If there are other ways to keep up with the Ruby community that work well for people I would be interested, just point them out in comments.
I just upgraded to 1.8.7 on a development machine yesterday (from 1.8.5) to get rid of memory leaks. The app I was working on went from growing memory usage at about 1MB a minute to staying put at 24MB.
Hmm ... if you think systems administration is simply a matter of "running apt-get and compiling a few apps," it's not surprising you'd think EY is a ripoff.
"Hint: There's no sysadmins." I'm not sure I understand what you're trying to say. When I send ticket requests to EngineYard, they are completed quickly (and it frees up my bandwidth to work on other stuff. So, who is doing that work for me and my client, if not support staff or sysadmins?
I don't see it that way. I treat models as the "bottom" layer, I have my business logic in the /lib hierachy. My controllers are skinny and mostly talk to the business layer. To each his own I guess.
What is the "model" if not the model of your domain, i.e. business logic. The lib folder is only really for utility/library code. The fact its outside the app/ folder should make that clear.
Except when somebody else has to take over your project and wonders why you've ignored conventions.
Imho, the lib folder should be used as little as possible. If it is reusable, use a plugin (or better yet, a gem), if it is part of the domain, it's a model. You are introducing an additional layer into MVC. There is a point to be made for this, having ORM and model layer separate, but you are not following the Rails convention. Which is usually a bad idea in my experience. Looking at apps which use lib extensively always makes me feel that having to hop back and forth between app/model and lib to figure out how the components interact is very annoying. It makes it much harder to figure out how the application works. It annoys me that RESTful auth, which is used in *many* applications, gets this wrong. Ohh well, Merb is coming, and with it, the wonderful merb-auth, I hope.
&gt;Looking at apps which use lib extensively always makes me feel that having to hop back and forth between app/model and lib to figure out how the components interact is very annoying. It makes it much harder to figure out how the application works. Personally I don't like the fact that rails puts the views in a different directory than the controller. 
&gt;Imho, the lib folder should be used as little as possible. If it is reusable, use a plugin (or better yet, a gem), if it is part of the domain, it's a model. I find these harder to maintain and write. It's easy enough to create a hierarchy in the lib directory. 
the views should be as separate from the controller as they are to the models. why would you want them in the same directory as the controller? surely that is just going to gunk it up and make it harder to browse/understand?
&gt;the views should be as separate from the controller as they are to the models. why would you want them in the same directory as the controller? Because I am working on them at the same time. This is the way webobjects does it and it's very nice. &gt;surely that is just going to gunk it up and make it harder to browse/understand? I find it much easier. The controller has actions, each action has a view, they are all in the same directory. That makes it much easier to work on them together. 
You could just as easily extend this argument to models too. Each controller interacts with a model therefore place them in the same directory. Lines should be drawn somewhere and I feel dividing on MVC is the way to go.
&gt;Each controller interacts with a model therefore place them in the same directory. Controllers may interact with multiple models. &gt;Lines should be drawn somewhere and I feel dividing on MVC is the way to go. I am not talking about blurring the lines, putting controller code in your views or anything like that. You still have MVC it's just the files are grouped differently. You don't code any different.
Passenger is a popular way of deploying a Ruby on Rails website, but have you ever wanted to change the error templates that Passenger provides?
Do you expect EY to actually code for you?! Heh... good luck with that one. And yes, I know very well how to deploy apps.
Disclaimer: I'm pretty close with some people who work at Engine Yard and my company uses them extensively. There are staff available 24/7. Real staff. Can your "few hours a day" dude fix your 3a.m. database crash before everyone gets up the next day and then monitor it throughout the day to make sure load doesn't go up again? They didn't fire everyone. 15% != their whole support staff. I'd reckon that's not even close to half. They still employ 72 people. And you're not paying $2k a month. Most people pay about half that. You've obviously never hired EY to handle your hosting, or I really, really think you'd change your tune.
Congrats on finishing the book! But... &gt;This chapter explores meta-programming - self modifying programs. Then you should rename it. [Dynamic programming](http://en.wikipedia.org/wiki/Dynamic_programming) means something else.
This guys rocks!
Many thanks for the comment and the congratulations which are gratefully received ;-) Let me explain the chapter title. The term ‘dynamic programming’ - like so many other terms, alas! - is used by different programmers to mean different things. This is why I began this chapter of The Book Of Ruby with a several paragraphs in which I define what I mean by ‘dynamic programming’. I had hoped that my introduction had clarified that my intention was to discuss the dynamic program modification capabilities provided by Ruby as a ‘dynamic programming language’. Thus, the theme of the discussion in this chapter is to explore Ruby programs as ‘dynamic’ (active, responsive, mutable) systems. The Wikipedia article which you reference discusses a mathematically-derived concept of dynamic programming which is unconnected to the dynamic program modification techniques discussed in The Book Of Ruby. This alternative Wikipedia article discusses (rather briefly) dynamic programming in the latter sense: http://en.wikipedia.org/wiki/Dynamic_programming_language best wishes Huw Collingbourne SapphireSteel Software http://www.sapphiresteel.com
Here's how you avoid ActiveRecord threading issues and MySQL - you stop using MySQL, and start using a real RDBMS.
As a new rails developer, I am happy to see a site like this return.
I understand what you *mean* to say. Still, the term "dynamic programming" does mean something in computer science, and even somewhat in programming in general. I admit it may be somewhat of a niche-ish term, but still, it means something and it means something important (so much so that you will not find your "alternative definition" on the [first page of google search results](http://www.google.com/search?hl=en&amp;q=dynamic+programing)) It's a really freaking huge idea, I'd hate to see an otherwise well-written book attempt to redefine it. I'd opt for "programming dynamically" as a title before that. Even more so, I'd just go with the term you mean: "Chapter 20: Metaprogramming" In any case, regards(!), and good work (and luck to you!)
Yes, but mod_ruby is fundamentally flawed and useless. It reuses processes, so site_a.rb will eventually be loaded in the same process as site_b.rb. Using mod_ruby for hosting becomes impossible (user A gets access to user B's runtime), and debugging becomes a giant pain.
The second entry on the Google search page links here: http://en.wikipedia.org/wiki/Dynamic_programming_language ...which explains "There are several mechanisms closely associated with the concept of dynamic programming" and then goes on to describe various features beginning with 'eval'. It has been my experience that programmers of 'dynamic languages' such as Lisp, Smalltalk, Python and Ruby often use 'dynamic programming' in this sense. I have to say that it seems to me entirely logical that a "dynamic programming language" should be expected to do "dynamic programming". In fact, I am not really sure how else to refer to the special characteristics of a "dynamic programming language" (which include but are not limited to metaprogramming) other than to refer to its "dynamic programming" capabilities. I have a feeling that the definition you link to in Wikipedia is much more likely to be familiar to computer scientists and academics than to most developers using dynamic languages. I also have to say that, even though I use the term 'metaprogramming' in that chapter, it is not a term I much like. Just like "lambda expressions" it seems a bit too classical in flavour and, for someone coming to the subject for the first time, the terms are likely to be pretty meaningless and off-putting. Remember that even though The Book Of Ruby goes into considerable depth, it is not an academic book and I have tried to make it as reader-friendly as possible. best wishes Huw
In other news: lead is an unsuitable material for lifejackets.
Guys, I'm trying really hard, but I can't get these nails into the wall with my band saw. Man, band saws must be horrible, useless tools.
 I’d like to see an explanation of why those 3 things are needed for game development. Further, “I don’t really want to switch to JRuby” is not a compelling reason to say Ruby is not suitable for game development because Ruby doesn’t have X even though an implementation of Ruby does have X. I’m not saying I’d be trying to build the latest Calls of Duty in any implementation of Ruby. But you’re dismissing it, and contradicting yourself at the same time. 
The point of the article is basically this: you can't sustain 60FPS because of the mark-sweep garbage collector, so don't bother trying ruby for serious game dev Why not JRuby you ask? Well, most games need access to native code so what then? JRuby -&gt; Java -&gt; JNI -&gt; Native Code? Ouch! :) For me, I'll stick to C++ for now and try Ruby again later when they sort out the GC, maybe in Ruby 2.0?
I'd argue that naming the chapter Metaprogramming would be just as descriptive and wouldn't clash with the other definition of dynamic programming.
I signed up for the beta and was very impressed with the service. It will be interesting to see how the commercial offering differs from the the one I played with. The biggest challenge will be database bits. It's easy enough to load balance web servers, database servers are a whole another animal.
awesome! I was just trying to figure how to do something like this.
&gt; why not jruby? well most games need access to native code, so what then? jruby -&gt; java -&gt; JNI just to call some native code? no thanks :) That's the part where I felt you were contradicting youself. I thought Java had all the things you mentioned were lacking in MRI/YARV Ruby, and thus JRuby would have them too (which means you could use Ruby the language to create a game). Anyway, thanks for the clarification. 
This individual seems to think that try should be andand.
Okay, so what's wrong with adding NilClass.to_s and NilClass.to_i methods so that they default to '' and 0 respectively? If this is a globally sought after behaviour that is... Just go for broke and add those methods... What is at risk of breaking? 
He likes `receiver.try(:method)` whereas I wrote something with `try`'s semantics that had `andand`'s syntax: receiver.please.method So I guess there are four 'flavours' distributed on two axes: message invocation vs. send-like syntax, and `.respond_to?` vs. `unless nil?` semantics.
Isn't that the default behavior? The author's problem seems to stem from the fact that these _don't_ return nil on nil objects.
No, the default is opposite. irb(main):001:0&gt; a=nil =&gt; nil irb(main):002:0&gt; a+1 NoMethodError: undefined method `+' for nil:NilClass from (irb):2 I don't necessarily know if I agree with that. In databases, n+nil=nil . Makes sense as nil is unknown. When you add nil to unknown you get another unknown.
No, the default is as spohlenz says. 001:0&gt; nil.to_s "" 002:0&gt; nil.to_i 0 It's important to remember that, as in your example, + isn't an operator, but a method, and that "a+1" is just syntactic sugar for "a.+(1)". In fact, your example demonstrates the mehtodness of + NoMethodError: undefined method `+' for nil:NilClass nil just doesn't have a + method. Now, when you go the other way (1 + nil), you're using the Fixnum method + 003:0&gt; 1 + nil TypeError: nil can't be coerced into Fixnum In that case you might expect nil to be transformed into a 0, but instead, + method asks for nil to be coerced, and that happens with a different method: Numeric's coerce (not NilClass's to\_i). And, in the end (if you grep through the source), that coercion ends up trying to call Float(nil) (which is much stricter than just to\_f) and that's where it fails with the TypeError.
Yeah, and this is where I'm opinionated... NilClass.+ should exist. nil is unknown, but there's no reason NilClass.+ cannot return nil. But that's just my opinion, and I understand why Ruby developers might opt to throw errors - either in int + nil or with nil + int. I just don't have to agree with it :) 
What you want is the full `Maybe` monad from Haskell or perhaps `sudo gem install ick`. If you want to have full-blown database-like `NULL` semantics, then `nil` cannot be an object. For example, what does `nil.class` return? What does `nil.nil?` return? `nil` has to live outside of the object and method system, and something like `nil?` probably becomes a keyword rather than a message, as in `nil?(nil) =&gt; true`. Also, `!nil` probably returns `nil`, just like a database. `nil` and `false` have to have completely different semantics.
&gt;For example, what does nil.class return? Actually it returns NilClass &gt;What does nil.nil? return? True &gt;nil has to live outside of the object and method system No, that's not the Ruby way. NilClass is an object in Ruby. I openly admit I'm not an expert in the theory of programming languages, so I'm sure I'm going to get smacked down soon enough :)
I think I was not phrasing things properly. What I'm, saying is that if you want `nil` to have `Maybe` semantics, then yes, `nil + 1` will be `nil` and at no extra charge, `1 + nil` will also be `nil`. However, `nil.class` will be `nil`, as will `nil.to_s` and `nil.to_i`. You can't write a method like `nil?`, you will need a special keyword for testing nil. `object == nil` will be `nil`, and so will `object != nil`. That's how SQL NULLs work, and that's why there is are special conditions, `IS NULL` and `IS NOT NULL`. I agree that isn't The Ruby Way, which is, IMO, why Ruby's `nil` does not behave this way. Once you think about it, you quickly realize that although you can use `method_missing` to do some cute things, making it consistent and turtles all the way down is very, very hard.
aka: Crap vs. Shit 
Good article! I usually use C-based Ruby, but JRuby is a great tool for working and deploying in JVM-land.
Or write a completely useless blog post full of affiliate links.........
Where is the hpricot home page now? 
I read half of this article, and got the impression that the author basically just doesn't understand how objects work, and that `puts` prints the string version of the object and that he should really be using `p` if he wants to see the "raw" object.
I am tempted to hookup my wiimote to my laptop (I have done this to play frets of fire) and make some live midi music with my wii guitar... that would be fun
nice idea... if it also includes comments where the code originally came from, even nicer. The `method_missing` stuff would be hard if not impossible to do though. For example `Post.find_by_title` is a method that would be created by `AR::Base.method_missing`, but only after the request has been made. You could rewrite to an .rb file after the response has been sent, but it might be a different output for each request made. Before you go into the deep with this one: with merb's influence on board the promise is that rails 3 will have most of the magic removed. At least, that's what I silently hope they'll be bringing to the table.
Is is possible to do something like [this](http://music.eochu.com/) with it?
Having some exposure to DataMapper, you'd be hard pressed to get me to use ActiveRecord on its own. That said, one of the few remaining areas where ActiveRecord come out on top is the availability of a wide array of adapters. AFAIK DataMapper does not have an ODBC or an Oracle adapter. Yet.
That's too bad. You should have read the whole article. Your impression is shortsighted.
Once again, what is this about? Like creating a third library?
&gt; (so you can see lolal vars at a glance). Those must be variables like has &lt;&lt; [ :cheeseburger, :a_flavor ]
that, and I keep typing http://lolcathost:3000 all the time now :/
eridius' evaluation seems to pretty much correct. However, I did read the whole article and the comments at the article reflect the whole puts vs what-object-is-responding-to-the-puts-message issue. Oh well. I would however, like to know where the hpricot articles _why wrote have moved to. He had a set of docs and discussions online but they've moved or are gone. Google spider not hit new ones yet
Seems like they created something like dh-make-perl which builds debian packages from CPAN. I'm kinda surprised there isn't already a tool in debian for this actually and a little sad that someone is going to end up re-implementing it. 
Reading the rest of the article, the only even semi-intelligent point is that the Text object doesn't implement `#inner_html` to return its own string.
&gt;Incidentally, you win the prize (which is endless glory :-) if you can account for the difference between these two snippets: &gt;&gt; {1 =&gt; 2}.select {|x,y| x } =&gt; {1=&gt;2} &gt;&gt; {1 =&gt; 2}.select.select {|x,y| x } =&gt; [[1, 2]] \#select with no args returns an enumerator.
Wtf is DSL?
Digital Subscriber Line. Whups, no, Domain Specific Language. The kind of thing Lisp advocates tell you it's perfect for creating. For future reference: http://www.acronymfinder.com
I did try http://www.google.com/search?q=define%3Adsl which usually has pretty much everything (it's google!). but it only lists the broadband DSL Thanks
[Here's another post in the same vein.](http://www.randomhacks.net/articles/2005/12/03/why-ruby-is-an-acceptable-lisp)
Wikipedia is also good for these kinds of things. [Here's their disambiguation page for DSL](http://en.wikipedia.org/wiki/Dsl).
Wikipedia is also good for these kinds of things. [Here's their disambiguation page for DSL](http://en.wikipedia.org/wiki/Dsl).
Reminds me for [RubyWebDialogs](http://www.erikveen.dds.nl/rubywebdialogs/index.html). See [the homepage](http://www.erikveen.dds.nl/) for an example.
I figure it'll be just like anything else: let the early adopters gain all the benefits and suffer all the disadvantages of the new thing, and I'll switch when all the bugs have been ironed out.
pure, incredible hotness
RSpec 1.1.12 now works with Ruby 1.9.1-rc1. Let the testing and patching begin!
Sinatra is the future of Ruby web development. You heard it here first.
I didn't know Elijah Wood used Ruby.