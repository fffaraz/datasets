&gt; Python also has a focus on one obvious way to do something. This, I think, is a very important thing. In Python, there is often "the Python way", and in Ruby "there is more than one way to do it". I've met a few pythonistas who would ask me how to do something in Ruby and ended up quite frustrated that I gave multiple options as an answer. If you're learning a topic (let's say: data science), you don't necessarily want to learn python; you want to learn data science.
In Ruby there is more than one way to do it (TIMTOWTDI). It gives choices but if you don't like it there's always Python! The lonely person operator was born out of real world pain. It's been a great salve. I actually agree on #itself taking a block being a nice way to go. Matz does pay attention and care. He continues to do a damn good job.
Matz says the `&amp;` is a person sitting crosslegged staring at a period: &amp;.
I have no personal animosity towards you! /u/schneems, do you have a relationship with Matz to express your concerns? Or would you like to express them on the ticket that is the OP here? You are "a name". :)
&gt; TIMTOWTDI Yeah, but `.()` is a unique case. It not only confuses method sending with `Proc` "calling", which are quite distinct cases, but is not even an alias or way but "syntactic sugar" to `Proc#call` aka `Proc#[]` method, resolved not at runtime level but source parsing phase like keywords and literals. Added confusion and inconsistency for the sake of shorting invocation by "omitting" typing `[]` method name. Definitely not worth, if you'd ask me. &gt; The lonely person operator was born out of real world pain. It is not that simple, removal of some boilerplate at the cost of breaking basic rules like thorough and consistent Ruby's object model. I have no problem if similar solution like `Object#try!` works on a library/framework level, but it should not pollute the core language. I've seen too much of a buggy code misusing this operator or ignoring either nil *and* false as possible results in conditions.
Ruby is too late to the party for data and math libs and ecosystem. Ruby lost on mobile because RubyMotion was proprietary and expensive. Still is Ruby lost in enterprise because its runtime is too slow. Ruby's biggest selling point was Rails and sooner or later all puppets,chefs will be replaced with something else. What can save Ruby ? GraalVM.
Curses, I was going to make a guest RubyTapas with Avdi on exactly this subject and you have approx 100% of my content. Nice job. :-)
I started an issue with concurrent-ruby. It doesn't actually break the lib at all, but I agree it could cause confusion.
I like the usage of \`.then\` over \`.yield\_self\`, but I worry it might confuse beginners since \`then\` is already an optional keyword used with \`if\`/\`unless\`/\`case\`.
Don't worry about the changes because the principles are the same. If you really need to know about the up-to-date details then there's is nothing to do but read the source code.
An issue to do what... you want concurrent-ruby to change the method name it uses for promises to _not_ match the way that method is named in every other promise library? That does not seem like a great idea to me. 
This is my first real open source project, so I'd love feedback \-\- even if you think it sucks!
Thanks. I suppose I'll go through the book and just try to match it to the current code. I wonder how software engineers working on Ruby today deal with situations where they are unsure of why something was implemented a certain way. Do they just leave code they don't understand, or do they delve into the codebase until they can guess at why one implementation was chosen over another?
&gt; I wonder how software engineers working on Ruby today deal with situations where they are unsure of why something was implemented a certain way. They either ask someone (in Japanese), or if you are experienced with VMs and work on them professionally you will have a good knack for figuring these things out.
&gt; yield can be replaced with ordinary method call Sure. In that case didn't need - in fact, aren't even using - `Dry::Monads::Do`. I've looked at the [implementation of `Dry::Monads::Do`](https://github.com/dry-rb/dry-monads/blob/master/lib/dry/monads/do.rb) and it seems to me the whole _point_ of that module is to implement a contract whereby the prepended method yields to the block that it's given, to handle `Result` containers for it, to reduce the amount of boilerplate. &gt; WRT passing blocks to methods it turns out you're likely not to have such problems ... you can refactor your code to work around this As we say here in Australia ... "Yeah, no". I use blocks extensively in my code. I'm not willingly giving them up for a new flow-control library. So this observation supports the thesis that dry-rb is basically a new &amp; different language. 
I just opened up the issue to discuss a potential issue, since you brought one up. I agree it doesn't seem there is a problem after all. It's not even particularly confusing. Seems fine!
Mostly because [SciPy](https://www.scipy.org/) is not just some popular library that you quickly port. It's a whole ecosystem of really good libraries and tools. So if you want to work in the field and be productive you can build on that. The advantages of using Ruby over Python can just not make up for the things you loose.
Argentina (Buenos Aires). Been working on Ruby for five years already and I love it. My current project is a financial application that is taking off.
`Dir.glob("*")`
This post sort of marks the end of my long search for good Ruby auto-completion with vim. I'm really happy with the result!
I guess that's more a philosophical debate. That's how all object oriented languages do it under the hood anyway. Call me weird, but I like that it still exists. It makes you think whether or not a method should belong to a class, or should it exist on it's own, or maybe it should only exist as a private helper function, since you're not manipulating the object directly.
Agreed!
Exactly. Check out one of my gems as an example of using sequel with sqlite on MRI and JRuby in production. https://github.com/steakknife/oui
This seems really good. Well done. Now I wanna build some cli client even having no need for one.
A truly existential operator. 
That transition is part of the roadmap to RuboCop 1.0. Read the details here https://speakerdeck.com/bbatsov/all-about-rubocop-rubykaigi-2018 If anyone is maintaining a RuboCop-related OSS project we'd love to see it become a part of RuboCop HeadQuarters!
I'm pretty sure you meant to name this project "police station" or "precinct". 
Thank you! Do you experience any slow down when developing with larger projects? I used solargraph on vs code before transitioning to vim and I noticed significant slow down on that editor. 
Support for 2.6.0-preview2 also on Heroku available, immediately https://twitter.com/schneems/status/1002403999503540224
Looks good. There was a pretty good book recently that covered some interesting points of encodings https://aaronlasseigne.com/books/mastering-ruby/strings-and-encodings/. 
I also can't see myself using either `yield_self` or `then` for the small benefit of not introducing a local variable and for the bigger deficit of less readability (in my opinion). But `then` is *much* better than `yield_self`. I also still use `#call` or `#[]` instead of `.()`: The point before the parentheses always looks a bit off. Furthermore, with either `#call` or `#[]` you can easily duck-type your way around. For example, using a Proc instead of a Hash, or a custom callable object instead of a Proc. And don't think too much about "the most hated Rubyist" title - new features for Ruby core do have proponents *and* opponents most of the time and voicing opinions helps the core team decide. So thanks for taking your time and contributing to Ruby!
This looks neat. My feedback: First thought: this seems a lot like futures/promises. Have you looked into those? I like what you‚Äôre doing but it feels like it can be generalized or taken a bit further. Maybe I missed it, but I think you‚Äôll want a way to handle exceptions in the asynchronized method. I guess that comes for free with the thread.join method but not in the block version. You may have a problem if the method being asynchronized has a call to super. I think using Module pretending sidesteps this issue and simultaneously removes the need for method_added. It‚Äôs been a while since I had to do this, so definitely do some testing and don‚Äôt trust me blindly :)
This looks neat. My feedback: First thought: this seems a lot like futures/promises. Have you looked into those? I like what you‚Äôre doing but it feels like it can be generalized or taken a bit further. Maybe I missed it, but I think you‚Äôll want a way to handle exceptions in the asynchronized method. I guess that comes for free with the thread.join method but not in the block version. You may have a problem if the method being asynchronized has a call to super. I think using Module pretending sidesteps this issue and simultaneously removes the need for method_added. It‚Äôs been a while since I had to do this, so definitely do some testing and don‚Äôt trust me blindly :)
&gt; else without rescue now causes a syntax error. [EXPERIMENTAL] They really should have picked better words for that Turns out, it's just about `begin-else-end` without `rescue`. https://bugs.ruby-lang.org/issues/14606
No, no slowdown whatsoever. Perhaps there are other factors making vim slower for you? I've found iTerm to be awfully slow with it, and switching to [Alacritty](https://github.com/jwilm/alacritty) sorted that out. If it's not the terminal, you can also try [profiling vim](https://stackoverflow.com/questions/12213597/how-to-see-which-plugins-are-making-vim-slow) to see what's up.
I did look at promises, but it seemed like quite a bit more than what I needed for another project I'm working on. This is meant to be simple. No interface to learn, and no bloat. I haven't done much testing with how exceptions behave, or calls to super, I'll definitely look into those and find solutions. Thanks for the tip :) The current plan for version 0.2.0 is to not use method_missing by default and only include it if you pass some option to asynchronize, but module pretending sounds cool.. I can't seem to find any references for it. Do you have a link to share?
Thanks. That‚Äôs the intention! I‚Äôm sure you can come up with something semi-useful ;-)
Thank you! I hope to spread the joy of Ruby scripting in the terminal. I‚Äôve just presented this at RubyKaigi in Japan.
I did entertain the name RBPD for a while. ;-)
[removed]
Is there a published roadmap for Ruby 2.6.0?
Python's `dir()` is similar to pry's `ls`.
Some things that make Python more attractive than Ruby: * The outstanding documentation site. * Execution speed. * Highly transparent language evolution, managed by the nonprofit Python Foundation. * Core developer communication is in English. * Excellent module definition and import system, which allows selectively including items into the current namespace. * Culture of explicitness, not implicitness, which reflects all over application code projects.
&gt; Highly transparent language evolution yeah, when both 2 and 3 coexist and community is split. &gt; Execution speed Execution speed is rather similar between these two. 
Lol, some comprehensive bs here. Sorry. In a nutshell, contrary to Ruby, Python has - two kind of object citizens - built-in and the others with different rules, like former can not be extended, modified aka refined - you have to keep all names of operator/iterator methods in memory, instead of writing them as they are - ruby blocks do not affect performance, this is a pure nonsense - pyenv is only a wrapper around pip and virtualenv, bearing all their irks - vim/emacs support for both languages in on par, including code completion. Ruby-mode and inf-ruby in emacs, vim compiled with ruby support plus Tim Pope's plugins. - python does not obey (or no longer) rule do thing one obvious way. Four ways of string formatting, many duplications in standard library solving the same problem etc. 
Doing batch HTTP requests while not relying on exception\-based error handling was one of the reasons I started \[HTTPX\]\([https://gitlab.com/honeyryderchuck/httpx/wikis/home](https://gitlab.com/honeyryderchuck/httpx/wikis/home)\). It could handle your map phase internally, arguably in a more reliable way \(it handles all requests in the same execution thread using non\-blocking I/O\). The wraps errors in the response object, and you can optionally raise them yourself by calling \`#raise\_for\_status\` \(I "stole" the API from python requests\). 
&gt;An endless range, `(1..)`, is introduced. It works as it has no end. Yes, it goes on and on, my friend.
Does it actually include infinity (1...)
I've seen some code which uses ROP &amp; do notation, but never encountered a case where `Dry::Monads::Do` would break it. To be fair, I do have some `Result`-returning code that passes blocks around, but it's complicated: * we use blocks to help us reuse some code * it's actually a workaround to help us deal with ActiveRecord * those operations don't use `Do` I'm just wondering, how do you use blocks in your business logic? How can `Do` break your flow?
So, I'm a new Ruby developer \(coming from Java\)... is it just me or is that style guide schizophrenic? There's so many contradicting concepts in the style. Spaces here because readability, no spaces here because readability. Some of the more mind boggling #good styles like this: # good result = if condition x else y end how on earth is that readable? The switch / when stuff is equally mind boggling from a readability / style perspective. Why no indents on switch? It's like we're stuck on 640x480 monitors still or something? Am I the only one \(aka, "other language developer"\) who feels this way or is this something that I just have to get used to?
Typo, I meant prepend. Here‚Äôs some background: https://www.justinweiss.com/articles/rails-5-module-number-prepend-and-the-end-of-alias-method-chain/
Unrelated to the style guide and not sure if you used that example for the sake of argument. Anyway, as a small pointer for readability of conditional assignments, try the [ternary operator](https://en.wikipedia.org/wiki/Ternary_operation). This transforms your statement into `result = condition ? x : y`, which to me is so much more readable. If you already knew about this forget I said anything :)
**Ternary operation** In mathematics, a ternary operation is an n-ary operation with n = 3. A ternary operation on a set A takes any given three elements of A and combines them to form a single element of A. An example of a ternary operation is the product in a heap. In computer science, a ternary operator is an operator that takes three arguments. The arguments and result can be of different types. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I didn't even know begin-else-end was a thing! 
`./doc` is where yard by default produces docs, is why it's ignored. There's probably some way to change where yard produces docs. Or you can put your manually created docs in any other directory of your choice. You are of course allowed to change the .gitignore generated by whatever tool generated it, it's just a suggestion of commonly good defaults. :)
Oh no, I meant vs code slow down. Thing eats up so much ram as is. Thanks for the tips though!
I like style of that example you gave, unless x and y are short enough that the ternary if makes sense. I also really dislike seen case statements (we don't have a switch) that have indented when parts (like the rails code base. Those case statements are horrible). 
Out of curiosity, how would you propose formatting the example you gave in a more readable way? I think it makes sense as is. The if...else part of that assignment is formatted the way you format if...else statements, so why not stay consistent like that? Especially in Rails (but also likely in a lot of other situations too), there's a good chance the condition won't be something really short (like "x==5"). Instead, it'll probably be something like "SomeModel.some_getter == 5" or perhaps "SomeModel.some_getter &lt;= SomeOtherModel.some_other_getter" so if you try to shove the if...else on one line it'll be a complete mess. Finally, if it's not a simple if...else, but an if...elsif...else, giving it some sort of compressed/one-line formatting would be absolutely horrible to read.
My opinion on all these style guides is that it is complete rubbish. Your examples are just the top of the iceberg
Seems so: $ RBENV_VERSION=2.6.0 ruby -e 'Inf = 1.0/0; puts (1...).include?(Inf)' true
Fixnum expands to Bignum, which is limited by the amount of memory you have. So no, if you made a big enough number then you'd just hit a memory allocation failure.
&gt; This makes me think that python isn't really object oriented Python feels like a procedural language with object orientation bolted on. It's not a big problem but I think it's messy
 begin # executed always rescue FooException =&gt; e # executed if a FooException is raised rescue # executed if any exception other than the above is raised else # executed if no exceptions were raised ensure # executed always end
&gt; rescue &gt; # executed if any exception other than the above is raised I forget this and always have to look it up, but I believe a bare rescue only rescues `StandardError`, not _any_ exception. 
That was fast! Have they supported prereleases before?
"The built-in function dir() returns a list of defined names in a namespace." So it would return the json python objects and methods, example: import json dir(json) ['JSONDecodeError', 'JSONDecoder', 'JSONEncoder', '__all__', '__author__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '__version__', '_default_decoder', '_default_encoder', 'decoder', 'dump', 'dumps', 'encoder', 'load', 'loads', 'scanner'] 
I like the style in that example. use the language more and you‚Äôll leave your java sensibilities behind. detaching myself from java-think was the hardest part of learning ruby (or any other language). besides, if you disagree, all you have to do is open an issue and debate it (but check prior issues first)
You're totally correct
Really solid gem. Nice work!
Exactly. See pry's `ls`. 
They've been hinting at a runtime AST and some of the new commits seem to be indicating it's a distinct possibility. That, and I asked Koichi and he said yes on Twitter. Perhaps we're finally getting some macro-like features. I'd bank on it being a result of JIT work. 
If it _really is_ UTF8, then either read it in UTF8 to begin with (which your app is_probably_ doing already), with eg `File.open(filename, encoding: "UTF-8")`, or use `force_encoding("UTF-8")`, not `encode "UTF-8"`. If the bytes you are reading are _not_ UTF8, you've got to figure out what they are, and if they are actually a good encoding to begin with or started out corrupted gibberish. This is my favorite (non ruby specific) post for getting a handle on encodings. http://kunststube.net/encoding/
constant scope is _confusing_ it's not just you. 
Style guides are usually _imperfect_ but far from complete rubbish. If you've ever worked in a code-base that has had many developers working in it without guiding principles on style ... it can be maddening to dive into when making a change or sussing out a bug. You waste valuable attention resources trying to grok the wild mish-mash of coding styles from the entire history of developers who've contributed to it instead of just reading the code and dealing with the logic. One of the great things about Rubocop is that it's tunable to your shop's own "flavor" of coding standards. The default config will be to "police" the code to the standards published in the two style guides. Then you can create your own .rubocop file and check it in to the project's repo, and tweak the settings to what you and the other developers on your team can live with. Introducing rubocop to our workflow (and having it enforced by our build process) has vastly improved the quality and maintainability of our code base. It's had a measurable effect in the reduction of defect tickets, and a climbing CodeClimate score. Additionally, it makes the code review process simpler (due to the reasons mentioned above about style/readability), and our reviews now just focus on the logic. And since there's an automated process ensuring our coding standards are adhered to, there's never any ambiguity and nobody has to say, "I really think you ought to structure that _this_ way". Our .rubocop file is a "living" document - that is, the developers on our team are always welcome to submit a PR to make a change to it if they feel it's cramping their style. There was a flurry of PRs to it early on, but it's been stable as-is for over a year. 
hi :wave: I work for heroku. We started doing pre-releases with Ruby 2.0 I believe https://blog.heroku.com/ruby-2-preview-on-heroku. We do them every year, though usually there's not one until october/november-ish when it's close to release time. I think they wanted to hit some real world apps with jit to get feedback early. Usually I only announce them on the changelog. I don't add them to the official ruby support docs because I don't want people to get the impression they should be running system critical things on a pre-release. Maybe I could add a section on it though.
I'm not sure I agree with the new naming convention. If an organization has a primary project I feel like the organization and the primary project for that organization should be the same. So it should be `/rubocop/rubocop`. Any chance we can get this as a new RuboCop rule?
There isn't a formal roadmap, but you can see what features have been added so far in the [2.6 NEWS](https://github.com/ruby/ruby/blob/v2_6_0_preview2/NEWS). I've written a few articles on features that will be released in 2.6, like [the JIT](https://medium.com/square-corner-blog/rubys-new-jit-91a5c864dd10), [endless Range syntax](https://medium.com/square-corner-blog/rubys-new-infinite-range-syntax-0-97777cf06270), [class naming rules](https://medium.com/square-corner-blog/new-class-naming-rules-in-ruby-bb3b45150c37) and [keyword exception arguments](https://medium.com/square-corner-blog/rubys-new-exception-keyword-arguments-4d5bbb504d37).
I have plenty of experience working with old code bases and yes, different code styles are messy but also not a problem. If the code works, you don't look at it. And if it doesn't work, then the problem is *never* the style. My biggest problem is that style-guides make developers focus on cosmetic issues which is a pointless exercise and a waste of man-hours in my book. For example; what is the functional difference between the following statements: &gt; do_something if !condition &gt; do_something unless condition Show me a programmer that can't translate between the two in a blink of the eye and I'll *FIRE* him because this should be a basic skill. But no, style-guides prefers one over the other and then programmers spend time on living up to a standard that doesn't bring anything to the table. Style-guides are as useful for a programmer as a business-suit is for a carpenter 
The Attributes features seem to add a lot of overhead. I wonder how often they are used, i.e. are we paying a lot for an abstraction layer that isn't used very often? Could it be opt-in or lazy instead of something which needs to be hand-tuned to opt-out? There are few Ruby gems which have more backwards compatibility baggage than ActiveRecord so none of this is easy work. My sympathies for all involved.
Cool. The reason for going the method_added route was so I can declare the asynchronous methods at the top of the class. I'll definitely look into this as an alternative.
Right ... you can definitely deal with an oddity here and there and make those little translations. It's a "death of a thousand cuts" situation. As for the particular example above ... that's not so bad, and very common for a programmer coming from a language that doesn't have the `unless` keyword. However, it _can_ lead to confusion and bugs when you're doing boolean logic with negations ... especially when the boolean logic is more complex than your example. In that situation ... no problem, but it is definitely more _expressive_ and immediately obvious if you just use `unless`. That said ... if you're happy with that particular construct in your code base ... just disable the cop in your `.rubocop.yml` file and you'll never be flagged for it. The point is that the things that rubocop (and the style guide) _tend_ to flag is things that tend to lead to bugs. Sometimes the choices made are arbitrary ... and sometimes they're for good if non-obvious reasons. For the more complex ones ... they're quite configurable. &gt; My biggest problem is that style-guides make developers focus on cosmetic issues which is a pointless exercise Not if you use good tooling. Rubocop integrates into many editors and will flag violations either as you write them or when you save the file. You suddenly see a green squiggly line under some code you just wrote and you just fix it right then and there. Soon, it becomes habit, and you never even skip a beat. We've even got a git hook that'll flag you when you try and make a commit with new violations ... useful in those cases where you did bulk file changes, etc... The bottom line is that a consistent style in the code base lessens the cognitive load when working in that code base, and when performing code reviews. Good tooling prevents it from being an undue burden to the developers writing code. Configurability means you can tweak the policing to match what "works" for your team. It's really a win all around. 
Thought it was worth posting Sam Griffin‚Äôs response from the article‚Äôs comment section: &gt; Given that you know I‚Äôve been working for over a year on fast_attributes to fix this, and you have access to that repository, I‚Äôm extremely disappointed that you did not include that in your comparison. In fact, it seems like you‚Äôre actively trying to imply that no work has been done on this on the AR side. I‚Äôm not entirely sure what the goal of this article was. 
There's an even better middle ground where teams agree to a common style and use it consistently without needing to use a tool like Rubocop.
Basically a rip-off of the work done by the crystal team lol. Not that I am complaining about Ruby getting a new feature.
Will this lead to some equivalent of "compile time" optimizations that type systems traditionally offer, or is it only meant to help prevent bugs?
I like both Crystal and Ruby, but this is not really very much like how Crystal does it. It seems more inspired by the optional type signatures in languages like Racket. 
Tbh, with all of that effort, it's better to just deploy using Python or Node imo if you need to ship and don't have a language preference.
Thanks. Is Christmas still the release date?
&gt; However, it can lead to confusion and bugs when you're doing boolean logic with negations I don't buy that argument. If true, languages without `unless` would be more prone to bugs and then we would have noticed by now. The reason for using `unless` is because it's there. Same with `{}` vs. `begin ... end` &gt; lessens the cognitive load No. It doesn't make a difference. The information the brain has to process is the same in the two sentences. It sees `if !` as a pattern just as it see `unless` as a pattern and doesn't spell its way through u-n-l-e-s-s. That's how the visual system works Anyway; within reason, I've never had problems with working with a heterogeneous code base. Bad or lacking documentation is a far worse problem and nothing annoys me more than buggy and undocumented but *style-guide* *compliant* code 
For me, Python is object-oriented, whereas Ruby is "stringly typed" in two important areas: module importing, and meta-programming. A second thing I really like about Python is that the language provides enough meta-info so support excellent IDE's like PyCharm. In contrast, the same company's Ruby IDE, RubyMine, will probably never be able to be a true IDE - simply because Ruby is so dynamic.
Just to prevent bugs. This won't change how the interpreter actually runs the Ruby code.
Another idea: Python is standardized enough that there are several alternate implementations and packagings. Maybe Ruby's "The MRI is the standard" approach has limited this kind of development.
Yup!
(1..).last =&gt; infinity
Not sure if I should be linking to the tweet or the stream since it hasn't started yet, but here it is: [https://www.twitch.tv/thejonanshow](https://www.twitch.tv/thejonanshow)
Use sequel. Nuff said.
Years ago I wrote something similar called ruby-lint (https://github.com/YorickPeterse/ruby-lint / https://gitlab.com/yorickpeterse/ruby-lint). While basic type checking is doable, supporting the standard library, C extensions, etc, is really difficult. ruby-lint used built-in definitions much like C headers to support these cases, and these were generated ahead of time. This sort of worked, but required me to generate [definitions for many libraries](https://gitlab.com/yorickpeterse/ruby-lint/tree/master/lib/ruby-lint/definitions). I wonder how Stripe will tackle this problem.
Yes ... completely true in your one simple example. Anyway, I'm not going to 
&gt; It sees if ! as a pattern just as it see unless as a pattern and doesn't spell its way through u-n-l-e-s-s. That's how the visual system works Yes ... completely true in your one simple example. You've chosen one of the less-useful constructs to argue over. &gt; Anyway; within reason, I've never had problems with working with a heterogeneous code base. Bad or lacking documentation is a far worse problem and nothing annoys me more than buggy and undocumented but style-guide compliant code. The only thing worse than that is buggy undocumented code with with lines 200 characters long, deeply nested blocks, inconsistent style and formatting, strained boolean logic and methods half a screen long. Bad code is bad code. Bad code is _worse_ when it's also challenging to read. Anyway, I'm not going to argue the merits of one style construct over another, nor am I going to evangelize to you or try to make "see the light". I'll simply say this. I've been writing code since the 80's and doing it professionally since the 90's. I've seen things that would make the stories [Coding Horror](https://blog.codinghorror.com/) sound like a fairy tale. I've also seen the other side of the coin. I've seen bad projects succeed, and I've seen good projects fail. I've worked without codified coding standards through _most_ of that time, but most places I've worked at at least have a "cultural" standard. I've also seen some pretty nasty code reviews where people get all hot under the collar because someone was critiquing all of their one-line-wonders that they were so proud of. For the last 5 years, in my current shop, we've been working hard to codify our coding standards. And the last 2 years we've been enforcing with automated tools. It's paid off in spades, and I'll never look back. Automation is _good_. The more we can automate the _mechanics_ of getting code written, reviewed and integrated, the better our velocity and quality. We've been measuring it carefully via multiple routes, and it's been _clearly_ a significant improvement for our engineering department. Defects are _way_ down, new features are implemented quicker, new-hires ramp up quicker, and code reviews only focus on the functionality ... the automation handles the nit-picky shit that tools like Rubocop are good for. On top of rubocop, we also run reek and CodeClimate. The focus on quality imbues a _culture_ of quality in the team as a whole, and we've all become stuarts of it. Leave the code nicer than you found it. If it needs a refactor ... refactor it. Don't leave broken windows, and be a good scout.
Yup ... been there. The thing is that when deadlines are looming and you just need to get this one last patch in ... coding styles tend to be the last thing enforced. The nice thing about tools like Rubocop is that they're configurable. Spend a little time tailoring the .rubocop.yml file to your team's liking and it just takes the human out of the loop. Integrate rubocop into your IDE and it warns you of violations as you work. Nobody has to every bring it up in a code review that you've not been compliant with the style rules, and there's no way to argue with the tool. It's compliant ... or it isn't. Automated tools process your code, and let you know. Then code reviews are just about the logic ... not whether to use an `if` block or a guard clause....
While [DataMapper](http://datamapper.org/) is no longer actively maintained, it was ahead of ActiveRecord in many ways (superior performance, true lazy loading, custom attribute type system, and available as a mixin).
``` Inf = 1.0/0 ``` nice lol there's also ``` Float::INFINITY ```
That's amazing. Today I learned. Cheers for the tip!
&gt; I'm less impressed by Python the language. It feels a lot clumsier than Ruby in many ways, and I often have to use 5 lines to say what I could have said better with 2 Ruby lines. Yep, Ruby can be very succinct if well-written. I tend to be a fan of readability over brevity, though often you can have both.
I, for one, am shocked that a direct database query returning primitive values outperforms an object relational mapper designed to be tied to front end forms
For me the readability aspect is terrible by moving it to the next line. As other have mentioned, a ternary statement is appropriate for that specific thing, but imagine it's "more complex" \-\- I found that the style guide was REALLY interested in keeping line widths as small as possible as the primary motivation. switch/when, moving that whole if to the next line to keep indents down, etc. That seems so silly to me. As a total aside, I mentioned that I'm going to be a "new" Ruby developer and I guess my question is already completely a non\-issue. My new job \(first day was today\) has an ENTIRELY DIFFERENT style guide. Basically imagine ruby was closure/lisp. LOTS of parenthesis... They require return statements to be like this: `if(condition)` `return(bool_method?() &amp;&amp; some_other_method_with_no_args())` `end` Very anti\-ruby and anti\-any style so far as I can tell. 
I wonder how this compares to https://github.com/egonSchiele/contracts.ruby
Contracts was one of my favorite ruby libs, its actually what made me start looking at elixir (Elixir has typespecs and pattern matching out of the box). I'm glad someone stepped up to the plate to maintain it
I‚Äôm currently learning ruby, can you explain what this means? All I got from reading the docs is that it doesn‚Äôt evaluate fully...
This is a recent personal project of mine. I wanted a minimal rss aggregator/reader to follow [ruby/rails](http://devfeeds.xyz/topics/ruby) news as well as [javascript/frontend](http://devfeeds.xyz/topics/js-frontend). I built it with Rails 5.2, Heroku, and Sidekiq. 
Does it help that the files I'm reading are files I'm making myself? I'm going to pages, copying text, pasting it in sublime text and just saving it as a text file.
Academia leans heavily towards Python, and they've done a pretty good job of developing a consistent, productive community around the tools they build. It's not that Ruby is incapable of being used in data science capacity, but open source communities are very momentum-driven, and the momentum in the academic/data science communities favors Python over Ruby. Two killer features about Python you didn't mention in your original post are PEPs and explicit dependency references. These seem like a small things, but having a single standard way of writing code makes a huge difference from a maintenance standpoint, as well as being able to import single functions and easily see where they come from.
This is fantastic. My life is so much better since adopting TypeScript. i hope work on this continues!
Sam Saffron replied to that comment: &gt; @Sean_Griffin sadly rails_fast_attributes does not fix this issue: &gt; &gt; Original example with rails_fast_attributes: &gt; &gt; Total allocated: 3476274 bytes (23259 objects) &gt; If anything it gets a bit slower :frowning: It does allocate 3000 or so less objects but the lion‚Äôs share are still there &gt; &gt; magic 252.326 (¬± 2.0%) i/s - 1.274k in 5.051335s &gt; ar 53.296 (¬± 9.4%) i/s - 265.000 in 5.033042s &gt; ar_select 152.251 (¬±11.8%) i/s - 756.000 in 5.084951s &gt; ar_pluck 1.427k (¬± 3.2%) i/s - 7.140k in 5.008473s &gt; raw 3.393k (¬± 3.2%) i/s - 16.960k in 5.004625s &gt; raw_all 240.900 (¬±31.1%) i/s - 1.044k in 5.104016s
(having some difficulty with the Internet atm, stay tuned üò¨)
They are doing fascinating things over there!
Ternary makes sense _only_ for very short and simple statements. It's rather hard to read otherwise. But please note that [the specific section you're referring to in the guide](https://github.com/rubocop-hq/ruby-style-guide#indent-conditional-assignment) has an alternate style that they also say is good: result = if some_cond calc_something else calc_something_else end The point of that specific section is the alignment, not the multiline if/then/else/end statements. The ternary operator is mentioned (and recommended to be used over if/then/else/end statements, _when appropriate_) elsewhere in the guide: [here](https://github.com/rubocop-hq/ruby-style-guide#ternary-operator), [here](https://github.com/rubocop-hq/ruby-style-guide#no-nested-ternary), [here](https://github.com/rubocop-hq/ruby-style-guide#no-semicolon-ifs), and [here](https://github.com/rubocop-hq/ruby-style-guide#no-multiline-ternary). re: your work's style-- That's wacky. It's not _the worst_, but it's not great, either. If you're feeling bold you might want to find out why they do it that way instead of the more common styles shown in this guide. But that could also be a dangerous question to ask. You might offend whoever instituted that style, or you might end up with the task of converting your work's codebase(s) to a more "normal" Ruby style.
&gt; All I got from reading the docs is that it doesn‚Äôt evaluate fully... That's correct. `a` in `a = [1,2,3].lazy.select{...}.map{...}` isn't an Array, but only a description of what operations to execute. Internally it might look like `@operations_to_perform = [[:map, proc1], [:select, proc2]]`. Once you call a method which requires the Array to be evaluated (`#take`, `#to_a`, `#[]`, ...) it does so by iterating over the array once(!) while taking `@operations_to_perform` into account. This is useful because it not only saves iterations, but also allocation (traditionally every call to `.map`, `.select`, ... would allocate a new object). You can also rewrite the call sequence in order to make some optimizations (I'm not sure whether this is actually done): E.g. `.map(&amp;f).map(&amp;g)` should be the same as `.map(&amp;f.compose(g))`
Actually, with rdoc you *could* merge the API documentation from multiple projects together. I haven't done it but since rdoc allows storing and loading API documentation data from a backend store, it should be possible.
I'd say that Ruby _allows_ you to write better code than Python, but it requires skill and learning to do so. Sloppy grad students will write equally crappy code in both languages.
&gt; I really wish someone would step up towards being a maintainer. Why don't you do it?
Yes, but not in data science. It will, however, give a leg up to Ruby in terms of losing its shackles of being hard to scale and non-performant. Its a gamble though. Few companies ever get to the point where scale and performance are big deal.
I came to know that AWS Lambda doesn't support Ruby only after creating the skill. So that I tried to deploy with the same code. In future, I surely consider doing Alexa skill in Node.js.
Oh no, I'm not saying it's your fault or anything. I honestly wish they would support Ruby as a runtime language.
May consider adding email subscription too?
Sloppy isnt fair. They have 14 hours of other crap to do that day
Do you mean like a weekly update of links sent to your email? 
Is sorbet something that everyone can use now?
I like this "Rails 3x3" term. I guest that's not impossible :)
I found implementing the style guides on my codebase useful especially when developing from a 13\-inch screen. Sometimes I would have half the screen be my code and the other half be the web browser showing my app. The guide is just that \- a set of rules that can be followed at your choosing. In the course of refactoring some ruby code I found that some of the enforced styles cannot be met because long variable names, for instance. To find a better name would imply a 700\+ line pull request for code review of which my colleagues won't be able to review properly. I like the guides as a baseline, but of course we shouldn't be breaking said styling rule all the time. If so, this rule should be relooked at...
For the same reasons other people don't do it. Busyness, other projects, life in general.
Are you positing that the typechecker will not be useful without typing on the underlying libraries or that it‚Äôs a requirement?
Contracts operates at runtime. This is a static type checker. See https://sorbet.run for examples.
sloppy was referring to the state of the code, not their well-intentions.
Looks weird a bit. But the idea itself is great :) 
Thanks. I'll take a look at `rdoc` again.
The emphasis is on *how much* the raw database query outperforms Active Record. If people are aware how much memory Active Record allocates, then they might appreciate more all the work Jeremy Evans does to make Sequel, an ORM which solves the exact same problems as Active Record, as performant as possible. I posted the Sequel benchmarks in [my comment](https://discuss.samsaffron.com/t/an-analysis-of-memory-bloat-in-active-record-5-2/422/2?u=janko_marohnic), which shows Sequel allocating 5x less memory and being 5x faster than Active Record (or 10x faster with `sequel_pg` gem loaded).
Unfortunately the `rubocop` organization name is taken (https://github.com/rubocop), so this wasn't an option. The org has no projects and no public users, so maybe someone would have been willing to give it to us, but I don't care about the name that much. 
Consistency is its own reward. ;-) Anyways, everyone is entitled to an opinion and frankly I don't care much about yours (and clearly you don't care about mine). If you think the guides are rubbish just ignore them instead of engaging in pointless discussions that have been scientifically proven to lead nowhere. :-) 
Yes sir. üòÄ
Fans of DataMapper may find [Hanami::Model](https://github.com/hanami/model/) or [ROM](http://rom-rb.org/) more to their liking.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://rom-rb.org/) - Previous text "ROM" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Nice, going to try it in one of my smaller upcoming projects.
Feel free :) 
No, I'm just wondering how they will tackle this. Various past Ruby type checkers always had serious limitations, so I'm curious if Stripe actually tackled those problems.
&gt; I don't care much about yours (and clearly you don't care about mine) What ?! This is your first comment in this thread and your opening is an insult ? Go away ! 
&gt; You've chosen one of the less-useful constructs to argue over I could do the same argument with a lot of the other stuff style-guides are made of: `{}` vs `begin ... end`, spacing between parameters, indentation, etc. &gt; Bad code is bad code If you have a developer writing the horrible code, you're talking about, why not educate him ? Or fire him ? You would do the same if you had a carpenter that did a piss poor job I'm probably a little older than you and began programming in the 70's and got my first job as a developer in the 80's. To this day, I've never come across a bug that was caused by a developer not following the guides. On the other hand: I'm current working in a company that use rubocop/pronto and some other tools, and the error rate is about 25% according to management (that's after all functional tests have passed). My opinion is: To hell with the style guides. It's a waste of time. Focus on real problems instead !
¬Ø\\\_(„ÉÑ)\_/¬Ø you do you I guess. It takes more than linting for quality software. A 25% error rate is frightening ... sounds like you guys have quite a lot of things to work out. I can say it's a valuable part of OUR process. Our error rate it's &lt;1% for our team of 7 in-house developers and 5 remote contractors and 5 QA engineers.
Yeah, seems awesome, first time hearing about it, despite having used every single competitor libs. 
&gt; 7 in-house developers and 5 remote contractors and 5 QA engineers That's 0.4 QA engineer per developer or even higher if the contractors are not full time. We have 0.1 QA per developer. The error rate should also be contrasted with productivity because anyone could produce error-free code if they had an eternity to do it so it is difficult to measure, but we're going out a tangent here... 
If you write code like this, please for the love of god make sure it is extremely well documented, and preferably very carefully contained to a small module or class. I have worked on legacy rails apps touched by upwards of 100 devs over the years, and invariably stuff like this turns into the ‚Äúhere be dragons, I don‚Äôt know what it does but please don‚Äôt touch it because it‚Äôs super critical‚Äù kind of code that you really really don‚Äôt want in your codebase.
QA isn't dedicated to our team, they also cover the front end and systems integration. As for velocity ... We typically have 2-3 releases per week. Code is constantly marching down the pipeline. We've got a well groomed backlog and all developers (including contractors) are empowered to push back on the PMs if requirements aren't well spelled out. We typically have about a quarter's worth of shovel-ready work in the backlog at any time. As our code base has become cleaner, our velocity had consistently improved. We took a hit up front, as there was much refactoring to be done, but it has proven to be well worth the effort. Every quarter, we schedule 25% to platform maintenance and refactoring and 75% to new development. This was impossible before, as the disruptions from escalations made planning a fruitless exercise.
So, unless I'm missing something, it doesn't seem like this solves the problem. prepend Asynchronize asynchronize :foo gives an error that the asynchronize method is not defined, since the Asynchronize module isn't included till afterwards. Still exploring other ideas, but for now the plan is to have it not override method\_added by default, and allow an option hash to be passed to add it from the asynchronize method.
The point of the article is that's it perfectly okay to use metaprogramming in your applications. And that's true. But very often, metaprogramming either creates an implied framework that will eventually become a maintenance hazard, or (more likely, especially when written by less experienced developers) it ends up being a re-invention of something that's built-in. Or to put it lightly, there's a lot of very questionable design decisions in this article. &gt; I need to run queries on the attributes, so I couldn‚Äôt store them as a JSON string. Which RDBMS is being used that doesn't support JSON queries? Both postgresql &amp; mysql can do this. &gt; I could create a new table portfolio_tags with a column tag to store the value and a portfolio_id to refer to the portfolio If you have a `belongs_to` in your record, it is no longer a [tag](https://en.wikipedia.org/wiki/Tag_(metadata)). In fact at this point the author is halfway to the [Entity-Attribute-Value](https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model) pattern (but doesn't get there). &gt; Now that I have a place to store arbitrary attributes, where should I place the data source for the attribute names and values? ... Using the meta programming magic of ruby, I write code that dynamically generates these methods for me. This is how: **Iterate over the entries in config/locales/en.yml**. Please don't ever do this. A file for _English translation strings_ should not be used to determine which methods you'll create as attribute accessors. Different keys in that file then lead to different behaviour in those accessors - which means there's an implied object class screaming to get out here, and should be recognised as such. The missing abstraction though was very simple: object classes. The writer has optional single_select and multiple_select attributes with slightly behaviour for each. That's crying out to be recognised as two model classes off a common base. What's more, if you do this in Rails the type then flows through to things like automatic partial selection in views, allowing you to simply `render @portfolio.tags` rather than buggering around with conditionals. But really all of this could probably have been avoided by reading https://stackoverflow.com/questions/22667401/postgres-json-data-type-rails-query and using [store accessors](http://api.rubyonrails.org/classes/ActiveRecord/Store.html). 
‚¨ÜÔ∏è This. 
Also, I'm not seeing any problems with calling super from an asynchronized method, but there were some unexpected problems when the method referenced by super had been asynchronized.. That's been fixed. Let me know if I missed any edge cases? [https://github.com/kennycoc/asynchronize/blob/5c91de9c7755cd0a68a66a49f0af80b6bde4dbd5/spec/spec.rb#L137](https://github.com/kennycoc/asynchronize/blob/5c91de9c7755cd0a68a66a49f0af80b6bde4dbd5/spec/spec.rb#L137)
Not sure what you have in mind for exceptions.. Currently it just handles exceptions how a thread normally would. I suppose we could catch it and pass the exception object to the block, or save it in a thread var, but that doesn't seem like it'd be very intuitive when using it..
While at RubyKaigi, I took a bit of time to refresh a little Kiba ETL benchmark I have (https://github.com/thbar/kiba-ruby-benchmarks), which I use to monitor evolution of raw performance &amp; compare ruby versions. My first round of testing seems to show Ruby 2.6.0-preview2 gives a 17.7% improvement over Ruby 2.5.0 (with JIT disabled) on Mac OS X. JIT enabled though gives a 6,6% regression (but @k0kobun, JIT author said he will check that). This is performance you get for free! In general, a lot of talks at RubyKaigi 2018 were focusing on memory + performance improvement in Ruby, more will be shared later. This is all pretty exciting :-)
What's insulting about this? I think your first comment on the thread called the work of many people (including mine) rubbish, so your current remark is rather odd. Anyways, apologies if you felt insulted. 
Any benchmarking on Ubuntu available?
Wow, nice! This is great news. I think JIT will be a winner by the time 2.6 is final... might not be a total game-changer until 2.7, but I think the next few 2.6-preview releases will bring some smiles 
Yes that is very important. That is why I mentioned it'll be only 10&amp;#37; of your codebase. I just checked, I have 25 comments out of 99 lines in total.
Some of what you say is valid but there are a lot of others things that get in the way of optimizing Ruby. This post by Charles Nutter is a bit old and a couple of things have been resolved but it gives a good overview of the costs of having a dynamic language like Ruby http://blog.headius.com/2012/10/so-you-want-to-optimize-ruby.html?m=1 
&gt;But really all of this could probably have been avoided by reading [http://guides.rubyonrails.org/active\_record\_postgresql.html#json\-and\-jsonb](http://guides.rubyonrails.org/active_record_postgresql.html#json-and-jsonb) and using [store accessors](http://api.rubyonrails.org/classes/ActiveRecord/Store.html). Not true. I am already using store accessors. And even if I did use json to store the data it doesn't solve the problem of custom getters/setters for the data. I would still need a single source of truth for this data. &gt;Please don't ever do this. Overloading a file of *English translation strings* to configure attribute accessors is playing with fire, to say the least \- and it's entirely counterintuitive for any subsequent developer who will be expecting to find accessor names either implied by the db schema or declared in the model code. A translation file is probably the last place I'd look. And then there'd be a lot of swearing. That is why I wrote a lot of comments in both the model and in the translation file. &gt;The missing abstraction is very simple: object classes. The article has optional single\_select and multiple\_select attributes with different data and slightly behaviour for each. That's crying out to be recognised as two model classes off a common base. What's more, if you do this in Rails the model type then flows through to things like automatic partial selection in views, allowing you to simply render @portfolio.tags rather than buggering around with conditionals. I can have 2 classes. But I have around 100 attributes. How would I read/write each of them, if not dynamically.
I'm not sure types are the most important thing. A sophisticated Ruby implementation can determine most of the types dynamically, and then at runtime the only cost is to 'guard' that the types are still correct, which can be just a word comparison. I think things that are more significant that make Ruby slower include: * more complicated semantics, such as overflow on integers * late\-bound dispatch * idiomatic code is very high\-level and uses a lot of metaprogramming
Could http.rb be adopted as the default solution instead of Net:Http
You could definitely run it on Ubuntu. I will CI the repo and try that out.
You may find https://crystal-lang.org/ interesting
The problem is they are. But no one is willing to change. Sam pointed out a problem with Rails and mainly Active Record and look at the amount of backslash, if the community together does not accept they have a problem nothing will ever change. 
Hey thanks for the notes, they are much more structured than mine üòÅ (I was at RubyKaigi too) Also Noah's talk was epic! Definitely going to watch it again once the videos are up. 
Yeah, that's a good point, and also -- writing a good jit compiler is a massive undertaking. JavaScript has good fast jits because massive effort has been put into it from many big companies. Ruby just hasn't had nearly the same amount of effort put in to it, though I believe jit compilation is coming. It would be interesting to see how fast Ruby could get with the level of investment js has had, but I don't think that's ever going to happen.
Did a quick overview on those points 1. [Integer overflow?](https://www.interviewcake.com/concept/java/integer-overflow) Isn't this handled? Its just allocating some size based off the value it was set. This is nice, right. If on Java or C, sometimes while learning and exploring those langs, you tend to specify types as "long" where as it should have been "int". It happens a lot. So Ruby is automatically handling this for you. So, how will this contribute to performance bottleneck? 2. [Late-bound dispatch](https://lukasatkinson.de/2016/dynamic-vs-static-dispatch/) Basically it is inheritance, polymorph..The crux of OOP Many languages have that, like python and as mentioned in the comments, JS. Even C++. But what makes its implementation in Ruby a concern? 3. Idiomatic code I am not sure if following the absolute best practices or almost aligning with it, would contribute in exponential increase in comparative performance. 
Do know about that, have dabbled in it little bit. But that is not Ruby.
&gt; So Ruby is automatically handling this for you. So, how will this contribute to performance bottleneck? Well the bit where it automatically handles it for you is the bottleneck. &gt; But what makes its implementation in Ruby a concern? Ruby programs tend to include a lot more method calls than other languages. It's fixable using the same techniques as other languages, but these fixes require you to always have access to state to store a cache in, which is not easy inside a core library method. &gt; I am not sure if following the absolute best practices or almost aligning with it, would contribute in exponential increase What do you mean by exponential increase? I did a lecture about these points if you want to know more https://www.youtube.com/watch?v=b1NTaVQPt1E&amp;list=PLJq3XDLIJkib2h2fObomdFRZrQeJg4UIW
This was a nice read.
At this point Net::HTTP is probably here to stay in the Ruby standard library. But I would like to see people reaching more for http.rb.
I wish they could have included it in standard lib, and recommend using it, and later depreciate Net::HTTP. 
Have you considered using RuboCop's auto correct feature?
Yeah, me too. I wish I didn't have to spend all that time figuring out how to make streaming in [Down](https://github.com/janko-m/down) work with Net::HTTP and open\-uri, only to realize that there exists a much cleaner and better alternative. I would like to be able to spare other people that step.
Yeah, I really don't see how all this defensiveness is useful. It seems that whenever someone points out a problem in Active Record, people tend to reply with something like "Active Record is a tool, you should know when to use it and when it might not be good fit". But if Active Record doesn't scale well with the number of records, then I feel reluctant to reach for it to begin with, because I don't want to be painted into a corner later on. I know that developing an ORM is difficult; it's really a lot of code, especially with all the adapters, and people have high expectations. I think no\-one is blaming Active Record developers for lack of performance, Tenderlove, Sean Griffin and others have put a lot of quality work into it. I would just like if Sequel and ROM were presented as equal alternatives in the Rails docs, so that people consider using them more. That's again what I wish for other people based on my own experience, as I spent a lot of time learning and investing in Active Record before finding out that Sequel was better, and wished that somebody had told me about it sooner. Now that I said it, I think I'll try updating the Rails docs.
[TruffleRuby](http://chrisseaton.com/truffleruby/) is trying to do this sort of thing via Just In Time compilation using Graal.
Interesting talk. Couple of points I took away 1. Caching JRuby does not cache methods calls. So everytime a compiler sees the same method, it has to do AST generation and get the result. If it was cached, it can just look up in its memory and get those results, it can be fast. By extension, this problem also applies to CRuby. 2. Compartmentalization JRuby has a beefier definitions of basic core library methods. It attempts to handle everything, every scenario. If instead it broke up those scenarios into different multiple methods, then the compiler would have an easy task of generating an AST, which would be simple in construction, hence would run faster and consume less memory. Again, I assume it is same for CRuby. Nice to know you were involved in building [TruffleRuby](https://github.com/oracle/truffleruby), so you may know this 1. Why was then these decisions not applied, was this a deliberate design decision? Something to do with the core Ruby philosophy of making to write code easier? Or it was plain poor planning? Both for Jruby and CRuby. 2. I found a [thread](https://www.reddit.com/r/ruby/comments/7hhgrt/where_is_the_work_on_ruby_3/) discussing Ruby3x3. Things which you suggested and demonstrated which yields good performance, are not mentioned. Again is this because it is really really tough to reconstruct the core library, atleast at this stage or it would be just better to use a different type of compiler, JIT. Okay, now the points you make are interesting. I was wondering if these were applied to actually programming solutions, would it yield results 1. Basically memoization should be default in any Ruby program. 2. Any complicated method, should be broken to different pieces. Correct?
Looks like SLANG for Ruby.
I know I'm beeing a pessimist, but all this feels like is coming a few years too late.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/github] [Page TOC Now in Gem markdown\_helper](https://www.reddit.com/r/github/comments/8oa6pg/page_toc_now_in_gem_markdown_helper/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
neat!
Try to model a system you are an expert of to practice OO. It could be as simple as modeling your family, where each person gets a class and has relationships. Start concrete have a myself class, a dadclass, etc. then you‚Äôll start to realize the abstractions. All these people have names, let‚Äôs pull out a nameable module, id suggest you try to use composition (modules) instead of inheritance to practice. If people are boring you could do something else, but this type of exercise is invaluable when you are learning, just make sure you model something unambiguous that you are an expert of so you can focus on the software.
Really cool, too bad no support for blocks
If this works as described, it is (will be?) amazing. Not sure if op is affiliated with the project, but some questions I have when reviewing it quickly: - Is this project stable enough for production? - Versioning doesn‚Äôt appear to be using semver. What changes can be expected when versions are bumped? - Is there a project roadmap anywhere? - How does performance compare to native C code? I imagine the answer will probably be ‚Äúsimilar but it depends on the complexity of your code‚Äù but asking anyway. Apologies if any or all of these are answered elsewhere.
Great article but everything in lowercase was very distracting. 
I'm wondering how much this is supplanted by ruby 2.6's ability to do JIT.
JIT is probably not the answer to everything. Depending on how JIT is implemented, most of the calls may still be dynamic. Whereas here it seems that you have to manually specify some types, thus i'm guessing no overhead of dynamic calls everywhere.
&gt; Why was then these decisions not applied, was this a deliberate design decision? Something to do with the core Ruby philosophy of making to write code easier? Or it was plain poor planning? Both for Jruby and CRuby. Well figuring these things out was original research done in 2013. I don't think the problem was as clear to JRuby or CRuby back when they were implemented. &gt; I found a thread discussing Ruby3x3. Things which you suggested and demonstrated which yields good performance, are not mentioned. Again is this because it is really really tough to reconstruct the core library, atleast at this stage or it would be just better to use a different type of compiler, JIT? The things I suggest are quite complicated to implement. They haven't gotten there yet in JRuby or CRuby. They might, with time.
I guess it helps, but it doesn't answer the question. But you can make sure SublimeText is saving as UTF8? Who knows what Pages does, let alone copy paste between Pages and ST. 
I think it's worth pointing out that some of the things AR is doing (keeping a couple copies of some data) are to provide _very useful_ features like dirty tracking. Dirty tracking is pretty sweet. I'm sure there is room for optimization without losing features, _and_ there ought to be a way to turn off Dirty tracking if you don't want it (I'm pretty sure there is although not sure what it is; would be an interesting benchmark with full AR models but all the 'extra' features you can turn off turned off). But in _most_ cases I think the time you spend waiting for the database justify the extra features that take extra cpu/ram. 
&gt; maybe i should pull request rails Or you can just write a scope for `without(assoc)` and put it on your ApplicationRecord. Or write a one-file probably 6-line gem that monkey patches ActiveRecord::Base if you want, heh. 
&gt; Or you can just write a scope for without(assoc) and put it on your ApplicationRecord. My thought exactly. class ActiveRecord::Base def self.without(asso) left_join(asso.to_sym) .where("#{asso.to_sym}": { "#{reflections[asso.to_s].foreign_key}": nil }) end end 
Release it as a gem to add `without` to AR, heh. 
I don't want to be like [leftpad](http://www.haneycodes.net/npm-left-pad-have-we-forgotten-how-to-program/) though. ... MIT license.
Well performance has been improving continuously since at least 1.8.7, the pace is only increasing. A lot more is about to happen :-)
https://www.reddit.com/r/ruby/comments/8nzu66/httprb_is_great/
What are the advantages of Rubex over using Crystal?
This article covers it far better than I have [https://medium.com/rubyinside/how\-i\-built\-timeasure\-part\-1\-motivation\-method\-wrapping\-1304cf841206](https://medium.com/rubyinside/how-i-built-timeasure-part-1-motivation-method-wrapping-1304cf841206)
Yeah I agree. What I was getting at is the block form has a default of "fire and forget" style. Any exceptions within it are going to disappear into the ether because the thread is not returned.
ruby 2.6 JIT isn't anywhere close to making all or even most ruby as fast as C. For just one thing, the JIT is still a work in progress. 
Can you use Crystal to write C extensions for MRI?
Apparently you can, but need a sort of bridge between MRI's C interface and Crystal's Object Model. https://www.slideshare.net/AnnaKazakova/how-to-write-ruby-extensions-with-crystal
Consider using Nim or Rust for native extensions
i would recommend starting by learning the basics of OOP in ruby. You can google for tutorials in that pretty easy. If you want to get a deeper understanding / be able to understand random libraries easier, look for resources about metaprogramming.
Does your benchmarker take into consideration the warmup time required by JIT? First runs will be slower as the code is compiled and optimisations (of which the Ruby team said they have hardly any at this point in the release cycle; so it'll only get better) are applied. I've seen a lot of benchmarks show "bad" performance when using JIT but don't consider that the first run is a bit sluggish, and then response times get *much* faster after that. This kind of tradeoff will be a no-brainer for Rails apps since once warmed-up they can stay in the runtime state indefinitely.
Please, tell the way Nim could be used to write extension for Ruby.
I belive, name "Rubex" is like "Pyrex" for Python, which were mostly replaced by fork Cython, but still developed. 
Hey, funny\_falcon, just a quick heads-up: **belive** is actually spelled **believe**. You can remember it by **i before e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
http://www.bootstrap.me.uk/bootstrapped-blog/nim-for-the-discerning-rubyist
Hey there! It's cool that you felt like making a gem, but when doing so it's really quite essential that you do a few things. 1) Write tests. This cannot be stressed enough. The behaviour of your method is not obvious, and without test-cases, no-one should feel safe using it. Right now, your implementation strips newlines from the input string, which I would not have expected. It also will not work for tab characters. 2) Stick with established conventions. Ruby uses American spelling, the name should have been "Marginalize". 3) Make core extensions optional. I know it seems smart to have `"mystring".foo"`, but many people prefer explicitly invoking dependencies, eg. `Marginalise.marginalise(string)`, as it makes moving away from the dependency a lot easier, and less risky. 4) Try to avoid nested if conditions. it makes following the logic extremely hard, and usually a more elegant solution lingers somewhere out of sight.
Not OP, I would like to know those answer as well.
I'll agree with the other stuff but &gt; 2) Stick with established conventions. Ruby uses American spelling, the name should have been "Marginalize". NEVER! RULE BRITANNIA. And on a more serious note I think this is a reach. I have never seen it mentioned anywhere that American spelling is preferred aside from this comment.. 
[removed]
I hope this project lives... It has a huge potential.
Except that the standard library is full of methods that prove it so. `capitalize`, `unicode_normalize`, `rationalize` etc.
You don't **have** to do it. But it's easier for everyone if you follow convention. What's the argument not to use it? If you're really adamant on using British spelling, just alias it so both work.
That was 4 years ago. A big debate about spelling of one word and mention of the upcoming 1.0 version. 4 years later we still haven‚Äôt hit 1.0. Kind of amazing that the tool is actively developed but still not at 1.0. Maybe they just don‚Äôt care anymore. 
Does this actually improve performance? Apart from running methods in threads, do you provide any kind of synchronisation? You might like [https://github.com/socketry/async\-await](https://github.com/socketry/async-await)
So I guess that's the difference? This project is specifically focused on writing MRI C extensions. If you want to write a relatively small MRI C extension, this might be of interest. If you want to write a relatively large program in a ruby-like language that compiles to C (and has nothing to do with MRI ruby), Crystal might be of interest. If your needs are somewhere in between, then perhaps you could consider both. 
This is so great. Thanks for the link! This looks so much better than what I'm doing ha
No, there is no performance benefit other than running the method in its own thread, which may help or hurt performance depending on the situation. It literally just takes your method and wraps it in Thread.new. I do make a comparison to async await in the readme. As opposed to similar projects, this is meant specifically to not add an extra layer of abstraction on top of the threads, just to make it easier to use regular threads :)
Fair enough. Yeah, I read the README. So, what's the purpose? Not just what it does, but where are you using it?
Not easier to use, but less typing
It's possible I'm misunderstanding the purpose of this gem, but is this word wrap? If so, there's a clever trick for doing this in a line of code. This should word wrap at 60 characters: `str.gsub(/(.{1,60})(\s|\Z)/, "\\1\n").strip` (this isn't my creation, just a snippet I stumbled across somewhere or other).
I agree, this does seem possible.
&gt; the tool is **actively developed** but still not at 1.0. Maybe they just **don‚Äôt care** anymore. How "active developers" can stop to care?.. As far as I can understand, there are just different approaches to what 1.0 means. Everybody became used to "Chrome 48 got updated to Chrome 57, one button changed", and libraries like ROM reaching 4.0 being still in "highly experimental" stage. For libraries with more old-fashioned developers, it is common to have "stable and useful" 0.4, while 1.0 means something of great importance, like "now there is API stability guarantees, book written, and IEEE standard proposed". Bozhidar Batsov (creator and chief maintainer) just announced the plan towards 1.0, and moving to separate GitHub organization is part of this plan.
I'll try to summon Rubex's author, he is my fellow SciRuby maintainer.
I‚Äôm sorry. I wasn‚Äôt clear at all on what I meant by that. I was meaning maybe they just didn‚Äôt care if it reached 1.0 or stayed at 0.x for however long. I know they‚Äôre actively developing it and it‚Äôs an awesome tool used by many so the 1.0 or not yet 1.0 doesn‚Äôt seem to matter that much, or maybe it‚Äôs the opposite. You make valid points as to what a 1.0 release should mean but I find it off that RC in its current form wouldn‚Äôt warrant a 1.0 release. Either way it‚Äôs great and wasn‚Äôt my intention to say otherwise or that the devs don‚Äôt care. :)
Hello, I'm Sameer, the author of Rubex. To answer some of your questions: * 'Simple' C extensions are usable via Rubex and you can make them work easily. However, something more complex might be tough to code and debug since the only way to debug rubex programs is to dive into the C code and see the C comments about the corresponding origins of the given line of C code. There's no GDB integration yet. * Speed should not be an issue since in most cases Rubex will compile to very optimized C code. There might be some overhead due to temporary variable allocation on part on Rubex but I don't think it will be much of an issue. * You can see the project roadmap in the github milestones: [https://github.com/sciruby/rubex/milestones](https://github.com/sciruby/rubex/milestones) * I'm thinking of using semver post v0.2 release since that's when I expect people to start using it more. Until then you can expect some abrupt changes in the API \(july end\). * JIT won't affect this in any way since JIT compilation affects the Ruby code directly, not C extensions. See Kokubun's talk at RubyConf/Ruby Kaigi for details. * A very important goal of Rubex is to make it easy to create APIs for C extensions of Ruby gems which look like Ruby public APIs. This will allow users to easily share the C backend of their gems with other gems via a Ruby\-like API. This functionality has already been planned and should be ready in the coming weeks. I'm always open to any other questions by people. Do email me if you have any doubts. I recently spoke at RubyKaigi 2018 on Rubex : [http://rubykaigi.org/2018/presentations/v0dro.html#jun01](http://rubykaigi.org/2018/presentations/v0dro.html#jun01) Also, thank you Victor for pointing me to this thread :\)
Can you show both of the outputs?
With the print statement comes out like this ÔºªÔºª3, 7, 109ÔºΩÔºΩ ÔºªÔºª3, 7, 109ÔºΩ,Ôºª7, 3 , 109ÔºΩÔºΩ With the solutions array it becomes ÔºªÔºª7, 7, 97ÔºΩ,Ôºª7,7,97ÔºΩÔºΩ I am not at the computer at the moment. That is basically what it outputs. 
So, I'm working on a distributed hash table for ruby, and found myself writing a lot of methods where I was immediately calling [thread.new](https://thread.new). I wanted to remove the repetitive boilerplate, and figured other people might find it useful :\)
I‚Äôd need more output for me to determine the pattern. From what I have, my suggestions are to - reduce the size of your three prime arrays so the entire process is easier to reason about - put a debugger (pry, byebug) in just above the print line and interrogate the difference until the problem is clear to you
"write generic C-compatible library and use ffi to bind with" is not "write extention for Ruby".
The thread is always returned :\) I'll change the documentation to make that more clear
OK, folks; why the down-votes? Do you have a better modern ORM candidate for DataMapper folks that _isn't_ ActiveRecord?
What advantage does this have over the current work going on here? https://bugs.ruby-lang.org/issues/13618
^The linked tweet was tweeted by [@keystonelemur](https://twitter.com/keystonelemur) on Jun 04, 2018 18:12:50 UTC (0 Retweets | 1 Favorites) ------------------------------------------------- It's time for a new problem! This week, we'll look at getting the hierarchy of HTML headers. Gist to follow, post your solutions as replies to this, or comments on the gist! [Attached photo](https://pbs.twimg.com/media/De3cme0UYAUIh6c.png:orig) ------------------------------------------------- ^^‚Ä¢ Beep boop I'm a bot ‚Ä¢ Find out more about me at /r/tweettranscriberbot/ ‚Ä¢
Starting something new: Problem of the Week! (PotW) These problems will have multiple stages of difficulty as well as accompanying tests to try it out against. Have a problem idea? Feel free to shoot me a message. As with the tip of the day, I _might_ have a backlog of content stashed to use for dry weeks :)
There is an extensive discussion on that issue which should answer your question but feel free to let me know if you have further questions.
I suspect it's not going to be Ruby 1.29 - that would be over 15 years out of date.
Are you just using Ruby/Rails for a CRUD API? While it's good for that, you can make a CRUD web API in just about any language, but yeah, Rails is good for it. Ruby is indeed a nice language to work with, but you should also think about your other client applications (web, mobile, and desktop) and make sure you're picking appropriate tech for them. Look into what authentication mechanism you want to use, I'd recommend JWT. For database, Postgres is usually a pretty easy recommendation, but you might be swayed by some of the others (MariaDB, MongoDB), depending on your exact needs. Make sure you're hosting your code in some sort of version control (GitHub, GitLab, BitBucket). Have fun!
Oh wow! I guess I just thought that was the current version :[ I suppose I should confirm the version with them rather than assume!
I'm liking: include 'nokogiri' def header_hierarchy(html) Nokogiri::XML("&lt;wrap&gt;#{html}&lt;/wrap&gt;").xpath("//*[starts-with(name(), 'h')]").collect do |h| case h.name when 'html' '[h0] ROOT' when /^h(\d+)$/ "#{' ' * [0, $1.to_i - 1].max}[#{h.name}] #{h.inner_text}" end end end 
great problem though :)
This is obviously a poor solution and unruby like. I am going to come up with another solution.
2.5.1 is the current stable version.
2.5.1 is the current stable version.
Semicolons everywhere
I have my semicolon/colon key flipped, one of the best things I did when I started focusing on Ruby.
Spend two weeks learning ruby foundations before starting into rails. Wverything makes much more sense. 
It‚Äôs more likely that‚Äôs 1.92 That‚Äôs still old as fuck, but definitely a huge improvement over 1.8x 
Are you checking out any courses on Udemy? 
I was planning to use Team Treehouse, but I will probably browse other options too.
One point two nine..?
I think I may be wrong... I need to figure that out in the morning...
Almost 20!
I could make the super hard version of this which is to generate a table of contents (ul/li) from headers and put target anchors above each header. The text version leaves itself open for Regexp a bit too much :P
&gt; Spend two weeks learning ruby foundations before starting into rails. Wverything makes much more sense. Spend another 2 months learning OOP design and best practices and then spend another month learning metaprogramming with Ruby. Rails will make actual sense!
So I‚Äôm not 100% sure if that‚Äôs actually the version that you‚Äôre using, but as other people have mentioned‚Äîit‚Äôs a bit dated. However, my experience thus far transitioning from py to rails (using ruby version 2.3.3) has been awesome. They‚Äôre really similar in a lot of ways, and though some of the syntax seems a little less sensible at first, I find that the formatting is really forgiving. Plus, there are tons of gems (which are chunks of ruby code meant to do a specific task) that will eventually be something you come to love. I realize you said ruby specifically, and that might be the extent of the position, but I‚Äôd be willing to bet that you‚Äôll eventually delve much deeper into rails because it‚Äôs amazing. And as for a resource, I‚Äôve learned using pragmatic studio. The classes cost a little more money, but even though there are free classes online, it‚Äôs an amazing program, and it was definitely a pleasant surprise to see the difference going from free classes to the badass pragmatic ones. Good luck with the switch, and feel free to ask if you have any other questions about it! 
Not in Ruby nor in Python
Pretty sure there are still plenty of live, webfacing in-production codebases stuck on 1.8/1.9. Hell I recently turned down such a project.
Now this could be a game changer... Perfect example of a library hitting the sweet spot between developer convenience and industry needs.... like, for example... Ruby itself ;)
1.9.2 Not 1.92
Eh, you'll use them in Ruby if you're doing trying to jam a bunch of statements on a single line .
Which is neither good style nor that common really.
[Official Ruby Documentation - To Ruby From Python](https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-python/)
Seems interesting! Will the presentation you did be viewable at some point? :)
I don't know if they are still using Rails for Apple Music, but a few months ago I saw a job offer from Apple looking for Rails engineers.
I never said it was either.
I wrote down all links at my notebook. kkk Thank you!
1.8 sucks so much... 1.9 has been at EOL for years (feb 2015) So yeah...
Aren‚Äôt you a cool semantic versioning cat? ;)
Too many people assume that, for example, `1.1.0` must come after `1.0.9` - when actually `1.0.10` is also a valid version ;)
No love for GoRails? There‚Äôs some good Slack communities too you could check out. 
GoRails is the best.
I think anytime you employ a triple nested loop, it is a sign that you need to split your code. Here's how I would solve it. This way I can reuse the methods or refactoring them without messing everything up: require 'prime' def obj_eval(val) if Prime.prime?(val) == true true else false end end def contains_prime(array) arr = [] !!array.uniq.combination(2).each do |a, b| sum = a + b if obj_eval(sum) == true arr &lt;&lt; sum end end p arr end irb(main):021:1&gt; end =&gt; :contains_prime irb(main):022:0&gt; h = (1..20).to_a =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] irb(main):023:0&gt; contains_prime(h) [3, 5, 7, 11, 13, 17, 19, 5, 7, 11, 13, 17, 19, 7, 11, 13, 17, 19, 23, 11, 13, 17, 19, 23, 11, 13, 17, 19, 23, 13, 17, 19, 23, 17, 19, 23, 17, 19, 23, 19, 23, 29, 23, 29, 23, 29, 31, 29, 31, 29, 31, 29, 31, 31, 37, 37]
RemindMe! 10 hours
I will be messaging you on [**2018-06-06 02:09:45 UTC**](http://www.wolframalpha.com/input/?i=2018-06-06 02:09:45 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/ruby/comments/8oq4v1/my_favorite_ruby_community_resources/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/ruby/comments/8oq4v1/my_favorite_ruby_community_resources/]%0A%0ARemindMe! 10 hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
If you want to concoct the value of |a, b| then set your variable in lieu of sum. 
I knew I would miss something! Thank you. Will update.
This book is a good starting point: https://pragprog.com/book/rails51/agile-web-development-with-rails-51 It's a great introduction to Rails, of course, but it also introduces many parts of the environment surrounding Rails.
I was originally going to use it as just an API, but then I came across posts saying it should be used for the entire application. I am not completely new to programming but just about, I have finished my first year of university and am moderately familiar with some practices of OOP. It will be a small amount of users using the program, primarily only the people on site \(under 10\), does that change the way I should go about it? Do you have any other suggestions as to languages I should write the rest of the program in? Would any one language substantially make things easier, without compromising integrity of the program?
http://www.rubyflow.com/ 
\&gt; The new edition of this award\-winning classic is completely updated for Rails 5.1 and Ruby 2.4, with information on system testing, Webpack, and advanced JavaScript. Love it! Thanks
The language doesn't really matter all that much as long as you're using something semi-modern. If you really will have mobile, desktop, and web clients, it's worth making it just an API though, because then you will be able to hit the same API with all of the different clients and format the data received the way that they need them. I'd make the web client first since it's easiest to test against the API, and I would recommend using React or Angular to do it. That is just a recommendation though, and you should consider whether or not you need such tools before committing to them. You can certainly use ERB for templating your front-end, but then it is tied strongly to the back-end. Step back, look at your goals and decide if you want to have your front-end and back-end in the same project. If that is what you want, yes, use Rails for both. As for would a different language make things easier: sometimes. Very specific things are easier to do in one language or another. The libraries available for your language of choice should also be considered here (Ruby calls these libraries gems); if your language makes something you see yourself doing frequently difficult and there are no libraries to make it easier, perhaps a different language would be better. Ruby has easy ways to manipulate collections, which is what many CRUD apps really need, so it's probably a solid choice.
Welcome! Here's a summary of a [few differences and similarities between Ruby and PHP](https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-php/). Ruby ships with a dependency tool for Ruby packages called [RubyGems](https://rubygems.org/), which gives you the `gem` command. For example, to install the [Pry](http://pryrepl.org/) gem, `gem install pry`. Ruby also ships with a popular testing gem called [Minitest](https://github.com/seattlerb/minitest). Ruby has a benevolent dictator named [Matz](https://github.com/matz), rather than a standards board. [Rails](https://rubyonrails.org/) is one of many adapters for the [Rack](https://github.com/rack/rack) gem. I'd recommend making a simple, pure Rack app. Then try running it with `rackup`. Once you start adding routes you'll see why the adapters exist to make your life easier. Notable Rack adapters include [Hanami](http://hanamirb.org/), [Sinatra](http://sinatrarb.com/) and my favorite, [Roda](http://roda.jeremyevans.net/).
You may find it helpful to at least read/skip thorough https://www.railstutorial.org/ It goes over building a rails app with increasing complexity and touches the whole ecosystem. You will see many of the tools, their use, and the reasoning behind including them.
Super useful information, particularly around what Rack is. That definitely helps me wrap my head around things.
i can't believe you've done this.
Code golf time? "you're welcome".gsub(/./){[$&amp;.swapcase,$&amp;].sample} # =&gt; "YoU'Re weLcoMe"
Can someone point me to something that explains what this is?
`2.4.2 :001 &gt; "you're welcome".chars.map { |a| a.swapcase! if rand &gt; 0.5; a }.join`
https://www.youtube.com/watch?v=WIrYh14H9kA
 next c.swapcase if rand &gt; 0.5 c could be: rand &gt; 0.5 ? c.swapcase : c
Doesn't the meme swap every other letter though?
Yes. Should be up in a few weeks.
Just don't call Rails or the like a Rack adapter at your next job. These are web frameworks.
Yea, seems rather that Rails is a framework that _provides_ a Rack adapter for easy development using a Rack server.
I'd add these to the list too * https://ruby.libhunt.com * https://www.ruby-toolbox.com/
 module SpongeMeme refine String do def spongebob methods = %i[upcase downcase].cycle chars.map do |char| next char unless char.match? /[[:alpha:]]/ char.public_send methods.next end.join end end end using SpongeMeme "you're right".spongebob #=&gt; "YoU'rE rIgHt" 
Golfed: 2.5.0 :001 &gt; "you're right".gsub(/\p{L}\p{^L}*.?/i){$&amp;.capitalize} =&gt; "YoU'rE rIgHt" 
Golfed: 2.5.0 :001 \&gt; "you're right".gsub /\\p{L}\\p{\^L}\*.?/,&amp;:capitalize =\&gt; "YoU'rE rIgHt"
I can't even read that.
Two things are in play. 1. The regexp. Uses `\p{L}`, which is basically "match any 'letter' from any language", followed by zero or more `\p{^L}`, which is the opposite of `\p{L}`, basically "any not-letter from any language". It then captures zero-or-one of any character (the `.`). 2. `gsub` accepts any block or proc-like object, in this case the `&amp;:capitalize` tells it to call capitalize for every replacement `gsub` will replace on. If you want to see what replacements gsub will call, you can just use String#scan, which outputs all the matches in the string: irb&gt; "You're right".scan(/\p{L}\p{^L}*.?/) =&gt; ["Yo", "u'r", "e r", "ig", "ht"] From there, it just calls `capitalize` on each element: irb&gt; _.map { |x| x.capitalize } =&gt; ["Yo", "U'r", "E r", "Ig", "Ht"] And then you can get the string back by `join`ing it: irb&gt; _.join("") =&gt; "YoU'rE rIgHt"
Thank you for that writeup! You are very knowledgeable.
Hello, using the sportdb machinery (gems, command line tools and build scripts in ruby) I've put together a [new free public domain dataset for the (football) world cup in Russia 2018](https://github.com/openfootball/world-cup.json). The world's biggest (sport) event kicking off in about a week. Enjoy the beautiful game with ruby and datasets in json or sql :-). PS: Find the [(activerecord) sql to json script](https://github.com/yorobot/football.db/blob/master/scripts/up/json.rb#L102) in the yorobot automation repo. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [yorobot/football.db/.../**json.rb#L102** (master ‚Üí 99d7a17)](https://github.com/yorobot/football.db/blob/99d7a17a0e90f8ce013cc483ae97ec3f4e69a45e/scripts/up/json.rb#L102) ---- 
...if anyone find this useful. docs https://github.com/equivalent/azure-test
&gt; This is obviously a poor solution and unruby like. Yeah, which suggestion did you base that assessment on? The one to use a debugger designed for Ruby, or the one to break the problem down into a simpler version in order to diagnose the problem with your poor code? Either way, you are not only wrong, but also a complete jackass for being that rude and dismissive to u/modnar42 when he was giving you good advice (for free!) on how to work through your problem. I see the problem, and came here to tell you what you are doing wrong, but now that I've seen this comment I think I'll keep it to myself.
I'm a huge fan of Avdi Grimm. I levelled up at Ruby thanks to RubyTapas, and this episode in particular was one for the ages. It's great to see it republished with free access. 
Actually, I was talking about my code with nested loops. I need to come up with a better solution to me problem.Calm down. Of course, Im not denying being a jackass, but I think you might have misunderstood what I was saying.
Some dudes spend all their life to master in software engineering to make another Ruby version 2 times faster while 99.9% of this retarded community upvote and then reuse in production such shitty code like this. Ruby community is fucked up.
If you want a list of some industry ‚Äústandards‚Äù, check out Suspenders by Thoughtbot. You‚Äôll see this company quite a bit in the community as they make a few popular gems, tools, and put out great info. Also, DriftingRuby and GoRails are both worth checking out. I sometimes watch videos on features I may not need just to learn more about how to do various things. 
Lmao
Alas http://knowyourmeme.com/memes/mocking-spongebob
Loving the Discworld reference. :)
no tests tho
Which Slack communities would you recommend?
You got me
Thought y'all might like some benchmarks. require 'benchmark/ips' class String def spongebob each_char.map do |c| next c.swapcase if rand &gt; 0.5 c end.join end def sponge_if each_char.map do |c| rand &gt; 0.5 ? c.swapcase : c end.join end def sponge_golf gsub(/./){[$&amp;.swapcase,$&amp;].sample} end def sponge_alternate methods = %i[upcase downcase].cycle chars.map do |char| next char unless char.match? /[[:alpha:]]/ char.public_send methods.next end.join end def sponge_alternate_golf gsub /\p{L}\p{^L}*.?/,&amp;:capitalize end end Benchmark.ips do |x| str = "Yours is shorter but mine is quicker" x.report('spongebob') { str.spongebob } x.report('sponge_if') { str.sponge_if } x.report('sponge_golf') { str.sponge_golf } x.report('sponge_alternate') { str.sponge_alternate } x.report('sponge_alternate_golf') { str.sponge_alternate_golf } x.compare! end Warming up -------------------------------------- spongebob 6.289k i/100ms sponge_if 6.652k i/100ms sponge_golf 3.179k i/100ms sponge_alternate 965.000 i/100ms sponge_alternate_golf 8.672k i/100ms Calculating ------------------------------------- spongebob 67.789k (¬± 3.2%) i/s - 339.606k in 5.015462s sponge_if 68.688k (¬± 2.4%) i/s - 345.904k in 5.038931s sponge_golf 31.852k (¬± 5.2%) i/s - 162.129k in 5.105108s sponge_alternate 11.463k (¬±14.4%) i/s - 56.935k in 5.090994s sponge_alternate_golf 88.211k (¬± 4.0%) i/s - 442.272k in 5.022879s Comparison: sponge_alternate_golf: 88210.7 i/s sponge_if: 68687.8 i/s - 1.28x slower spongebob: 67788.7 i/s - 1.30x slower sponge_golf: 31852.3 i/s - 2.77x slower sponge_alternate: 11462.6 i/s - 7.70x slower Surprisingly the alternating golfed one is the quickest! Nice work u/Arcovion!
Not this specific run (which is short), but I did other runs, much longer, and the problem with JIT still remained. I'm pretty confident, though, that it will ultimately work great!
 2.4.4 :001 &gt; "you're welcome".split(//).map{|c|o=c.ord;(rand&gt;0.5&amp;&amp;o&gt;65?o-32:o).chr}.join("") =&gt; "yoU'Re WELcoMe"
That's what I want. Thank you!!
Instead of manually creating the setter as def users= assigned_users @users = assigned_users end you can simple use [`attr_writer`](https://ruby-doc.org/core/Module.html#method-i-attr_writer) to create the same method, i.e. attr_writer :users
I don't think that moving from instance variables to helper methods is an improvement. At least with ivars, data is pushed to the view. Helper methods cause the views to pull data. The importance of this distinction is difficult to understate. The data contract between the controller and the view should be explicit, and data access should happen separately from template rendering. I expect to be able to render templates with synthetic data in order to test them in isolation, which I can't do with views that are coupled to a universe of helper methods. Conversely, I expect to be able to actuate a controller action and observe the data it gathered separately from the templates. Instance variables in controllers may have been a hack, but I personally wouldn't trade that hack for the approach outlined in this article.
You can move all helper methods to it's own concern so you get a nice separation of concerns there (see what I did there?). Anyways, I do agree it's not perfect. To be honest I'm fine with having instance variables as long as there's at most 2 per controller action. Also, I don't know if it's a hack, it's most of an OOP thing. ERB originally uses the context of an object to get it's data. It doesn't use a hash, it uses an object. So it makes sense for Rails to use it that way.
In addition to Ruby, is MRuby which you could setup H2O web server, alternative to Nginx. https://h2o.examp1e.net/index.html https://www.slideshare.net/mobile/ichitonagata/how-happy-they-became-with-h2omruby-and-the-future-of-http
Oh man, I was just in your shoes a year ago. I started writing a book on transitioning from PHP to Ruby. 
For the most part _it doesn't matter_, you should consider object_ids to be "opaque". But I've seen someone writing before about MRI's implementation I think (which might not match JRuby's etc).... Ah, I think this one: https://tenderlovemaking.com/2017/02/01/object-id-in-mri.html 
Ah. It definitely read like you were dumping on his advice a little. Like a lot of the people here, I rely on people being willing to help out from time to time. Too many people come here and 'poison the well' so to speak and I'm a little sensitive to it. Well, you probably don't care about this then if you are planning to change your whole approach, but the problem appears to be than prime_series? isn't idempotent. Basically you should break this method into two, the boolean test should be separate from the method that actually performs operations on the array.
&gt; You can move all helper methods to it's own concern so you get a nice separation of concerns there (see what I did there?). I'm not sure that solves any of the problems I brought up. I was talking about separation of concerns between the controller and the views. If views depend on helper methods from the controller, then they don't stand on their own. They can't be used without the surrounding controller. Because of that, I'm arguing that they ought to depend on a data contract, instead. Making "rails concerns" out of helpers doesn't really move the needle in that regard, at least from my vantage point. &gt; Anyways, I do agree it's not perfect. To be honest I'm fine with having instance variables as long as there's at most 2 per controller action. If three is too many instance variables, why is it not also too many helper methods? &gt; Also, I don't know if it's a hack, it's most of an OOP thing. ERB originally uses the context of an object to get it's data. It doesn't use a hash, it uses an object. So it makes sense for Rails to use it that way. I'm not sure I follow this. Rails doesn't supply the controller instances as the template binding, it actually copies the instance variables over to some interstitial object. It's not really object oriented at all, since ERB template rendering shouldn't make use of the binding object's internals (i.e. instance variables).
&gt; I'm not sure that solves any of the problems I brought up. I was talking about separation of concerns between the controller and the views. If views depend on helper methods from the controller, then they don't stand on their own. Views depend on data. How can they stand on their own? For example, you can compile a view and render it as such: `view.render(foo: "bar")`, in that case the view depends on `foo: "bar"`, where does that live? In your tests, most likely it's gonna be mocked there, but there is no specific entity which defines all the values it needs in order to work, something like a `MyViewParameter` object. You can define that responsibility in a concern, while not an object, it still gives you a place to put that logic. Any controller can then plug-in that role, so the role is independant from the controller itself. You have a place for the view's dependencies, and the view and the dependencies themselves are also separated. &gt; If three is too many instance variables, why is it not also too many helper methods? Well it depends on how you handle helper methods, if you go with the concerns approach, you can have several small concerns with few methods each, you can even relate those 1-to-1 with views if you want, although I'm not sure that's the approach you want to take. &gt; I'm not sure I follow this. Rails doesn't supply the controller instances as the template binding, it actually copies the instance variables over to some interstitial object. It's not really object oriented at all, since ERB template rendering shouldn't make use of the binding object's internals (i.e. instance variables). Yeah I wasn't talking about the controller itself but whatever is passed to ERB, or whatever template engine you have. Think of ERB as evaluating some code in the context of an object. It then makes sense to pass an object instead of, say, a hash. Because objects can have dynamic fields and also, it gives you room to use inheritance and write more complex things if you want. It surely is object oriented but it's quite dynamic, think Smalltalk OOP rather than, say, Java OOP.
Templates (i.e. rails views) _should_ depend on data. They should _not_ depend on controllers, or a universe of helper methods. &gt; In your tests, most likely it's gonna be mocked there, but there is no specific entity which defines all the values it needs in order to work, something like a MyViewParameter object There should be no need to mock. Pass a data object into the template, render it, and observe the result. Ideally, that data object is an instance of a concrete data structure class. &gt; Well it depends on how you handle helper methods, if you go with the concerns approach, you can have several small concerns with few methods each, you can even relate those 1-to-1 with views if you want, although I'm not sure that's the approach you want to take. My larger issue is whether this analysis is based on what approach "feels" the best, versus the one that offers the most tangible benefits and least unavoidable costs. If we've decided that two is the limit of how many instance variables we allow a controller action to define, then what's the basis for that decision? And what makes the calculus for the limit different for helper methods? &gt; Think of ERB as evaluating some code in the context of an object Agreed, that is exactly how I think of it. &gt; It then makes sense to pass an object instead of, say, a hash. Yep, definitely. &gt; Because objects can have dynamic fields and also, it gives you room to use inheritance and write more complex things if you want. It surely is object oriented but it's quite dynamic, think Smalltalk OOP rather than, say, Java OOP. My argument is not that templates shouldn't depend on objects, it's that they should depend on data structure objects, not Rails controllers. Controllers have a different concern, coordinating a request/response cycle. Attaching helper methods to them that templates then couple to is a pretty flagrant violation of SoC, because you're going to inevitably introduce methods on your controller that serve a template. All methods on a controller should serve the controller (or the user of the controller, which is moot here since Rails actuates the controller directly).
&gt; Templates (i.e. rails views) should depend on data. They should not depend on controllers, or a universe of helper methods. Yes, it's whats called a Data Object, like a Vector or Money object for example. You can make an object for it if you want, or define a role and implement a concern. It's the two ways you can do it in Ruby. &gt; There should be no need to mock Yeah that's right. I said "mock" but what I really meant was "dummy data", just something you use to test. &gt; If we've decided that two is the limit of how many instance variables we allow a controller action to define, then what's the basis for that decision? And what makes the calculus for the limit different for helper methods? People who have written tons and tons of object oriented code. Thoughtbot, Sandi Metz, and a bunch of very respected Ruby devs. It's not like it's the only way, but it's one way which works. That's enough for me. Also, it just feels good once you get used to it, once you see clean code, small objects, small methods, well organized code. It's worth it. &gt; My argument is not that templates shouldn't depend on objects, it's that they should depend on data structure objects, not Rails controllers. I agree with this. What I add is that, I'm fine with them displaying a Data Object. &gt; Controllers have a different concern, coordinating a request/response cycle. Attaching helper methods to them that templates then couple to is a pretty flagrant violation of SoC, What's the difference between defining a method and an instance variable then? They are both violating it. The fact is, controllers do set instance variables or helper methods, they do set whatever is used in the views. So at least lets extract that into a concern. There is no other place in standard Rails to put it. So the controller can only care about the req/res stuff and at least plug-in that other behaviour.
Rad! Are you enjoying the language and ecosystem? 
I agree with you and another way to put it IMHO is that your views shouldn't depend on objects which expose operations that aren't O(1) or that have side effects.
Yea it's so nice to not have to look up PHP functions constantly. And debugging is a cinch with pry. Because the OOP structure is so flexible you don't need to worry about DI and IoC Containers very much at all. As far as Rails goes, it's just like Laravel but with a few more opinions built in.
Let me take a few steps back for a second. Here's a rephrasing of my argument (and hopefully I've been a bit clearer this time, I think some of my meaning is being lost in translation to text): while using instance variables to push data into the template binding context is an undesirable hack, replacing ivars with helper methods just _deepens_ the coupling between the template rendering and the controller. Separately, I've argued that templates should depend on a data contract, not a controller. If a rails controller is using an instance variable to convey a single data structure to the template, that's better than a template that is coupled to an arbitrary number of helper methods exposed by the controller. It doesn't mean I particularly _endorse_ instance variables in this case, it's more that I'm distinguishing the dependencies of a template from how the data is supplied to the template. Instance variables have the advantage over helper methods in that they don't represent a coupling between the template and the controller. Ideally, we wouldn't have to use instance variables, but that's now how Rails' API works. So, when I'm rendering templates in Rails, I do it The Rails Way, knowing that while the use of ivars is suboptimal, it's _far more important_ to keep the template decoupled from the controller. That means not calling methods defined on the controller, or methods that the controller exposed via the `helper` macro. &gt; People who have written tons and tons of object oriented code. Thoughtbot, Sandi Metz, and a bunch of very respected Ruby devs. It's not like it's the only way, but it's one way which works. That's enough for me. Also, it just feels good once you get used to it, once you see clean code, small objects, small methods, well organized code. It's worth it. Reading this paragraph led me to suspect that I may appear to be taking a side against object oriented development, or that I may seem naive and uninformed about OOP. I am very much an OO enthusiast... I hope this reply makes my stance clearer.
Yes! All data access should have already occurred before rendering a template, otherwise the template _cannot_ be rendered without supplying it a context capable of serving all the template's data access needs. It's "Tell, Don't Ask" ultimately.
Also, look at this for learning ruby with common CS puzzles. It‚Äôs a lot of fun and introduces language concepts as necessary to solve the puzzles. https://github.com/JoshCheek/ruby-kickstart 
Thanks! Here's a faster random version (`then` is an aias for `yield_self` in Ruby 2.6+): 2.6.0 :001 &gt; "you're welcome".tr *[*?a..?z].shuffle[0,13].join.then{|x|[x,x.upcase]} =&gt; "You'rE wELComE" Comparison: sponge_fast: 134319.1 i/s sponge_alternate_golf: 85223.3 i/s - 1.58x slower sponge_if: 68822.3 i/s - 1.95x slower spongebob: 68701.0 i/s - 1.96x slower sponge_golf: 30110.7 i/s - 4.46x slower sponge_alternate: 7743.7 i/s - 17.35x slower
I'm not sure what you mean \- which bit is strange? This is just how \`object\_id\` is defined.
Author of the linked article (I had posted this to r/rails yesterday). I was just using that to explain the pieces that go into the final meta programming. The intention is not to code it manually like that.
Not faster, just another way (a="you're welcome").chars.zip(a.swapcase.chars).map{|c|c.shuffle.first}.join =&gt; "You'rE weLcOmE"
Author of the linked article here (I had posted this to [r/rails](https://www.reddit.com/r/rails) yesterday). Interesting discussion you have here. The template doesn't really have to know it is pulling the data from the controller. It can still be pushed in other contexts (test, console, etc). The helper is creating that binding between the controller and template. There is no coupling between the the template and controller. If you wanted to render the template at the console (or in a test) you could still do so by just calling: UsersController.render :show, locals: { user: User.first } You could even just use raw ERB if you wanted, I just use the class \`render\` method for conciseness (so it knows where to find the template). Either way, the template is rendered in isolation from the controller action. If you wanted to provide mocked data you are perfectly able to. If you want to test that the data is loaded by the controller is isolation from the template you are perfectly able to do so without having to dive into the internals of the controller (i.e. hacks like the now deprecated \`assigns\` test helper). You now have a public method that makes testing the loading of the controller data easily isolated from the templates. In the end the template have requirements to render correctly. If that data is injected by Rails copying the instance variables, pulled from accessors via helpers or pushed via local variables it is architecturally the same thing IMHO.
What if a template renders something on some condition. For example, when some if statement is true, it brings some things from the database, otherwise, it doesn't. Would you prefer accesing all the data anyways and sending it all at once, or let the view evaluate the contents lazily, only when it's needed? If you do prefer to send all data at once, let's say we really don't want to run that extra database query on every request. What is your approach so that it's efficient then?
Yeah I think we are basically hating on the same thing lol
My favorites: - [Forwardable](https://ruby-doc.org/stdlib-2.5.0/libdoc/forwardable/rdoc/Forwardable.html) (i.e. `def_delegator` and `def_delegators`) - [SimpleDelegator](https://ruby-doc.org/stdlib-2.5.0/libdoc/delegate/rdoc/SimpleDelegator.html) A note on DRb, which is mentioned in this post: to my knowledge DRb access is equivalent to remote code execution. Use it with care! (if at all)
Here we go, I changed `.shuffle[0,13]` to `sample(13)` and moved the alphabet into a constant: A=*?a..?z def sponge_ascii l=A.sample(13).join;downcase.tr l,l.upcase end Comparison: sponge_ascii: 321767.3 i/s sponge_alternate_golf: 80770.1 i/s - 3.98x slower spongebob: 68514.0 i/s - 4.70x slower sponge_if: 68052.5 i/s - 4.73x slower sponge_golf: 29860.7 i/s - 10.78x slower sponge_alternate: 7450.6 i/s - 43.19x slower
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/github] [Gem markdown\_helper File Inclusion Adds :comment and :pre](https://www.reddit.com/r/github/comments/8p4vg9/gem_markdown_helper_file_inclusion_adds_comment/) - [/r/markdown] [Gem markdown\_helper File Inclusion Adds :comment and :pre](https://www.reddit.com/r/Markdown/comments/8p5ehx/gem_markdown_helper_file_inclusion_adds_comment/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
https://ruby-doc.org/stdlib-2.5.1/libdoc/e2mmap/rdoc/Exception2MessageMapper.html
I use SimpleDelegator quite often, too.
Thanks for the reply. Are you referring to the function or the loops? The boolean function seems to return correctly. Can you clarify, thanks.
&gt; Any time you refer to a named value in a method, and you're tempted to use an instance variable... &gt; or explicit method call ask yourself if there's any reason not to refer to the value as a bareword instead. &gt; Chances are there isn't. If abstraction is necessary sure, but making the internals of your class part of its public interface via `attr_reader`, `attr_accessor`, etc... by default _is not_ a good idea. 
So, make them `private`.
i'm not sure what I think, I don't find either method of data binding to templates to be great. But I know 'concerns' aren't the answer to anything. despite the name, they provide no "separation of concerns" (encapsulation) at all. They just lead to objects or classes with enormous surface areas, but spread across multiple files. 
Here's a link to a working solution from the link. It can be launched either on host or in containerized mode (dind): https://github.com/zinovyev/monidock If you have any suggestions on improvement of it, you're welcome! =)
https://en.wikipedia.org/wiki/Dynamic_array
Thanks for that. It's amazing how much difference knowing the correct term can make. tl;dr: Dynamic arrays are true arrays in the sense of occupying a contiguous block of memory. They are allocated a block of memory larger than is strictly necessary to begin with, allowing for constant time resizing on insertion up to a certain point, but when they exceed that original block of memory they must be copied to a new location. Where could I read a little more about how Ruby specifically implements this? That is, how is the size of the block of memory determined when you initially create an array (It would have to be dependent on the size of the initial array at the very least)?
https://github.com/ruby/ruby/blob/trunk/array.c#L916-L926 https://github.com/ruby/ruby/blob/trunk/array.c#L357-L397 https://github.com/ruby/ruby/blob/trunk/array.c#L730-L785
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/ruby/.../**array.c#L916-L926** (trunk ‚Üí 265bfdf)](https://github.com/ruby/ruby/blob/265bfdfbf5a809a7e22231ae25a551eda23cbf7d/array.c#L916-L926) * [ruby/ruby/.../**array.c#L357-L397** (trunk ‚Üí 265bfdf)](https://github.com/ruby/ruby/blob/265bfdfbf5a809a7e22231ae25a551eda23cbf7d/array.c#L357-L397) * [ruby/ruby/.../**array.c#L730-L785** (trunk ‚Üí 265bfdf)](https://github.com/ruby/ruby/blob/265bfdfbf5a809a7e22231ae25a551eda23cbf7d/array.c#L730-L785) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e09ac72.)
Thank you.
It increases the capacity when you hit certain array sizes like: 3, 20, 37, 56... These thresholds are calculated by the ary_double_capa function inside array.c: https://github.com/ruby/ruby/blob/ruby_2_0_0/array.c#L183 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/ruby/.../**array.c#L183** (ruby_2_0_0 ‚Üí 073cc5e)](https://github.com/ruby/ruby/blob/073cc5e815fcf5178fe4e515fcde74dc3597adeb/array.c#L183) ---- 
Interesting, are their any reason why Ruby communities ( Or more like Rails Communities ) hasn't pick this up? Seems to fit Shopify perfectly.
Shun the non believer! :)
The only useful bot on Reddit.
Of course, but author has not mentioned/illustrated this important caveat. 
Something I don't understand about this line of reasoning is why do attributes need to be marked as private for developers to know not to couple to it? If developers understand Tell, Don't Ask, it should be obvious to them not to couple to attributes. In my experience, it *is* always obvious. Even to junior devs with minimal training. Conversely, marking attributes private almost always causes usability problems for tests, which often rely on those attributes for making necessary observations. Ruby has an ethos about typing: don't want to call a number method on a String? Then don't do it! I wonder if that ethos can be transferred here. Don't want to couple to internals? Then don't! Just my $0.02
Definitely object_ids don't matter, it was just an interesting pattern we recognized. But now having done some reading into how object IDs work, it really just plays on the fact that `anything.object_id` is an integer, and `int.object_id = 2 * int + 1`. Since `2 * n == n &lt;&lt; 1`, that's where the relationship comes from.
If you have several things to select on, just put those conditions together on one select: my_array.select { |n| n.odd? &amp;&amp; n &lt; 256 } In general, I've hardly ever had to write my own loops. If you get stuck on an example where you feel a custom loop is needed, show us!
This only works with packages supporting semantic versioning, which isn't required by RubyGems is it?
I would in general lean towards combining in a single \`select\` as iconoclaus recommends. But there are times where for clarity or reuse reasons, I'm ok with the less efficient approach. For example, when the filtering is abstracted as a method and I want to keep that abstraction for reuse reasons. Generally the number of items we iterate over is small. Going through the list a few times may not be that bad. But if you can keep clarity, reuse and keep it as efficient as possible go with that route.
I'll add another angle: the question does not really make much sense in a language which does not give you direct memory access (i.e. no pointers to memory addresses). Fact is, for the user of the language only the API of Array matters \- how things are stored internally is irrelevant as long as it fulfills the advertised access patterns and performance characteristics. You could argue though that since there is no link to a next element visible from Ruby code, Array certainly is not a linked list. And this would be true even if the *implementation* was using linked lists. It is really important to separate these two layers even though the source code of the Ruby interpreter is readily available and it is easy to look up how things work underneath. (Another of my pet peeves are the tagged pointers which are / were used to efficiently implement integers and a few other things. On the Ruby language level these are invisible.)
Definitely use the built-in methods instead of writing your own. Each of the built-in methods has a name that conveys some meaning to the next person that reads the code. For example, if I see that someone calls Array#map then I know that no matter what else is happening here I'm starting with an array and getting another array, and all I have to do is figure out what that transformation looks like. Each of the built-in loops does something like this once people get a basic familiarity with the names. There are a ton of other reasons to use the built-ins as well. The built-ins are likely implemented in the language the rest of the Ruby VM is implemented in, so they're likely to be faster. The built-ins are likely to manage resources intelligently, or at least manage them in awhile prescribed way. Looking at the Array#map example we know that the output array is a second array that is completely distinct from the input and that can be relied upon by the rest of the code. Finally, I would use the built-ins because they are reliable and well tested, any loop you write but only get the testing you provide.
It's a little more complicated than that assuming we're talking about MRI's implementation and there are a bunch of special case optimizations involved. First, MRI stores all objects as a `VALUE` struct which is 40bytes long. With some exceptions for optimizations, an Array in Ruby is an array of pointers to these `VALUE` structs. Some objects in Ruby are small enough that their data is actually stored directly in the `VALUE` struct, others are larger and the `VALUE` struct just stores a point to the actual data somewhere else in the heap. So if you have an array of really big objects and the array needs to resize, you aren't copying all the data, you are copying the pointers to said data. But, your array is 2 levels of indirection away from the actual data so there is no guarantee that your is continuous in memory. There are further optimizations at multiple levels, just as some examples: Any Array itself is a `VALUE` and for very small arrays, the array's data (which are still pointers) will be stored directly in the `VALUE`, removing a layer of indirection. Some objects, like machine sized integers and symbols don't allocate a `VALUE` struct at all, the data is embedded in the pointer itself. So for example if you have an array of machine size integers, the data itself is continuous in memory.
This is a nice solution, thank you. But let's say you want to apply a certain condition inside the select with another if/unless statement. For example n &lt; 256 if my_var We would need another select in that case...
if performance is not an issue, do multiple selects. It‚Äôs more readable. If performance is really an issue, write your own loops. Again, if you can come up with a full-fledged example of your own loop, we could comment on it more.
Those are very good angles I never thought of. Thank you
&gt; Or am I missing some important point altogether? Yes, it doesn't matter. It matters in a language like C where you have low-level access to memory locations. That results in there being a different API for array-like things and list-like things. Ruby is an interpreted language that doesn't give you direct access to the memory. Some of the API for Ruby Arrays looks like C arrays, some looks like C lists. It's entirely possible that under the hood there's some clever optimization where Ruby uses sequential memory locations for small arrays then switches to linked lists for large arrays. Of course, C is likely to be faster because by knowing and caring about the gory details, you can optimize things. A lot of the point of Ruby is to make it easy for the programmer. By having an API that lets you think of it as a list, or lets you think of it as an array, you're given the freedom to solve the problem however you want. As long as Ruby is fast enough for your purposes, you don't need to care how it's implemented internally. 
Something to consider: object references are basically pointers since they refer to the same object in memory. One can make a linked list out of plain Ruby objects that acts pretty much like a language with access to those objects memory addresses: ```ruby class LinkedList attr_accessor :prev, :next def initialize(prev: nil, next: nil) self.prev = prev self.next = next end def append(item) end = find_end item.prev = end end.next = item end def unshift(item) beginning = find_beginning item.next = beginning beginning.prev = item end def find_beginning item = self while item.prev != nil item = item.prev end item end def find_end item = self while item.next != nil item = item.next end item end end ```
yes please. 
I don't have a concrete example right now, I'm more looking for different approaches other developers have. Sqeaky added a very nice comment on the benefits of using built-in methods as well. 
&gt; All data access should have already occurred before rendering a template, otherwise the template cannot be rendered without supplying it a context capable of serving all the template's data access needs. That doesn't make much sense. Why should a view care if calling `@post.comments` executes a DB call in the background? It's immaterial to the view what the internals of the `comments` method is, all it cares about is that it returns something that implements `each`. 
Happy to see a new Ruby podcast :)
I'm not arguing that templates should be aware of whether a particular method call hits the database. I'm arguing that templates shouldn't be transforming the underlying data model into the document's data model (i.e. DOM). Practically speaking, though, when templates depend on data structures specialized for the template, data access must have already happened. This implies disentangling data access from the templates altogether, which is a big design win on its own. It _also_ just so happens that programmers looking at templates designed this way can presume that no database is being touched in the context of template rendering, but that's not the goal.
Doh, forgot to say that this only works for non-array type data structures since arrays are defined specifically by the proximity of the memory, of which Ruby gives no control.
Depends on the operations and what your goal is. In contrast to what several have said here, running multiple chained commands is often faster than doing it one go as with the former you'll often be using fast C implementations vs a Ruby implementation. For example if you have an array of integers or strings and need them sorted in reverse order then `my_array.sort.reverse` is _much_ faster than `my_array.sort { |a,b| b &lt;=&gt; a }` or `my_array.sort_by { |a| -a }`, even for very large arrays.
&gt; Practically speaking, though, when templates depend on data structures specialized for the template, data access must have already happened. That isn't true at all, for example you can apply a decorator which handles view formatting to an ActiveRecord relation and it can still trigger the query in the view. Or more generally what we're talking about is lazy transformation on load which can occur in many ways, and is often more performant as you don't have to loop the data multiple times. 
Decorators aren't data structures. I'm talking about rendering templates from data structures that contain everything needed by the template (and nothing more). There is nothing that's going to be "more performant" than constant time lookups of data on data structures.
There is no practical difference to the view. For example the view expects an object to respond to `price`, it doesn't matter to the view if that method returns a precomputed value or computes it on the fly. It also makes zero different to your tests, unless you're confusing what it is your testing. &gt; There is nothing that's going to be "more performant" than constant time lookups of data on data structures. That is not accurate. It is not 'faster' to iterate over the source data twice, once transforming it to the 'view data model', then again in the view to render the template. This is particularly true if your duplicating data without apply any meaningful transformation to it. 
No, you just use a block. my_array.select do |n| if my_var n &lt; 256 else # whatever contrived logic end end
If I see someone construct their own collection iteration in Ruby, it's a potent code smell. It's a sign that you don't really know what you are doing, IMO. Sometimes chained selects are fine, performance-wise you make your first select something that eliminates the bulk of the collection, so that subsequent selects are against a trivially sized collection. If you need complicated logic in a select, use a block, or define a proc that encapsulates that logic and call that from the select block.
Past the first iteration here, you aren't looking at how `object_id` happens to relate to one another in general, you're looking at how the object_id of integers relate to each other (since `object_id` returns an integer). So the question is, why do Integer's have object_ids that relate like this? It's because MRI stored machine sized integers via something called a 'tagged pointer'. Basically you can think of an `object_id` as a pointer to the object itself (or to a `VALUE` which is an intermediary used by MRI). Since Integers are so common, and don't need additional data, the 'value' of an integer is stored in the `object_id` itself. ` 76.object_id &gt;&gt; 1 == 76` and this holds for all integers up to 2**62 - 1. This is just an optimization to make integers more space efficient and faster to work with. This also means your assumption that this holds universally doesn't work, it'll fail as soon as it gets to an object_id &gt; 2**62 - 1. 
Use "...; downcase.tr! l,l.upcase" to make it still a bit faster (one less string creation)
&gt; There is no practical difference to the view. For example the view expects an object to respond to price, it doesn't matter to the view if that method returns a precomputed value or computes it on the fly. It also makes zero different to your tests, unless you're confusing what it is your testing. You're not understanding me. Yes, we can control the interface expected by templates. Yes, obviously Ruby has polymorphism. I'm arguing that the nature of the interface used by the template matters. If it's bound to an object that has already got the data needed by the template (and nothing else), then the job of substituting that binding object for another one is made easier. Particularly if the alternative is an `app/views` directory where templates make unfettered use of ActiveRecord calls, helper methods, etc., where the reader has to have memorized most of the app (and db schema) to be able to make sense of individual templates. &gt; It also makes zero different to your tests, unless you're confusing what it is your testing. Nope, I promise I'm not confused about what I'm testing. &gt; That is not accurate. It is not 'faster' to iterate over the source data twice, once transforming it to the 'view data model', then again in the view to render the template. This is particularly true if your duplicating data without apply any meaningful transformation to it. O(1) vs. O(1). The point I'm making is that an interstitial data structure doesn't introduce the kind of performance problem that you described.
You can get the best of both worlds with `lazy`. For example, consider this non-lazy code that will hang forever: (1..Float::Infinity).reject(&amp;:odd?).first(5) This will try to get the first 5 even numbers, but it will attempt to iterate over an infinite list, which will take forever. Now let's try it with lazy: (1..Float::INFINITY).lazy.reject { |i| i.odd? }.first(5) This will lazily iterate over the infinite list, which means it will only compute the portions of the data that it uses. This is similar to how Haskell works. As a side effect of this, loops basically get combined automatically.
&gt; Yes, it doesn't matter. That's the ideal, but believing it too hard can be dangerous (sometimes literally, as with side channel attacks on security software). All abstractions leak, and how things are actually implemented is likely to matter. Dynamic arrays are a common enough thing that it's worth understanding what they are and what the tradeoffs are. 
Yeah, I think this is spot on. Part of Ruby's beauty, as we know, is the english like fluidity it brings to the table. The built-in methods allow for such clean code, diving into someone else's world is a whole lot easier than attempting to read a custom-made loop. And, as most people have mentioned, from a performance angle, I don't know if it's quite worth the effort. I'll try to think of a good use-case and let you know.
Ok, it doesn't matter to 99.99% of Ruby programmers. If you think it matters to you, you're probably wrong.
&gt; O(1) vs. O(1) Big O notation isn't a panacea for in fact it's often wrong, especially in Ruby. More over it's only applicable for large n, and n should never be large in a view.
I'm not suggesting it's a panacea for anything, just that performance is similar enough to be a non-factor here.
This.....
I see you've embraced laziness. I approve.
Physician, heal thyself.
I prefer to use `&gt;= x.y.z` in my gem dependencies. Some feel this is too optimistic but I prefer not to exclude future major versions. Users can always lock a known good version in their Gemfile.
You don't need a wrapper class, you can call `future.value!` -- which will return the value if the future was not `rejected?`, and raise the `future.reason` if it was. I don't blame you for not knowing about this. Concurrent Ruby is somewhat poorly documented and often inconsistent. At one point I wanted to put some time into making this better, but it seemed like the current c-r maintainer(s) were more interested in working on a 'new implementation' of most of it, and suggested my PR attempts to the 'old implementation' were thus not so useful. Of course, years later we don't have the 'new implementation' either (and I never really understood the point or goal of the 'new implementation' myself). ¬Ø\_(„ÉÑ)_/¬Ø concurrent ruby is still pretty darn awesome. But it could be _so much better_ and easier to use. (like by prioritizing making it work less crazily with Rails for instance, and accepting help from a Rails committer on making it so. https://github.com/ruby-concurrency/concurrent-ruby/issues/585 )
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¬Ø\\\_(„ÉÑ)_/¬Ø`&amp;#32;or&amp;#32;`¬Ø\\\_(„ÉÑ)\_/¬Ø` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
If you have an existing project. If you're rolling from scratch and breaking changes were applied in a dependency, you're gonna be in for a bad time debugging :D 
Y'know I could really use a layer on ActiveJob that has join/promise-style interfaces but without assuming a shared runtime. Anyone seen something like that in the wild? 
I find myself doing something similar with semver, and I've come to think that semver made a big mistake by failing to distinguish major release milestones from smaller breaking changes. I tend to use a modified semver for my libraries now, where `x` is increased for every major product milestone or release (and implies big changes downstream), `y` is increased for every breaking release that's not part of a product milestone (and thus implies that only minor API changes may be necessary), and `z` is any non-breaking change.
It's confusing to call it \`ConcurrentRuby::Future\` and similar. It should just be \`Concurrent::Future\` etc.
Making internals `private` is an easy way to make code more bulletproof and less cumbersome to maintain. Let's take the code in the article, which does not use `private`. It ultimately requires a `designation` via `ObsequiousImp.new`. Let's make a modification to that code's constructor to make this check explicit: class ObsequiousImp # Snip irrelevant code attr_reader :designation def initialize(designation) # I added this raise ArgumentError, "designation required" if designation.to_s.strip.empty? @designation = designation end def greet(title, first_name, last_name) full_name = "#{first_name} #{last_name}" puts "#{salutation}, #{title} #{full_name}. ", "Welcome to #{progname} version #{version}. ", "My name is #{designation}.", "May I #{service_inquiry}?" end end This code can easily be broken: imp = ObsequiousImp.new("O senhor") imp.designation.clear Ok, so you move the validation to `#greet`. Fine. But what if you have 1+ methods that depend on `designation`? Do you do something like this? def greet(title, first_name, last_name) validate_designation # implementation end def dismiss(title, first_name, last_name) validate_designation # Like greet, but say bye end def validate_designation raise ArgumentError, "designation required" if designation.to_s.strip.empty? end This additional complexity that's easily elimitated by limiting visibility to the classes' internals. 
Those are typos, it should be `Concurrent::Future`
They should write a guild implementation so we can start using guilds today while it's being developed.
How's sidetiq working for you guys? While it's pretty old at this point and not maintained it's still working pretty good for us.
Good stuff. I will add that it seems like you could wrap both of those API calls together and get an even bigger perf boost :)
Genuine question: How is Ruby Motion holding up next to things like React Native and Flutter? Is it still a good idea to start a Ruby Motion project?
From what I can tell it's about the same as it's always been. It has it's space and it holds that well. It brings in a lot of the style of doing things that exist in the Ruby community, and you can do some (I do mean some, because we're talking basic business logic objects) code sharing. I'm a big fan of using Apple's tools for my iOS work these days but RubyMotion still is amazing at what it was built to achieve. I actually wrote two posts about this ages back that are still pretty spot on. Just replace "Swift" with "React Native" haha. [https://blog.motioninmotion.tv/why\-swift\-will\-never\-replace\-rubymotion/](https://blog.motioninmotion.tv/why-swift-will-never-replace-rubymotion/) [https://blog.motioninmotion.tv/swift\-still\-won\-t\-replace\-rubymotion/](https://blog.motioninmotion.tv/swift-still-won-t-replace-rubymotion/) 
I take is lower is better in this graph.
Agreed. I did mainframe/mini development for years as the PC industry was getting itself started up and, in that world, four-digit release numbers are common. So, going from Quasimatic 1.4.5.x to 1.4.6.0 would add some new stuff but not break existing code, 1.4.x.x to 1.5.0.0 *might* add new features but *would* involve a certain amount of breaking change, and going from 1.x.x.x to 2.0.0.0 is a Brave New World where the safe assumption is that the work involved would be at least comparable as migrating to a competing system. That gives you semantic versioning with clearer guidance on how cataclysmic a version change is likely to be. I wish that SemVer had followed that lead.
How about @foo = ‚Äòbar‚Äô if @foo.nil?
I wouldn't mind having a specific operator if it were thread safe, thats the biggest pain point of `||=`. 
TIL undefined @variables return `nil`. Nonetheless the lonely operator got included, I think `@=` is comparable.
i‚Äôm pretty sure that‚Äôs the first intended use of guilds. But with it being in such an early stage, any adoption of guilds will break faster than you can write it.
Or @foo = @foo || 'bar'
That won‚Äôt work if foo is falsy, and is mostly equivalent to ||=. 
 @foo = false unless defined?(@foo) @foo = 'bar' unless instance_variable_defined?(:@foo)
There is a good chapter on this in Practical Object Oriented Design in Ruby by Sandi Metz. The solution they give is supply classes with a hash of parameters, and have them merge with a default set of parameters. class Foo def initialize args defaults.merge(args) @foo = args[:foo] end def defaults {:foo=&gt;'bar'} end end Foo.new( {} ) =&gt; #&lt;Foo:0x00000001152f10 @foo='bar'&gt; Foo.new( {:foo=&gt;false} ) =&gt; #&lt;Foo:0x00000001152f10 @foo=false&gt; 
Sorry, originally read this on my tiny phone. I understand what op is asking now.
Couple of things. I would first make the each iteration section shorter. The basic idea is enough and the rest is easily learned by practice. Also, I would definitely want to show folks the reduce iterator at the end. It‚Äôs a surprise to many folks that map, select, etc. are all just special cases of reduce. i can show some examples if that is confusing. 
Any more you should probably just use keyword arguments for that: class Foo def initialize(foo: 'bar') @foo = foo end end
This has been implemented and released. Check out the latest :)
&gt;Something to consider: object references are basically pointers since they refer to the same object in memory. Not sure why you post that as a reply to my comment. Fact remains that Ruby does not give you access to physical memory. Your statement is only true in the abstract sense that object references point to objects in memory, but they do not point to specific addresses in memory. For example, objects could move in physical memory without you noticing in Ruby code. In fact, this is what can happen with JRuby because object references in the JVM are not pointers to physical memory either and the JVM does quite a lot of things to objects during their life cycle. You prove that one can implement a linked list in Ruby, but nobody denied that and it does not help answer the initial question whether Ruby Array is an array in the stated sense ("arrays, which have a block of memory reserved so that the next element is always the next contiguous memory location").
&gt;map, select, etc. are all just special cases of reduce could you give an example for that? my understanding is: map - to transform each element of array, select - to filter elements of array, reduce - to get single value result `nums.reduce(0) { |op, n| op + n**2 }` gives you sum of squares - a single value.. `nums.map(&amp;:abs)` applies `abs` to each element and gives back an array - do you mean this is also a special case that can be done with reduce?
H2O established is quite late where Ruby and Rails started in early 2000‚Äôs where lot of tooling became mature and stable. So the community are more focus on newer Ruby while MRuby is based on Ruby 1.9 for lightweight purpose.
Thanks for this!
You're welcome! I hope it helps. :) I there is at least one other person in the world whom I was able to help, it was all worth it. :)
Reduce is just a collector that can pick up anything or nothing as you iterate over an array. At the end it can produce an array or a singular value. Sorry i‚Äôm not by my machine so allow me to link you to an article that demonstrates: http://blog.lerner.co.il/implementing-map-reduce/
thanks a lot, that is really interesting and opens up what I thought was possible with reduce...
yep, many languages underappreciate the need for reduce. some, like python, have a distaste for it and feel it confuses developers. i feel that grokking reduce actually simplifies the story of enumerators. enjoy your ruby journey!
Unfortunately I'm stuck using Ruby 1.9.3 ü§™
example of why ruby is superior to python: def _spongebob_meme_text_generator_(usrStr): memeString="" n=0 for c in str(usrStr): if n%2==0: memeString+=c.capitalize() else: memeString+=c n+=1 print(memeString) while True: _spongebob_meme_text_generator_(input("&gt;&gt;&gt; "))
What do I need to do to make my app GDPR compliant at a minimum? i.e., what could I potentially be in violation of?
Can you make a gem that automates lawyering?
I believe that language should not support this case on a syntactic level. Runtime type errors are amongst the most common in Ruby, and we don't want to introduce more of them. If your data can be either `nil`, `false` or something else, then you should probably reconsider the way you describe your data. And if you're absolutely sure this is the best design, you need to make your intentions *explicit*. This way you'll reduce bugs in your code. And that's good
What‚Äôs been your biggest challenge through out this process? Any hurdles you overcame that might help others?
That cleaned up nicely!
I‚Äôll ask a few questions I already have a confident answer for, but I‚Äôm interested in your opinions, and want to see a real conversation here so I can learn more. 1) a hypothetical company in the U.S., targeting U.S. customers. What, if any, GDPR compliance do I need to worry about? If I get a form letter complaint, how should i respond? 2) for a European company subject to GDPR, using a simple authentication gem like Devise... what legal compliance do I need to worry about? 3) running on AWS in Europe with this European Devise app, capturing your typical debugging logs like dates, times, login ID, IP address. What responsibilities do I have with that data? Can I share it with a small development team? 4) the U.S. company above not normally in GDPR jurisdiction, but with the potential for a few European users uses AWS U.S. East, but because of a failover ends up hosting in Europe. Do requirements change?
For those seeing this again... I had a typo in the title which was stupid. :/ Deleting and reposting is the only way I know to fix it. Sorry.
Is it enough to let people request deletion of their data by email? Any chance you can validate privacy policy I wrote here https://gitpunch.com/privacy it's pretty short?
NB article's a week old.
I don't have any questions but just wanted to say thanks for such a great project!
Hi, I have had a list of questions about GDPR compliance that need input/answering. Can you take a hypothetical app like a Forum(bare bones demo app) which contains a Database, Memcache for caching, ElasticSearch for searching, Redis for background jobs which has another backend service which communicate through a queue to send updates to each other. What exactly each component/service need to do from an Ops perspective(encryption etc.,) as well as App perspective? Do I need to encrypt the disk, encrypt messages between servers, encrypt messages which go into the queue etc., What are the challenges and what are standard approaches to solutions to the challenges? When I send data to any external system, do I need to encrypt or is sending over SSL sufficient? Do I need to expose a list of all external vendors I use where any customer data is going to or any where even meta information is going? How does GDPR compliance go in-hand with regular compliance for a company. If a data analyst downloads data and sends raw data to a group (say top 1000 active users), if a customer requests to delete data, should the data be removed from the emails as well? How does blockchain implementations solve for GDPR compliance 
Thank you for Passenger!
Different jemalloc versions behaves very different with Ruby and especially Rails workloads, it could be interesting to know which version is recommended to use.
I like Ruby Rogues podcast because of topics that being discussed. I am not in Ruby and Rails right now, but this podcast keeps me not to forget about the ruby world.
Perl uses `//`: https://perldoc.perl.org/perlop.html#Logical-Defined-Or
**Question 1:** the criterium for whether a non\-EU company needs to comply to GDPR is: does the company intent to seriously service EU citizen? This is determined based on multiple factors, such as the website's language (do they have e.g. German translations?), providing pricing in euros, testimonials from EU customers, or having a contract with a parcel company with the specific intention of delivering to EU customers. The mere fact that the EU citizen *can* do business with this company is not enough to have it fall under the GDPR. Without knowing the specifics of your hypothetical company, my opinion is that it does not need to be GDPR compliant. If you get a form letter complaint, you can just respond with that. Having said that, I think business\-wise that ignoring EU customers is not a good idea because you're missing out on business. Also I think that the spirit of the GDPR is a good one: we (companies world\-wide) *should* care about data protection and privacy, and complying to the GDPR even though you aren't required to is a good way to ensure that. But your mile may vary. Source: [Handbook GDPR, Compliance in practice](https://ictrecht.nl/boeken/handboek-avg-compliance-in-de-praktijk/) (Dutch) by IT lawyer Arnoud Engelfriet, page 11. I also [blogged about this recently](https://www.joyfulbikeshedding.com/blog/2018-04-17-should-non-eu-websites-ban-eu-visitors-under-the-gdpr.html). **Question 2:** The authorities want you to adopt a certain attitude towards data protection: know what data you collect and why, and be proactive in thinking how to protect that data and how you can minimize it (in both time and space). Let's assume you are using default Devise settings whereby you only collect the email address and a bunch of IP addresses (e.g. for tracking when a user has last logged in). Email address is necessary for normal functionality. But are the IP addresses necessary? Do you really need to know when the user has last logged in? If you don't have a good reason for it (beyond "may be useful some day") then you should disable that feature. (Note: logging for security reasons is a good reason) So I think asking what legal compliance implications Devise generates is asking the wrong question. You should generalize this question to a more general case, about **any** system. What data do I collect? What is not necessary and be thrown away? In this sense, Devise does not result in any special compliance questions that you didn't already have to ask. **Question 3:** as I already said, data minimization. Is it really necessary for security and debugging? If no, throw it away or anonymize. If yes, then you have the responsibility to secure it according to reasonable standards. In my opinion, yes you can share it with a small part of your development team, just make sure that you've taken proper security measures and that you don't share it for longer than necessary. One can ask: what is "small"? What are "reasonable security standards"? I can't easily say anything about that without knowing the specifics. But know this: the enforcer is not there to argue about technical details of your security story. The enforcer needs to see that you've done your best, and they would rather see you become compliant if they spot any errors, than to punish you with fines. This latter claim is supported by [the UK's Information Commissioner's public statement](https://iconewsblog.org.uk/2017/08/09/gdpr-sorting-the-fact-from-the-fiction/): &gt;"It's scaremongering to suggest that we‚Äôll be making early examples of organisations for minor infringements or that maximum fines will become the norm. &gt; &gt;The ICO‚Äôs commitment to guiding, advising and educating organisations about how to comply with the law will not change under the GDPR. We have always preferred the carrot to the stick. &gt; &gt;\[‚Ä¶\] we intend to use those powers proportionately and judiciously." My Dutch IT lawyer (not the one who wrote the book) said a similar thing about the Dutch data protection authority. By the way, if you're on AWS, you should sign the data processing agreement with them. **Question 4:** I don't really understand your question. First you say "not normally in GDPR jurisdiction" (which I took to mean that the company doesn't intent to do business with EU customers), but then you say that there is a possibility that traffic ends up in European servers that the company apparently controls. Do you perhaps mean that the company has two branches, a US one and a EU one, and that they have tight organizational relationships, and that the US branch doesn't intent to do business with EU customers but the EU branch does? The fact that it is technically possible for the load balancer to direct traffic to EU servers, tells me the US branch and the EU branch are not properly separated with proper security measures. So you should work on that first. Or perhaps you mean that the company only has 1 branch (for the US) and simply chose to host on European servers even though it still only intends to do business with US customers. I would not recommend this approach. The EU authorities will put question marks on whether you aren't actually intending to do business with EU users. After all, there are tons of alternative cloud providers in the US, and there are even alternative US AWS regions. So why did you pick EU servers? It is very suspicious.
&gt;jemalloc And Redis has decided to jump straight to version 5.1 as default. Also Ruby Core has decided against shipping with Jemalloc by default. [https://bugs.ruby\-lang.org/issues/14718](https://bugs.ruby-lang.org/issues/14718) Jemalloc also doesn't work well with Alpine Linux and Ruby., 
Hmm, reading through that issue discussion, i can't find a decision, just an ongoing discussion. Is there a decision I missed, or elsewhere?
&gt; Also Ruby Core has decided against shipping with Jemalloc by default. &gt; &gt; :(
&gt; criterium Non-native English speaker here with a "fun fact": criteria is the plural form of criterion; criterium is a bike race :))
They haven't decided against it but they've been pessimistic in the change; they believe there will be a non-trivial amount of maintenance in vendoring jemalloc, it will slow down the Ruby build and there will be cases where it increases memory usage over glibc. I don't think any of them actually experience the memory bloat that is so endemic in the Rails world. There's a huge gulf between the Ruby test suite and Discourse benchmarks.
Is the allocator used for every new object? Or only to increase the heap available?
Deploying rails apps before passenger was shit show.
I‚Äôm the same wrt regular ruby/rails dev. Thoughtbot‚Äôs BikeShed podcast and this sub keep me up to date. I also watch a lot of the RubyConf and RailsConf talks when they appear on the ConFreaks channel. 
I'm guessing `nill` is a typo, it should be `nil` other than that I can see some issues/suggesstions * `File.open('fil.txt', 'r')` inside the while loop means you are opening the file again and again.. assign it to a variable before the loop, for ex: `f = File.open('ip.txt', 'r')` * no need to actually test for `nil` , when `gets` returns nil it will be a falsy condition and while loop will end * your implementation would work for single line with multiple words.. you need to use any whitespace like space/newline etc to get word count for multiple lines.. 
There are two things: 1) `nill`, unless it is defined in your session, is not the correct syntax. 2) `File.open('fil.txt', 'r')` would return a new instance of the file every time: ``` &gt; f1 = File.open('fil.txt', 'r') =&gt; #&lt;File:fil.txt&gt; &gt; f2 = File.open('fil.txt', 'r') =&gt; #&lt;File:fil.txt&gt; &gt; f1 === f2 =&gt; false &gt; f1.hash =&gt; 1081115760241248509 &gt; f2.hash =&gt; 734762632214327165 ``` With every new instance, this call `File.open('fil.txt', 'r').gets(" ")` will always return `"Lorem "` ``` &gt; File.open('fil.txt', 'r').gets(" ") =&gt; "Lorem " &gt; File.open('fil.txt', 'r').gets(" ") =&gt; "Lorem " &gt; File.open('fil.txt', 'r').gets(" ") =&gt; "Lorem " ``` Give this a try: ``` 
A slightly more Rubyish structure might be: count = 0 File.open('fil.txt', 'r') do |f| f.each(' ') { count += 1 } end puts count However, you're actually going to get problematic results at newlines, because newlines aren't spaces, and IO's input separation only gives you one character to play with. A line-by-line split and sum might work: count = 0 File.open('fil.txt', 'r') do |f| f.each_line do |line| count += line.split.count end end puts count and we can golf this down further: puts File.new('fil.txt').map(&amp;:split).sum(&amp;:count) or the more memory-efficient: puts File.new('fil.txt').lazy.map(&amp;:split).sum(&amp;:count) 
Thanks! nil was really a typo. I believe the problem was the fact that with opening the file again and again it was resetting the position pointer of the file. 
File.open(filename, mode='r').read.count(' ')
Thanks, I will look into it. I was trying a different thing. Also in order to flex my newbie Ruby knowledge, and gain some experience. But 'split' seems to be the common way to go. The other solutions you presented I will still have to take a deeper look at them. Thanks! I tried a new version of my first code, and I have an interesting result, if you want to take a look. It's in the edit section of my OP.
You're right! I tried an evolved solution addressing the issues you presented. And gives an interesting result. If you want to take a look it is in the edit section of my OP.
The thing about `split` is that it handles the multiple whitespace cases for you and will include tabs, newlines without further hassle. This is the "awk" style of split and is the natural mode that fits most latin script texts. In particular you can expect the same results as `wc -w` on the command line. 
One of the best answer. Thank you. From your past posts, I believe you have a quite few years of experience in Ruby. Would you mind suggesting few resources or steps on how to master/or go deep into ruby especially meta-programming? I always feel like I am perpetually stuck in the beginner level.
I see. 
I'll try it. Thanks!
No prob. The read method will return the contents of the file as a string. Count is a standard method for string that will return an integer. Then +1 because text doesn't usually start or end with a space, and you want a count of words. Another way you could do it is. File.open(filename, mode='r').read.split(' ').length In this case the split method will take the string of text and split it into an array, delimiting by the space character. The result would be an array of every word in the text. The it calls length on the array to get the number of words.
The reason the program breaks when switching between single and double quotes, is because single-quoted strings don‚Äôt process ASCII escape codes( \n, \t etc), and they don‚Äôt do string interpolation, while double-quoted does both. So "\n" is a newline character, but '\n' is a back slash and an n.
Creating the data processing register. We aren't obliged to create one because we're not that big, and because we don't process sensitive data. But we made one anyway because we take the GDPR seriously and wanted to know it well. Creating a register involved listing all our systems (both automated and manual), listing all the SaaSes we use, and analyzing what they do and how they are linked together. This wasn't a challenge in the sense that it was hard, but it was definitely the most boring. The next biggest challenge would be learning about the GDPR itself. It wasn't that hard for me because during my university days I took a single class in IT law. But as a developer I want to know what the implications are for implementation details, and most of the resources out there don't really help you with that. What did help was legal advice from an IT lawyer, and a book written by an IT lawyer. Don't consult a regular lawyer \-\- consult a lawyer that is specifically specialized in IT.
Ah! I knew there were differences between " and ', as some functions don't work well with single quotes but thank you for enlighting me. 
Your question is very short and I know nothing about your specific context, but here's a try. Without knowing you, at the bare minimum you need to learn and understand the GDPR. Yes this is not the answer you're looking for, but the GDPR should not merely be treated as a set of rules on what to do. The GDPR embodies a philosophy on how one's attitude should be towards data protection. It is deliberately written in "vague" terms in order to take into account future technological changes, and in order to allow judges to make fair and proportional decisions that are fitting in each context. This can sound strange to Americans, or people who are from societies that view the government as an adversarial party. They will think, "but if it isn't EXACTLY spelled out how do I know I am compliant", and "but the law is so vague, there is no guarantee that I won't get a 20M fine for a small error". I recommend such people to [read this](https://news.ycombinator.com/item?id=17100541) which excellently describes how the difference between how American and European regulation works, causes so many misunderstandings. Know that Europeans in general have less of an adversarial view of government compared to Americans, which is important in understanding the GDPR. The core principles of the GDPR are: be aware of what data you collect, know why you do it, think about whether you've secured things properly, and think about whether you can collect less. This is in contrast to how a lot of companies treat data: just collect everything and store everything forever because it may be useful some day, and don't really think about security until it's too late. Again, attitude change. Enforcers want to see that you've done your best thinking and implementing things according to above principles. They aren't there to punish you, they are there to make you compliant. You're a developer (I think). If you already use developer\-level no\-nonsense good practices then you are [probably already mostly compliant](https://www.reddit.com/r/rails/comments/8pj3hf/i_am_the_passenger_author_i_have_also_been/e0cmdz8/). Of course, this isn't an excuse to do nothing, the enforcer needs to see that you've taken time to learn the GDPR. You asked "what could I potentially be in violation of". I don't think this is a useful thing to ask \-\- you can be in violation of everything if you did absolutely nothing, e.g. you posted healthcare data on pastebin without password protection. I can help you better if you are more specific.
In fact, we are working on a new GDPR\-related product in order to help organizations achieve what I call "continuous security &amp; compliance". I've seen how painful and boring the GDPR compliance process is. But becoming compliance once is one thing \-\- how do you ensure that you stay compliant? Going through a heavy process periodically is not fun and is error\-prone. And in most organizations, GDPR compliance is handled by a team, but that team's knowledge about what happens elsewhere in the organization will always lag behind reality. So we're working on a product that makes compliance an organizational\-wide responsibility. Everyone can and should contribute. Our app will help you manage your data processing register \-\- using Excel for that purpose really sucks. We'll provide visualizations so that you can see an bird's\-eye overview of how data flows through what systems, so that you can understand your security story better. We'll provide browser extensions and other tools to make it easy to do the right thing by default \-\- e.g. if you sign up for a new SaaS then you won't forget to update the data processing register. We'll provide APIs so that developers (who change systems and therefore can easily cause the compliance story to change) can integrate their apps, systems and deployment pipelines to the data processing register so that they too can help out continuously. By being continuous compliant, we help not only organizations improve their security and prevent data breaches, but we also help society.
* [RubyNewsWeekly](https://rubyweekly.com/) will provide you with cr√®me de la cr√®me of what happened in the community during the week * [RubyFlow](http://www.rubyflow.com/) is self-submitting ruby gems &amp; articles stream. Starting from this two, in a few weeks, you'll quickly understand where the most interesting things are typically written and who to follow.
A really wonderful write up \- I hope this gets accepted!
sinatra is hardly a huge framework. its a fairly thin wrapper around rack. that‚Äôs where you probably want to begin. 
Can you explain what makes Sinatra a 'massive framework'? It has 4 dependencies: - Rack: which is a defining the standard interface between your app and web servers. While there's a few thousand lines of code here, it's pretty much all code your going to want (e.g. handling redirects recursively, normalizing HTTP header fields, working out request/response types. In principle you could do without some of it (.e.g you don't need multipart.rb if you never intend to have a form on your website) but you're not saving much by avoiding it. You also probably don't want to be writing writing webrick servelets (or whateve) so this layer of abstraction is probably mandatory for anything that has to last more than 15 minutes. - Musterman: mostly provides nice around common regexes for URI/path matching. You could probably hand-craft every route by parsing raw HTTP requests, but you're on your way to regex hell. You could do it in less lines of code, but &gt;50% of any given RB file is documentation, so it's doubtful you could do an equivalent job in less work. Again, you could save a bit by dropping 'nice declarations' , and maybe you don't need the fancy AST to match URIs to files on disk, but it's simple enough that there's not much to gain by avoiding it. - Tilt: which is exactly the sort of wrapper around template systems like ERB and SASS, Coffescript, and mardown that you'd want to make. It includes support for a few things you don't need, and if you really hate that idea, I guess you could fork the repo and delete its restructured text support, but this doesn't seem like it's worth avoiding. There's really not much left to strip out here. The remaining dependencies of rack, and it's dependencies' dependencies are limited to stuff you're going to need: rake and minitest. The next step down is going to be building things up on top of Thin/Puma/Webrick etc. ``` #!/usr/bin/env ruby -w require 'erb' require 'webrick' require 'webrick/https' class Ping &lt; WEBrick::HTTPServlet::AbstractServlet TEMPLATE = DATA.read.freeze def do_GET(_request, response) @time = Time.now response.status = 200 response['Content-Type'] = 'text/plain' response.body = ERB.new(TEMPLATE).result(binding) end end server = WEBrick::HTTPServer.new(Port: 8000) server.mount('/ping', Ping) trap('INT') { server.shutdown } server.start __END__ &lt;!doctype&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;ping&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Pong at &lt;%= @time %&gt;.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ``` That's obviously not a great example of anything you could use, but it's really all that's left once you strip away Sinatra.
Hmm. It seemed very intimidating when I looked at it, but I guess it'll pretty much always be intimidating if it's anywhere near useful. I have never done web development before besides static html pages and such. Anyways, thank you very much. I'll have a go at Sinatra!
Thank you. I guess Sinatra isn't all that big after all.
Yeah, I think Sinatra is what you're looking for. 
I'm actually really surprised how much people are interested in these episodes being re\-released. If you ever want to ask some questions directly feel free to contact me on Twitter (@FluffyJack).
I've tried it just now, it seems to be exactly what I need!
This is really nice /u/-TURBOMAN-, but where's the feed for it? I'd like to throw it into my own RSS aggregator, Newsflow, to pull your great resources for Ruby on in.
Thanks. I am in the process of making feed endpoints for each topic. I'll let you know when it's done. 
Sinatra is great for the requirements you described. I've been doing a lot of small things like this with Roda too.
Glad we've been of help!
For such specific questions, I recommend you to consult an IT lawyer. I don't think I am the best person to answer your questions.
**Question 1:** The GDPR does not prescribe specific technical mechanisms. As I've mentioned in other posts, the GDPR is about changing one's default attitude into one of caring about and being serious about data protection. The authorities need to see that you've done your best and that you've carefully considered your options. You have a lot of freedom in choosing your security mechanisms, but you need to be able to explain why you chose a particular setup. Do you need to encrypt the disk? That depends: what attack scenarios are you trying to protect against? We at Phusion encrypt some, but not all, of our servers' disks in order to protect ourselves against vulnerabilities in the hosting provider's admin panel. Yeah this actually happened to us before: someone hacked the provider's admin panel and rebooted our server in recovery mode which did not ask for the root password. But disk encryption results in higher sysadmin burden and does not protect against attacks to running services, so we chose to only encrypt the disks of our most important servers. Do you need to encrypt messages between servers? Again it depends, what are you trying to protect against? If the messages go over links that are already secured at the link level, then extra encryption won't buy you anything. But if the data goes over the public Internet then yeah, encrypt the \*\*\* out of it. What sort of data is passed between servers and systems? Do you process sensitive data like healthcare information? Yeah then it helps to be extra paranoid and employ double encryption. These are all arguments that you can document so that when the authorities visit you, you can show them that you've done your homework. Their main job isn't to punish you with fines, their main job is to make you compliant. **Question 2:** There are few challenges that we didn't already had to deal with pre\-GDPR. There is one minor challenge though: when a user asks for their data, the letter of the law says that I need to provide them with their IP addresses because we log them. But there is still uncertainty even among lawyers as to whether this is really necessary (I got two different answers from 2 different lawyers). And parsing Rails logs to figure out which IP address belongs to which user really sucks. A system that tracks logged in users' IP address would solve that, but that would add **more** tracking which goes against the spirit of GDPR, and my lawyer said we have no obligation to add extra tracking. So what to do with IP addresses in logs is still a gray area. I don't expect this to become problematic. We don't do anything weird with IP addresses: we collect them for security investigation and troubleshooting purposes, we retain them only for a couple of weeks and we secure their access using standard server security good practices (file permissions, SSH keys, firewalls, etc). **Question 3:** See 1. **Question 4:** Depending on how big you are and what data you process, you may be required to keep a data processing register. That register is similar to the list you've mentioned, but it contains more information than just that. I don't know what you mean by "expose" \-\- the register does not have to be made available to the public. In Phusion's case, [we made a register anyway](https://blog.phusion.nl/2018/05/22/itinerary-of-a-software-company-until-the-gdpr-deadline-part-1/) even though we aren't required to. Such a register gives us insights into what's going on with the data flows. See also [this comment](https://www.reddit.com/r/rails/comments/8pj3hf/i_am_the_passenger_author_i_have_also_been/e0e807i/) in which I wrote more about the data processing register. **Question 5:** Depends. If the emails contain personal information, and your lawful basis for processing that information is "consent", then yes you need to delete those emails. But if your lawful basis is something else, e.g. "compliance to legal obligations", then no. For example if I forwarded invoices (which contain customer addresses) to an internal mailing list of accountants then I am allowed to retain them for 7 years (or whatever the retention period is according to local tax laws) for the purpose of tax reporting. Data subjects do not have the right to be forgotten in such a case. See also: [the UK Information Commissioner's explanation on lawful basis](https://ico.org.uk/for-organisations/guide-to-the-general-data-protection-regulation-gdpr/lawful-basis-for-processing/). But data minimization is still a thing. When the accountants are done archiving those invoices, they should delete the original emails. If you don't have a good reason to keep something, then don't keep it. Now, you specifically said that you're dealing with meta information. It doesn't sound like personal information to me, but the devil is in the details and I don't know your system. Does the data contain email addresses so that you can associate stats with a specific user? Well then that is personal information. Or, instead of email addresses, it contains opaque account IDs? That's already much better (called pseudonymization). What do you use the data for? Are the email addresses or account IDs really necessary? Can you throw them away or anonymize them in such a way that you cannot relate them back to the original users? If so then do it. **Question 6:** I've been wondering about that myself. My lawyer [wrote a paper about this subject](http://aphd.ua/publication-224/). I haven't read it so I have no TLDR. :)
You could chime in on https://bugs.ruby-lang.org/issues/14736 which is the only place the ruby core would be guaranteed to see it.
This is super interesting! Any particular reason for using XML?
Thanks, fts. The XML can be parsed reliably and without much fuss. Actually, the logger is a simplification of my test logger, which does considerable post-processing (for reports, etc.).
Small objects are stashed directly in the heap slots but larger objects like long strings need a malloc for every object. MRI really benefits from a better allocator. We observed a 10% increase in web throughput from switching to jemalloc.
Maybe using some sort of combinatorics gem? https://github.com/postmodern/combinatorics
I suspect you'll be needing the array's [permutation method.](https://apidock.com/ruby/Array/permutation)
 File.readlines(fil.txt).size
That feeling never really goes away, y'know. I'm not an expert, I just have a longer back catalogue of mistakes. Happy to give you my own go-to resources and suggestions though. Off the top of my head: * Avdi Grimm's [RubyTapas](https://www.rubytapas.com/) series. It's a subscription site and well worth the price. The series is long (over 500 episodes and still growing), high quality, well paced, and covers a diversity of topics that explore many facets of Ruby programming. * Reading [Sandi Metz's books](https://www.sandimetz.com/products/). Many Ruby books will just teach you the mechanics of doing something. Sandi Metz will teach you to think critically about the structure of your code. * Watching [Sandi Metz's talks on YouTube](https://www.youtube.com/results?search_query=sandi+metz), especially "All the little things", "Get a whiff of this" and "Nothing is something". Also some [Jim Weirich](https://www.youtube.com/watch?v=NLT7Qcn_PmI). * Reading Ruby source code. If you use a framework or gem or even just something in the standard library, read the source code of features you use. Read and trace through until you understand fully how that feature was implemented. Sometimes it's a terrible mess, but usually it's an eye-opening journey into someone else's thinking. The source code for Ruby on Rails, for example, has both. It really helps if you're familiar with the feature in question, since you know the expected result. * Read the source code of Ruby itself. Again, I suggest you start by following a language element you're familiar with all the way down the rabbit hole. * Write an internal DSL. Read one of the many guides on writing DSLs in Ruby, then implement one yourself for something you need. When I first did this I went way overboard and the result was a massively over-engineered and buggy reinvention of core language features, but I learned a lot. * Write and publish a gem. It doesn't matter if no-one uses it. Simply knowing that your code is public will lift your game. * Making friends (in person) with Ruby devs and bouncing ideas off them. This is the real value of a RubyConf, by the way. The talks are nice, but the greatest value is in meeting people and sharing ideas. * Try answering people's questions on Reddit (or for the truly brave, Stack Overflow) on topics you don't understand. Do all the research, write some examples, boil it down to a couple of paragraphs if you can, ask a friend to review your answer. You don't even _have_ to post it if you're not confident, just write the answer for yourself. Some people like to follow a programming koans feed, but I prefer the messy and sometimes poorly articulated real world. Hope this helps. Don't forget to have fun along the way:) 
Forgive me for my ignorance \-\- but isn't deploying on heroku just as easy if not easier? heroku has been around for years now, and it's very easy to deploy indeed.
that was fun! i wrote this: s = 'cat' output = [] for len in 0..s.length do for start in 0..s.length do break if start + len &gt;= s.length sub = s[start..(start + len)] output &lt;&lt; sub end end sure hope i didn't just do a homework/interview problem for you ;)
 substrings = Hash.new do |hash, key| hash[key] = case key when ""; [] else (0..key.length-1).inject([]) do |acc, index| acc &lt;&lt; key[0..index] end + hash[key[1..-1]] end end substrings["cat"] #=&gt; ["c", "ca", "cat", "a", "at", "t"] 
that seems simple: ``` class String def substrings length.times.reduce([]) do |memo, size| memo + Array.new(length - size) do |index| self[index..index+size] end end end end puts 'Animal'.substrings.inspect # [ # "A", "n", "i", "m", "a", "l", # "An", "ni", "im", "ma", "al", # "Ani", "nim", "ima", "mal", # "Anim", "nima", "imal", # "Anima", "nimal", "Animal" # ] ```
clean
I‚Äôm talking around 2008? Rails 1.0. Before that we were proxying from Apache to mongrel clusters. I‚Äôve never used Heroku so maybe I am/was doing things the wrong/hard way.
There are exponentially more permutations of a string than there are substrings of a string, so this is going to do a lot of work that you'll have to throw away and is not very computationally efficient. For example, one 2-permutation of `hello` is `le`, but that's not a substring.
look up mergesort tree
I like this version very much, and here's a slight rearrangement to produce the exact output requested: class String def substrings length.times.reduce([]) do |memo, index| memo + Array.new(length - index) do |span| self[index..index+span] end end end end 
``` s = 'cat' (0..s.size).to_a.combination(2).map { |a, b| s[a...b] } ```
Almost, but he's not looking for [2,1]. So it's actually the `combination` method that he needs. Posted a snipped with it. I'm not a fan of one-liners.. but sometimes they are fun: https://www.reddit.com/r/ruby/comments/8pva8s/substrings_problem/e0eus1b/
I experimented with fibering I/O sources in my Ruby infrastructure back in 2010. em-synchrony and goliath tried to popularize the same. It made the process runtime really fragile and prone to sudden slowdowns (if a blocking I/O source slipped in somehow) and a source of really tough debugging problems. Gave me new appreciation for blocking I/O and readable stacktraces.
I have application code that relies on `Array#combination` and I worry about it, because the generation order is specifically not guaranteed or so says the doco. In practice it is fine, we just have some realistic tests to defend against regression when bumping Ruby version. 
I understand where you are coming from and I did study em-synchrony. Threads have their own downsides too. For the best best performance you should definitely run async with multiple processes. Not sure why stack traces would be any worse with fibers?
Why would someone be writing a performance sensitive service in ruby though?
If you use `each_with_object` and concatenate to the memo instead of `reduce` you'd generate a _lot_ fewer arrays. Should be substantially faster for larger strings. 
Your example works just fine, so I definitely don't want you to take this the wrong way, but I'd avoid using for loops in Ruby. I can't think of a single instance where a for loop was more suitable than a `times do` loop or `each` iterator. For loops in general are just very 'not Ruby'.
 class String def substrings length.times.each_with_object([]) do |index, memo| (length - index).times do |span| memo &lt;&lt; self.slice(index, span + 1) end end end end 
I manage a feed aggregator with ruby news and blogs: http://rubyland.news
The best suggestions I have received on this ruby sub-reddit group. I have subscribed the RubyTapas and have stopped watching the episode after few. I have to start now. Do you have any suggestions on any specific C books/resources?
Why monkeypatch String though :( was specifically not the challenge, and should never be a goto
Heroku and Passenger are not mutually exclusive. [You can combine them](https://github.com/phusion/passenger-ruby-heroku-demo) for better performance and features.
Thank you for the write-up! Just to make sure I understood, would this enable making any gem that does IO async-aware? When I was researching EventMachine, I wanted to understand how exactly do Fibers improve things, and it took some time for it to click. For those who are not familiar, [this blog post](https://www.igvita.com/2010/03/22/untangling-evented-code-with-ruby-fibers/) should shed some light. TL;DR: Fibers allow you to write asynchronous code in a sychronous way, reaping the performance benefits of asynchronous code while avoiding callbacks.
\&gt; Thank you for the write\-up! Just to make sure I understood, would this Ruby patch enable making any gem that does IO async\-aware? Yes. However, it works both ways. It makes it possible for other gems to take control of IO \- e.g. it would be possible for EventMachine to use this mechanism too, or Puma (it has it's own event loop AFAIK). It's basically opening up the base IO abstraction in a way that allows for different concurrency abstractions. With a few additional changes, it would even be possible to implement async/await futures/promises type callbacks. \&gt; and it took some time for it to click Yes, I know how you feel. Another good blog post is [http://journal.stuffwithstuff.com/2015/02/01/what\-color\-is\-your\-function/](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)
fair enough, i've been writing way more python than ruby lately
Wanting more performance for your service doesn't automatically imply that your service is performance-sensitive. Btw, Samuel only said what combinations of threads/processes would have best performance, nothing wrong with choosing an optimal combination. Also, the `async` framework isn't really about speeding up Ruby code (at least not for me), it's about helping you to utilize your CPU to its full power. With classing web servers it's common to have waiting on IO operations affect the request throughput, because your web workers cannot serve requests while they're tied up on waiting for IO operations to finish. `async` fixes that by eliminating the waiting. As an example which benefits a lot from the `async` framework, I maintain a [Ruby implementation](https://github.com/janko-m/tus-ruby-server) of resumable uploads. It contains two sensitive features: receiving uploads and serving downloads. Classic web servers either don't have streaming requests/responses, or enabling it can have significant impact on the request throughput, so there are caveats in running my service on them. On the other hand, the `async` framework was made for running such a service, due to its asynchronous nature.
&gt; It made the process runtime really fragile and prone to sudden slowdowns (if a blocking I/O source slipped in somehow) and a source of really tough debugging problems. I've been thinking about this. We already have a set of debug wrappers which catch incorrect usage of the reactor (e.g. calling `#read` from multiple fibers, etc). Based on your feedback another idea I had was to add latency checks. We can definitely track the latency of any given task, and issue warnings if it's blocking the reactor. These checks would only be enabled with the debug wrapper around the reactor, so it wouldn't affect production code, but in your specs it would give you feedback if any particular part of your code was blocking the reactor.
sounds like too much effort when heroku does everything i want
interesting, so I did implement different algorithms to the code and ran a benchmarking: require 'benchmark' class String def substrings_using_reduce length.times.reduce([]) do |memo, size| memo + Array.new(length - size) do |index| self[index..index+size] end end end def substrings_using_each_with_object length.times.each_with_object([]) do |size, memo| memo &lt;&lt; Array.new(length - size) do |index| self[index..index+size] end end end def substrings_recursive(scan_size: 1, current_index: 0, results: []) return results if scan_size &gt; length word = self[current_index...(current_index + scan_size)] if current_index + scan_size == length new_scan_size = scan_size + 1 new_current_index = 0 else new_scan_size = scan_size new_current_index = current_index + 1 end substrings_recursive scan_size: new_scan_size, current_index: new_current_index, results: results + [word] end end string = 'These violent delights have violent ends' * 5 puts "string length is #{string.size}" Benchmark.bm do |bm| RubyVM::InstructionSequence.compile_option = { :tailcall_optimization =&gt; true, :trace_instruction =&gt; false } bm.report { string.substrings_using_each_with_object } bm.report { string.substrings_using_reduce } bm.report { string.substrings_recursive } end # [ # "A", "n", "i", "m", "a", "l", # "An", "ni", "im", "ma", "al", # "Ani", "nim", "ima", "mal", # "Anim", "nima", "imal", # "Anima", "nimal", "Animal" # ] The results here were (and by the way I had to increase my maximum stack size to not run into Stack too deep): 1st is the `each_with_object` version, 2nd is the `reduce`, third is the `recursive` string length is 200 user system total real 0.015283 0.000521 0.015804 ( 0.015805) 0.020919 0.008509 0.029428 ( 0.029488) 16.945756 0.654898 17.600654 ( 17.727241) and comparing `each_with_object` vs `reduce` approach with a very long string: string length is 2000 user system total real 2.992152 0.701866 3.694018 ( 3.703809) 23.673747 12.249739 35.923486 ( 36.313198) So you were right! Much faster 
Should have added: A main point of this logger is to have nested structuring both in the code and in the log. So the log format needed to be something that has a natural nested structure, and of course also something that's standard.
Should have added: A main point of this logger is to have nested structuring both in the code and in the log. So the log format needed to be something that has a natural nested structure, and of course also something that's standard.
Seems like the key feature it's missing is to tell you what time the game is on in your local TZ.
From the README: &gt; Currently, if you want your app architecture not to follow strict framework's _frame_, you can take ROM or Sequel for _data layer_; Sinatra, Roda, or Grape for _routing layer_; but for _view layer_, the situation seems to be different. Typical "views" part of the application (say, with Rails, Hanami, Padrino) is bound to a lot of conventions (like "it will look for the corresponding template in that folders") and global configuration, and tightly coupled with routes/controllers ("if you want data from controller to be passed to view, you mark it so an so"). &gt; **Sho** is an experiment to provide view layer that is "just Ruby" (= follows the regular intuitions of _Ruby_ programmer, not introducing some hidden conventions that are not deductible from the code) and reuses regular Ruby concepts for code sharing, parameters passing and flow structuring instead of introducing its own concepts like "helpers", "exposures", "locals" (completely unlike local variables!) and so on.
Python similarly shys away from looping with indices.
There is a bug in your `substrings_using_each_with_object` version. `memo &lt;&lt; Array.new ...` should be `memo.concat Array.new ...` 
Oops, thanks
Bare Ruby can be pretty fast these days, especially if lots of I/O is involved. We're a long way from the 1.8 days. It'll never be as fast as Go, for instance, but much of the slowness today is the overhead of heavyweight frameworks.
The football.db JSON HTTP API includes the hour / time and timezone, see &lt;https://github.com/openfootball/world-cup.json/blob/master/2018/worldcup.json&gt;. Might be a great exercise for a first time contribution :-). Enjoy the beautiful game. Cheers. Prost.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [openfootball/world-cup.json/.../**worldcup.json** (master ‚Üí aba3eca)](https://github.com/openfootball/world-cup.json/blob/aba3eca3e1f89e6f620c0c12438d9dfc6964f25e/2018/worldcup.json) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e0g2058.)
I would prefer to see people contributing to crystal\-lang...
With crystal\-lang it is easier [https://www.reddit.com/r/crystal\_programming/comments/6813ae/what\_would\_it\_take\_to\_build\_helix\_for\_crystal/](https://www.reddit.com/r/crystal_programming/comments/6813ae/what_would_it_take_to_build_helix_for_crystal/)
omg everyone is a critic. implement this in python without using indices, i'll wait. you'd think my solution is the worst one in this thread given the criticism, in the meantime people are playing code golf and nobody says peep.
Get over yourself. Idiomatic code is a cornerstone of good programming.
the first solution in this thread monkeypatches `String`. the next one uses an unsafe ordering of `combination`. the third one is an illegible string of symbols. which one is the most idiomatic? oh, i'm still waiting on your python implementation without indices. those who can't do -- criticize on the internet.
Lol just fuck off why are you so upset about this all I said was that something wasn‚Äôt particularly idiomatic. Anyway challenging people to do things and saying they have no point without doing so is childish and pathetic. Either accept something is idiomatic or it isn‚Äôt. I don‚Äôt care if you do or don‚Äôt, but don‚Äôt keep whinging to me.
Or: count = 0.tap do |it| File.open('fil.txt', 'r') do |file| while file.gets(' ') do it += 1 end end end puts count
THANK YOU!
Do you have any speed tests, u/zverok_kha? I really like this idea. Ruby is too dependent on Rails and we got used to using entire frameworks, as a community, if we can move to more library style apps that would be an interesting alternative
i like it
Awesome, I have been meaning to start with Go. 
I've been using it for a few months, it doesn't hurt :) You just have to get used to the more verbose syntax and static typing.
What would be a good approach to speed\-up SQL queries in a rails 5.2 app without write RAW SQL queries? For instance, I have an application which has lot of controllers doing some SQL queries. It's a web service, with a lot of data, so every select is expensive. Should I for example implement a Repository pattern rewriting some ActiveRecord queries direct with Arel, or should I do it using sequel? To drop ActiveRecord, isn't an option. 
&gt; Do you have any speed tests Not at the moment (the whole idea of this API/library is ~48 hours old), but "intuitively" I don't expect any non-trivial slowdown here, comparing to raw Tilt rendering (which is known to be pretty effective). Will try to use it in library form more, myself, and report performance, too
I really like [codewars.com](https://codewars.com). You can also try [exercism.io](https://exercism.io). 
thanks
1.) You need to use `puts` to print to the console (`puts string.special`) 2.) `return` in blocks don't work as expected, see https://stackoverflow.com/questions/2325471/using-return-in-a-ruby-block 3.) Your implementation of `all?` doesn't return the correct result (assuming you're trying to mimic the behavior of `Enumerable`'s `#all?` method).
Yes, return doesn't work as expected in inline blocks?
There are a few issues: In Ruby, everything is an "expression". The statement inside your block `return false if ....` will return `false` (from the whole method, by the way, not just from the block iteration) if your condition evaluates to truthy. But if the condition evaluates falsey, the statement as a whole will give `nil`, since the `if` statement has no `else` branch. 2. For `special`, need the `!` to apply to the entire end result, not just the inner regex check 3. Your `all?` implementation should give a boolean value at the end, but right now it will just give `false` every time because eventually the `while` predicate will evaluate to `false` and that'll be what the `while` loop gives. Here's something working: ``` class String def all?(&amp;block) i=0 all_so_far = true while all_so_far &amp;&amp; i &lt; self.length all_so_far = block.call(self[i]) i +=1 end all_so_far end def special !self.all?{|c| (/[a-zA-Z0-9]/ === c)} end end ``` That being said, this is a better way to go, where you leverage Ruby's `Enumerable` module: ``` class String include Enumerable def each(*args, &amp;block) # delegate to the `chars` collection chars.each(*args, &amp;block) end def special? any? { |c| /[^a-zA-Z0-9]/ === c } end end ``` But honestly, I wouldn't monkey patch String ever. Every class/library everywhere will be using Strings in all kinds of ways, so you don't want to mess anything up. I'd put the `special?` method elsewhere and pass the string as an argument
 Return from inline blocks is lexically scoped. E.g.: ``` def foo(&amp;block) block.call puts "after call" end def bar foo do return end puts "after foo" end bar puts "after bar" ``` .. prints "after bar" only, as the return is lexically scoped to "bar", and so exits bar, rather than exit out of the block. So, it depends what you expect, I guess. 
And, if you're defining `String#any?` just for use in this `#special` methods, I would recommend just implementing it worth an embedded call to `chars.any?` directly rather than extending String with additional enumerable methods...
Solo learn app
It does matter a great deal, because it affects the time-complexity over various algorithms. Now, as other people have noted, Array does use a contiguous amount of memory for the object references, and this e.g. means that a lookup for an item in a Ruby Array has a time complexity of O(1) (since it's just a matter of calculating an offset from the start of a buffer and retrieving the value there). If it was implemented as a linked list, then to traverse the n'th node would have a time complexity of O(n). That is an important thing to be aware of, because it makes a difference between whether or not you can e.g. verify that the lookup cost is acceptable by benchmarking against a small Array vs. needing to assess the average and worst-case Array size you might need and verify that performance is adequate at those sizes. Understanding the complexity trade-off is essential to understanding what and how to test, and which data structures are appropriate. 
I think the main reason to ask that question is that if you serialize as e.g. JSON, then passing the data to Elasticsearch or similar for indexing is almost "free". A lot of log processing tools natively support or expects JSON. It also benefits from a lot of support for to_json/as_json for custom objects (though you can take advantage of that too: instead of doing a kind_of?(Hash), do as JSON.generate() and check if the object supports to_hash or to_h - optionally also 'as_json"; that will give you "free" support for outputting a lot more types of objects than explicitly checking for Hash. 
Sololearn is good but I needed something that also gives you ideas for what to code like [codewars.com](https://codewars.com). Thanks though.
Solo learn does that, there's a community that posts challenges, ideas, concepts etc.
really? how do i find it?
I think framework style and library style both have their place. The ideal framework would be composed mostly of libraries that can (and are well-designed enough to make sense to) also be used independently. Just takes a lot of work to get there. Rails... tries. But yeah, I like this too. 
I love these sort of articles that demonstrate the similarities between two languages. There was another that compared Rust and Ruby. 
check out http://rubykoans.com/ and https://rubymonk.com/ I've also put up a few basic-intermediate exercises: https://repl.it/community/classrooms/53963 ... feedback has been mixed so far, some say these are easy, while some beginners found it a touch too hard..
By the way, there's a free book called practing ruby with written up examples, see &lt;http://yukimotopress.github.io/practicing&gt;. Cheers. Prost.
the last website looks really good, thanks
I agree, it's the approach we took with our framework. 40+ small libraries that can be used on its own, with one "meta gem" that you can add to your Gemfile and get everything. There's a lot of tooling we've had to build to make the entire project more manageable, and there is some tedium involved with managing so many libraries, but the end result seems to gain the benefits of both approaches, with limited downside. I think Rails was not successful with a decomposed library approach because it wasn't built from the ground up that way. (Which is not a criticism, just the way it is)
Just download the app and there's an activity feed with challenges and concepts plus the code playground, if you want to practice you could scrape a load of ruby codes from the playground and improve them
Again no. Ruby may have optimizations that say that when the array is small it's sequential locations in memory, but over a certain size it's a linked list. If the performance of something matters because it's either O(1) or O(n) you probably shouldn't be programming that critical component in Ruby, because there are all kinds of other gotchas that will hurt performance, like garbage collection.
No worries. I think you can pick 8 and 7 Kyu katas. I learned so much by trying and reading the solutions from other people. If you decide to try and need help, ping me and I‚Äôd be happy to help. P/S: You can ping me anyways even if you don‚Äôt try those specific sites. 
Thanks, rubygeek. I will look into this. The main thing I don't see in JSON is the ability to log a formatted multiline string, which I've put into CDATA in the XML. Such data could be put into JSON as an array of strings. Actually, the in-progress log is a constantly-flushed text file. In case the process craps out entirely, there's some residual info. Because of that, the XML log is generated all at the end, in method :dispose. That method could easily gen XML, JSON, or even YAML, per use selection. 
Alright, I will look into it. Thanks! 
Okay mate thanks a lot
&gt; Again no. Ruby may have optimizations that say that when the array is small it's sequential locations in memory, but over a certain size it's a linked list. That'd be theoretically possible, but it's not the case - [read the source](https://github.com/ruby/ruby/blob/trunk/array.c) - specifically ary_resize_capa(). It does various optimizations such as embedding really small arrays, but they still use contiguous chunks of memory. Ruby's Array uses a very standard amortized cost dynamic array. &gt; If the performance of something matters because it's either O(1) or O(n) you probably shouldn't be programming that critical component in Ruby, because there are all kinds of other gotchas that will hurt performance, like garbage collection. That's not how big-O notation works. The whole point is that even if he constant time cost is acceptable, if the complexity is unsuitable for the operations you need, then that constant time cost will quickly spin out of control, hence why big-O notation explicitly excludes the constant factors. This is the case irrespective of what language you use - the only thing that differs is how large the dataset needs to get before you need to pick more suitable algorithms. That *can* be an issue, but there are plenty of uses where Ruby works just fine if you pick suitable algorithms but would not be acceptable at all if you don't pay attention to complexity. To put it another way: If you have an array of a million elements, and the cost of a constant time lookup is 1 micro second, then the average lookup time with a linked list (assuming the traversal costs the same as a single lookup for simplicity) is 0.5 second and the worst case is a second, while with a proper Array it's 0.000001 second. Do a million of them, and the average time with the linked list will be 5.8 *days* vs. 1 second for the proper Array, and if you're unlucky with the distribution you might spend twice that. Now, the constant cost of traversing a linked list for retrieval is likely to be *far worse* than for a proper array - for the array once the argument checking is done you're adding an offset to a memory location and retrieving a value, vs. thrashing the cache while following one pointer per node, so it's likely to be worse than that. Yes, there are other gotchas, but you know what? I've had projects with far larger Array's than 1m elements that have performed just fine that would certainly not have if I increased the cost of lookups from O(1) to O(n). 
Check out goldiloader gem https://github.com/salsify/goldiloader it intelligently does the eager loading for you, and links to a blog post explaining some of the encapsulation problems with using includes in your code.
I think it's a bit of a stretch to say that Rails "was not successful"! :) But yeah, I'd agree it has not been _as_ successful, specifically in the architecture/design area, as some would like, and agree that it's hard to try to retrofit that onto an architecture that wasn't very intentionally, carefully, and probably slowly built that way from the ground up. (Rails 2.0 and the great merb borrowing was when Rails started thinking more seriously about architecture and composability for re-use, I think). And of course, it's not _just_ X small libraries that can be used on their own, but that they work _very well together_ when used together, without you having to write a lot of reinventing-wheel glue code. This stuff is _hard_. To get something that is well-architected for composability and re-use (without the framework), _and_ works great for people who want it to "just work" with the framework-suggested integration without having to reinvent it all. It is _not_ generally a question of lacking motivation or intentions, but that intentions are not enough. I think it takes both a lot of time and a lot of skill. As separate things. There's a lot of code to write which takes time (which makes it hard to catch up with an existing mature solution), but spending time to write a lot of code alone is no guarantee you will succeed and pull it off. 
Big O notation makes sense when the time the entire operation takes is dominated by that operation. If you have to sort a big list and then print the results, the sort operation may be N Log N, but it *doesn't matter*. Why? Because printing the results out is almost certainly going to take much more time than the sorting. If you have an array of a million elements in memory at the same time, you probably shouldn't be using Ruby to deal with it. It's telling you have to come up with such an absurd scenario to try to come up with a case where it matters. 
My (very raw, to say the least) current theory, which I am trying to check with the library and try to outline with the "post-framework" term that the dichotomy of "framework (with tightly coupled layers)" vs "independent libraries (with a lots of glue code and boilerplate)" is a false dichotomy, at least for language as expressive as Ruby is. In this mind experiment, I am trying to think towards a _minimizing_ of the surface of contact between layers (instead of maximizing it for "convenience") -- but I am thinking about convenience too. The question that I am asking myself and trying to answer is "could a set of libraries with small interfaces without _any_ assumptions about code/architecture be as convenient as a framework"? I don't believe the question is purely rhetorical. The downside _and_ upside of this approach is staying alone when it comes to the whole app architecture. For me, it is exactly what I want -- and it seems the same for many and many people who come with their own architectures (this operations/"service objects", form objects, view models, ...) _on top_ of Rails, frequently going as far as leaving almost empty models and controllers and logicless views, with all the "meat" in their own "framework". Seeing this happening again and again (on recent Ukrainian RubyC conference 50% of talks were something about "what architectural components we added to Rails to make it bearable"), I started to think a bit further... And to that moment, I am interested in how far I can go on this path.
&gt; If you have to sort a big list and then print the results, the sort operation may be N Log N, but it doesn't matter. Why? Because printing the results out is almost certainly going to take much more time than the sorting. I find it hilarious that you're suggesting my scenario is absurd when you feel compelled to come up with such a contrived scenario to counter it. I agree - if all you need to do is sort a list, there are plenty well optimised tools that are better. &gt; If you have an array of a million elements in memory at the same time, you probably shouldn't be using Ruby to deal with it. It's telling you have to come up with such an absurd scenario to try to come up with a case where it matters. If you think it's an absurd scenario, you have severely outdated ideas about the performance characteristics of Ruby. I'm routinely processing datasets consisting of hundreds of thousands of JSON documents representing graphs of millions of entities with tens of millions of attributes we need to filter and group and extract information from. One of the datasets sitting on my laptop right now is 850MB in 120K files. It's mid-sizes. With no optimisation it runs the algorithms we need on that dataset in about 20 seconds. That involves building several arrays and hashes with several million attributes each, and doing millions of lookups to process connections in the data. 20 seconds on my cheap laptop is fine. The *days* it'd take if the complexity of the relevant lookups was O(n) instead of O(1) on the other hand would not be. We don't load it into a database to run the queries because when we tested it, it was slower - the process of doing the inserts alone outweighed the processing cost of reading in the raw files and computing the data directly in Ruby and writing out the results (if we were doing lots of repeated processing of the same data, that'd change, but we're not). Ten years ago, the constant overhead of doing this kind of thing in Ruby made it at least slightly challenging (as in: we had to ensure the processing was split across multiple servers), though I processed millions of RSS feeds a day and 100 million documents a day using Ruby back then too - ironically for that system what made it cost-effective to use Ruby was that we were limited by network IO long before the CPU overhead of the then far slower Ruby version on far slower CPUs became a bottleneck once we'd spent a just a little time actually thinking about algorithmic complexity and concurrency. Sure, there are things Ruby is too slow for, but you can scale Ruby to far larger data structures than you see to realise with very little effort. 
IMO the best is to get out the box of books, lessons and all that stuff and get down and dirty making something, anything, it doesn't matter. Just write code!
i was thinking of making a simple blackjack game but for some reason the idea of practicing ruby in websites like [codewars.com](https://codewars.com) got stuck in my head
I'll reiterate what the others said and recommend codewars. I learnt lots, quickly playing with it but had to keep going through the 8, then 7 (and i think maybe a 6!) until I really started to get it. Some of them are really oddly classified though, I've had 8s that I could not get my head around, then others I managed in a few moments! Don't get too disheartened. 
&gt; I am trying to think towards a minimizing of the surface of contact between layers (instead of maximizing it for "convenience") -- but I am thinking about convenience too. The question that I am asking myself and trying to answer is "could a set of libraries with small interfaces without any assumptions about code/architecture be as convenient as a framework"? that's the dream, certainly. I don't think it's crazy, I also don't think it's unique. I think almost any large project you can think of, people were _trying_ to do this, they didn't fail for lack of trying. 
A game is a good idea. You can even add in some rules to level up your code, like, no more than 5 lines per method, no more than 100 lines per class, no more than one conditional per method :)
that does sound like it'll help me get better at coding thanks a lot man!
There is a phrase from old [Strugatsky's brothers](https://en.wikipedia.org/wiki/Arkady_and_Boris_Strugatsky) novel I really like: "Yes, of course, we realize the problem is unsolvable. What we are currently more interested in, is how to solve it" :) Something like this.
ha, i like that. Which novel is it from? I've only read _Roadside Picnic_ (in English translation). 
&gt; preload method is nothing new - it is just an alias for #includes method. Technically, I _think_ is not true. `Includes` will use `preload` in some cases and `eager_load` in others, as appropriate. I think. It's not well documented and the code is not easily legible. But that's what this one says (it's certainly possible it's changed since then). http://blog.scoutapp.com/articles/2017/01/24/activerecord-includes-vs-joins-vs-preload-vs-eager_load-when-and-where At any rate, it does not appear to be an _alias_. https://github.com/rails/rails/blob/c81a7fcf76663e6d189792d6eed57b1162199635/activerecord/lib/active_record/relation/query_methods.rb#L114-L125 https://github.com/rails/rails/blob/c81a7fcf76663e6d189792d6eed57b1162199635/activerecord/lib/active_record/relation/query_methods.rb#L147-L155
Sorry, I think I was ambiguous. Rails was obviously a runaway success as a web application framework. However, it has not succeeded at delivering a framework composed of libraries that can be used independently of one another. &gt; This stuff is hard. To get something that is well-architected for composability and re-use (without the framework), and works great for people who want it to "just work" with the framework-suggested integration without having to reinvent it all. Yes, definitely. It's hard work in the sense that you have to be willing to proactively correct mistakes before they impact users and attract coupling. It's also cognitively difficult to map out the right boundaries between components/libraries. Software design (and architecture) is exhausting. And it requires a good deal of hands-on practice (years, even) of delivering software designed to be used by other programmers in order to even have a chance at success. A lot of teams have good intentions, as well as the right level of discipline, but they frankly don't have the experience necessary to pull off a healthy library ecosystem. So, me saying that Rails failed at this doesn't really mean much. They really didn't view library composition as a chief (or even ancillary) concern. Even the Rails 3 rewrite didn't really decouple things all that much, as far as I've been able to tell. In today's ruby landscape, most devs I know avoid gems that depend on ActiveSupport, for instance. I can't pull in ActiveRecord to a project without getting a whole lot of the rest of Rails to come along with it.
_Monday Starts on Saturday_. Most of (older) post-Soviet geeks love it: it describes the everyday life of "Institute of Magic", and it is pretty like a large generic engineering/programming collective life description, lot of humor and lot of devotion to work and problem-solving.
Awesome, adding the English translation to my Amazon cart for next order i make. 
Agreed. It's possible that if you _do_ focus as much as is (or seems at the time) needed on _architecture_, you don't wind up delivering anything useful, at least not in time to succeed. Is the trick of it. It's all a bunch of balancing acts at once. That's why we get paid the big bucks? (Yeah right, if we do, _that's_ not why haha). But yes, double triple this: "it requires a good deal of hands-on practice (years, even) of delivering software designed to be used by other programmers in order to even have a chance at success." Some day our peers will collectively realize that experience and learning from what's come before matters? One can hope. (And as someone doing Rails since 2.0.0 (on a project that was started under 1.x), 3.0 (I misremembered, you're right, it was 3.0 that was the Big Rewrite) really really did decouple things a _lot_ compared to what was there before. It also resulted in pretty severe upgrade-rewrite pain, of the likes that I think Rails could probably not afford again. Didn't help that ruby 1.8-&gt;1.9 with char encodings was at the same time.). 
&gt; such a contrived scenario to counter it Yes... because printing out the list of things you sorted is so contrived.
Whether it's expected or not depends on your expectations. I bet you expected what ruby does here: def has_the_magic(array) array.each do |i| return "YES!" if i == "magic thing" end return "NO!" end
i'm not sure what you're asking but couldn't you convert the file to base64 ? 
&gt; It's possible that if you do focus as much as is (or seems at the time) needed on architecture, you don't wind up delivering anything useful, at least not in time to succeed. Is the trick of it. It's all a bunch of balancing acts at once. Thanks for the response. I do want to challenge this idea that if startups didn't put as much pressure on themselves to deliver more features (and less architecture) as much as they did, that they wouldn't succeed. I've worked with hardware engineers where mistakes would cost the company millions. Investor and executive expectations were calibrated accordingly. Correspondingly, in the world of web development startups, we're usually on a short leash and have a very limited amount of time to show lots of progress. What made Rails so disruptive in 2006, IMO, is also what sets feature delivery expectations so high today. Most executives and investors don't believe that bad code will sink their business the way a botched chip will, but that's only because they don't see (and thus quantify) the extent to which bad code amortizes and compounds pain over time. And so to be honest, I think web startup culture could stand a pendulum swing back to relaxing the feature delivery expectations set in the first 6-12 months, and increase expectations on quality. Of course, plenty of teams _do_ get a management green light for a architectural investment, but fail to deliver ROI. I see the business owner's perspective, too. At any rate, I don't think architectural investments jeopardize companies nearly as much as they strain the relationship between programmers and executives. Welp, you done it, you got me rambling now! &gt; Some day our peers will collectively realize that experience and learning from what's come before matters? One can hope. It's tough. I wish there formal education of some sort that taught the skills necessary to build and maintain sustainable software systems. The knowledge is out there, in bits and pieces, waiting for someone to take on the monumental task of stitching it into a curriculum. Right now, the programming world is largely led by thought leaders. Many of them are wonderful people, but they're no substitute for formalized knowledge and learning. Cheers! (PS I remember the rails 2 -&gt; 3 upgrade... wow that was a doozy. I did find ActiveRecord's internals easier to follow pre 3.0)
&gt; (PS I remember the rails 2 -&gt; 3 upgrade... wow that was a doozy. I did find ActiveRecord's internals easier to follow pre 3.0) I think these things are not entirely uncoincidental. Turning something into loosely coupled components can often result in more complicated architecture? It's easier to make code simpler to follow when it does _one thing_ and is relatively inflexible to your use case which is not in the relatively small set it planned for. You can push back, but we've discussed similar before, and you are not going to convince me that there isn't a _tension_ between "good architecture" and "getting it out the door". There has been for me in all of my 20+ year software development career. Doesn't mean you've always picked the _right place_ in the spectrum. But the right place is necessarily about your context and financial pressures (even if you're working in a university or non-profit, there are _some_ kind of external pressures to produce within a certain monetary and calendar budget). 
First thing is diagnose and fix all N+1 queries within the app. Another thing would be to explicily `select` only the fields you need. In your queries.
I'd say turning something into the _wrong_ loosely coupled components definitely results in a more complicated architecture. And I didn't find the Rails 3 equivalents to be less coupled, per se, just more structured. But with that structure came indirection and really difficult-to-grok abstractions. There _is_ definitely a tension between overall quality (e.g architecture) and time-to-market. The short term and long term has to be managed simultaneously. The only thing I'll really argue here is that I believe that tension should be negotiated based on quantifiable data and actual analysis. In practice, though, most software shops don't really put that much thought into their decision making. And the perception of managers, executives, etc. is that software design is something that the programmers want and might need to be given some leeway to keep up morale. They don't generally see it as a crucial predictor of what product development will look like 1-3 years from now (which it very much is). Heck, most people aren't even measuring the basic things that would be necessary to make informed decisions that balance short term and long term needs. &gt; But the right place is necessarily varying with your context and financial pressures (even if you're working in a university or non-profit, there are some kind of external pressures to produce within a certain monetary and calendar budget). Yes! And actually it applies even to a solo programmer doing open source work in their spare time, too. Balancing all of that together _is_ software management, in my view. It's been my observation (15+ year career) that most teams capitulate to short term pressures far too quickly, and the reasons are mostly social. And many teams that do make serious architectural investments often fail, because they don't realize that far fewer skills are required to realize something needs a rewrite than to actually pull one off. Cheers!
&gt; It's been my observation (15+ year career) that most teams capitulate to short term pressures far too quickly, and the reasons are mostly social. And many teams that do make serious architectural investments often fail, because they don't realize that far fewer skills are required to realize something needs a rewrite than to actually pull one off. Agree with all of that from my experience too, yup! 
Youre going to need to be more specific. Posting a gist of your seeds.rb might help. There are a lot of ways to tackle this. 
Thanks! Apparently my podcasting software does that for me automatically.
certification_level is a Stripe::Plan object, not a hash. So in order to read information about its product you'll need to use a method accessor most likely. Try certification_plan.product.name. I'm not familiar with Stripes API you could try checking their gems unit tests, can be a good way to learn an api.
Thanks! I tried that first but didn't have success. This is the error I get. NoMethodError: undefined method `name' for "prod_D27O9OtG8mEYzg":String Perhaps there is a better way of doing this.
Seed image file? How about just serve static assets?
Ruby-kickstart on github. Common CS puzzles introducing the language with growing complexity. Include tests and solutions. Fun and addictive. 
you can always... `p certification_level.class` will return the object class. `p certification_level.methods` will return methods that are defined. and help yourself traverse the object that way without having to dive too deep into the docs :)
You're right. I've just checked that. When you use `includes` with `where` or `order` clause (that refers to preloaded association), `includes` uses `eager_load` (single query instead of two like in `preload`). One more thing. It's not possible to simply use this in that way: `Client.includes(:addresses).where('addresses.city = ?', 'smth')` - Rails 4 will throw information about deprecation, Rails 5 will thrown exception. It's only possible in Rails &lt;= 3. For Rails 4/5, we should use something like this: ``Client.includes(:addresses).where('addresses.city = ?', 'smth').references(:addresses)` Anyway, like you said, documentation is not clear about this. Thanks for pointing this out. I will update my blogpost asap :)
Use [Roda](http://roda.jeremyevans.net/)
Check the Grafikart's Ruby formation (french) https://www.grafikart.fr/formations/ruby
Why not just serve static assets?
Hehe. Tell me afterward how you've like it (don't expect any Big Literature there, it is rather a series of anecdotes in imaginary magic-engineering, but a lot of fun.)
This is the design of Hanami. You can use `hanami-view` as standalone gem in your project. Whereas `hanami` (the gem) glues all the `hanami-*` gems together for a streamlined user experience.
I'm curious why this one was down-voted? 
No, it's contrived because if sorting is all you want, there are existing well-optimised tools, so you wouldn't be writing new code to do just that. The more realistic type of scenario involves additional processing - like the example I gave. Sure, there are instances where complexity does not matter a great deal, but there are also plenty where it makes the difference between performing well and being totally useless. 
I have to open the document twice to get a preview.
I've already been using [Octodown](https://github.com/ianks/octodown) for a while now and it's working great for me.
Maybe because it is very shallow marketing article with undefined audience and looking like it was written in 2007?.. ("easily modifying letters for mass newsletters" my ass. WordPress can do this already.)
&gt; What do you suggest as the basic things that should be measured here? I'd say the most important thing is setbacks. When something that should be easy -- and _would_ be easy in a "greenfield" environment -- proves really hard, that's a valuable data point. For my part, once I started taking note of setbacks, the data showed me how the delays associated with substandard code are predictable and quantifiable. Also, I noticed that a lot of software development principles really do "work," in the sense that following principles will lead to fewer setbacks. In fact, I'd go as far as saying that it'd be impossible for me to really apply principles without the experience of knowing how they steer code away from setbacks. I suspect this might be why so many programmers read up on SOLID, POODR, etc., and then have a hard time actually making their codebases better. Really, thanks again!
Same here. In my vim config I have `autocmd FileType markdown :AsyncRun octodown %` and it's perfect. Make sure to upgrade octodown for this to work correctly!
Did anybody actually try it? Dont know why a perfectly valid solution gets downvotes.
Interesting. So what's the difference between: Client.includes(:addresses).where('addresses.city = ?', 'smth').references(:addresses) and Client.where('addresses.city = ?', 'smth').references(:addresses) I'm surmising both will work, both will generate the same SQL -- but only by using `includes` do you actually get your relationships pre-loaded. 
Hmm, setbacks is not what I expected from 'measurable'. You just log them? &gt; In fact, I'd go as far as saying that it'd be impossible for me to really apply principles without the experience of knowing how they steer code away from setbacks Agreed. 
anyone wanna compare and contrast hanami-view to sho?
These are really good tips, but be aware that lambda invocations are very slow. Mapping a lambda against a large array will kill performance.
Thanks! I also concerned with life cycle of bound variables and memory leaks as result. It looks like we have to keep lambdas pure and Ruby may have some means to do it right. But I'm not yet sure of what they are.
I read that 2.6 may have some optimizations around lambda invocation, so hopefully the performance becomes less of a concern. I don‚Äôt know if it is an established best practice, but I believe that lambdas should be strictly functional. The performance and readability considerations are probably reason enough.
Do you mean the ISO standard? You can read the draft for it for free here [https://www.ipa.go.jp/osc/english/ruby/](https://www.ipa.go.jp/osc/english/ruby/).
Oops sorry, I meant ISO in terms of "In Search Of" Thats bad practice on my side, my apologies.
It is not informative. It's just some words. 
For me the most common use case is to memoize the result of some method. I use Memoist gem in order to do that, so I do not have to worry use too much boilerplate if nil or false are possible computation results. 
A style guide might be a good resource. https://github.com/rubocop-hq/ruby-style-guide
How do I farm Rubydoe? 
I don't know any Ruby resource about concurrency, but I found Simon Peyton Jones' [Parallel and Concurrent Programming in Haskell](https://simonmar.github.io/pages/pcph.html) a great resource to build up a vocabulary and get an intuition for when you'd use the different ways to build concurrent applications (STM, locks, channels, ...). The content is full of real-life examples, I can remember something about a chat application and a distributed database.
Quite a bit of concurrent\-ruby is inspired by the work that went into concurrency in the JVM. I would recommend you read Java Concurrency in Practice by Goetz. I don't think there are any books on Ruby concurrency ora parallelism, I'm afraid.
See, I'm not affiliated/related to whoever wrote or posted that article, but I think people here are being over critical. Yes, maybe it isn't the most informative article, but it still could ignite interest towards Ruby in some new/young devs. I can understand lack of votes, but this kind of down-votes are a symptom of a negative community to me.
Maybe you should take a programming course before studying to an exam? tryruby.org has an introduction that will cover the above problem iirc. Also google for "ruby array", the official documentation is always a good place to look.
 myArray[0..2] + myArray[-2..-1] myArray[0, 2] + myArray[-2, 2] But since you couldnt answer yourself I suggest you to take strangepostinghabits advice and learn some basics first.
One of the best things about Ruby is a thing called POLS. It stands for the principal of least surprise. It has many meanings but one that often works for me is try the obvious thing. You say you want to take some elements from the first array. Search for Ruby‚Äôs take method. 
Use [Array#values_at](http://ruby-doc.org/core-2.5.1/Array.html#method-i-values_at) to pluck multiple indices, thus: myArray.values_at(0..1, -2..-1)
I've written some post on russian IT-site about one of the applications. How do I put this... I store helper methods in lambda. It's slower but code becomes cleaner in some cases (so it should not be practices often). For example: ``` class MyClass &lt; AnotherClass def method1 p_method1 p_method2 some_objects.each { |e| p_method3 if p_method4?(e) } end def method2 p_method1 p_method2 end private def p_method1 # ... end def p_method2 end # You get the idea end ``` In this code `p_method4?` is needed only by one method (`method1`). I call such methods "helpers". They just add some abstraction to main method. It's hard to read class with many private methods. At some point you may even have helpers that are not used at all (e.g. after some refactoring). So my suggestion is to use lambda for that helpers: ``` def method1 p_method1 p_method2 is_something_whatever = -&gt;() { ... } some_objects.each { |e| p_method3 if is_something_whatever[e] } end ``` That way your code will be reduced. In some cases it will be reduced drastically. But it's sure my slower than methods so you need to be careful. And this hack is not really needed if you keep your classes small (SOLID).
https://www.codewars.com/ - this has a ton of trivial problems and solutions submitted by other people. you can practice and you can explore other ways to solve the same thing.
I wonder why this thread stopped: https://www.postgresql.org/message-id/flat/20170828172834.GA71455%40TC.local#20170828172834.GA71455@TC.local And &lt;3 for /u/tenderlove for trying to fix hard stuff so we don't have to leave Ruby that often!
I can recommend jstorimers book, https://www.jstorimer.com/products/working-with-ruby-threads 
I have read that, it has not much to do with ruby-concurrent and general theory.
&gt; I think people here are being over critical. What? People just downvoted article which was not interesting (I said any criticizm only to answer your explicit question). And it is not, indeed, at least for this Reddit. It is not even a "criticizm", it is just indication "spent my attention to this, not think it worth it, let others know by downvoting" (and that's what Reddit voting mechanics for, not for praising or punishing anybody, just self-regulation of information flows). Downvoting is not "negativity", downvoting is just indication for others not to spend their time, and it is absolutely appropriate for this article, not /r/ruby reader can fetch absolutely nothing interesting from it.
&gt; Hmm, setbacks is not what I expected from 'measured', it's pretty subjective/qualitative. You just log them? Yes, though I haven't personally in a while. It didn't seem like a quantitative measurement at first, but after a while the quantitative aspect became apparent. Studying the work we do is such low hanging fruit for easy improvement. I wish it were a cultural norm across the profession. It's so common to get attached to certain techniques and habits, and having hard data telling you that you're making mistakes makes it easier to move on from them. Or at least that's been my experience. &gt; Some principles "work" to avoid setbacks, but the very same principles when applied blindly and with abandon can often cause em. :) Yeah, and there is also a difference between applying principles and simply being able to recite them. Agreed on reading code. It's important to know what _is_ good code, versus what code looks good. It's common to develop a sense of aesthetics around code before we really know how to determine if it's good.
If you had time, I'd love it if you would blog or screencast a 'lesson' on this, with examples of what/how you log, and what the log looks like after a while, and how it helps you make decisions. 
I loved Roadside Picnic, and it sounds good to me! 
What's an "Elixir Engineer (m/f)"? I don't get "m/f"? Like, any gender? Aren't any job posting for any gender? Or, uh, monday-friday?
Haha yeah that freaked me out when I moved to germany. It's because in german, job titles are gendered by default - there's different words for male and female secretaries, for instance. The M/F thing is to ensure that no gender is meant by that.
Aha, I see. Probably safe to eliminate when translating to English? :)
Seems to me a better solution to this is to add proper finalizer support to Ruby. I think you could technically hack around this with existing finalizer support, but it would be pretty ugly.
You want "general theory" _and_ "working with ruby-concurrent"? I don't think you're going to get both. I'd learn "general theory" from sources using Java, ask around for good ones. I dont' think you're going to find any shortcut "here's how ruby-concurrent is intended to be used" stuff -- cause ruby-concurrent kind of just _is_ a mish-mash of primitives inspired/ported by/from various different languages and platforms. I think you just gotta understand some concurrency basics, and then figure out yourself how to put it together to do what you need. Concurrent-ruby actually still is mostly relatively "low level" in the grand scheme of things -- just a much nicer slightly higher level than Thread.new directly. Concurrent threaded programming is still challenging with it though. 
A Ruby gem is a set of Ruby files that you can include in your program to do something that is useful in more than one program so that you want to share it to allow it to be used more than once. Look up 'how to install gems' in general, and then look at the README for the gem you want to use to see how to 'require' and use it. Then look up 'bundler' to see how gems are managed in practice.
gems are themselves modules or pieces of code that you can include in your own ruby code to add in different functionality, usually things that you don't want to write yourself. Take the faker gem, for example, which enables you to generate email addresses (Faker::Internet.email) or Bitcoin addresses (Faker::Bitcoin.address) or even random Legend of Zelda item names (Faker::Zelda.item) without actually having to code those things yourself. The benefit of this gem is being able to generate fake, but properly formatted data for use in (e.g.) tests.
bundles of code. libraries. Anything you think you can reuse could be put into a gem. Some gems are popular and have a long life like rails. Others like https://rubygems.org/gems/home_run are used to overcome specific problems in ruby and then are abandoned when those problems are fixed.
And please, don't hurry to publish own gems. Their list is already cluttered with abandoned and useless things made for tests and personal usage.
did you mean `respond_with`? `respond_with` is baked into Sinatra already. If you actually meant `respond_to`, similarly to Rails-style block responses, you may have to add in https://github.com/cehoffman/sinatra-respond_to or similar. I'm not sure if Sinatra has that rolled in already.
When I run into a confusing situation like this I search my gems for the method definition. In my `.bashrc` file I have `alias bundle-search="bundle show --paths | xargs ag"` which relies on https://github.com/ggreer/the_silver_searcher/ I just type `bundle-search "def respond_to"` and see what files appear. You could just type `bundle show --paths | xargs ag "def respond_to"` There's a new kid in town for file searching too, so if you don't have `ag` you might want to consider `rg` instead: https://blog.burntsushi.net/ripgrep/#pitch That doesn't directly answer your question but it should give you a way to investigate
I somewhat disagree. Go wild. It's fine if you publish something obscure. In general the only issue I can really think of is that someone else wants the same name. I've come across those cases and 100% of the time when I contacted them, they gave me the gem name. So please go and have fun, but be responsible and keep others in mind. RubyGems is still pretty small in comparison to NPM. Back in 2017 they hit 350K libraries https://developers.slashdot.org/story/17/01/14/0222245/nodejss-npm-is-now-the-largest-package-registry-in-the-world. Rubygems, by comparison, is only at 144K gems in 2018 https://rubygems.org/stats. So unless this individual is going to make 206K worthless gems, I think we can be a bit more supportive. 
I don't want to see the same posts "oh god, our NPM repos became a mess" but about Ruby. And bad naming of gems is a real problem, like: https://rubygems.org/gems/bmp
Contribute to Open Source is always a good idea. Also, branch out, learn other languages. Ruby is only good as its people - and its people are only as good as their ability to learn new things.
Thanks, that helped. 
I would recommend either diving heavy into JS or AWS. You mentioned that you hate JS, but I don't know the last time you looked into it but there's some pretty great frameworks out there and coding standards. It's not the wild west of jQuery anymore. Almost every developer above intermediate is going to expected to start providing solutions. Most of the go to solutions these days is breaking your monolithic app into microservices that you can individually monitor and scale. The requires learning about cloud services the EC2, RDS, Lambda, and many more AWS technologies. It's not the most interesting stuff, but it makes you very employable.
&gt; It's not the wild west of jQuery anymore. Is that really how people see jQuery these days, because when it first came out jQuery made things so much less awful.
I'm three months into Python 2.7 / 3.5 (after 6 years of Ruby and Rails). Even though I want to, I can't recommend it. I'm sure it has it's uses in data science due to historical libraries, but the language and it's standard library is just slightly above meh to me. Swift \+ Vapor looks cool. I would love to get a perspective on it from someone who's well\-versed in both.
I think the west is way wilder now. I am nostalgic for JQuery. 
If you want to continue with ruby I suggest DevOps. A lot of the tools use Ruby. At least where I leave is one of the profiles more difficult to find and one of the highest paid. 
If you want to continue with ruby I suggest DevOps. A lot of the tools use Ruby. At least where I leave is one of the profiles more difficult to find and one of the highest paid. 
Well, I am actually on the start of my web dev career period, and I am trying to learn on RoR/JS currently. Seeing a post of this natures makes me jealous, as I am still trying to be proficient in any language. With that being said, what about R? I see so many people talk about it, and it seems like the perfect pet-project language to pick up. I don't know about employability, but it definitely seems like something people are making a lot of chatter about.
Full-stack and security should be the natural next steps for you. Especially security and data privacy compliance.
Getting more experience is not a bad thing if you've been at it two years--you also didn't say whether what you're writing has 20 users or 2,000,000. A "lateral" promotion into a more challenging environment is far from a bad thing. That being said... RoR goes along well with full-stack--it seems most people hire on that. Mobile is another one. Devops isn't the best of career paths with ruby. Few people run chef and puppet is terrible. It's also difficult to get into without operations experience. I have lots of devops experience but very little in the cloud and I'm not really getting where I'd like with employers. Python is endlessly useful these days (especially with devops), and machine learning and data science is big, but the field as I understand it is pretty crowded.
Re-evaluate "I hate frontend and JS" - "page full of functions and micromanaging the DOM with jquery" sucks, but stuff's come a long way. Frameworks like Vue make developing front ends really nice - it makes JS front end stuff feel like real development instead of the old hacks upon cruft upon junk way of doing things. Plus, you don't have to go 100% JS to get in on the front end stuff - you can keep Ruby for the back end and go JS on the front. Machine learning has become pretty approachable too in recent years. The basics, like text classification, can be picked up with some time and effort - and there's some decent Ruby stuff, though its not as big as Python. 
jQuery is amazing when it comes to accomplishing because tasks in very little code. Tooltips, drop downs, modal pop ups, calendar fields, form validation, etc are all great examples of stuff you could accomplish with jQuery in a couple lines of code. But jQuery is not a framework, it's more of a psuedo language. I would not recommend that someone write a SPA in jQuery, but looks to a framework like React, Angular, or Vue.
Learning SQL is good. I brushed up my SQL a few months back by writing a bunch of unit tests to check that certain queries returned the expected results. If you wanna check it out, here it is =&gt; https://github.com/amorphid/learn_sql_ruby.
Not sure how that's bad. It's got 24K downloads. Better than one of my lowest https://rubygems.org/gems/johnny_cache. 
Very true and I've debated this where I am now, but it seems automation is making DevOps jobs rarer these days. I'm about 5 years in and I ironically started off learning AWS / OpenStack for everything, and now we are fully automated at my current job with single click Jenkins deployment in a fully dockerized environment.
Pick up knowledge of containers (specifically docker) and different web architectures. Monoliths vs microservices and play with dockerizing your RoR App. There are all kinds of guides you can find online and it fits well within the rails ecosystem. In general start learning about the layers you're not so familiar with. Nginx/Apache, Sphinx/ElasticSearch, Redis/Memcache, Try out different ruby appservers like unicorn or passenger. Start thinking about the architecture at a high level, and see if you can replace one of those layers with a different technology just to see if it would work / the pros and cons. After a while of doing this kind of stuff, just call yourself DevOps and enjoy a 40K raise ;)
Not sure how is number of downloads related to naming quality. BMP should stand for image format.
This is the correct response IMHO. Today everything is front-end. I have learned to sort of love/hate JS but, if you're doing rails, you have to do some JS in today's world. I do mostly ExtJs plus a little vanilla and Vue but, really, JS is unavoidable.
You should become a SQL ninja. 
Learn unix system programming: learn about pipes, setuid processes, tcp/ip &amp; networking, and so on. It's how everything ultimately works under the hood and will give you the ability to thoroughly understand and debug almost any problem. Yes you'll have to learn C, but any programmer worth his salt should learn C \- it's the lingua franca of \*nix.
That's part of the DevOps jobs, improving and maintaining the delivery of the project. It's quite complex to maintain and keep the continuous delivery stack updated.
"RoR + JS" is maybe 10% of the stack at most. You should try each of the things you listed for a week, and then follow your nose into the one(s) you really like. You need to get over "hating frontend" though. Front-end is the part that people interact with, and technology is pointless if it is not made for people. 
Just out of curiosity, what is the other 90%?
containers and devops would be my vote.
If Devops is on the route I would actually suggest learning a bit of GoLang. A lot of devops people and tools are starting to migrate towards that route.
Why Sinatra? I learned Sinatra before Rails and I never want to go back.
If someone can design &amp; build a datacenter, assemble/rack/stack your servers, cable &amp; configure network elements and a SAN, manage network addresses, build &amp; run a DHCP &amp; DNS service, package an operating system, write a kernel module, compile your own ruby, have a PR merged in Rails, write a pitch, obtain funding, launch a company, hire a team, design a user interaction, construct a viable continuous delivery pipeline, write and publish a mobile app, setup container infrastructure, package your code, repackage someone else's code, create command-line tools, install and tune a database, boot an application in production, configure a loadbalancer and a CDN, write a UI toolkit, write a style guide, design a domain model, implement a service layer, setup backups, create database views, setup an analytics dashboard; and then document all of it. Then maybe, just maybe, we can start to think about labelling them a "full-stack" developer. 
&gt; useless things made for tests and very specific personal usage. 24K is a lot of for just "personal usage" &gt; BMP should stand for image format. If you want it for your own image format gem, then make it, show value, and ask the author if they'll hand it over. BMP honestly isn't a very good name for an image format gem though. It would be better as `image_format`which happens to be totally free. Go knock yourself out https://rubygems.org/gems/image_format. Looks like you snagged `ccu` but haven't updated it since 2015. If you want to dissuade people from putting free code online for everyone to use because you're upset that some projects go nowhere or get abandoned, you can start by deleting your own old gems. Honestly though, thanks for writing code and sharing it. I appreciate you publishing gems, or at least I appreciate someone with your same username publishing them. 
Sure... That would be great, isn't it? But for the humans out there, when they refer to full-stack developer, they are talking about someone who can join an early stage startup and work in all the parts of the system. A person who is able to create a decent looking UI, code in one JS framework, such as React, code the backend in Node or Rails and deploy everything to Heroku. 
Worked with s guy like this. Completely self taught.
No. No, I don't think so. That sounds like a description given by a recruiter. Basically you're not full-stack unless you're smelting your own copper.
Love this suggestion. The overwhelming majority of tools we use are either written in C, or a C derivative, or in a language whose compiler and/or runtime is written in C or a derivative of C and whose standard library ultimately has to interface with an operating system that is written in C (or a derivative). C is most definitely the foundation language of the current era of computing.
&gt; 24K is a lot of for just "personal usage" I mentioned that one for "bad naming, not the "personal usage" issue. And anyway 24K is not a lot. My the most downloaded gem is 16K and it's still raw and used only by me -- I don't know which bots are incrementing these rubygems.org stats. &gt; make it, show value, and ask the author if they'll hand it over This is a chicken and egg problem -- when the gem becomes popular it's already not nice to rename it. And what if author for some reason loses an ability to hand it over? Like passing away that is unfortunately already happening to Ruby programmers. Yeah, ccu was my project, probably the first gem I made -- when naming it I took in mind that I'm taking the name that does not sound like anything else and so nobody would want that name. I can't imagine how that guy could not think someone would want to make a gem about BMP images processing, that's just weird decision or maybe even purposeful squatting.
Thank you for appreciation.
Isn't ~backbone~ ~angular~ ~vue~ react great?
Sounds like everything you need to deploy an application. Not an application.
JavaScript is what all the cool kids are doing but I think it is overweight and over engineered. Most business applications don't need to be single page applications.
If you're on Vim 8 or NeoVim, I'd recommend using https://github.com/w0rp/ale over Syntastic since it runs in the background and doesn't cause slowness.
Being full\-stack is incredibly invaluable. I try to hire everyone good full\-stack dev I can.
Given your requirements, maybe stop being a software developer and go be a cook on a submarine? You need to know SQL, HTML, and VanillaJS. You also need to know how to deploy a Rails app using Capistrano and, today, how to wrap a deploy in docker. Once you do that you can call yourself a developer. 
This is exactly the comment I've been waiting for. The bad thing is that I don't know to code in Java. But I've seen the terms are almost the same everywhere e.g. Actor model, Promises, Futures etc. Or some of the implementations like that you can "attach" a promise to an executor which might be a Thread Pool. I was thinking the opposite - I find concurrent-ruby 'high level' because of all those helpers it has. I **want** to get my hands dirty with 'low level' concurrency so that sounds good to me. I guess that you mean sidekiq/resque for example are of a more higher level, correct? I don't see any other way that reading Java to learn about concurrency. Otherwise, I don't get how people can get used to how to use concurrency libraries (including celluloid) without e.g. finding out what is the difference between an Actor, a Future, a Thread etc. 
Sounds like you are describing a very particular stack. I would even argue that many of the skills you listed really belong in the realm of senior engineer, and going full stack is more specific to what domain of software you wish to engage in. 
See How I Start - Let's Build a Gem Together! - &lt;http://yukimotopress.github.io/start&gt;. Cheers. Prost.
Any suggestions for resources to learn AWS and related technologies?
Why do you create a new thread to call `deq`? And why do you check if the mutex is `locked?` before doing it? Instead of using `MUTEX.lock` and `MUTEX.unlock` consider using `MUTEX.synchronize { }` which does the lock and unlock automatically. Or use the `Queue` class, which is synchronised by default. 
Ah a git commit hook is a good idea, thanks!
&gt; knowing only Heroku &gt; full stack that means that you know literally NOTHING about what happens beyond the browser. More like full-browser developer. 
The first race condition I can see is that it can fail to dequeue a message. As /u/chrisgseaton said, though, this is pretty much exactly the use case for `Queue`: # once queue = Queue.new Thread.new do while item = queue.pop # send `item` puts item sleep 0.5 # go slow end end # at runtime queue &lt;&lt; "hello" queue &lt;&lt; "world" # lazy hack to make this demo work sleep 2 
I first thought that you were a full blown neckbeard in his habitat. But then I had a look to your history and realized that you are just a troll. Well done.
I think that things that are "higher-level" concurrency are largely new, and largely don't exist in Ruby. First there were _only_ Threads. Then things built on top of threads, like Actors and Promises and Futures -- generally different ones of these come from _different languages and platforms_, as different people and communities tried out different ideas for making concurrency easier to work with. It's kind of all still shaking out, as people try them out and develop new things. Really "high-level" concurrency support kind of needs to be baked into the language/platform and supported throughout the ecosystem, to end up being useful. For future Ruby, some ruby committers are trying out something more or less of their own invention called "guilds", to be baked into ruby. I mean, I guess you could say something like Sidekiq is "higher-level" concurrency, it is higher-level in a way, but only by carefully constraining the embedded concurrency for a particular use case/pattern, rather than providing general-purpose higher-level tools. So, yeah, threaded concurrency is not easy. There are so many places for gotchas. The attempts at "higher level" abstractions are an attempt to provide less places to shoot yourself in the foot. I think you'll do fine with texts in Java despite not knowing Java. You don't gotta be a Java expert, and it's similar enough to ruby, both being object-oriented. Maybe start with a couple day intro to basic Java though if you've really never seen it before. The basic primitive of the current kind of concurrency we have is the 'thread'. This is actually an _OS_-level thing, it's (at least usually) the OS that supports threads, and threads were invented some decades ago at the OS-level as "light-weight processes". I don't know if they were invented for unix and C, but that's where they got popular. So threaded concurrency is pretty similar in all languages, they all use the same basic model, with the same gotchas and the same patterns to deal with them. So if you want "low-level", you want to learn about threads and how to use them. In ruby that's the `Thread` class. In Java that's _also_ a class called `Thread` (`java.lang.Thread`). They work similarly. If you find a Java text that teaches you about Threads, that's going to be teaching you about them in ruby too; there may be some differences, but you'll know enough to then understand texts that explain the differences, or explain ruby threads assuming basic understanding of ruby. Futures, Promises, and even Actors are _relatively_ lightweight abstractions on top of threads. There's another common kind of concurrency than multi-threaded concurrency, "evented", which I'd ignore for now. :)
This is a nice example actually. I tried using Queue already, but didn't realize how to make it loop. Thanks!
Thanks for the detailed reply. I've worked lots of times with Ruby classes as Thread, Process, Mutex, Queue and I've experimented with Pools. I've even built things working in production fine. I know what a Mutex is and how to use it to block execution. I've also worked with EventMachine for two apps \- this is harder but I haven't got the time to get deeper. It's odd but I don't get the opposite: I think I got enough of 'low\-level' terms but I don't get the 'high\-level' ones. For example the meaning of an Actor is hard for me to understand. And I am not asking for a two paragraph explanation in a reddit post \- I just can't find resources in bibliography about higher level of threading abstractions. I guess the purpose of high\-level libraries is to do safest choices and keep code DRY, isn't it ? I'll give the Java book you suggested a try :)
I'm checking if mutex is locked because if it is, there is no need to create a new Thread? Or am I missing something here? `MUTEX.synchronize {}` would definitely look cleaner. 
Is the idea of `unless MUTEX.locked?` that it ensures only one consumer (deuque) thread is created? If this is all `MUTEX` does, why not just use a variable `@thread_started`? If you want to run this code in parallel as well, on JRuby or Rubinius, it isn't safe like this, because there is nothing to ensure the message is fully created before it's enqueued.
Is the idea of `unless MUTEX.locked?` that it ensures only one consumer (deuque) thread is created? If this is all `MUTEX` does, why not just use a variable `@thread_started`? If you want to run this code in parallel as well, on JRuby or Rubinius, it isn't safe like this, because there is nothing to ensure the message is fully created before it's enqueued.
OK, I'm confused what you are asking for then! You said you wanted more 'lower level' stuff, but sounds like you've already got quite a bit of experience with them! You are not in the situation I thought you were from your original questions. So what _are_ you looking for? If it's a simple way that all these things _go together_, it might not exist, they are all just parts of people experimenting with ways to do concurrency in more sane ways, independently, with all of them having been found useful by some people/communities, but none of them 'winning'. (It wasn't me that suggested any specific Java book btw). 
haha sorry about the suggestion kudos, someone else might be underestimated! Well, you've helped a lot. I want to learn about concurrency terminology and how it works - higher than Threads and stuff, meaning as I said, usage of Actors, Futures, Promises etc. Obviously googling "Actors" is going to give me George Clooney as a possible result and "Actor concurrency" will lead to the ruby gem without any resources to learn **why** to use Actors but just **how** to use them blindly. Again, thanks for the hints. 
Perhaps a variable could do the same thing. I felt that using a mutex communicates that there's something thread-critical going on, and also I wanted to use a mutex, and thought I would need one. :) As for creating the message, I made a mistake by simplifying the example too much. The message is always given as parameter to enq function. I am positive that the message is created, when enq is called.
Instead of trying to jump into completely new technologies, I would advise starting to look into software engineering best practices. Start playing around with Trailblazer and/or dry-rb, just so you know vanilla Rails isn't the only way. Read books like "Patterns of Enterprise Architecture", "Practical Object Oriented Design in Ruby", "Working Effectively with Legacy Code", etc. Also read blog posts, but never just believe one side of the story. If you do want to try out new tech, try something really different, so you can learn new ways of thinking, e.g. a statically typed language and/or a functional language, but (in a very different vein) dabbling a bit in C or even assembly will also tell you a lot of things. Understanding things that you already use - like SQL, HTTP, etc. - on a deeper level can also be helpful. Especially with SQL, Rails by default only exposes you to a subset of it; modern DBs like postgres have tons of other features that you could explore. Always be learning.
&gt; I am positive that the message is created, when enq is called. That's not how parallel programming works, unfortunately. You may think you have done a, b, and c before calling `enq`, but really the interpreter and the processor can re-order these things, and could be doing b, calling `enq`, and then doing b and c. The way we prevent it reordering things like that is to use a mutex. Locking or unlocking a mutex says 'make sure everything up until this point is finished before proceeding'. It's also called a 'memory barrier'. For messages when the thread is already created in your code there is no mutex lock or unlock, and so no memory barrier, and so your message could be half-created when the consuming thread sees it. https://www.youtube.com/watch?v=3FS1xnCEMq0 You have been lucky so far that it works on JRuby - it may randomly fail one in a billion times or something like that. You need to use a lock every time you add something to the queue, or an explicit memory barrier (advanced topic), or use a builtin class which does this for you, like `Queue`. 
Have you tried googling 'actor concurrency'? Cause I just did, and that's not what it leads to. It leads to a wikipedia page, a master's thesis, "the actor model in 10 minutes", some documentation from the Akka language on "what problems does the actor model solve", and a two-part article from JavaWorld with part 1 being "Understanding actors in Erlang", and part 2 being "Understanding actors in Java." As the top 6 hits. I suspect all of them will be useful to you. 
Eh. Swift is neat as a language and I like its type system. But the main target of Apple is iOS devs and that shows. The tooling to develop outside of that bubble just isn't very good; not using an IDE sucks because the CLI tools are awkward to use (e.g. the testing tool just dumps a bunch of poorly formatted stuff at you, unlike e.g. RSpec), but there is no IDE yet that integrates with the official package manager (that you'll need for server side development). Hopefully that situation will improve but I wouldn't recommend anybody migrate from Ruby to Swift for backend work just now.
Yeah I know. But google isn't the best resource due to opinion\-based tutorials and also I see it foolish to google search all this list one by one [https://www.rubydoc.info/github/ruby\-concurrency/concurrent\-ruby/index](https://www.rubydoc.info/github/ruby-concurrency/concurrent-ruby/index). That's why sometimes books are non\-replaceable. Also you got a method to learn something than going back\-forth and randomly wandering through thousands lines of code and trash articles. We might be a little off\-topic as my OP was about "how" and not "why" :P
Yeah, but the first page of results for google 'actor concurrency' looks pretty useful to _me_, I wouldn't ignore it. I think the master narrative you are looking for may not exist, these things each have their own history and context and intention you'll need to just research and understand, I'm not sure the shortcut you are looking for exists. But hope this helped, good luck! 
As a university graduate I can assure you that reading a book isn't a shortcut but searching in Google for quick solutions is what it really is! Thanks !
&gt; That's not how parallel programming works, unfortunately. You may think &gt; you have done a, b, and c before calling enq, but really the interpreter and the processor can re-order these things, and could be doing b, calling enq, and then doing a and c... Even if a, b and c are performed by the same Thread, that calls enq, and none of them are async? My understanding is that the order within a thread is not changed under these conditions. The processor(s) switch between threads as they please. But change of order... Watching the video will probably help to understand your point. I think using Queue seems like an excellent idea right now. Also, it is not in production yet. The comments have been timely. :)
Use a Queue. It‚Äôs already synchronized. https://ruby-doc.org/core-2.4.2/Queue.html
&gt; Even if a, b and c are performed by the same Thread, that calls enq, and none of them are async? Yes :) The thread which does it cannot see that this is happening, because if it reads a variable the interpreter and processor ensures that the read comes after the write, but it's visible to other threads. Since you are passing an object from one thread to another, that's exactly where you could observe this effect. Parallelism is like crypto - you should definitely use the builtin tools, and if you think you have a clever idea of how to do it differently, there's probably a good reason why other people aren't doing that.
Unfortunately, this will not work: `Client.where('addresses.city = ?', 'smth').references(:addresses)` It throws an error. It works only with `includes` or `eager_load` but no with `preload`
Sure, but it's staring to seem like hating on jQuery is the "in" thing to do. I've been building web apps since the late 90s, and jQuery brought Javascript forward in a massive way, and does not deserve any disrespect. Most of the modern JS frameworks owe a huge debt to jQuery in terms of underlying design, interacting with the runtime environment (a browser in most cases), or just plain ambition about can be done with Javascript.
Thanks for the tip.
Udemy has some pretty good courses you can buy for like $10. They have an AWS Certified Developer course that will give you a pretty good base of knowledge and at the end you can take the AWS test and actually get certified if you want. Something nice for the resume.
Considering Ruby apps often default to PostgreSQL this might be a major contributor to the image Ruby has of not handling memory well. Is anyone in a position to compare this with how Python manages the same issues?
"A-I-D-A. Attention, interest, decision, action"
following all of this malloc stuff recently has been really enlightening, and I'm really glad there are people still poking around at the core foundations of ruby and ruby performance.
Very weird. I can not explain any way that API actually makes sense, heh. Would it also work with `joins` instead of `includes` or `eager_load`? (And if so, i'd still what is the difference/relationship between joins and references, why you need both?)
Cool idea but kinda wish it was slimdown instead 
Dude if you think Heroku covers the "backend" then I feel sorry for you. 
This is a neat idea, but it's not really practical. I don't see an obvious way of adding the `.class` or `#id` or other arbitrary attributes to the Markdown elements. Being able to type `# Title` or `[link](url)` sometimes is not desirable to me, if I have to type `%h1.post_title Title` and `%a.btn(href=url) link` other times.
It would be much harder task to differentiate Slim from Markdown, than Haml from Markdown
The idea is not to add \`.class\` and \`#id\` to \_existing\_ markdown elements (btw you can do it with [kramdown](https://kramdown.gettalong.org/quickref.html#id)). The idea is to support both syntaxes at once, so that you could keep using Markdown for static content of your blog post, and use Haml to generate stuff.
Hah :) someone found it useful :) I'm glad
With something like this the adoption is going to be based on the ease of use, not the ease of implementation. 
Thanks! I got them in the database and into Stripe (not the cleanest way) but of course I just found out today that their subscription service won‚Äôt work for the group since they want all of the money upfront instead of yearly (the max Stripe allows). I should be able to use their regular checkout system though. As a matter of fact, this should make the web application easier.
I started my career as a junior sysadmin in a datacenter. At first I used to manage HP-UX, Solaris and Irix. Then, Linux, when it became mainstream. Now I build web apps and, because I know what it is to manage an infrastructure, I would never recommend it to any company whose business model is not having millions of non-paying customers. In the country I live, you don't get a decent devops for less than 70K, so I would need to be spending more than 200K in Heroku before even start to think in hiring a devops. Still, in most cases, I consider better to just pay a third party, rather than manage servers in-house, because of the human factor. So yes, in 95% of the early-stage startups, being full-stack means as well to be clever enough to invest time in the product, and not in the infrastructure. 
Not sure how much this gives you over just haml. 
‚òùÔ∏èBest comments are a lot of times in the bottom. 
&gt; employability A developer who know well Rails and JS should not have any problem to find a job in most countries. And by knowing well, I mean being able to take a set of business requirements and build an app that is not a blob of spaghetti. 
Maybe I need to learn something new about CSRF here. I understood that it wasn't needed in Rails API mode because the API is already cross origin and CORS and CSP are more important to implement. The article kind of skips over explaining why its needed in this architecture vs having Rails render the forms.
I love slim. It feels natural to me and HAML just looks a little bit strange. 
I don't know that I consider Kramdown's solution of &gt; A nice blockquote {: #with-an-id} to be better than the equivalent Haml: %blockquote#with-an-id A nice blockquote Anyways, it's a cool project, if it works for you then go with it.
I'm getting there! Not that confident yet though...
If you enjoy what you do and you stay curious, then it's just a matter of time. 
100% agreed. Can't really think of any reasons why one would choose Haml over Slim. Smart mode (activated by `&gt;` instead of `|`) is the biggest selling point. More on why Slim rocks: https://github.com/slim-template/slim/issues/386
It‚Äôs only needed if you‚Äôre using sessions, which is something you probably want to avoid when building an API. 
I appreciate it a lot... It's nice to hear that, especially in these early months.
Why would your API implement sessions? That‚Äôs the main problem here.
I was really surprised as well when I saw that for the first time in another offer. Apparenly, this is because a German law against gender discrimitation. But it seems a bit counterproductive IMO.
\&gt; "Knowledge is knowing that a tomato is a fruit. Wisdom is not putting it in a fruit salad." Ruby is not Javascript. The developers that come after you will have a set of expectations based on all the other Ruby code they read in the past. Although all this constructions are nice, and can make person who wote them feel like he/she is a clever programer, I feel that they don't really improve the quality of the code.
Have you ever heard about JS clients for API? They kinda use sessions sometimes.
this in explained in my older article https://blog.eq8.eu/article/csrf-protection-on-single-page-app-api.html :) 
long story short - If you send your session id via cookie (or if you send token like JWT via cookie where BE reads that cookie) you need CSRF even if it's SPA (and yes even HTML rendered application) ...so example if you use Devise if your API is just using some custom "non cookie header" you don't need CSRF (that means BE is not reading cookie value) ... if you send JWT token via `Authentication` header
I have a traditional Rails app with Devise that I added some Spa sections to, so I just fell into it. Any suggestions?
I am having massive issues with CSRF since rails 5 though. If a user hits the back button, chances are they are about to have a bad time. I didn't implement anything weird and I always follow the guide, but CSRF really sucks for my users now.
My lawyer adds the following: if you share data with a small development team, and that team is \*external\*, then you should sign a data processing agreement with that team.
long shot but have you tried different `protect_from_forgery` strategy ? http://api.rubyonrails.org/classes/ActionController/RequestForgeryProtection/ClassMethods.html e.g. null_session ? 
as long as you have CSRF protection (as described in the article in the cookie session section) you should be fine (that mean you send X-CSRF-TOKEN header and you have `protect_from_forgery` in the controllers) but If you do session cookies without the csrf token then, no your website is not secure 
Yeah I do that, doesn't work if I don't.
Well that would just make them appear to be logged out, right?
Great times are coming to ruby.
This isn't about Ruby, in the least. Ruby isn't even mentioned. It's actually about how the writers adoring fans should communicate with them. All right, Mr. DeMille, I'm ready for my close-up.
He‚Äôs an organizer of Keep Ruby Weird. He‚Äôs an organizer, so no he isn‚Äôt patting himself on the back. He is saying how the attendees should interact with his speakers. It‚Äôs a manifesto for against what at least I see as a conference anti-pattern. As a sometime speaker I HATE Q&amp;A and fully embrace a pattern that lets us get rid of it while encouraging communication and collaboration. I hope more Ruby confs do this.
This is a subform about Ruby, about the language, about engineering and building cool things. This is a post about marketing and self-promotion. Also, just to reiterate, it doesn't even mention Ruby once, in passing. I guess the fact that he does use Ruby (although most Medium are "gurus" who "motivate" engineers, not actual engineers) doesn't excuse posting an article that doesn't even mention Ruby on /r/ruby. Everything has conferences. Maybe a subreddit about conferences would be more appropriate. Or a subreddit about marketing or self-promotion.
He‚Äôs also volunteered as a conf track organizer and talk reviewer for RailsConf as well. His target is speakers, especially Ruby speakers. You don‚Äôt appear to be his target. I am. You can downvote. I can upvote. Ultimately if the community finds it interesting and useful it will swim, if not then it sinks. I hear you. You‚Äôve made your position known. Let‚Äôs move on. 
It‚Äôs been good times. Fast times are coming!
If this is already 9x faster, what is the point of the upcoming mri "3x3" ? 
Just my personal opinion below :-) A first reason is that it's far from 9x faster on all cases at this point at least (see [CSV.read 2x slower than MRI](https://github.com/oracle/truffleruby/issues/1072) or [A first na√Øve look at TruffleRuby](https://github.com/oracle/truffleruby/issues/1054). I'm fairly sure these points will improve (especially after discussing with the TruffleRuby guys!), yet it won't be faster yet in all cases. Also, another reason is that having a different implementation, with a different sources of funding (e.g. some MRI committers are paid by different companies, e.g. CookPad), which can be seen as more solid on the long run (like Postgres does), where TruffleRuby is AFAIK (correct me if this isn't true) largely funded by Oracle only. Finally, after going to RubyKaigi 2018, I find that having various implementations (MRI, TruffleRuby, JRuby, MRuby etc) appears to foster postivie emulation &amp; improve the whole language.
been pondering whether truffle is going to be our version of V8
Is it available through rvm yet?
First hit showed this: https://github.com/oracle/truffleruby/issues/1062 Then I saw this thread where "eregon" is talking about it yesterday: https://github.com/rvm/rvm/issues/4297#issuecomment-397643829 So yeah, fortunately we're going to see this soon it seems!
awesome - thanks!
Seems some people got really pissed off from reading through that about wanting other options and not liking RVM. Kinda ground my gears a bit since I've had a lot better experience with RVM.
Is it only me, who is worried about the company which owns and finances its development ? Don't get me wrong, I'm glad Ruby still gets serious attention, but get used on by long time proven, neutral development model of most open source projects, including CRuby. On the other hand have bad experience with such and similar companies with murky deeds in the past. I just smell some kind of future vendor lock-in, intentionally crippled free version to force payment for normal version with closed-source parts‚Ä¶
Can't wait to see TruffleRuby landed so the communities can / should massive test it out. Unfortunately Sulong and the C extension aren't working quite well yet.
The good thing about open sources, GPL, MIT / BSD , Apache is that once they are out, the community can pickup and continue where it left off. I am certainly not worry at all. Esepcially for Open Sources programming lanagues when they need as much help as they need.
On the flip side, I've experienced cases where RVM users could not use software that I released, because of how it modifies GEM_HOME/GEM_PATH. It's frequent enough that I've had to decide to not support RVM users, sadly. To my knowledge, rbenv+ruby-build and chruby+ruby-install (what I use) never cause problems. And chruby+ruby-install works flawlessly, and offers the best experience for everyone all around. It's easily controlled via shell scripts, and it never does anything to render your ruby environment nonstandard.
\&gt;**I wonder how many gems we've been using that really hurts the performance of the apps that we design and deliver.** Nothing, or close to nothing in Rails land ( Not necessary Ruby Land ) has had performance in mind. I think as Rails mature, we can start looking at performance again.
Author of the library here. I thought the broader ruby community might find some of the work interesting. Essentially MRuby-Zest provides a way to create a GUI building off the idea of Qt's QML while keeping the implementation solidly within Ruby objects. This approach in my opinion makes things run more smoothly (from a development perspective) than trying to extend widgets which may have their core/base implementation in C or C++.
That is really interesting. Haven't seen such a problem after using RVM for so many years. I still rely on it and have had problems with rbenv and even chruby.
&gt; Nothing, or close to nothing in Rails land ( Not necessary Ruby Land ) has had performance in mind. I don't think that is true at all. Performance isn't an on-off switch, there are tradeoffs to be made. The vast majority of people will not benefit from less memory usage in their pagination gem.
True. I mentioned this elsewhere. But I wasn‚Äôt referring to pagination gem but while ecosystem in general. 
I don't find it true of the entire eco-system either. Rails isn't slow for the vast majority of use cases. If you're finding it slow, you may be an outlier or more likely look at how it's being used. Regarding Pagy....I find a lot of irony in a performance centric pagination gem only supporting offset/limit. Chances are if you have performance issues with pagination, it's not the memory overhead of the gem you're using, it's the queries you're sending to the DB.
I'm not sure what you mean by 'session' here. You are vulnerable to CSRF if you send any sort of auth token via a cookie. Doesn't really matter if there is a 'session' or it's just an auth token for the user. 
It depends on your usage patterns. If you're doing the most common thing rubyists do, work in a single big rails app, you might not ever encounter a problem with any of the tools. RVM has a lot of magic under the hood, though, and it only really works well on commonly-traveled paths. At this point, I'd be surprised if chruby actually had any real bugs. It's several orders of magnitude less complex than RVM. It never required a kickstarter campaign to raise money to write a testing framework in bash. It does what you tell it to do, nothing more, nothing less. It's pretty common for devs to develop an affinity for tools they use, and to promote them out of zeal. I won't insult you with that kind of nonsense, but I'll say that if you set up chruby, your development environment will be much more deterministic and stable. If you don't, it isn't the end of the world, either.
I am glad the amount of new gems is diminishing, because I don't think anyone reinventing the wheel is a good thing, nor is releasing gems which solve problems the wrong way. Sometimes gems are better left outside of your program in favor of a custom module. That said, we do find better ways to do things and those are times a new gem can be valuable. I am currently using kaminari because I don't think will_paginate is very graceful and I think the project can be considered abandonware. Pagy looks like it's worth a try.
Sounds interesting. Do you have the source or a demonstration available?
I'd be interested! As I've just started down the path of applying for jobs. Some way of automating part of the process would be fantastic!
Do you have an example of the output? I'd be very skeptical of a generated cover letter.
There is a screen cap on the repo.. that I just realized I did not link to, woops. https://github.com/angela-d/resgen
Sorry! Somehow I managed to forget to link to the repo: https://github.com/angela-d/resgen
Forgot to link to the repo in my original post (replying direct to ensure you get a prompt in your reddit box!) https://github.com/angela-d/resgen
Competition is always good. It drives projects to be better.
operators in ruby are not-so-secretly just methods. irb(main):001:0&gt; nil.method(:&amp;) =&gt; #&lt;Method: NilClass#&amp;&gt; irb(main):002:0&gt; true.method(:&amp;) =&gt; #&lt;Method: TrueClass#&amp;&gt; irb(main):003:0&gt; false.method(:&amp;) =&gt; #&lt;Method: FalseClass#&amp;&gt; irb(main):004:0&gt; Object.new.method(:&amp;) NameError: undefined method `&amp;' for class `Object' from (irb):4:in `method' from (irb):4 from /opt/rubies/ruby-2.4.2/bin/irb:11:in `&lt;main&gt;' irb(main):005:0&gt;
Oh wow, that's really interesting. Thanks! I didn't realize methods were called like that, but it makes sense given how &lt;=&gt; is a method.
it's pretty cool! You can define your own operator methods on objects (for the operators ruby supports like this; not recommended for common operators people expect to do other things), and 'operator overloading' is nothing but method overriding! The binary `&amp;` operator isn't used much, I'm not sure it's that useful that it's defined on `true`, `false`, and `nil` -- to be the same thing as `&amp;&amp;` apparently. Just use `&amp;&amp;`. Do use `&amp;` for bitwise-and on numbers, where it's the standard built-in way to do that, although you don't need that unless you're doing some unusual-for-ruby binary packing. 
To add to this, I've found that overriding some of the operators makes your class work more intuitively. For instance, I'm playing around with implementing Dungeons and Dragons-style ability scores, and overriding the '+' and '-' operators makes it act like a Numeric. strength = AbilityScore.new(15) strength += 5 puts "Strength is #{strength.value} (#{strength.modifier})" =&gt; Strength is 20 (5)
neat!
Just to add to jrochkind answer, in Ruby everything is an object. &gt; true.methods.sort =&gt; [:!, :!=, :!~, :&amp;, :&lt;=&gt;, :==, :===, :=~, :^, :__id__, :__send__, :class, :clone, :define_singleton_method, :display, :dup, :enum_for, :eql?, :equal?, :extend, :freeze, :frozen?, :hash, :inspect, :instance_eval, :instance_exec, :instance_of?, :instance_variable_defined?, :instance_variable_get, :instance_variable_set, :instance_variables, :is_a?, :itself, :kind_of?, :method, :methods, :nil?, :object_id, :private_methods, :protected_methods, :public_method, :public_methods, :public_send, :remove_instance_variable, :respond_to?, :send, :singleton_class, :singleton_method, :singleton_methods, :taint, :tainted?, :tap, :to_enum, :to_s, :trust, :untaint, :untrust, :untrusted?, :|] So `true &amp; true` is just `true.&amp;(true)` with some syntax removed. And because everything is an object, you can monkey patch anything to do whatever you want. &gt; true.class =&gt; TrueClass &gt; class TrueClass &gt; def &amp; thing &gt; false &gt; end &gt; end =&gt; :&amp; &gt; true &amp; true =&gt; false But monkey patching core object is generally not a good idea. Better to create your own version of that object.
This is cool for fun, but be very wary of code like this. It'll generally break when you turn it around (`5 + strength`), and is usually edgecasey. 
Oh!! I forgot to mention, I defined `#to_i` on the AbilityScore class so that the reverse works. However, that doesn't invalidate your point -- using `strength = 5 + strength` changes `strength` to an Integer, which is somewhat unintuitive. Thanks for the tip!
&gt; figured the last line was because there were no () and it was attempting to use &amp; true as a parameter Other posters have covered the fact that operators are "just" methods, so I'll just add that the error message clearly states that your interpretation is wrong: &gt; NoMethodError: **undefined method `&amp;'** for #&lt;Object:0x007f9e7ac96420&gt; Ruby is telling you everything you need to understand what's happening (and that it's *clearly not* parsing `&amp; true` as parameters to `new`). The error message is trying to help you understand, if only you read it.
API with http only cookie and CORS protection is secure and don't need CSRF protection. Or maybe you can provide example when CORS is not enough? Except GET request that has side effect like deleting project :)
You can make formatted code blocks using the backtick ` mark three times. ``` Like so ```
Why not just write bindings and have a native extension gem?
a project called tensorflow.rb already does that. I am looking for something that can run anywhere without too much dependencies and supports AMD gpus from the get go.
but won't just... using ruby negate all the benefits of that?
If all your doing is setting an http only cookie / CORS than any other website a user accesses in a logged in browser has full read access to your site. 
why would it? if you ship out the heavy computation to GPUs then you still benefit.
For machine learning inference, I think ruby should be ok for that. Besides the performance improvements ruby is getting recently seems promising.
GraalVM developer advocate here. [TruffleRuby](https://github.com/oracle/truffleruby), the Ruby language implementation, is an open source project, [GraalVM](https://github.com/oracle/graal), the runtime that makes it really-really fast is also an open source project, all parts of which are freely available under the GPL2 with CPE. You're right there's an enterprise edition of the GraalVM which one can purchase if they need additional performance and security enhancements. It is a good thing because it helps us fund these open source projects in the long run. At the same time, the team is committed to making the community edition of GraalVM the fastest runtime for all supported languages, Ruby included. TruffleRuby is already fast. It's an open source project, it will stay that way, and you can certainly treat it as such. Please, take a look it, try it, see if it works for your projects, contribute back, even submitting issues or benchmarks where you think it's not fast enough would help a lot. And from our side we'll make our best to be a great open source project. 
Neat! It‚Äôs now on my list of things to check out soon. 
It would be nice if you checked that list out from to time :(
I recommend https://github.com/runtastic/rubocop runner to easily install the pre-commit hook 
It‚Äôs a 404 for me ‚òùÔ∏è
Updated the link, thanks 
I just opened the PR today: [https://github.com/rvm/rvm/pull/4406](https://github.com/rvm/rvm/pull/4406)
I feel like you're more likely to see MEAN, MERN, or Node listed in JavaScript postings than Express. It's used, just not explicitly referred to as much.
Great write up! I looked into JWTs as an option for token based auth with my last project, but ended up going for [Devise Token Auth](https://github.com/lynndylanhurley/devise_token_auth) since it did most of the auth heavy lifting for me. Will try JWTs on my next project!
Thank you ;)
Am I missing some situation where I told you I‚Äôd check out something of yours? I don‚Äôt see any previous conversations between us in our history. 
I would love to work with Ruby professionally but it seems like all the positions require 5+ years of experience. I‚Äôve found it much easier to find JS jobs. 
Excellent - thanks for sharing! This is of interest since some people have already mentioned using MRuby to implement VST plugins (https://blog.fazibear.me/processing-audio-with-ruby-330796afd06). Your framework will be much nicer to use compared to JavaFX (which I attempted to use here https://github.com/thbar/opaz-plugdk a long while back).
Thanks for your work on this!
&gt; using MRuby to implement VST plugins Yikes. Ruby isn't suitable for realtime audio processing and that article reinforces the point. Having a mutex to lock during audio processing and lots of memory allocation/deallocation is a recipe for disaster ( http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing ). I understand the appeal of being able to use ruby in that context, but IMO it's not really a practical tool there going beyond toy examples. Other parts of the plugin however can greatly benefit from ruby since those components can tolerate the additional latency. &gt; which I attempted to use here https://github.com/thbar/opaz-plugdk a long while back Thanks for the link.
If you're in Toronto or willing to move here, message me
In SF currently but thanks!
Exciting stuff, it's is in place as of about 30 minutes ago: [rvm get master &amp;&amp; rvm install truffleruby](https://www.reddit.com/r/ruby/comments/8ruapz/rvm_truffleruby_ready_rvm_get_master_rvm_install/)
Exciting stuff Benoit! THANK YOU!
I'm curious why JRuby can't support `fork()`?
The JVM which jruby runs on does not support fork very well or at all so it makes sense that Jruby won't either.
Why do you think that ruby requires 5+ years of experience while node doesn't? 
That's great. I will give it a try soonish :) (~8h)
How generate a Windows executable file using mruby? I don't know that is even possible. Tell me everything please.
Having serious large scale full stack Rails and non-Rails (Py or Node) under my belt now, it has become ever so clear how productive Rails is and how much of that is the fact that Ruby actually has a f\*\*\*ing standard library. So I'm not surprised by these numbers. Then with gems like devise, filterrific, simple\_form, cocoon, carrierwave, sidekiq, and activerecord-import I can whip together apps so quickly it just boggles my clients' minds. The ecosystem is deep, rich, documentation is good if not great and the language has several paths to getting some serious speed improvements behind it (Graal/Truffle/Substrate and JIT). Implementing the simplest things in node ecosystem sometimes feel like wading through molasses. I love ES6/7 but damn for 95&amp;#37; of projects today regardless of (anticipated) scale I'd choose Rails to start with and then split off just the things which need to be fast or fancy like Delayed Processing / MQs, ETL, any data science, etc.
Are you referring to just mruby in general or specifically with mruby-zest? In my own work I tend to build mruby via gcc on linux/osx and mingw64 for cross compiling on windows (though I have seen people building mruby-zest vis msys2). mruby itself supports directly compiling on windows via MSVC as well (see https://github.com/mruby/mruby/blob/master/doc/guides/compile.md ) as cross compilation options. One of the cool things about mruby is that it's fairly simple to specify the set of gems to compile together into one standalone binary, rather than an interpreter and several source ruby files.
Since I have to sometimes get involved in hiring ... For us the issue is that we hiring incoming college grads, so we basically don't advertise Ruby or anything like that to hire them AND a lot of them are hired via University programs. People with less than say about 5 years of experience aren't necessarily THAT much better than those incoming college grads, so we just use a similar ad to hire them. 
lol nil types
oh wrong sub
Thank you. I like to know how to create a application that uses mruby, like your mruby-zest.
Testing is a disaster, it doesnt scale well, requests per second are comparatively very low, gems dont manage dependencies well, and Rails marries you to a lot of its built in functionality. Is demand high because too many projects are abandoned?
This looks really great! As far as I understand it yet, this works only for your audio application, right? Would it be possible to extract mruby-zest as a standalone gem so others can create a client application with it? If so, are there plans to do this, or is this up to the community?
"RPS comparatively low": compared to what? I am very skeptical of your other comments, so I want to heavily discount your statement on RPS but I'm open to listening to arguments about RPS. RPS is a hard metric to optimize for, in a large production environment... having a Rails based service in itself might be the least of your problems, relative to a lot of other questions about how the fabric is designed as a whole. 
I am impressed by 80k requests/second for Shopify, but maybe that's just me? ¬Ø\\\_(„ÉÑ)\_/¬Ø
I'd def be cautious re- or special-define something so common as `+`. On the other hand `&lt;&lt;` is pretty common to custom define for domain objects, and is an operator too -- just meaning it can be called in operator syntax without `.` and `()`. I think we expect `+` to be symmetrical, but not `&lt;&lt;`. It's definitely easy to accidentally end up with a confusing or error-prone api using custom or overloaded operators, but it's still kinda neat and there's probably at least one or two examples that would be easily legible, heh. 
Why did companies require 5+ years of experience in Rails back when it was only a couple of years old?
After 5 years, working in a golang gig, I came back to Rails, an ongoing project, lot to do and I'm quite happy to be able to work full-time with ruby again. Nothing against go, but I love the ruby development stack.
I worked on a considerably old node project (in Javascript Time Measurements), which was started around 2014 primarily with callback style code, then Promises came through - at that point I joined in, there was a lot of Promises based code mixed in, then there was a co-routine style hype wave! I have since left actively working on that project. But seems like active members of that project want to slowly migrate all of the code to async/await style. If they drop that idea, the codebase will be as good as a tree trunk with concentric circles showing off the age.
Rspec hasn't given me much grief in the past 2 years I've been using it.. are you using Test::Unit?
I haven't checked this but I'm pretty sure Mongo is not a huge thing anymore. Seems like startups still choose boring old MySQL/Postgres. Also the 'A' for angular isn't that big as it used to be now that React is gaining momentum. So no reason why MEAN should be huge...I just don't think it's a thing anymore. But if you have data you think I should look at let me know.
I think the difference between someone with 5 years experience and university graduate is huge. Unless the grad also did web development on the side for a few years, it just takes A LOT of time to digest Ruby,Rails,databases,html,javascript,css, front end frameworks and the list goes on and on. Do you maybe take grads that already know Ruby and web development but never worked in the industry?
&gt; Testing is a disaster Quite the opposite, Ruby testing frameworks are often praised outside of Ruby. &gt; it doesnt scale well Note that in 99.9% of scenarios you need to scale your databases, not the language. &gt; requests per second are comparatively very low When you add the database to the mix, I think it more-or-less evens out at the end. If a Ruby web framework responds in 5ms while a Golang web framework responds only in 1ms, it doesn't matter to me if database calls add another 20ms. &gt; gems dont manage dependencies well The Ruby ecosystem has all the means to manage dependencies well, so I don't think Ruby developers are worse in managing dependencies than developers in other languages. &gt; and Rails marries you to a lot of its built in functionality That I agree with. Generic Ruby libraries FTW.
`rbenv install truffleruby-1.0.0-rc2` but rails 5.2 is not there yet
Not quite sure what you mean by 'implement' pair. In this case `data` appears to be something that mixes in `Enumerable`, which gives it a `each_with_index` method. When you call `each_with_index` with a block (this part here `do |pair,index|`) it yields each element of `data` as a first block argument, which in this case is called `pair`, and element's index as a second argument. It appears to be that pair is in itself an Array, which allows us to access its elements by index (`x.id==pair[0]`). Keep in mind that you can call block arguments any name you like, it doesn't have to be `pair`, its just an arbitrary name chosen.
&gt; this works only for your audio application, right? The framework was built with the needs of audio applications/plugins in mind, but nothing intrinsically limits it to that domain. &gt; Would it be possible to extract mruby-zest as a standalone gem so others can create a client application with it? It is it's own gem at the moment, however it is entangled with some of the implementation of the specific user interface for the zynaddsubfx synthesizer. One of the goals down the line is to eliminate this coupling, though the speed of that change likely depends upon community interaction (both requests and more direct contributions). At the moment the other gems involved in the library are much more standalone including the qml parser, qml-parse-tree to ruby class converter, and osc-bridge.
In that case I'd recommend reading the documentation and examples available in the official [mruby repo](https://github.com/mruby/mruby).
their instinct to follow the language leads is correct. but unfortunately the language leads are schizophrenic and broken. in almost any other, and more stable, environment we might praise coders for fighting to be up to date. 
The JVM is heavily multithreaded. Forking only transfers across the forking thread to the new process, meaning all your support threads are gone, stopped at pretty much arbitrary points. That puts a forked VM in a [precarious state](https://thorstenball.com/blog/2014/10/13/why-threads-cant-fork/) that's prone to imploding if you so much as blink. You can actually run fork via FFI, and even some bits of the standard library have been known to do that, but such usage is basically always wrong - the only safe things you can do are [basically the same as for a signal handler](http://man7.org/linux/man-pages/man7/signal-safety.7.html), and you can't guarantee any of that using Ruby.
same! i've been in an engineering role for 5 years now, just recently (within the last year) have been learning ruby and rails, and i'd love to get a position where i'd use it daily. it's so great to use compared to .NET or JS on the backend
FWIW here is a real example of RVM doing too much and having bugs because of it: [https://github.com/rvm/rvm/issues/4408](https://github.com/rvm/rvm/issues/4408) ruby-install/ruby-build don't have that issue and don't touch the installed files after extraction.
could you detail why testing is a disaster? your points could contribute to the discussion if they were qualified by some examples.
I work for a large Enterprise rather than a tiny startup, so longer term stability is more desirable than necessarily being able to work from day 1. My whole point was that 5 years and university are different steps (and we hire them differently.) It's the in-between people that was more problematic. There might be a person with 1-2 years of experience who's as good and reliable as people who have 5 years of experience, but the majority of them are not. If we open up a job with 2+ years of experience, we'll be inundated with people who not much if any better than new grads AND they want more money. Ultimately we've just chosen to mostly only advertise for new grads and then 5+ years for 99% of our new hirings. We do end up with some people with less experience applying for the 5+ jobs and we don't necessarily 100% screen them out, but we don't lower any of the screening questions. All this these screenings and "requirements" are really just attempts to limit how much work the technical and management people have to do with interviewing to hire each person. Nobody wants to interview 100 people everytime you hire 1 person.
&gt; And please take into consideration that the last release of will_paginate was almost a year ago, the git repo has a few dozens of pull requests pending and the last commit dates back to July 2017. I wish we could stop this wankery over commit dates.
I appreciate the link, thanks!
Very exciting! I've been wanting to use Truffle for a while now and this is just the ticket!
Similar experiences. Go is just not Ruby. It was exciting, but the enamoration wears off, especially for those who have worked with Ruby before.
As a person who used to interview candidates, and help write job listings. I would have never required 5+ years for either, but I can understand why it would sound kinda absurd to require 5+ years JS since JS has changed so much in the last 5-8 years. Whereas I can pick up a 10 year old Rails app and still understand, edit, and even upgrade much of it.
Because the HR people didn't know what they were talking about?
This is basically every myth/misconception bundled into one sentence, with no source. I mean, even with your first point (testing is a disaster), several other languages have been *catching up to ruby, by copying its design* for testing!! IMO ruby is perhaps the **best** language for testing, period. Other than, of course, arguments for "static typed languages don't have runtime errors", or "functional languages don't have side-effects". But now we're comparing apples with oranges. Compared to PHP, JS, Python, Perl, ... (all of which have decent testing frameworks now), ruby has IMO been on par or way ahead of them.
None of the replies to my comment mean that implementing functional patterns at a large scale in Ruby is a good idea. Ruby is not a functional language and implementing FP in Ruby is a massive kludge at best. I'm not saying FP concepts have no application in Ruby, nor am I saying learning them won't make you a better developer, but learn them in a language that's built around them. Learning them in Ruby won't give you the same advantage.
I'd be really interested to see what the numbers look like when you factor in jobs that aren't posted publicly.
You may need to install, link or just add llvm 4 to your path. https://github.com/oracle/truffleruby/blob/master/doc/user/installing-llvm.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [oracle/truffleruby/.../**installing-llvm.md** (master ‚Üí 5d7724a)](https://github.com/oracle/truffleruby/blob/5d7724a08b283d9e8823a355b7325ba98f6057d8/doc/user/installing-llvm.md) ---- 
So happy to have a JRuby release, with Jruby ActiveRecord adapters, that actually works fully with Rails 5.x finally! Thank you JRubyists! 
Nice! Love to see Ruby getting some love in the AI space. Because let's face it, Python is just a drag.
Microservices? I agree though, Sinatra kinda sucks. As soon as your service as more than 2 or 3 endpoints, you end up reinventing Rails, and that usually goes badly. 
Thank you for giving me a use case where Sinatra would make sense üòÇüôèüèº
RVM will install the dependencies for you by default, including LLVM. Note the per-platform deps in eregon's PR: https://github.com/rvm/rvm/commit/70ff3d0af27e55a2b70f66216e5d1919c5bcd840
Python has a lot of investment from both its communities and big companies in the data science and Machine Learning front. I'm optimistic we will eventually catch up, but we have ways to go.
I had some but no full success. Some gems couldn't be compiled. For example - pg &amp; nokogiri.
I installed llvm 6. Do you think that could have been the source of my issues :)?
yup, follow the guide and link brew with llvm@4.
thanks, I will give it another shot.
what makes you optimistic?
Honestly I‚Äôve never seen a Sinatra app that convinced me for any other reasons than raw speed (vs. Rails). I‚Äôm sure it‚Äôs possible to write a clean, well organized app with it, it just seems to require more discipline than the large majority of people using Sinatra possess.
&gt; Python has a lot of investment Tell me about it. Almost every scientist I‚Äôve met seems to downright *hate* programming, which is why they *love* Python. 
They want senior dev, senior means 5 years. Doesnt matter how old the framework is /s
Seems hard to get that data. I can tell you that looking at [indeed.com](https://indeed.com) , the results are the same. Rails on top.
LLVM 6 might work, but we don't test it. pg &amp; nokorigi definitely need more fixes to work though (pg support should land soonish), so changing LLVM version won't fix that.
 If u want to find hash rate of different graphics card u can visit [***https://miningchamp.com/***](https://miningchamp.com/) 
Thanks for sharing~ I'll check it.
If you're using this with a high-throughput table, you can expect deadlock issues.
that's because lookbehinds have to be fixed length, cannot be variable.. see also https://stackoverflow.com/questions/22821644/why-this-regex-assertion-doesnt-match here's a work-around, though `\K` is not documented &gt;&gt; /&lt;\w+&gt;\K\w+(?=&lt;\/\w+&gt;)/.match("Fortune favours the &lt;b&gt;bold&lt;/b&gt;") =&gt; #&lt;MatchData "bold"&gt; 
Ah! Thanks! Gonna try it out.
I did a write up on this here https://blog.heroku.com/rails-asset-pipeline-vulnerability. Heroku is actively detecting vulnerable versions using config of `config.assets.compile=true` and blocking the deploys. First time we've done something like that before.
Awesome, thank you. The [cve](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3760) is still listed as "This candidate has been reserved by an organization or individual that will use it when announcing a new security problem. When the candidate has been publicized, the details for this candidate will be provided." Have you already flipped the neccesary switch, just waiting for it to percolate through the system? Or do you need to do something to finish this CVE? Incidentally, this feature is why you can reserve/add the CVE _right away_, you don't need to wait until you have a patch to apply for the CVE to identify the vulnerability. Because initially it includes no data whatsoever. 
From my own experience, going from ruby to java was quite rough. Overloading, generics, annotations, etc. oy vey. Probably best, imo, to learn some sort of compilation language like C, C++ or Java.
It's been published, but for some reason isn't showing up. I'm following up with why right now. The CVE is also listed at https://github.com/rubysec/ruby-advisory-db/pull/340. The text of the CVE roughly has the same language that is listed in this group post. Looking into it right now üëÄ.
Any thoughts on learning data structures in strictly Ruby? 
Here's a the link to the live editor to play around with [https://visualize-ruby.herokuapp.com/](https://visualize-ruby.herokuapp.com/)
Did not know about https://github.com/magnusvk/counter_culture which is an issue I have for CodeTriage. Thanks!
Again, e.g. Java has lists, arrays, vectors, hashes, etc... With Ruby it's just arrays and hashes. So, it's probably not a bad idea to understand data structures in both ruby and another language. 
Gotcha. Thanks for your help.
I think you should be comparing Rails with Node.js as Node's use is mostly within web development. There are very few job postings for other Ruby frameworks so discounting them doesn't alter the picture much whereas preferring Express to Node excludes Meteor, Sails, Haps and many other popular Node.js frameworks. Spring Boot is arguably more web-centric than Spring MVC so if you omit it you have only half the picture for Java and it could be argued that Rails is used for intranet apps as well as websites. LinkedIn's job search is far less nuanced than Indeed where you can specify that the search term appears in the job title, which I find to be a much more reliable metric. Indeed also has an API which eliminates duplicates. My stats from Indeed indicate that the USA is atypical for Ruby/Rails. When you broaden your search to Europe and the rest of the world Ruby and Rails rank much lower. Here in the UK, according to Indeed.co.uk, Rails jobs have declined by about 50% in the last couple of years and it's mainly concentrated in London unlike PHP, Node and Python which show steady adoption nationwide. For London Node.js/Rails by job title is 3:1 and Python:Ruby is 4.3:1. Outside London PHP (excluding CMS) is 7:1. Rails is still a mature framework but there's no doubt that in the UK adoption is declining relative to Node and Python.
Try London. Recruiters are falling over themselves trying to fill Ruby roles. London did have a very buoyant Ruby community 5 years ago but if you go to Ruby hack nights the numbers have dwindled significantly in the last 2 years. With Node, JS, Python and Go you have to join a waiting list for a lot of events.
cool, thanks!
What would you consider to be high throughput?
The science behind data structures is the same on every language. What this guy is saying (correctly) is that ruby makes them easier by hiding most of the complicated stuff behind a magic curtain. Learning it in a language like java would be harder, but you‚Äôd have a much better understanding. And it would then make using data structures in simpler scripting languages trivial 
Thank you! I'm sold on it :D. I plan on going that route. 
The purpose of CVEs is simply providing a unique identifier for coordination between security researchers and affected technology vendors. The fact that the vuln has been published elsewhere is absolutely the point and expectation because CVE is not a vulnerability database. The public listing of a brief description and some references is a side-effect enabling broader coordination and for the historical record, it's not intended that you subscribe for up-to-the-minute vuln information.
It's relative to how beefy your DB is. But anyway counter caches like every other optimization is about trading something off for something else. In this case you are trading write performance for read performance. If you are using them on a write heavy table, then it's a design mistake. 
TLDR: You're safe if you have config.assets.compile = false (in production, which is the default setting) If not, bundle update sprockets to a patched version and deploy
Yup, but don't make the mistake of assuming that it's still the default value. I've seen cases where one dev flipped that switch in some tiny commit that no one noticed years ago. Here's a one-liner to determine if an app is affected: $ rails runner 'puts Rails.application.config.assets.compile.inspect' 
Yeah I never assume - I double-checked all of my repos before posting to reddit :) I never (ever) use rails runner - thanks for that reminder
It worked with less "on screen" errors with llvm 4. Unfortunately, in my case both "pg" and "nokogiri" are showstoppers. 
Thanks for the writeup and quick fix. From looking at the sprockets fix here - https://github.com/rails/sprockets/commit/c09131cf5b2c479263939c8582e22b98ed616c5f - it seems like if one were to find logs making requests to URLs including "assets/file:..." that would be indicative that an attacker may have been attempting to exploit this vulnerability. Is that correct? Or would the exploit potentially work with "file:" anywhere in the path following "assets"?
I'm not sure if "throughput" is the right word. Frequently updating a table isn't bad by definition, instead it depends on variables such as: 1. The number of columns and their data types. 2. The number of rows. 3. The size of these rows. 4. The number of indexes and constraints In general you want to notix frequently updated data and rarely updated data in the same table, if that data gets pretty big. In those cases it's better to spread the data across multiple tables. A simple example: say you track the number of "likes" a post gets directly in a "posts" table. Every time somebody likes a post, the row has to be updated. In case of PostgreSQL that means copying the entire row and creating a new one (ignoring HOT updates). If a post is big, or this happens often enough, this can put quite a bit of pressure on the database. At GitLab we had a whole bunch of these cases over the years, usually these involved timestamps being updated every time the user as much looked at their computer. We historically dealt with that in three ways: 1. If the data/operation isn't necessary, just get rid of it. Removing code is the best way of optimising it. 2. Throttle the number of updates, e.g. 1 update per minute per row. This only works if you can permit the data to be less accurate. 3. Move the data to a separate smaller table. This ensures updates become much cheaper, and you can still easily get the data (e.g. using a JOIN).
That‚Äôs correct. It needs to start with file://
It's pretty handy when benchmarking/profiling Ruby code tied to Rails without going through the complete HTTP ceremony.
(Sorry for awful accent. Some ideas seem worth sharing, though.)
Has someone managed to exploit this successfully though ? All I managed to do was get an `Sprockets::FileOutsidePaths` error (when trying /etc/passwd) seems like you can only target files under the sprockets load path ?
Because you are declaring the variable at the start of the block, Ruby limits that variable name to the scope of the block. &gt; foo = 42 &gt; 1.times { |foo| foo = 'hello' } &gt; foo =&gt; 42 &gt; foo = 42 &gt; 1.times { foo = 'hello' } # foo not declared &gt; foo =&gt; "hello" 
Can anyone recommend a solution for rails 3? Just setting `config.assets.precompile = false` won't do, because I keep running into missing files. I would love it if I could just update the gem. However, rails 3.2.22.5 depends on actionpack 3.2.22.5, which in turn depends on sprockets 2.2.1. The patched version is 2.12.5, though. Any suggestions for a quick solution?
this is not what I'm asking clarification for... `1.times { |foo| foo = 'hello' }` here, `|foo|` is basically index value for each iteration.. for `3.times`, it will be `0,1,2`.. this will never affect variable of same name in outer scope let's say I use the variable `idx` to get this index value, then what should I do to declare `foo` variable inside the block to isolate it from variable of same name in outer scope? Ruby documentation says to declare it after a `;` and that works.. what I'm observing is that it works if I use `,` instead of `;` as well..
You're the guest? 
Yup. 
Congrats dude! I also saw you last year at EuRuKo giving a really funny lightning talk https://youtu.be/NEnZViT581o?t=14m10s
There is a difference. If you use `,` you declare a second argument to your block, it's just that blocks don't enforce the number of arguments passed and will initialize the missing ones to `nil`. &gt;&gt; block = Proc.new { |a, b| [a, b] } =&gt; #&lt;Proc:0x007fc865a5f9a8@(irb):15&gt; &gt;&gt; block.call(1) =&gt; [1, nil] &gt;&gt; block.call(1, 2) =&gt; [1, 2] &gt;&gt; block.call(1, 2, 3) =&gt; [1, 2] 
Initially it's the index, but you can assign it to whatever you want once in the block. The point is that by declaring the variable within the `| |` before the block, you create it as a new variable within that blocks namespace. foo=42 1.times do |i, foo| puts "foo is #{foo}" foo='hello' puts "foo is #{foo}" end =&gt; foo is =&gt; foo is hello
thanks a lot, this helped me understand this better.. also I suppose `;` makes the intention clearer even for the example I had in question...
ok, in the example you've created, I wanted to know what's the difference between `|i, foo|` and `|i; foo|` ... you could use `foo.inspect` for the first puts to show nil in the output.. the other comment cleared my doubt, thanks anyway :) 
You don't need to apologise. Your accent is easy to understand. I've seen native speakers with thicker accent than yours. 
When executing: rvm get master rvm install truffleruby Searching for binary rubies, this might take some time. No binary rubies available for: ubuntu/18.04/x86_64/truffleruby-1.0.0-rc2. Continuing with compilation. Please read 'rvm help mount' to get more information on binary rubies. TruffleRuby requires LLVM to be installed to run native extensions. For more details and for setup instructions for your system, please see: https://github.com/oracle/truffleruby/blob/master/doc/user/installing-llvm.md 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [oracle/truffleruby/.../**installing-llvm.md** (master ‚Üí 8e0f23c)](https://github.com/oracle/truffleruby/blob/8e0f23cdede8c64ccac6b0aa5f91a7b8b998839e/doc/user/installing-llvm.md) ---- 
My VM with 10 GB ram runs out of memory building nokogiri, what error did you get?
Ruby != Rails
I‚Äôve run into both the problems the author highlights. But I recall some time back finding that leading dots were preferred by Ruby style guide. Now that he shows that both are perfectly acceptable, I‚Äôm wondering if this is a recent change in the style guide and Rubocop?
Sounds like you are enjoying Elixir :) I can relate to the things you wrote in your post. One thing you didn't write about but what I'm really happy about is the simplicity of Elixir. Crazy meta programming is very commonplace in the Ruby world and I'm super happy it's not a thing in Elixir. I feel like the language is a lot less complex and I'm never left guessing where a particular method comes from. Also, we all love Jos√©. He's super helpful and always looking to get people involved in the project. I have 2 pull requests in ActiveRecord (from 5 years ago) and one in Ecto (this year) and the difference was just night and day. The AR changes took well over a month with little to no communication and had to refactor twice. The Ecto changes were merged the same day by Jos√©.
You need to be in the directory of the project in the command line, and then run "bundle". This will install the gems specified in the Gemfile. 
I haven't stepped into the metaprogramming world much. But I definitely feel that Elixir is more expressive in many ways. So I can relate to what you mean by "never left guessing". Yep, I have the same experience with contributing to Elixir. Both of my PRs to Elixir were merged within 24 hrs by Jos√©. It's really encouraging to see him being so involved in the community: on the forum, github, conferences, etc. 
Got it to work! Here is my .te file module passenger6 1.0; require { type httpd_t; type cert_t; type default_t; class capability sys_resource; class file { execute getattr open read }; class file execute_no_trans; class file { write create }; class file { setattr unlink }; } allow httpd_t default_t:file { execute getattr open read }; allow httpd_t default_t:file execute_no_trans; allow httpd_t cert_t:file { write create }; allow httpd_t self:capability sys_resource; allow httpd_t cert_t:file { setattr unlink };
I went to a talk by Hal Fulton of The Ruby Way on Elixir. He's pretty enthused and spoke much on why Dave Thomas and other early rubyist are excited about Elixir. Hal recommended reading this article http://www.gotw.ca/publications/concurrency-ddj.htm
I wrote this. It's designed to make serialization to postgres jsonb, possibly with complex multi-level object hieararchy, as smooth and seamless as possible. Any kind of feedback is very welcome. 
We all love Matz too :)
So I *think* that is what I did. I cloned the Repo to my H: Drive. Then in CMD, I went directly into the repo (ie: H:\\rightsignature-pdf-download) and ran this: git bundle create ../myrepo.bundle master When I do this, the 'myrepo.bundle' files is always appearing in H:, not rightsignature-pdf-download. After moving the bundle into that folder, I've re-run the script, and got a slightly different error message: Traceback (most recent call last): 10: from rightsignature-pdf-download.rb:2:in \`&lt;main&gt;' 9: from C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler.rb:114:in \`require' 8: from C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler.rb:107:in \`setup' 7: from C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler/runtime.rb:20:in \`setup' 6: from C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler/runtime.rb:108:in \`block in definition\_method' 5: from C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler/definition.rb:227:in \`requested\_specs' 4: from C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler/definition.rb:238:in \`specs\_for' 3: from C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler/definition.rb:171:in \`specs' 2: from C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler/spec\_set.rb:85:in \`materialize' 1: from C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler/spec\_set.rb:85:in \`map!' C:/Ruby25-x64/lib/ruby/gems/2.5.0/gems/bundler-1.16.2/lib/bundler/spec\_set.rb:91:in \`block in materialize': Could not find http-form\_data-1.0.1 in any of the sources (Bundler::GemNotFound)
Matz is also great but unless you speak Japanese and work on Ruby's core you probably won't come into direct contact with him.
Very cool library - and a pretty good README too :) . I think I might try to check this out over the weekend
I tried elixir for 3 months. learned it enough to build a small app in Phoenix. It has its purpose but in my opinion it is overhyped by its followers and i'll explain why. Let me be clear first that I **am** a fan of Elixir (but not of Phoenix which its kind of married itself to - similar to how ruby did with Rails at first) for very niche purposes. Its biggest bonus is concurrency. Few other platforms match its per server concurrency capabilities. But truthfully VERY VERY few apps will ever need it and other languages simply use a few more servers if they get to millions of users The problem with Elixir and phoenix (which its pretty married to at this point) is that it involves a decent learning curve and it has a very very small ecosystem (be prepared to make your own wheel often). Its pretty easy to get going and do some crud work so it can and was sold as "like rails" but don't be fooled -Somewhere after the first week the hill comes and the learning curve goes up. Thats okay if it really does lead to more productive programming but the evidence is lacking with elixir/Phoenix to say the least. I am still struck after following with the Elixir community and news for nearly two years how so few are doing anything big with it. Elixir enthusiasts always tell me how more productive they are and when you ask them what they built or are building its terribly underwhelming. Many are still working their way through a book. If its so productive where the rush to the gates? over the two years I have followed it adoption by programmers is nowhere near at the level the elixir fans thought. After familiarizing myself with it I don't believe the enthusiasts at all anymore. Mind you Functional programming is cool . its clean and common sense at some points going very much along the path I think ... I do believe functional programming will continue to grow but in the end I asked myself - Why choose elixir to be that functional language when its basically a language wrapped over Erlang's capabilities which in decades has not been used widely outside of telecom? I'd rather continue learn functional programming for something I can use widely. Rails and ruby work great for me (and will shortly wipe out some of the main downsides people levied against it with Truffleruby and its brother from another mother - Crystal - faaaaar more similar to Ruby) on the server. Why mess with Elixir further when its usage is very limited to Where its underlying BEAM can be used? If we ever have a multimillion user app on our hands (or one thats growing fast to that then) maybe but thats pretty niche and with other tech the difference is slimming every 6 months and yes I kow there are othe benefits but none of them are game changers . Elixir /phoenix also herald a high uptime efficiency but how often do you go to use any of your top apps which run on OOP tech and find it down? I was initially impressed with that as well until I realized a .00001&amp;#37; uptime rating was a under a minute a year. 
Might be nice if you could extend this to use a config variable along with the url. The variable would be an array of urls, these can be the exclusion list just like the url tag. Also might be nice if this extended the ability to add a relationship opener. This can help in telling web crawlers not to follow the links as it‚Äôs not a part of your site
I think you should post some code so we can get a better idea of what you're working with. In general, I'd avoid Hash for things other than maps. Also you mention 'gets' in the title, but not in your post. Are you talking about IO.gets or about "getters and setters" ?
I'm afraid I have to agree with you. I too jumped on the bandwagon at a time elixir headlines where the top or near top of all ruby related discussions. My biggest issue to date with it, is it's totally unclear and (IMO) overly complex code locality standards. I feel the Rails team has done a real phenomenal job with nugging the community to follow a fairly standardized pattern; in regards to where various forms of business logic and relational logic is to reside. With elixir, you just really end up throwing things in various hugely/overly exaggerated nested "contexts". A simple umbrella app will have you typing till the moon rises before you can access a simple `hello_world` function. I do love all the pattern matching and recursive nature tho. But I think stripping out simple things like Array's in favor of lists, was not a good move since 90% of all languages have a concept of an array. 
Yeah upgrading to 2.5 from 2.4 isn't trivial. I ran into problems because I use mariadb locally. What other things should we watch out for?
Here is a longer discussion that have a few years about dots topic [https://github.com/rubocop-hq/ruby-style-guide/pull/176](https://github.com/rubocop-hq/ruby-style-guide/pull/176) At the moment there is no main recommended approach so it might be confusing for newcomers to decide what to pick [https://github.com/rubocop-hq/ruby-style-guide#consistent-multi-line-chains](https://github.com/rubocop-hq/ruby-style-guide#consistent-multi-line-chains)
I can repeat every single work of you. I dig into Elexir for about 3-4 months. I'm definitely a fan as well, and I like it a lot. However,... everything you have said :D
Thats why I am particularly not a fan of Phoenix. In my opinion phoenix developers got the "I want to be different to seem profound" bug. I think Elixir itself is fairly solid and Jose Valim did a good job with it but I won't look at phoenix again. I might look at Elixir if another framework comes up but really when I step into a different paradigm I want to do it for a language I can use on multiple platforms and that has a up and coming ecosystem. 
Give your product class a variable called quantity. The user gives you the product and quantity. Create a method that multiplies a products quantity by its price. 
&gt;I hope it is huge enough, but if it is not, it is too late to fix \~ /u/zverok_kha
To be fair, you shouldn‚Äôt use umbrella apps unless you have a large set of OTP apps that need to share code but not necessarily a supervision tree. I guarantee you don‚Äôt need that, it‚Äôs a very special case. There are plenty of patterns you can follow for logic as well, but you need to go out and learn what patterns are right for your problem. Additionally Phoenix is just a web interface you can strap on an OTP app, unlike Rails, it doesn‚Äôt call your code. Your supervisors call Phoenix code. This is hugely different in practice once you realize that you can drop the parts you don‚Äôt need or want.
There are many terms that get thrown around without really understanding their meanings. Dynamic refers to the type system. If you define a variable `item = 'name'` (and yes, that is exactly how you define a variable in Ruby) you do not have to tell ruby that the value of `item` is a string. You can then later redefine the variable as another type `item = 1` and that is perfectly legit, unlike in a static language where you define the data type when you define the variable and can not change it's value to a different data type. As for 'everything is an object', there are classes in ruby and everything has a class. Even the the value `nil` is an object with the class `NilClass`. I've found that numbers are a good representation of this. The `Integer` class is the parent class of all integers, so you can call any of the methods defined by the class on a number. A popular example is `5.times { puts 'hello' }` which will print out the word 'hello' five times. Even math is a method call: `5 + 5` is just the syntactic sugar for `5.+(5)`. Is Ruby a dead or dying language? No, not really. It was massively popular for a couple years, primarily tied to the web framework Ruby on Rails, but it's not the popular new kid on the block anymore. But articles that shout "X IS DEAD" drive more page views. I guess if your definition of dead is 'not what all the cool kids are using' then you could call it dead. But it has a strong community and leadership and is still used by many companies and people. Is it used mostly for web development? Well, yes and no. Due to the popularity of Rails, it is mostly used in web development. However, it is also common in server management. Tools like chef and puppet are written in Ruby. Really, you can do a lot of things with Ruby. So just because it is primarily used for web development doesn't mean that it can only be used for web development.
Thanks, really helpful answer. I'm definitely going to pursue more Ruby. I have a few questions: * You wrote 5.times {puts 'hello'} .... is this the preferred looping syntax for Ruby, or would I generally use a for loop? * I've wrote a small program, but I'm having trouble getting the typing correct. I thought Ruby kind of determined it for you. Like I have a function that does some math operations, and takes in two parameters, it seems like I always have to use ".to_f" inside the function to enforce that I'm using a float? Otherwise my compiler thinks it's a string or something? Am I just doing things wrong, or is that how things are supposed to be done? * Say I have this code: def print_age(age) print "Your age is : " + age end print_age(18) This doesn't work. I guess that the "+" is only used for concatenation, and it can't concatenate a string to an int. However, is there a better way to write that print line? Or would I have to use TWO print statements, one for the string and another for the variable age? Like with C++ I could just use the "&lt;&lt;" operator, so I could have written like: cout &lt;&lt; "Your age is: " &lt;&lt; age; I've looked online but I can't seem to figure this out. Thanks for all the help.
No. Generally in ruby you define a class and all it's methods in the same file. You _can_ spread it across multiple files, but unless you have a really good reason to do that, don't.
Gotcha thanks. It just seems like things would get a little messy, and would be easier to read otherwise. But I definitely want to stick to whatever is the proper syntax for writing things.
1. Loops in ruby are a little different than most other languages I've worked with. Usually I use the `.each` method, as in `['a', 'b', 'c'].each { |val| ... }` but if you need to do something a set number of times, then yes, the `.times` method is common. 2. It seems like you are running into the 'Strong' type system in ruby. Ruby does not convert types for you. So if you want to make sure that a value is always treated as a float, then yes, you have to call `.to_f` on the value. 3. Like above, ruby will not convert the Integer `18` to a String for you. You have to tell it you want it to be a string, `print "Your age is : " + age.to_s`. Ruby doesn't know if you want to convert the `18` to a string or convert the "Your age is : " to an integer. There is a way around this and that is to use string interpolation: `print "Your age is : #{age}"`. Ruby now know you want a string and will convert the integer to a string.
1) there are many ways to loop.. it depends on what you need.. 2) when you are assigning a variable, Ruby automatically determines the type.. but operations between two different types depends whether they are defined.. for example: `'hello' * 3` is defined but `'hello' + 3` is not 3) you can use interpolation.. `"Your age is : #{age}"` ... `#{}` allow arbitrary expression also, which guide are you using to learn?
Thanks a lot. For the third point, I didn't realize that everything on the same line of Ruby has to be the same type. Like in that C++ example I mentioned earlier, the age variable is still an integer, whereas we also have the preceding string. Regardless, should be doing age.to_s or using string interpolation? Which is standard? Thanks again. 
Yes. It can get messy. As you get more into things, you can look at using Modules to separate out logical groups of code as well as using class inheritance. There are many ways to do anything in Ruby and that's actually on purpose. Do what you understand and your ruby style will evolve as you go.
I prefer string interpolation and I have seen it used more often than concatenation. The only real gotcha on it is that it only works inside double quotes.
Thanks for the help. I'm not really using a guide right now, I've just started. I heard the best way to learn a new language is to dive in and rewrite an old project in that language, and google as you need help. That's pretty much what I've been doing. Is there any specific guide that you would recommend? 
No, this is not the git bundle function, it's the ruby gem bundler that needs to be run. You just need to go into the repo and run `bundle`. 
It's technically wrong then in 2.4, isn't it?