I received this from a different doofus @ Solomon Page Group.
Classic email blunder there. I get the impression that a lot of recruiters do more harm than good. See here: https://gist.github.com/1285068
Fair!
&gt; Though, you'll probably only get one accepted! FINE! \*stomps off*. :) &gt; As far as talks go, pretty much anything goes. Roger. I've had this happen with conferences before, is all. "We want talks that are about ANYTHING!" "Sorry, we got so many talks, only pure Ruby gets in, you talk about documentation isn't accepted." \*watches videos, there are like 3 node.js talks* I've already submitted the one I want to give the most, but I've always got two or three I'm down to give, so I'll throw those in too. This fall I did 3 talks split over 6 or 7 different confs...
I liked her signature line: "If you're not working on you're best idea right now, you're doing it wrong."
I am best idea, what do I do now?
HA. I got that email.
Hey, good article. I was also really annoyed when I found out that I had to lose all my plugins with Gedit 3. So I tried about 5 other editors, and settled on Geany. It's so much faster. I'm starting to send patches for bugs and features, so I don't think I'll be going back to gedit. Thanks so much for mentioning the rails-footnotes gem, that's really awesome! I have an amazing development gem to share too: [LiveReload](https://github.com/mockko/livereload). It applies CSS/JS changes to Safari or Chrome **without reloading the page** (and autoreloads the page when HTML changes).
&gt; We have placed talented Rails Engineers in a space.... Something about that sentence is scary. It sounds like a reality TV show. Or a horror movie. 
It puts the lotion on its skin, or else it gets the Java again...
Hopefully we can generate some interest and find someone willing to dedicate some spare time to teaching a bunch of us redditors :) 
so in my mind, it totally depends on what that piece of functionality is. even if it isn't being used in multiple places, if it is something "modular" that can in some sense stand-alone, i'm all for moving it into its own file. however, i've seen too many fragmented code-bases that were the result of "refactoring" where bad code was just moved elsewhere instead of really refactored. that said, i currently work at a company where our entire django app is in a single monolithic models file (don't ask me why, i've fought to change this again &amp; again), and it is cumbersome at best, and very inefficient at worse
"If you're not working on **you're** best idea right now, you're doing it wrong." David Heinemeier Hansson (DHH) ,Creator of Ruby on Rails
It's like [Pradipta's Rolodex](http://thepradipta416.com/) all over again...
How does this compare to [ronn](https://github.com/rtomayko/ronn)?
md2man uses [a real markdown parser](https://github.com/tanoku/sundown), supports tables [PHP-Markdown style](http://michelf.com/projects/php-markdown/extra/#table) and all HTML4 and XHTML1 named entities, uses simpler syntax for tagged paragraphs (see "Document Format" in the README), and *only* performs markdown to roff conversion---if you want HTML, just run your markdown input through any markdown processor.
Would this be paid, or gratis? I'd consider it, but I just launched a freelance career, and I'm spending a lot of time getting a network together as well as working on projects. I'm not sure I'd have the time to put together everything that's required unless I could use it for some billable hours at the minute. My situation might change in a few months though.
md2man uses a [real markdown parser](https://github.com/tanoku/sundown), supports [PHP-Markdown tables](http://michelf.com/projects/php-markdown/extra/#table), translates all HTML4 &amp; XHTML1 named entities, has simpler notation for tagged paragraphs (definition lists), and *only* performs markdown to roff conversion (if you want HTML, just run your markdown input through any markdown processor).
Good luck. A few years ago my manager (the lead developer at what we'll refer to as "Company X") and I heard about Rails (back in the 1.x days) and started playing with small projects in our down-time. We fell in love with it, and decided to pitch the rest of the team and management on possibly using it for new projects. Management pushed back and said "too expensive to train everyone", and "we've been doing things the same way for 10 years, no need to change them now" - pretty much the typical response. We tried explaining to them that just because our current method of doing things was "working" doesn't mean that it was the best or most profitable / efficient method, but management basically just plugged their ears and started yelling "la la la I can't hear you". Anyway, fast-forward a few months - my then-manager and I quit Company X (a PHP shop) and partner up to start Company Z (a Ruby shop). A few of Company X's clients abandon ship and come along with us to Company Z, which gives us a good starting point. Last month was Company Z's five-year anniversary, and we've officially overtaken Company Y as the #1 shop in town. We have only three employees and pump out at least twice as much work as our old company (in half the time), without sacrificing quality. Company X has a 10 person development team and 8 "account executives". TL;DR - chances are that pitching your company on switching technologies is futile. Jump ship and start your own agency. It worked for me. P.S. If this doesn't make any sense, or my grammar is horrible, please forgive me - I've had a few beers this evening and I'm exhausted.
Chiliproject, I still don't get why they forked, yes I've read their wiki. The redmine devs are pretty damn awesome and move pretty quickly IMHO. With the REST APIs introduced in 1.1 and extended in 1.3 developers can create external UIs and functionality outside of redmine if needed. 
+1 Nice library, I'll probably use this ;)
This is going to be extremely helpful with my current project. Thanks for releasing this!
Global variables. Global variables everywhere.
why aren't you... ALLCAPITALIZED??
BECAUSE I'M POLITE.
How I feel when I'm forced to code PHP (after years and years of doing Python, Ruby, Erlang, Haskell... heck, I'll even add Java): &gt; my mind is going. I can feel it. I can feel it. My mind is going. There is no question about it. I can feel it. I can feel it. I can feel it. I'm a... fraid.
$;$;$;$;$;$;$;$;$;
[/r/lolphp](/r/lolphp)
Sublime text 2 is probably the best editor on ubuntu everyone who likes textmate should consider it 
I can't really go too in depth, but yes, we are doing several projects for government use, including our biggest one for the DoD. Just look at the clearancejobs.com for rails and you will find a bunch of Dod and NSA work going on in Rails. They don't publicize much for the same reasons I won't go into too much detail in a public forum like this, but it is being done and the clients are very happy as well. Agile is very hot too. Allot of the major players in the DoD contracting world are using agile now. Sample job posting. One of about 30 that came up in clearancejobs.com. http://www.clearancejobs.com/jobs/1495655/principal-software-engineer-ii
As for bad code, I have seen my share of bad code in C++, Java, and yes Rails. Bad code doesn't discriminate, and congress will investigate things at the drop of a hat. I can't tell you how many meetings I have sat in with various government agencies where they say this report is because congress asked this or that report is because congressman xyz got all bent out of shape. Par for the course.
No one from the federal side ever even set eyes on the code. Use of Ruby on Rails is prohibited and no exceptions were to be made. As I mentioned before we couldn't even get them to allow the code to run in the Development environment which was under DoD's control.
Just because private organizations hire people with the Ruby on Rails skill set doesn't somehow trump the fact that the technology stack isn't allowed. "But we just hired these two new guys!!!!1!" doesn't matter to the Government. As a consultant you should certainly understand this. Trying to make a point with private sector job listings is just foolish; clearly they are not held to the same standards. As someone who has been doing consulting (specifically for cleared contracts) for some time, you cannot hide behind the veil of secrecy with statements like: "for the same reasons I won't go into too much detail in a public forum like this". First and foremost, if the work was secret you couldn't discuss it **period**; regardless of whether the forum is public or private. Now it's starting to sound more like a fabrication than anything. We work very closely with one of the Deputy Directors within DoD on our modernization efforts. When he prints, highlights, and personally delivers documentation to your desk that expressly prohibits Ruby on Rails you don't push back. That's not to say a bad contractor won't try and slip something in that isn't allowed because it's the only thing they're comfortable with. Clearly this can be done as our program unfortunately discovered. That doesn't make it right.
Do you have a directive number or identification I can have our program people check out. We have live projects in DoD and are bidding on more so we need to know how to get this information.
If you're more comfortable with another language for web development, I suggest taking that route, as supposed to learning something new. That said, ruby can be used for this just fine. It more comes down to comfortability, and how quickly you need this up and running.
If this is a read-only, SQL-dump app then I would recommend [Sinatra](http://www.sinatrarb.com/) and [sequel](http://sequel.rubyforge.org/) Sinatra lets you write a very light and simple interface to capture gets/posts from HTML/javascript UI, perform validation, execute SQL and respond with output. Sequel is also really easy to use for command line apps. You can test the access layer on the command line and then try different web access methods. Sequel has both ORM style and clean-sql access to data. I've found that this works best for reporting, as some reports are easy with one approach and damn near impossible with the other. Good luck. EDIT: cleaned up.
You can find most, if not all, of this information in the DHS TRM as I mentioned previously.
My only experience was with C++ in high school so I don't really have a language that I'm comfortable with. There's also no real due date for this project so I have plenty of time to learn.
Thank you!
Thanks Jesus.
ZE GOGGLES, ZEY DO NOTHING!
Is there a good, clean howto/introduction on getting started with _simple_ web/database things in ruby? I don't want to code a blog or a shop, i just want to learn the basics for now. Text input to database via web, searching and outputting the corresponding database fields to the web again. Preferrably sqlite. Thanks in advance for any help!
Blogs are an easy way to teach what you want to know. Try googling a Sinatra ruby blog tutorial.
Looks fantastic. I'll definitely give it a thorough read. 
And \{\}!
Let a preprocess rewrite the css urls from relative to absolute instead: https://github.com/carlhoerberg/sprockets-urlrewriter 
no offense, but this looks like crap. why would you go with this over a more well supported https://github.com/spree/spree ? 
oh this is so funny! haha
I think this should be in /r/rails
I learnt on ruby, and I've been doing some php at work as that's what's used there, and jesus. It's not the verbosity, or braces or anything, it's the way that things I think of as bedrock core concepts feel sort of smushed around randomly. Like there are a whole bunch of just... functions... floating around. Apparently not belonging to any object or class in particular. And even the terminology (which I understand is more common, but still) seems designed to discourage what I think of (perhaps mistakenly) as core sensible not-too-complicated OOP concepts. For instance, compare this explanation: http://php.net/manual/en/language.oop5.static.php To the ruby practice of simply calling them 'class methods', and being able to declare them as you call them (def ClassName.method) The PHP version seems almost intended to make the whole thing seem exotic and complex. Something maybe you shouldn't fuck with till you're deep in the woods. In ruby it's something you start doing intuitively when it just doesn't feel right to have to instantiate to use something, or you want to keep some value shared within a class... And just to make it confusing, the PHP version they make the static methods available to instances too, but not the static variables. I'm sure there's probably some 'obvious' underlying reason for that complete inconsistency, but jesus... work around it. It turns it from a one sentence explanation for a programming beginner ('remember classes and objects? Well static means it belongs only to classes...') to a whole big memory exercise...
I'll have to try that out, I hadn't seen your gem before or thought of it. How does the pre-process know the correct absolute URL for a relative URL? I think it differs depending on rails asset config settings (dev, production, dev with debug=false, etc), no? As well as whether you are deploying your app to URL-root, or to a URL prefix. Does your solution work in all of those cases?
Yes you can do much better. What you're looking for is "bulk insert," wherein all your data is blobbed up and inserted in one call, as opposed to 100,000 Searching for "bulk insert" and "sqlite" turns out http://blog.quibb.org/2010/08/fast-bulk-inserts-into-sqlite/ Let us know if you have more questions or if this doesn't work for you.
Also, I think for Sqlite you have to use "UNION"s between each data tuple to get it to work. I'm a postgresql user but that's what I've heard. Ultimately, though, you shouldn't use Sqlite or most other embedded databases if you care about performance. edit *typo
Look at any of the NoSQL options; preferably one that can handle reading and writing collections and collection sets. MongoDB sounds like a much better option to store a large hash than sqlite. If this is not an option, consider using transactions and compiled statements to improve performance. DB.transaction DB.prepare ("insert into foo ....") do |stmt| hash.each do |k,v| stmt.execute (k,v) end end DB.commit! It should run faster this way. Double check my syntax, this is from memory. 
banachtarski and absinthe both have good answers (bulk insert, prepared statements) what you probably should not do, if performance is a concern, is directly use activerecord model objects. you likely want to do this using sql. if you want use pure ruby, you can submit the insert sql via activerecord, iirc, though assembling the sql string might be costly. what's worth noting is that there are ways of doing activerecord finds by sql and retrieving hashes, so it's possible there's support for moving in the opposite direction. of note, if this is a one time import, in the time since you posted this question, you would be well on your way towards finishing the import and all answers are moot. if this happens periodically, however, it might be worthwhile to consider the source of your data and decide if using a tool like [taps](https://github.com/ricardochimal/taps) might be a better fit.
You can pass an array of attributes to YourModel.create! which should do something smart: YourModel.create! [ attrs1, attrs2 ]
Try taking a look at the .import command in the SQLite shell. Take your data, output it to a file and then import it using .import. I just imported 100,000 rows of 20 columns of random data in a couple of seconds as a test. I'm not sure if the .import command has an equivalent interface in the SQLite Ruby adapter but that would be another option.
&gt;Ultimately, though, you shouldn't use Sqlite or most other embedded databases if you care about performance. This is untrue. I have used both postgresql and sqlite quite heavily. Sqlite performs similarly on analytical queries under single user scenarios if used correctly. Now, if you're talking about transactions per second, then yes, postgresql is your huckleberry. Edit: Added quote, comment about tps.
You don't say if you are using ActiveRecord, or want to keep using it for this task if so. But I just found this, for AR bulk inserts, that claims to work with multiple dbs https://github.com/zdennis/activerecord-import/wiki
You should just try wrapping your inserts in a transaction. Psuedocode: while there are still rows to insert: begin; insert 1000 to 10000 rows; commit; end This will allow you to considerably increase your insertion rate without resorting to bulk insert or c-based methods. 
Really? Even for databases larger than several gigabytes? I was always under the impression that sqlite performs poorly under those conditions but I might be wrong.
Why the downvotes? Suggesting that MongoDB stores maps well? Suggesting using transactions to avoid lock problems? 
sqlite performs well into the GB range, but at that size it is rarely a good choice. I will say that if you want to bulk load data, transform it and then spit out some other file for the next process in the line, then it might be a good choice. Better than yaml files at least. But for data that is going to in use for weeks or months, then I'd suggest pg or mysql or some other database that will be easier to backup and maintain. 
OP wants a faster way to seed a SQLite DB, not an alternative way to store the data.
I agree. I'd also like to recommend having a practiced script before trying to make a screencast. A script can make all the difference in the quality of the cast.
I provided both. Why this is a problem for anyone?
gratis through the universityofreddit.com website (http://ureddit.com) if you ever may be interested in the future you could always stop by their website and offer a class. the knowledge that can be shared with the amount of people interested in learning is a beautiful thing.
sooo, how would I use this? Being a novice, can I use this in Rails at some level? Totally reimplement a rails app as a C extension? Within my models and controllers? Or would that interfere somewhere? My skill level isn't at a level where I can fully understand, but this seems useful. 
I found a great solution to this for the project I'm currently working on. I switched to postgres.
I've not played with it yet, but I'd pick some computationally expensive ruby code and try compiling just that. So no, not your whole rails app. :-)
Or we could just make MRI faster? That mindset has worked well for JRuby / Rubinius. Also I'm going to bet there are some epic-subtle C bugs in their compiler implementation.
Agreed. This has already been done before with `ruby2c`, the project stopped back in August 18, 2009. MRI doesn't need this. IMO. *Edit: If you really need to interface with c, checkout [ffi](https://github.com/ffi/ffi)
You can [import CSV](http://www.sqlite.org/cvstrac/wiki?p=ImportingFiles) directly into `sqlite`. You could dump the dataset as a CSV file, or even setup a FIFO pipe.
Not as far as I've seen. Jeremy Voorhis made a [binding for Portaudio](http://github.com/jvoorhis/ruby-portaudio) which could be used to make something like that but I'm not sure if it's been maintained.
I suggest creating an Array of Hashes, where each Hash represents the attributes of a single record, and wrap one call to #create in a transaction. For example, let's say you have a Person model with attributes first_name and last_name. Then your import script would look something like this: array_of_record_attributes = [{:first_name=&gt;"Joe",:last_name=&gt;"Smith"},{:first_name=&gt;"Sue",:last_name=&gt;"Smith"}, ,...] ActiveRecord::Base.transaction do Person.create array_of_record_attributes end edit: I created a new application (Rails 3.1.3, ruby-1.9.3-p0), a Person model, and 1000 records with first_name, last_name attributes. Here are my benchmarks for wrapping the call to #create in a transaction vs. no transaction: user system total real without transaction: 1.180000 0.320000 1.500000 (150.139544) with transaction: 0.780000 0.020000 0.800000 ( 0.955037) edit2: Notice that the "real" time shows it took 150 seconds without the transaction block, and ~1 second with the transaction block.
Nice find. I've heard the win32 API may be of some use, but at my skill level I can't verify that without trying it out. Thanks for the help!
THIS. Start with this. If you're not doing this, it'll be a huge improvement.
Thanks, think I'll setup a transaction. This is a one time seed from a huge hash
Wow! This works great! Thanks for doing the benchmarks
Not a problem for me. This is just a demo app for a friend, so I don't need to change the DB/persistence engine. Mongo is awesome BTW
Just found this. Trying it out now.
upfloat for ffi. If you need speed, write it in C to begin with and use Ruby for the syntactic sugar / DSL stuff.
Looks interesting. Can you please explain some more use-cases? What do you mean by 'Profile different tags, commits, and branches against one another'? What does 'binding.pry' do?
im a noob can someone elaborate on this a little?
Thanks! You could probably use the win32 API. Portaudio actually uses that API so you could look at just maintaining the windows part of the binding. Would be easier and a bigger upside with potential cross-platform capabilities BTW, I moderate a subreddit [r/musicprogramming](http://www.reddit.com/r/musicprogramming) that you may want to keep an eye on. Ruby is well represented there...
ed is also a EDitor in unix. the pitch is that it is the only editor guaranteed to be on all unix boxes by default. 
So, why not use grit? and are you just shelling out to git?
You can do this anywhere in your code (not just in a cucumber step def). Though the method I use is "debugger;puts". I'm not sure if breakpoint and debugger are the same, but the ";puts" is the same as the "\n0" except that when you go to remove the debugger from your code, you know to remove the whole line.
I found out about Sinatra when I was reading up on Ruby on Rails. Decided to go with it and I'm happy I did. As a n00b, I'm quickly learning Ruby, Sinatra, HAML and SASS together. Not sure the right database yo use with it yet.
There's a benchmark example in the `examples/` directory: https://github.com/robgleeson/ed/blob/master/examples/benchmark.rb It should (I hope) give you some better ideas of what you can do :) 
Grit and Ed solve two different problems. Ed is more convient than Grit for the use cases it solves (it is designed specifically for a small range of use cases, and tailored to those). And Yes, it shells out to the git binary. 
My pre-commit hook is written in Ruby. I could see this being useful for that sort of thing. 
If I understand correctly you are going to have to get the record by it's ID which is most likely 1, something like. record = Modelname.get(1) record.update(:columnname =&gt; 'whatever you want the new value to be')
I just would like to store it in a variable, to use it later record = City.first .... then I have no idea how to find :url of that City instance its City.first.url..... god that was easy, glad it only took an hour to find it. FUCK
Yup that would be it. Glad you figured it out :)
From the binding class docs: Objects of class Binding encapsulate the execution context at some particular place in the code and retain this context for future use. The variables, methods, value of self, and possibly an iterator block that can be accessed in this context are all retained. Binding objects can be created using Kernel#binding, and are made available to the callback of Kernel#set_trace_func. These binding objects can be passed as the second argument of the Kernel#eval method, establishing an environment for the evaluation. --- So it's the execution context, pry is a tool REPL (Read–eval–print loop). It tries to be a powerful alternative to IRB. --- Calling `binding.pry` from would open an IRB-like shell so you can poke around.
You really don't need a Gem for this. Why not just use something like: sox -d --norm -t .wav - silence -l 1 0 1% 1 6.0 1% rate 16k | lame -V2 - out.mp3 (this would autodetect non-silence and start recording then) or arecord -q -d 3 -c 1 -f S16_LE -r 22050 -t wav | lame -V2 - out.mp3 (which would just record for 3 seconds right from the start) Sorry though if I gave you two reasons to abandon Windows and come to the dark side of Linux ;) PS: You can just use the system command or backticks in Ruby to call these up.
A brief introduction to the the Smalltalk programming language and environment to tantalize the Rubyist into checking out Pharo (a Smalltalk distribution). For more information, google "Pharo Smalltalk."
So then you could use record.url As the city.first has been stored in record. 
If you want to pop the occasional question, why not post to [StackOverflow](http://stackoverflow.com)? There are a lot of decent ruby devs around there - so you'll get a quicker (and maybe better) response there.
Why Skype? use IRC. There are a ton of Ruby support channels on freenode. 
I've loaded sqlite databases with 100,000,000 rows at least and it performed fine for analytical queries. If you're not versed in rdbms, using sqlite is going to be much easier. I am not saying that sqlite will scale as well as postgresql, but I would never suggest someone stop using sqlite unless they fully understand why one would need something like postgresql. Sqlite is an all around easy to use, extensible, solid tool. If you know its strengths and understand its limits, it will reward you.
"This is not true" is a statement, not a good argument. The only reason given in this post has to do with generating files. Okay, fair enough, but that that just leaves us with trade-offs either way, not a clear vision that generating gemspecs is better. In this long argument, there have been many reasons proferred for why using a non-generated gemspec is preferrable too (less confusing, more standard, fewer dependencies, have a gemspec in the repo that matches code at every commit, no way to forget to re-generate the gemspec when something changes). There is also a bit of misdirection in the post -- as far as I can tell, Gem::PackageTask does not generate a gemspec, it _uses_ a gemspec (whether generated or bare) to package the gem. That is not evidence that right from the start it was seen that generated gemspec files were the way to go, to the contrary, it shows that right from the start it was assumed that when packaging a gem (into the zipfile that is actually the package), a gemspec would already exist! 
I wouldn't do that. Storing in the "first" row of an rdbms is not really using the rdbms right. There's not neccesarily a guaranteed persistent 'default' ordering in an rdbms; now for a particular rdbms you're likely to get the same row back as "first", sure. But it's a weird way to use an rdbms, that will quite possibly give you trouble later, say when/if you migrate to a different db, or a different version of your app, or even just migrate your data to a different db instance. If there's a particular City you want, you should refer to it by some persistent id. I suppose that could be the pk, but better yet, retrieve it by a unique shortname you store, or something. 
I'm starting this today. After reading the "about", I found myself agreeing whole-heartily with the author. Looking forward to it!
He's still arguing for the same end result of a fat model, except organized by defining the business logic in one-off modules which are included in the model. I think that's actually fairly reasonable, as it separates data access from business logic, and organizes business logic into related chunks. Of course, it's also a specious argument, because it's not a different design, merely a different way of physically organizing code, while logically leaving the behavior in the same place. He might as well be telling you to put your public methods in one file and your private methods in another. It looks different, but it doesn't *change* anything.
Um, smalltalk is a computer programming language? It's got nothing to do with ruby, but this is a post explaining smalltalk targetted toward an audience of ruby programmers. Not sure what elaboration you need here. 
What's wrong with `method_missing` for `find_by_first_name_and_last_name` and the like in Rails?
Try finding where it is defined in the docs
 ri ActiveRecord::Base and I didn't even have to look very hard. Obviously, only by reading code and not docs, it's a bit trickier, so documenting hacks like this is particularly important. But in and of itself, especially from the API user's point of view, I like it very much.
the site seems down in the mean time though
Agree with you here, this hasn't been confusing to me ever and is documented everywhere. Seems like once you understand metaprogramming the patterns become more obvious -- though maybe for people new to Ruby this violates the 'least astonishment principle'. However looking at the function name itself it should be pretty obvious what it's doing.
Yeah, but if what you're looking for is `find_by_first_name_and_last_name`, you won't find any documentation for that. It's a method name that is composed for you through the magic of `method_missing`. Whenever I've used method_missing (and I use it *highly* sparingly), I've been careful to raise a NameError when method_missing actually missed, because silently consuming all missing methods is a terrible way of writing code.
Ruby, and it's popular web-based framework rails, would actually be a fairly good fit for a simple reporting solution based on existing data/tables/database. Some points: 1) Ruby, as a language, is a lot simpler and easier to read and write than C++. (Depending, of course, on a decent programmer doing the coding. It's possible to write bad code in any language, and unfortunately many do.) 2) You just need a little bit of ruby knowledge, to get started being productive in rails. 3) Rails, at an introductory level, through the use of scaffolds, allows you to very quickly create a simple UI for CRUD like functionality based on existing database/schemas. 4) Rails also has a lot free tutorials/screencasts, most of them free, thus enabling you to easily get started in a matter of minutes. 5) Rails is database-agnostic, and allows one to connect to existing db's across vendors. Whether you want to connect to sybase, oracle, sql server (whichever db you erp uses) it can connect without any change to your code. 6) Check out the following sites for more info: - [Practical_Reporting_Rails_Book](http://www.amazon.com/Practical-Reporting-Rails-Experts-Source/dp/1590599330) - [A_Decent_Free_Rails_Tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book) - [Railscasts](http://railscasts.com/) free and fairly decent screencasts - [Dynamic_Reports](http://dynamicreports.rubyforge.org/) - There's also plenty of free blog posts/magazine articles/screencasts on rails. Google it.
Seriously cant stand instance_eval. Nothing like taking a block from one scope then calling it INSIDE a call to instance eval. Im looking at you sunspot.
[dynamic finders](http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=dynamic+finders)
Oh, I see, where the *actual function* is documented. Yeah, nowhere - but it's such a self-evident naming convention that no-one should need any documentation for it for reading code. If you want to *write* ActiveRecord code, reading `ActiveRecord::Base` documentation should be a prerequisite. Also, I didn't think that raising an exception when method_missing can't parse was an issue. Is there seriously someone who isn't doing this? If it's going to be used, then it needs to be tight; if it's a one-shot, it doesn't need metaprogramming anyway.
CS code smell.
Why program when you can metaprogram? As my coworker says: &gt; If you can find who's calling the method, or where the method being called is defined, you're not programming hard enough.
Your english could use some help. Happy to proofread it if you want assistance!
reminds me of perl golf. Neat stuff
Nice DSL, my personal preference would've been to make the yielded 'repo' argument in the blocks implicit by instance_eval'ing the block in the context of the repository.
Now find where it's actually implemented in source, if there's something about it that doesn't seem to be working right, and you want to actually read the source. Now it is in the source somewhere, and you may very well reply and tell me where. Doesn't change the fact that it's harder to find both code and source using tricks like this. But sometimes it's worth it. Personally, I'm not a fan of the AR magic finders and dont' feel they are worth it, especially with 'ordinary' find syntax being so much cleaner in Rails3. But opinions will differ. 
Cairo is a C library, as far as I can tell? Perhaps there simply is no mature supported gem for using cairo in ruby. Your question is not entirely clear on what you're looking for documentation on. For a C library to be used in ruby, someone has to have written a gem with C bindings to do so (and released it to you for free). This hasn't always happened. In which case, you aren't going to find documentation on something that doesn't exist. 
Every language has somewhat-obscure idioms that are much easier to sort out socially than via documentation. Frankly, I have no idea how the dynamic finder concept could be presented so as to be searchable in the way you prefer. What Google terms do you think should bring up the docs?
[Ruby bindings do exist.](http://cairographics.org/rcairo/) Documentation on it seems sparse though. Besides, the OP linked to the Ruby bindings, albeit with the documentation in Japanese.
I don't have much experience with Cairo, but I've encountered a disturbing lack of documentation in other bindings, such as Tk. At that point, it's usually a matter of looking at [the documentation for the source library](http://cairographics.org/documentation/) and [the source code for the Ruby bindings](https://github.com/rcairo/rcairo). It may also help to look at [documentation for the bindings to other languages](http://cairographics.org/documentation/pycairo/3/reference/index.html).
I think I found that last link. I just don't get why I should look at python documentation, which looks much like the ruby counterparts, to find ruby documentation. I might just be used to the good documentation that follows most ruby bindings. 
Yeah, the documentation sucks. I'm pretty sure the methods are the same in Ruby as they are in C, except rather than `cairo_whatever(ctx, blarg)` it'd be `ctx.whatever(blarg)`... [Here's what I did find](http://cairo.rubyforge.org/doc/en/). The best way to figure out where to get started is looking at examples, it seems. If you just wanna play with drawing stuffs in a window, check out [Shoes](http://shoesrb.com/).
I'm not trying to justify anything; after all, I'm not the one who made the bindings. That said, Ruby/Tk is (used to be?) egregious about its lack of good documentation, even though Tcl/Tk is exceptionally well-documented. Similarly, [Ruby-GNOME2](http://ruby-gnome2.sourceforge.jp/hiki.cgi?Ruby-GNOME2+API+Reference) has great documentation *if* you're familiar with Gtk et al., which if you're not, will require you to explore the main documentation of the C library (or at least tutorials for things like PyGtk). So I would say this type of documentation is not unheard of in the Ruby community, but I'd wager that's because these bindings are so desktop-oriented, as opposed to web-oriented.
I don't know of any way to make the dynamic finder stuff more findable in docs or source. Rather, I think the difficulty of findability of dynamic stuff like this is one (of several) reasons to avoid using method_missing unless you really have to. That's the point. 
What about [http://cairo.rubyforge.org/doc/en/](http://cairo.rubyforge.org/doc/en/)
How about the English version of what you've been translating? http://cairo.rubyforge.org/doc/en/
I agree with the comment on that blog, what's wrong with simply: block_run = false meth { block_run = true } block_run.should == true The primary solution on that blog post seems way overengineered
if you don't accept the yielded 'repo' argument, it will use instance_eval in the context of Ed::Context, so you can have the best of both worlds (instance_eval, or retain the calling scope - it depends if you accept a yielded param or not). 
Interesting idea, but, eh. There's better ways imo to deal with the "we don't want it to be a full blown project" issue. First would be to publish a repo without packaging a gem (at least publicly). Another would be language in the summary or readme. While it would lose out on the "goodwill" aspect, I'd even advocate private gem servers over this. Also, a gist doesn't give you full git access. Last I tried, you can't clone a gist repo, add a file, and push back; you'll get a permissions error. That's a pretty bad smell. I think the idea of microlibraries is great, but don't sacrifice good tech to get them.
Wow, this is fantastic. Thanks!
I'm sorry if I made it feel like it was against you, I'm just a bit frustrated by the thing. But you seem to know pretty good what you are saying. Thanks for the help anyway :)
Hehe, look at it and compare it to the japanese ;)
Hehe, look at it and compare it to the japanese ;)
The first link is just the english version, and that's pretty bad compared to the bad japanese translation. I'll try looking a shoes :)
Nice, if a bit silly. It's basically a demonstration of the untyped lambda calculus, but then in Ruby. The [epilogue](http://experthuman.com/programming-with-nothing#epilogue) will send you to the interesting stuff.
I've had to work with a domain-specific language written for a misunderstood domain, and it was painful. A lot of time is spent wrestling with the DSL 'framework' rather than writing code to actually support what the business wants. For political reasons, it can't just be tossed away. Not really an indictment of metaprogramming, just one case where I've seen a use of metaprogramming be a net-negative.
It reminds me, painfully, of the existence of -&gt; as a lambda operator. Gleesh. Makes code unreadable unless you're a savant in that language. 
I agree. Ruby is headed towards a pretty terse future ;)
This is an incredibly inspiring article. I feel like if I stepped through the entire process of writing this script it would reinvent me as a programmer. Should probably get to it... 
blech. I guess there's no rule saying you have to use it. If I wanted weird domain-specific decoration, I would have stuck with Perl.
To be fair, lambda / proc is also pretty ambiguous to any new programmer. The knowledge of what a lambda signifies is specific to users with existing familiarity with patterns. So, if the idea is that -&gt; is less clear or more confusing, I kind of disagree, in that it establishes the pattern as anchored to a symbolic reference.
And pulled down just as fast.
I like how the very first thing is DON'T REPUBLISH THIS!!!!!!!!
Are there any in particular you'd recommend? I'd like to chat with more ruby devs too.
I agree that this is more of a quick hack. I tried a git clone and git push on a gist and it worked fine for me. Did you push to your read-only gist url instead of the private read-write git url on accident?
I would suggest using s3 for storing the files, instead of storing them locally. Then you can use Heroku and not worry about administrating the server. Have never used it, but the [Redmine s3](https://github.com/tigrish/redmine_s3) plugin looks like it does what you want.
About damn time. Although I'm worried that I'm *so* in love with TextMate as it is, that if the changes are really sweeping, I won't like it. I'm just too used to how things are. But then I saw that grouping folders at the top of a project is now an option, and I'm in. 
Aha you may be right! I seem to recall just copying the private clone url. I'll try again later. Thanks. EDIT: Huh, maybe it was a fluke that day, because the private clone url is the right one. Good to know for working with gists, but I'll stick to github proper.
Haha, yeah... I was conflicted in posting. I've already seen it all over the internets, so I figured I wasn't being too evil by posting it. It makes me wonder if the big warning message at the top was reverse psychology...
It's still up for me, but here's the a mirror: [download](http://ge.tt/9iWZ19B?c).
Hmm, all I know is I saw [Alpha pulled](http://old.nabble.com/Alpha-pulled-td32963482.html) too.
I love how this is in the Ruby subreddit.
Try again, I got to it ok
To be fair, it was posted &gt; Dec 12, 2011; 04:59am ... and it also says &gt; We’re planning to release the alpha preview tomorrow. So, its probably ok.
[Ah, and it's officially on their blog now too](http://blog.macromates.com/2011/textmate-2-0-alpha/). 
\*faints\*
The changes definitely aren't sweeping so you'll be good.
sadly as I mentioned int he original post the redmine s3 plugin is pretty out of date and i've already spent a few hours trying to get it work on heroku with our vers. of redmine. Not worth rewriting the plugin if we don't have too...
It's probably just getting hammered, it downloaded for me after a 45 second lag.
Six months ago I would never have imagined I would be saying this, but: I'm sticking with Sublime Text 2 for now. Sure, it's a preview release, but it's painfully apparent that TM 2.0 will have a lot of catching up to do.
Gem::PackageTask is the correct way to write `gem build blah.gemspec` and the correct way to package gems from rake, not `task :build do system "gem build blah.gemspec" end` If your gem has files that are generated how do they get into your gemspec? Magic? No! You generate a complete gemspec from an incomplete template programmatically then package the gem. This is how it worked from the beginning. Please, go check the original "how to make a gem" emails to the ruby-talk mailing list if you have a doubt about this.
Anybody got a mirror for the official release?
No autocompletion?
Have been thinking about picking up TM for a while. How does their licensing work? Does a major release require a new license?
The v2 branch should be codenamed "Duke Nukem Forever".
Oh, I didn't feel that way. I understand how frustrating it is, and I hated to be the bearer of bad news, but I couldn't do anything. Like I said, I know the frustration from back in the day, when I didn't even know very much about programming, exacerbating the difficulty. Back then, there was no Github (no git at all) and no Rails, so the English-speaking world hadn't grabbed onto Ruby to a huge degree. It was a huge pain, but we make it through. What you can consider is to figure out the bindings, then contribute your findings in the form of documentation to the rcairo maintainers. That way, many people can be benefited.
Check their blog, there is a newer build that is now officially released.
http://blog.macromates.com/2011/textmate-2-0-alpha/ Newer (8930) build than the leaked preview (8926).
I saw the slides for this a while ago; incredibly cool stuff. I had loads of fun going through the GitHub repo, too.
The documentation for Cairo itself is pretty shoddy unfortunately. Be prepared to dig through source code. Perhaps search github for code that uses it for examples. Also, the Ruby Cairo bindings follows the C API very closely, so read the (slightly better) C documentation. 
Odds are pretty good you are a recruiter. If by some miracle you aren't a recruiter I have bad news for you: you sound exactly like one. On the off chance you aren't here are some tips: * No one who knows what they are doing is going to respond to a bulleted list. Its really boring and reminds us of filing out forms at HR. * For almost everyone, the demands on our time far outstrips the amount we have available. Tell us why it would be super awesome to work with you instead of picking up a different project. * At least mention specifics about money. Too many people try and talk us into working for free.
Not sure if I might give TM2 a chance anymore. I'm too far down the Sublime Text route to turn back...
Auto-completion is a complicated. It can never introspect into your application correctly, or it blatantly makes your editor bloated like (rubymine/eclipse). Generally a few doc pages open solves the problem.
The author originally said a TM1 license would be good for TM2, though he has since said he regretted it, and some folks are trying to convince him to withdraw the free-update offer. [source](http://www.marco.org/2011/09/27/textmate-2-free-upgrade)
Thank you for the advice, but I'm not a recruiter. I simply know what I need. Money depends on the skills they bring to the table. If they can do everything they there is a lot more to be had and equity. Trust me, it would be impossible for anyone to talk someone into doing what I need for free. You'll be working for 1-2months. 
Guessed wrong :( We already have 2 programmers. Looking for a 3rd one who can jump right in. 
I have some news for you. You have become jaded by recruiters. You should practice more positive thinking. 
Eclipse might be bloated, but it is really fucking good at what it does.
You are not alone. Sublime Text has felt like TM on steroids. 
Nice find! I'm a complete beginner and it's helping me understand the concept behind Sinatra.
[download](http://www.sublimetext.com/blog/articles/sublime-text-2-beta)
I was actually thinking about that. It's properly only a handful of methods I'll use, but it's a start of some documentation, and could maybe help some people.
What does this have to do with Ruby?
Rails, flash and java? Sounds fun!
It's ridiculous, and most ruby people I know (including myself) use Vim. I'd love to give it a try just for funsies though, I remember textmate 1 being pretty, although I probably wouldn't use it on my day to day work.
Okay... no, it's REALLY pretty, but I can't use it, it just doesn't do what I need it to do.
yea you might think that but the intention is not to have a golfing focus but to promote simple/elegant/minimal solutions to problems. so short code: yes, save every character possible: NO! although we sometimes have golfing posts and as long as they don't take over the subreddit I'll let them live ;)
I like the context sensitivity and the functionality around scopes. You can also add your own functionality, although probably not quite as much as with Vim. Meanwhile, I can scrape by in a Vim editor but I won't enjoy it :) Modal editors give me a headache (and bad memories of old software like pfs:write from the 80's on commodore 64's) I'm a Rails guy if it matters.
Well, I totally get you because even though I use Vim now and I invested a lot of time getting used to it I also want to learn Emacs and I hate having to spend 3+ months getting used to it and suffering in the process. Textmate works, and it's pretty, and somewhat programmable, it's a good code editor, I just got too used to working in vim now.
A lot of people are mentioning other editors (vim and Sublime Text, mostly) with the point that TextMate isn't enough. Can all of you mention a few specific points? I'm a TM user, and I would hate to think that I'm cutting myself short on tools. My only real complaint with TM is not being able to have split views. 
What's the deadline for CFPs? 
If you don't release your library as a gem how do I know you won't randomly break it with a future commit? If you use a good build tool like hoe you can eliminate the majority of your pain points. You can also pass the gem off to the first person who files a pull request for permanent maintenance.
There's are already two gems named rabbit: http://rubygems.org/gems/rabbit (presentation app) http://rubygems.org/gems/rabbit-tools (RabbitMQ tools)
Cool, cheers
I submitted one a few hours ago, my first Serious conference submission :)
Unfortunately, it wont run on Linux.
Ed is the [standard text editor](https://www.gnu.org/fun/jokes/ed.msg.html)!
Asking these sort of questions on a forum usually makes old guard programmers upset. However, I've asked my share of questions in the past so I'll help as much as I can. There seems to be a general consensus among Ruby web developers that if you want your web framework to be adopted by a decently sized audience you configure it to work with Rack. This benefits the community because there are so many Rack middlewares out there. Having Rack as a common touch stone of Ruby web frameworks allows little frameworks like Sinatra or Bats to sit on the shoulders of a larger developer community. Rack is a middleware layer, it allows you to define functions which will be called during the parsing of an HTTP request. Thin and Mongrel are webservers for Ruby. Mongrel is bulky, poorly maintained, and unoptimized use Thin. Rails uses Mongrel by default last I checked but can be configured to use just about anything.
* Rack: a web layer for Ruby, it sits between HTTP servers and your applications and handles most of the dirty work such as parsing HTTP headers, cookies, etc. Website: http://rack.rubyforge.org/ * Sinatra: a micro framework built on top of Rack. Website: http://www.sinatrarb.com/ * Thin, Unicorn, Mongrel, etc: HTTP servers that listen to a IP address and port or a (Unix) socket and pass all incoming requests to your application. In a typical application you'd end up with the following "flow" for each HTTP request: Client -&gt; Nginx/Apache/etc (not required but recommended) -&gt; HTTP server (Unicorn, Thin, etc) -&gt; Rack -&gt; Ruby application (e.g. Sinatra) Rack is required because, as mentioned before, it is used for all the dirty work. Without Rack every application/framework would have to do this itself which would require a lot of time and effort. Sinatra (or other frameworks) generally make it easier to work with Rack by providing easy ways of binding certain methods or blocks to certain URLs.
Rack also provides one API that servers and frameworks can use, and they all interpolate. Every server can be used by every framework.
Rack also provides one API for both sides of the server/framework divide to implement, so they can all work with each other.
Rack is a convention, or specification, that lets web applications "plug" into a common interface for handling HTTP requests. Did you ever learn or hear about CGI? CGI is the old Unix way of executing code via a web server. As it turns out, Rack is nothing but a slightly more rubyesque version of CGI. To actually serve requests, you need a *web server* — something that can translate HTTP requests into Ruby calls. Thin and Mongrel are web servers that do this. Sinatra is a web application framework which happens to rely on Rack. Sinatra does not have a web server — it relies on Thin etc. to handle this stuff. --- **In a nutshell…** So what is Rack, exactly? Well, it's actually very little. Mostly it's a specification on how the various parts of a web stack talk to each other using Ruby. A "Rack handler" is simply a class which implements this: def call(env) return [status, headers, body] end That's it. A Rack-compatible web server will take an HTTP request, build a hash containing request metadata (the `env` bit), and call that method with it. The method is expected to return a three-element array containing the response. As you can see, Rack is essentially just glue. --- **The rackup file** When you run a Sinatra app directly, by letting it set up a port and so on, that's actually the "old way"; Sinatra has a built-in web server thingy (I forget the details), and that's why it works. The preferred way these days is to use Rack in conjunction with a so-called "rackup" file. Let's say you have a Sinatra app, with a main class called `MyApplication` which extends `Sinatra::Base`. Now create a rackup file in the root of your project, call it `config.ru`, and put this in it: $:.unshift(File.expand_path('..', __FILE__)) run MyApplication Now you can run your app with: thin -p 3000 -R config.ru start Thin will start, then execute the rackup file, which essentially configures Rack for your app. The `run` bit essentially tells Thin what implements the application proper. --- **The Rack stack** It gets more interesting than that. Rack is designed to be *layered*. Whatever implements `call` doesn't need to be a whole web app. It can be just a middleman; for example, a filter that compresses the output of the HTTP response, but doesn't care about anything else. How? Through chaining. To illustrate the power of Rack handlers, here's the rackup file with a filter added that will uppercase all output from the web app: $:.unshift(File.expand_path('..', __FILE__)) class Uppercase def initialize(app) @app = app end def call(env) status, headers, body = @app.call(env) out = '' body.each do |part| out &lt;&lt; part.upcase end [status, headers, out] end end use Uppercase run MyApplication The `use` statement here will tell the Rack system to chain `Uppercase` into the stack of handlers. It will be initialized with the next handler in the chain as an argument. Rack handlers are often called "middleware" for this reason. Rack has a bunch of pre-built handlers you will want to check out. Rails also comes with a bunch of them. --- **And incidentally…** Since Rack handlers is just `call(env)`, you can use Ruby blocks (aka lambdas, or proc objects) as Rack handlers. This is a complete, perfectly valid rackup file: run proc { |env| [200, {}, 'reddit'] } If you run this with Thin, every request will return 200 and the word "reddit" in the body. --- As you can see, Rack is very low-level. You can implement a whole web app as a Rack app, but it's very crude, and designed not be interacted with directly. That's what you have frameworks like Sinatra and Rails for.
Hmm, the only weird part to me of this is that you have nginx/apache AND Unicorn/Thin/Etc in there. Isn't apache _already_ an HTTP server? I usually use apache, and do NOT use Unicorn/Thin. I thought they were alternatives, I didn't realize some people used em together? Oh shit, and this also leaves out passenger. I usually use apache+passenger. I think nginx+passenger is another option? If you are using unicorn/thin, do you not need passenger? Are unicorn/thin sort of alternatives to the passenger layer? I'm realizing I'm confused about this stuff too, even though I've been deploying rails apps for a few years, I know exactly what I do, but don't really understand all the options either!
Rails actually uses it's own built-in WEBrick by default, but not recommended for production deployment. It doesn't really use anything by default for production deployment. I think. (If you HAVE the mongrel gem installed, Rails might use it auto instead of mongrel, but presumably in Rails 3 it would need to be in your Gemfile too, not just installed in the system, making it harder to 'accidentally' use.)
WEBrick is built into the Ruby standard library, not Rails.
Passenger is a apache/nginx plugin that's basically a process manager/proxy. It takes requests from your server and will spin up a backend process to handle your request (if one is not already running) and then forward the request to that process. 
The way it works is you have an application server (thin/passenger/unicorn/mongrel) are all application servers, these load your ruby (or rails) application code, and respond to web requests. You *could* run on just these alone, binding them to port 80, but it's bad practice because it's expensive (memory wise) to run many instances to handle all the requests, especially for static assets such as images/css/javascript, as any server/worker/thread (depending on the model the app server uses) that is serving those assets is blocked from responding to a dynamic application page request which is what it's meant to be doing. So that's why a web front end such as nginx/apache etc is used in front of this, and is configured to handle static files (from your public directory), and pass on any requests for dynamic content (anything not in the filesystem) to your application server. passenger is tightly coupled to apache/nginx which allows it to spin up &amp; down the number of passenger instances it has, which is nice, in that setup apache/nginx is acting as your front end, and passenger (which is run as a child process of apache/nginx) is your application server.
I think right now it's webrick unless you uncomment the unicorn gem in the gemfile. 
rails can use any rack compatible application server. Ruby application servers generally all implement the rack format, in which rack handles parsing the http request &amp; headers, and the framework (eg. rails), and the webserver e.g (mongrel/thin/passenger) only have to treat responses as a three part array of: response code, body, and a headers hash. Rack takes care of the rest
Emacs is better. Just saying.
Actually, it has a lot to do with Ruby. Quite a large portion of Ruby was influenced by Smalltalk, and Smalltalk is a pure object-oriented language in a similar style to Ruby.
Thanks, this explained it. So, if I understand right, you have: * a web server (apache or nginx) * an application server (thin, passenger, unicorn, or mongrel) * and your actual application (in ruby, sinatra, or anything else that uses the Rack standard will work with the above). It's not _entirely_ clear to me what the application server is for. I understand what passenger does that the application alone does not (and it wouldn't make sense to) -- mainly, it spins up extra application processes when needed for traffic, spins em down again when idle, according to your config. But I understand that the other application servers don't neccesarily do that... so what the heck _do_ they do that your application can't do for itself? Ah, just provide the Rack-compliant interface HTTP and ruby? If that's it, why do you need a seperate layer to do that, why wouldn't that just be built into sinatra or rails or anything else using rack gem? So there must be something else I'm missing?
Awesome, this looks really promising. I like how it's already been tested to work on multiple implementations and it is also incredibly well documented. Will be using this a lot.
Yes, that's right. &gt; It's not entirely clear to me what the application server is for They actually run your application. Without one, you'd just have apache and some ruby files on a filesystem. When you type `rails server`, you're starting up a ruby application server, be that the ruby lib built in webrick (okay for dev mode, not for deploying to production), or one of the alternatives listed above. Your rails code knows how to take rack input, but not how to bind to a socket or port (80), it leaves that up to the application server, which is a good way for things to work. Rails can focus on a nice MVC way to generate database backed html pages, and the application server takes care of handling http requests (by parsing with rack) in an efficient manner and keeping a robust process running without leaking memory etc. I know when you look at it this way you may be thinking the application server doesn't do that because that's stuff you expect to "just work" (TM), but underneath that magic there's actually work that does need doing, and is a complicated problem domain
This is a great explanation. Well said sir. 
Cool, thanks. It _seems_ like the application server is doing so little, why wouldn't that just be built-in to the framework, or an extra gem or something that gets used by the framework... but it's probably not easy/simple as it seems, thus how it is. Okay, good, thanks! 
IMO you don't need to stick Apache or nginx in front of the "app server" unless you want to use it as a load balancer. In which case you should use nginx or HAProxy. Using Apache only as a LB seems weird to me.
It's worth pointing out that rack isn't the only game in town. There's webmachine-ruby, as well. 
In the case of thin, mongrel and webrick it is just actually an extra gem. The other application servers like passenger and unicorn require complex interaction with either the http servers (nginx/apache), and/or the ability to start an entire process and create child processes.
Both Apache and Nginx are much faster at serving static content than ruby or any of the application servers. They also know how to handle caching and are good at allowing concurrent file downloads while still taking in traffic and passing it to the application servers. It really makes way more sense. :-\
thanks! this has been very helpful for my understanding of what's going on, and i'm not even the OP. 
This looks really cool, and might be something to actually get me to make the leap from Java to the alien feeling Ruby.
The DSL syntax looks very similar to Rake [file](http://rake.rubyforge.org/files/lib/rake_rb.html#M000002) / [directory](http://rake.rubyforge.org/files/lib/rake_rb.html#M000004) tasks. Could I use Vendorer in a `Rakefile` instead? I dislike these `Filename` files cluttering up my projects.
many thanks!
If you look at [line 218](https://github.com/ruby/ruby/blob/trunk/ext/openssl/ossl_cipher.c#L218), you will find that this has been deprecated a long time ago and is not used any longer under normal circumstances. To execute this code path, you have to pass parameters to Cipher#encrypt/decrypt, a feature that's not even documented. We decided to keep this for backwards compatibility reasons (and the "Ruby rulez" part is not interoperable with other implementations). Currently the "default IV" being used is an all zeroes IV (see https://gist.github.com/1480700), which is also not ideal, but note that this default is actually OpenSSL's default and it needs to be kept for the same reason of backwards compatibility. However, I'm aware that the documentation could be more explicit on these matters and also actively guide users in their choices. I will update it soon. Please have a look at your Cipher code, and see whether you set an IV explicitly or not. You should always set an IV explicitly, because you should always use a mode that is different from ECB. There is almost no legitimate use for ECB in symmetric cryptography, so you should consider changing if your code does nonetheless. Using #random_iv as shown in the OP's post is a secure way of choosing your IV. Note that once chosen, the IV can be safely transmitted to the receiver in public - it is not secret information, it should just stay unpredictable. Unfortunately, for now, we need to keep these parts in the code to allow "legacy applications" to interact with actually insecure software. If we were to remove those parts, these apps would no longer be able to do so and break. We consider our choice the lesser of two evils, and will actively endorse secure usage patterns by updating and clarifying the documentation.
To be precise, this is sinatra-rabbit. No idea why the name is rabbit though.
I'm going to be doing something soon about "reading" Java for Rubyists, but perhaps I should also investigate the other way around. I've been porting quite a bit of Java code lately so am becoming aware of some of the parallels.. and areas where there isn't quite an exact match :-) (e.g. abstract classes and interfaces)
I get the Rack/Sinatra dynamic, but what specifically do Thin et al do that Sinatra does not?
Sure, and rack is certainly not perfect, as we're seeing with the Rails situation.
Thin is a web server, Sinatra is a web framework. Phrased another way: &gt; what specifically does Apache do that Rails does not?
I guess the largest difference is that Apache does the low-level socket and buffer work. Is it like Thin is the server, Sinatra is the routing logic, and Rack is the glue?
 request -&gt; {nginx,apache} -&gt; Thin -&gt; rack -&gt; Sinatra -&gt; your app Your statement is pretty close, sinatra is a bit more then just routing, though ;)
You mean `Filefile`s?
Oh no, I didn't mean to marginalize Sinatra! :) Got it, now, thanks.
don't expect formtastic-bootstrap to automagically transform your existing formtastic views to proper boostrap-based html, it's actually a new FormGenerator with his own dsl, so it will break existing forms.
I don't get it, why did they name it -&gt; x {x +1} if x -&gt; {x +1} is better readable and makes more sense (for me ;). Lexing, parsing issues?
Ya. It looks like it's been deprecated [since at least 2004](https://github.com/ruby/ruby/commit/0dc43217). Probably needs better docs and for more people to run ruby with -w, otherwise the [rb_warn](https://github.com/ruby/ruby/blob/trunk/ext/openssl/ossl_cipher.c#L212-217) will not show up. Edit: In fact, I don't think the code path shown in this article will actually touch the "Ruby rulez" part. You have to call the `encrypt` method with an argument in order to hit the warning. Here is the original code from the article which produces no warnings: require 'openssl' @cipher = OpenSSL::Cipher.new('aes-256-cbc') @cipher.encrypt @cipher.key = @cipher.random_key @cipher.iv = @cipher.random_iv # bye bye "OpenSSL for Ruby rulez!" @cipher.update("I'm gonna be encrypted") output = @cipher.final My updated version that actually hits the `rb_scan_args` code path: require 'openssl' @cipher = OpenSSL::Cipher.new('aes-256-cbc') @cipher.encrypt 'foo' @cipher.key = @cipher.random_key @cipher.iv = @cipher.random_iv # bye bye "OpenSSL for Ruby rulez!" @cipher.update("I'm gonna be encrypted") output = @cipher.final 
Ed doesn't install any executables so I don't see this as being confusing, plus naming things is hard ;-) 
Thanks for the positive feedback! Comments like that, and knowing it is useful to people out there, makes all the work worth it :) 
Everything that speeds up railsboot is good in my book 
Yes! very helpful. Thanks for all the wonderful replies. I havent posted much cause I've been trying to research what the hell each little piece does.
This reads like a "how to make money in real estate" add.
A week after I switch to VIM from TextMate the version 2 finally gets out? &gt;.&lt;
Looks promising.
Why even post something like this? **:|**
Beautiful dog!
Do programmers have no sense of humour? It is adorable and funny.
I was hoping for a sexy girl called Zoe. I'm a fool.
2 years ago this may have been a nice change, but after The Great Influx of 2010 programming reddits are some of the few un-fucked reddits we have left. Meme pictures taking over all of reddit have made some of us bitter. It's not that we don't have a sense of humour, our sense of humour is just assaulted on all fronts these days. I don't always want to see cute pictures of animals. No matter how cute.
This does indeed sound serious. Maybe I never see the influx of images because they are all downvoted. keep up the good work
Do you not have res or thumbs enabled?
I wrote it so that the perspective could be understood in that I described the problem and then the solution but I certainly didn't intend for you to see it like an ad from a huckster.
That's one smart looking dog. I'm sure she'd do great in client-facing situations. Two questions: does she have any experience with TDD? And, what's her hourly rate for spec work?
Thanks. I've been putting a lot of research into it and have used the concepts on several of my projects.
I agree with the other comments. PM some additional info and I might be interested in talking. I know how hard it is to find Rails dev help these days. Good luck!
It just occured to me that a comparison to PHP is useful, precisely because there are (as far as I know) fewer choices in php. Web Server: * PHP: almost always (always?) apache * Ruby: apache , nginx (others?) App Server: * PHP: `mod_php` does this * Ruby: passenger, unicorn, thin, or mongrel _Framework_ for providing app functionality within your app * PHP, often none, but there are some options, like Zend or CakePHP, as well as many other contenders. * Ruby: often Rails or Sinatra, but you can get close to 'none' by using nothing more than Rack, as an interface to the 'application server' above. I _think_ I have this mostly right, heh. Part of what makes things so confusing, is ruby gives you so many choices, and the ruby community tries to abstract everything out to make it possible to mix and match so many choices. What 'rack' does is kind of built into `mod_php` from the start, but the way `mod_php` does it is somewhat less flexible; in ruby it's abstracted out into Rack (a specification _and_ a gem that implements the specification that anyone can re-use), which then different app servers can use. You could try to compare to Java too, but that starts to confuse me too. I guess J2EE kind of fills the role of 'rack', but with many many more features, as opposed to rack's bare-minimum-other-people-build-on-top-however-you-want approach. Tomcat or Jetty fill the 'app server' role of unicorn, thin, mongrel, passenger. 
That's a good point. We don't want to set a precedent that this is acceptable behavior. Otherwise, it won't just be one picture this one time - it will turn in to ten pictures a day of cute animals looking like they are coding. Keep it in r/aww.
Yeah this seems more the type of thing to put in r/pics or r/funny.
Great... YAXF. Yet Another "X"file
In ruby community you don't find job, job find you
Well, if nothing else, the Ruby (and Rails) community is continually coming up with new things so there's never a shortage of things to learn. I came to ruby from a Python and C background. There's a certain amount of circle-jerk that goes on in the community that you'll need to look past. A lot of people out there are doing cool things and they're fun to learn. Also, if you put 'Ruby(on Rails)' on a linked in page, the recruiters come running en masse. ;)
As someone who recently switched to Ruby/Rails from .NET this year, I can tell you to run to this opportunity! You are basically going to get on the job training and experience without making a leap of faith to a new employer. My switch was the best career move that I have ever made. The amount of recruiter calls that I get now is ridiculous. It comes down to, where do you see yourself in 3-5 years? Working on C/C++ or getting more on the cutting edge.
The part I love about using Ruby (and Rails) is the immediate satisfaction I get with making something awesome with very little energy. Don't think of this as being lazy but being super efficient. The language was created to be elegant and simple so you can focus on the fun stuff of solving problems and creating neat stuff. Going from c/c++ to Ruby you are either going to be doing web applications or back end, both have a lot of neat libraries available. Unlike the c/c++ community that doesn't always accept libraries Ruby encourages it, embrace it if you can.
I'm a rubyist and I love it. you can never know/learn enough so definitely try ruby out. Playing devil's advocate here: C++ seems like it might be very lucrative soon because so many people are moving into the more dynamic languages. Do you have any idea how much a COBOL programmer makes?!
He could always do Ruby for fun and then go back to C++ when it gets more lucrative
https://twitter.com/#!/devops_borat
I use both, but Ruby is nearly infinitely more pleasant to write and maintain.
I made the same move several years ago, from C/C++ etc. to Ruby work. Best career move I ever made. And while I have tons of respect for the people in the C++ community, Ruby has a far more active and vibrant user/OSS community. Which makes programming Ruby for a living not only lucrative, but a lot more fun and fulfilling than C++ work.
A few reasons: * Very productive language. * Much more fun to code in than, say, C++. * Great community that pursues code as craft. * High demand for Ruby developers. * Performing web development is ~~dominated~~ great with Ruby on Rails. And web development is here to stay.
Jim Gay ಠ_ಠ
As for the future of Ruby, Salesforce just bought heroku (a rails cloud hosting provider), and is now employing the creator of Ruby, Matz, to take the language to the next level. Salesforce has said that ruby is the "language of the cloud" (i know, I hate the term cloud too). So I think with its newish corporate backing, you can be safe to invest your future in it.
Name a language that is (more) pleasant to maintain please. . . 
What do you want to do with your career? Ruby is most commonly used these days for web development. I'm sure it's used in other capacities, but the fact of the matter is that if you're a Ruby developer, your career is going to take a very web-oriented direction. If that's what you want, then Ruby's a great choice. There are more Ruby web development jobs than there are good Ruby developers to fill them right now. Coming from C/C++ is going to be great, because you'll be able to avoid many of the programming pitfalls that people who learn on garbage-collected loosely-typed languages learn, and you'll be able to appreciate the power that Ruby gives you.
More pleasant than which?
I'm a recent graduate who self-taught ruby and Rails - I've always been in well paying work in London and the UK - going to start my own thing soon. The Ruby community is refreshing when compared to PHP specifically - Ruby has a real emphasis on code beauty, reuse and pragmatism and these lend really well to programmer happiness. Recruiters are *constantly* ringing me up asking me if I want to earn £300-£350 A FUCKING DAY. When that first happened, I was speechless - now I kinda avoid the calls, he he. Ruby is quite young but already well sought after language and career choice, I wish you the best!
&gt; plus naming things is hard ;-) Brother, I feel your pain.
Consider giving us some example or really any indication you actually have written a decent book so you won't look like you're trying to gather email addresses like plenty of the all-famous 'how to make money selling ebooks'-ebooks sites do.
I'd say it's going to be the language of sysadmins too. It's great for scripting. Take Chef/Puppet for example
I'm working on it. I'll have a sample except from the book up soon.
Really? No help? :/
Cumulative patch https://gist.github.com/1484985
not enough?
As a ruby/rails dev I think you are exaggerating rails dominance. I find clients regularly asking for php because it's something their own IT guys are familiar with and want to maintain. 
Heroku is great, but pricey. I do love them though because their support is speedy and friendly. In one case I was chatting with the agent and he encouraged me to restructure my app to more heavily use background dyne processes to abstract a slow bit of code. This had a HUGE impact on the performance of the app,now I benchmark everything - not just bits I think would be slow,
I spent the last year teaching myself Ruby and Rails from scratch coming from a totally unrelated industry (literally zero programming experience). Now I am employed full-time in a badass salaried job doing interesting things with Ruby and Rails. I would argue that I can do it, anyone can.
You have a very valid point. I was thinking about your typical Silicon Valley startup, but even there PHP is still very common. FWIW, I noticed that PHP positions tend to be paid less than Rails ones, if this is something that may interest the OP.
I wish I could help you. Is there no way you could install it system wide?
You could consider setting a symbolic link to the libgdm.la in /usr/lib64 so the buildscript will find it for sure?
Why?
Do you have sudo and/or yum? If so: sudo yum install libgdm Also you may want to see if there's a corresponding devel package: sudo yum install libgdm-devel 
you might have more luck at r/rails, but I'm not too sure what the activity is like over there. I've been there before, where people say "just build something" but you can't think of anything. I tend to just pick up on ideas every so often when I'm wondering around. Stuff like "Secret santa is a pain, I wonder if I could make a solution that would make it easy to discuss gift ideas and get suggestions from the giftee anonymously" or "I wish there was a simple way to fork guides on solomid.net" and so on... Find a silly itch some website you use has, and scratch that itch. Failing that, build a todo-list app or yet-another-blog-engine. J
Hmm does this work with tables that don't have serial primary keys? Like UUIDs for example.
Thanks! /r/rails is pretty dead though, that's why I posted her :p
a hunch: in your .bash_profile: export LDFLAGS="-L${HOME}/opt/lib $LDFLAGS" export CFLAGS="-I${HOME}/opt/include $CFLAGS" when compiling libgdbm ./configure --prefix=$HOME/opt (TOTAL GUESS) add -- --with-gdbm=$HOME/opt (or something) to the gem install command?
I see. The gem you're installing uses native bindings to C. There is a similar memcache client gem that is pure Ruby, in other words it doesn't use native bindings. The gem is by Mike Perham who's a great Ruby developer and has worked with memcache and Ruby for years. Can you try this one? https://github.com/mperham/dalli 
What's wrong with paginate?
Is she available? Groupon has a position open.
Ruby has its good points but is tightly focused on the web. There is a stark difference between the way Ruby is used and Python for example. Frankly the library situation with Ruby is pretty terrible, unless of course you are focused on the web. Don't take this as me being negative on Ruby or pro Python, I'm just pointing out that they are used differently. I suspect that the demand for Ruby programmers is regional so your job switch may or may not be a good idea in that regard. In any event it is a good thing to learn a language and get paid to do it. One other thing, C++11 is changing the face if C++ drastically, leave it too long and getting back in will be difficult. 
I just recently ran into the problem of find_each not allowing ordering other than by id. I will certainly keep this gem in mind. FYI to those that don't know: User.order("name desc").find_each will NOT be ordered by name. find_each forces order by ID to do it's batching.
I think that it has to be set to the `bin` directory within there.
Tried that. C:\Users\matthew&gt;set JAVA_HOME="C:\Program Files\Java\jre7\bin" C:\Users\matthew&gt;jruby -v Cannot locate Java installation, specified by JAVA_HOME: "C:\Program Files\Java\jre7\bin"
 C:\Users\matthew&gt;set JAVA_HOME=C:\Program Files\Java\jdk1.7.0_01 C:\Users\matthew&gt;jruby -v jruby 1.6.5 (ruby-1.8.7-p330) (2011-10-25 9dcd388) (Java HotSpot(TM) 64-Bit Server VM 1.7.0_01) [Win dows 7-amd64-java] That was very very odd. But now dir %JAVA_HOME% doesn't work. Why does using JRuby require me to break my JAVA_HOME path?
Ask THE MAN: https://twitter.com/#!/headius ;-) (Charles is the main developer behind JRuby).
Well, I got it now. Using short path names worked. C:\Progra~1\Java\JDK17~1.0_0
When I try to run this I get Java LinkFailed errors for require "lwjgl.jar". After fiddling with it for a while I got "Can't load IA 32-bit .dll on a AMD 64-bit platform" at java_import org.newdawn.slick.AppGameContainer
JAVA_HOME should point to C:\Program Files\Java\jre7 \bin folders are usually added to the path, if needed.
How is this different than the built-in [find_in_batches](http://apidock.com/rails/ActiveRecord/Batches/ClassMethods/find_in_batches)?
Read the doc you linked to: &gt; It’s not possible to set the order. That is automatically set to ascending on the primary key ("id ASC") to make the batch ordering work.
If your project has specific requirements include the other library in your distribution. 
In the gemspec file, you can also specify specific versions of the other gem i believe. Then if there is an important upstream fix, you can always update the gemspec file and release a new version of your gem.
You can, but the worry then is the other gem might disappear from rubygems. I suppose you could set up your own gem server to solve that... kind of.
So to take a larger example -- if I do something that builds on ActiveDirectory, you're of the opinion that I should distribute (my favorite version of) AD with my thing?
Yes use a gemspec; do not unpack the project's gem into yours. Yes, release generally-useful String utilities as a stand-alone gem. No, it doesn't matter if one person is the author of both projects. The gem dependency version is a VERY good question and it's widely debated without a definite answer. My personal recommendation is to use the tilde operator and a major minor version number like this "~&gt; 1.2" so there's some flexibility which enables getting bug fixes. However, using the ~&gt; does lead to problems sometimes if a gem author introduces other bugs in a subsequent version - or worse, if the author decides to change the public method signatures. In my experience these problems typically appear immediately when you run your test suite on your own gem with the new version of the included gem. This does /not/ mean you're testing the included gem, it just means that your own gem will blow up quickly. Other developers prefer to pin the exact version like "= 1.2.3" and I think this is viable too. If you do this, you just need to stay on top of changes to your included gems, and also be responsive to developers who use your gem and other gems that both include the same underlying gem but different versions e.g. your gemspec says "foo = 1.2.3" and another gem's gemspec says "foo = 1.2.4". 
Gems disappearing from rubygems.org is a big issue imho. Yanking gems should not be possible. It happens far too often. If your project depends on a gem, forking the gem source code on github is great idea. If the other project decides to do something crazy, you can start a fork.
Ah, gotcha. I've never needed more than that, so I didn't realize it didn't.
Just to confirm your comment, I learned that lesson the hard way, from gems that didn't do dependencies properly. Yes, failure to include version numbers can cause catastrophic failures. I had to migrate an app that was on Rails 2.3.8 to a new server. Unfortunately, I did not have access to the old server in order to see the exact versions of the gems that were installed. Trying to get the right gems set up for this site was a huge problem. Whoever first created the site wrote the back-end around a nightmare of a gem called "Blue Light Special". I wish I'd never heard of it. Installing that gem would automatically install other gems, with no versions specified, so of course rubygems would pull in the latest versions of them all... and then those gems would install yet more gems, making for a three- or four-level dependency tree, somewhere around 15 gems, most of them apparently with uncontrolled versions. The app ended up trying to use some gems intended for Rails 2, some for Rails 3... there were huge compatibility issues. I tried freezing gems and everything else, and believe me, it was not a pleasant experience. So for each release of your own gem, make sure it includes version numbers for its dependencies, using the CURRENT version of those gems. You will save other developers hours to days of grief. 
Oh, you haven't looked at it yet apparently. :)
I've already switched to the alpha for my primary editor for work. I really don't understand what people see in Sublime Text.
I've used Sublime Text, and it's basically if you make TextMate look really really pretty, and removed 99% of the functionality (which are the bundles). Seriously, maybe if you are one of those people who uses a 'mouse' when they program it works ok, but I don't think I can ever go back to an editor in which I can't pipe my text through a terminal command with one button.
Not advised. Best idea is to use [bundler](http://gembundler.com) and specify exact gem versions.
Gems are very unlikely to disappear from rubygems - you can email them if you accidentally upload passwords in gems for example, but there's no UI for it. If rubygems lost gems pretty much every ruby project would be fscked
I'm surprised nobody else in this thread suggested Bundler. **Bundler is designed to solve exactly the problem that the submitter mentions.** You specify your dependencies in a description file and Bundler will calculate a correct dependency graph and activate the right gem versions for you. External gems having too liberal dependency specifications? Just make the specifications stricter in your Gemfile, and your problem is solved. In my opinion you should almost never vendor external libraries into your codebase. The dependency specification problem is solvable through Bundler. Gems don't usually disappear from RubyGems.org so that solves your availability problem.
For me it's things like: - Project handling and switching (cmd-shift-P) as it should work. - Multicaret support. TM2 now has this, but doesn't have ST2's "expand selection" (cmd-D) that lets you effortlessly replace/insert stuff in multiple locations. Try it. - Remembers entire workspace on quit/crash, even unsaved changes and new documents that haven't been saved to a file yet. - Works with large files. - Build system integration. - Per-project/directory file exclusion rules (as opposed to TM's huge one-line regex). - "Find" that highlights all matches, not just the current one (and integrates with multicaret support). - "Find in files" that doesn't suck. - Indentation guides. - "Goto anything" (cmd-P) command that, among other things, matches the entire path. (TM's cmd-T only matches the file name.) - "Execute anything" command access (cmd-shift-P) for mouseless access to all sorts of things. - Aesthetics (Soda Dark theme: https://github.com/buymeasoda/soda-theme). - Python API, with the ability to extend the UI and manipulate buffers.
Forking is nice, but the fact that if the original repo is deleted, also deletes your fork instead of orphaning it means I wouldn't do this for projects if I didn't trust them to stay around
Another note about bundler: It gives you the best of both worlds. You can run [bundle package](http://gembundler.com/man/bundle-package.1.html) and it will cache the compressed gemfiles in the project for you, in case they do disappear. Note that [yanked gems are still available on rubygems](http://help.rubygems.org/kb/gemcutter/removing-a-published-rubygem) unless someone is emailing rubygems.org to remove them - and you wouldn't do that for a code error, you'd do that if e.g. you pushed your server password in the gem by accident or something stupid like that. I can't emphasise enough how good bundler is, it was designed to solve dependancy hell and I have never had any dependancy issues using it. I'd go as far as to say if you're not using it now, you should have a really, really good reason not to, it should be the default choice for new projects.
Exactly what I ran into recently -- the developer of a project was using the "kinda" ~&gt; operator to require about 10 gems around certain versions, but those gems then started requiring others... etc. Ended up being a 30 or 40 gem install, and in the end landed on a bad version of Nokogiri, so couldn't use it. :/ 
The source of the gem is in your cache folder. If your dependency disappears you can unpack it, rename it, repackage it and uploaded it again, provided you respect the license.
There's only been one API version of nokogiri, 1.x. If someone was specifying a tighter dependency than ~&gt; 1.4 or ~&gt; 1.5 they're doing it wrong and you should file a bug against the author. If they need a particular bug fix in the 1.x series they should specify ~&gt; 1.4, &gt;= 1.4.1, for example.
tl;dr For apps it's OK, for gems NO WAY! **NEVER DO THIS IN A GEM** **USE A DEPENDENCY IN A GEM** If you embed your dependencies in a gem you lose out on bug fixes, have additional licensing demands (all the embedded libraries must have compatible licenses and you need to mention those as required by the individual licenses) and this costs rubygems.org more money through larger downloads. If you embed libraries in an application that isn't redistributed as a gem like a rails app or a MacRuby app, fine. You don't want to mess with 
I don't see any reason to include the source directly. If you are worried about "too permissive with version requirements and upstream changes break things" then simply set your gem dependency to an exact version. This will accomplish the same 'locking' as including the source. So that's a non-issue. I think it's highly unlikely that a gem will disappear from rubygems. I mean, I guess the author _could_ yank it without a replacement... but what problems are we trying to solve here exactly? But sure, if you won't take no for an answer, there's nothing stopping you from including external source of a third party gem in your own gem. I am not sure what you are looking for here. 
bundler is for apps, it doesn't help you at all for releasing gems (other than knowing that the users of your gem(s) will have bundler available, making it easier to resolve dependencies of their app, including your gem's) You specify a gem's own dependencies the same way with or without bundler. And you should expect that people will use a gem you release both with and without bundler. 
&gt; This will also replace valid responses, even 200, basically making your application useless.
&gt;use StatusCats, :except =&gt; 200...300
Context is everything and careful reading of his post justifies me response. Simply put he has little trust that his libstdc will be available at all in the future or possibly rasdically changed. It that context taking the code into your project makes a lot of sense. Also expanding this discussion makes no sense at all. For all we know there may be a single file involved that munges some strings. In the end I see this path as more secure if you don't trust the source, the lib is developing to fast or in a direction you don't like. Let's face a lot of code disappears or falls dead on the net, so sometimes it pays to hedge your bets. Further if things shore up outside his app he can always revert to requiring a gem or whatever. We probably can argue until we are all blue in the face but I believe the original post creates a context where this makes sense. Programmers often get a bug up their ass about doing such and such this way or that, so much so that they forget to look a little deeper. 
Sorry about the iPhone typos. You guys can figure it out. 
This is why Yehuda and team wrote Bundler. Bundler makes it easier to work with gem dependencies and versions. For example, Bundler will calculate all the dependencies of your gems, and their gems in turn. You can also tell Bundler that there's a bad version of Nokogiri, and Bundler will do its best to pick a viable version. The "~&gt;" operator gives Bundler a bit more flexibility to find a solution that works for all the gems you need. You can specify multiple versions like "~&gt; 1", "!= 1.2.3" which means "Any version 1.x except 1.2.3"
What? I have never heard of this.
Bundler can use your gemspec to help out with gems. It's still useful there.
This isn't true, I just tried it to be sure. It won't delete forks.
Thanks for the expansion. I think you're right, there's a lot of trust that required libraries will retain the same API between 1.2.3 and 1.2.4, and will be available in 3 months.
If the fork is of a private repository it will.
It will delete the forks if the repository is private.
Had it happen with a private repository fork. The company I work for forked the repository of their app from the consulting company they hired originally, instead of making a new one. When the consulting company cleaned up their github account, our repository disappeared. We all have most recent copies of the repo, so it wasn't that big of a deal.
Why I'm super-surprised about this is that some of my largest projects were taken from someone who deleted their entire GitHub account; the only reason we have the software today is because of errant forks left behind. EDIT: Oh wait, we're in /r/ruby, it was _why.
Well played sir. Well played.
It's great!!
In all seriousness, I don't trust most ruby code to be thread safe. That's what's appealing about fibers. 
i do. nothing to write home about :/
Haha, classic. I wish threading were more powerful and safer. I like it. Is there a deeper commentary you're trying to make about concurrency in ruby and fibers or is it as simple as it appears? This appears like a good opportunity to talk about it and learn about it.
This is git we're talking about, so as long as you still have the repo locally, you can push up the entire history to a newly created repo on github again, as Scyllinice said. Apparently this is only true for forking private github repo's, I just remember seeing this message when forking before, and being careful.
https://gist.github.com/1220800
thanks, I need to take some time to digest that, but it doesn't seem to me to be the same difficulty as preemptive threading. I.e. I think it's much much easier to avoid this than race conditions in threads. If I understand the code correctly they are doing this 1. read value 2. do something nondeterministic 3. increment and write value That seems rather easy to avoid to me. Edit: Hopefully this clarifies my point. With fibers you're code is deterministic by default. With threads your code is nondeterministic by default. I think that makes a big difference, but I have to admit that I've never written anything of consequence with fibers. Edit 2: I've written some threaded code in JRuby and it was a joy. Being able to use java.util.concurrent with ruby is amazing. 
*edited* Okay, okay, I looked at the 'source', okay, ha ha. Believe you me, I have been working for a while at using ruby threads... even in 1.9.x, they have some odd performance characteristics, and of course writing thread safe code (and figuring out what libraries you are using are thread safe) can be tricky. Of course, I suppose the latter could apply to fibers too. 
Well played. I was wondering what the heck this library might be doing, perhaps wrapping Thread &amp; Fibre in a single common API, after reading the comments, I started to catch on &amp; looked at the source
Nice. Now who wants to make it a nice ARel extension instead, so it would read something like this instead: &gt;User.order('influence desc').batches_of(2000).each do |item| Or... why not actually patch AR to make the already existing find_in_batches and find_each respect #order? Monkey patch for now, or actually contribute an an improvement patch for AR? If this gem can do it in a particular-db-driver-independent way, why not just contribute it to AR?
Kinda funny I found this video on the same day that fibur is released!
Threading really isn't that hard. In fact, Threading is pretty nice in Ruby give threads are wrapped in closures. Just remember to use Mutexes/ConditionalVariables where appropriate and use Queue/SizedQueue to communicate with Threads.
You are assuming that your processing fits a producer/consumer model. It is not hard to get that right, but not everything fits that model. Things that don't can be much much harder. More importantly, I don't trust most ruby libraries to be thread safe. 
My solution: Runs in 0.656816s 117 characters output = 0 gifts = gifts.split("\n") day.times do tmp = gifts.pop tmp[0].chr.eql?('A') ? output += 1 : output += tmp.to_i end 
That's pretty much code for an example that boils down to this: val = DB.read_value async_io do |str| DB.write_value(val + 1) end
A nice summary, it might be useful to have a bit more opinion when and when you should not use these. There are times when ruby has a more ruby-like solution.
Top quality, very funny!
"confusing XML configuration" is kind of the point of "monstrous 'dependency injection' frameworks". The typical Rubyist solution is for configuration to *be* Ruby code (not usually considered an option in a compiled language). Paramaterization as implemented in the article is perfectly possible in C# and IMHO preferable to any framework supplied [Bag of holding](https://en.wikipedia.org/wiki/Bag_of_holding). Passing the payment provider class as a parameter could be considered a cheap (in terms of brevity) version of the [factory method pattern](https://en.wikipedia.org/wiki/Factory_method_pattern). Factories provide the opportunity to initialize the constructed object. In the case of a payment provider for example, a Merchant Account ID may need to be supplied (the initialization being specific to the payment provider class, so we cannot just add parameters to the calling method). In this example, such complexity is only required if the payment provider instances are mutable. Otherwise, why not pass a pre-initialized immutable payment provider instance instead of either a class or a factory? 
Hmm, in my example the method DOES take a pre-initialized instance. But the 'default config' was a class, I suppose it could be a single initialized-at-startup instance too. But I guess I'd say, in ruby, people don't do too much with making it clear whether an instance is mutable or not, and making truly immutable instances is not always straightforward (which is probably why people seldom bother). This is not neccesarily a great state of affairs, I think the recent interest in pure (or nearly pure :) ) functional languages has raised awareness of how useful immutability can be. But writing in ruby, it's generally safer to make no assumptions about whether a particular class/instance is mutable or not, thread-safe or not, etc, because ruby conventions and stdlib and language support (perhaps sadly) often don't draw a clear distinction, and a class that starts out immutable may later become mutable. And even classes that are (to the outside world) immutable, may lazily load and cache internal data in a non-thread-safe way. (On a side note, personally I'd love it if there were stdlib immutable versions of well-used 'data types' like Hash, Array, and String, and if using those became a popular thing to do in ruby open source, which would probably lead to greater awareness of and support for immutability in more complex composed data types... but it just ain't so at present.)
Less magic.
Wow, those are impressive numbers. I guess it's time to give it a serious look. Is warbler still the way to go? Glassfish? Tomcat? Has the stacktrace issue been sorted or do you still have to dig through a thousand lines to figure out what went wrong. 
Most folks familiar with ruby will want to simply use trinidad, our preferred command line server. Warbler also works great if you intend to deploy to a java app server, and torquebox provides a full-featured set of JRuby plugins for JBoss. Stacktrace issue?
Please read [this classic](http://weblog.jamisbuck.org/2008/11/9/legos-play-doh-and-programming) before talking about DI in Ruby. def process_payment(string orderData, payment_provider_klass = PayPalPaymentProvider) paymentProvider = payment_provider_klass.new result = payment_provider.Execute(orderData) MessageBox.Show(result.to_string) # yeah, just assume this exists somewhere end That's way simpler.
I'm also very happy with Kirk server. In conjunction with Quartz it was the best solution for us. You can read more about it here: http://www.slideshare.net/ocher/jruby-everything-in-a-single-process Since we moved to JRuby Trinidad has fixed its problem with hot deploys. It also has some scheduling capabilities, but Kirk+Quartz worked better for us. 
Dr Nic says: use nginx and jruby.
DAE see the title and think JJJJJJJUU a-la F7U12?
I have this book, bought it at beta v1, and it really is very well done.
Why run Ruby on a Java VM? Seriously are there any advantages beyond the fact that it is Ruby code instead of Java. 
I know reasonable amount of Ruby, but only a tiny bit of Java. Every now and then there's a situation where Ruby simply does not cut it for performance reasons. JRuby allows me to extract the most calculation-heavy pieces into much more performant Java implementations, and then access them seamlessly. Or maybe a juicy contract says it should be done in Java, either for hopes of future maintainability or simply to favour some pre-arranged deal. JRuby allows me to bid for the contract. Or maybe it just so happens that you need to interact with The Enterprise, things Ruby community does not give a damn about. Signed, encrypted XML over SOAP webservice. No, the bank won't change its payment interfaces because you asked them to. I have tried implementing necessary things in Ruby - slow and painful. While over in Java-land, there are libraries that will do exactly what I need. As a Java guy, there really isn't much to gain via JRuby, if prettier, more concise code is not your thing. However, a Ruby dev stands to gain a whole lot from having Java tools readily available from within comfortable territory of Ruby code.
Very cool... just need to find a use for it now!
Sun's JVM is an amazing piece of engineering: state-of-the-art GC and JIT, and it's cross-platform. It has great performance and native threads. You also get to hook into the enormous Java ecosystem of libraries. 
For me it's the Java-only libraries like iText. It's great to have access to (most) gems and JAR's out there. 
I was thinking of trying jruby with Amazon Beanstalk. Do you have any experience with that? As for the stacktrace issue I have heard people complain about huge stacktraces with jruby, maybe that has to do with the container. 
Try this: http://blog.headius.com/2011/01/jruby-on-rails-on-amazon-elastic.html Sometimes Java traces will leak out, but in general we go out of our way to make traces always be pretty Ruby versions. If you see a raw trace, it usually signals a bug in JRuby that we'd want to fix.
What's its output? Other than the erroneous `end` on the second to last line it seems ok.
It's way faster for ruby code, but when I test it with my real rails apps MRI is usually faster. This is largely because most of the work they are doing is talking to a db via a C driver, serializing to json (C code), etc, etc. Now, if I need concurrency I'm all about the JRuby :)
There's an extra "end", as dpiddy pointed out, but other than that, it looks okay. You could do it a bit more idiomatically, though. require "open-uri" open("Python Manual.html", "w") do |out| open('C:\Users\sred13\urls.txt', 'r').each do |line| out.write open(line).read sleep 2 end end Yay blocks!
Right tool for the right job man! http://gnuwin32.sourceforge.net/packages/wget.htm
If you have Cygwin installed, you can do thi as a one liner: `cat urls.txt | xargs -n1 curl &gt;&gt; 'Python Manual.html'`
You might want to try `strip`ing `line` before opening it. The line will Include the end or line characters as well (\r\n on windows), which should not be part of the URL.
It's the fastest ruby vm.
We also use Kirk, and I don't know about Quartz. Thanks, for mention, will give it a try instead of Resque.
It gives about 8% of performance improvement in my environment (Ubuntu 11.04 32bit gcc-4.5.2). Not tested in other, though.
How it differs from catch + throw ?
&gt; This implies inability to call load or require after the initial loading process, using Class.new or define_method, absence of eval family functions, certain operations with singleton classes, nested method definitions (def a; def b; end; end) and maybe a few other, even lesser used features. Yeah, so, discarding everything that makes Ruby Ruby and not, say, a watered-down Python? Off to a great start there.
&gt; While all of the above may seem like a severe restriction, actually none of those features are commonly used at runtime, and, in fact, if they are actually used, that’s a sign of bad code. Yikes. I'd like to introduce you to a few things called the "Rails router" and "ERB", which make extensive use of define_method and eval, respectively. While I'm aware that Rails is not all of Ruby, it's certainly the lion's share of the Ruby programmer base. define_method is very commonly used as a memoization technique, and is very commonly used with gems that provide macros for extending classes. To write it off as rarely-used or only present in bad code smells an awful lot like not paying attention to the Ruby ecosystem. I grepped my $GEM_HOME for define_method, and came up with gems such as ActionPack, ActionMailer, ActiveRecord, Arel, bundler, Compass, curb, Dragonfly, EventMachine, Guard, Haml, HTTParty, Minitest, MongoMapper, Nokogiri, Passenger, Resque, RSpec, Sqlite3, Thor, Warden, WebRat, WillPaginate, and ZenTest. Nothing important or commonly used there, surely? Excluding define_method basically means that none of the really commonly used stuff will run. At all.
This seems to fix the [nasty bug](https://github.com/tenderlove/mechanize/issues/123) "too many connection resets" that made me downgrade back to v1.0. Congratulations to the Mechanize team!
Only after runtime. Read the article.
Apart from the Ruby/tool issues (I'll second using something like wget and cat), also know that you can't simply concatenate two HTML files and assume you'll get correct result. You probably need to append only the content of the &lt;body&gt;&lt;/body&gt; into the other's body. Even then you can have problems if you redefine stuff like id's (attributes). To handle the HTML, look into nokogiri and or hpricot.
I just wrote my own in .NET so that kind of sucks I did not know about this. Even so, we have to do a lot more than just parsing these documents. We need to map them to different formats, validate them, store and retrieve them, and make routing decisions based on their content. For me, I found the mapping of these documents to be harder than parsing them due to their hierarchical nature. I need to take header and detail, flat payment files for example, combine them with the incoming 837, and map to a new 835. Or, an eligibility data stream mapped to an 834. In one case, an internal claim system can take no more than 9 lines so i need to 'inflate' (copy the header and trailer) each claim with more than 9 lines into multiple claims. It is interesting to meet other x12 programmers.
'after runtime'? Do you mean 'compile time?'
&gt;While all of the above may seem like a severe restriction, actually none of those features are commonly used at runtime, and, in fact, if they are actually used, that’s a sign of bad code. Yes, only 1% of all ruby code or less uses it. Yes, 99% of all ruby code has to use this at some place, somewhere. The magic complicates the implementation, therefor it is not common to do these tricks in your own program, but it very common for many of the DSL' you depend on, to use them. You can't just rewrite rails for this theoretical Ruby. Many of its features, simply couldn't be done. So, if he would still call it ruby, that would be like almost an attack on the language itself. If you invent a new language, that isn't compatible with most ruby code out there, don't call it ruby. Give it a new name.
You can now use: task :vendorer do v = Vendorer.new(:update =&gt; true) v.file 'xxx.js', 'http://....' end
ruby-- ?
Yeah. Sinatra is great. 
&gt; Every line length &lt;= 80 characters. Let me ask you something - are you still using a 640x480 CRT monitor? No? Then why limit yourself to 80 characters? I'm of course omitting the fact that there are editors, like [Kate](http://kate-editor.org/), that support something called 'dynamic word wrap', which dynamically wraps your code to maximum width possible with no effort on you part, which makes any manual wrapping completely pointless and moronic. Just because many people do something it doesn't mean it is a good idea. Oh and, I'd increase the tab size from 2 to 4 - if you're writing methods that have so many levels of indentation that you need to use 2 space tabs to keep everything on screen - you're doing it wrong.
Wow, that is much prettier! Thank you!
Good point! I've just wanted to easily concatenate them all so I could then use another tool to strip extraneous information from them.
&gt; Then why limit yourself to 80 characters? Code quality. If your line is greater than 80, you're doing it wrong. Make it less complicated. &gt; I'd increase the tab size from 2 to 4 Two is standard Ruby style.
I always though ! after method meant in-place? I have never really understood the 80 characters max rule either. Why are we limiting our code, and most importantly, good variable names, because of this silly rule?
First rule of any coding style: when editing an existing file, follow the style of that file even if it does not adhere -- unless you're specifically re-styling it.
I come from python and think that 4 space indentation is awesome, specially when indentation is significant to the code, however the convention in ruby is to use only 2 spaces, if you "would change that" then you are doing it VERY wrong.
There are many statically typed languages on the JVM and .NET with ruby like syntax. I'm not saying it would make a bad language per se; there are many ways to solve a problem. But semantically, this Ruby-- is as close to Ruby, as Javascript is to Java. The one single defining feature for Ruby is dynamic dispatch. It is essentially Smalltalk with a different syntax. Imagine some one would propose to remove classes from Java and switch to prototypes. Or if someone would remove functional programming from Haskell. What, if anything, is left? The culture? The ecosystem? The syntax? The OP seems confused at best. You can change everythingy about Ruby, and still have it be something very near Ruby, except for this. This completely changes the paradigm, and it affects not just the semantic of a few programs, but how you would construct a program. Ruby is a dynamic dispatch language. That is it's paradigm. Take that away, and you have a language closer to Java or Haskell, than to Ruby. 
 list.each do |x| # multi # line # blocks end list.each { |x| #single line blocks } 
What metrics are you using?
For those wondering about the character limit, there are multiple reasons. For one it ensures that almost anybody can view the code without having to scroll horizontally. For example, wrapping code manually at 80 characters means I can have 2 vertical buffers open in Vim as well has NERDTree (file explorer). Another reason is the use of terminal emulators. A lot of terminals will wrap text after 80 characters but usually aren't very good at doing this. By wrapping your code manually you can ensure that it looks exactly the same across different platforms and tools. tl;dr: wrapping lines "manually" (Vim can hard wrap lines for you) you ensure that your code looks the same across different platforms and tools.
&gt;End methods with '!' if they need attention. More on bang methods: [http://www.wobblini.net/bang.txt](http://www.wobblini.net/bang.txt) That being said. In the standard lib most bang methods are generally used to denote that the method modifies the object it is called on. str = 'kittens' str.upcase! puts str =&gt; 'KITTENS' In Rails they are used (mostly) for methods that throw exceptions. `Post.find_by_title('kittens')` can return nil but `Post.find_by_title!('kittens')` will raise `ActiveRecord::RecordNotFound`.
I use ! to signify a method that "does something scary" (I pronounce ! as "AH!" or "EXCITEMENT!"). This seems to generally convey the semantics intended (eg, save! fails if validations fail, iirc, in rails -- even though it's not in-place, I think the ! is justified (I'd also pronounce `save!` as `save with EXCITEMENT!`) As for the 80 character rule. For my part, I often have many terminals tiled across the screen, so 80 characters means a 3x2 arrangement of terminals without any wrapping at my (fairly small) font size. More generally a line that's more than 80 characters tends to indicate a line which could be refactored into some helper methods, or maybe be simplified -- at least, in my experience it does. That said, I don't think you should blindly conform to any rule in all cases. It's sometimes okay to break that rule, but only if doing so is truly justified. That is to say, if you have a line which contains simple logic, but by virtue of following another rule (say, good variable names), you end up 80+, I'm not going to come after you for it. Typically when I see lines &gt;80 chars, it's because much of the line is burned in deep indentation (which is why I love Ruby's 2-space indent idiom), or in some guarding conditional. eg: class Foo def bar if baz? the_result_of_bingling = bingle unless bangle! || bongle! end #snip end end Here, the 4th line is pretty long, I might try to refactor the `if` and `unless` clauses into one helper method like: def should_do? not bangle! &amp;&amp; not bongle! &amp;&amp; baz? end then rewrite that line as the_result_of_bingling = bingle if should_do? which shrinks things a bit, I might also consider terser variable names -- depending on the level of exposure the variable has (I'm generally okay with crappier names if they're only used very locally). Or even just caching the result of bingle in a method (or in the bingle method proper) and using it like a variable. The punchline is that they 80 character rule isn't a limitation inasmuch as it is a rule of alarm. If you're constant writing 200 character lines, you're probably doing it wrong. 
&gt; Code quality. If your line is greater than 80, you're doing it wrong. Make it less complicated. Fair enough; I agree the less is better, but you're talking about something *entirely* different. Let me requote: &gt; Every line length &lt;= 80 characters. It doesn't say "try to keep every line less than 80 characters long", it says that every line **must** be less than or equal to 80 characters, which implies that any line over 80 characters will get manually wrapped, which is just stupid. &gt; Two is standard Ruby style. So what? Adherence to a given language's syntax is mandatory, but style is a matter of preference/readability. In this case, in my opinion, 4 spaces are way more readable than 2, and I'm not going to force myself to use 2 just because everyone else does.
&gt; the convention in ruby is to use only 2 spaces, if you "would change that" then you are doing it VERY wrong. Then could you kindly explain why it is "VERY wrong"? Will using 4 spaces as indentation kill someone's newborn?
please correct me if I'm wrong. I think this is what is happening in your version: 1. Loads the uri/working with the web module 2. Opens/creates the file in write mode storing the object in 'out'. 3. Gets the url's line by line using the .each method, and for each, stores it in 'line'. 4. Uses the variable out's .write method, with the current URL objects .read method for the data 5. sleeps then moves to the next line until the document is empty I hope this is basically what is happening. Are you omitting some words or characters to save space? I just find it so hard to read, being new to Ruby.
... then you're not programming in Ruby Style, which is what the article was asking about, not 'koutiheika style.'
Yeah, formatting change commits should be different than functionality changing commits.
[The ! does not mean “This method changes its receiver.” ](http://dablog.rubypal.com/2007/8/15/bang-methods-or-danger-will-rubyist)
That's basically what's happening, yes! I'm not really omitting anything; Ruby blocks are very powerful, especially when dealing with files. The form: open("foo", "w") do |f| ... end Says "open the file foo for writing, and pass the file handle as `f` to the given block, then close the file after the block finishes". So, I'm able to omit file closing, since passing a block to open does it implicitly. The blocks aren't so much "storing" the file handle in "out" as they are invoking an anonymous method, and passing the file handle as a parameter to the method. It's sort of like if you did this: def read_file(file_handle) # Do stuff with the file handle end handle = open("file", "w") read_file(handle) handle.close() But instead of having to define an explicit method, then invoke that method, Ruby blocks let you pass an anonymous function to a method as a parameter, then the method you passed to can all that passed-in function with some parameters (via the `yield` keyword).
It's not about that, it's about following the style. If you're not going to follow the language style, then don't even pretend to, and just do whatever the fuck you feel like and watch all the seasoned developers laugh at your code. I'm assuming that is true in any language, not just ruby.
This breaks down sometimes because do has lower operator presence than {. [Discussion](http://stackoverflow.com/a/533255/96067)
True, as rules go this is one of the ones that you need to apply based on common sense and aesthetics, and not written in stone. But it's a good guideline.
&gt; .. then you're not programming in Ruby Style, which is what the article was asking about Okay, my bad. I thought he was asking how he can make his code more readable (as he wrote "**my** Ruby style"), but then when I read the title again I do see that he might have been asking whenever he's following the hivemind properly or not.
Yea, need to up vote this. For instance in `activerecord`'s `save!` will raise, where `save` will not. [ActiveRecord::Base#save](http://apidock.com/rails/ActiveRecord/Base/save) vs [ActiveRecord::Base#save!](http://apidock.com/rails/ActiveRecord/Base/save!)
I think for newbulars like myself, its a lot easier when you use extraeneous handles here and there, so it is obvious when a file is closed or not. In any case, thanks for the elegant solution to my chunky problem.
Understandable, but it's worth noting that my example is idiomatic Ruby - blocks are one of the most common constructs in Ruby, and understanding how they work is going to do a lot to make Ruby more accessible. The [documentation for File#open](http://www.ruby-doc.org/core-1.9.3/File.html#method-c-open) explains the block semantics. Good readin' :)
One of the points the author was making is that often define_method is often used around the same time as files are required, and classes are defined. After some setup of the environment, things start to settle down and those methods are rarely, if ever called again. That's what he meant by "runtime", which could be confusing because everything happens at runtime in ruby -- but there is a clear separation in most libraries between "setup" and "normal execution". In fact in libraries that use define_method during "normal execution" it's usually the sign of a bug. There's usually an upper bound to that sort of thing, and if it continues on indefinitely bad things will usually start to happen (i.e. memory leaks, bloat, etc). That's what I think he means by "none of those features are commonly used at runtime, and, in fact, if they are actually used, that’s a sign of bad code"
Doesn't python have all of those?
Thanks everyone for the comments. This clears up things a bit. 
http://docs.python.org/library/functions.html#eval def a(b): def c(): pass return c http://stackoverflow.com/questions/5449244/pythons-equivalent-for-rubys-define-method 
Some sort of mechanism like this is the right way to do dynamic languages. The important insights are that A.) recognizing "compile time" is useful and B.) you can do "compile time" again whenever you need to. See Chambers, "The design and implementation of the self compiler, an optimizing compiler for object-oriented programming languages" for a 20 year old doctoral thesis on how to write compilers like this efficiently. The punchline is that you should be able to get about a third the runtime speed of C without sacrificing any dynamic features.
I ran rails application and siege it with `siege` ;) Also, ruby's `make check`, startup time of `rails runner`, startup time of small scripts. However I admit that some exotic workload could suffer from patch. Synthetic bench could be made presenting little performance degradation from patch.
This is the update that moves it off of moldy-old Gitosis and onto up-to-date Gitolite. I have an existing Gitolite setup in place for the company I work for, and I'm interested to see how smoothly I can get this running on top of what I already have in place, rather than starting from scratch with a fresh Gitolite.
That is pretty awesome. I wish my circumstances allowed me to apply.
&gt; are you still using a 640x480 CRT monitor? No? Then why limit yourself to 80 characters? Readability. Deciding line width based on screen size is a bad idea. Would you use an infinite line length if you had an infinite screen? No.
"If you aren’t deeply frightened about all the additional issues raised by concurrency, you aren’t thinking about it hard enough." John Carmack 
Could you explain further why we should be afraid of Threads?
***CamilleRoux***: &gt;&amp;#91;2011/12/24&amp;#93;&amp;#91;14:18:13&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|ruby %2De %22%28%281..20%29.to%5Fa+[6]*4%29.each{|i|puts %28%27#%27*i*2%29.center%2880%29};puts;puts %27Merry Christmas%27.center%2880%29 #Ruby #Christmas %22 'google translate this tweet'): ruby -e "&amp;#40;&amp;#40;1..20&amp;#41;.to_a+&amp;#91;6&amp;#93;&amp;#42;4&amp;#41;.each{|i|puts &amp;#40;'&amp;#35;'&amp;#42;i&amp;#42;2&amp;#41;.center&amp;#40;80&amp;#41;};puts;puts 'Merry Christmas'.center&amp;#40;80&amp;#41; [*&amp;#35;Ruby*](https://twitter.com/search/%23Ruby 'twitter tag search') [*&amp;#35;Christmas*](https://twitter.com/search/%23Christmas 'twitter tag search') " [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/ruby/comments/np5by\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error')
No he didn't.
You shaved one character, removed the comments, and messed up the quotes. That's not better.
Not that I write Ruby (next year's goal), but can comments begin with a hash?
Yes, and doing so would be considered idiomatic. I'm not sure what's up with these silly 'corrections', can't people just appreciate a quality ASCII Christmas tree anymore?
Shaved off 3 characters. I actually assumed the comments were misplaced hashtags at first, so "fixed" it. Still shorter either way. It's an awesome line of golf, we're all friends here.
You're right. I didn't copy those because I thought those were just hashtags for his tweet, and I missed the end-quote after them.
Oh, the parentheses - so then I guess it's actually five?
Well I suppose they're both really. I quite like the idea of hash-tagging code for bookmarking.
ruby -e "(((1..20).to_a+[6]*4).map{|i|'#'*i*2}&lt;&lt;''&lt;&lt;'Merry Christmas').each{|l|puts l.center(80)}"
With a star: ruby -e "(['\^','&lt;*&gt;','v']+((1..41).step(2).to_a+[6]*4).map{|i|'#'*i}&lt;&lt;''&lt;&lt;'Merry Christmas').each{|l|puts l.center(80)}"
That's an arrow.
That's an upvote.
truly genius.
***chriseppstein***: &gt;&amp;#91;2011/12/24&amp;#93;&amp;#91;19:49:10&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|ruby %2De%27a=%281..8%29.to%5Fa+[4]*3+[0];%28[%22\e[1\;36m%22]+a+[%22 \e[0mHave an upvote%22]+a.reverse%29.each{|i|puts %28Fixnum===i ? %28%22#%22*i*2%29 : i%29.center%2840%29}%27 'google translate this tweet'): ruby -e'a=&amp;#40;1..8&amp;#41;.to_a+&amp;#91;4&amp;#93;&amp;#42;3+&amp;#91;0&amp;#93;;&amp;#40;&amp;#91;"&amp;#92;e&amp;#91;1&amp;#92;;36m"&amp;#93;+a+&amp;#91;" &amp;#92;e&amp;#91;0mHave an upvote"&amp;#93;+a.reverse&amp;#41;.each{|i|puts &amp;#40;Fixnum===i ? &amp;#40;"&amp;#35;"&amp;#42;i&amp;#42;2&amp;#41; : i&amp;#41;.center&amp;#40;40&amp;#41;}' [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/ruby/comments/npejl\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error')
Just found this and thought it was really good as an introduction to Ruby
Nice. Can save some extra characters swapping `['^','&lt;*&gt;','v']` out in favour of `%w[^ &lt;*&gt; v]` as well.
Same, it's something I wish Github had for Gists. 
Kind of a Rails noob here. Why would you want to?
So you could use the inheritance to actually inherit from one of your models (that doesn't have to be an ActiveRecord class), that might come in handy every now and then. 
I guess I was interested in what the "now and then" could be. As a noob, why wouldn't you want all that ActiveRecord love?
How would you handle STI?
You do want all of the ActiveRecord love. You just don't want exclusively ActiveRecord love. Maybe you need to inherit from some other base class that gives unrelated functionality, such as the ability to transfer the objects over a network or render them in a visual graph. Who knows.
I always liked this one from Ruby Inside, granted it's more than 140 characters: print "#{def r(x);rand(x);end; C = "\033["}2J#{C}0;0f#{C}32m"; w=r(20).to_i+13 h=w-r(10).to_i; h.times { |line| puts " " * ((w / 2) - (line / 2)) + (1..line+1).collect { r(rand(12)) == 0 ? "#{C+'5m' if Time.now.usec % 2 == 0}#{C}#{r(7) + 31}m*#{C}0m#{C}32m":'='}.join}; print "#{C}33m"; 3.times{ puts (("x" * (w / 6) ).center(w)) }; puts "#{C}0m\n", "Merry Christmas From Ruby Inside!"
I was reading [http://qualityonrails.com/archives/33](this article) and don't they accomplish the same thing using the idea of MixIns? Perhaps the benefit comes from the use of a class over a module?
Very good find, great quick intro for some people without having to read an 800 page tutorial/reference based book
Presumably, you can still inherit from a class that mixes in ActiveRecord::Model for STI behavior. This is how some other ORMs (DataMapper) work.
Hmm... * ^^^ ^^O^^ ^O^^O^^ || Too many characters?
Looks cool. But seriously, does *no one* teach ruby bottom up? I’m unequivocally a bottom-up learner.
Yes: as I understand it, ActiveRecord is becoming a mixin rather than a class. You can combine multiple mixins in a single base class but not multiple base classes. So if a capability can be provided as a mixin rather than a base class, that's generally better. (all else equal)
Inheritance is a scarce resource that should be used carefully. (Each class can have only one superclass.) The `ActiveRecord::Model` mixin allows the developer to decide how that resource should best be spent, not the framework. See also: "favor composition over inheritance" (Gang of Four).
Great share..thanks..
The [description of the top level object](http://www.apeth.com/rubyIntro/justenoughruby.html#toplevel) is incorrect, for an accurate explanation, see: http://banisterfiend.wordpress.com/2010/11/23/what-is-the-ruby-top-level/
Not everything lives in the database. 
I've been wanting this for a LONG time. Kudos to the Rails team!
No, because the submissions aren't recorded unless they pass the test, so somehow it has to pass the test.
That actual string is composed of tabs and spaces, which don't count towards the total count. I imagine the contest will want to change this. The string is: " \t\t\t \t\t \t\t\t \t \t\t\t \t \t\t \t \t \t\t \t\t\t \t\t \t\t\t \t \t\t\t \t\t \t\t\t \t\t\t \t\t \t\t\t \t \t \t\t \t \t \t \t\t\t\t \t \t\t\t \t\t\t \t\t\t \t \t \t\t \t \t\t\t\t \t \t\t \t \t\t \t\t\t \t \t\t \t\t \t\t \t \t\t\t \t\t \t \t \t\t\t \t \t\t \t \t\t \t\t \t\t \t \t \t\t\t\t \t \t\t \t \t" The key is that when using the "B" (bit string) pack format considers the LSB of each character to represent that bit, so: " ".ord == 32 32 % 2 == 0 "\t".ord == 9 9 % 2 == 1 So he can use this to represent the code in binary with " " meaning 0 and "\t" meaning 1. The result of .pack("B*")-ing that string is "string.gsub /\\w+/,&amp;:capitalize"
[Here](https://github.com/ruby/ruby/commit/976aba43c30c3fcd86fb36b68a829751a9a1b697) the updated docs.
Indeed. I've occasionally seen entries similar to this get "honourable mentions" in various code golf competitions, but naturally they are usually disqualified since this technique would end up dominating so many of them if left unchecked. I'm not sure if there's a standard rule you can use to prevent this that works with all/most languages, or if it mostly has to be left to the judges' discretion.
Thanks!, I tried to do something similar, but since it was single-quoted I couldn't figure it out
In case anyone wants to play with this, I made a function which will convert a string to whitespace to be evaluated with #pack and eval http://pastebin.com/Gbz63Die
Or even simpler "string.gsub /\w+/,&amp;:capitalize".unpack("B*")[0].tr("01"," \t")
They should just count significant whitespace. If that is too vague, then count all whitespace.
now write this as whitespace to make it as short as possible...
I'm very excited to apply for this!
You are not hungry enough! Om nom nom
GoDaddy is apparently registered with GoDaddy. I think we should all boycott GoDaddy until they move registrars! /s
/r/SOPA is over there.
Catch/throw is too mainstream.
Chill, the official move date is the 29th. Complain then. 
Who's on board?
I've found that [The Well Grounded Rubyist](http://www.manning.com/black2/) is a thorough, bottom up intro to the language.
Lol at 4 space indent
Don't understand why it was ever a direct inheritance in the first place.....
Hmm... - Now and ever you could use Mercedes, kindly and freely presented for you. - No, I will build my own car with blackjack and bitches, cause your Mercedes is too `mainstream` for me. Sorry for a joke, but really: what functionality presents `return_bang!`, which could not be got by `throw/catch`? 
Speed Comparison with equivalent Sinatra app? (I am guessing that is the main competition)
Presto is doing about 4000 requests per second out of the box. Regard competition... well, Presto not aimed to compete with any framework. It is just a clean and fast way to do stuff. 
boycotception!
This looks really good, and I wonder how well it could work as a PAC framework. Good job on pushing something out, and good job on the website introduction.
My team and I found Formtastic absolutely abysmal to work with, once you go beyond "simple forms". I also found it easier to just drop the bootstrap.css file straight into `vendor/assets/stylesheets/` and call it from `application.css.scss` with `//= require bootstrap` than to use a gem.
I suggest you read the README here: http://docs.seattlerb.org/return_bang/ Perhaps the Testimonials section will clue you in on the true nature of this gem. :D
1) include ActiveRecord::Model. 2) puts MyClass.ancestors.inspect 3) Be enlightened.
The point is that thus far, ActiveRecord couldn't be a mixin. It means that in future, if inheritance makes sense for your domain model, you aren't constrained to putting a framework class at the root of your inheritance hierarchy.
Have you submitted this to ruby-core mailing list?
There's too much free content and cheap books on the internet. I'm not going to pay anything above $200 for a "workshop". Fucking scams.
I can understand the vehemence, but people's time is not free. For a 6 week in person course, $2800 isn't all that much. Particularly if you can get some big names to help teach it and one-on-one experience with a good teacher. As an example, I'm working through the Koans right now, and would love to be able to pull someone aside and discuss the advantages and disadvantages of using the "shovel" operator with strings.
This same kind of scam is happening in Chicago, but for $6,000: http://codeacademy.org/programs I get that some people like traditional classroom style learning, but these prices are ridiculous!
In the case of learning, people's time should be free. We're in what's called "Peak Programmer": More jobs than there are developers. If we don't find ways of boosting the number of programmers out there, we're going to have serious resource problems. Also, feel free to hit me up for such questions (@krainboltgreene on twitter, or me@kurtisrainboltgreene.name via email) Edit: I should have been clear that I wasn't specifically saying someone should, for free, give up 6 weeks to teach a class. Instead I would suggest free time, like with my time helping on Rails Hotline.
Much obliged for the offer for discussion. :) And while your first comment would be great in an ideal world, in the real world folks fall into two categories. The first is people like me: I can't afford to give away 6 weeks of my time for free. You ask me to teach something I know well to folks, and I need to get paid to continue to support my family. The second is people who can afford to speak or teach for free, but don't. One interesting case study for this second group, would be Neil Gaiman. &gt; As anyone who’s read the FAQ (which was written in 2002, thus the Clinton reference) or has been reading this blog for a while knows, if you want to hire me to come and talk somewhere, and people do, I’m expensive. Not just a bit pricy. Really expensive. &gt; The main reason I got a speaking agency, ten years ago, was because too many requests for me to come and speak were coming in. And the speaking requests were, and are, a distraction from what I ought to be doing, which is writing. So rather than say no, we’ve always priced me high. Not Tony Blair high, or Sarah Palin high (last time I read about them, they’re about $400,000 and $150,000 respectively). But I’m at the top end of what it costs to bring an author who should be home writing and does not really want a second career as a public speaker to your event. [source](http://journal.neilgaiman.com/2010/05/political-football-in-teacup.html) Plug in programming for writing, and you have a fairly convincing (at least from my point of view) argument for why someone's time shouldn't be free, even if they can afford to let it be so.
The local university offers a 9 month extension course for about that price. Unless its full time for 6 weeks that's a ridiculous price.
Some people learn better in a classroom setting than with books and online resources. I find it helps to be able to have someone help you without feeling like you are bugging people online. If people want to pay $2000 for a class, let them. It's their (or their company's) money. It's quotes like this which annoy me... &gt;One user, Dave Newton, wrote: “In any case, I’m done–nyc.rb is pretty much ruined for me, before my first in-person meetup, before I had a chance to contribute back.” So he's going to get all pissy because a company wants to provide a service to teach people ruby/rails? Grow the f up fella.
Really? I'm happy to answer questions and help others, but if you're asking me to come up with a course and then teach it, I won't do it for free... I'd rather just work on my own problems and teach myself more while getting paid for it.
I read that as the conflict, not the company offering the course, prompted him to depart.
Ahh - thank you for that - That makes way more sense... In which case I'm in 100% agreement with him. 
ummm, why is this a problem? I'm sure the devs are amazing at their work (art.sy and pivotal labs especially are legendary in the rails community), and 2800 is quite cheap anyway.
the word 'scam' is probably too strong. i'd only consider it a scam if they are misrepresenting what you receive for the money. if some one is aware of what they are getting, and willing to pay what's asked, then it's not a scam.
I think this is partly to do with ruby, and rails, position in the market right now. The idea of a company paying real money for rails lessons for staff seems a bit ridiculous because rails just isn't that sort of framework, or at least it certainly wasn't. It was the framework developers demanded to use against the wishes of their managers, because they just sort of loved it, and they got results fast. The idea that companies are now saying "hmmm hoo haa we need some rails developers in house, so lets send some guy out to learn rails so we can do teh rails" just feels weird. Because if you're not the sort of dev that can teach yourself rails, just don't bloody use it. It's not a necessary technology. And you're going to end up in a mess. If your company depends on a rails codebase, and your company doesn't have any hackers in it who would never consider a course like this, then you've fucked up somewhere along the way. **TLDR**; Rails doesn't have a (non-hacker-preference) problem domain that it owns. So using it is a matter of taste. If your devs aren't demanding to use it, don't. Therefore these courses are stupid. 
The koans take a bottom-up approach. Haven't barely touched control structures, but I've gone through strings, symbols &amp; other data structures in a fair bit of detail.
&gt;if some one is aware of what they are getting, and willing to pay what's asked That's kind of the issue. 6 grand was a full year of tuition for me, about three years ago. This code academy business actually seems like it might be, you know, more personally useful - but it's difficult to impossible to evaluate beforehand. For six grand, that class room better have less ~10 people.
who's the "we" who's going to be in trouble? The people you are asking to contribute their time for free (developers), are the people who _benefit_ from a programmer shortage in terms of their market value. (granted, we require a certain critical mass of smart rubyers to keep the community strong and keep the language alive, but at the moment we seem in no danger of losing that). I guess maybe the people wanting to _hire_ rails programmers are the ones you should be suggesting should be offering free classes to the public at large. (Personally, I don't think anyone who _knows how to program_ in another language needs a 6 week in person class in ruby (anyone!). But for a 6 week in person class, the price is not entirely unreasonable.)
&gt; Because if you're not the sort of dev that can teach yourself rails, just don't bloody use it. It's not a necessary technology. Ah, but what about the companies that have such products to support (perhaps internal products) but the staff who wrote them have left? If they can't hire someone who knows ruby, they've got to train someone who doesn't. Now, I do think if such a company thinks they can make someone into the right ruby developer with a 6-week class.... they're going to be in trouble no matter what. Someone who needs a 6 week in-person course to learn ruby is not going to be able to maintain their legacy products adequately after the 6 week course either. 
Exactly. As I said, if you've got a rails codebase and no-one who wouldn't turn up their nose at this course on staff, then you've got headaches in your future.
I can tell you this: they got a multiple of the number of applicants they were _hoping_ for at that price. People will charge what the market will bear. Not that CodeAcademy is that way; it's actually pretty close to 'costs,' and not a 'ripoff' in that the founders are taking away tons of cash. From what I understand.
Here in Australia, the cost for one course (e.g. 4 two days per week, one semester) is about $2500 at many universities (Monash, NSW, etc.). Also, there are some training companies here that charge about $2000-$3000 for a 3-day course. If I am not wrong, Oracle, IBM, Spring, JBoss and others have similar short term courses for similar prices. Is $2800 expensive? Yes, so expensive and I don't like it. Is it the norm? Yes.
"{hivemind} implies u think its a BAAAD idea for people to follow conventions in languages so as suchhh ive writtun this p0st in mY own unique style. sh4me EVERYONENE doesnt write like dis?" Yep. That's an English language equivalent of what non-standard code styling looks like to professional coders. And that's why it's not a good idea to actively avoid it because people who write like that wouldn't get hired by the New York Times any sooner than developers who ignore sane conventions.
&gt; Ignores pesky ensure blocks for when you really, really need to return Ok, this is difference. Excuse me for flood.
I agree that $2800 is a ridiculous price, but how is anyone "offended" by this? This is capitalism. Charge what you want, pay if you want. If they're charging too much, they won't make any money. Who cares?
Couldn't an argument be made (for the sake of discussion) that the inheritance resource should be used by whatever that class is? For example, if I have a Car class that inherits from the Vehicle class, then it is obvious that a Car is a Vehicle. It makes less sense to me to say the Car has all the functions of a Vehicle. Dropping the analogy, isn't everything that belongs in the model folder an ActiveRecord at it's core? Or, maybe another way of asking the same thing, if a model requires stuff from ActiveRecord, is there really going to be a more important class? Some class that is so important you would say it's that, instead of an ActiveRecord?
Doubrovkine... DRAGON BORN
Oh, no no no! This is a joke gem. You don't want to use exceptions, catch/throw or continuations as control flow. None of them are "better" than the others.
I've changed optimization strategy, please test it, if you found previous patches usefull.
I do agree that sometimes a good teacher on call is very handy. But, not that much!? That's ($2800 * 15 pupils) / (4 hrs per week * 6 weeks) = $1750 per hour, not lesson, hour. It seems there's two teachers, so $875. However good they are, I could live off that money for a month and a half. Obviously there are expenses, teaching materials, rent, etc. .. assuming they hold the classes in hotel Armani in Burj Khalifa, the price is about right.
&gt; "{hivemind} implies u think its a BAAAD idea for people to follow conventions in languages so as suchhh ive writtun this p0st in mY own unique style. sh4me EVERYONENE doesnt write like dis?" Bad analogy is bad. You've just made is less readable; I wasn't talking about arbitrarily modyfing the style but about making the code **more** readable. &gt; it's not a good idea to actively avoid it because people who write like that wouldn't get hired by the New York Times You're saying that I won't get hired only because I prefer more readable 4 space indentation? I think you're on crack. &gt; any sooner than developers who ignore sane conventions. Sane? You don't seem to get my point, so [I've made this to explain it better](http://img585.imageshack.us/img585/356/rubyk.png).
Exactly! It is a free market. Plus by attending a class you develop relationships with other students. Beyond all of that many Ruby programmers could use professional help. 
$2800 is peanuts. Seriously you can pay that much for a one week course for specialized development systems. 
You really have no idea how capitalism works, do you? Things don't cost what you think they should. They cost what people will pay. The course is sold out. QED.
How dare someone do something that doesn't affect me in the slightest!
Then help organize cheap (or free) Ruby classes.
I think you got the wrong link there!
Nope, born and raised a communist :-P. But I do understand the difference between cost and prize .. and that one can profit from another's stupidity .. that doesn't make the price any less outrageous though. And, IMHO, nor does it make it right to ask such a prize for a course that is probably not much better than a $100 one. But, in case it's not obvious, I fully support their right to ask whatever prize they like. But it still doesn't make it less outrageous, less greedy .. or right. (And if you say there's no "right" in capitalism, sure, but there is a "right" being human, without which, in my opinion, life doesn't make much sense.)
That's what I mean by "you have no idea how capitalism works". If you honestly think that these people are somehow doing something immoral by selling a product in good faith for what people are willing to pay, I guess we will just have to agree to disagree. Haters will of course continue their stated course of action regardless.
Yeah, I kinda do .. so ok, let's do that :).
[This is the correct link](http://railstech.com/2011/12/peer-to-peer-chat-using-html5-web-socket-and-em-websocket/)
Damn it, for a second there, I thought I could do P2P chat with one line.
yeah same ;-)
 "SEOmoz PRO" is the one of weirdest product names ever. But useful technique, thanks. 
Quite an interesting and good read.
&gt; Dropping the analogy, isn't everything that belongs in the model folder an ActiveRecord at it's core? Only if every single model class has serialisation as its primary functionality. That's just not true in general. The job of the model is to, well, *model* the domain. Serialisation is mostly a red herring, and in the specific case of ActiveRecord, can actively get in the way. AR puts restrictions on inheritance that might well make no sense whatsoever for your domain. &gt; Or, maybe another way of asking the same thing, if a model requires stuff from ActiveRecord, is there really going to be a more important class? If a class requires stuff from ActiveRecord, then you're making the statement that the thing being modelled is a database row. Following the Single Responsibility Principle, that class shouldn't be doing anything else, so no, there isn't going to be a more important class. &gt; Some class that is so important you would say it's that, instead of an ActiveRecord? If I have class User &lt; Person, there are *very* few domains I could be modelling where having a method called User#destroy makes sense. However, it *might* make sense to do this: class Person; end class User &lt; Person; end class SerialisedUser &lt; User include ActiveRecord::Model end Or even: user = User.new user.extend( ActiveRecord::Model ) user.save # or whatever That way you can test all User's functionality without AR's overhead, and as long as you make sure SerialisedUser obeys Liskov Substitution, everything will Just Work.
I recently attended a three day Ruby class that cost close to $2000. It was worth every penny even though I've been a developer for 10 years. Here's my reasoning for paying money for training. * experts show you the right way to do things immediately * The class was taught by Dave Thomas (author of The Pragmatic Programmer) and Jim Weirich (the guy who wrote Rake). Having access to them for three days to bounce questions off of is worth the money * getting training on the basics gives you more time to research problems to solve within your specific domain * a training class helps you avoid the translation problem if you're coming from another language. I often see people solve a problem first in the language they're comfortable with and then port it to Ruby. In a class, you're immersed in the language and have the instructors to help so you avoid the translation problem
SEOmoz has a HUUUUGE amount of brand recognition in the SEO industry. They're one of the few people who actually knows wtf SEO actually is and how to do it correctly.
&gt; and I don’t know of a way in rails to route identical requests to different controllers based on a feature flag on the current user record. You could do this with one of the constraints classes: class SomeConstraint def self.matches?(request) # request.session[:user_id]... end end root :to =&gt; 'controller#index', :constraints =&gt; SomeConstraint
The problem I have with all these tutorial sites is they just explain basics. Once you understand the built-in functions you can run on an object, how to build classes, etc etc, what can you really do? Anything practical requires extra gems and knowing how to use them. THIS is what I want to see. I am a web developer (the HTML/CSS/JS type) who used to do PHP and Perl back in the day. I want to learn how to use Ruby to build websites (handle form data, query databases, all that good stuff). The tutorials for Rails I have found online are outdated, error-prone, or both. I discovered Sinatra, which seems like a sleeker version. I believe DataMapper is the best DB gem to use. The issue is I have to reference Ruby documentation, and Sinatra documentation, and DataMapper documentation. I would love to see a tutorial put all of this together in one nice example website. [/soapbox] 
Have you tried using a Java adapter? I'm curious if you have and what the perf diff was
java adapter? 
I personally prefer vim, but if your only complaint about RubyMine is its memory usage, it's definitely worth it. Your computer probably has 4-8GB of RAM. Pretty sure you can spare 600MB to use the editor you want to use.
I have a MBA, so it maxes out at 4GB. This poses a problem if I'm also running JVM based web sites locally. I.e. the things I work on :)
The shovel operator( &lt;&lt; ) modifies the string in place, as compared to += which instantiates a new object, there are no disadvantages to using it.
Seriously? Even with 4GB, your JVM-based web sites make you so strapped for memory that 600mb is too much to spare? I've never run a JVM-based web site on my computer, but they must use WAY more RAM than Rails on regular C Ruby.
Yup. It's an amazing IDE and I use it whenever I can, but on bigger projects it eventually caps out available RAM and becomes useless. I assume that the tradeoff for being fast and having decent autocomplete and linking is that it has to maintain massive indexes. Not really scalable.
I have answered at SO. Hope it helps!
Nice. But personally I'd actually prefer what they ended up doing instead. 
they do use way more ram than MRI. I have a site and an API, separate ruby apps. I'm currently running 1 of them, RubyMine, Firefox, Chrome, and some standard mac apps. With 4GB of RAM, I only have 148MB free. I literally can't start the other rails app on the JVM or I'll run out of memory. 
Wow, that's nuts.
That's odd. I thought JRuby was supposed to be better at GC than MRI?
Keeping indexes in memory at all is usually a very, very, bad idea.
I'm assuming that's what's eating up all the memory. If not, what else?
being better at GC doesn't mean using less memory
I have heard good things about Jetty. 
It's a Java application. By default that carries a 400mb RAM usage minimum. :)
I've worked with rubymine in a pc with only 1 gb ram on linux..this worked really well...actually much more fluid than eclipse or netbeans...now I'm using aquamacs for small scripts..I only hate the long time for started rubymine...
What about the fact that it also modifies other references to that string? Perhaps it's just my background, but silently modifying other references seems like it could be a great source of bugs. def test_the_shovel_operator_modifies_the_original_string original_string = "Hello, " hi = original_string there = "World" hi &lt;&lt; there assert_equal "Hello, World", original_string end
I'm not sure what else you expect it to do since there is no assignment, naturally it has side effects. If you want to create a new object then be explicit with hi = hi + there; There is no 'modifying other references.' There is only modifying the object. += is bullshit though, don't use it :)
That's definitely a real problem for everyone with only 768MB of RAM.
I have 4GB of RAM and I can't have RubyMine, firefox, chrome, and two jruby web apps all open at once or i'll run out. I think that's a real problem. 
Okay, on the one hand I get what you're saying here. On the other hand... No, you're wrong. Better garbage collection means either more efficient or more thorough freeing of memory, which directly corresponds to total memory use.
I rarely have free memory and I have 8gb .. I've never worried about not having any free. If it needs more it swaps out the lesser used apps to cache
Nope, you are wrong. The JVM GC is better because it doesn't slow down the performance of your app as much as the MRI GC does. Also, JRuby uses more memory for reasons other than the GC. 
What OS are you on? On OS X it's painful when it starts swapping. I'll cmd-tab to switch apps and it will pause for a couple of seconds if it has to page in something. This slows me down, so I avoid paging to swap like it's the plague. Maybe other OSes do it better? Maybe i'm anal about pauses? 
I stand humbly corrected. A garbage collection system, much like an employee, can be considered "better" for more reasons than simply being smarter and faster - "plays well with others" being the clincher. I was starting to logically sort this out but prematurely ejaculated the previous post before I was finished. /contrite
law of conservation of quality? Ha, it's more like law of entropic guaranteed degradation of quality over time. 
No worries, I do the same all the time :)
[MBA?](http://en.wikipedia.org/wiki/Mba) You could try getting your local [A+ kid](http://en.wikipedia.org/wiki/A%2B_certification#A.2B_certification) to give you a hand with that.
Help me with this: Let's say I have an app that will use one of several different interfaces to a server. It won't know until runtime which interface it needs to use, but loading all of the interfaces at once will DRASTICALLY slow down the startup time. What can I do? Generally, situations like these boil down to: if interface1 then Int1.new else Int2.new What's a guy to do?
I thought JVM based web sites saved you memory because they ran each site inside of a thread and all of rails and your common libraries were shared.
Not really. RJS was in older versions of Rails, and was universally considered a bad idea.
why is it a bad idea?
It results in really, really bad JS. If you want Javascript, just write code in Coffescript (haha!). The new 'unobtrusive JS' model is infinitely better than RJS ever was, for multiple reasons.
I don't know of any general-purpose ones. I wrote a [prototype of a Ruby to Riak Map-Reduce JS compiler](https://gist.github.com/1320752#file_qria.rb) once, and it wasn't too hard, but it's also terribly incomplete. If you're suffering with js, look up coffeescript.
&gt; many Ruby programmers could use professional help. Hee hee
Fwiw RJS wasn't a Ruby to JavaScript compiler. It was a Rails specific way of generating the bits of JavaScript needed to do things like simple Ajax requests without having to write JavaScript. 
Ha. Wait till he gets to lisp where there is no decoupling code from data. His head will explode.
Every example he cites is simply a problem of the programmer, not of ActiveRecord, Rails, or Ruby. "200 line controller method", that is just a bad programmer. I would go so far as to say that Rails goes out of its way to make it easy to decompose code into nicely encapsulated small methods. But you could do the same thing in any language, in any framework. Bad article because it starts from a bad premise.
&gt;It took me two and a half years to realize that Ruby classes in the models folder don't have to inherit from ActiveRecord::Base. That is a problem. So while I'm sure this guy has his strengths, I'm not sure it's going to be wise to follow his advice in this article.
... right. It compiles a subset of Ruby to JavaScript.
I already code in Lisp, thanks. You misunderstand my point.
Rails' bad design forces you to write bad code. Controllers pass global state to views, no matter if they're 1 line or 200. AR forces you to combine logic and persistance. You can fight it, and I do, but Rails encourages bad code.
Always take every post with a grain of salt. I think my credentials speak for themselves. Anyone who pretends to be perfect is a liar.
I don't disagree with anything you said here, but I don't see what relevance your 'credentials' have.
You're suggesting that my advice shouldn't be followed because I don't know what I'm doing. I submit that I do.
Edit: You can, of course, use threads with MRI as well. They can, but it depends. Normally you run a bunch of processes to handle requests with MRI Ruby. But, if you're site doesn't get a ton of traffic you can get away with running 3. At that level you are probably using less memory with MRI, but once you go beyond that you'll save memory by using threads. But there's a big problem with using threads, a lot of ruby libraries aren't thread safe. You have to be very careful and selective. 
&gt; What I'd really like to see is Rails adopting a 'ViewModel + templates' system, with logic-less templates and presenter-esque models that represent the views. I think "Cells" might be part of the path to solution here. Cells are pretty much ViewModels, use a non-powerful templating language like mustache with em.... how's that?
Again, I don't see what relevance your 'credentials' have, and you have done nothing to explain that. Further, I **actually** suggested that you probably do know what you're doing, in some areas, but that people may want to be skeptical of this particular article. Finally, "I submit that I do" is not very convincing, for reasons which should be obvious.
Hash.new is useful for when you need to specify a default value or block that will produce a default value. I more often than not need a default valued hash.
I was kidding. I enjoy your blog, btw.
I think there's a distinction between encouraging "bad code" for a new rails developer and the platform being fundamentally flawed. It's true that if your new to rails you probably write some pretty bad rails code, but I'd suspect the same could be said of any platform. Most of the more experienced guys I know recognize the value of breaking things up into services instead of leaving all of their logic in the model (or worse the controller.) If the coupling of AR bothers you there's always other options like datamapper. Personally I'm willing to make a trade off in design purity for convenience when it comes to AR but I know some folks/systems where this isn't a good option. That said i simply can't refute the assertion that AR violations SRP, it does, it's just something you decide to be ok with if you like pattern. It's also my experience that the notion of a viewmodel is starting to become more popular. It may not be called that explicitly but when you pre-package all your data to keep your templates down to nothing but prints and the occasional looping partial that's pretty much what it is. The Dijkstra "quote" is interesting though. I'm currently teaching 2 classic MS devs how to build apps in rails. We're very much at the 15 min-blog level of understanding and I wonder how you get over that hump of "here's how rails does it" to "here's how a good OO programmer does it." I think rails used to encourage bad code, but today it's so customizable that you can do better if you go beyond the basics. 
Tone on the internet is hard. :/ thanks!
You can always overcome obstacles with good practices. I want my framework to help me, not hurt me. Get Avdi's "Objects on Rails". It answers your question.
I threw a solid state into my mbp. To be honest since then I have never noticed any pauses or hiccups. Fwiw I usually have 2 parallels instances running (2 gb dedicated each), safari, Firefox,chrome,mysqlworkbench,sublime text 2 and spotify. Free ram is usually in the 200mb range. That said, I bet it's because I use the same core apps always, rarely switching into other memory things, so most operations are in memory.
Kk. I'm apparently not communicating my point well.
Feel free to give it another go.
Cells are cool. Think 'a page is one big cell' though.
I'm on mobile. Give me a few hours. :)
Yea - sorry about that. I came off like a dick.
Absolutely zero offense taken.
right, but the guy admitted to not understand ruby classes despite using Rails for 2.5 years.
Rails was launched in 2004. Dijkstra died in 2002. Unless I'm missing something, he must've been a time traveling wizard. http://en.wikipedia.org/wiki/Edsger_W._Dijkstra http://en.wikipedia.org/wiki/Ruby_On_Rails
No, no he did not say any such thing. At least not in this article. Misunderstanding what Rails does with the models folder is not the same as misunderstanding his Ruby handles classes.
I really do agree with the bit about models not needing to inherit from ActiveRecord::Base. Not all your models are going to need to store data, or want to pull data from your database, I have quite a few models which inherit from an API which I use to query an API without storing the data locally.
alright, you're right. I wasn't giving him much credit, but I still think many of the issues he brings up are due to poor coding. 
*AR forces you to combine logic and persistance.* How is this a problem?
http://en.wikipedia.org/wiki/BASIC#The_IBM_PC.2C_and_compatibles (last paragraph) By "paraphrased" he means changed the wrath target i guess 
you know, my MBA is new, so I haven't tried it with the SSD. On my old MBP I got into the habit of ensuring I never let it swap. I'll try today and see if it isn't a big deal anymore with the SSD. 
I think that was a joke. |Edsger W. Dijkstra (paraphrased)
First and foremost, you are just wrong. Let's talk about why. - Controllers pass global state to views. Wrong. Instance variables in the controllers are not global state. Views are bound to the context of the calling method, which is why you have access to those variables. This is just basic CS. You're rendering the view inside of the environment you setup in the controller. That's not a problem, but if you want you can easily pass all of your data as locals to the rendered view and not use instance variables at all. If you aren't doing that, and you feel that it's a bad practice to use instance variables from the controller, why aren't you improving your practice? - AR forces you to combine logic and persistence Actually, given that the persistence is almost completely abstracted away from the code you write in most AR models, this is fucking awesome. You tightly bind the relevant code, logic, and operations on your data to the definitions of that data. That is really fucking good design. No need to pollute a larger namespace with code to operate on data you pass to it, and it creates a beautiful encapsulation. The only decent argument I see against AR that comes up regularly is the "implicit schema" vs. the "explicit schema" of other ORMs, to which I say both sides make a strong argument. The one you've laid out is not.
"Most of the more experienced guys I know recognize the value of breaking things up into services instead of leaving all of their logic in the model (or worse the controller.) " Can you explain where the logic is going to wind up if you take it out of the model or controller and put it into a service? In my experience it winds up in the controllers or models of that particular service.
You're only looking at the time they are teaching, not the time it takes to prepare the material and review/grade homework if there is any.
agreed. Also, rails devs are extremely hard to come by in NYC right now. It's to the point now where it's better to hire someone with a strong CS background and teach them ROR than to interview another self-taught Rails dev who can't tell you the difference between a stack and a queue. 
This is a problem with people now thinking "Model =&gt; Something that gets saved to a relational database". A model is a data abstraction, it's not a packaged row in a database. The model can be backed by literally anything you want to store data to (including pure memory). There's nothing wrong with models not inheriting from ActiveRecord::Base, the models directory was never meant to be the ActiveRecord directory. I blame people just doing a flyby on the topics and then claiming to be experts.
Sounds like you problem would be solved if you didn't use java. No chance of getting those on a remote machine and then developing on C ruby until deployment?
&gt; Rails is kinda getting old these days. It's no longer the new and shiny Strongly disagree. Rails is constantly evolving, and 3.1 is amazing. &gt; ... it's lead Rails developers to build huge, monolithic models that are hard to test I've never struggled writing lots of tests for large models... &gt; Ruby classes in the models folder don't have to inherit from ActiveRecord::Base. That is a problem. I've put ActiveResource classes in `app/models`. But you don't have to put things there! Create whatever subfolder you like in `app/`, or put it in `lib/` &gt; Have you ever seen a 200 line long controller method? Poor coding. &gt; "... just promote your data to a global" I'd be crucified. Yet we do the same thing Instance variables are not global... ? &gt; ... logic in templates leads to all kinds of problems. They're hard to test, they're hard to read I've never had any problem testing a view. If the logic gets complex, we abstract it into a testable helper method. And it's also useful to have integration / acceptance tests. &gt; ... would require some really serious changes. It'd involve re-architecting large portions of things that people classically identify with Rails... Rails is opinionated software. Love it or leave it.
"developing on C ruby until deployment" Edit: we're developing on C ruby until we go live, then we're switching over. this is actually our plan. The downside is that it's a bit more work to ensure everything works on both C ruby and JRuby. Having said that, it's absolutely amazing to be able to use ruby so easily on both platforms. 
It doesn't force you; I use Tilt to compile most of my templates.
I may be mistaken but I think he means a different service than you think. I read that as "service objects" not "web services". If you are unfamiliar with the term, it's basically an object which wraps/delegates/mixes-in with other objects to provide extra service. E.g. you might have a service object for "placing an order" which coordinates a number of "dumb" models.
Well, for one, it's a pretty massive violation of single responsibility... But specifically, you end up putting process logic into models, not data logic. I think validation logic in the models is acceptable (in a lot of cases, anyway), but the logic for how that model might be used in different contexts does not ALL belong in the same class.
I'm currently doing that on http://kiwoos.com , actually, using mustache. Still, I would not say it's a must-do, it's just the best solution imo to do some client/server side template sharing.
Hmm... I am familiar with service objects, but more in the case of data transformations on heterogeneous objects, or sets of homogeneous objects that have different possible transformations for different needs (XML generation is something that I have to abstract out into basically a wrapper that can be configured for different demands). I did not read it that way, but I can see how it could be interpreted to mean that.
Good find. I guess it was just a really obscure joke then.
The implicit passing of instance variables to views is a constant headache for me. There is no clear description of what is required to render a view, and it's very hard to track down all potential instance variables created in an action, or which are actually used by the views and partials. It isn't a compelling argument to write it off by saying that teams need to simply have more discipline with these things. 
You can't change the target of criticism in a quote from a respected computer scientist and call it *paraphrased*. The real quote is: &gt;It is practically impossible to teach good programming to students that have had a prior exposure to **BASIC**: as potential programmers they are mentally mutilated beyond hope of regeneration.
*it's a pretty massive violation of single responsibility...* Is this really more a violation of CS principles than anything that affects the end product?
&gt; You tightly bind the relevant code, logic, and operations on your data to the definitions of that data. That is really fucking good design. No need to pollute a larger namespace with code to operate on data you pass to it, and it creates a beautiful encapsulation. ... until you need to serialize your model to something other than a database. I suggest you read the other database pattern chapters in Fowlers "Patterns of Enterprise Application Architecture" that active record comes from - it outlines the tradeoffs between active record and several other ORM patterns.
&gt; If the coupling of AR bothers you there's always other options like datamapper. Contrary to what the name might indicate, Datamapper doesn't implement the datamapper pattern, but actually is just another implementation of the active record pattern, and so has the same issue of combining the model and persistence. 
Read it. In the case of data serialization to I often create an external object that walks a tree of objects and serializes them applying the proper transformations. The differing needs of clients means generating serialized output is just not a responsibility that belongs directly on the data object itself, and it's not required that you treat it as such. However, the fact that the code to pull out specific parts of you data objects is bound tightly to the object itself is a huge win, rather than having to write all that code in the external wrapper.
I have worked on Rails for 5 years and this has never been a problem for me. I'm not sure what the code base is doing that you work on, but it is pretty straight-forward to understand the rendering code, and if you really wanted to prevent instance variables from being passed down, you could just patch it for your project to render the view with a different context and require passing of all variables as locals. I'm not saying you should do this, but if you really have a problem keeping track of instance variables in your controllers when the view is rendered, it's an option. The easier option is to just not use instance variables and require locals in your views. That requires discipline though by all members of the team.
I've been doing rails for over 6 years. I never had a problem with this until I started working on rails projects with larger teams, some of whom have never done rails before. Here's what happens, they see that they are doing the same basic thing in a handful of controllers so they want to DRY it up. They move some code into application.rb or a module that they mix into a few different controllers. This code sets up instance variables that the views use. Do this 3 or 4 times and it becomes very unclear what is needed to render a view and where it is coming from. Throw in a few before filters and it gets hairier. Explicitly passing data to views makes a lot more sense for larger code bases, it makes the code a little longer for really simple code bases. I care more about the former than the latter. 
I'm not sure I understand the question. I don't want to presuppose what you meant, but it sounds like you are saying "does it matter if it doesn't affect the end product?". If that's what you mean, absofrickinglutely it does. Maintainability is paramount to continuing to deliver quality in the end product and fixing problems/behaviours that negatively affect its users. If you've never seen how these types of coupling affects the maintainability of (or better put, ease and pleasure to work with) a large code base, I put forth that you haven't worked on big enough Rails apps or with large enough teams. If my assumption of your commend was misplaced, then by all means clarify and I'll try to respond
Then I suggest you read it again. There's absolutely *zero* reason why you need to "write all that code in the external wrapper". The logic that AR uses to serialize the models would work equally well if it was generated in separate mapper classes, with no need for it to require the developer to write any extra code at all in the default case. If you believe it requires writing extra code, you lack fantasy - the same dynamic nature of Ruby classes that makes all the "magic" in Ruby ORMs possible in the first case makes it trivial to generate separate mappers instead of injecting all that crap into the models. But decoupling the model and mapping achieves one very important thing: When you save or create a model object, you're explicit about how it gets created or saved (by picking the persistance mechanism). Active record (the pattern) is a simplistic model that sort-of works for simple scenarios, but the moment you have multiple repositories for data, it causes all kind of nasty inconsistencies in your APIs because you monopolize the model API for a single repository at a time. 
I don't have anything to prove, I'm just asking what the practical effect of this is. "Maintainability" is rather nebulous, and I've seen CS-trained people write some bad things indeed. Furthermore, is SRP subject to the same gray areas that encapsulation and inheritance are?
Sure... people will always have different interpretations of what a single responsibility is, but if everyone aims to break down responsibilities into the smallest reasonable pieces, then, in theory, we trend towards better design. If you are interested in removing the nebulous aspect of good design, I highly recommend Clean Code (either the book or the screencasts). Uncle Bob's emphatic style can be ... interesting (for me, slightly off-putting) ... but the content is rock-solid.
Really? The magic code that transforms the data for a client who wants XML with fields X,Y,and Z vs. a client who wants JSON with fields A, B, and C, while transforming D into another value, will just write itself? I could mix that in via other modules to decouple that logic from the model as well, but man, if that code to generate those two different outputs lives in the same process I hope you're very careful about the order you mix things in, because it just won't work with the way modules are added to the inheritance lookup chain. I don't really understand what you're trying to say. Your example doesn't make any sense, so maybe I just don't understand what you're trying to say. *** It seems to me you are talking about 1 of 2 scenarios: 1. You have a model you want to persist to multiple datastores. Maybe a relational database, an in-memory store, and something else? I don't know. It seems like an unusual use case except where caching comes into play, and marshaling to a caching system is a pretty well defined interface. 2. You have some models coming from a relational database, and then some from other type of store... document store, memory-mapped file, whatever. There's no reason all your models have to derive from the same persistence mechanism. 
Then just pass everything as locals and make that a policy for your team. I've worked on many large Rails projects as well as fixed bugs and submitted patches to the core project and this has just never been an issue for me. Even using things like Engines (or Desert back in the Rails 1/2 days) I never came across a case where it stepped on my feet. If you have this problem though, the mechanism is there for you to take advantage of.
&gt; The implicit passing of instance variables to views is a constant headache for me. There is no implicit passing of variables. If you want to disable one of the class vars, then comment it out. It's all defined in the controller.
Yeah.. everyone should program in binary. None of these shortcuts!
"this has just never been an issue for me." I hope you understand that that doesn't mean it isn't an issue. "Then just pass everything as locals and make that a policy for your team" We have, but this isn't a good argument for doing things the way they are done. 
I'm not sure if you are just being a pedant, or if you really don't understand my point. implicit: Implied though not plainly expressed The data needed to render a view is not plainly expressed in rails. 
My problem is that there is nothing inherently wrong with the mechanism the way it is if you understand how rendering is done. In the case of ERB, which I use because it's the out of the box template engine, ERB is rendered in a context. That context is the environment you setup in your controller. It makes sense, it's deterministic. To me it's the case of "you have these tools, use them in a responsible manner". It's like people who say "you should never use eval". That's ridiculous. I realize that other people may have this problem, but it becomes an issue of working together as a team to come up with good policies that make sense for your code. It's not a problem with the mechanism, but with the way people are writing code on top of it.
Well sure.. you have to understand how rails works in order to know about that kind of stuff. But then, that's kinda how all frameworks work.
"It's not a problem with the mechanism, but with the way people are writing code on top of it." The mechanism can make doing things the right way the default or it can make it hard to do things poorly . I don't think this particular mechanism does that, and I think it could. 
You're still missing the point. 
Explain it to me.
given the implicit way data from controllers is used in views it can easily become hard to figure out what data is needed to render a view and where it is coming from. I think that data should be explicitly passed to the views. Yes, this will make simple code bases more verbose, but it will also make large code easier to maintain over the long run. 
What is your alternative solution?
If you don't know how rails works, then I can see your point. But if you want to know what vars are being defined for a particular view, just go look at the method for that view in the controller. Keeping data separate from UI is essential in scaling and code maintenance. 
Yeah, major WTF. &gt; SOPA will destroy the Internet as we know it. &gt; – Thomas Jefferson (paraphrased)
On my current project we're using mustache so we can render views both server and client side. This requires us to be much more explicit with the data used by the views. So far it's working well, but we've only been using it for about a month. Maybe some pitfalls will become apparent as we get farther into it. 
I disagree with most of his post. Yeah, the different rails components give you the possibility of writing REALLY crappy code, just like almost ANY other programming language/framework. If you have huge models you are doing it wrong, if you have 200 lines of code methods in a controller you are doing it wrong, if you don't consider if you need a database persisted object as opposed to just a class to handle logic on certain objects you are doing it wrong. if you cram up your views with logic you are doing it very wrong. The poblem is not our tools, the problem is - and will always will be - crappy coding practices and half assed attempts at following them. EDIT: I know this probably sounds harsh, but I am in no way attacking whoever wrote this, I just want to put things in perspective, my logic is the same as "guns don't kill people, people kill people" :)
What data does the view need? class PostsController &lt; PortalController include Searchables before_filter :authenticate before_filter :searchatize def show @posts = Post.all super respond_to do |format| ... end end end
I think you misspelled "bad joke"
@posts is available. Go nuts.
Are you sure that's all it needs? I see at least 4 other places that might be creating instance variables that the view might need. 
Needs or can use? By default, rails only has a single instance variable for each view. Adding more is your own choice. You can make any code as complex or as simple as you want.
Possibly stupid question: What are the 4 other places? 
You're still missing the point, and I won't keep explaining it. "By default, rails only has a single instance variable for each view" Nope. 
the two before filters, application_controller.rb (this is implicit), and the call to super. There's actually more, PortalController could be have filters, etc, etc. It can become a giant pain to figure out what a view needs and where it comes from. 
But wouldn't it be better to put stuff like authentication information into a partial using a helper method? Authentication information has nothing to do with showing posts.
Maybe, but that doesn't affect my point. 
Maybe I just need a more specific example. What is something that would be specific/important to a view that wouldn't be defined in the corresponding action and couldn't be loaded using a partial/helper?
I think it's common wisdom that you shouldn't load things in partials or helpers. "What is something that would be specific/important to a view that wouldn't be defined in the corresponding action" My current project has what we call properties (think Spiderman). The action simply gets the property object and sets it to an instance variable, but the page has all kinds of stuff. There are a bunch of filters one can use for searching and things like movies, books, characters, games, activities, etc related to Spiderman. This data comes from a bunch of different internal REST services and not a local db. Now if you go to a Character page it will also have all of these things related to the character. Rather than repeating the code to fetch all this stuff in each action, we break it out into filters, mixins, etc. In short, you can't look at the action and see the stuff that's needed. 
&gt; Really? The magic code that transforms the data for a client who wants XML with fields X,Y,and Z vs. a client who wants JSON with fields A, B, and C, while transforming D into another value, will just write itself? You're entirely missing the point. When you write AR models, you only write much code for mapping from the database schema to the model when there are discrepancies between the database schema and the expectations AR has about how the structure of a model should map to a database. Other than that you add some minor declarations about the relationships of the data. There is no reason any of this needs to 1) be in the model classes, as opposed in mapper classes, 2) why there need to be any more per-model code than there currently is in order to generate persistence methods in mapper classes rather than in the model classes directly. The big advantage of pulling this out of mapper classes is that meddling with the model classes means that if you have two different persistence methods and one of them have already added a "save" method to your model classes the other one needs to use a different method. So you end up with multiple divergent API's for the same logical operation. It is ugly and inconsistent, and means your code need to understand multiple different ways of manipulating model objects even for parts of your code that has no reason to know where it is persisting something. It's massively increases coupling. It makes testing harder. It's just overall bad practice, and it doesn't actually save you any effort. &gt; You have a model you want to persist to multiple datastores. Maybe a relational database, an in-memory store, and something else? I don't know. It seems like an unusual use case except where caching comes into play, and marshaling to a caching system is a pretty well defined interface. Yes, persisting or loading to/from multiple sinks or sources, except it's not limited just to datastores and not at all unusual. Loading data from external XML files. Taking data from HTTP requests. Returning data via APIs. Dumping to CSV files. Putting data into a cache. Passing data to an external API. In most complex systems, models get instantiated from different sources, stored to different sinks, or passed around all the time - or would do if the weren't so closely tied to a persistence mechanism that people end up muddying the waters by putting code that transforms them to something else all over the place instead of cleanly encapsulating it. It's a rare system that doesn't sooner or later grow to a stage where model data doesn't at some point or other get created from something other than a database or passed along to something other than a database. 
I don't think he knows what paraphrased means.
&gt; ActiveRecord's greatest strength is also its problem: Tying class names to table names. The DataMapper pattern is being implemented in [DataMapper 2](https://github.com/datamapper/dm-core/wiki/Roadmap) using [veritas](https://github.com/dkubb/veritas#readme) and [veritas-sql-generator](https://github.com/dkubb/veritas-sql-generator#readme). If your really interested, you could help out with integration and testing (the DM devs are pretty overworked). Another major difference between AR and DM, is that DM is declarative, meaning you can decompose common Model bits into [Modules](https://github.com/ronin-ruby/ronin/blob/master/lib/ronin/model/has_license.rb#L37-47). &gt; It took me two and a half years to realize that Ruby classes in the models folder don't have to inherit from ActiveRecord::Base. The classical symptoms of Rails tunnel vision. Non Rails/ActiveRecord developers already know this (`DataMapper::Resource` is a module), especially when one starts using [dm-rails](https://github.com/datamapper/dm-rails#readme). &gt; ActionController relies on instance variables to pass information from the controller to the view. Have you ever seen a 200 line long controller method? Nope. You can decompose controller method logic into other methods (under the protected section of the Controller), or even Modules (sensing a pattern here). A 200 line Controller method is technical debt... kill it with fire or fire the original author. &gt; The whole idea of logic in templates leads to all kinds of problems. View Logic goes in Helper Modules (again with the Modules, like it's some sort of idiom?). Logic in Views is technical debt. &gt; What I'd really like to see is Rails adopting a 'ViewModel + templates' system, with logic-less templates and presenter-esque models that represent the views. I'd like to see this as well, but not coupled to Rails; so Rack/Sinatra/Padrino/etc apps could use it. &gt; the impedance mismatch between HTTP and MVC, for example, is pretty huge Yes! Sometimes I just want to [map paths to Model queries and return JSON](https://github.com/postmodern/rack-mapper#readme), I do not need MVC for that. WebMachine looks interesting, except it shoves a `WebMachine::Resource` base-class down your throats, the same problem with `ActiveRecord::Base`. Please, Ruby library authors, **just use modules**. I think the pain points you list are the result of Rails developers who are stuck thinking in terms of Rails and not Ruby Classes/Modules/Objects. However, I personally want a lighter mapping of HTTP -&gt; Data -&gt; Views.
Passing what ought to be arguments to views as controller instance variables is Rails fault. Among other things. But I'd suggest that part of what Rails is/was trying to show is that with the right framework architecture, it can encourage people to write good well architected maintainable code, even make it easier to do so than to write crappy code. And I think it actually _does_ to do that to some extent. But I think in fact saying "oh, yeah, most people who use Rails just write crappy code anyway" is actually sort of a failure of Rails, rather than a defense of it. I think Rails is pretty good, especially for the time it's architecture largely was designed. I also think the OP is right in identifying some of it's flaws. Of course we can say this only because of how much we learned from using Rails. I suspect if even DHH were to start from scratch today, he'd do some things differently.
&gt;But there's a big problem with using threads, a lot of ruby libraries aren't thread safe. Why would that be a problem if everything is running inside the same thread?
Why not? Even for a full page, I think cells may be in a better architectural direction than what Rails by default does. There is in fact no reason you couldn't use Cells as they are now for the full page, is there? It might need some fine tuning (does cells still pass arguments as ivars? If so, that can be changed), but I think if paired with a 'weak' templating system like mustache, it's in the direction you're talking about (I agree with your post, btw). If not, then identifying exactly why not might help clarify what something that was what you wanted would look like!
Nothing wrong with that, if you can manage to identify the right people. A good programmer (with or without a CS background, there are many ways to arrive at being a good programmer) can learn rails without a 6 week in person course. Heck, most of us did, and some of us are good programmers! Sure, there are self-taught people who are not good programmers. I'm sure there are also really not good programmers who went through that 6 week course. Or there soon will be. But it's totally true that getting the right person (who is a good programmer) is way more important than if they already know RoR or not. If they're good AND they know RoR, sure, that's great, but better to have someone good who doens't than someone bad who claims to (with or without a CS background, with or without a 6 week course, I don't think either of those are good predictors). A good programmer doesn't need it, and a bad programmer won't be sufficiently helped by it, is my hypothesis. With or without a CS background. 
because everything isn't running inside the same thread. Let's say I use HTTParty for fetching data from a REST service. In my rails controller I have HTTParty.get("http://blahblahblah") Is that threadsafe? 
Does a model neccesarily represent persistent data though? I kind of think it does, but I've had people try to convince me... well, I'm not sure what they were trying to convince me, maybe that just about anything that's not a controller or a view or a view helper module is a model. That doesnt' seem right. If 'model' is a useful concept, it's got to mean _something_, and I think it probably means a persistent data object (editable or not). 
&gt;because everything isn't running inside the same thread. But it is inside of the JVM. The JVM launches an instance of the ruby interpreter in an isolated thread. &gt; Let's say I use HTTParty for fetching data from a REST service. In my rails controller I have AFIK this is no different than running it inside of the MRI. As far as your app is concerned it has it's own interpreter.
But I suggest that the idea of a 'web framework', especially an 'opinionated' one like Rails, is that the right architecture can lead people to write better code. I think this is in fact part of the goal of Rails. You can think this is an unrealistic goal, but I personally think it actually is a worthwhile goal, and I even think Rails actually _has_ succeeded in that to a respectable extent. But as we try something, we learn from it, and I think the OP has mostly accurately identified some current pain points. One trick, though, is it's hard to fix things like this incrementally mostly backwards compatibly. And I think the Rails community (those who write the framework, those who use it, and those who are both) is probably not ready for another chunk of huge backwards-incompat changes after the pretty large effort the 3.x switch took. I know I'm not. 
&gt;Ruby classes in the models folder don't have to inherit from ActiveRecord::Base. That is a problem Why is this a problem? It would be a bigger problem if it was the other way around. &gt;logic in templates leads to all kinds of problems. They're hard to test, they're hard to read Logicless templates are even a bigger problem which is why there are so few of them around. &gt;ActiveRecord's greatest strength is also its problem: Tying class names to table names. This means that it's impossible to de-couple your persistence mechanism from your domain logic. This is factually incorrect. There is nothing forcing you to put your domain logic inside of your models. It's just one incorrect statement after another. While I am at it. Rails does not force you to use AR. You can use ruby DBI and write SQL statement all day long if you want. That's dumb of course but you can do it. 
"The JVM launches an instance of the ruby interpreter in an isolated thread." Then you aren't saving memory compared to MRI. 
Eh, not exactly. It's more like 'builder', no? You wouldn't say builder 'compiles ruby to XML'. More like a DSL for generating Javascript. But I agree it was a terrible idea. 
You are because you are loading ruby and rails just once.
Or even [Sequel](http://sequel.rubyforge.org/)
Thanks for point this out. I didn't even catch the “paraphrased” part. That's some BS.
"A data model in software engineering is an abstract model that documents and organizes the business data for communication between team members and is used as a plan for developing applications, specifically how data is stored and accessed." http://en.wikipedia.org/wiki/Data_model
We're in violent agreement here. ;)
Builders are a form of compiler. Regardless of the terminology, we all agree: bad idea.
This article makes me miss Merb. It was nice to have another opinionated framework to speed Ruby webapp framework development purely by compitition and differences. Rails, any more, should be one of the last things you learn in Ruby, would save a lot of people struggling through application design conflicts like this. PS: I'm not trying to discount Sinatra or any other Ruby web framework in the Merb statement above, just that Rails and Merb had a very unique relationship.
yeah, I def wouldn't call it a compiler. but, yeah. I'm not sure exactly what the OP was asking about, I don't think it was builder/rjs type stuff, but I dunno. If there's projects to actually cross-compile ruby to js, I don't know em. 
Looks like indeed current Cells implementation you can render directly from a controller no problem, as the entire page, presumably still getting a layout. I don't like the idea of HAVING to create a seperate class for every single page/action for the Cell/ViewModel in addition to the template though. Hm, maybe a sort of default Cell that does nothing but pass arguments straight through from controller to weak template, that can be created for a view automatically or with a one-liner in controller without a separate file? Just brainstorming. (I have never actually used Cells in a real project, just gone through the basic getting started examples a year or more ago. But I've read the documentation a few times and liked the idea; just didn't fit into my actual (legacy) projects for various reasons, yet.)
the common MRI servers fork for each process so they save the same memory via copy-on-write. 
Okay. So. I said, "It took me a really long time to realize that models don't always have to inherit from ActiveRecord. This is a failing of Rails." You said, "You made a mistake in the past? Better not listen to him in the future." That logic makes no sense to me. Everyone makes mistakes in their past. That lesson that I learned a few years ago is the entire reason that I'm where I am today, and I'm sharing that with you. Does this make more sense?
Word. I never used Merb, but I think I'd like it, sorta.
&gt; the different rails components give you the possibility of writing REALLY &gt; crappy code, just like almost ANY other programming language/framework. I'm making a stronger assertion than that; it actively encourages you to write crappy code. You can certainly overcome it! You can write awesome apps in PHP too, but you'll get no help. I want Rails to help me write good code.
That is not even close to anything I said.
Thanks for this, I've been looking for the _exact_ qoute but had no luck in finding it.
is this sarcasm? hmm..
You held up Steve's admission of a mistake as a mark against his competence, and now you're pretending that examples to the contrary are irrelevant. Stop being deliberately obtuse. 
Only REE has copy on write.
The situation here is a lot better than it used to be though. The separation of activemodel from activerecord helps a lot.
***CamilleRoux***: &gt;&amp;#91;2011/12/31&amp;#93;&amp;#91;11:04:47&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|ruby %2De %27def a;10.times{puts %22 %22*rand%2879%29+%22*%22};end;99.times{a;puts %22 %22*34+%22Happy New Year 2012%22;a;sleep 0.1;puts %22\e[2J%22}%27 'google translate this tweet'): ruby -e 'def a;10.times{puts " "&amp;#42;rand&amp;#40;79&amp;#41;+"&amp;#42;"};end;99.times{a;puts " "&amp;#42;34+"Happy New Year 2012";a;sleep 0.1;puts "&amp;#92;e&amp;#91;2J"}' [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/ruby/comments/nxfm0\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error') &amp;#91;Automated Edit&amp;#93;: It looks like I erroneously commented 1 extra times. I deleted those comments thanks to [*jlogsdon*](/user/jlogsdon 'thank you for the error report!')!
Someone can't take a joke. :-)
Apparently, like others with my Dijkstra joke, I didn't get it. My apologies.
s'ok - tone doesn't translate online very well
Agreed. There's some basic concepts that the article and indeed the programmer doesn't get. That's ok, except that he is criticizing Rails based on his lack of understanding. I don't claim to know a whole lot about Rails, but then.. I'm not writing an article to criticize it. :-)
Just realize that Rails doesn't *make* you do anything a certain way. I think that would go a long way in your criticisms of it. Don't like the way Rails does something? Do it your own way. Rails will let you do that.
ah, you are correct. I still have to get up to about 4 MRI processes before it uses more memory than the one JRuby process. 
Sure. That's not good enough. Rails' defaults used to lead the way into The Best Way to Build Apps; that's why you use an opinionated framework in the first place. I want to see it maintain that thought leadership.
10 Hey!! 20 BASIC was my first language, and I am now a very good programmer!
Do you have a suggestion of a better way to default than Rails has? It's one of the best framework structures I've ever come across.
Merb used to use DataMapper. Django basically uses ViewModels. That new Amber.js uses a derivative of Mustache for templating. &gt; It's one of the best framework structures I've ever come across. Exactly! Rails is state of the art web app design from 2006. It hasn't really changed much since then. We should be thinking about the best possible way to build web apps in 2012.
I know Clean Code, but so far the concerns here sound academic.
How about getting people to stop using php? How about improving the speed of rails and various APIs and DB interactions? How about making the bundle/gem/passenger whole thing to be stable? The problem right now with rails/ruby is that it changes too frequently and the changes are not backwards compatible.
Most deem the elusive "maintainability" concerns as academic until they feel the brunt of them being ignored.
Sure. Other people can work on those things. They're not things that I personally care about. &gt; The problem right now with rails/ruby is that it changes too frequently and the changes are not backwards compatible. Rails releases take a long time. I never really bought this complaint.
Compared to Perl and Python, Ruby is a spaz.
Last Ruby releases: 1. 1.8.7: May 31, 2008 2. 1.9.1: Jan 30, 2009 3. 1.9.2: August 18, 2010 4. 1.9.3: October 31, 2011 It's once a year. That's not very often. Compare that to [Python](http://www.python.org/getit/releases/). They're a little longer, but not that significantly.
In OO lingo "model" usually means a model of the reality your software works with. That often means it handles persistent data, but it can just as well handle transient data for example.
&gt;&gt;Ruby classes in the models folder don't have to inherit from ActiveRecord::Base. That is a problem &gt;Why is this a problem? It would be a bigger problem if it was the other way around. I *think* he means that the fact that it took him two and a half years to *realize* that is the problem. In the sense that while it is technically possible, almost nobody actually does that, due to how Rails is normally used. Or something... He may have meant something completely different, of course.
Firefox is unusable on Macs. It *never* returns any memory. Stick to Chrome unless when you specifically need FF. This may be part of your problem.
It's not the frequency of the releases.. it's the non-backward compatibility of them.
1.9.3 is backwards compatible with 1.9.2. 1.9.2 and 1.9.1 are close, `require_relative` being the biggest one. The 1.8.x series and the 1.9.x series shouldn't be backwards compatible.
For work yes, for my hobby sites I usually only need 2 with a varnish cache in front of it. 
***chriseppstein***: &gt;&amp;#91;2011/12/24&amp;#93;&amp;#91;19:49:10&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|ruby %2De%27a=%281..8%29.to%5Fa+[4]*3+[0];%28[%22\e[1\;36m%22]+a+[%22 \e[0mHave an upvote%22]+a.reverse%29.each{|i|puts %28Fixnum===i ? %28%22#%22*i*2%29 : i%29.center%2840%29}%27 'google translate this tweet'): ruby -e'a=&amp;#40;1..8&amp;#41;.to_a+&amp;#91;4&amp;#93;&amp;#42;3+&amp;#91;0&amp;#93;;&amp;#40;&amp;#91;"&amp;#92;e&amp;#91;1&amp;#92;;36m"&amp;#93;+a+&amp;#91;" &amp;#92;e&amp;#91;0mHave an upvote"&amp;#93;+a.reverse&amp;#41;.each{|i|puts &amp;#40;Fixnum===i ? &amp;#40;"&amp;#35;"&amp;#42;i&amp;#42;2&amp;#41; : i&amp;#41;.center&amp;#40;40&amp;#41;}' [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/ruby/comments/npejl\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error')
***CamilleRoux***: &gt;&amp;#91;2011/12/24&amp;#93;&amp;#91;14:18:13&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|ruby %2De %22%28%281..20%29.to%5Fa+[6]*4%29.each{|i|puts %28%27#%27*i*2%29.center%2880%29};puts;puts %27Merry Christmas%27.center%2880%29 #Ruby #Christmas %22 'google translate this tweet'): ruby -e "&amp;#40;&amp;#40;1..20&amp;#41;.to_a+&amp;#91;6&amp;#93;&amp;#42;4&amp;#41;.each{|i|puts &amp;#40;'&amp;#35;'&amp;#42;i&amp;#42;2&amp;#41;.center&amp;#40;80&amp;#41;};puts;puts 'Merry Christmas'.center&amp;#40;80&amp;#41; [*&amp;#35;Ruby*](https://twitter.com/search/%23Ruby 'twitter tag search') [*&amp;#35;Christmas*](https://twitter.com/search/%23Christmas 'twitter tag search') " [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/ruby/comments/np5by\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error')
I prefer stranger things than this, green nights ablaze with snow, the kiss rising slowly to the eyelids of the sea.
It was for me too, that's why I love the quote so much.
If my ignorance is so common, why can't the practical benefits be succinctly articulated? And the point isn't "maintainability," but AR as some monster of bad architecture. Also consider the history of the "considered harmful" trope.
Looking at the controller, there's no way to know what ivars are used by the view, and what ivars are just internal controller state. This is the "implicit". 
I largely agree with this OP. I do think the idea that it's somehow significantly better if AR were an 'include module' instead of an 'extend class' is.... misguided. Things are marginally better implemented as 'include', and apparently AR is headed that way anyway (maybe as soon as 3.2?), but it doesn't make _that_ much of a difference. 'include' of a very complex module has all almost all the same downsides as inheritance, mix-ins in ruby are pretty much just multiple inheritance of abstract classes. It's still basically "inheritance over composition". Using modules is perhaps marginally better, as it makes some complicated meta-programming type hackery easier when AR is involved. But it's not some huge win, if it took a whole lot of work to refactor to make this possible it's probably work that would have been better spent elsewhere, IMO. I think the fact that "AR should be a module not a class inheritance" is the thing that in this thread people agree with the _most_, while people are violently disagreeing with all the other points... is depressing. Apparently Rails can engender non-self-reflective non-critical cargo-cult-esque programmers just as much as anything else. If Rails does it that way, it _must_ be optimal, oh except I've been told that modules are always better than inheritance, so that must be true too. Grr. 
I certainly think we can do better. We can always do better. That's the main theme of the blog post, you know? :) I personally haven't found the transitions to be particularly painful. Then again, when the newer Rails comes out, I upgrade my app, so I'm rarely stuck with any large jumps. I did recently port a smallish app from 1.2 the whole way to 3.1, and it wasn't too bad.
I agree with you that the 1.8 to 1.9 transition AND the rails 2 to 3 transition were very painful, and that such a transition hopefully won't happen again for at least another few years. I'm not sure I agree that _every_ release of a language (or framework) must be backwards compat. That gets you... well, Java. It is a tightrope to walk, balancing innovation with backwards compat. In general, I think the Rails 2-&gt;3 transition was wholly needed and appropriate, even though it was painful. I just hope it doesn't need to happen again soon. I am a bit less enthused about the 1.8.x to 1.9.x transition -- some of the changes, despite being backwards-incompat were wholly needed and appropriate despite pain. Others of the changes, I'm not so sure they were worth it. (The big one, char encoding, I think the jury is still out on how well 1.9.x's approach works out, although it looks good on paper, once you start working with it, it can be hell). But either way, it's done, and _largely_ for the better.... and I hope it doesn't happen again for at least several years. 
My god. Good lord, I love you, Tweet Poster Bot. 
Jeez, and I had just read those other articles and been convinced that I couldn't possibly have been doing what I've been doing for the past 5 years... now I don't even know what is true!
It'll be a mixin for 4.0, but I agree 100%, it only helps a little.
Reading this was a great way to start my day back to work doing Rails development.
blame retardo :O
&gt; Best to just ignore them and continue being more productive than them
I'm not sure what will be used to replace Kernel#autoload, but Matz himself has spoken out _against_ using it: http://www.ruby-forum.com/topic/3036681 It will be removed in a future version of Ruby (likely 3.0) because it is not thread-safe. Maybe until then it is better to take a hit at boot time then depending upon the lazy-loading of files. 
I'm just getting into rails (finished my first book building a blog app like most of them have you do) and my mind is blown. Love AR and nearly every other part of the environment. I haven't been this "holy shit think of all the stuff I can do" in a while. It kicks ass so far. For what its worth...
I thought it was a good read. ;)
Here is the only thing worth commenting on: &gt;Just because you wear thick rimmed glasses and drink lattes with your scarf flipped casually around your neck doesn’t mean you get to throw fundamental principles out of the window. "Fundamental principles" is a farce. There is no such thing; they are not falsifiable claims. They are quite literally aesthetic preferences (i.e. whenever someone talks about 'elegance' or 'simplicity'). The above sentence really tips off that the rest really isn't worth reading. No one should be worked up over this.
&gt; As a rails developer, Been writing too many cucumber scenarios lately? ;)
[StackOverflow](http://www.stackoverflow/) is your friend.
Thank you! It is confusing for me is that &lt;&lt; points to class from @body_class and not vice versa so it looks like we are opening some class and assigning it @body_class attributes, when what actually happens we are opening the metaclass of @body_class. This piece of code made me research metaprogramming and the best I've found so far is Dave Thomas' presentation linked here: http://ruby-metaprogramming.rubylearning.com/ 
def @body_class.&lt;&lt;(s) is so much easier to understand. class &lt;&lt; @body_class Tripped me up. Thank you so much. As I am learning ruby I am understanding how important it is for a language (or patterns) to be consistent to ones I already know. I see how things that seem paifully obvious for someone who knows a specific pattern can be very different from everything I know and therefore impossible to connect to existing knowledge.
Guilty as charged =)
This was pure ruby example from a set of exercises on learning ruby. I will check out the ActiveSupport class_attribute, though.
I posted a similar comment below that explains it more, but my fault for doing it two places at once. #extend can be used to add a module onto a specific instance, instead of a class as a whole as is more typical. Are you familiar with Modules in general, and mixing them into a class with 'include'? You can mix a Module into a single instance instead of a whole class with #extend instead. And `Module.new do` just defines an anonymous module inline. You could instead define the module non-anonymously: module AddSpecialConcat def &lt;&lt;(str) ... end end @body_class.extend AddSpecialConcat would do the same thing. 
Cool. Keep in mind, it's not actually a "one line syntax", although it could be. It's defining a module anonymously with a block. `Module.new do` by itself doesn't do anything, the `do` is introducing the block that defines the module, in the lines after, until the `end`, right? You _could_ do it in one line, if it's a very short definition, with the curly bracket syntax for a block instead, but it would require semi-colons, which I don't like: Module.new { def &lt;&lt;(str) ; some_definition ; end } I don't like that, prefer: Module.new do def &lt;&lt;(str) some_definition end end Note that the block is the important part. Module.new defines an anonymous module with a block, that you can then do whatever you want with. You could assign it to a constant (now it's not anonymous anymore) `SomeModuleName = Module.new do .... `. You could even assign it to a variable. `this_variable_holds_a_module = Module.new do ... `. And then actually 'extend' with the variable! `@body_class.extend this_variable_holds_a_module`. Or you can just immediately extend with the anonymous module, as in my original example. Names of classes and modules are simply constants that point to the module definition. So module Something def something ... end end Believe it or not has the same effect (in most cases) as: Something = Module.new do def something .... end end In both cases, at the end there's a constant Something that refers to a module defined thusly. 
Yes, that's right. 
Or, simply: def @body_string.&lt;&lt;(str) concat ' ' unless length.zero? concat str end
This was a great article, thank you for posting.
To quibble, the block definition encloses variables in scope, I believe, so it's substantially different in that way. But most usage does indeed do as you say. x = 5 module First define_method(:puts_x) do puts x end end Second = Module.new do define_method(:puts_x) do puts x end end z = Object.new z.extend(First) z.puts_x =&gt; NoMethodError 'no local variable or method x for object...' z = Object.new z.extend(Second) z.puts_x =&gt; prints '5' to stdout 
Yes, and I wouldn't even do what José did: class SpacedString &lt; String def &lt;&lt;(other) concat(' ') unless length.zero? concat(other) end end You rails core guys love your wrapper classes doncha? ;) Inheritance is fine too.
He's obviously biased to wrapper classes ;)
On this note, the singleton in ruby is most often called the eigenclass. 
Great real life example. I wouldn't pass much less in code review. The only other thing I'd recommend in the example is an accompanying test. This is a perfect chance for TDD. As the problem is described, we could write one or two simple tests to hit all the goals: * The String you return must be retained during the object's entire life * The method must be able to be called multiple times * The String you return should know how to add new classes: each class is separated by a space * The only method you need to worry about being invoked is the &lt;&lt; method.
We have an arrangement with a hosting company - where we get part in the profit. So we run a quarterly subscription with them.
I don't. I help them get their own account set up with a hosting company if they need help and make recommendations for hosts based on their needs, but I don't host sites. Hosting is just a pain and not all that profitable, and not something I want to deal with.
If your client won't pay $30/month for a good hosting, he's not a good client. run!
Essentially, yes. There are some differences in some cases, but in that case, those will do the same thing, yes. 
Are you a Ruby developer? I found [this link](https://my.bluehost.com/cgi/help/221) in their docs. Rails 2.3.11 is rather old. I think I'd like to have more freedom in terms of which framework and gems I can use.
specifically: &gt; At this time, Bluehost does Not support the Rails 3.X.X. version as it does not use Dispatchers. This guide is not intended to be used with the Rails 3 gem.
Definitely don't use Bluehost.com. I've had nothing but terrible hosting and service experiences with them for PHP projects, and was unfortunate enough to inherit a Ruby-based project hosted there once. The stuff of nightmares. Really, if your clients can't afford $30/month for a website hosted on Heroku's cheapest plan, they're not paying you enough. Period. If you *really* need an economical solution, try spinning up a small EC2 instance for ~$30/month and letting a few small Rails client sites share the resources there. (I'd personally recommend against managing your clients' hosting though - if you do, get yourself liability insurance and a really bullet-proof contract).
Yep, although generally in Ruby you will have either a test or spec directory that holds all of your tests. The test directory if your prefer your usual TDD (Test Unit), the spec directory is if you prefer BDD (RSpec). Test Unit: http://www.ruby-doc.org/stdlib-1.9.2/libdoc/test/unit/rdoc/Test/Unit/Assertions.html http://en.wikibooks.org/wiki/Ruby_Programming/Unit_testing RSpec Docs: https://github.com/rspec/rspec Article: http://www.skorks.com/2010/01/thoughts-on-tdd-a-case-study-with-ruby-and-rspec/ Look on github there's quite a few examples you can look at: testunit: https://github.com/thoughtbot/paperclip/tree/master/test rspec: https://github.com/sarvasv/TDD-ruby-game 
&gt; Can I do this in Ruby? This is actually the default way to code in Ruby. Or at least we all pretend it is.
 $ cat mini.rb require 'minitest/unit' include MiniTest::Assertions assert divides?(4, 2) refute divides?(5, 8) assert divides?(5, 8) $ ruby mini.rb ~/.rvm/rubies/ruby-1.9.2-p290/lib/ruby/1.9.1/minitest/unit.rb:85:in `assert': Failed assertion, no message given. (MiniTest::Assertion) from mini.rb:11:in `&lt;main&gt;' $ ruby -v ruby 1.9.2p290 (2011-07-09 revision 32553) [x86_64-darwin10.8.0] 
Ditto, I also host all my stuff on various Linodes and have been very pleased with their reliability, especially for the price point.
I'd agree that the intro is trite, but he raises fair and intriguing points. The information is valid regardless of his writing style. In retrospect maybe I should have written a different title for the link instead of using his words. 
Same with: http://cofmachine.blogspot.com/2011/12/cofmachine-flashcards.html I had to resort making a html version. : (
I tried several times but can't make any sense out of this sentence.
Referencing the sensationalist titles. Made sense to me at the time :-)
Why 23? Why is it different in 1.8? What is the length in 1.8? What about jruby or rubinious?
"Amateur hour?" I've been doing this for 10yrs, and yes, I do make more than $100/hr. For an extra $400-500? Not worth it. Even if I don't have to touch it 90% of the time, even if I'm not managing the servers - not worth it. That reseller account goes down, *I* look bad - doesn't matter that it's not my fault, doesn't matter that I have no power to fix it, as far as the client is concerned, I'm the one hosting their site, so it's my fault. Most of my clients need at least a VPS, anyway, which means I would be managing the server, or contracting that out, or leasing managed private hosting, which would mean significantly increased prices to the client if I wanted to make a profit off of that, and more headache due to the more involved nature of their hosting needs (that 4-5hrs/mo of checks, backups, and maintenance would have to be done across multiple servers). Again, not worth it, and I actually like my clients, so I'd rather not over-charge them just to act as a go-between. I'm a software developer, not a hosting company, and this software developer doesn't want to be "on call" 18hrs/day. A 9-5 schedule is easily worth $500/mo to me.
FuK c: Why Ruby strings and the Alphabet are too long at 24.
Thanks for taking the time to reply. Sorry to hear about your eye. If anything there's something to be learned from this dialogue. While the little guys are scratching their heads, I hope they can take something away from this. I only threw out numbers not to brag but to give an idea of how reseller accounts can make you money and you can learn a thing or two by taking on the time to learn to maintain sites to be safe and secure. Just like us, they gotta start somewhere. I respect your hard work (and it is!). I wish you a speed recovery. 
 # file myprogram.rb def divides?(a, b) a % b == 0 end # file mini.rb require 'minitest/unit' include MiniTest::Assertions require 'myprogram' assert divides?(4, 2) refute divides?(5, 8) assert divides?(5, 8) 
Depending on the project I use heroku if I can.
If you have an almost recent MBP, you can upgrade your RAM to 8GB for about $45 (for example from Crucial). If you have a late 2011 MBP you can upgrade it to 16GB for about $250. But overall I agree. Java apps eat a lot of memory. By the way, right click on the RubyMine app icon, and make sure it's using the 32-bit JVM. This way it would eat less memory.
Overall I agree with what you say, but these days you can buy 8GB of RAM for very cheap ($40-$50). 16GB (2x8GB) also costs about $250.
I recently learned about Alien VPS. Their UFO 5 plans is only $25 per month and comes with 3GB of RAM, 5 cores, etc.: http://alienvps.com/vps-hosting/
Hey Neztok! I just woke up, sorry I didn't see this. I'm the maintainer of Shoes. The packager is undergoing some work at the moment, and is a big buggy. I can make a .app special for you if you'd like, though. As for why it's ugly on Windows, I don't know unless I see the source; we try to make it as close as possible everywhere. You might have found a bug. EDIT: Oh, if you send an email to the shoes mailing list, shoes@librelist.com, there are lots of helpful folks who can also help out.
Can someone explain why they chose 23? I didn't see that mentioned in the article...
If you want to work at 10pm on a Sunday, go for it. I'm happier relaxing.
It's not really work. More or less, an easy time to sit and run some scripts when traffic is low. I've literally done it when watching Dexter/Homeland. Just checking that everything is in order. 95% of the time it is.
what's a (an?) "Ragel extension"?
I have a lot of respect for Evan, but I have to ask - why Yet Another Webserver? What problem does it solve that isn't solved by Mongrel, Thin, Unicorn, Passenger, or Goliath?
The request parser is written with Ragel and is a platform-specific C extension. Basically, the slow part of the parsing is done in compiled C rather than in interpreted Ruby. This was Mongrel's claim to fame several years ago.
Faster, thinner, better? 
You can think of Puma as the modern successor to Mongrel (which is now generally unmaintained). Unlike all the others, Puma is designed to run to run in a highly concurrent VM and is being tuned as such.
where new is defined as over four years old?
4 years old in what way?
I guess he means this: https://github.com/evanphx/puma/blob/master/History.txt#L57
Mongrel and not Mongrel2, right?
well, what's the difference between 'fun and excitement' and 'linkbait'?
Puma started as a mongrel fork, that's the old History file from mongrel. I'll nuke it.
But sublime 2 is da shit! No seriously, if you code the whole day. It is truly worth its money! 
Just go with vim/macvim already. You won't be sorry. In 20 years people will still be using some variation of it.
Just to let you know, I haven't forgotten about you, but I'm having some issues with packaging up the Mac version. :( This is helping me find new bugs, though!
Is this only in DC? 
Hey thanks, I really appreciate it. I'll make sure to publicly acknowledge to my 121 readers on r/CoFmachine that you helped me. I want them to start contributing and hopefully this will motivate them. My life: Like Mac version - bug packaging it. Tolerates Win version - packages with no problems.
:) So the deal is this: for [Hackety Hack](http://hackety.com), we use an alternatie kind of packaging, that's done via the command line. Its 100% undocumented and a bit buggy, though, so I was trying to build yours the same way. One of goals this new year is to fix a zillion Shoes bugs, and documenting this stuff is one of the bigger parts.
&gt;Your question to me is also irrelevant, Examples to the contrary might be relevant. &gt;since you have stated that no credentials would matter. Well, let's see if I stated that or not. http://www.reddit.com/r/ruby/comments/nwaz5/activerecord_and_rails_considered_harmful/c3cfyqa : &gt;I don't disagree with anything you said here, but I don't see what relevance your 'credentials' have. Nope, no such statement there. http://www.reddit.com/r/ruby/comments/nwaz5/activerecord_and_rails_considered_harmful/c3cg3ke : &gt;Again, I don't see what relevance your 'credentials' have, and you have done nothing to explain that. Wow, still nothing like what you claimed. Could you make an attempt to support your claim? Specifically, can you link to the comment where I stated that no credentials would matter? 
just set up virtual image and distribute images. I still don't get the point of vagrant. seems like just a wrapper for standard linux which i wouldn't suggest. 
I'm glad I'm not the only one. 
FWIW, DHH came down against rSpec last year: http://www.rubyinside.com/dhh-offended-by-rspec-debate-4610.html While I like syntactic sugar as much as the next rubyist, I just don't see the added value in rspec.
The basic one felt a bit lackluster, but the intermediate version was super fun to build. My hideous, never refactored, total mess of a solution: https://gist.github.com/1573464
I'm doing passenger and ruby 1.9.3 with all my rails/rack apps. Can someone give me the biggest reasons why i should switch to puma, unicorn, thin or goliath?
The nice thing about Vagrant VMs is that, if your provisioning script (chef recipes, whatever) is good enough, you can throw away your VM and replace it very easily. This means that you can screw up anything on your system and recover from it in just a minute or two. Sometimes after a debugging session, my VM has debugging statements all over its system gems, changes in config files, or a different version of postgresql or Redis or sqlite. Cleaning all that up by hand would be really tedious, but just destroying my VM and spinning up a fresh one only takes a couple of minutes.
They've mentioned that if it goes well, they'll run it again, and make it open to everyone.
i understand what you're saying, but what we advocate is always making backups of stable images. Clean image of vm at point a, with x y z installed. We have a library of images like this. So someone can screw around all they want destroy it , copy image a again, and be back at point a. Sounds like its more of an unnecessary step to me. Storage is cheap, copy and paste the image to storage and always have it. I still am missing the point. 
A big issue is that so much early work and guides ignored big chunks of the DSL, or just used the DSL wrong (I'm looking at you, rspec peepcodes). The rspec book helps cover a lot of these things better, but also check out this presentation: http://kerryb.github.com/iprug-rspec-presentation/#1 It's really easy for it to just be "Test::Unit plus confusing metaprogramming", but if all its features are used it can really be more readable and concise.
Think about it from the perspective of provisioning a machine for deployment of a Rails app or something. Having a `Vagrantfile` in my tree, in addition to my Puppet manifests means that I can build out new functionality, add necessary dependencies like Redis, etc, and pop up a VM to run my Puppet manifests then test the application out. Additionally, it provides a common setup for the entire development team.
but thats exactly what puppet or chef is for , to automate management of these tasks. So what exactly is vagrant adding ?
An incredibly useful way for working with the VM and the provisioning tool. If you don't see any value in making things easier with Vagrant, then so be it.
this looks cute. at level 4 there is a lowercase 'a' on the map without explanation what this is. will give it another try when i have more time. but for sure a funny way to learn ruby. though it would need far more explanations for beginners.
This coming week.
When I first saw it, my reaction was "WTF?!" Our designer is fixing it this weekend. Sorry for offending you eyes :)
I'll start packing now!
nice approach! 
Great work, guys. It reminds me of when i had started an org in the mid 90's and had to find and train my colleagues on Win16 and Win32/NT API. You get to reach young enthusiastic folks early before they pick up bad coding/work habits. Some Suggestions: a) Focus on teaching the participants good work habits and good code habits. b) Make sure that participants get a lot projects/homework but not so much that they burn out and start hating code. Probably the best person to determine this trade-off is the trainer in consultation with each participant. c) Make participants stick to one common platform/editor/IDE/VM to minimize problems with configuring different environments. d) Introduce Version Control basics from Day 1, along with things like backups and restore. e) Make participants take notes/manually type things instead of cut/paste initially. f) Make participants go through code with the help of a debugger and learn how to step into/through/out of code. How to watch variables etc. g) Make participants read the documentation and make it a habit. In a class it often is easy for participants in a hurry to turn to their instructor or colleague to learn about a function or API. They need to learn how to read the documentation religiously ( and rails/ruby has some of the best documentation going around ) h) Teach them things like Test::Unit, RSpec and Cucumber early on in the course. Testing should be a habit. i) Writing comments in code is also something which should be encouraged early on. Other than that, focus on having fun during this course. 
Can you write rspec tests for plugins?
I guess bootstrapping of chef and puppet? I'm in the same camp of not "getting" vagrant other than providing a nice CLI hook, integration with Chef and Puppet, and prebuilt configs for developers (like shared folders).
I don't like the overhead of all the "And"s and their blocks. Capybara itself is very readable. There's actually no need to comment each line. On the other hand, the output looks nice, though. But most of this stuff could probably be expressed in one sentence or by using context. Btw. Jim Weirich also made a DSL on top of rspec with Given/When and Then quite a while ago: https://github.com/jimweirich/rspec-given
Yea, I found running it locally to be much more fun. Passing the -t 0 option to rubywarrior speeds up the process a lot. Also, using vim instead of the textarea was more pleasing.
THANKS FOR LINKING TO THE AUTOPLAY VIDEO BRO
This article demonstrates one of the most egregious mistakes when using Give/When/Then. It's a really bad idea to talk about UI elements in your steps ( When I fill in, When I click) as it makes your tests hard to read and brittle under change to your UI. Instead, talk about what you are actually doing (in this case logging in) take a look at http://aslakhellesoy.com/post/11055981222/the-training-wheels-came-off 
what's the motivation behind it? (i.e. does it aim to be different from the other irc bots out there in some specific way)
[Minitest](http://bfts.rubyforge.org/minitest/index.html#methods) has built-in spec syntax and does the job for me.
Dammit, now I have to try it.
Good tips, thanks!
What?
thanks for the -t 0 option heads up :D
And I will never forgive you for it.
With all the Ruby jobs out there, why should I want this one?
got it. will reply after lunch. thanks!
Email me at lonny6@gmail.com and I will get back to you later today with some CV-type info. 
Potential for what? This is a really weak pitch.
I was just guessing, extrapolating from the bits of information there.
I think there is a reason why you had "limited success" on /r/hiring
I know some brilliant Ruby developers (that are also affordable). I'd be happy to get you introduced. Send me some project details and I'll get you connected. Brett Miller dev@cspreston.com
There have been a spate of ruby configuration object gems lately, which I think indicates that it's tricky to figure out how to cover the bases in a flexible way without over-engineering or assuming too much about use cases. For me, most of the recent offerings either do not enough (I have to implement too much myself to do what I want), or too much (very complicated hard to understand code, which ironically then gets in the way if I want to use it somewhat differently than it's intended golden path), or both at once! (Doesn't do what I want, AND makes it hard to build off of to do what i want!). For me and my use cases anyway, this one, Confstruct, (by a colleague, but not by me) hits the sweet spot. Powerful enough to keep me from having to reinvent the wheel and give a nice DSL for writing config, but at the right level of abstraction to let me do what I want or easily build what I want on top of it, while still being relatively simple/concise code for what it is (does though, still need to use method_missing for the nice config dsl experience). 
Do you have a list of these recent gems. I'm in the midst of building something I need to juggle user settings effectively and I'm trying to learn enough to make it effective while I build it. Something like this could be useful.
thanks this is useful too. I'm actually looking for something to juggle and unjuggle 'settings' across a number of instances of an object. The use for the bulk of these seems to be app-wide at first glance. I'll try a few and see what they do.
I would recommend checking out the one that, you know, I posted this reddit in order to suggest. :) Confstruct You could have a confstruct object on each instance. That confstruct object could even initialize itself by deep_merging another confstruct object, say a class-wide one or app-wide one, and then add it's own instance-specific config on top. Confstruct won't exactly do that for you, but it gives you the building blocks to easily do it in a few lines. That's all assuming simply using a Hash isn't enough for you. Most of the focus of most of these is on a nice DSL for writing configuration. With per-object 'configuration', I'm not sure where that would come in exactly. Don't know what you're doing that wants more than a Hash, but if it doesn't, don't over-complicate, just use a Hash. 
There's also configatron (https://github.com/markbates/configatron/). Recently, I did a search and found various options. Here's another: http://speakmy.name/2011/05/29/simple-configuration-for-ruby-apps/
I love it when new programmers think they've discovered something big.
1.9.3 is soooo much better in development now. pages don't take 20-30 seconds to load.... edit: removed my "omg, " since I think I'm getting downvoted for that.
nice work
no way man, just a really really bid legacy app on 2.3.14, with 1.9.2 was just really really slow. they changed some of the internals to 1.9.2 when you require a file (we have a shit ton of files everywhere), causing a big slowdown. 1.9.3 has addressed some of these issues. There are also patches that you can find for 1.9.2 for speed increases when requiring files.
And its my cake day!
Holy crap man, I know what that's like, just migrating a 2.1 app to 3.1 was bad enough (now two years ago, that 2.1 app was migrated from 1.0, but at least I didn't do it all at once). Rails is, well, not kind to legacy code. 
I tried something similar a few months back, but I didn't have the database schema/dump. This was also before I learned migrations. And proper backup.
Well we just started with 0.8.0, but we upgraded from 2.3 to 3.1. We were on 2.3.14 before the final leap. Biggest thing, get bundler to work with 2.3.8, gem up everything you can in lib. We had a ton of small little one file libraries that did things in our app. We just created gems out of all of them, and it fixed all of our dependency errors and other library loading issues. After that, I just created a new rails, and then just moved in all the main parts (/app, some things in /config, other things). 
Well, if you use the private keys shipped with the project then anyone with access (read, anyone) could spoof everything about your certificate. It's a pretty slippery slope and it's a good reason for projects to not include example keys but to include instructions or a script to generate them. So, no, not really so bold.
And were you able to do that without rewriting 90% of the code in two times the time it would have taken to rewrite the app ? :)
Hashie::Mash
It often _seems_ like it would be easier to rewrite something from scratch, but my experience matches that of many others, it's almost always a bad idea to do so. Your existing software has an embedded history of bugfixes and performance improvements and whatever else its' got in it, that you lose starting over from scratch. It might be different if you have a _really good_ test suite, at a high enough level that you can keep _most_ of your tests applied to your new 'from scratch' app. But my experience with Rails is that migrating a Rails app over a major Rails version bump almost always requires me to completely rewrite almost all of my tests (which is part of the pain. Perhaps I'm just crappy at writing tests. Well, I know I am.) http://www.joelonsoftware.com/articles/fog0000000069.html
Do mean changing the "ip_lookup" class name to "geolocate_ip" as well? Will that cause any problems? 
No, use IPAddr from the standard library to validate the format of the address. 
Sent you a DM (via email) question. Thanks again for all your help!
Implemented it. Works great. Thanks!
I'm going to submit a pull request in an hour or so. ;)
defintiely checkout out the rails casts for upgrading to rails 3. and here is what i said in another comment. Biggest thing, get bundler to work with 2.3.8, gem up everything you can in lib. We had a ton of small little one file libraries that did things in our app. We just created gems out of all of them, and it fixed all of our dependency errors and other library loading issues. After that, I just created a new rails, and then just moved in all the main parts (/app, some things in /config, other things). 
No problems after many months of using under Rails 3.0 and 3.1. I've tried other similar gems in the past and they quite quickly show their flaws, so I've been on the lookout for code not being refreshed etc... Rails 3.2 is getting similar functionality built in, based on active_reload I think.
thanks for the input
I completely refactored the gem based on some great feedback. Thanks for taking a look and let me know what you think I could do to make it more awesome. Thanks, Dan B. (a.k.a twitter.com/thoughtpunch)
Just sent [the pull request](https://github.com/thoughtpunch/geolocater/pull/2). I did some of the things you did, and some others. I'm going to wait and see if any of it is useful to you before I do some additional work. :)
Great! &gt; Easier to maintain and add additional geolocating services in the future? In general, one class per file is a good idea. It helps with organization. If you want to move to autoloading, it helps. Keeping small number of things in a bunch of files also lets people load only the parts of your library you want to load. For example, I can do this: require "active_support/hash_with_indifferent_access" require "active_support/core_ext/array/access" And get only those bits of the library imported.
tenderlove's implementation does just this anyway. Doesn't every test suite automatically fail a test if it raises an uncaught exception?
I don't tend to keep my finger on the pulse of internet drama so I don't know if anything more has been "revealed" in the last couple of years. But the story at the time was essentially that one day he decided to withdraw his online presence (at least as _why) which entailed no longer keeping his websites, projects, etc. up and available. No explanation or public statement was posted prior or at the time so the reasons are unknown. At the time, a lot of people were concerned, alarmed, upset, or confused. A lot of people probably expected or wanted a "story" to go along with it, as you do today, and maybe felt disappointed when there wasn't one. Well, perhaps there was, but if so it was _why's story, and not a public one. Regardless, his reasons are and were his own.
I think he was probably a British undercover agent for MI6, assigned to infiltrate a particular group of ruby hackers with national security significance, but the operation ended and he was re-assigned. 
The point is that a test that just asserts that no exceptions are raised is not useful. The code under test in this case is removing a column from a table, so that behavior is what should be tested for.
The test that says what the code should actually DO will fail if that code raises an exception, right?
Not necessarily. You're asserting that that code -- under those conditions -- will never raise an exception. While I agree that you should _also_ test that the column is actually removed, it is not unreasonable to put this test there. Since it tells me that -- under those conditions -- I never have to worry about any exceptions being raised. The syntax is effectively a no-op, yes, but that syntax makes it more legible. I much prefer the syntax: it "shouldn't raise an error, ever, in this simple case" do expect { 1 + 1 }.should_not raise_error end to it "shouldn't raise an error, ever, in this simple case" do 1 + 1 end _even though_ the former is more verbose -- in fact, I like it _precisely for the fact that it's more verbose_. It more clearly represents my intent. In the latter case, excepting for the message at the beginning, doesn't express my intent to only assert that the simple case doesn't raise any unexpected errors. Whereas the former practically screams it. My only syntax change that I'd truly prefer would be to be able to do: expect { 1 + 1 }.should_not raise_error by itself. **TL;DR** I'm not convinced it's a bad thing, there may be legitimate reasons for testing for such a thing.
Check out NYC.rb. Also, good luck, you'll need it!
He was infiltrating us in the only way he knew how... With kindness.
Pretty much. Unless the test itself catches it and doesn't reraise, or unless it's listed in PASSTHROUGH_EXCEPTIONS, in which case MiniTest will exit anyway. (P_E by default would pretty much crash programs anyway, so generally acceptable: [NoMemoryError, SignalException, Interrupt, SystemExit])
Yes. But my view is that it is important sometimes to make that assertion explicit.
Seriously, I think this happens in reality more than we would be comfortable with.
On my phone, will reply longer later. Apologies for cryptic shortness potential. The point is that I am making two separate assertions, one about the thing the method returns, and a much stronger assertion about other things the method might do. By saying that the method should never raise. I inform the consumer of my API that if they ever get a raised exception, it is most certainly an API bug, not a bug from them. Will provide examples shortly, but hope this makes sense. 
what seems to be the obstacle that makes it so challenging? lack of funding? lack of talented developers in the area?
Whoops, sure did. Thanks.
Interesting. If it works well enough to run Sprockets and the Rails Asset Pipeline -- could this result in a Rails Asset Pipeline that does *not* need an external javascript VM, but can be run with pure ruby? Modify execjs to find and execute using this guy?
Shoes maintainer here, if you ever need anything.
&gt; By saying that the method should never raise. I inform the consumer of my API that if they ever get a raised exception, it is most certainly an API bug, not a bug from them. But that test case does not say that. Just like `should raise_error` does not say that "this method *always* raise exception for any input", `should_not raise_error` does not mean that "this method will *never* raise error for any input". So `should_not raise_error` only gives the message that "this method will not throw exception in this particular case". And if it only gives that meaning, what use is it if you don't tell the reader what is supposed to happen beside not raising exception? If you tell the user nothing else, then it's simply undefined behavior marker. But if you tell them the result, then not throwing exception is redundant. The default expectation of every function call is "may throw exception" and your documented "may throw exception" does not add any thing to documentation.
More jobs than good developers. It's been extraordinarily difficult to find qualified candidates that aren't already happily employed elsewhere.
This blog post is so ill thought out, poorly written, undocumented and unconvincing as to be incomprehensible. "A fixation on quality champions great software. If you don't agree, please have a look at Apple's success. Building great software takes time, commitment to excellence, ambition, and phenomenal chemistry on the team. Testing is a pillar of quality. Without it you're on unstable ground." The first sentence isn't even sensible. Fixations don't champion. Further, Apple has no more software testers than, e.g., Microsoft does; many of their software products are of arguable quality (e.g. iTunes on Windows); and their success isn't proof of software testing benefits not being mythical. The third sentence is meaningless. The fourth and fifth sentences are mixed metaphors that are also so vague as to be meaningless. A blog post about the metrics of testing ROI should include metrics, rather than 3 wikipedia cites (!?!), a cite from a 1985 article (!!!), and a cite from a 1979 article (!!!!!).
Ridiculously exciting. Can't wait to meet in person next week!
+1 the writer is an illiterate chump I agree testing is important, but fucko can't write
Yo dawg!
P.S. You got your assertion backwards :P 
If you're using a key that can be factored by one guy with one computer in [two and a half months](http://www.ticalc.org/archives/news/articles/14/145/145154.html) in 2009 that anyone can access and you shoot your foot off thinking it was secure simply through obscurity I don't know what I can say but "wow, you're an idiot!" I guess it's good that the license protects me from people that stupid.
Posts like this make me tempted to move to NYC... even though I love my job and city (Portland), and I'm looking for CTO-level stuff, not development (although I write quite a bit of Ruby code on a daily basis...) Seems like an amazing city to live in, if you can succeed in the job market.
Did you receive a call today? Are they contacting everyone or only the people who got accepted?
There are differences. 1) If you explicitly make the assertion then the test framework will handle failure with a clear message, and if you do not the test runner will assplode and you'll have to work back to what you expected to happen. 2) Tests without explicit assertions (i.e. relying on implicit assertion that all tests should complete without error) look weird, and when you come back later to read them you'll have to double-check it's not actually a mistake. __EDIT__ actually ignore this it's irrelevant.
Well I think it's implicit, but on reflection on your main point I was wrong and you are right. Unless method under test is __only__ concerned with raising an error or not, then you should not use `assert_nothing_raised`. So cases where you could use `assert_nothing_raised` are vanishingly rare. e.g. def foo if condition do_something else raise "o noes" end end You should assert that `do_something` is called when `condition` is `true`.
Don't forget that you can utilize Java libraries with JRuby, keeping your code ruby-centric while simultaneously tapping into a different support ecosystem. Obviously not a silver bullet, but certainly useful to remember.
Brilliant.
There's the [Renee](http://www.reneerb.com/) micro-framework.
Rails does too much for you, Sinatra doesn't do enough for you. I think you have to figure out which of those ends you want to be on. 
That would work only if you're using a paid version of SketchUp. Free edition doesn't support importing/exporting to "foreign" formats.
you described exactly the situation i'm in! i need something more than Sinatra but less than bloat. 
There isn't a gem. What I've done in the past is shell out to admesh.
If you love ruby, you should really man up and learn to like DSLs. It's a hurdle, I went through it, but once you are comfortable w/ DSLs, you'll love them. You'll always hate the (undocumented) magic, though...
I'm not quite sure what you are trying to prove by linking that article. Looks to be a completely different issue to me. My comment was that including a private key as a testing tool on the assumption that people are smart enough to not use it in any production or development environment is potentially irresponsible. My second comment hinted at a simple work around, to use a "forever valid" key, but have it ignored by your SCM, and if you happen to be working with a fresh working copy of the repo, automatically regenerate it using the code you provided. It'll still be ignored, and still be unique to that installation, but it won't be floating around the internet if the developer/user decides to git push it somewhere else. Linking an article about someone bruteforcing a 512 RSA key... seems to have no relevance to running Ruby tests against an x509 certificate outside of the mysterious and magical field of cryptography.
How is ramaze and rails slow? Have you actually benchmarked them **with database queries inside the request**? Most framework benchmarks are useless, because there is always going to be some I/O, and it's going to take up the vast majority of the request time. If rails handles a request in 10ms, and sinatra does it in 1ms, it doesn't matter alongside a 75ms database query.
by slow i mean that framework is doing less than 1000 rps with an "Hello World" app, without any I/O. as is said before, Rack is doing at least 5000 rps with an "Hello World" app. why frameworks can not do at least 2000? i currently run an non trivial perl/php app that does about 1000 rps. it does rendering html and doing I/O. i think, if some framework would do at least 2000 rps, app I/O and templates would reduce it to about 1000 rps, what would be great 
a few links for consideration: [Write modular web applications with Rack](http://rubylearning.com/blog/2010/09/21/writing-modular-web-applications-with-rack/), [Goliath asynchronous ruby web server framework](http://postrank-labs.github.com/goliath/), [Pakyow framework for building web apps in Ruby](http://pakyow.com) 
Have you tried Devise for authentication? I've enjoyed it quite a bit over authlogic. Rolling your own is also a pretty good option. 
I stopped reading at "There are no tests for the Speaker class at all, except that we co-incidentally check the rating it emits." That assumption seems entirely flawed.
Sorcery for authentication. As much as Devise is awesome there is so much built in it can be a bit much. I found that Sorcery was just so nice and easy and never got in the way. Some people will disagree but I love Formtastic for building forms. Rails makes it easy anyway but Formtastic goes a step further.
I'll look at Devise. I have no experience with it. Rolling our own is an option but I definitely want maintainability and using well established Gems seems like a good start to that end.
FINALLY! I've looked at all the IRC bot frameworks and despaired at the lack of testability. Like I want to let an IRC bot loose on my favorite IRC network without knowing if it'll work or spam the channel.
If you roll your own, you should use the new #has_secure_password DSL method to set it up. Should make things very easy!
How does it compare against Authlogic?
It's not that the tests are lying to you, it's that you aren't following good testing practices well. It's easy to dig in to testing and forget about proper isolation; you know, because you're being so clever. Good practices will save you a world of trouble. No amount of testing can save you if you don't have those practices in place.
Are there any features in devise that i would miss with sorcery? Like remember me, email verification? I'm in a similar boat as the op. I'm jumping back into rails from a few years off. 
The Ruby Toolbox - wonderful rankings of what gems people are using. https://www.ruby-toolbox.com/
Thanks for mentioning Sorcery. I'm pretty new to Rails so I've been spending a while wrapping my head around Ryan's "creating authentication from scratch" video. This helps a lot.
i said any framework that does under 1000 rps with an "Hello World"-no-I/O app, is a slow framework! my demands are fully justified, cause once Rack is so fast, there could be at least one framework that uses at least half of its performance. and 1000 rps is not an optimization, it is a middle to low performance for any web project. are you all voting down just because you are unable to achieve this performance? 
agreed, this is the first place I go to find which gems to use.
I'm continuing to use Devise on all my new projects. A lot of my sites have invitation requirements and the devise_invitable gem makes this very easy.
We're using Resque for background jobs and I've been pretty happy with it. It takes a bit of work to make sure the workers stay alive and that they restart properly on deploy. If your on Heroku make sure you use the hone redis branch so that the workers get properly shut down. For a much lighter weight alternative, I'm excited to try out girl_friday on some of my personal projects. User Auth, I'm using and have always used Devise. If you need to handle user invitation at all, the add on devise_invitable gem is great. Not sure exactly what you mean with the form building but I either use the built in form_for or simple_form along with ryanb's nested_form gem. For ZipCode/Mapping we use the geokit gem with the google maps api. Also, if you havent gotten into haml and sass yet, you NEED to do that. I could never go back to writing pure html again. For file upload handling I've switched from paperclip to carrierwave and couldn't be happier. CarrierWave with it's uploader pattern is much nicer in my opinion. 
Devise can be super bare bones: http://blog.plataformatec.com.br/2011/09/bare-bone-stripped-down-devise/
Not an answer to your question, but a custom form builder would be an awesome open source project. If you are going to invest a lot of time into it, please do think about releasing it as a Rails Engine. We use formstack.com for a lot of our surveys and sign-ups, because managers like to be able to make changes to the forms by themselves. So an open source alternative would be really awesome. Edit: As a side note, we have just built 'custom fields' into our Rails app, and had to think very hard about database design. Stay away from EAV if you can :)
Performance does not only depend on the developer, that I agree with. However, like I said different frameworks do different things. Some go down the magical road whereas others only offer a thin abstraction layer to make things a bit easier than having to work with the raw HTTP layer (e.g. Rack). When it comes down to Ruby frameworks each popular one could be categorized as the following (do note that this is my personal opinion and not per definition a fact): * Rails: does *a lot* for you in order to cut down development time. Downside of this approach is the increased difficulty, sluggish performance and less flexibility. * Sinatra: a DSL around Rack making it easy to bind URIs and request methods. Very fast as it does very little out of the box. Useful if you're building an API that has to handle a lot of requests in a short amount of time. Downside in my opinion is that the way the DSL is built makes it harder to organize. * Padrino: a mix of Sinatra and Rails. It takes some of the ideas of Rails and combines them with the speed of Sinatra. I haven't looked to deeply into it but it seems to take both the advantages and downsides of Rails and Sinatra of which I'm not sure if that's a good thing. * Ramaze: not the fastest framework out there but that isn't the main goal of it. The idea is to stick to POLS/KISS as much as possible and make it pleasant to write web apps with it while still being performant enough for most applications out there. One thing you should remember is that there's no framework that combines all the good things of the frameworks mentioned above without the downsides. There's no framework that's super fast, super flexible and a breeze to work with, each has its downside. Another important thing to remember when benchmarking frameworks is that most (if not all) will start in development mode out of the box. Usually this mode includes features such as code reloading, request validation (using Rack::Lint) and so on. Turning these off can usually give quite the performance boost. Take for example my website. It runs on a combination of Ramaze, PostgreSQL, Nginx and Memcached (used as a session store). When running the following command (from the server itself) I get about 540 requests per second: $ ab -c 1000 -n 1000 http://yorickpeterse.com/ I'm not caching the database queries at the moment, doing so would probably give a pretty nice performance increase. Why not? Because it's simply not needed at the moment.
This looks like an awesome resource... I can't believe I have never seen it before.
Definitely getting a lot of votes for Devise so I will be evaluating that. As well as resque. Thanks I am currently using Geokit and haven't been that impressed but perhaps it is a combination of using an older Gem and not using it properly. HAML + Sass is definitely part of the plan Thanks for your in depth answer! :)
Nice will do although I excpect we will select an existing authentication library. 
MacRuby gives me feelings.
MacRuby makes my penis tingle.
&gt; Using mocks appear to require a lot of set up code for the object under test. Why not just fire up Factory Girl, create a bunch of objects we need to test this code, and just check the outputs? Once you hit thousands of tests, you want each test to run under 1 second. If it takes 2s per test, and you have 1000 tests, you're already in the 30m range and can't run your entire suite reasonably. 
great work!
After building a lot of apps with Sinatra, I decided to pull out the code I always end up using (the framework) and package up the code I almost as often use (the plugins), then write generators for everything and wrap it up in a gem. There are still a few plugins I'm writing now (DataMapper REST services, Stripe boilerplate, user accounts, URL based commenting, Linode stack script, etc.), but since the whole project is moving along nicely, even getting a decent amount of downloads, I thought I'd share. It's my first gem and my first public project.
Why did you choose to go the way of "plugins live in a directory" instead of "plugins live in gems"?
Because I work with a lot of designers that do just a little programming - enough to get an app up and running, add routes, that kind of thing - and it's easier for them to create and use plugins live in a directory than to write gems.