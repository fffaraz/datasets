s/most/some/ In fact, I *think* this is only generally true with PHP. Any others?
Simpler apps (comparable to most Rails sites in scope) written for the JVM can often be deployed with just a .jar or .war file you can drag and drop. You can do this with JRuby too, if you're hosting it on a Java Application Server and package it with Warbler. It's also kinda how Torquebox does things.
Java.
The way you get a job: In person. At a meetup or conference. The other things you can try: Stack Exchange has some decent postings. You didn't really say where you're located (too much personal information?). If you're looking to work on the East Coast, pm me.
Dear OP -- do this. If you know ruby, please build a Rails app this weekend. It's in your own best interest, if you don't mind programming with Rails. Also, check out this [Ruby Rogues podcast](http://rubyrogues.com/125-rr-loyalty-and-layoffs/).
Do some side projects while you're looking for a job. You'll make some walking around money and it looks good on your resume. I'd start with restaurants or doctors/dentists. Their sites tend to be pretty easy and the existing sites are usually in need of some serious work. You can host them on Heroku for free or use Linode if you want to get some practice with deployments (check out Moonshine to make it easier). 
I'm in California. Currently Santa Monica but willing to move anywhere. 
In San Francisco you can get hired **extremely** easily.
My feel is that there is a ton of demand for capable Ruby developers out there. My first stop for this stuff is [GitHub Jobs](http://jobs.github.com) or [37Signals Jobs](http://jobs.37signals.com) but there are a ton of others out there. Fix up your resume, polish your GitHub profile and I think you'll be well on your way.
There's also much more on his account. Including rails http://www.youtube.com/playlist?list=PLSXDqiI4sC5MvxXseYrhUdmQ4IQ7uL5JR
I have friends up there and it seems extremely expensive. 
Another reason why I feel I have parted from rails so much is this company used mongo so we didn't do anything with activeRecord
PM me. The company I work for is looking for talented Ruby/Rails devs and we have a distributed work environment. Doesn't matter where you live. The work is interesting, salaries are very competitive, and our company is very well connected in Silicon Valley; it's been an excellent networking opportunity for me personally. And if we don't hire you, I can put you in touch with others who may. Edit: We do Rails but there's a lot of backend stuff to work on that's essentially pure Ruby. You'd need to come up to speed on Rails, but Ruby experience is always more important.
It is, but not so much that you can't get by on a typical Rails dev salary. You should start at absolutely no less than $75k in the Valley (that's on the low side). Apartments can be had for $900/mo, especially if you go the roommate route. I paid $975/mo with 4 roommates for a really, really nice place in Mountain View for a couple years.
Far better, do freelance consulting. He might not be able to charge the $180+/hr that Rails consulting vets do, but the market will bear much more than a doctor or dentist is typically willing to pay.
Those are decent, but there are vastly better non-public job postings out there that are available if someone connects you to them.
I know of a ton of rails shops in Utah that are hiring. Money desktop, Instructure. Instructure has a great set up for devs and they are all open source.
I work for Indicate on this: http://indicate.io/companies/square http://indicate.io/people/bob-aman/watchlists/payments Our team is distributed around the world. I'm in Tucson, others are in Texas, others in Portugal, and our head of eng is in Thailand. CEO jumps back and forth between Palo Alto and DC.
Thank you for the link. Tomorrow I will be updating my resume and starting some kind of rails project. I did a lot of web scraping with authentication of various reward programs using RestClient and nokogiri so maybe I will do some of those. Things like checking your Starbucks balance, airline miles balances and various point balances. 
Company I just left was in the same industry. Mobile payments. 
If Java's allowed, then so's JRuby.
Ditto for Portland
To clarify, dashboard builds analytics tools. I just used a few payment startups as examples of the kind of analytics we do.
Ah so thats how I've been getting away with not using bundle exec et al this whole time...?
Isn't finding the clients for freelancing just as difficult as finding a job in the first place? Edit: I mean, I'd love to do freelancing, I've got like three months until a move and was just planning side projects for that time.
Do you go to the Ruby/Rails meetup? Every meeting at least five people are hiring. There are a lot of jobs in LA. 
It can be. AngelList makes it a lot easier though and if you're recommended on any investor/accelerator's mailing list, you'll have more clients than you know what to do with.
IMO this is better experience than building a toy blog and posting it on GitHub. You will most likely never be asked to build a site yourself from scratch at whatever place employs you. Building a blog and posting it on GitHub will prove that you are not incompetent but I would rather employ someone who has experience maintaining a project because it's much harder to maintain another's code than to create your own site your way. Don't sell yourself short just because you haven't built a rails app before.
From the shuffle source code it seems clear enough that it will first create a new array and then randomize the order. The alternate shuffle! would not make a copy but still makes array.length random replacements. So rather obviously at least for large arrays shuffle is very expensive. I would strongly avoid this. (btw it should be rather simple to generate a array with say 100 numbers and run both your methods against it and measure the time they take). for a very limited test in irb I get (array size 100 with 10000 requests): rand: 0.00514 shuffle!: 0.039203 shuffle: 0.050573
&gt; Apartments can be had for $900/mo, ~~especially~~ **only** if you go the roommate route FTFY
You mean hosting? Pretty well anywhere you can drop Ruby. I've had it running on shared Dreamhost pretty easily, providing you can cope with an older Ruby. Lately been moving stuff to DigitalOcean. The latter's base offering is only $US5 per month and you have the whole VM to play with. Depends on what you are planning on doing I guess.
As a Shelly Cloud owner I'm going to say [Shelly Cloud](http://shellycloud.com/), of course. :) It's as simple as Heroku (you just do a git push), so you don't have to worry about deployment much. We have a documentation page for rack-based apps (so including sinatra) that should get you started: https://shellycloud.com/documentation/rack_based_apps BTW it's interesting to start with sinatra first. I've taught some people web programming this way and it has its pros and cons. On one hand you don't have many new concepts to grasp, on the other there are some gritty details to worry about which Rails hides from you when you are starting out. Since you're focused on Ruby right now I think it's the right call. You will be able to learn one thing at a time this way. Out of curiosity: which tutorials are you using to learn Ruby?
Hey.. Shelly Cloud looks neat. Just some feedback though - the pricing calculator shows the current price under the fold. Took me a bit to figure out the sliders weren't broken - just the data was hidden down the page (looking on a laptop). Hope that's useful.
Thanks! Yeah, we're actually in the process of redesigning the pricing page. You're right the current cost should be more prominent, maybe even always visible.
Any street corner. Ruby devs are ridiculously employable.
Look to the sidebar, Luke! EDIT I was thinking of the /r/rails sidebar. There are some links to good job sites there. Ruby devs are in hot demand, good luck!
Read the source code, modify it for your needs, etc. It stops being magic the more you bend it to your will.
I've gone to the westside rails meetup on thursdays the last few months. It's usually a few people trying to get started and a few people who think they have the next big idea and are looking for some one to build it for them (for no pay of course). Haven't seen any legitimate employers there.
I spent a little time exploring dynamic finders and their pending deprecation. My final conclusion doesn't quite match the title however - I found that we have decent alternatives to the old syntax.
Check out the company, "MoneyDesktop"
I will give Shelly Cloud a try. I chose to start with Sinatra because when I was reading the Hartl book I felt that he was introducing too many concepts at the same time. I have never done test-driven development before and while it is something that I will have to learn I just can't learn 3 things at the same time (Ruby the language, Rails the framework, and RSpec the testing framework). So I decided to study Ruby by creating a small REST service using Sinatra. Just reading the Sinatra book and everything online. I used DataMapper for the ORM and erb for templating. Next up is probably RSpec or some other testing framework before Rails because I know Javascript so even without Rails knowledge, I can make an app like back-end Sinatra front-end Backbone or something to that effect. Then, Rails. I had experience with MVC (CodeIgniter) so I sort of know what to do but still, without a mentor it's not that easy for me. Here is what I did: 1. (Already know some PHP and JavaScript). Watch TryRuby and Rails for Zombies. 2. Read Sinatra book, hello world. Read first few chapters of pickaxe book. 3. Create some REST-service type thingie, while reading the pickaxe book (Pragmatic Programmer I think?). Still haven't finished that book. 4. Now I have to upload it somewhere, just to make development complete, so I'm looking for options. 
My personal stuff is up on Bluehost. There is a Rails option there but I haven't tried. I guess I'm a bit irritated at things because while I love Ruby, I had a traumatizing experience when I was installing it on Windows, so I feel that I'm going to repeat that experience again when deploying.
My company is hiring! http://jobsco.re/16202Lj
Trying to get any unixy tool working on Windows is like that. Often on a *nix the same process is one command. Don't be scared. 
Why is depending on Bundler a bug? Managing GEM_HOME and GEM_PATH is *technically* simpler, but *psychologically* much more complicated. Every time you open a terminal and switch project, you must never forget to set those environment variables to some exact path. You must manually setup a new directory every time you start a new project. You must manually manage the gemsets: installation, uninstallation and upgrading. And you must manually figure out whether the dependency graph you desire is consistent (i.e. whether there are no internal conflicts). And what if you wish to revert to a previous version of your project, e.g. to test whether a bug existed there, and that version had different dependencies? You gotta modify your gemset manually. And most important of all: if you manage gemsets manually, then are you also keeping on tab on which exact gem version you installed, so that when you deploy to production (or when another developer tries to setup an environment), the exact same gem versions are installed? Doing this manually is hell. Bundler does this automatically for you. So yes, you're introducing a new dependency. But if I have to choose between running a few thousand lines of code, versus manually managing things and potentially introducing human error, it's a no-brainer.
How does one go about getting hired by a company like that? Walking in and dropping your résumé probably won't work, as well as in person interviews being complicated. How do you get noticed? Having a pretty github profile?
Just find a company you like that uses Ruby and shoot them an email. Even if they aren't hiring they'll probably know someone who is. Also just because a company hasn't posted any jobs doesn't mean they're not hiring. Most companies will jump at any dev if they're a good fit and have the technical skills. Also what part of the country are you in?
Why is it a bug? Because it's an unnecessary dependency on a complex, fragile chunk of code. &gt; Managing GEM_HOME and GEM_PATH is technically simpler, but psychologically much more complicated. Totally disagreed. In general, what you're calling "manual" I call "scripted with a tiny amount of Bash". Bundler jumps through considerable hoops to achieve the same effects you can get with *much* less effort, which means that when it goes wrong, it's a load more effort to figure out why. &gt; Every time you open a terminal and switch project, you must never forget to set those environment variables to some exact path. I spell that[0] $ rv 2.0.0-p247 That can be called from autoenv if you prefer not to type it on switching projects. I tend to be testing against more than one ruby version for any given project, so I leave it explicit. &gt; You must manually setup a new directory every time you start a new project. `$ rv-init 2.0.0-p247` &gt; And you must manually figure out whether the dependency graph you desire is consistent (i.e. whether there are no internal conflicts). Nope. Bundler does this fine. &gt; And what if you wish to revert to a previous version of your project, e.g. to test whether a bug existed there, and that version had different dependencies? You gotta modify your gemset manually. `$ rm -rf .rv/; rv-init 2.0.0-p247; git checkout &lt;thing&gt;; bundle install` &gt; And most important of all: if you manage gemsets manually, then are you also keeping on tab on which exact gem version you installed, so that when you deploy to production (or when another developer tries to setup an environment), the exact same gem versions are installed? Doing this manually is hell. Bundler does this automatically for you. You're right, Bundler does all that for you, *entirely without being needed at runtime.* Use it to lock and install the gems, then let it get the hell out of the way. &gt; So yes, you're introducing a new dependency. But if I have to choose between running a few thousand lines of code, versus manually managing things and potentially introducing human error, it's a no-brainer. I'm still not seeing the upside of bundler at runtime compared with the relative simplicity (yes, including the cognitive simplicity) of taking advantage of the mechanisms we already had to manage the problem. I'm really not seeing where the human error creeps in here. [0] https://github.com/regularfry/rv.git
I'm in southern California, but willing to relocate absolutely anywhere for a decent offer. I'm even considering posting my resume on some Moscow job sites as I have some Russian language skill.
Run through [Hartl's Rails tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book) and then build something of your own.
It is. But you're also paid accordingly.
The rand method could allow you to "draw" the same item twice. While using shuffle and then pulling items from it will not.
Wait, so Bundler is a "complex, fragile chunk of code", but rv+chruby+gemsh isn't? Where does that distinction come from? Since when is Bundler fragile? Has it ever stopped working for you? Later on in your reply, you admit that you need Bundler for certain things, e.g. checking the dependency graph for consistency and installing the gems from the lock file. But earlier you called Bundler a "bug". Isn't relying on a "bug" do to things in your "simple solution" rather self-defeating? You've now introduced additional complexity.
And let me present you with a scenario that your simple rv solution does not cover. Let's say your app version 1.0 depends on foo 1.0 and bar 1.0. foo 1.0 depends on rack &gt;= 1.5 and bar 1.0 depends on rack &gt;= 1.0. You create the rv environment, gem installs rack 1.6, foo 1.0, bar 1.0. In your application, you require the libraries as follows: require "foo" require "bar" You commit and push. A colleague clones your code, 'rv init' an environment, gem installs the exact same versions you did (since Bundler is a bug, you wrote a nice text file detailing exactly which gem versions you installed, instead of using Bundler to create a Gemfile.lock, didn't you?). All is fine. At some point your app has reached version 2.0. It now depends on bar 1.1, which depends on rack = 1.5. You install the Rack 1.5 gem. But now your app fails while loading bar. Why? Because `require "foo"` required Rack 1.6 (after all its version specifier is &gt;= 1.0, so this is legal), but `require "bar"` requires Rack 1.5. 1.6 is already loaded so it can only error out. Bundler's dependency graph checking algorithm could have prevented this situation. But let's say that you *always* clears your rv directory every time you change your app dependencies, in order to avoid problems like this. That works. But what about that colleague that came back from a month long holiday? He installs all the gems in your text file, but forgot to clear his rv directory. Boom, error during startup. Frustrated, he sends you an email for help. As if you aren't already busy enough. With Bundler, this situation would never have happened. It would have just worked.
I think its good for any ruby and or rails developer, in this case sinatra.. to know how to setup a basic server with nginx/apache and the ruby/rails stack. I've been seeing a lot of people moving to the heroku/cloud deployments lately and I think its a shame, its not that heroku or could services are bad in any way, its just that I found it made me a better developer knowing how it works from the start..
Depending on where you are in SoCal, I know a lot of companies hiring. It may even be worth reaching out to a recruiter. Feel free to message me and I can put you in touch with some people. I'm in the LA area for reference
www.Rubymonk.com It's not the 'single best', but it is an amazing supplement to whatever other learning tool you so choose to use.
In my case, I've been doing Ruby for eight years, almost nine, I'm an ex-googler, I've done a bunch of remote work before, and they were already familiar with some of my open source work. (e.g., Addressable, which has a bit &gt; 10m gem downloads) I was explicitly looking for remote work because my GF and I are passionate about global health work and we needed location flexibility. We're headed back to East Africa for a month next week. She gets to do her stuff while I keep right on coding. Works out pretty well.
There AR drivers for mongo. MongoMapper is the first one that comes to mind, but there are others. 
[ThoughtWorks](https://jobs.thoughtworks.com/USA/JobDetail?id=784) (my ex-employer) hires fresh grads/junior devs all the time. I would think similar shops like [Pivotal Labs](http://pivotallabs.com/pl_job/software-engineer/) would be hiring juniors too. Also, don't just specifically look for "Junior Dev" positions. Employers are often willing to relax their requirements even if the job listing might say 4-6 years of experience required. Doesn't hurt to apply. Also, having an active Github is a good way to break the need-experience-to-get-experience deadlock.
I don't live or work in SF but as a somewhat senior dev working in Ruby amongst many other things, I would suggest two steps: branch out from Rails - we don't use it anymore, there are so many front-end pieces that do a better job and rails is at most just one part of the puzzle. Along with that, find some open-source project that is interesting to you and spend some time and energy working on that. You will get good experience and hopefully learn from others on the project. It used to be that I could know one language/tech and get work, but these days it seems like we have to be familiar with a dozen different apache projects and have hands-on experience with a variety of frameworks or tools just to be able to contribute. I hope that helps.
Find a recruiter who works for startups.
Thoughtbot's learn prime is a little pricey, but really good: https://learn.thoughtbot.com/prime
So you were already a rock star before you went into it. That doesn't really help me, but thanks for sharing :P I guess the bottom line is "be awesome and you'll get any job anywhere".
San Francisco
First thing: do you have a github (or equivalent) profile somewhere? That's key. Do you have a LinkedIn profile? Is your github account on there?
You should try the main meeting. Seriously, there are a lot of people looking to hire. 
I can only wonder how many other boots are reading your thread Ben. Also check out /r/webdev
You hiring guys that *do* know Ruby but just not a lot of experience? Cause that is me. I love Ruby and would love to get better.
As someone who is diving in to Ruby now, thanks for these links. Has anyone tried: https://onemonthrails.com/ ? 
try [Hired](http://hired.com), they have a lot of SF employers who are looking for Rails devs
Go through https://angel.co/jobs and apply to anything that looks interesting. A lot of them will jump on a rails dev, even a junior one. Previous experience as a product manager is pretty handy. We had a DB alum at my current company for a few months on contract and he was pretty great. Really driven, although weak on fundamentals. I'd take him over a As for advice: - Get on github. There are a lot of ways to demonstrate that you can build stuff, but putting code on github is probably the easiest. - Build something useful. I put together a site for sharing .vimrc snippets a while back- super simple, but it made it to hacker news and it's a great talking point for interviews. - Try startups if you haven't already- there are a lot of really awesome companies out there paying market rates and that are desperate for web devs, especially in SF. - The best job boards I've found have been AngelList, HackerNews' monthly "who's hiring' thread (collected by a third party here: http://hnhiring.com/), and StackOverflow careers. Also, I don't know if we're looking for someone junior right now, but I work at [Threadflip](http://www.threadflip.com/jobs) doing rails dev on a 6-8 person dev team (depending on how you count). You should apply!
Where and when?
There's a lot of Ruby here, actually. Get in touch with Pivotal, Riot Games, Hulu... and a few shops in Venice, too.
Yeah but in that case you're managing 1) you're compilation pipeline (maven etc.. yuck!) 2) manually deploying by drag and drop 3) aren't managing your database migrations/asset compilation could it be improved? sure! but don't forget all the things you're getting.
Thanks. I've came across that. But I read in the comments that he suggest learning html CSS and Javascript before going in to rails. Which I have little experience in. What do you think? 
Thanks 
Why would you learn a web scaffolding framework like Rails without knowing the other core parts of the scaffolding?
Your own mind.
&gt; And let me present you with a scenario that your simple rv solution does not cover. Let's say your app version 1.0 depends on foo 1.0 and bar 1.0. foo 1.0 depends on rack &gt;= 1.5 and bar 1.0 depends on rack &gt;= 1.0. You create the rv environment, gem installs rack 1.6, foo 1.0, bar 1.0. In your application, you require the libraries as follows: require "foo" require "bar" You commit and push. A colleague clones your code, 'rv init' an environment, gem installs the exact same versions you did (since Bundler is a bug, you wrote a nice text file detailing exactly which gem versions you installed, instead of using Bundler to create a Gemfile.lock, didn't you?). All is fine. At some point your app has reached version 2.0. It now depends on bar 1.1, which depends on rack = 1.5. You install the Rack 1.5 gem. But now your app fails while loading bar. Why? Because require "foo" required Rack 1.6 (after all its version specifier is &gt;= 1.0, so this is legal), but require "bar" requires Rack 1.5. 1.6 is already loaded so it can only error out. Bundler's dependency graph checking algorithm could have prevented this situation. Not applicable. &gt; But let's say that you always clears your rv directory every time you change your app dependencies, in order to avoid problems like this. That works. But what about that colleague that came back from a month long holiday? He installs all the gems in your text file, but forgot to clear his rv directory. Boom, error during startup. Frustrated, he sends you an email for help. As if you aren't already busy enough. With Bundler, this situation would never have happened. It would have just worked. I've traded off getting an easily-addressed support email against being woken at 3am because of a dependency resolution bug hitting in production. Seriously, if this happened more than once, I'd take a look at `bundle --standalone`, or something like it, but it's never come up. There's a psychological effect at play here too, though - because you know that all your dependencies are in a single directory, and that directory can be easily rebuilt, there's little resistance to the idea of just blowing it away and starting again. It's pretty good practice to do that anyway, since you're guaranteeing that your environment hasn't drifted too far from production. In your hypothetical example, it's not unlikely that, upon hitting a problem like that, my colleague would have clobbered his project directory and started again from a fresh clone without having needed to contact me at all.
insanely helpful reply, thank you!
encouraging, thank you
great advice, cheers
yes and yes. I need to clean up my github asap. thanks for your reply.
thank you
cheers, thx
cheers, thanks for the advice
&gt; Not applicable. And why not? If you work on any non-trivial app you will quickly run into similar dependency scenarios. Of course, you can pick your dependencies carefully to avoid the scenario. But the thing is, you as the developer shouldn't *have* to think about and avoid these scenarios: it should just work, all the time. Anyway, this all boils down to whether Bundler actually is buggy or not, and whether Bundler's approach is *inherently* buggy. You belong to the camp that equates more code with inherently more problems. I do not: in my experience, more code can sometimes solve or prevent problems, depending on the circumstances. Let's conclude the discussion here.
I'm looking for something like this. Do you mind if I take a swing putting it together in OO Draw or something? I'd post it.
I was under the impression that you didn't have to know those before giving Ruby a shot 
&gt;&gt; Not applicable. &gt; And why not? Because I use bundler and check in Gemfile.lock to avoid precisely the situation you describe. I just don't use it *at runtime*. This sort of version mismatch is only ever a problem if clobbering and rebuilding $GEM_HOME is expensive which, given a local gem mirror and the fact that doing so can't affect any other projects, it isn't. And if it ever happens, it's also an easy problem to spot: since rubygems gives you a nicely descriptive error, and you know the "wrong" gem version isn't being depended on by any other projects, you can `gem uninstall` your way out of it if you want.
Ah excellent thank you. But how come the code works fine in 1.9.3?
Appreciate the help. I just changed the IF statement to if @wpn.to_i and I have it working. Thank you.
What fundamentals are missing from the Devbootcamp alum?, like ruby/rails ...I am learning rails right now, can you reccomend books or projects that can help in my learning? thanks
Ruby, no. Rails, yes. You mention you want to learn Rails. Trying to do a site in Rails without understanding how you can leverage CSS + Javascript to make your life easier is definitely hard mode.
It doesn't. $ ruby -v ruby 1.9.3p448 (2013-06-27 revision 41675) [x86_64-linux] Check if it could work: $ irb 1.9.3-p448 :001 &gt; '1' == 1 =&gt; false Running the game to show that is uses the default damage instead of axe damage: $ ruby game.rb Choose your weapon! Press 1 for Sword And Shield, 2 For Double-Handed Axe and 3 for daggers. 2 2 You find a monster. To attack, press Enter! You attack the monster for 8 damage The monster now has 142 health. Press Enter to continue. Correcting the line to **@wpn = STDIN.gets.chomp.to_i** gives us $ ruby game.rb Choose your weapon! Press 1 for Sword And Shield, 2 For Double-Handed Axe and 3 for daggers. 2 2 You find a monster. To attack, press Enter! You attack the monster for 20 damage The monster now has 130 health. Press Enter to continue. Which seems to be what you want.
FYI mdam = (rand(11)) if mdam == 9 mdam = @mon_atk * 2 elsif mdam == 10 mdam = @mon_atk * 4 else mdam = @mon_atk end can be rewritten to mdam = case mdam when 9 then @mon_atk * 2 when 10 then @mon_atk * 4 else @mon_atk end or if you dont like the "thens" mdam = case mdam when 9 @mon_atk * 2 when 10 @mon_atk * 4 else @mon_atk end 
Ah this is a simpler solution to the one I came up with. That is very strange, it was working for me in 1.9.3.
Glad to help! I would have included some other info, but I'm on my phone, sorry. You could easily tighten up that code a lot! Ruby style is your friend :-) If you're interested, I can poke at it later.
I'm very excited about Go, but my current workflow in production is still RoR based. Its called being Pragmatic, nothing wrong with that. I only switch to some technology when it has large community, great tools and libraries, automated and powerful deployment options, etc. I hope I can switch to Go in 2-5 years. Till that time, I'm sticking with Ruby.
I've been learning Ruby for about a week and a bit. I don't even know how to write tests. Could you explain how?
I tried it! I think my biggest complaint is that it's basically a screencast. The instructor doesn't really explain why everything fits together the way it does. One good thing is that you have a fully functional pinterest like site up by the end of the tutorial.
I was with you for about three quarters of it, then I hit my limit of knowledge. Great tutorial though, and I hope to get it up and running :)
Absolutely fantastic for beginner or intermediate Rubyists. I went to RubyConf on my own dime as a brand-new beginner and it was a huge learning experience and motivator. They do three talks at a time, basically a beginner, intermediate, and expert room, so there is always something interesting going on. You should expect a bunch of excited, friendly Rubyists. Leave extra space in your bag to bring back all the swag. Free tee-shirts, bbq sauce, you name it. Lots of folks from the community looking to recruit. Absolutely worth taking off and paying your own dime. (I’m super looking forward to doing just that for the third time at this year’s RubyConf!) I can’t think of any concerns. For sure be bold and introduce yourself and meet lots of people, even if you’re a novice. I think make the most of it by asking lots of questions, participate in hacking on stuff, and meet lots of Rubyists!
codelitt.rb has an error. you should be include 'sinatra/base', not 'sinatra', otherwise the app will run twice.
Hey there Ruby friends! We're super happy to open the 2014 CFP today! We're working hard on locking down the exact date (most likely March 6th and 7th, but it depends on the venue).
I think the sheer quantity of knowledge is the biggest thing that intimidates me. Even if more than 50% of the talks are useful to me, I feel like coming back to reality and the day-to-day routine, the retention will change from fresh knowledge to just a recollection of some ideas. Thanks for the response, I think I just have to dive in and participate in a few.
I was 50/50 on going to GoGaRuCo. I feel like I should have just gone. I'll do my best to be there next year! Are you from the Bay Area? Maybe I could pick your brain some time!
God, I hate the term 'rockstar' so much. In any case, the career path I took was not a hard one really. I saw unmet open source needs and filled them in the most OCD way possible and then found people on StackOverflow who were trying to solve problems that my libraries solved. Did that a bunch of times and eventually my stuff started becoming a common dependency. That became part of my freelance pitch: There's a damn good chance you're already using my code, whether you realize it or not. And so on. Every career starts somewhere and then builds on itself.
Damn. You're right. Thanks man. 
Rent did go up a bit by the time I left the Bay Area, but the most I ever paid was $1050/mo. When I was apt. shopping, I did find unfurnished places in Mountain View/Sunnyvale for $900/mo. with no roommates. Tiny places, mind, but they do (did) exist. I totally agree that $75k is low. But that was my point. The shittiest SF dev salary is still good relative to the rest of the country. Cost of living sucks, of course, but it's possible to keep it down and there's a lot more upward mobility.
What are you looking for in sponsorships (amount, other things)? I'm going to pitch it but not sure if they'll bite seeing as the company is based back east. But you never know.
Here's what worked for me: https://gist.github.com/postmodern/6912812
Yeah, sure I'll work it out next time through though :)
what. are. you. talking. about.
1 in 11 people don't write tests for their code. 
Is it just me, or does this look like a bro-grammer conference? After parties? I'm all for a drink after a conference, but seriously, after parties? 
I can confirm this.
I prefer style 1 when there are a handful of methods and style 2 when I have methods and attributes. I believe a third style would be "extend self" if you don't have any instance methods or instance variables.
Not sure I want to log in using my Github credentials, and I don't have a Twitter account. Why must everything be tied into social media these days?
I can assure you this is not a "bro-grammer" event. We usually have a company or two that wants to sponsor an after party at a local bar. But, you do bring up a good criticism and I think I'll take that wording off. Our main goal is to give Rubyists a fun event in a fun little town in Oregon where they can learn and network. 
I understand the concern. I feel that way when places want me to sign up with Facebook and/or Google. On the other hand the GitHub OAuth flow is pretty secure for you and us since we don't store any passwords and you control what data we have access to (including revoking that access). I toyed with going back to a "regular" username/password combo but the friction it caused when wanting to submit a talk felt "too damn high". The only things we store is a reference to your GitHub username and an email if you submit a proposal. This also helps us immensely when assembling the speaker pages as we try to link to GitHub profiles first and other social networks secondarily.
Thanks for sharing. Very nice looking site, by the way.
Thanks! It's an octopress theme called Octoflat https://github.com/alexgaribay/octoflat
I tried to refactor what I had based on what you just showed (thanks for that btw). And I get this error: emp.rb:37:in `setpos': already closed window (RuntimeError) from Desktop/emp.rb:37:in `initialize' from Desktop/emp.rb:219:in `new' from Desktop/emp.rb:219:in `&lt;main&gt;' It also throws a RuntimeError if I try to use the `scroll` method or set `scrollok` to true.
Maybe I'm missing something, but there's no cost to sell in your classes... It's important that selling is never more beneficial than waiting. 
There's no selling period, at this point anyways. There's no real point in ever selling anything in cookie clicker anyways. I can't honestly say I understand why selling is included in the actual game. I intend to get there, but, just haven't at the moment. :) So, if missing anything, it's the fact that there's no selling at all yet. :P
It bothers me when people use `alias_method` or `alias` when doing aspect-oriented programmming. In this particular instance, it seems unlikely to cause issues, but it's easy to see how it could cause problems in cases like class Bar alias_method :real_foo, :foo def foo(*args,&amp;blk) puts "before: #{args.inspect}" rv = real_foo(*args,&amp;blk) puts "after: #{rv.inspect}" rv end end # sometime later, perhaps in another file class Bar alias_method :real_foo, :foo def foo(*args,&amp;blk) @foo_count ||= 0 @foo_count += 1 real_foo(*args,&amp;blk) end end Now `Bar.new.foo` is going to blow your stack. A related error using `Mocoso` is a bit more contrived: def obj.foo :original end stub obj, :foo, :outer do assert_equal :outer, obj.foo assert_equal :original, obj.__mocoso_foo stub obj, :foo, :inner do assert_equal :inner, obj.foo assert_equal :outer, obj.__mocoso_foo end assert_equal :outer, obj.foo assert_raise(NameError) { obj.__mocoso_foo } end # raises NameError undefined method `foobar' for class ... The way around this is just to use method objects def stub object, method, result, &amp;block metaclass = object.singleton_class original_method = object.send :method, method invoked = false metaclass.send :define_method, method do |*args| invoked = true result.respond_to?(:call) ? result.call(*args) : result end begin yield(original_method) ensure metaclass.send :define_method, method, original_method raise "Expected method #{method} not invoked" if !invoked end end Then you can do def obj.foo :original end stub obj, :foo, :outer do |original| assert_equal :outer, obj.foo assert_equal :original, original.call stub obj, :foo, :inner do |outer| assert_equal :inner, obj.foo assert_equal :outer, outer.call assert_equal :original, original.call end assert_equal :outer, obj.foo assert_equal :original, original.call end assert_equal :original, obj.foo This approach avoids the error entirely. It doesn't pollute the namespace, and lets you add as many aspects as you like. 
What I forgot to say: cool library!
&gt; I see a ton of Rubyists talking about Elixir and Node.js as somekind of wholesale replacement for Ruby. In wat alternate universe have you been living where Ruby programmers have been evangelizing for Node.js?
I think it is a mistake to "leave" any language and never come back. While exploring new languages is fun (or annoying if the language hasn't stabilized), I think we still have yet to tap Ruby's full potential. For example, it is relatively easy to write asynchronous networking code using good old [IO.select](http://rubydoc.org/stdlib/core/IO#select-class_method) and callbacks, or implement the consumer/producer pattern with [Queue](http://rubydoc.org/stdlib/thread/Queue) and an Array of Threads. I'm also excited about the implications of [Ruby 2.1.0](https://www.ruby-lang.org/en/news/2013/09/23/ruby-2-1-0-preview1-is-released/), [Rubinius 2.0.0](http://rubini.us/2013/10/04/rubinius-2-0-released/) and [Celluloid](http://celluloid.io/).
I think the minute people stop trying to learn from other programming languages is when Ruby will stagnate. I am getting a lot of tribalism from this post. Ruby is going to be okay if some people go learn Elixir in their free time. I honestly have not heard of too many people outright dropping Ruby for Elixir. I have heard people doing so for node and all I can say is I wish them luck. Erlang and by extension Elixir solve some problems better than Ruby. Erlang has a better concurrency story than Ruby. That is not likely to change any time soon. Why should "old fogeys" stick to Ruby if they encounter a problem that requires better concurrency tools than Ruby can provide. Why should they refuse to learn a new language because it is new? Who benefits from that? I also don't agree with the idea that they are throwing away the time they spent learning Ruby. They solved problems with Ruby. Software got shipped and they most likely paid the bills with the earnings. That is a tool that served a purpose. Also nobody says that a person only has room for 1 programming language in their head at once or that they can only use 1 programming language for any period of time. It just isn't true. I code Ruby all day at work. When I get home I code Haskell. I can do both. Furthermore, I can find ideas that the Haskell community has and bring some of them over to my Ruby code and vice versa. Furthermore, I have another tool in my belt I can use when Ruby's concurrency model or dynamic typing isn't cutting it. tl;dr chill out and never stop learning.
The main arguments for node.js are speed (in some cases up to ~10x faster, and you don't need to be writing C), fact that you need to know only one language for web development (as opposed to one for backend and one for front-end) and possible code sharing between front-end and back-end. Arguments for elixir are that it has a very similar to ruby while adding more goodies from erlang. Ruby is a pretty slow language. This was probably fine back in the day but it's starting to matter more these days. If you like C++, you should check out node.js since it's written in C++.
There's a popular culture in (particularly web) development that tends toward the overstated idolatry of "cool things", influential (wealthy startup) people, etc. Check hackernews - there's a new, hip JS library every week on the frontpage. Hyperbole gets out of hand, and people say things like "Foo language can and damn well should replace all other languages." That's all this is. Node has impressive performance benchmarks (the MongoDB of frameworks at the moment) and is a very cool project. There are problems that it is perfectly suited for. Nothing is perfectly suited for all possible problems. http://nodeos.github.io/ &lt;- I rest my case.
So, I'm in the middle of writing a series of blog posts called "Elixir for Rubyists". In fact, tomorrow and Saturday I'm going to a two day intensive Erlang workshop. I love Erlang and Elixir... And yeah, I could write pretty large systems in either instead of Ruby... that doesn't mean I hate Ruby or want to leave it. I'm *young*, both in age and number of years seriously digging into code. That said, a few things *seem* clear to me. 1. The number of languages that exist will just keep increasing. The communities around them come and go. One year a particular language will be exceedingly popular, the next, people will have moved on to the new hotness. 2. Due to 1, it doesn't make since to me to tightly couple my career to any particular language. It sure would suck to spend the next 15 years of my life as a "great **ruby** developer" and then watch the community around it die and be left having to learn everything over from scratch. 3. I *happen* to have a keen interest in languages and love reading about new ones and trying them out. In doing so, I've found that I generally learn things from other languages that make me better at my primary language (Ruby). In particular with Elixir, functional programming causes you to think about problems in a very different way from OO programming. Writing Elixir and Erlang has definitely improved my Ruby code I write during the day. 4. Being pragmatic means picking the right tools for the right job. You can probably hammer a screw into the wall... but that doesn't mean that was the best way to get the job done. Look... I'm not trying to claim that Rubinius or Celluloid are wasted efforts or anything. I'm really excited about getting to play with Rubinius 2.0 and at my day job we use Celluloid... But I *am* pragmatic and want to pick the best tool for the job. Erlang was built around concurrent problems. It's much easier to write concurrent code that's easy to understand and gives you better errors in Erlang than in Ruby. Period. That doesn't mean I hate Ruby or I'm leaving it or I won't implement some complex system in Ruby. I spend most of my time writing Ruby. I just also like Erlang. I'm *loving* Elixir because it's bringing the expressiveness of Ruby to the Erlang VM. As far as the early adoption part... I'm having a hard time comprehending a technically experienced person not understanding the value of coming onto a thing during the early stages. Why would anyone *not* want to jump into something like Elixir and work towards molding it into something they love to use?
I know someone who firmly believes node.js is the answer to every problem. And he also believes there are problems that only node.js can solve. I was.. shocked.
Of course other things can be learned from other languages, I am all for this. Just by the name I am guessing a 'promise' is sort of like a C++ 'future'. A function or object that executes asynchronously and can be checked for its result later. Is this at all close? If not, can you suggest any reading before I jump off into Google land?
Forgive me, I am not trying to be tribal. I am questioning the logic of leaving a hard earned skill behind (or perception thereof) for new and dubious territory. I called myself an 'old fogey' for hailing from C/C++ land and liking it. It is my understanding that non-MRI implementations of Ruby had threading solved (jRuby/Rybunius seem to do good in benchmarks), and that MRI/YARV was being improved. Combine that with how few problems seem to require threads in the first place. No one needs to chill out, I wasn't trying to get angry or get anyone angry. Of course I agree always learning is good. I think that sometimes learning the details of a language can be worth more than a new language.
Of course, what I am suggesting is that more Rails developers becoming involved in major JS frameworks could have been misconstrued by OP as "Rubyists talking about Node" (which alone doesn't strike me as accurate, in agreement with your original post).
10x increase in speed. That is not the smallish gain I was thinking it would be. Surely this must be in applications that implemented poor algorithms. Do you have some benchmarks, articles or example applications I could read or look at? It has always come in waves of Perf over expressiveness, then expressiveness over perf. Once upon a time C/C++ was that slow and expressive language. Ruby is nowhere near its best theorhetical performance using just known techniques, certainly things still look bright for it. I will look again at node.js I only looked at the Javascript API before today.
I was under the impression that the design of node.js prevents it from becoming self-bootstrapping. Does this friend have an opinion on that? To someone actually interested in pragmatism the world is compose of *more* than just Hammers(node.js) and Nails(every problem) Edit - grammar
You got it. http://wiki.commonjs.org/wiki/Promises
There is a bunch of them, some of which have more merit than others. This one comes to mind http://highscalability.com/blog/2012/10/4/linkedin-moved-from-rails-to-node-27-servers-cut-and-up-to-2.html Basically, Linkedin switched from rails to nodejs for their mobile site and went from 30 servers to 3. And apparently in some cases the perf increase was 20x. I guess you could object that some of that slowness might be due to rails and not so much due to ruby. There was a thread about this on HN https://news.ycombinator.com/item?id=4613870 where people were saying that Linkedin could have achieved similar perf increase if they rewrote it in rails but I kind of doubt that. The issue with ruby is that the expressiveness is at odds with performance since ruby needs to keep a lot of the code around to achieve metaprogramming and such. Not to mention the fact that MRI does not have real parallel execution due to the GIL (JRuby might? I'm not sure. I think that it does). There was also this series of comparisons http://www.techempower.com/benchmarks/ It does not seem like node.js did all that well but my guess is that that's due to the way the tests were done (as in kind of few requests at a time). I'm guessing that with more concurrent requests, node.js (or other evented frameworks on that list) would have done better. 
These seem like well reasoned responses to me. Thank you for putting the time into this reponse. I agree the number of languages will just increase. I do not agree that all will die though. For example even though Java is losing both market and mindshare (and its sex-appeal) it seems only be gaining developers, just not as quickly as everything else. For an extreme example I work with some Cobol developers that make preposterous amounts of money because of the demand for their skill. Sorry, If I gave the impression of picking only one tool. Please note that in my original post I included some of the other languages I have used as the situation demanded. I like Valve's philosophy of 'T'-Shaped employees; Become an expert(world class if possible) at one thing and learn as many other things as possible to a simple working proficiency. A large number of people like this can do impressive things rapidly and can learn from each other in natural ways. I have two issues with your comments on molding. First, there is risk. What if significant time is invested in a thing and it cannot be molded despite this. Look at the history of BSD forks for clear examples this. Theo De Raadt said much about the design of other BSD systems and his efforts to *mold* them, yet his epic amount of effort failed in his eyes. Thus he forked NetBSD(I think, could have been FreeBSD) and started OpenBSD. My second issue is cost. As you mentioned there is a plethora of languages out there. Most of the time isn't it easier to pick something else than to change something else into what you need? Of course this doesn't apply to original research and a few other kinds of projects, but it almost always applies when dollars are on the line. Another cost is people. Employees are expensive, employees with rare-skills are expensive, and even training employees is expensive. Leaving money out of this, community impetus is a rare commodity using an already popular can affect it, but so can riding trends as you described. I can clearly see now why someone who hasn't picked their area of expertise, a startup or a research group at large company would drop Ruby for something new and untested.
Its more about easy-to-reason-about async io than threading, IMHO. Go also benefits immensely from having concurrency (read: NOT parallelism) baked into it's syntax with go channels.
I will point out, saying it is a 10x increase in speed is meaningless. Node.js is a application server-ish kinda thing. Or, at least, a way to easily make your app it's own server. Ruby is...a programming language. Comparing an evented server running javascript apps to a programming language is, needless to say, pointless. To quantify speed gains, you would need to talk about how you are serving up ruby. And to that point, there are a LOT of ways to do that. There are things like passenger, unicorn and thin. These are pretty unexciting, not super fast, but useful servers. They handle the job for 95% of people just fine (I just made up that number). The thing you have to keep in mind though is that we also have JRuby, which gets your ruby on the JVM with all the fancy app servers that has available. We also have evented servers like nodejs, such as Event Machine and Goliath which can easily match or beat node.js with good old ruby. Here's a nice video comparing node and event machine if you're interested: http://www.youtube.com/watch?v=U7dbQ4cIe34 So the upshot is, ruby is slow but it can be fast enough for almost anyone. And the big thing you get out of node.js is not language speed, but a speedy evented server, which is something you can also get for most every other language. And personally I think Ruby is a lot more fun to write than javascript. That said, I do like other languages as well. I'm personally quite fond of Scala as it's a neat functional language and what I think java should have been, but it's a pretty niche market. I also like Go a lot for a simple backend/api type setup. I think node caught on because it was quick and easy and a lot of people knew some javascript already due to front end work (and being able to reuse your frontend skills on the backend is pretty enticing). In the grand scheme of things I think it's a fine solution for some problems, but if your goal is absolute performance I think there are plenty of alternatives worth considering.
No, it's because node / chrome has a blazing fast recompiling JIT. For the same reason, PyPy is most often much faster than CPython.
JRuby and Rubinius removed the GIL so Ruby is less hamstrung when doing threading. As I understand it, library authors are putting a lot of effort into leveraging existing threading code from the JVM into something more palatable for Ruby folks. All of that is good. However, that only gets you so far. You're still doing parallel programming in a language with shared mutable state and you have to deal with all the headaches and hazards that come with that. Some people are looking to different languages/paradigms that trade a different set of constraints for better characteristics. Elixir is just one of those languages that people may look into. I doubt people are rewriting large amounts of code in Erlang or Elixir where it isn't warranted. That is really expensive. Instead they are hopefully introducing it in an area where it does a better job. Ruby *is* a fine language. Its just that some of the things we really like about it are actually tradeoffs that subtract from other columns, and some other languages are stronger in those columns. Sorry for implying you were angry. I misunderstood the intent of your post and ran with it.
For people dealing with low concurrency situations or workloads that can be handled serially, Ruby rocks. If you need to deal with highly concurrent and long blocking workloads it's less than idea. This is where things like node.js, elixer, Erlang and (my favorite) Go really shine.
I think it is implied in these kind of coarse comparisons that comparable software would be compared. There are plently of web servers that ruby can run/load to make the comparison easy enough. Doesn't Nginx do asynchronous IO too, or something else like it, as well? I thought it was the high performance Ruby web server of choice.
definitely googled
Don't forget celluloid. Its my favorite eventloop stack as of late
Ruby has "freeze"
The place where node dominates is on benchmarks that have a lot of IO since the language by design cannot block. The problem is the nested callbacks of doom. If you want expressiveness and speed all in one place skip node and try go. It's faster, more expressive, and has better concurrency primitives.
I really like your response. I would point out two things. 1. I'm not sure there's as much cost or risk in either of the two technologies you mentioned (Node and Elixir). Node seems to actually have a lot of the typical tooling and libraries you might need and has a pretty large community around it that doesn't seem to be slowing down any time soon. Elixir... frankly there just aren't many people using it in production. So any cost and risk is pretty much taken on by developers in their free time. Beyond that, you can use Erlang libraries in Elixir code, so you have about 25 years of work to build off of. Elixir is shockingly mature for it's young age. The community is definitely small and it's more of an unknown as to whether or not it will continue to pick up steam... but it reads like Ruby and is a functional language and Rubyists do seem to be trending towards wanting to learn FP. 2. Really more importantly, there's cost and risk associated with any technology you pick. Granted, if you're picking, say, a dot net stack rick and cost are pretty predictable... But if you're a company you're betting that you will continue to find developer who writes that particular language and doesn't cost millions of dollars. If you're a developer you're betting that the community will still be around in x amount of time and that people will want to pay developers to write it. **OR** maybe you just enjoy playing with new toys and don't care if you spend a lot of time on something that never gets used to make money... in which case risk and cost probably don't mean crap to you. I guess I just don't see people leaving Ruby, or any language that matter, totally behind for something new. Maybe it's just because I'm young and haven't been around the block long enough. But it just doesn't make sense to me that anyone would just up and leave any particular language behind and I don't know anyone doing it.
Snake Plissken? I thought you were dead.. 
The Ruby community has always been about exploring other languages and practices, that's what has made it so diverse and, in my opinion, great.
Sponsored events in the evening that usually include free beer is a pretty regular thing at conferences...
Ruby/Rails has been an awesome experience. You can quickly build a web application. I have a C/C++, Java, Python, Smalltalk background and have doing this longer then I care to admit. But why venture out of Ruby world? Well performance. Ruby is fine for 99% of most web apps. When we started hitting some crazy volumes to ingest data we started exploring other tech but use Rails as the main customer portal. Couple of technologies have come out in the investigations such as GoLang and ZeroMQ. If your a C/C++ guy you will love the cross compilation and ability to build for different platforms and chipsets. Threading is a dream. For backend SOA architecture ZeroMQ is pretty interesting and performant. It can be a nice glue across many languages. If you are exposing ZeroMQ so it is publicly accessible you may want to wait for security to be rolled into the next release or look at CurveZMQ. I see it as more of a progression of build it fast (Ruby/Rails) and then optimize the slow bits if needed by staying in Ruby and if need be reach out to other tech as necessary. I don't know anyone that just drops Ruby wholesale.
Try doing it one at a time, let us know the results of: Locations.first Locations.first['data']
We just opened up the Ruby on Ales CFP and I'm astounded by the number of Elixir talks ALREADY submitted. I had no idea so many Rubyists were playing with Elixir. Your comment about conference talks seems to correlate with what I've seen the past three days.
&gt; I think it is implied in these kind of coarse comparisons that comparable software would be compared. That is very generous of you. However this is rarely the case... Most benchmarks are meaningless and in the end the only one that really matters is the one testing your specific problem and how various solutions perform. &gt; There are plently of web servers that ruby can run/load to make the comparison easy enough. There are. That doesn't mean someone claiming node.js offers a 10x improvement over ruby actually took the time to do a valid comparison. In all likelihood, and no offence to the person who said it, they are likely just reciting some figure they heard somewhere else and have no idea what the parameters of that comparison were. &gt; Doesn't Nginx do asynchronous IO too, or something else like it, as well? Yes. But it's just a web server. It would have to still talk to a ruby application server, which may or may not be evented/async. &gt; I thought it was the high performance Ruby web server of choice. I know very few people using nginx to serve ruby apps. It is not uncommon for it to be used as a reverse proxy for ruby apps however. I don't have any hard data but I would guess that passenger is by far the most common way of serving up ruby apps, with thin and unicorn coming in next. 
Good point, thanks. I often forget the built in evented server is just one component of node (even though I use node based apps on the command line daily!).
I am well out of my depth here but it is my understanding that there are still a massive number of land mines down that way in C++. I get that impression most recently from articles like [Edward C++ Hands](http://bartoszmilewski.com/2013/09/19/edward-chands/). I do feel confident in saying that if immutability is something you really need when doing parallel program, you will have a better time with a language to which that concept is central like Haskell and some of the other FP languages than a language like C++.
Ironically, we're calling something that has been out for barely 3 years "old". Never again, Apple.
I know... FIRST has its drawbacks apparently.
Yeah, they were trying to maximize their profit margin, so they cheaped out on all the internals and put it in a pretty case. They pulled the same crap with the original Macbook Air too. I'll have to poke at your script when I get home - my ipad 1 could certainly use some love.
Maybe give [Try Ruby](http://tryruby.org/levels/1/challenges/0) or [Hackity Hack](http://hackety.com/) a try? 
holy cow, I haven't even started using Ruby 2.0 yet
Appfog is a good choice. Running my sinatra app on it right...now...
What's stopping you?
My project is using jRuby and it doesn't look like jRuby's 2.0 support is that great yet, so I haven't really had any motivation to start using it
If you are that new, I wouldn't worry about the meaning of objects and classes. I didn't have a good understanding of them until a couple years after learning them. Just start programming. You will learn as you go. In Ruby, everything you use will be an object and you will eventually figure out the importance of that. Figure out what you want to build and start building it. Maybe you like solving small puzzles or maybe you have something bigger in mind. If you have some code written, post it here and I will give you an object oriented implementation of it. That might help you see the difference.
There were a bunch of coders who got into Ruby because it was hot, and may be leaving because there's a new hotness elsewhere. I don't have any evidence of this, but I did see a lot of Rubyists buy the Armstrong book because Erlang seemed to offer the novelty they were craving (yes, I admit..). But, as other posters have noted, there's also trend in Ruby to look outside for new ideas and bring them back to the fold, because Ruby is still one of the nicest languages to code in. Node may be hot, and it may be fast, but where's the love? Where's the joy? Ruby still has programmer happiness baked into its core.
Avoid before(:all) and let! They indicate failure to segregate your unit tests. 
I like to use let liberally with nested contexts with a single before block in the outer context doing all my mocks. I thus change what the mock is expecting/returning based on context with minimal repetition...
this could be huge
I agree with this. Often when glancing back up at the method signature, it's a good reminder that it's a class method. 
I like [Learn to Program](http://pine.fm/LearnToProgram/) by Chris Pine. but what really made me understand Classes, Methods etc was [Beginning Ruby](http://www.amazon.com/Beginning-Ruby-Novice-Professional-Experts/dp/1430223634)
Notice you used my snoo library. How did you like it? Anything you think it might need?
Wow...4 years for me and I didn't even know the sandbox feature existed. Thanks!
Here is "the" collection? As in, the official collection? I don't see a reference to it anywhere on the capistrano website.
So.... no Rails recipes yet? Bundler, asset compilation?
It has been released for a while, but sadly many tutorials and whatnot are not updated to v3. http://www.capistranorb.com/
Richard, in your let example, I don't understand how the second it-block is functional without something in the db. I see that you're saying that the let block doesn't yield a `tag` instance because it isn't asked for, but isn't `Tag.all` going to return an empty set?
There actually is hosted rdocs! http://rdoc.info/github/paradox460/snoo/frames
The title is quite misleading. Rails and bundler support have been broken out into separate gems: * https://github.com/capistrano/rails * https://github.com/capistrano/bundler
This title is very misleading. These are simply one person's recipes, not an official set released by the developer of Capistrano.
Setting up a new dev environment is a pain, and setting up a new deployment instance is a pain. Thing is that once you set up an environment, you don't have to do it again for a long time usually, so you end up never bothering to create scripts to make it easier. So every time you do it, you have to forage through a thick garden of installation and configuration paradigms (rvm, bundler, git, yum, jenkins, etc). So couldn't there be a standardized master script that installs everything and automatically puts a reasonable default cohesive setup together? So on your first day when you start a new Ruby project at a new workstation, you are spending your time getting running instead of getting setup.
you should think about renaming it, cause that's [confusing](http://en.wikipedia.org/wiki/Shard_\(database_architecture\)).
I was thinking, a shard is a piece of a gem. 
Maybe jewel instead? Don't get me wrong, I like shard as a name. Just tossing out options. :)
I made [this](https://gist.github.com/redjazz96/6944560) compatible with shard. Yay!
shard redjazz96/rbinit_project That's pretty sweet... I don't need to include any gems, or download any files... all I need to do is just run a shard, and it loads your script. I like it!
How about that :) I ended up reading the source.
Sorry to all you guys about my title wording. I never thought that you'd expect an official collection of recipes. Official capistrano recipes resides on https://github.com/capistrano. I have been attempting to create a collection of valid recipes for capistrano 3.0, and it won't clash with official one.
Neato mosquito. 
Ruby is the programming langauge and Rails is a web framework based on Ruby, so to be precise Rails is a DSL based on Ruby. Ruby can be used for a bunch of things apart from Web dev stuff. The APIs for Ruby and Rails are different (Rails API is a superset of Ruby API)
From what? Each other? What do you mean?
Common practice is to use one file per class unless class is really small (like Exception ancestor, or something like that) Variables should be inside class they belong to :)
This is why code walking other people's projects is a valuable practice. Spend an hour going through some of the biggest or most respected Ruby projects on GitHub and you'll feel out all you need to know (noting, of course, that many are libraries rather than apps per se). However, I would note that it's common practice to rejig things as you go along. For example, you might keep an entire module including its classes in a single file while they're all small, but then begin breaking them out. You need to remain agile like this and having some tests in place will make this process easy peasy. Typically though, yes, you could/would eventually end up with a file for each class of any substance inside `lib/yourappname/`. I wouldn't give modules their own file though unless they had constants or methods of their own that needed to remain separate. If you're just using them to namespace, use them within the respective class files instead. But code walk, it's the best way to learn this stuff. Part of the reason is because there *are* no fixed standards for these things in Rubyland and what people consider acceptable changes over time. Find a style that suits you but also generally fits in with what other developers are doing.
&gt; From each other? Yes. The maintainers of rspec discuss the drawbacks of before(:all) as they consider removing it here: https://github.com/rspec/rspec-core/issues/573 This rspec style guide says most let!s should be lets: https://github.com/reachlocal/rspec-style-guide If the code inside the let! block needs to be run before the spec, use a before block. If you have particular examples where before(:all) or let! are appropriate, I'd be happy to discuss the possible refactors. 
Do the simplest thing that works and when you find your files getting bloated and it's hard to know if you have to scroll up or down you should refactor. If you start with tests (and I would really recommend a Test-Driven-Development approach, because this will teach you how to write your interfaces and construct your classes) there are two simple conventions for naming files: 1. `test/minitest_helper.rb` or similar (e.g. `spec/spec_helper.rb`) 2. naming your testfiles after the file that is tested. if you have `lib/table.rb` then name the corresponding testfile `test/table_test.rb` Edit: looking at your code, this is so small and simple that refactoring it into more files would decrease readability a lot. write something with more than 50 lines and then ask again for refactoring advice.
I have to admit, that I find the different solutions for `require` in my own code a little bit confusing and I also keep on forgetting what the best approach for require is. This is how I do it currently, please let me know if you think I could improve: 1. Tests should `require "test_helper"` 2. `test_helper.rb` should require `lib/&lt;gem_name&gt;` 3. `lib/&lt;gem_name&gt;.rb` should require all the files in the `lib/&lt;gem_name&gt;/` dir. This is where I have the most problems, because there are many different solutions for requiring the whole directory.
I can relate to this. I tend to have a lot of side projects so I probably bootstrap an ENV more frequently. I, too, found it cumbersome at times, however I've extracted many of the common things I do to gems so that copying the gem and doing bundle install gets me most of the way there. Setting up rspec and capybara with database cleaner is a good example. I've read about groups that use Rails templates exactly for this. Although, it feels like maintaining rails templates as gem preferences come and go would be more work than it's worth. The pain has never been bad enough for me to resort to templates. 
I'm a novice, but I feel like this is akin to photoshop. There are 50 million ways of accomplishing a desired goal, some are easier and quicker than others, some provide other advantages that may pay off in larger scale projects, etc. The best thing to do is try different ways so you can learn what those tradeoffs are and which approaches are truly "worst practice" or "best practice" and what that means.
I think people are leaving rails. They feel that it is not the way forward. And they call it ruby.
I don't think you'll have many problems. The only pain points might be unix-specific commands or process forking.
In our dev team some guys are on windows without any problems, we tease them with not having RVM however. ;-) (I believe [PIK](http://imgur.com/gallery/VbzhAbd) is the alternative)
Though I have a Linux machine at work, my home computer has Windows (8, even) and I've been learning Rails with it just fine.
Well, it has much slower execution speed. Some gems don't build well on Windows (or didn't when I last tried it), and some of the binaries could trip you up later for deployment to, say, Heroku. There are usually workarounds on Stack Overflow, many of which I had to employ, but it was a constant headache unless I was very careful to use things I knew were well supported on Windows. Python works about the same everywhere -- virtualenv and pip are a lot more solid on Windows than Bundler and gems, mostly because there just isn't a lot of Windows support out there in the ecosystem compared to *nix/OSX support. Sinatra (for Ruby) and Flask (for Python) are both great microframeworks for side projects if you don't need the weight of Rails/Django. My suggestion: use a virtual machine with Linux on it if you want to use Ruby for Rails dev. It's not all that painful, and there are dozens of guides to getting everything set up quickly and easily for Ruby and Rails on Linux distros. In the end I think that will actually save you time.
I'll second the virtual machine route. I use Oracle Virtualbox for work and play and it treats me oh so very well.
Back when offices primarily ran Windows XP and Ruby 1.8.7 was new, I used the [Ruby Windows Installer](http://rubyinstaller.org/), then [Cygwin](http://www.cygwin.com/), then VirtualBox + Fedora. Now that Microsoft is pushing thing to their App store, I don't consider Windows a viable platform for non-Visual Studios sanctioned development.
I run into some issues with Ruby 2.0.0 (32 or 64-bit) and some gems on my Windows 8 boxes, but have yet to run into any problems with 1.9.3 and any gems.
1.9.3 is great on windows. I've been developing tools in it for last 6 months or so exclusively on windows with little issue. The built in platform specific stuff for windows paths and whatnot is only mildly confusing.
Eh, shard isn't a bad name really, and jewel is arguably more confusing because of Jeweler.
Not really. It works for the most part, but I wouldn't want to rely on it. However, you can always install Linux in Virtualbox or VMWare.
I don't think that's the hyperlink you intended to use..
Start out by contributing to libraries that you actively use. I'm sure you have come across many bugs or desired features in those projects. Perfect opportunity.
[The Ruby Installer](http://rubyinstaller.org/downloads/) (I've only used 1.9.3-p3xx recently) plus [GitHub for Windows](https://windows.github.com) is a pretty pleasant experience. As a Linux dev, I was surprised at how smooth that all seems to function. I only know this because the Ruby product I work on must run on Windows, Linux, and OSX, so I'm occasionally troubleshooting on these other platforms.
Pick a Railscast at Railscasts.com; Check and see if its been updated for Rails 4. Quite a few of them havent and it kind of sucks, having to moneypatch everything to get things to work. If you were to start updating some of those gems (which are extremely popular due to being covered in a Railscasts) you would be a God.
Set yourself an OSS exercise regime! I'm considering a weekly workout of: - particiapate in one discussion on an issue - create an issue - submit a pull request on an issue (bugfix/documentation) - create a pull request with (feature/enhancement) ...where all four points are on different issues/prs, and repos if possible. No expectation of doing them all every week, but I'd like to pressure myself.
Look into CodeTriage; it sends an email every week with an open issue on an open source project. Good to get you in the habit of OSS contributions.
Will do, thanks.
Solid plan, definitely have some already in mind. 
Capistrano Cancan (v2)
&gt; we tease them with not having rbenv however ftfy
Jekyll's internationalization (is non-existent)
I am working on updating an old gem http://xmpp4r.github.io It could use some contributors. 
Sure, would you cover various ci systems and tech? 
ya, would love to see a sub reddit regarding that topic. 
Capistrano needs an owner. Espresso got abandoned. Active scaffold could use an overhaul. 
Depends on what you WANT to work on. My company uses Haproxy and I currently automate interacting with parts of it through regular expressions... but I decided to checkout haproxy-tools and work on that so it's more mature for my needs.
My book is getting a bit old now, sadly, but happy to see you're working through! Just skip the Rails chapter ;-) In terms of becoming a better Rubyist, Eloquent Ruby is the place to head, but you might also like to recap and get extra viewpoints from The Well Grounded Rubyist, and having both the Pickaxe and the O'Reilly Programming Ruby book to hand as reference won't hurt. Sandi Metz' book is very interesting and I enjoyed it, although personally I'd advise to go with your gut on object oriented design. It's possible to take it too far and abstract absolutely everything. A lot of the principles she covers are sound but you need to use them carefully rather than universally (all IMHO).
In your conclusion, you write: &gt; However, it should be very obvious now that it is paramount that all applications have tests and that all the tests exercise every line of code. This is in stark contrast to Java where the compiler performs a large number of checks concerning the correctness of the code during compilation. You are basically advocating for Java over ruby here. Ruby sounds like a lot more work. I disagree with that assessment.
It was not my intent to advocate Java over Ruby. There are many differences between the two and any serious discussion of the merits of one versus the other should include them all. I will update my post to reflect this.
I use ruby all the time on windows PCs at work. The only time I've run into problems on windows was heavy rails apps with lots of dependencies (like imagemagick) - these are far better suited for vagrant anyway. If you're going to be giving your ruby scripts to anyone else, you can package them into an exe using the OCRA gem, although the resulting files are pretty slow. 
i'll do ruby &amp; rails on regular bases on my work windows machine, i can confirm there have been problems but they got less. especially bigger gems are mostly good supported. Also i can confirm most of my gems dont work well on windows because i use unix internas. cant talk about the speed or anything, i use windows only at work which is slow anyway.
You could try http://www.reddit.com/r/devops, but it's not totally specific to CI.
Why isn't contributing to OSS work? Many of the kernel contributers (see [How the linux kernel is developed](http://video.linux.com/videos/how-the-linux-kernel-is-developed) by Greg Kroah-Hartman, one of the kernel maintainers, the slide I'm referencing is at about 24:27) are from the industry. They get paid to do a day job, and that day job involves working with and on OSS. OSS lives because it has users, not just programmers. And I'd rather have someone with no github repositories at all, but at the same time, active and contributing to issues or mailing lists. Contribution to OSS isn't just defined by LoC.
*Cough* Can Can *Cough*
Install a Vagrant vm, I have one running ubuntu. There are a set of pre-made rails-dev boxes that you can clone of github, or you can make a basic vagrant box from scratch. https://github.com/rails/rails-dev-box http://www.vagrantup.com/
tl;dr but yeah if you can get paid to do OSS that's even better, incredible even.
I'd probably start with the tools that I'm using, travis-ci, code climate, recap/capistrano etc, but would always be looking for the next thing
Wild guess, but it seems that "--wait=30" isn't a valid option for thin? This setting is in thin/thin.yml
Yeah. Thin 1.6.0 thinks it's a valid option, but OP is running version 1.2.4, which I'm assuming hadn't learnt it yet. It sounds like OP is using debian-managed gems (rather than using the 'gem' utility), but he isn't replying on IRC, so it's hard to tell.
This is the best way to go. There's always bugs or things that need improving in the libraries you use. Fixing them, including tests, and submitting pull requests are not only great ways to learn, but great ways to improve your skills.
Do things that interest you, that you have a passion for. It doesn't matter if the community around that is small, or that you don't commit to the major libraries in that sphere. What matters is that you have enthusiasm and show that you are interested in things. 
It's terrible and their services fail frequently. No support either. Stay away.
Lame, any suggestions on alternatives? 
I used to live in the Bay Area. I used to be in Pleasanton. I've moved since then, for work related stuff. You can hit me up on my email if you have questions. I'll PM it to you! If you are close to the Bay Area or in it, I definitely recommend going. Your total costs would be cheap. If you live out of California, I would suggest you find something a little bit closer to you unless you want to visit SF at the same time.
Did my 3rd year dissertation two years ago using it. Whilst it was fun learning it. It wasn't very good, has some odd qwerks. Phone gap is similar. Whilst I'd advise you to stay away, I'm not sure what they've done since it got bought by Motorola. But for some cases it may be suitable but the UI and android performance just won't be very good. You can check out my diss here http://github.com/richrace/remoteapp Oh and if you want to read my 85page report which will go into in more detail pm me. 
Better for what? You should probably describe the problem you wish to solve. What does your application do? who will be maintaining it? what devices/platform do you need to support? Do you need access to device APIs? This is your job as a software developer. To evaluate tools based on the needs you have. There is no silver bullet that fits every use case. 
Do you happen to know if Can Can is working on Rails 4? I plan to use it this week. 
We do php and ruby sites as well as android apps. One of our clients is looking to bring a native app to market sooner rather than later but across all platforms not just android. We know there are a number of frameworks now to publish from a single codebase to ios, android, windows. We've researched plenty and have other options but the idea of a tool that allows this kind of cross publishing with a ruby codebase caught my interest since we know ruby. Which is why i figured posting to /r/ruby looking for ideas would be useful. We don't need fancy system functions and the app will be pretty self contained. Sounds like this isn't the way to go anyway based on the 3 neg comments.
I used RhoMobile on my job for a prototype and it was... weird. To write a new native plugin, you have to write code in up to four different languages (JavaScript, Ruby, C AND Java on Android). Also it has a pretty weird way of calling ruby code from JS. Instead of having a simple interface, you always have to go through an AJAX call. To make things worse, customer support is terrible. It was okay before Motorolla bought (?) the project but right now I have two bug reports on their issue tracker that didn't even get an answer in over a year. After discarding the prototype we switched to Cordova/Phonegap which is a little easier to handle. Still, after several months of work, I would say, it might have been easier to just build two seperate native Apps for Android and iOS. You should only use cross platform frameworks if you need very few native features or a lot of platforms.
http://rubydrama.com/
I don't disagree that this is an important issue, and shouldn't be minimized, but I fail to see how this event is associated with the "Ruby community" at all. One guy did something wrong, and a programming language that he happened to use is being discredited? What kind of car did he drive? An Audi? _Clearly_ this is a problem with the Audi community.
If it's really as serious as it's made out to be, it should be handled by the police - not by a bunch of *i-wanna-be-outraged-too* people on twitter. You don't know a damn thing about it other than reading a couple of emotionally charged blog posts. It's this trial by social media, and the band-wagon that follows that is really embarrassing. 
How else are we suppose to react to an off topic post from a throwaway? Frankly I'm insulted at the implications of your post. The ruby community is not involved in this, we gave no implicit or explicit assent to this crime. If a Slot Car enthusiast was accused of a mass murder would it be an 'opportunity for the slot car community as a whole to come together and let everyone know we stand against mass murder'? No that's just absurd. If he did it, he's a bad man. If he didn't she's lying. Notice how neither of these is about ruby programming? The only embarrassment I see is a concern troll trying to stir up drama.
If whatever your doing is JRuby compatible (Rails is), you can package it along with jruby-complete and run it anywhere you can run Java. There're a few small annoying things about JRuby, but it should solve any compatibility problems.
Programming Ruby, AKA "The Pickaxe". The most up-to-date version can be found here - http://pragprog.com/book/ruby4/programming-ruby-1-9-2-0
The pickaxe. I don't have it in front of me so the exact name escapes me. But, it's the one with the pickaxe on the cover. It may actually be called 'the ruby pickaxe'. Edit: http://en.m.wikipedia.org/wiki/Programming_Ruby
Thanks much. 
They weren't at an Audi conference, though.
It's been too long since i read Programming Perl but "The Ruby Programming Language" is the book that i use the most. While the Pickaxe is good, you can't beat the pedigree of "The Ruby Programming Language" what with Yukihiro Matsumoto aka Matz aka The guy who created the ruby programming language in the first place, co-writing the book along with Mr.Flanahan. [Amazon_Link](http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177)
What type of feedback do you expect without someone giving you $750?
I have heard good things about Wroclove.rb
I had to check the username to be sure this wasn't something I had posted and forgotten about. Spot on. _"You will run into issues where certain gems misbehave or do not even function."_ And thats what kills Windows as a platform for Ruby; far, far too many gems.
Hi TheGoddamBatman, I'm one of the cofounder. We think it's nice to have a seamless setup and most of our alpha users like that way. Would you prefer to have the possibility to do it manually instead letting us do it? Thanks. Christophe
So, these OOP concepts might not make sense right now, but as you gain experience youll know when to use what technique. IMO, use what ever technique better conveys what you are trying to do. What helped me was reading some [refactoring books](http://www.amazon.com/Refactoring-Ruby-Edition-Jay-Fields/dp/0321603508) and reading on [anti patterns](http://c2.com/cgi/wiki?ClassicOoAntiPatterns). Refactoring will teach you how to fix bad code and anti-patterns teach you what bad code is. Youll have to write some bad code before you get good at it; just code. 
Is a demo or anything up and running yet? I logged in through github, but can't seem to get any further.
[BaRuCo](http://www.baruco.org/) (Barcelona Ruby Conference)
that non-sense in that article wants to make me puke.
I'm not a rubyist, I'm primarily a Java developer. That being said, this article is a load of crap.
I chatted with a guy over the weekend that is recruiting for a company transitioning from Perl to Ruby. I recently left a gig at a &lt;cough&gt;major language-learning software company that has been using Ruby for 8+ years. I currently work for a startup using Ruby.
I signed up and linked my github... and .... now what? It just takes me back to the homepage... /u/_toch maybe u need to run this tool on your own code....? (trollface)
How does this differ from Code Climate?
Sad that the article had to be framed so stupidly, Rubinius X seems like an ambitious project at the very least - &gt; - Promises and Non-blocking IO &gt; - Persistent and Concurrent Data Structures &gt; - Mirrors and Object Capabilities &gt; - Immutable Strings and ByteBuffers &gt; - Behaviors &gt; - Keywords and APIs; All APIs use keywords where necessary. 
It seems to have a few good ideas but it's either going to simply die halfway through development (like perl 6) or become ruby's very own python 3.
I would hypothesize that, if you work heavily on Rubinius, you might not be able to distinguish between "Business is over its dalliance with Ruby" and "Business is uninterested in Rubinius".
Hi whatsmyline, :) good advice. In fact, we use PullReview on PullReview. If you check the text before the button "Log in", it's written "Already got your account?". For the moment, only invited people can log in. But we'll open the gates very very soon. Christophe
I didn't get a chance to look through the code but the README is well done. Yes, I know that sounds like faint praise, but if you have enough code/features to inspire a good README, at least you have vision and a good goal :) My advice to you as you're starting out: you might want to check out the Jeweler gem: https://github.com/technicalpickles/jeweler Figuring out the structure of a Ruby gem project is annoying enough, especially as you've just begun learning Ruby...Jeweler provides some nice conveniences, among them, building out the skeleton and test suite. I don't know what language you've come from, but Ruby is very test-centered, and part of the reason why is because tests are so easy to set up. As I've become more experienced at Ruby and writing my own gems, I always look at the test suite of other gems first...it shows me what the author thought was necessary to test and the completeness of the features, and is often better than the documentation itself. 
I'll definitely look into Jeweler. I have found the structure of gems to be a little confusing. I think a little more research would help. If you get a chance to look at the code please let me know what you think. Some of it is very hacked together and I already have a lot of ideas for improvements but I'd really like to hear from more experienced programmers before I start making the changes.
Hi totallymike, Regarding CodeClimate, I can point two main differences, both linked to our objective to "mimic" the way code reviews are done and when. So first we analyze in priority the branches you are working on, and push you to fix first the problems you've introduced with your modifications. Our opinion is that the best time to refactor and cleanup thing is before the merge of a feature, not afterward. Then we try for each problem found to give you the explanation (why is this bad), possible solutions (how to fix) and also references on the subjects (blogs, articles). We want to help to make better developers, not only better code. Christophe
Looks like a good start, and as danwin said, Jeweler will help here. One thing that stood out, and as you mentioned in the comment at the top of drawmap.rb is the drawmap method; it can probably be as simple as: def drawmap [ @htmltags, @createmap, @markers, @circles, @polygons, @popups, @geojson, @geochloro ].join end 
I don't know how I didn't think of that. Thanks!
I'm biased, but [Frozen Rails](http://frozenrails.eu/) is great (I'm one of the organisers). It'll return in [2014](http://2014.frozenrails.eu/) (for various reasons we skipped this year). [Railsberry](http://www.railsberry.com/) was also very good in 2012 when I attended it, and I heard great things about the 2013 conference too.
I can't rave about [The Well-Grounded Rubyist](http://www.amazon.com/The-Well-Grounded-Rubyist-David-Black/dp/1933988657) enough. Very approachable.
I can recommend making a simple template and the just building new gems from it, saves me ton's of time and you can pick exactly what layout you want https://github.com/grosser/project_template I'd advise against jeweler and simply use bundler gem tasks they are pretty good + bump/tasks and you are all set
You should probably add mustache (and any other outside gems you require) to your gemfile. :)
NOOOOOOOO Not Jeweler. Jeweler is dead. Use Bundler.
Before you go for a rather complex tool like jeweler, please also have a look at the `bundle gem` command that is built into bundler. It is much more lightweight and gets the job done just as well in my opinion.
Thats great- ok friend, I am new to Rails and have a question - How can I use that exact version, the one you linked to? Thats a fix, no? How can I, like, pull it and use it in an app? Would you mind telling me? Thank you.
In looking up Jeweler right now I came across some info on Bundler. Seems like you are right and may be easier.
Yeah I wasn't sure how that worked. In the sort of first round of research I did it seemed that maybe it was only necessary to declare dependencies in the the gemspec.
I wonder why none of these changes have been proposed on the [ruby issue tracker](https://bugs.ruby-lang.org/projects/ruby-trunk) or in the [Ruby Implementers meetings](https://bugs.ruby-lang.org/projects/ruby/wiki) Some of these ideas could be of benefit to all ruby implementations so it seems odd that ruby is being forked with no attempt to contribute back.
My completely uneducated guess is ego. "Psh, I've been working on a Ruby implementation, I can totally make my own, and it'll be better than Ruby, too! And Ruby would be too hard to fix anyway."
These are all backward-incompatible changes. How could they be contributed back?
Hi, RoR developer here. I think that the price is about right for lessons, and I sure wish something like this was available when I started. 1/hr with a pro can == 2 days banging a beginners head against the wall. I would also suggest taking a Koans / TDD approach from early on. The sooner people see tests, the sooner they start writing them. Good luck to you! 
Nothing wrong with Ruby. Your classmates probably just don't understand it and thus fear it. They dismiss it for dogmatic reasons, which just makes me sad for them. In any case congratulations for learning Ruby. I hope you enjoy writing applications in it as much as the rest of us.
&gt; Ruby is a dying language My ass it is. It may not be hip and cool, but neither is Java. Look how dead Java is.
Thank you. You couldn't of explained High school better.
Actually, it was dead...I remember the author saying so about a year ago, precisely because of Bundlers emergence. But he has been revamping it, and even made changes within the last week. It ends up being much nicer than bundler, without too much cruft 
The irony that the python programmers dislike ruby. 
My guess is that there is a strong prejudice towards C-based programming languages/syntax. Though ruby can count itself as a C-derived language based on it's perl influences, it also gets a lot of "rubyness" from Smalltalk and Lisp and the people who really get smalltalk and lisp are vastly outnumbered by the C crowd. I think this is what turns off a lot of "serious" Java/C++/Python programmers to ruby, I would guess the hate is more about syntax rather than shortcomings with the language itself. I would secretly make a list of all your friends who scoff at you about ruby and see how many of them end up giving it a try down the line.
what were the reasons they claimed ruby was trash? i like ruby because i'm very productive in it, because it makes it simple to do oo via composition rather than inheritance (inheritance is obv also first-class, but composition is pretty much equally first class), there is a strong community around testing (rspec, etc) and it's generally pretty fluent/fun to write. i dislike it mostly where mri has issues (some gc related stuff, mostly fixed in 2.0, some thread stuff not quite fixed but at least workable with jruby) and because by-and-large it is very slow when doing large amounts of number crunching. but as a systems language doing distributed stuff, passing off heavy lifting to python or c, i'm a fan. 
Ooh. I'll check it out again.
Nothing's wrong with Ruby. Some people don't like it because they've heard it's slow, or they've heard it doesn't support concurrency well, or because they don't like Rails (which is often conflated with Ruby). Ruby's a great programming language and it's awesome you've decided to pick it up. Don't worry what your classmates think; anyone who looks down on you for learning a new language isn't going to do well in software engineering anyway.
&gt; passing off heavy lifting to python or c I agree with you re: C, but not Python. Python (CPython, anyway, which is the default, most widely used implementation) uses the same mark-and-sweep garbage collection model used by Ruby 1.9 and implements the same Global Interpreter Lock as Ruby, which only permits one thread to execute at a time. As far as I know, neither is appreciably slower than the other for most operations (though this is tricky to prove in the general case, and a lot of programming benchmark "articles" are really just sensationalist blog posts meant to evangelize one language at the expense of the other).
&gt; No major startup is lauding their use of Ruby and existing businesses are migrating away or simply writing new applications in a different language. Uhh... What?
If management dictates what language you use based upon what's trendy at the moment, it's not a company you want to work for. And Ruby has one of the most active communities for a language that I've seen, as far as web development goes at least. I decided to learn it partly because so many awesome tools and libraries were written in Ruby. (I wonder how many people stop and realize that popular packages like Vagrant and Homebrew are Ruby, or that GitHub was developed in Ruby...) I agree with drbrain. These are features that should be proposed as additions to the Ruby language, not dragged off into the corner to become part of a forgotten fork.
[Sciruby](http://sciruby.com/) is making good progress. But yes, Ruby is definitely lagging behind a bit in that area.
1.9 wasn't backward compatible with 1.8. I'm not really an expert on it but I don't think this would make it a new language.
Can you expand on this? I'm still using python 2.7, but only because there has been no reason to move to python 3. is there something more significant about Python 3?
That's true. But the only syntax changes I can think of from 18 to 19 were new hash declaration and new lambda declaration. These changes in rubinius x seem really drastic. They aren't just syntax or standard library changes, but language fundamental changes. The "type checking" in the argument list is also confusing to me. It seems to be there to ensure that the object is like a String (or like an Numerical) but Ruby doesn't normally care about classes or types only that it handles a certain message. Will that syntax insist that the object implements all public methods on String, even if the method doesn't need all of them? Ones of the things I like about Ruby is not having to worry about explicit interfaces (like Java) but rather the interface us defined by whatever message an object responds to (even messages only known at runtime)
One ideology I stand by is not being too passionate about software. By that I mean: languages, databases, OSs, etc. are all just tools. If a tool has been around for any length of time, it is probably useful for something. Anybody who turns their nose up at a tool is just ignorant to it's uses. Also, ruby rocks.
&gt; In general, anything inspired by Perl should be removed... Say goodbye to regular expression literals, easy Unix interop, ... EDIT: [Spammy newsletter feed](http://mailinator.com/inbox.jsp?to=rubiniusx) via Mailinator.
That might be valid, except this guy maintains the ruby spec library and has created and maintained one of the more impressive ruby vm's. While there could be ego involved, he has the resume to back up the ego... edit: to add, I don't agree with his opening statement at all, just pointing out this isn't some random egotistical person ranting.
I would say it's because of inertia. Python has these libraries so people use Python to use these libraries. Python is also taught more in academia than Ruby is. Ruby isn't thought of as an academic or research language nearly as highly as Python is.
&gt; I instantly fell in love with it. It pays to be careful with instant infatuation (not just with programming languages...).
couldn't *have
It is very easy for people to dismiss a programming language when they: * Have no experience with it * The only source of their compliants are other people's complaints * Have limited themselves to a certain type of problem Every tool is designed for a different problem; identifying the domain of the problem correctly allows us to determine the right tool. We need to be pragmatic, and open to the new possibilities and new thought patterns that a new language can give us. Anyway, I don't think your classmates are jerks or idiots, but right now, they're taking an attitude of wanna-be hackers rather than real software engineers.
Ruby is a very "good" language and it is very pleasant to code in Ruby. Like all languages (that I have used) it has its own set of pros and cons and strengths and weaknesses.
You're in highschool. Being judged harshly by your peers for doing something different is what happens there. Ironically 25 years ago when I was in highschool my peers looked down on me for the very act of programming, never mind my choice of language. They couldn't understand it, and it looked boring to them. Just feel confident in the notion that none of you really have that much experience in anything yet and they probably don't know what they're talking about.
Sounds like usual CS sperglordery. They typically don't like ruby because they can't understand it. It does some things differently than C-like languages, and since that makes it different than a very large percentage of languages, it scares those who attempt to treat C as dogma. Now, C isn't bad. It set down a very specific way of doing things, and for many people, its more than enough. But there is no such thing as one-size-fits-all. There are other ways to approach a problem, and ruby takes them in several cases. Just because C does it one way does not make it best. Historically, ruby has been a little slow. But with the past couple of major releases, its sped up tremendously, and so that point is sort of nil now
Standard 3-tier web apps: Client code in HTML5/JS, Ruby on the web server, SQL in the back end.
That the differences between the languages are largely superficial. Python and Ruby have fairly similar semantics, although Python tends more towards ALGOL and Ruby more towards Smalltalk.
Pik is pretty good. Couldn't do a windows install without it
I'm guessing your high school classmates have no idea what they're talking about. They either know nothing about ruby or they're parroting things they've heard without understanding. High schoolers have *zero* perspective, generally. I was in a survey of programming languages course in undergrad, and we had a section on Perl (mostly to cover regular expressions). I hate Perl. Ruby does basically everything Perl does (often with identical syntax!), while being elegant and object-oriented instead of hideously disorganized. So, I suggested to the prof that he teach Ruby instead of Perl, and he did some research, and the next semester replaced the Perl module with a Ruby module. Ruby as a language is generally optimized around the thing which is usually most expensive in a software company: programmer hours. It is designed to maximize the rate at which programmers can turn out working code, by being really ridiculously pleasant to write code in. It's not particularly optimized for speed, but computer hardware is DIRT cheap compared to paying the salaries of good developers. If they're all obsessed with wanting to write video games, then this story makes slightly more sense. Ruby is awful for writing video games that are performance intensive, I will absolutely grant you. You're better off using XNA or something else that is intended for games. The same might be true for mobile devices, where you're dealing with slow processors and low memory, and might need to use a deliberately lean language. What were your classmates claiming about it, and what are they claiming is better? If they're trying to argue that Java or C++ are better, well, those languages might still be popular for massive companies, but they're awful to write code in, so they're much less common among start-ups. 
Mirah is pretty far along. It would be better to help mirah than to start from scratch.
I guess the majority of haters define a "good" programming language by the (most popular) IDE ( and few by the Debugger ) and its features. particularly the Java guys ( I encountered ) are ignorant and intolerant and have to bash on everything new and strange to their beloved Eclipse. The language itself is usually the second tier of complaints. But things like type-safety are not a design flaw in ruby but a design choice. I'm coding ruby for 5 years now ( 3 big applications with 200+ customers ). And haven't had a moment like "this would be better in language-X". keep coding!
there are things "wrong" with all languages - that's why people have brains to figure out which tools are good for the job. people dismissing a tool without ever learning it do not use their brains. do invite your fellow classmates into this discussion so we could all have fun reading and debunking their puny arguments.
Is it? Last time I looked into it a few months back it seemed pretty inactive
FUD
I don't think such changes would be accepted to core ruby. They're big, will break a lot of things.
The gemspec is the correct place to declare your dependencies as you are building a gem. The gemfile can remain as is.
Yes! I used to be statically-typed language snob.. Ruby, Python, etc always seemed "toy" languages. But then I started playing with Ruby.. oh my.. never looked back. Ruby is predicated on programmer joy, there's plenty of good jobs in Ruby, as there are in C++, Java, etc. But when you get out of High School do you want to spend your days in a language that sucks? By all means, know how to code in C.. but if you actually want to enjoy coding keep going with Ruby. My 2c, but I was in the same place as your classmates once upon a time.
Sorry.. somewhere in there I meant to say IUseRhetoric is right! :)
Ruby is fundamentally very different from other mainstream programming languages. By design it is a programming language for "programmers". It is designed to make programming fun and easy - in certain areas, this was done at the expense of performance and memory consumption (for eg: why ruby came up with symbols - because strings just consume way too much memory). When every thing is an object, and the language is functional, it is going to consume a lot of memory. Then there is multi threading. MRI would utilize only one of the cores (jruby solves this problem). As it is fairly easy to learn, and has a very Buddhist like attitude towards programming - that is "there is no one right way", that everybody has to find his or her way. Combine this with method chaining, and by the rules of probability and permutations you will get lot of sub optimal codes. Compare this with python's "one right approach" principle. Hitler like, but efficient. Then there is static typing. It's awesome that I am able to convert a json string of anything to a hash in ruby - but this is done at the expense of catching some checked exceptions at compile time. Ruby's strengths are its weakness - when it is in the wrong/inexperienced hands. 
Seems not to do anything very special. Even if I would consider doing something very similar I would think it a waste of time to bargain about the costs (not worth much anyway) and then have to handle your code base (quality unknown). The time to evaluate if this is worth it alone would be better spend coding.
Upvote purely for the use of 'sperglordery' :)
good ol' emacs.butterfly()
I can understand why a Java programmer would dislike Ruby, since Java's compile time checking can save you trouble, and the performance of the JVM is pretty good. I can understand why a C+ programmer would dislike Ruby, since they THINK their compile time saves them (but it doesn't) and C++ has pretty good performance (if you know what you're doing, but I bet they don't.) I do not understand why Pythonistas have an issue with Ruby. Maybe because for a while in 2005 Ruby came and took their lunch money. Python was supposed to be the new hotness that would replace Java and everyone would use it, but Ruby showed up and looked awesome and people drooled over the features that Python already kinda had. Ruby does have some downsides, all that flexibility is basically handing you a rope and waving you in the direction of a tree, and the performance is nothing to write home about, but the tradeoff is so worth it. Have fun with it. 
Why not feed in craigslist or something? Seems kind of pointless.
&gt; But when you get out of High School do you want to spend your days in a language that sucks? By all means, know how to code in C. I agree with you that Ruby is awesome, but don't use the word "sucks" when talking about other languages when we're defending Ruby against people who say the same thing. ;)
I would recommend adding some tests. 
Or you can use jruby and leverage the power of the JVM.
You forgot "high school" is only capitalized when used as a proper noun such as The Ruby High School.
It's inactive but far along. That's why it's perfect for somebody to pick up. It's also fast, modern, and can make use of the huge java library. Seems like a more worthwhile effort than rubinious X
While I use Ruby as my go to language and agree with the others who have posted here, you should head over to /r/cplusplus and/or /r/java and ask the same question for some non-biased. You will get some troll high school-ish type responses but hopefully there are those who give you real reasons. At the end of the day, learn many languages and use the right tool for the job. When there is no clear 'right tool' use the one you most enjoy. Not everything you write is going to be powering the stock exchange or a space shuttle. And I'll just leave this here: http://www.csee.umbc.edu/courses/331/fall10/images/languageFans.jpg
If your C code has bugs then it will break. But that doesn't mean "stay away from it". There are a great number of rubygems with C extensions. If you have an error in your ruby code your application will crash just the same.
Having the resume to back up the ego just makes you a megalomaniac.
I just hope this doesn't mean Rubinius itself will stop being a Ruby interpreter.
It's against the terms of Craigslist (and they're litigation happy).
It's a JVM language. That puts it up against a slate of other JVM languages for people who are happy to rely on the JVM, while those who are not happy to rely on the JVM will stay away. That makes for a tricky niche. 
Your example code isn't correct Ruby form: require 'httparty_with_cookies' class My_awesome_cookie_using_api include HTTParty_with_cookies end api = My_awesome_cookie_using_api.new api.get 'http://someurl.com/endpoint' api.cookies['darkside'] #=&gt; 'We have cookies!' Should be: require 'httparty_with_cookies' class MyAwesomeCookieUsingApi include HTTParty include HTTPartyWithCookies end api = MyAwesomeCookieUsingApi.new api.get 'http://someurl.com/endpoint' api.cookies['darkside'] #=&gt; 'We have cookies!' Just make sure you camel case things correctly. Also, normally when you make an add-on gem, it gets named `httparty-with_cookies` and then you'd require it with `require "httparty/with_cookies"` I haven't yet looked at the code but I like that you have tests.
Or just use scala/java. Depending on the use case. Jruby is a novel idea though
Thanks for the feedback! I just don't understand why the class would include to HTTParty as well. I decided against the httparty/with_cookies in the end because of the different method of usage (since I kinda force you to use classes), this was probably a silly reasoning :P
If the class doesn't include HTTParty then how will it get HTTParty's methods?
my module already includes it, but get, post, delete, put, &amp;all are defined as instance methods on it, for the auto cookie handling.
I'm am ex-rubyist who codes in Java. Sometimes I visit this sub and sigh wistfully and look sad. 
I would let the person using your gem specify their own loading of HTTParty. Personally, I use a custom fork of HTTParty with some additional things and if I wanted to use your library I'd wind up with some conflicts.
I see. Does the fork you use have a different module name? 
[How to deploy a rails 4 app with git and Capistrano](http://robmclarty.com/blog/how-to-deploy-a-rails-4-app-with-git-and-capistrano)
I imagine promises could be implemented more efficiently if built in to the language than if implemented atop ruby constructs.
I don't see how you determine the correct cookies to send for different domains. You probably want to use the [domain_name](http://rubygems.org/gems/domain_name) and [http-cookie](http://rubygems.org/gems/http-cookie) dependencies from [mechanize](http://rubygems.org/gems/mechanize) to avoid security issues with cross-site cookies.
These questions don't seem Ruby specific. It doesn't matter what kind of application you are designing, if it's going to grow large it will need pieces to be split across different servers, as they don't all need to scale at the same rate. Each server should not care what language or OS the other servers run. They should talk to each other through something easy like RESTful interfaces. So for example, you might have a pretty UI written in Rails running on 4 or 5 servers, but when a user logs in, it will have to fetch that user's info from a datastore, which could be anything (a relationalDB, nosql db, solr), doesn't matter what, but you probably only have one or a cluster that the UI thinks is one. Then again, if the users' data needs to be updated, the app will do an insert or update into that datastore. It's not routing the user's requests, your ruby code has to make separate downstream requests as needed, which won't necessarily be 1 to 1 with the upstream user requests.
O didnt know. Idk maybe go to the barter kings and have them sponsor you? The site doesn't offer enough people to use it unless it has a solid break out. Even then it will be hard to float.
At my last Rails job (2009-2011) we used a lot of memcached and redis for caching. (We used memcached for when we need to store marshaled objects or simple things like arrays of IDs, or when we needed cache keys that automatically expired. We used Redis when we needed its awesome data structures, like lists or sorted sets.) We wrote some convenience functions so that we could try to retrieve something from memcached, then fall back to a database retrieval if it wasn't found: CACHE.get_or("user_friend_ids/#{user.id}") do User.get_friend_ids # model method that queries the DB end The `get_or` function tries to return what's at the key; if it's not present, it runs the block, then sets the key to the return value of the block in memcached. This was painless. The cacheing wasn't necessarily a by-product of our decision to use Rails; it was an effort to be nicer to our Postgres database by avoiding complex queries as much as possible. In this example, instead of asking the DB, "give me all the users that list this user as a friend," it was much faster to ask the caching layer for the IDs of all that user's friends, and then hand that set of IDs off to the database for lookup. As for deployment, we did a reverse proxy sitting in front of some number of servers, all using [Unicorn](http://unicorn.bogomips.org). This worked well for us. These days, I think [Puma](http://puma.io) is the new hotness, so maybe look into that.
 if user.other_site_link.match(/\Ahttp:\/\//) I was going to nitpick "why not use start_with?" but found something interesting: 1.8.7 :014 &gt; Benchmark.bm do |x| 1.8.7 :015 &gt; string_match='http://' 1.8.7 :016 &gt; x.report("match") { 1_000_000.times { "user.othersite.com".match(/\Ahttp:\/\//) } } 1.8.7 :017?&gt; x.report("start") { 1_000_000.times { "user.othersite.com".start_with?('http://') } } 1.8.7 :018?&gt; x.report("start2") { 1_000_000.times { "user.othersite.com".start_with?(string_match) } } 1.8.7 :019?&gt; end user system total real match 0.640000 0.000000 0.640000 ( 0.641223) start 0.690000 0.000000 0.690000 ( 0.695209) start2 0.580000 0.000000 0.580000 ( 0.587346) String creation is some heavy stuff! (and regexps are mighty efficient!) Well, the example does not support https! 
Ok, the real question here is: what is meant by "scale"? What is the throughput you're looking for (as measured in operations per unit of time)? What is acceptable latency in operations? Are you number crunching or are you doing online transactions? As in any language, you'll sooner or later reach a point where to be able to scale horizontally, you'll need to think about architecture. That applies to C as much as it applies to Java, Python or Ruby. Depending on what you're doing, other languages can be more efficient, thus hiding the problem longer, allowing you to live in a messy environment for longer. I've worked with lots of languages in my career, and in my experience you're _always_ better of thinking about both the infrastructure design AND the model/object design before starting off (and if you're using something Active Record based - simply translating database tables into Classes does not a design make). It will always pay off in the long run. In fact, thinking about caching, be it out of process with redis or memcache, or in process with local lookup tables or ActiveHash maps is not a bad thing. You won't need to implement it straight away, but being able to design for caches in those places, and then being able to abstract the cache implementation cleanly away is a good thing. Always be on the lookout for places to offload from the database. I've seen lots of web application backends being bogged down by unoptimized database access, be it superfluous or suboptimal SQL where lots of JOINS have just been slapped on. In general, the database will be one of your slowest components, once your working set no longs fits into the available RAM. The above is language independent. As to ruby itself, over the years I've gained some experience with ruby performance, but still stumble over surprising stuff. As with PHP, the performance killers can be unassuming (PHP arrays come to mind). First of all, if you're in a tight loop or a frequently called place where you know that the ruby code is a performance killer, have a look at what you're doing and then think of alternatives. Benchmark them (using the standard libraries benchmark module). E.g. say you have a string that may contain '-' signs that you need replaced by ':'. What would be faster? str.gsub or str.tr? Then, learn about how the memory manager in ruby works (this applies to any language using garbage collection). Ruby has strong functional roots, so a lot of methods return copies of the original instead of modifying the original directly. Which in turn puts pressure on the GC, which up to ruby 2.1 has a rather simple implementation that can kill performance. So the question to the above question is in fact, to use str.tr!, which will modify the original string: 2.0.0-p247 :001 &gt; require 'benchmark' =&gt; true 2.0.0-p247 :002 &gt; count = 100_000 =&gt; 100000 2.0.0-p247 :003 &gt; Benchmark.bmbm do |x| 2.0.0-p247 :004 &gt; x.report( "str.gsub" ) { count.times { str = "foo-bar-baz"; str.gsub( /-/, ':' ) } } 2.0.0-p247 :005?&gt; x.report( "str.tr" ) { count.times { str = "foo-bar-baz" ; str.tr( '-', ':' ) } } 2.0.0-p247 :006?&gt; x.report( "str.gsub!" ) { count.times { str = "foo-bar-baz"; str.gsub!( /-/, ':' ) } } 2.0.0-p247 :007?&gt; x.report( "str.tr!" ) { count.times { str = "foo-bar-baz"; str.tr!( '-', ':' ) } } 2.0.0-p247 :008?&gt; end Rehearsal --------------------------------------------- str.gsub 0.280000 0.000000 0.280000 ( 0.277805) str.tr 0.070000 0.000000 0.070000 ( 0.075562) str.gsub! 0.270000 0.010000 0.280000 ( 0.280978) str.tr! 0.060000 0.000000 0.060000 ( 0.059255) ------------------------------------ total: 0.690000sec user system total real str.gsub 0.250000 0.010000 0.260000 ( 0.253826) str.tr 0.060000 0.000000 0.060000 ( 0.068335) str.gsub! 0.270000 0.000000 0.270000 ( 0.268059) str.tr! 0.060000 0.000000 0.060000 ( 0.056164) And then of course there are non-obvious things that can be performance issues. Like rubies internal method cache that gets rebuilt everytime a method or a class gets added to the object pool. Deserializing database fields into OpenStructs (which will generate anonymous classes) can have disasterous effects on your performance if you're aiming for high throughput and low latency. Feeling that the requirement to learn about how a language works beyond the syntax is a bad thing, is a bad thing in itself, because it can and probably will bite you in the end. No matter what language. With ruby you have the advantage that most internals are pretty straight forward to understand - you just have to think about thinking about them. If you ever reach a point where ruby is too slow for you and that you can't fix with C extensions for the relevant functions, and it really is ruby that is your main performance problem, neither PHP nor Javascript will help you either. You'd need to switch to either C, something JVM based (scala probably) or have a long hard look at erlang. But unless you'll be trying to serve tens of thousands of web requests per minute, that won't be too much of an issue. Yes, you'll have two or three servers more in your datacenter, but that is balanced out by ease of coding and the usually higher code throughput of programming in ruby when compared to other languages. With numbercrunching you'll be reaching the point of hurt a lot sooner, but you'd probably want to work with a compiled language in that case anyway. My standard toolbag contains Nginx, unicorn (switching to puma soon) as an application server, Postgres, Redis and Ruby + Framework (mostly rails or padrino). Thats good enough for most applications and requirements. For profiling code, have a look at tmm1's excellect bag of repos on github. It's been a while since I needed them though, profiling is something that pops up maybe twice a year for me. 
ah. good catch on https. still, what I had was good enough for the example.
Love being devils advocate. 
Do or don't?
Sites like this which require large user bases to function have their worth based almost entirely on their popularity. Your site isn't really useful unless lots of people are using it and it doesn't seem especially tricky to build a duplicate at a glance. Without an existing active community using it I don't know if you'd get much for it.
When I looked at it I wanted to use it for Android development, which basically was impossible because one could not use outside dependencies like the open source UI tools (ActionBarSherlock and such)
I would keep the site running so that you can always show it off.
There is no try? (I edited it, it was supposed to be don't)
That's a really good point. I have always interpreted the side bar as 'this is ruby programming' but that's not 100% definitive.
This is my experience at some pitfalls in using Ruby to match through a 90k line log file. The TL&amp;DR is you can use Open3.capture3 in Ruby to make a system call to egrep to avoid a Regexp#match call for a dramatic speed improvement in certain circumstances.
Ruby has shown itself to be philosophically opposed to some (or possibly all, depending on the implementation) of these changes. Why bring them up when it would be a waste of time? For the rest, I'm sure they'll get cherry-picked back into MRI once they've been proven.
This isn't starting from scratch, it's starting from rubinius. Rubinius is arguably further along than Mirah.
Incorrect. See [my other comment](http://www.reddit.com/r/ruby/comments/1oi99k/introducing_rubinius_x/ccsrbfo)
It's been mentioned but EuRuKo is as close as we have to a de-facto official European Ruby conference.
I've heard that onigmuro and onigmo (the regex engines in 1.9 and 2.0 respectively) are the best out there. But they tend to do an awful lot, like back and forwards references, and so forth. Perhaps this has something to do with it being slower, as grep is usually only POSIX regexp compliant, which leaves off the references
I did forget to mention in the post what Ruby version I am using, just added that, and it is ruby 1.9.3p374 (2013-01-15 revision 38858) [x86_64-darwin12.2.0] so I assume that'd mean it is running the Oniguruma regex engine. I also looked at https://github.com/michaeledgar/ruby-boost-regex but since it hadn't been updated in 2-4 years that scared me off a bit. Benches there show what 2-3 times speed boost instead of going right to egrep which is 10x.
I'd be interested to see a comparison between 1.9, 2.0, and grep
Sword gives you Sinatra-like helpers (slim :page renders ./page.slim and returns the string with the resulting content) and it builds using the --compile flag.
I did actually read it before commenting, and my very best interpretation of it is as *rampantly* optimistic. Cleaning up encoding alone makes this worth experimenting with. `undefined` is DOA because it won't fit in MRI's immediate bitset. I'd suspect that ByteBuffer and *universally* immutable strings would get thrown out with the argument that they were discussed and rejected back in 2006. As far as primitive consistency goes... well, this keeps coming up in one form or another, but #8449 is the most recent related bug report I can easily find, so that's clearly a known problem that's just not going to change. A proper code loading API is something I was going to propose myself (loading code from an in-memory database was handy on one project), but getting past the inevitable performance argument takes data I don't have, and it's an argument rubinius x gets to avoid totally. Mirrors and capabilities imply ripping out the existing reflection APIs completely. While I can *possibly* see the introduction of persistent data structures as optional extras, I can't see them replacing core classes as it stands because it's such a fundamental change. There *is* current discussion of adding concurrency-supporting modifications to core classes, and it'll be interesting to see if that goes anywhere. There's not a huge amount left.
[wow such doge](http://i.imgur.com/fyItTIQ.png)
The problem is this line: puts 'I suggest ' + new_num + 'because its bigger and better!' The error says: TypeError: can't convert Fixnum into String because you can only use '+' to add two strings together, and the + operator doesn't have any idea how to convert numbers to strings. Here are two fixes: puts 'I suggest ' + new_num.to_s + 'because its bigger and better!' This is explicitly converting new_num into a string, which the + operator can handle fine. Alternately: puts "I suggest #{new_num} because it's bigger and better!" Note the double quotes - this and the #{} syntax are known as [string interpolation](http://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals#Interpolation) and it essentially calls the .to_s for you.
&gt; relativistic I'm pretty sure that's not the right usage of that word. "Relative," maybe, but this discussion has little to do with distortion of spacetime.
&gt;I have spoken to a couple of companies using Ruby/Rails and they said scaling and performance have to be designed into the application. Yes, but I’d say that’s the case for anything WebScale™ &gt; They say I have to use a lot of caching and non Ruby back end services to get any kind of scale and performance. It depends. I once watched some programmers look at a Ruby program that was parsing some input, and say “Oh man, the slow part here is in the regex parsing bit. Let’s rewrite this in Go to make it faster!” What happened was that they rewrote it in Go, and then found it to be the same speed. Why? Because Ruby uses a compiled C-based library for its regex engine, which was the same thing the Go program ended up using. That having been said, Ruby can be pretty slow at some execution paths of programs. In those cases, you will typically do one or some of these things: * Not care; if it’s 10x as fast, it doesn’t really matter * Rewrite the slow part in a compiled language or one with a kickass JIT compiler and call it from Ruby via FFI or a network layer like HTTP (which involves a server/client, etc.) * Reframe the problem so it can be solved with a concurrent algorithm and spend CPUs until your performance problem goes away &gt; In addition, I will be doing a lot of data analysis and rule based actions on inputs. What are experienced Ruby developers using for these kinds of back ends? This is still pretty general, but you might want to look into something like SciRuby. &gt; What are the integration points? Do I route requests using a reverse proxy or are there better ways to integrate with Rails/Ruby. I know there must be some good articles on building a scaleable well performing Ruby app, any suggestions? * You only need Rails to build an MVC web application; look at Sinatra or just Rack if your web-interaction needs are not a big deal * It sounds like you are probably going to spending most of your time writing analysis libraries; you won’t need Rails there other than to display results * You will only need reverse proxies if you need to serve more than one request concurrently * Some Rails web servers like Passenger will perform the reverse proxy pool thing for you Godspeed and please write tests.
Please also write and fix docs. It’s a great way to get started reading code, sending patches, and getting to know people wanting to do rad stuff like you. Get started with http://documenting-ruby.org/ if you like Ruby.
Use interpolation, it's slightly faster too.
Sell on flippa or open source it for cred and community help.
This. Helping improve documentation is the easiest way to get involved in OSS, and helps you gain greater understanding of the architecture. Documentation improvements to Ruby can be submitted as [Pull Requests via GitHub](https://github.com/ruby/ruby).
Even if you don't feel like forking a gem to fix a bug, at the very least please submit a bug report.
They weren't at a Ruby conference, either. In fact they weren't at a conference at all, since it hadn't yet begun.
I'm just speculating, but I read it as replacing blocking IO with promises IO. E.g. if `` `ls` `` returned a promise-to-string rather than a string. That would be a pretty big break. Don't know if that's what the OP intends though.
Let's get this party started. Everyone probably knows that if you add an &amp; before a symbol, it'll turn it into a Proc that calls the method. Basically, the following two are equivalent: arry.map { |x| x.some_method } arry.map &amp;:some_method What's less known is that you can do the same for any method in current scope by using Kernel#method. These are again the same: [1,2,3].each &amp;method(:puts) [1,2,3].each { |x| puts x } The cool thing is that you can also use `method` with a receiver. This gives you "poor man's partially applied functions". Try this in irb: [1,2,3].map &amp;"z".method(:*)
 NameError: undefined method `*' for class `Object'
Why are you switching to puma? are you going to use it with CRuby? I have stayed away from threaded ruby application servers because sometimes is difficult to know if the gems you are using are thread-safe. Do you know if sinatra and the pg gem are thread-safe? 
unicorn, identity cache, cache digest, etc...
identiy cache is an awesome gem you should look into if you are still using rails. makes caching via memcached for activerecord calls very easy
I always see the first but I just like the second version. Is it less readable? (1..10).to_a [*1..10] Also, if you ever first select and then transform, instead of using select and then map, it is often ok to use the grep function: # Get all ints and convert them to strings [1, 'a', 2, 'b'].grep(Integer){|x|x.to_s} #=&gt; ['1', '2'] # Get all digits after the letter C and convert them to ints: ['a1', 'b2', 'c3', 'c44'].grep(/c(\d+)/){$+.to_i} #=&gt; [3, 44]
Also very good if you need to chain functions, it can make things more readable: number_plus_two = -&gt;(x){x+2} pretty_numbers = -&gt;(x){[2,4,6].include? x} [1,2,3].map(&amp;number_plus_two) .select(&amp;pretty_numbers)
You should definitly watch this: http://www.youtube.com/watch?v=aBgnlBoIkVM (Ten Things You Didn't Know You Could Do by James Edward Gray II) It's actually 101 things.
I don't :) I listed that on the limitations. I've taken a look at those gems, quite good suggestion, thanks. Now I'm pondering on whatever to implement it or just leave it as is to allow me to do xsite cookie tests.
Are you talking about Symbol#to_proc from Rails, and now Ruby 2? Another neat thing is using a hash of matcher =&gt; replacement with String#{,g}sub.
Nice seeing Datamapper's nice features recycled. 
http://www.sitepoint.com/the-self-pipe-trick-explained/ is one I've been using a lot lately.
It's some combination of pathetic and insane that it's faster to shell out to egrep than use Ruby's regexes. 
[1,2,3].inject(:*)
What is interpolation?
essentially the structure of a gem is pretty simple - you need a lib directory and a .gemspec file IIRC and that's basically it. when you install a gem the lib directory will be added to the ruby load path so that you can require whatever's in it. Now it's good practice to have a lib/gem_name.rb file so that you can require gem_name in your applications (or so Bundler can do it automatically) but that's just a convention. It is perfectly possible to call your gem foo but give it a lib/bar.rb file. In which case you would: gem install foo, but require 'bar' Hope that helps.
I've been using puma with MRI for about a year on a pretty large production app (sinatra based) with no issues. The pg lib actually has a method (is_threadsafe?) to ensure your libpq iss threadsafe.
Very true. I hadn't considered that. But it definitely is one of the things that makes useful projects stick out and really helps early adoption if the docs are good. 
To protect(fail-fast) against invalid inputs, you could use Integer(gets) to_i method silently converts invalid input to 0 or takes as many digits from the beginning.
Gem threadsafety is of course a big unknown that I will be keeping a close eye on. Weeding out threading issues in your own code can be challenging as well, if you're new to threaded environments. (Hint: Avoid shared mutable state and you're 99% good. No $globals, no @@class_variables, no @class_instance_variables. Use Thread.current[:variable] if needed). MRIs GIL will mitigate threading issues somewhat until the bad gems are weeded out. I believe threading problems will be worse under JRuby or Rubinius, since they are truely multi-threaded. As to the why: One reason is RAM requirements. If I can have 16 puma workers with 4 processes that have 4 threads each instead of 16 unicorn instances, I'll only need about 1/4th of the memory I currently need. Also, the benchmarks I've seen so far are rather convincing. I will still need to see how puma behaves in a real production environment compared to unicorn before making my final decision though. That being said, I agree with Matz that threading is a design-smell. Personally, I prefer the actor model as a multi-processing design pattern as done by e.g. Erlang. Threading itself is bring too much of a cognitive load to the individual programmer to be reliably done correctly. (Going a bit off topic here: this is one of the reasons I'm looking more and more into Erlang and Elixir and the Beam VM. They - or something very similar - are the way to go forward to do massive scaling and efficiently using available processing power without overloading coders with details).
Pretty important to understand this since case statements are confusing and frustrating to use until you do, but they are often super useful for writing clean, readable code.
Awesome, thanks!
thanks, i'm thinking it is a good deal too. i've taught quite a few people and I think that they learn a ton that they wouldn't otherwise get studying on their own. i'm a fan of testing from the start as the process of understanding how to test really flushes out a person's understand of the underlying behaviors and concepts. one month rails started by exploding on skillshare, what do you think I should be doing to connect with people who would likely benefit from rubyonrailstutor.com ? 
Yep, just in case any noobs in this subreddit aren't aware, case takes an argument, then calls === on the arguments to the when statements with the original as the other thing to test equality on, so: case something when '4' then ... when other_var then ... when obj then .... end So if something is obj (for example), then the following method calls are made: '4' === something (false) other_var === something (false) obj === something which is the same as: '4'.===(something) So you can define a method named === on your internal POROs or Structs or whatever, so that they behave the way you want when used as arguments in a case statement. Pretty handy.
That's a pretty stupid wish. About 80% is inspired by perl. Do you want to start from scratch or switch over to javascript?
You can use his fix by referencing his fork of CanCan from your Gemfile: `gem 'cancan', git: 'git://github.com/neubloc/cancan.git', branch: 'master'`
I haven't seen any Rubinius attempt to contribute back any features or feedback, while JRuby has. Why is this? It's obviously less difficult than people think.
tmux + vim-slime works well for this
For what it's worth, [Symbol#to_proc has been in Ruby since 1.8.7](https://github.com/ruby/ruby/blob/trunk/doc/NEWS-1.8.7#L311), in case anyone is worried about compatibility.
Don't forget `Class#===`, which is equivalent to `Object#is_a?`: if String === s puts "it's a string" end
Avdi uses Emacs. There is an Emacs package that does that. I think it's this one? https://github.com/nonsequitur/inf-ruby Edit: Actually /u/avdi is on Reddit. Forgot about that
&gt; str1.concat(str2) is more efficient than str1 += str2 as no extra object is allocated. I really prefer the other syntax: str1 &lt;&lt; str2 But yes that's nice.
This is covered in the [FAQ](http://www.rubytapas.com/faq). I did a [whole episode on it](http://devblog.avdi.org/2013/06/24/rubytapas-freebie-xmpfilter/).
Insane. What a weird special case to remember. 
Like many implementations of #===, it [only] makes sense in the context of a case statement.
I just built this and tested it out by using a Ruby snippet to add a custom HTTP response header. Very cool so far! Thanks
Ah yes, very good. Thanks for correcting me there.
It's not starting from rubinious at all. It's a new language.
It's not designed for Android. That's ruboto.
|= assignment for habtm associations in rails. http://www.wordofmike.net/j/just-another-ruby-idiom
And is some other cases.. my_array.grep(String) is a good way to find all strings in an array. It uses the === operator.
Rails' default_scope is, in my opinion, a bad idea. The thing is that it works... until it doesn't, and then you are in deep shit. We currently use default_scope in a rails 3.2 (nearly 4.0) app and it has cost us all kinds of grievances. Once you set the default scope, you can never, ever, get rid of it. Our product is semi-multi-tenant, where some user accounts are part of multiple tenants, and there it plain sucks. From rails 4.0 onward, there exist unscope and except methods, which allow you to unscope some of your scopes: User.where(username: 'bear').except(where: :username) == User.all However, when the same thing is specified in a default_scope, it no longer works: class User; default_scope -&gt;{ where(username: 'bear') }; end User.except(where: :username) == User.all == User.where(username: 'bear') In some cases, this might be a good idea. For pure multi-tenancy, it might be usable, however, there are better solutions. Check for instance New Relic, they also have multi-tenancy. When you go to your dashboard, you are on a url of the form https://rpm.newrelic.com/accounts/1010101/applications So you are on your dashboard, but it's for the account 1010101. The Account is always explicitly there. You can/should always do @account.applications, instead of Application.all, which is much more sensible.
The problem with this, as Ryan Bates says in his screencast, is that without default scope you would need to remember to do @account.x or @account.posts..comments and similar in each case. Using default scope frees you from this and you don't need to worry that you may have left a hole in the application because you may have forgotten to scope something - well I am talking here without taking testing into consideration anyway.
Good call, I forgot about that for some reason and it's a synonym for concat.
&gt; "Can do everything Ruby can, most of the time just as concisely" Except in 100% less readable fashion. The reason I stick with Ruby is because I can write less weird syntax and write more code I can go back and read 2 months later. 
&gt; Even I could write a parser for Clojure. [Really...](http://clojure.org/reader) &gt; Clojure is faster… Amazingly, if you write [2x the code](http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=clojure&amp;lang2=yarv&amp;data=u32), you can get a faster program.
Incidentally you can straight-up curry a proc. f = proc { |a, b, c| a + b + c} f.call(1,2,3) #=&gt; 6 c = f.curry[1][2] c.call(3) #=&gt; 6
I use this for caching method calls a lot, though you have to be careful with ||= and results that return nil or false.
I agree on the LOD, presenters and service objects, although the problem of remembering to scope in each case remains (I think)
You can also pass a block to ```Hash#fetch```, which is called only if the key is missing: h = Hash.new h.fetch(:a_key) {|key| puts "#{key} is missing!"} Note that unless you make it happen in the block somehow, the return value of the block is *not* set to the associated key in the hash, so in this case: puts h #=&gt; {} That isn't a terribly useful example, but you can use it for other things: class SomeKindaNetworkThing attr_reader :socket_factory def initialize(options = {}) @socket_factory = options.fetch(:socket_factory) { TcpSocketFactory} @socket = socket_factory.new(blah, blah) end end Pretend this isn't so awfully contrived. The fact of the matter is that the parser will recognize ```TcpSocketFactory``` as a constant, but won't evaluate it unless the options hash has no ```:socket_factory``` key. Now you can do network_thing = SomeKindaNetworkThing.new(socket_factory: SslSocketFactory) # or network_thing = SomeKindaNetworkThing.new(socket_factory: UnixSocketFactory) I used this form in an experiment to keep other class names out of my classes. True, ```TcpSocketFactory``` is still mentioned inside of ```SomeKindaNetworkThing```, but it's only evaluated as a measure of last resort, not a hard-coded dependency for SKNT to function, and you can inject different classes in. Very useful for testing :)
Backed. That is a big goal though, I hope they are able to make it!
Backed, worth it for the time it's saved me already! Good luck with V2
Do you know about [unscoped?](http://apidock.com/rails/ActiveRecord/Scoping/Default/ClassMethods/unscoped) It removes all scopes (including default scopes) from relations - it's necessary knowledge if you use default_scope. For the record, using default_scope is usually a bad idea, but honestly a bunch of my models use a default scope that has never bitten me, like so: default_scope order('published_at, name DESC') It's basically for auto-ordering records correctly. Also if you rely on gems like ActiveAdmin or RailsAdmin it's really hard / potentially nearly impossible to hook into their controller code so you kind of have to use default_scopes to get their index views to scope correctly (for example, if your models have states).
re:unscoped, yes, the point of the whole blog post was the use of unscoped :)
Personally, I find the combination of [Postgres schemas](http://www.postgresql.org/docs/9.3/static/ddl-schemas.html) and the [Apartment gem](https://github.com/influitive/apartment) to be a much more reliable. Once the request hits any of my code, the Apartment middleware has already changed to the correct postgres schema based on the subdomain, and I can run 'select * from users' with absolute certainty that only that company's users will be retrieved.
Wouldn't it make more sense to write a tool designed to install ruby versions in something that didn't require a ruby version already from the start?
Wouldn't it make more sense if you try to read the fundraiser?
RVM is a train wreck. 
If you use Postgres then definitely that's the way to go :) I am stuck with MySQL (Percona XtraDB Cluster) at the moment :-/
I did. It mentions a few advantages of Ruby over shell script in general terms but I don't see where it addresses my point, unless it does in the video.
read harder.
Ok, I apologize. The thing here is he's going to offer binaries, so you can just download the binaries and run rvm from there. I'm not a rvm fan anyway.
Wouldn't it make the most sense to have a stable language where you only need one interpreter installed at one time (like every other language on the planet!?) ? EDIT: added "installed at one time"
Why? grep is going to be a hell of a lot faster (it's pure C [C++ these days?]) and it has decades of optimisation behind it. Given all of Rubys bagage, Ruby doesn't actually do bad! When people say "Ruby is slow" they actually mean it. Its slow. If you find you need to optimise for speed it, sure its possible to break out ffi, but even then its slow! A loop in Ruby costs about 30 times as it does in C/C++. Its SLOW! Not that that alway matters, Python is slow, perl is slow, PHP is glacially slow - its just something to keep in mind. 
Ruby seems to be about on par with Python, Perl,... here in terms of effort required to upgrade to another version. If you have an interpreter at all and don't want a completely dead, unchanging language you need some way to upgrade from one version to another and might need to install old versions if you want to use old software. I also see nothing wrong with competing language implementations, keeps the specs up to date (as opposed to e.g. PHP where the interpreter implementation is the spec). There are other arguments against Ruby but I don't see this as something where it does any worse than comparable languages.
Except Python, JavaScript, C/C++ (multiple compilers), C#, Perl, would you like me to continue?
I don't know of anyone who runs multiple versions of any of the languages you mention as a matter of necessity. While you might choose to have multiple versions of GCC/perl/python/etc installed, you don't have a community who believes that you need a dedicated compiler install and dedicated user for every application that uses GCC/perl/python/etc. I hear this from the ruby community all the time. EDIT: clarity
Why the influx of "X is a better ruby" articles recently?
Can anyone say why you would use RVM or RBENV and other similar things when installing from source seems to be better? You don't need to rely on another persons script, installation via RVM sucks butt when you do it over capistrano, and you know for sure that you are getting a "clean" version of ruby. Heck, here is the section of a lame script I wrote to install ruby from source. # Get ruby 2.0 patch 247 from the official ruby website. echo "Downloading ruby 2.0, patch 247, from the official ruby website" wget http://cache.ruby-lang.org/pub/ruby/2.0/ruby-2.0.0-p247.tar.gz &amp;&gt;/home/vagrant/bootstrap.log # Extract and enter the resulting directory. echo "Extracting ruby source" tar -xzvf ruby-2.0.0-p247.tar.gz &amp;&gt;/home/vagrant/bootstrap.log echo "Entering ruby source directory" cd ruby-2.0.0-p247 &amp;&gt;/home/vagrant/bootstrap.log # Install ruby from source. echo "Installing ruby" echo " |- [1/4] running configure" ./configure &amp;&gt;/home/vagrant/bootstrap.log echo " |- [2/4] running make (This takes a while)" make &amp;&gt;/home/vagrant/bootstrap.log # make test Not sure if I actually need this for anything. echo " |- [3/4] running install" make install &amp;&gt;/home/vagrant/bootstrap.log cd .. # Exit directory # Clean the ruby installation files echo " \- [4/4] Cleaning up files" rm -r -f ruby-2.0.0-p247 &amp;&gt;/home/vagrant/bootstrap.log rm ruby-2.0.0-p247.tar.gz &amp;&gt;/home/vagrant/bootstrap.log
Really? Every other language? Let me list some languages with more than one interpreter/compiler Python, C, C++, C#, D, Java, Perl (well, perl6 at least... hah), Python, Ruby, Fortran, COBOL, Ada, Haskell, F#, Visual Basic, Lisp/Scheme I'm certainly forgetting a bunch, but I'd venture that something like 80-90% of all extant code in the world is written in one of those language (with C, C++, and Java probably comprising a lionshare of that). Some languages I know only have one interpreter/compiler. Erlang, I think -- though I vaguely recall an Erjang project (Erlang on the JVM). Eiffel, Elixir... That's all I've got, I'm probably missing a few here too, but having multiple interpreters/compilers is _normal_.
@user.projects.unscoped.upcoming.from_managers does not strike me as ugly, in fact it's pretty much just english at that point so the fact that I would have to throw in one more scope doesn't bother me - chaining scopes is kind of the point of scoping. My point is, would you rather have .unscoped.whatever_scope sprinkled through a *little bit* of your code that you don't want scoped? Or would you rather have .order("created_at desc") sprinkled throughout your whole codebase? The "default_scope considered harmful" meme is silly - it is harmful if you use it incorrectly, but if you *actually* want the same scope on 95% of your queries then of course it's not only appropriate but actually intellectually dishonest not to use it.
Ah, i see, I didn't read it, I was simply responding to "default scope is a bad idea"
It's not that careful though, right? I can take the examples in the original Ritchie C book and they still work in the latest (and every other) version of GCC. And with a few exceptions, most C will be easily compiled by any version of GCC. Same with Python, the whole ecosystem is much less fragile because there's not Ruby's self-fulfilling prophecy of "you need separate interpreters because no one ever wants to support anything for more than 5 seconds." I'm getting downvotes for these ideas as I always do on this subreddit, but I think they're worthwhile ideas. I think it's a toxic mindset and it holds Ruby back.
The point is that @something.something_else.unscoped.something_more does not work. It's the same as doing SomethingElse.something_more and completely drops every restriction before the unscoped call, i.e. the something_id: @something from the @something call. You can hardly consider the advice to not use something, which actually causes a lot of problems in normal use cases, a meme. If your code is DRY you will never need to sprinkle common code all over the place. 
You should crosspost this to /r/rubymotion.
Really? I have clang and gcc installed. Pypy and CPython and Jython... I had Hugs and GHC for a long time (till hugs died). I guess I just disagree -- I don't think having multiple intepreters/compilers installed (and indeed, even ensuring they can compile/interpret on multiple interpreters) is so rare. It's routine that I'll run a build on a couple versions of, eg, Java, to make sure it will work on many people's platforms as possible. Further, you don't install a separate interpreter for each application -- even with ruby, you install the different interpreters once, and then RVM/rbenv/chruby/whatever switches between them. Maybe I don't understand what you're saying, this doesn't seem odd to me (at least given my experience in other languages).
I'm sorry if I've offended you, but I'm not trying to push dogma or a meme. I'm saying that from my experience with using default_scope combined with the fact that it really applies everywhere (including association scopes) unless you explicitly remove it with unscoped (and every other scope, including the association scopes), I find using them is not advisory. You have another opinion. I'm not being obtuse here. You say that composing scopes in controllers suits you. I prefer to let my controllers only do simple routing and to know as little as possible of the model layer. Both manners are fine. Yes, using the default_scopes responsibly is possible. But it's not something that *I* want to put energy in. And unscoped has existed for quite some time, but unscope (singular), except and only are new in 4.0. As I said, I'm not trying to bullshit anyone. I'm just expressing opinion. 
I maintain a gem that needs to run on several versions of ruby for my job, and not all of the rubies are built the same way. Using ruby-build means I don't have to know how they differ, just their names; all it does is build from source, just like your script, but I don't have to maintain it myself. Using rbenv, I can switch between them easily. 
It's not your fault for misunderstanding, I'm being pretty unclear. I'm not talking about development environments/developer workstations. I'm talking about running ruby applications in production and the "best practice" suggestion that they have their own interpreters.
I'm still confused -- and now I'm really curious because I would've thought I'd've figured it out by now. When running an app in production -- you clearly have to run it on _an_ interpreter. When running multiple apps, you might need to run on 1.9, then update to 2.0, and so on. Now, you might be arguing to use a package-manager-installed version of ruby. If so, I agree with you (in production). I think many people do operate this way. However, some platforms do not offer ruby packages for the version you may want to run on (Ubuntu is a great example, they offered only Ruby 1.8 for a long time, and still (AFAIK) don't offer ruby 2.0 in their main repos). Thus, RVM in production. Personally, I *still* don't do that, I use ruby-build or ruby-install to install a specific version of ruby, and then run my app that way. I have ended up with more than one interpreter installed before on a production machine (especially in low-budget migration projects, where I'm updating an old app on a fairly limited budget to a new version, it is sometimes useful to run parts of that app on the same machine under a different version, but this is pretty rare). I don't think anyone argues for running multiple different ruby versions in production as a matter of rote, the RVM guys recommend using RVM in production because it does two things (both of which can be accomplished with other tools, notably) One, it makes installing any specific ruby interpreter easy, which is not the case on all (or even most) platforms. Two, it isolates installed dependencies for the app from other things that may be installed on the system (a good example is maintenance scripts, that may move between versions of ruby faster/slower than the main app. Chef is actually a pretty good example of an app that might require a different version of ruby than your app). Now, all that said, I *think* I understand what you're getting at -- being able to install and maintain multiple versions of an interpreter in production is not a big benefit. Indeed, running multiple versions of the same language in production is probably pretty confusing. However, RVM in production is usually not used that way (if it's used at all, tbh, I've never met anyone who walked out of that dance feeling like they didn't get spun).
C is fairly compatible for source code, not so much for their ABIs. Python is pretty broken at the moment, especially with the Python 2 to Python 3 transition but we had the same issues with each minor version before, just in less extreme ways. Ruby didn't start out this way either, it is an attempt to solve the underlying problem, because interpreted languages break in non-obvious ways on incompatibilities you need to try to avoid them up front by e.g. using the exact same version the developer actually tested.
Have you actually tried finding patterns in multiple files using Ruby vs grep? I have and my experience mirrored the OP.
If your app only needs one ruby, you don't need a ruby switcher. Also, if you're looking for a minimal alternative, checkout [chruby](https://github.com/postmodern/chruby#readme) / [ruby-install](https://github.com/postmodern/ruby-install#readme).
Your script doesn't check md5s or installs additional dependencies needed to compile Ruby. Checkout these [copy/pastable instructions](https://github.com/postmodern/chruby/wiki/Ruby). Also, there's [ruby-install](https://github.com/postmodern/ruby-install#readme) and [ruby-build](https://github.com/sstephenson/ruby-build#readme).
Based on the suggestions in this thread, I did a bit of googling and ended up following the steps outlined in this [blogpost](http://www.commandercoriander.net/blog/2012/10/10/evaluate-lines-of-ruby-in-vim). [This](https://raw.github.com/t9md/t9md/master/img/vim-ruby-xmpfilter_anime.gif) is a demonstration of what it allows you to do in Vim. Magic!
RVM became cargo culted into deploy processes because Rubyists were deploying to old versions of Debian/Ubuntu/CentOS which provided ancient versions of Ruby. Now that all distros have upgraded to Ruby 1.9.3/2.0.0 and that Bundler exists, you shouldn't need RVM/rbenv/chruby in production. Even if you need to install a specific version of Ruby, use [ruby-install](https://github.com/postmodern/ruby-install#readme) / [ruby-build](https://github.com/sstephenson/ruby-build#readme) to install it into `/usr/local` and `bundle install --deployment` your app.
I'm 100% with you (and Nussbaum) on the crazy number of versions of MRI that exist in parallel development. I think RBX and JRuby do a generally better job (and Rbx's move toward Semvar made me so nerd-happy I can't even tell you). I am deeply surprised that people think running more than one ruby version at the same time is a reasonable idea. Those people clearly haven't actually tried to do that (I've moved my fair share of SOA's from spanning a few Ruby versions to one across multiple machines. It's hard to maintain an SOA to begin with, much less when you have to debug multiple different interpreter inconsistencies). As for the bleeding edge culture -- I too, can't wait till Rubyists get in their head that the bleeding edge (while fun) is called 'bleeding' for a reason. Part of the problem is there is often a lot of non-backwards-compatible features added in non-major versions of Ruby -- this gets back to the whole 'What the hell is supported' / Versioning problem Ruby (particularly MRI) has, but I digress. Now, I do have one question (to prey on your experience) -- I usually do a user-per-app, but with a single common interpreter (usually in /opt/rubies/) and locally managed dependencies (via bundler). Clearly having an interpreter installed per user is toast (even if it's the same interpreter), but would you favor a single user running multiple apps w/ one interpreter? To my mind, the multi-user approach, though complicated, does afford some greater ability to control access. I've even thought occasionally about some sort of chroot setup (a la Docker/LXC), to help ameliorate RCE vulnerability's effects. 
Of course grep is faster than Ruby. But the fact that shelling out to grep from Ruby for a simple pattern match is faster than just doing it in Ruby is just sad. &gt; Python is slow, perl is slow, PHP is glacially slow... [But Ruby takes it to the next level](http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=yarv&amp;lang2=perl&amp;data=u32).
&gt; Flexible Funding &gt; This campaign will receive all funds raised even if it does not reach its goal.
&gt;I am deeply surprised that people think running more than one ruby version at the same time is a reasonable idea. Wow, I don't. I don't know what I said to give you that idea. I left that job because I thought they were insane. Also, when I said that having a single version is problematic, it's only problematic because of Gems which is a side-effect of the mindset I'm arguing against. &gt; Part of the problem is there is often a lot of non-backwards-compatible features added in non-major versions of Ruby I think it's worse than that. I think that may have been where it started, but gem vendors only care about today's commit of their code and if you're not on that, to hell with you. I don't mind at all having unix-level users per application, privilege separation is a good thing. I'm all about the single version of [interpreter]. Thanks for the discussion, I"m probably out for the weekend. I enjoyed talking this out rather than just getting hated :)
Ouch, been a while since I looked at comparisons...lets all switch to Ada!
The first two methods do they exact same thing except for the 0 and 1. Same with the third and fourth method. You should extract the commonalities into two methods and just pass in the index (0 or 1) As for styling. Ruby indentation is two spaces instead of a tab. Method names should be all lower case with an underscore separating the word. EDIT Depending on how many urls you have, you might want to loop over the urls and do file.open inside that loop (i.e. open the file per URL) file.open will not write to the file until you leave the block, which could cause memory bloat since it will keep all that data in memory.
I personally use tab for indentation in Ruby code. But, lots of people use 2 space.
Good idea - posted in there now. Thanks!
number.to_i -- This is not valid Ruby. Ruby has no ++ and -- operators. Use number = number - 1
Use number -= 1 
That was it, thank you sir!
The solution to RVM is NPM.
You can use something like def strip_us_and_global_from_tr(tr) [tr.search('td')[0], tr.search('td')[1]].map{|td| (td &amp;&amp; td.text).to_s.gsub(/(\s|US|Global)/,'') } end if error parent_us_visitors = parent_global_visitors = child_us_visitors = child_global_visitors = 'ERROR' elsif tr.count == 3 parent_us_visitors, parent_global_visitors = strip_us_and_global_from_tr(tr[1]) child_us_visitors, child_global_visitors = strip_us_and_global_from_tr(tr[2]) else parent_us_visitors = parent_global_visitors = child_us_visitors = child_global_visitors = '' end output = [url.gsub(/\s+/, ""), child_us_visitors, child_global_visitors, rank, parent_us_visitors, parent_global_visitors ] file.puts output.join('^') puts output.join(', ') BTW, in ruby, methods should be snake_case, not camelCase. Also looks like you have a bug in line 27 (should be tr[2]?) 
Better to use rbenv, or chruby, because they are better designed, simpler, easier, and safer.
Thanks! I'm author of ngx_mruby and mod_mruby. [Ruby code] if server_name == "NGINX" Server = Nginx elsif server_name == "Apache" Server = Apache end r = Server::Request.new r.headers_out["X-matsumoto-header"] = "test" Server::rputs "Hello #{Server::module_name}/#{Server::module_version} world!" [access] $ curl -v http://127.0.0.1/mruby * About to connect() to 127.0.0.1 port 80 (#0) * Trying 127.0.0.1... * Connected to 127.0.0.1 (127.0.0.1) port 80 (#0) &gt; GET /mruby HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1 &gt; Accept: */* &gt; &lt; HTTP/1.1 200 OK &lt; Server: nginx/1.4.3 &lt; Date: Fri, 18 Oct 2013 14:45:41 GMT &lt; Content-Length: 28 &lt; Connection: keep-alive &lt; X-matsumoto-header: test &lt; * Connection #0 to host 127.0.0.1 left intact Hello ngx_mruby/0.0.1 world! Enjoy!
Yeah, I know. I'm not worried about losing my money, I'm just hoping this actually happens
I've never heard of developing for OS X or iOS using Ruby. Is it good? I am particularly interested for iOS. 
Care to elaborate? I've had a few problems, but mostly it seems to work as advertised.
Can you elaborate? I use RVM and it would be great to hear about the alternatives from someone opinionated about it.
I would suggest that you put your code through the linting tool rubocop and get it down to 0 errors/warnings. It helps a lot, especially if you are beginning ruby.
I guess a framework is next right?
&gt; I maintain a gem that needs to run on several versions of ruby Travis CI. 
20k lines of shell script
yeah, but then you would need 20k hours to decipher it
I am reading a book and have yet to cover that. I like your way better haha, thanks man.
Definitely, I think if you've been working primarily with Ruby (as I have) then being able to put those same skills and experience to use on new platforms is pretty exciting. You still need to build up a good understanding of the Cocoa APIs ideally, although some very nice RubyMotion libraries are springing up all the time to provide wrappers around those underlying APIs that are more consistent with Ruby conventions used elsewhere. Happy to answer questions you have getting started if you decide to dig into it!
To auto-generate crap? What do you mean? It is just for templating your README. Not for auto-generating crap. Read README for Gutenberg first :-)
Sorry, I missed that part. You can divide your README into smaller parts for easier comprehension. You can take your app constants and inject it right into your README, version for example, so you don’t manually change your README after each release. Via metaprogramming, you can take methods of some module and describe it. It can do pretty a lot via metaprogramming, you can build a README for your piece of code that writes itself automatically without any manual efforts. You can build a dynamic README. It is just the same difference like between SASS and CSS.
And yeah, thanks. Added.
Oh boy. I'm not sure why you would want to emulate the Node.js module system in Ruby when Ruby does modules so much better. A good exercise, though? Interesting read. module Pi def area(radius) Math::PI*radius*radius end end class MyClass extend Pi end MyClass.area(1) =&gt; 3.14159...
The main reason is to avoid dependency hell where different versions of the same module are required by different gems, as everything is included into the global namespace they will clash.
This is why you have bundler. Each gem defines its dependencies and then bundler figures out the right version of each to use. There are good things in JS that would be great in Ruby, but I don't thing modules is one of them. The fact that you need something like RequireJS to figure it out for you is suggestive of its insanity.
I don't see why I'd want to have to manage 5+ files for something I can easily manage in one.
Bundler doesn't just get the right versions. It tries to draw a graph of dependencies, but if it can't resolve, it throws an error. I've had this happen many times in many situations.
Another option would be to list all of your drugs in a separate file and then import the file using Ruby's built in File class. If you separate each drug in the file like this: acetaminophen Aspirin Tylenol You would then name the file (putting it in the same folder as your script) something like drugs.txt In your program: file = File.open("drugs.txt", "r+") file.each_line do |line_of_text| #your programming magic end 
done that, I'd suggest using a GEM that helps parsing web pages, such as "[mechanize](http://mechanize.rubyforge.org/index.html)" Very good for filling in forms, finding [links](http://mechanize.rubyforge.org/Mechanize/Page.html#method-i-links) (page.links) or all the [images](http://mechanize.rubyforge.org/Mechanize/Page.html#method-i-images) in a page. Check out the examples and watch a [good usage video at Railscasts](http://railscasts.com/episodes/191-mechanize)
You could let the CSV class do the heavy lifting here. http://ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV.html
could you explain what the (td &amp;&amp; td.text) does? I tried google searching but &amp;&amp; doesn't come up with anything. edit: i also refactored based on your suggestions, thanks!
thanks for the input, i refactored the code! let me know what you think
installed the gem, thanks for the tip. It's new to me that things like 'return' are omitted...I thought syntactically it's beautiful, guess not
Totally OT but...how is it going with Ghost? :)
Now let's just finish Ruby Object Mapper!
Why is atariboy downvoted? He and Johnneylee are exactly right. Bundler does solve the problem, but in a different way than Node's module system, and each method has its own benefits and drawbacks. Heck, the article mentions the exact same thing that atariboy and Johnneylee say. RTFA before you downvote or comment.
I am wondering if your problem is extractedurl[0, 4] == "http" My first guess is that this will never be true. Can you add a puts extractedurl[0, 4].to_s Then maybe you will see what you are getting here. It sounds like this was working before so the problem may be in the new code you added, probably somewhere in how you are creating your directories and files. If you get a chance try to throw this code into a Gist instead of a jpg so that others can test it without restyling it all. What you have so far is really cool though good luck with it I am sure you will figure it out.
Waste of time.
A feature of ruby is that the last value of a method is returned. This means rather than write def self.sdl_inited? if (SDL::inited_system(SDL::INIT_VIDEO) == 0) or (not SDL::TTF::init?) return false end return true end You can break this up into three methods (perhaps two private). Though I'd look to fix it so those are positives and the expression becomes negative. The idea is that short concise methods have better readability and usage. Rule of thumb is if you find yourself returning false/true explicitly you have a piece of code you can refactor. def self.sdl_inited? ttf_inited? || dl_video_inited? end def self.sdl_video_inited? SDL::inited_system(SDL::INIT_VIDEO) != 0 end def self.ttf_inited? SDL::TTF::init? end
Ruby: srs bzns only, no fun allowed. 
Wow, thanks! I came from a heavy C/C++ influence, need to wrap my mind around this Ruby-esque refactoring.
Honestly, I'd make a loop in bash to call the script multiple times. xargs may be helpful. 
Interesting, I haven't seen a lot of SDL interaction within Ruby. Fun project :-)
What does RVM do that justifies 20k lines of shell script? I'll be unwisely honest in public, I don't trust the development process or team that brought us this to successfully bring us a better architected solution. 
First off, here are some things I would change. They will help to avoid errors and clean things up a bit: html = open("http://pillbox.nlm.nih.gov/pillimage/search_results.php?getimprint=&amp;getshape=&amp;getfirstcolor=&amp;getsize=&amp;getscore=&amp;getingredient=&amp;getinactiveingredients=&amp;getauthor=#{manufacturer}&amp;getDEAschedule=&amp;hide=1&amp;submit=Search&amp;display=1750").read #to************************ url = "http://pillbox.nlm.nih.gov/pillimage/search_results.php" # we will use the URI library to encode the args later, # but this looks nicer args = { getauthor: manufacturer, hide: 1, submit: "Search", display: 1750 } url = URI.parse(url) # This will ensure the URL is valid, plus other stuff url.query = URI.encode_www_form(args) # this URI object can be used with open etc # plus its cleaner (and you don't have to worry about mistyping ----------------------------------------------------------- # we can use URI.parse on you other URLs too urls.each{|extractedurl| if extractedurl[0,4] == "http" puts extractedurl[0,4].to_s imageurls.push(extractedurl) end } #to************************ urls.each{ |extractedurl| extractedurl = URI.parse(extractedurl) if extractedurl.scheme = "http" puts extractedurl.scheme imageurls &lt;&lt; extractedurl # I just like this syntax better, yours works too end } # now we have an array of URI objects instead of plain strings --------------------------------------------------------- [Nokogiri](http://nokogiri.org/) - I personally love this little guy, and I use it for webpages (I've done several similar page rippers like your writing). It also does XML if you decided to use the API in the future. You would have to check up on it, but you might be able to use this for your image search replacing a chunk of your code, you will have to 'gem install nokogiri' first: require 'nokogiri' ## code omitted ## html = Nokogiri::HTML(open(your_url)) images = [] html.css('img').each do |image| img_url = URI.parse(img['src']) if img_url.scheme = "http" #do stuff end end --------------------------------------------------------- I don't know if any of this will fix any issues you are having, but it will make the code easier to read and less prone to errors. I have to go right this moment, but hopefully you will get everything working perfectly. 
I have no use for projects like this which are written for the sole purpose of catering to an anti-windows crowd in order to seem like some kind of "l33t h@x0r". I get wanting to learn more about SDL but he honestly wouldn't have to try very hard to write something more useful than this.
&gt; Micro$oftWindow$ So edgy.
This is a quick and dirty pattern to make sure that you don't try to call .text on nil. An explanation for why this works: "&amp;&amp;" is logical and. &amp;&amp; is true if both operands are true, and false otherwise. In ruby (and many other languages) if the first operand evaluates to false, then the second operand is not evaluated (&amp;&amp; will return just the first operand). If the first operand returns true, then the second operand is returned. The other tricky thing here is that in ruby, nil and false are the only things that are false. Any object evaluates as true. So what this says is, check to see if td is false. In this context, that will only happen if td is nil. If td isn't nil, then evaluate td.text and return it.
Came here to say this. Might as well start saying O$X. While I can't think of a clever misspelling of Linux, the top Linux Kernel contributors are employed by Intel, IBM, HP.
Thanks. I appreciate that insight. I have been dabbling in both Python and Ruby, and actually love both languages. I'm just the sort of person that if I am going to take the time to learn, I would like toe reach as many platforms as possible. But more as a "just in case" scenario.
[rbenv](https://github.com/sstephenson/rbenv) uses executable shims to intercept calls to `ruby` and pick the desired version, and is ~1481 LoC. [chruby](https://github.com/postmodern/chruby) only modifies `PATH`, `GEM_HOME`, `GEM_PATH`, and is ~168 LoC.
It looks a lot better. Nice job. The only thing that jumps out to me is setting @error to true when an error is raised and then having #process handle that error. I would just set @summary in the rescue statement, move the #process call into the begin, and remove the "if @error" check from #process since it is being handled in the rescue.
What do most people use to serve up ruby apps?
Edit: You need to add the .chomp method to manufacturer to remove the new line. open("http://pillbox.nlm.nih.gov/pillimage/search_results.php?getimprint=&amp;getshape=&amp;getfirstcolor=&amp;getsize=&amp;getscore=&amp;getingredient=&amp;getinactiveingredients=&amp;getauthor=#{manufacturer.chomp}&amp;getDEAschedule=&amp;hide=1&amp;submit=Search&amp;display=1750").read give that a shot. It worked for me in ruby 2.0 I downloaded all the images for pfizer, bayer, and roche on to my computer. My list looked like this: bayer pfizer roche You should also use the .chomp method on your directory names to remove the new line that was being created in the title.
If I had to guess I would say Passenger is probably the most popular method, followed up by nginx acting as a reverse proxy to a pool of application servers (thin/unicorn/puma). But I don't have any hard data on that...
£inux?
https://github.com/alexdantas/bsod/blob/master/lib/bsod/linux-sparc.rb
In a reach as many platforms as possible perspective, you're always going to be making trade-offs. It would really be nice if there was a language that you could really write something once and have it run on all the target platforms. However, even the solutions that we *do* have for that kind of thing, differences in how the target platforms operate means that even if the language itself compiles and runs, you often have to figure out alternate and specific behavior for each of your target platforms. Continuing from this perspective, it means that when you're wanting to reach all three, you're going to be jumping through some hoops no matter what language you choose. It's just the hoops will differ as to whether their platform behavior hoops or language implementation difference hoops. For example, Windows likes to store information in the registry. There really isn't a Linux or Mac OS X equivalent for that. Sure the information is usually obtainable somehow, but, it's not going to be the same code to reach it. To touch on what I said earlier, when I want to target a ruby script to have it run it on windows, I can take the extra steps to make it possible. But, the challenges for getting windows users to run ruby scripts include the fact that ruby isn't included in windows by default, so you've got to get them to install that in most cases. Then if there's gem dependencies, you'll need to have checked before hand that all of them compile and run on windows. There may also be challenges in getting those gems installed. Some may require the user to install build-tools... and so on. I do think there's a way of compiling ruby scripts into executables, but, I'm ignorant of how useful this is or isn't as I've not done it. I think I could continue to babble and possibly I'd only end up muddling things more. I think the TL;DR take away would be ruby is definitely capable of reaching all three platforms, I'm just familiar with some of the hurdles and have found the easier solution is to avoid the least favorite kid in the room (from ruby's perspective.)
It just happens that Windows BSODs were first implemented, it allows for easily adding new crash screens so it's not Windows specific (See linux-sparc.rb referred to in the other comment.
 File.read('quicktestlist.txt').each {|line| get_images_for(line.chomp) } This assumes you put one item on each line, with no extra whitespace except for newlines. If you want to accept a "dirtier" input file, you'd have to add more parsing.
Looks interesting, but Chrome gives me an ssl warning when I try to sign up.
Author here, looks like it's MailChimp. I'll see what can be done. Sorry about that.
I signed up for the newsletter - would love it if you covered Ansible (as well as|instead of) Chef! Honestly I'll probably buy it either way.
I hadn't heard of Ansible until just now. It looks pretty neat, but being proprietary, it's kind of against the grain of why I'm writing the book. I want my fellow Rails developers to _not_ be at the mercy of a proprietary service to get their work in front of people. I'll have a blog post/newsletter blast on my philosophy soon. And thanks for subscribing!
It's open source, you can find it on github.
As another commenter noted, Ansible is free software (GPL) and the source is available on Github. AnsibleWorks is the company behind it, exactly like opscode for chef or puppetlabs for puppet.
Oh! I see. :D
This is JUST what I have been looking for!
I'm glad to hear it! :D
Now if there only was something to get our current project from 2.3.18 and 1.8.7.
This. I've tried chef, puppet, etc but ansible has so much shallower learning curve and configuration files that make sense. Ansible, unless you're doing insanely large concurrent deployments then look at Salt, is the answer
[Gosu](http://libgosu.org)
I have been fumbling around with just using a shell script this entire time when setting up using vagrant. Tried using chef but the seeming total lack of documentation.
You have been writing your book since 2012. Can you tell what percentage is done and when you believe it will be done? 
Subscribed. Any recommended reading for Chef? Over the next few months I have to take about 200 apps that are hosted on one big fat server and move them all to their own individual mini-VPS. 
&gt; To me, this seems like Rail's conventional-oriented approach doesn't follow ruby's almost laid-back mindset, while django's open-ended approach doesn't seem to match up with python's scricter mindset. awesome conclusion. and I agree
Interesting. My guess is that Rails is strict because the language is not. It was designed to help corral and shape code, so the "laid back" aspect would be kept in check. (Contrast to Sinatra, which is super simple and lets you do whatever you want.) I can't explain Django, though. I'm not as familiar with it, or Python in general, as I am Ruby.
Indeed - Rails does a lot for you for free if you understand its philosophy. It is extremely readable if you understand its philosophy. Kind of like SQL - you tell it what you want, and you get results: the "how" is irrelevant, and you trust the engine to do the right thing. Readability comes in play when you can express a complex model in just a couple of lines of almost natural language. However, at the moment Rails is rather complex, and getting to the point where it is easily readable and easily writable takes considerable effort. I agree with /u/redwall_hp: Sinatra is "a minimalist framework that has the developer explicitly say things instead of having the framework do it for them. It doesn't have as many conventions and puts the developer in total control of what's going on." So you don't have to go to Python if you don't want to, and this is what you're looking for.
Choose the framework based on which one's method of operation you like the most, not the language. Unless you're already an expert in one of the languages, then either you have a lot of time on your hands and you should learn the other language's, or you don't and you should learn your's.
Where are you getting that from? I'll be frankly astonished if the first version doesn't have a very clear lineage to the rubinius VM.
/r/python is discussing it at http://www.reddit.com/r/Python/comments/1oy1hi/django_rails_and_the_philosophies_behind_them/
I used to be a PHP developer before ruby and I was in a similar situation like you. There are not too many junior level position out there unfortunately. I went for freelancing and that helped me to make some ruby references. It depends on your location too by the way. Where do you leave?
I'll have to give Sinatra a look-see! (that's the first time I've ever used that.. seemed appropriate somehow) I don't know why, I've tried to love python, but the first time I sat down to code any ruby at all, I instantly loved it. 
As the second person to suggest Sinatra, I will definitely give it a try. Rails does seem a bit daunting at times, even with Mr. Hartl's excellent tutorial, I feel like it's something I could grasp much easier after some general knowledge of web programming. I've messed with drupal and joomla to do some basic things, but this is no comparison.
Where I currently live there aren't really any rails jobs at all, but I'm willing to move nearly anywhere in the US. Not just willing, actually, I'm looking forward to moving someplace new.
Scratch your own itch. Think of a problem you experience and try to write a program that makes it easier to deal with. I find this is the best way to learn as you have a vested interest in the outcome. Good luck!
Yeah... I have problems I know I want to solve, but feel I need to crawl before I run. Just looking for practice.
I should build an anonymous security exception reporting tool for work.
I feel fairly comfortable in both languages. I feel more comfortable in general with python, simply because I've used it longer, but as I said elsewhere, I never really fell in love with it... unlike ruby, where I immediately said "this is just so much more fun" but thanks for the course! I'll sign up!
There were semantic differences between 1.8 and 1.9 that are not syntactical -- some 1.8 code would run differently in 1.9.
In the US the Bay area has lot of possibilities as far as I know. 
&gt; Rails would not be possible, or at least very hard, in Python. Could you elaborate on this? Unfortunately, I never got a chance to get very deep into Ruby. That [old Zed Shaw rant](http://web.archive.org/web/20080103072111/http://www.zedshaw.com/rants/rails_is_a_ghetto.html ) came at a critical time when I was trying to make a decision between the two. I've always regretted that I never went down the Rails path. 
I'm completely self taught in development. My current goal is to look for front-end positions in rails shops and try to transition over. People seem to always be hiring for front end jobs.
Django is not particularly minimalist, but that's beside the point. You seem to misunderstand Python's philosophy. Python is not about restricting choice; it's about having *at least one* (but preferably only one) obvious way to do something. There are still going to be obtuse ways you can do it, and python won't stop you if that's what you want to do. A phrase I've heard is that python "assumes we're all adults". You see that in how it handles private attributes - they're not enforced whatsoever. Django follows python's philosophy of being explicit, something I found very helpful as a beginner. You can easily trace through the request from start to finish. Rails, otoh, gets rid of as much as it possibly can to save time (assuming you're in the 80%), which means a lot of things just "happen". It's no surprise rails has always been popular with the Apple crowd. While I love ruby (it's one of my three primary languages, with python and shell), I absolutely hate working with rails. I'll keep ruby relegated to cli scripts, tyvm.
Btw, in true python explicitness, both python and django have philosophy docs: * http://www.python.org/dev/peps/pep-0020/ * https://docs.djangoproject.com/en/dev/misc/design-philosophies/
I "know" (know the basics, these are on my Resume)...C++, Java, HTML, CSS, RUBY.
Try [Rubeque](http://www.rubeque.com). They have practical problems you can solve, ordered by difficulty, that cover a lot of topics and gets you familiar with common methods. You can do the whole thing in your browser.
This is exactly the kind of stuff I am looking for. Thank you! 
fantastic! I'll see you there
Good point... I really do have some fun ideas with stocks and metrics that I would like to pull in. I could start building out some stubs (that will 100% need to be re factored with an increase in skill) for some of the tasks that I know will need to be accomplished. 
Very cool. JRuby has to be one of the most ambitious Ruby projects around. There are so many POSIX features in Ruby that are hard to emulate in Java, it's a miracle JRuby works as well as it does. Keep up the good work. I've also just tested JRuby with Phusion Passenger 4.0.20, and it works great. Since 4.0.21 is around the corner I'll explicitly mention JRuby 1.7.6 compatibility in the release notes. EDIT: [here you go](http://blog.phusion.nl/2013/10/23/phusion-passenger-4-0-21-released-supports-os-x-mavericks-jruby-1-7-6/).
I've been having a lot of fun with https://www.codewars.com I think there's a difficulty level you can set - Ruby basics or something like that. They're somewhat contrived functions to write but there definitely is a lot of decent things to practice like learning array and string functions well so they become second nature. Then you can see how others solved it and see the highest voted answers. Those answers are usually the most expressive or concise way to accomplish the task.
While you corrected a few of my lines of thinking, you ultimately got at about the same thing, that being that I love working in ruby but just don't really like rails. Maybe I'm a control freak, but I like to have the ability to do it all myself. Though.. I'm by no means an expert so what do I know haha
hrm...I kind of agree with your approach of crawling, not running. If you 'just build it', without a sufficient skillset debugging even minor problems, you will spend a LOT of time banging your head against the wall to 'scratch your itch'. If I had the time when I was learning (and the resources that are available today), I think I could have saved a lot of un-necessary pain (and permanent damage, since I probably started some bad practices 'not knowing better') earlier. just my 1.5cents. 
yes, you should.
I think the thing is that I may have a notion of how I should build something now that I know WILL change. I am used to troubleshooting and working to find solutions, but it is only within the context of my current skill sets.... and honestly it has been a loooong time since I have had to work through complex math problems (I am an older than average learner) I think doing some problems will naturally help me build those skill sets, hopefully to a point where I can not only solve a problem like other developers would, but raise it to the next level and bring my own brand of awesome sauce to the table. 
I'm not touching it. I'm still on Snow Leopard.
I just upgraded and RVM, Homebrew, Pow, and everything else are working perfectly fine for me. If you don't want to deal with issues that come up though, don't upgrade just yet. Let people like me whine about it and find the solutions first. :)
Which is why you shouldn't upgrade ... or just use vagrant.
Yes. MacPorts shat itself and required pretty much an entire rebuild. A bunch of other dev libraries stopped building too for some unknown reason, haven't had time to look into it. The existing compiled static libraries were working fine though.
I've been running the gm for a few weeks and I've had surprisingly few issues. Just needed to update xcode and recompile ruby wit rbenv to get native extensions to build. 
I upgraded my personal computer and later tried to test my company Rails apps (they are huge). Everything went fine, so today I'll upgrade my workstation. (Chruby + Homebrew)
Nope! homebrew, and rbenv were fine. Upgrade went great!
there's plenty of free resources to kick off with Ruby. I've found a useful Quora thread about it: http://www.quora.com/What-are-some-good-online-courses-for-Ruby-on-Rails
that's a pretty nice coloring setup on your terminal. would you share it?
Agreed, I'd like to use it on mine.
Same I'd love to copy it.
He's probably using a modified [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh) theme. I used to have one of those but the slight millisecond delay those special themes add to your prompt turn out to become pretty annoying after a while.
Ruby 1.8 has no notion of encodings. Everything is binary as far as it's concerned. It's just that Rails ActiveSupport happens to have functions for treating the binary blob as a sequence of UTF-8 characters. This is what I usually do if str.respond_to?(:force_encoding) str.force_encoding("binary") else str end
Yep. Please share details.
I doubt those work with `fish` which he seems to be using, according to the terminal title. I never bothered to take a closer look at `fish`, because the idea of a non-Bourne-Shell-compatible shell seemed strange to me. But I had a look at its homepage now and it seems to have a bunch of nice ideas. For example, it uses a shell function rather than a variable for prompt definition, which should make things much easier, because fancy prompts in more traditional shells usually require some very obfuscated definitions.
Jeffs's
RVM + Postgres, memcache and nginx all on mine. All seems happy so far, as does a brew update I just ran. Only been running it for 45 mins though, there's bound to be something wrong... In my experience, XCode updates are more likely to break things than OS X upgrades for us devs. I went to 5.0 before my Mavericks upgrade though.
I use Mathias Bynens' bash prompt, it looks very similar: http://f.cl.ly/items/0y2O101f1d0G2C1G3P0Z/Screen%20Shot%202013-10-23%20at%209.01.15%20AM.png It has git functionality too, so if you're in a repo it displays the branch name and adds a star if you have uncommitted changes. https://github.com/mathiasbynens/dotfiles/blob/master/.bash_prompt
If you need to write data to file, take a look at File.binwrite, File.binread methods.
Its [Tomorrow Night, by Chris Kempson](https://github.com/chriskempson/tomorrow-theme) And the terminal configs can be seen in my .dotfiles repo, [here](https://github.com/paradox460/.dotfiles/blob/master/.config/fish/config.fish) There's some OS X only code, and some git specific stuff, but if you delete or modify a few lines, it works fine on ubuntu or other systems
interesting... I just updated and it says I have 1.9.3, but I upgraded to 2.0 before. 
Haa, I don't even know how long thats been like that. It used to be mbp
Since we're trading terminals, donut anyone? http://imgur.com/CcZuc3W
RubyMotion 2.11 builds my apps just fine on Mavericks. What's broken for you? You might chat over at https://groups.google.com/forum/#!topic/rubymotion/q-LNxStDGZ8 for help.
Travis blows for that. If I'm troubleshooting jruby's handling of zero-length socket reads, I want to run a single spec. I don't want to commit, push, and then wait for Travis to run all the specs.
Nothing's broken for me. I just saw that post yesterday of Colin Gray saying not to upgrade but I guess it's OK. 
java is not included by default. If you run java-based apps, it will ask permission to install one.
http://i.imgur.com/lukzyZq.png I ate all mine
Good to know.
NO.
Yup. I actually originally moved to oh-my-zsh, but got tired of it significantly slowing down my shell load time (turns out to be a 2 fold problem between rbenv and zsh, i submitted a patch that fixed it but there were other performance issues with zsh so i moved away from it. Unfortunately, I deleted my old oh-my-zsh repo when moving to prezto, because I wrote a blog post once that highlighted it, and kept getting support requests, even when I put it on the repo that it was for legacy purposes. I still have my prezto repo around, which is the modern version of omz: https://github.com/paradox460/prezto ---- As for switching to fish, the largest reason I switched was speed. Fish was nice and speedy, and seemed more ruby-ish, even though a significant portion of it depends on python. The auto-complete is just extra goodies
I love the idea of using an Emoji in the terminal conf. I've noticed homebrew does this with a beer (🍺), but thats really the only exception I've seen. I may add that with a hook that detects OS X, because I've yet to see a linux system with decent emoji support I'm going to stick this in my conf though ---- And there it is!
No, we gave devops a build months ago, and when the GM seed dropped they validated everything was fine and ready.
Two quick comments: a. It is not necessary to install gcc separately afaik. I have been only using clang for long time and for Ruby 1.9.3+ apps, using clang works. b. You are probably better off installing Mysql from homebrew. 
How do I configure these? Where do the files write to?
Tomorrow night, you should be able to add to your terminal, on OS X. Sometimes even double clicking the themes work. As for the .dotfiles, you probably want to check it out to your `~`, and then symlink it into the various config paths
Last time I was using it, I trimmed down some of the white space, and cleaned up some extra stuff, but it was still neat.
Shouldnt this sort of generalised functionality be a mixin unless it is strongly bound to the objects responsibilities? While they are always interesting, I am finding that metaprogramming tricks like this are starting to make some projects feel a little bit like BobX.... ;)
&gt; remember an Object is a class That's either wrong or badly expressed. You would be right if you say "`Object` is a class". But this wouldn't be relevant to your code at all. What you probably want to say is: "a class is an object". &gt; We then told it, there would be 2 variables that need to be included in order for this to run Very vague. What are you trying to tell us? That you're setting two instance variables? Or that your constructor (`initialize`) takes two parameters?
Thanks for this! I guess I'm trying to say it takes two parameters that will be used later. All this vocabulary is new to me so I'm trying to wrap my brain around it. I appreciate the help!!
There are a few things that may become confusing if you go on on with this. - "remember an Object is a class", nope, an object is an instantiation of a class. A class defines something in general, while an object is something that actually adds content to it. (This detail is somewhat important, since many people new to OOP already have difficulties seeing the actual difference) - "there would be 2 variables..." not wrong as such, but in the context of classes you often see variables inside classes referred as attributes. - "Notice the order the name and profession appear, its the same as the welcome." The order in "welcome" is not relevant in this context. You most likely mean "initialize".
Just because you're able to leave out parenthesis in Ruby doesn't mean you always should. Especially places like method definitions, it really improves readability to have parenthesis.
I'm with the guys from [Thoughtbot](http://robots.thoughtbot.com/post/54109839209/psa-do-not-use-system-ruby) when it comes to this. Besides, rbenv makes using other rubies a dream. Edit: [Ruby 2.0 will be the new 1.8.7 of Mac OS](http://dl.dropbox.com/u/113966/Screenshots/cpjnuizmuca_.png)
holy shit! I did not do that site. I haven't touched it in about 6 years so…. yeah. somebody else. I suppose I should not link to them anymore
I wouldn't use unless I absolutely had to. As I said elsewhere in this thread, I attempt to stay as *far* away from root and sudo as I can. The only time I really ever have to even sudo is when something goes wrong, or I'm trying to play with some deep-filesystem mac functions, such as editing a postgres config or whatever
Mavericks comes with Ruby 2.0.0 as the system ruby, not necessarily any need to install it with RVM.
Yeah Ruby 2.0 comes with Mavericks but in order to use some gems you may need to use sudo
&gt; see variables inside classes referred as attributes. Or instance variables, and don't get thrown if you see the term ivar, not common but I've seen if a couple of times.
Should it read like this? &gt; def initialize (name, profession) Sorry I'm really new to this! 
It does not use google API.
It's still considered best practice to keep your own local copies of Ruby with your own gems. If Apple modifies the system ruby or something breaks as a result of an update, you don't have to worry about stopping what you're doing and fixing it. Additionally, as newer versions of Ruby 2.0 come out or you want to install custom patched versions of Ruby, you'll want RVM to handle that so you don't screw up the system ruby. I've spent many a day repairing the system Ruby before RVM came along and it's something I hope to never have to do again.
yes
I love it. I ran into problems with rate limiting last time I did this myself. You might want to watch out for that or capture those types of errors so the client knows what's going on.
Synchronization is not backup. If you have corruption, it *will* be synced.
You wouldn't use system ruby? Then why does it matter what version is installed? I mainly don't even pay attention to system ruby simply because Apple has a kind of terrible track record of keeping the system ruby up to date.
Agreed. I call that out about half way through the article. However, I could have done a better job differentiating between backup and redundancy.
Those people who may write system utilities that they want to distribute can now make use of new ruby features. Things like TextMate bundles, Alfred tasks, and so forth
thx :)
That's cool, I'm all for diversity, but what situation would require RVM over rbenv?
Didn't we already have this topic not even a week ago?
there is a section in the fundraiser https://www.bountysource.com/fundraisers/489-rvm-2-0 "RVM vs. rbenv vs. chruby"
I read that, but it's pretty vague, and the article it links to is just a bunch of rage comics. I really would like to know what complex situations benefit more from RVM.
General convention is to put the opening parenthesis against the method name; spaces within the parenthesis is up to personal tastes. e.g.: &gt; def initialize( name, profession )
there are many reasons, the biggest difference - rvm is the only one that builds and installs binary rubies
Neat toy. [You probably shouldn't use this for anything in production, however.](http://www.google.com/intl/en/policies/terms/) &gt; Don’t misuse our Services. For example, don’t interfere with our Services **or try to access them using a method other than the interface and the instructions that we provide.** You may use our Services only as permitted by law, including applicable export and re-export control laws and regulations. **We may suspend or stop providing our Services to you** if you do not comply with our terms or policies or if we are investigating suspected misconduct. 
rbenv + ruby-build does too
This one is full of more bullshit hyperbole though
binaries like this =&gt; http://rvm.io/binaries/ ?
https://github.com/sstephenson/ruby-build/tree/master/share/ruby-build
IMHO rbenv and chruby are better, faster, easier, and safer choices. If you're interest is funding open source improvements, take a look at GitTip (https://www.gittip.com/) which enables you to donate to thousands of open source projects on GitHub, including rbenv and chruby.
One complex situation that RVM handles vs. rbenv is gem sets. However, IMHO there are better choices for gem sets such as bundler (everyone I know uses this), oh-my-gems (which is brilliantly simple), or simply setting your own path as you like (my preferred solution on servers). 
Interesting. I didn't realize RVM used precompiled binaries.
I was happy to ditch gemsets in favor of just using bundler, but you can actually use them with rbenv if you wish: https://github.com/jf/rbenv-gemset I haven't seen oh-my-gems before.
I didn't know about that thank you.
I stopped using RVM because it seemed like clunky overkill for what I was doing at the time. Having my nose rubbed in the fact that it's 20K lines of *shell script* puts it into a whole new omniverse of Rube Goldberg Awesomeness™, though. I can hear the "It seemed like a good idea at the time" argument for how we got here, but seriously? Getting 20K lines of shell script into a hemidemisemiquasicoherent whole is an amazing feat that most people would have given up on and thought through another solution after maybe 2K lines. :-)
no, this are only definitions for compilation, what rvm provides is skipping compilation and downloading a compiled already binary when it is available
Oh, well thats kind of cool. I still found rvm to be a bit more of a hassle than it was worth, what with having to juggle sudo, rvmsudo, and so forth
You could also considerer Nginx without removing your current Cherokee installation.
Apache is a fine server. Despite all the Apache hate that has built up in recent years ("Apache is slow", "Nginx is faster", etc), Apache is an excellent product that can perform great if you tweak it a little bit, e.g. by reducing the number of processes and their stack sizes. The recent Apache 2.4 release significantly improved performance with its event MPM. Apache also has a very good module ecosystem and very good compatibility with almost any web app. Wordpress is trivial to install on Apache. That being said, my favorite web server is Nginx. Its configuration format is slightly less verbose and easier to understand. It "feels" lighter (it's not *that* much lighter compared to a well-tuned Apache, but the feeling remains). Combined with Phusion Passenger, I host a ton of Ruby and Python apps on Nginx and it's a pleasure to work with. However, Nginx may not make sense for you because you want to host Wordpress. Nginx cannot run PHP out of the box without all sorts of annoying php-fpm management, and does not support .htaccess, which Wordpress relies on for URL rewriting. There are ways to get around it, but in general it's such a pain that I find it easier to put Wordpress on Apache, and then Apache behind Nginx. This setup performs pretty well: I tweaked Apache for low memory usage and blog handles traffic pretty well. I don't know much about Cherokee. The only I've heard about it is that 5 ago they claimed to be "the fastest among modern web servers", and published a benchmark in which they show they're faster than Nginx. Since then I've heard nothing about them, no new benchmarks either. Of course benchmarks are bullshit in general. Maybe they were only benchmarking how fast they can serve a 'hello world' file from disk, which means nothing. It's probably a fine server so if you have no reason to switch then you should stick to it I suppose. Unless you want to run Ruby/Python/Node apps; then you should use Nginx + Phusion Passenger. ;)
I'm a happy user or RVM and I contributed. Having variety in the ruby management ecosystem is a good thing and hating on RVM just because you use rbenv or some other ruby interpreter management tool is a little silly in my opinion.
Seriously, pick a ruby open source projects and try to systematically work through their issues or bugs list. using git diff, check out how prior issues or bugs have been solved. Then try to get your commits accepted by the project maintainer. Nothing is sweeter than that initially. Pick a project you use regularly for more awesome feedback cycle.
You're right. I think it should be fine for non comercial, small scale uses though.
Thank you for this. I will be buying it once I get home. One quick question... does this book cover deploying "Multiple" rails apps to a single VPS? I ask this because I want to use a Linode box to host 3-4 very simple Rails apps. They won't get nearly enough traffic to warrant having their own servers. Thanks.
Thanks! Will do.
I would go for nginx, the problem with cherokee is that uses a binary config file that sometimes changes between version to version. And what if you want to put your config file in your repo?
Interesting. Hopefully the book covers Unicorn. I've had endless problems with my init scripts for Unicorn.
Do you use Capistrano 3 in your book?
Yep the main app server covered is Unicorn, there'll be a couple of configurations, one with zero downtime and one without. Both are using init scripts and monit configs I've found to be reliable in production. 
You won't just be funding RVM by contributing to this fundraiser. Michal has an excellent track record of contributing back patches and features, so you'll also be contributing to many other projects that RVM touches including RubyGems and by extension the other version managers.
I've administered all three in a professional context. The real problem with apache is its configuration syntax; even after working with it for years, I still have to continuously look things up, and xml just doesn't make sense for things like if-statements. There are also a number of times where I absolutely could not explain why apache was not doing something we thought we told it to do - and then we hacked it into the varnish config in two minutes instead. :) The problem with Cherokee is the reliance on a config file, but always wanting you to use an abstraction layer to edit it. The file format is designed for machine-parsing, so you can't really edit it on your own (and then why are you using Cherokee?). There were a number of instances where I saved the config in the admin ui, and the server died without telling me, because there was an error their client-side validation didn't catch. They fixed those particular instances, but I'm uncomfortable with a system in which that's possible. Finally, when Cherokee hit 1.0, [I asked]( https://web.archive.org/web/20100515144509/http://lists.octality.com/pipermail/cherokee/2010-May/012743.html) about stability guarantees, and the answer was no. I realized then it was irresponsible for me to continue using and recommending it. Nginx is cool, though. 
Some ideas: - Attend and/or host as many Rails related meetups as you can, especially hack nights. - build a brand and answer as many questions on stack overflow as you can - write some helpful blog posts targeted at beginers and post them to rubyflow. 
This feature could be implemented as an rbenv plugin backed by a service/repo of some kind. Pretty much all the things folks want rvm for can be done with rbenv and plugins. Feature being discussed: https://github.com/sstephenson/ruby-build/issues/42
I used to think I needed gemsets till I read the bundler documentation and figured out that `bundle install --path .bundle/bundle` saves the path in the .bundle/config file (and .gitignore the .bundle directory). Any subsequent calls to `bundle` in the project directory read that file and honor the path. The one place a gemset is kind of useful for me now is for project creation, like having a rails4 gemset for creating new projects. Chicken before the egg kind of thing.
I'd just like to say that this is fantastic general advice. You have my sincere thanks for taking the time to share it with me. I'd like to focus on attempting to make games with Ruby. I feel like that's been my positive point so far. I feel like Rpg Maker VX Ace is a little restrictive. You can really make any type of game using the engine if you know enough about rgss3 (ruby-ish) but it is a lot more work to make a game that is *not* an RPG, as that's what the engine is intended for. 
the way from "could" to actually implementing something is really long, and remember the first time is the hardest (what rvm had to do), someone could now read rvm code and implement the same compilation of binaries a lot faster avoiding all the hassle with patching ruby, with finding compilation flags, it all has been done, now it would be a lot easier because the hardest parts of it are already done by rvm.
I can't speak for the gaming side of Ruby. Often what that means is working with a particular library or suite of tools to produce a game, which requires so many different components to create... However, there is nothing to stop you looking into the open source community of Ruby based gaming engines/tools etc and seeing where you can pitch in. From using the tools to providing bug fixes, features or generally using the libraries coding to improve your own. From my time as a programmer, one truth is that every six months any previous work I have done, I hate, or at least hit my head asking why. I hope one day that won't be true, but don't be afraid of that. It means you are learning, you are seeing mistakes you made from before, decisions you'd of rather changes, etc. Games often see like the easiest entry to furthering programming skills, but as you said with RGSS3 you are restricted. But if that is your love, look at alternative libraries, and for a first go attempt to re-create existing games you've created. Is it easier, harder? Why - look into the reasons, they are often deeper than one library being better than another (or engine). Often it is idiomatic choices of the library inventor - do they prefer a different style of coding, event-driven, procedure-driven, async/sync. What suites your games best - learning this enables you to use better tools for future work, and design better tools yourself.
You're probably not including the module you need. You're probably doing something like this: consumer_key '01230ssssf00' On the offending line. However, you're using some method included in your class or module without including it, so you get a NoMethodError. Have you tried: require 'chatterbot/dsl' ? It looks like you need to use 'chatterbot-register' before you can do anything, too...
I second that, this looks like an amazing ready. That could surely benefit the Rails development community. I think one thing holding back a lot of apps from being deployed, is the actual staging process of getting a server setup can be quite intimidating, let alone needing to setup multiple servers.
Shouldn't it be consumer_secret "=" %{...} ? And the same for consumer_key
So, after all that, I'm just redoing it with nginx--thanks for the help and advice!
Glad to see a fellow rpg maker guy :D Well making games with ruby is a little bit harsh at the time, there's a few implementations of opengl but none of them seem complete or supported, in fact they seem like a proof of concept, it's nothing like sdl, lwjgl or glfw. I guess since you come from RPG maker you don't know about gems? Gems are ruby libraries. I was working on a opengl library that wrapped opengl as an object oriented interface and included the functionaility of glew - it loads all the functions and constants. I'm "working" on a windows api wrapper as well, but those two are pretty much on hold, university consumes too much time :C. If you want to get simpler there's Rubygame and Chingu, but they are limited to 2D games. 
If you do end up using V3, will you update the relevant parts of the book for free, or will we have to buy it again?
Sorry to be dense, but what's the difference between an "awareness company" and a "spammer"?
You're right, I didn't phrase that well. It's actually for political purposes, it'll say something about people having the right to denounce police officers if they don't let you film them in response to certain hashtags. I guess it is something close to spam, but i hadn't seen it that way before you pointed it out.
From the git tip website: &gt; We add an additional 30¢ + 2.9% fee when pulling money in from your credit card If you care, just mail someone a check.
I understand that you're not building this to be abusive on the platform, but be aware that this app will likely get it's account, the API keys and any subsequent accounts that use it suspended. See Twitter's [Automation rules and best practices](https://support.twitter.com/articles/76915-automation-rules-and-best-practices) for more info. 
And with 2.0, it gets even more powerful. Ruby gains the double-splat operator, which not only passes value, but passes keys as well Yes you could fake similar things before with the implied `{}`. But now you don't have to. So `def x(l, **m, n)` is now possible.
To be honest it depends on timing. If I switch (so have some experience with it in production) while the book's still in progress I'll include it in this book for free. Otherwise I'll probably do it as a small standalone piece/ series of blog posts. Main factor is I'm trying to make sure everything that goes into this book, I've tested properly in a production environment.
I can't even see any ruby code, could you link to some ACTUAL code so we can evaluate it? all i saw was an RAR file with god knows what's in there (i couldnt see any .rb files)
&gt; ... people having the right to denounce police officers... Unless "denounce" has some specific legal meaning, this is a complete waste of your time (and/or your employer's money). "Denouncing" a cop for trying to make you stop filming has about as much value as "denouncing" a rock for stubbing your toe. You seem to have a general problem with believing that language has more power than it actually does.
Let me know if the source code would be useful to open source. It is currently part of a rails application, but the code is applicable to anything ruby.
Open source is always useful, if you're able to release please do so
https://www.ruby-forum.com/
http://parley.rubyrogues.com/ has some some pretty content Find the mailing list of your local ruby user group or join the mailing list of user group in another city
Ruby has copied a lot of perlisms, so with a lot of things you'll feel right at home. Some of these are hardly used in the ruby community though (BEGIN and END blocks come to mind). To your first question: Ruby is built (mostly) according to the principle of least surprise, so DWIW is definitely there, but maybe not to a degree as you'd expect from Perl. Regarding pragmatism: there's a lot of that there as well. Due to the open nature of rubys class system, you can re-open any class at any point and inject your own methods or overwrite existing ones (aka "monkey patching" in the ruby community). Ruby as a language does force you to think about what you're writing though. There were two big pain points that caused me to move away from perl and to ruby back when I made the switch: nested structures/variable references and perl scripts usually gravitating towards the unmaintainable; unless programmers were self-disciplined, it's so very easy to misuse perl as a write-only language. There are a few oddities you'll need to get used to (for loops don't exist for example, the more functional mapping/filtering paradigms are used here; constants aren't really; classes can have instance variables in addition to class variables) and if you really want to use ruby to its fullest potential, you'll need to learn the class model that ruby uses. But all in all, I've gotten comfortable very quickly with ruby and the syntax. Since you mention having tried python: I've only gotten around to trying it after becoming good at ruby and one thing that really struck me in a bad way in addition to the whitespace-has-meaning thing was how perly it felt (in a bad way). So be warned: migrating from perl to ruby may very well influence how you look at perl after you've become comfortable with ruby. Regarding the second question: Jeff Atwood recently had a nice blog article about ruby (http://www.codinghorror.com/blog/2013/03/why-ruby.html), from which I will quote one paragraph: &gt; Ruby isn't cool any more. Yeah, you heard me. It's not cool to write Ruby code any more. All the cool people moved on to slinging Scala and Node.js years ago. Our project isn't cool, it's just a bunch of boring old Ruby code. Personally, I'm thrilled that Ruby is now mature enough that the community no longer needs to bother with the pretense of being the coolest kid on the block. That means the rest of us who just like to Get Shit Done can roll up our sleeves and focus on the mission of building stuff with our peers rather than frantically running around trying to suss out the next shiny thing. Personally, I don't know where the rubinius guys article came from, but I guess there's some non-obvious personal angle or context in that article. First of all, there may be differences in opinion as to language design (one of rubinius' main selling items being truely threaded, as opposed to MRI rubys global interpreter lock which allows only one thread to execute at the same time), Matz regarding threading as a design smell and lots of people with java background disagreeing. Also, Rubinius' main sponsor for the last few years dropped the project in favor of helping other, less mature projects along. Could also be that the Rubinus author was just trying to generate some traffic to attract other sponsors. Does the MRI ruby interpreter have warts? Sure. If you ever look at the underlying C code, it can get ugly, especially in the older libraries. The garbage collector has been a potentially big performance killer for years, but is seeing continual improvement since the 1.9.3 release. I'm a bit worried about refinements and the impact they will have on code readability. But all in all, the interpreter is fine, the language is great (unless you need to do number crunching stuff) and I don't think ruby is going to die any time soon. It just doesn't give ruby coders the wow factor they had 5 or 10 years back.
Yes, exactly. Rubinius was a different implementation that happened in parallel with the main ruby development and has been around since the ruby 1.8 days. It definitely wasn't a CPR project. There have been severl different implementations over the years. MRI has always been around as the reference implementation. Rubinius' aim was to write as much of ruby in ruby as possible, and to introduce a JIT. Then, there's JRuby - as the name implies, ruby for the JVM. There's Maglev, running ruby in a smalltalk VM. And then there was also IronRuby, a microsoft implementation that got killed a few years back. I wouldn't wonder if someone came around and ported ruby to the erlang VM next (oh wait, there's elixir...).
Hey man. Sorry about that. [Here you go](https://www.dropbox.com/s/i1l8wxaec6hm27k/RSS_BETA109_Scripts_Source.rar), thats a rar file with all the .rb files for the system I posted in the OP. I'll edit the post now and put it in there. btw, the rar file you ended up getting was basically a source for a game project in vx ace, included within are all the scripts and a demo that shows off the system a little.
&gt; a desperate effort like perl5i or kurila to breathe life to a dead-end language More like Topaz. Ever heard of it? No? That's your answer.
1.7.5 &amp; 1.7.6 do not work with warbler for me. The web.xml has junk characters at the end. I am sticking with 1.7.4...
IRC, stack overflow, etc
I agree with the Devise statement, but CanCan is light enough to be useful for a lot of apps.
I've picked up some Ruby recently and also some opinions on Ruby, by osmosis, and the thing that stuck with me is this: Ruby is meant to be _fun_ to write. It gives you things that make it enjoyable. And programmers who feel like their work is enjoyable will want to keep coming back and code day after day. So you should try to get into a mindset where you _enjoy_ writing the code, where the language features help you out with that. I feel like a lot of the things Ruby gives you, take you a long way towards that. The smallest things can help: writing a function call with an argument without needing to do a `Shift`-combo twice? Your fingers thank you--a _lot._ E.g.: f(x) versus f x And so on.
well ironruby is still alive on [ironlanguages github page](https://github.com/IronLanguages/main?source=c) but they seem to be focusing on ironpython for now
 1. There was a link posted either here or on hacker news that really summarized good ways to do it. [link](http://brandonhilkert.com/blog/3-ways-to-get-started-contributing-to-open-source/). 1. If I have used any gems in my personal projects that have any outstanding issues that I can solve, I usually contribute there. 1. You can always help out on the posts that appear in this sub. Every once in a while there is a post asking for critiques of new projects or help. 1. I've taken to using the advanced search on github. I'll select the categories of ruby projects, stars 2..30 and then search from the least stars. This way, I can find newer projects that are budding and looking at what looks interesting. If you're really experienced, you could look at really popular projects and work on some harder issues.
Thank you. Very new. 
Learn Rails, perhaps create a html5 game?
This mostly addresses the dying language question. Ruby has matured a lot but is definitely not dead. It's finally stable enough that it's getting a lot of love from other products. [OpenSuse just adopted it for Yast, doing a complete rewrite in it.](https://news.opensuse.org/2013/10/10/coming-soon-opensuse-13-1-with-yast-in-ruby/) The language really is great for getting things done. There are so many things in the standard lib alone that make it really useful. It's not shiny. It doesn't have some of the fancier projects that you might see in other platforms like nodejs. But the community is super active and building new things all of the time.
Ruby is basically Perl 6 as it was meant to be. It threw away all the legacy garbage and kept all the good parts.
That was exactly what it seemed when I went through some Ruby tutorials like [this](http://migo.sixbit.org/papers/Introduction_to_Ruby/slide-index.html). I don't know enough about either language to conclude one way or the other though, but so far googling only gives me claims like "Perl 6 is much more ambitious and versatile than Ruby" without concrete examples of where it's better. 
Thanks, that "fun to write" factor is exactly the thing I wanted to capture with my first point, and the place where Python gets in the way too much. Thanks for confirming that Ruby gets that aspect right. :) 
Depends on what you mean by contribute. If you mean cleaning up bugs then you can look at some of the more popular gems or apps and then look at the issues list on GitHub. If you mean designing in new features or making the project better then I think it's best to just start wherever your interests are. For example if you started messing with Wikis and looked into Gollum, you'd find several Gollum side projects, and also find that Gollum has not-awesome documentation. A few months ago, you'd also find when you tried to get it to run that it depended on Grit, which was unmaintained and now was being bugfixed by someone else - except Github's version of Grit didn't point to this new version so their app *always* crashed out of the gate for any new users. You'd also find several side projects related to serving up Gollum content or making static sites from Gollum, all of which have feature requests such as adding search in, etc.
Ask yourself why you want to contribute to a project. Ask yourself which projects are more interesting to you. Enthusiasm and being interested are the main things you need to be a good contributor. Hopefully by thinking about the types of things you like, you can find the types of projects - to narrow down the list. 
It also added a scoop of object-fetishism, and threw away variable declarations, opting instead for something kind of like Python's bizarre version of scope: irb&gt; [1,2,3].collect{|n| n+1} =&gt; [2, 3, 4] irb&gt; n NameError: undefined local variable or method `n' for main:Object irb&gt; n = 0 =&gt; 0 irb&gt; [1,2,3].collect{|n| n+1} =&gt; [2, 3, 4] irb&gt; n =&gt; 3
They fixed that particular issue with Ruby 2.0, because everybody knew it was wrong, but before that they didn't want to break backwards compatibility in 1.x: irb(main):001:0&gt; n = 0 =&gt; 0 irb(main):002:0&gt; [1,2,3].collect{|n| n+1} =&gt; [2, 3, 4] irb(main):003:0&gt; n =&gt; 0 Now it's pretty much DWIM scoping.
Did anyone else notice it updating git to 2.0 as well?
&gt; for loops don't exist for example [Yes they do.](http://ruby.learncodethehardway.org/book/ex32.html) It's just that nobody bothers to use them.
There's also a project to write ruby in rpython, although the name escapes me. 
CanCan has two real problems. 1. Lack of caching 2. The learning curve to effectively implement non-trivial rules. ...but I didn't say it was impossible. 6 of the 7 high-level points OP makes are solvable using CanCan.
In perl lingo, those would be foreach loops. There are no for ( i = 0; i &lt; limit; ++i ) type loops in ruby, which is what I implied for OP.
They actually fixed that in ruby 1.9, many years ago now.
This was fixed many, many years ago in ruby 1.9. It was a 'bug' in ruby 1.8 which is now ancient.
&gt; For example Perl's insistence that "5", 5, and 5.0 are the same object really screws the language, You can like or dislike this, but it's fundamental to Perl being Perl: operators have types, scalars don't. I happen to find it more annoying having to call "to_X()" all over in Ruby, than to have "5" and 5 be the same thing, but that's just a matter of taste. &gt; most frustratingly Perl 5's ^ operator actually magically distinguishes "5" from 5 - 5^5 is 0 but "5"^"5" is "\x00" IMHO this is the mistake (and, last I checked, Perl 6 fixes it) -- these operators try to look under the covers to change behavior based on hidden state, making them untrustworthy. Smartmatch is the worst offender, but the bitwise string ops have been making this mistake for longer.
Scalars in Perl of course have types - one of the types is this awful numberstring hybrid. Other scalars are variety of custom types and these are properly separated. This is not a matter of liking it or not - it's a fundamental design mistake because you can't have real objects and you can't have fully featured container classes if you do that. And the benefits of saving a few characters here and there is basically nonexistent, it won't even save you any typing (Ruby code is usually shorter than Perl code for the same thing, and more readable while at it) - string interpolation automatically converts things to strings so that's no savings at all, and converting strings to numbers on input is really not a huge deal.
&gt; Scalars in Perl of course have types - one of the types is this &gt; awful numberstring hybrid. I have no idea what you're talking about here. In Perl, numeric operators ask for numbers, and scalars provide them: main @&gt; $i = 23; $s = '23'; $f = 23.0; $g = \23; main @&gt; $i + $g '140622002907919' main @&gt; $i + $s 46 main @&gt; $i + $f 46 &gt; This is not a matter of liking it or not - it's a fundamental design &gt; mistake because you can't have real objects and you can't have fully &gt; featured container classes if you do that. Can you ELI5 what "*real* objects" and "fully featured container classes" are? I'd rather not play the "true Scotsman" game. &gt; Ruby code is usually shorter than Perl code for the same thing, and &gt; more readable while at it) It looks like [a wash](http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=perl&amp;lang2=yarv&amp;data=u32) to me.
Is there a reason you're installing rc2? Have you tried with the latest patch level? (p247)
&gt; Imagine any custom object class. What does == mean on it? What does eq? Does any of that make any sense? You mean you want to be able to control how binary operators apply to scalars? The built-in "overload" module does that. And unlike in Ruby, "`3 + object`" and "`object + 3`" are both under your control. &gt; Objects that need external knowledge to even compare for equality are no real objects. I take this to mean you don't like how "==" forces both of its operands act like numbers, etc. This doesn't bother me, and while it may bother the poor operands, I don't tend to anthropomorphize them. As for sorting and comparing arrays, the former is built-in, and you can trivially write a function to do the latter. If you want more Ruby-like syntax, use something like "autobox."
the biggest issue that I came across isn't whether or not a user has access to an object, but how much access it has to the object (specifically which attributes). I use CanCan for some other projects because the DSL is (normally) very clean and straight forward.
I think they can both be useful sometimes, and for rapid development and deploy, but there are always trade offs. I think the ease of using Gems with bundler can obfuscate them and make it seem like you're getting something for nothing.
Cancan was driving me crazy in a project due to Rails compatibility issues and my ability file being massive. IMO the organization of it (user role -&gt; model privilege list) is backwards to what goes on in a large project, where you have many models all with their own complicated privilege logic based on the current user. I discovered Pundit thanks to this subreddit and have happily using it ever since.
if you recently updated to Maverick make sure you go into X Code and update command line tools to the Mavericks version as that can throw weird errors. 
Thanks, I've been postponing learning RoR for way too long. But I think you've done the "advice/how to learn" for me. I'll just read what you did and do the same until I start developing my addiction for RoR. Currently (ashamed to mention age) I'm addicted to WoW gaming!
Doing it the RoR way? Or have you gone alt?
congrats. Your hard work and perseverance has paid off well :).
I'm about 3 months into doing pretty much exactly the same thing you have been doing. I have a little bit of programming and web design in my background, but nothing professional. I've actually taken on a freelance project for a friend, unpaid but still work in rails. It took me about a month for rails to really start to jive with me, but I've also been working on Objective-C and iOS development. What advice do you have when you actually attend the meet ups to get the kind of connections you need, and just out of curiosity, which city do you live in? and are the internships remote, or within the area you live?
You play WoW? You must be between 5 and 70 years. Did I guess?
You also might like padrino, which uses sinatra as a base and extends it, with things like scaffolding etc..
Yes i do but only very slightly. Only for the fact that i think it helped convince my current employer that i wasnt a complete slacker. I think alot of startups wouldnt care though
I may be missing some context here, but yes im trying to learn the mainstream best practices way of doing rails apps and stay pretty much to the book.
This is pretty amazing. I have don something similar- I had been studying ruby and rails for a few months and decided to move home with my parents in the south for a few months. I worked my ass off all day every day and have now built around 5 Rails apps. I still have a ton to learn and my testing needs work, but it is exciting. Later this evening I close a freelance deal, so I will have that $$ to fall back on while I continue my job search. I have a few interviews lined up this week. 
Seems like you are even going well beyond what I've gotten through up to this point. Congrats!
Don't worry. VIM have analogues plugins: Package Manager - NeoBundle AutoComplete - http://valloric.github.io/YouCompleteMe/ - fuzzy autocomplete like in SublimeText2, and have integration with Eclipse http://eclim.org/ ack, grep, ak - yes, VIM have plugins for search enh-ruby-mode - syntax and errors highlight - https://github.com/vim-ruby/vim-ruby and errors: https://github.com/scrooloose/syntastic Projectile Mode - CtrlP Rainbow Mode - yes Robe Mode - yes, Ctags + default vim key &lt;c-]&gt; - go to function definition Highlight indentation for Emacs - VIM indent guides or https://github.com/Yggdroot/indentLine Yasnippet - yes, UltiSnip, SnipMate multiple-cursors - yes textmate.el - CtrlP - :CtrlPBufTags 
Great point. CanCan is better suited for authorizing actions rather than attribute access. I would be interested to see how you solved the problem. :-)
This is a great story! Congratulations. This is what it takes to be successful in *anything*. You sat down and made it happen through self-motivated work with a payoff in the potential future. This is awesome. 
I've been there. It's very difficult to break the feeling of accomplishment that online gaming gives you. You have to though. You will look back and wish you had started that company, or developed that project, or something. Trust me. The feeling of accomplishing something in WoW can be experienced x10 when you are writing your own app, each time you solve a problem, each time you get stuck and dig yourself out of a complex programming hole, etc. Things like Code School can help break that addiction because they follow the same rewards mechanism where you slowly build up steam and earn badges and stuff along the way. You will be filling that experience bar. Good luck!
I've never used NeoBundle, but [Vundle](https://github.com/gmarik/vundle) is a great solution for managing your plugins.
i'm no hardened RoR developer, so I might be wrong, but I think the rails tutorial does things the RoR way (TDD, fat model / skinny controllers, etc)
$42 seems steep for a pre-release. Will that full amount be discounted when the book is complete? Are there any sample chapters or excerpts to read?
Thanks!
What did you feel was the hardest thing to learn about rails?
Hopefully all of that will be on Amazon when it does come out...
I just tried the forum post method. Can confirm.
No samples yet but I'm working on finishing it up and will post them when it's complete. I've given out discounts at different times and will send notifications to my mailing list if I have any in the future. A sample of some other things that I sent to my mailing list are my recent blog posts http://www.saturnflyer.com/blog/
Wow congratulations, I have a front end background, have done railsgirls, hartls book and one month rails and have been wondering about the learning curve and transition time to employment as a jr dev. Your story was motivating, and educational for ideas on getting there, and how to step it up a notch. thanks! 
Ah ok, Well it's definitely real ruby code you're writing, but it is a little unidiomatic. But it's a good base to start from.
Download [pry](http://pryrepl.org) and have a play around in there. It's particularly good for exploring third party libraries to see how they fit together.
Oh also, you're probably going to want to run linux/osx in a VM. Real Ruby dev in windows is a pain.
nice setup! also I suggest undo-tree, I discovered it recently and now I can't live without
Slightly unrelated, but would anyone be interested in a similar setup for Vim and possibly Vim + tmux?
I bought the book a while back and was quite disappointed. It points out why book publishers have editors. The first two chapters were filled with questions but no answers. We know the questions, that's why we bought the book. There is quite a bit of rambling. I quit reading after that so it may get better. I haven't went back to it since then. I figured that I took my chances and lost. 
Thanks for the story. I've been trying to accomplish something similar. I'm about 2-3 months in learning programming. At first I didn't really know where to start and probably wasted a lot of time not learning basic HTML and CSS first. I feel like I'm on the right track, learning objective-c and doing Xcode tutorials. I'm currently learning through teamtreehouse.com. I hope to be able to where you are within 6 months of working hard at it. This post motivated me to keep going. Thanks again!
&gt; Does Emacs have anything Sublime doesn't these days? Yes. &gt; Sublime Text: The text editor you'll fall in love with Humility? &gt; just about everything in Sublime Text is customizable with simple JSON files LOL. Either their config file will grow a programming language, or they'll develop a broken "plugin" system next to it.
Heaps of things. org-mode, magit, a decent terminal emulator, and degree of scriptability that sublime text can only dream about. Emacs is very smalltalky, it's essentially a live lisp process that can be patched and modified at will.
Keep going! When I look back to where I was at 3 months I realize I had only begun to figure out what I even wanted to learn. Try to find something that will really hold your hand through your first project. It will build your confidence.
After years of an on-again off-again relationship, I've decided that the power to pain ratio is just not there. Sure, emacs can do lots of things if you are willing to go through the hoops to do it. I would rather be working on my projects, not my editor.
Hmm. Not promising. Usually Delegation arises when Oh Dear, you have the behaviour on the wrong object! So we will move it to the right object. Oh dear, all the clients still have a handle to the wrong one, so we will just shunt the method on... Oh dear we have boiler plate code which we can meta-program away.... See we have cleaned up our mess with the Delegator pattern. Nope you haven't. You have a mess. You used the false sanctity of the delegator pattern to give the impression that you actually meant to do that. You actually need to rethink your design. Nine times out of ten use of the Delegator pattern is a code smell, not clean code.
Me. I would be. There's a neat one out there for Vim and Python but I would also read a Vim and Ruby edition for sure.
That's what I've been doing so far. I've done quite a few marathon sessions (8+ hours a day a couple days a week) and I think I got burnt out. I'm going to attempt to schedule a few hours each to work on it and then stop til the next day to prevent that. 
I used Vundle, but now I use NeoBundle. And NeoBundle is faster, IMHO.
&gt; ctags is a static analyzer Yes, this is a problem in VIM :( I need to regenerate tags file every times when i install new gem.
And VIM can it, includes meta-programmed methods (ohh, don't all). For example: respond_to :json I use keybinding &lt;c-]&gt; to go to definition method json: *active_record/connection_adapters/postgresql_adapter.rb:325* But, def self.method_name I can't go to definition methods like this :(
This is a link to a page trying to convince you to buy a book, which has no samples of the content that's actually IN the book. This is advertising, not content. 
as per this commit, the jruby team appears to be taking it over: https://github.com/ffi/ffi/commit/e40243a224a7aedc3cd36c67ee11d847f24f99c5
Yes. A decently powerful and customizable editor. 
.
This can be done automatically if you do these three things: * http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html * https://github.com/tpope/gem-ctags * https://github.com/tpope/rbenv-ctags
Ah, sorry. I misunderstood. That's a bit weird, though, jumping from a controller to an ActiveRecord schema definition method. And it's also a plain method (not defined dynamically).
&gt; That's a bit weird, though, jumping from a controller to an ActiveRecord schema definition method. I think, it's useful for understanding, how **it** works. And i sometimes use it if i want know, how method realized. &gt; And it's also a plain method (not defined dynamically). Than, vim + ctags can't go to definition meta-programming methods :(
Congrats, I'd take it further than you do based on personal experience. If you can complete and undertand hartl's sample rails app and you're capable of googling/reading to acquire things not covered there you're pretty much equivalent to junior dev anywhere.
This is an application of "prefer composition to inheritance", and it's absolutely the way to go. Quite apart from the structural effects, wandering around rampantly extending things with modules has icky performance implications.
How's your SQL skills? You mention ruby, rails, javascript and jquery but I don't see any mention of mysql or mongodb, etc. Has this been a problem at all? 
But `respond_to :json` has no relation to `ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::ColumnMethods#json`. Jumping there from a `json` call in a schema or a migration file (which I expect Vim also does) would make more sense.
I'm working on a large JS codebase, but it's the same thing: Using mixins for duplication removal was such an awesome idea at the beginning, but now it's almost impossible to grasp all the functionality of a class without opening several other files.
Cool! This gets me thinking. I'm learning Ruby coming from Javascript and would anyone advise using a short-circuited double pipe in harmony with the ternary operator, or does that decrease readability too much? Example: val = (a) || (b), where a = x ? y : z, and b = c ? d : e Is this a pattern that people use?
First off, I just want to say congrats. You're where I want to be and your post convinced me that I definitely need to be more outgoing at meet ups. As for Hartl's tutorial, are you just going through the book version or are you watching the screencast as well? I'm contemplating whether or not I want to buy the screencasts. 
Are you going as a specific ruby developer, or ruby developers as a concept? Have you considered carrying the pickaxe book with you?
You can use `||=` in combination with `begin..end` blocks. value ||= begin if condition 'enabled' else 'disabled' end end 
Yeah, total "duh" moment, I corrected myself above. I think my logic still applies though (unless I'm missing something). The end result is that you'd still really have 3 values to compare. That first expression will always either evaluate to your positive return value, or will be `false` or `nil`, which will cause it to move on. I suppose it's really a preference, but it seems logical to replace the "else return a false result and move on to the next expression" with the next expression. I will say though, that what you're describing would probably work better if you were dynamically building those statements before-hand (as you do `a` and `b` above). Otherwise I'd maybe warn that abstracting that too much vs. having a tree of conditional statements that can be more easily followed might hurt readability.
Also, I hear knit hats are good. Maybe thick frame glasses and a PBR in your hand too.
For the lazy: /r/rails --- I provide direct links to lesser known subs mentioned in the title if one isn't already provided. Let me know if I need to try harder: /r/LazyLinkerBot
I'm a ruby developer and like to dev naked, so you could do that.
The blue might be formatting specific to your browser, but you can format your comments on reddit using markdown - take a look at the little "formatting help" link below the comment box.
You don't even need `begin..end`. `if..else..end` by itself is a perfectly fine expression: value ||= if condition; 'enabled' else 'disabled' end 
Real list comprehensions, please! I also think that [pattern matching and guards in functions] (http://learnyouahaskell.com/syntax-in-functions ala Haskell) would fit nicely in the Ruby way. Edit: leaving my broken link as testament to how dumb I am. Please see /u/mcdud3's post below for a working link.
Not sure what level you're at, but SQLZoo is a good free resource. I spent a weekend reading everything and doing all the problems on the site twice and felt like I had a solid grasp of SQL by the end. I'm no DBA, but it's enough to understand what ActiveRecord does. When you're ready you can view the solutions in "cheat mode" by adding ?answer=1 to the end of the urls.
Fixed your link: [pattern matching and guards in functions](http://learnyouahaskell.com/syntax-in-functions)
^ what he said.
so these are both the same? But not really because the 2nd one doesn't check for 'false'. So is it like the third one then? @tracker ||= {} @tracker = {} if @tracker.nil? @tracker = {} if @traciker.nil? || !@tracker
A way to do single-file static binaries with a modern interpreter, so deployments aren't painful. I know in principle one way to do this. Sweep up all stdlib and gem sources into an sqlite database, which you load into memory at runtime before launching an embedded ruby interpreter with `require` hacked to use that from [amalgalite](https://github.com/copiousfreetime/amalgalite.git). The sqlite database gets dumped into a .data segment as part of the build process. I did get part of the way there with this [over here](https://github.com/regularfry/carton), but then 1.8.7 became 1.9, and I haven't had time to get it working again since. It's probably worth redoing rather than fixing up. (You may notice that this would benefit from my pluggable load api suggestion. This is not an accident.)
A [nodatime](http://nodatime.org/) port, to replace the flawed DateTime in stdlib. EDIT: less pejorative.
Just use Sequel with sequel-pg , and you'll be as fast as cheetach.
ew, horizontal split.
The `||` moves on if the expression evaluates to `false`. As `nil` evaluates to `false`, we get the result we see.
I tease a friend of mine about wearing a knit cap and being a stereotype. 
Also instead of installing XCode you can install the Command Line Tools for Xcode https://developer.apple.com/downloads which is a significantly smaller install.
This worked really well. I knew it could be possible but was too lazy to do it.
Fucking semantic versioning of the language. God. 
Worked for me as well. Thanks!
Don't forget to bump the major version if you switch a library. You just broken backward compatibility.
Your probably better pinging @peterc about this on twitter, not sure how often he checks this subreddit
Fill it out anyway, the form actually DOES work, I just forgot to take down the notice after it was fixed. I'll do that now ;-)
Thanks! :)
There are three kinds of (male-identified) ruby developer. The Hipster, who sports a vneck and a scarf, some sort of thick rimmed plastic glasses, and a smug sense of superiority, an some obscure, gross tasting IPA. The Brogrammer, popped polo collar and shorts with flipflops, some sort of bracelet or shiny watch, sunglasses of the douchiest variety. A smug sense of chauvinism. Bud Light. The other guys, who probably wouldn't show up to the halloween party because they're cleaning up the mess the brogrammer left the day before which the hipster didn't fix because that'd be 'too mainstream'.
Funny it's not a ruby oneliner, those work pretty much the same way as perl ones do. 
Highly opinionated is sometimes a great thing. If you don't have opinions about how something should work for you, it makes sense to punt those decisions to someone else (or a group) that has thought about it. I use Devise in a few side projects and replaced a custom login solution because the logic I have for the application has little to do with logging in and out. Because that came for "free" (with consequences, of course if you want to customize), the majority of my time can be spent on creating business logic.
If you want `.rb` and `.erb` but not `.brb`: find . \( -name \*.rb -or -name \*.erb \) -exec ...
 % echo "{ Module::Class =&gt; 'val', :foo =&gt; 'bar' }" | ruby -p -e 'gsub(/(?&lt;!:):(\w+)\s*=&gt;/, "\\1:")' { Module::Class =&gt; 'val', foo: 'bar' } 
I must be the only one who dislikes this new format. Old format is just way more flexible. `{ 'sure-why-not' =&gt; 'value' }` `{ what.are =&gt; 'you doing' }` `{ 1234 =&gt; 'a number' }` `{ WTF =&gt; 'no' }` ^ those cannot be represented in the new format.
agreed. i think there's only two of us.
Agreed. I mostly use the colones by default now, and then I lose productivity when I have to use a string as a hash key, forget, and get odd behavior or a syntax error...
A great place to start is http://codetriage.com You can subscribe to github projects of your choice and every so often you get an email to help triage some of the open issues on the project. It's a great way to get a feel for the flow of how pull requests and issues work. 
Agree, but isn't one if the first sentences in the blog pointing out that this new syntax is only available when your keys are symbols (otherwise you have to use the old syntax). Even though in practice most of the time my keys are symbols, that's a different issue.
Three and counting...
make that four. also the new syntax can't handle objects and classes as keys either. :-(
Looks like 22% of the way https://www.bountysource.com/fundraisers/489-rvm-2-0 (as of time of writing)? Is $20k the min to work on it? &gt; Tools like rbenv or chruby can work well in simple scenarios, especially if you’re very skilled with the Unix shell. However, as environments and dependencies grow in complexity, these tools quickly become inadequate. I'm a Windows guy and use an Ubuntu VM, why do you need to be skilled with the shell to use rbenv? I've had far more issues figuring out special libraries to install so that a gem would work on the system than I had trouble following the installation instructions Also with bundler, how exactly does rbenv become inadequate? I have been following this philosophy: http://ryan.mcgeary.org/2011/02/09/vendor-everything-still-applies/ I hardly ever touch rbenv commands and never have to worry about switching gemsets between projects. 
* optional typing. * better memory utilisation * tail call optimization * Speed (read Charles Nutters posts http://www.javaworld.com/community/node/13329 http://headius.blogspot.com/2007/04/what-would-i-will-i-change-about-ruby.html See if this thing can be resurrected https://github.com/copiousfreetime/crate Better yet maybe work on Mirah http://www.mirah.org/ Mirah has the potential to be the next ruby which is as fast as java but the friendly syntax of ruby. 
Additional complexity to solve something that isn't actually a problem.
And pray that bumping a major version doesn't cause new and amusing issues.
He means half-way in terms of time. That confused me, too.
Or use the ternary operator. value ||= condition ? 'enabled' : 'disabled'
It's very clear. I'm sure no one has trouble understanding it on their first encounter, and it's easy to verify that it's a symbol by whipping out `irb` and entering `{ foo: 'bar' }.keys`
I don't know how you develop *your* libraries, but I've never written mine to behave differently based on the value of VERSION.
yeah `{ symbol: :symbol }` makes my eyes go crazy
You don't have to be. All you really need to do is install rbenv and ruby-build and you're set for the most part. If you don't want to do `rbenv rehash` every once in a while you can just install rbenv-gem-rehash too.
I see. makes sense. I didn't realize that !method checked for nil as well as false. [Thanks](http://imgur.com/5AlhVg0). :)
Rails is a very opinionated framework with a lot of automagical things. It might be too much for the beginner, but then again it's pretty easy to get results with. Sinatra is a barebones framework especially compared to Rails. It makes use of a DSL which may seem a bit like magic for the Ruby newbie, but it's much simpler than Rails and requires you to roll your own solution for many things. Either framework could be a good choice to wet your feet. It probably depends on your knowledge of Ruby and/or web technologies.
You're thinking too hard about it, just make something! :) Surely there is an idea or interest you have that would be fun to hack on. Don't worry about it being done the "right" way. You have more than enough time to go down the rabbit hole. The first thing you build will suck, and the next thing will suck a little less. It takes years of practice to feel confident about your code, and even then there will be room for improvement. That's the fun thing about doing this - you never stop learning. I realize I didn't exactly answer any questions here, but I hope I provided some encouragement. Don't worry about following the rules... just get out there and have some fun. If you're passionate and have some talent, it will pay off. 
Sinatra is awesome. If you like mvc but want to keep your code base under a gazillion files, check out padrino
Pick a basic tutorial (blog, todo-app, twitter-clone), complete it, then tweak what it does. Play around, break stuff, see what happens. Take a command line program and try to implement it into the tutorial app. http://www.danneu.com/posts/15-a-simple-blog-with-sinatra-and-active-record-some-useful-tools/ This is a nice short Sinatra tutorial, I found that doing some Sinatra stuff helped me get a better handle on MVC, plus it helps you realize what exactly Rails "gives you for free". http://ruby.railstutorial.org/ruby-on-rails-tutorial-book This is a super long Rails tutorial but it covers a whole lot of stuff. It can get a bit overwhelming in the later chapters so take it slow. Also, sticking in Ruby-land, I'd recommend trying to make a command line app that interfaces with an API (twitter or google are pretty simple to mess with), or a webscraper. 
try some rubeque problems or move on to rails and build your app
The hardest thing to understand as a beginner is what is connected behind the scenes. Justs something like realizing that naming of your models views and controllers can intrinsically connect them is non obvious to a beginner. In truth , it seems like the best and worst thing about rails is that it does so much for you behind the scenes. It can make it frustrating to learn but can also be exciting when you start to connect the dots. I learn more and more every day that documentation is my friend.
Wow! I'd never thought of it that way but its awesome to hear!
While I highly encourage you to patronize Michael and buy the extras, I think you should do it once just with the book. I think if you're a true beginner, the first time is just about understanding what a rails app is. It's not going to turn you into an instant pro but it is going to connect a lot of dots about what a rails app consists of. It's almost a muscle memory kind of thing. Don't feel bad about copying the app line by line. I think it's an amazing excercise even if you're not really doing any critical thinking. Then when you go to make your second app or do the tutorial again you can challenge yourself to take more of a problem solving / research approach. I plan on building the sample app from the tutorial at least three times and I can't shut up about how awesome of a resource it is. 
Well we use postgresql so I don't need to know a thing about mongo. I would like to learn about non relational databases though. I'm planning onl taking a databases course at a community college around me. Honestly, rails does all the sql for you so to get started it's really not required. I could write basic sql queries just from seeing them so many times in my rails server logs but the truth is, ive never had to write queries by hand.
"White box" versus "black box" does not sound like a useful distinction. When I develop a model, I generally have one big test that covers an end to end happy path, and a whole lot of little guys that test boundary cases. That sounds like what you're describing. My unit tests hit the database, though. I use fixtures. They're still really fast. It's awesome for me, because I can test queries, controllers/views, etc., all without having to build out complex scenarios for each test.
AKA, 'composition over inheritance'. Contrary to some belief, module include (mix-in) _is_ a form of inheritance (and the denigrated 'multiple inheritance' at that!). Like all inheritance, it's still useful sometimes, but every time you start to reach for inheritance, it's worth trying to figure out if you can do it with composition instead; in the long run, you'll be happier. 
The idea for hiring junior devs by most companies is to find the individuals that have the capability of being senior devs. They understand in advance that these employees will need training, guidance, and more experience.
At a small ticketing app I built for my school, I used Rails 4's live streaming to notify people of tickets. I wish I'd had this blog post to help out, there's a lot of rough code I'm going to have to demolish and clean up
Works fine for me: https://gist.github.com/schneems/7271701 
The line variable you are using is string and the regex is checking for a number. So the match would be false in your test 
Who thought fading out the entire sidebar on mouseout was a good idea?
Here is a gist to the full code. https://gist.github.com/karrde00/61f349f5869e90ee3182 and here are two example lines that I would be parsing. ATOM 303 N LEU B 100 -7.575 -5.845 -8.399 1.00 0.00 N ATOM 302 HB3 ALA B 89 -9.720 -2.261 -7.983 1.00 0.00 H I need the max length in this example to be 100. My program will not even get through the interpreter as it provides errors on line 17/18 
Why?
Because any field benefits from diverse ideas and diverse points of view. If you are always solving problems from only one perspective, you are limiting the creativity and approaches available to solve those problems. The talent pool in technology does not need to stagnate. We have too much to accomplish.
Why isn't it noted that you have to install the pre-release?
I'm assuming you're on a computer with more than one core, but the official announcement recommends that you pass in a number that is one less than the number of cores you have. 
We programmers/engineers (you included) know the truth: programmers are well on their way to ruling the world-software already controls cars, computers, coffeemakers, your money, and is on its way to being in your glasses and probably your socks any minute now. It's important to have minorities be a part of that so they're taken into consideration when we make decisions about how the world will work. We have POWER-and that makes the imbalances more important than in many other fields of study. Think about the fact that for many, many years, crash test dummies were all modeled on large males. Was that even close to the reality of who really drove cars and what would be safer for those people? Not really-but it reflected the automobile designers. Would that mistake have happened if automobile teams had good representation of women? It's possible-but probably not. People who make things tend to think of themselves when they make them. Great for niche products, but not so great for things that will see wider use. Another case I can think of - the DC Metro trains was well known by locals as not having good handholds if you were shorter-(the few within reach for a shorter person that were there required reaching right behind a stranger's head-awkward.) The original designer of the cars was over 6ft tall. On the other hand, there's very good headroom for tall people. TLDR; it's not that women/minorities should be programmers for heck of it, it's that having women programmers be a part of the creation process helps keep the new tech appropriate and friendly for women/minorities too.
Sorry, I simply assumed it was closing after hitting the end of the program. You need to convert the variables `a`, `b` and `c` to compute, or concatenate them to a string. (see the `to_i` or `to_s`) http://pastebin.com/RQGnsQXv
because I didn't realize that, it's noted now. Thanks for the input!
noted!
wow nice one!
Matt Aimonetti is not the author of MacRuby, but was an early contributor. The book is very light weight, but if you have no Mac OSX dev experience it might be useful. You don't need any experience to begin _learning_ MacRuby. If you know Ruby MacRuby is good way to learn about Mac OSX development. Programming Mac OSX is mostly about the Cocoa framework and less about the language. The only issue is development on MacRuby itself has mostly stopped so it has a limited life.
Strong assertion? Readily observable, and measurable (if IQ is your flavor, look up the substantial variation in male IQ - we make more geniuses and retards, but women strongly cluster about the mean). Doesn't mean women can't succeed in these fields, but they're always going to be outnumbered by their male counterparts, especially by white men and asian men. 
Though the license cost is only 3-times that of Sublime Text. And RubyMotion is pretty nice, IMO.
Readily observable? You mean like this? http://xkcd.com/385/ You apparently didn't actually bother to read my links at all. But, here's another one for you, from the American Psychological Association: http://www.apa.org/research/action/share.aspx TL;DR - "Spelke believes that later-developing differences in career choices are due not to differing abilities but rather cultural factors, such as subtle but pervasive gender expectations that really kick in during high school and college." Also, "they're always going to be outnumbered by their male counterparts" is an odd statement to make when there was already a time in history when female programmers outnumbered male programmers. Back in the beginning, when programming was considered to be a low-paying clerical job, most programmers were women. The original six ENIAC programmers were all women (http://en.wikipedia.org/wiki/Eniac#Programming). Men didn't become interested in programming until it became a higher paying job.
[Image](http://imgs.xkcd.com/comics/how_it_works.png) **Title:** How it Works **Alt-text:** It's pi plus C, of course. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=385#Explanation)
I don't mean to threadjack you on this, but could you please explain why you are doing this? Serialization is something I've never fully understood and I'd like to understand what your usecase is/when to implement it. I could be wrong but couldn't you just use an association to ensure you always get inflated objects back? 
uh, so part of it is that I'm pretty new to Ruby (I'm from a PHP background). I'm building a project from scratch, just trying to figure everything out, so maybe there's a better way to handle it. I hadn't realized the association thing. That might make more sense. The other part is that serializing it just seems simpler to me, as someone new to activerecord and not familiar with associations. I'll look into the association thing and see if that works better. Thanks for the tip. Edit: OK, so another reason is that each of the Stats are mutable. They're based on a row on a table, but this particular user's stat could be modified. It's effectively a copy of the stat. stat = Stat.find(1) # some_attribute = "bar" stat.some_attribute = "foo" user.stat.set(stat) user.save Or something like that. So I'm thinking if I serialize it, then that user can have their own unique version of that stat. That make sense?
http://news.bbc.co.uk/2/hi/uk_news/education/4183166.stm
Use this: https://github.com/apotonick/representable/ This way it will be easy to load and save your stats object as serialized JSON.
Neat. Thanks!
Dress up like DHH
Sure, they should be encouraged, but if they need to artificially be propped up, especially if a more capable person must be displaced, that's not okay. 
http://chartsbin.com/view/3069
https://en.wikipedia.org/wiki/Turing_Award
I think that part of the movement is to encourage computational thinking in the general public, because a lot of people are bad at it, and it is needed for solving a lot of our "first world problems." I have stood at a whiteboard for half an hour before, trying to explain a dangerous edge condition in some business logic, and it was incredibly frustrating trying to get the business guys to see what I could see. These weren't stupid guys -- they just weren't used to thinking that way. So, that's one situation we can improve. Another issue, from a long-term hiring perspective is: We are not getting our best possible pool of programmers, if more than half of our population never even tries it out. We may have a lot of missed potential, there.
If you're going to dive into Mac development I don't think the language should really matter. Sure it'll be a day of syntax oddities but the hard part will be getting the frameworks into your head. Which you would access the same way (for much of what you'd do) regardless of language.
Why do you think I'm talking about displacing a more capable person? Ultimately, I'm talking about the exact opposite of that. When only women are teachers, you don't have the best possible pool of teachers, because you are missing out on a lot of men who could have been good teachers. When only men are programmers, you don't have the best possible pool of programmers, because you are missing out on a lot of women who could have been good programmers. To get the best long-term candidate pools, you must have diversity.
If there are more men in the field, I would expect them to win more awards. If girls start experiencing bias in STEM topics all the way back in elementary school, I would also expect men to win more awards, in the long run. If many female programmers have crippling imposter syndrome, because they have been told their entire lives that they aren't good enough, they aren't going to be confident enough to seek the kind of positions you need to be in to get these awards -- and I would once again expect men to win more awards. By the time people are winning international awards, the damage is already done. It's way too late. The gender gap in awards has absolutely nothing to do with relative ability between men and women.
Most of education is geared toward girls (I'd say education is essentially feminized at this point), girls outnumber men at university, and young, single adult women outearn their male counterparts. 
What does that have to do with programming or computer science?
It applies to education in general. In the case of programming and computer science, both are absent in elementary school, and rarely present in a suitable fashion in high school. Boys usually end up discovering it out of their own intrigue. It requires a lot of solitary time staring at a computer with very little social interaction. Girls are attracted to social endeavors. You're trying to paint a picture of discouragement that doesn't really exist. 
Edit: bad numbering (probably some programming joke in there somewhere) 1) Of course, people in a certain job have to be able to perform that job, and do so well. Diversity isn't more important that actually being able to do the job- that's a straw man argument. Nobody is saying "you should hire this incompetent person because they're a girl!" But: 2) Surely, diversity has at least a little value. If you have a team of 8 white guys in their 20's with similar education, looking to hire a ninth and then you're faced with two candidates *that can do the job well*, one another white guy in his 20's and the other a girl/latino/guy in his 50's/etc there is at least some value to someone who can bring something new to the team. How much? Hey, it's at least a tiebreaker, right? 3) Do you know what the "natural" percentage of women in programming should be (those who truly enjoy it and do it well)? At this point, it's a pretty open question-there are enough other factors affecting actual percentages in the field that we don't know. It's very possible quite a few women who would make excellent programmers are becoming lawyers or accountants or something else instead because of those other factors. For instance, look at what happened with girls in sports with Title IX. Before Title IX, people thought girls just liked sports a whole lot less than boys. I remember growing up and hearing that girls didn't like sports as much as boys! Turns out, after many years of Title IX, that girls are participating in sports at similar rates to boys. (and nobody's forcing them to play on those high school soccer teams, they LIKE it) That would have been one hell of a surprise to everyone 50 years ago. 4) Minorities are like your standard white male programmers in one way - a lot of them aren't going to be good. If you've been involved in hiring, you'll have seen that the real problem is that 70% of the people out there aren't any good. True of minorities too-artificially hiring into that 70% of not-up-to-the-job people, even if they're minorities, does nobody any good. The real goal is to increase the whole pool, so you can make the pie of people you're hiring from bigger. (see point 3) Honestly, it's not we are faced with too many awesome candidates to hire and have to turn down excellent people. There is no displacing a capable person if they were both up to the task- it's so hard to find capable people at all, we'd hire them both!
The decision should be blind to gender and race. The merits of the applicant should be evaluated, of which neither of those are relevant. An obscure appeal to diversity's dubious merits is unwarranted. 
Let's throw out the idea of diversity's merits then (though there's easily argued merits for it, especially in the product development realm). If we had more women and minorities in the field, you'd get more qualified candidates in total-because some of those additional women and minorities would be qualified and would make it through the blind process. Since there's a long-term shortage of qualified programmers, nobody's losing their job-we all just get to grow our companies more quickly. Win! 
Doesn't really exist? Gaslighting much? I'm not painting a picture of discouragement that doesn't really exist. I'm painting a picture of discouragement that is backed up by research (like the utexas study that I linked earlier). I'm painting a picture of discouragement that I experienced, for a substantial portion of my life. It must be delightful not having to deal with that in YOUR life, but you don't get to pretend that it doesn't exist, just because it's inconvenient to your argument. On your other point, according to "MBTI Manual: A guide to the development and use of the Myers-Briggs Type Indicator (3rd ed.)," 47.5% of US women are introverts. That's a whole heck of a lot of women who are perfectly happy to engage in solitary activity for long periods of time. But aside from that, the world desperately needs more socially-capable programmers. There are modern software teams (such as those working on MMOs) that run upwards of 200 people. You don't get to be a cave troll, on those projects. You have to communicate with your team.
I've used macruby to develop a couple of little GUI utilities and found the experience to be reasonable, but not without caveats. If you're writing using Apple's frameworks for things like UI, you'll need at least a working knowledge of objective c and its syntax. You'll spend a lot of time with the cocoa API docs, translating their obj-c examples and call syntax to ruby. At some point in this process, you may find yourself wanting to just write the objective-c directly. I've also run into issues with binary distribution, as the apps needed to embed the full macruby runtime, inflating their size considerably. 
Ok. I'm glad you're successful despite whatever obstacles were thrown your way. I don't think anyone should be discouraging women from trying. But nonetheless, there's no way in hell that I'd support affirmative action. It's not right. Either you can hack it or you can't, and if you're too sensitive in the face of adversity, you probably don't deserve it either. With all that said, men are still going to outnumber women as you get closer to the top. It ain't gonna change just because your panties get twisted at the thought. 
Right, but if you can make it through the blind process, then everything else is irrelevant. 
RubyMotion is fantastic, it's well worth the money.
Luckily, the most effective programs I've seen in bringing more women into Computer Science haven't really required any affirmative action at all. Harvey Mudd and CMU have begun to provide CS tracks for people with potential who are coming in without programming experience. It has boosted enrollment for both genders, and has vastly improved the percentage of women in the major. Make no mistake: This is not a dumbing-down of the curriculum. They are still held to the same standards for graduation. They just get to start out learning in classes without the fierce competition with the students who have been programming since they were 9. It wouldn't have helped me, personally, because I had been programming for years, by the time I went to college, but, there are a lot of people out there of both genders who -- for complicated reasons -- only discover that they really like programming and computer science as adults. So, maybe there's a win condition for everyone. I'm curious to see how these programs work out, in the long-term.
That's excellent. I think it's great to have that offered. Personally, I came to computer science and programming late. I think there's also a strange cultural issue where people assume that if you weren't programming since you were younger, you can't learn it. That deters adults who might otherwise be capable software developers from trying. This is especially bad because those coming from other disciplines can make great use of computer science and programming in their fields, whereas someone only training in computer science is unlikely to have the foundation to advance the given field. The only time it's too late to learn something is when you've got a foot planted in the grave.
I Perl'd almost exclusively for like 12 years. Over the last 5 years, been learning ruby, and don't really like coding in Perl any more. There were a bunch of starts and fits. So keep pushing through. Read, "well grounded rubyist". Also, these: http://rubykoans.com/ Specifically, some things that helped... **default object** All functions in ruby are acting on an object. If you don't see the object, it's acting on the default object. Kind of like $_ in perl. This helped me a lot. thing = "cheese" is really self.thing=( "cheese" ) **symbols** A symbol is not a string, but they get used interchangeably, which is confusing. Because you can do :one.to_s and you get "one". But a symbol is not a string. It's nothing like a string, except that you can convert it to a string easily. All symbols with the same name are the sam object, and they're immutable. They don't do much but exist, and you can create them easily with ":". Strings have a bunch of string functions on them, and they can be changed. 2.0.0p247 :005 &gt; "one".__id__ =&gt; 70129376918360 2.0.0p247 :006 &gt; "one".__id__ =&gt; 70129376912840 2.0.0p247 :007 &gt; :one.__id__ =&gt; 4891368 2.0.0p247 :008 &gt; :one.__id__ =&gt; 4891368 Symbols get used in hashes a lot because it takes up less memory and is faster than using strings. (because all symbols with the same name are the same object.) This is annoying when dealing with a lot of data structures that has strings and symbols intermixed. There's a class in ActiveSupport that changes hash to deal with this in a more sane way. **binding.pry** Use binding.pry to figure out what's going on. It's probably the single one thing that makes it intolerable to code in perl. No pry sucks. require 'pry' binding.pry
This. The Cocoa framework is huge. Getting used to Objective-C is trivial in comparison. 
Not everything is irrelevant-it's still of value to encourage those minorities that are good fits to become programmers so they're there to hire later on (like I said, I don't know how many that is, but we certainly haven't maxed out yet). Best place to start is probably at the elementary through high school school level so you get more people who come through who have the right education and experience. This is the long game, not the short game. The goal in encouraging women isn't poor hiring practices, after all. 
Python has a much more diverse ecosystem overall and especially with regard to scientific libraries/data analysis.
`when` clauses attempt to match using the `case` target's `#===` method. For ranges, this happens to be an inclusion check, and `(1..2)` certainly doesn't contain itself.
GOT IT.... thanks, you are my hero today. 
I wonder what the logic behind that is? irb(main):002:0&gt; (1..2) === 1 =&gt; true irb(main):003:0&gt; (1..2) === 2 =&gt; true irb(main):004:0&gt; (1..2) === (1..2) =&gt; false It includes both its endpoints, but not itself? Oddness. 
The reality is that minority groups are at an artificial disadvantage when entering programming. Giving them an artificial advantage offsets that. For example, women face serious harassment issues all the time. It seems like hardly a month goes by without a big snafu on twitter about one event or another, and that's only the harassment that gets reported, the real issue is much much larger. Having programs that gives an "artificial advantage" to women (or some other minority) is more like a band aid than a solution, but ideal solutions are hard to come by; and people are slow to change. The groups fighting for equality are also doing their best to fight for tolerance, awareness and kindness in order to bring down the real root causes of discrimination as well, but that's going to be a very long fight.
I will actively fight against unfair advantages that discrimate based on race or sex. If you want to improve educational opportunities for everyone, I'm all aboard. None of this race/gender nonsense, which flies in the face of any notion of equal opportunity. 
To answer your second question, much of it comes down to having things to build off of - where you can see python is clearly winning. Python has also been historically faster, which starts to become important when doing number crunching over large sets. I believe it's had good support for large numbers for a while, as well. 
Thanks a lot, that's a lot of useful info. 
That's the thing. Fighting equally for everyone just maintains the status quo. Specialized programs are necessary in order to disrupt things. Right now young white males have a distinct advantage over everyone else entering into the programming industry. Everyone else deserves to have the same opportunities that they have.
What does that even mean? What's conferring an unfair advantage to young whites? Or young asians. I must have missed the memo and the meeting where my skin color gives me access to super-secret resources. Telling people that they have unfair advantages when they don't, is only bound to irritate them. 
`===` is one of those scenarios where principle of least surprise is thrown out the window.
See my earlier points about harassment as one example. There are others.
If fighting equally for everyone maintains the status quo, then I'm all for it, because I believe in true equality; that is, equal opportunity for all. It seems like bigotry to me to do otherwise. No thanks
If you think that the current status quo presents everyone with an equal opportunity, then I'd ask that you look a little closer.
No, you said giving people equal opportunity will result in the maintenance of the status quo. So which is it?
For example, [Citikat](https://pay.reddit.com/r/ruby/comments/1ppt5r/call_for_funding_more_women_needed_in_open_source/cd5myop) showed something I could get behind: &gt;Luckily, the most effective programs I've seen in bringing more women into Computer Science haven't really required any affirmative action at all. Harvey Mudd and CMU have begun to provide CS tracks for people with potential who are coming in without programming experience. It has boosted enrollment for both genders, and has vastly improved the percentage of women in the major. Make no mistake: This is not a dumbing-down of the curriculum. They are still held to the same standards for graduation. They just get to start out learning in classes without the fierce competition with the students who have been programming since they were 9.
Well, if I can generalize a bit, that's a program that singles out students who would not be as likely to succeed in a traditional program. I think our difference is that I see women and other minorities as such a group, and I don't see a problem giving them preferential treatment until they day that they are not. That program is a great thing, and I think anyone arguing against it is making a mistake. I feel similarly about programs targeted at other groups.
For everyone who is really new to ruby like me, and gets the "/usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require': cannot load such file -- mkmf (LoadError)" error, i can save you some googleing, you have to install "ruby&lt;version&gt;-dev" package
What makes women a minority when they attend universities in greater numbers than men do? 
Not in software development.
I know - so what is the issue, if women are not as represented in engineering, but overall have greater access to education? 
Because of issues like harassment and discrimination, women who would be great for the industry are discouraged from continuing. We drive them out. Even if they had equal/better opportunities in other fields this would not be ok. 
Is there tangible evidence that this is so endemic? In my science and engineering studies, most of the women didn't receive harassment from men, they received a ton of support because they enjoy helping women. I'm not trying to say that because of my experience, this is universal, simply that I often find the reverse more than what's proposed; i.e. "benevolent sexism" over harassment and negative discrimination. So, with men being minorities, why aren't their recruitment programs that target men? Why aren't there scholarships recruiting men to occupational therapy? Nursing? 
I don't know why you're hung up on labelling men as a minority. Within engineering, this is clearly not the case. [Here's a long list of incidents that single out women in tech](http://geekfeminism.wikia.com/wiki/Timeline_of_incidents)
They are a minority in those situations I presented, but a majority in engineering. Women are a minority in engineering, but a majority elsewhere. My point is, why pick and choose? By the way, I fully appreciate the discussion with you. Thanks for everything so far
I love Ruby, I'm warm to Python, and my advice in this case is to use the right tool for the job. Personal preference is important, but G.S.D. (getting shit done) is actually pretty important too. If Python has the tools you want, I'd suggest using that.
Nothing here is incorrect, but you're slightly conflating ranges and sets (or perhaps arrays). Given the context of the question, it seems worth mentioning that `Range#===` is an alias for `Range#include?`, which simply returns whether or not its argument is between the receiver's `#begin` and `#end`: `(1..2) === 1.5` is `true`.
Might find this one interesting: http://www.sciencedaily.com/releases/2013/11/131101112416.htm
Just came across this one, you'll probably find it interesting: http://www.sciencedaily.com/releases/2013/11/131101112416.htm
If you are playing computer games too much i would recommend Jonthan Blow's talk about video games and the human condition. He does an amazing job explaining why games and so addictive and how the games developers are manipulating you. Link http://youtu.be/SqFu5O-oPmU
Well, it's been three months; I'm really curious to see how it's been going since. Is everything well?
So basically the point of this article is that the author was able to move a conditional out of his own method by leveraging `max`, which is itself conditional. Are there any advantages to this approach?
He's arguing that it's more readable. To each their own I guess. Also, why didn't he use the take_while method from the Enumerable module that can take a block?