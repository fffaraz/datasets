WTF is a list comprehension?
http://en.wikipedia.org/wiki/List_comprehension FTFM
I recommend [e](http://www.e-texteditor.com/). It's the closest you'll get to TextMate on Windows, and lots of Rubyists (myself included) like TextMate.
I don't use Windows, but I develop Rails on Netbeans in Linux, which is also available for Windows.
Were I on Windows, I'd probably go for [SublimeText](http://www.sublimetext.com/)
I've been using RubyMine more and more. It's getting quite nice and convenient for me.
I recommend Vim - it works everywhere and it's not as scary [as you think](http://akitaonrails.com/2010/04/25/updated-vimfiles). edit: formatting
I so completely agree. List comprehensions are the worst thing in python. Python does lots of stuff that I would consider "backwards" (right to left in a left to right society), and list comprehensions are the worst of it. For truly heinous examples, read pretty much anything in twisted python. Worst. Code. Ever.
Best open source enterprise search engine.
What's the situation with the new iPhone dev license and rhodes?
I think duby will be a better bet myself. duby promises to be almost as fast as java and almost ruby. 
I'm not positive, but I don't _think_ it's allowed under 3.3.1.
The article says "we believe we are allowed" but that seems like bullshit to me.
Benchmarks coming **very soon**.
Isn't this what scaffolds are for? Those are also some pretty wonky-looking routes.
I have mixed feelings about this. It's a cool project and I'm glad to see them having success, but having MacRuby-specific features is kind of lame. Being locked out of using some new killer-app library unless you use OS X would lead to fragmentation of ruby.
This saves the simple step of writing each attribute and data type for each model. The routes are specific to my app and can easily be modified.
Dave Thomas of the Pragmatic Programmers explains the genesis of the publishing company, Agile software, learning new programming languages, and building your own business.
What features are specific to MacRuby (aside from the bridge to Cocoa and related Mac frameworks)? I was under the impression that it's a compatible implementation of Ruby 1.9.
Mostly the [dispatch library](http://github.com/masterkain/macruby/tree/0bc12181a7a2fab11e54a41e4691f71334bf6c9c/lib/dispatch).
That's an additional module that implements a bridge to an OS library, much like the Cocoa bridge implemented by MacRuby (meaning, it's not an addition to the core language that would make it incompatible with other Ruby 1.9 implementations).
I just use activescaffold. 
Call me when MacRuby is cross-platform. 
This is what Apple's developer license says (emphasis mine): &gt; 3.3.1 Applications may only use Documented APIs in the manner prescribed by Apple and must not use or call any private APIs. Applications **must be originally written** in **Objective-C, C, C++, or JavaScript** as executed by the iPhone OS WebKit engine, and only code written in C, C++, and Objective-C may compile and directly link against the Documented APIs (e.g., Applications that link to Documented APIs through an intermediary translation or compatibility layer or tool are prohibited). &gt; 3.3.2 An Application may not itself install or launch other executable code by any means, including without limitation through the use of a plug-in architecture, calling other frameworks, other APIs or otherwise. **No interpreted code may be downloaded or used** in an Application except for code that is interpreted and run by Apple's Documented APIs and built-in interpreter(s). So whatever the Rhodes developers may be saying, no matter how they spin it, writing applications in Ruby is explicitly forbidden by the license.
LLVM, bitches!
Nice attempt, but it doesn't seem like a the rails way. Here's some points to consider: * Writing a generator would be a better fit. Write to the filesystem and skip all this intermediate stuff. Also, you then plug in to the Rails environment, which avoids duplication or disconnects to how your app actually is setup. * There's a comment in the code for "add models here". Having to change the code, even if it's just two lines, to support generation requires unnecessary changes. * As malcontent said, something like activescaffold (or nifty generators) would probably be a better fit. Nifty generators will give you forms like this with very low overhead on your part. * If you find forms tedious but need to build them yourself, maybe [formtastic](http://github.com/justinfrench/formtastic) would be useful. * Because you are outside your rails environment and not pulling in the environment, you end up losing helpers and route information so there's hardcoded info, custom inflectors, etc. Anyway, good on you still for contributing ideas. I'd suggest you look at [nifty-generators](http://github.com/ryanb/nifty-generators) if you haven't already. EDIT: BTW, if you are unfamiliar with ActiveScaffold or nifty-generators, keep in mind they are two varying approaches to the problem. ActiveScaffold give you configurable runtime generation of your forms, while nifty-generators still builds the views up front, acting as a drop-in substitute for the stock script/generate usage.
Blub 2.0.
Formtastic looks amazing and I'll experiment with using it in my project. Instead of shooting me down, you gave me constructive criticism, and I really appreciate it. 
...he said one day ago... ;)
perhaps, more info would help
Started reading this last night. It's brilliant. Unlike any other computer book I've ever read.
Is this a poll?
haha no, actually looking for someone. you could even call this a shameless job ad but good rails devs are hard to find so I thought I'd try you ruby peeps on reddit
It lives on! I hadn't even thought to look for a mirror...
To elaborate: Looking for: &gt; **Junior Ruby on Rails Developer *OR* Senior Ruby on Rails Developer** With experience in: &gt; * Ruby on Rails &gt; * MySQL &gt; * Familiarity with Git, Haml, Agile methodologies, PHP is a plus &gt; * Familiarity with web technologies such as HTML, CSS, Javascript (Jquery) is also a plus &gt; * Databases, gems, partials, databases blablablabla. You know, the usual stuff Let me know
That's exactly what I thought when I first read it right in the middle of my undergrad. Then I learned later that ruby was not really standardized on anything but what the interpreter spits out. Things have gotten much better for ruby since then.
nice try Why...
This stuff works for some, and it doesn't for others. Sadly, I'm of the latter. I just can't read through a technical subject such as ruby in comic book format. I lose patience.
I've read through this twice. Its brilliant!
Poignant since _Why has gone to a farm.
Didn't this guy delete everything he had online? Is he back or did somebody mirror this?
It's a mirror
I've been trying to learn a programming language (*any* programming language) for some time now. I generally can't get interested enough to actually follow though. Then I found this book. 
no. downvotes because you just criticized without giving a reason why.
very nice! thanks a lot :) Maybe you could also extend the Vector class with a few basic functions too such as normalization for example! :)
... and if you try to refuse to learn, we will possess you with demons who *will*. --Why?
You're being downvoted for spergraging over something so trivial.
Everything _why ever did has been mirrored: http://viewsourcecode.org/why/
Whatever you do, don't try to read that when you're drunk, high or sleepy. It's, like, woow...
+1, why's stuff irritates the crap out of me. Just give me a technical manual.
I don't want to write, use such a package, or maintain software that depends upon it. Ruby 1.9 allows me to do more with less typing but having to bend over backward to work on both Ruby 1.8 and Ruby 1.9 is too difficult. While most features can be backported using plain ruby, the Encoding related features cannot. Since RubyGems and RDoc both ship with Ruby they can't use any compatibility gems.
Give me a reference and will be implemented ASAP
&gt; Pickaxe, on the other hand... I didn't get into the Pickaxe book. It shows a tiny bit up front, then dives into weird advanced topics, and then attempts to fill in the blanks. It didn't click with me. The updated Programming Ruby book seems alright. 
Personally I didn't find it very useful for me. I like more practical approach although not completely in to the "computer manual" variety. However, that said, I did find the Why's Poignant Guide to Ruby very amusing, sometimes quite funny - and it definitely is a helpful for those people who are just unable to read technical manuals without falling asleep on page five. Just because they find dry academic writing boring doesn't make those people stupid or "retarded kids". Anyway, as for downvotes, I think it's mostly because you come across as a raging prick - not because you're giving legitimate criticism with well established dialog about your reasons. The lack of punctuation is not helping your first impression, either.
Whats the pay like out there for RoR people? 
Why do you think I'm why? Why is off living on a farm. ;-)
Fool of me :( #normalize gives you the normalized vector. I added #magnitude to retrieve the geometric length of vector
So just like Lisp, then. 
LaTex?
I was a bit worried that the project was stagnating after they switched to JRuby. I'm glad too see that things are going well. 
Shhht... no swearing, please! ;-) Glyph does *not* aim to be a LaTeX replacement, as I guess it will never offer advanced typographic features and it relies on CSS3 for pagination etc. Glyph's aim is to be easily extensible, and improve text reuse. To be quite blunt, Glyph gives you a small and simple macro language that can be *fully* customized, basically by executing Ruby Procs over captured text. In the future, it may even _produce_ LaTeX code, but in a less verbose and more productive way. This feature: http://github.com/h3rald/glyph/issues#issue/74 ...awaits for a brave soul to help me implement it! :-D
Does it have Perl personalities? I have some Perl code that I need to work on but I hate firing up Eclipse to do it. :(
&gt; Cross-platform. Works on Linux, OSX and Windows, with native gui controls. I hate to say it, but there's nothing native about Java GUI's, specially on my Mac. Nice editor anyway :-) But I'll stick with TextMate.
Firing up redcar took its time too: loading plugins took 6.242 EditViewSWT.start took 3.624s initializing gui took 0.953s project start took 0.097s 10 seconds to start an editor is not really what I was expecting, considering it's a small one. 
It uses Cocoa, except for the text editing widget.
Believe me I know. JVM startup plus JRuby is quite slow to load Ruby code from .rb files. I hope we can figure out how to compile the code to a jar and get fast loading somehow.
thanks Matt!
Is that irony? :-P What I mean is, even close (save, don't save, cancel) the dialogs look foreign to me... The app takes forever to load. But once open, I've been using it for a couple of hours now and I really like it. Text completion, indenting, everything works like I expect it to. I just don't see the "Mac-feel-like" if I may call it that heh.
Still, great work. Second time I open it up, plugins loaded in about 2 secs. The bottleneck seems JVM, but it's open... I'm cloning the source from github to peek around. 
Most interesting. Now I have to figure out if this article is flawed somehow. It seems counter-intuitive to me that curb should be slower than a pure ruby implementation.
Wtf, half year video? Maybe post all other videos from confreaks site?
&gt;I couldn’t get curb to use a persistent connection. There ya go. It's an IO bound op at any rate.
The calls to a c extension are probably expensive... I've done some work with http and ruby over the past few months and I like [typhoeus](http://github.com/pauldix/typhoeus) (curl based) and for asynchronous things [em-http](http://github.com/igrigorik/em-http-request). If one is looking for easy "session persistence", [patron](http://github.com/toland/patron) might also be an interesting choice
I've been using this library lately and I don't perceive slowness but the API is pretty clunky and showing its age, I suppose
For people on macs who haven't setup a ~/.irbrc previously, you should first copy the default one at /etc/irbrc to ~/.irbrc, or at least first put a require 'rubygems' as the first line in your ~/.irbrc. Otherwise the require 'bond' won't work.
It'll be published next Monday. :)
Why not use nailgun? 
I downloaded it and tried it. Putting aside the startup time it does seem to be noticably slower than netbeans (and that's saying a lot!). Also I could not get code completion to work the way I was expecting. 
Netbeans ... been using it since version 6.0 The 6.9 beta is really really good ... it can be really slow sometimes though (freezes for a couple of seconds ever so often)
Congrats. But do we need the braces in scss? I assume it's for css3 compat?
Useless. We need more high quality stuff on this here reddit
Was there something in this post?
SCSS exists specifically to provide a CSS-compatible syntax. The indented syntax is still around if you don't like braces.
This is great, I wanted to use this for a project just days ago to convert Markdown to PDF. The biggest problem is Pandoc is a pretty big requirement to get on a system. Not really an option for Heroku or shared hosts. Not simple to get it installed on OSX either, needs someone to make Homebrew a recipe.
But do we need the braces in scss? &gt; Since there’s been some confusion on this point, I want to emphasize that the indented syntax (or just “Sass”) is still supported and will continue to be supported. It's not needed, as in you do not need to write in braces styles. &gt; I assume it's for css3 compat? Yes. It means you can start migrating to SCSS by simply renaming your existing CSS files to SCSS. Then only start using SCSS feature as needed.
Consider yourself forked. Edit: And pushed: http://kbedell.heroku.com/
Syntax is irrelevant. Seriously, the only difference between the two is curly braces and semicolons. That's pretty much all. Having them there is for tool support and because people freak out with whitespace significance because they're so used to not having it. We use scss on the website to lower the bar of understanding for new users. Both are fully supported, but if you made us pick one it'd be scss so just deal with it ;)
Nice I am still hoping to get PDF support soon. I got it working fine locally, but I can't get PDFs to work on heroku due to some limitation missing software.
might want to change that &lt;title&gt;...
yeah I noticed on his resume, I actually need to change the code to auto generate the title based on the markdown file. Added it to the todo list.
The Sass syntax will always be supported. SCSS adds many features on top of CSS3. It's a way for people to use the power that Sass provides while using a syntax that's familiar and comfortable to them.
Does HAML also support optional braces now?
The title bug is now fixed if you want to pull the latest. It now takes the first line of your markdown and converts it to the title.
the title bug is now fixed thanks for pointing it out.
[Some context.](http://translate.google.com/translate?js=y&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;layout=1&amp;eotf=1&amp;u=http%3A%2F%2Fitpro.nikkeibp.co.jp%2Farticle%2FNEWS%2F20100512%2F347926%2F&amp;sl=ja&amp;tl=en)
This week’s episode is an interview I did a few weeks ago with Kevin Rutherford. Kevin is the author of Refactoring in Ruby. He’s an agile coach, and blogs at http://silkandspinach.net. Finally, he has written the reek tool, which identifies code smells in your code.
No.
Bummer. I guess I'll continue with erector.
variables and mixins is a pretty big enhancement, but check out the cool [colour functions](http://nex-3.com/posts/89-powerful-color-manipulation-with-sass) 
I'm not sure what you're imagining Haml-with-braces looking like. The reason SCSS has braces is that it's an extension of the CSS syntax. The logical parallel for Haml would be to make it an extension of HTML, which would sort of eclipse the point of Haml (besides which, HTML syntax is already valid in Haml documents).
I guess it would kind of look like erector but with terser syntax. Anyway I am not a fan of significant whitespace which is why I program in ruby and not python. I can see the appeal of it when reading but when I am fooling around I tend to refactor, move things around, copy and past etc and all of those are PITA when you have to worry about spaces. With braces or ruby syntax I just press ctl-alt-F in netbeans and the code is formatted beautifully after a copy and paste or a refactoring operation. I like what HAML is trying to do, it's certainly less pain that HTML but still...
tldr: encoding is hard; let's go shopping
This should have a different title: &gt; Look! HTTParty is awesome
&gt; What I know however is that with 1.8 you could mix different encodings in the same string instance and the worst that could happen was some weird looking characters in the resulting web page. But ruby 1.9 makes things different, it throws an exception in your face. In short, I'd rather output garbage than learn to code correctly.
where are these "ruby jobs" you speak of?
impressive work! kudos to the rubinius team
Congratulations! I didn't realize so much progress had been made.
team... *snicker*
ok, props to evan :)
That is something I can get behind.
Duh? Not related, but that is a horrible header....
Published: http://antoniocangiano.com/2010/05/16/benchmarking-macruby-0-6/
already read it using RSS :) good stuff, thanks!
Looks like other Java apps to me. The tabs look all out of place - especially the very Eclipse-ish close "X", and the resize handle in the bottom right corner is screwed up. It should have a transparent background like in Safari (open a new tab and you'll se that the resize handle turns black and blends into the rest of the window). It's worse to try &amp; fit in and fail than to just admit you won't fit in and do your own thing entirely. See Cappuccino and Atlas for an example of this. They don't fit in, but neither do they look half-assed. Not to nitpick on your hard work, that is how it looks to me. Please take it as constructive criticism.
Indeed, I'd prefer native tabs on Windows and Linux. (Cocoa doesn't have a usable notebook widget which is why both SWT and Textmate implement their own.)
It would be neat if an Enumerator could be set to use `n` threads, and methods called on it were automatically parallelized. [:a, :b, :c, :d].each.par(2).with_index.inject(... etc. I guess parallelizing inject is a bit of a tricky beast, but you get the idea.
Parallelizing folds is generally considered to be impossible, because they imply order of operations. I.e. ["foo", "bar", "baz"].inject("") {|sum, obj| sum &lt;&lt; obj } is different inherently from ["foo", "bar", "baz"].reverse.inject("") {|sum, obj| sum &lt;&lt; obj } However, as long as you ensured that the results ended up in the same place, you could parallelize a map or other less-specific operation. Since these are possibly side-effect-ful operations, though, you'd have to be careful with it. 
This wouldn't really work - first inject implies order, and second Ruby threading is rather heavy and really worth the cost only when you're doing heavy i/o, not loads of small cpu operations.
Yeah. It seemed like a great idea until I tried to write it and realized it's difficult or impossible to do correctly. I think you'd just have to override specific methods, and "promise" to not confuse it. Of course, as you said, ruby's threading makes it all pretty pointless in most cases.
Great tutorial, vimcasts is a really good resource!
Holycrap, that's awesome! Off to install it now. 
Very awesome, thanks for this link!
Why is an irb command that mainly just delegates to a system call even newsworthy? def vim(*files); system('vim', *files); end For a more comprehensive attempt at editing/loading code from irb, see sketches: http://sketches.rubyforge.org/ 
I really need to get a fresh version of Sketches pushed up. :)
You could try using haml2erb. I don't think any implementation would be perfect. If significant whitespace is your only issue, I'd just roll with it. The time taken to convert to erb would be wasted, and a good developer can take on a new project and not need to convert it to something more familiar, because things "annoy" them.
haml &gt; erb don't waste your time
haml is so superior to erb... it's like converting bacon to mashed potatoes, or kittens to snails... doesn't make any sense!
Oh .. It's like [SLIME, but for vim](http://technotales.wordpress.com/2007/10/03/like-slime-for-vim/).
&gt;You could try using haml2erb. Do you have a link to that? &gt;The time taken to convert to erb would be wasted, and a good developer can take on a new project and not need to convert it to something more familiar, because things "annoy" them. If there was a script it would take very little time. Anyway I see no reason to annoy myself needlessly. Why put up with shit you hate when you can run a script and fix it. 
well that wasn't helpful at all.
I hate refactoring haml. If I liked significant whitespace I'd be programming in python.
Yep, but now I'm forced to listen Stairway To Heaven..
it is only greater if you do not have a text editor that can auto-close tags for you. if you think that haml is the greatest thing since sliced bread, you should probably use something other then notepad or nano to develop.
Obvious troll is obvious. However, he is right in that we probably peaked in terms of adoption. On the other hand it's now a pretty uncontroversial technology decision.
Just a hatchet piece full of errors, straw men, and unsubstantiated opinion. Oh, but look, a titillating picture!
_derp_
&gt;However, he is right in that we probably peaked in terms of adoption. For now yes - the academic community seems to have a love for python more than ruby - there's a crapload of scientific libraries on Python that are way more mature or non existent on ruby. 
We're also in an awkward transition period - Ruby 1.9 to 2.0, Rails 3 just around the corner, we're no longer the hot new thing few people have heard about. People are wetting themselves over node.js, though.
Jeez, he's just explaining why he don't like significant whitespace (hard to refactor). No point of downvoting because you disagree with his choice of template engine.
i fail to understand how this is better then include/extend
This is pointless. You can do everything very simply using 'require' and ruby's open classes with no magic, no overhead, and no confusion. It gains you nothing.
Google knows where it is. It seems like a shame to do it though. Haml is great.
&gt; If there was a script it would take very little time. True, but the way I see it converting HAML to ERB is non-trivial unless the HAML documents are fairly simple. The best way to covert HAML filters and helpers to ERB would be for the converter to drop into your project a similar .rb file. The other option would be to expand the helper or filter into HTML, in the case of a helper this would negate the cleanliness of using one in the first place. In certain situations you'd get back a page of extreme ugliness. My serious recommendation is for the OP to take this as a learning opportunity in adaptability, an essential skill in a career of a developer. Refactoring someone's old code is good, porting because of your own personal inflexibility is not.
&gt;True, but the way I see it converting HAML to ERB is non-trivial unless the HAML documents are fairly simple. That's true. That's why I was asking for a tool to do the job for me. &gt;My serious recommendation is for the OP to take this as a learning opportunity in adaptability, an essential skill in a career of a developer. Yea that's good advice but life is too short to learn things you are annoyed with. Like I said if I liked significant whitespace I would be programming in python. I would rather spend my "learning time" on erlang or node.js or even rails3. I just don't understand the hostility here. I asked for a tool. If one exists I would appreciate a link, if one doesn't exist that's OK too. Why would you all feel the need to berate me because I don't like HAML? Do I have to like everything you like? 
There's no hostility at all from myself, just recommendations. The way I see it, there's a high likelihood you will find yourself in the exact same position again in the future. Think of yourself as part of a collaborative team extending from the original developer to the people who will maintain the project afterwards. It's not all about you, but the project. 
Simple and easy to start. Good for small CMS
:( What is he doing :/
I'm downvoting him because malcontent is always a dick and gives people who use ruby a bad name. Is that close enough?
this question was asked in: http://groups.google.com/group/haml/browse_thread/thread/af1e93e5e2e73cdd where he says that no such tool exists, maybe haml2erb was after that or is flaky. does not seem to be straightforward, and adds additional complexity, test coverage etc. when you ask for the url, are you asking for the canonical url, anyways found this on github (the number of watches was more), there was one another repository but it was deleted: http://github.com/cgoddard/haml2erb evidently, @robbyrussel also does not like haml http://twitter.com/phlipper/status/6939669636 hope this helps
if nothing works you can write a post-processor, write haml with lines seperated by semicolin and then as a script parse and output correct haml, sort of a *mini-compiler* but only if u are very desperate :-)
Then downvote him when he's actually a dick, and not when he's asking a proper question.
The main issues you will have with windows is path problems and compiling gems. I'm stuck developing on a buggy version of nokogiri until they release the next version. On Linux I just compiled the development version. Path problems aren't that big an issue. I have on a few occasions needed to modify some gems that didn't play nice but that's rare. I use the E text editor with the [railscasts textmate theme](http://railscasts.com/about). E requires cygwin and cygwin ruby installed but I prefer to use the Window's ruby as it comes with many gems working out of the box. I used to use RadRails on Aptana. While some parts of it were nice it was really slow. Starting up took a while, and it would even stutter sometimes if I was typing too fast. This is a fast computer too. I can't stand slow things so I had to change. The main advantages it has over E is better project management (e is really lacking in this area) and the rails servers and logging are integrated. E doesn't have integrated logging and getting a colourized log is pretty much impossible natively in windows. If you use E then install mintty and use cygwin's tail program to watch your log files. To get around the lack of integrated and project switching in E I created batch files for each of my projects. They open up the rails server, tail log, autospec, browser window pointing to the rails server, and E with all the relevant files in the projects pane. This setup works much better for me than Aptana did. I just click on an icon and everything is up and ready for me to work in a matter of seconds. If you do decide to use E make sure you learn the Rails bundle commands. They'll save you loads of time.
Thanks.
I want one!
GVim is the best editor for Windows that I have found. Notepad++ is the next best thing though.
http://rubyinstaller.org/addons.html DevKit fixed my problem of compiling gems.
This idea is horrible. "Feature flipping" is one of the worst ideas I've ever heard. And even if you did want to, just make a setting in your application configuration, and don't generate a bunch of queries.
Thanks for the kind words. Use a cache to limit the queries. Putting control in a web-based dashboard lets non-coders control features. There could be admins who will be granted access to feature flipping but not application code. The tutorial I wrote is meant to get you up and running. Optimizing is up to you. I guess the Flickr guys are morons, too.
Yes, the Flickr guys are morons, _when it comes to this_. You introduce exponential cases you need to properly test, as well as introducing places where it's easy to forget to remove code later. You're significantly increasing your complexity for no real gain.
Complexity is definitely increased--we agree here. There is plenty to be gained for certain situations--we disagree here. I'd also say merging branches can be very complex. So weigh the benefits of not having to split hairs in winmerge with the added complexity of a new system. I don't know why techniques/tools turn into religion on the Internet.
My phone isn't showing your reply for some reason, sorry. So I'm responding to the wrong post. What SCM do you use? It's possible that we have different opinions about merging because I've never had to deal with a particularly ugly merge. I branch for _every_ _feature_ and it's never been a problem.
Git + Github
Here's a suggestion: Could you extend this to work with popular Rails user management plugins (acts\_as\_authenticated? I never use them), to flip features on a role-basis, rather than a site-wide basis? That would be very useful, and would fill exactly the same use case as for a site-wide flipper (you could flip a feature on or off for all user roles). Edit: under\_score formatting
Another comment: One thing I don't understand with this feature-flipping for Rails as a deployment strategy is that it doesn't negate the need to do invasive database migrations, new models + controller code to be rolled out, probably any new plugins to be instantiated. All these things are more likely to kill your application than whether the actual feature is made visible to your users or not, and you don't get to do a clean roll-out using the flipper, because all these things require you to destructively migrate and update your site, and reload it, anyway. What I mean is, if you're worried about a new feature killing your application, with Rails that new feature needs to be loaded up anyway, even if you hide it from your users. Flipping it off at that point won't resurrect your Rails application, you'd need to do an actual application roll-back using your SCM to get things online again. The only case I can see where this could be useful for Rails is if you had designed the new feature to exist entirely in a silo, meaning new models, new controllers, new views, any new needs for lines to be written to config files/new gems/new plugins, loaded independently through an initializer which itself checks in the database before applying the config/gems/plugins. Or instead of for deployment, for this to be used as "feature throttling" if a feature ever begins to drag your system resources down.
This is something I definitely have planned. Not sure if I'm gonna make a post about it or not. Think of what I posted as a minimum viable product for feature flipping. And you're absolutely right about the migrations etc. This isn't going to be everything to everybody, but for certain tasks, for the application I'm working on, it should prove quite useful.
I say actually turn it into a totally role-based feature flipping management tool. As it is at the moment I really don't think it's viable to be used in Rails. It's so close to being really useful :) This could also solve the DB queries problem. When you load the user's details to the session, you'd load the current "on/off" settings for that role into a session too, expire it every day or week. Then you could query your @user object, coming from session data from the user themselves, something like this if @user.roles.registered.on? Or some other nice Ruby syntactic sugar using `method_missing`.
I appreciate the encouragement! It's one thing to implement something like that in my own app. It's a whole new mess if I'm going to learn how to write Rails plugins and open-source it.
Err... No. But if it runs like Rails does (not) on there, I wouldn't count on it. 
The latest Camping is built on Rack, so if BlueHost works with Rack, Camping runs on BlueHost. Here's a tutorial for running [Sinatra on BlueHost](http://www.bluehostforum.com/showthread.php?t=16486). Try something similar, but replace `run MyApp.new` with `run MyApp` (where `Camping.goes :MyApp`).
Simple opensource social networking platform in Ruby. 
Hehe sounds like a choice. As Morpheus say in the Matrix: "You take the blue pill - the story ends, you wake up in your bed and believe whatever you want to believe. You take the red pill - you stay in Wonderland and I show you how deep the rabbit-hole goes"
It looks to be abandoned. There are others and the front runners are tog and communityengine. They both have their strenghts and weaknesses but neither one of them is as advanced as the PHP counterparts and they also don't have the same size communties. Unfortunately I could make the same comment for every category of web apps. CMS, ERP, community sites, blogging software etc are all done better by the PHP community. Why is that? We should be totally kicking their puny asses. 
This is actually exactly what haml does so just run haml on all the erb
Say I have a bunch of files in a web server created by different customers, and I need a ruby script to do some kind of processing on them. What is the safe way to do this in ruby 1.9 considering the files will probably have several different and unknown encodings?
Something like this: strings = files.map do |file| File.read(file).encode("UTF-8") end
I created two files containing simply the text "á", one in utf-8 and another in iso-8859-1. This code gives me an error if I do something like s = File.read(file).encode('UTF-8') puts s if s =~ /á/ # "invalid byte sequence in UTF-8" for the iso-8859-1 file puts s if s[0] == 'á' # only prints the string for the utf-8 file.
I've somehow managed to pick all the gems that don't/won't work with Rails 3 so I'm stuck on Rails 2. 
I hate to be the "it is open source, you can fix it yourself" guy, but what gems specifically are you using that aren't Rails 3 compatible? Have you thought about trying to update them?
Unfortunately judofyr is wrong. There is no way to solve your problem. Basically, if you don't know the encoding of the files you're working on, how will Ruby? The code above is going to work differently depending on what encoding the *code* is in. As an example, if it's in iso-8859-1 (this is Ruby's default assumption but maybe not your editor's default), File.read(file) will return iso-8859-1 strings for both files, irregardless of their actual encoding. Ruby doesn't know the actual encodings so what else can it do? You've then told it to convert the iso-8859-1 strings into UTF-8. Both will convert because no matter their contents, they will be valid iso-8859-1 (any combination of bytes is valid iso-8859-1, which is untrue for UTF-8 as I'll explain below). So you now have one good string (iso-8859-1 treated as iso-8859-1 then converted to UTF-8), and one gibberish string (UTF-8 treated as iso-8859-1 then converted to UTF-8). This however won't lead to the error you are seeing because both strings will now technically be valid UTF-8 . Which can only mean... The code is UTF-8, thus File.read(file) returns UTF-8 strings. encode("UTF-8") is then a no-op because the strings are already *tagged* as UTF-8. It's important to note that they're only tagged as UTF-8, not actually are. No conversion took place. So now you have one valid string (UTF-8 interpreted as UTF-8), and one invalid string (iso-8859-1 interpreted as UTF-8). iso-8859-1 "á" is not a valid UTF-8 byte sequence and thus the error "invalid byte sequence in UTF-8" As I said, there is no way to solve this without knowing the encodings before processing
I'm using 14 gems and 2 plugins in a Rails 2.3.5 application. The ones that I don't think will ever work are `searchlogic` and `calendar_date_select`. Also I'm using a plugin called `acl_system2` which is unmaintained as far as I can tell. As far as the rest I'm sure it's mostly a matter of time before they get updated. My original comment was mostly made in frustration because I've read a couple of "upgrade to Rails 3" guides that I'm sure work perfectly if you only use Rails without any plugins or gems. Who does that though?
Hm. Strange. I guess I've gotten lucky on merges.
Gah, encoding and time zones must be the worst problems in programming… Maybe [RChardet](http://github.com/jmhodges/rchardet) could help in this case?
That's right, something like RChardet definitely could work. I believe that sort of thing can't be perfect though (No experience so just an informed guess). You can only try it in your situation and see how it goes Encodings aren't that hard! :) It's just that it's not something people ever talk/think about and so people generally don't know much about it. There's only a few things to it: the byte sequence, the way an encoding interprets this sequence, and the default encoding for unknown strings
Thanks for the [inf-ruby-bond](http://github.com/pd/inf-ruby-bond) shoutout. =)
Just what the world needs.
This looks great. RDoc is too loose for my taste, but when I looked into YARD for my last project but it was a bit too much. I think this one is just right. Sorry if that sounded a bit Goldilocks-ish.
Searchlogic's functionality is completely replaced by the Arel backing of rails 3, so you should be able to transition safely.
I did not know that. Thank you. 
How does this compare to rsruby? I've been using that and it is a little clunky, but it works well enough. Reading through the code has me wondering about maintainability tho.
I definitely understand the frustration, but there's also the school of thought that you shouldn't be using any plugins or gems that you couldn't write yourself. Point being that gems and plugins should only be shortcuts and if you build your app on too many black-boxes of mystery, then you're setting yourself up to fail whenever those gems or plugins are no longer maintained. Updating gems has the potential to be a huge time-sink, though, so good luck.
Rserve should be little slower, but being pure ruby the client implementation, it should be more robust to error. I prefer pure ruby client based on textual script rather than object based, cause allows you to use huge script without worrying about posible conflicts between the ruby and the R api.
I'm so happy Hackety made it in. I'm real excited about its ability to help beginning programmers, and get them hooked on Ruby...
I don't agree with that school of thought at all. As far as languages go, I am not always up to date on how to correctly do things in Ruby or Rails. Maybe I can describe in high level the algorithms that a gem relies on, but that doesn't mean I know how someone else coded it. I can probably figure it out, but that's why I went with a gem in the first place. A gem, in my mind, is the exact same thing as a C library. Just because I rely on a graphics library doesn't mean I need to know how it works, does it? I do think having an understanding of whats going on makes you a better programmer, but its not a requisite.
I think using a gem as a shortcut for solving a problem that you already have a decent understanding of but don't care to take the time to implement is the right reason to use a gem. (Obviously it makes more sense to use something battle-tested than to roll-your-own) I don't think the argument is that you need to know 100% how every line of code works, but rather that you shouldn't rely too much on something that might as well be magic to you. When the magician retires, you're either frozen in time or shopping for alternatives.
I'm pretty blown away by how far Rubinius has come, go Evan Phoenix/Charles Nutter... Dynamic bytecode compilation via LLVM, nice work... The only vulnerability seems to be the hilbert matrix suite
Where are the others? 13 are listed, and 3 of them are blank.
Was the JVM warmed up for these benchmarks on JRuby? Because if not, they there was a penalty paid for warmup since the JVM needs a little time to JIT everything properly.
If your main use of Ruby is for scripting tasks then you don't want the JVM warmed up. If it's for Rails, then you want a warmed up JVM. If you have a serious decision to make about which Ruby you use, definitely benchmark your own uses instead of relying on something like this. (The disclaimer basically says as much, just restating it here in case people missed it)
Why wouldn't you want it warmed up? Nailgun exists for a reason.
_why really helped me out a few years ago. I would not be the person or programmer I am now if not for his influence.
Hey that's pretty cool. It's like Emacs' server. Yeah, knowing that I can't think of a reason not to benchmark JRuby with a toasty JVM.
[This](http://mislav.uniqpath.com/poignant-guide/soundtrack/) was a really nice discovery for me, since I hadn't encountered his music before. Track 2 especially. As an artist and programmer myself I tip my hat to him.
_why taught me Ruby. Thanks dude!
I saw his musical performance at one of the RailsConfs. He managed to mix in obscure Ruby knowledge into his show and make it hilarious. I learned the [symbol to proc](http://blog.hasmanythrough.com/2006/3/7/symbol-to-proc-shorthand) nifty shorthand because of him, and still use that a lot...
_why influenced the way I teach.
I've ran the test with --server flag and updated the post. The execution time is 1 hour and 40 minutes, so don't know if the JVM was warmed :)
Why doesn't this use YARD as a backend? I get that he doesn't like YARD's default syntax for specifying information about the method, but it's so customizable it wouldn't be hard to slap a TomDoc parser on the front and use that. Then you get the benefit of all the excellent tooling that has been and is being built for YARD.
_why cured my cancer
Very interesting.
The yard author has already done it: http://github.com/lsegal/yard-tomdoc
I don't believe that _why's creativity can be suppressed for long and he will be back in one way or another. What I am concerned about is that he is not likely to choose Ruby again as all this talk going on about his disappearance and identity. I am really saddened by the fact that it was so important for some people to discover his "real" identity when he was truly exposing himself in the art he created. It's also possible that he simply burned out which happens especially if combined with external stress. Anyways, I for one miss him and hope to eventually something from him again.. 
I don't buy into the theory that he committed e-suicide because his identity was discovered. How could he ever expect to have any anonymity when he appears IN PERSON AND ON VIDEO? Does he expect that no one else on the planet will not recognize him?
Just say no to scribd links.
I'm not fan of flash, but scribd is where the author, Aman Gupta, put the slides. If this is the only place on the web to view them, what's your solution? Do you "just say no" to youtube links as well?
&gt; I once asked a team leader, who had .net and PHP experience and was in the middle of a large Ruby On Rails project, what the benefits of Ruby and Ruby On Rails were. She could not think of a single one. The team leader in question does not know ruby.
it doesn't seem to use flash on my browser (firefox)
Scribd has made a lot of noise lately about [switching to "html5"](http://www.scribd.com/doc/30964170/Scribd-in-HTML5) lately so you probably weren't using flash. Their use of flash has been the most consistent complaint about the site which is what I was referring to above.
What I'd like to point towards is one of the comments: "This is a big reason we have Active Model though. Theoretically the library behind it shouldn’t matter all that much; most plugins only need the external API’s that it provides."
good
just ruby? have you tried http://railsmentors.org?
Meh, I was in a bad mood when I wrote that. My apologies. I went back and actually read the whole thing this morning. And it had nothing to do with Flash, just a general feeling of malaise coupled with prior frustration with scribd. Have an upvote.
Some great interviews and conversations here. Although, I can't help feeling like I'm being trolled by Borat.
Just what my website was missing!
What is your site?
Cool!! Thanks for releasing this!
Sorry I was being sarcastic...
For a more complete and less meandering explanation: http://innig.net/software/ruby/closures-in-ruby.rb Section 6 gives a nice summary of the differences.
what is uploadd? how does it work, what problem does it solve and how is it different? Was facing timeouts and general slowness, in file upload in my app and found uploadd. Although i am still debugging and it i am sure it is a network issue.
Uh, "executes a shell command via puts"? Could you post that line here?
sure. my bad on that. "ndiff" is the file the output is being redirected to. the code is: ndiff.puts(`#{MyConfig::Ndiff_cmd} #{file_1} #{file_2`) MyConfig::Ndiff_cmd holds the location of the command ndiff. file_1 and file_2 are the two files that are being compared. 
You're expecting Bar's @log to create a new variable scope (so that it doesn't overwrite Foo's @log), but Baz's @log to share Foo's. To do what you're trying to do, use a closure for the log object: class Module def has_logging() class_eval { log = L.new define_method(:log) do log end } end end
sounds like you need ActiveSupport's class\_inheritable\_accessor
[Here](http://juixe.com/techknow/index.php/2007/01/22/ruby-class-tutorial/) is a good explanation of class initializers and constructors in ruby. Hope that helps, man! Good luck! :-)
`Baz` and `Foo` are two different objects. That's just how `Class` objects work. And they don't share instance variables (not being shared **is** the whole point of an instance variables). 
What you said makes sense to me. But I wrote this test case (after making your suggested change), and it fails: describe "logging" do before (:each) do @c_base = Class.new do has_logging end @c_derived_without_logging = Class.new(@c_base) do end @c_derived_with_logging = Class.new(@c_base) do has_logging end end it "should have distinct logging for subclasses" do # Fails! @c_derived_with_logging.new.log.should_not equal @c_base.new.log end end
What you want to use is the Singleton pattern. Here's an article dealing with the exact issue you are dealing with. http://dalibornasevic.com/posts/9-ruby-singleton-pattern-again
Hm, okay. What would you say is the best route to do what I'm intending?
Odd, this passes for me: http://gist.github.com/418370 
You created a class instance variable, not an instance variable. CIVs are not inherited. However, class variables are inherited and this is exactly the type of situation where you want one. Either that or you need a proper class level accessor method and to stop using reflection methods.
I'm not sure if this fits your exact case, but HTTParty does something similar with its [module inheritable attributes](http://github.com/jnunemaker/httparty/blob/master/lib/httparty/module_inheritable_attributes.rb). You can see it in use [here](http://github.com/jnunemaker/httparty/blob/03852d246bc1482150e92c23115e02e1de4930fb/lib/httparty.rb#L31).
This seems to work for me: class Module def has_logging() class_eval { class_variable_set :@@log, L.new def log self.class.send(:class_variable_get, :@@log) end } end end 
Whoops. Replace `==` with `equal` (edited above test).
Also passes for me under both 1.8.7 and 1.9.1. What version of ruby are you using?
`puts` isn't the problem. Executing a shell command is notoriously inefficient. &gt; Benchmark.realtime{10000.times{`pwd`}} =&gt; 50.3542881011963 &gt; Benchmark.realtime{10000.times{puts ''}} =&gt; 0.0497150421142578 As you can see, puts, at 4.9 microseconds, is approximately 1000 times as fast as opening a shell and doing just about nothing. 
You should follow the text closer. The constructor(initialize) had already been explained, and the definition of new methods on an existing class (reopening) was being covered. "In Ruby, classes are never closed: you can always add methods to an existing class. This applies to the classes you write as well as the standard, built-in classes. All you have to do is open up a class definition for an existing class, and the new contents you specify will be added to whatever's there." -- From the paragraph just above your snippit. So, you'd need both snippits, or you'd need to define initialize in that snippit for it to function.
As tootubular suggested, there is probably an initializer explained earlier in the chapter that you are reading. anyways, to get your example to work try this: class Song def initialize(n, a, d) @name, @artist, @duration = n, a, d end def to_s "Song: #{@name}--#{@artist} (#{@duration})" end end song = Song.new("Bicylops", "Fleck", 260) puts song.to_s
You might try downloading the examples from here: http://pragprog.com/titles/ruby/source_code What the example you posted is missing is the definition for the constructor for the song class. Recall that in ruby you can "re-open" any class at any time. The constructor for Song was defined in a previous code snippet. Plug this in before the example you posted: class Song def initialize(name, artist, duration) @name = name @artist = artist @duration = duration end end
When I was learning ruby I fell into the trap of thinking ruby was supernatural. It certainly seemed supernatural to me compared to other languages I had used. Alas it's not supernatural, it's just sixteen kinds of awesome. Same goes for rails BTW although rails sometimes is almost supernatural in it's powers. Anyway.... Faced with that kind of power sometimes you presume ruby can do things it can't. Sometimes you become afraid of doing things because it seems like you are acting like god. You have to learn to ground yourself. In this case you need an initializer. Ruby is not able to magically understand the parameters you pass into new without an initializer. 
i agree. but, i run the same command with two other options command-line options in my program and that line runs in a little more than a second (1.1 - 1.4).
I don't like that book neither, I could recommend you Beginning ruby from novice...from Appress Editorial...A good free book is http://www.sapphiresteel.com/The-Book-Of-Ruby from sapphire in steel..a ruby ide using good visual studio...it's free and very nice to learn...these and desing patterns with ruby (a more advance book) are my favorites ruby books...sorry for my english a greeting from italy 
I'm currently using why's poignant guide. It's a lot of fun and very entertaining so I think I'll stick with it for now. When I'm finished I will surely check out the books you recommended, thanks!
I think charles is doing heroic work in jruby land but.... It seems to me trying to wring the last bit of performance out of ruby is like trying to get blood from a turnip. Maybe what should be done here is to make duby a more usable system. Duby can be a viable replacement for ruby which is almost as fast as java which is pretty freaking fast. If ruby code could be ported to duby code with 80% efficiency by a tool I think it would be a huge win for everybody. If nothing else perhaps duby can be used to optimize sections of ruby code by taking the slow bits and rewriting them in duby. Most ruby programmers would balk at writing java but would probably do it in duby in a heartbeat.
Developers will make plugins that assume defaults. If things are properly abstracted, then it should not be difficult for someone to adapt the plugin to work other models.
I enjoyed [The Ruby Way (2nd Edition)](http://www.amazon.com/Ruby-Way-Second-Techniques-Programming/dp/0672328844). It's large, but I jumped around in it. It sits on my desk for whenever I need a reference.
I'd actually like to see him work on rubinius. Duby is a statically typed language that looks similar to Ruby. While it does use inference to guess types, it is still another language and none of the nice ruby libraries are compatible (or portable without a some hassle). The thing is that a language itself isn't really "fast" or "slow". It's the execution environment that is the key factor. Nearly all Ruby VMs have a global interpreter lock (besides JRuby), a crappy garbage collector (besides Jruby and Rubinius) and aren't thaaat optimized from what I could read. It is possible to accelerate Ruby to speeds that native Java reaches. Just look at other dynamically typed languages like Javascript, Lua or Self which have nicely optimized VMs and are gaining speed with every release. 
burke is right, puts definitely is not at fault. Here's an experiment to prove that puts isn't to blame: Try assigning your Myconfig::Ndiff_cmd to a variable and then dumping the contents of that variable out to your file via puts. Your slowdown should now be on the variable assignment line.
puts isn't your problem (see burke's response), but to answer your question, the source is here: http://ruby-doc.org/core/classes/Kernel.src/M005954.html See also: http://ruby-doc.org/core/classes/Kernel.html#M005954 EDIT: That source isn't very helpful, unfortunately. You're probably best off downloading the source and grepping for rb_io_puts. But you're still chasing the wrong suspect :)
good call. i just did that, and wouldn't you know it, that was whats the problem. is there a more efficient way to run shell commands? its a necessity for this project
&gt;The thing is that a language itself isn't really "fast" or "slow". It's the execution environment that is the key factor. That's not quite true. The nature of the language puts severe limits on how fast it can be. That's why I think duby would make a very nice companion for it.
Besides the static vs dynamic typing, what else would be a "severe limit"?
The dispatch, the stack trace, the dynamic lookups for every method call, the open classes etc. 
What was wrong with [domainatrix](http://github.com/pauldix/domainatrix) ?
@rb2k If you look at the source code, I created the library a few months before domainatrix but it was a private project. When I discovered domainatrix, I didn't really find myself comfortable with the library internals and the public API so I decided to go ahead working on my custom library. Furthermore, domainatrix depends on Addressable and also focus on parsing full qualified URLs. If you need it or find yourself comfortable with it, it's perfectly fine, domainatrix is a good library. I personally didn't need all that overhead.
which gem was causing issues?
There's no silver bullet. You need to either A) make spinning up the shell command more efficient (perhaps by passing off a job to an existing process) or B) make the shell command itself more efficient. Not enough information is provided.
I like, good luck.
Good idea!
That looks awesome. You should make the similarity stuff a gem in itself if it isn't already. And if it is you should use the gem.
Oh nice
Need this for apt-get also
I wish I had thought of updating `gem` like that when I made [guessmethod](http://guessmethod.rubyforge.org/) and grake. (Of course, I would have made it so that it just installs the gem with the closest name to the misspelling. Causing some people grief and making it impossible to get it rolled into RubyGems at all.)
every commit != every push 
Eep. Nice catch. I didn't want to leave the headline in first person and have people assume I was the author. This is what I get for trying to be clever.
Quines are one of those hobbyist things I keep putting off. I think I will take a stab at it now though.
Such gems do exist, but this code is tailored pretty specifically for this purpose.
OK, I'm not aware of them. Just out of interest, what's the benefit to rewriting/altering it in this case?
Maybe I was a little hasty in my previous response. The gems that exist, as far as I know, do more than was needed for this application. The code used to actually compute similarity using Damerau–Levenshtein distance was modified from [existing code](http://gist.github.com/182759) and is only about 20 lines long. What I was thinking in my previous post was about the code which attempts to avoid having to compute the distance, by downcasing, removing dashes and underscores, prefix matching, and avoiding comparing strings that have very different lengths. None of that would be needed in a general purpose method. On the other hand, it is simple to remove that stuff, so [here](http://gist.github.com/423093) is the code just for computing Damerau–Levenshtein distance between two strings.
Well, to be fair, you *have* clearly labeled yourself with your username ;) Also, really, it's not incorrect: he does test before every commit to github. It's just that those commits only get there through a push. Yay semantics!
http://blog.zenspider.com/2006/09/ruby-quine--slightly--smaller.html
RSpec gives us many powerful tools to make our tests readable. Matchers allow us to provide custom predicates to our should statements that succinctly define the behavior of our code.
Structs are definitely the most problematic part of FFI. I knew that when I built the API, but a necessity for simplicity at the time resulted in the current API (the original API required you to specify the byte offset of each field too). I'm all ears for ways to make this better. We've got a struct generator class which can generate .rb files with Struct "declaration" based on gcc, which is I'll bet how jruby generates all those etc.rb files.
I wish more projects would run their tests before pushing! Good stuff.
if fixing the byte offset of each field can fix matters, could you mandate that the C header file be included with the .rb files, and scrape it out?
Just signed up. I'm curious what you have up your sleeve with this one.
We can do that now up front, no need to bundle them. But where it breaks is stuff that comes from the C libc headers. I've been looking for a good C parser in ruby that could be wired up to this, but haven't found one.
ah, i just took a look at the libc headers and i see what you mean.
hooray! viva la ruby! :)
Would a C parser be enough? Wouldn't you also need something to run the preprocessor? Granted that probably wouldn't be too hard to implement in Ruby...
Upvoted for being helpful and friendly without giving it away.
Ah, shucks. Thanks. :-D I'm just reciprocating what the Ruby community has done for me over the years. One of the main reasons I'm still here. Helpful and friendly makes everyone's day better.
You need a C parser to be able to see and probably extract the typedefs
anymore like this?
Right, I get why a C parser would be necessary, but not why it would be sufficient, since typedefs etc. could rely on the preprocessor.
Nice! This is the first time I haven't been in three years!
This is a nice thing, but littering the markup with non-standard attributes like `data-foo` can't possibly be the most elegant solution?
They are "standard" in the sense that they're part of the HTML5 spec. The `data-` prefix allows for inclusion of any arbitrary string data as an attribute. So they're using it for the exact thing for which it was designed. Now, this means that it's valid HTML5 but still invalid HTML4 and XHTML 1.x. If that bothers you, you'll have to write your own unobtrusive JavaScript without relying on the Rails helpers.
This was a fun interview with Bryan Liles. Bryan is a very expressive guy. He’s noted in the Ruby on Rails community for TATFT (Test all the f*ing time) and his blog at smartic.us.
The title implies it was on our radar to begin with. I've never heard of it until now. After poking at it, I'm still not sure why I'd bother using this over ri. Why leave my text editor?
Any other Ruby redditors at railsconf?? 
I dunno. I just kinda like it, so I thought I might as well submit it to the ruby reddit.
This is rad!
yup
i've been contemplating something like that based on github and a template engine. individual snippets or question/answer texts are pushed as individual files, and then stitched together into documents in various ways.
There's no words there.
No because the slow bit is not rails it's the database.
The answer is not that simple. Actually the question was already wrong. Did you read the article?
Avi Bryant is just an awesome dude.
Nice try, why.
I wish. I only maintain Hackety. ;)
I'll probably end up submitting something to Hackety. That was his most interesting project to me. I love teaching people.
Er... why?
It's a bit rough at the moment, but I'd love to have as many people involved as possible. Feel free to email me at mailto:steve@steveklabnik.com and I can explain more. One of the things that's first up on the to-do list is get my 'how to contribute' documentation more up to snuff...
So--let me guess--on Whyday we each delete our online code repos without warning or explanation even if many other people depend on them?
I wonder why they didn't use maglev. 
cool!
To test the front-end javascript stuff, there are selenium/webdriver gems that work with capybara. It actually launches Firefox to run through the steps.
Only if you have created and run at least a dozen projects and contributed to many many more.
This is unnecessary and just a little creepy/sycophantic. I mean, I wish I could track the dude down, get him drunk, and talk some sense into him, but the dude basically pulled a fucking J.D. Salinger on all of us. All I have left is my rather entertaining email exchange I had with him once.
Nah, I think the only requirement should be to have the ability to screw over lots of people at once in some misguided act of online martyrdom.
people should also check out http://rubythere.com/
I'd really like to get some *constructive* criticism about Glyph (where "constructive" means "useful to help me improve Glyph"). Would you consider using it for your next article, thesis or ebook? Any missing feature you'd like to see implemented? For a list of the planned features, see http://github.com/h3rald/glyph/issues **P.S.**: Glyph is NOT a LaTeX replacement, and therefore it's not *better* or *worse* than LaTeX. It's just different, more focused on extensibility, reusing and organizing content in general.
Automatic and proper hyphenation is important when producing high-quality print. You can use Knuth's algorithm from LaTeX, I even think there's a Ruby implementation somewhere.
Even now it is possible to produce hyphenated PDFs using Prince's *prince-hyphenate* CSS attribute: http://www.princexml.com/howcome/2006/p6/p6demo2.html ...Alternatively I could "just" insert soft hyphens automatically in words using a dictionary. Thanks a lot, will think about it.
I just want to let you know that I have watched Glyph grow. I remember reading the first announcement about it and it has come a long way. Do not stop working on it. I have yet to find an excuse for me to use it, but I will gladly do so given the next opportunity. Great work! Keep 'em coming.
Those intridea guys are pretty sleazy. They were trying to get this project I was involved in, and they actually threatened to create a competing product if they didn't get the gig. Using the source code of the client to boot. 
Thanks, that means a lot! Yes, it's quite a niche project and normal people won't use everyday... the good news is that I am (I'm a technical writer), so no, I won't stop working on it :-)
i agree 
Somebody from the event machine team should have gotten an award. 
That looks pretty cool. I'm still waiting on the GNU PDF project to complete. The plan is a C based PDF standards complant API. Once this is complete I'll write a Ruby wrapper and all of our PDF generation problems should solved. (hopefully) http://www.gnupdf.org/
That's fuckin awesome.... Having spent too much time on FPDF for php and equivalent for ruby, I'm pretty sure we'll see webkit to pdf libraries come for other languages as well. Thank you, you made my day.
how does it compare to wicked_pdf ? http://github.com/mileszs/wicked_pdf
that really is beautiful. i've been generating lout from ruby and then rendering pdfs from that, but there is a *huge* ecosystem of tools and libraries for working with html and css, and it would be amazing to leverage that for pdf generation too.
this is awesome! I use princexml at work and this is nearly a drop in replacement! 
Looks about the same, except that wicked_pdf is a simpler usage for a Rails user. pdfkit does come with middleware that can serve any html page as a pdf. Maybe a little unfortunate that Relevance guys didn't find this in their search. Or maybe they started it before wicked_pdf was available.
I have been using an htmldoc wrapper, but it is very limiting without css support
anyone got wkhtmltopdf compiling on solaris?
My question is why does it require an X server? And would xvfb be an acceptable substitute on Debian?
According to [this](http://code.google.com/p/wkhtmltopdf/issues/detail?id=3), it seems to implies that it can run with out X server now, no? ADDED: "Features" note also says that: &gt; (Linux) No longer requires an XServer to be running (however the X11 client libs must be installed) 
EM is awesome but the docs could use some love. 
Perhaps you have us confused with someone else (and by perhaps, I mean you must)? That's not something we would ever do. Not only that, but how in the world would someone "trying to get" a gig already have the source code for the client? If you're going to slander someone at least don't do it nonsensically.
this was not so much an 'interview' but a long blowjob. ugh way too much cheese and sucking up!
in other words, he assessed the problem and came up with a better solution. Congratulations for doing your fucking job.
Indeed. I read the article in a manner not dissimilar to: "Take a look at this guy's incredible life and dream on!" *sigh* :(
This looks really great and useful. Apotomo does a similar thing and it just doesn't get enough attention. They need to talk to each other.
There are loads of CMSes for Rails. And though it has become even easier with Rails 3 it was still quite easy to use routes from DB in Rails 1 &amp; 2. Simplest way would be to make a route that matches /page/\* to something like PageController that takes the "\*", looks up in DB and returns the dynamic page.
Nope. Never. That's not the target and it won't be. Rails is for developers creating applications with agile and test-driven practices, not for putting up sites quickly and cheaply. If you want that, you should look into other technologies. You can try RadiantCMS, if you haven't already.
There is also http://pdfcrowd.com. They have an html to pdf online API + a ruby gem for easy integration.
You can share models by using git tricks. It makes no sense to share controllers. That's just dumb. If you want a decent CMS there are lots of them. Give Zena a try. It's hard to learn but is fully featured and supports multiple web sites. 
Next time you want to create a self-post, click "text" tab, next to "link" tab. It's not that hard.
Have a look at Django. It was created to publish content (newspaper for a town)
BrowserCMS.
Can you elaborate on these git tricks?
What you need to do is to merge some of this code with automateIT so you can also manage your non gem dependencies like native libraries, OS packages etc.
you just create the shared models as a separate git project and add it as a submodule to your app. Most people use a namespace so the model name is Shared::User instead of just User. Another way to share would be create a rails plugin. The desert gem is very good for this. It mixes in the models in the app with the models in the plugin so you can override methods if you want. You can install the plugin as a git submodule so any updates could be coordinated with the other rails apps.
Have you seen [babushka](http://github.com/benhoskings/babushka)?
Wow another one. That's too bad we already have chef, puppet, automateit and others.
If they're so great then what are you complaining about? Why do you care that others are making new tools?
&gt;If they're so great then what are you complaining about? I am not complaining. I am suggesting. Isolate and Bundler are ruby specific tools. They manage how you load libraries into your app and they also manage the installation of those libraries. Installation of libraries is also done by puppet, chef, automateit and others but they do a much better job because they can also install the dependent source code, OS specific packages, etc. They can even pull a file and do a make and install if you need them to. What they don't do is to actually load the libraries into your app. Clearly it would be a worthwhile effort to combine these things. In fact the effort to do that would be more worthwhile than to create another gem loader. &gt;Why do you care that others are making new tools? See above.
Every good project needs a good setup. In this episode, I set up a github repo, create a new rails application, hook in Cucumber and Rspec, write a Cucumber feature, and write the code to make it pass.
You can call this FUD if you want, but in my experience DRB falls over under heavy volume. I ended up going the AMQP route.
I have hit some nasty DRb bugs that return the wrong functions return data to the wrong caller when under heavy load. Not to mention DRb spins up a new thread for every method called, which can drag the server's performance way down. 
I only wish more people talked about the DRb load issues. I never would have went that way had I known it was so terrible.
Try brb http://github.com/kwi/BrB
Stackoverflow like Open Source Question and Answer system in Ruby
Source at git://gitorious.org/shapado/shapado.git
Great news!
They really need to declare ruby 1.8 dead in the hope that people will actually fix the two packages that are still annoyingly broken on 1.9.
Almost every comment on that site is spam.
i'm still waiting for qt to work with 1.9 :( people say they've gotten it working, but those people aren't me
On top of that there's no way of knowing what ruby 1.9 bugs are now fixed or not. Site is really useless in gauging anything.
It's a shame they don't give us the highlights. Here's what I've gleaned from the slightly cryptic Changelog: * OpenSSL 0.9.8/1.0.0 compatibility fixes * Fixes of varying severity for pathname, iconv, net-http, net-imap, fileutils, rational, date, net-smtp, resolv, readline, zlib, uri, webrick * Windows error mapping fixes for VC++ 10 * Fixed a potential core dump for win32ole * Potential timeout hang fixed * Fixes for NetBSD 5 * UTF8 fix for String#inspect * Some configure/build tweaks
That site used to be a very useful resource, it's a shame to see what it's become.
To browse the commits for this release: http://github.com/ruby/ruby/compare/v1_8_7_249...v1_8_7_299
Thanks. Lots of ugly merge commits (rebase anyone?) but it'll do. :)
This is an interesting idea but I don't think it's practical. For most classes the tests are bigger than the code that is being tested. What might be interesting is code generation from tests. In other words write the tests first and have ruby generate the classes based on what the tests specify including hopefully pre and post checks and assertions.
Thanks for the feedback. There are times it can overpower the methods (in the same way RDoc does) but I think the benefits outweigh the costs. Plus it helps me keep from making God objects and instead split things out into small maintainable objects and modules.
You know what might be even better. Get rid of the need for testing in the first place by using design by contract. This is not an often used paradigm in ruby for some reason even though there are numerous libraries for it. http://split-s.blogspot.com/2006/02/design-by-contract-for-ruby.html If you use something like this all your tests have to do is to run the code with various params and see if the code breaks. 
I don't think it's a good idea. I was surprised to see it in D.
I have looked at Design by Contract before and I think it is an interesting approach. I wonder if it really verifies the code as well as traditional testing but that just may be because I haven't used it in a real project before. One nice thing about test_inline is that if you are already into Test::Unit then it is easy to switch. Just copy and paste your tests into the right place. Thanks for the link.
Yea I'm not sure if it is a good idea yet either. I have used it in a few projects and it had worked better for me than traditional Test::Unit but only time will tell if it will continue to be something I like. Thanks for the feedback. I haven't really looked at D. There is a Perl module that also does inline testing.
I think it's a good idea. I wouldn't put all my tests inline with my code, but I have examples in comments that should be tested to ensure that they still work as advertised. This is a way to make them test code, so that they will get updated if things break.
just out of interest, why isn't it a good idea? The only reason I can think of for not doing it this way is it might muddy your code, but the benefits are that it is even easier to write tests. Anything that makes testing easier is a good thing IMHO.
I wonder how they decided to use four R's instead of three or five. Is there a standardized spelling for Arrrr?
Why is Isolate better than Bundler? Based on this article, they're more or less the same. 
Open source Ruby libraries to do profiling and detect memory leaks
It is short for About Ruby, Rails, Radiant and Rum, four R's looked better and so we ended up with free mojito's in the afternoon.
This is awesome, and would have saved my arse a year or two ago when I was looking for exactly this kind of tool. Really great work! Will remember it for next time. One question about this bit though: heap_find can’t return some objects that are traversed by Ruby’s GC, but aren’t first class Ruby objects—things like SCOPEs and VARMAPs. Does that mean it won't be able to tell you about objects being kept alive because of references when a block which closes over some variable scope is still kept alive? These are some of the trickiest leaks to track down, hence the most likely to need a fancy leak detector :) So would be nice if it could indicate them somehow. Maybe it could return a Binding object? or maybe an indication of the variable name responsible for the reference from that scope, with a file and line number? Or failing that just returning whatever was the nearest first-class ruby object before the culprit in the reference graph?
I liked this approach from the D programming language and created my own library called quicktest http://github.com/gregwebs/quicktest where a test method is created below the method under test with "def quicktest". Implementing this involved some horrendous meta-programming. Inline tests can be nice for getting something off the ground- you don't have to bother with structuring a project, and it opens up a technique for distributing a one-file project with tests. It can also create a nice workflow when you are creating a method- instead of moving over to your test file you just move down a little in your current file. Making it immediately obvious whether a method has a direct unit test can be a good thing also. I always thought that once code got more finalized and test suites got bigger that the tests would move out from being inline to go to their own file.
This episode of the TeachMeToCode podcast is an explanation of how I came to programming and why I approach things the way I do. It's a journey through Electrical Engineering, QA, Tech Support, and Consulting.
I expected this to be a one-sentence article that said: &amp;&amp; has higher precedence. 
I found it helpful that he provided examples of operators between the two, though the link to the precedence table is all he really needed to include.
It's funny, because the author links to the pickaxe book, which has a shorter explanation of both operators than his article.
&gt; Monads are just monoids in the category of endofunctors – what's not to get?
Thankfully you don't need to know category theory to understand operator precedence :) (or to use monads, for that matter)
your comments are so fucking useless. Edit: copious downvotes? Seydar's one of my best friends. Chill back, people.
you talk like a fag and your shit's all retarded hope you're enjoying NYC
it's "you talk like a fag and your shit's all retarded"
i walk around town with a stark erection i gave you mom what? a yeast infection
I wouldn't mind seeing Ruby overtaking Objective-C...
This really does sound far-fetched.
Sometimes I think the same thing, other times I wonder why they bother with the MacRuby project if they aren't going to do something big with it.
I really don't know the answer... does apple ever helps other languages? Has it ever helped two competitive open source projects? This could be naïve but maybe they just help developers to foster a "mac is _the_ environment for developers"...
Same here, but I seriously can't see this happening. There's several problems, including the fact that the source code to almost every application then would be in the plain, since its interpreted and not compiled. Ok for open source, but not for everyone else. 
Current issue in my mind is iPhone. Source code isn't a problem because MacRuby allows compilation of Ruby source files. I'm sure they are reverse engineerable, but so are .NET apps. Edit: I take that back. They do not seem to be reversible like .NET apps. macrubyc -V -o blah blah.rb arch -x86_64 /Library/Frameworks/MacRuby.framework/Versions/0.6/usr/bin/macruby --emit-llvm "/var/folders/pc/pc9oMdpLGielUvV07uUkbU+++TI/-Tmp-/blahx86_64-4589.bc" MREP_12AEB158BFEB4DE1B64AE43FD9799223 "blah.rb" /Library/Frameworks/MacRuby.framework/Versions/0.6/usr/bin/llc -f "/var/folders/pc/pc9oMdpLGielUvV07uUkbU+++TI/-Tmp-/blahx86_64-4589.bc" -o="/var/folders/pc/pc9oMdpLGielUvV07uUkbU+++TI/-Tmp-/blahx86_64-4589.s" -march=x86-64 -relocation-model=pic -enable-eh /usr/bin/gcc -c -arch x86_64 "/var/folders/pc/pc9oMdpLGielUvV07uUkbU+++TI/-Tmp-/blahx86_64-4589.s" -o "/var/folders/pc/pc9oMdpLGielUvV07uUkbU+++TI/-Tmp-/blahx86_64-4589.o" /usr/bin/lipo -create "/var/folders/pc/pc9oMdpLGielUvV07uUkbU+++TI/-Tmp-/blahx86_64-4589.o" -output "./blah.o" /usr/bin/g++ "/var/folders/pc/pc9oMdpLGielUvV07uUkbU+++TI/-Tmp-/main-4589.mm" -c -arch x86_64 -o "/var/folders/pc/pc9oMdpLGielUvV07uUkbU+++TI/-Tmp-/main-4589.o" -fobjc-gc /usr/bin/g++ -o "blah" -arch x86_64 -framework MacRuby -lobjc "/var/folders/pc/pc9oMdpLGielUvV07uUkbU+++TI/-Tmp-/main-4589.o" "./blah.o" 
I believe Ruby is supposed to replace Applescript, not Objective C.
No. Next question.
[MacRuby's](http://www.macruby.org/) mission statement would disagree with you.
I stand corrected, but in my defense, there was chatter a while ago about it replacing **Applescript**, not Objective C.
What's wrong with colon sex? 
The second part of the tutorial for building a blog with Ruby on Rails version 3. We demonstrate how to set up some basic routes, manage the controller and views, and create a basic form for creating posts.
For most people I think a pure ruby solution would be sufficient. If threading is really an issue you can use jruby which uses native threads. I would rather have a pure ruby solution than to have dependencies on other databases, erlang, other daemons, other message queues etc. In the past I have often just used a database and EM to manage messages and it's worked great. 
A colleague has a shirt I really love: the front of it says &lt;body&gt;. I'll let you figure out the back.
I like the idea of using custom matchers and what the author is shooting for. There's something big though I'm not sure I agree with about the post. The author is turned off by the shoulda (or remarkable) way of spec'ing something like validating the numericality of an attribute, because it doesn't actually test for failure. This is in fact, by design (at least, I *know* this is the case for shoulda, and assume so for remarkable). The rails validators have tons of tests on their own to cover them, so you don't need to do it in your examples. Rather, examples like this are your up-front contract and going forward coverage as to the validations you expect to be set on a model. If the validations actually fail, and you have set them as expected in the model, then ActiveRecord itself has big problems. Also, if anybody is curious as to why you'd want to set the expectation for a validation even though it doesn't actually test for a behavior, think of this case: Imagine you start with a model, drop your validations in, etc. Then you notice, you have 2 models with some shared code, so you start extracting it to a module, and have the module tell classes that include it to set the validations. If you miss something when extracting your validations to the module, your examples will catch that.
Good point. The majority of Ruby blogs and examples feature people using OS X, so maybe they're really just trying to foster a community for those people.
Even basic validation have bugs. In case of shoulda and remarkable you ship your bugs from model to tests and that is the problem. As maintenance and refactoring: the case of accept_values_for covers it. If your you pick right values - you will receive the same failure if any validation was lost. 
I came home last night to find my wife and her best friend in bed using the spaceship operator.
Fair enough. BTW, I didn't mean to suggest in the second paragraph that your solution wouldn't cover refactoring; was speaking more generally. I've written examples in front of people that asked "Why would you check if it can mass assign a value, rails is already good at that and its such a small part of the model?", in a codebase were extraction has caused such issues. 
Did you change it into a ternary operator?
This has been a really fun experiment for us to try and find some of the best candidates out there.
Yeah, but then you have to move to racist as fuck arizona. 
And that would make me integrumpy
Sorry not "How" *What would..* @all: The specs are WYSWYG (Tinymce?), tags, Rss, code highlight, comments(disqus?)
Very difficult to say without knowing specs/requirements, but crudely: Drupal is out. CMS-as-blog usually ends up a little clumsy. If I'm concerned about future expansion into CMS-like features, I'd use a framework instead of a CMS unless I was very certain about exactly how the blog was likely to expand. Rails is an OK sort of solution. I find rails works better for more 'web 2.0-ish' sites. For simple blog functionality, Django offers the quickest rollout whilst still offering a flexible solution. But ultimately if all I want is a blog, and I'm confident it won't ever need to be much more than a blog, Wordpress is the way to go. It's quick to setup, it has a bunch of functionality on hand via plugins if I need it, and it'll do what a blog needs to do.
If the integrum folks are here, I'd love to hear if anyone with experience bothers applying. The test is annoying, but the main problem is that you don't provide any salary guidance and the website practically screams "young and cheap job shop". My honest reaction is why bother? If it really is a good opportunity, you should explain why.
If you want a 'personal site' that hosts your pictures, app demos and a blog-like thing, go with the framework of your choice, does not really matter. If you want to blog, Wordpress. It's made for blogging. It works well for blogging. There is no need to re-invent the wheel if all you need is another twitter account without 140 symbol limit.
If you need to embed a blog into an existing site, I built a rails plugin (2.x/3.x) that you just drop in and adds a blog that uses your existing authentication system, layouts, etc... http://github.com/ryanstout/blog_kit More info at: http://www.agileproductions.com/blog_posts/4-BlogKit-a-Plugin-to-Add-a-Blog-to-your-Rails-App
based on the amount of forks, I'd say people did apply.
Most people with a lot of experience and committed to strong development practices already work some where they love and aren't looking for some where new. We do get a fair number of people that want to be better developers and work on a self-organizing team apply. You would have to define young and cheap. I probably wouldn't classify us on the far end of the scale of either. Define what you consider a "good" opportunity. As the definition would be different for different people. More than willing to honestly answer them.
My theory is that people will work on something like that if they have no better options. The most talented people just have to put word out to their networks or make a few calls and they get hired right away. If someone has to work that hard to get an interview, then they aren’t among the top developers in their area. I’d never ever do something like this. More than that, I’d rather work with people who bring me in at a higher level because they’ve worked with me before or because we know common people. If you want to know the quality of my code, ask the people I’ve worked for. They’ll tell you I was one of their top coders. If that’s not enough for you, then it’s not a good opportunity for me anyway. This is a great way to hire one of the best of the bottom half of the developers on the market who has no better options.
This may have something to do with their success -- http://www.indeed.com/jobtrends/unemployment Arizona is in general more competitive than a lot of other job markets. That would never work to hire rails developers here in Boston -- especially if they have the experience that this company is looking for.
Wordpress. because its actual blogging software?
I'll look at it thanks! It seems only WYSIWYG is missing
@grigio, maybe not what you're looking for, but blogkit has all of those WYSIWYG, tags, rss, code highlighting, and comments, and really not much more.
I use RVM (http://rvm.beginrescueend.com/) to manage my Rubies, and so should you. I normally run Ruby 1.9.1 and recently started testing Ruby 1.9.2-preview3. If you are looking for speed than 1.9.x, Ruby Enterprise Edition or JRuby are your best options. While Ruby's ecosystem leans heavily towards web development, I try to use Ruby for everything (everything that Java, Python, Perl allows).
Well, everyone has to guess about the salary, so here's mine. Looking at the pictures, your company seems to be "good" for guys under 35 or so, and you are a startup. Let's call it $65k/yr. Am I close?
I use it for a lot of general purpose tasks. I do web development with it, but I also use it to automate image processing, or handling the sorts of file or directory operations I might have done with Bash scripting 5 years ago.
Wow. I'm sure some neckbeards are out there saying "This is just doing what X has been doing for years!" but this is seriously impressive to me.
&gt; * A test suite is included with failing specs. &gt; * Please refactor this code, this is real code we found in a real project that could be much more readable and intuitive. &gt; [...] &gt; * Please note: feel free to change the specs, but they should all be passing when you turn in your code. How does this have anything to do with refactoring? According to Fowler refactoring is changing the internal structure of software *without* changing its observable behaviour. (See chapter 2 of his book "Refactoring" for the definitions.) To guarantee that the behaviour doesn't change you have to have automated tests in place that cover most of your code. If there are failing specs, one has to first specify the requirements and/or fix the bugs in the code/tests before one can begin to refactor. Apparently for the people who came up with this test refactoring can mean almost anything that somehow involves editing text.
Most of our team is under 40. $65k is probably slightly above average for a moderately qualified programmer in Arizona, but certainly not the ceiling for the kind of talent we are looking for. 
As the other posters have mentioned, I develop with Ruby as a day job doing web development on the Rails platform. That being said, I also used Ruby throughout college to do machine learning programs, genetic algorithms, and bioinformatics work. In general, Ruby's great for anything you want to just _get done_, without worrying about the contortions that some of the other explicitly focused languages put you through. Just having a REPL loop like IRB is great for very quickly trying things out. That being said, Ruby is not good at any heavy computation. I don't care which version of Ruby it is, it's still slow for any heavy number crunching, so if you're going to be working with heavy datasets, it's best to pick your battles. As you've said you're just getting into programming, I would - rather than worry about if Ruby is the right language for you - just pick it up and learn with it. Certainly we aren't tied down to just using the bike on which we first learn to ride, and the same goes for languages. If you have some *NIX / programming experience, I've heard great things about http://github.com/edgecase/ruby_koans If you like to buy books, http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177 is the best and only Ruby book I'll bother owning. I have a short attention span (except when writing comments, apparently) and have found all other resources laud on and on about how great Ruby is, rather than tell you anything about it. Otherwise, they read like a dictionary. Not useful for me. You've probably had it recommended, but if you like cartoon foxes, bacon, and a lot of comedic nonsense in your learning, check out http://mislav.uniqpath.com/poignant-guide/book/ - it's a quite fun way to get exposure to the language! Ultimately the first steps are the hardest - and the best way to move forward is to set a goal. Perhaps write a program that takes a number _n_, and tells you what the _n_th prime number is. Certainly not the most exciting program, but something that can be improved on, etc etc.
I just started learning Ruby this week, and am liking it so far. In addition to using Rails, I plan on using it for [Chef](http://www.opscode.com/chef/), a centralized system configuration system.
What people tend to leave out is, speedy things can be handled by ruby through extensions in C or Java (depending on the interpreter). My advice to beginners would be to just start using ruby wherever they can, regardless of crunchiness. It'll be easy to speed up the code down the road. 
As I said in the original post I found Why's Poignant Guide. I made it through a couple chapters reading it on his site, but it got deleted when he went AWOL and I started looking into Python. I was under the assumption that Why never finished the book. You prefer the O'Reilly book to the [Pickaxe]( I was under the impression that the book wasn't finished.)? I started working through it tonight (pickaxe) and using the 1.9 stuff thats included. That's not a bad idea is it?
Just get a basic interpreter up and running right now, though. When you get more experienced with the command line, programming, and *NIX platforms, then go back and customize your setup. This will save you time and spare you pain.
@grigio, it has WYSIWYG, its an option in the blog_kit.yml config, its just not the default, markdown is the default.
That's pretty rough. I'm in the Phoenix metro area making double that as a .net dev at nowhere special. 
AFAIK, Integrum is the only really successful Rails shop in the East Valley. If you want to do Rails work here, they're pretty much the place.
Well good luck out there. I'm genuinely interested to see what reaction you get. Please follow up in a few weeks! 
&gt; ... but the speed is supposedly lacking. Yes, but that's a red herring. For a multitude of tasks, execution-speed of the scripting language is irrelevant. Most tasks are IO-bound; Eg. disc or network access. This is handled by the operating system, and so it doesn't matter if you use Ruby or C. Further, a lot of resource-intensive tasks (Such as parsing XML), happens in shared libraries, that have bindings to the scripting language. Whether you use Python, Ruby or any other scripting language, they all piggyback on Xmllib for parsing XML, so they perform very similar. There *are* some tasks where the performance matters, but they are special cases.
i'd want hazard pay for being brown!
Pickaxe is under constant revision, and is always the best place to get the basics. The poignant guide was hardly the best way to learn ruby. It was more a...I don't know what the hell that thing was, aside from entertaining. Perl, ruby, and python are all essentially different flavors of the same candy (unfortunately, someone left perl behind the couch and it is covered in fuzz and dust bunnies). If you like python, there is no compelling reason I'm aware of to use ruby aside from pure curiosity. That said, the best way to learn ruby is the same as the best way to learn any other language: read other people's widely-used code, pick something you want to write, ask questions, and write that thing you wanted. There are also ruby challenge sites. Go to those, read people's solutions, ask questions about what you don't understand, and try to solve the problems yourself. Doing it is really the only way to learn how to do it. 
wow, that is a great way to get people to do free coding... pretend to offer jobs for passing the 'test' where the 'test' is actually a paying project. I wonder how long one could pull off a scam like this. In my field, this is like when universities ask you to submit to them your syllabi for a course they need taught, a syllabi takes around 4k to develop, but if you'll just send it in with your application, we'll judge you on that... and have 200 great syllabi from which to get ideas. 
If you are proficient in Python i think there is no point to move on to Ruby unless you want to use some of the aspects of the language that differentiate from Python like blocks. If you are into speedy environments, parallel tasks and so just forget it. If you want a language that can handle 80% of your needs then give it attention. The best thing about Ruby IMO is the paradigm shift. There are so many good practices in the Ruby eco-system like extensive testing, tools like Rake, Capistrano, Chef and there ll always a be an API in Ruby for almost anything. If you are a Java dev i suggest that you should give a shot to JRuby, it solves a lot of Ruby 's defficiencies. If not I suggest you to move to 1.9 but keep an eye on 1.8 as not all of the libs have been ported
1.9 is on par with python as far as speed is concerned. If you are on windows jruby is the fastest and best option. 
I definitely prefer the O'Reilly book to the Pickaxe version. To be fair, I haven't spent as much time with the second edition as I did the first, but I found the introductory examples (a jukebox, as I recall?) a bit too contrived to be educational (that was the book I originally used to try and learn Ruby) and flipping through to later pages it read more like a compendium of the API than an instructional book. To be certain, it is illuminating on the topic of metaprogramming, but I found it to hardly be a beginner's resource. The O'Reilly book on the other hand, was concise in its goal of providing a broad overview of the language sufficient in teaching you the syntax and ideology, and then moving further into details. And as someone mentioned above, yes - computationally heavy work can be done in Ruby by using extensions to subvert the language for another. But for a new learner, I agree with the general mentality of forgo those concerns for now, and see how you like the syntax, ecosystem and community instead.
That is very impressive but I think the webcast leaves out the fact you need to have the domains in your hosts file.
I didn't look at the code, but I don't see anything in the quoted text that makes refactoring semantically impossible. You could refactor the code that is covered by the tests that pass. You could fix the code for the failing tests, then refactor it as well.
That is correct, this detail is omitted for brevity's sake.
I've been experiencing a strange issue with the previous preview release. With a Rails application I'm developing, running all tests takes approximately twice as long under 1.9.2-preview3 versus 1.8.7. I'll see if rvm has updated to include RC1 and see what happens. **Update:** Doesn't look good. Tests on RC1 take 19 minutes, while on Ruby Enterprise Edition the same suite takes about 8 1/2 minutes. Something strange is going on here.
toto is a very simple ruby blog engine : http://github.com/cloudhead/toto
this is as likely as ironruby replacing C#
[Highly relevant](http://t-a-w.blogspot.com/2006/07/rlisp-lisp-naturally-embedded-in-ruby.html).
I was curious what the difference was between this and the last release, p378, so I did [a diff of their changelogs.](http://gist.github.com/462058)
Wow very nice. This should immediately be adopted by the rails or phusion teams.
Can't wait for this to be fixed: http://redmine.ruby-lang.org/repositories/entry/ruby-19/insns.def#L1033
Yes, good point. For mass assignment it stays as is.
Yeah I really wish they would start posting the changelog for each release.
I personally recommend Isolate instead. Much cleaner. Much simpler. Lighter weight than bundler.
haha was this meant for RUGBY not RUBY ? :)
can you elaborate on that? :) code example etc would be appreciated :)
Superb article! I think that the second idea you mentioned would be the easiest to implement, but the third would be the best. Can't say much more now. must leave
I think bundler is kind of a botched solution. We also need something that that can handle the native libraries in a sane way. Gem install Rmagick or gem install sqlite3 doesn't cut it when you don't have the approriate -dev packages.
rectum sex is not safe. colon sex is worse.
 def nice # ... respectful end ?
no.
why does it sound like they're reading from a script, especially the women.
coderrr was kind enough to provide an example: http://gist.github.com/455547 Also, for some odd reason I was able to trigger it in a mixin that used self.included / module_eval.
I tried 1.9 but had some errors regarding UTF-8 handling - it used to be that `@KCODE = "U"` made `scan(/./m)` return an array of UTF-8 chars. Also iconv doesn't seem to be working (chokes on a "bad char"). Haven't dug deep enough, but curious nonetheless, as I noticed about a 30% speedup in the code that did work.
Put `# encoding: utf-8` at the top of the script. And your regex needs a `u` modifier. Seriously though, dude, it's the first page in Google.
I just started trying out RubyMine (after using TextMate for around two years), and I'm really impressed. I think this is the most worthwhile Ruby IDE on the market.
I have been using it for a little while now and really like it. The interface is a bit bewildering and some of the behavior is odd but once you get used to it everything seems to work OK. It has really good refactoring support and good debugging tools too.
How about linking to the source http://rbjl.net/27-new-array-and-enumerable-methods-in-ruby-1-9-2-keep_if-chunk and not some ad-spam site?
Was confused for a second there. "Gets less what?"
RVM is really great. I have no idea what Ubuntu does to Ruby (if anything), but I only use it to install RVM and let it manage Ruby. It's just easier that way. I've written a few article on RVM [here](http://ruby.about.com/od/rubyversionmanager/Ruby_Version_Manager_RVM.htm).
Better yet: launchd. 
via: http://www.rubyinside.com/ruby-tracker-an-online-dependency-tracker-for-your-ruby-projects-3523.html
I'm guessing this http://lesscss.org/
This looks interesting but honestly it's a bit of duplication of effort. You already have many excellent and high performance work distributors and it's trivial to set something up with the rufus scheduler. 
Yeah. That's what I got after that second :)
I'm in love with launchd.
The name and its goal both are good. It is what I have looked for.
That's really nice. 
I use Ruby for pretty much everything. Anything that ruby doesn't do quickly enough, you can use a C library to handle if you really need to. When I say everything, I mean network programming, evented applications, threaded processes, etc etc. I don't just use it for Rails. Most of my day is spent outside of the framework anyway. For learning Ruby, I used Beginning Ruby: From Novice to Professional by Peter Cooper and I learned the ins and outs of Rails from RailsSpace: Building a Social Networking Website with Ruby on Rails by Michael Hartl. I have the Pickaxe around for reference but I haven't read it cover to cover. The Well Grounded Rubyist is another good book if you want to read something cover to cover to get going. Most of the resources you encounter will be based around Ruby 1.8 just because it's been around for longer. That being said, there aren't too many ground breaking changes between 1.8 and 1.9 so the fundamentals will remain the same. Really the best way to learn is to just write an application or build a gem. Dive in and have fun!
&gt; The biggest mistake the author made with closures FTFY
Actually, no. I believe this was a response to [Ben Kudria's](http://ben.kudria.net/) attempt to make a [LazyStruct](http://gist.github.com/467459). And in case you didn't know: MenTaLguY is a long-time Rubyist who knows his shit. He actually started [Inkscape](http://en.wikipedia.org/wiki/Inkscape#History)… **EDIT:** And can you please tell me what's the biggest mistake everyone else makes with closures then?
Hey, I know this reply is a little late, but if you find any references that you like, I'm building a list over at the Hackety Hack wiki: http://wiki.github.com/hacketyhack/hacketyhack/ruby-references Hackety is _why's project to learn programming, more than learning Ruby, so it may not appeal to you... but any tutorials you found helpful would be awesome.
seconded... I see people making this mistake all the time. MenTaLguY really knows his stuff. He's earned his respect in this community.
I honestly didn't mean to slight the author, but the title is written as if *everyone* has made or will make this mistake. The behavior makes sense to me; in reading the article I wondered how someone would think that the Proc would return anything but 3. I incorrectly assumed that the author had personally made this mistake and arrogantly wrote an article projecting his misunderstanding on everyone else. I stand corrected: &gt; The biggest mistake Ben Kudria made with closures
Has something changed in 1.9.* where k = (1..3).map{ |i| lambda{ i } } p k[0].call doesn’t print 1, because it sure does in 1.8.7?
It depends on whether i exists in the enclosing scope actually. I will add a clarification. (I did try out all the code examples before posting, but I got sloppy.) i = nil k = (1..3).map{ |i| lambda{ i } } p k[0].call I think in this particular case it was because I ran it after the for ... in example, which does introduce the variable into the enclosing scope. (Let my mistake be a lesson: always use a fresh session to test each code example. :)
Haha, well -- yes! I've fallen victim to it, at least in the distant past. The title IS a bit consciously hyperbolic, but I do see people making the mistake on a frequent basis. Seeing yet another person make it today was what prompted me to write the article.
"in reading the article I wondered how someone would think that the Proc would return anything but 3." I'm not sure it's necessarily obvious. In some languages you'll get 1, in some languages you'll get 3, and in some languages (like Perl and Ruby), you can actually find examples of both behaviors.
On this very night, ten years ago, in this very language, using ruby-gtk, I made a mistake, just like this. And when I finally figured it out, ...
As of 5.1, Lua uses a different variable each pass through a `for` loop. (That's based just on reading the documentation—I don't have an interpreter lying around to test.) I don't have any insight for the other languages, but I think that the first Perl example is no surprise. It is hard for me to read `$x++` as "create a new variable `$x` whose value is one more than the old `$x`", and much more natural for me to read it as "mutate the existing `$x` by adding `1` to it"—which accurately explains what happens, namely, that it's the same `$x` throughout. The problem with the `map`-based Perl solution is, I agree, more subtle; it's that the `$_` over which the anonymous subs are closing is a global variable, as can easily be verified by assigning to it later: my @k = map { sub { return $_; } } (1..4); $_ = 5; print $k[0]-&gt;(); # =&gt; 5 (In particular, you saw `undef` in your example only because nothing before had assigned to `$_`.) The proper solution here, which I think would rescue all your examples, is to explicitly ask for a new variable when you want one: my @k = map { my $i = $_; return sub { $i }; } 1 .. 4; print $k[0](); # =&gt; 1 EDIT: Removed a de-referencing arrow.
You can refactor the internals while keeping the API intact. That's the goal. You can change the specs without changing the external API. It's really straightforward.
True. What you say about the C-style loop in Perl also applies to C-style loops in JavaScript, of course. There are some ugly subtleties to introducing a new variable in Ruby specifically, but it is a valid approach.
That's exactly why some of the upper echelon will do this; it's a new market. I know personally, that all my contacts are in the UK, San Francisco, Austin, Orlando, Boston, NY, Portland, or Seattle. I want to live in Arizona and I've been watching the job market for a competent Rails company over there for at least three years, if not four or five.
I applied. [Here's my CV](http://m3talsmith.heroku.com). I don't think the companies cheap at all. They look like they have the right mix of people to get stuff done. They are also surviving in the middle of .Net world in Phoenix as a Ruby shop; that says something in and of itself.
&gt; if everyone has made or will make this mistake. I did when I first starting using lambdas in C#. I then proceeded to watch most of my coworkers make the same mistake.
It is DB2 not DB/2. It is not "expensive as hell" ... it is FREE. DB2 web services are not just SOAP but can do both SOAP and RESTfull web services. You actually don't write them in any language. You would use the free Data Studio IDE and, basically, point to a stored procedure or an SQL statement and say "make it in to a web service". DB2 will create the wrappers (yes they are in Java) that you can then deploy out for production to a free WebSphere Community Edition server or some other Java server of your choice. It is pretty cool i you think about it. http://FreeDb2.com
Thank you for your report and for including your CV. Good luck! I hope that others chime in as well.
i think there's something slightly different going on: $ ruby -v ruby 1.9.1p378 (2010-01-10 revision 26273) [i486-linux] irb(main):001:0&gt; x = (1..3).map {|i| lambda {i}} =&gt; [#&lt;Proc:0xa215018@(irb):1 (lambda)&gt;, #&lt;Proc:0xa214fe0@(irb):1 (lambda)&gt;, #&lt;Proc:0xa214fa8@(irb):1 (lambda)&gt;] #&lt;Proc:0xa214fe0@(irb):1 (lambda)&gt;, #&lt;Proc:0xa214fa8@(irb):1 (lambda)&gt;] irb(main):003:0&gt; x.each {|i| p i[]} 1 2 3 $ rvm use ree info: Using ree 1.8.7 2010.02 ree-1.8.7-2010.02 &gt; x = (1..3).map {|i| lambda {i}} =&gt; [#&lt;Proc:0x084f628c@(irb):1&gt;, #&lt;Proc:0x084f628c@(irb):1&gt;, #&lt;Proc:0x084f628c@(irb):1&gt;] Note that it's not a question of reusing the variable binding - it's creating the *same closure* thrice. Note also that this is not some brilliant interpreter optimisation ree-1.8.7-2010.02 &gt; a = lambda {i} =&gt; #&lt;Proc:0x084e5400@(irb):6&gt; ree-1.8.7-2010.02 &gt; b = lambda {i} =&gt; #&lt;Proc:0x084de858@(irb):7&gt; 
the behaviour makes no sense to me; a closure is supposed to capture its lexical environment, and the loop counter is supposed to be a lexically scoped variable. note that ruby 1.9.x has fixed this, even this works: &gt; x = (1..3).map {|i| (5..7).map {|i| lambda {i} } } &gt; x.map {|i| i.map {|j| j[]}} =&gt; [[5, 6, 7], [5, 6, 7], [5, 6, 7]] 
Current status of Temple: It pretty much works as expected; people just have to start using it. [Mustache](http://github.com/defunkt/mustache) is currently the only template engine which actually uses the Temple ideas (it doesn't depend on temple.rb though). I have partly created a Haml clone in Temple, and the implementation is current *much* easier to understand than [this crap](http://github.com/nex3/haml/blob/master/lib/haml/precompiler.rb). If you consider creating a template engine/language: please, please, *please* contact me! I'd love to help out :)
Yes, that seems to be the case. In 1.9.* this isn’t a problem, either, it seems.
You guys should make a better effort to get the word out. 
Yes, Ruby 1.9 changed it so that the parameters no longer shadow outer variables. In Ruby 1.8.7: &gt;&gt; x = 1 =&gt; 1 &gt;&gt; lambda { |x| x * 3 }.call(3) =&gt; 9 &gt;&gt; x =&gt; 3 The outer variable x was changed from 1 to 3, even though we never touched it. Ruby 1.9: &gt;&gt; x = 1 =&gt; 1 &gt;&gt; lambda { |x| x * 3 }.call(3) =&gt; 9 &gt;&gt; x =&gt; 1 Here x remains 1.
Ah, while: x[0] # =&gt; #&lt;Proc:0xb7798170@(irb):1&gt; x[1] # =&gt; #&lt;Proc:0xb7798170@(irb):1&gt; however: x[0].object_id # =&gt; -608387368 x[1].object_id # =&gt; -608387528 The address shown by Proc#inspect refers to the underlying code/AST object (which gets shared in this case), not the Proc's object id.
ah, i see. didn't expect that - how does it even work? is the interpreter seeing in advance that there are no block-local variables being closed over and just reusing the ast fragment?
This is one of those moments when I wish github had a "like" button.
Me too. Sometimes I want to mark a project so I can come back to it, but I don't necessarily want to see every commit.
The AST is always only stored once, no matter how many times you call: def foo proc { } end 100.times do p foo end Why would you need to copy the AST? It only describes the syntax. After the file is parsed, it will never change.
Man. Getting Shoes going on Snow Leopard was a piece of work... at least it seems this was easier. Good for wxWidgets!
&gt; I have partly created a Haml clone in Temple, and the implementation is current much easier to understand than this crap. This seems very harsh. I don't quite understand your page, because I don't program in Ruby (so I have no idea what ERB is), but it looks like an exciting approach to simplification and unification; but knocking the works of those who came before you is no way to win converts.
I know it sounds harsh, but it *is* a fact that Haml's compiler is terrible (just ask @nex3; the current maintainer). In a single module (1097 lines long) it both parses, optimizes and compiles; with basically no documentation at all.
I guess the shit heads that downvoted me don't think security matters. Way to go assholes.
Depends upon remarkable/active_model for all validation matchers except validate_uniqueness_of
Videos: http://www.youtube.com/whytheluckystiff
use the watch button it's GitHub not Facebook ;)
Is this old or new, and if it's new; does this mean _why is back?
From 2005/2006.
I can't follow a single strip. Perhaps it's because I don't live in Matz's basement or pick through his trash.
hey thankyou jud, I am a fan of these. I was missing #2, but you seem to have found it! Nice to have the titles too, now I know all about chinese sundaes!
I should probably add the RedHanded comments too. The ones on #5 are awesome!
ok then, you don't like it. Not a big deal but pls sshh.
Your comment doesn't add anything, either. If you're not going to say anything more than 'lol shitty,' just hit the down arrow. That's what it's for. :)
so far i've spent about two weeks playing with rails and reading about the community, and i get the jokes. often, satire is only funny to people who understand what it is satirizing. the daily show is just politics and news buzzwords and silly jokes. it makes no sense.
Can we actually call this one stable? 
because we do read from scripts.. that we also write... usually immediately before recording the show. :) It cuts down significantly on the editing / production time since we have less pauses, rants, diversions, and, well, "ummmmmmms." Some of the hosts are certainly more fluid and conversational than others. And, for her first episode, I think Desi did well. :)
&gt; $: no longer includes the current directory Weird change. I wonder why… Always seemed very convenient for small scripts.
Ah ok, well you do a better job than I could! 
not sure why but you can use require_relative now!
What I've heard is that it caused problems when you wanted to make a script with the same name as a library. For example, "I'm going to make a script that does something with Twitter, so I'll call it twitter.rb, and then require the 'twitter' gem... whoops!"
If you used apache it'd be a matter of changing ServerTokens -- http://httpd.apache.org/docs/2.2/mod/core.html#servertokens
Nice screencast. Usually I get annoyed when this medium is used without the obvious advantage of talking in it, but the music was so catchy!
why not thinking_sphinx ?
&gt;The first point I would like to raise is that Objective-C, while itself quite elegant (at least in comparison to its namesake)... To say C is not elegant is quite out of line.
It isn't in the same way that Ruby is. Elegant, but a very different elegance for sure. Ruby excels at having code that even non-programmers can read, and is very English-like. Compare _why's intro to Ruby vs the K&amp;R book. Both are absolutely amazing languages, Ruby (thanks to being much slower and newer) has a certain grace to it that C can't touch. 
I need to give Objective-C programming a shot again. I'm a Rubyist and I should admit that doing stuff like memory management again, does scare me. Some of the design patterns in Objective-C are strange, and overall the Cocoa framework is a lot to injest at first. Objective-C probably isn't my problem as much as Cocoa and wrapping my head around that. Not much different than encountering Rails the first time and not understanding how it all works. 
Gonna go with no.
My comment was C vs. Objective-C; it had nothing to do with ruby, but I will take the bait. Objective-C's elegance has more to due with Apple/Cocoa's strict adherence to a delegate system, rather than the language itself. While elegance is subjective, I do not believe Ruby's similarity to English is a measure of elegance; the available printed subject matter is not either. I don't think these arbitrary qualities give true credit to why people use languages like Ruby/Python (I will group these together). High level languages are excellent at describing data structures and the actions upon them. In day-to-day to programming, these provide and elegance and grace that cannot be matched by C. Pushing around data for human consumption and manipulating abstracted systems is much more natural in Ruby, and can be described in much fewer statements. However, neither Ruby or Python measure in C's ability to bridge the gap between man and machine. Neither Ruby or Python can take a block of contiguous memory and abstract a data structure over it in the most efficient manner possible. Ruby/Python manipulates the block of memory for you, via objects, which act as proxies to manipulate program memory. With C, you describe this explicitly and quite elegantly, considering the complexity of the operations that are possible with such a simple syntax. 
gotcha :) and totally right on
&gt; However, neither Ruby or Python measure in C's ability to bridge the gap between man and machine. I disagree. Ruby and Python, being high-level languages, bridge the gap between person and machine better than C. They better capture thoughts at a nice level of abstraction and turn them into runnable software. Imagine a stream, and you want to put a boulder in the middle to help bridge the two sides. Where do you want the boulder -- close to one side or the other, or close to the middle? I'd think in the general case you'd want it in the middle. High-level languages are in the middle. C is close to the machine side of the stream, so it's not the best bridge. To be good at C you have to start adding dirt to the person side of the stream to move the shore closer to the boulder. You have to become more like a machine, in other words. You have to do tasks that are often left to the machine to do (e.g., memory management, creating closure-like objects, managing tables of function pointers). Don't get me wrong. I like C, especially C++. I disagree with your bridge comment.
Objective-C 2.0 has garbage collection (though I've never used it). The Objective-C pocket reference and Apple's Objective-C 2.0 documentation are good language references, but it is important to have a strong grasp of C as well.
This made my day. Thank you!
Even better to gem install pussy and see some sweet, sweet ASCII vag. 
As an Obj-C developer (first Mac and now iPhone) writing an app that DOES use Garbage Collection is scary to me. I have this obsession over all my in-memory objects and not having full control makes me a little worried.
 $ gem install pussy ERROR: Could not find a valid gem 'pussy' (&gt;= 0) in any repository :(
Poor guy... immediately after he says "...anyway... new technorogy is a lisk" 
He clearly said "to blave"! and as we all know, to blave means to bluff!
Let me see If I've got this right... So, Matz is Japanes and Japanese people have trouble distinguishing between 'l' and 'r'? That's really hilarious! (If you happen to be an idiot racist, of course) 
MINASWANN? :-(
Poor Matz. He must not know he's a racist, since he laughed at himself about it.
Great, in that case someone should tell David Duke he's off the hook because Chris Rock once said "I hate niggas! I hate em!", and also laughed! Except, it doesn't really work like that, now, does it. 
Idiot maybe but hardly racist.
FTFU: Hardly bacist
I understood hardly.... 
Because, as we all know, jokes about l/r mispronunciation equate to racism. Sshh, don't anyone tell mistertim about the Rinda library! Now settle down and just enjoy the video.
Opensource HTML parser for Ruby 
There are better languages and they deserve your love. One of those better languages was invented at apple too. It's called Dylan. It's all but dead now but it's a very good language. 
I love this. Reminds me of figlet.
Is this what the nokogiri.org docs are using? I've always liked that design.
This is fun. I put it to my .bashrc. Now whenever I open xterm it displays a kitten :)
You can even promote to specific subreddits!
I hate PHP so much for making people think that integer-index hashes would even possibly be a reasonable way to see arrays.
I saved and bookmarked this post, because it actually solves a problem I currently have. So while I agree in theory, I found the post useful, regardless of OPs affiliation with Juicer.
Rails != Ruby
I do think it would be a good idea to have a set of "official" gems. A lot of times you just don't know which fork to use. You have to spend a lot of time looking through the commit logs to see what was done to the gem on each of the forks to try and figure out which one is good. I think github turned out to be a double edged sword. Lots of forks are good, lots of forks for no apparent reason and no merging back and in various states of abandonment is not so good.
And then you'll have official gems stagnating because the maintainer went on a sabbatical to tibet, or is afraid to develop fast and add bugs; and you'll have separate non official gem, maybe a fork, moving faster and being used by most people. If you don't believe me, look at Rails. What's the official Rails version? 2.3.8. What are lot's of people using? Rails 3.0.0betaX, even though it's problematic to do it. I don't go to github to get gems, I get them from http://rubygems.org, where you have only one gem per *name*. Forks are not there, so it's not an issue. Only twice I used a fork in GitHub and it was pretty clear that the original was abandoned.
People use Rails 3 because it's stable enough and different enough to use. It doesn't make sense to create new projects on Rails 2 at this time when Rails 3 final is just around the corner. A better example would be something like delayed_job. It started under the "Tobi" user account. 159 forks later, I think the blessed repo is the "collectiveidea" one these days.
http://ruby-toolbox.com/
JavaScript does it pretty much the same way :(
Ben, a [hardcore Rubyist][1], is a friend from high school, but I have no affiliation with Juicer. I posted it here because it's a useful service where Ruby support will remain critical. [1]: http://www.bencurtis.com/
Wahhh, name me a language where all the libraries are perfect. 
And Lua. 
Missing possibility: don't allow integers for hash keys You also wouldn't be required to assign a key to a value. ha = [:a =&gt; 'one', 'two'] ha[0] # 'one' ha[1] # 'two' ha[:a] # 'one' ha.delete_at(0)[0] # 'two' ha.key_for(0) # :a ha.key_for(1) # nil imo it simplifies some things and confuses others and of course you limit yourself to not being able to use integers as hash indexes 
No, he mentioned that: &gt; In other words, unification of arrays and hashes is impossible - at least unless you're willing to accept a monstrosity like PHP where numerical and non-numerical indexes are treated differently, and half of array functions accept a boolean flag asking if you'd rather have it behave like an array or like a hash. Doesn't sound like a good option.
PHP is different because it is just a hash that does bizarre things to numerical indexes. I'm suggesting that it act like an Array with each value in the array having an optional non-numeric key. It would avoid much of the nastiness suggested in the article largely because every item that has a key ALSO has a numeric index that is independent.
No, I have a different layout. I've been meaning to refactor it and release a gem, I've just been lazy! :-(
Haha, you calling yourself lazy is like a slap in the face! I wish I had the motivation to do as much open source stuff as you.
It's up to the central maintainer to accept the pull requests for merges back. I've found a lot of maintainers are just slow on merging back. Stopping forks wouldn't change that. Before there was forks there were patches and you still had this problem.
I do so wish that Ruby preserved the order you created the items in the hash. It's a rude awakening the first time you discover that it doesn't. I mean isn't a Hash nothing more than an Array of values indexed by an Array of Keys? 
not really, no, it's a set of buckets containing values. you can have ordered dictionaries, but that changes the performance of the various operations.
So… let me get this straight: people provide you with a shit ton of code for free, through no commercial motivation at all, and you're complaining about the quality? Ever heard the expression with not looking a gift-horse in the mouth? I have no problem with people bitching about shitty code, I do it all the time, but when it's not accompanied by one of… 1) Patch it 2) Sit yourself down and write something fucking better …then you have no mandate to complain. Some of us who've released popular gems spend way more free time than we should on building stuff for you, if you're not going to help, then shut up.
And jnicklas wins! :). I agree. Also, thanks for CarrierWave/Capybara. I'm contemplating moving a production app to CarrierWave from attachment_fu.
&gt; I do so wish that Ruby preserved the order you created the items in the hash. 1.9 does exactly that.
Oh yeah forgot about that ^_^ I only really needed it once - I was making a CSV file without using the CSV library, and I wanted to define a hash so I could have the headers preserved. I hacked it up, but it was annoying as hell.
Here is an idea, don't use bundler, it is crap. use Isolate.
This trips me up more often than any of the rest of PHPs god-awful design decisions.
&gt;And then you'll have official gems stagnating because the maintainer went on a sabbatical to tibet, or is afraid to develop fast and add bugs; and you'll have separate non official gem, maybe a fork, moving faster and being used by most people. Yes of course. This means that if a gem is deemed to be "official" there would have to be some sort of a commitment to maintain it. Presumably the ownership of the code would transfer to some sort of an organization. 
&gt;It's up to the central maintainer to accept the pull requests for merges back. Yes of course but almost none of them do that. Most of the project that got started are now abandoned.
I made the Horo style, initially for use with the Phusion Passenger RDoc. It's interesting to see that it found its way to Rails and now being forked by someone into an standalone project.
Next time provide a link.
That was my point. The official gem maintainers are horrible at maintaining in a lot of cases. Forking is the best way for those gems to survive.
Seriously, what's with the trend of bloggers putting completely nonsensical images in their blog posts? A fucking *bunny*? What does that have to do with string interpolation in Ruby? (I don't normally use Reddit to comment on the æsthetics of a blog layout, but gah, this trend is something I don't get at all.)
Does my blog have that much impact? [I've been doing that since 2006](http://t-a-w.blogspot.com/2006/07/list-of-things-that-suck-in-ruby.html).
Glad I'm not the only one. :) I started using Objective-C/Cocoa almost 5 years ago, and I still haven't gotten used to the garbage collection features. (Or properties, which I still really don't like, either, especially the dot syntax -- but I digress.)
I so wanted to try rvm, but it didn't have Ruby 1.8.5, and that's exactly what I need to test as CentOS still has that :-(
I dunno who or where it started, but it seems to be the "hot new thing", and I don't get it.
You should update the copyright and send me a pull request. I want to make sure that appropriate credit is given. I can program, but I cannot do markup. ;-)
Aren't a lot of pictures in articles are fairly superfluous anyway? Think about articles that have illustrations commissioned for them. Are they really that necessary? Probably not - but they do break up the text and people seem to like them (they're like office plants, but for prose), otherwise they wouldn't keep doing it. If the bunny makes you mad, you sure wouldn't like this article: http://pragprog.com/magazines/2010-04/tangled-up-in-tools
My point is that if there was some sort of a foundation that took ownership of the "official" gems we would not have this situation.
The problem with %W, %w, %Q etc are that they are just about impossible to google for. 
How does this work for images, javascripts, css files etc?
First hit for "ruby syntax" explains them (except not mentioning this %W trick).
Ahh, a foundation. I think you might be right there. With one small caveat. This foundation suddenly has to decide what should be considered official which introduces a form of bureaucracy that could be detrimental towards the innovation that's happening right now.
I don't think so. People would still be free to innovate all they want. They could fork like crazy, they would write all kinds of new gems and of course anybody would be free to use anything written by anybody else. It's just that the "official" ones would be handled in an orderly, stable, and conservative way to provide a degree of certainty. Over time the list of offical gems might change. Or they could switch back ends or something. Either way the idea is to provide some degree of safety net.
Why is the first page a picture of a cat?
I don't really know either but it was freaking awesome! :P
You could probably get it by making rvm build off of a certain tag: http://rvm.beginrescueend.com/rubies/installing/ This would be the tag you'd probably want: http://github.com/ruby/ruby/tree/v1_8_5_231
This guy puts them at the beginning of every post.
Because your webserver should serve those static files, this does nothing for that. What I do is just create a theme/default directory in public/stylesheets and public/javascripts. It's only slightly inconvenient.
It does have 1.8.5 - for it to build though, you'll need to be tricky and specify a special flag - the openssl ext bundled with it no longer compiles with recent openssl versions. To do it, make sure you're on head (rvm update --head &amp;&amp; rvm reload), then run: rvm install 1.8.5 --patch backported-ossl-fixes If it fails with an error on readline, try: rvm package install readline rvm install 1.8.5 --patch backported-ossl-fixes --with-readline-dir=$rvm_path/usr
Wow that was pointless refactoring. In the end you typed more and got harder to debug code. 
It's a first step, at least. There's still tons of similarities between the two chunks of code that a little more metaprogramming could eliminate.
Link? 
http://rubygems.org/gems/send_nsca Not sure why I didn't think to include that...
Charles Oliver Nutter (headius), one of the Jruby devs, is getting in on the [discussion over on Hacker News](http://news.ycombinator.com/item?id=1528613).
Or when you get one 'F' right at the beginning, and have to wait 10 minutes to see the damn trace.
some docs would be great
rspec supports multiple output formatters. just put this in your spec.opts and tail it. --format failing_examples:spec/spec_failing_examples.txt
i'm on it. Hey - just getting the code running was a bit of work. 
Sorry but it seems pointless to me. Maybe if it was a more complicated thing I might buy it. In the end I prefer explicit clear code that is easy to debug and understand.
The point of the article was to demonstrate the blocks and eventually create a small DSL
I wasn't kidding when I said that I hope every email forever on the rest of the Hackety list is this awesome.
This doesn't make any sense. What about things like Singleton methods? Or classes that have been monkeypatched? Duck typing as it stands is just fine. (and my other favorite language is Haskell...)
It is an awesome email and it makes a very strong case for using camping in your next lightweight project.
This is meant for human use. Mainly things like discussing how collection system works, and how it should actually work. One extremely annoying problem is how collections get automatically converted to `Array`s. For every collection type `Col`, you have operations like: * `Col[A]#map&amp;(A-&gt;B)-&gt;Array[B]` * `Col[A]#select&amp;(A-&gt;Boolean)-&gt;Array[A]` * `Col[A]#partition&amp;(A-&gt;Boolean)-&gt;[Array[A], Array[A]]` * `Col[A]#group_by&amp;(A-&gt;B)-&gt;Hash[B, Array[A]]` This isn't right. If you map a `Hash`, you want a `Hash` with new values - `Hash[A,B]#map&amp;(A,B-&gt;C)-&gt;Hash[A,C]`. If you partition a `Set` you want two `Set`s - `Set[A]#partition&amp;(A-&gt;Boolean)-&gt;[Set[A], Set[A]]`. And so on. Not every collection can do that (`Range[A]#map&amp;(A-&gt;B)-&gt;Array[B]` - it probably won't be a range), but many could - except nobody even bothers making them, as they get treated as second class citizens in Ruby. Even standard ones like `Hash` and `Set` suffer from this. 1.9 made some small step forward with this, `Hash#select` now returns hashes, `Set#select!` got added, which modifies set in place (`#select` still returns an `Array`) - but this is really not enough. (I hope you see how these type descriptions helped me talk about the problem easier)
Okay, so you mean "human use" as in "blog posts", not in the code itself?
I thought that part was obvious, but apparently it wasn't.
I could also be really dense. The first thing I thought of was Perl's optional type information for function calls. This might have affected my understanding.
That's... not what the article is about though.
I agree that this doesn't make much sense to me, or more accurately, I don't see a need for it. taw's ideas for this are too clean. For example, every collection example he gives is a homogenous collection. I've been coding in ruby for 10 years now and have yet to have a problem communicating with another human how something works. I certainly haven't needed an esoteric haskellesque syntax for it. I think even more important than _types_ are the reasons _why_ something is the way it is. Instead of: &gt; `Hash[String, Array[Module|Class]` (note the disjunction to specify heterogeneous collections) I'd much rather know: &gt; "This hash maps class or module names to arrays of ancestors of those types" See how much information is missing in taw's syntax? 
This makes no sense to me at all. _Why_ do we need a syntax for talking about Ruby types? Can anyone provide an example of how this would be used in practice? The proposed syntax is opaque and not really any more useful than a comment explaining the intended use of a collection. In what world is a statement in a blog post reading: # Enumerable[A]#()&amp;(A-&gt;B)-&gt;Hash[A,B] def hashify(collection, &amp;block) Hash[*[collection.collect {|key| [key, block.call(key)]}].flatten] end more readable than this? # Iterate collection and build a hash consisting of key =&gt; &amp;block(key) def hashify(collection, &amp;block) Hash[*[collection.collect {|key| [key, block.call(key)]}].flatten] end
Or you could just do a `grep -H "puts" */**/*.rb` (only tested in zsh).
I wrote the lll gem to use instead of puts. Among other things, lll prints where it was called from. http://rubygems.org/gems/lll
&gt; Can anyone provide an example of how this would be used in practice? Is [this](http://www.reddit.com/r/ruby/comments/crkmx/we_need_syntax_for_talking_about_ruby_types/c0upwx3) a good example? I'm not sure how good is the syntax I'm proposing, but it is really easier once you have some syntax.
Ok bad points: * Doesn't work with datamapper * Doesn't work with warden * Doesn't work with canable * Doesn't work with form_helpers * Doesn't abstract template engines * Doesn't provide choices 
i've used this on projects. it's a rails plugin that only works in test mode that lists the file and line where there is a puts. http://github.com/tobytripp/Putsinator
or: [ack](http://betterthangrep.com/) puts
 require 'camping' require 'dm-core' require 'warden' require 'canable' Camping.goes :Hello module Hello # Any modules included here will be included in the request: include Canable::Enforcers # You can inject any Rack middleware: use Warden::Manager do |manager| manager.default_strategies :password, :basic manager.failure_app = BadAuthenticationEndsUpHere end # Directory for templates (coming in next release): set :views, File.dirname(__FILE__) + '/views' end module Hello::Models # It's just an empty module; you can't put whatever you want in here. # And no, ActiveRecord won't be loaded. class User include DataMapper::Resource include Canable::Cans property :name, String end end module Hello::Helpers # Canable needs this method: def current_user return @current_user if defined?(@current_user) @current_user = (id = @state[:user_id]) &amp;&amp; User.get(id) end end module Hello::Controllers class Index def get # Example of Canable enforce_view_permission(something) # In the next release, this will either: # 1) Render Views#index using Markaby # 2) Render ./views/index.* using Tilt render :index end end end What is form_helpers? What do you mean by "Doesn't provide choices"?
I always raise 'poop'.
Nice! Great job!
Has support to scale multiple servers, do replication etc.
Or [this](http://img.skitch.com/20100722-eu4b2pkphc3s1gty34wd6ywugm.png)
That distinction blows the bottom out of the credibility bucket for this article with such a velocity that I have difficulty finding words to describe it.
This actually happened to me today.
looks cool. how about: * error handling (end before start, non-existent dates, etc.) * time
One of the most annoying bits of ruby I've ever seen was someone overrode the / (divide) operator on a string to make it do translation interpolation. I made me be a little bit sick in my mouth.
Why will someone want to do that ? Exceptions exist for a reason!
Yes... but not this reason.
Doesn't Objective-C do this by default?
Yeah, it's one of the few parts of Objective-C I prefer over Ruby.
could be useful. i really just ported over some .NET code i had (and was amazed how much cleaner it was in ruby) probably more important would be being able to use other properties than start_date, end_date. it fulfills all my needs right now, but i'd be happy to see it forked.
oh my god I just puked
but nil is such a nice and legitimate return value. If I call a method that could return nil, say "are there any items in that list?" and it says "nil", but that "nil" comes from some problem with a database, then execution continues, but at the cost of proceeding with incorrect information.
If there are no elements in the list then it's better to return an empty list. And if there is a problem with the DB then you should throw an exception. Nil is rarely a desired result, and almost always means you have to write special cases for handling it. 
That should really be 27 bytes: def p.method_missing*;p;end
UTSUP? was built with the intention that most interaction with the application would originate from command line. from initial setup and project initialization to all the other features, we wanted to make sure that the core of the application works where you do. you can check recent supdates from everyone (or a specific person), set a supdate message, check in and out of projects -- all right from the command line.
Jebus this is a horrible misuse of method_missing.
FYI: There's already a [sup](http://sup.rubyforge.org/) gem which uses the `sup` executable.
That's the first thing you'd do to obfuscate your code: override everything :-)
is it closed source? and by closed I include the euphemism "hosted" that people say when they don't want to say closed source "SAS".
I suppose its time to get coding and get things working under Rails 3.
Are you one of the developers? Your app is throwing 500s right now.
Is fixed, thank you though! (I'm also one of the developers). I had hastily pushed out an update to get http://chartbeat.com up and running, I'm liking what I see so far, it is a pretty cool real-time traffic monitoring service!
This is the kind of thing that we'd probably shell out a significant amount of cash for if we could host it internally. I know that complicates everything a lot; I'm just putting it out there.
I may just be speaking for myself, but I really hate when a company tries to create a bunch of dumb names for things based on the title of their company/product. I usually just want to punch whoever actually uses the "terms" right in the mouth, and burn down the company that helped ruin my day. Please just say what your product does without making everyone around me sound like the mouth-breathers I try to avoid. But, like I said, that may just be me. 
Doesn't really complicate things all that much, we considered that as an approach but we wanted to get something out there and get feedback first. I'm one of the other developers and have been reading a lot about ideas like Eric Woodward's Minimum Respectable Product (http://ejw.com/2010/07/essay/mrp) and the 37 Signals idea of getting the simplest form out first then worry about spreading into new features. If we do end up rolling out a whitelabel do you mind if I contact you again?
Hahahaha point taken. Sometimes trying to be too clever can backfire.
Uhm... How is that useful? If everyone is working on feature branches and writes meaningful commit messages that should be enough, right? I'm not hating though - I just don't get the idea.
Beautiful! Great find with the load(String, Boolean) business.
There are already multiple libraries to handle this including andand, try, etc.
I can see the usefulness of automatically publishing a log of local commit messages and status (file list) in real-time to let other team members see what you are currently working on, but only as a git extension. From the video this looks overly complex, requiring special commands, sign ups, logins, special commands getting in the way of the regular git workflow simply for the kind of additional features displayed.
These were my thoughts. One could have a small shell script that would write a status message to some hidden tracked file, and then commit the result. I'm not sure what the benefit is of tying this to an external service.
We mostly use it to track progress on projects through the twitter stream. As a user goes about their daily work the merges and commits are automatically posted to utsup which then bounces them out to a private twitter stream. Watching that can tell you a lot about the velocity of work. If that user runs the command "sup in" at the beginning of their day, then every 5 minutes a process is kicked off that send a diff of what has changed out even if they haven't committed anything. The idea is that for the most part this is transparent to the user and provides a stream of information about who is working on what to the other team members.
The extra commands are only for extra features. If you just install the gem and initialize it, it runs transparently by accessing the git hooks and sending commits and merges out to utsup. The other commands do things that normal git process doesn't allow, like the command "sup in". Like I said above, running that kicks off a process every 5 minutes that sends a diff of what has changed out even if they haven't committed anything. If you are a manager or a team member watching a private twitter stream of updates and you can see what people are currently working on even without them committing anything it can be a powerful tool.
The benefits of tying this to an external service are: bouncing the updates out to twitter to allow users to monitor a stream of information, access to git updates / commit messages in places or times where you don't have a command line, filtering and searching commits and status updates, and doing things that git doesn't like the sending out of a diff every 5 minutes to show what a user is doing even if they haven't committed yet. We use the app as it is in a way that is almost entirely transparent to all the users, we only ask our remote hourly people to run "sup in" so that we can see the constant stream of diffs and make sure they are actually working on things. Additionally there are other features that we have plans to add, but haven't yet as we wanted to get feedback on what we have.
Ah - I see, cool idea - but it has to fit into the team's workflow. My team is using Campfire for this kind of stuff (and Github dashboard). I could see myself using this - but it's too late for using it at my current job - too many habits :-)
Understandable, habits are hard to change! The one feature that makes it really useful for us to use with remote hourly workers is the automated 5 minute diff. It is really nice to be able to see exactly what a programmer in Argentina is up to even without them needing to commit changes. Makes it simple to see when they are actually working and when they might be doing something else.
Video is ten seconds of blackness for me. Broken, or was that the point? :D
oh gee, whoop dee doo
works for me..
I hate IE
So if the browser for whatever reasons decides to use the wrong encoding, then Ruby barfs? Snowman or no snowman, that's pretty messed up. Shouldn't Rails catch such an error instead of relying on the browser to do the right thing? Afterall, the bad guys may have something -- gasp -- other than a browser. You know, like curl. ;-)
&gt;Shouldn't Rails catch such an error instead of relying on the browser to do the right thing? No. 
But, without IE we wouldn't have snowmen in our code. How can that be bad?
The only reason to change the charset clientside is if the website already had charset garbage on it. Don't emit charset garbage and there is no reason for accept-charset.
Excellent, thanks for linking.
No bad will intended, please enlighten me. My understanding of the post was that Rails *crashes* when a POST is passed to it with the wrong encoding. I understand the need for the workaround in IE -- I just don't understand why it shouldn't also be fixed in Ruby/Rails.
very interesting. How is the data input? Parsed excel files or from an API? Also, [this entry](http://www.war-logs-on-rails.com/war_events/022DC748-AFFE-49AE-84EDDC5F506585E7) need to be more legible. too many acronyms. Maybe you can parse the report and then add :hovers (short text explaining whats WIA, KIA, OCCR) so that anyone can understand the data and hopefully more people can use it your website
The original sql zip file as posted on http://wardiary.wikileaks.org/ is included in the repository, a migration imports it and makes it 'railsy'. Better layout is one of the 'todo' items in the README. The terms are explained in the glossary on the right, but a mouseover could be useful too. I've added that to the todo section in the README.
Awesome! Is it at all possible to have some sort of option for a column sort?
I've run out of time for the next few days, I've made a list of things that people could do in the README of the codebase, I forgot to add sorting columns to that, so I have now. I do think a lot of other things have higher priority though, like finding events by data/location/other fields. Hopefully somebody out there will have time to pick it up...
My expertise is more in PHP and Python, but I grabbed the source and I'm going to look through it to see what I can understand and do with it.
Great, let me know how you get on, I'm happy to assist with any issues. The tagging process in particular may not be working, it takes so long that I did not have enough time to test if it properly works without manual intervention.
benoît chesneau also made an afghan war logs web application, and he posted the source code at http://github.com/benoitc/afgwardiary since it's couchdb, you can replicate the entire dataset to your own couchdb instance to play around with the data
To get it in Emacs: `C-x 8 RET SNOWMAN RET` 
"Crashes" is a big word. It implies that Rails becomes unusable upon encountering bad data and needs to be restarted. In truth, it sanity checks the data and just rejects bad data by throwing an exception (which is caught by lower layers and an error message is logged, but the current request is otherwise aborted). This *is* the right thing. Now the browser has to do the right thing to in order for everything to work properly.
Take a look at this [one](http://github.com/redhatcat/afg). It already has column sorting, column filtering, and search. No tagging on this one though.
Here's another one using [ActiveScaffold](http://activescaffold.com/) you might enjoy. http://github.com/redhatcat/afg
[jQuery tablesorter](http://tablesorter.com/docs/) is good and easy to use.
http://nokogiri.org/
But it can only sort for data already on the page, which is not really what you want: you don't want to sort the 30 entries on the page, but the 12000 results. That needs to be done server side with pagination.
Yeah, I was really surprised to see that left out, but then I noticed the article was written in 2008 :(
I checked the dates, Nokogiri was out when the article was published. But ok, it probably wasn't known yet.
I seem to recall one of the main points of merging with Merb was a leaner more modular framework? Did DHH drag the Merb guys in a room and torture them til they submitted to the bloat?
&gt;No bad will intended, please enlighten me. Sure... It's not up to rails to accommodate every broken browser on the market. &gt;My understanding of the post was that Rails crashes when a POST is passed to it with the wrong encoding. Your understating is wrong. That's not surprising because you don't seem like a very intelligent person. &gt;I understand the need for the workaround in IE -- I just don't understand why it shouldn't also be fixed in Ruby/Rails. Yea this is the fix. 
Thanks! I'm only just starting out with Ruby and was looking into various parsers.
You're right, with 12000 results tablesorter might be a bit slow... You could use [this ajaxy version of will_paginate](http://github.com/mbostler/will_paginate) or follow [this tutorial](http://railstrip.ourgreatjourney.com/how-to-paginate-sort-and-search-a-table-with-ajax-and-rails-jquery-style/). There doesn't seem to be an easy solution. Also: You could put "white-space: pre-line" in the CSS for .summary, so the line breaks aren't ignored. Or visualize the stats with the [Google Chart Tools](http://code.google.com/apis/charttools/index.html). And have a glossary for the military codes, or a proper search in which you can select the different tags and limit the dates etc. I'll look at the source after i've finished my tests. Great site so far. 
Nice! We call these delegates in Apple land. Edit: Fuck the ideologue that down-voted me for mentioning Apple.
Announced and demo'ed at Security B-Sides in Las Vegas. Hope you like.
Awesome tool. Thanks for the post.
It's about time, slacker! ;)
Rein gave a really interesting presentation of this at PDX.rb - pretty fascinating stuff.
&gt; # Actually, you need to define both #hash and #eql? &gt; # Weird. &gt; # But true. &gt; &gt; def eql?(other) &gt; hash == other.hash &gt; end His definition of `eql?` is facepalmable - this is so far beyond just wrong... "x".hash == 61.hash #=&gt; true "x".eql? 61 #=&gt; false It goes `a.eql?(b)`, then `a.hash == b.hash`, not the other way around. (and if you return 0 as hash of all objects, ruby still works, just a lot slower)
masochism, not machoism. http://github.com/technoweenie/masochism 
There's also this one -&gt; http://github.com/mauricio/master_slave_adapter
I have had some success with db-charmer. Edit: The reason being that I know it can do multiple slaves. I haven't researched the others to know whether or not it's possible.
Initially, I missed the point of: foo = 42 and foo / 2 I was stuck on the fact that after the above expression `foo`'s value was still `42`. Then I realized that it was the result of the total expression (21 in this case) that we were interested in.
You can also use things like pgpool.
[Direct link to the blob](http://github.com/jbw/rubycv/raw/master/example.rb)
Thats hardly brief since its 118 slides
ActiveRecord connection adapter is included in the gem (as well as one for Sequel) - both a fully green on the tests in each respective framework and have had people using them in production for a little while
thanks all, trying out data_fabric, then will try masochism and db_charmer. Any more inputs would be helpful. What are the pro-cons of all there plugins. Maybe - why did the developers code their own? What was wrong with the existing code etc. thanks 
I've been wanting to do it the past few years, but it just hasn't worked out. If anyone is looking for a team member, send me an e-mail ryan (at) agileproductions.com
I'll be doing it for my third year. Not sure what we're doing yet either, but I'm sure something will come to us eventually. Definitely going to have a designer on the team for once - I've regretted not having one every year.
I've competed 2 out of the last 3 years, and looking to enter again. Also in need of idea/team
Fancy putting the URL in the post?
First year competing. We have a pretty decent idea being formed. 3 web programmers of varying Ruby/Rails experience (4 years, 2 years &lt;me&gt;, 6 months) and a designer. We should be getting some basic paper wireframes done this weekend. We're charting out our planned rollout phases next month, so we can release a basic site after about 24 hours, then add features over the next 24. Having not done this before, I dont expect us to be able to get as much done as we think we can. But the site should be pretty cool, and is something I've been wanting to make for a while... so getting some friends to spend 48 straight hours helping me is pretty cool.
I want to compete this year, but I lack a team / idea. If anybody wants to work together, shoot me a pm.
http://blog.railsrumble.com/
I love this guy's articles. Favorite is the Monads in Ruby one. You all should check it out.
The Ruby logo has scrollbars
Since you use Mercurial, check out [amp](http://amp.carboni.ca). It's a Mercurial interface in Ruby. Use it, abuse it, report some bugs, get some love, and you can help make it better.
thanks!
The logo in the ruby official site is too large, I has changed one, thanks!
Anybody ever use it? It never seemed like an attractive choice to me.
surprise!
Does anybody care about ironruby? 
the article lost me when they missed the main appeal of iron ruby - to bring the .net libraries to ruby. this has nothing to do with "interop", just with being able to write applications in ruby while using the rich .net stack.
This makes [wxruby](http://wxruby.rubyforge.org/) even better choice: native widgets, supports all major operating systems (OSX 10.5 and 10.6, Windows and Linux).
I've used db-charmer and it was relatively simple to setup. However, when I went to combine master-slave with sharding I found out it was basically one or the other for a single table. I was looking to do something like a sharded table where each shard had a master and a couple slaves. 
Jesus. Nobody really cared about ironruby in the first place. Let's let the dead rest in peace.
Truth be told, I've never written a .NET app with Ruby. I was looking forward to playing with Silverlight and Ruby, but now with IronRuby dying off and Silverlight taking second place to HTML5 in Microsoft's endeavors, I think I might just leave the whole thing alone. MacRuby is grand. It's unfortunate no-one cares about the other side of the fence.
I don't get it.
Its interesting really. Ive messed around with IronRuby, and while interesting, I dont really see it fitting in anywhere. (Same for IronPython really). If you can host Ruby code from within C#, why not script in C# instead? (Since you obviously know both languages). And to write Ruby code that interacts with .NET, the reverse applies. And frankly, most Ruby folks dont even want to touch .NET, since they mostly come from a Mac or Linux background. I give props to those teams for coming up with an interesting idea, but it just doesnt seem very practical.
you might like ruby more than c#, but still need to work in a .net environment.
I don't know a single ruby developer who uses Windows by choice, and of those I know forced to use .NET, they're in situations where they can't choose the language they use anyway, even if it can interact with C#. I don't really see the point of IronRuby.
i haven't either, but if i did have to use windows, and did have to develop a gui app, ironruby sounded like one of the better options for it.
I've been at work for a while, now. I wouldn't read Waiting for Godot right now and similarly, I'm going to bookmark this for later.
Writing Windows desktop applications would be appealing, but the VS GUI Designer currently doesn't support Ruby, I guess. So without decent IDE support, IronRuby won't attract any users. Using a big API like .NET is a lot easier with autocomplete and built-in documentation. 
Why are you testing across multiple versions of Ruby for a Rails app?
Bundler has a grander vision of what a gem sandbox should be. For me, Isolate has a few show stoppers. The biggest being the lack of SCM support.
I have. Laying out the GUI was fun without a visual designer. Basically, I used the GUI editor for C# and then I translated that output into Ruby form. That's basically what is missing. The visual designer. Working with .NET libraries was a breeze and enjoyable.
I was wondering what all those gists you were posting were about. Good stuff!
Thanks! I should probably clean up my gist list though. I think I have too many. :-(
I cannot stand that font that you use for headers. Sorry, but the content is good though.
Nobody cares. 
So, Perl isn't actually dead after all those mass hypnotic delusions incantated by Python programmers? That's cool!
**Do not take this as a statistic for overall use of programming languages.** There are several different version control systems with a decent community to them. So, for example, C/C++ is much stronger on sourceforge.net. Ruby on Rails' official source repository has moved from Subversion to Git. Pythons source is still on Subversion. *just to name a few big and yes, I am aware that I mix VCSs with VCS-based community websites* 
http://github.com/gitpan
Not only that, but GitHub supports svn. Your point stands, regardless.
Good thing the article is titled "GitHub Stats on Programming Languages" and not "Statistic for Overall Use of Programming Languages".
I would love to work with you.
Can we see some of your works? (I'm not available, I'm just very curious...)
Ideas are cheap, implementations are where it's at. What are yr ideas?
I'd give it a try. How big is the project? 
sounds good, PM me. Edit: I'm retarded, it's 1am. PM sent.
you seriously want people who are unable to follow the simplest install instructions to use ruby? downloading an installer or running 'sudo apt-get install ruby' is not the highest entry bar ever
An argument can be made about an over abundance of choice in ruby but this article doesn't really make it. 
+5 years experience in ruby/rails. developed about 10 big webapps. i love compass. so whats the deal?
&gt; downloading an installer or running 'sudo apt-get install ruby' is not the highest entry bar ever Thank you for showing exactly why it's hard to get into programming languages: **People who already program can't see with new eyes.** AKA: You're being disingenuous. That isn't the only thing required for someone to get into a Ruby project.
&gt; simplest install instructions For me this means "click on setup.exe". A terminal command is not *simple* if you don't already know how to use it. This elitism is just retarded. The more the merrier.
what terminal command? on windows you just click on the installer, the only choice you ever get is the version of ruby you want, but that's not something that you can dumb down I mean with python you also choose between python 2.x and 3.x, plus there are the alternative interpreters, etc. and if you're on linux and it hurts to use a packet manager, install windows (and oh yeah, you might have to add the interpreter to your PATH if you want to run stuff linux-style, but that's more of a windows convention than anything)
to be fair, knowing how to program, and knowing how to use your operating system are two different things.
&gt; People who already program can't see with new eyes. Bullshit. Some of them can't, but some haven't lost their sense for these things.
I know how to install things, thanks. I'm programming. You perfectly outline the problem: &gt; and oh yeah, you might have to add the interpreter to your PATH if you want to run stuff linux-style, but that's more of a windows convention than anything "Obviously", the PATH! We know what it is, how to use it, etc. Not everybody. Especially newcomers. At some point I didn't know what the PATH is, and the same goes for you. We have to learn that at some point. Hence the "entry level" problem.
From an evolutionary perspective, ruby is growing and mutating at a fantastic rate. This is annoying right now, but once a selectivity function comes through, the species will come out stronger than those which limit their mutation.
Overabundance of choice is a valid concern but this article is horrible at showing it. Is installing ruby such a big problem? Windows: Download and click setup.exe Linux: apt-get install ruby How hard can this be?
This only happens on systems without a package manager... otherwise, It's certainly in your PATH.
This is why projects like Hackety Hack are so important. (Disclaimer: I'm the maintainer)
Are you looking for contract work, or just to collaborate on a project? 
You're right, I should have prefaced that with "Most".
That *isn't* hard, but it also *isn't* the only step required to actually get into a Ruby project.
What are your letters doing?
What is required? What is your definition of a Ruby "project" To run puts 'Hello World' you just need the ruby interpreter. You don't need RubyGems or source control. You have to draw the line somewhere. Programming is not for everyone. You have to make some assumptions. Assuming your users are able to manage their own systems by installing software or using the command line is a good thing here. Hackety Hack is a good thing because it's written to be used as a teaching tool. You can make different assumptions with it. You can assume a user has not programmed before and might not be up to par with system maintenance. My point is that you can't expect a programming language such as Ruby, being a language that is not primarily a teaching tool, to start at the level in which you assume no prior knowledge of computer operation. Just my opinion.
ruby = not enough choice
Hello world isn't a ruby project, not even slightly, and it's disingenuous of you to say so. It's even more disingenuous to suggest I'm saying that we should assume no prior knowledge of computer operation.
Sent this to my fiance
You seem to like that word. Projects come in many many different forms. I could use a more involved project that doesn't need anything more than the interpreter itself, but the point I'm making still stands. Edit: Btw, you still haven't mentioned what you think is required. It would help me (and others) understand your point of view. This isn't intended to be a flame war.
Huh. Wonder how well this would have gone over with my last ex. She was an artsy type, so While I mentioned my programming stuff I never got really in depth with it, j ust vague "Ye gods this assignment is complicated" rants. Though I did once discuss which languages I knew with her father, which impressed me because he was a drummer and owner of a tiny record label, not that technical.
Super awesome post.
I love programming. There are moments when I'm doing something fun like playing a game and think, "Damn, I think I'd really like to be doing some hacking right now." Programmers are passionate about seeing an idea in their minds and then coersing a computer to see that vision perfectly. Pixel perfectly. Programmers are like demi-gods of their own little worlds. And I'm guessing most would love for a partner to sit down and just watch them working on their current masterpiece, if only for a few minutes. Ask your partner to show you something simple and basic, something visual, so that you can see how they progress from step-to-step on their digital "painting". I bet it would totally make their day and you might understand what they do -- just a little better!
Thanks! :) 
Ya, great post. Why didn't you submit it to r/programming though?
I sent it there as well. Submitted it here too because it applied to Ruby in particular, but it's also on proggit :)
This is extreme overkill for this small script, and I especially hate their abuse of method_missing for such a small code savings. The problem with tutorials is that they're usually either so trivial that the method demonstrated isn't worth the hassle, or they're so complex that it's easy to get lost in the problem domain and overshadow the technique. I'd be willing to give the author the benefit of the doubt and assume it's the first case, but then he says: &gt; In fact I've been able to use that parsing code in 3 other Rake tasks ... which leads me to believe this isn't just a demo. My rule of thumb is: if I'm doing the same thing more than once, I should think about abstracting the logic. Sometimes it's so easy I don't even think about it and other times the cases are different enough where I'd rather just get it done than shave my yak all day. If the author has 20-30 of these classes to parse and stuff into the database maybe this level of hackery is called for; for 2 it's uncalled for.
Thank you.
:) We'll see if I deserve it on Whyday, eh?
Another clue from IRC: http://pastie.org/1087414.txt?key=buofeehkddu74klbsdmraa
You are awesome. So is my wife of 13 years. Thank God for people like you.
This guy is a lucky bastard. I hope you understand how rare you are. You take an interest in programming, you like games, you're pretty, and you can fall for a geek. This is an exceedingly rare combination (I'm 38... I've been looking for a little while, and I'm no slouch myself), and I'm a little jealous, having to have contented myself over the years with either "the hot one" or "the smart one" depending on the relationship, never both. Not to mention, most of the guys marrying all around me are marrying women who do not entirely understand them. One guy has to confine his gaming to wednesday nights and saturday mornings because his new wife *hates* gaming. Another guy doesn't seemingly have any interests in common whatsoever with his lovely wife except for compatible personalities. A third couple is the classic stereotype of "guy watches sports; woman makes up the home". Hell, my parents, who are still together, seem to have only 1 thing in common- a little gambling (and, of course, mutual respect). The one woman who I had a ridiculous amount in common with, the one I tried so hard to make work because of it... That fell apart due to her crippling insecurity. I concluded from that experience that "things in common" was a nice-to-have and no longer a relationship requirement. I think that if you're a guy passionate about something like programming and/or gaming, a woman in your life who understands this a bit is a *massive* asset. Did I mention I'm a little jealous? ;) So I think that instead of wondering why more women don't take a deep interest in their spouse's livelihood, you should instead count the both of yourselves very. damn. lucky. TL;DR: Fucking love Ruby, never ever met a girl who even heard of it except for [Amy Hoy](http://vimeo.com/1104149) from the Rails community, who pretty much fits the expected stereotype of "female programmer". 100% of the people at any ruby or rails event I go to are men (railsconf the exception). If there is 1 woman, she gets to feel uncomfortable...
We've known about these issues for years now. What's new about using :include ? Not to mention you talked about the select * issue but I didn't notice you using the :select option to winnow the select down.
Just a follow up. I'm moving to Phoenix, AZ. I'm leaving this weekend. I accepted a position at a very good rate with benefits, and I'm looking forward to working with the crew out there. The interview process was fun, and if the coder I did remote pair programming with was any measurement of the quality of the rest of the team, I'm going to enjoy my work immensely.
Thanks for the follow up, and good luck in Phoenix! 
Its even easier in linux because you don't have to download anything.
You only have to set there path on stupid operating systems like windows.
I have used method missing on occasion. Mostly to "memoize" functions. In other words instead of using method missing all the time I use method missing to build functions on an as needed basis so that subsequent calls to that function have proper end points. This is a better use for method missing and it's faster too.
Show me a project you can work on that only needs the interpretor? Ruby projects need a host of things: Git, any number of gems, test gems, usually an IDE... The barrier to entry is larger and bolder than it should be.
You're hung up on big projects. No one starts out with Ruby contributing to an established open source project. Hell, not everyone starts out with source control. Test::Unit is bundled with Ruby. You don't need to install anything extra. You just have it. A new user doesn't even have to care about the debate over TestUnit and RSpec. By IDE, I assume you mean a text editor. A user probably has one they like already. It doesn't even need to be fancy. I think you're falling in your own trap of "People who program can't see with new eyes." You aren't seeing Ruby as the language. You're seeing Ruby *and* the set of common practices. Those common practices don't even come into play until a new user has learned enough of the language.
Hmm, perhaps I am. But I still think it's not as easy as just installing Ruby. It certainly never has been when I've seen it started.
So perhaps the problem is the starting tutorials that are out there. Maybe they do too much at once. Thinking of something like "Try Ruby".. it doesn't even require an interpreter download. It does walk you through the basics of the Ruby syntax so you get a feel. A starter tutorial that covers syntax and *maybe* touches on TestUnit would be ok. It wouldn't require anything external and it gets the idea of testing in early if you included the TestUnit stuff.
I think you're setting your standards a bit too low. Any programmer should be able to figure that out.
A better tutorial would indeed be a sound response, regardless of who is correct (if that even applies here).
Nah, I don't think "correctness" is an issue here. Discussion can only make things better as a whole :)
I agree with the comments on the commit log, it should be "_utf8" rather than "utf8"
[It's snowing again!](http://github.com/rails/rails/commit/c49144b2f7b2cb9b59ea3a9cddd69de47f268ae6)
Is there an actual reason for this change? I loved the snowman. And the glyph they've replaced it with requires an extra character (okay, that's a rather small complaint, but I'm sad!)
Yaaay!
circle jerk!
People freaking out along the lines of "WTF is this snowman"
Quality article. The depth is appreciated.
I hope this results in some ridiculous pissing match where they switch back and forth, culminating in adding some UTF8WidgetSelector component for Rails 3.1.
"This commit breakes a lot of things. Like my day and your sense of humor for instance" - Best comment in that thread
Why aren't you using polymorphism or single table inheritance? It seems like a lot of extra work for nothing. Can you imagine how complex this will get on full project?
The only difference between this and the last release (p429) is a fix for [a security vulnerability in WEBrick](http://www.ruby-lang.org/en/news/2010/08/16/xss-in-webrick-cve-2010-0541/).
upstart is a better bet if you are on a distro that ships that out of the box. runit is also good.
What's the plan for tail call optimization?
another quick reference: http://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals#The_.25_Notation http://cheat.errtheblog.com/s/ruby_percent/ 
While I like Chronic, for heavy date processing (say hundreds of thousands or millions of dates), it's (anecdotally) about 30 times slower than Time#parse in Ruby 1.8.7. If you are taking input from users, it's wonderful, if your batch processing something in a more consistent format, beware. 
Less complex than STI, that's for sure. Start here: http://rhnh.net/2010/07/02/3-reasons-why-you-should-not-use-single-table-inheritance
Hey, isn't that the guy that temporarily fucked over a bunch of people by deleting his online repos without warning or explanation? Let's all idolize him now!
everybody matters. besides, even if _why is less relevant as a rubyist than he once was, his wonky bohemian style is a form of poetry that stands on its own.
I wonder how many people would idolize him if they had to go through a lengthy dev cycle with him on the team. 
The code in chronic is _horrible_ and not tested very well at all. I would never use it in production. 
Fact: \_why was actually Larry Wall. Perl6 was delayed for ten years because Larry was working on Ruby all that time. Larry deleted all of his \_why persona when someone uncovered his identity by correlating headers in old usenet postings.
TL;DR Use the [mysql2](http://github.com/brianmario/mysql2) gem. Upshot is increased performance and better encoding compatibility. (see inside link for interesting details and history)
He was a very vulnerable genius who was only protected by his alias/alter ego. Once that was violated he was of course going to book out. It does suck that he left all his interesting projects behind. When a person feels violated, they tend to flake out like that. I did manage to have 1 bizarre/lovely email exchange with him before he disappeared. I wish I could buy him a beer and coax him back out somehow. :/
I think the photo of him making crybaby faces at babies is hilarious.
Rubyists don't have lengthy dev cycles.
You're right. I bet he could drive you insane in a single sprint. 
Considering I've inherited a ton of his code... I think I'd be okay.
I know I miss him, and I haven't been in the ruby community for years. Just in case you missed this: http://www.smashingmagazine.com/2010/05/15/why-a-tale-of-a-post-modern-genius/
No that's not the guy at all. This guy helped millions of people by giving them lots of free code, tools, and documentation.
upstart indeed looks quite nice, but isn't yet that widely used. Anyway, both of them are more designed to replace your system's /sbin/init. The daemontools on the other hand co-exist with whatever init system you are using.
Fine, toss out STI. Why aren't you using polymorphism? That's much cleaner and more natural than what you've done here.
Shortly after _why disappeared, I had a very vivid dream that I ran into him in a bar. We spent the whole night drinking and talking, and explored every topic in the universe. At the end of the night, I said “hey, let’s stay in touch” and he said “no.” Then I woke up. :(
It's not his code that would drive someone nuts. His projects are excellent, but there's a fine line between cute and painfully obnoxious, and he walks it with a dangerous teeter. He also strikes me as the "fragile flower" type of person, and many people simply have no patience for the fragile type. They can be tough to put up with in a team setting. Of course, this is all outside perception. People can be totally different in different settings. Maybe he would be the ultimate team player, even if he seems off in his own personal la-la land when it comes to how he presents himself to the Internet.
Point taken.
His code was some of the most high quality that is out there. Apparently, Shoes his GUI toolkit is still the best way to write GUI programs with ruby.
Does upstart restart your deamons if they crash? 
You beat me by two seconds. Dammit. ;) I saw this hit [ANN] and was refreshing http://www.ruby-lang.org/en/news/ , but it wasn't there. Oh well. I'm excited! Everyone can really move to 1.9 now!
I'm pushing to try to get Ruby (and maybe even Hackety Hack, eventually) used by my alma mater, and I'm encountering some resistance, due to Java static typing love. We'll see how that goes.
... and Policeman gets released tomorrow! /shamelessplug
rvm update --head &amp;&amp; rvm reload &amp;&amp; rvm install 1.9.2 &amp;&amp; rvm 1.9.2 --default :D
A text-processing app I wrote runs ten times faster in ruby 1.9 compared to 1.8. If you haven't started using 1.9 yet, get on that!
How did we ever live without rvm?
Debian is the *only* officially supported system? Are they serious?
Here's a [diff of what changed between rc2 and this release.](http://gist.github.com/536152)
That's one more officially supported system than most programs.
Mmmm stick with ree or make the switch.
Officially supported in this case means "it's the only system we have continuous integration machines running on". Most of the core devs are running it fine on the "Best Effort" systems, but they don't have the hardware to run a half-dozen continuous integration environments.
I'm guessing it will work just fine on any typical Linux distribution.
rvm means not having to choose!
3 lines of text, a ton of ads. --CLICK-- 3 lines of text, a ton of ads. --click-- 3 lines of text, a ton of ads. --meh, close tab--
Yep, I detest about.com
They should consider adding some Fedora boxes to their CI. I know not everyones favorite distro, but installing/running 1.9.2(-rc*) with RVM was smooth.
It might also get 1.9.2 into Debian's Stable Packages repository a bit quicker.
What are you looking to do with Ruby? If it's web based work then looking into [ruby on rails](http://rubyonrails.org/) and learning that is a good start. There are loads of resources for learning rails. Once you've got the basics down then [railscasts](http://railscasts.com/) is a fantastic resource for taking the next step and learning specific skills. [Peepcode](http://peepcode.com) is another. Peepcode screencasts will cost you a few dollars but they are well worth it. [Rails forum](http://www.railsforum.com/) is always full of helpful people. I got in to Ruby through the rails route so my suggestions are obviously biased in that direction! 
Cheers for the tips! Well, I'm an undergrad scientist at the moment. So ideally, I'd like to be able to use Ruby for non-online stuff as well. What d'ya reckon? Are books still worthwhile, what with the wealth of online stuff available? If they are, can you recommend any in particular? I'm also trying to find ways of getting involved with existing web stuff as quickly as possible - to help me learn and gain confidence. Any ideas? 
This book [Learn to Program](http://www.pragprog.com/titles/ltp2/learn-to-program-2nd-edition) was written for you. It's not as jazzy and irreverent as one of Why's masterpieces, but as a practical starting point I've not seen better. Enjoy Ruby!
I'm releasing a new version of Hackety Hack in a few minutes here, it's just for you! http://hackety-hack.com More to come when I'm not frantically updating things.
Awesome! Can anybody tell me what's new in Shoes 3? Or point me at a link to a summary?
learn to use irb and love it. Your code is executed immediately, line by line. Whenever I'm programming some large project and I have a question in my head about whether something will work or not, I try it in irb. Another thing to watch out for, 0 is true in Ruby, where it's false in alot of other languages. (only false and nil are false here). I even opened up irb right now to make sure I'm not lying to you.
Mostly stability fixes and bugfixes. I found the changelog on github, I think that's the only place it's hosted at the moment. From the [changelog](http://github.com/shoes/shoes/blob/master/CHANGELOG): **Policeman** 17th August, 2010 * Move to Ruby 1.9.1 * General stability improvements * Updated all dependancies * Ported OSX to Cocoa * Now works with Windows Vista and Windows 7 
brettbender is correct, but I figured I'd give you an orangered. There's a few other changes as well that I forgot to put in the changelog. bloopsaphone is now included by default, for example. A major part of this release was simply that it's the first release since _why left. Getting everyone organized, getting stuff updated for new platforms, and the Ruby 1.9 move were the largest parts, by far.
AFAIK, books are still the way to go (at least for me). Not so much a good book to learn programming, but an excellent and very thorough book with a 'how-to' approach and also dives into the philosophy of Ruby: The Ruby Way. It's definitely my favorite one and you should get it even if you already know some Ruby. A more beginner's level book would be Programming Ruby: The Pragmatic Programmers' Guide. I heard it's very good for a start, but I've never read it.
Learn to Program is good is a good book, I liked the style. Once I got more into Ruby I enjoyed the Apress 'Beginning Ruby Book', it presented a lot of nice features of Ruby and is perhaps a little more accessible then the Programming Ruby book by Mats.
irb is fantastic for learning and answering "I wonder if..." questions. I almost always have it (or its rails cousin ruby script/console) running when I'm writing code.
To learn more about Ruby you need to learn more about programming in general, too, so you might want to brush up on the foundations. For example, the [design patterns](http://www.amazon.com/s?search-alias=stripbooks&amp;field-isbn=0201633612) book is applicable to any object-oriented language. Parts of that come into play in Rails. The fastest way to learn is to solve problems. Trawl [Stack Overflow](http://stackoverflow.com/) for questions you can answer, or are interested in answering at the expense of some research. You'll learn a lot more than a self-directed study. Teaching like this is a great way to make sure your own knowledge is solid, too, as you will get fast feedback on any advice you've given, good or bad. Challenge yourself. Try different problem domains. There's a lot of different ways to program, and to be effective you can't be a one trick pony.
wow Thank you! I love Hackety-Hack! 
Thanks! Give me an email when you've played with it some more, and let me know how I can make it better.
I enjoyed the post and have bookmarked your site for future reading. I am also 2/3 through reading "Metaprogramming Ruby" and it is easily one of the best books on Ruby ever. It is sure to become a classic. It has THE best discussion of eigenclasses, method resolution, and the inheritance chain that I have ever seen. Excellent reading, and really good, truly pedagogic code examples. 
"Matz", and I read Pickaxe, as I think everyone else should.
Upvote for Learn to Program. I give it to all of my friends interested in getting into programing, and it happens to be centered around my favorite language!
You need to learn ruby before delving any deeper. Ruby on Rails, ruby's absolutely fantastic web framework, is a mouthful and without a solid background you'll feel hopelessly lost. [Try Ruby](http://tryruby.org/), if you haven't already, and [go from there](http://lmgtfy.com/?q=ruby+tutorial&amp;l=1). I came from the same background as you (HTML/CSS with javascript re-gigging abilities) and just launched my first full scale rails project this summer, and I'm also doing my undergrad! Let me know if you get stuck on anything.
* Definitely buy a Book on Ruby ([Learn To Program](http://www.pragprog.com/titles/ltp2/learn-to-program-2nd-edition) or any recent O'Reilly Ruby Book). * Avoid Ruby 1.8.6 like the plague, it's slow and goofy compared to some of the more recent versions of Ruby. if your on Linux or OSX you probably can easily install 1.8.7 or maybe 1.9.1 (if your on Ubuntu). I like using the [Ruby Version Manager (RVM)](http://www.pragprog.com/titles/ltp2/learn-to-program-2nd-edition) which makes installing Ruby and Gems muuuch easier. * Play around in IRB, test your assumptions about how Ruby works in there.
Without a solid background in programming I agree you could get lost in rails. But I wouldn't say your ruby knowledge needs to be particularly strong to start learning rails. If you can code another language then ruby isn't hard. Far from it - it's a pleasure! I found rails was a nice gentle introduction to ruby. Rails relies heavily on DSLs (Domain Specific Languages) which keep things really simple and intuitive. The next step with rails and ruby comes when you want to write your own gems or plugins and you start playing with the dynamic nature of ruby. But 99% of the time you don't need to take this step. As for another book recommendation: [Ruby Best Practices](http://blog.rubybestpractices.com/posts/gregory/022-rbp-now-open.html). A great book (and free!) but again it's probably best saved for once you've got a little experience with the language. I didn't learn to program with ruby so can't really say what's good for that, other than the obligatory pickaxe which everyone buys.
Make that a +1 for the design patterns book (or "gang of four" book as it's more affectionately known). If you take pride in coding elegant solutions to problems rather than just hacking out the first thing that works then that book will be like porn to you! Probably the best book on programming I've ever read. At the time I read it Java was my passion and it didn't matter a jot that all the examples in that book are in C++. Its genius goes beyond the programming language and the ideas it champions will (99% of the time) work in any language.
Good stuff. I've considered getting his book. [These](http://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming) screencasts are also quite good.
and my [teach yourself ruby the hard way](http://zem.novylen.net/ruby/tutorial/arithmetic-quiz/arith.html) tutorial is intended as a followup to the book.
If you eventually get into rails, check out the [Agile Web Development](http://www.pragprog.com/titles/rails3/agile-web-development-with-rails-third-edition) book
Why do we need this? I use ruby because I don't want to worry about garbage collection.
Is there bug submitted for this? You're right though, this does imply it's not "production ready"
all software has bugs.
reproduction?
This is a new one to me. Could you enlighten us with an example?
Debian screwed the pooch on this one (at least in Squeeze). For some reason, they packaged 1.9.2 as 1.9.1 and now RubyGems wont work. Grrr!!! Beyond that though, I hear 1.9.2 is great. Yea!!
Can you give us the sales pitch? Why should we use camping instead of sinatra, padrino, ramaze etc.
so what's new? :( debian has historically been antagonistic to the way ruby does things.
If you're running on macos, use rvm install 1.9.2 --enable-shared=yes to enable CarbonCore (for sass et al).
You need this because your poor code can still create leaks.
That shouldn't be possible. 
But it is! Memory leaks are NOT the fault of the language or GC (they can be, but that's irrelevant). They are the fault of the programmer, who has a part of the code, that is long forgotten, that still holds on to a couple objects.
I would say one of the best books you can get starting out would be what is lovingly referred to as the 'pickaxe book' by the ruby community ("Programming Ruby" from The Pragmatic Bookshelf http://pragprog.com/titles/ruby/programming-ruby). Also, another book you may want to check out for a rather animated introduction to Ruby would be _why's Poignant Guide To Ruby (http://mislav.uniqpath.com/poignant-guide/). These two will definitely get you rolling. Note that Ruby has two main versions out in the wild under heavy use: 1.9 and 1.8.7. Those who use 1.8.7 are mostly those who are using Rails &lt; 3, but since Rails 3 is going to be compatible with 1.9, you might as well concentrate on 1.9. If you have an issues or questions about Ruby, there are tons of mailing lists, IRC channels, and sites out there that can help you out, just google your questions and you're bound to find them. Hope this helps. Have fun!
I think something that's particularly interesting to bear in mind is what you want to use it for. If you found the aesthetic of the ruby community attractive and that pulled you in, then it's a valid selling point. I mention this because I had a similar interest a few years back in ruby and _why completely enthralled me but since I was still in senior school and we didn't have any programming courses anyway to speak of, I found it hard to think of things to do with the stuff I would learn in tutorials, which I felt was a very quick demotivator. So if you have a particular idea for a web application, for instance, try to use ruby as early as possible to write it, just so it feels like your learning has a particular goal. If you're short of ideas, since you mention you're an undergrad in science you probably have a project or something you'll have to code in C++ or Java or some other godawful language. If you have the time to spare, try rewriting it in ruby completely, from top to bottom. It might even earn you an extra mark or credit or something. Point being: have a goal in mind or you risk losing track of why you want to learn how to program in ruby in the first place and you'll make so much more out of the books you find.
It's never good when a large group of people gangbang a poodle.
Use `rvm`.
Difficult to take this advice seriously if you say something like "C++ or Java or some other godawful language". Don't preach language hate. Java and C++ are awesome in the space they operate. Understand and respect the tools, not "hate" them just because it's cool. Peace.
As an example, throw this in your rails request: (Thread.current[:actions] ||= []) &lt;&lt; action_name It's not a leak in the sense that there are blocks of memory haven't been explicitly freed, but you are still chewing up memory that you might not have intended to. 
Oh I completely understand the advantages of C++, which is the language I use in school and I'm terribly sorry if it came off as language hate (what a pointless concept). But I guess I have a more retracted perspective because I'm an EEE student, not a Comp Science major. I despise C++ because of the handful of projects I was forced to do in it. We made some neat things but it just didn't click in my head like it might with a computer scientist or software engineer. I'm much more at home with a more human readable language like Python and for hobbyist things I enjoy the clean syntax of ruby. I never had to use Java though, so my criticism is overstretched there, I'll admit. I tried my hand at building a fairly simple Android app I needed though and I think I passed out trying to understand nested classes so I just wrote a web app in ruby instead which served my narrow purpose just as well as a native Android application. EDIT: mm, I'd like to apologise if I came off as pedantic before but on reading the OP's link, I saw a number of things I could relate to from personal experience.
The desert color scheme is better...
It can, yes.
[Learn to Program](http://pine.fm/LearnToProgram/), by Chris Pine. Hands down the best programming book there is!
Most of the time memory leaks in garbage collected languages are the result of circular references. This happens when two objects point to themselves. ex.: # Create circular references Ref = Struct.new(:obj) a = Ref.new b = Ref.new a.obj = b b.obj = a a = nil b = nil # Force GC to run GC.start # Check to see that the objects are destroyed (and they aren't) ObjectSpace.each_object(Ref){|o| puts o.inspect} OUTPUTS: #&lt;struct Ref obj=#&lt;struct Ref obj=#&lt;struct Ref:...&gt;&gt;&gt; #&lt;struct Ref obj=#&lt;struct Ref obj=#&lt;struct Ref:...&gt;&gt;&gt; 
Have a look at [Sinatra vs Camping](http://librelist.com/browser//hacketyhack/2010/7/20/on-camping-vs-sinatra/).
MRI/YARV have conservative garbage collectors, not precise ones. This code is most likely targeted at users of those (overwhelmingly common) implementations.
If you're using a language with a conservative collector, it's your fault for writing code that generates memory leaks. That said... they're still in part the fault of the language/GC when the collector is conservative and doesn't pick up all the dead references it theoretically could. We shouldn't take any pressure off of the Ruby devs to figure out a solution to this one. See rhythmx's post below - with a precise collector, that code would not result in a leak.
So... yeah. If the GC is supposed to do its job but doesn't, then yeah. It needs to be fixed.
And where is it, please? The links on the linked to page do not work.
Some categories of garbage collectors (`conservative` collectors) rely upon algorithms that are incapable of finding all dead references. Precise collectors do not suffer from this issue. That doesn't mean that conservative collectors aren't doing their jobs, it means it's job doesn't catch all dead references by design. Ruby's garbage collector - if it were completely bug-free - gets tripped up by cyclic references, and it's "doing its job" just fine.
You're right, I forgot about the cases of cyclic references, although that was not the case that was presented in the example, which is what I was discussing.
That's only a problem if the VM uses reference counting. Ruby uses mark-and-sweep and can collect circular referenced objects just fine. Your result is probably caused by other things like temporary references on the C stack that haven't been cleaned up yet. Try this instead: # Create circular references Ref = Struct.new(:obj) 1.times do a = Ref.new b = Ref.new a.obj = b b.obj = a a = nil b = nil end # Force GC to run GC.start # Check to see that the objects are destroyed ObjectSpace.each_object(Ref){|o| puts o.inspect} This outputs nothing on my machine.
I think you're mixing things up here. Rhythmx's post speaks of circular references but he's wrong, conservative garbage collectors handle circular references just fine. It's reference counted garbage collectors like the ones found in Perl and Python that suffer from the inability to collect circular references. What Ruby's conservative garbage collector suffers from is dead references on the C stack, or data on the C stack that *look* like references to Ruby objects. When programming in Ruby the programmer has next to no control over what's on the C stack and therefore your statement "If you're using a language with a conservative collector, it's your fault for writing code that generates memory leaks" doesn't make any sense. In fact, it is found that compiler optimizations play a more important role in maintaining dead references; i.e. turning on compiler optimizations can leave more dead references behind on the stack because the compiler thinks it's being clever by not zeroing the stack so often. Normally this would be true, but not for Ruby. It should be noted that the MBARI patch set, as incorporated in Ruby Enterprise Edition (and partially incorporated in later versions of MRI 1.8.7) uses a variety of techniques to wipe the stack once in a while in order to clear dead references. This significantly reduces the number of uncollectable objects while retaining the conservative collector.
Just a little footnote: It's not really a problem if the VM uses reference counting either, because a reference counting collector will be backed up with a cycle collector. It's not a "true" garbage collector if it doesn't handle circular data.
Nice article. Even though I find the part where the JAVA programmer is concerned about the speed of Rails a little ironic - made me laugh a little.
Generally, Java's run speed is getting better and better, it's just the startup speed that sucks. The solution is to keep HotSpot running between processes, so that you're not starting up a new one on every request.
Yes, people should remember that the fastest ruby is JRuby!
At the moment. I have high hopes for RBX.
Awesome idea... I wonder if parts of it shouldn't be incorporated into the core... assuming the appropriate changes could be made to get it to match the existing spec. 
Also check out http://github.com/rtomayko/date-performance
so do i! :)
Yeah, fuck those debian dudes and their silly "policies". Who needs stable, correct systems with automatic dependency resolution and safe upgrades anyway? It works on my laptop.
you can have a perfectly stable, correct system by installing ruby as a monolithic packge, the way the language expects, rather than splitting it into a bunch of components. it won't break correctness, and it won't break dependency management.
Please just fucking die already. Ruby 1.8 will be the death of Ruby. It continues to hold back the entire ecosystem.
&gt; As always, you install this latest version with: gem install rails --pre And of course update your Gemfile to: gem "rails", "3.0.0.rc2" and $ bundle install They always leave out the bundler stuff.
Probably because YAML isn't a configuration file format to begin with. YAML is a "human friendly data serialization standard for all programming languages".
And yet configuration is the primary use of it.
It's always possible, depending on what you consider leaks: $myglobalvariable = .... reference to some Ruby object that indirectly references all kinds of other things.. ... do stuff ... here I think I've dropped all references, but I haven't - they're still referenced via $myglobalvariable ... do more stuff. Oops, ran out of memory because $myglobalvariable prevented lots of stuff from being GC'd. Mistakenly retained references can easily become a really big deal in large, long running programs unless you're very careful about nil'ing out references to objects you no longer care about. 
Actually, the primary use of it is, you know, store data.
It's not strictly a configuration format, but yes it's one of the main uses for it. Although it is missing from the spec, it's fairly trivial to do if the parser implements YAML 1.1 Language-Independent Types tags (check out http://yaml.org/type/index.html, at the end of the list).
Just a friendly reminder to the downvoters of this guy's post and comment. [Reddiquette says](http://www.reddit.com/help/reddiquette): &gt; Please don't: &gt; &gt; * Downvote opinions just because you disagree with them. The down arrow is for comments that add nothing to the discussion So feel free to downvote my comment. :-)