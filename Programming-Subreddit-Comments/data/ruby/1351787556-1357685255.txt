I second this
I've burned by enough gems introducing non-backwards compatible changes in minor versions to never trust it or bundle update. Even thoughtbot is guilty of this with changes to paperclip.
I don't, since it's confusing as hell to non-english speakers (ie rest of the world). Also, might get you in trouble with HR if you ask another female employee to take a look at your spermy operator...
VIM with tmux. Use it for all my text
rubymine
Seconded. My most productive Ruby environment ev4r.
Definitely RubyMine if you want an IDE to help you learn Ruby. I also use VIM but that's another rabbit hole you don't want to be in when learning a new programming language.
&gt;Do you run into lots of work when you have to update any gems, having to figure out for yourself what dependent updates need to be made (without breaking dependencies of siblings)? Or has it not been a problem? Yes, even version problems that bundler can't solve. I have even had to hack in a specific version into the Gemfile.lock because gem authors create strict dependencies that weren't necessary. &gt;You can of course also 'twiddle wacka' to the patch level, not allowing minor-level updates in your spec, but still allowing patch-level updates. I have seen major refactors end up in a patch version, so experience has taught me to not trust it from most gem developers. All said, I trust bundler to do this for me as far as I can throw it.
Startup time matters extremely little in the grand scheme of things. How often do you start Rails?
SublimeText2
+1
Every few seconds -- each time I save a file in my application. Actually I'm using guard and spork. But if you are not (or something similar like zeus), and you are constantly running tests/specs then the start-up time matters alot.
Vim for all my program. SublimeText2 under windows. You might want to use SublimeText2 if you aren't familiar with vim because of the cross-compatibility.
Second this. Jetbrains IDEs are pretty amazing.
I used to use Aptana, before I switched to a terminal-as-ide workflow using `vim`, `tmux`, and others. Aptana is good software, as is RadRails. It's just a shame that after being bought out by Appcelerator they gutted it for Titanium Studio and abandoned the Rails bits.
Vim + many plugins for ruby/rails 
I'm loving this setup. My standard is to create two windows in Tmux. I load Vim in one and use Vim tabs and windows (and nerdtree for directory browsing) for all my text editing. In the other I use multiple Tmux panes for executing shell commands and ongoing processes like Shotgun for Rack app development. As a bonus it's super easy to store all your config files and plugins (.tmux.conf, .vimrc, .vim) in a remote git repo and pull them down whenever you're on a new machine.
You should give Tmux a shot, it'll eliminate the need for multiple terminals. Edit: a good place to start http://blog.hawkhost.com/2010/06/28/tmux-the-terminal-multiplexer/
A proper tiling window manager (e.g. i3) facilitates a very clean IDE-like setup with terminal on one side and GVIM on the other. Files to edit can be put into tabs or whatever configuration is most useful at the moment.
Wow. Going to a Starbucks to try this
I work in Bioinformatics. This is very useful!
Could someone then theoretically attack your account to generate tons of images on the fly using the lazy load capabilities to exhaust your limits prematurely? I mean, someone could just script some random combinations of transformations and force the images to be created to run your uploaded images and storage limits into the ground. Is there any sort of security mechanism in place to prevent this sort of thing? Google Maps for instance uses signed URLs for its static maps images and geocoding in its enterprise package, where URLs are created and then signed using a secret key that they provide you.
+1
Engine Yard is a PaaS that specifically caters to Ruby applications. What better way to get the Ruby community engaged?
Does this mean refinements are most likely here to stay? I remember them saying at one point it was possible it was going to get pulled before the 2.0 release.
I've been using [redcar](http://redcareditor.com/). It's written in (j)ruby and you can write plugins in ruby for it. gem install redcar It's not released stable, but I haven't had any problems with it. Looking at the development, it's beginning to stall a bit.
Does this come with news about ruby and threading?
Is it possible to install this with rvm? 
ruby-build already has it, so you can install and use it with rbenv.
me too
Good point, thank you. I will be sure to include it in the next article of the series.
rvm get head &amp;&amp; rvm install ruby-2.0.0-preview1
I'm a big fan of these changes, especially the named arguments. The options hash convention has been an ugly workaround for this missing feature for too long now. Another change I'm looking forward too will be the [improved garbage collection](http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0). I hope we can start seeing some other major performance improvements too - if V8 can make javascript performance improve as much as it has in the past few years, I'm sure we could see the same thing happen for ruby.
What about all your gems? What if you need the file system.
+2
&gt; if V8 can make javascript performance improve as much as it has in the past few years, I'm sure we could see the same thing happen for ruby V8 has Google working on it full-time. Even though Google employs Guido von Rossam (creator and maintainer of the Python language) they don't pay him to develop CPython or Jython or anything, he just works there providing his expertise. Is there an equivalent company behind Ruby (YARV, JRuby, etc)?
Ruby's a lot of fun, but I tend to avoid it for anything over 100 lines or so because it's just not easily maintainable. The refinements change and the keyword arguments both are contributing to change that, which makes me rather glad.
http://sciruby.com/blog/2012/09/24/sciruby-receives-ruby-association-grant--fellowships-available/ If you can have an application by Monday or Tuesday, we'll still accept it. Later if you were involved in any natural disasters this last week, just let us know.
heroku employ matz and one or two japanese core members
One thing i really want, but doesn't appear to be in Ruby 2.0 (?) is `Enumerator#+` and `Enumerator#last` :(
Seems odd to say anything over 100 lines is unmaintainable. We have several high end public facing sites scaling out to millions of pageviews with tens of thousands of lines of ruby/rails code. It's extremely maintainable and we continue to extend them every week.
Macvim works
That was two years ago and I don't remember high-profile discussion about the implementation when it was merged into trunk. Have you seen any newer discussions about it? I believe some of his concerns were addressed (`instance_eval` I believe), and I don't remember seeing much noise about concurrency (which is weird given how many thread-based libraries have become popular). Or maybe I didn't pay too much attention.
I assume you're referring to this ` #6670: str.chars.last should be possible`. I looked at issue `#6670` and it's just they're making `str.chars` return an array in 2.0, not that `Enumerator` will support `#last` unfortunately :(
That's odd...I didn't take a look at the issue before I posted but since `#chars` currently returns an `Enumerator` I just assumed. Not sure why it was accepted so hastily, seems odd to break a clean API for something that already had a very well-accepted alternative (`string[-1]`). Seeing as they've implemented lazy `Enumerator`s the absence of `#last` is more understandable.
You look nice too, the beard is very classy.
Tenderlove replied to me, I can die happy.
Lucky bastard. I'm too busy with school and poorness to attend one
If you're trying to make a statement... This isn't really working.
I make the assumption that you are the requester on the other side of this nonsense, if that is not the case, then take no offense, because this message is not intended for you. ------- This isn't funny, it's pathetic. We're adults, not children; I presume from your 'pull request' that you don't care for haml. Good, great, neither do I -- but guess what, only one of us is a Jack ass in this scenario, and looking in my mirror -- I don't look much like the donkey. All you're doing is wasting this maintainers time, and reinforcing the notion that the Ruby community is a bunch of brohards who drink their Natty Lights and talk about how cool they are and how much they can bench. What your doing is not helpful, not funny, and you should be ashamed of yourself. Now go back to the shore with the rest of your orange ilk and think about what you've done.
For those curious about this like I was, these are the relevant sections for how Celluloid provides mechanisms for you to do so: https://github.com/celluloid/celluloid/wiki/Linking https://github.com/celluloid/celluloid/wiki/Supervisors https://github.com/celluloid/celluloid/wiki/Supervision-Groups
But did you eat Tenderlove's meat?
I'm so jelly. My best friend is there right now, having a great time, and I'm stuck at home. :(
`ActiveModel::ForbiddenAttributesProtection` ? I think I'm going to have to read up a bit more on that. Also: gonna be noping right out of turbolinks too
Nice shirt!
so was I :-)
47 years old? Guy looks like he's 25!
Can't you create something like a class in JavaScript by using dictionaries though?
Dang, I even thought about making a post on Thursday night to see who I could meet up with.
the guy is a php developer. so he likes php, but hates haml. and has bad taste in jokes. i don't think he and i can be besties.
looks like Nutter is still concerned about it, has not signed off on it, hasn't had time to look into it yet, and didn't realize it was a done deal for 2.0 until just now. http://www.ruby-forum.com/topic/4407408 Last comment on issue from Matz recently, looks like he is aware of problems and considering, but still wants to put refinements in. http://bugs.ruby-lang.org/issues/4085#note-109
Kate.
Kind of off-topic, but it really bugs me when someone poaches a Github username just so they can have a fancy subdomain.
This page is unusable on a Mobile.
Is this supposed to be satire?
Seems pretty cool. Hate the presentation though. That style is really annoying to me (slides with single images, catch phrase or a meaningless question, arrows to move around, choppy).
thanks man, I've been looking all over for that!
Hugs are for Python lovers (Not an actual fact).
But it's so simple it doesn't need tests?
Ahhh, I see your reasoning. Absolutely, then. You can do that already, though, with hashes in the signature. I wonder if I'm just looking for reasons to hate keyword arguments, but I also think that if you use them as symbols/hash in the function body, then they should be symbols/hash in the method signature.
didn't rails do the; http params are also ruby params a long time ago?
You might want to install the preview locally too: http://coderwall.com/p/tptocq 
any of `users`, `products`, `orders` can be actually slices shared between N Espresso apps. You just do like this: app = EApp.new app.mount Users app.run Espresso is a HTTP tool, it has no idea about databases, migrations etc. It is a courtesy of ORMs 
1. Install the [Ubuntu Ruby 1.9 packages]( http://lenni.info/blog/2012/05/installing-ruby-1-9-3-on-ubuntu-12-04-precise-pengolin/). 2. `gem install rails`. 3. Make sure your home directory is on it's own partition, so your code can survive re-installs. 4. Host your Git repositories on [GitHub](https://github.com/) or [BitBucket](http://bitbucket.org/). 5. `git clone` the repositories and run `bundle install` with in them.
Simply [install RVM](https://rvm.io/rvm/install/). Try to use Ubuntu packages as little as possible as they quickly run to a brick wall against RVM and gem.
just do whatever you did on the first machine, and then check your project out of git on the new machine?
This can take over Sinatra.
Having watched Padrino stabilize, it's going to be a while before Espresso works out all the kinks / loose-ends.
@waxjar, regard HTTP verbs, you do not like it cause it is unusual for you, so it was for me, but in short time it turns out it is a really easy, readable and memorable way to define request types. Regard path params, seems you missed the point. Path params are the params that goes before `?` sign, not after. And they are accessed via arguments. def edit id "id = #{id} and params = #{params}" end # GET /edit/100?foo=bar # will return # id = 100 and params = {:foo =&gt; :bar} More details [here](https://github.com/slivu/espresso#natural-actionroutesparams) Regard speed, i did not compare to Cuba. See the [comparison with Sinatra and Rails here](https://github.com/slivu/espresso#performance) What's the overhead added by Cuba? Espresso adds about 0.2ms overhead, so on a HelloWorld app it will perform at (1000ms / 0.2ms) = 500 requests per second. 
A fraction of those downloads are thanks to web crawlers that ignore `robots.txt`. I'm a bit sceptical that actual people downloaded the [80ae2fe5c929b7d0a00bdee2d710fa9e](http://rubygems.org/gems/80ae2fe5c929b7d0a00bdee2d710fa9e) gem ~900 times.
Hey aradabaugh, I'll see if I can help you a bit with this. You say you're new to Ruby, so, my immediate response that I did a 37 minute presentation at this year's RailsConf regarding some of what you're mentioning (http://confreaks.com/videos/900-railsconf2012-how-to-find-valuable-gems). Primarily, that presentation talks about finding and evaluating gems... hopefully it's useful to you. If nothing else, go see The Ruby Toolbox (https://www.ruby-toolbox.com/) and crowdsource your knowledge. So, I do recognize your point and issue with naming. That's one of my biggest concerns with Gems - and one that's not simple to fix. Gems are required to have globally unique names to be useful (you can kind of get around that with custom gem hosts, but that's beyond your questions). That means that someone came up with a library that did a task (say authentication) and named it something. Then dev #2 came along and tried to make it better for vary it, and since Naming Is Hard™, often dev #2 will simply name their new library with a varient of the original gem's name. And in most cases, the first name wasn't great anyway. The problem simply compounds. So, RubyGems ("gems") are simply easily distributable Ruby libraries. They provide some extra meta data about the library (version information, other gem dependencies, summary, author info, etc.) Often a gem's scope is very focused, the functionality is very small, and the concerns - if written well - are very isolated. A gem, by itself, is not your application. It is simply a bit of code to do some certain task, hopefully well. This idea is spread pretty much across all other languages with Perl having CPAN, Node has NPM, Python has PIP, etc. Ruby certainly wasn't the first, and absolutely will not be the last implementation of this idea. Now for your Bundler questions. I mentioned that gems names are unique. When you install gems, at its most basic level, you'd "gem install bundler" (to install Bundler). But, typos are often an issue... so at some point, someone has name squatted typos of popular libraries. You noticed that with "bundle." If you look at the bundle gem's details (https://rubygems.org/gems/bundle), it has a runtime dependency on "Bundler" and the author has left a kind note. If you trust him, then it is just a friendly way to install bundler for you when you have a typo. If you don't trust him, maybe he's installing malware on your machine when you typo. ;) Honestly, I've never seen that happen. But it's possible and will likely happen some day. Some gems install executables, like Bundler which installs "bundle." Some gems are simply Ruby code that gets required into your application. If you use Bundler and define a gem dependency in the Gemfile, then Bundler will often require the library for you. This is the case when using Rails, which has a dependency and uses Bundler and Gemfiles. It's pretty simple to see what a gem does. Just go to Rubygems.org and search for it, or just make the URL yourself: https://rubygems.org/gems/GEMNAME. You'll immediately get an idea of its dependencies, usually a link to the source which is often on Github anymore, often it'll have a link to the documentation, and author or description information. I hope that helps. Certainly let me know if you have more questions about it.
Ah. I missed the Builder part. Builder is an XML builder that uses nested blocks to generate the final XML documents. Rails has used it for a long, long time via the actionpack gem. And, if I'm not mistaken, DHH made followup library for JSON, I think, which builds JSON in a similar manner. You may recognize: xml.user do |user| user.name "Nate" user.username "nathanielb" end That's a builder construct.
I don't like how HTTP verbs are done, because it's easier to implement a method that isn't prefixed, which will respond to *all* HTTP verbs, which is wrong. In a framework like Sinatra, this is impossible to do without defining that route multiple times. The reason this worried me is that nearly all examples show non-prefixed methods, DELETE requests will respond in the same way as GET or POST requests. I didn't miss the point about path params. The path of an URL is the path to *a resource*. Sorting options and the like don't change the resource itself (just it's appearance), so they do not belong in the path. Cuba's speed tests are [here](http://files.soveran.com/cuba/#9). I don't know if they're comparable at all or how they're executed, though. An article that helped me enormously is [Nobody Understands REST or HTTP](http://blog.steveklabnik.com/posts/2011-07-03-nobody-understands-rest-or-http).
tbh, i think you are right about "accepting everything" actions. At the very beginning i were thinking about making verbless actions to answer only to GET requests. Seems i'll rethink about. Thank you for precious feedback. Are you the author of Cuba? I were playing with it too before decided to go with Espresso. 
&gt; As of 1.9 the GIL (Global Interpreter Lock) is gone! But it’s only been &gt; renamed to the GVL (Global VM Lock). This sentence is a bit confusing. First you way it's removed but then you mention it has simply been renamed. It would be much better to either leave it out alltogether or just say "As of 1.9 the GIL has been renamed to GVL". &gt; Another important note is that the Ruby GC is doing a really horrible job &gt; during this benchmark. The reason for it doing so "bad" makes perfect sense and isn't entirely just a fault of the garbage collector. What you're doing is filling up an array with 51 million instances of `Object`. In this case the GC most likely doesn't know how to clean up the memory since it might still be used somewhere (I'm not entirely familiar with the inner workings of the GC).
Cloudinary includes measurements for handling potentials abuse or attack attempts (like any web service or application should). In addition, while dynamic URL-based transformations are very powerful and make like easier, Cloudinary supports enabling 'Strict Transformations' so users can access only images of allowed transformations or ones generated through an authenticated secure API. This blog post shows some examples: http://cloudinary.com/blog/how_to_quickly_build_a_stock_photo_site_using_cloudinary 
The bit about the GIL doesn't make any sense. Ruby 1.8 never had a GIL: it was userspace threaded. Ruby 1.9 is the first version that is natively threaded, but had a GIL. The Ruby authors call it the GVL but it's the same thing.
Yes. Rubygems.org is to 'gem' like what the Debian APT repository is to 'apt-get'. Developers upload their gems to rubygems.org so that users can install it with 'gem install whatever'.
We can compare to the number of debian users or php developers but ruby is catching up... :) 
With being able to subclass Java classes now, does that mean that a ruboto app would have full access to the entire Android API? If this is the case, what limitations does ruboto currently have for Android development?
You're completely right. That's exactly the GC behavior that is expected here. GC can (and should) only clean up stuff that is no longer reachable. The program in question puts all those objects in top-level arrays, making them reachable all the time.
I don't know about any current limitations, but since Android classes can be directly subclassed, you (should) indeed have full access to the API.
Does that really happen very much?
thanks for the benchmark. I think the to_i and the comparison are NOT very expensive, but what Range#include does is not a #to_i and a comparison, but actually doing #succ a bazillion times, each time asking "is it equal now"? I suppose the cheap way to use the range would be: ((IPAddr.new(x).to_i)..(IPAddr.new(y).to_i)).include? IPAddr.new(z).to_i But at that point it's confusing enough that you might as well write just write your own object to encapsulate it. I am not sure this is a bug to post to ruby core -- it's known, although not liked, that Range#include is slow for anything that's not "numeric". The question was really to some extent about how much of this stdlib documentation is actual contract or formalized as a spec, if the meaning of "numeric" cross-rubies is actually spec or implementation dependent or what, if you can actually count on this part of stdlib being predictable. I suspect not, in addition to being pathologically slow in MRI. (5 seconds for 10000 iterations? half a milisecond for one range check,which is pretty bad ... and would got a worse proportional to how large your range is, if you wanted to check a larger range it would be proportionally worse (trying to do it myself, I actually can't manage to make it check a larger range, at some point IPAddr#succ is failing! Now _that's_ a bug to report if i can track it down) 
is there anyway you could give me example starting code to head me in the right direction, if not it's fine and thanks so much for your comment this is a problem I want to solve!
yep, agreed, very convenient, worth pointing out, thanks. But for me, like i said, &gt; If your range is expressable as a CIDR, IPAddr will do it for you `IPAddr.new("192.168.2.0/24").include? IPAddr.new("129.168.2.12)`, but I don't always have that situation.
There's a truly enumerable [IPAddr](http://ronin-ruby.github.com/docs/ronin-support/IPAddr.html) in [ronin-support](https://rubygems.org/gems/ronin-support).
couldn't find the class looking around the github, direct link might be helpful to others. But my 'truly enumerable', do you mean that #succ actually works? I was annoyed that it didn't seem to in IPAddr (unless I mis-interpreted), but that's not actually the root of my problem, since using Range#include? in IPAddr's is bad anyway, but fortunately Range#cover?, as someone else suggested, is exactly right (and doesn't depend on #succ working). If you actually wanted to step through all IP's in a range (I don't!), you'd need it to work though, and _is_ annoying when the stdlib is broken. If you have a fix, considered submitting it as a patch to ruby core?
Actually here's some code using the List Comprehension monkey-patch from [combinatorics](https://github.com/postmodern/combinatorics#readme): def split_ip(ip) ip.split('.',4).map(&amp;:to_i) end def ip_range(ip1,ip2) split_ip(ip1).zip(split_ip(ip2)).map { |a,b| a..b } end ip_range(ip1,ip2).comprehension.each do |a,b,c,d| puts "#{a}.#{b}.#{c}.#{d}" end range = ip_range(ip1,ip2) octets = split_ip(ip) octets.each_with_index.all? { |octet,index| range[index].include?(octet) } 
ah, you are indeed still expanding any nmap-style range to the full array of elements in range, which is exactly what I don't want to do! But useful algorithm for interpreting * and -, which indeed I'll want (and I forgot about -). Cool, thanks. 
This makes me happy. One less gem to add to each project :)
+100 karma points on /r/ruby thanks so much, you really are helping me make this solution tangible.
I wrote one called Utopia and since I'm biased I think its pretty sweet :D
JRuby is packaged into another app, [Ruboto Core](https://play.google.com/store/apps/details?id=org.ruboto.core), so different Ruboto apps share the same VM, but it *is* pretty slow to start up, still.
[Dragonfly](https://github.com/markevans/dragonfly), handy for data uploads, thing I most like about it is the on-the-fly image processing, while only saving the original file until any other formats are needed.
Is there a directory of Gems out there that a n00b developer like myself would find incredibly useful?
https://www.ruby-toolbox.com/
this was x-posted from proggit, where I saw it. Not sure about the etiquette of cross-posting, if someone thinks I shouldn't have done it let me know! But I think twitter saying they can handle a lot more traffic on java than they could on ruby is a claim of interest to the ruby community (and the java community but i'll let them fend for themselves :) )
This is pretty old news... they moved their backend to Scala a few years back. Much of the frontend web stuff is still RoR. It's really just a case of the right tool for the right job. The other side of the coin is that if they had started out using Java for everything, they probably would have run out of money before they had an MVP. It's also important to note that part of the issue is the implementation of MRI; JRuby wasn't mature at that point (2008 or so), and MRI was on &lt; 1.8.7. So it's not like anyone (including Alex Payne) is saying using Ruby was a mistake; Twitter just outgrew the limitations of Ruby as it existed at the time.
Agreed, but you can get those for Rails apps off-the-shelf from Heroku (their Postgres service has been extremely reliable, and more dynos roughly translates to more uptime and more performance), and you get those for much less than the opportunity cost of learning and building with languages and frameworks you don't know.
Danke!
looks useful. ImageMagick / RMagick are great, but the setup is time consuming.
If you need any help, feel free to contact me.
if anyone's curious, here's the convenience class I ended up making for my own use of IPAddr ranges. https://github.com/jrochkind/ipaddr_range_set Thank you to those who gave tips here. 
One of my favorites: s = "hello" s[/(?&lt;doublel&gt;ll)(o)/,:doublel] = "R"
The idea behind Ruboto is good, but performance seems to be a real problem, at least, for me it is. Could work for pet project but certainly not professional apps.
Slides at: https://speakerdeck.com/jeg2/10-things-you-didnt-know-ruby-could-do
This and the rest of the Aloha Ruby Conf videos are [on Confreaks](http://confreaks.com/events/aloharuby2012). Well, technically the videos themselves are on YouTube, but Confreaks is a much nicer way of finding them. :)
I'm not sure wrapping workers with restart and isolation semantics is the same thing as stability. Last I checked once a request is dispatched to a worker dyno, if it blows up, it's gone. Maybe that doesn't matter if the transaction is indempotent, you can just refresh the page until you find a worker that's up, but otherwise you lose information. The only way around that is opportunistic clustering, where multiple dynos get a single request and the first one who answers wins. But that's not exactly efficient or as scalable as having reliable processes in the first place. Postgres doesn't really factor into it unless the source of your instability is in the driver or the db. But in that case I would hope competent engineers would have run detailed profiling to figure out the problem rather than just shift languages. I am curious if twitter had problems with stability in just ruby or if rails was a factor?
With `nanoc` and NearlyFreeSpeech.net is it even easier and maybe cheaper to set up and host a blog - I've paid a couple of usd cents for my blog and it's fast. `nanoc` is better than Octopress because it is less magick and more control (but I understand that taste differs). If you are new to ruby or web it's a great way to learn, and if not you'll be up in less time than with octopress. But it's fun to read how others do it :) 
Funny that you mention opportunistic clustering, that's what Riak does with a read quorum of 1 :) The reliability issue might not just be dropping requests, but the time and cost of restarting Ruby instances. A performing app server like unicorn would help, but why not just move to languages with better tools for eliminating crashes and controlling memory usage?
Here's his talk about "~~10~~ [42] Things You Didn't Know Rails Could Do": http://www.youtube.com/watch?v=GRfJ9lni4QA And the slides: https://speakerdeck.com/jeg2/10-things-you-didnt-know-rails-could-do
Well, I guess that is the point. But to be fair to Ruby, when I dug into the details of this mess, it's a lot harder to find root causes and "technical truth"... A couple surrounding observations: * the rock-solid db platforms we've mentioned (Postgres, Riak) aren't implemented in Ruby. * Unicorn's [feature list](http://unicorn.bogomips.org/) reads like a laundry list of curatives for every bad thing that can and does happen in a Ruby process -- but that isn't necessarily Ruby's fault, I'm more inclined to blame Rails or devs for this. Along the lines of blaming devs, the initial story of Twitter's move back in 2009, was [heavily critiqued for poor implementation](http://www.unlimitednovelty.com/2009/04/twitter-blaming-ruby-for-their-mistakes.html) and not Ruby. And Scala isn't free of it's own problems as Coda Hale [pointed out a year ago](http://codahale.com/the-rest-of-the-story/). His 'brutally honest [response](http://codahale.com/downloads/email-to-donald.txt)' has a lot of interesting details that you only discover when you actually *work* with a language and libraries in a production context. The question of "is it the language or is it the library support?" comes up. And then there was the community attitude, which immediately recalled my experience with RoR: &gt;We had some patchwork code where idioms which had been heartily recommended and then hotly criticized on Stack Overflow threads were tried out, **but at some point a best practice emerged: ignore the community entirely** *[emphasis mine]*. Not being able to rely on a strong community presence meant we had to fend for ourselves in figuring out what "good" Scala was. (In Rails, we call such behavior "opinionated" as an excuse for a certain breed of *anti-social intellectual laziness*. (i.e. we don't need to respond to legitimate problems in adoption because they are *your* problems, not ours.)) I can imagine that such pressures might have pushed Twitter away from Ruby initially. Interestingly, [a post this year](http://stackoverflow.com/a/9749305/555187) explained that TDD also was not enough: &gt;...[Scala has compile-time checking, something that] interpreted languages cannot provide... A quote from Dikstra in Programming in Scala illustrates this point: "testing can only prove the presence of errors, never their absence". As their application grew, they ran into more and more hard to track down bugs [ed: which as the first critique mentioned might well have been the devs, not the language]... so they made the switch. Ruby-core has typically been much more mature and stable about things than Rails (read: "less opinionated" and more engaged with their community). I view Rack and things like Sinatra as backlashes against the chaos of Rails that have also ironically improved Rails -- which brings me to the main thing: all software is evolving within this ecosystem. Step back and look at the 4 years that have elapsed since this controversy started. These technologies aren't static, they rise to their challenges. Constructive criticism and contrast has IMHO improved the language scene for everyone. So I welcome accounts of actual production experience with any of these tools, but avoid reading the wrong conclusions about adoption from them. I tend to side with Hale on his closing: &gt;So. &gt; &gt;Should you use Scala? Is Java better? &gt; &gt;(You’re asking the wrong questions.)
I probably should have substituted "might have" for "probably would have." Java is "not that bad" compared to C, sure. But bootstrapping a web application in Ruby/Rails is often (I almost said "usually") orders of magnitude faster than in Java. Especially looking back to 2008, when Spring was the go-to framework and (IIRC) Play didn't even exist yet. As another commenter pointed out, Twitter's RoR code wasn't even _good_ RoR code. And back in 2008 the framework itself was a bit of a mess. Every Rails developer should check out José Valim's [presentation on the rafactoring that went into Rails 3](http://en.oreilly.com/rails2011/public/schedule/detail/19579). **tl;dr premature evil is the root of all optimization.**
yeah, I think the stuff described in the OP is somewhat unorthodox use of celluloid, you don't usually need to use the mailbox directly, you usually use higher level celluloid constructs, like async method calls with `actor.async.method`, that the OP doesn't mention. Plus, if you want the "world" actor to wait for "hello"... then wouldn't you _want_ it to block waiting for 'hello'? 
Hi, OP here, The mailbox functionality is suggested in the documentation when referring to protocol interaction. https://github.com/celluloid/celluloid/wiki/Protocol-Interaction Since the point of this exercise is to synchronize between two actors, you need more than 'fire and forget' by using 'async. If you think there is a higher-level construct In Celluloid that can achieve a synchronized 'Hello, world", then you are very welcome to fork my gist and submit a new comment for further discussion/integration. 
If you also want inherited ones, minus the clutter that all objects have, you could also use this: class Object def meths (methods - Object.new.methods).sort end end class Class def meths (methods - Object.methods).sort end end
I do the same thing, but I call it local_methods.
Yep Agree. Map will give it in a nice way. 
That's fine, but what exactly is your point? Feels more right? Because apart from that it's longer to write and also a little bit slower: class Object def meths1 (methods - Object.new.methods).sort end def meths2 (methods - Object.instance_methods).sort end end 1.9.3p0 :014 &gt; Benchmark.measure { 1000.times { 2.meths1 }}.real =&gt; 0.3160519599914551 1.9.3p0 :015 &gt; Benchmark.measure { 1000.times { 2.meths2 }}.real =&gt; 0.3251168727874756 Not that such a difference would ever count anywhere.
As you said, that difference would never count anywhere, but it's not even a reliable-- when I run it on my machine, I get the opposite result: 1.9.3p194 :012 &gt; Benchmark.measure { 1000.times { 2.meths1 }}.real =&gt; 0.18368840217590332 1.9.3p194 :015 &gt; Benchmark.measure { 1000.times { 2.meths2 }}.real =&gt; 0.18336057662963867 But again, it's completely negligible and would never be a reasonable optimization. Using Object.instance\_method feels _a lot_ more right, because you're using the reflection API for reflection and you aren't instantiating an object you'll never use. If you'd rather go with something "shorter" than something "right", I'd hate to work with you.
I hate this "gets the job done" attitude. It's shit. It's the attitude of someone who doesn't think about the future. It's the attitude of someone who doesn't think that code maintenance is a thing. It's the attitude of someone who doesn't care about doing things properly. It's the attitude of someone who has no standards. I'd hate to see the code you write. Doing things the right way and doing them quickly is not mutually exclusive. A person who does things the right way is open to improvements. It doesn't mean that upon writing `o.new.methods` they would then spend 3 hours searching for a better way. It means that if someone told them a better way, they wouldn't argue. In a way, you can't take criticism. 
either way, I don't like having to remember every time I type a command in the shell if it's a command provided by a rubygem and thus i need to prefix it (even with just `be`). Although I guess if it's doing anything to or with my ruby project, that generally means it needs the prefix. But it's a difficult problem to solve, and like I said, I think could only possibly be solved by tighter integration between bundler and rubygems (instead of bundler being an add-on tool rubygems is unaware of), and even so would be tricky. But yeah, command line executables installed by rubygems are _already_ wrappers installed by rubygems that call out to code in a gem installed in the gems dir. It sure seems like they could be bundler-aware executabes that looked for Gemfile.lock in working directory (or parent! Don't forget to look up the parents!) and automatically called the _right version_ if so. 
Upvote for confreaks. Amazing service to the community, especially all of us who don't go to the events.
Not really a case study, more like a commercial.
This dude is awesome
Extra context about the project: I started it because there are no decent linters out there that do more than complaining about coding style issues. The closest I could find was [Laser][laser] which hasn't been updated in over a year. I also couldn't really make any sense of the code. I've been working on this for the past four months and it's finally starting to take some shape. Keep in mind that there are lot of things that it doesn't handle yet. For example, calls to `define_method` and `attr_accessor` will be more or less ignored by the code that builds a list of definitions. I plan on addressing these issues in the coming weeks/months. I'd also like to ask people to give it a spin and submit issues for any problems they might encounter or suggestions/requests they might have. While there are already quite a few tests there's only so much I can come up with myself. In case the README isn't clear enough I'd like to point out that Rlint is still in the very early stages. Code will change and there's a big chance that code you're validating will result in invalid errors/warnings being added. Note that for the time being you'll need to install the gem as following: $ gem install ruby-lint --pre [laser]: https://github.com/michaeledgar/laser
Also saw it at Magic Ruby, and it convinced me to switch to Vim. "Dang, look at him go"
&gt; The deprecated rake/rdoctask.rb library has been removed. RDoc supplies its own rake task now. Hmm, I _think_ I have code that uses this and gets no deprecation warnings. But I could be wrong... either way, does anyone want to look up and post here the `require` line for the equivalent rake task from Rdoc?
I like this. I don't even care that it implements something that every ruby programmer should know how to do. Just curious: any plans on writing tests for this? How would you do it?
Also, COOKIES! def from_the_police? true end https://github.com/kyledrake/running/blob/master/lib/running.rb#L66-68
Wait... Why did seeing vim wizardry convince you to switch to Sublime? I wanted to switch to vim after I saw Ben's talk at Magic Ruby but I still can't configure vim right so I'm sticking w/ Sublime for now. edit: I just switched to vim.
It's a good presentation, but the value of duplicating the standard Range lib seems dubious in this case. 
Page seems to require login to Heroku sadly.
He defines: attr_reader :contact This generates a read-only method for you: def contact @contact end ...using this will project intention to only want to read from that variable.
100% agree! I am a Java programmer by trade (that is slowly injecting JRuby/Rails apps into our environemnt MUHAHAHA!) and I have been following these principles for quite some time. It seems to me that good OO design principles sometimes take a back seat to the "Oooo, shiny functional programming" aspect of Ruby in a lot of cases. So, presentations like this are quite refreshing.
I think it's because he had attr_reader on contact
&gt; I feel that we should be getting to the point where we can grok selects, maps, and reduces directly without having to extract small chains to methods. Yeah, at some level I appreciate being able to figure out how the rubber meets the pavement without having to drill down through several methods and classes, but if the same set of selects, inclusion checks, etc. are being duplicated in multiple places, it makes sense to pull them out.
Not sure yet. If Travis has a special environment var that shows the platform independently, that would work.
~~Did you forgot to release it to rubygems.org?~~ Never mind, I see you've added the part about "--pre" to the readme.
Note: I'm currently working on having a `type: image` using http://aa-project.sourceforge.net/aview/ as seen here http://superuser.com/questions/378786/is-it-possible-to-view-images-in-a-terminal More seriously I'm also looking into having a `type: terminal` to open up a repl live and `type: command` to do some command and display the output.
&gt; The closest I could find was Laser which hasn't been updated in over a year. I also couldn't really make any sense of the code. I lol'd. I went to school with the guy (kinda). Good friend of mine. Laser was his senior thesis which started as wool which was a linter for our project amp. He now works at Gizoogle and since he codes fulltime, doesn't do much programming outside of work.
Its pretty cool. You might also think about some basic markdown formatting, using terminal control codes, so people can easily do bold/italic
I see, thanks for clarifying!
It would simplify an awful lot. Redcarpet with a custom renderer would work very well for terminal
Awesome, came to the comments to ask about repl but you've already answered it!
Very nice. I am going to use this ASAP. repl is going to make this killer!
it could show the matrix screen for slide transitions!
Repl is in: https://github.com/krainboltgreene/termnote/blob/master/example/slideshow1.yaml#L24 Version 1.1.0, which is already shipped.
There is a similar project created by Xavier Noria https://github.com/fxn/tkn.
I can highly recommend using TermNote with the cathode monitor emulator for OS X http://www.secretgeometry.com/apps/cathode/. If your users aren't deeply touched by seeing an ascii presentation in a cathode emulator, they have no soul. Or they are to young to remember cathode monitors.
Man, I arrive at these suspicions all the time when I'm writing class method APIs. Didn't know if dropping into an instance like that was janky or not (or more/less janky than my class method "refactoring" from the article), so it's nice to see this post. Now I can instantiate with confidence. However, can't you memoize with class methods anyways? def self.render puts keywords end def self.keywords @keywords ||= get_keywords end
Transitions are definitely a feature to come.
Mind if I yonk some of this?
That will run get_keywords every time you use Foo.render as there is no instance to store the instance variable to. With class methods like @@keywords it would work, but they aren't considered to be very elegant.
Sure there's an instance, there always is, but in this case it's an instance of Class, and as oqa pointed out that will cause this value to be persisted across requests.
Babney is correct, but here's a bit more of an in-depth explanation. These subtleties are what really differentiate Ruby from many other languages, and can be difficult to wrap your head around at first. @ variables always refer to the current context's _instance_. Say you have a class A. In A's body and class methods, it refers to A itself, which is an instance of Class. In instance methods, it refers to the method's receiver, which is an instance of A. @@ variables always refer to an instance of Class. In A's body and class methods, this is again A itself. In A's instance methods, it refers to the instance's class, which is of course A. So @ variables behave a bit like @@ variables when used in a class body and class methods, but they are not completely the same. @@ variables are shared with sub-classes (think of them as _protected_ class variables) while @ variables are not (think of them as _private_ class variables). They also do not share a namespace, so @@var and @var never refer to the same variable.
haha, of course not
Really not sure what this has to do with class methods. If you're using an OOP language, passing mutable shared state around between calls, you're gonna have a bad time. The whole point of OOP is to encapsulate that shit. Write nothing but C for a week and you'll never make this mistake again. Also, I'm all for sharing techniques, but jesus. Taking a method and breaking it into smaller parts doesn't need a damned name other than "Good Engineering". Having a lexicon like this only serves to confuse people starting out because they're being fed "greek" and completely alienates anyone trying to assess the skills of a programmer if they're not one. This is why that $250/hr consultant that just got hired, and knows things like "Single Responsibility Principle" and "Extract Method Technique", is still figuring out how to commit to your repository.
Now if they only fixed the bug where #fetch with a default value modifies the Hash...
really? 
Really https://github.com/rails/strong_parameters/issues/56
There are a lot of existing continuous integration servers written in ruby https://www.ruby-toolbox.com/categories/continuous_integration. It's even possible to write jenkins plugins using ruby https://github.com/jenkinsci/jenkins.rb. Why do we need another one solution? What is it better in?
I should've probably mentioned that I got similar results: old links with either very complex or non-desirable solutions. I am just wondering if JRuby could be an option. Another option I am considering is a VM running linux.
What about IronRuby? At least according to [this StackOverflow question](http://stackoverflow.com/questions/3327437/ironruby-on-rails-with-iis-7#3327996) it's possible.
I'm going to try to answer my own questions and see what kind of feedback anyone gives me. So the workflow is: rvm gemset create some_name; rvm gemset use some_name gem install some_software rvm gemset export some_name.gems And reinstall: rvm gemset import some_name.gems So another question: rvm can export a Gemfile thusly: rvm gemset export Gemfile and then install with bundle. What's the preferred method? I'm guessing the Gemfile technique since bundle has options for executing code in the context of a Gemfile.
yep, that's what I was going to say. Although I don't know "should", just that it's another option. But it'd probably be a pretty neat to rig it up so it used VCR on the development machine -- but intentionally skipped the VCR and ran live on CI. Plus, then if something does fail in CI (live), you can compare the current live response to the VCR recorded response, and see if it broke because the third party API change, and exactly why/how. 
Don't do this. It will kill you, and it will hurt the whole time you are dying.
Well, that would be around IIS.
Yes, you can do JRuby + Tomcat behind IIS AFAIK. EDIT: Here you go: http://stackoverflow.com/questions/1086994/instructions-for-setting-up-iis-and-jruby
Thank you! 
If you're only writing whole-stack tests they won't give the kind of rapid feedback you need to easily and successfully refactor. I've worked on code with only high-level tests and it is typically very messy. I'm unsure how they can maintain any kind of momentum without unit tests.
We use JRuby+Warbler+Jetty (give client a .war file, he drops it into a folder and restarts Jetty) and it works just fine (you'll need to tweak rails a bit to run migrations on boot, you'll need to be thread safe!, and maybe something else - can't remember). edit: Talking about hurt, it was a pain for a while before we patched various JRuby networking, jruby-rack and Rails thread safety bugs. But if you have simple/classic rails app, it should work without issues.
We’ve been looking into VCR, but for our current remote specs we decided to simply skip them on the development machines because they test functionality that rarely changes. But we will consider VCR for future specs for sure. @jrochkind: That’s a good point, I haven’t seen this advantage before!
I seem to remember this as well.
yeah, I haven't actually heard of someone setting things up before so that VCR is in the project and cassettes are checked in -- but is skipped on CI. But it seems like a great idea to me. I'm not entirely sure how one would set that up, but if you figure it out you should add it to the VCR wiki -- and if you have trouble figuring it out, ask on the VCR listserv, the VCR author is pretty helpful. Also, it's very straightforward to add VCR to existing specs, you wouldn't need to rewrite them or anything, just wrap em in VCR. That's the amazingness of VCR, your specs/tests stay exactly the same just wrapped in a VCR block, and they now use recorded HTTP responses instead of contacting the server live each test. I kind of love VCR. I actually use it for tests against code where the third-party API requires a paid subscription to use, and not all developers (of a collaborative open source project) have access to it -- but they can still run the tests with VCR. 
This is a real-world example of how this simplifies your code when using conditional arguments: https://gist.github.com/4088602 improve readability, reduce human-error. *Take the edge off.*
I feel like "debugging with Robert Downy Jr" is a reference to the "A Scanner Darkly" film he was in. intentional?
Seems way too outdated.
I would love to get an updated overview like that one. I'm pretty confused about the subject myself.
Thanks for the update!
Passenger can't really be compared to mod_php. mod_php runs in-process to the apache server so all php apps share the same memory and run under the same user account. Passenger is more like fastcgi or even slightly akin to a free frontend proxy - one apache/nginx server running passenger can front many applications running under different user accounts and therefore separate protected memory and file permissions. I love passenger for this, and when I can't use something that does privilege separation elegantly (e.g. hosting plain old PHP or mod_perl apps) I inevitably set up a reverse proxy and run each app in its own dedicated mini-apache. The benefits of a frontend proxy with backend apps running in seperate user accounts can't be overstated. You get security and many different levels to tune if you need. Passenger is awesome. Also, passenger standalone uses nginx under the hood.
Kind of missing all of the JRuby options, most notably http://torquebox.org/
Writing request specs as your only method of integration tests can be a bit overloaded. For me, the fundamental definition of integration tests is to ensure that components between systems are hooked up correctly. If you are testing scopes on a model, you are testing your integration with the database and ensuring the interface is correct. An integration tests is not limited to a request, it can be done on any level. When you have higher level specs, often requests specs, trying to test integration at all levels you'll run into too "unit" integration test, which is a integration test that test a simple user interaction with the site. For example: * A user logs in, performs a search, assert the right search result appears, and log out. * A user logs in, sends a message to another user, assert the other user received that message, and log out. * A user visits the site, uses cool javascript widget, assert form submits correctly, and log out. * etc... These are often described as the happy path for a user, but these are usually happy paths defined from an acceptance criteria from a project manager. In a perfect world, these are the Cucumber friendly written specs. The problem that occurs is the setup and tear down of a request spec is very expensive. I've started taken a new approach, a colleague of mine refers to it as the "common path". When you visit Reddit, you login, check your messages (maybe), click on a bunch of links, make a random comment, upvote, etc. All in one user experience, the common user experience. Now you can move more specific integration tests to lighter weight layers, controller, views, javascript, and model tests, and this can be faster. Fast tests suites are not mythical, following this approach and rigorous refactoring and object isolation, we've had fast tests. We were able to run them our dev machines and have great instant feedback. Please keep in mind this practice takes discipline from the start. Refactoring a large test suite with this principle can be over whelming because you feel that you are getting rid of large chunks of request specs that are testing elements that are not tests on lower levels of integration (controller, javascript, model, etc). Confidence is always key.
To start, read The Pragmatic Programmer. A unit test should cover just one thing. You should test each path through the method, including edge cases for branches. Unit tests only test the local behavior. Behavior from calls to other methods are ignored. This will help you avoid over-specification. Methods should be small, more than a dozen lines is a code smell for both tests and implementation. Adding more tests has rarely reduced snappiness for me. One has 1750 tests and still has annoying gaps in coverage that slow me down because they don't catch me when I forget about other parts of the (large) project. (The test suite runs in 10-20 seconds, but isn't a rails app)
https://github.com/charliesome/racer DAT graph. I haven't tried it yet but it looks to have potential.
You're probably OK, but I'd advise you to offer `strong` and `em` in addition to `b` and `i` or have your code translate directly instead of mapping `b` to `strong` and `i` to `em`. There are some [semantic differences](http://html5doctor.com/i-b-em-strong-element/) between the units of each pair. 
...wat
What's wrong with nil?
8/10 times nil is better replaced with a null object that has sane defaults.
I'm really curious what you mean by this, I've never had any real problem related to nil. If it's causing you that much trouble, there's probably something about the way you're writing code that could be addressed, instead.
nothing, but it can show up when a noob doesn't expect it. Have you ever seen "undefined method 'foo' for nil:NilClass"?
My point is that someone new to Ruby or programming isn't going to think about that.
[How and Why to Avoid Nil](https://www.destroyallsoftware.com/screencasts/catalog/how-and-why-to-avoid-nil) if you're DAS subscriber.
Do you have enough tests? Automated tests help with nils a lot.
AST looks good. Parslet has [example on repeating whitespace](http://kschiess.github.com/parslet/get-started.html): rule(:space) { match('\s').repeat(1) } rule(:space?) { space.maybe }
Now I do. I decided to try TDD a while ago and have found it very valuable. If nil is a shadow monster, rspec would be a knight. 
There are two things that I feel that could be improved: 1. The way you're whitelisting tags 2. The AST ## Whitelisting Tags Right now your parser does two things: parsing tags and "validating" them. It's not true validation since you use the `TAGS` array to create a set of rules instead of throwing errors when an invalid tag is used. Although not technically incorrect I'd keep parsing and validation separate. What this means is that your parser would parse any tag, be it `[foo]bar[/foo]` or `[b]bar[/b]` and validate the used tags *afterwards*. This makes things a bit easier to maintain as well as allowing you to perform more in depth validation of the tags (e.g. context based validation). ## The AST I haven't actually executed the code so maybe the example you've shown is pseudo output. However, what you did show is a bit of a weird AST. I'd go with a nested AST instead of one where you have start and end blocks similar to Ruby's `do` and `end`. Take for example this AST (using a Hash for the sake of simplicity): { :type =&gt; :root, :children =&gt; [ { :type =&gt; :text, :children =&gt; ['hello'] }, { :type =&gt; :b, :children =&gt; ['giggle'] }, { :type =&gt; :text, :children =&gt; ['goodbye'] } ] } You can easily iterate this AST using the following (messy) code: def iterate(node, spaces = 0) prefix = ' ' * spaces puts "#{prefix}#{node[:type]}:" node[:children].each do |child| if child.is_a?(Hash) iterate(child, spaces + 2) else prefix = ' ' * (spaces + 2) puts "#{prefix}#{child}" end end end If you were to run this you'd get the following output: root: text: hello b: giggle text: goodbye The reason this is easier than using opening and closing tags is because you don't have to do anything extra besides recursively calling a method in order to create/destroy a new context.
I really like the separation of request specs and feature sets. Will clean things up a bit!
I think I tried something like this, but I completely scrapped it because I didn't know what I was doing, I think; I think I tried to do it from scratch, but... The project's still on github if anyone's interested, but it's probably not too pretty; to be honest, I'd love to learn how I could improve on it.
Very cool. I like this library a lot. I noticed a few things: * `write!` doesn't do the same "raise if closed" check that `write` does. Is that intentional? * `write!` writes `@object`, not the supplied `object`. I think it's a bug. * The local variable `readble` is misspelled. I think it should be `readable`. * If you were able to supply the timeout to `write!`, you could rewrite `write` in terms of `write!`. Same with `recv!`. * The `close` method could be a bit more efficient. It does more calls to `!` and creates more arrays that it needs to. I've sent a [pull request](https://github.com/robgleeson/ichannel/pull/3) with these changes. The library looks great. Keep up the good work!
Mongrel and Mongrel 2 are entirely different beasts now. I wouldn't even call it Mongrel 2, since the only similar piece is the ragel engine, and Puma uses that much as well.
I am stretching my own knowledge a little here, but I'll try to contribute. Please correct if wrong. I think the OP needs to be clearer as to exactly what they need. The variety of responses all seem to be thinking in different spaces. I haven't used Rubinius, but my query around the approach of "to simply add another instance attribute to the AST structures" is whether multiple variations of source code could reference the same AST structure (eg. one with comments, one without). This might make it complex. Why not just add an attribute to the method/proc itself? My understanding of 'getting source code' techniques is: * pry and other techniques to get source code from the file of origin - (will not allow you to change the source dynamically within your program, if that is important to you) * Abstract Syntax Tree techniques - dynamic but you don't get back exactly what you typed in [eg. comments removed] (eg. 'rubyparser'/'ruby2ruby'. [or this for rubinius](https://github.com/txus/to_source). [Also 2.0.0 is adding something of this nature](http://bugs.ruby-lang.org/issues/2080)). * Just saving the source code with every proc/method, similar to [this](http://www.rubyquiz.com/quiz38.html).
actually pry's technique does allow you to change source dynamically within your program - you can just modify it in the REPL, this converts the method to a `(pry)` method, so the modifications will only apply for the duration of the running program. Another approach is to use the [edit-method](https://github.com/pry/pry/wiki/Editor-integration#wiki-Edit_method) command to open the method in an editor, any changes you make to it are then persisted to disk and the method code is reloaded. In the next version of pry there will be a `save-source` command added too, which will enable you to write out `(pry)` method to disk, so changes you make to methods in the REPL can be persisted, too.
yes, just end line with \ (or maybe / i didnt use this for some time, one of both will work) like this: very_long_text = "text" \ + "more stuff" in case of strings this could be done different, but it shows the idea very_long_text = "text" + "more stuff" in this case Ruby would know that something more has to come because of the + sign. 
Thank you! This is exactly what I wanted.
Absolutely pathetic. The real sexists and racists were the people moaning about the selection. It was clear the selections were made on merit and were open to anybody regardless of race, gender or anything else. The pitchfork brigade did so for racist and sexist reasons of their own - they saw a bunch of white males and their racism and sexism towards white men did the rest.
With strings you can also do the following: string = "some long string that will be longer than, say, 80 characters per line " \ "here's the rest of the string that will be appended to the line " \ "above similar to when using +"
The ultimate issue was that [the sponsors pulled out](https://twitter.com/Rebeccask/status/270220165344550912) as a result of the Twitter drama. The organizers' hands were tied on the matter.
When you only pick white men for your lineup you're doing it wrong. Let's say only white men applied to be speakers. Plenty of other conferences have have highly-qualified, highly-regarded speakers that aren't white men. (You dont even have to look outside of Europe!) It should cross your mind to invite them if you want to claim you're building a community. I don't know what to say if you thought a homogenous lineup was just fine. If more than just white men applied to be speakers and you came out picking zero of those that weren't, again, I don't know what to say. Building community is about inclusion and diversity. Picking a homogenous group of speakers doesn't imply you are racist or sexist, but you can't claim to be contributing to the Ruby community if this is all you include in your lineup. Perhaps your program goals were so narrowly focused that white men just so happen to be the most knowledgable and the best at speaking. (I dont believe this is even possible.) If somehow this happened to be true, your lineup isn't representative of the Ruby community. People want to go to conferences to learn and be inspired. Part of inspiration is identifying with the speaker and thinking, "I can do that too!" Sure, attendees should be capable of doing this with a white man, but that's not how inspiration works, and that's not welcoming to people with different views, races or genders. I can't see how this feedback would be undeserved for any general programming language conference. Much like the speakers you rejected from your lineup, the community is rejecting you from the conference organizer lineup.
However, if you have to wrap conditions like this, you should turn it into a method. You also improve readability and testability since the complexity of the method with the condition goes down.
Josh Susser is a massive tool and embodies everything that is wrong with the Ruby community and it's penitent for drama, he's the single reason I stopped listening to the Ruby Rogues podcast, not at surprised to hear he started this crap.
I don't believe an all-white-male lineup was anything more than coincidence, but I expect more than this at a Ruby conference and so do many other prominent rubyists. Unfortunately not everyone is going to express this in a calm and rational manner. A homogenous lineup is more a sign that you're not doing your homework as a conference organizer than anything else. I'd feel pretty terrible if I made this mistake as an organizer and was called out on it, especially if vitriol (which haven't seen or looked for) was thrown into it.
more likely some sponsors pulled out
If I were attending a ruby conf, I wouldn't even notice if all speakers are white or mixture or whatever. Why are people looking out for such stuff in first place? I am non-white, ruby dev and I just feel like people are just obsessed with this whole diversity/race/gender issue too much. feel sad for folks/devs of britruby conf. 
How would anybody even know if they were cisgendered heterosexual males without spying on their medical and sexual history? It is totally ridiculous either way.
Interestingly, I think there may be more to this than meets the eye. That tweet has now been deleted, and later ones from the same person say that [they may pull out](https://twitter.com/Rebeccask/status/270250181176475648), which is a different story altogether (i.e. the conf organisers are pulling the plug in advance of having the discussion with the sponsors...) It did seem odd that a company would pull sponsorship on the weekend, less than a day after some twitter controversy..
Yeah, I don't personally know any of the details. If that tweet was a lie, then who knows what actually happened. Either way, the idea that a conference should be canceled (or that sponsors should pull out) because a few people complained on Twitter about there only being white men giving talks is ridiculous. [Here](https://gist.github.com/4106776) is another post on the matter: &gt; * It was pointed out on Twitter that the lineup so far is white males. &gt; * This became frenzied and shared with allegations of racism/sexism. &gt; * This put the sponsors in an awkward position regarding commitment to the conference. &gt; * This meant the venue contract couldn't be signed because of a potential lack of financial security. &gt; * Since the team can't be personally liable for the costs, there was a hard decision to be made. &gt; * That decision was: cancel.
As a female Ruby dev.... really, I don't care. I don't care if there are fewer women, or if they don't want to be a part of the community, or if they don't want to work in tech, or if they don't present at conferences. Fine, don't participate. I like it here. I'll stay. I don't think the Ruby community is sexist. I think some people have done stupid things on occasion, and there was one conference (I don't even remember now which one it was... one in Boston) where the organizers actually did manage to offend me, but whatever. That's not indicative of the whole community. It's just an annoying few, and any community has those people. 
This the dumbest thing I've seen. Who cares about the gender or the color of the skin of the participants??? I care abou what they have to say. This is stupid. Very. 
I was stoked about this conference til I saw the lineup (the white guys they invited). Quite apart from the diversity fail, it just looked like the same old faces and the same old cliques. Sad to say, despite all the effort the organisers must have put into it, it just struck me as boring and uninspiring.
Wow, that was a seriously lame announcement! Looks like it was written by some frat bro. (and the spelling..). I hope you have a great time in Boston.
Great comment. Not that I doubt you, but for the sake of argument, would you list them?
Thanks. I'm so used to the semantic mantra that I knee-jerk replace &lt;b&gt; with &lt;strong&gt; without thinking about it. You're entirely right. Didn't even know about &lt;u&gt; (I use &lt;style class="underline"&gt;text&lt;/style&gt; -_-).
thank you!
Wow. This was the type of response I was hoping for. Parsing vs validation makes a lot of sense and helps me decouple some competing logic I was struggling with in this parser. I really like your tree output. root: text: "hello" b: text: "giggle" text: "goodbye" ...is worlds better than what I had: root: text: "hello" open: "b" inner: text: "giggle" close: "b" text: "goodbye" Using the tag as the node is obvious to me now. I'll work on this right now.
Is there any proof of non-white non-male presenters being rejected? Or maybe BritRuby favoured famous speakers (who happen to be white males) over first-time presenters? To avoid this brouhaha, I recommend the following CFP reviewing process: 1. Make all talk submissions public, but blackout the presenters name/email. This prevents any biases from leaking into the review process. 2. Downvote repeat talks. This favours fresh content and punishes those who travel to conferences recycling the same slide deck. 3. After the first round of reviewing, un-blackout the names/emails. Run the names through Google. Reject known trolls and charlatans. 4. Ensure there is a balance between famous speakers and first-time speakers. Too many famous speakers means not enough slots for first-timers. Too many first-timers means a lot of nervous speakers. I don't feel the problem is so much white male speakers, but that the same speakers (majority of which are white males) are getting to speak at almost every Ruby conference; often giving roughly the same talk. Their employers pay for the plane tickets and hotel, since these talks also act as subtle advertising/recruiting.
#3 is meant to be evidence based. For example, if someone submits a talk about this awesome new framework, but refuses to produce source-code or binaries, that's sketchy. Or if we find that the speaker has been giving roughly the same talk (maybe with different titles) at multiple regional conferences for 1-2 years, that's also sketchy. Researching the speaker should be the last step in the review process.
*Make all talk submissions public, but blackout the presenters name/email. This prevents any biases from leaking into the review process.* This misses a huge and most critical "outreach" portion. Anonymization helps reviewers make less biased decisions but doesn't by itself increase the diversity of proposers. Most of the work needs to be put into encouraging a wide range of people to apply in the first place. Another key step is having a diverse committee for reviewing the proposals. Why? Because even if I did anonymization, if *I* were picking the proposals I might subconsciously be biased toward ultra technical, academic talks and even without names or e-mails, this would trend toward male speakers in the Ruby community (not entirely but there's a slight bias towards content about productivity, design, UX, and social issues from women than men). A more diverse group of people doing the reviewing and picking lends itself to a more diverse group of people speaking.
You're injecting politics in a place it doesn't belong. Typical progressive tactics: Politicize everything, turn people against each other so they are easier to control. 
Just because a group of people are white and male it doesn't mean they are not diverse.
The only people who *decided* anything was the sponsors, who clearly *decided* things were screwed up with the conference.
I was responding to advice about getting a diverse range of proposals, not discussing the conference in the OP. But whether or not you agree with working to ensure diversity, doing so prevents dramas like this occurring so is a good practice nonetheless.
In my experience, the diversity complaints come regardless. Sadly, the twitter rumblings undermine the great work done by volunteers, particularly those volunteers from minorities within the community -- who get on with the job of building a great community while the rest complain. If you are concerned about diversity in the BritRuby community and have not volunteered to help, what good are you? Edit: sorry if this seems harsh. I saw too many volunteers bullied by the vocal few and too many silent acts of awesome inclusiveness totally ignored in the thirst for blood. In this case the victims are Ruby enthusiasts of all walks.
Did anyone ask the organisers how this happened? I haven't seen that yet. I've seen a lot of assumptions and jumping to conclusions and outrage, but not much checking. I don't think it matters much. Some people will be outraged because they want to be, regardless what the organisers say. Precious few will listen to them and take their words at face value, because, you know, it's easier to assume that they're lying. 
Can't upvote this enough. 
I couldn't agree with you much more and I was discussing this issue with them in e-mail in late October. As they maintain, they were planning to resolve it during the CFP/proposal stage but it wasn't soon enough for some it seems. It's certainly a huge shame and I agree with what you're implying, that volunteers don't deserve to get a shame campaign out of the gate. I did a video about this - http://www.youtube.com/watch?v=utkvVUoySv0 - which I shared with most of the protagonists a few hours before the cancellation was announced.. but since that ended the issue, I removed the tweet to it. It's especially sad since I know all of the people involved on both sides and know they're all pretty good, rational people. It's just too easy for sentences on Twitter to be misinterpreted in both directions and a sort of verbal trench warfare to occur. But as Redditors, we know that already, right? ;-) All that said, I *do* believe in going out of one's way to increase diversity (I never used to but I've been convinced in the last couple of years) and I hope other organizers use this debacle as a lesson to take it into consideration a little more or at least put their opinions out in public so no-one gets misled.
Are the times that it was hard to find a non-Asian Rubyist really that long gone that almost no one remembers?
It seems that the initial lineup was all invited to speak. The pages on the BritRuby site that would confirm this are no longer present (or on archive.org), but Avdi confirms he was an invited speaker and says the remaining five slots were up for decision after a CFP: http://devblog.avdi.org/2012/11/19/on-britruby/ Avdi's post is a bit long, but well worth reading
I haven't seen anyone accuse the organizers of bad faith or believe that this was anything more than an unfortunate mistake, nor have people who looked (see http://testobsessed.com/2012/11/diverse-discussions/ as I linked elsewhere in this thread). I have seen outrage directed toward the people who spoke up in the first place. This post's comments has plenty of such examples.
When ruby encounters a need to block and wait for IO it'll yield control to another thread. This means that the connections will be able to run concurrently with each other and the threads will yield control between each other. Due to the GIL, these requests are not being processed *in parallel* as each thread is sharing one processor. There's a difference between parallelism and concurrency. There are some good posts on these issues that deserve a read: http://merbist.com/2011/10/03/about-concurrency-and-the-gil/, http://yehudakatz.com/2010/08/14/threads-in-ruby-enough-already/ spring to mind. If you play with the code and add some some logging and move around the pieces you can see when each request is made, when the response comes in, etc.
Rubinius 2.0 provides true parallelism too.
yes it is
I would guess that the problem is with one of the gems you're using. For the most part, MRI gems don't really work well under MR.
No, he's right. You're also attacking the user and not his point, ad hominem fallacy. You're wrong. He has my upvote, you have my downvotes. Enjoy. :)
Well said. After all is said and done, what I really want is for the community to be strong -- and that means inclusive. I genuinely hope that people who complain also try to help and reach out to Chuck Hardy and his colleagues, too. There is strong evidence that they are feeling hurt and upset by claims made against them. If you are one of those who complained: I commend you on your dedication to a better world ONLY if you also act to help in some way (I assume many of you do!). To those who come only to complain and not also help: you are not a worthy part of a community and likely never will be.
Oh dear, now drbrain's suggested line-up has drawn some criticism. See how easily it happens? ;-) Seriously though, (I'm being a broken record here) it seems much more potent to HELP encourage inclusiveness in a community than to CRITICIZE alleged non-inclusiveness. 
I'd like to see some sources on this.
I have to admit that I was swept up in the fervor, then. On the other hand, Susser's original tweet is so easy to interpret as an accusation of intentional discrimination as to be irresponsible. For a change, as these things go, it went kinda well. I guess that's progress. 
I'm just curious because your comment got plenty of up votes, I didn't have an opinion at all, at least not before this drama happened.
I've seen a screenshot but can't find it right now. Here's the speaker lineup from lanyrd.com. http://lanyrd.com/2013/britruby/speakers/ Its an amazing lineup for a first year conference. Their budget must have been huge.
Can you link to this evidence? Here's mine that is completely the opposite of what you claim: http://testobsessed.com/2012/11/diverse-discussions/
I have very few committers besides myself on most of my projects, but that's probably due in part to the age and stability of my active projects and in part due to my stinginess with commit rights. The numbers are so small that, upon taking a similarly-sized sample across all open source projects, you'd get results with a useless sample variance. As far as contributors go, I couldn't tell you. Many people who contribute via github, either through issues filed or pull requests submitted, don't give their real names. Much like GoGaRuCo's speaker selection process this lends a blindness to my evaluation of the contribution. When I add the issue or pull request to my history file I use their name from their profile page, so after the pull request has been replied or the issue has been fixed I may end up with an idea of the gender (from the real name, if given) and race (from their photo, if present). I think around 30% of contributors haven't included either. If you want an accounting, though, I think auditing myself would introduce a bias to the results. Please have a neutral third party conduct one for us and publish the results. If we're going to be following up with accusations let's be sure we have reliable facts to base them on.
Yeah, I know the sponsors pulled out and that's why they cancelled. The offending tweets were deleted. And I'm betting those responsible complained to the sponsors, which is why they pulled out (which is speculation on my part). 
Is this really a rant about a debugging tool that's too slow to be used in production? Isn't that like complaining that running your application in gdb is too slow to use in production?
Can't help but think Susser's comments are a bit like releasing the details of a code exploit without contacting the developers first - it shifts the balance from being a useful contribution and more towards "me me me"... I'd have more respect for him if he'd made the criticism after the event, contacted the organisers with advice (and Avdi Grimm's blog post has some good ideas in it), and hopefully improved things for next time. 
I'm not in England. And I don't have a good network or blog. I'm a decent rubyist, focusing everything I got on WATIR, cucumber, and Sinatra, but I do t know if there is a demand for people to hear how I got a company from no automation to full qa automation. Maybe if I blogged and put myself out I would get asked but I haven't put the effort on my end to be recognized. To be frank, I just don't know where to begin and if I am even worthy...
I understand where you are coming from, but here is a statement that sums up my feelings towards the issue &gt; Adding a token minority speaker is offensive to that speaker, it says "You're here because you tick a box - not because you're skilled." If I were asked just because I was the only Puerto Rican in the room, not because of my skills, then I would be angry. It comes down to white mans burden. Don't fight injustices on my behalf when I don't view it as such. If I were in England, I would have loved to go to the BritRuby Conf. I would love to network with fellow rubyists, and I know that there would be more than white people at the Conf. Stopping the advancement of the community due to a lack of minority speaker is asinine at best.
Again, you and the quote are making it sound like there aren't any good non-white/male developers and so you'll just have to get one to tick a box. That's the problem. You don't even realize you're perpetrating it.
If there were minority/female Rubyists who actively sought a speaking role and was denied, then I would agree with it being racist. But no minorities jumped at the opportunity to talk. No women. If I were there, and I had the chance and the expertise, I would talk and I am certain that they won't deny me. The problem is that you are finding racists where there are none. You are perpetrating the thought that us "minorities" are too dumb and lazy to call out racism when it really happens. Again, white man's burden. Hope you enjoy it, because the majority of the world doesn't.
&gt; But no minorities jumped at the opportunity to talk. This is why it's called "inclusion". The conference actively sought out the white males, but did not actively seek out the non-white/non-males. Why must non-white/non-males strive to be included? Why can't we expect the conference organizers to actively do the including? More importantly *no one has use the term racist or sexist in this conversation or in the original tweets*. Stop saying that we are. I have also specifically not used the word *minorities* for a very good reason. Percentages don't matter in this situation. 
The C API makes it somewhat more difficult to fix MRI's garbage collector. You can get direct pointer access to objects in the C API, so any moving garbage collector is out. That said, the collector has been improved lately. In 1.9.3 we got lazy sweep. In 2.0.0, bitmap marking.
I believe you are replying to the wrong comment. You are quoting someone else. Either way your argument is filled with a lot of fallacies and I refuse to be called a *racist* for asking that an organization *try* to be diverse. Especially when that organization has already admitted that it wasn't diverse enough and didn't try to be diverse. Have fun with your name calling.
I say this as someone who hasn't bothered to get his app to run in jRuby: he's got a point. The JVM has just plain solved these problems already, and as much as you "fix" MRI, you're unlikely to cover all the edge cases that a platform with the visibility of java has. It's just got more eyeballs, and more center-of-gravity at this point.
It is not very interesting really. There is no any specific or particularly different tools or things. Just stuff that everybody uses. Even editor, the most useful tool in development is not mentioned. I think that Ruby programmers should know how to install git or particular ruby version on Mac OS.
What's the alternative to getting the command line tools? 
Just keep in mind, they occasionally do update their command line tools package. If you've got XCode, you can use it to keep your CLI tools updated a bit easier. Probably not super important as the command line tools don't change very often, but just something to note. 
Instead of making yet-another-installing-Rails/Ruby-on-OSX blog post, someone should write a copy/pastable Guide and maintain it on github. Every OSX setup blog post is laden with the authors bias towards certain tools (bash vs. zsh, rbenv vs. RVM, Vim vs. TextMate vs. SublimeText, MySQL vs. Postgres vs. MongoDB).
More logical fallacies and more attacks.
It's a relatively new thing.
How would that drive traffic to his blog?
&gt;what compiler should I use? There aren't really compilers for ruby; it's an interpreted language (I guess macruby is a compiler, jruby might count too?) That said, just stick with MRI (the 'official' interpreter) until you have a reason to look elsewhere. &gt; Are there any excellent resources for a rookie? _why's poignant guide used to be the standard answer here, but, you might not like the style... &gt; What are good habits to ingrain in myself now? This is not specific to ruby, but, meaningful variable names and good documentation (at minimum comments in the code, bonus points for a more advanced documentation system). &gt;Do you have any other advice for a budding coder? Enjoy yourself and have fun. Programming is one of the few things in the world where (minus hardware costs) the only expense is your time. Go find a problem you want to solve and solve it. If you think that an existing solution is crap, either fix it, or create your own. But, again, most of all, have fun.
Thanks for the great advice! 
The interpreter can be installed using an exe. If you happen to install Linux - in a virtual machine or otherwise - then you can use RVM, which is awesome.
 Some resources that I've discovered that may help you is codeschool.com and teamtreehouse.com have ruby courses. These are wonderfully designed and very simple to use. Also use tryruby.org to get use to the syntax. Or codecdemy, wateva floats your boat. Look into Zed's learn to code the hard way. He has some free books which teaches programming concepts. Lots of options. I'd recommend you install virtual box from oracle so that you can run Linux in a virtual machine. 
Just to second bosniasoldier's comment here, I finally moved from a combination of TextMate and vim to Sublime a few months ago and haven't looked back. It also works on OS X, Windows, and Linux, which is pretty awesome. Sublime is still a bit rough around the edges imo, but, it's pretty awesome overall, and totally worth the $ if you program on a daily basis (or really anything that involves editing text).
You know what? Fine. Have fun being ignorant to the world.
This I have been noticing many developers beginning to cargo cult rbenv/RVM into production. Worse, I've seen the same developers installing rbenv/ruby-build from git master (rbenv-installer and the rbenv-chef do this), resulting in [unwanted surprises](https://github.com/sstephenson/ruby-build/issues/241). Ubuntu 12.04 provides a ruby 1.9.2 [package](http://lenni.info/blog/2012/05/installing-ruby-1-9-3-on-ubuntu-12-04-precise-pengolin/) and Fedora 17 provides ruby 1.9.3-p327. Both packages work perfectly fine; `bundle install --deployment` and you're done. "don't use system ruby" is FUD from the days of Ubuntu 10, when gems were installed into `/var/lib/gem/`. If you need to install specific versions of Ruby, you can a) download the `.tar.gz` to `/usr/local/src/` and unpack/build/install into `/usr/local/` or `/usr/local/$ruby` b) use [ruby-build](https://github.com/sstephenson/ruby-build#readme) to basically do the same thing (`ruby-build 1.9.3-p327 /usr/local/ruby-1.9.3-p327`). As the blog post suggests, user accounts and VMs are great ways to compartmentalize your applications. If you want a shell script to automatically set `PATH`, `GEM_HOME`, `GEM_PATH` for you, install [chruby](https://github.com/postmodern/chruby#install) and call `chruby 1.9.3` in `~/.bashrc`. Don't be afraid to do a little system administration.
rbenv has no tests, therefore you should not be running it in production. Also, one does not necessarily need rbenv to install rubies, you can use [ruby-build](https://github.com/sstephenson/ruby-build#readme) directly.
What about you? Do you use Padrino framework for real world application or you just stick around with #rails? How do you handle authentication in your #padrino app?
I think the point the author is making is that rvm is fine for some situations but the infrastructure is much easier to work with if you take the minimal server approach described in the article. I can see how thsi would be much simpler in a lot of cases as well creating a world where it's easier to create a new VM for an app that add to an existing ball of mud.
I'm looking to update it. Any suggestions on what you'd like to see?
That's why I made it a community wiki. You can link it it as the permanent location. I'm looking to update it so any suggestions or edits are very much welcome.
Out of the box route nested and shared code vs sinatra, for one: [http://files.soveran.com/cuba/#4](http://files.soveran.com/cuba/#4) I don't think the guys that made it wanted to muddy the waters or anything, they just wanted a tool more closely aligned with their values and use. The people working on it are fanatics about getting stuff done with the barest amount of code possible. Additionally, if cyx's benchmarks are anywhere close to reality (yes yes, I know, benchmarks) it's pretty damn fast: [http://cyrildavid.com/articles/2012/03/22/cuba-3.0-released](http://cyrildavid.com/articles/2012/03/22/cuba-3.0-released) From the post: &gt;Part of the reason why the performance improved was because we replaced Rack::Response in favor of a simpler bare-metal Cuba::Response object. Lastly, it's fun to play with, too. 
Everyone pretty much answered your questions already, but I wanted to mention that I like inType (http://inotai.com/intype/) as an editor in Windows. I stopped doing any Ruby dev work in Windows though, my laptop is running linux now &amp; I have a VM running linux on my work machine using Virtualbox. It makes life a lot easier when it comes to using gems.
Very little that makes passenger magical runs inside apache (it spawns completely separate processes connected (IIRC) via sockets), unlike php which runs everything inside the actual apache process and leads to the headaches involved in tuning apache / php apps. I'm not sure what you're saying. You're saying they're similar because they are both used with web servers?
What distro of linux would you reccomend? I've used linux before to get into a system that won't boot to windows with parted magic off of a flash drive but outside of that I have no experience with it. Any advice on that too?
Start with Ruby 1.9. Consider Ruby 1.8 dead to you. You might pick up some habits that work in 1.8 that are broken in 1.9
It doesn't really matter, they can all handle Ruby development. I'm personally a fan of Debian based distributions (Debian itself, Ubuntu, Mint). Ubuntu generally has the largest newbie support availability just because it's one of the most popular and would be a fine starting point for you. It's also fine to just use linux inside an virtual machine, you don't need to install it to your disk until you're more comfortable with it.
As long as it does not install rbenv (especially not from git master) and merely installs the required Rubies, you should be fine.
People seem to think that a router that matches HTTP requests to methods makes something constitute a microframework. I guess it might but, then, so what?
Well it's just my opinion but high level I would say a framework should solve a particular set of problems in a generic way. That way you can see whether it addresses the problems you have and, if so, it should simplify solving those problems in such a way that as the framework matures it works better and better. So the most minimal framework would address one problem, leaving you to do everything else from scratch. I see a lot of frameworks that solve HTTP routing and pretty much nothing else, making them just barely qualify as frameworks in my book.
I do most development on windows and it I'd not that hard to adjust your environment for production. The main issue is some gems are not universally supported for all systems. " source of constant pain" is hardly a phrase I would use when developing for windows. Though I would suggest looking into the ruby version manager pik if you want to work with multiple ruby versions.
I agree, there had to be some specific case to warrant doing it slightly different. Though I'm not sure I'm sold on the performance reason yet without seeing data, because there's plenty of low hanging fruit in web optimization that don't involve microframeworks at all.
Fair enough, though I suppose that's where the modifier "micro" comes in to play. Sinatra mainly handles routing and has a set miscellaneous supporting functionality that you would need along with routing, but the meat is in routing
That's right. I'd call Sinatra a minimalist framework. Fortunately with Ruby you have gems and fairly standard API conventions that mean the pieces fit together pretty nicely without strict reliance on a framework. So while one might re-invent Rails' feature set eventually one can do it in one's own way with the pieces one likes best. That sort of thing helps make ruby microframeworks more useful.
Yeah, I don't fault sharing one's code - that's really cool - but if your code differentiates itself mostly on personal coding flavor you shouldn't be surprised if adoption is limited when compared to those who did it before you.
Why isn't the falcon patch in mainline yet? Is there any reason it's not already included?
This is a transcript of the Ruby Hangout that Jeff did a couple of weeks ago. There's a lot of valuable info here.
see last comment https://bugs.ruby-lang.org/issues/7387 edit: and https://bugs.ruby-lang.org/issues/7158 so it's in.
Do these patches still work with 1.9.3-p327?
Okay, here are the results I got: # Standard Ruby-1.9.3-p327 $ time bundle exec rake routes 13.649 total $ time bundle exec rspec spec 15.684 total $ time bundle exec rake assets:precompile RAILS_ENV=development 36.165 total # Ruby-1.9.3-p194 with falcon patch, CC flags $ time bundle exec rake routes 4.002 total $ time bundle exec rspec spec 6.853 total $ time bundle exec rake assets:precompile RAILS_ENV=development 19.385 total # Ruby-1.9.3-p327 with GC backport patch, CC flags $ time bundle exec rake routes 5.705 total $ time bundle exec rspec spec 7.797 total $ time bundle exec rake assets:precompile RAILS_ENV=development 22.733 total My system is an iMac core i5, so I used `CFLAGS="-march=nocona -O3 -pipe"` in my `.rvmrc`. For all these tests, I was using these GC tweaks: # GC tweaks from Github export RUBY_HEAP_MIN_SLOTS=1000000 export RUBY_HEAP_SLOTS_INCREMENT=1000000 export RUBY_HEAP_SLOTS_GROWTH_FACTOR=1 export RUBY_GC_MALLOC_LIMIT=100000000 export RUBY_HEAP_FREE_MIN=500000 I used gcc version 4.2.1 (Apple). I patched p327 with the [backport patch](https://gist.github.com/3721562#file_07_backport_gc.diff) mentioned in [this gist](https://gist.github.com/4060622). I haven't tried [Zeus](https://github.com/burke/zeus) yet.
Also might want to check out http://batmanjs.org/ for your js needs, I haven't really worked with it but it looks pretty nice.
I like Ember.JS whenever i do client-side templating, its the best out there, and does things none of the others do. You can build UIs that update seperate segments automatically, without diving into callback spaghetti I usually use HAML, SASS, Compass, Redcarpet, and occasionally Draper for my views. If i'm doing a wimpy model structure, I either use ActiveRecord or MongoMapper/Mongoid. Generally though, If I start doing any heavy server-side work, i evaluate what I need and usually chose Rails. Sinatra is good for simpler apps, but if you find yourself including ActiveSupport, ActiveRecord, and the various rails internationalization gems, you're probably better just using rails
If you have gcc version above 4.2, you can use "-march=native" for intel/amd.
Please be aware that they are private API, so don't depend on them.
rvm-head has this patch https://twitter.com/mpapis/status/272034154416336896
It's gotten a lot better since a few months ago. I know what you mean, however, its sort of one of those things where whatever you do, you're blazing a path. Rumor is Square will put out a guide soon, as they use it extensively
Ruby 1.9.3 reacts on this variables (here's my preferred values): export RUBY_GC_MALLOC_LIMIT=60000000 export RUBY_FREE_MIN=200000 # I think RUBY_HEAP_MIN_SLOTS is unuseful export RUBY_HEAP_MIN_SLOTS=200000 
Patch against p327 is released https://gist.github.com/4136373
For what it's worth, we are using [rabl](https://github.com/nesquena/rabl) and OJ to write pretty large json structures (&gt;1MB in size). We saw at least a 80% performance boost over the default JSON gem for these sizes.
are you sure it is implemented in your ugly way? please take a look at code before post about what you hate. it does not use `method_missing`, it is building a map at loadtime and use it at runtime. 
Thank you so much. The impact this has on my happiness as a developer can't be understated. :)
Installation for rbenv: https://gist.github.com/1688857
Ok. I dislike the unnecessary metaprogramming in building a map at loadtime for "#{method}_#{action}".
[Codecademy](http://www.codecademy.com/learn) has Javascript, Python, and Ruby now.
Why are they your favorite values?
 brew install automake worked for me.
I see: linux compiller is too forgiving for conversation warnings. Change `st_data_t` to `sa_index_t` and it should work. I'll fix it in a gist.
Going to sound dumb here, but how? I reran rvm reinstall 1.9.3 --patch falcon -j 3 with the same errors.
Ok got it. I updated brew (brew doctor yapped at me quite a bit) and updated to rvm head (again) and was able to install. Thanks!
What does the -j 3 do?
I can't think of any :)
The landing page doesn't immediately make clear what the site does.
It is passed to make: make -j 3 This gives instruction to compile 3 files simultaneously. If processor has more than 2 cores this value can be greater.
that site design hurts my eyes
If you're not going to get a real SSL cert, just turn off ssl entirely - as it is it makes the site look broken.
It's from startcom, their CA is in the default list for ie8+ firefox since like version 3 and chrome. Unless for some reason you're not using the default CA list in your browser or blocking class 1 certs it should work just fine.
This is what it says about your cert on Chrome, using the default CA list. [Screenshot](http://imgur.com/ogb8T) And if I were a normal computer user when it showed the certificate warning, I would have just moved on.
I mostly use Sinatra to quickly build APIs so I just add the DataMapper and RSpec gem. When I need to put a front end to the API I will probably use Ember or Angular.
Home computer. Mac running OS X 10.8.2
I read through the 'Get Started' introduction and I didn't see any comparisons with Grit. Is there some difference I'm missing or is Grit just not maintained anymore?
Miner is basically a fork of Grit since Grit seems to have stopped development. It's kinda hidden but there is a post that explains why Miner was forked and what I plan to do. It also includes an xkcd reference (bonus points if you guess it beforehand). [The post, "Introducing Miner".][1] [1]: http://dunsmoreb.github.com/miner/2012/11/25/introducing-miner/
1. Good. I like this. 2. I believe the cool kids now use libgit or libgit2 and connect via C bindings. 3. Check out [amp](http://amp.carboni.ca/) which was doing this back in 2009/2010. I wrote amp with adgar. We got hg support and then started to do git support. Not sure what the state of git support ever was.
Thank you. I wonder why OP posted a twitter link instead...
No worries, bro. Didn't know the backstory. Thanks for the update :)
That's so cool I had to make a [t-shirt](http://www.zazzle.com/funny_ruby_code-235092689980993688). (URL edited to point to new t-shirt without the pipe-cursor mistake.)
all good questions. since nobody else replied, I'll attempt an answer (read: guess). 1. since type safety is a defining feature of go's channels, I can only assume that `Queue#check_type` falls under the little clause at the top of the readme that says, "This gem is a work in progress, so treat it as such." 2. "Ilya is far smarter than I. Far far far." I have said these words to myself uncountably many times. 3. this is a wild guess, but maybe it's necessary in order to support channels of type channel?
This is one of the things I've been wondering and one area a formal spec would help, since it seems "whitespace" is legitimate in Ruby identifiers which would ordinarily be against a typical PL spec. Since Ruby 1.9 is Unicode aware, it seems odd that the implementation itself doesn't treat all forms of whitespace equally.
Isn't it most likely that they just missed that it existed somewhere? It should be submitted as a bug. 
Thanks! I thought that pipe looked suspiciously thin. T-shirt fixed at the new URL.
Unicode
Ruby supports UTF-8 encoded source code. This is different from the usual restricted ASCII set and includes, well.. millions of potential characters. Some of those characters *look like* ASCII characters but are actually distinct characters in the Unicode set. "Non-breaking space" is a character that looks like a regular ASCII space but is not. MRI is not smart enough to treat all spaces in the same way so sees these "different" spaces as legitimate characters to be used in identifiers.
&gt; To test CRuby's multi-threading performance, I contrived a small example program. No, that's a contrived, small example where CRuby can't do any multi-threading at all. Multi-threading in CRuby is fine for I/O, the part, that was left out of the picture. Just working with stuff (not even altering it!) that is already in RAM is a pointless benchmark in this case. It's not only designed to leave CRuby in a bad light, it's also completely unrealistic. 
You have a "getting started" page that doesn't tell you how to get started and a "documentation" link that's actually just a readme file. I have no idea why I might want to use your gem or how to use it if I wanted to.
Alright, I've just edited my app in that manner. Is there a way I can test if this worked? I'm using the app multiple times on my own computer. When I run the code to check the 'numbackends', I get '1'. Maybe it's working now, but I just want to be sure. EDIT: Alright, I moved the "DB..." connection out of the 'before' loop, and limited the max number of connections to 17. I wrote a script that uses the calculators 1000 times, and opened a couple hundred instances of it. While those hundreds of simple scripts were running, I ran another script that periodically checks to see how many connections are open to the database. Thankfully, that number only went to 18 at the highest. So far, ejholmes' solution seems to work. I still wonder though, what exactly is database connection pooling and how it works in Sequel.
I often vectorize logos with Inkscape using the trace path tool, but this one comes out crappy.
https://www.dropbox.com/s/2jkhfebqip9nju5/id-jruby.svg
Ahh, sorry I messed up: puts X XXX (so puts(X(XXX)) ) This is what spaces do to *my* brain at least ;-)
Thanks caadbury! I took your version and omitted the text. http://www.yellosoft.us/logos#jruby
Here's with net/http (which is kinda verbose): require 'uri' require 'net/http' url = URI.parse('https://www.pathofexile.com/login') req = Net::HTTP::Post.new(url.request_uri) req.form_data = {:login_email =&gt; "hello", :login_password =&gt; "world"} res = Net::HTTP.start(url.hostname, url.port, :use_ssl =&gt; true) do |http| http.request(req) end p res['Set-Cookie'] 
I've seen early video presentation link, but it's quite big amount of time, to observe it. Pure slides miss some detail, but require less time to cherry-pick most interesting things.
Hmmm.. I keep getting this error: &gt; "`connect': SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (OpenSSL::SSL::SSLError)" I don't think there there is anything wrong with my SSL certificate because `curl -I "https://www.pathofexile.com/login"` returns &gt; HTTP/1.1 200 OK ... Any ideas?
* [gist by headius showing drip experiments with startup time ("Good 50% reduction in startup...and more should be possible").](https://gist.github.com/4156388) * [another gist showing rspec command startup time with no examples reduced from ~5s to ~0.5s](https://gist.github.com/3143eda104d7a4bf6e85)
what's drip?
I forget how off the top of my head, but there's a way to tell openssl to skip the certificate validation. 
Thank you :) I will share my desktop workflow, but that deserves a entire blog post. A few points though: * KDE (but I never use dolphin) * Compiz, even though it's deprecated. My workflow is *very* efficient with it * Font rendering: no hinting, sub pixel rendering (as opposed to apple font rendering, so it's actually superior), lcdfilter * Tons of keyboard shortcut when I don't want to use the mouse It's basically tuned to get out of the way, and also to add substancial value to my workflow.
I think there are too many "simple" rails projects. I really wish there were more "robust" and "full featured" projects.
I was working on one of these months ago, and just gave up due to frustration/real world concerns
That sounds like a very bad long-term idea haha.
see the following pointless twitter thread for james edward gray's, dhh's, gary bernhardt's, and ryan bates's opinions on the matter: https://twitter.com/rbates/status/245307515666059264
&gt;Is that not something we should still be doing? Sometimes there's cases where breaking a 100 character line into 2 lines is less readable. Chaining scopes in Rails, for me at least, is usually an example of that.
Is this SEO as in Search Engine Optimization? 
I wish there were more, as you say, "full featured" projects as well. But there is space for small projects too. As a matter of fact, there are plenty of great small gems that solve their own little problems and that are not part of a larger package 90% of which you are not going to use.
So what can this thing do?
I don't think of it as a hard limit but if &gt; 20% of my lines were to be going over that, I'd start to think of it as a smell of something bad.
 def ( ) *2 end = 4 puts Where the above prints "8".
thanks, you're totally right
Thanx! And check site position in the search for keywords...
Looks like the drama over this has taken down bugs.ruby-lang.org. Here's a repost of the message: Issue #4085 has been updated by matz (Yukihiro Matsumoto). Since there still remain undefined corner case behavior in refinements, and the time is running out, I decided not to introduce full refinement for Ruby 2.0. The limited Ruby 2.0 refinement spec will be: * refinements are file scope * only top-level "using" is available * no module scope refinement * no refinement inheritance * module_eval do not introduce refinement (even for string args) In addition, Module#include should add refinements to included modules, e.g. module R1 refine String do def bar p :bar end end end module R2 include R1 refine String do def foo p :foo end end end using R2 "".foo "".bar module R1 refine String do def bar; p :bar end end end module R2 include R1 refine String do def foo; p :foo end end end using R2 "".foo "".bar # does not work now You can treat top-level "using" as soft-keyword, as long as it does not change the behavior (but performance). Matz. 
This is a very good decision there was so many problems with Refinements as implemented.
hooray. although i'd rather they got rid of refinements entirely. 
For me, it's just a metric, which say that something is going to become ugly. Usualy, when you obtain long line, you can refactor it to shorter one. In Clojure it's very clear, because you don't put many simple parts into one long. All "atoms" described in let-binding and then you create one big "sentence" from these lesser "atoms". In Ruby, we usualy tend to put all stuff in one big line and it quickly reach the limit of 80 chars.
It's back up now
What drama?
I don't have Tk installed anymore, so I can't personally run this to verify, but I'm fairly certain that "list" is not in scope in myproc. Something like get_list = proc { myproc(list) } btn = TkButton.new(root) do text "Exec" command (proc get_list) pack("side" =&gt; "right", "padx"=&gt; "50", "pady"=&gt; "10") end
Oh, and also, as a side note, unless you've got a pressing requirement that is forcing you to use Tk, I would highly suggest looking in wxRuby. I've build GUIs in both, and wx is by far better documented and easier to use. I also like to pair it up with a GUI builder tool like DialogBlocks that can save to an XRC file to keep much of the actual form/panel set up out of the core code. 
Part of me thinks this wouldn't have happened if discussion about Refinements began back in 2010, instead of after it was implemented in ruby trunk. Also, arguing about edge cases on a mailing, read by both English and Japanese speakers, list isn't a very effective form of communication. I wonder if Ruby's semantics could be expressed as axioms and ran through an automated proof checking program, such as [Coq](http://coq.inria.fr/)?
It was better post this to [r/rails](http://www.reddit.com/r/rails) as it's more about rails than about ruby.
The worth thing about this for me is that ruby specification is changed between feature freeze and release. Feature freeze was announced on 24 Oct 2012 and release is going to be on 2 Feb 2013. I'm crossing fingers to see 2.0 release without refinements and further work on refinements specification for the next release.
I do appreciate being able to statically type some vars and method args. It can give clarity to what is being set sometimes and also it would be nice sometimes if a var raised an error if the wrong type was assigned to it. 90%+ of the time I prefer dynamic typing, but every once in a while I miss static types. One advantage is that it does allow for code to easily be read and understand what method args need to be or what a var should be.
This may sound like a stupid question, but can anyone explain me what refinement is?
I might be wrong, but I think it's scope-limited monkey-patching.
Often my types in ruby are "responds to methods a, b and c" so restricting the type to a particular class (as most typing people seem to want) would eliminate flexibility.
Doesn't show up on http://rubydramas.com/ -- therefore, no drama.
Agree with and identify with your needs there too. I've thought about this before, and I think it would potentially be pretty useful to be able to quickly define and check for such a 'duck type. class SomeTypeAbstract responds_to :a, :b, :c end foo.kind_of? SomeTypeAbstract or even completely on the fly foo.kind_of? AbstractType[:a, :b, :c] Just random brainstorming. Both those of course are implementable now in ruby one way or another; we'd have to move on to talk about what the syntax would be for this sort of "on the fly duck type checking", in some kind of 'strong' and/or 'static' type check system as joedirt123 was wishing for. But I don't think duck typing is incompatible with strong typing. What we in ruby often call 'duck typing' is more like just plain Not Typing, heh. (Which has it's place too don't get me wrong). But you can strong or even static type based on 'duck type' too, not just based on a particular concrete class check. (on the other hand, ruby may be incompatible with _static_ typing, what with classes being open at runtime to modification, and the way classes are defined in ruby in the first place makes it hard to treat them as 'static' even when in practice one isn't getting monkey patched after load time. Static typing and ruby is going to be hard for it's own reasons, which may make the whole discussion moot, I'm not sure if we'd get anything useful from an optional strong-but-not-static typing. But I don't think the duck-typing concern (often my types are 'responds to methods a, b, and c') is a barrier, I think elegant solutions there can exist.)
It would be nice being able to pass a block instead of implementing a class for each unit. This should be easy by using yield in XPool#spawn when a block is passed via the channel.
Is the performance of rabl so bad compared with ActiveModel::Serializers? 
YESSSSSSSSSSSSSSSSSSS!!!!!!!!!!!!!! Thank you JESUS!
Ruby 2 is great. I'm using preview 1 in a new app and finding speed improvements of 20% on a typical Rails app, and so far no issues at all upgrading from 1.9.3. I've seen perfect results installing from source, and also perfect results installing using ruby-build and rbenv.
Man, I love ruby as much as anyone. It has really changed my life for the better. I get to go to work and have fun doing what I love. It's great. But you are way more excited about this than I am.
Does this mean that we can monkey patch with impunity ?
Basically yup. Context local monkey patches. Maybe rails 4 wont be such a heavy monster then
It's not whitespace, it's chacacter that looks like space. Why would you want to *break* on *non-breaking* space?
&gt; MRI is not smart enough to treat all spaces in the same way so sees these "different" spaces as legitimate characters to be used in identifiers. I disagree the it should be "smart" in this case. Non-breaking space should not be considered "whitespace". For all its purpose, it's supposed to be a non-whitespace character with a font that is rendered to look like a space.
I too am happy.
I didn't think of serialization when I wrote that comment. Closures can't be easily serialized, so that is kind of a showstopper. You could try the answer in http://stackoverflow.com/questions/199603/how-do-you-stringize-serialize-ruby-code : create a textual representation of the block and pass that, than eval the code on the other side. Capturing the free variables is harder, but the author of the answer above also thought of something there. The solution is not an easy one and maybe too much hazzle for just a little bit of syntactic sugar.
[Jesus would like to have a word with you.](http://i.imgur.com/RRcTj.png)
What an accessible write-up. If this is the guy that's behind krypt, then I expect only good things.
Rubyspec aims to fulfill that wish to some extent -- though it's not static proof, it does attempt to 'nail down' the semantics in an executable form. The problem, as I understand it, is that the ruby-core team doesn't really mind breaking rubyspecs freely. I can't imagine getting them to buy in to fully specified, formally-verified semantics is likely, when they apparently don't buy into ad-hoc testing of existing semantics. Based on the discussion's I've been reading, it seems they can't even really agree on semantics to begin with, it's all a bit cowboy. 
I think sometimes it would be nice to have a first-class 'interface' object, which a class can 'implement' -- and would cause some sort of load-time failure unless it's contract was fulfilled. I could then introspect on incoming objects to see what interfaces it implements. Essentially a minimal `raise unless obj.respond_to?(:method1) ... and obj.respond_to?(:method_n)` It's not strictly necessary for anything, and wouldn't limit my ability to necessarily pass something in (ie, I still have to explicitly check for it) -- but as a form of executable documentation of a particular interface I require, it's useful to me.
rubyspec only tests whether an implementation behaves in a certain way. It can't test whether the semantics are consistent and complement each other.
It was not as great as expected, maybe if it was an actual Ruby core commiter comments could be better.
Considering how similar are Ruby and Python, I think that it's a good idea to concentrate all efforts on one platform rather than half-assedly try to do it on two. Or is there some advantage to using Ruby over Python for scientific computation?
Yes, he is ;) Thanks for the kind words!
What were you expecting, BTW? Pat has written a [pretty in-depth book](http://patshaughnessy.net/ruby-under-a-microscope) on Ruby internals and even given a talk where some of the Ruby core team were applauding from the front row ;-) So if it wasn't in-depth enough, say, that was deliberate since he knows more than enough to go way deeper. We just wanted to keep it super simple for people who've never gone into the code before, not experts. If it was the delivery, however, then yeah ;-) This was Pat's first ever time doing a screencast/interview in this style, so always room for improvement.
So since ruby already has Rails, there's no reason to build libraries useful for web apps in python, right? Better to concentrate on one platform, or is there some advantage to reason to use Python over Ruby for web applications. If you've got a web application that also needs to do scientific computation, I guess you've got to combine two languages. (Oh, you're going to say "But we don't like Rails." But surely there is so much code for web app related concerns in ruby, that even building your own thing you do like instead of Rails, you're going to have a head start in ruby, right? Why reinvent the wheel in Python? I'm playing devil's advocate here of course, because I think the idea that because langauge X already does Y it's "splitting our efforts to do it half-assedly" for someone to want to implement that in the language they prefer instead.... is silly.)
Like I said -- to some extent. :) The point was aiming towards 'if we can't get even that, it's unlikely that we can get them to abide by some formally verified semantics'.
&gt; PyPy Rubinius? 
It helps build a broader scientific community. I learned on Python, but I use Ruby every day at work now. I can meaningfully contribute lots of high-load production experience on a huge team right now. To a Ruby project. For a Python project (and I love Python!), I'd have to re-learn a lot, on my own time. I imagine lots of Python people are in the same boat the other way around. There are LOADS of Ruby devs. Some of them are even really good. A very strong testing culture. A very strong open-source culture. Why not? I don't think your argument makes any sense at all. There isn't some boss of all developers who makes this call. The Ruby community, like the Python community, has lots to offer.
Let's all decide which Library should be in which language so that you have to learn 10 languages for 10 library. Let's put HTML parser only in Perl, XML parser in Java, GUI in Visual Basic, 3D Graphics in C++, ORM in C#, Scientific library in Python and Web application Framework in Ruby.
There seem to be a lot of unresolved issues with refinements and pretty confusing edge cases in the current implementation. headius did a good writeup here: http://blog.headius.com/2012/11/refining-ruby.html EDIT: Looks like matz already posted that full refinements aren't going in. Comment above.
Why are you here if you think that? /r/rails is that way ---&gt;
If you're asking about ruby's syntax, it would be one hell of a read. Compare a grammar for JSON: http://code.google.com/p/myjson-parser/source/browse/grammar.y ...to a grammar for ruby: https://github.com/ruby/ruby/blob/trunk/parse.y The amount of complexity in the diagrams would scale in about this proportion too, I think.
notice the large absence of counter-examples...
Someone did something similar to this for Ruby, Java and JavaScript a few years ago. The results are here: http://antigreen.org/vadim/ProgLanguageComparison/grammar-vizualization/visualization-of-rubys-grammar.html Unfortunately the images aren't particularly high-resolution so the text is difficult/impossible to read, but there are instructions there for generating your own graphs. Would be kind of cool to try and reproduce these with modern versions of these languages.
Exactly, this diagram is language-agnostic.
Well, remember that Nokogiri is mostly a wrapper around libxml2, a library written in C, and most of Nokogiri is in C too. Edit: and Java for the JRuby version.
Nothing helps resolve syntax errors faster than a train whistle.
Puppet and Chef aren't webdev and both seem quite successful.
Plus you'll typically lose the outer scope, so if you use this technique in some class and want to call other methods from the class within this block, you first have to make a local reference to the method. Pretty kludgy to me.
yep, that's defintiely one of the oddities that happens. 
Method with ! without non-! version ☹
well, put that way you could also include Rake and while I don't deny their usefulness they're not big in my opinion. but I concede, those are valid examples.
+1 to that :)
If you really wanted to use one of the libs on that page you could always work with one of the java libraries under jRuby. 
Totally agree – there is no reasonable excuse for using such technique in production code, it brings overhead to code. But as you can see FactoryGirl has similar syntax. Anyway I found implementing of such syntax a good exercise for metaprogramming skills.
Agree, I didn't added non-bang version of method but the goal of the article to show tricks about evaluation of scopes in different contexts and implementing of syntax proposed by some developer. In my next articles I will be more careful with that, thanks for feedback.
If you absolutely want the original syntax: class Binding def open $lvars = eval("local_variables") yield end def commit me = eval("self") (eval("local_variables") - $lvars).each do |lvar| me.send("#{lvar}=", eval(lvar.to_s)) end end end class User attr_accessor :name, :email def initialize(&amp;blk) instance_eval(&amp;blk) end end me = User.new do binding.open do name = "Magnus Holm" email = "judofyr@gmail.com" binding.commit end end p me 
It's not a big deal, it just makes me a tiny bit sad.
Are the strings not usually the other way around (ie. upside down)?
nice, you should post this to [/r/musicprogramming](http://www.reddit.com/r/musicprogramming)
bookmarked! This might come in handy soon for me. Thanks. 
Yeah, normally tabs are written upside-down compared to this. :-/
Agree on all counts. Bookmarked, removed bookmark.
If you only want this DSL *at the time you create the object* there may be a shorter way: class HipsterHackerStruct &lt; Struct class SafeEval &lt; ::BasicObject def initialize obj @obj = obj end def method_missing method_name, *args, &amp;block @obj.public_send "#{method_name}=", *args, &amp;block end end def self.new *args Class.new(super) { def self.create! &amp;block obj = new SafeEval.new(obj).instance_eval(&amp;block) obj end } end end There are 2 advantages to this implementation. 1) you can set an attribute to `false` without using singleton objects (the original implementation has a bug, you cannot do `User.create! { name(false) }`), and 2) after object creation, the reader methods no longer have to check the parameter. I think #2 is an acceptable change because it seems the intention of the original implementation was to only use the reader methods as setters inside the block supplied to `create!`. Let's define two classes, one using the old implementation, and one using this implementation to see the differences: class User &lt; HipsterStruct.new(:name, :email, :old) end class Hacker &lt; HipsterHackerStruct.new(:name, :email, :old) end user = User.new do name 'Snow king' email 'snow_king@gmail.com' old false end hacker = Hacker.create! do name 'Snow king' email 'snow_king@gmail.com' old false end The `User` class uses the old version, the `Hacker` class uses the new version. If we examine the value of `old` in both instances, we see the bug from the original version: p user.old # =&gt; nil p hacker.old # =&gt; false It's nil when we set it to false. Next, with the old implementation, the reader methods can still be used as writer methods outside the block: user.name "Fooo!" # this sets the name value p user.name # =&gt; "Fooo!" hacker.name "Fooo!" # raises ArgumentError The advantage for the new version is that after object creation, every call to `name` does not need to check a parameter. The reader method should be significantly faster. The down side is that this is an API difference from the old version, and people may want the feature of the old version. Hope that helps!
Already added an issue as an enhancement. A small change :)
Perhaps something constructive would be more appropriate? Let me guess.. you're a tester? 
&gt;Let me guess.. you're a tester? Uh, no. As a general rule-of-thumb, if you're naming files and have a bunch of things like, g_chords, f_chords, g_sharp_chords, consider grouping them in a folder and drop the repeated name. EG: chords/g, chords/g_sharp, etc. This is generally the point I consider creating a module for said classes. Name your classes according to their file names. EG: chords/g.rb would contain a class named G, a file named g_sharp_chords.rb would contain a class named GSharpChords. As a standard gem convention, attempt to contain your gem's classes within an appropriately named module as namespacing is important. In this case, "Chordy."
I am so happy to learn this subreddit exists. Thank you. 
Thanks for not being a super defensive person but instead coming back and giving good and valid constructive criticism. 
This is... awful?
really really weird this was designed this way...
thanks, i love it when people use the word agnostic when talking about programming... makes me feel fuzzy inside.
diagrams have a name... and the name makes total sense!
Seems a lot clumsier than the curses library that ships with ruby. The README makes shows manual error checking instead of exceptions. The talk of pointers is scary. 
Future proof from what? 
Aaron, thanks a lot for such a wonderful example! I made a mistake with *false* setting, seems like only you noticed it. And your second improvement looks really good – setting variables through reader methods outside the block is unnecessary. Would you mind if I post your comment to original article as update?
Let me try to explain. I could treated `Text` simply as a string; it would have worked perfectly for my current needs. But what if I needed to add some more functionality to `Text`? Sub-classing from `String` is the right way though I guess.
It provides similar benefits but implement them in different manner. Sugar.js extands JS-prototype, and it's not very good, because of clash with other libraries and different unexpected experience. RubyJS gives you R-funcation, which wraps everyting into some container. All operations is done over this container and then you can unbox result from it. This approach is very similar to Underscore.js and is much safer than in Sugar.js. Commerical licence alienates my Ruby-soul, so I stick to Underscore.js.
I think subclassing (or maybe better, proxying) String is better than monkeypatching. Text (at present) is good -- it avoids the over-use-of-primitives smell, it is cheap to do, and makes it so there is a natural place to put changes he knows he will eventually need (perhaps rendering in different ways). It has one responsibility (representing text) -- it's much more nicely open for extension (as compared instead to monkeypatching, which can easily modify 'by accident', potentially breaking in major ways), and it substitutes cleanly for it's parent (Liskov-compliant). I'll leave 'I' and 'D' off, because they don't really apply here, but I'd say this class is pretty SOLID. It's also _cheap as shit_ -- probably took 10 seconds to write, and now he has a simple place to put new extensions. However, were it me, I probably wouldn't have written it, because the payoff _now_ isn't very good, and in particular I think it may lead to a multiple-responsibility class later on ("Text can manipulate it's underlying representation to be rendered as Lilypond, ABC format, and Tab format, and ..., and ..., ...") Rather, I would stick with string, and when I found the need to convert those things, I would create a 'FoobarFormatter', that formatter would be responsible for managing exactly one formatting task (a command object) and respond to the same interface (say #format) -- and return another string. I can then toss those formatters around and replace them freely, test them in isolation, etc. But I also don't have to pay the cost of doing `Text.new('thing')` everywhere. I guess I don't think it's bad, it's certainly better than monkey patching, but I don't think I'd do it that way unless I was sure Text only needed a few extensions/changes.
I dunno if it's THAT big a cost there. I doubt ruby plans on introduce support for musical concepts :P.
xposted to /r/rails
The advantage is, that the features are on a wiki, so non-programmers can see them, and edit using the wiki.
so... i'm never gonna see the source for this? :'(
Ah thanks, `bi-directional`, neat. I missed that. Could you put a couple sentences up about how you use this in a process/workflow? I imagine your business developers are writing features before hand. In which you pull, write, test, and push, approve, deploy? All that jazz. That's neat. 
&gt; Sugar never overwrites methods that already exist, and does not modify Object.prototype. Should be noted. Personally, I don't use it. 
Ruby 2.0.0 uses Onigmo: https://github.com/k-takata/Onigmo
I actually really like this library. I feel like its just a drop in replacement for underscore with a much nicer syntax. I really like how he's added support for Ruby array operators. The author has updated the license to be MIT. Kudos to him for putting out a cool library. 
Really? Is there an article that has some sort of comparison?
[rspec-given](https://github.com/jimweirich/rspec-given) looks sweet, it really looks like the kind of DSL I want to use.
Well, see the first paragraph in the README + https://github.com/k-takata/Onigmo/blob/master/doc/RE.
Cool. Thanks
Communities and names are not distinct. Anyone can make a community named 'Ruby'. There is already a prominent one named "[Ruby Language][RL]" by the people who do the [+Ruby][R] page. [RL]: https://plus.google.com/communities/117943761886564468082 [R]: https://plus.google.com/103356462068155467049/posts
There are already 350+ users on the "Ruby" community and ~150 users on the "Ruby Language" community... I think they should join, so we will have one big community on Google+.
In my experience, future-proofing is best achieved by writing readable, easily-maintained code. Adding things for the purpose of expanding later is a code smell. A better approach is to add things as you require them. If the code is clean, refactoring is a relatively easy process (though admittedly involved). After all, your project may require a different pattern altogether when it's implemented. Having another look over your gem, I urge you to thoroughly understand the differences in comparison operators, specifically concerning their precedence. '&amp;&amp;' and '||' have higher precedence than 'and' and 'or,' and should be preferred over their keyword compatriots. Another suggestion is to follow the [Github ruby style guide](https://github.com/styleguide/ruby). Code authoring style goes a long way in legibility and maintainability of a codebase, and their style guide aids greatly to that end.
new site, not a bunch of users, looked simple enough, signed up, took the quiz, didn't even place on the leaderboard. womp.
There's also javascript errors on the page when you click on the Creative Response tab.
&gt;Write a method that will take a sentence and return it in reverse order (still as a string) **without using the String reverse function**. Half the answers are just `string.reverse`... can they read?
I've had a similar ruby library kicking around for a while now that I've used on chordiehow.com and I've played with it off and on trying to get it ready for a public release, and this has inspired me, so I've posted the chordie-how gem on github: https://github.com/dark-panda/chordie-how That's the library that provides most of the functionality of http://chordiehow.com/ . The Rails app itself isn't quite ready for release yet, as I haven't yet upgraded it all to the latest heroku stack, but that's coming eventually. Our gems seem to share a lot of functionality, so I figured you might find it kind of interesting and/or useful.
Yes this place is too crowded with links and comments.
Use bcrypt or scrypt for hashing passwords. There are perfect ruby gems for that. 
Awesome.
You will do it wrong. It's a simple fact of life. Your first 4 or 5 iterations will be wrong. It's not easy to get right, and it's fairly easy to come up with something that's either not workable or that has a complete absence of security. Be prepared to throw your code away. I can say from experience - having written user management code many times - you *will* throw away your first couple iterations.
Yeah, totally. I'm not that new to webdev :) Would you by chance like to help out?
Sorry, no, I have more pressing projects taking up my time.
mdmd136: Indeed it was. I made this interpreter as a test for Treetop and as a resource for others learning Treetop. This, by no means, was supposed to be a clone of the creator's implementation.
Couple of suggestions: 1. Use warden. Take the time to learn it and understand it, because it's awesome and will save you time in the long run. 2. Start writing tests. From looking at your code base, it looks like you're reaching a point where it's non-trivial and testing it manually is probably cumbersome. RSpec is pretty sweet for doing bdd/tdd. I really can't emphasize enough how important tests are, especially in the ruby community. If you start anywhere, focus on unit testing your models, since this should essentially be your internal api for your app, which the Sinatra app consumes in routes and views. 3. Make your methods small and try to follow the single responsibility principle. It'll help out when you're writing tests and need to stub out methods with mocks. 4. Organize your code base in a more ruby-esque manner. Have a look at some other open source sinatra apps (Janky is a pretty good example of "doing it right"^tm https://github.com/github/janky)
Why would people use G+? We have irc, blogs, reddit (or HN if you are into that), mailing lists, forums, voip, conferences, meetups, twitters and a thousand other different ways to communicate. 
Password HASHING. Encryption is NOT hashing. One is designed to be reversible, the other is not. It's only confusing to conflate the two.
Highly second Michael Hartl's tutorial! Seriously: either use an off the shelf auth gem or go through Hartl's tutorial so you can begin to understand how and why you built authentication the way we do!
I'm not seeing any advantage over attr_* methods besides providing an initializer? It seems like the real boilerplate I encounter is trying to coerce types, which something like https://github.com/solnic/virtus provides.
Thanks for the suggestions. I didn't put much thought into handling inheritance yet, but I definitely will.
I hadn't heard of this before. I occasionally build plain old ruby objects that take params from complex forms that aren't model-backed, and this will come in real handy there.
Oh, perfect. Doesn't Rails handle most of the auth for you though?
Okay perfect! I think my next step is a refactor, then tests, then off to feature dev and more tests!
got it
No offence, but this has been done to death. Checkout [virtus](https://github.com/solnic/virtus#readme) or [parameters](https://github.com/postmodern/parameters#readme).
Very pretty. This is a really nice alternative to constantly switching back to a term to view the webrick/thin/x output.
Yes, and this is incredibly powerful with the REPL inside!
Having to use ruby sounds like a good way of getting the language into your fingers, thanks!
\#[] accepts multiple arguments: ["Hello", "world"].map &amp;[1, 2]
*hangs head*
Oh fuck, what a stupid mistake I made. I'll correct that asap, thank you.
I'd argue that in Ruby it makes more sense for `f * g` to mean `g(f(x))`.
To conflate function composition with method chaining does a disservice to both.
OS X is what would initiate [turbo boost](http://en.wikipedia.org/wiki/Intel_Turbo_Boost), and an intense script of any kind could motivate OS X to overclock the CPU. To find out for sure, I'd suggest an experiment. [Install watch](http://osxdaily.com/2010/08/22/install-watch-command-on-os-x/), run your script and in another terminal, run 'watch sysctl hw.cpufrequency' to get the current frequency. I'm sure there are GUI alternatives as well.
I didn't see anything in the article to indicate that they were leaking database credentials specifically. Where did you see that?
The password table would be hashed in such a way that you couldn't tell whether or not a password was a user password or a random record What I'm stating here is that the passwords are separated from the users table - you cannot connect the two. The only possible issue is collision.
I agree. Much better idea.
&gt; A bug in the Ruby agent causes database connection information and raw SQL statements to be transmitted to New Relic servers. The database connection information includes the database IP address, **username**, and **password**.
I'd look into using threads and JRuby
I do see your point. This has actually been recently discussed at ruby-core, so you might want to chime in if you care about this: https://bugs.ruby-lang.org/issues/6284
Like izotech said &gt; an intense script of any kind could motivate OS X to overclock the CPU and a multi-threaded script running in jRuby would definitely be intense. I would suggest spawning the same number of threads as your CPU has cores
Using multiple cores would be better then maxing out a core for 'turbo boost'. Albeit more difficult to program. The best option, I can think of is too separate the work into jobs. You wouldn't need `jruby`. The work is scaled by process concurrency vs thread concurrency. Consider `resque`.
would you be to create a hash with all the values in the CSV files and then manipulate the data structure?
You can use IO#foreach to read a line at a time, and the CSV library to parse each line. It would be light on memory. You'd have to accumulate the totals as you parse though. 
There is no need for Perl-style ties in Ruby, because you can simply write a new class that behaves like a Hash but which reads data from the disk instead of storing it in memory. ...but there's no need for anything like that in this problem. Just use something like CSV.foreach to tally up the data one line at a time without storing them all up in a data structure.
You know what sidekiq is modeled after? Resque. I mentioned it specifically for a learner. Which will help when they're trouble shooting problems as resque is wildly popular. And this is not to say sidekiq isn't. I don't think you need it either given the context. Macs generally have 8GB ram these days. Process concurrency should be plenty for whatever issue he is solving while turning they're mac into a frying grill. Given additional thought a simple ThreadPool could work too.
Resque is pretty heavily used, but development seems to be stalled out at this point. In production, especially on JRuby, sidekiq is much more efficient than running a bunch of resque processes. Also, you don't need to setup a monit/god monitor for each one, you just need to run/monitor a single process. On JRuby/Rbx this single process will use all of your cores without any extra work, and will only use the memory it needs, without much waste. Also, I feel like the API for sidekiq makes a bit more sense than the one resque has, especially considering the extensions it makes to classes, actionmailer, and activerecord.
Got it. Yeah, I mean hashes. I've been programming a lot of js recently, so my brain got some wires crossed.
You might also considering using your shell's built in functions for this. Ruby isn't always the right tool for the job. ``` awk -F, '{print $3}' | uniq -c | sort -r ``` will give your counts 
I'd probably even use a simple `#split` instead of throwing the CSV library at it.
For those responding that it is not necessary since you can implement your own... I think what's being asked isn't if Ruby itself has an equivalent - but if there is a gem of some sort that takes care of that implementation. You could argue there is no need for any of the gems because it's all stuff you could implement yourself but that's not the purpose. The purpose is to provide you the implementation so there are fewer things for you to worry about. As to the specific question, no I am not aware of anything that gives you the Tie::Hash functionality in Ruby. But I don't see why someone couldn't write up something for others to use as a gem. 
I was thinking jruby would be needed since MRI doesn't have true threading and only runs 1 thread at a time, which wouldn't be as CPU intensive as true threading
That's not entirely true, you should read what Katz says about [threads in MRI](http://yehudakatz.com/2010/08/14/threads-in-ruby-enough-already/). `resque` is scaled by process concurrency so there is no grumpy gil to pay. But, yeah, I see you're point. I just feel like learners should focus on MRI, then jRuby, maybe I'm backwards about that.
I've recently gone through the process you are going through and I'll be honest - learning the testing methodology is not easy. The actual tech/coding behind it is pretty simple but getting it's a different mindset so getting your head wrapped around the issue can be challenging. It's a tad harder to find documentation online showing you how to do testing with Sinatra. But typically you will want to separate out your testing into testing the stand alone models and then also testing the Sinatra functionality. I use Rspec and have just recently started using FactoryGirl (there will be a lot of religious debates on what to use... I use Rspec because it seems to be used the most... and FactoryGirl because it's what my first book I read used - this book focused on Rails so I don't know how much use it'd be for Sinatra). FactoryGirl creates factories of test data to use to run tests. To give a very basic example (this will be Rails-centric but should give you an idea), here is a simple class and it's tests for an app I'm working on now. &gt; app/models/domain.rb (CLASS FILE) class Domain &lt; ActiveRecord::Base has_many :pages attr_accessible :description, :domain validates_presence_of :description, :domain validates_uniqueness_of :domain def self.valid? (domain) Domain.exists?(:domain =&gt; domain) end end &gt; spec/factories/domains.rb (CREATES MOCK DATA FOR A DOMAIN OBJECT) FactoryGirl.define do factory :domain do domain 'www.epicurious.com' description 'Epicurious' end end &gt; spec/models/domains_spec.rb (TESTS) require 'spec_helper' describe Domain do it 'has a valid factory' do FactoryGirl.create(:domain).should be_valid end it 'is invalid without a domain' do FactoryGirl.build(:domain, domain: nil).should_not be_valid end it 'is invalid without a description' do FactoryGirl.build(:domain, description: nil).should_not be_valid end it 'does not allow duplicate domains' do FactoryGirl.create(:domain) FactoryGirl.build(:domain).should_not be_valid end context 'check validity of given domain' do it 'returns true for a domain that exisits' do FactoryGirl.create(:domain) Domain.valid?('www.epicurious.com').should eq true end it 'returns false for a domain that does not exist' do FactoryGirl.create(:domain) Domain.valid?('www.yahoo.com').should eq false end end end I won't go into the details of all of it because it's pretty straightforward... but it'll hopefully helps.
/r/ruby isn't really a forum, it's a collection of news posts with associated commentary. Depending on your needs, comp.lang.ruby might fit the bill.
Could also check out [Hacker School](https://www.hackerschool.com/).
a coworker of mine went to code academy http://www.hackeducation.com/2011/12/10/code-academy-teaching-chicago-how-to-build-web-apps/ we hired him as soon as he got out. hard to find people right now
Devbootcamp.com is very good, I know several people that went there. Appacademy is another one but don't know how good it is.
You can also chat on [\#ruby-lang at Freenode](http://webchat.freenode.net/?channels=ruby-lang).
http://www.gschool.it/
Hmm, closer look at the _classifications(text) method in the Classifier:Bayes class seems to let me get a numerical output: b.classifications "I hate bad words and you" =&gt; {"Uninteresting"=&gt;-12.6997928013932, "Interesting"=&gt;-18.4206807439524} That might work! 
I think for this to happen Ruby needs to become a lot bigger for at least 2 reasons. 1) The current method is working; Ruby is mature, stable and relatively bug free and also free from design by committee. The size that it the community currently is lends itself well to these features. Too many cooks spoil the broth. 2) These proposals are so bureaucratic that it will require more people to be paid just to keep up with these proposals. They aren't fun, they aren't cool, they ain't something that you will get people to volunteer there spare time for.
I believe the specific one you're thinking of is Course Hero possibly. The ones that are also doing well but not guaranteed is Starter League
Code Academy is now http://www.starterleague.com/
This is probably what you're looking for. It is led by some of the same people who ran LivingSocial's HungryAcademy.
The article says you don't have to know Ruby to learn Rails. And while that's technically true, a Rails developer would be VERY limited in what they could do without Ruby knowledge.
Indeed I too agree to that, I had the same experience... Working with just rails he would see or limited the view of a typical web developer, getting to know more on Ruby. One would suddenly see a huge set of potential use cases, which couldn't be worked if we thought of regular web application. Using more of Ruby would make you feel you can leverage everything you can do with the computer to the internet through rails... :D 
OK cool. Is there a way to filter for only English posts though?
My two cents... Theory: The default collection should probably be Set. If you need duplicates, then use Bag (Multiset). If you need order, then use OrderedSet. If you need duplicates and order, then Array. Practice: Day-to-day this probably doesn't matter enough to break team standards or warrant syntactic baggage or going against the language. 
Come hang out with us in Bend for our third year!
Cool. I guess all I needed was a sanity check since I've never heard this come up and I *never* encounter Sets in Ruby whether I'm looking at random Ruby projects, sample code, gists, blog posts, Rails apps, or any of the literature I consumed while teaching myself!
Ruby's array is a catch-all. Its easy for development because you can just use [] for any group of objects. Yes - people are lazy and just use Array for everything.... usually it doesn't matter much in terms of performance and makes the code simpler rather than harder to read. Sometimes it does make things slower or less logical. In this case, yes, there's tonnes of lower level data types you can and should be using (in addition to sets and bags there's singly and doubly-linked lists, fixed-length arrays, enumerated types, etc.)
I generally use arrays by default, and then use sets if I need a specialty collection, like no duplicates. Arrays are just easier to work with, from my experience
That makes sense for smaller snippets, then I can use actual test files for integration testing. Side question: what would the better design pattern be? Having a class that takes the unclean text in the initializer, assigns it to an instance variable, then have all my functions operate on that instance variable? Or should those functions all take in text as a parameter to operate on, then return it?
Stateless functions and objects are easier to test. If you make small stateless methods, you can combine them easily in the main function. TDD is usually easier in small chunks, where you gradually build up the main feature from parts. That way you don't try to build something too complex. Sometimes it's the opposite, writing a test for the top level reveals something from the smaller parts. Sometimes the development process is a mix between those two. 
Use sets where it makes sense, especially if you need to check for membership. I don't think anyone would fault you for that. Also, you can use this to make sets: `Set[1, 2, 3]`
Sets have always used a hash internally, at least since [Fri Aug 30 13:47:49 2002](https://github.com/ruby/ruby/commit/fb00e309f66c4e00d07373fec46e36620bfda6fa).
Further discussion is on bugs.ruby-lang.org: https://bugs.ruby-lang.org/issues/7549
The array API in Ruby is very rich, and although some of it is clearly intended to model sets... idiomatically, you would just use arrays. If Ruby 2.* would include sets, that could be interesting.
&gt; One issue with Sets, is that you end up finding that various libraries don't work well for them. Once obvious example, if it's an Array than serializing it as JSON Just Works. If it's a Set, who knows what's going to happen, you have to stop and think and investigate. Yes, this is the biggest reason that people don't use sets. The other big reason is that very few practical applications need to guarantee uniqueness over a large set. The underlying Hash in a Set doesn't have any performance advantage over Array until the Array is big enough (hundreds of values). Array has every method Set has and more. So if you are under hundreds of unique values, Array#uniq is fine (also faster and more familiar). If you are over hundreds of unique values, Hash is a little more familiar than Set, and if you are doing something with those keys other than assuring they are unique, you are probably going to want key/value not just value. So there are very few applications indeed where Set is anything but pedantic. 
Sets are slower and you have to require 'set'. Ruby 1.9.3-p327 require 'benchmark' require 'set' Benchmark.bm(10) do |bench| 3.times do bench.report('sets') do 1000000.times do set = Set.new set &lt;&lt; "bob" set &lt;&lt; "joe" set &lt;&lt; "seymour" end end end 3.times do bench.report('array',22) do 1000000.times do arr = Array.new arr &lt;&lt; "bob" arr &lt;&lt; "joe" arr &lt;&lt; "seymour" end end end end user system total real sets 3.710000 0.000000 3.710000 ( 3.717861) sets 3.830000 0.010000 3.840000 ( 3.838309) sets 3.860000 0.000000 3.860000 ( 3.871765) array 0.780000 0.000000 0.780000 ( 0.837835) array 0.770000 0.000000 0.770000 ( 0.775716) array 0.770000 0.000000 0.770000 ( 0.771326)
In Ruby, a Set is basically just a Hash. So yes, insertion is slower, but testing inclusion should be quite a bit faster.
Linux has survived very well under this model. I shudder to think what will happen if Linus doesn't have successor planning in place.
Yes, checking inclusion is faster because the keys are indexed. Array is more memory efficient than sets. Every algorithm has tradeoffs.
I agree in placing more emphasis on writing the documentation than a lot of developer's do, and considering no code commit finished without docs same as you would without tests. And I agree that "tests are the documentation" is silly, you often end up either sacrificing documentation (most usual), or sacrificing test quality (if you take it serious and prioritize making the tests good docs over making them good tests). But in my own experience, i find that _any_ "always do things in this order" doesn't fit. Write everything iteratively, sometimes the tests first, sometimes the code first, sometimes the docs first. Coding is still a craft (for better or worse), you know what to do just by having done a lot of it. &gt; we are ensuring that we only test behavior, and the only way we know about the behavior is documentation. But yeah, that's a pretty good way to think about it. "Black box" approach is pretty fundamental to many not-new ideas about software engineering, right? Abstraction, encapsulation, etc. 
This. I'd still contend that at least some documentation before the code is a good idea, though - of course it's a simplification, but that's the whole point. I've found that if you don't try laying out what you plan to implement before you actually start coding, the control flow for a large-scale application can become muddled in technical details that often leads to several redesigns down the road. If you spend a day or two ahead of time laying out exactly how the program is going to be used, it gives you a nice rough-draft of what needs to get coded.
i am trying to have a pure ruby version!!
Yep im sure for some circumstances with large arrays, and look up requirements, that sets my be useful. That said with those kinds of things I think id normally use a hash directly as i'm probably dealing with some kind of key value store. I think for the vast majority (low number of elements, only adding and removing) of uses array is fine as a the "default".
I deleted my benchmark after I saw that you already posted one in another comment, but you were too fast. Faster than a Set lookup! I also came to your same conclusion. Arrays are faster to construct and often just used as a way to iterate a collection. A better default for sure. Not to mention anyone doing any real work with collections would be a bit more deliberate about their choice data structure. I've been enlightened.
Hey it's cool, more data is always good!
Additionally, when considering webdev/Rails, the uniq would be better served from the database.
A vast majority of collections are small enough that the relative speed difference between Sets and Arrays is not a factor in deciding what the default should be. If you're working on a bottleneck, that is when you start trading clarity for performance. Not in choosing your default (preferred) representation.
On a lot of the projects, I've integrated YARD into our CI. If you are less than 95% documented, CI rejects the build. And really, I should have emphasized this more in the article, I think this should be more a guideline than a fixed process. It came across as a process, and that was not my intention
QED? http://rubyworks.github.com/qed
Multiget is a damn cool cache improvement. I hope that catches on more. Side note this reminded me of. This doesn't always work, because it depends on the variance of your collections, the size of your cache, etc etc but... If you have a collection with moderate variance, you can use a nested cache arrangement. The outer cache is of the entire loop, with the key being a hash of the ordered cache keys for everything in the collection. Then you go about inner loop caching as normal. This only works with so many likely combinations, though. Another possibility is to incorporate roles or aspects of the permissions into a generated cache key. It can bust fast, but if you get a spike, can also save the day. Just wanted to throw it out there because so many strategies focus on the #cache_key, and it's often OK to derive your own or add to it.
And this is bad how?
From the comments, it's bad because it pollutes the ancestor chain with an anonymous class. class Wheel &lt; Struct.new(:rim, :tire) end Wheel2 = Struct.new(:rim, :tire) do end p Wheel.ancestors # =&gt; [Wheel, #&lt;Class:0x00000000ce7c28&gt;, Struct, Enumerable, Object, Kernel, BasicObject] p Wheel2.ancestors # =&gt; [Wheel2, Struct, Enumerable, Object, Kernel, BasicObject] And &gt; Another reason is because you cannot use Kernel#load to re-load a file that creates a subclass of Struct (type mismatch, since your subclass already has a parent). Can't imagine this cajoling anyone to stop subclassing Struct. Of course, by virtue of blog headlines, you can reduce it to "Things to know when subclassing Struct".
Brian Ford's talk on this at RubyConf was great: http://www.youtube.com/watch?v=BagNfTbXn3w
That second one is to me the bigger issue.
This is pretty far on the molehill side of the mountain &lt;-&gt; molehill spectrum. I'll probably remember to do it that way next time, but I won't be going back into old code to track down places where I subclassed.
You also can't 'reload' a file that has classes inheriting from a `Struct.new`
 class Foo &lt; Struct.new(:a) def a= x super "hi #{x}" end end Bar = Struct.new(:a) do def a= x super "hi #{x}" end end Foo.new.a = "hello" Bar.new.a = "hello" # =&gt; 'super: no superclass method `a=' for #&lt;struct Bar a=nil&gt; (NoMethodError)'
I think the argument that "subclassing from Struct.new breaks Kernel#load" is valid. Then again, maybe the solution is to fix that problem instead of playing struct police.
I don't think your expectation about how Struct.new operates meshes with mine. In general I think the idiomatic use of class Blah &lt; Struct.new doesn't work the way most people teach it. My only real question is this, why are you trying to call Struct#a= in your second example and what does it have anything to do with how Struct.new is used? I think a better second example is as follows: Bar = Struct.new(:a) do def a= x self[:a] = "hi #{x}" end end Bar.new.a = "hello" b = Bar.new b.a = "hello" b.a # =&gt; "hi hello" Assuming Struct works [the way it's defined](http://www.ruby-doc.org/core-2.0/Struct.html#method-c-new) and no other way why should we expect it to operate differently? Edit: Changed link to point to Struct#new from Ruby 2.0 for funzies and fixed a word I accidentally. Edit2: The more I think about it the above is just pedantry. After all, using the form suggested is still broken for file re-loading if the Struct is subclassed in the same file a-la: Bar = Struct.new(:a) class Bork &lt; Bar; end Or if it's in separate files and re-loaded in sequence: #first.rb Bar = Struct.new(:a) #second.rb class Bork &lt; Bar; end #Somewhere else load('first.rb') load('second.rb') load('first.rb') # produces warning as expected. load('second.rb') # produces error about superclass mismatch as expected. 
Excellent point, but I'm wrestling with myself over weather or not this is a problem with Struct since it's just doing what we're telling it to do. Is it really reasonable to assume that subsequent calls to Struct.new(:a) will return the same anonymous class? Is that the appropriate fix for the problem? Would it even solve the problem? I'm probably nowhere near qualified enough to ask or answer these questions.
57 lines to write a custom expectation, seems like work! Here's how you do in in minitest/unit: def assert_writes expected, to = :stdout out, err = capture_io do yield end output = to == :stdout ? out : err assert_match expected, output, "after writing to #{to}" end 9 lines. I'm fortunate that minitest/unit already has built-in IO capture support, but that's only 17 lines. I should have tested this, but it's so few lines it's easy to add new types of assertions.
&gt; it's bad because it pollutes the ancestor chain with an anonymous class. I'm not sure that's so bad. It may be harder to read, I suppose. But should have no impact on runtime or anything. Also, I think it's more common than people know: irb(main):001:0&gt; require 'delegate' =&gt; true irb(main):002:0&gt; DelegateClass(IO).ancestors =&gt; [#&lt;Class:0x007fb454156610&gt;, Delegator, #&lt;Module:0x007fb45415ef90&gt;, BasicObject] irb(main):003:0&gt; Another example: irb(main):001:0&gt; x = $".dup; nil =&gt; nil irb(main):002:0&gt; require 'tempfile' =&gt; true irb(main):003:0&gt; Tempfile.ancestors =&gt; [Tempfile, Dir::Tmpname, #&lt;Class:0x007f9474249590&gt;, Delegator, #&lt;Module:0x007f94741e0040&gt;, BasicObject] irb(main):004:0&gt; load ($" - x).last TypeError: superclass mismatch for class Tempfile from /Users/aaron/.local/lib/ruby/2.0.0/tempfile.rb:81:in `&lt;top (required)&gt;' from (irb):4:in `load' from (irb):4 from /Users/aaron/.local/bin/irb:12:in `&lt;main&gt;' irb(main):005:0&gt; I don't really find this behavior to be very bothersome. More bothersome to me are things like this: irb(main):001:0&gt; require 'tempfile' =&gt; true irb(main):002:0&gt; Tempfile.new('foo').is_a?(IO) =&gt; false and if you look at [the definition](https://github.com/ruby/ruby/blob/trunk/lib/tempfile.rb#L81), you'll see it "inherits" from IO.
Bar ||= Struct.new... That has other frustrations but those are easily fixed with a reload! method like rails has.
http://www.codecademy.com or similar websites. I tried this one, and the ruby course is nice.
I've actually started codeacademy for ruby like a week ago. I'm almost done with it. Yea I'm pretty slow but I have other priorities right now. I just wanted to find resources that would make learning ruby faster and easier. 
Try the koans - it's fun &amp; interactive way to learn: http://rubykoans.com/
I think this list isn't complete without [active_model_serializers](https://github.com/rails-api/active_model_serializers).
For straight-forward stuff, the [json](http://rubygems.org/gems/json) gem and JSON.generate does it for me. For more fun and control, especially in a Rails app, the [acts_as_api](https://github.com/fabrik42/acts_as_api) gem with JSON output is really great. 
I use the built-in json gem.
Gotcha! Thanks man that was helpful
Most ruby programmers I know learned through on-the-job training in rails. Ruby was my first programming language when I started at a rails shop about two years ago. I think the best and most motivating learning material was videos from [railscasts](http://railscasts.com) and conference videos from [confreaks](http://confreaks.com). They also give you a good sense of what the community is like. I also read a lot of books, which seemed to have good information but aren't as motivating for whatever reason. Reading the source to rails helped a lot, as well as poking around github and rubygems for neat projects. I still haven't found a good online community for ruby. I usually find it best to just talk to coworkers about new ideas and projects. Hope that helps! Good luck!
oh, you noticed too.
JS objects are not hashes! http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/
I made something similar as a rake script using the spritefactory gem
if you made this then you should namespace the sprite classes after the uploaded folder's name.
Haha good point! Thanks very much! :)
The [Ruby Rogues Parley](http://rubyrogues.com/) mailing list is kind of interesting. Fairly low traffic, higher level topics like design patterns and workplace politics. You get invited by supporting the Ruby Rogues podcast with $10/year or more.
This makes me sad, but good to know
Use `flat_map` if it has the semantics you want. Use `map{}.flatten` if it has the semantics you want. Don't prematurely optimize.
I think you shouldn't take your understanding of TDD and BDD from what "some devs" say. TDD is not for documenting your code and BDD is not for making management write your tests. Before you try to fix something, you should make sure you understand it. Documentation-first (or any other sort of requirements-first) development will always struggle with the simple fact that we rarely know what we need until right before we need it. Trying to figure out what you need too soon just leads to bad decisions. Writing a bunch of documentation that then becomes obsolete before it is implemented isn't a solution to anything. Your process of documenting the requirements and design of a program up front then writing code then writing tests is just the same waterfall development process that has been failing for decades. It's not a new methodology. It's the same terrible old methodology we've been trying to get rid of. Writing tests that drive development leads to better code, faster, with a more elegant design and fewer bugs that is easier to maintain. I'm not giving that up to go back to waterfall.
I use `flat_map`, because it is a pattern I use all the time. Also, you should also take into account [what OstapBenderBey pointed out](http://www.reddit.com/r/ruby/comments/14zja9/use_flat_map_instead_of_map_flatten/c7hynya).
What's the point of wrapping a C library and just using `method_missing` to delegate to underlying functions while exposing implementation details like pointers? Doesn't seem like a useful abstraction at all. The examples are terrible, too. They seem like C directly ported to Ruby: https://github.com/eclubb/ncurses-ruby/blob/master/examples/form2.rb
Yes, that's what I was referring to when I said "if it has the semantics you want".
&gt;Imagine calling @@sides.puts in Ruby! Well, *actually*, you're calling puts on $stdout implicity, with @@sides as the argument (without those optional parentheses) As a result, the following are identical: $stdout.puts(@@sides) puts @@sides Of course, when you add parentheses, you can call several puts's at once: puts("Hello", "world!") is the same as puts "Hello" puts "world!" So if you didn't already know, puts is just another method with your desired output being the arguments! :) EDIT: If you drop the parentheses, but keep the comma, it still works: puts "Hello", "world!"
In which case, my own prompt command would probably screw mine up, because it captures the last exit code. What I'm getting at, is that I don't appreciate some software automatically messing with my own shell environment. I regard as somewhat equivalent to it wanting to change the prompt itself.
Then don't enable auto-switching by default? **Update:** I've updated [chruby](https://github.com/postmodern/chruby#readme) to [safely append to PROMPT_COMMAND](https://github.com/postmodern/chruby/commit/5313b890f4b5403ab904ffb997ae8128a1c8674d). RVM will likely use a similar approach.
You cannot use non-symbols for keys with the new syntax.
That's where the both-guy comes in. You can mix and match syntax within one hash. But yes it sucks. why can't we { "foo.bar": :baz }
I'd recommend being consistent inside the same file. If you're working on a file that has the old. Use the old. If you're creating a new, create the new. And if you are upgrading an old, make sure that you replace them all. Nothing worse than having files with mix and match formatting.
While I appreciate that it looks nice, I never understood why we needed a new hash syntax. I would have rather seen the effort go into a shorthand syntax for Set or something. 
I like Compass: http://compass-style.org/help/tutorials/spriting/ Dump the images in a folder, get the CSS automatically.
There seems to be a lot of confusion over this but while it's a "new hash syntax" it's not *the* new hash syntax. It's extra syntactic sugar and *not* an entirely new way. Type `{ a: 10, b: 20}` into `irb` and you see `=&gt; {:a=&gt;10, :b=&gt;20}` come back. The hashrocket syntax is still the standard, default form for representing hashes and that hasn't changed. We just now have an *extra* way for use in certain cases. The hashrocket syntax is not "the old syntax" any more than Coke is the old Pepsi.
...aka. dash-rocket
Yeah, I'm thinking it should be standard though. It's just too useful and underutilized. 
Set is cool but for most list based usages (lots of small lists, where items are added and removed frequently) array is quicker.
I think it is more to get people used to the keyword args syntax. If you start calling methods now using the new syntax "something name: 'blah'" you can safely use kwargs in ruby 2.0. Thats how I've been justifying it.
We don't actually do that. We just discussed the possibility. In the end we agreed to be consistent within a file.
I like that argument. My main motivation for the new syntax is readability. Keeping the word- to non-word character ratio high makes the code flow more in my opinion.
You wouldn't use a Set data structure for most list based usages; you use it when you want uniqueness of values to be guaranteed within your data structure.
Obviously. The new syntax is meant as a shorthand for defining Symbol-keyed Hashes. Use the traditional syntax for Object-keyed Hashes.
But not in haml, which does support 1.9 syntax
I prefer the term "stabby lambda".
yeah, but I hate the 2.0 keyword args syntax for exactly the same reasons I hate the new hash syntax. :)
Definitely agree, literal set syntax would rock.
Looking up membership in an unsorted array is going to have O(n) cost. A sorted array brings that down to O(lg n). Testing for membership using a set is going to be amortized O(1). It will absolutely result in a performance difference on collections of non-trivial size.
Not any different than: { alpha: "hello", beta: "another string", user_id: 123, blah: foo } You're just used to the old style. I use the new style 99% of the time now and prefer it, though it was a bit weird at first.
Syntax highlighting makes a big difference here. Now throw in new style lambda's and start feeling like stabbing your eyes out :p {:foo =&gt; -&gt;(a){a.bar}}
Huh, I had tried it a while ago and it did not work. I wonder if I fat fingered something. 
He said incompatible dll ... so Windows.
It's RUBY, like you know, def my_awesome_function, you should know how to fix that, comeon. Just help the guy already! He obviously doesn't have time to mess around! 
Since I bounce between ruby and python a lot at work, I prefer the old syntax. Having a special syntax for a subset of the hashes you use seems silly to me, and I'm constantly expecting the new hash syntax to be as full featured and versatile as the python hash syntax it resembles. 
I think it's always important to point out the relative unimportance of benchmarks like these. Is Set faster than Array? Maybe. Does it matter more than using the object with the behavior you want? No. Don't prematurely optimize.
My answer is: Set is always faster than Array by its nature. - How Array#include? works? It starts from 0th element and goes one by one checking if this element equal to argument. As you can see in worse case we have O(N) time, where N – size of array. - How Hash#has_key? works? I say Hash#has_key? because Set is based on Hash. As you know hash works like array where our argument is key, so it takes hash O(1) time, because we don't need to iterate over elements to check if our argument there. You should not initialize Set for each include because in this case it is really useless. The thing is that for each task you need to choose proper data structure and Set (or Hash) should be used when you need to do many lookups for a lot of data. Actually prefix tree could be useful for such tasks either. Couple of days ago (what a coincidence) I wrote a post about converting Array to Hash for lookups: [http://gistflow.com/posts/582-array-include-vs-hash-has_key](http://gistflow.com/posts/582-array-include-vs-hash-has_key) As you can see Hash is **371 times (!!)** faster than Array (in case of 10000 elements Array)
I agree completely. The reason I did these anyway is because some folks in another thread (and even here in this thread!) were claiming that Set `include?` was _always_ faster than Array, and therefore you should always use it. I suspected it was _not_ always faster -- and indeed the benchmarks seemed to indicate that. I also agree with you that _even if it is_ faster in micro-benchmarks, it very well may not matter at all. But if _it isn't even faster_ in the micro-benchmarks, then it _definitely_ doesn't make sense to prefer Set for 'performance' reasons!
I think so. The speed is comparable if not better than Rabl too.
http://rubyinstaller.org/ to install ruby http://railsinstaller.org/ to install rails http://stackoverflow.com/questions/5775344/how-to-use-mysql2-gem-in-rails-3-application-on-windows-7/7313694#7313694 for specific help with mysql2 gem
json_expressions is awesome! We built a crappy alternative to it months ago but we'll be switching to that. Much more powerful than what we currently have.
To say one is faster than the other, you really need to specify which operation you are referring to. Your benchmark is measuring the time required to populate the collection (insert operation) and the time taken to do a n_reads searches. Searching a Set is much faster than searching an Array. On the other hand, inserting data into an Array is faster than inserting into a Set. What your benchmark shows is that the overhead of populating a Set for a small number of searches is not worth it.
Right, the thrust of it for me is that if you've _already_ got an array of items, it's almost never worth converting it to a set just to do some `include?` checks.
The big problem with your tests is you're always looking for the element "56". That means that the array lookup time is always going to take 56 comparisons, while the hash lookup can take longer. Get rid of the `:test_for` param, and instead make it test for a random value between 0 and (size-1), which is randomly generated for each read. You should see a huge benefit for Set. Alternatively, you could shuffle the array.
Sure, if you have 6M entries, Set is almost certainly going to be faster than Array, even if you are only doing one or two include? checks. (If you want to be sure, benchmark it though!) But when was the last time you wrote software that had millions of objects in an in-memory collection? I all the time write code where I have only a couple dozen items in an array, and check it for include?. People were saying "Oh, Set is obviously _always_ faster than Array for include?, always use Set", I was dubious, my doubt appears to have been justified, no? For only a couple dozen items in the collection and only a couple dozen include? checks (which is a pretty common case for me), it appears it probably doesn't make any difference or Array may even be faster. 
Ah, good point, you're right, thanks. Feel free to run it this way and report back! I may or may not get to it. 
As I said in the other thread, your scale is way off. It's very important to understand the characteristics of your data structures when you're dealing with large numbers of items (no, 10k is not enough). You're also looking for '56' in all your examples which means the list is finding the element it's looking for within 56 iterations every time. 
I hear you, but I've NEVER written code where I have 12k elements in an in-memory collection (let alone millions as someone else suggested). If you're doing heavy duty data analysis maybe, but not for the sorts of interactive (webapp and other) apps I write. Plus, I mean, if it DOES grow, how hard is it going to be change to a Set later? 
Thanks a lot, this is exactly the kind of feedback I was hoping to get. You're absolutely right about the structural difference between roles and decorators: there aren't any, really. But conceptually I'd expect that the methods on a decorator would always return values, and the records on a role would pretty much never return values. A role would almost always correspond to something in the application's language (a commenter, an administrator, a guest, an author, an editor, etc), and a decorator would almost always refer to something related to the *infrastructure* of the application: things that format, summarize, or transform data. So if you opened up a role object, you'd see lots of things that correspond to the actions involved in external usecases. If you opened up a decorator, you'd definitely be looking at something that is literally an adapter. (I'd be comfortable using that name for them even) I'm pretty much in the same boat as you regarding adapters vs. modules: I feel that adapters cost you a little bit up front every time you use them, but that the pain for them is a constant cost, where mixins have combinatorial costs to them. I am hoping to find the default position that gives us a place to start from that on average, reduces the *average* pain of maintenance over time. It's worth noting that I'm not suggesting this as a universal architectural pattern to be followed blindly: only a possibly decent place to start from when you don't have a clear sense of what the best kind of organization would be for your objects.
yep, true. Doesn't change the fact that lots and lots of rubyists seldom if ever write code that needs to keep 10k+ items in an in-memory data structure. So the idea that "Oh, you really always want to use Set" does not apply to them. That's really all I was trying to get it, saw people claiming that, wanted to see if it even hypothetically mattered in the sorts of situations that many of us typically work at, found that not only didn't it matter, Array is often better at the sort of usage patterns typical for me and many others (although probably not in a way that matters much in the end). That's all that i was trying to say. 
The best way to communicate intent in your code is to document it. You can use [YARD](http://yardoc.org/) to add type information for parameters of methods, what they yield, what they return and when they raise exceptions.
These measurements are invalid, they will be absolutely dominated by the time taken to create the particular data structure. That should be outside of the simulation. Or I guess you could change your text to say "is it worth instantiating a set every time I want to check include?" but y'know, that's not something anyone was ever saying.
Thanks for sharing that. It does seem very invasive, but it's nice to see you have lots of examples.
Oh yeah its hugely invasive. My objective was to meet DCI's requirements 100%, things like being able to add and remove roles and faking #unextend, even if it meant multiple sacrifices to the meta-programming gods. More an experiment really! If you have any questions i'd be happy to explain how it works. 
Hostname(s) in deploy.rb, and everything else in `.ssh/config`
His answer is true, asymptotically. Your answer is true because it is faster to find the 56th element of an array than to convert an entire array to a set, then check whether 56 is in the set. Since you need to touch every element of an array to convert the array to a set, I would expect this to be true for every array longer than 56 elements (at least!). You are talking past one another because makaroni4 has some training in complexity theory, and evidence suggests that you do not. 
What? That's not my job, I've notified you of what is clearly a mistake, you should fix it. Seriously, you made a bold claim substantiated by methodology that is clearly deeply flawed. The onus is on you to fix it.
I don't have a big issue with using composition to do DCI, other than worrying about the self schizophrenia thing. I guess it means you are coding one step away from your 'data' object which is okay if the code reads well. That said, most of the guys who developed DCI say its not proper DCI to use composition.
So why are you bitching about it on reddit if it's not your job? Okay, done updated with some more stuff. Dude, I think it's good if people (like say me) benchmark stuff and share their benchmarks, even if they're not completely sure if they're doing it right. I tried to provide enough info for people to know if I was doing it right or not. Then it's good if people who notice it's not right say so and explain why and how, indeed. Then we all learn more. My initial post said quite clearly, please let me know if I'm doing it wrong. shrug. I provided the code so someone else could run it again themselves after editing it; or someone who just wanted to point out why it was wrong but not spend the time to fix it and run it themselves can do that too, indeed. You perhaps think that nobody should ever post anything unless they are completely sure they have it right. You're entitled to that opinion. But anyway, yes, updated the gist for the '56' problem. 
yeah, 56 was a big flaw, sorry. But yes, I understand asymptotically. But actual apps with actual use cases have collections whose size does not grow to an asymptote, I was curious how much it mattered with actual MRI implementation and it's constant factors, and with actual scenarios that approximated patterns in my actual code. But I have no idea if I did that or not, anymore. Got me. I have updated the gist to mention the '56' problem,and provide some data on other runs where the target is in the middle of the array, and not in the array at all, to see how that looked. But I have no idea what it means, and no longer claim to, no problem. I will think twice before attempting to answer a question with benchmarking in the future. 
It's great that you benchmarked it, and the great thing about the internet is that people are there to point out mistakes and help you learn. I would never attack anyone for that, in fact I'd be supportive. The issue is that when a *clear* mistake was pointed out your response was *Feel free to run it this way and report back! I may or may not get to it.* That's a shitty attitude. Your benchmark was clearly called out as wrong, and rather than fix it you expected others to go the extra mile. Something about that kind of attitude really bothers me.
The other issue here is that this is benchmarking insertions and reads simultaneously. Generally algorithms are profiled separating those two out because their characteristics are so hugely different. In the case of a ruby Array appends should be O(1) and a lookup's worst case is O(n) with an average case of O(n/2) In the case of a Set (backed by a hash in this case), it's O(1) on both insertion and lookup so long as the hash is sized correctly (which I don't believe you have control of in ruby) and there aren't collisions. If the hash must grow then rehashing has a cost as well on insertion. Unfortunately calculating the hash has a relatively high constant cost in comparison to simply appending to a linked list, and that's what accounts for the discrepancies here. However, this cost disappears quite quickly. Depending on your use case this has a huge effect. The right way to run these benchmarks would be to run separate tests for reads vs writes. Combining the 2 only confuses things as real world applications vary wildly in their read / write ratios.
Right, everybody knows that the Hash/Set is O(1) append/lookup and the Array is O(1) append and O(n) or O(n/2) membership check. Nobody needs need to benchmark to do the big O. But there's a constant factor in those O(1)s and O(n)s that only matters in actual implemented algorithms and apps, not in theory, and the constant factor may be different in the different collections, and may make the 'break even' point at different sizes of the various factors. And actual apps is what we've got. And an actual app will _always_ have to build the collection before it can check for membership in it, the cost to build it really does matter, right? For deciding if you get any advantage in an actual app to switching, not for calculating the big O. So I was trying to benchmark patterns that might match actual code like the kind I write (where I think I've probably once or twice in the past 5 years created an in-memory collection with more than 10k elements in it, for instance). Perhaps I failed completely. I have no idea, I give up. Certainly people can make up their own minds. (I will admit that I still believe that for my actual patterns, where my collections seldom have more than hundreds of elements -- it's not going to make any difference that matters unless I'm doing thousands of reads, and if I'm only doing dozens of reads use of Array may even be faster (but prob not in a way that matters). But people can make up their own mind, and do what they will. Clearly the most important thing is that we get to argue on the internet.). 
My deploy.rb pulls all hostname information from EC2 tags. Each instance has an application name, application env, and roles tag. Each environment has it's own task which sets deployment variables, queries the deployer for the branch or revision to deploy, and sets up a task for querying the EC2 API for instances matching the tags. 
That does clarify a few things but I'd say it all comes down to how you use modules. Including 5 modules but only using 1 is a end developer flaw. The same applies to decorators: if you have 5 decorators and apply them but only use 1 you're left with the same problem.
I like the examples as I was only recently talking to a friend about ways of reducing the size of models in large applications. My question would be where is the best place to store concerns? In the models directory? Create a new directory?
&gt; That is a nice idea... but I think the concern I have is that I like to conceptually black-box things, and I like my files (and object) to be aimed at a singular level of abstraction at a time Yep makes sense, though I don't think this is incompatible with DCI. &gt; So if you look at the example I provided for my MRDI, I like to be able to pull open the file that reflects the "layer" I'm interested in: either the logic, the data, the presentation, etc. Yep again makes sense, but I think you are also mixing up issues with DCI with issues with the application architecture. You can do all of that with DCI. 
This blog post describes how to easily generate advanced image transformations for your Ruby on Rails applications while using the CarrierWave GEM for uploading images to the cloud and assigning them to your ActiveRecord or Mongoid model. All image transformations and delivery are done in the cloud by Cloudinary. Disclaimer: I'm one of the co-founders of Cloudinary. 
I think that you may have missed something: Even if you use all 5 modules, you never wanted (nor needed) for the five to interact with one another, you just wanted the five to interact with the object you mixed them into. But by design, they're all mixed into one space unless you do something like extend() at the instance level and throwaway the object instances (as many implementations of DCI do in Ruby)
Again, I currently am skeptical about what is "proper" and "improper" because I have seen neither a compelling argument that shows the real problem in code, nor an example that shows the significant advantages of direct data access. This is a new, heavyweight pattern. More effort needs to be put in by those who are developing it to justify their claims with real world examples. We can't just accept ideas like "It's not proper DCI to use composition" on faith: we need to have a clear understanding of WHY.
This isn't a new idea in rails, right? CakePHP has been doing this for ages with [Behaviours](http://book.cakephp.org/2.0/en/models/behaviors.html) :)
Ryan Bates just did a Railscast about this, he has a very interesting take on this. http://railscasts.com/episodes/398-service-objects?view=comments
I really like this idea, especially because I sometimes forget to push branches, would be nice if this could eventually also support checking for updates, perhaps even git-fetch'ing repositories, etc. Anyway, keep it up
(sorry, I tried to put in /r/rails first, but like 50% of what I post to /r/rails ends up spam filtered by reddit, including this one. Not sure why, and not sure why I don't have that problem in /r/ruby. If you think this is spam, then downvote and/or let me know. :) )
From the article: &gt; Basecamp Classic’s domain model is 8+ years old now and still going strong with the use of concerns. From the CakePHP Wikipedia entry: &gt; Version 1.0 was released on May 2006. One of the project's inspirations was Ruby on Rails, using many of its concepts. 
xposted to /r/rails.
Never used RubyMine, and I'm assuming this is a Rails app, but does that include any embedded Ruby console/server/processes it may have? Because I use Vim and terminal panes, but each of my `rails server` and `rails console` panes eat 300-400mb each. Doesn't take much to hit a gig. 4gb memory just isn't enough these days :(
its an java-based IDE, not a rails app. 
So did their original domain model have concerns built in in 2004? 
I feel your pain. I paid for a license because I had good success on a hacked version of IntelliJ I had for my Ruby environment a few years ago. After an hour of watching it relentlessly consuming resources I have yet to open it again.
Annihilated.
I can't really speak for them but i suspect they don't consider it correct because by definition in DCI you make specific methods available to an object rather than a proxy object. So its more about how they define DCI. I guess they can do that as they created the paradigm. I'd agree with you talk of proper or improper form is a bit silly, if something works it doesn't hugely matter what technique is used. You say that DCI is a heavyweight pattern, I don't actually consider it that heavyweight if the tools are in place for it to be easily implemented. After all it is roughly. 1) Give objects roles in a context. 2) Roles enable role-methods on those objects. 3) Context executes and objects Interact as their roles. 4) Context finishes, and roles are unbound from objects. Pretty simple in theory.
exactly why I passed on the 75% off JetBrains uber-sale today
I've been using RM (with VIM plugin) almost daily for a little over 2 years now. It has always been a giant ram pig, nowadays I use an early 2012 MBP with 16GB memory so I don't feel that pinch anymore. In my experience the CPU only really spikes like that when it loads up or when switching projects. There were times in the past when I had a lesser amount of memory in my machine when i'd get fed up with it and go back to Textmate (I did a good run with sublime text2). The visual debugger and repl (of suspended live webapp!) always draw me back though. The other niceties of the refactoring tools and code completion are nice. One thing I wish it did have was the 'search for anything' mode that sublime has. so, long story short: RM is great if you're into debuggers and navigating large code bases AND have enough memory to let it do it's thing. 
And [a comparison between RubyMine and IDEA + Ruby Plugin](http://devnet.jetbrains.net/docs/DOC-1146). Basically, IDEA with the Ruby plugin has all the features of RubyMine and more, and plugins for other languages (PHP, Pyhton, etc.), but the interface is a bit more complex because it isn't pared down for just ruby.
Use VIM
Side note, Jet Brains has a sale with 75% off all personal license for 6 more hours (8:30 PM PST here). Pick up RubyMine for $20 or so.
When my computer runs slow I just give it a ram or two. 
I typically dislike advertising, but I will be a shill for Jet Brains any day. Good company, good software.
Someone asked me why I had such a hardon for RM's debugger, this was my reply: I'm the type of dev that likes to drop into a debugger while reading code or developing on top of frameworks. Pausing execution and having a look around at the state of the app provides such a bigger and more complete picture of what is going, really speeds up my understanding thus allowing me to crank out better code faster. So, I've been doing this along time and grew up using GDB, etc. One day I picked up eclipse when I started doing java dev and discovered the joys of visual debuggers. Now I try to find something similar with what ever technologies I'm working on at the moment. To answer your question, I came back to RM because of it's visual debugger. I was happy using ruby-debug in the past but the visual debugger gives such a better 'at a glance' picture of whats going on that going back to command line debugging felt like I was wearing blinders. Typically if something is happening that I just don't understand I'll drop a break point somewhere sensible and try to hit it. RM's debugger interface provides a few tools that i find indispensable: * The big picture, being able to add watchers when ever, seeing all of instance variables at once * Being able to drop into a REPL with all of the app's context loaded up. This is different than the rails console in that you can have your whole stack going, users logged in, background jobs running, etc. It lets you play with what ever is going on at that moment. * RM will load source files while stepping though the app when you enter a context you don't already have open. This includes source of any gems or libraries * Being able to step though the stack while paused. This is great if you think you've set your breakpoint too deep. you can step though the stack to see how you got to where you are and what the state of the world is at each step. ruby-debug can do all of these things in one way or another, but having them all immediately available in RM makes them far far more usable. So, i'll drop a break point, step though, see something fishy in a library - bust open the repl to do a few ad-hoc tests then fix the problem. Saves me loads of time having to make guesses with Tests or god forbid, print statements. RM needs memory, feed it all it wants and it'll make you happy.
"Speak Klingon, it's very powerful and easy once you learn it. " Edit: Yes, I would like to use vim as it's available on everything incl. terminals and I've seen the magic pouring under people's fingers. I wish I could have the muscle memory downloaded into my brain Matrix style. Until then it's SublimeText2 and Textmate shortcuts.
Sublimeee Text!!! 
No, but concerns are really just mixins with a little bit of syntactic sugar. And people have been pulling logic out of models and into mixins since the beginning of rails. Kudos to Cake for being the first to add a new capitalized pattern, I guess. 
If it weren't for "jump to declaration" and "extract to variable" I would have literally no reason to use Rubymine over Sublime.
Exactly why I requested 16 GB in my Macbook. And yeah, Invalidate Cache has become my new best friend.
Is this like a Christmas-time thing? http://jaydonnell.com/blog/2011/12/29/i-love-everything-about-rubymine-except-this/
Hey Sandal, thank you so much I really appreciate that. Very unexpected and cool! By the way I've finished my article, so have a look [here](http://rebo.ruhoh.com/why-dci-contexts/). It may not change your mind at all but hopefully you can see some advantages. 
It's news basically because DHH has been criticizing DCI and other "enterprisey" patterns that people have been proposing to clean up their app/models directory for a few months now. He has finally actually introduced his proposed solution, and it's a rebranding of something that already exists, with a shiny new directory added to the load path: app/models/concerns. Your original post sounded like you were poking a little fun at Rails for being "behind" CakePHP. If you did not intend that, I apologize for my snarkiness.
Very much looking forward to DataMapper 2, can't believe I took so long to try out DataMapper v.1, its really great.
that's the one!
Damn, tried all those... anyone wanna remotely help me? I'll paypal you 20$ if you solve it
You know what you call a struct with methods? A class. Try using them!
reference
It's call by value. And it also passed reference by value. If Ruby actually call by reference, you will be able to do this. def swap(a, b) temp = a b = a a = temp To swap value of caller variable. But you cannot do that in Ruby. So Ruby is call by value. Note that you can change the internal of object `a` and `b`. But that's because variable to object in Ruby is reference to the actual object. Beside C++, most other language only do call by value, even if that passed value is actually a reference. I'm aware that my answer may not agree with the other comments. But if you looked up how C++, the language where it has both kind of calls (and also call by passing value of pointer), works and look up Wikipedia topic on this, I think you'll agree with me.
In a call-by-reference language you don't need to change the object pointed-to by a variable in order for the change to be visible to the caller. In a call-by-reference language changes to the variable itself will be visible to the caller. So Ruby is not call-by-reference. What Ruby (and Python, Java, C#, Lisp, ...) does is commonly known as [call-by-sharing](http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing) or call-by-object.
Yes, exactly.
And when you say x = 4 You are creating an object 4 and then changing x's reference to point to that object. 1.9.3p194 :001 &gt; x = 3 =&gt; 3 1.9.3p194 :002 &gt; x.object_id =&gt; 7 1.9.3p194 :003 &gt; x = 4 =&gt; 4 1.9.3p194 :004 &gt; x.object_id =&gt; 9 
If you don't mind, please ELI5 how this differs from ActiveRecord and why it (may be) preferable. Is it like Hibernate or Doctrine 2 (PHP)? I think I want to try it out on a new project. 
You're getting downvoted for a mistake in your second sentence. That's an example of call-by-reference, not call-by-value. Kind of a shame, since you're otherwise correct. All variables in ruby contain references to objects. Those references are passed around by value. These semantics are identical to Java's object-typed method arguments, which are commonly accepted to be pass-by-value. See: http://stackoverflow.com/questions/40480/is-java-pass-by-reference
I prefer pry for this stuff ;-) 
We had similar problems going outside the lines with Rabl. It's really, really terse, and can prevent DRY problems by putting JSON generation inside a view, but it had a tendency to be much slower than building the JSON hashes by hand and arbitrary nested objects could be painful.
I'm far from an expert as i've only recently been playing with DM but I like how DataMapper is more declarative in the class files. For instance a DataMapper class looks like this : class Animal include DataMapper::Resource property :id, Serial property :name, String property :notes, Text end I can see exactly from a glance what properties it has that get persisted. No need to separately migrate databases. Also I like how classes that use DM just #include it rather than inherit from a base class. I can't really comment on Hibernate or Doctrine i'm afraid, as i've not used those.
I suggest you to run it in 32 bit mode. It will use less memory...though I see your problem is CPU.
Only one way to find out! :) Fire up irb and try it out. 
Ruby is call-by-value, but most values are references. 
Anyone want to explain what this is for me?
Whoa. That's pretty neat, thanks for the explanation. 
What was the problem with jenkins?
&gt;have your CI run on your local machine rather than have a server for it I think we're missing the point of the 'I' in 'CI'. Running it locally is going to require every dev to merge in upstream changes as well as remote changes from all other devs on the their local copy just to check their code.
how is this better then just using [Nokogiri](http://nokogiri.org/)?
The proper terminology is "call by object", as in Python.
mechanize uses nokogiri.
Thanks. That's actually the book that I was looking at buying next.
awesome! that's just the kind of thing I was looking for. thanks
Interestingly enough the current site I'm working on is doing some screen scraping of recipe sites. I wrote rspec tests using [vcr](https://www.relishapp.com/vcr/vcr/v/1-6-0/docs/test-frameworks/usage-with-rspec) pointing to a random recipe I picked. Then I just occasionally update the vcr cache every once and a while and if the test fails I know they changed the page. I'm looking into automating this and just having it run daily and emailing me when a site breaks. It isn't a perfect solution but I can cover the major recipe sites.
I agree, the gem is a horrible idea. Although if I can automate the rspec tests I might make it into a gem. I tend to do a lot of screen scraping and honestly just knowing when it breaks is really the most important part.
This is not a new scrapper gem! The purpose of this gem is to simplify the extracting of data from a page classified by the website name. The gem is might break, so you have to check the building status on Travis-CI. Note that, the only implemented websites now are Techcrunch and Mashable and extracts only its title and body. You can help me add more websites and tests.
You may have interests on my little plugin https://github.com/janx/vim-rubytest
woah, you've helped me in #ruby-lang before! Nice to see you here. I am perry @ freenode.
Yes. The make command does block, but if you use it and you use :copen to open up a "quickfix" window, it makes fixing compilation bugs a lot easier. I do like your script from a testing perspective. I run Awesome instead of XMonad and I feel the same way. I may have to try it out for testing as well. I'm thinking that perhaps I just do clean builds from within Vim to leverage the error window, but then run my tests using a script like you suggested. Of course, I do mostly Java development now, so I don't get test messages in the quickfix window. Not sure about other languages.
Have you read the Well Grounded Rubyist? 
This is not the Python Imaging Library.
Although you qualified this question with "One step above looking at the source code itself", it might not be a bad idea to do just that if you are able to grok C code. Ruby's source code is extremely clean and concise, and there is certainly a wealth of tacit skill to be gained from having a low level understanding of it - especially if your goal is to understand how Ruby works "behind the scenes." If you do go this route, I'd suggest you start out with looking up how some methods have been implemented in native code. Go look up how 'puts' is implemented. It's in io.c, and almost reads like Ruby code forced into some sort of Frankenstein C-language mold. Work your way up to language features - see how classes and inheritance work; and then up to gc and the vm. There's no book in the world which would supplant the level of knowledge you'd gain from getting neck-deep in the true nuts and bolts - if you're up for it.
If you commit to vim, the learning curve is 1-2 days.
My exact thoughts while reading this, except that Avdi also defines `to_model` and `class` on his Excibit classes, to make them work well with rails `form_for` and such helpers, as described here: http://objectsonrails.com/#sec-12_4 (at the bottom).
&gt; This is not a new scrapper gem! The purpose of this gem is to simplify the extracting of data from a page classified by the website name. I don't know what that means. 
I'd like to see more "filters" like this. Protect your users from themselves, and help everyone be a little more secure.
Awesome! I'm also judofyr@gmail.com if you need some help/feedback :)
Thanks for the recommendation, Juan!
A couple comments: * Unnecessary to test for "@datafile.nil?", which only occur if one instantiates PasswordList with nil. open's error would be sufficient for that case. * Rather than file = File.open(@datafile) file.each_line { |line| @passwords &lt;&lt; line.chop } I would do the following. Which is both cleaner and faster. File.open(datafile) do |file| @passwords = Set.new(file.readlines.each(&amp;:chop!)) end * No need to store the filename as @datafile, it is unused. * I wouldn't have attr_reader :passwords, or test that it is a Set/Array; purely an implementation detail. * Normally lib/pil.rb would be used to define ::Pil, not lib/pil/pil.rb * There's no reason for ::Pil to be insatiable or to be a class. All Pil instances are identical, and the root of a library is usually a Module. * The readme describes creating a validator from ActiveModel::Validator. Using ActiveModel::EachValidator, one can make a reusable validator for an arbitrary column name. Usage would be something like: validates :password, uncommon_password: true
Same. Shift + Click is godsent!
It's not always just, like, your opinion, man. RubyMine has some serious problems.
Some excellent points here, jhawthorn. I've incorporated most into v0.3.
Probably worth giving a look to vim-vroom: https://github.com/skalnik/vim-vroom 
All the plugins I have looked at block vim till the tests finish, which is a huge pain. Just checked out vroom, it has the same issue. This snippet on the other hand doesn't block vim, and makes it usable for me.
If anyone has an idea of why that is happening, please let me know
does anyone have a suggestion for a vim tutorial in ruby? i know that this might be sort of a silly request, and that i should learn vim by just doing stuff in it, but ive got a huge backlog of stuff i want to finish by the end of the year, and i kind of want my hand held at this point 
Hi. I am the translator of a book called "The dRuby book", and I choose the word "Pass by Reference" in the book, and had a big debate with one of the book reviewers, and this is what I explained to him. https://gist.github.com/1381070 . In a nut shell, you pass by value, but you can also pass the value of an object reference. This is also called "Call By Sharing" 
Could you point me to one resource which could see me through that? Please only one. 
Well, with RSS all the work is done for you and it's unaffected by Markup changes. 
I would recommend vim's tutorial. You can invoke it from the command line with vimtutor.
&gt;Do they expect people to know the exact patch number they're on? Yeah, it's not that hard. Considering the patch number is always displayed along with the version, it's basically part of the version.
The only time i see the full version number is when I open up irb (if I'm not using pry) and when I do my brain skips everything after 1.9.3. I prefer python's versioning system, makes things a lot easier to comprehend and explain. Edit: I'm referring to the moments where I see the version number without using ruby -v
In Python, you only have to worry about the 2.X or 3.X version numbers. 2.X.Y or 3.X.Y are bug fixes and aren't meant to break anything. I find it hard to believe that in Ruby, a 1.9.X release can introduce game breaking issues and developers have to know the exact patch number they're on. I'm only using ruby for personal pet projects so the patch number doesn't really concern me at this point but it just seems like the versioning system is overcomplicated.
No issues, just annoyed at the way versioning works in ruby.
My insignificant opinion is that this whole post is bullshit. Resources being used?! zomg! Dude... you're not just running vim here.
I use ed, it uses like 1k of memory!
what's the difference between a minor number increment and a patch number? I'm guessing most people don't really care either way; they just install the version with the biggest minor number and forget about it for a few months. It's rare people get excited about minor bumps unless there's a security hole. And if they're just using it on their laptop, they probably wouldn't care about security fixes either. I'm still running ruby 1.9.3p0, node 0.8.11, and python 2.7.0 on my laptop which are all a few versions behind trunk but I haven't bothered with upgrading. People who make a fuss about the way version numbers work are just bike shedding. Honestly, I really doubt many people care.
I find it awkward discussing new minor versions of any programming languages in general. I can't think of the last time I told anyone about the new minor upgrade to gcc or java. Do you know the differences between gcc 4.2.1 and gcc 4.2.2? Also, ruby has multiple runtimes -- this one is only the "official" one, but one could be using jruby too. jruby has their own set of minor versions too, but really nobody cares about those minor versions. Maybe there's a 10% speed bump or corner case bug fix, but it's rarely the reason to rush an upgrade. Talking about patch version numbering scheme is like discussing if your bed should have teal or blue cover sheets, it doesn't affect anything either way.
Hey, it takes 2 to argue. I guess we'll just have to agree to disagree then.
I wasn't arguing with him though...I agreed with his points and highlighted why I was annoyed... According to this comment: &gt; If you don't know what Ruby version you're writing code on you're doing something seriously wrong. So obviously people do bat an eye in this thread. All I'm saying is I don't like the way that ruby numbers their releases and prefer a more sensible method e.g. python.
The question is, Does every website support RSS? and how to fetch an old article via RSS?
It's actually one of the many things that Ruby used from Perl. Perl doesn't have an exclusive range operator; just the inclusive one (..). So the 3-dot one was a later addition for developers who wanted an exclusive range without popping off the last element.
Perl did it this way first, and it's very good syntax.
 I agree. I've never needed the exclusive one, and when it occurs in other people's code, it always surprises me. (If I notice the third dot.)
I must admit I did not know the exclusive, but perhaps you can think of 1...5 as if 5 is further away and therefore outside the range? 
And then I have to carefully re-read the method surrounding said range to ensure it's not a typo. 
yeah, just need to buy a ticket.
I always remember it by imagining that the 1...5 syntax extends out that the last one pops off :p
Let me remind you of the excellent metaphor from [why's (poignant) guide to Ruby (chapter 3 -&gt; Ranges)](http://mislav.uniqpath.com/poignant-guide/book/chapter-3.html): &gt; "When you see that third dot, imagine opening the accordion slightly. &gt; Just enough to let one note from its chamber. The note is that end &gt; value. We’ll let the sky eat it."
The article seems to care more about self-promoting an ebook and attacking DHH than promoting the merits DCI. Does this obvious drama seeking and attention whoring really sell books? This is exactly the type of shit Ruby and Rails does not need. 
I haven't used ruby shoes in osx, but I would recommend green shoes. It's a pure ruby variant, meaning you can use it as a rubygem. There are some differences, but it makes it easier to use then the default ruby shoes.
I'm trying compiling it myself to see if that will give me a fully functional Shoes app. I'm using the guide I linked below. https://github.com/shoes/shoes/wiki/Building-Shoes-on-Mac-OS-X-10.6-and-10.7 EDIT: This failed to compile with homebrew. This has just been an unlucky day. 
Unfortunately it failed to install :/
But it is so delightfully absurd you won't forget it.
Hah. Thanks. I've had part 1 open in a tab waiting to be read for a while now. Now I have two.
I concede your point. Happy new year!
Yeah, while I love shoes for its simplicity and easiness, there's tons of bugs in it. I don't work in osx, so can't help you there. Hope it works out.
first you say it's not a scraper gem, then you say you're trying to do something by scraping the web page. (assuming both 'scrapper' and 'scarping' were typos for scraper/scraping). It sure sounds to me like you're scraping. It'll be a library of custom code for scraping various websites, right? 
Think of it this way. (...) means the right end is farther way and it's so far away that it's not even there. I learned this from _why.
I highly recommend it - Portland is a great city, in addition to the quality content of the conference.
there's a tesseract gem I think.
I am using https://github.com/dannnylo/rtesseract works beautifully with resque and state_machine 
You basically want to use tesseract then one of the many ruby bindings for it
There are no real choices but to use Tesseract either forked or bound via native interface.
Everyone has suggested Tesseract and I agree. I actually use this in one of my projects and it simple to use and works great. 
looks like tesseract.
If you find binstubs obtrusive and prefer simple `$PATH` manipulation, you should investigate [chruby](https://github.com/postmodern/chruby#readme).
Honestly, you might want to take a look at MatLab for your OCR, and just run your data manipulation and rendering in Ruby. I have very little experience in this, but I've seen some MatLab + Ruby OCR work done well. 
You could also check out the Docsplit gem which provides both a programmatic interface and command line tools for processing a variety of tools including tesseract: http://documentcloud.github.com/docsplit/
I'm willing to bet that gets.chomp returns a string matching the input with the newline at the end removed. The thing is, the rand method returns a numeric value. So, the string "1" and the number 1 aren't the same.
If you're simply checking the equality of the two, you could convert the randomly generated number to a string using to_s and compare those.
you need to convert one or the other variable to the same type. Most likely you're looking to just compare numbers so you would do something like: number = gets.strip.to_i if number == 4 # Yay, it's 4. end The String#to_i method converts the numerical value represented by the string into an integer object. This looks like homework assignment. Good luck learning more. I think the major thing here is to understand the difference between Instances(Objects) and Types (Classes) -- in this context. And that something of one type does not (generally) equal something of another type. And that there may be more in depth rules going on for equality checks between objects of the same type. good luck.
 rand = rand(1...3) rand.to_s Had no effect either :/ &gt;&gt;What's the random number? 2 &gt;&gt;nope, it's actually 2 
 gets.strip.to_i Was exactly what I needed! Not a homework assignment; I kind of wish it was. The closest thing my high school offers to Ruby is French :/ Thank you very much for both the solution and the speedy reply!
just sending rand the message to_s won't accomplish anything. you would need to store that value somewhere, otherwise it just gets lost in the ether. also, you shouldn't call your local variable rand since that's also the name of the method for generating a random number. you should do something like rand_num = rand(1...3).to_s; if gets.chomp == rand_num
 print "Choice?" choice = gets.chomp rand = rand(1...3) if choice == "5" print "What's the random number?" num = gets.strip.to_i if num == rand print "yup" else print "nope, it's actually #{rand}" end else print "not 5" end *That code works, just in case you were wondering. I hate it when people don't post the answer to their problem, so here it is :) Major thanks to [byu](http://www.reddit.com/u/byu)!
no problem. FYI, a couple of other beginner resources you might be interested in starting to learn ruby: http://www.ruby-doc.org/ http://www.ruby-doc.org/docs/ProgrammingRuby/ http://www.codecademy.com/tracks/ruby 
Thanks! I love Codecademy; went through their HTML/CSS courses as a refresher before doing some work for a mate's mum. Thanks very much!
About your looping question, an infinite loop is `loop do ... end` or `while true ... end`. You can break out of an infinite loop using `break`. If it makes sense to have a condition at the top of the loop, you can use `while &lt;condition&gt; ... end`. So... What exactly did you mean by "until you quit the program"? A special value in the input? User pressing Ctrl+C? Something else?
How do you deal with layout issues? Tesseract seems to just throw everything together
Woohoo!
I'm hoping to have it read some sections of a simple game screen, I think I can just split the image into appropriate segments though.
Honestly, if this is your response to one random dickhead on reddit accusing you of being someone else's sockpuppet, you probably do need help. Also, what does lists of words used by each account but not the other prove? Surely if you wanted to prove anything you'd want to come up with some kind of frequency-chart of words that might serve as some kind of hard-to-fake fingerprint for your writing style.
Yep. That's why I specifically said by default. I sort of wanted to get him started thinking about return types early in his life because that will save him from a lot of headaches in the future. 
I do not want to seem condescending, but there are much better exercises for the set of skills you are trying to learn. Check out the sidebar. I think Shaper_pmp's point was that you shouldn't get so worked up about some random troll replying you on reddit. 
Fair enough - I was only joking, but I think you've got a way to go before this is anything interesting. &gt; I'm probably not the only one to encounter this "sockpuppet" issue on reddit. See, if you turned it into a general service *that* might be interesting. Make it something like redditinspector, so people can sign up to have their comment history scraped, and distill the results down into some sort of easily-compared fingerprint or minor-variation-tolerant hash for each user. I don't mean to be harsh, but what you've got so far is almost worthless - it's half a dozen lines of ruby that proves nothing very much so far. The value (and the interesting problem) is in generating: * an easily-compared fingerprint * that's nevertheless tolerant to small variations (so recalculating it after each few comments won't give a radically different result), and * that ideally captures aspects of someone's writing style that's hard to fake out (word length, vocabulary breadth, reading grade, etc)
I think it would be nice if the string "exit" closed it. Would loop do ... end ensure that a new random number is generated every time the user passes through the if/else chain? I'd like a variable to change every time (the random) but I also want a value to maintain throughout, such as a number of games played for example: choice = gets.strip.to_i random_number = rand(1...10) number_of_wins = 0 number_of_losses = 0 if choice == random_number print "Yay!" number_of_wins +=1 else print "Oh well" number_of_losses +=1 end
Thanks! I'll see what I can find online about return types :)
I found the word lists a little suspect. You never used the word "or"?
Another alternative I was considering was using markov chains - analyse a corpus of text to build a hash of all words used and an ordered hash of the most probable words that follow each one. Then compare the hashes of two separate users and see how similar they are - perhaps strip out all the words *not* used by both users, and compare how similar the follow-on words are for each word in the hash to see how similar the two users' phraseologies are...
great blog post, ronbrowndbt
Sure. Whatever you want to happen each time goes inside the loop. number_of_wins = 0 number_of_losses = 0 loop do choice = gets.strip random_number = rand(1...10) if choice == "exit" print "Kay, Bye!" break elif choice.to_i == random_number print "Yay!" number_of_wins +=1 else print "Oh well" number_of_losses +=1 end end
That's exactly what I'm after! Thank you!
This was my first thought for moment, too. But then I realized, I often put WAY too much into writing a ruby script to scratch some stupid itch that would have been forgotten in a minute otherwise. If it was me, this program would have unit tests, a database backend, and a web interface before it was done. Then I would probably just delete it before even showing anybody ;) I see it as an interesting thought experiment and programming exercise. If OP is being neurotic about anything, it is probably about playing with ruby, which can hardly be considered a bad thing :) I would file this under "using ruby to examine everyday problems".
ctrl-c out of everything then type reset. it should be fine after that
I think… I think you're in the Matrix...
Good to know!
"Well...shit."
I've had this happen to me in Django's dev server, too. Anyone know the common cause?
You garbled your terminal by printing binary data. Yawn. Just cat /boot/vmlinuz
Your terminal cannot handle some escape sequences. About halfway through [this page](http://mosh.mit.edu/), there are some screenshot examples.
I didn't know ruby ran on the Commodore 64
Your BIOS has been hit with cosmic radiation. This is bad. What you see here is your CPU accidentally entering real mode as a result, corrupting all kernel memory, especially the memory that handles virtual PTYs. Cosmic radiation doesn't hit every component but does generate secondary generation through transmutation, so most of the memory blocks are corrupted but some are not, thus the reason why you still see a little bit of sane text in there. One way to solve this problem is by reversing the voltage on your power supply. This will cause the magnetic field to repulse any cosmic radiation. The quantum mechanical interactions between the magnetic field and the cosmic radiation may cause some memory bits to enter a superpositional state, meaning that some of your terminal bits will exist and not exist at the same time until you observe it. To counter this, make sure you look at your computer at all times - do not stare away. If you are distracted by your wife, cat or TV, your computer may break.
Update: [This](https://gist.github.com/4458943) is the kind of thing I was talking about. Usage: reddit-fingerprint.rb &lt;username1&gt; &lt;username2&gt; [&lt;number of pages of comments to download&gt;] All it does is download as much of a user's comment history as the reddit API makes available, and for each user builds a markov lookup hash of each users' phraseology (ie, for each unique word they use it compiles a list of all the words that ever follow it in the corpus, and a count of how often each of the following words appears). Then it has a stub function `compareMarkovLookups()` to compare the lookup tables of the two users specified on the command-line. It's intentionally simple at the moment because I haven't started playing with different ways to fingerprint users or different metrics to compare them on - all it does right now is spit out a total count of the unique words the user uses in all their comments (a vague metric probably related to the size and breadth of their vocabulary and how long their comments typically are, among several other factors). Even that's a little interesting though - for example I ran it on six redditors I picked out of thin air - myself (shaper_pmp), a friend (tabris), another redditor known for long, in-depth comments (kleinbl00) and three accounts all known to be run by the same person (bechus, karmanaut and probablyhittingonyou). Username: Unique words used in corpus (case-sensitive) Bechus: 5437 Karmanaut: 4078 ProbablyHittingOnYou: 4477 Shaper_pmp: 13745 Tabris: 8784 Kleinbl00: 10720 It's a tiny sample-set of redditors (and "unique word count" is an incredibly primitive, simplistic metric to use on its own), but I thought it was at least interesting how even with this small sample the four different people's vocabularies are between 3000 and nearly 10,000 words apart, whereas the three accounts known to be sockpuppets of the same person all demonstrate vocabularies with a size within 950-1500 words of each other. I would imagine that with more and cleverer metrics (reading grade analysis, average comment length/mean deviation of comment length, word-pair frequency fingerprint, etc, etc) it might be possible to tell different redditors apart and/or spot "normal" sock-puppet accounts with a moderate degree of reliability.
You're not supposed to catch Missingno. It'll glitch up your save.
Hey, so long as it returns 200, NBD! Right?
You might need to zap your PRAM and reboot.
Old-school fix, before there was reset: cat /bin/ls ... not 100%, but worked surprisingly consistently. We used to call it getting "flashed", although that usually implied someone was doing it to you by writing to your terminal.
Don't delete it! I find myself browsing old source code all time looking to reuse logic or remind myself of how certain problems are best approached.
Some more research in the area: http://33bits.org/2012/02/20/is-writing-style-sufficient-to-deanonymize-material-posted-online/
hm, i wonder if we can reverse the encoding problem and see some passwords. ;)
Some part of your Ruby program printed out a control character which modified the print settings. As thatfunkymunki says, close the terminal tab and restart the logger.
I threw this together for you: It makes a function called "play" and calls it. As long as you want to keep playing, it will call itself again. Otherwise, it ends. def play() print "Choose from 1 to 5: " rand = rand(1...5) user_input = gets.chomp choice = user_input.to_i if choice == rand print "yup\n" else print "nope, it's actually #{rand}\n" end print "Play Again? Y/n: " playagain = gets.chomp if playagain == "Y" play() else print "See Ya!" end end play() You should add on a playcount variable, and maybe a wins or losses report!
Hey, very cool! I actually threw that into terminal and this came up Choose from 1 to 5: 3 nope, it's actually 2 Play Again? Y/n: y See Ya! Had me stumped until I realised that the "y" had to be capitalised :) I'm actually learning!! Thanks for that!
This is always the first application I write when learning a new language, and I've written it in various ways since I was about 8 (and i'm over 30 now!). It's a great way to learn about a language, since it's not very complex, but it is flexible and you can add a lot of small features to it that will teach you the common concepts that are slightly different in each language. That's why I suggest implementing the play count &amp; win:loss reports: you'll learn about iteration and more about how functions work. Feel free to PM me if you've got questions! Disclaimer: I am also a Ruby noob, but I've gotten Rails apps working, but I can write scripts in about 7 languages. I'm no expert in any of them, though!
Moar upvotes for this guy.
One minor gripe words[token] = true unless token == "" is the idiomatic way of writing if not token == '' words[token] = true end
Type `reset`. Escape characters are messing up the terminal.
I see; it runs through it like order of operations.
Yep! I like to avoid nesting if/elsif/else/end statements as much as possible, so I've learned (slowly, and painfully) to: 1. Eliminate anything I don't want to consider. 2. Consider the following: 3. If it's anything I don't want to care about, toss it. 3. Do I care about what I'm considering? If yes, take it. Then I'll decide what I'm going to do with it - I usually use switch/instead statements for this. It's worked pretty well for keeping my if statements under control. In the beginning, I had labyrinthine complexes of if/else statements. My mantra is "eliminate the negatives, and seek only the good."
Could use ~~token.blank?~~ `token.empty?` instead of an equals comparison
Were you using pcap library to snif data? I faced the same issue doing that I saw a 200 in the screenshot.
that's even prettier 
As a side project, I've put together a site for creating collections of useful products from Amazon for subreddits. I hope you all find the books useful. While the links are affiliate links, I hope I'm providing the community with something of value by collecting these resources in one place and adding little notes on why they're useful to Rubyists. I'd love any suggestions!
As a side project, I've put together a site for creating collections of products from Amazon for subreddits. I hope you all find the books useful. While the links are affiliate links, I hope I'm providing the community with something of value by collecting these resources in one place and adding little notes on why they're useful to Rubyists. I'd love any suggestions!
Interesting - thanks!
You're right; it's none of my business. I'm sorry, phd001.
And which book does Reddit decide to use for a thumbnail? The only Java book in the list.
:)
Well, the answer to your question is no, but why would you ask that?
D'oh! It has been a very long time. All I remember is chunky bacon. And how the pipes for block variables are a slide. And... monopoly money!
Heh. Not that old school ... I just didn't remember it being available before recently so chalked it up to being relatively new. I guess either the system I've used in the past didn't come with it or, more likely, I just didn't know about it!
anyone has thoughts on [the rails view](http://www.amazon.com/Rails-View-Beautiful-Maintainable-Experience/dp/1934356875) I ordered it off the library as my first ruby book and I'm learning ruby off of codeacademy.
Really, your only contributions to reddit are supporting Ron Brown, which you created your account for, or insisting you aren't Ron Brown, which you attempt to prove by making a brand new blog, on which to assert you aren't Ron Brown. Dude, we all know the truth. You're a sad, sad sock puppeteer.
Any particular order you would recommend reading them in?
Just a general comment that Uruguay is a wonderful, wonderful place, and I very much hope to attend. :)
I think you got the wrong book. The Rails View is a niche Ruby on Rails book for organizing the view layer of a Rails application.
hmm
Also worthwhile; * Exceptional Ruby - Avdi Grimm * Objects on Rails - Avdi Grimm * The Rails 3 Way - Obie Fernandez * Service-Oriented Design with Ruby and Rails - Paul Dix * Growing Object-Oriented Software, Guided by Tests - Steve Freeman &amp; Nat Pryce (Java, but excellent)
Yeah, I really like Avdi's books. I also wanted to add _Ruby Under a Microscope_ by Pat Shaughnessy, but for the time being the app is tightly integrated with Amazon. I was avoiding rails books (those will go in a future collection for rails) but I'll add Growing Object-Oriented Software.
I'd say, _The Ruby Programming Language_ then _Metaprogramming Ruby_. From there you'll probably have a better idea of where to go next.
well
indeed
IM SO EXCITED
Except it's clearly a Mac, so /boot/vmlinuz doesn't exist :P
AND YOU JUST CAN'T HIDE IT
Thanks, and I'm just finishing up *The Ruby Programming Language*, but I've got an interview coming up that wants me to be familiar with the R language. I saw the *Exploring Everyday Things with R and Ruby* and thought that will definitely be where I go next, but *Metaprogramming Ruby* will certainly follow it up. Thanks for the awesome list! 
I wish _why and his paramour (or just regular amour) the best.
Ah, ok. If you actually need R for a job then definitely learn that :) Metaprogramming Ruby really helps to clarify some of the weirder parts of Ruby, but that's easily something you can do after getting the job.
Thank you so much for the response. How about [this ruby book](http://www.amazon.com/Ruby-Visual-QuickStart-Larry-Ullman/dp/0321553853/ref=pd_rhf_se_p_t_1) I ordered that from the library because the reviews look good and the other books are all rail books. any thoughts on that book?
can someone full me in on what the heck the deal is?
Chunky Bacon
oh _why? how art thou
~barf~ Wikipedia on narcissism, "A narcissist may secure a sense of superiority in the face of another person's ability by using contempt to minimize the other person." "That's the danger with patterns: they can quickly graduate from tool to taste." and "the simplest thing that could possibly work is no longer not just good enough, it's disgusting.". Such disdain at the rigidity of Java developers thought patterns held by the emotion of disgust that it apparently blinds DHH to his own programming thought patterns are made rigid by the emotion of contempt. 
The thing is, I actually kind of disagree with DHH and am hoping to hear more opinions from other redditors. With DI, I am explicitly providing dependencies to my `SUT` (`System Under Test`). In DHH's example, this isn't true. What if the `publish!` method changes its implementation to no longer depend on the `Time` class, but some other class instead? That probably means I'll need to go back and update my test to now depend on the new class being depended on. Instead of stubbing the `Time` class, I guess we could mock it and validate that it was called. I brought this up on a [similar question at SO](http://stackoverflow.com/q/13877777/173957), specifically the section called **Reason 1: A dependent class can be changed at run time (think testing)**. I'm not looking for a reason as to why DI is needed in a dynamic language, but better yet, I'm waiting to hear a decent explanation as to why it's not.
On drama, if there's Linux, PHP, JavaScript, any other programming disagreements online, it's not called anything. And they happen *a lot*. If Ruby is involved, it's "yet another Ruby Drama". If you're looking for it, you'll find it.
One of the things I really miss in ruby is being able to provide type hinting. PHP and python get it right - hint if you want to. IMO this strikes a balance between demanding deps and allowing ad hoc apis and hashes of data. I think this lack of hinting makes most of rails feel like a shallow collection of functions with not much cohesion - it works because things are kept simple. With activerecord, theres a lot of tight coupling between the persistence layer and the model - you test by actually doing crud on our object graph all too often. While we have activemodel and a few other persistence layers around; I dont feel its easy to do. This hinders doing soa integrations - dumb it down to json or go away, its hard to share models across language boundaries. Fine for the web, but a pain in the enterprise. I think this is a still a problem with AR. I think it stems from failing to put in adequate dependencies. I think thats a good argument for establishing a DI convention - structure your classes to clearly have a single responsibility, especially where the API will be used everywhere. AR didnt, and you pay for it at a certain scale.... 
Agreed. And I still love Rails, I think it's as useful as anything else like it. But to me it's got some big problems, the same ones you are identifying, and I'm increasingly frustrated by core developers lack of recognition and reflection upon these problems (or maybe just in public?), or interest in lessening them rather than exacerbating them with future versions. It may very well be simply that the goals and priorities of rails development team do not match my own (like, say, maintainability, yeah) -- which would be legit, if unfortunate for me. But they don't either seem very interested in elucidating exactly what their goals and priorities are, beyond [dhh vaguely saying "applications like the ones I do"](http://david.heinemeierhansson.com/2012/the-parley-letter.html), without explaining what this moving goal of 'applications like I want' consists of. (And it seems unlikely that other rails core team devs who aren't dhh are any more clear on this than the rest of us). In the end, a lack of willingness to be publically self-critical, or even self-reflective, a public persona that whatever they're doing must be right, and if you don't like it it must be because you aren't interested in the same (unspecified, vague) goals or sorts of apps as dhh... is just plain annoying, and yeah, does not lead one to have trust and faith in those with such attititudes. (And don't get me wrong, bugs and in-retrospect-mistaken designs _will happen_ no matter what, one can't expect perfection, not what i'm saying)
No it's definitely called drama when Linux, PHP, or JavaScript geeks go at it. ;-) At least when I'm describing it, it is… But I have to say that there is a different type of drama in the Ruby community. It's rarely about technical merit or methodology, but rather it has to do with effects of the so-called "brogramming" culture and a "rock star" attitude among certain members of the community, which leads to silly arguments as well as more problematic things such as misogyny or financial exploitation of programmers who don't play the game.
 &gt;With DI, I am explicitly providing dependencies to my `SUT` (`System Under Test`). In DHH's example, this isn't true. What if the `publish!` method changes its implementation to no longer depend on the `Time` class, but some other class instead? Why would you change the class? Most likely because you are trying to change the behavior. So you need to update the tests to reflect the new behaviour. This is as it should be. It works the same with DI. Instead of time.now the new class has a totally different interface. So you must mock that up now instead. &gt;That probably means I'll need to go back and update my test to now depend on the new class being depended on. Exactly as in DI but for a slightly different reason. With Ruby, you are replacing the changed class. With DI you are replacing the changed interface or behaviour. No real difference in the big picture. 
i agree with #3 whole heartedly.. and i say this as a person who has been using rails since 0.13.
Well for starters, I think more people should take a tone closer to yours and get away from more inflammatory language damning people and their dangerous ideas. I think you show the answer yourself.
I don't get the point of including Refinements as an experimental feature. If its not good enough as it is, it shouldn't be in the release. 
I agree with not trying to predict the future. And although my example is somewhat theoretical, I still think I have point. The point is, if underlying dependencies change and those dependencies aren't reflected in our tests, we could have some issues. For example, if DHH's example changed it's dependency from `Time` to `DumbTime` and `DumbTime.now` always returned `2012, 12, 24`, our tests would pass but we'd have production issues. So, I dunno, maybe it's a bit of a stretch, but if I could avoid that type of thing with minimal effort, I think I'd do it.
Now, to hold my breath until the RVM team gets this into the RVM head ...
Can someone explain WTF dependency injection is in simple terms? I still have no clue.
Say you have a car, and it needs some way to move itself around. So give it some wheels: class Wheel def initialize @diameter = 4 end end class Car def initialize @wheels = Array.new(4) { Wheel.new } end end puts Car.new Here, you have a common pattern seen in lots of code where one object's constructor creates other objects it will need for itself during its lifetime. Dependency injection, at its simplest, is just externalizing this process, and *giving* the object the things it needs: class Car def initialize(transport) @transport = transport end end puts Car.new(Array.new(4) { Wheel.new }) This way, maybe we could have a 3-wheeled car in the future, or one with an anti-gravity drive, but we no longer need to change our Car at the source level to do so. The much lauded feature is that you can now easily choose to pass in a normal, production object (if you're in running in production) or a mock object, for testing, at your choosing.
The "Well-grounded Rubyist" has to make that list. Its hard to find a better book that explains the nuts and bolts of ruby
Added!
btw I'm not the guy that wrote the article. My stance on books in the early stage of learning something is that you can't really go wrong. Just expose yourself to many of them. When I started Rails, I was reading through three different books at once. What one book leaves out, another book might pick up on. Or what another book makes confusing, another might present in a way that fits your brain. I've never heard of that Ruby book, but my experience with libraries is that they rarely have what are regarded as the best books in a technical field like programming. And don't overlook all the free resources available online. I think the best way to read is to be building stuff on the side so that when you read you arrive at 'a-ha' moments that compel you to change your existing code/projects. If you aren't coding on the side and just reading books, then you really have nothing to apply your knowledge to and retention will suffer.
Anyone know when JRuby will have 2.0 support?
The point is that if it's in there as an experimental feature, it's deployed widely enough that people can write experimental libraries that make use of it, and so we can see how it might get used in the wild (which is the part that nobody can agree on yet). But it's still an off-by-default feature that can change without breaking backward-compatibility.
&gt; The problem is (and this kind of touches on that drama thing too) that inexperienced, immature people are cheap. I think you hit the nail on the head here. I was cheap when I was inexperienced and made the decision to go with Rails. I learnt from that mistake, but it was probably more expensive for the company to hire me and that inexperienced team at the time than to just cash out for experienced developers from the get-go. On the other hand, I would've never had the chance to learn, so that puts me in an awkward position. Well, at least I'm rather pricey these days. ;-)
Almost done with code academy's ruby course! Working on railz for zombies at codeschool and afterwards i don't know what project to pick up and spruce up a portfolio. Also working on a blog using jekyll bootstrap on github, got it up but haven't yet figured out how to customize it. I love this stuff it's frustrating and then it gets super exciting. this is great I hope to be picked up by a start-up or a company in the following months. Wish this reddit had a mentorship program, would be good. Thanks again! Thank you a million times!
"Optimized IO performance on Windows" Sploosh!
They're still refining 1.9 support...
Anyone else have problems with iconv? I tried: rvm --skip-autoreconf pkg install iconv rvm reinstall ruby-2.0.0-rc1 --with-iconv-dir=~/.rvm/usr irb -riconv But still get "LoadError: cannot load such file -- iconv"
Nevermind, just found that iconv was removed in Ruby 2: http://www.ruby-forum.com/topic/4409612
I have the first lesson of Learn Ruby the Hard Way open in the browser, but seeing this post made me wonder if I should wait for 2.0 to come out? I'm mainly planning on using rails maybe it won't matter so much. 
"Applications like I do" meaning the applications that had to go through the Big Rewrite?
When they say they want speakers of all experience levels - what do they really mean? I'd love to give a talk about my using Ruby for some antimalware type stuff on windows machines but I am like 99.9% sure I am not qualified enough.
2.0 is actually not a major change to the language (far smaller than 1.8 -&gt; 1.9).
&gt; The problem is (and this kind of touches on that drama thing too) that inexperienced, immature people are cheap. Rails lets inexperienced, immature people produce a lot of code in a short period of time. I don't think the parts of Rails that most of us object to are the parts that let inexperienced people produce code quickly. I think it's quite possible for a tool to be good, including good for experienced people, _and still_ let inexperienced people get started quickly. And Rails actually _isn't that far_ from being there, which is part of what has made it succesful. In fact, some the parts of Rails I object to the most are the parts that make it _difficult_ for inexperienced people to get started (Rails is increasingly heading in that direction, which you may actually like), or lead inexperienced people down _bad paths_ (I've been using Rails since just before 2.0, and I simply refused to use rjs from the start, yeah). Yet when such complaints are brought up, the response from Rails partisans, and sometimes even dhh, is that _rails isn't actually intended to help inexperienced people get started quick_, so it's not a problem that they don't serve such users needs. Which is ironic, since I agree that the _popularity_ of Rails is due precisely to that. 
&gt; As a result, I'm finding it harder and harder to find people I can have a discussion about the code quality of software with when evaluating libraries, for example, and more people are spending more of the time they could be spending on improving their software, writing blog articles or speaking at conferences. I know what you're saying, but if you want there to be more discussions that evaluate code quality, do you really want to _discourage_ people from writing blog articles? I think we need _more_ discussion in blog articles, not less. Yes, perhaps the problem is people aren't writing blog articles on the topics you want. But one of my frustrations is how _little_ the rails core team puts their design discussions and decisions and rationales in public, since the days of wycats as lead. wycats at least spent some time on blog articles explaining design decisions and rationale, and I think we all benefited from such public conversations. 
&gt; Here the formatter dependency is injected on the method call with a reasonable default. At runtime a different formatter might be specified. Of course this is a simplistic scenario but I think DI in ruby is perfectly fine here. Agreed, and also agree with your example of the 'simplest DI that might work' in ruby being simply putting a class name in a parameter like you've done, with a hard-coded class as default. This is so simple and easy to do in ruby, that there's little reason _not_ to do it. It's _not_ the crazy "DI framework" stuff you see in Java -- there have been some people trying to advertise Java-style "DI frameworks" for ruby, which are such terrible ideas, and I think it's _that_ style that makes people think "you shouldn't do DI in ruby". (On the other hand, the style of DI in ruby you demonstrate is so easy to do, it's _also_ easy to add in later _when you realize you actually need it_, instead of parameterizing every single dependent class name everywhere). Agreed that the mocked dependency thing is a sidetrack. (And that the style of stubbinng an entire class demonstrated in the OP which _might_ work for testing doesn't work at all for actual runtime configuration, because it forces you to redefine the whole dang class globally, not just as used in a certain context). 
Probably should have researched it myself but I saw 2.0 and jumped to conclusions. Thanks for clearing things up!
so… why were the release numbers done this way, then? why wasn't what we have as 1.9 launched as "2.0", and this new rev as "2.1"?
1.9 was originally supposed to be a development preview version IIRC. It should have been 2.0, but it just didn't turn out that way.
nokogiri does css and to parse javascript https://github.com/tenderlove/rkelly/
CSS is just an example. I'm not looking for a css parser library.
Do you mean something abstract like this: In the file "foo.bar" you want to grab a single phrase "BEGIN - Thing I want to grab - END" and the file looks like this: pages and pages of stuff that I am not interested in. Just loads and loads of stuff that I am not looking for. I just want the one thing which is in the middle. I just want to grab it out and assign it to a var- iable. Right? BEGIN - Thing I want to grab - END and then after it is more stuff that I am not interested in. And I don't want to get a gem to do it, because I am not building a web browser, I'm just looking for a short snippet of code. I'm wrestling with the same problem... 
try something like: targetString = file.scan(/\.bigbox.*; }/) This uses a regular expression In this case that should set targetString equal to ".bigbox a{ font-decoration: none; font-family: "SeccaThin"; }" Here's a useful primer on using regex in ruby: http://www.regular-expressions.info/ruby.html I believe you could even forego setting the variable file and just treat the file itself as an object and use: File.open("stylesheet.css", "r").scan(/\.big.*}/)
I imagine you'd only hit problems once the file size hit a significant fraction of the available system memory. Someone please correct me if I'm wrong - my knowledge of ruby is old and limited. 
right, except the BEGIN thing isn't set in stone; More like I want to grab the BEGIN and the "Right?" before it as well.
Yeah, but the BEGIN would be variable. It's more like BEGIN + the Right? before it.
Good luck. Regular expressions are powerful, but a little goofy. They will often return exactly what you want for a long, long time, then a slight difference will screw everything up.
Versionsnumbers don't mean anything. It is what the developers feel for, and there are no rules on them. However, some systems like the Gemfile expect the 0.0.x to be minor releases for bugfixes and such. 
Beacause Ruby is silly, and does not follow SemVer. Also, because 2.0 is being released on the 20th anniversary of Ruby.
&gt; Again, in these examples, the definition of what constitutes a "major" as opposed to a "minor" change is entirely arbitrary and up to the author, as is what defines a "build", or how a "revision" differs from a "minor" change. The Linux kernel use even numbers for release, and uneven numbers for developing. 2.4 was a release number and 2.5 was a development number until 2.6 was released. And the Linux kernel was in 2.6 until it released as 3.0. There seems to be some rules. Like the major.minor-convention and you bump the version number up with new releases. But it is arbitrary and just conventions
Some people, when confronted with a problem, think “I know, I'll use regular expressions.” Now they have two problems. 
Regex is definitely the best tool for the job. That was just an old joke.
In that case you might want to scan the document word by word, storing the previous word in a variable. That way, when you get to BEGIN, you can just look at the variable and see what the previous word is. I think it might be more efficient than using a regex on large files. 
I think you need to explain your general problem more, then.
It is not entirely arbitrary though. It is true that *some* projects have their own conventions, but usually major version number change does mean backwards-incompatible and/or major change. Just because a handful of projects use version numbers differently or completely the other way around (like Ruby) doesn't mean that they don't mean anything.
Agreed. If the problem is serialisable (i.e. can be processed line-by-line/ byte-by-byte) the regex is probably fine but if not (i.e. you have to read large chunks or the whole file to identify the bit you need) then it's more likely a case for an existing parser. Also nokogiri is an excellent parser as it covers a range of formats.
http://rubular.com check this out. you can write your regex, give it sample text, and it will show you what you're matching.
DHH has publicly stated, as if it wasn't already obvious, that Rails is great if you're building Basecamp. Basecamp requirements come first.
I bought that book because I read a Yii tutorial by Larry Ullman and liked the writing style. Its pretty good. He writes in a unique (in my opinion) way that still manages to convey the same concepts as more technical and dry writers.
def a; :output; end a # =&gt; :output container = method(:a) container # =&gt; #&lt;Method: Object#a&gt; container.call # =&gt; :output
http://ruby.learncodethehardway.org/book/ex43.html Line 22 is the code in question.
A million thank yous
So method(:method1).call() Is another way to call a method? Hmm. That would allow the executed method to be variable. That makes a lot of sense. Thanks!
Bingo. This is exactly the explanation I needed. So, if I understand correctly, "method()" creates the object and "call()" runs it.
Yep, this. Container contains a Proc object.
understood and agreed. you did say something about blog articles though, which I already quoted you doing, right?
&gt; Can someone give step-by-step instructions as to how I can feed that file into Terminal so that I have access to the methods, etc." I don't think it works like you think it works. Or I don't understand what you're trying to do, sorry. If you have ruby installed in your system, then the way you execute a ruby script is simply `ruby ./path/to/ruby.rb`. But I am not sure that's what you're trying to do. 
To import the file in irb, you can use require "path/to/the/file.rb"
&gt; That would allow the executed method to be variable. If that's all you need, and have the object handy, there's an easier and cheaper way to do that: object.send(:method_name, argument, argument) `method(:method)` returns a `Proc` object. A `Proc` object represents some logic (in fact, a 'closure'), which is executed by calilng #call on it. In most day-to-day ruby, you won't see `method(:method_name) # =&gt; Proc` very often, it doesn't come up much. `send(:method_name)` comes up a bit more often, but still not super common. 
`cd` to the desktop `pwd` shows you where you are `ls` shows you folders you can access `cd folder` goes into a folder (`cd ..` goes folder 'up') once you're `cd`ed onto the desktop folder run `ruby file.rb`
Agreed. I use lambdas sometimes, but procs never -- well, not explicitly. Technically you create a Proc every time you pass a block to a method, of course...
I think I broke TextMate :/
In your withdraw method, @pin isn't set to anything, therefore that if statement returns false and it falls into the else case.
You need to look at [this](http://www.reddit.com/r/ruby/comments/167f16/recursive_functions_am_i_doing_it_right/) post. Seriously, post some code if you want a real answer...
Looks like you're using @pin without having defined it. I notice you've defined the "pin" private method, but haven't assigned it to anything, nor are you allowed to pass it in as an argument to the constructor ("initialize"). The solution here is to remove the "@" sign from "@pin" on the first line of the "withdraw" method: def withdraw(pin_number, amount) if pin_number == pin ... end That will call the "pin" method instead of trying to use the "@pin" instance variable.
you have a `pin` method that is private that set's the @pin variable but it doesn't get called anywhere. Call it in initialize like so def initialize(name,balance=100) @name = name @balance = balance pin end or just put @pin = 1234 in initialize
So object.send executes the method and returns what the method would have returned? 
Eh, I didn't mean "lambda" vs "proc", they're more or less interchangeable (yeah, I know, there are a few diffs) -- I meant that one seldom in the wild sees `obj.method(:method_name)` to retrieve a proc object representing a method closed under a certain obj instance. You just don't usually need/want to do this, to use the `method` method. 
Huh, cool. I took a class in objective-c (iPhone) programming. That makes a lot of sense now. 
Lulz