To me, it seems the source of this pain is that behaviour is being tested at the wrong level, with too many end-to-end integration tests, and not enough lower-level unit tests. http://blog.codeclimate.com/blog/2013/10/09/rails-testing-pyramid/
Which problem in session 3?
Looks like ass on mobile
If you don't want to use ActiveSupport but want the semantics of `delegate`, you can implement your own version quite easily: https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/module/delegation.rb#L155
This was posted in a subreddit about the ruby programming language. This writing seems nice but is unlikely to find an audience here
Haha that was my guess. What garbage. 
Hmm, it does. http://i.imgur.com/PPMGt5l.jpg. OP, did you use Bootstrap for the styling? Did you change the default code for it?
Find something you want to use. If you don't want to use it, it's very unlikely you'll find issues that you can fully understand and properly fix.
But how would you suggest "synchronizing" the two sessions? How does the backend know that data received from client A needs to be handled in the current context of client B? edit: for clarity, in this case client B is a full graphical client with input and output capabilities, client A only has a single button.
From 2015. Wonder if it still has merit with todays tools 
I think it still has merit today! In fact, with more mature container softwares and their ecosystem, is more easy today to think about going for micro services without thinking too much about the involved challenges. So, to sum up, I see it as thinking about a good code design before going all in with micro services.
Yup.
For at least the first year you're learning to program, the most resource-intensive thing you'll ever do is have 30 stackoverflow tabs open at the same time. For a beginning programmer, the biggest benefits of having a shiny new computer are 1) incredible battery life and 2) feeling really nice when you pick it up to open it. If those are worth the extra $600–$700 you're gonna pay over a five-year-old macbook instead, then go for it. Otherwise, save your money and buy used. (For reference, the MacBook I'm typing this on is nearly twice that old — 2008.)
I have been building software in Ruby for nearly 10 years and this is the first time I've seen those constants.
Absolutely this is exercising form validation when it should really be something more along the lines of: 'A user logs into their dashboard' 'with correct authentication information' expect page to be user's dashboard 'with incorrect authentication information' expect sign-in page to contain error message 
I totally agree with the "give and take". Having less magic will inevitably make some gem integration more difficult or they just won't feel "like magic". 
I agree with the principles behind both your points and the only reason I've replied is to provide some counterpoint. Many things in programming are about trade-offs and this is no exception. I think it's a little more nuanced than just extracting the duplication immediately. In my experience, the wrong abstraction is harder to work with than no abstraction. I agree that something would be extracted, but I would wait for a little more design pressure before setting on `CreateUserAction`. I don't know that a class that does CRUD for a remote users is a violation of SRP. Most ActiveRecord classes would have the same responsibilities, so how is this different? I agree that a large class is a code smell, but unless you know something, what I'm describing isn't necessarily a large class. 
I don't understand the benefit. Aren't the constants just placeholders for their respective booleans? Do you have an example of how one could have used these constants?
I'm quite sure they're being ironic.
I agree with u/TheStrabusiness, I don't see these constants as a reasonable necessity. Can't you just define them yourself whenever that need arises? What sort of mental load are you saving yourself by having them already defined? u/kcdragon I'd love to see how you use them.
 &gt; 'Service objects' can make sense although there are usually better abstractions. However its likely that any team that employs them though will be unable to recognise the alternatives. e.g. where I have most recently seen them employed it progressed to the level of having an Anemic Domain Model (which is a logical conclusion - validation of input is just a service after all [not my words]). I'd call it 'a complete disaster' due to the underlying data corruption, but the team were happy with it (customers were a different story). Well, I don't mind validation being a separate class -- it's _part_ of the domain model, anyways. Where most teams that go off the rails trip up is that they don't namespace things, so in the end there's a massive sea of indirection with no organization.
I have seen it; I'm not really in the market for a library to expand rails to better accommodate code design. Architecturally speaking, I'd rather move my code outside the web framework altogether :-)
Service architecture debates have been going on for decades, not much has changed. The only recent advent is that modern dev ops tool make it easier to manage the deployment of lots of small services, but that was never really the main pain point of micro-services in the first place.
action_cable_client and drawers are happy to accept help :)
So far, all code that we've refactored and moved into a Service is a "PORO". Just calling it a 'service object', I suppose you can call it whatever you'd like. What are some alternative ways of cleaning up models/controllers you prefer? 
They actually completely disabled all top-level constant lookup not just these. https://bugs.ruby-lang.org/issues/11547
Haha whoosh. I missed that.
Modern devops tools make it actually viable to deploy 1000s of services where you may only actually need 10-15. It was a nonstarter before, and it's actually _possible_ now. It's still a bad idea, though. I'm hearing about more and more teams slicing their software into docker containers each running a few hundred lines of code. I don't see how anyone gets more than 45 minutes into this approach without thinking, "geez, this sucks."
What are your interests, what have you worked with before? There are plenty of projects out there in need of help, but it really helps (heh) if they are relevant to your interests/experience.
My interests are games but I'm motivated to do anything that will help me learn. I'm most proficient in Ruby
:-)
Congratulations on getting started, and keep it up! If you are learning to program completely, I can warmly recommend [Learn to Program](https://pragprog.com/titles/ltp2/learn-to-program-2nd-edition) by Chris Pine. While it's an old book, it's also very easy to pick for non programmers. Later you may want to try out the [Ruby on Rails tutorial](https://www.railstutorial.org) (if you want to go web programming - but then Ruby can be used for many non-web things too!). Hope this helps.
If you need to encode any Unicode codepoint, you can either use the `String#&lt;&lt;` operator like this: `'' &lt;&lt; 0x1D41A` or `Integer#chr` like this: `0x1D41A.chr(Encoding::UTF_8)`. I don't know why you are using the value 4036858010 since 0x1D41A = 119834... 
Thank you so much for the information! I will look into it for sure thank-you for the warm welcome!
I use 4036858010 because [that's listed as the decimal](http://imgur.com/Hnlz1EJ). Even though I seem to have been looking [at the wrong place](http://imgur.com/Bch0S7D). Thanks for spotting the error! Cheers!
I love the book, it's been really helpful in making the connection between the GoF patterns and how they might actually be used in a ruby code base. I totally recommend it.
Some tips on cleaning it up a bit so it's a little easier to read. You can just use 'puts' with no arguments to output a newline. You can also 'gets.chomp.to_i' so that you don't need to convert so many times in your if statements. It looks good though!
Sure. Get as much RAM as you can, so you can run VM's if you want/need. 
If you patch nil, you're also patching NIL - it's just a reference to the object, not a 'pristine version'. NIL.object_id == nil.object_id unless you redefine NIL. You also can't redefine true, false or nil in ruby either (you get a 'can't assign to' error).
He works in the ministry of truth.
Aaaaahh thanks! Cheers!
nah, people say it's mostly used in web applications, but it's because those people are the most vocal. I'd be willing to bet it's used much more as quick side scripts in projects written in other languages, for watir (web application testing in ruby), Rakefiles, etc.. These are the use cases that aren't talked about but what make ruby great. 
I have heard it described that micro services solve a people problem, not a technical one. It allows more developers in an organization to work. I see it being pushed so much as the new hotness. But you have to see where/when you need it. You probably only need it if your developers number in the thousands
 "Luke\\032\\09108\\05800\\05827\\0580b\\058b0\\058c0\\093".gsub(/\\(\d{3})/) { $1.to_i.chr } =&gt; "Luke [08:00:27:0b:b0:c0]" "Johns\\032Mac\\032Mini\\032\\0402\\041".gsub(/\\(\d{3})/) { $1.to_i.chr } =&gt; "Johns Mac Mini (2)"
With something like this: `erb :view, layout: :'layouts/other_layout'`
This was brought up in 5 itself in a blog post by dhh or someone. Default JS does ajax pretty well via fetch and stuff so it is mostly unneeded. 
I'm maintainer of Skyderby project - app for skydivers and basejumpers to analyze flight through gps tracks. I'll be happy to have help either with basic things as well as with complex. Here you can learn every detail of RoR stack. repo: https://github.com/skyderby/skyderby
Nice question, Im at work now but when I will get back home, will reply
Yeah to understand recursion you need to think recursively; heard that one before Same as everything is an object 
&gt; Firstly, my example was someone contrived, but we'll stick with it. Yes, examples are hard to work with when discussing general approaches, I've found. In particular, my final examples don't exactly look like where I'd leave them off. &gt; One thing that was missing was the implementation of once. I don't agree. If the object were to mistakenly run the query three times, you'd have a performance problem, not a problem with the operational semantics of the test subject. That kind of thing belongs in a performance test, and only then if you're looking to improve the performance of an actual bottleneck. It's not like the design is prone to beget a duplicated effort scenario. &gt; I would consider this approach to be procedural rather than declarative. The test reads more like: "how do we test this", rather than a "what are testing". I think there is a large benefit to having fluent APIs in testing libraries. The benefit of BDD is that the test procedures for design elements often serve as specification of behavior. So, procedural tests are not a bad thing. I would typically add structure and prose to the test procedure so it can serve both functions: context "Post" do context "Comments" do post = Post.new test "Requests approved comments" do approved = false post.fetch_comments = proc { |params| approved = true if params[:approved] } post.comments assert approved end test "Requests unread comments" do unread = false post.fetch_comments = proc { |params| unread = true if params[:status] == :unread } post.comments assert unread end end end You spotted it, but there's another concern that ought to be tested: that the fetch comments query result is returned. That's another test: context "Post" do context "Comments" do post = Post.new control_comments = [] post.fetch_comments = proc { |_| control_comments } comments = post.comments test "Fetches and returns comments" do assert comments == control_comments end end end &gt; You are implementing the logic yourself to test the code. Rebuilding features that already can be more verbose, error-prone, timely, and less readable. NIH, etc. etc. Right. But if you're going to write code that is useful for test assertions, there's three places the code can go: 1. the test itself, 2. some directory structure where RSpec matchers are stored, or 3. the actual implementation of the test subject. I'd rather have that code be in 1. rather than 2., but in practice I prefer to move the code to 3. Objects _should_ expose methods useful for observing the object carrying out it's duty. That's one _role_ that objects must serve -- the testing role. Move that code out to an RSpec matcher file and you've got the code further removed from where it belongs. &gt; IMO, better failure messages == less time navigating/source-diving/context-switching. In practice this doesn't bear out. Let's consider the junior programmer a little more deeply. Suppose they see this message: Expected 42, got 41 Which of the following questions is 42 the answer to? 1. What is 21 * 2? 1. What is 41 + 1? 1. What is the meaning of life? Automated tests inherently use rely on _examples_ to control the experiment, so to speak. Assertions form the basis of proving the intent of the test against those examples. Plunging a newcomer without context into the middle of example data is pulling them into too deep a context. It's actually _better_ for them to simply know that the assertion failed than to start wondering why some value is 41 when it should be 42. The first step to understanding a test failure is to understand the specification, or the general characteristics or features the tests are trying to prove. The example details are a distraction -- it's just as possible that the number is _supposed_ to be 41 as it is that the test subject is in error. You don't want to introduce a bias here. Another important point -- if design and testing principles were followed properly, then the person who is seeing this test failure is almost certainly seeing it because of a change they made in the test subject itself. This further devalues the elaborate assertion failure output. Besides, all those values can be pretty printed situationally if the user wants to. It's been over a year since I swore off fancy assertion messages, and I haven't stumbled on a single regressed test case where "friendly" assertion output would have helped. &gt; On the other end of the spectrum, one could go overboard with testing features and ignore obvious code smells (like allow_any_instance_of(User) type tests). &gt; But I think there is a middle-ground. For me, I will use test library features when the are useful, and help me write concise, robust specs that are not to the detriment of architecting my app. I don't know, it sounds like you're offering a middle ground between an extremely undesirable place and a desirable one. I have as little use for mocks, stubs, custom matchers as I do for `allow_any_instance_of(User)`. &gt; Overall, it's a matter of taste. How many features you I want to use from a testing library? On one end of the spectrum, one could even say, why use a testing library at all! I can just raise errors myself! Your example is obviously crude and primitive. But I would actually take the example you gave over most RSpec (and minitest) test suites I've encountered. An advanced tester using crude tooling will still end up delivering far better results than a beginner tester using advanced tooling. And it's funny you should bring that example up, because [I wrote a test framework](https://github.com/ntl/test-bench) that essentially offers `assert`, minimal spec-style annotations (ie. `context do ... end`), and a test runner/CLI. I've been using it for a few years across many projects and I have yet to find a use for the following RSpec features: 1. Custom matchers 1. Shared example groups 1. Mocks/stubs/doubles/spies 1. Piles and piles of confusing configuration options like `#treat_symbols_as_metadata_keys_with_true_values=` that strikes me as obvious feature bloat If it's not already dead obvious, I'm pretty passionate about testing :-) While I am not a fan of the approach you're endorsing, I do enjoy the subject matter. Cheers!
&gt; not a problem with the operational semantics of the test subject. It is absolutely a problem with the operational semantics of the test unless you assume that querying an API is a pure function... In my draft of this post, I actually included an `offset` parameter. In retrospect, that would have more obviously shown the impurity of the `fetch_comments` method. &gt; Right. But if you're going to write code that is useful for test assertions, &gt; there's three places the code can go: 1. the test itself, 2. some directory &gt; structure where RSpec matchers are stored, or 3. the actual implementation of &gt; the test subject. I'd rather have that code be in 1. rather than 2., but in &gt; practice I prefer to move the code to 3. Objects should expose methods useful &gt; for observing the object carrying out it's duty. That's one role that objects &gt; must serve -- the testing role. Move that code out to an RSpec matcher file &gt; and you've got the code further removed from where it belongs. Did you even read the OP? I specifically advocated to not move the code out to a separate matcher file. ¯\_(ツ)_/¯_ &gt; I have as little use for mocks, stubs... Eh... You are using stubs. Just a more "crude", less feature-rich version of them: # This is a stub post.fetch_comments = proc { |_| control_comments } # PS: but Ruby is not Javascript :P # post.define_singleton_method(:fetch_comments) { |_| control_comments } It is a stub, just not one that I can make assertions on without my own glue code. I'd rather spend my time on other things. Like, debating people on Reddit :) &gt; if design and testing principles were followed properly, then the person who &gt; is seeing this test failure is almost certainly seeing it because of a change &gt; they made in the test subject itself. Let's be honest here: that's a bold expectation. I'm certain almost all Ruby developers either have, or are currently working with code bases with side-effect splatter. 
Would this be an alternative to Sinatra?
You are vizcay? If so, thanks so much for submitting that thread! You put the issue into words extremely well and it was something I had been trying to query on Google for quite a while. I 100% agree this should be in RSpec core.
Could this be used to write documentation for a regular app or is it more suited to API's?
What do you think, and why? Honestly, I'd probably just leave the duplication. The HTTP request content is unique to every spec anyway. So the only duplication is really one line `expect(response).to redirect_to new_user_session_path`. I suppose you could replace that one line with a helper method from somewhere `expect_redirect_to_new_user_session_path`, or even `expect_redirect_that_happens_on_auth_failure`, but, like, why? The shared example approach also seems reasonable, especially if you already have `action`, `http_method`, and `params` in `let` variables, or it seems reasonable to you to put them there. But you're running the risk of replacing your 'duplication' with more lines of code than they replaced, which seems unuseful. None of your proposed approaches seem horrible to me, they're probably all fine, as is just leaving the duplication. 
GoRails.com has some nice videos onit
After some more searching, I think a custom matcher including only the assertion (not the call to `process`) is the best way to go. Compared to repeating `expect(response).to redirect_to new_user_session_path` in all tests, this approach has the following advantages: * Improved maintanability. If we eventually have to change this assertion, we change it in one place instead of having to change dozens or hundreds of tests. * Better failure messages. I have created [this answer](https://stackoverflow.com/a/44681910/6307730) to provide example code. **Edit:** I had written this reply before you edited your comment (it only had the first two paragraphs). Thanks for your help.
A custom matcher could be worthwhile then. Maybe something like: expect(response).to require_authentication And have that be equivalent to `redirect_to new_user_session_path`. I think it's better to still be explicit with the `expect(response).to` part. But you would be able to swap out the matcher implementation to check a different path, check that some text appears in the page, or whatever else you need in the future. I'm not sure this is the best way to define it, but you could do something like: RSpec::Matchers.define :require_authentication do match do redirect_matcher.matches?(nil) end failure_message do "Expected authentication to be required\n#{redirect_matcher.failure_message}" end failure_message_when_negated do "Expected authentication not to be required\n#{redirect_matcher.failure_message_when_negated}" end def redirect_matcher @redirect_matcher ||= redirect_to(new_user_session_path) end end
Thanks. Appreciate your vote of confidence. 
+1 for ngrok. I'm using it currently to field Docusign webhooks and it does the job nicely. 
Ruby makes a lot of assumptions which lead to the programmer having to do less explicitly. I think this is a good thing, especially when you're starting out. Right now you should focus on understanding how Methods work, the Scope of local, instance and global variables (avoid global variables, but understand how they're different), and how to control the flow of your program with enumerables and conditionals (`each` and `if`).
No limitations. It only gets messy when you try opening a file you already have locked, or if you get into multi threading. That could get messy ;)
At a glance, I would think the fact that there's an unhandled condition - result &lt; m ...could possibly lead to an infinite loop for certain values of m. Haven't tested this or walked the code, just a guess at a glance. Personally, I would add a final 'else' clause that just prints what's being skipped: else puts "Not it: #{ result }" That should hopefully expose the error.
Your algorithm is constantly repeat the same work. Each try you try the next val, you end up redoing all the work of the previous val. Figure a way to avoid this. 
Have you considered simply adding the cube of increasing integers starting at 1, and each time checking if it equals or surpasses m?
`#chr` is supposed to handle ASCII encoding (0..255). It doesn't (and shouldn't) support Unicode, since it's an access point to a lower level design (it references the C type `char` which is 8 bits long and matches a single "byte"). 
Yes, you are correct. When you use the block form of file interaction, the file closes when your block exits. There is another way to explicitly open and close the file, but you aren't using it (and don't if you can avoid it). I was just noting that you would only have limitations on how often you can read your file in this regard: don't do this (and you aren't) def dont_do_this file CSV.open(file, 'w') do |csv| CSV.open(file, 'w') do |wat_i_dont_even| end end end I assume you'd probably get an Exception before you open a black hole, but I don't even really know. Regardless, I'm pretty sure file IO is not the issue that you are having. About the massive romance novel above: Don't worry too much about grasping it all, or even implementing any/all of it. I'm only slightly ahead of you in learning Ruby, and I found that the most enlightening information was seeing someone else solve my same problem. It would often yield methods and syntax tricks I had no idea where valid. (The many magic tricks of Enumerable come to mind) It was just some things I thought of while trying to better understand your problem. If you learn one cool thing for future use, then my time earlier was worth it! If someone critiques my refactor, it was also worth it!
Actually, you can specify the encoding, and it changes. The real problem was that I used the incorrect number. See the other comment. :)
Good to know :-)
Oh, one more thing I'd try to look into. The .csv you have expresses single objects across multiple line items which makes it harder to manipulate programatically. I would create objects that represent the data this .csv expresses. There are a few objects, such as Settlement which has a Summary, a collection of Orders, Refunds, and OtherTransactions Then you would do something like: - Parse the file, generating the objects as you go along - Summarize the collection of objects as needed This gives you much more freedom to slice and dice the values as needed. Imagine: orders = data.select{|d| d["transaction-type"] == "Order"} .group_by{|d| d["order-id"]} # orders is now a hash where the keys are order-id, and the values # are all associated rows for that order-id # =&gt; {"116-9534530-8991461"=&gt; [row, row, row], # "135-1838616-1241245"=&gt; [row, row, row], ... } orders.each_with_object([]) do |(id, transactions), collection| this_order = Order.new(id) this_order.transactions = Hash[ [ transactions.map{|o| o["amount-description"]}, transactions.map{|o| o["amount"]} ].transpose ] # =&gt; {"Principal"=&gt;7.29, "FBAPerUnitFulfillmentFee"=&gt;-2.99, "Commission"=&gt;-1.09} # Before wrapping up, you can save any other relevant info. Customer ID maybe? # Heck -- you might even wish to add to this object all of # the source/raw data rows that creates this object: # this_order.raw_data = transactions # Finally, drop this newly created Order object into our collection, # and iterate until we're done: collection &lt;&lt; this_order end # =&gt; [Order, Order, Order, ...] # Now you can do neat things like: orders.map{|a| a.transactions.values.reduce(&amp;:+)}.reduce(&amp;:+) # =&gt; 135133 # or, the total value of all orders # the first reduce is to sum the transactions within a single order. # the second reduce is to sum all orders. # If you added the summing as an instance method to the Order object: orders.map(&amp;:revenue).reduce(&amp;:+) # sweet!
you mean like code documentation? No, it does not do that, it's specifically built to document API calls. 
Thanks for sharing, this is useful :)
Correct, Current.user would be nil in the new thread.
&gt; You could very well have situations where you're expecting Current.user to be nil but instead it's set to some vaule because some other test set it. Now which of the 500 tests in my application did that? Good luck finding it. This shouldn't be too hard? Either search for `Current.user` in `spec/`/`test/` or overwrite `Current.user=` to raise an exception and run your tests.
Looks good. Thank you!
Working on a fix for this today, appreciate the feedback!
I totally agree with Bigg's statement: &gt; Rails is still a good framework.... I just can't reason with the guy at all. We have vastly different opinions on this sort of thing. Despite having some decisions I don't agree with (what complex mature framework won't?), I still think Rails is a pretty great framework to work with. But, like Biggs, I find myself frequently disagreeing, sometimes fundamentally, with Rails architecture decisions dhh makes. And unlike other architecture decisions, dhh's seem like they can be made with very little input from others and no justification but "I like it". Somehow, rails success (and I do think it is a very succesful framework despite it's problems) seems to me to happen despite dhh, rather than due to him. 
&gt; Protecting programmers from themselves is explicitly not in the charter for Rails when it comes to providing features that have a valid use case but could be abused. I can see DHH's perspective on this -- he has 100% control over any code which might utilize this type of a feature, so he can axe it when it's abused. That is a luxury we all don't get. Some of us inherit apps which have 300 line methods and routing logic in models. A new feature which could _potentially_ make our lives difficult scares us and keeps us from pushing forward with with. I've been there. Letting fear of how others will use a feature in a framework isn't the right response, though. Every screwdriver can be used as a hammer with enough applied pressure. I'm not sure I'll use `CurrentAttribute` (for many of the reason Ryan pointed out), but there is [similar code in the wild](https://github.com/ErwinM/acts_as_tenant) that hacks this functionality into place already. There is a demand for it within the framework. I, for one, will not let my fears control other's needs.
I think you might be overstating that last point (especially early on, Rails had some great ideas in it), but you aren't wrong. This stuff, allowing the asset pipeline to languish forever in a SPA world, the bizarre pushback against service objects. There are a lot of places where Rails seems to make choices that favor small conveniences for small projects over giant nightmares for larger ones...
&gt; There's no telling what the state of Current is in any given test. Instead of raising an exception, one could log the set value + some part of the stack trace using `caller.last(3)` while keeping the original behavior of `#user=`. Having tests depending on (mutating) global state sucks, but it's usually pretty straightforward [1] to fix using some meta programming + a known order of specs which cause problems (e.g. rspec seed). [1] Or maybe I have simply too much practice removing global state from Rails code bases... :/
&gt; lot of places where Rails seems to make choices that favor small conveniences for small projects over giant nightmares for larger ones That perfectly sums it up actually. I'll have to remember this expression
If you're spawning your own threads you should not be sharing references between them anyway. i.e. Regardless of where `Current` stores data this should be written as `Thread.new(Current.user) { |user| fetch_stuff_from_api(user) }`
I'm not sharing references, though. I'm calling a method and depending on the thread which calls the method the return value changes. That's surprising, at least to me. The workaround you proposed doesn't fix "sharing references", btw: irb(main):007:0&gt; a = {} =&gt; {} irb(main):008:0&gt; Thread.new(a) { |b| b[:foo] = "bar" } =&gt; #&lt;Thread:0x007faf93055c68@(irb):8 run&gt; irb(main):009:0&gt; a =&gt; {:foo=&gt;"bar"} You'd need to (deep) `clone` objects in order to avoid sharing the same object between threads.
&gt; Probably because the former is an easy judgment to make while knowing what "easy to maintain" means requires a lot of experience. This is a tired argument; "If you disagree with me you must just not be experienced enough". Maybe people of similar experience levels can just disagree. 
They definitely can. If you like, you can read my comment like this: &gt; Because people seem to prefer code that is easy to write over code that is easy to maintain. This (that people use shared mutable state because they value initial speed of delivery over maintainability) is a personal opinion, YMMV. Even the question of whether you actually do value maintainability is a personal opinion (for some projects it really doesn't matter if they're maintainable). &gt; Probably because the former is an easy judgment to make while knowing what "easy to maintain" means requires a lot of experience. This one I'd argue is objective. Knowing what "easy to maintain" means doesn't come naturally. I certainly wouldn't want to argue that I fully know this myself. 
gonna migrate my code over to `almost_sinatra` :P
&gt; This one I'd argue is objective. Knowing what "easy to maintain" means doesn't come naturally. I certainly wouldn't want to argue that I fully know this myself. Maintainability isn't remotely objective. I've worked on codebases that tightly follow SOLID that were awful to maintain. Sifting through a sea of hundreds of 1-5 line functions is is not maintainable to me. Yet, SOLID is often held of as the holy grail of OO maintainability. I'll take a single 100 line function over 50 2 line functions any day. 
I think this is a good change. Every non-trivial Rails app I've worked on has implemented this pattern in one form or another. It's often hidden in gems and implemented in a somewhat sketchy manor, particularly reset handling. Having the executor handle reset solves this nicely.
Beforehand, I don't really do web applications currently; I have only done some small Rails apps until Rails 3.1. However, I don't really get it why so many people seem to be okay with overusing globals since they always need to be taken care of in special ways, e.g. when testing some functionality. It's certainly worse when libraries make extensive use of globals but I feel that even for applications it is leading to bad design and problems later on.
&gt; But your production code is now highly prone to nondeterminism, and your test suite is now less likely to catch it. Bit hyperbolic? The production code presumably just sets the 'user' at the beginning of each request / background job. It's not exactly like you'd be adding/mutating data there at various points through a flow of code.
Agreed. Much better way to do it. Thanks for the advice, I'll implement it shortly
Not really, that `user` (if it's implemented in ActiveRecord) is likely connected to most of the database through associations. A background job might have code in one places that mutates the user record (or an associated record) in a way that another piece of code is not expecting. Happens all the time when teams pile fixes on top of features on top of fixes. Anyways, my critique is that the general approach is _prone_ to bugs. This kind of thing always seems to start with something that, in isolation, can be perceived as innocuous. Over enough time and churn, teams that allow this sort of pattern whenever it seems innocuous will inevitable get bitten. It's not worth it! There's nothing won in exchange for the risk that makes up for the problems it's prone to causing.
Nope, but that's a darn good idea. There are some nice features of heroku I can use to help https://devcenter.heroku.com/articles/expensive-queries. 
 &gt; Concurrent modification of database records (or associated records) is always a concern, storing the AR object in a thread local doesn't have any notable impact on this issue that I can see. Nor does how features are added. It's just something you have to be aware of. You should use transactions and optimistic locking appropriately regardless of any of the issues discussed here. ORMs are rife with problems. They are exacerbated when you store instances in memory and reuse them in different places. &gt; I could make that argument about any design pattern. They all create messes when mis-used. Sharing global state isn't a design pattern. It's a vector for nasty bugs. &gt; You win simpler code, and most of the alternatives aren't a notable improvement in either code clarity or safety Simple is in the eye of the beholder. I've worked in systems where any class is liable to be going out and fetching global state -- I wouldn't call any of those systems "simple." &gt; Passing a reference through a bunch of methods that mutate it along the way is no better than mutating a 'global'. Both approaches are likely to cause bugs. Passing a reference through a bunch of methods that mutate it is a smell. Do you want to cover up the smell with fabreeze or do you want to find the skunk and dispose of it?
I probably should just delete this - but maybe someone will learn from my poor method construction. As I said I was using irb to run the methods and get_principle *wasn't working*. I said this because all I got when I ran the code (via IRB) was *nil*. I just went back, ran, and then looked at the code for, my tests and it clicked tome that the *get_principle* method doesn't actually return anything, and I should have just been looking at the object and I would have seen that income had changed. So, yeah, I'm someone who doesn't always think or know good 'user interface' (in ruby or rails), but obviously I need to tweak this code to provide a good output. Thanks to everyone who tried to help and gave suggestions, sadly, as usual, the programmer was in error
&gt; ORMs are rife with problems. They are exacerbated when you store instances in memory and reuse them in different places. What does an ORM have to do with this? You have exactly the same issue with or without an ORM. If the data in memory does not match the state of the database you have to deal with it, doesn't matter what object holds that data. &gt; Sharing global state isn't a design pattern. It's a vector for nasty bugs. Global state exists whether or not you'd like it to. The only question is how to handle (or obfuscate it) it in code. &gt; Simple is in the eye of the beholder. I've worked in systems where any class is liable to be going out and fetching global state -- I wouldn't call any of those systems "simple." _Any_ pattern can be abused. Blaming the pattern just creates coding sects. &gt; Passing a reference through a bunch of methods that mutate it is a smell. Do you want to cover up the smell with fabreeze or do you want to find the skunk and dispose of it? I think I said the same thing? If you wouldn't mutate a passed reference, why would you mutate a global? 
The executor is pretty good new architecture in 5.1.
To me you're just painting a false dichotomy. It's either no architecture or bad, premature architecture. I agree 100% that pulling some patterns out of your hat is not going to help you; I also am fully in agreement that you should be in a "always refactor" mindset. That said, while badly architected code makes maintenance a nightmare, unarchitected code - where all the knowledge is duplicated (so if you change the behaviour, you have to change it in 20 places) and you need to keep 100 things in mind to understand what is happening at any given point - is, in my experience, not any better. I've seen 2000 line application.js files or Rails views littered with logic and that is just hell to maintain. To me, architecture is an iterative thing. Don't do BDUF, just keep an eye for patterns that naturally emerge or that match your domain (e.g. value objects) - the last point is especially important, usually when some coder went crazy on an architecture they haven't actually talked to the domain experts and figured out how they think about the problem space. And don't be afraid to refactor when the current design doesn't match its goals. I'm not advocating for having AbstractFactories everywhere. I just don't think that "you won't know 100% what's going to happen" is an excuse for not planning. Project managers, stakeholders, executives also never know 100% what's going to happen - yet they still somehow have to manage their work. Make reasonable assumptions, don't paint yourself into a corner too much and accept that sometimes your assumptions will have been wrong. edit: oh, and about DRY - yes, a lot of people overdo it. Even automated tools annoy me about that. Code Climate for example flags duplicates if you have two methods with a similar structure. Two instances of something being similar is for me, IMHO, not yet a reason to abstract away. Once you get a third instance then, yeah, think about it; but don't blindly pull stuff in a module - think about why, in terms of your domain, do these methods even share behaviour and try to capture the essence of that reason in some abstraction. And even then, sometimes I don't bother. The point of DRY is not "remove duplication at all cost" but "keep every piece of knowledge in one location only"; sometimes two pieces of code are *accidentally* similar. They do similar things just by coincidence but they might as well not in some future version of the code. In such a case, I don't remove the duplication because I don't want a change in one part to affect the other part.
I honestly wish, there was something similar for `fetch`. Or actually, I wish Ruby hashes didn't return `nil` if the key doesn't exist, but a `KeyError` like Python. You can use `fetch`, but writing `params.fetch(:user).fetch(:address).fetch(:street)` or so is much too verbose and hard to grok.
I used to work on some internal application. Most of the views didn't have backend pagination, but some weird Javascript library that did all the pagination client side. That worked - for the prototype version with, like, 100 records. After 2+ years, with 50000+ records in the DB, most of the pages would just time out on you... unless you used the search filters and limited your queries to a small enough subset of data. Which is what people would do. It took forever until that was finally fixed.
Is this meant to be a faster and/or better Rubocop, or something to use along side Rubocop?
Is it really a great idea to align things? It leads to messy git commits if you end up having to change the alignment of a block of things. Great idea to use a real AST though.
Glad I don't have to maintain [this garbage](https://github.com/rkh/almost-sinatra/blob/master/almost_sinatra.rb).
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [rkh/almost-sinatra/.../**almost_sinatra.rb** (master → c61fc1b)](https://github.com/rkh/almost-sinatra/blob/c61fc1b3ac0193bd1c480960cfc54be7f2c36f3d/almost_sinatra.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djajvqn.)^.
Rubinius have unfortunately deleted their JIT. They planned to write a new one but a year has passed and nothing has been shown. So it isn't really a fast a Ruby any more (it's slower than MRI), but it does have other strengths. TruffleRuby is very fast (I'm biased, I work on it) but yes it isn't finished yet. So neither are appropriate if you want fast Ruby to actually use today. There are other experimental fast or hopefully fast implementations of Ruby, including Topaz, MJIT and OMR, but none of these are ready either. Your only option for maintained fast Ruby that is ready today is JRuby.
&gt; Until programmers stop acting like obfuscation is morally hazardous, they're not artists, just kids who don’t want their food to touch.
Thanks, _why. If you can't easily read code, you can't easily maintain it.
Someone obviously needs to improve his skills.
And IronRuby hasn't been updated since 2011.
Or... dig
Here you go: class Hash def multi_fetch(*args) args.inject(self) {|h,a| h.fetch(a) } end end Example: root = {:user =&gt; {:address =&gt; { :street =&gt; "High street" } } } # Works puts root.multi_fetch(:user,:address,:street) # Fails: puts root.multi_fetch(:user,:billing_address,:street) 
Lower latency is also a good thing, and by no means a solved problem in MRI.
Depends on how you write your regexes. 
&gt; Maintainability isn't remotely objective. I've worked on codebases that tightly follow SOLID that were awful to maintain. Sifting through a sea of hundreds of 1-5 line functions is is not maintainable to me. Yet, SOLID is often held of as the holy grail of OO maintainability. SOLID is a pile of marketing. People who pursue SOLID as a goal almost never arrive at the skills needed to design code properly. At best, it's training wheels. &gt; I'll take a single 100 line function over 50 2 line functions any day. You may not have experienced well designed software. Given a 100 line function, a reader _has_ to understand every concept in play in order to understand the function. If it is decomposed, it _may_ end up being a sprawling mess of indirection. But it also may end up being a design that exhibits contextual depth, which allows the software to exhibit three important qualities: 1. The ability to quickly navigate through the namespacing to find whatever detail it is you're concerned with. 2. "Outer" code whose implementation reflects a summarized, "higher level" understanding of the overall picture. 3. "Inner" code that can be understood in greater detail by a reader who only needs to load into their brain the concepts that are related to the specific nuance in question. Some programmers are so good at loading a zillion concepts into their brain at once and figuring it all out that they really don't ever find personal benefit to a design that is optimized for general human understanding. These kinds of people write great databases and operating system kernels. The vast majority of programmers, however, benefit from structural design.
&gt; First thing I need to do when chasing a bug or adding a feature is figure out what the current code does and how it does it, this sucks with SOLID code. It sucks with _bad_ code. Entangled code. Whether it's a pile of small objects that are codependent, or it's an unruly, massive method or class. You are hinting at what I think is ultimately the worst thing about SOLID,. People can create outrageously mistaken code designs and dub the code "SOLID," as if "SOLID" is some kind of adjective that can be attributed to code at all. The thought process goes like this: "hey look, this popular blog post about SOLID code sure is neat. I'm going to follow it's advice and, yipee, now my code looks like the blog post. It is SOLID now!" Unfortunately, the way you talk about SOLID falls into the same trap of being an adjective. You look at a pile of poorly designed classes and say, "ugh, this is some SOLID code." &gt; I find SOLID to be very much akin to waterfall development processes in that doing it correctly requires frontloading requirements to a degree that it's often incompatible with the real world. It's all about batch sizes. How far ahead can a programmer see at the outset of a design? What aspects of the design are the least clear? How can clarity be increased? What areas are subject to the most churn? In my experience, the biggest asset a "senior level" programmer can bring to the table is the ability to step away from the keyboard and increase clarity as much as possible before getting started. Agile isn't about recklessly banging out implementations as fast as possible. It's about applying constraints and shrinking the batch sizes enough to allow for high quality implementations. Do less, but better.
Hope your work on TruffleRuby is going well!
We've been a bit quiet recently - trying to tidy up some of the basics and get things into a state where people could start to use it.
[This benchmark](https://github.com/reu/fibaas) would beg to differ. Response time in MRI is *less* than JRuby. If you're building microservices or doing most of the heavy lifting in client-side scripting, MRI is perfectly fine imho.
Can you make a more real-world example?
Does this help? I just made up some possible names and values for a hash. { user_id: params[:user_id], title: self.name, correlation_stream_name: stream_name(params[:order_id]) } 
 { user_id: params[:user_id], title: self.name, correlation_stream_name: stream_name(params[:order_id]) } what's the issue?
Now `:user_id` is closest to `:title`, when it actually has the strongest conceptual relationship to `params[:user_id]`. The fact that `:user_id` and `params[:user_id]` are separated by so much whitespace is caused by the textual length of `:correlation_stream_name`, something irrelevant to both `:user_id` and `params[:user_id]`. This doesn't add up!
[Diaspora, the open source Facebook clone written in Rails.](https://github.com/diaspora/diaspora) You won't find the absolute greatest designs in their code, but it's solid, huge, and worth looking through. 
&gt; So how people really "know" these things and at the same time they get better at them and learn new things? Learning new things should happen naturally. I think it's natural for programmers to second guess their own code, and try and find better ways to write it. Or learning a new gem because to avoid re-inventing the wheel. "putting the pieces together" mainly involves having a larger codebase that warrants this kind of architectural diversity. For most people, this is the codebase they program at work. &gt; How are two different types of people treated by the tech industry? It depends on the company. Some places want to bring on someone who knows a particular toolset fluently so that they can "plug and chug". This is probably more likely to be an early-stage startup since they will have presumably done some calculation as to which language will give them the quickest return on their money (this is particularly important for Rubyists to understand, because our language is known for being strong in this regard). I would say that you should give due diligence if you find yourself in this situation, and make sure that there is ample experience in tech amongst the company's leadership. If there's not, then you may have more independence, but also a harder time communicating with management. Other places (like consultancies, or more stable companies) will possibly give more opportunity to work with mentors and a chance to discuss shifts in tech stack. Ideally they'd be less married to a specific stack
Does Rubocop actually formats your code? Or does it just check that it's well formatted? I couldn't find an option to actually format something, but I might be really bad at reading docs. How to do it?
You can find non-minified version in comment by /u/geraldbauer 
Aaah... it seems you can `rubocop -a file.rb` and it will format it. I just formatted rufo's formatter (2000+ lines) and it took about 6 seconds to do that. `rufo` does it in 180ms. That means `rufo` can be used to autoformat code from your editor (almost instantly) while `rubocop` cannot, so I think `rufo` is a useful tool on its own. It seems rubocop made their own parser instead of using Ripper, that's probably why it's so slow.
It's not an implementation of Ruby per se... but the syntax is very similar... Crystal. Fast. LLVM backed. Compiled. Ruby-like syntax. It's nice.
Personally, I like it either not aligned or aligned with the whitespace. With the whitespace, it's much like what you'd see in a spreadsheet or anything else with columns and I would think most people are used to that. I have no issue with them not being aligned however.
It's better from a legibility perspective. It's a bit harder to scan for a particular key, since we read left to right in English, so I still have a preference for left justified/no columns. However, the context of this discussion is about legibility, which is an ancillary argument to my main beef (which was pointed out by someone else). If the character length of the longest key changes, you get unnecessary diffs in the git commits (same as the table aligned approach). I'd still prefer standardizing on the non-aligned approach -- and I'd certainly be against a linter telling me my way is wrong.
&gt; There doesn't appear to be anywhere in the CurrentAttributes code -- as far as I can tell -- where it would reset the state of this Current object in between each test. If so, that bit should be fixed. Otherwise it's perfectly sensible design. People bitching about it are as bad as people bitching about ActiveRecord managing database for you and wishing for java-style shitton of boilerplate. Also notice how DHH has far better track record of good judgment than authors of any other framework.
I agree with you that to really learn something you have to focus on it and work for it for a long time. I disagree with the conventional wisdom (if it is that) that you should drop what you're working with and learn something completely new every 3 years. I've been working on ruby and Rails for around 10 now. But you do need to keep up with new trends, learn new things, and be prepared to sometimes drop what you are doing and switch to something new, or even work on more than one thing at once. You would not be the only developer whose natural change-averseness needs to be worked against to do this. :) But I think developers who don't stick with something long enough to truly understand it are missing the opportunity of true mastery -- both of the tool they work with, and of software architecture. You don't really understand how to do better than something until you _really_ know it. (Well, unless it's immediately apparent that it is terrible, heh) And yes, you _do_ need to know _something_ about all the things you mention to be a good Rails dev. I know something about all those things, but I've been doing web development for 20 years. There aren't really shortcuts, it's a skilled craft. Eventually you realize that a basic understanding of how basic technologies work is transferable, and you can learn the new things quicker. But you can't be _100%_ aware of what's going on -- for instance, I have only a basic vague understanding of electrical understanding what's going on at the _hardware_ level, certainly not close to enough to be 100% aware of what's going on. This is an edge case example, but applies in other cases too. 
Yes, but it's also not production-ready. It is a really exciting project, but it's got a ways yet until 1.0.
That PG gem issue really is a thorn in the side. It's one of the reasons the Discourse team Tweeted that they wouldn't be supporting jRuby, and more recently it's the reason Mastadon, which has bought a lot of recent attention back to Rails imo, won't support jRuby. I can't blame the JDBC team because it's a volunteer group and I feel like they go through this every major Rails release. I do wonder if there's a bit of a root cause in ActiveRecord that makes things more difficult than needed.
RubyGems is an open-source Rails app: https://github.com/rubygems/rubygems
Rubocop is plenty fast at autoformating files (albeit mine are usually small)
&gt;&gt; but isn't line count in minified projects kind of arbitrary? Couldn't it be one long one-liner? The Almost Sinatra coding guidelines state: &gt; wrap at 200 characters to make it readable on a terminal Isn't that great - a one long one-liner is no longer readable ;-) 
Yup, thanks!
There was actually a period where running even Rails apps on JRuby was pretty painless. Around Rails 4.x. But yeah, I think the trend has been in the opposite direction to what we'd want since Rails 5.0. Darn software changing. The issue with Rails isn't really JRuby itself, but lack of sufficient skilled developers working on activerecord-jdbc-adapter. :( For non-Rails things, I think JRuby still tends to be pretty painless. But if Rails doesn't work well on JRuby, I expect more and more gems will stop paying attention to making sure they work on JRuby too, and the general adoption of JRuby even for non-Rails things will be harmed. :(
Is there any hypothetical point that could be reached where it could no longer be better? Everything can always be better. :)
I'm not sure you'd get much help, problems with activerecord-jdbc-adapter are well known -- there is still no official release that is compatible with Rails 5 (Rails 5.0.0 released June 30, 2016), and this is not a secret in any way. There's just not enough developer resources for activerecord-jdbc-adapter. :(
I tend to agree. Jruby problem is mainly rails not acknowledging jruby (they officially only support MRI). And even beyond that , the mindshare that rails attracts is way bigger than jruby or even CRuby itself (compare core teams). Bundler and other "infrastructure" gems manage this well, but other like openssl don't (this is a topic on itself). The only way this ever goes away is if 1) rails acknowledges jruby as a target environment, or 2) projects ditch activerecord and go for another library which supports multiple environments, has same features and some more, and is overall less buggy... such as the sequel gem.
The problem I'm pointing at isn't one of entanglement nor 'incorrect' application of SOLID or encapsulation. The problem is how to encapsulate correctly given unknowable constraints. As an example, say we have some code that applies filtering to a collection of data. Initially are a handful of filtering constraints that apply to the data records, something that could be written in a &lt;100 line method quite easily. But instead we decide to architect this. We come up with objects that encapsulate filter predicates, an object that handles sequential application of filters, etc. A good SOLID design. Then, 6 months later we want to add a new filter that has some new constraint, maybe it doesn't just work on a single record at a time but needs to be able to also consider the sequence, but our nice abstraction doesn't support this since it wasn't a constraint at the time. Had this been an 'ugly' 100 line method, no big deal we can just add the new filter logic as needed, but instead we have this great design pattern that is very clear, but the code is structured around a filter only acting on a single record at a time...shit. Now we have to either update the abstraction, including every place it's used, or 'break the mold' here and replace the abstraction with a new one that supports the filtering we need, but the new one wants to be API compatible with the old one so we can reuse predicate objects...fuck...we have a mess. Especially in hardcore SOLID shops, the solution to this is often extend the abstractions, maybe we add a 'filter executor' base class with multiple implementations that either work on sequences of single records then do the same with the predicate objects such that we have predicates that are 'sequence' predicates or 'single' predicates and wrap the whole thing up in a module or package. Over the course of a year or two new features come in and this turns into a dozen or more objects, it's very SOLID, taken in isolation it's good code. But, at some point you step back and say...shit...we've just reimplemented all the flow control logic our programming language already provides, just to avoid a 100 line method. I run into issues along these lines all the time, and I'm not advocating ignoring all code structuring, but I am saying you should think long an hard about creating an abstraction as you're now tied to it's design and abstractions are _hard_ to change. This is actually considered a 'feature' of SOLID, hard to change easy to extend, and guess what? It get's extended, a lot. If you're not sure about it's long term applicability of an abstraction, don't build it, write the 100 line method, it's probably better in the long run. If it gets hard to understand, break it into a few methods but don't build an abstraction, don't encapsulate the data unless you have good reason, chances are good you'll encapsulate the wrong data and have to undo the abstraction and replace it later on.
&gt; Without an ORM, you wouldn't have mutable data structures whose values are initialized from the database. You ALWAYS have that. It doesn't matter if I load a row from pg into a hash, update a value, then write it back or if it's in an AR object. The underlying database row may have changed since I read it. Nor does it matter if I make the hash immutable and modify a copy, same problem. This is actually a great example of where an ORM helps as I can get optimistic lock checking added to all writes automatically. &gt; If a large swath of code is coupled to the same instance of an ORM record, you have a greater surface area for bugs than if different parts of the code retrieved the data that they needed independently of one another. That is highly code dependent, different pieces of code may rely on changes made by other pieces of code that can't be written in the interim. &gt; This is incorrect. Global state does not have to exist. It's a one way ticket to bugtown. Global state is a reality, how to handle it is up to you. Every process have `ENV`, that's global, every web request has a socket that is global to the request, pretty much every app will have a global logger, etc. You can choose to encapsulate this as you wish but global state is a matter of the problem space, you can't get rid of it, only hide it which has it's own perils. See rack's design requiring socket highjacking for streaming responses as an example of where encapsulating global state causing problems. &gt; My point was that the need for all this code to depend on user is itself a smell that is obvious when you have a user being passed explicitly into a giant constellation of objects. You miss out on that painfully obvious design feedback when references to Current.user can be hiding anywhere in the codebase. That is the problem though, in an average web-app you need the user in tons of places. You need it to tag changes for every database write so you can track changes (e.g. `paper_trail` whodunit), you need it for logging, you need it for metrics. I agree if there is a business use for a value, you should explicitly pass it, but there is a huge set of use cases for data that is needed in many places that is ancillary to the primary business function of the code. Certainly in terms of clarity I prefer to _not_ explicitly pass such values. I don't want to pass the request ID explicitly to every method that may write to the log just so transaction tracing works. It muddies the API and makes it appear a method truly needs a request ID for it's core function when it does not. &gt; I get that you prefer code to be lumped together in one place, and that you haven't personally experienced benefits to cohesive designs. Cohesive designs are great, _if_ they are structured correctly, if they aren't they are awful to work with. This isn't usually the result of a 'good' programmer vs a 'bad' programmer, it depends entirely on how ridged the problem space is. If you know you need to build feature X and it's not going to change significantly for 3 years, but all means, make it SOLID. But, that is a fairly rare situation in my experience and I run into a lot of code that was written with the assumption that it wouldn't change in a way that fights with the designed abstractions, but the need arose and now I have to spend a lot of time undoing the premature abstractions. &gt; I've seen the benefits first hand, and frankly, I wouldn't touch a codebase that made use of this kind of garbage feature with a 10 foot pole. The culture of rails seems to increasingly encourage reckless shortcuts. Glad I'm not doing rails anymore... I can almost guarantee you have this pattern in your codebase somewhere, it's likely just hidden from your view so you don't get upset about it :) 
&gt; To me you're just painting a false dichotomy. It's either no architecture or bad, premature architecture. Not my intent. I'm not saying all architecture is bad, but pre-mature architecture is, and a lot of SOLID code I run into is _extremely_ prematurely architected. &gt; To me, architecture is an iterative thing. Don't do BDUF, just keep an eye for patterns that naturally emerge or that match your domain (e.g. value objects) - the last point is especially important, usually when some coder went crazy on an architecture they haven't actually talked to the domain experts and figured out how they think about the problem space. The problem I see is that once a programmer learns a bunch of patterns it's easy to see them everywhere and think it's a great idea to use them. Also in many company structures the programmer may be sufficiently removed from the business problem space that they can't learn enough about the domain to make an intelligent choice. For bigger companies this requires a thoughtful project manager with coding experience which is rare. It also requires a business model that is relatively stable. &gt; And don't be afraid to refactor when the current design doesn't match its goals. I'm not advocating for having AbstractFactories everywhere. Sure, but if it hadn't been pre-maturely architected I wouldn't have to refactor an abstraction. As the use case becomes more clear it's much more time efficient to refactor into an abstraction that emerges and may be different the the 'obvious' abstraction that existed when the code was initially written. It's easier to create abstractions than change them. &gt; I just don't think that "you won't know 100% what's going to happen" is an excuse for not planning. Project managers, stakeholders, executives also never know 100% what's going to happen - yet they still somehow have to manage their work. Make reasonable assumptions, don't paint yourself into a corner too much and accept that sometimes your assumptions will have been wrong. I'm not advocating for no planning, I'm advocating for not creating an abstraction unless you're fairly confident it's the right abstraction for the foreseeable future. If you aren't sure, write the 100 line method, it's easier to refactor that into the right abstraction as domain knowledge becoming clear than it is to refactor out of the wrong abstraction. 
Design Patterns is a good book, but I would recommended POODR instead.
Also, since you're modeling dice rolls, keep in mind that the distribution of 2*rand(1..6) is not the same as rand(2..12) (aka, there's a reason 7 is an unlucky number in craps): irb(main):010:0* require 'pp' =&gt; true irb(main):011:0&gt; counts = Hash.new {|h,k| h[k] = 0 } ; 1000.times { counts[rand(1..6)+rand(1..6)] += 1 } ; pp counts.sort_by(&amp;:first) [[2, 24], [3, 53], [4, 81], [5, 117], [6, 134], [7, 179], [8, 151], [9, 107], [10, 80], [11, 46], [12, 28]] =&gt; [[2, 24], [3, 53], [4, 81], [5, 117], [6, 134], [7, 179], [8, 151], [9, 107], [10, 80], [11, 46], [12, 28]] irb(main):012:0&gt; counts = Hash.new {|h,k| h[k] = 0 } ; 1000.times { counts[rand(2..12)] += 1 } ; pp counts.sort_by(&amp;:first) [[2, 97], [3, 94], [4, 90], [5, 80], [6, 98], [7, 81], [8, 97], [9, 90], [10, 80], [11, 108], [12, 85]] =&gt; [[3, 97], [3, 94], [4, 90], [5, 80], [6, 98], [7, 81], [8, 97], [9, 90], [10, 80], [11, 108], [12, 85]] 
elseif .... arg == nil ......#{arg.join}" Lolwut Loads of duplicate code in that file too
Yeah....ugly ugly solution. I rewrote the functionality of all the network stuff into a new netgeo script.
Should be in the repo. Trying to use more modular practices to avoid repeating myself. Most of them were written when I first started learning Ruby, and neglected best practices. It's been an evolutionary experience, just trying to learn from past mistakes and make it more idiomatic over time. 
Well looks like I'll be getting POODR too then, will probably read POODR first.
Everyone has to start somewhere!
[here](http://www.unheap.com/inputs-forms/date-time/) are a number of jQuery plugins for datetime
Looks like the project is already dead? 
Awesome! This is awesome for people who have a tough time with regex sometimes. People like me! I don't do a ton of search and replace in files, but I'm going to try this out as a regex alternative for some scenarios. I agree with /u/joelparkerhenderson on the suggestions about picking a single name. Make it easy to remember, the more names to remember, the less likely people will actually remember. Again, awesome job, can't wait to test it out! 
Enumerable#count_by isn't that bad with Hash#transform_values: posts.group_by(&amp;:author).transform_values(&amp;:count)
That's a good point actually.
You can use `+` instead of `join` which makes this look a little more crisp: Pathname.glob(path + "*/*.txt") Note that this expression does not find all "all big text files in path = Pathname("some/directory")" but rather all in "some/directory/*", i.e. in all immediate subdirectories of "some/directory".
The only thing I miss from ActiveSupport are a few of the Hash methods. Why aren't `slice` and `except` part of Ruby core? It would be nice to have `transform_keys` and `reverse_merge` too.
&gt; One mindbogglingly missing feature is access to query parameters in URI objects to extract or modify them. The library treats the whole query as opaque string with no structure, and I guess expects people to use regular expressions and manual URI.encode / URI.decode. Agreed it would be nice if it were there, but you can use `CGI.parse`. `CGI.parse(uri.query)`. 
Got it, that makes sense.
I might as well code a mini framework in ones and zeros, and then write a book to explain what those arrangements of ones and zeros mean.
Yeah, but why would I ever want to use `irb` instead of `pry`? (unless it somehow integrates all of pry's features).
Is that final code threadsafe?
This is great and all but I can't help but think the article would have been better with realistic code samples. 
Thanks for your comment. I agree with that, but sometimes to describe some concept or general idea I prefer to pick really simple examples. Examples that wouldn't distract reader by details of implementation. I feel like it helps readers to focus on the main idea or concept. Thanks again for the comment. I appreciate feedback and try to adjust my style of writing according to that.
&gt; Yeah, but why would I ever want to use irb instead of pry? because ruby ships with irb? 
 this article to tought very little about state machines. 
(About gems, mostly) To be honest, I am highly skeptical about _any_ scaffolders (though I can understand how one can be useful for Rails app with all the models, controllers, views, decorators, migrations, conventions over configurations you name it). I see it in gems, and it ends up with ton of half-baked gems with "default README" (saying "this is you gem README") -- I believe it would be better to have author to fill it from the very empty file (maybe this way we'll also have fewer gems, spending 5 paragraphs to explain how'd you perform `gem install gemname`). I see it in my students trying to use rspec for the first time with generated 200-lines `spec_helper.rb` with a ton of explanation they don't read and "just leave here, don't know what is it". I seriously prefer we'll use tools, frameworks and approaches that will NOT require any "scaffolding", just mindful code writing. For my own gems, I typically use the next steps: * start with `lib/potential_gem_name.rb` (if it starts from the "will this work?" though) or * start with `README.md` with explanations "why it is necessary and how it will work" (if it starts with "this is possible and necessary, I just should writ it" though) -- yes, BEFORE any code * then write some specs and/or `sample/demo.rb` (but in latter case, it is just in earliest stage on development, then specs go); * at this point, I am probably starting to have `Gemfile` (with the simplest content possible) and `.rspec` and drafts of `README` * closer to first release, `.gemspec` will emerge, maybe with some `bin`, if it suits the gem * then, polishing and working on new versions, it grows to have `CONTRIBUTING.md`, `Changelog.md`, `.travis.yml`, license, `Rakefile` and so on and so forth. I am not sure which of this steps would be seriously simplified with scaffolder (well, I constantly forget and need to copy-paste overall `.gemspec` structure... and maybe some of my favorite `.rspec` options... but that's mostly it)
Thanks for your great reply and insight. Starting from scratch is always a great option (especially for gems) - not so fun for [sinatra apps](https://github.com/quikstart/sinatra-starter-template/tree/master/template) or [gem-packaged jekyll themes](https://github.com/quikstart/jekyll-starter-theme/tree/master/template), for example. The idea of quik is that your "scaffold" is just a git repo with your "standard" setup that you can "parameterize" and script in - surprise, surprise - ruby. Ruby is great to automate code too - I think it's called metaprogramming or something. Anyways, famous scaffolders in python land include [cookiecutter](https://github.com/audreyr/cookiecutter) or in node.js land include [yeomon (yo)](http://yeoman.io). Ruby can do better ;-), thus, quik. For example, the bundle gem "scaffolder" is "hand-coded" and cannot get re-used and also as you say is more-or-less an opinionated take-it-or-leave-it-approach. Can we do better? Cheers.
Hi Gerald … - for starting a new gem, simple use `bundler gem new_gem`, - for a new grape based API [grape-starter](https://github.com/LeFnord/grape-starter) is the tool of choice for me 
This article seems to be describing simple workflow processes, i.e. "all movies begin in the production step and then transition to the theatrical run step." State machines are concepts that we borrow from lower level parts of our stack -- hardware chip designers use state machines all the time (in fact, our CPUs are one big state machine). In software, state machines are patterns that enable long lived objects to carry out processes whose life cycles endure indefinitely. From time to time, "events" are pushed to the state machine (this can be a method call), and the state machine updates its _internal_ state (these can be instance variables). State machines can actuate useful behavior by broadcasting events that means something to the particular domain -- i.e. "this movie now in theaters," although that isn't strictly required (it's just another useful pattern that often arises). Many of these sort of activerecord-ish "state machines" lift a lot of the language of state machines but are counterfeit state machines under closer observation --the most common tell is that the state is not kept internal to the machine. Another tell is that the current "state" (again, which is generally just a workflow "step" if you drop the SM vocabulary) can be explicitly set. This is usually a side effect of the fact that the gem being used works on top of ActiveRecord, and `state` is a column. State should almost _never_ be an attribute on an object that implements the state machine pattern. This kind of gem _can_ offer useful behavior, but I prefer to call it "workflow."
hi , thanks for the detailed reply. Too tired learning abt tests the whole day. Gona learn again tomorrow. Good night mate
Awesome post. Is this feature only available in Postgres? I am using AWS Aurora and wonder if the same strategy could be applied. Right now I am just trying to focus on getting my indexes right the first time but we all know how that can go.
State machines aren't a concept borrowed from hardware. They are a mathematical model of computation; a mathematical automaton. They are useful in modeling many types of systems; hardware, algorithms, workflows, ... A state machine is defined as a finite set of states, and the conditions on which it transitions from one state to another. Then, an instance of that state machine has but one "instance variable": which of those states it is currently in. Of course, the constructor would need to know the initial state. (Note that this is literally the exact information that is included in the article's example Movie class!) There's no reason that an instance of a state machine needs to continuously be in memory, in fact, one of the benefits of structuring your software after a mathematical state machine is how easy it is to serialize: it's just a single state identifier! State machines are a mathematical model that many people find useful in thinking and reasoning about a variety of systems. Nothing more. That said, the article was a very light "tips on using state machines to model workflow."
I mainly use `bundle gem new_gem` because I'm too lazy to look up all the things I need to put in the gemspec. Then I delete half the stuff it generates.
Griasdi * For creating a new gem, I pretty much only use `bundle gem`. * For Jekyll themes: Jekyll provides a `new-theme` command, so I've used that when extracting my personal theme into gems (they're on a private gemserver, might change that in the future if there's enough interest) * Jekyll plugins however are just like generic gems, therefore I also use `bundle gem` here * I've also written a quick-and-dirty CLI project scaffold/boilerplate for myself, just to ease the beginning of writing CLI applications. The code of it is almost unmaintainable though 😂 * For Sinatra apps, I don't have anything to quickstart now. Which I should/want to change, maybe quik/qk can help out here a lot. ;) Looking forward to your talk next week.
Thanks for sharing. Looks like the `bundle gem new_gem` is the winner. I'm still "old school", that is, using the [Seattle.rb gem rake tools, that is, hoe](https://github.com/seattlerb/hoe) with a `Manifest.txt` (instead of `git ls` for including files etc.). Cheers. 
Thanks for sharing. `bundle gem`is the new favorite. The [gli gem](https://github.com/davetron5000/gli) for "git-like command lines" might interest you - it includes a great CLI scaffolder /starter "out-of-the-box/gem". Little [gli article](http://planetruby.github.io/gems/gli) from the Planet Ruby Gems of the Week series. Your CLI scaffold might make a great new boilerplate / starter template maybe for quik ;-) No worries "quick and dirty" is the new normal. There's a first [sinatra-starter-template](https://github.com/quikstart/sinatra-starter-template) for quik - it's kind of minimal. New ones more than welcome ;-) Cheers. PS: Looking forward meeting you. If anyone else is around Linz (in Upper Austria near Bavaria in Central Europe) join the [Meetup on July/4th](https://meetup.com/Ruby-User-Group-Linz-RUGL/events/240388912/). 
X-Post referenced from [/r/programming](http://np.reddit.com/r/programming) by /u/TheFearsomeEsquilax [Interviewing Ruby Programmers (Steve Yegge, 2006)](http://np.reddit.com/r/programming/comments/6jq7c4/interviewing_ruby_programmers_steve_yegge_2006/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I've been using this recently for testing Rails integration in a gem. I don't want a whole Rails application in my `spec` directory, and a Rails app in a single file works just as well.
* great job * use spaces not tabs (afaik in ruby we do 2 spaces indentation). * say `SomeClass` not `Some_Class` why not do a file format like: Operation Source (Target) C = Copy, M = Move, D = Delete eg: C this that M this2 that2 D this3 The empty prefixes in the existing format probably makes it harder to parse and seems more error prone. tbh if I was going to go to this much trouble in a text editor to move some files, I'd just write a shell command cp "source" "target" mv "source" "target" rm "source" those commands also have flags for interactive mode.
I bumped an app from 5.1.1 to 5.1.2 and started getting `NoMethodError: undefined method 'needs_server?' for nil:NilClass` from my system tests. Probably I didn't set things up quite right when I cut over from integration to system tests, though...
s/map/select/
I use a gem generator I built. I use boilers often but since there's a big learning curve with them, I generally prefer to use ones I've made myself. The most useful ones have been: - webpack boiler with my preferred loaders set up - sinatra / faye-websockets skeleton - ruby REPL skeleton for command line applications - phaser and gosu 2d game skeletons - SPA static website generator using markdown pages for content blocks and isotope.js for filtering them by tag 
You should define your regular expression outside the loop, I think. I'm not sure though. switch = ["ChangeServer&lt;br/&gt;Switch:3&lt;br/&gt;PinCode:DFSFSDFB04008&lt;br/&gt;ShipCode:DFADFSDFSDM-000D3&lt;br/&gt;SomeCode:sdfsdf", "werwerwe", "adfsdfsd", "sdfsdfsdfsd&lt;br/&gt;Switch:7&lt;br/&gt;PinCode:ADFSDF4NS0&lt;br/&gt;ShipCode:FADFSDFD-9ZM170&lt;br/&gt;"] re = /(?:Switch:)([0-9]+)/ switch.map{|str| str.scan(re)}.flatten Or just switch.join.scan(re).flatten
Any estimates on when the first release candidate would see the world? Big thanks for your work by the way.
WE MISS YOU RYAN! 
I use Aurora and it does not lock tables on indexing. It will block until it is done if you're doing it with rake db:migrate, but it will not lock the table. I just use an EC2 instance, load up a screen session, run my SQL against the Aurora cluster, then when it's done I deploy my code.
You had to pay for at least one month.
He hasn't charged anyone since he stopped making episodes.
Wow. Word's 1st Quik Template for Thor! Thanks for sharing (and trying). 
I upgraded libhunt.com from rails 4.2.x to 5.1 recently. It took me around a day, and it wasn't painful at all (having most of the functionality covered with specs). 
Are you already using the [grpc gem](https://rubygems.org/gems/grpc) and wish to abstract that further?
But to also partially answer your question, the [twitter gem](https://github.com/sferik/twitter) and [aws-sdk gem](https://github.com/aws/aws-sdk-ruby) provide nice simplified interfaces around the relative APIs.
Wow thanks! TIL.
Absolutely. Specs can even help you detect subtle changes in the framework or your dependencies. Spec breakages provide a great way to measure some sort of progress in the upgrade (even if a small number of failures often end up taking more time to fix than the remaining 90%).
Some people are still on 2.x (I even saw one case of 1.1.x still in production less than 2 years ago if I recall well). The more we'll advocate than it's not a good practice, the better :-)
Yeah. We're trying to get to 4 or 5 this year, but choices that developers made in the past have made upgrading difficult. 
Yes, unfortunately technical debt can remain hidden until you try to upgrade (monkey-patching, unused SQL tables, whatever)... Good luck with your upgrade though, it's important!
Thanks, Ryan. Do comeback to creating videos on rails or anything else which catches your fancy - when you are ready for it. Till that time, focus on getting back to health both physically and mentally. Thanks for everything you have done for the community.
Its happening but we've been caught in a backlog of new feature development. 
Yeah. I've brought this up before. 
This is really good content. Keeping it weird AND technically substantive!
No problem - you can use Hanami, Sinatra, Padrino, or even Phoenix like I do, the same still applies. Know the maintenance policy, and keep your apps up to date!
I always keep my projects up to date, it is indeed a good habit. It's a worth while PSA :-)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [ruby-concurrency/concurrent-ruby/.../**lock_free_linked_set.rb** (master → 041c1d1)](https://github.com/ruby-concurrency/concurrent-ruby/blob/041c1d10df225e6d3295c428aebb719931754562/lib/concurrent/edge/lock_free_linked_set.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djiw13x.)^.
Maybe compared to something really ancient (Rails 2 and Ruby 1.9) the speed improvement will be significant but my argument was about post-asset pipeline versions of Rails. According to http://engineering.appfolio.com/appfolio-engineering/2017/4/14/comparing-ruby-speed-differences moving from 2.1 to 2.4 will bring increases only for 99th percentile (and that just screams "garbage collector" i.e. "not gonna happen in production apps")
HA, fair enough, it actually doesn't work as I'd expected. It returned 1 and looked like it successfully set the chmod flags, but didn't. You do have to use 02755. That's at least predictable and consistent though. For some reason I expected passing "2755" to work because you often see "0755" when using stat or chmod on the shell.. I guess even though I knew it in the back of my head, it didn't click until just now that even though "0755" as an attribute is in octal, when you see it with stat the first 0 is actually a zero bit, whereas with ruby's "0755" was really just "755" because of the goofy octal notation. So now it makes perfect sense to use 0o2755/0o755 in lieu of 0755/2755. Thanks for your patience, haha.
Yep :-D
&gt; great job thanks :) &gt; use spaces not tabs (afaik in ruby we do 2 spaces indentation). &gt; say SomeClass not Some_Class tbh this part of ruby convention never made any sense to me, so in something like this (where I don't really expecty contributions) I probably leave it as it is &gt; why not do a file format like: &gt; &gt; Operation Source (Target) &gt; &gt; C = Copy, M = Move, D = Delete &gt; &gt; eg: &gt; &gt; C this that &gt; M this2 that2 &gt; D this3 &gt; &gt; The empty prefixes in the existing format probably makes it harder to parse and seems more error prone. True, the empty prefix makes it a bit harder to parse (there was even a bug related to this in pre-release version), but in your format I would have to someone handle escaping, which seems even more prone to errors. &gt; tbh if I was going to go to this much trouble in a text editor to move some files, I'd just write a shell command &gt; &gt; cp "source" "target" &gt; mv "source" "target" &gt; rm "source" &gt; &gt; those commands also have flags for interactive mode. If I want to move file or two, I would probably also just use command line. But if you for example ever saw how torrents with manga look inside, that's were this tool comes in handy. The ability to see how the regexp resolves everything inside the editor before you save it (so you can do multiple tries if you don't get it at first try) is at least for me (I'm not good at regexps) very useful. To sum up, this tool is not supposed to replace `cp` or `mv`, it's meant (in my usecase at least) to simplify management of lots of torrent files (where people do get a bit crazy with names from time to time). Also it's useful for batch renaming subtitles :)
Do you pay for the LTS fork?
Speaking from personal experience, the only web-related ruby projects that I've contributed to have been based on Sinatra/Grape/Roda, and it's basically for the reason you listed. Usually it's easier to get at the meat of the code.. I don't even know where to start half the time when it comes to debugging other peoples rails apps. edit: I should note because this is because rails apps are usually huge and I'm just less inclined to roll up my sleeves and learn a codebase of that size. It's not that rails is unappealing.. it's just that the kinds of repos that I find myself cloning are usually either entirely non-web projects or webapps that do one very specific thing (usually gluing one library to another) and lend themselves well to being built on top of a microframework.
In YARD, you can auto-copy documentation from other places. For example, the docs for [this param](https://github.com/tomdalling/rschema/blob/dd7e1302f8489f5b7130174662ce9ba789b74b5e/lib/rschema/dsl.rb#L79) are being copied from the [param of another method](https://github.com/tomdalling/rschema/blob/dd7e1302f8489f5b7130174662ce9ba789b74b5e/lib/rschema/dsl.rb#L149-L153) using the `(see X)` syntax.
I don't think there's a significant difference in ease of contribution based on framework, in these cases. 
It's actually rather sad. This sounds like he's not going to continue. Thanks Ryan - I've learned so many things from your railscasts
Rails maintenance policy is a promise of a breaking change per year. Not only the end-apps have to allocate resources by upgrading, but the whole mostly-OSS ecosystem (rails-only gems, speculative-state: over 9000 gems!) has to follow as well. Most failed/delayed end-app upgrades are due to the latter. Also, most learning resources lose value after 1/2 years. I've stopped upgrading apps wherever I can, and now start using more minimal stacks instead of rails. The rails migrations have exhausted me (been doing this since 1.8), and the non-rails ecosystem is mature enough. 
That's interesting because I often hear the argument that "Rails is easier for onboarding because it uses conventions and if you know one Rails app you know all of them". Personally, I generally prefer non-Rails-stuff, especially if I don't need any of the view stuff (when I'm developing an API), but I've been wondering if I let my personal preferences interfere with the ability for new people to contribute. Glad to hear that you find it easier to contribute to non-Rails projects. I'd also imagine that if you take any non-Ruby developer they might find it easier to contribute to a Sinatra project than to a Rails project.
But probably not very significant, right? My point is not that upgrade is useless it's that "our application will be faster" is not a strong argument for it, but "huge parts of our application will be maintained by random people for free" is.
**Example** Imagine somebody walks in with a new device that you've never seen before. he calls it the "calculator". "Interesting," you say, looking a little askance at the device. "It adds any two numbers you give it," he replies, quickly, and with confidence. "*Any* two numbers?" "Yessir, any two numbers!" Again you're suspicious: how do you know that it's doing what it intends to do? That's where testing comes in. **What to test** I don't recommend you test everything, but test the key features of each method to make sure that it does what it is meant to do. You start by writing at easy test: 1 + 0 = 1 (the expected outcome). then you test whether the calculator gives you the same result. etc. THAT is as simple as testing gets, and no more complicated. **Summary** INPUT -----&gt; Output all that testing does is confirm that the input gives the output that you expect. I highly recommend you read 99 bottles by Sandi Metz to give you an introduction to testing. try out the first chapter (it's free) 
Ah - absolutely; performance is not the most compelling reason to upgrade, indeed. For me the most important reason is that being mostly on your own (no shared issues, no relevant SO threads, fewer forks) on old versions of all your dependencies is not a nice place to be (ends up costing quite a bit, &amp; introduce security issues).
You use whichever tool is best for the given task. If you need a **loop**, then use `while`, `until` or `loop`. If you need a **conditional** then use `if` or `unless`. Generally speaking, it is a preferred style-guide to write `unless condition` instead of `if !condition`, and vice-versa. Likewise it is preferable to write `until condition` instead of `while !condition`, and vice versa. `loop` is typically used for "infinite" loops; it's typically preferable to use this instead of `while(true) do ...` Have a read through [a ruby syntax styleguide](https://github.com/bbatsov/ruby-style-guide#syntax) for more detail.
&gt;ok m gona read the 99 bottles. thanks mate I had the same problem while back. 99 wasn't even an idea at the time but Sandi Metz is the best at explaining OOP and in directly testing. I read her poodr book which was both challenging and approachable. She is a really fantastic and accessible teacher of OOP concepts. 
Just a little bit more: in general, you only need to test public methods, or methods that affect something other than the object itself may see. Generally, if the public methods work, then your private methods probably do as well, but even that doesn't matter since they don't act on the world outside of the object. So you don't need to write tests for every little bit. That was my biggest takeaway from reading the end chapter of poodr. That realization helped me a lot when I was in OPs shoes.
I think it's almost certainly easier to onboard new developers to huge monolithic apps if they're on rails versus something mostly custom, but if we're talking about small single-purpose webapps or APIs/microservices (something that any developer should be able to pick up reasonably quickly), rails doesn't do much but get in the way; it's just one more thing you have to learn (along with its opinions and idiosyncrasies) before you start work. The beauty of Sinatra is that it's been replicated in almost every other language at this point, so as you said, there's a very good chance even a non-ruby dev is familiar with it at some base level. A couple times now, I've handed off little Sinatra projects to language-agnostic shops, and I'll hear stuff like "Oh this looks just like slim/express/spark/etc". I never feel bad about handing off a sinatra app to a team that's a little light on ruby experience, because most of the time it's ~500-1500 SLOC, and it's all laid bare in front of them. It's not some extra burden to maintain, whereas with rails, if you aren't keeping track of the ecosystem and cert advisories, that app will rot if the team doesn't put in the effort to maintain it.
I've got a Thinkpad t400 Ubuntu 14.04 and the only time I've felt the need to upgrade is trying to do Android development. 
yes sir/ma'am i concur with the above statements.........i would add that if you test private methods then if/when they change all the tests would break. nothing worse than seeing a wall of red after making a wee-tiny change. sometimes i personally test private methods to make sure they're doing what i intend them to do, but i understand the risk of brittle tests and am quick to get rid of them when required.
Nope, but it seems really insecure to run on software that's unpatched and unmaintained.
Cool! I wrote the last section of this article in a bit of a hurry. Are there parts of `concurrent-ruby` that use compare and set without a lock under the hood for MRI code? 
I am somewhere in the 4th chapter in poodr. that book is really amazing 
Everyone`s reply is helping me add my knowledge. :) .
Look for first timers only tags. 
SECTION | CONTENT :--|:-- Title | Rails Conf 2013 The Magic Tricks of Testing by Sandi Metz Description | Tests are supposed to save us money. How is it, then, that many times they become millstones around our necks, gradually morphing into fragile, breakable things that raise the cost of change? We write too many tests and we test the wrong kinds of things. This talk strips away the veil and offers simple, practical guidelines for choosing what to test and how to test it. Finding the right testing balance isn't magic, it's a magic trick; come and learn the secret of writing stable tests that protec... Length | 0:32:23 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
actually m testing a sinatra app. the reply from the reddit community is so helpful, m finally being to undertand testing.
Yeah, that sounds about right. It's easier to contribute to a clean, readable codebase. Sometimes a microframework is the right tool for the job, and a lot of other times a larger framework like rails is. It's also entirely possible that your project could grow in scope and you need to port it to a framework that makes managing something of that size less burdensome. Use what makes sense at the time of the initial MVP, later on, if it needs changing, change it. A framework doth not a good project make.
Sorry, I didn't know that was against Reddit etiquette.
Unless the test was meant to check failure?
You can always add padrino if you need more features, you might not need rails
Maybe OP meant + as in logical and?
I'm not sure I understand where you heading, as I never used SOAP :-) (I do know however that people didn't like SOAP, and REST was a solution to that? like gRPC being a 'solution' for REST? :-)).
I had a hard time understanding model scopes, this episode helped me understand them better and is the reason I switched from MySQL to PostgreSQL. http://railscasts.com/episodes/343-full-text-search-in-postgresql
Hello, What's your favorite datafile format? [Awesome YAML](https://github.com/datatxt/awseome-yaml) or [Awesome JSON (What's Next)](https://github.com/datatxt/awesome-json-next)? I prefer good ol' INI ;-) that's why I published a new [iniparser gem to read / parse INI configuration, settings and data files](https://github.com/datatxt/iniparser) into a hash. Use: require 'iniparser' hash = INI.load_file( 'planet.ini' ) pp hash Cheers. PS: What's INI? See the [`planet.ini`](https://github.com/feedreader/pluto.starter/blob/master/planet.ini) as a "real-world" example.
That's great! Thanks a lot.
I prefer YAML, it's advanced, but really simple to use, and also (somewhat) compatible with JSON. I also recently stumbled upon [SDLang](http://sdlang.org/), because it is used by D's package manager [dub](http://code.dlang.org/getting_started). There's also a Ruby library for working with it ([sdl4r](https://github.com/ikayzo/SDL.rb)), but it doesn't look like it got any updates the past few years (also its API doesn't look fun to work with) 
If you like .ini files, you might want to check out TOML: https://github.com/toml-lang/toml
Thanks for highlighting SDLang and sdl4r. I'm also a big fan on YAML for datafiles etc. but sometimes INI with all values all string all the time is easier / simpler e.g.: title: Planet Open Data News [osm] title: Open Street Map (OSM) News link: https://blog.openstreetmap.org feed: https://blog.openstreetmap.org/feed/ vs: title: Planet Open Data News osm: title: Open Street Map (OSM) News link: https://blog.openstreetmap.org feed: https://blog.openstreetmap.org/feed/ Not much of a difference I know. But in YAML sometimes you have to quote strings e.g.: title: "Using JRuby: Bringing Ruby to Java" because title: Using JRuby: Bringing Ruby to Java will not work in YAML, for example, (but works in INI) files.
edit: :+1:
Your fix is included in 2.1.0
't' and 'f' is how SQLite represents boolean values
Good thought
Right, but simulating sets using hashes is not cute. PR Submitted. 
A similar gem already existed, is mature at 3.0 release, and supports writing as well as reading. https://github.com/TwP/inifile Is this new one meant to do something that one doesn't?
boolshit
[this is bullshit](http://imgur.com/DSP7PQf) edit: PR submitted
Maybe instead of trying to catch each edge case, create a config option that you can call in a initializer to add your app specific cases. Just supply the expected cases(empties, false strings, ect) out of the box. 
Awesome article... the digging that went into this is VERY impressive... tipping hat to you ;)
This is really well said... I don't know how many times I have wished to use one of the big CMS rails engines only to not do it because it was not in this or that version of rails... As someone who was using ruby before rails existed, I have run the whole lot of feelings about rails... still have a love / hate relationship... And still love sinatra just as much as the first time I saw it... Just wish it had more traction and tools in its ecosystem...
The PCRE is strong with this one... obviously using the force with a lightsaber he has constructed himself...
Just as a helper for you or anyone who checks this out... a great tool for working on your Regex stuff is [http://rubular.com](http://rubular.com)
Funny, but I think this gem has an actual purpose. It can be used to establish very strict truth checking. A string with contents wouldn't be bullshit, so making this PR would change that for the worse.
Uhm yeah I'll be bringing this gem into my company and I'll use it on my next rails app.
Technically, your approach is probably more efficient. `Set` in MRI is implemented as just a hash of booleans so your variant uses a tad less memory due to not allocating the `Set` wrapper object and has one less method call for each lookup. Otherwise, it's identical. 
Good question. I repost my answer from the ruby-talk mailing list: The major innovation of the new iniparser is that you can now use \-- Haskell (or SQL) like comments too - plus bonus! % you can now use TeX like comments too. More serious ;-) The new IniParser is simpler ([see the single parser.rb file](https://github.com/datatxt/iniparser/blob/master/lib/iniparser/parser.rb) ). On purpose every value is a string e.g. no (auto-)conversion to bool (for true/false) or numbers (for 1,2, etc). Also the IniParser returns a "plain" Hash. Here be dragons ;-) No wrapper around Hash or anything. Also INI.load and INI.load_file is "modeled" after (or just copied 1:1) from YAML.load and YAML.load_file - the idea is that you can replace one with the other (both return hashes). Last but not least do NOT want to scare anyone, but not sure if inifile is still maintained (and loved) by Tim Pease?
seems_legit
The final "data" solution introduces a new problem imo: the DatetimeField class must now be modified in order to be extended. Using the earlier presenter/decorator pattern, we followed the nice open/close principle that our classes are open for extension, but closed for modification (aka the O in SOLID). 
I dunno. You can replace the data with: FORMATS = YAML.load_file('config/datetimefield_formats.yml') And then you're not technically modifying code anymore. It's a bit of a grey area.
Huh, I came into this thread expecting a joke gem, and instead found something quite useful. Cool!
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: https://www.reddit.com/r/Serendipity/comments/6kmlzv/11_small_improvements_for_ruby_followup_xpost/
Agreed, actually. Considering adding a way to define custom bullshit string values, but leaving the defaults as generally useful.
I wrote this as a joke gem, actually, and now I find myself considering it as an actual useful thing. Weird.
true
A fair point, and moving the data to a true data format is probably a necessary conclusion to the data oriented approach.
Thanks so much!
congratulations on your gem this is hilarious. 
From what I understand, you're trying to limit the value of a variable between 0 and 10, right? If that's the case you may consider defining a custom getter and setter for the variable and put your limiting logic there.
One solution would be: def happiness=(value) raise ArgumentError.new("Must be 1..10") unless (1..10).cover?(value) @happiness = value end Or actually maybe that's not what you want, when you say `But also Self.happiness = 100 should result in Self.happiness #10`, maybe what you want is: def happiness=(value) @happiness = [value, 10].max end Not sure what you actually want, but whatever semantics you want you can make it so. `attr_accessor :happiness` is just a shortcut for definining basic `def happiness` and `def happiness=` methods. You can define them yourself, however, you want, even the `=` version that will be called when someone does `object.happiness = whatever`. &gt; Self.happines = += 1 (i believe that is what the rspec is doing) I don't know why rspec would be doing that unless you told it to somewhere, but that's another issue. But don't design your API and semantics around something you think rspec is doing but don't understand why and don't want it to; figure out what's going on and get rspec to do what you want instead, if needed. 
That's about 80% of Ruby blog posts anymore
I appreciate the reply. I've tried that, perhaps poorly. I can't really articulate my problem, other than the test code seems to be setting the variable in one place = 100, and in another place incrementing it with += 1 (should that even work in a setter method, using ' += ' ? if @happiness = 8, then calling self.happiness = 1 should set @happiness to 1, but can you call self.happiness = += 1 and expect it to be 9? I feel like my rspec is doing that, but when i try to code similarly it doesn't work. (i'm familiar with the thing += integer shorthand in itself.) 
Hey! thanks a lot. I think the [value, 10].max is close to what I'm looking for. (err, I suppose setting the minimum to 0 would look similar, like [value, 0].min? ) (I"ll google that.) &gt; Self.happines = += 1 (i believe that is what the rspec is doing) &gt; &gt; I don't know why rspec would be doing that unless you told it to somewhere, but that's another issue. But don't design your API and semantics around something you think rspec is doing but don't understand why and don't want it to; figure out what's going on and get rspec to do what you want instead, if needed. Good advice in general, thank you. But I didn't write the rspec, it's supposed to be a test driven challenge. However, my question is SHOULD that method Self.happines = += 1 work like that? I tried experimenting in a repl but am getting meta problems. Thanks again. 
did he really say you don't need to know how it works?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/amaaggregator] [Would you be interested in an AMA here with the lead maintainer of RSpec?](https://np.reddit.com/r/AMAAggregator/comments/6kp5em/would_you_be_interested_in_an_ama_here_with_the/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Pretty interesting. Thanks for sharing.
&gt; I think the [value, 10].max is close to what I'm looking for. (err, I suppose setting the minimum to 0 would look similar, like [value, 0].min? ) (I"ll google that.) If you are using Ruby 2.4 you can use `clamp` to limit the range of a number: my_num.clamp(0, 10) 500.clamp(0, 10) # returns 10 -500.clamp(0, 10) # returns 0 &gt; my question is SHOULD that method Self.happines = += 1 I'm not sure if you are mistyping this or that is what the actual code is but it should be something like `self.happiness += 1` (without the extra `=` and spelling fixed). `+=` is just short hand: a = 1 a += 1 # same as a = a + 1 You shouldn't need to do any special handling for the `+=` operator vs the `=` operator. 
Yes please.
rspec is one of the most critical and valuable software packages in our stack...yes please!
I'd be interested in this.
Yes!!
🙋
Yes.
If you are looking at ruby alternatives crystal should be on the top of your list. 
As a mod and subscriber, I approve of this wholly.
Yes!!! 
I don't know what exactly i'd ask but i'd be interested there are about 30,000 subscribers to r/ruby so i do think it will be of general interest to Marston and if you casually drop that number in the conversation -- well it would be a very handy way to promote his new book ;)
yup i like @jroch solution - whatever you do, whenever you change or set the value of hapiness, you will need to make sure it's within your required range of values and to act accordingly if it isn't. checking the value prior to saving in the def happiness=(value) method is the perfect way of doing this. 
Can't recommend this enough... 
&gt; SHOULD that method Self.happines = += 1 That's not legal ruby, in a couple different ways, so I doubt that's what you copied from an rspec example. This would be, and is perhaps what you meant: some_object.happiness += 1 Which is equivalent to: some_object.happiness = some_object.happiness + 1 That's not a "method", it's a line of ruby code involving the invocation of several different methods. Should it work like... what? I'm not sure what you're asking. Unless I've already answered it. It "should" do exactly whatever it does, since ruby is mature enough not to have bugs in basic syntax. I can't say if there are bugs in your own code, because I don't know what you're own code is supposed to do, only you know that. I'd suggest you spend more time making sure you can understand what every line is doing in terms of syntax, understand how to take apart a line of code in terms of the syntax alone -- sort of like diagramming a sentance in English (which is sort of a formal excersize not about what the sentence actually means yet). What "parts of speech" are each part of the line of ruby. Which in ruby are, with few exceptions, just: 1. variables 2. calling a method on variable 3. variable assignment (which can look confusingly like #2, but is a different thing, this is the main confusing thing) 4. operators (this is a trick, operators are actually just another case of #2, but with special syntax. Pretty much every line of ruby can be broken down into these things (plus a few more maybe), understanding the 'parts of speech' will give you the tool to figure out what any line is doing, rather than just copy pasting things from stack overflow or whatever without really understanding what you're copy pasting. I didn't realize I was doing a homework assignment or exam for you though, oops. 
PSA: if you upgrade to Rails 5 and have a large test suite but are annoyed with needing to change all your controller specs to use the 'params' keyword, try my gem https://github.com/tjgrathwell/rails5-spec-converter
I'll see some of you guys in Elixir in a few years. Look me up. Jose's intuition was right.
Home work assignment? Exam? It's just a practice question. I appreciate the help, but I didn't use your input. I put my answer above in the edit comment hours ago. That range limit looks useful, but I have to figure it out still. Thank you. 
I don't necessarily have any questions to ask as I am new to the Ruby community (literally days), but I am experienced in other languages and a proponent of TDD / automated testing so I'd love to read the insight they would provide. 
I was looking exactly for that the other day. Thanks!
To be harsh: Only if your list runs to unfinished languages with almost no users &amp; no jobs. It's fine if that's true, because it may well be, but that's not going to be most people. Elixir is in a slightly better position, but not by much. Go maybe slightly better again. Alternative languages for web dev where there are users, libraries &amp; actual jobs? Well you know them: Java, PHP, C#, Python to a lesser extent... and of course Javascript. They're the alternatives. That list hasn't changed in ages. They're all worse IMHO, some of them way worse, but they're the alternatives.
If you are looking for a job learn java or C#
Starred just for the development advice alone: "First, decide if this is something you truly want to spend time on. Life is short and getting shorter, and each moment is precious."
would love to. I actually think a series of AMAs from popular gem authors and maintainers is a great idea.
Why would you use python instead of Perl? Or Perl instead of R? Mostly preference, and sometimes availability of a certain library (for ruby, classically Rails). &gt; Why does it exist? https://en.m.wikipedia.org/wiki/Ruby_(programming_language)#History &gt; I was talking with my colleague about the possibility of an object-oriented scripting language. I knew Perl (Perl4, not Perl5), but I didn't like it really, because it had the smell of a toy language (it still has). The object-oriented language seemed very promising. I knew Python then. But I didn't like it, because I didn't think it was a true object-oriented language — OO features appeared to be add-on to the language. As a language maniac and OO fan for 15 years, I really wanted a genuine object-oriented, easy-to-use scripting language. I looked for but couldn't find one. So I decided to make it.
Ruby vs R - I don't see the comparison. Ruby is a general purpose programming language, R is specifically designed for statistical computing. Different tools for different jobs, you won't be building a web-app in R any time soon. Ruby vs Perl - At the time Ruby was being developed, perl wasn't much of a general purpose language, it was mostly a tool for scripting and string processing and had a limited and rather bolted on object model. With modern perl you could make a more direct comparison but the mindshare has largely departed from perl and Ruby borrowed it's best features while adding a much stronger object model. Ruby vs Python - These are pretty much directly comparable languages and it's more a matter of taste than anything. Python still has a bit of a bolted on object model which makes it a little weird to work with for those that prefer the smalltalk style object model of Ruby. Python has a strong following in the data science world due to the quality of supporting libraries: numpy, scipy, pandas, etc. Both rubyists and pythonistas have relatively strong opinions on language design that run into conflict at various points. As one example Ruby strongly favors chaining for functional programming constructs, `map`, `filter`, `reduce`, etc. Python heavily favors list comprehensions to fill the same use case. 
I find the focus on elixir / crystal vs ruby rather strange. All they share are some rather superficial syntax similarities but lack the features of ruby that make it ruby. 
&gt; you won't be building a web-app in R any time soon. For most apps, probably not. But it is used to build apps https://shiny.rstudio.com/ The R of 2017 is Turing complete/general purpose as well. It may not be pleasant sometimes though. 
&gt; The R of 2017 is Turing complete/general purpose as well. It may not be pleasant sometimes though. SQL and CSS are Turing complete as well :) I think Turing completeness is a necessary but not sufficient characteristic to define a general purpose programming language. Certainly you _can_ build a web-app is any language that supports strings and network sockets, but that doesn't make it a great idea. Actually neither of those are really required either, depending on how reductionist the argument gets.
Cool story bro
Most of us started this way... if not with Ruby then another language... Then you get more experience and start writing better code... some of the shortcuts take a while to get... [This book](https://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104/ref=sr_1_18?s=books&amp;ie=UTF8&amp;qid=1499018598&amp;sr=1-18&amp;keywords=ruby) has quite the collection and is pretty much how most of us do it... EDIT : OOPS... wrong book... that is a great one, but I meant [this one](https://www.amazon.com/Ruby-Way-Programming-Addison-Wesley-Professional/dp/0321714636/ref=sr_1_24?s=books&amp;ie=UTF8&amp;qid=1499018598&amp;sr=1-24&amp;keywords=ruby) for your level 
#vs. R I have never used R, but as I understand it it's more about modelling statistics. Most likely it can be used for different things, but so can everything else. So we might as well ask why not use C or Java. #vs. Perl At least to me perl has always been kind a odd language. As I was learning programming all I heard was how weird it was and how it was old and wasn't developed anymore. I've had limited exposure to Perl 6 however and it feels fine, but it's a quirky language and I just don't have the interest currently to dive into it. #vs. Python This I have most experience out of the three comparisons. Python is great since it has good library support. Syntax is also really similar to Ruby, but I think Python is not as expressive as Ruby. To this point I feel part of it from the "Zen of Python" passage: &gt;There should be one-- and preferably only one --obvious way to do it. To me this most of the time means: "you do it in Python way or you don't", which to me just feels restricting. There's just something about Ruby that I love. Somehow the syntax just clicks in my head and I can just write it. For most people Ruby is just Rails, but I personally hate Rails for same reasons why I find Python restrictive. Maybe this just means that I'm a bad programmer.
IGNORE THIS POST, MY UNDERSTANDING WAS BACKWARDS.
You could accomplish the `contains_nil` this way: ``` contains_nil = !!array.compact! ``` I assume you need to compact the array, otherwise you could just check if `array.include?(nil)`. However, I wouldn't advise writing code like this (or your example), as squashing a few lines should not be the goal of refactoring. Code that is more readable is much better than code that is short.
`==` compares values, `equal?` compares identity. So assuming that you meant `equal?` when you said `equals`, it's actually the opposite of what you said.
Also note that `compact!` returns `nil` when the array doesn't contain any `nil`s (generally mutating methods return `nil` when they don't change the array), so if you have an array without `nil`s, `a == a.compact!` will actually be false.
never marry your career (or username) to a single technology, "brandononrails"
I'll keep that in mind when I goto work tomorrow and continue working in Swift.
lol
I think your confusion here is due to the order of operations. This is, in effect, what you're doing with `a == a.compact!`. a = [true, nil] a = a.compact a == a Of course a == a. They're the same thing. `#compact!` changes the original array rather than returning a new one (like `#compact` does). Since this happens _before_ the comparison `==`, you've changed the array then compared it to itself. You can do this with any other method that modifies the object rather than returning a new object with modifications. a = 'a string' a.upcase == a # =&gt; false a.upcase! == a #=&gt; true You can also test it with `#object_id` to see when the call to a method returns a new object vs modifying the existing object. a = [true, nil] as_object_id = a.object_id a.compact.object_id == as_object_id # =&gt; false a.compact!.object_id == as_object_id # =&gt; true
Thanks for that. I'll go ahead and edit this post to mark it wrong!
This answer is the most thorough IMHO. Still, it's a little unclear what's going on under the hood. Here it would appear we modify `a` then ask if `a` is equal to `a`: a.upcase! == a #=&gt; true Here we ask if `a` is equal to `a.upcase!` a == a.upcase! #=&gt; true The first example is not surprising to me. The second example is surprising to me. Now, I know this is apples-to-oranges, but the following example illustrates the sort of behavior I would have expected: a == (a += 1) #=&gt; false (a += 1) == a #=&gt; true This example's behavior is not at all surprising. Breaking this down a little further, we see that we're calling `#==` method on `a`, but we modify `a` when passing our argument to that `#==` method: a.send(:==, a.upcase!) #=&gt; true The `#==` method's implementation takes two values as argument. In my original example, both of these values were `a`. Maybe someone can help me better grasp and explain this: https://ruby-doc.org/core-2.4.0/Comparable.html#method-i-3D-3D Thanks for your explanation, it's correct and on the right track toward clearing up the confusion/surprise. Thanks to all the other commenters as well!
If you print out the VM instructions you can see the `compact!` call happens before the comparison operation. irb(main):002:0&gt; require "pp" =&gt; true irb(main):003:0&gt; pp RubyVM::InstructionSequence.compile('a = [true, nil]; a == a.compact!').to_a ...snip... [:send, :compact!, 0, nil, 0, 0], [:opt_eq, 2], ...snip... With your `+=` examples there is a `[:dup]` operation that creates a copy of `a` then modifies it and changes `a` to point to the new object. You can see this has happened with `#object_id` as mentioned. irb(main):014:0&gt; a = 1; puts a.object_id ; a == (a += 1); puts a.object_id 3 5 =&gt; nil By the time the equality comparison happens, `a` on the right is pointing at a different object than `a` on the left hand side, so it fails the comparison. When you do it the other way around with `+=` on the left side of the comparison, the left hand side is evaluated, `a` is pointing at the duplicate object and then the equality passes because `a` on the right hand side is a reference to the same object by then.
You seem sad :( ... Here's a picture of a cat. Hopefully it'll cheer you up: http://random.cat/i/MSa3D.jpg ^The ^internet ^needs ^more ^cats. ^It's ^never ^enough..
I started with Perl. Then PHP became the norm. I preferred Perl but for websites PHP made more sense. Then I discovered Rails and found something that was fast and powerful. I think it really comes down to personal preference. Use whichever tool works for you. I can get more done in a lot less time with Rails. 
I don't understand how can one hate Rails, it feels great making a web appreciate in RoR compared to ASP.net or Django
Yes, I'd add that although Rails 5.1 now has a webpack/node-based asset manager and api option to help you do React+Rails API, React is being blindly adopted for trivial front-ends where turbolinks (Rails) would be a simpler and better option. 
I agree where Elixir is concerned. It's the polar opposite of Ruby once you get past the superficial syntax similarities. Crystal, however, is almost a carbon copy of Ruby. Just statically typed.
Could you elaborate? Crystal lacks the object model of Ruby, which is in many ways, it's defining characteristic.
Have you tried Sinatra? I wrote RoR for living for a while and it completely killed my interest to Ruby, but then I used Sinatra for my theisis (to display some data and have interactive UI to play with) and it was so freeing Rails expects you to do everything in "the rails way" which just doesn't mesh with the way I work/think. Again maybe I'm just bad and should feel bad, but that's my personal experience EDIT: just to clarify I'm not saying that's RoR is worst, I'm just saying that I do not like it and I rather use Sinatra or even Express.js, but to me Ruby is way more than just enabler for a web framework I prefer it as a scripting language
His loop as-written did not have side effects.
This is cool! Is there an Atom feed?
&gt; Have you tried Sinatra? No I did not, but I see your point. Comparing Rails To Sinatra feels a lot like comparing apples to oranges to me but I agree that Sinatra is probably a lot better for small web apps or just putting something together quickly. I can see myself using it. That said, I'd imagine Rails apps scale a lot better than Sinatra apps. 
 irb(main):002:0&gt; ... ^^ Double-check your regexes kids ;)
Thanks! Sorry, but Getrevue does not offer RSS or Atom feed :/ I'm making reposts to Telegraph, you can read it via channel in Telegram: https://t.me/randomruby
So, Ruby is for creating websites? 
What do you mean? It's object oriented and it has the standard library so you already know the stdlib. 
`a == a.upcase!` is a method call. * First it evaluates `a` because we need a receiver to send the method call to. * Then it evaluates `a.upcase!` because we need the argument to the method call. Notice that this mutates `a`. * Last, it sends the method `==` to `a` with payload `a.upcase!`, and `a` responds accordingly.
[_why's Estate](http://viewsourcecode.org/why/) &gt; Hey, welcome to my collection of why the lucky stiff links. Everything _why has published on the internet should be accessible from here. It works sort of like a museum that sells maps. Many of his abandoned writings are mirrored locally here, and everything else is through external links.
Let's rewrite your examples in a way that makes the evaluation order explicit: a = "hello" # a == a.upcase! lhs = a rhs = a.upcase! lhs == rhs Why does this return true? Because `a`, `lhs` and `rhs` are all references to the same mutable string. After you do `a.upcase!` the value of that string will be `HELLO` and that value will be visible in `lhs` as well. The value "hello" no longer exists anywhere in memory. a = 5 # a == (a += 1) lhs = a rhs = (a += 1) lhs == rhs So why doesn't this behave the same way? That's because `+=` acts differently than mutating methods. `a += 1` makes `a` refer to another value (it re-assigns `a`), this does not affect the value of other variables that previously referred to the same value. We can get the same behaviour with strings if we use `+=` there as well: a = "hello" lhs = a rhs = a += " world" # =&gt; false # lhs is "hello", rhs and a are "hello world" # Now let's use the mutating method &lt;&lt; instead of += a = "hello" lhs = a rhs = a &lt;&lt; " world" lhs == rhs # =&gt; true # lhs, rhs and a are all "hello world"
That makes sense. 
&gt;I'd imagine Rails apps scale a lot better than Sinatra apps. That might be. I have never ran Sinatra in a production environment. Also I no longer work as web dev, so I won't get a chance any time soon. In my opinion RoR is good when working with bigger team and it allows greater flexibility with remote workers since it's so opinionated. 
The article never answers WHY
Ruby is basically Perl 6 - it took all the good parts, left behind bad parts, and it's such a natural migration path nobody looks back. There's maybe a few minor features people would like. R is not really a legit general purpose language Ruby vs Python was a real competition for a while before Ruby won. Mostly thanks to blocks, Rails, non-bolted-on OO, and DSLability. Python is similarly expressive for basic stuff, but it gets left behind real fast when you try to do something more complex.
I tremendously appreciate Mislav's work to preserve [why's Poignant Guide to Ruby](https://github.com/mislav/poignant-guide). I had bookmarked http://mislav.uniqpath.com/poignant-guide/ but now I see that it redirects to http://poignant.guide/ [Code School's Try Ruby course](http://tryruby.org/) is also a great tribute to why's guide. More proof that the Ruby community is so great :)
[removed]
`sed` and `awk` are Turing complete... That's really not much of an argument for a language being "general purpose". Just because you [*can* write arbitrary programs in a language](https://github.com/uuner/sedtris), it doesn't mean you "should" :)
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](http://i.imgur.com/5BU0H6t.jpg)
Funny how all that got over-interpreted and made more complicated then it really is. It is simply about precedence, where method call (object.method_name) has higher priority then any operator method or assignment. Feel free to search about operators precedence in Ruby for yourself.
Although `&amp;.` can be useful at times, I *generally* consider it a code smell - for the same reason that I *generally* consider `Object#try` a code smell. First, note that `&amp;.` is more comparable to `try!` rather than `try` - since it will raise a `NoMethodError`if used on a non-`nil` object that does not respond to the method: [1] pry(main)&gt; 2.try(:bad) =&gt; nil [2] pry(main)&gt; 2.try!(:bad) NoMethodError: undefined method `bad' for 2:Fixnum [3] pry(main)&gt; 2&amp;.bad NoMethodError: undefined method `bad' for 2:Fixnum Sparingly using an occasional `&amp;.` or `try!` as a "quick hack" to make code easier to read is OK in my opinion, but when you start chaining method calls like this: order&amp;.client&amp;.address&amp;.street order.try!(:client).try!(:address).try!(:street) ...You're asking for trouble. Was it the `order`, the `client`, the `address`, or the `street` that was `nil`? Obscuring errors like this can often cause a nightmare for debugging.
&gt; Python is similarly expressive for basic stuff, but it gets left behind real fast when you try to do something more complex. Do you have an example? 
&gt; ...You're asking for trouble. Was it the order, the client, the address, or the street that was nil? Obscuring errors like this can often cause a nightmare for debugging. Exactly. It is hilarious who everyone calls himself a "developer" ;-)
Cool article.. I think I had already learned ruby when I saw the poignant guide, but liked the approach and went thru some of it anyway.. Glad it caught on and taught plenty of people who may not have jumped in otherwise, and that they're carrying on his spirit
I feel quite free. I also feel free to engage other rubyists on reddit to help myself develop a better understanding of my observations. Feel free to condescend further!
&gt; That said, I'd imagine Rails apps scale a lot better than Sinatra apps. Frameworks don't automatically make apps scale. There's not even a general sense of "scale"; it depends heavily on good architecture and proper consideration of lots and lots of use-case specific factors. There's certainly parts of Rails that have helped some applications to scale well and other that have helped other applications to scale poorly. That said, Twitter did famously switch away from Rails for much of its stack (but since it went to another language instead of to Sinatra, that doesn't really say much about how much Sinatra scales). Personally, I don't think there's anything inherent in Sinatra that makes it not scale well. If anything, the lack of a clear guiding architectural principle could make it arguably easier to structure your application more according to your scaling (and other) considerations; though you could also make the argument that you can create an unarchitectured mess out of a sinatra app if you don't know what you're doing. 
Not just data science, really anything scientific has almost no equivalent in Ruby. We have some people working in language technology here and it wouldn't make sense for them to use Ruby for their prototypes. I was looking for a proper natural language tokeniser recently and couldn't find anything that was even half-decent, except maybe bindings to Java-based openNLP but that didn't seem worth the hassle.
&gt; Ruby vs Python was a real competition for a while before Ruby won. Ruby won? By what metric?
it's a primitive form of natural language processing :P
I remember the day he vanished. It was quite the mystery back then, quite fascinating actually. I got a little bit obsessed with finding out who he was and what drove him away.
I have a few thoughts, but I'm on mobile, so please be patient with me. :) First off, I would get in the habit of putting my code on a site like Github or Bitbucket. Pastebin works, sure, but using those sites will also force you to use version control, which is a best practice. Global variables aren't really a thing in Ruby-land in my experience. Obviously, you can use them, I just don't really see them used that often, and I've heard others express the same sentiment. There are databases you can hook a Ruby script up to. You don't need a huge feature-rich database, but using SQLite is probably perfect in this case.
[removed]
[removed]
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](http://i.imgur.com/3Fb3B.jpg)
[removed]
[removed]
[removed]
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](http://l.yimg.com/os/152/2011/10/20/3387261714-1e157c4d23-z_213720.jpg)
[removed]
I would rename `add` and `remove` to specify what exactly is being added and removed. That will be helpful if down the line you decide to store different types of things in the database and the functions differ based on the type. Also, I'd rethink naming the variable 'warning.' The value doesn't represent a warning - it represents the user's response to a question. You don't need to use sleep after printing whether or not the database has been wiped. You can just do the reset immediately. In fact, you may consider switching the order, and doing the reset first, so that you can provide info to the user based on whether the reset was successful.
I'll give Github a look. Regarding Global variables: I ran into an issue exiting my methods when I wasn't using global variables. Example: def add #Defines Database Add Method (Option 1 from main menu) puts "To add words to your database" puts "type one word at a time and press enter to save it" puts "type !exit at any time to return to the main menu." inputVar = '' while inputVar != '!exit' inputVar = gets.chomp if inputVar != '!exit' $database.push $inputVar else mainmenu end end end When I did it this way, after typing !exit it would get stuck at the beginning of the while loop. I am not sure why as it should have been going to mainmenu when it detected the !exit. This was my quick remedy around this. Any suggestions regarding this?
Ok, last two things - you shouldn't have to use '!exit' - 'exit' should be fine. I'd also look into the begin-rescue-retry block pattern. That should help you refactor your code to perform the same tasks without so many while loops and if statements.
I was mostly just using sleep to add some time between command and execution to see what it would look like; experimenting with different functions. I am executing the code in cmd and I was curious if it would look better to have a slight delay or not. Either way it doesn't matter as my end product will be behind the scenes. I'll look to rename my variables and methods. Probably a good habit to pick up now so things do not get confusing with how vague they are. Thanks for the tips.
Does exit kill the program or the method? I was using it as a way to return to the main menu without having to re-execute the program.
I would look up the break and return methods. Those are what's used to get out of a control flow mechanism like a while loop.
Great! Thank you!
In this case, it shouldn't kill either, since it's a string input. But like I said above, the way you exit a function or control flow mechanism is to use `return` or `break`.
I'll look into these as well as the begin-rescue-retry block pattern. I appreciate the input.
Oh, I just remembered the reason why I used !exit instead of exit as the input string to leave the add function, because I didnt want the program to get confused if the user wants to add the word exit to the array.
Oh, gotcha. In that case, why not use a phrase? Like "exit program"
[HELLOYES](http://thomas.fach-pedersen.net/SPOOL/PNG/55%20-%20HELLOYES.PNG)
Rails is for creating websites. Ruby is for creating Rails'.
This is great! It's a nice way to learn and understand how other devs build.
Interesting concept. Anyone with hands-on experience with this type of architecture? Is it as life-fulfilling as it's made out to be? 
&gt; very low write, very high read Sounds like a problem best solved by caching. Your underlying stack should be irrelevant. 
So....Ruby is cool among web developers I see
That's just because somebody used it to make Rails. But you could also use it to create the "Rails" of some other domain. In other words, it's for inventing new ways of doing things.
Re: the database conundrum - you're trying to solve a problem you don't have yet. Use the tools you're comfortable with until they hinder the application (performance, maintainability, etc) then figure out what tool will best solve that problem *when you actually have it*. Otherwise you're worrying about hypotheticals when you could be getting real work done.
Use rails and postgres and cache with redis. Don't pidgin hole yourself with Sinatra. Don't use anything but Postgres. It's rock solid. Redis should solve your read problem better than any other nosql solution. I found nosql to be immature and unreliable. 
Did you follow the video I gave you for installing ruby (well, installs rails, but...)? There are a couple extra libraries that are installed that may be your issue. 
Kinda hard to answer him when no one knows where he is.
I remember him posting a blog post when he found out his sister had a substance abuse problem. He seemed to take it pretty hard.
Just based on preference. I never touched rails but have coded ruby a lot; from cli-tools, deployment system, xml-parsers to small minimal rest-api's using sinatra. All of that could be done equally well in Python without problem but ruby just clicks better with me.
Thanks for the comments they make me realize that I'm Over engineering and over thinking the problem as usual. I've really appreciate your input but I think at the end I'll give a try to Sinatra and couchdb because it will be harder and it will be a nice addition to my CV/portfolio
This.. As mentioned below, redis / read the rails guide on caching
Hello, as an alternative you can browse / read the [all-in-one-page source in markdown](https://github.com/geraldb/talks/blob/master/quik.md) (*¹) - Quick start your ruby gems, your sinatra apps, your jekyll sites 'n' more w/ project templates (from GitHub). What do you use to get (quick) started with new gems, sinatra apps, jekyll themes? Let us know. Cheers. ¹: Did you know? The slide deck gets build from text with markdown formatting with the [slideshow gem](https://github.com/slideshow-s9/slideshow). See the [Slide Show (S9) project](http://slideshow-s9.github.io) for more. 
You code for your first method works for me, even without the `class Foo...` in `bar.rb`. &gt; I thought requiring a file essentially made all the code in that file available in that context It does.
Hm thanks for that. That makes me think it must have to do with how I have my spec written.
I'm curious what libraries you're used to using that aren't available in Ruby. My focus is on web development and I'm primarily using Rails so maybe that side is different. I have noticed that a lot of stuff I come across is from 2012. Seems like we may have peaked then. That said the community is still very large and active. I just set Google to show results from the last year and it's fine.
The one that jumps out at me was a really good Excell spreadsheet parser. Python has a few good ones (I probably used Openpyxl the most), but the one I found for Ruby was really slow and not very feature-rich. Also, I am somewhat interested in Machine Learning, and it seems like all the well-known libraries in that domain are Python-based.
Ruby is great but I can understand how you would have been intimidated by the pick axe book. I think that was probably the worst book you could have started with. That particular book is intended to be a reference. The best beginner book would have to be the object oriented design book by Sandi Metz. She is extremely knowledgeable and capable of breaking down basic object oriented design patterns in such a way that benefits from Ruby's design. A good intermediate book would be the design patterns book. I don't remember the exact title but it breaks down some common idioms in Ruby programming.
https://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330/ref=sr_1_1?ie=UTF8&amp;qid=1499172143&amp;sr=8-1&amp;keywords=Object+Oriented+Design+In+Ruby https://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452/ref=sr_1_1?ie=UTF8&amp;qid=1499172191&amp;sr=8-1&amp;keywords=Design+Patterns+in+Ruby 
[removed]
Welcome, err, back!
Python does have better math and machine learning libs. 
I have been considering this, too. I have been going around and around with languages for the past few months. I tried Smalltalk, then Scheme, then Smalltalk again, then Rust. And maybe a couple of others. Clearly, I most want to become proficient in Smalltalk, but something is frustrating the hell out of me with it (a few things, actually). Coincidentally, my original Smalltalk guru back in the early 90's was also a musician. I remember having a pretty easy time with Ruby, so maybe I should refocus on it.
Haha, that's funny. I believe Alan Kay is a musician himself, so it must be a sign :) I played around with Scheme and Smalltalk as well, especially Scheme since I was interested in an audio programming language called Impromptu. That got me to fall down the SICP rabbit hole, but since my math is not nearly as good as it needed to be, I put that book down rather fast.
Heh. The reason I dove into Scheme to start with was because of an Alan Kay comment I read about how impressed he was with the elegance of LISP.
it's been fairly well debated in this subreddit. it has lots of fans such as me, though there are die-hard Rails adherents who don't see the need, and then folks who agree with it but disagree with the nomenclature of these functional objects. you might have more specific questions?
Hi! I would suggest the podcast series "My Ruby Story" There are full of inspiring stories like the one you are about to make. 
Hey, if it works, it works. However, I don't think the way you have out this together really supports long term maintainability. What I mean is... if a test were to fail, which part of the test failed? You have one method that is responsible for several actions. If these actions were broken up and tested individually, this would help you in the long run. While it may not be necessary for this particular project, exercising this idea may help you in future, and possibly more complex, projects.
Does it matter, really?
Crystal fundamentally doesn't support much of Ruby's metaprogramming system, such as `send`, `eval`, loading code at runtime, defining classes and methods at runtime, etc etc etc And these aren't edge cases - this language functionality is needed to run almost any non-trivial part of the Ruby ecosystem. Crystal isn't just statically typed, it's much more static overall.
If you want a bit of adventure, I would suggest using [RJB](https://github.com/arton/rjb) to use [POI](http://poi.apache.org/spreadsheet/index.html) or some other java-based lib for excel. You might be able to pull the same trick to get at python libs by way of jython, but that's like a double adventure.
Millions of reads per day is little load at all. That's &lt;100 queries/sec. Four years ago my ecommerce employer ran a mysql database in production that did about 8,000 queries/sec and I'm sure others here can show even higher loads. postgresql can handle that without any problems as long as you index and tune properly.
if you try rails then you'll be on track ;)
https://imgur.com/a/8NOAs Pretty much what I thought
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/E4tlE74.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[state_of_imgur](https://np.reddit.com/r/u_imguralbumbot/comments/6i1huv/imgur_has_gone_to_shit) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20djseeih) 
Yeah, sorry bot. The app that I'm now forced to use is pretty shit. 
+1 on _POODR_ by Sandi Metz. Easily the most accessible explanations of important CS principles I've found yet. Check out [this talk](https://www.youtube.com/watch?v=8bZh5LMaSmE) for a taste of the way she breaks things down.
&gt;Crystal fundamentally doesn't support much of Ruby's metaprogramming system, such as send, eval, loading code at runtime, defining classes and methods at runtime, etc etc etc Of course not. It's a compiled language and purposefully avoids those to become order of magnitude faster and smaller. It does have macros though and you can get a lot of meta programming with them.
which app?
That error seems like firing from windows, not ruby. Just search for" too many open files windows". There might be a setting for that. 
I think you can try some simple game programming to understand OOP. I didn't understand a bit, after 2-3 months of Unity development made it otherwise. It is a core part of the answer of 'why ruby?' question :)
It seems that [nobody really knows what the cause is](https://stackoverflow.com/questions/41496441/errnoemfile-too-many-open-files-rb-sysopen-when-opening-first-file). I can't work it out, but it appears to be a problem with Windows. Since it only affects a such a small number of users, your best bet is probably to update/reinstall Windows.
&gt; Of course not So if you know all that, why did you ask what they meant by 'lacks the object model of Ruby'? That's the part of the Ruby object model it lacks - the meta-object protocol part. I'm answering the question you asked and you're telling me you the answer was already obvious?
We switched from webkit-cabybara as we had some odd issues going on with ajax related tests. It's much easier for new devs to install and anecdotally tests seem to run faster.
I'll definitely compare performance on some suites - thanks for the feedback! One thing to keep in mind is that downloads are not yet possible with Chrome headless (see [full discussion](https://news.ycombinator.com/item?id=14700824)), if that's important!
Not an issue for us, but thanks for the heads up on that.
&gt; Since it's only a problem with the dishwasher, and only affects a small number of people, your best bet is to demolish your home and rebuild it.
It's actually the exact opposite. The dishwasher won't run. It runs in everyones house except yours. We've traced the fault back to some very strange wiring in your house. Time to call the electrician.
Looks like I happened to read this subreddit at the right time. Send me a PM and I can help you out. /r/PokemonRMXP is also a good resource.
Good point. You are right, of course. For now the test is a simple example. More tests needed and a better way to make it easier to add more. One future way might be to follow the [/feeds](https://github.com/feedparser/feeds) tests (for the feedparser). 
Poltergeist had a network_traffic mode which we found quite useful. (Seeing if requests were made etc) Does Chrome headless have an equivalent? It's the only thing preventing us from moving across. And if not where should I raise it?
I gave a talk called [Fast Metaprogramming with Truffle](https://youtu.be/lRMWwjqbXUo) a couple years back at RubyKaigi that gives a deeper dive into how TruffleRuby achieves high performance in the face of metaprogramming, if you're looking for more info behind the linked numbers.
The fun part about programming is answering these questions through experimentation. I recommend writing up your second example there and running it in a terminal you don't care about. Don't wait for it to finish, because you've coded an infinite loop there :) Your while loop will continue as long as `input` isn't "bye", but `input` only gets assigned to once, and that's outside of the loop. So the loop never ends, because `input` never changes. You can fix that thusly: input = gets.chomp while input != 'bye' puts input input = gets.chomp end puts 'Come again soon!' And that absolutely will do what you're wanting: It'll print out the word the user first input without outputting a blank for the first line. The only reason you wouldn't want to do that is because you're basically repeating the `input = gets.chomp` line and, if your input functionality is more involved than that, you don't want to be copy-pasting it everywhere. But that's easily solved by a function, or something like: done = false while !done do input = gets.chomp if input == 'bye' then done = true else puts input end end (though that has its own problems, namely you now have to *remember* to turn `done` to true at some point, or else you're back in infinite-loop-land)
That makes sense! Thank you so much!
Have you tried saving to a different path and still get the error? Because it doesn't look like an issue with the path; note what the error states - "Too many open files". This implies the game is attempting to open the save file, but is denied by the OS due to limits on the number of open files. No idea how to change that setting on windows, or even if it's different on different versions. Although, you can test this by ensuring that any apps/services running in the background that may have files open have been stopped. Alternately, google around for how to raise the limit. The '.' is likely a red herring, as IIRC it refers to the current directory; in this case it's identical to the path 'c:\Users\Gabe\AppData\Roaming\Oneshot\save.dat'. Although, I'm noticing now that it's '...Oneshot/save.dat' and that forward slash '/' may be causing an issue. Ask the dev about that. 
Imgur app, I no longer see an option to upload on the mobile Web page
&gt; blocks, Rails, non-bolted-on OO, and DSLability 
It looks very good. Hopefully it is not too little too late.
Sold
Using ERB at the end is a bit overkill. There is an option to use the ARG directive in your Dockerfile: https://docs.docker.com/engine/reference/builder/#arg
Oh he's ready to do it, he just wanted me to make sure it'd be welcomed since we don't usually do AMAs :)
I'm sure this isn't exactly what you are asking, but no, because PING is actually a specific ICMP request. You can't PING on any protocol, you can only PING on ICMP, and I'm fairly certain the ports are fixed for ICMP, but I could be wrong. However, odds are you are using ping colloquially, and you don't mean PING, you mean make a simple request to any protocol, url, and port. Sure, you can do that, but you are really going to want to restrict your requirement on protocol. There are a lot of [protocols](https://en.wikipedia.org/wiki/Lists_of_network_protocols) out there, and you will need a specific library that implements that protocol in a lot of cases. Again, maybe you actually means HTTP or HTTPS, not literally any protocol, in which case, use [Net::HTTP](https://ruby-doc.org/stdlib-2.4.1/libdoc/net/http/rdoc/Net/HTTP.html).
Great reply. The only thing I'd add is that... while !done do ... Is usually written... until done do ...
You could [include namespaces](https://ruby-doc.org/core-2.4.0/Module.html#method-i-append_features) and wrap params to next line: require 'grpc' RSpec.describe MyObject do it 'should do something' do include OrganizationService::V1 service = OrganzationCreate::Stub \ '10.100.120.100:5050', :this_channel_is_unsecure request = OrganizationRequest \ option_a: 'hi', option_b: 'bye', option_c: 'foo' response = service.create_organization request end end 
Correct me if I'm wrong, but `include` is much more of an easy access to everything under that module, it actually mixes in EVERYTHING in that module (sub-class, methods, class variables etc). It might work here, because - well- it's just an RSPEC example, but on other places, that's probably not recommended? I'm using `\` for mostly when I need long strings. But I can see how this can be useful in other places, thanks!
Just change your whitespacing slightly, and it's well within the 80 char limit (and still perfectly readable IMO): RSpec.describe MyObject do org_service = OrganizationService::V1 it 'should do something' do server_ip = '10.100.120.100:5050' org_stub = org_service::OrganzationCreate::Stub( server_ip, :this_channel_is_unsecure ) request = org_service::OrganizationRequest( option_a: 'hi', option_b: 'bye', option_c: 'foo' ) response = organization_service_stub. create_organization(request_object) end end
Carrierwave? Paperclip?
I'm getting kind of worried about Paperclip - there have been 2 commits this year, which were just logo and copyright updates. I'm using the github repo in my gemfile because there's a fingerprint update task that I need, but it hasn't been released. It's not like they have a 100% stable product now and can just sit back. 153 open issues and 48 open pull requests say otherwise, but it looks like thoughtbot no longer has anyone working on it.
I've found this to be the case with a lot of gems. Thankfully there's alternatives if you aren't already tied to one thing. I had used Paperclip in the past but my latest project is using Carrierwave and I'm liking it thus far. 
I recently moved a project over to Shrine, and its very nice
Refile is the latest take on file upload. https://github.com/refile/refile
Is this one of those comments where somebody points out that something already exists so anything new that has the same goal and outcome has to justify its existence?
Nice. I'm actually really exited about it. Although I'm not seeing any processing associated with uploads. How do I resize uploaded images here?
I can see how that's implied, since i didn't really say anything in my comment. I'm just wondering why something like this is going to be part of Rails proper after all these years. I feel it's kind of like MS bundling IE with the OS. Sure you don't have to use it, but once it's part of the framework, it becomes the standard and alternatives tend to become sidelined. Take ActiveRecord for instance. Sure you don't have to use it, but how many rails projects use alternatives vs what's built in? I'm on the fence about it though, because, file uploads are pretty core to the web, so it makes sense to have it as part of a web framework, but maybe it should just be something like ActiveJob where it's just an abstraction layer over your file upload gem of choice. I don't have a horse in this race, so I don't really care one way or the other to be honest.
Ermm, I wonder if it's possible to sit `vim` to work like that. Or else everytime I will be `=` the whole file, it will return to the further indentation. 
It's definitely possible, since I wrote that file with `vim` ;) I have quite a custom setup though, with lots of plugins and tweaks to my `vimrc` - so I'm not sure exactly which config option(s) replicates my whitespace setup.
This is pretty common for Ruby code (and I think it's what Rubocop also suggests nowadays): require 'grpc' RSpec.describe MyObject do it 'should do something' do organization_service_stub = OrganizationService::V1::OrganzationCreate .Stub('10.100.120.100:5050', :this_channel_is_unsecure) request_object = OrganizationService::V1 .OrganizationRequest(option_a: 'hi', option_b: 'bye', option_c: 'foo') response = organization_service_stub.create_organization(request_object) end end
In the end, this will be like activejob: define a core high level api, build adapters for the existing tools, tight-integrate activerecord. Once it's stable, bump with every rails version. Nobody likes to reinvent the wheel. Now if you want to get people excited, let's talk about active-ORM :)
Awesome and pretty clever work! Having invested a considerable amount of time in Elixir, I am so happy to see work that in this direction - pipelining.
It's designed to be standalone, not like ActiveJob.
I can understand people being excited about this, but I can't help but wonder why spend time building a new competitor to Paperclip (incumbent) and Shrine (probably highest quality, and definitely newest) in the file upload category. There are so many other things that would be more beneficial to Rails (mostly things aimed at competitiveness with Elixir and the JS world), and this seems to be a marginal benefit at best, especially when Shrine and Paperclip integrate so easily with ActiveRecord.
Uploads are core to the web, but there are great solutions already in use, and they integrate very well with Rails. I think the reason for questioning is because that effort could probably be better spent elsewhere.
I just finished reading the source code. One part that I found brilliant is the `MirrorService`; I think it's an amazingly simple way to have a secondary backup storage, and it can make it dead easy and really safe to migrate to another storage. Another thing that's great is the built-in support for deleting in background, CarrierWave and Paperclip don't have that. I also like the built in support for multiple file uploads, which CarrierWave and Refile have, but Shrine doesn't. However, other than that, I didn't see some notable advantages over other file upload libraries. This is the comparison emphasized in the README: &gt; A key difference to how Active Storage works compared to other attachment solutions in Rails is through the use of built-in Blob and Attachment models (backed by Active Record). *This means existing application models do not need to be modified with additional columns to associate with files.* Active Storage uses GlobalID to provide polymorphic associations via the join model of Attachment, which then connects to the actual Blob. I don't think this is different than other gems, you can always create a separate table that will only hold the attached file data and link it with `has_one`/`has_many`. What I like about other file upload libraries is that you have a choice whether you want save attached file data in a new column on the main table (which is simpler) or in a separate table. I'm aware that this is an initial release, so that's why many features are still missing. But it will take a *lot* of work to add all those features (trust me), and I don't see how they would be different/better than in other gems. Some of the important features: * retaining uploaded file in case of validation errors (requires temporary storage) * generating custom locations for files (currently it's flat, everything is stored in same directory) * way to determine real MIME type (`Content-Type` header can be whatever the attacker wants) * way to extract and save custom metadata (e.g. image dimensions, PDF pages, video duration) * file validation (filesize, MIME type, extension) * uploading from remote URL or data URI * file processing * uploading in background (without possibility of race conditions during longer uploads) * direct uploads (to the app and to S3/GCS) * support for other ORMs or web frameworks? I went through all of that with Shrine (and much more, hello resumable uploads), and it was very challenging to make all features work nicely with each other, and make the design work both for 1MB and 1GB files. Some of the design decisions are definitely not ideal (like always), and there are features still missing, but after 2 years I feel like Shrine is still going in the right direction. I was really hoping that, instead of creating more file upload libraries, we can focus around an existing solution which is already extremely versatile. I'm always open to new and fresh solutions, but when there aren't significant advantages I think it's not good because it increases fragmentation and causes a lot of reinventing.
&gt; mostly things aimed at competitiveness with Elixir and the JS world Have any ideas? Where Elixir and node shine seems to me to have little to do with the framework, and a lot to do with the runtime, which isn't really something within Rails control. 
You need to figure out the # of requests to the backend as # of requests to the CDN doesn't really matter, those requests are going to the CDN regardless of the backend stack. Generally CMS apps have highly cacheable content absolving the backend of much of the load. In general, JS is a faster language than Ruby when it comes to CPU bound execution. Node also has an advantage when it comes to high connection count handling (e.g. websockets). However, which will be faster for your particular workload, depends entirely on the workload. Finally, you have to consider total cost. You could, for example, need more hardware resources for Ruby but have fewer developers and faster development velocity. All these things have costs. The opposite could also be true. Too many variables to give a definitive answer. 
Never even heard of Shrine (looks great though). I think it's about offering working features that 99% of apps need out of the box. Every time Rails gets a version bump all dependencies immediately blow up. So having first-party gems like that could be a good thing. Hopefully.
p.s. you can follow the topic on Hacker News here https://news.ycombinator.com/item?id=14714944
I generally use [Python's guidelines](https://www.python.org/dev/peps/pep-0008/#indentation) on indentation, since I think they're readable and ruby doesn't have similar things. There are examples in there of different ways to handle breaking up long lines.
Note that the code here is this: require 'benchmark/ips' class Thing def method_missing(name, *args) end def normal_method end define_method(:speak) {} end t = Thing.new Benchmark.ips do |x| x.report("normal method") { t.normal_method } x.report("missing method") { t.abc } x.report("defined method") { t.speak } x.compare! end Truffle likely just optimized away all the code, it's just not even executing it as it found it to be pointless. This is why you see 200M i/s. This is more of a test of the time resolution of whatever benchmark-ips uses for timing than of method calling.
cool stuff! as a heads up, you can have typhoeus gunzip the response for you, which is likely to be more efficient :) https://github.com/typhoeus/typhoeus/blob/master/README.md#compression
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [typhoeus/typhoeus/.../**README.md#compression** (master → ba78cf1)](https://github.com/typhoeus/typhoeus/blob/ba78cf1bcf2b817a7df90c77a27b5810ff93292d/README.md#compression) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djvquby.)^.
Did you just link us to a subscription only article???
And even then it's more hype than results. Node's IO model has serious drawbacks (cooperative multitasking has always been a tough tradeoff). Elixir has gotten a lot of hype, and certainly appears to be a fine programming language, but it doesn't offer improvements that matter to most ruby shops.
Thanks for the comment. Bundle install was successful. I tried running the command you suggested after bundle install and here is the output. https://paste.ubuntu.com/25036134/
Thank you for the follow up. Yes I ran your commands and in the video (which was awesome btw) and here is the output after doing bundle install and then running bundle exec rails server. Note: the only issue I ran into was trying to install the newest version of nodejs. For some reason I was only able to install the legacy version. https://paste.ubuntu.com/25036134/ 
- Where is the bottleneck? - If you feel the bottleneck is Ruby, why is Node an answer as opposed to Go/Elixir/et al?
No no! Sorry, it was an error. Now, it's fine. Thanks for your comment!
`Accept-Encoding` is used when you want to reduce bandwidth by compress the content transferred transparently. Setting `Accept-Encoding` won't decompress an HTTP response where `Content-Type` is gzip data. When used on already-compressed data you will see a small increase in transfer size.
You might look into [Imageflow](https://www.imageflow.io/) as an alternative to preprocessing
Huh? Passing the `accept_encoding: "gzip"` option to Typhoeus will instruct libcurl to deflate the response given that the response's Content-Encoding is gzip.
Gotta hope they get their funding goal and license it as MIT/Apache2
Yeah I don't think they actually mean ping (and ICMP does not use ports like TCP/UDP). I think Net::HTTP would work just fine.
Ok. yes, by ping I meant sending a packet, not necessarily a PING packet. literally, any protocol. 
They basically ripped off Paperclip.
Thanks for the resource -- I love the simplicity of Middleman (to me Middleman:Sinatra :: Jekyl:Rails) and wish I could have found more basic articles like this when I first started out.
tl;dr: The diagram at the top shows that the data is already compressed on the server (likely `Content-Type: application/gzip`), so `Content-Encoding` should not be set (provided the server is properly configured) even when `Accept-Encoding: gzip` is sent in the request. `Accept-Encoding`/`Content-Encoding` are a layer of HTTP/1.1 that are independent of the `Content-Type` and must not have an effect on the data that is given to the client. Here's the definition for Content-Encoding (RFC 2616): &gt; 14.11 Content-Encoding &gt; &gt; The Content-Encoding entity-header field is used as a modifier to the &gt; media-type. When present, its value indicates what additional content &gt; codings have been applied to the entity-body, and thus what decoding &gt; mechanisms must be applied in order to obtain the media-type &gt; referenced by the Content-Type header field. Content-Encoding is &gt; primarily used to allow a document to be compressed without losing &gt; the identity of its underlying media type. `Content-Encoding` is set if: * Your request indicated you can accept a `Content-Encoding` (via an `Accept-Encoding` request header) * The server supports the `Content-Encoding` you requested * The server believes applying the `Content-Encoding` to the entity-body is in its best interest For a `Content-Type: application/gzip` entity-body applying a `Content-Encoding` other than `identity` will compress the the already-compressed data again. This is likely to use CPU to make the file bigger, not smaller, so a server (usually) won't do this because it costs them time and bandwidth they could use for other requests. You can configure a server to serve pre-gzipped files with the `Content-Type` of the compressed file with `Content-Encoding: gzip` when `Accept-Encoding: gzip` is in the request, but that's outside of the scope of the linked post. If the file was uncompressed on the server (`Content-Type: text/xml`) then they shouldn't need to decompress it because the HTTP library should handle it for them like you said. (For primitive libraries this may not be the case, but libcurl is anything but primitive.) But since they post shows them decompressing it manually before starting XML parsing this must not be the case.
Contrary to the article, I think two things need to happen: 1. A good implementation of concurrency in Ruby 3 2. Increased popularity of Ruby apps/software that don't use Rails I'm not trying to say that Rails is bad, it's just that doing the same stuff we've been doing for the last 10 years isn't going to lead to a renaissance. It would require a variety of fresh software and ideas.
Maybe I should read the example a bit better next time 😑 Looking at the xml example, it's easy to assume that the Content-Encoding is gzip, the tar.gz file makes sense for being Content-Type application/gzip
Some of the big changes that Phoenix has recently undergone have been towards improving the long term maintainability of apps. Elixir has generally been viewed as more manageable, partially because of FP, and the gap has widened with changes to Phoenix. I agree that the hype is overboard for both JS and Elixir/Phoenix, but the door is open because of Rails' shortcomings. One interesting thing is that whenever a Rails codebase gets out of hand, companies frequently decide to rewrite it in a completely new stack, often times one they aren't familiar with. Many of these problems are inherent to the design, with an emphasis on rapid development. But it doesn't mean it can't be improved.
I use ruby because i don't hate myself at the end of the day lol In all seriousness, I like to work in ruby because I find the syntax to be clear and concise. As a platform for frameworks and projects I find those features make it easier to write better applications. I don't think its the best language for everything, every language has its strengths. Definitely wouldn't recommend it for machine learning. I tend to use ruby as a hub to connect various services in any given ecosystem I'm working on. I write a lot of APIs with it. I won't bother critiquing the language, it has its quirks when you dig beneath the surface (referencing variables has always been a sticking point for me), but as something to work with every day I love it.
[@dhh's latest tweet](http://i.imgur.com/os1OrpA.jpg) [@dhh on Twitter](https://twitter.com/dhh) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
Less a Renaissance, more a Reformation. There's a bunch of Martin Luthers posting Theses trying to oppose the religion of Rails with various levels of success.
&gt;So if you know all that, why did you ask what they meant by 'lacks the object model of Ruby'? Because metaprogramming has nothing to do with object models.
True, that's much better when server sends a proper Content-Encoding header. We noticed that some HTTP servers don't send the header and we also handle data from (S)FTP where there aren't any headers to tell when the content should be decompressed. The Ruby decompression only kicks in when Typhoeus/libcurl doesn't decompress. 
&gt; Because metaprogramming has nothing to do with object models. I disagree. One of the key historical texts on metaprogramming is called 'The Art of the Metaobject Protocol' which talks about metaprogramming as an aspect of the object model. I wrote my PhD and several papers on metaprogramming and metaobject protocols in Ruby.
So was ActiveJob, before it was ActiveJob. Rails 3.0 was supposed to ship with a background job framework, it was at some point in trunk, and it was dropped before the official release. It was a sane decision, as both delayed job and resque were already quite mature and commanded enough adoption, and sidekiq still didn't exist. If you analyze the complexity of all the possible use cases and peculiarities that Shrine, Refile, Carrierwave, etc..., are addressing, I don't think that "rewriting in rails" would be that beneficial. But that's my 2 cents, if it goes in the direction you described, I for sure won't contribute to "yet another upload processing" solution. 
&gt; sudo apt-get install ruby-dev I've done that, and new errors resulted. https://pastebin.com/3DB9k9a2
Thanks again to everybody for the inputs. FYI and maybe a little OT I've a friend that is interested in becoming a dev and I've decided to build this project with him and if someone is interested I'm thinking to stream our session on Twitch (https://twitch.tv/jabawack81) we should start tomorrow around 17.30 GMT or 12.30 EDT 
Writing a piece of code in Ruby seems much more semantic to me, when compared to other high level languages. And of course, there's RoR. It's just a choice of convenience. :-)
&gt; It seems like many people who tried different technologies, with the promise of being more productive, what people? what technologies? any links? otherwise it's really only a feeling, which I don't share. 
It's r/ruby and we'd love your point to be true, but hey give me the facts. Any arguments to prove the point? Show some numbers, analyze them, etc.
Ruby, more than any other language I've used, seems to most closely match my mental model. That leads to the lowest impedance between thinking about a solution and creating a solution. 
&gt; /var/lib/gems/2.3.0/extensions/x86-linux/2.3.0/ffi-1.9.18/mkmf.log I was just doing that as you replied! So it says it's not finding a 'package configuration.' https://pastebin.com/xLM2YwKQ
Because I like slow, memory-intensive code? (because the cost of rewriting it in something better and retraining the staff outweighs the cost of the extra servers to handle its bloat)
Any change you have a `dotfiles` git repo with your `vimrc` configuration? :)
Ermm, I didn't see this syntax before. Interesting. Wasn't aware Rubocop gives feedback about line limit, will try to run it, see what it suggests, thanks!
Cool, will check it out :)
Something like this, you mean? ;) https://github.com/tom-lord/dotfiles A few of my personal favourites: [1](https://github.com/tom-lord/dotfiles/blob/c9b7a0f9c2dd0a0d922158315a71b4866d5be902/.bash_aliases#L84) [2](https://github.com/tom-lord/dotfiles/blob/c9b7a0f9c2dd0a0d922158315a71b4866d5be902/.bash_aliases#L144-L149) [3](https://github.com/tom-lord/dotfiles/blob/c9b7a0f9c2dd0a0d922158315a71b4866d5be902/.bash_aliases#L89) [4](https://github.com/tom-lord/dotfiles/blob/c9b7a0f9c2dd0a0d922158315a71b4866d5be902/.vimrc#L170) [5](https://github.com/tom-lord/dotfiles/blob/c9b7a0f9c2dd0a0d922158315a71b4866d5be902/.vimrc#L174-L175) ... There are quite a few cool things in there (half stolen, half created by me). Feel free to steal anything you like haha!
Voilà! Thanks mate, I will be figuring out where the indentation settings are :P
Because it's fun to write and I can achieve thing it a way I like.
It's the syntax, really. The fact that it's permissive and easy to write DSLs, and there's not mandatory typechecking and semicolons when you just want to bust something out. 
Ruby is not the fastest language, but it's "fast enough" ([in the words of DHH](https://twitter.com/dhh/status/732253887936270337?lang=en)). There are many languages that are faster than Ruby. Javascript is pretty clearly one of those at this point. But you have to balance this with the team's experience with Node (development speed) as well. 
I hope it can! I do not think something like Opal can make it as people are (imho) tired of transpilers. What would help is making Ruby more attractive (as in making it faster, easier to deploy and maintain). Maybe a closer cooperation with Crystal ? 
Syntax, paradigms etc. I wish Ruby was faster ( i do not need the metaprogramming as much these days and I would sacrifice it for performance). I hope Crystal takes off
I'll end up needing a file framework for direct uploads to S3 in the next few days. So many options now!
If you do not have experience with scaling up what makes you think you will able to do it in node.js. Just the raw performance of V8 is not going to save you from the problems you will eventually face.
Because Python makes me ache for those good DSL's and a sensible object system. The only downside to Ruby is that there isn't a Sage or SciPy for it.
if they do not want loops/iterations then it means they want recursive version of algorithm you can look up recursive luhn examples I will not write more here as you should be able to do it alone for dev application so you understand how you got to that solution
I didn't know any better - i just chose something and ran with that for better or worse. 
Node will be faster and use less memory. There is no getting around that. Then again if those are important write your API in Crystal or Go.
When is truffle going to be ready for general purpose use?
80 chars is a stupid limit these days. That comes from the age of teletype FFS. 132 character terminals were made in 1980 so there is no longer any need to stick to 80 characters.
I use ruby because I love ruby ecosystem, e.g. gems, rvm, bundler...
I could go into a long list of details, but the primary reason is the fact that a level of freedom is given to the developer, with each possible solution having its own nuances, which makes writing in Ruby very enjoyable (in my opinion).
[Unlimited power.](https://media.giphy.com/media/xUA7ba9aksCuKR9dgA/giphy.gif)
I wonder if that is so, why is the Ruby community (which considered to be pretty flex-able if you compare them to languages like Java) still hold it as a style-guild recommendation? 
Infrastructure as Code. Performance is not a concern (within reason that Ruby can easily meet); Ruby's flexibility and readability pay off huge.
It has a great syntax to code in, many libraries for all kinds of work, gets faster with every release and is fast enough for most problems. And don't forget the great community!
Which "style-guild recommendation"? There is the [Ruby style guide](https://github.com/bbatsov/ruby-style-guide) which recommends some practices but it is just *one* recommendation. And you don't need to follow that. Personally, I work with 120 character lines. Otherwise I probably would go crazy and the code would be harder to read.
I know it better than other languages so it's faster to get things done. My shop uses Python though so I'm trying to convert myself. The ruby syntax seems more readable though. 
The same as what most others have already said. I closely compared Python and Ruby about a decade ago. Python made me think, "Yuck", while Ruby made me think, "That's really nice". 
&gt; sudo apt-get install build-essential libz-dev libffi-dev THAT did it. Jekyll installs, but green_shoes does not. Oh well. I should have searched harder. Thank you very much for helping me.
I'm not sure why "don't use iteration" is a bonus requirement... That's certainly how I'd solve it! E.g. use `string.reverse_each.with_index { ... }` and apply different logic whether the index is even or odd. Apparently they'd rather have you come up with a recursive solution, using `my_string[X]` to access each character - which is an unusual approach in ruby. Perhaps they're asking for this approach as a purely academic exercise, to take your out of your comfort zone... Or maybe because they've already given you [a link with an iterative solution in ruby](https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers#Ruby)! But if it were me taking this test, I'd probably provide an "iteration solution" (`.each`-sort of solution) too. Here is a vague sketch of the recursive function you could write: def calculate_checksum(string, index, sum=0) if index &lt; 0 return sum elsif index.even? partial_sum = # Do something... else partial_sum = # Do something else... end calculate_checksum(string[0..index-1], index, sum+partial_sum) end calculate_checksum(string, string.length - 1) # Now what?... There's definitely some room for improvement there (for example, can you think of a better idea than checking `even?` each time?), and some gaps in the solution. But I'll leave you to figure that out.
Also, note the bonus hint: &gt; Test-Driven Development This means writing your tests **first**. *Before* you've written a single line of actual code, write the tests. The tests should *fail* at first, and then only pass when the solution *works*. If you're writing a solution with source control (e.g. in `git`), then you'll get big bonus points if they can *see* that the tests were written before the code.
Also, note that the only difference in the ["extensions"](https://gist.github.com/elle/b9739bc21eb348916a60622f3fb6e2e4#extensions-1) is that the number has **15** digits, not 16. If you design the algorithm correctly, to loop through the number *in reverse*, then this should be no problem at all... So include this in your tests!
I am using Ruby because I'm paid extra for using it. Sometimes I think I've sold it too cheap though. Only side projects in so-much-better-designed languages (Erlang, Elixir, Haskell, Rust, a bit of F#) help me not hating myself at the end of the day.
It's easy. It's nice. The gems are good. The people are nice. 
Same feelings different language choices
Because as a scripting language it's the most concise an expressive. You can do very powerful things with very little code, so it's very flexible. Being so flexible it's also it's drawback, since sometimes on big projects things get really messy. However I'll say that I also prefer strongly typed languages for something big as it's easier to maintain in the long term. 
I use Ruby because nine times out of ten it's the quickest way to an idea from scratch. The language is powerful, elegant and satisfying to write.
/r/ruby is no place for prequel memes apparently
`Content-Encoding` is super confusing, especially when you're dealing with an entity-body that is also compressed 😞
I like the semantics and syntax. It's powerful and flexible without being overly verbose. It's also fast enough. I'm getting an average response time on https://www.codetriage.com of around 100ms. The ecosystem is also very good. Lots of libraries that have fairly good APIs and reasonable performance. 
Performance is always nice. That said, MRI is reasonably fast these days (I believe it's consistently faster than Python now). It'll never be as fast as Crystal or Go but much of the slowness in apps comes from massive layers of gems and frameworks and unoptimized app code.
Rule number 1 of ~~ruby development~~ any "technical" computer jobs: Get good at reading and interpreting error messages; then (if necessary) googling and interpreting the results. You will need to do this all the time when working in software, so it's a **very** valuable skill.
&gt; Elixir has generally been viewed as more manageable, partially because of FP I don't see why this is the case. Has anyone done any analysis of this? I realize this is a tautology, but the only way to create more manageable software is to have an awareness when a change about to made would result in less "manageability." Any programmer who understands that will apply that knowledge to any programming language, and no programming language will help any programmer who doesn't. This seems to happen every few years -- devs grow tired of their big monolithic projects and start fresh in a new programming language and feel like their projects are way more maintainable now.
Yeah I guess. When I come back from doing programming in other languages, like C#, Rust or Haskell and do some programming in Ruby I just get absolutely giddy with power. Defining classes, hooking stuff together, it's all just effortless. People complain about the reduced community activity, but it doesn't matter because all the gems you need already exist. Nothing gets me from 0 to a hundred like Ruby.
I use it because I like it, I'm familiar with it (and the ecosystem), and it's just me coding stuff...so that's okay.
That's the one, sorry, typo. guide, not guild :) 
I'm new to Ruby and loving it. I'm not knowledgable enough to get what you mean by the issue with referencing variables. Can you explain?
humans have been writing in columns of about 60-90 cpl for centuries and then programmers come along and write in 132 'because they can'. 
With regards to Paperclip, to be quite frank, I would not worry about it. Sometimes software is just "done". As in - there's nothing else to add. Paperclip's been around for yeaaaars and years and there's only so many features you can add onto it without rewriting the entire thing. As for the open issues and PR's - like I said, it's got a long long history and it's natural to accrue that kind of attention. The original paperclip maintainer is still at thoughtbot and keeps an eye on it ... just not on top of it like he used to be. I realize I sound kind of dismissive and defensive, that's not my intent - just know that paperclip is still in good hands and is certainly not abandoned.
I will do my best, I really recommend you pick up a copy of "The Well-Grounded Rubyist" by David A. Black. He does a great job of describing this and many of the other quirks of ruby in a very understandable way, much better than I can anyways. The short version is that every variable is a reference to an object not the object itself. This makes it possible for two variables to actually share the same object. Although other languages have similar features, due to how variables are created and assigned by the ruby compiler, this can produce results you don't expect. [This article](https://launchschool.com/blog/references-and-mutability-in-ruby) does a pretty good job of describing what I'm on about. Feel free to DM me if you have any other questions too. 
heeeeey /u/3k2i1 I might have something juuuust for you :D https://shubox.io
That's why I'm only kind of worried, not full blown "I need to find another file attachment gem pronto" worried. I'm keeping my eyes open for what I may eventually switch to if the need arises, but it's working just file for me right now.
Organizational velocity and I still think Rails is a great back-end framework.
A mature ecosystem is a luxury to be sure, but a welcome one.
I was going to assume that you were talking about pass by value vs. pass by reference but I wanted to ask in case there was something else you were mentioning that I didn't know. Nice to know I had an idea about it after all... Sidenote- I'm currently a student at Launch School and I drilled on that topic specifically. 
Ruby wasn't my first language, but so far is my last. Coming from a C/C++, Perl, and PHP background, Ruby was a breath of fresh air - so much can be accomplished with so little code. Tried learning Python but didn't take. Java is a goddamn enterprise trainwreck. Thinking of checking out Go. But still using Ruby regularly.
As most people here say - ruby just looks clean. It isn't burdened with excessive boilerplate syntax. Duck Typing makes for cleaner code - it just does what I expect. It seems like it follows OOP much better, as everything is an object even the number 42. The smalltalk roots really show through in that, though I find the smalltalk syntax to be not as clean as ruby. It's expressive, and makes me happy. :)
To me, this is one of the best features of object oriented programming, because in my mind I'm not picturing the variable, I'm picturing the object, like a lego piece, that it references. That object is a specific bundling of data, along with actions (methods) that it can do. Variable names are not the containers, the object is the container. The variable name is just a label or bumper sticker on the object.
Last time I tried it, it seems to work fine for projects that aren't rails. That's enough to get me excited!
LEGENDS! thank you both for the pointers. Its really great when people take time to help someone like me out! I literally know no one else that can code so is great to be able to reach out. I hadnt thought of recursion, and also putting on git with tests first is bang on. cheers! I'll put up link to the repo when its almost there... 
It would mean branching out from web dev to something else. 
I agree it has it benefits but Ruby does it in some strange places and ways. Check out the article I linked to for a better description of what I'm on about. They do a really great example using strings where two separately defined variables end up referencing the same string in a way that wouldn't be obvious to someone who doesn't understand the underlying mechanics of the language.
This is something I would welcome with open arms. I wish there was a way to write desktop/mobile apps in Ruby. I tried it recently with MRI, and the experience is truly awful. The only other options are: - Cobbling something together with JRuby and Swing - Using RubyMotion, which is a proprietary language that looks like Ruby, but behaves like Objective-C.
The people. I love the community, and haven't found another programming community that is as helpful and welcoming as Ruby. MINASWAN.
Are not allowed to many progress at all? I have a wide screen monitor and laptop why should I limit myself to 80 characters?
Thanks for posting the links. Shall check them out. As far as potential apps she could build next, i guess it depends on her - and her goals. Personally she should just work on apps which she gets a lot of fun out of. Ideally unique, and potentially useful - but her motivation is the key for completion.
Restricting the line length when writing text in a non-programming language like English is very useful because, for example, it makes it easier to find the next line (you still peripherally see the beginning of the current line). However, this is not the case for programming languages because text in one of those always has a very ragged appearance and the next line can easily be inferred by its content. In the old days with nondescrit variable and functions names it was easy to adhere to the 80 column line length. When programming in Ruby with expressive variable and function names, not so much. I don't see a downside to an appropriately large line length, e.g. about 120 columns. If a line fits into the editor without horizontal scrolling, why not use the real estate?
I agre but I hope ruby can get back on the hype train so it is not only few things it is used for.
Amen. Java dev by day, I've spent some good time with Haskell...good languages in their own right, but frankly I feel [unburdened](https://media.giphy.com/media/3o6wrFGJnucPdeeEfK/giphy.gif) when I do Ruby. There's nothing better when I just wanna git 'r done 
I managed to get it going in Javascript, has been an intense week of learning ruby so was good to work with another language... Any ideas why I cant just wrap the final return up in parentheses and a modulo expression and get a boolean result? Check out my jsFiddle to see how it works.... https://jsfiddle.net/matthew9429/8w8ewq2j/3/ 
 checkSum = (arr, i = 0, sum = 0) =&gt; { if (i &gt;= arr.length) { return 0 } if (i % 2 == 0) { sum = arr[i] } else { if (arr[i] * 2 &gt; 9) { sum = ((arr[i] * 2) - 9) } else { sum = arr[i] * 2 } } // currently returns the correct sum return sum + checkSum(arr, i + 1, sum) // I want function to return true / false if final sum == ( % 10 == 0 ) // why wont this work?: // return (sum + checkSum( arr, i + 1, sum )) % 10 == 0 }
&gt; I'm not sure why "don't use iteration" is a bonus requirement This is fairly common on any form of test. What they are saying is, they want to see that you can work with recursive algorithms.
have it running with ruby now, complete with some simple tests. Any feedback on my code would be great! https://github.com/mrslwiseman/credit_check
[@dhh's latest tweet](http://i.imgur.com/1adahEL.jpg) [@dhh on Twitter](https://twitter.com/dhh) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
Next to Clojure Ruby is my favourite language and that's even after undergoing a Functional Transformation :). I generally dislike OOP but Matz somehow managed to elegantly blend it with Lisp and Perl producing a magical synthesis that Scala has failed to match. I was lucky to start my programming journey in 2001 with Perl without being exposed to the prevailing Java OOP madness so Ruby was an easy transition. Ruby and Clojure are unique in the coherence and consistency of their design which I find lacking in Python. They embody beautiful design where Python, contrary to its reputation, is just butt-ugly with its def(self, ) , \_\_dunder\_\_.(), crippled lambdas, decorators, virtualenv, import re, if \_\_file\_\_ = 'main', obligatory return, lack of :symbols, lack of ?: ternary, string dict keys, lack of switch case and Perlish %w() shortcuts. I think Rails was only possible in Ruby as its beauty and coherence reflect feautres which are only available in Ruby. Despite my preference for functional programming in general I find Elixir disappointing compared with Ruby despite the superficial syntax similarities. I can't quite put my finger on it but each time I come back to Elixir it fails to match the elegance of Ruby. Although it has superior metaprogramming and concurrency, overall it doesn't have Ruby's magic. I'm sure that if Ruby 3x3 or Truffle/Graal succeed in speeding-up Ruby without gem incompatibilities there will be a Ruby Renaissance. 
Totally. Other than it's dumbed-down "easy to read" appeal to beginners, I can't fathom how Python grew to command 2 &amp; 1/2 times the adoption of Ruby by current metrics.
Your main `check_sum.rb` looks pretty good. There are some minor improvements possible, but nothing massive. The biggest "issue" I'd point out is: Why is the `check_sum` method public? This is an internal implementation detail of the class; you never need to call `CreditCheck.new.check_sum`... Your tests, however, have some issues: * There are 3 failing tests. These are beyond the scope of the original question, so you *could* remove them... Or, implement the correct behaviour in the `CheckSum` class! * The indentation and line length is messy... Could do with a quick cleanup. * The overall format of the tests is not great, for several reasons. Foe example, here's one of the simple tests you wrote: def test_is_valid assert_equal( @valid_expected, @valid_result, "Function should return true (valid)." ) end And here's how I'd write it: def test_valid_card input = "5541808923795240" assert( CreditCheck.new(input).valid?, "expected #{input} to be valid credit card number" ) end (You could even abstract that into a helper method, for each test...) Why is this a lot better? 1. Better method name (not a big deal though...) 2. **Only running against ONE CARD NUMBER PER TEST!!!** Currently, you are calling `CreditCard.new(...).valid?` 8 times *every* test, because you have stuck everything in the `setup`. 3. It's easier to use `assert` and `refute` instead of `assert_equal(..., true/false)`. 4. Better message on failure. * Some of the test failure messages are particularly inaccurate/misleading - e.g. `"Function should throw error if input empty"`. Returning `false` is not the same thing as `raise`-ing an error. Make sure your tests actually do line up with the expected behaviour, whatever that is.
- no bottlenecks yet, we're just exploring the valid options - some team members believes that Ruby costs a lot more that node and node is faster 
problems like what? 
&gt; This is also what you get if you implement Refile or Shrine. It adds a Rack endpoint to your Rails application that will fetch the image binary, perform the transformation according to the parameters received in the URI, and cache the transformation before sending the binary. This is something Shrine does? Out of the box? Can anyone point me to docs?
what is to be explain? based on the numbers, roda is faster than express. 
is there a way to figure out the real # of requests made to the backend? the number I provided was from CloudFlare for the current old website we need to revamp
I found strange that on ruby is slow on js, as I remember json is more c than ruby and oj is quite fast
any benchmarks? i mean will ruby cost double the resources or more than node? 
as i know node considered to be faster than Ruby? how's a node framework is slower than a ruby one? 
Does the current backend have any logging/metric infrastructure? If it logs all requests you can just parse the logs and count. Incidentally if it does log all requests there is a good chance it's request rate is low, logging every request is rather expensive at scale. Not to be too blunt about it, but if ya'll don't even know what requests hit the backend and which are served from a CDN cache you're in no place to be even discussing what the new tech stack should be. Do the research on the existing solution and really understand what it does and how it works before having a debate about architecture / tech stack. Frankly this should have been done prior to agreeing on the development contract, it sounds like you have no idea what you're in for here.
It has, sort of ... Devops with chef and other tools; security with metasploit and other tools. "A good implementation of concurrency in Ruby 3" -- i'm not sure but i think they're working on it
Optimized for developer happiness. Enough said.
Techempower benchmarks are maintained by volunteers. Most of the numbers on there really shouldn't be trusted. As an example, the Rails benchmarks for round 14 are ~5-10x slower than they should be due to misconfiguration. [The Rails benchmarks were running 8 processes on an 80-hyperthread machine.](https://github.com/TechEmpower/FrameworkBenchmarks/pull/2850/files)
&gt; is it really bad In a small, self-contained bit of code, probably not. In a big project, or a library that will be used by other projects, yes. For precisely the reason you've just described. This is why gems should put all their methods within classes/modules (typically "namespaced" by the name of the gem). As a random example, if you look at [`Pundit`](https://github.com/elabs/pundit/blob/master/lib/pundit.rb), you'll notice all the methods are within `module Pundit`.
Pretty simple: because Node is not necessarily faster than Ruby.
That auto tune code should be a part of puma and unicorn.
Precisely the reason I've described ... being, if gems define the same method on the root namespace? In which case those gems shouldn't be used, right? It's kind of a catch 22. But I guess it's something that nobody should do, and that's the point. 
I would say, 99% of the time, you're going to not want to monkey patch Object since you're then, in turn, monkey patching everything in your program. The only exception to this rule being if you're writing a framework. Rails can get away with monkey patching Object because it can safely assume that it's going to be the only framework used, and frameworks are the only ones that should be monkey patching object. So it's only competing with itself for method names. I hope that makes sense. In general, it's a good idea to namespace methods so that you don't run into this problem.
This is the wrong question. Ask this: "is my justification for putting a method on Object defensible?"
What you're saying is there are no bottlenecks, but some members of the team have made the decision that Node will address those bottlenecks. Sounds like this is not a technical decision.
Depends on what your application is doing, really..
Thanks mate. This is great constructive feedback, I'll get stuck into it. This is literally the first time I've ever made my own test cases before, jumped straight in. Have a ruby course which has private methods coming up so will keep doing course and implement these changes! Cheers 
Not really. Tuning Puma is complicated. [That's why I gave a 40 minute long talk on it.](https://www.youtube.com/watch?v=itbExaPqNAE)
Video linked by /u/nateberkopec: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [RailsConf 2017: Your App Server Config is Wrong by Nate Berkopec](https://youtube.com/watch?v=itbExaPqNAE)|Confreaks|2017-05-26|0:38:25|17+ (100%)|973 &gt; RailsConf 2017: Your App Server Config is Wrong by Nate... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/nateberkopec ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=djz18vn\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Depends on the purpose of the applications. What is happening to the data that is being thrown around
You can write a slow framework in a fast language
I just ask "Is this something 'things' do?"
Sorry but this isn't really a question. You only just opened a debate about moving a Ruby application to Node over "performance" issues, you got a series of advice and now you are here to continue pushing the Node angle. Look, if you want to write JavaScript, don't go looking for an argument, just go and write some JavaScript already. 
"Hmm this sounds like a Nate kind of comment." *Glances at username* Yep :)
Will the foo method be equally valid for all derived classes? If there's even one derived object which foo does not properly apply to then i suppose it violates the liskov-substitution principle (which states that child object should be perfectly substitutable for a parent object). in other words, if you ask for a Nissan 2000 model, but you get a descendant - a Nissan 2015 model, then it should still work as expected, because at the end of the day, the 2015 model is still a Nissan. warning, i could have it wrong coz i'm still learning ruby so take it with a grain of salt.
Hello, I’ve updated the JSON readers gem called jasony. The next next generation JSON parser / reader included is SON.parse for the Simple Object Notation (SON) format by Aleksander Gurin et al. Using SON you can use Ruby (Shell)-like #-comments, optional commas, and more. Example: { # Personal information "name": "Alexander Grothendieck" "fields": "mathematics" "main_topics": [ "Etale cohomology" "Motives" "Topos theory" "Schemes" ] "numbers": [1 2 3 4] "mixed": [1.1 -2 true false null] } Use `SON.convert` to convert SON text to ye old' JSON text: { "name": "Alexander Grothendieck", "fields": "mathematics", "main_topics": [ "Etale cohomology", "Motives", "Topos theory", "Schemes" ], "numbers": [1, 2, 3, 4], "mixed": [1.1, -2, true, false, null] } Use `SON.parse` instead of `JSON.parse` to parse text to ruby hash / array / etc.: { "name" =&gt; "Alexander Grothendieck", "fields" =&gt; "mathematics", "main_topics" =&gt; ["Etale cohomology", "Motives", "Topos theory", "Schemes"], "numbers" =&gt; [1, 2, 3, 4], "mixed" =&gt; [1.1, -2, true, false, nil] } Note: `SON.parse` is the same as `JSON.parse( SON.convert(text))`, that is, SON works like a "pre-processor" for JSON. Cheers.
Well, played around with. Apparently Rubocop only warns about it, even with `-a` it won't try to re-organization the code. But I'm using what you suggested anyhow and it looks decent :)
In a very simple program, it's fine. As your program gets more complex, yes, it gets confusing and there is risk of causing unintended consequences -- mainly through bugs, code you write (or code someone else writes) _thinks_ it's calling a method defined somewhere _other_ than globally, but that method it thought it was calling wasn't defined, and it ends up calling your global method instead. But also as to your point "won't the only issue be if a gem defines a method in the global namespace as well" -- so it works fine as long as only _you_ do this and nobody else does? :) But I think what you've correctly hit upon is it' even _worse_ for a gem to define a global method than for your own non-gem app to. I think it's pretty much unforgivable for a gem to do this (with maybe very few exceptions, nothing's universal), but you're right not quite as bad if you do it intentionally in a direct app. Still not a great idea. But for a very simple program, you can get away with it with likely no consequences, sure. 
There is no content in this article. Even opinion needs some evidence or argument to back it up, or what's the point of sharing it?
I tend to agree with you, but it's a religious argument. 
That should work fine. I think you are not getting the file you expect when you do `require_relative 'bar'`. If there was _no_ file at the relative path "bar.rb", you'd get an exception. If you don't get an exception, you're loading _something_ -- but maybe not the thing you think. Is there a file in the same directory as the file that contains the `require_relative` called "bar.rb"? Is it the file you expected to be requiring?
I was mostly just wondering how religious people solve some of the issues above :-) I fixed some of the basic Ruby indentation on my `vim`. Let's see if that's works better.
The day that your app is huge and the method breaks, or needs to be changed, someone is gonna do a global search on the project for `def foo` and won't find it. And that, to me, makes it a bad enough idea. It's just this convention that when I'll look at your object I'll know everything it does, which isn't the case if you start adding methods to the object outside of the class itself.
Great work! Looks good
It Depends. 
I think you are absolutely right
If you just want to send a message to a network port and see what happens, the protocol doesn't matter, I think? But without knowing the protocol, what do you send? I guess it doesn't matter? So I guess you can just use net/http and send something that looks like a GET request for '/', and see what happens. Not sure if that will work, give it a try. If you actually wanted something that would send a legal protocol-specific first request for _any_ protocol.... of course that's not really possible, since "any" protocol is just about an infinite set. Your "any protocol" part is a bit inconsistent with your specification "whether it be 200 or 500" -- those are HTTP result codes, other protocols can't generally "send a 200 or 500", those only mean something to HTTP. So in any case, the trick is interpreting what you get back for 'any protocol'. But I guess just getting back anything that's at least 1 byte would meet your specifications? Some protocols may close the connection without sending any bytes for an illegal message though. A protocol can do anything. Maybe what you want is using TCP::Socket, and if it succesfully opens a socket without raising an exception, you consider that "good". It's not exactly responding with something, but it's succesfully opening a connection. See http://www.blackbytes.info/2015/04/ruby-network-programming/ Sorry, I was thinking through this as I wrote, I think that's the closest to what you are kind of asking for. 
Refile and Dragonfly have on-demand processing, where processing definition is contained in the URL, but Shrine doesn't have that. I decided that it's not necessary to add it to Shrine because it's super easy add Dragonfly/Refile to the mix, and they both already solve that problem really nicely. Let's take Dragonfly for example; once you've configured the Dragonfly storage with the same parameters as your Shrine storage, and added `use Dragonfly::Middleware`, you can generate a Dragonfly URL to a file uploaded with Shrine like this: photo = Photo.create(image: file) photo.image #=&gt; #&lt;Shrine::UploadedFile&gt; uid = [*photo.image.storage.prefix, photo.image.id].join("/") Dragonfly.app.fetch(uid).thumb("500x400").url #=&gt; "/attachments/W1siZnUiLCJodHRwOi8vd3d3LnB1YmxpY2RvbWFpbn..." Shrine does have a `download_endpoint` plugin which allows you to stream uploaded files through your app. This is useful if you want to authenticate downloads or if you're using a storage which doesn't expose files via a URL (e.g. SQL or Mongo). But that endpoint doesn't do any processing, it just returns the requested uploaded file as is.
Oh great, a 30 years war is what every open source project needs.
My guess is better scientific and machine learning libraries 
Thanks! Guess it was an error in the review. FYI I went looking for docs on this to see if it was true... and hadn't even successfully found any docs or mention of the (non-transforming) download_endpoint you mention here. Not sure if my googling was just bad. Can you point me to docs for this, if any? &gt; It's super easy add Dragonfly/Refile to the mix, and they both already solve that problem really nicely. You're suggesting it might make sense to use shrine _and_ dragonfly or refile simultaneously? Huh, I hadn't considered that. I was going to ask for an example of how, but I guess your code example above is that? Would it make sense to do something similar with refile? This would maybe be a good thing to mention and provide an example for in shrine docs. 
foo = gets the gets method will take the user's input and store it in foo. Then you apply your logic to foo. Pretty straightforward answer to google, you should do that as often as possible. 
And if I remember correctly, gets_chomp deletes the new line
Close, it's gets.chomp
Check out the tty series for text based menus and such: https://piotrmurach.github.io/tty/
* ask the question * get the repsonse (See the other answers on this point) * then act on the response: if answer == 'out' else end
you've asked similar questions on /r/node and they too have pointed out that node only really excels at non-blocking io, which is very much available on Ruby. second, many Ruby libraries are implemented in c, so they are performant already. put those together and the results shouldn't be a huge surprise. 
**Here's a sneak peek of /r/node using the [top posts](https://np.reddit.com/r/node/top/?sort=top&amp;t=year) of the year!** \#1: [Programmers are confessing their coding sins to protest a broken job interview process](https://theoutline.com/post/1166/programmers-are-confessing-their-coding-sins-to-protest-a-broken-job-interview-process) | [77 comments](https://np.reddit.com/r/node/comments/5wqgw9/programmers_are_confessing_their_coding_sins_to/) \#2: [I Peeked Into My Node_Modules Directory And You Won’t Believe What Happened Next — friendship .js](https://medium.com/friendship-dot-js/i-peeked-into-my-node-modules-directory-and-you-wont-believe-what-happened-next-b89f63d21558#.ap3ne6eux) | [18 comments](https://np.reddit.com/r/node/comments/4wjdyc/i_peeked_into_my_node_modules_directory_and_you/) \#3: [Node v7.6.0 released (with async/await)](https://nodejs.org/en/blog/release/v7.6.0/) | [79 comments](https://np.reddit.com/r/node/comments/5vgdsy/node_v760_released_with_asyncawait/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Mmmm. That's the right energy right there ya'll.
In a way though, wouldn't this same argument show that most "hot methods" would now be optimizing for free? Like, the most executed code will knock down it's worst case? If the optimization doesn't help with variability of parameters... then I would see your argument as far more damning. But I don't really know how it handles that. Too lazy to do a good job on this one.
Thank you. Sorry for the basic question but took me awhile to find exactly what I was looking for. 
Thank you this is what I was looking for. Sorry for the noob question. 
unsubscribe
About 5 years ago I was developing PHP and knew shit about good development. I would also look longingly and lovingly at Ruby wishing I too can be like the cool kids. My problem was not only it wasn't clicking with me, I couldn't find help from people around me cause it wasn't popular in my country. I'd try and be frustrated over and over. Things like setup would take me days of frustrations and I'd give up. I kept going back though. Really happy that I did. I'm a much better developer overall. The community is generally better, the resources are endless and the emphasis on good clean code is really high. I'm not hating on other communities but with Ruby it was obvious from day 1. I'm glad you're coming back. Feel free to shoot me a PM if you should ever need to. Most of all, good luck and don't give up. 
Thanks! I felt a lot of discouragement with regard to the smallness of the community--it seems a lot of the Ruby thought leaders jumped ship for other technologies, and clearly Python is surging in popularity while Ruby seems to be just hanging on in TIOBE. But in the end I just decided I was going to do what made me happy. If I ever get a dev job requiring me to work with Python, I'm totally ok with that (I actually do like Python a lot). One can't make a living knowing only a single language anyway. But as you noted, the Ruby community seems warmer somehow. And Ruby isn't going anywhere. In fact, one thing I've only recently discovered--Ruby's built-in Regex pattern matching--means that there are a lot of amazing applications for this language which haven't even been realized yet. The way it's implemented as part of the language has given me all sorts of ideas for non-webdev projects (like all the report processing stuff I used to do in Python).
Yeah, I've heard all about POODR. I'm actually waiting for the second edition to come out before I buy it (it's supposed to be out soon).
You should go through a CodeAcademy type tutorial. It will cover this sort of thing. 
I just watched the beginning, so my input might be a bit incomplete, but: 1. You might consider using an EQ on the sound. The high end (higher frequencies) are too high, which causes a "grating" effect on the ears. A lowpass filter around 50Hz, a wide bump around the 400 Hz and a high shelf around 2KHz with ~-4db should probably solve the issue... but I didn't check the audio with a spectrometer, so I'm not too sure. 2. I felt that the subject presentation and pace could have been better organized. I think that if you presented each subject separately, stating the objectives ahead of the content, it would have helped me focus. For example, I would recommend starting the Gem choice subject with something like: "at first I will introduce the workspace and how to organize the gemfile and the gems we use. I'll briefly explain what gems are and which ones provide a good starting point for a Rails 5.1 project"... 3. Consider adding titles to your videos (maybe something from iMovie). **As a side note**: I notice there are a lot of Rails tutorials out there. Rails 5.1 is newer, but soon enough everything will get updated. I would consider the idea that maybe you would get more views if you published video tutorials about tearing Rails apart for parts. There's a common issue less addressed that pops up when a POC Rails application needs to scale into production and performance is sub-par\*. Many startups and tech companies more to node.js to improve performance, even through Ruby can be as fast (and even faster). A tutorial about separating the application code from the framework and dividing the monolith into manageable modules () i.e.: a tutorial on using ActiveRecord without the Rails framework, perhaps using ActiveRecord with Rack, would probably be of more interest to many intermediate level Ruby developers. Notice that on [the Framework Benchmarks by TechEmpower](https://www.techempower.com/benchmarks/): * Rails ("puma-mri-rails") got a sore of 1.1% (out of 100%) while Ruby's Roda (roda-sequel-postgres) got a score of 31.4% (out of 100%). * ... at the same time, the notorious express (express-mongodb) got a score of 2.4% and the full ORM version of Mitol (nodejs-mitol) got 19.5%. Ruby is often easier to code than Javascript, but someone shows people how to move from the development stage (where ease of development is key) to the production stage (where performance is key), Ruby might fade away from the web application arena. Just my 2¢. 
have a look at rack and cuba
Are there no progress reports? 
For another approach that works in Rails 5 too and I think is more flexible and powerful, see my experimental but solid https://github.com/jrochkind/json_attribute
Great documentation on the gem! Love it!
This is perfect, thank you! I agree with you that there's a gap that talks about separating out parts of your Rails application into a more maintainable scheme. For example, breaking up things into service objects, interactors, repositories, etc. Regardless, thank you for the well thought out feedback. I really appreciate it.
&gt; FYI I went looking for docs on this to see if it was true... and hadn't even successfully found any docs or mention of the (non-transforming) download_endpoint you mention here. Not sure if my googling was just bad. Can you point me to docs for this, if any? On the http://shrinerb.com website you have all Shrine plugins listed, and then you can click on the [`download_endpoint`](http://shrinerb.com/rdoc/classes/Shrine/Plugins/DownloadEndpoint.html) plugin to read its documentation. I haven't listed all features in the Shrine README because there are so many, I hoped that people would just look at the list of plugins on the website and search for the one that sounds like what they want. &gt; You're suggesting it might make sense to use shrine and dragonfly or refile simultaneously? Huh, I hadn't considered that. I was going to ask for an example of how, but I guess your code example above is that? Would it make sense to do something similar with refile? The code snippet above was extracted from [my blog post](https://twin.github.io/better-file-uploads-with-shrine-processing/), but I guess a full example application which shows the Dragonfly/Refile integration would be more helpful. It's just hard to create an example of every possible thing that someone might want to do :P, but this is important and I added it to my TODO list. On-the-fly processing is a completely separate responsibility to uploading/attaching, so it makes sense to use a separate gem for doing that task. Even though Dragonfly/Refile are full-blown file upload libraries, you can use just their on-the-fly processing endpoint.
if you want to learn the basics of routing, the first style you showed, then go with sinatra or roda. it will teach you more about lower level http basics. the method definition style you are alluding to is typically part of stronger or more opinionated mvc frameworks like rails, which shields you from many details. 
Thanks for the pointers! Yeah, I think when creating a library/framework built of lots of pieces you need to assemble yourself, the documentation burden is a lot greater. You've got to pay for that good elegant architecture making a lot of flexibility possible somehow. :) Not super thrilled about the roda dependency for download_endpoint, but even just having the download_endpoint code as an example is super useful, whether or not I end up using it. 
Thanks! I haven't succeeded in getting as much attention for json_attribute as I expected it's functionality would attract. If you wanted to take it for an alpha spin and let me know how you find it, would be super helpful! And I'm a huge believer in good docs and do my best, so glad to see you found them such! 
&gt; Yeah, I think when creating a library/framework built of lots of pieces you need to assemble yourself, the documentation burden is a lot greater. You've got to pay for that good elegant architecture making a lot of flexibility possible somehow. :) Yeah, it's also that file uploads can integrate with a lot of external gems/services, so it's nice to have an example on how to integrate a gem/service. I thought a wiki might be a good place for that, I already created a "[Backgrounding libraries](https://github.com/janko-m/shrine/wiki/Backgrounding-libraries)" page. &gt; Not super thrilled about the roda dependency for download_endpoint, but even just having the download_endpoint code as an example is super useful, whether or not I end up using it. I've received this complaint already, and I would love to know what would in your opinion be a good alternative. I thought about pure Rack at the beginning, but I just feel that it can be error-prone, especially the routing. And I like that the `streaming` Roda plugin has better EventMachine support. Rails is obviously out of question because with Rails you cannot create endpoints. My friend asked why not Sinatra, but Roda is *much* more lightweight than Sinatra, so I felt that Roda was the best choice here. I actually plan to add a `Shrine::UploadedFile#to_rack_response` method will return a Rack response, and then you can use it in Rails controllers or anywhere. Then I plan to make Roda optional, because you wouldn't have to use the Rack endpoint anymore. But then you need to generate your own URLs, and do your own file finding.
It can sometimes be confusing about which method of an ancestor gets called in a given situation – it helps to understand the [ancestor tree](https://blog.jcoglan.com/2013/05/08/how-ruby-method-dispatch-works/) to see how method lookup works in Ruby.
It's important to google the right phrase, you don't want to have to ask on reddit every time you run into a hurdle. Try google queries like ruby If statements ruby Get user input ruby text processing ruby case statement It's annoying because until you get some experience under your belt, the exact phrase to google is an unknown.
In example A, the entire HTTP method is defined in one place. In example B, every route is in one place. That's pretty much the end of it. The advantage of (A) is not having to jump into the router every time you want to look up or change something, at the cost of some abstraction. The advantage of (B) is that you can easily create and change complex routes and have a more abstracted way to call methods, at the cost of an extra layer of indirection.
This is a fluff piece.
You may be right about Roda being an appropriate choice here! Not sure what you mean by "Rails is obviously out of question because with Rails you cannot create endpoints" -- you _can_. But I'm definitely not going to make an argument that that would be an appropriate dependency when used in a non-Rails app, it would not be! It may be just right what you've done. I think people are just unfamiliar with roda, a sinatra dependency people are used to for things like this (even if they aren't thrilled about it), a roda dependency may be the natural improvement. &gt; I actually plan to add a Shrine::UploadedFile#to_rack_response method will return a Rack response, and then you can use it in Rails controllers or anywhere. Then I plan to make Roda optional, because you wouldn't have to use the Rack endpoint anymore. But then you need to generate your own URLs, and do your own file finding. That does sound like a _great_ approach to me, agreed. I endorse this as your best approach here, if it's feasible. :) Provide both ways, just as easy as now with the roda dependency, or put it together yourself using `Shrine::UploadedFile#to_rack_response` however you like. Can you make proper streaming work in that design? If so, that sounds perfect. 
Avoid? It's OOP. It's a huge part of what makes Ruby great. Seems like you'd like the functional paradigm. Check out Elixir.
This is true, it can be confusing. Thanks for the link. That's partially why I like to keep things simple ;)
You're right, OOP is one of the things that make Ruby great. However OOP is not only about inheritance and I think that avoiding this one particular feature makes things simpler in a long run while still maintaining the Ruby greatness ;)
strange, Uptime &amp; Availability Tests didn't complain
Maintainer of the `influxdb` Rubygem here. AMA :-)
Another decent primer on composition in ruby: https://medium.com/aviabird/ruby-composition-over-inheritance-3ff786ad9e5d
What you are looking at is how routing is implemented. The pros and cons of each approach aren't visible just by looking at this piece of it. You have to see how it plays into the entire framework. My advice is that you read up on [Rack](http://rack.github.io/). This is the underlying webserver interface that most if not all Ruby web frameworks are built on top of. Start with the interface here, then move into routing and see how your implementation of routing affects how your underlying code looks and behaves.
Comparison of third-party library with language features... I believe, pandas written for Ruby will shine either.
&gt; Not sure what you mean by "Rails is obviously out of question because with Rails you cannot create endpoints" -- you can. But I'm definitely not going to make an argument that that would be an appropriate dependency when used in a non-Rails app, it would not be! I meant here "Rack apps", not endpoints. But you're right, every Rails application *is* a Rack app, I had forgotten that. It's just that I've never seen a Rails app being used as a Rack app that you mount in the router, but it's definitely possible. &gt; That does sound like a great approach to me, agreed. I endorse this as your best approach here, if it's feasible. :) Provide both ways, just as easy as now with the roda dependency, or put it together yourself using `Shrine::UploadedFile#to_rack_response` however you like. Can you make proper streaming work in that design? If so, that sounds perfect. Yes, the Rack response would return an `Enumerator` that yields chunks (essentially what the `download_endpoint` does now), and then you can assign that `Enumerator` as the response body, which would achieve streaming.
"To favor composition over inheritance is a design principle that gives the design higher flexibility." --https://en.wikipedia.org/wiki/Composition_over_inheritance#Benefits
By your example, it looks like you're pursuing something that might be better designed in terms of configuration. Watch Sandi Metz's "All the Little Things" to see what I'm talking about.
`influxdb.write_point(, {` Either this is a typo or I just learned some "interesting" new Ruby syntax
How is your day going?
Not very productive, just busy work. Hopefully, I get something done tomorrow :-)
This is the closest thing I have found in Ruby, but I too use Python for data manipulation: https://github.com/SciRuby/daru
Having dealt with a fair share of serialised columns in GitLab I would advise anyone to approach serialised columns with extreme care. More often than not you can achieve what you're trying to achieve by either using separate columns or tables, at a fraction of the storage space typically occupied by serialised data. Migrating serialised data can also be a complete nightmare. There are _some_ cases where serialised data makes sense (e.g. when storing API responses that can be in arbitrary formats), but it's way too easy to get yourself in a tough spot that is hard to migrate away from.
OOP has very little to do with inheritance, or classes for that matter.
Agreed. It definitely is a tool in your tool bag and should be used appropriately. I’ve had several cases where it has been useful where the apps functionality has similarities in a model, but STI/additional tables would have been even more complicated. The example in this episode definitely wouldn’t have been my ideal situation for serialized attributes since it’s structure was simple. However, it was simply a proof of concept. I’ve used it in situations where a user is able to generate their own policies from a bank of many types. Each type has a small variance in their configuration where 80% of the content was the same. Using serialized attributes for these abnormal form fields made the database and schema readable while being able to keep the functionality needed for the various types. I then create generators for these repeatable types to template them with relevant documentation to keep consistency.
Could've been my Internet lol, but I was just making a joke in general.. in other words, NO ALTERNATIVES &gt;:l
This isn't going to help your current issue, but whenever I'm learning a language, I like to minimize my tool set so that I can build some "muscle memory" for the language so I don't have to rely on any extra tools. They're supposed to help me speed up my current abilities, not to be my abilities. 
It's an issue with syntactic. Use any alternative that can run these checks in background without locking up the editor process. E.g. Neomake.
Unreadable. I can't read an article that assumes the gender of a ruby object Seems no one in this sub can take a joke :p
&gt; It's just that I've never seen a Rails app being used as a Rack app that you mount in the router, but it's definitely possible. Well, every Rails "isolated engine" is essentially such -- just mounted in another Rails app's router. So you probably have seen it. Rails routing [mount](http://api.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/Base.html#method-i-mount) is often used with a Rails engine as the "Rack app". But yeah, _not_ a good idea for this use case, _not_ suggesting it. :) I don't think I've ever seen a Rails app mounted as an endpoint in a non-rails router, except as a last resort workaround. 
Hmm, using a postgres jsonb type, I suspect the storage space would not be that different, and suspect it could even be a win for postgres jsonb in some data patterns. But yeah, definitely tradeoffs involved. 
Indeed not. I think it makes json serialized data particularly attractive though, significantly alters the costs and benefits to make it more often come out pro. So much that I was surprised to go and check and see the OP actually does seem to be using MySQL!
I like the overall sentiment of the article, though I wouldn't say "avoid". In that example as soon as I saw engine, it doesn't make sense that you'd use inheritance for that. An engine is its own objet. Also, private status of vehicles would also not be inherited because that's just a property of vehicle. Too deeply nested inheritance can make things sticky, but if you're going down that route, you could probably make it cleaner by writing it differently.
@tenderlove
If you have to click "continue reading...." on a page which should be the full article, well....
This was weird seeing as you're comparing Ruby standard library to a Python non-standard package. I think what you should've included was a comparison in the amount of time it took those lines of code to produce their final results. This probably would've supported your idea a little better. I still favor ruby's readability after the demonstration from this article. 
You can try with https://github.com/w0rp/ale, it's an synchronous Lint Engine. I moved from syntastic to this plugin a while ago. 
You're welcome, I'm glad you found them useful.
Yep, every developer has their process; and it's good to learn from others, which helps me improve mine.
You're welcome :-)
hey tomthecool - could you pleeease grace me with one more look at my repo? have spent quite a bit of time learning and implementing some (what i think are good) changes... have been learning heaps about error handling, and have tried to break things out into more simple functions... things im not sure about which i'd particularly love your feedback: prep = prepare_string(num) @num = prep if check_string(prep)` Is this a good way to do things or a bit convoluted? Is my require_relative good to use at bottom of file ( I did this so I could run tests without moving to test file) Is creating my own custom error classes and implementing errors a good idea or will it score be negative points for making things a bit too complicated? I got a lot of my direction from this article: http://rubylearning.com/satishtalim/ruby_exceptions.html Hope to hear from you! 
Check out the book _Rebuilding Rails_.
@sandimetz - Author of POODR and 99 bottles of OOP @avdi - creator of Ruby Tapas 
Just don't disagree with Advii because he sees it as a threat to his book/video business and will block you instantly. Yep happened to me. I was pretty taken a back considering I was offering a friendly rebuttal to one of his teaching points. 
about rebuilding to a new MVC framework?
400 million requests/month is 360 req/sec (30 days 10 hours per day). Ok, lets peak to be 1200 req/sec. Depending on request complexity is either 1 cpu core or 1200 cpu cores. How many cores you use currently? (cpu aquired * cpu usage). What is your goal? If you use Rails+ActiveRecord, did you consider to rewrite some parts in Sinatra+Sequel? How cachable is your application? How heavily do you use Rails'es caching infrastructure? Did you tried JRuby? How many of team members voted for nodejs? If 8 from 10 then you'd better switch. If 2 from 10, then better fire them. If 5/10 then there is real headache. Have you considered rewritting only most loaded part?
Ruby really costs more. Node is really faster. But that is not the issue if you can afford the price. "Some team members" - they are strict minority? Then don't follow them. Convenience of majority is more important. Is it possible to isolate most loaded requests? Is there some complex logic that could be separate into microservice? Then it is possible to use nodejs as accelerator for ruby app. Otherwise, don't bother.
Follows, thanks!
Followed, thanks!
Cron on *nix, task scheduler on windows. 
No, not entirely. But if you want to create a web framework, like your post states, it'll walk you through how Rails does everything. Just read it. It's a ton of fun.
Something like that requires OS level support. You aren't going to find a unified "daily task" system, because the underlying implementations are super different. OSX is yet another weird one. It sounds like you aren't making a gem, you're making an app. If so, try [Traveling Ruby](https://github.com/phusion/traveling-ruby), and have a per-OS setup walk-through for enabling the app on a daily basis.
As other folks lia are saying, you probably want to compare pandas to daru or something. myself, i jump over to R for all my data needs. it's a very different paradigm than oop languages but its data wrangling looks even simpler than pandas. 
Something like what [clockwork](https://github.com/Rykian/clockwork) does?
&gt; Well, every Rails "isolated engine" is essentially such Rails engines were a workaround for an inherent limitation of rails: you can only have one application per process. Besides that, they can't be run in isolation (as in, outside of rails scope), and can't be used in non-rails apps. I'm not sure if they ever intended to tackle the "one application" limitation, but engines seem to have become the permanent "temporary" solution. &gt; don't think I've ever seen a Rails app mounted as an endpoint It's definitely possible. You can hack rails config.ru with rack's poor man router, I had a setup in dev like that to serve coverage generated templates from a specific dir. In defense of the roda option, I think it makes sense there. The end user doesn't need to know Roda, just mount the download endpoint. And rails users are already bundling gems which they might not need (mail, nio...), so what's one more? :) also, the roda streaming plugin (which is a copy-paste of sinatra stream helpers) provides support for all servers implementing streaming, sometimes bypassing rack, as rack doesn't provide sane streaming primitives, and some servers chose not to follow the spec. So if this is a feature that Shrine really needs, I would understand the choice. 
hence?
it's paid, do you mind sharing a copy?
OS X is UNIX and has the standard crontab. Also can be done through launchd I guess. I haven't tried that since I was already familiar with cron. Surprised Windows hasn't adopted cron as an option since it's so widely used elsewhere. 
I don't think using Rubocop goes against this. It helps to improve your code so what you build up in muscle memory is correct.
@schneems @sgrif @nateberkopec @gorails @rafaelfranca I follow a bunch but those are a few you should check out. 
Nothing real, just dumb benchmarks: https://www.techempower.com/benchmarks/#section=data-r14&amp;hw=ph&amp;test=query&amp;b=2&amp;s=1&amp;l=8vmwvz&amp;p=zik0zh-zijocf-zijunz-7&amp;w=z3kjqh-19tr&amp;f=0-0-0-47pc-0-0-0 https://www.techempower.com/benchmarks/#section=data-r14&amp;hw=ph&amp;test=db&amp;b=2&amp;s=1&amp;l=8vmwvz&amp;p=zik0zh-zijocf-zijunz-7&amp;w=z3kjqh-19tr&amp;f=0-0-0-47pc-0-0-0 https://www.techempower.com/benchmarks/#section=data-r14&amp;hw=ph&amp;test=update&amp;b=2&amp;s=1&amp;l=8vmwvz&amp;p=zik0zh-zijocf-zijunz-7&amp;w=z3kjqh-19tr&amp;f=0-0-0-47pc-0-0-0
[Zhong](https://github.com/nickelser/zhong/), although it requires Redis. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [nickelser/zhong/.../**scheduler.rb** (master → c799256)](https://github.com/nickelser/zhong/blob/c7992569fa032ba8d42417ebe90aa49ab477bc7f/lib/zhong/scheduler.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk2b3g0.)^.
Whoops, I linked to one of the source files. I was trying to figure out if it relies on Unix at or cron. It doesn't.
At least in MRI 2.3 and 2.4 give me a SyntaxError. Anyway, [`#write_point`](https://github.com/influxdata/influxdb-ruby/blob/7387e5099b9a9c1163858533b3759d462702c7f2/lib/influxdb/query/core.rb#L60) takes the series/measurement name as first argument, so influxdb.write_point(, { series: 'orders', values: { # ... should be influxdb.write_point("orders", { values: { # ... If your data point already includes the `series` key, you might be better off just using [`#write_points`](https://github.com/influxdata/influxdb-ruby/blob/7387e5099b9a9c1163858533b3759d462702c7f2/lib/influxdb/query/core.rb#L54) directly, i.e. influxdb.write_points({ series: 'orders', values: { # ... 
I was more just trying to point out the syntax error to the author of the article
What was the difference of opinion in?
It makes things more obvious. Finding things when they're less obvious, I feel, would improve your abilities a little more. Maybe using rubocop after you think you've caught everything
@javascriptdaily @programmingwrld @statuscode @thoughtbot @rails @rubyinside 
&gt; We hope you have enjoyed this episode of Honour-Ryan-Bates-RailsCast, **and see you guys next time** I thought this was the last *and* final episode.
It is, that's part of the joke. It's a tongue-in-cheek reference to Husky, a Starcraft video podcaster.
thx bro I try to make sure I have some Good Content (tm) on there
Google says https://rubygems.org/gems/win32-taskscheduler/versions/0.3.1, and you already identified something that works with cron.
OK, I gave it another good look through. Some aspects of the implementation are a little bit dubious - e.g. [this line](https://github.com/mrslwiseman/credit_check/blob/5700048d5edb573dfb29bfaebc3ae05d29d5e8dd/credit_check.rb#L35), which causes input values like [this](https://github.com/mrslwiseman/credit_check/blob/5700048d5edb573dfb29bfaebc3ae05d29d5e8dd/credit_check_test.rb#L61) to be "valid"... But the original question didn't really specify requirements here, and you *have* defined this behaviour yourself as "correct" via tests, so I guess it's ok?... Overall I think the solution demonstrates a good amount of research/effort, and use of the language features. This is what the company reviewing this will be most interested in - so I'd be surprised if you don't progress to the next round of the application with this attempt; especially considering it's only a junior role! Some final cleanups I'd suggest: * The test should require the main code, not the other way round! I.e. delete [this line](https://github.com/mrslwiseman/credit_check/blob/5700048d5edb573dfb29bfaebc3ae05d29d5e8dd/credit_check.rb#L62) (introduced in [this commit](https://github.com/mrslwiseman/credit_check/commit/a0f46be4cf253b023ea47ae47f48e8bd2c2c3f3b)) and put something similar at the top of the test file. Currently, you have to run the tests via `ruby credit_check.rb`, which is backwards! * There are some minor [style-guide issues](https://github.com/bbatsov/ruby-style-guide), such as unnecessary white-space/semi-colons; correcting some indentation levels; preferring methods like `.zero?` and `.even?`; ... An easy way to pick these up is to `gem install rubocop`, then `rubocop &lt;filename&gt;` to see the errors. (You can ignore some of the style guide errors such as missing documentation...) You can also `rubocop -a &lt;filename&gt;` to autocorrect most of them. * You'll also see that this highlights some unnecessary complexity in your code, such as the nested `if` statement, using `+=` instead of `+` and unnecessarily re-assigning the `sum` variable. I highly recommend that you go through this refactoring process yourself (use `rubocop` to help!), but you can simplify your implementation down to: x = num_str[i].to_i sum = if i.even? x elsif (x * 2) &gt; 9 x * 2 - 9 else x * 2 end sum + check_sum(num_str, i + 1, sum) * The `setup` method in your test is now empty - you can delete it!
You might be better off just writing your own simple tool that uses simple http calls to grab the data and transform the response. It could really be as simple as a function or two that is part of your test harness. Also definitely investigate mocking. Depending on the style of coverage you want here, you might want a mocked version so your tests are fast and don't require an internet connection. Then have some other integration tests that actually do end to end testing all the way through, including the rest services. 
The elegance and conciseness of it, for example: (4444**4444).to_s.split('').map(&amp;:to_i).reduce(&amp;:+) And even the more explicit version is short and sweet: (4444**4444).to_s.split('').reduce(0){ |sum, x| sum + x.to_i }
We already using mocks for some of the tests, we mainly need the above for 'real' end to end testing :) I see what you mean, I might as well end doing that, It just I decided to check first if there isn't something that is already quite nice and can be reused.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/sikoba] [From the Sikoba programming trenches: dynamically creating instance variables in Ruby](https://np.reddit.com/r/sikoba/comments/6mmzda/from_the_sikoba_programming_trenches_dynamically/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I don't see the need for this complex solution... The original problem was to do with dynamically creating **local** variables, but your solution is dynamically creating **instance** variables - which is easy. You can just do: ('a'..'j').each do |u| instance_variable_set("@#{u}", ledger.add_user(u)) end Whether or not this is actually a good idea, however, is debatable...
@dan_abramov
I just fulfilled Betteridge's Law of Headlines, AMA.
...sorry the tile should have been "web neutrality modal based on USA IP location"
Will I believe what happens next?
probably, yeah. 
I cringed at the title, but this is a solid article. 
Hey, thanks for this! Clearly an example of a blind spot: starting out with eval and bindings, found a solution that worked and failed to see that neither "eval" nor "binding" are necessary. Quite funny actually. Re "Whether or not this is actually a good idea..." definitely not in a prod context, but i find this useful for constructing test cases.
It's missing an odd number in the title: **Is Ruby Too Slow For Web-Scale? - 7 Reasons why it isn't** *You won't believe number 6*
Web-scale is too slow for web-scale. Don't even bother with web-scale if you are trying to go web-scale.
I may have gone a little overboard. I like doing ironic clickbait titles, but it's sometimes hard to catch the "irony" part.
[Not if it runs MongoDB](https://www.youtube.com/watch?v=b2F-DItXtZs)
Why not use Open Struct?
Have you been successful with this? I probably would have down voted and moved on, if I hadn't recognized your username on the post. If your goal is to get people to read, why not just use honest and authentic headlines?
Granted, u.a (or maybe usr.a in case we have a user 'u') is almost as terse as @a and programmatically cleaner. Still, the original idea of using variables a b c ... is somewhat attractive because of its minimalism.
No, not really. I think I was just so frustrated with the argument in this case (which is literally, "Rails cannot scale yo"). Replying to that argument with an equally hyperbolic headline made sense in my head, at least.
Yeah, I understand what you are saying, but to a random reader, they may come at this with no context of the argument and no ability to discern satirical intent from sincere intent.
&gt; the original idea of using variables a b c ... is somewhat attractive because of its minimalism. If you say so.
Just to clarify, this is what we're talking about: require 'ostruct' usr = OpenStruct.new ('a'..'j').each do |s| usr[s.to_sym] = ledger.add_user(s) end puts usr.a.inspect 
Unrelated, but what do you think of Guilds? It seems to me like a more lightweight version of processes...do you think it'll actually make a difference to Rails apps?
It's usefulness depends so much on how much time it takes to create and destroy them (basically, overhead). If they're cheap (similar to Threads), they could really really change the way we write Ruby IMO.
Well it worked on me anyway!
I wrote this. AMA.
[But is it still cool?](https://www.youtube.com/watch?v=5GpOfwbFRcs)
I got angry at the title until I saw it was Nate Berkopec that wrote it.
That's really unfair that the Rails benchmark had a limited number of processes, and the Roda benchmark had unlimited. And that the Phoenix benchmark didn't have equal setup either. I guess we'll need to wait for the next round to see the results.
Nice, this is interesting, thanks. 
New person here asking what may be a stupid and not wonderfully phrased question: What I'm getting from the article is that server costs can be saved by reducing latency for the app, what exactly are you paying for with your host when referring to 'server costs'? Is it more servers=more CPUs to process requests faster or something else? (I work at a hosting company, but have very little programming and server side knowledge, please ELI5)
Lets honor him with a plug for our own thing, it would have been in better taste to have left that out, or just sneakily added it to the Gemfile for the observant viewer. Anyways, good idea for a person that needs more appreciation. 
&gt; we can improve latency by having a lot of workers sitting idle waiting for new work to come in Yeah exactly, more servers. Let's say I need 10 Heroku dynos (dyno = server) to serve my app for whatever my given load is, which always returns responses in 200ms. If I halve that to 100ms, now I only need 5 dynos to serve the same load.
I think a lot of the other frameworks are gimped too. There are really, really subtle differences between how the Rails and Roda benchmarks set up as well, which I think may actually matter on a microbenchmark (Array.new vs map, for instance). TBH someone went through the Roda/Sequel benchmarks a month or so ago and optimized the hell out of them but didn't touch any other frameworks.
boiiiiii u kno i never do ya wrong
So, basically article saying that for a website it's ok to be a little slow, and +- 100ms latency doesn't matter. While such opinion has some reasoning to back it up, I don't like it.
Especially when even DHH says that performance and russian doll cache is critical to squeeze response under &lt;60 ms for native like user experience.
Not sure how to change where the game saves to, what's the best way to change the folder for the save data? I've stopped everything I could except Steam running in the background and that doesn't help.
No but literally it can't scale. In order to scale something it needs physical measurements. Software being a non-physical construct cannot be scaled (I'm just going to shit post at you on every medium now until you come to Santa Fe. :P)
give me an excuse and I'm there bro, it's only 90 minutes down the road
Was lunch not an excuse? :P
OH THAT'S WHO THIS IS
Let's all just blame the database layer and be done with this debate from a programmers point of view.
WHO THE FUCK DID YOU THINK I WAS
NATE ARE RANDOS TRYING TO GET YOU TO GO TO SANTA FE? YOU SHOULD SAY NO NATE THAT IS NOT SAFE
Shards are the secret ingredient in the web sauce.
I though it was a /r/programmingcirclejerk post.
**Here's a sneak peek of /r/programmingcirclejerk using the [top posts](https://np.reddit.com/r/programmingcirclejerk/top/?sort=top&amp;t=year) of the year!** \#1: [Garbage millennial websites](http://i.imgur.com/mHIvkeQ.png) | [38 comments](https://np.reddit.com/r/programmingcirclejerk/comments/58h3qt/garbage_millennial_websites/) \#2: [when u mention back-end on ur resume but only know nodejs](https://i.imgur.com/lK0Ved9.gifv) | [10 comments](https://np.reddit.com/r/programmingcirclejerk/comments/5m9lnj/when_u_mention_backend_on_ur_resume_but_only_know/) \#3: [MFW no pointers :( \[x-post /r/programmerhumor\]](https://i.redd.it/f2rjwzv2hoay.png) | [24 comments](https://np.reddit.com/r/programmingcirclejerk/comments/5p35sf/mfw_no_pointers_xpost_rprogrammerhumor/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
As said random reader, I ignored the article until I saw comments such as above. So you're right. 
Hi. Want to go to lunch? 
But... what if you're a core developer on a database engine? (Thankfully, I'm not.)
I'm on the hobby tier :-(
You can get the same info via PG stat statements https://www.postgresql.org/docs/9.4/static/pgstatstatements.html. It takes a little more work and no pretty dashboard. I'm not sure if it is enabled on the hobby databases though, try it and find out. 
I think it was more that *up to* about 100ms was acceptable, and that most of that latency would come from the IO (database, external API calls, etc), so focussing on the web app framework instead of worrying about optimizing IO is the wrong approach. Think 80/20 rule.
&gt;The majority of web applications handle far less than 1000 requests per second. This is understated. There's a huge correlation ime between people bikeshedding frameworks and making huge issues of needing to be the most performant platform they can, and web applications that nobody uses and end up on one low end VPS doing 10% CPU. 
 wow, thank you so much. I am so honoured you took the time to help me out with this - where are you anyway? If your in Melbourne some beers are definately on the way. rubocop is my new best friend. I'll let you know if I get the job
Actually I was tried to find something similar for Ruby, but didn't. You can attach a link if you want. I compared the way to solve a problem in two ecosystems 
For this "weird" comparison Pandas showed incredibly better results. But as other guys mentioned, I probably better to compare Pandas with Daru. Perhaps time will differ there in another way. Will do it on next weekend 
Great, thank you, I'll compare Pandas with Daru, it seems to be more relevant 
Is this yet another rehashing of the "ruby is optimized for developer time, not machine time" argument? It's becoming as boring as the "ruby can't scale" meme. 
Do node.js developers hate this one weird trick?
If your external services are highly deterministic and resource-oriented (basically, as close to a pure function as you can get), you can check out [vcr](https://github.com/vcr/vcr). What it does is that it will run the actual HTTP call only the first time you run a particular spec, record the request/response pair, and replay it for future test runs. For some use cases, this is perfect, however I'd say that as a caveat, it's not always useful if the external service you call has a lot of internal state, is non-deterministic etc. In that case, your recorded interaction won't help you much because it's missing a lot of the context (the recorded response might simply be incorrect for the particular context you were in). In such a case it is IMHO much better to assert that you made a particular request (using something like [webmock](https://github.com/bblimke/webmock)) or to route all your requests to a mock API (which you can also do with webmock). In terms of http clients I'd suggest to have a look at [http.rb](https://github.com/httprb/http). It doesn't give you a REST abstraction, "only" base http calls, but I think that for most use cases that's enough, and you can encapsulate all external access into some Gateway class (which I'd recommend doing anyway).
Are you using JRuby? It freezes for me only on JRuby, not MRI. I have the same setup, but using NeoVim instead of Vim.
What is your use case exactly? I'll tell you my experience, although I am not sure whether it is applicable to you. I use Ruby to write non-interactive sysadmin or business automation scripts. For example I was trying to write a script which automatically downloads SaaS invoices once a month and uploads it to a Google Drive directory so that someone can aggregate them and send them to the accountant once in a month. For this use case, I am not happy with the Google Drive API or any of Google's APIs. It seems that they all rely on OAuth2. They all require authentication via a browser URL, meaning that I can't make my scripts non-interactive. Eventually I gave up and setup an email-to-Google Drive gateway via Zapier. I then modified my script to send an email to Zapier instead. I found this way easier than learning the Google Drive API and trying to find a way to deal with the non-interactive authentication issue.
Wow, that's a pretty cool tool (`vcr`) kinda reminds me what [pact](https://docs.pact.io/) do. Excellent, thank you very much. I will be checking http.rb (which I wasn't aware about).
I know that's a pain. I finally was able to achieve something by creating a service account as described in this guide: https://developers.google.com/api-client-library/ruby/auth/service-accounts and important ---&gt; defining an env variable GOOGLE_APPLICATION_CREDENTIALS pointing to my client_secrets.json. here is a snippet of my working code: https://gist.github.com/itrion/fcb42b6ea8942dbd7b0dd70849e4582d It is not the same but probably you are missing the auth part as I was doing
I wanted to downvote this post, but after reading this comment, I am no longer upset with the title.
If you halve that to 100ms, then you need 10 dynos for 100ms, or 5 dynos for 200ms.
Will start all my arguments with "even DHH I days that" from this day forth.:)
Ruby 2.4 with rvm
Clickbaity title but nice recommendations. TL;DR: vulnerability scans and license scans can save your ass
One option is to set up a separate instance of the app which is used for testing. This way you don't have to worry about spamming your db with fake data, and you don't have to stub out every HTTP call. It might seem like integration tests are "end to end" and are a shortcut to test what's necessary quickly, but it is probably worthwhile to write unit tests as well, and the unit test suite will probably be significantly larger than the integration test suite. The reason for this is twofold. First all, if you don't stub HTTP calls in your integration tests then then will run slower. Personally I stub in unit tests and don't stub in integration tests. Second, the integration tests sort of cover the "tip of the iceberg", and if you only run integration tests than you will have less comprehensive test coverage. 
i avoid romance languages for the same reason
standard libraries?
So your suggestion is to get no feedback as you barrel along on learning the language so that by the time you do use linters "after you know the language well" you will be gleefully surprised by the muscle memory you have built over your assumed correct or non idiomatic code. slow clap. 
I think part of it is that Ruby is backed by a large community of web devs, right? So a lot of creative types where as Python has google backing it even if indirectly.
Love the title, I read expensive query dashboard in the context that it costs a lot of money on the first pass.
Nice article. I have a similar one: http://ragmaanir.mypresident.de/2014/11/12/performance-benchmarks-of-application-servers.html
Your assumption that linters are required to learn how to code well deserves the slow clap
I don't see the point in this, why not just use an array? Do you find alphabetical indexing simpler than numerical indexing? users = ('a'..'j').map do |u| ledger.add_user(u) end users[0] users[1]
I advise against let/subject and especially nested describe/context. That just makes the tests complicated and difficult to grasp. Instead all variables/objects needed for the test should be created in the test. DRY should not be followed in tests as strictly as in app code.
Thanks for the code and the pointer :))
Yeah I'm already thinking of alternative methods - the API seems poorly documented and probably subject to change :/
Great article. Didn't know about the `subject` thing previously. Thanks.
Exactly :-) We already have Unit-Tests, Integration Tests (that is sort of a contract testing between two services really) and the client I'm trying to build is actually more of an 'real' end to end (with a test-oriented db).
Hello, I've updated the JSON readers gem now called [json-next](https://github.com/jsonii/json-next), formerly jasony. The next next generation JSON parser / reader included is a world-wide ruby's 1st - `JSONX.parse` for the new [JSON: 1.1 # JSON with Extensions (JSONX)](https://jsonii.github.io) format. Using JSONX you can use all the JSON extension of HanSON (JSON for Humans) and SON (Simple Object Notation) and some more e.g. use Ruby (Shell)-like #-comments, unquoted keys, optional commas, and much more. Note: `JSONX.parse` is the same as `JSON.parse( JSONX.convert(text))`, that is, JSONX works like a preprocessor for JSON. Cheers. PS: What's your favorite JSON format? e.g. "Vanilla" JSON 1.0 or JSON5 or HJSON or HanSON or SON or CSON or USON or JSONX/JSON11/JSON XI/JSONII.
I'd hate to be in charge of maintaining a large rails test suite that strictly followed this advice... It's not about being DRY per se, it's about writing *maintainable* code. If you have tonnes of long repetitive tests, then people become opposed to making any behavioural changes to the code - since updating the failing tests becomes a painful/complex task. I agree with the principle that "deeply nested &lt;anything&gt; is confusing", though - if you find yourself doing this in a spec, there's probably something wrong with your code: Why are you writing so many tests against a single class? Sounds like it's doing too much, and the architecture needs to be reworked.
I think the article missed the point slightly about `subject`: Not only is there a special way to declare this variable (an [explicitly defined `subject`](https://relishapp.com/rspec/rspec-core/v/3-6/docs/subject/explicit-subject)), but there is an [**implicitly defined `subject`**](https://relishapp.com/rspec/rspec-core/v/3-6/docs/subject/implicitly-defined-subject), and an [**implicit receiver**](https://relishapp.com/rspec/rspec-core/v/3-6/docs/subject/one-liner-syntax) for it. In ["old" rspec syntax](https://relishapp.com/rspec/rspec-core/v/2-8/docs/subject/explicit-subject), you could write tests like this: it { subject.should eq 123 } # Or, using the implicit receiver: it { should eq 123 } In modern (core) rspec, using `expect()` syntax, there is a similar method to simplify the code. The following lines are equivalent: expect(subject).to eq 123 is_expected.to eq 123 If you ever migrate an old project from using `rspec 2.x` to `3.x` with [`transpec`](https://github.com/yujinakayama/transpec), it will automatically make this conversion for you. There also used use be an ["attribute of subject" method](https://relishapp.com/rspec/rspec-core/v/2-8/docs/subject/attribute-of-subject) built-in to rspec version `2.x` - which has now been [abstracted into a separate gem](https://github.com/rspec/rspec-its), since version `3.0`: subject { ["foo", "bar"] } its(:length) { should eq(2) } **tl;dr: `subject` is a special variable in `rspec`.** You may or may not like the "magic syntax" it provides. It's your decision whether or not you want to use it, but it's definitely worth learning about in case you need to understand someone else's test suite...
Was about to post this myself... And one minor improvement you could also make (since this is apparently for creating test data, according to OP): @users = (1..10).map do |i| ledger.add_user("user_#{i}") end Or maybe even just define `@users = ledger.users`, if such a method exists?
Similar tips and more at: http://www.betterspecs.org/ Also, not really sure it makes sense to use a matcher as a stand in for a mock, as described in the `anything` section: let(:books) { [Book.new(anything, anything)] } The `anything` object and other matchers can be used to match _against_ other objects but they don't actually _behave_ like the objects they match against. So in the example, if the first argument to `.new` is expected to behave like a string, you'll get an error if the `Book` class attempts to call any string methods on it, e.g. `#strip`: &gt; anything.strip *** NoMethodError Exception: undefined method `strip' for #&lt;RSpec::Mocks::ArgumentMatchers::AnyArgMatcher:0x007f6bef4d70a8&gt; For this use case you can either just us a real object that behaves like the type you need, or reach for a double if a real object is too cumbersome to set up (or if you need to verify behavior).
I'm not sure how useful this is for anyone in the JS community since its a ruby gem, adds unnecessary overhead since you need to transpile it everytime before it reaches the Browser and it doesnt necessarily make JSON any better. I mean comments, trailing commas, multiline strings are nice to have but most of the time people don't write JSON by hand unless its small modifications. Usually JSON is used to transfer data from two Software pieces using a human readable transport channel. E.g. from mySQL through a backend to the browser. I think this gem would be useful if it adresses the limitations of JSON like being bound to the few possible data types (string,ints,bools,floats,nested JSON). There is no support for custom data types like serialized class instances, dates(!) and other I can't think of at the moment. I'd love to just transfer a rails date object through JSON and consume it in the Browser without the hassle of casting it to a string and then parse the date in the Browser again. There are proposals for typed JSON iirc but they don't get much attention imo. Otherwise the gem looks great, just questioning its usefulness.
Thanks for your comments and kind words about the gem. Good points. &gt; just questioning its usefulness. The usefulness is for writing and reading JSON files by humans. If you do NOT write the JSON file by "hand" e.g. package.json, datapackage.json, etc. than - of course - the usefulness is zero - the machine doesn't care about the format. PS: To make the case for readability before: name = s-and-p-500-companies title = 'S&amp;P 500 Companies with Financial Information' license = PDDL-1.0 resources = &lt; name = constituents path = data/constituents.csv format = csv mediatype = text/csv schema = { fields = &lt; name = 'Symbol' type = string description = '' + name = 'Name' type = string description = '' + name = 'Sector' type = string description = '' &gt; } &gt; After: { "name": "s-and-p-500-companies", "title": "S&amp;P 500 Companies with Financial Information", "license": "PDDL-1.0", "resources": [ { "name": "constituents", "path": "data/constituents.csv", "format": "csv", "mediatype": "text/csv", "schema": { "fields": [ { "name": "Symbol", "type": "string", "description": "" }, { "name": "Name", "type": "string", "description": " }, { "name": "Sector", "type": "string", "description": "" } ] } } ] } What do you prefer? It's really all the small extensions that add up e.g. multi-line strings. Before: content_html : `Chris has worked at &lt;a href="http://adobe.com/"&gt;Adobe&lt;/a&gt; ... He lives on &lt;a href="http://www.ci.bainbridge-isl.wa.us/"&gt;Bainbridge Island&lt;/a&gt;, ...` After: "content_html": "Chris has worked at &lt;a href=\"http://adobe.com/\"&gt;Adobe&lt;/a&gt; ... \n He lives on &lt;a href=\"http://www.ci.bainbridge-isl.wa.us/\"&gt;Bainbridge Island&lt;/a&gt;, ..." And so on and on. 
heyyyy
 allow(Review::API).to receive(:new).and_return(test_api_client) This is generally a bad sign. It means that you're using Review::API directly instead of injecting dependencies. In general, you should never use "mock" as a verb, but as a noun, as in "I'm passing a mock to this constructor".
I have to say that it's a delicate balance. Too dry specs + nested contexts and you need to jump around too much and specs don't really explain what they're doing. But not having nested contexts etc. at all sometimes also creates a lot of boilerplate that makes it hard to focus on the right thing and that makes specs hard to extend. The middle ground is hard to find, but it's there somewhere (at least I always hope...).
There seems to be a lot going on here and I'm a little confused about it. You show lines like `include Twitter::REST::Users` but then later `Twitter::REST::Users.new`. Is that a module or a class? You can't include a class and you can't initialize a module (like that). You could use `method_missing` to check for a received message and query the modules/objects if they have a matching one and then execute it. Something like this: def method_missing(method_name, *args, &amp;block) case when @client.respond_to?(method_name) @client.public_send(method_name, *args, &amp;block) when @users.respond_to?(method_name) @users.public_send(method_name, *args, &amp;block) # etc... else super end end That would cause the method lookup to happen at runtime, but you could instead write methods at load time as well class Twitter # maybe you want all inherited public instance methods so you'd skip that 'false' flag...? Twitter::REST::Users.public_instance_methods(false).each do |method_name| define_method method_name do |*args| users.public_send(__method__, client, *args) end end attr_reader :users, :search, :tweets def initialization(client) @client = client # To be used when client information is needed @users = Twitter::REST::Users.new # etc... end But either of these approaches will only work easily if you have a clear pattern. You defined a `create_user(user_name)` method but the `@users` object has a plural version `create_users` so you'd need to strip the "s" character and check. It's not clear to me exactly what you should do but hopefully that gives you some ideas. Here's an article I wrote that has some similar ideas for forwarding messages to one object or another https://www.saturnflyer.com/blog/easy-metaprogramming-for-making-your-code-habitable 
Hello sautrnflyer, thanks for the reply. The above example is basically divided into two sections. The first one is taken directly from the Twitter gem. In that example `Users`, `Search` and `Tweets` are all modules. They mixed those modules into the `Client` objects, and by that giving a the user a `know-it-all` object to work against. I mostly try to use Composition when I can, and because the example from the Twitter gem has a lot of inheritance using `include`-ing, I was trying to think if there is a better option to do with composition. The second example has uses `Class` instead of `Modules`. Which means `Users`, `Search` and `Tweets` are all classes in the second example. Does it makes more sense now? I will update the original post to hopefully to be clearer. Thanks :) 
That makes sense but does that mean you plan to turn those modules into classes? That's the part that doesn't make sense and seems like a lot of work. I wrote a gem which allows you to compose behaviors on an object with modules https://github.com/saturnflyer/casting, so maybe there's an idea for you there. Did my reply help you answer your question?
I think there's something that's often overlooked: The need for lots of levels of nested contexts is often because the corresponding class being tested contains too much behaviour. In other words, the complex test isn't the real problem – it's a symptom of the complex implementation. In some ways RSpec can seem like a panacea, because it makes it easy to test poorly-designed code. If RSpec was less capable, it would act as a force to make the implementation simpler, in order for it to be testable. It would encourage the extraction of large classes into smaller pieces. However, when adding tests to 'legacy' code, the DSL that RSpec provides can be helpful.
Does this site comes with margins? Not really great to read on a phone. 
This is just my take, but it doesn't seem like there's a reason to instantiate the Users/Search/Tweets. If you instantiate the container class with the api key and create an attr_reader, then if you mix in these other components via modules then you can read the instance variable. class Twitter class REST module Tweets def get_tweets(*args) client.get_tweets(*args) # call the appropriate method on client end end end include Twitter::REST::Tweets attr_reader :client def initialize(client) @client = client end end You don't really have to stub here: client = Client.new # instantiate the client twitter = Twitter.new.client expect(twitter.client).to eq(client) However, this approach has the downside of introducing a dependency on the `client` method into the modules. To get around this you could refactor the `client` into a variable that is passed to whatever method needs it, and create wrapper methods (either one-by-one or by metaprogramming) in the container class which dispatches to the module methods. If you're following this pattern of always explicitly passing arguments, then you could refactor the mixins into class methods. If you're defining them this way, then the only difference between using a mixin and not is that that you don't need to reference the method's namespace. So for example: class Twitter class REST module Tweets def self.get_tweets(client, *args) client.get_tweets(*args) # call the appropriate method on client end end end include Twitter::REST::Tweets attr_reader :client def initialize(client) @client = client end # this dispatcher method gets added: def get_tweets(*args) REST::Tweets.get_tweets(client, *args) end end Following this static pattern (explicitly pass all arguments and avoiding side effects) is more aligned with functional programming and is easier to test since it's just input/output To avoid duplication in the unit tests, you could test `Tweets.get_tweets` in detail and then just check whether `Twitter#get_tweets` dispatches to it, e.g: client = Client.new twitter = Twitter.new(client) # note that the following is a stub and will make the method return nil immediately. expect(Twitter::REST::Tweets).to receive(:get_tweets).with(client, "foo") twitter.get_tweets("foo")
&gt; In some ways RSpec can seem like a panacea, because it makes it easy to test poorly-designed code. If RSpec was less capable, it would act as a force to make the implementation simpler., in order to for it to be testable. It would encourage the extraction of large classes into smaller pieces. That may very well be true, but I am also of the opinion that, even in greenfield projects, you can never have perfectly designed code. Your understanding of the architecture will continue to evolve. Sometimes a natural way to split up the implementation of a method with 5 branches doesn't present itself immediately. There's some balance involved here too. Sometimes panaceas are fine, we use them in real life too from time to time.
Yeah, I agree the code and the tests need to continually evolve, and it may take time for the right abstractions to become visible. But it's often at a point when it's too late, and the refactoring becomes extremely difficult. In [rubocop-rspec](https://github.com/backus/rubocop-rspec) there's a NestedGroups cop with a default maximum of 3 levels deep. It can act as a gentle nudge that some refactoring is probably due.
Hm, on my phone it looks fine except for the header.
Not following DRY **strictly** in tests does not mean the tests are full of repetition. Unimportant and short parts may repeat when it is not worth it to DRY it up. I used to use exactly what is shown in the article: let, subject, its, DRY up repetitive things. This made the test complicated and ugly. E.g. the setup logic for a simple test is spread out to (probably) multiple setup blocks and a bunch of lets. The problem with *let* is for example that not every let is used in every test. This is even the case in the article. If you have *let*s in your test-case that are hardly used, declare them in the tests instead. If you have stuff that repeats in your tests, write helper methods instead of before blocks and nested contexts. If there are many tests in you test-case, you should try to split it up. The class under test might be too complicated. I might write tests similar to this (example from the article, using the gems *minitest-power_assert* or *wrong*): describe Author do it '#name returns the name passed in the constructor' do assert{ subject.new("Bob").name == "Bob" } end it "#books returns an empty array when passed nil in the constructor" do assert{ subject.new(nil).books == [] } end it "#books returns the array set in the constructor" do assert{ subject.new([]).books == [] } book = build(Book) # factory method assert{ subject.new([book]).books == [book] } end end YMMV
iPhone SE. There is no left margin in safari. Header seems fine tho :) 
One thing that might help is to focus on the simplest 'happy path' first and worry the 'failure paths' later. In your test `"accepts 'resource' as a parameter"` the only thing you can really verify so far is that that no exception is raised. But that will be tested implicitly as part of your other yet-to-be-written tests, so there's not really any need to test that specifically. I find the [4 phases pattern](https://robots.thoughtbot.com/four-phase-test) to be a helpful way of thinking how to structure tests.
Not necessarily my *personal* opinion but this comes up a lot whenever Dependency Injection comes up in a thread: Not everyone in Ruby land is as enamored of DI as with, for example, Java devs precisely because mocking in Ruby is so easy compared to other languages.
[removed]
You can only test it based on the public state exposed by the object under test. Does the initialize argument effect some state that is exposed by a public method? Then you can test it that way. If it doesn't, there's nothing to test (and nothing that needs testing). Or, if in BDD where public state might exist but doesn't yet but you want a test that will pass now, then like andyw8 says, all you can test is that it was initialized without raising an exception. Because, after all, that's all the object _does_ so far -- it can be initialized without raising an exception, that's it. You can't test something that it doens't do yet, and have the test be green already. Whether this is a useful test to write or not, I dunno. 
Looks to me like you want to use mini-test rather than RSpec. 
I think you're trying to test details that are too specific. In BDD, you're not trying to write tests for every method, you're trying to write tests for each _desired behaviour_ (how the code will be used). So I would delete all those tests and just start with something like: RSpec.describe ShortLinkGenerator do it 'generates short links' do generator = ShortLinkGenerator.new(...) short_link = ... expect(short_link).to eq('/my/short/link') end end It gets a bit more complicated if you're calling out to an external service (for example, bit.ly).
Great article, thank you!
Ruby is a duck-typed language. By it's nature, it doesn't care about what "type" an object is. In fact, Ruby doesn't really have types at all. Don't worry about what your object is (ActiveRecord::Base), worry about what it does. Get rid of the "raise ArgumentError" and simply expect that the @resource object injected into your class will respond to any messages you want to send it. By taking this approach if someone passes in something that doesn't quack like the kind of duck you're looking for they will get a very sensible "method_missing" error.
Glad it helped!
No, its not about the framework. I used rspec first and picked up the habits mentioned in the article. That was probably 4-6 years ago. Sticking to these habits made the tests difficult to understand. At work we used minitest and shoulda with nested contexts, which also became a PITA. Flattening out the test cases by avoiding nesting and *let* made the tests more readable. Currently i am mostly writing code in Crystal using my own testing framework which does not use `let` or nesting (yet - nesting is useful in a few cases).
am curious about one thing: how did you embed multiple rb files in the same gist?
Hello isolatrum, thanks for the detailed answer :) &gt;This is just my take, but it doesn't seem like there's a reason to instantiate the Users/Search/Tweets. Well, I'm always think twice when creating modules, because this means I can't mock easily if I'll ever want to. For example, during testing, I might that `get_tweets` returns a list of tweets from a file, instead of the server - to make tests faster and more reliable. In any of the above example, this can't be easily done. I have to create a new module and changing the container reference. That's easier to do if `Tweets` is a class instead of a module. But your the 2nd person who mentioned modules is probably the proper way of doing it, so I will be using modules as you suggested. The 2nd option looks better to me, as I always prefer explicitly mention I need `client`. It makes reading `Tweets`, or `Search` classes easier to understand. Thank you! :) 
"add file" at the bottom :), that's why gist is beautiful. 
That was in the back of my mind too! I have been reading a lot between the /r/ruby and /r/rails subreddits about design principles and it totally skipped my mind. Thank you for the reminder. 
Good call, thank you very much. I've had trouble in the past by thinking way too far into it. So, more so I should be thinking about the input and the output, rather than what is really happening in the middle. 
Awesome, thank you very much for the link.
Y'all have been a stupid amount of help. Thank you so much for taking the time to help me see a bit more clearly. 
This is great! I'm not very familiar with Rust - how do you interpret Ruby code in the Gemfile?
Just a dumb regex to extract the version number if specified :)
It is as attractive as many other bad habits.
I made it [a bit less dumb](https://github.com/Floppy/ruby-version-badger/pull/2/files) for you :) A possible enhancement could also be to look for a `.ruby_version` file, as well as the current [search of the `Gemfile`](https://github.com/Floppy/ruby-version-badger/blob/2181755347aa67d3a11fac15e0c7ef1eb29ecae8/src/handlers.rs#L16).
It does that already - and thanks for improving my lazy regex :)
Check out Sandi Metz on testing. This talk is not BDD-focused, but I think is compatible. https://www.youtube.com/watch?v=URSWYvyc42M 
Ah yep, sorry. I must be blind... Or maybe I just searched for `ruby_version` instead of the (correct) `ruby-version` :)
You can still stub with modules you just,need to, do it on the class which includes the module
Nice article, I really enjoyed it. Helpful information. But I want to extend on point "It Isn’t Getting Worse" you are mentioning " Wirth’s Law" but you are not saying anything on "Moore's law" ( https://en.wikipedia.org/wiki/Moore%27s_law) =&gt; we reached the peek of what semiconductor can do, and we can only increase number of CPUs (and Hyper-threading like i7 is doing is just temporary patch). And although multi threading in Ruby is possible but Rails is not particularly doing that best. I heard on one podcast Matz saying that MRI will definitely focus more on multi-threading issues in the future, but he was mostly talking about "in the next decade". I would like to hear your take on this problem. Thx
I've released pubsub_notifier on yesterday. I think that Pub/Sub pattern is useful for us better than Observer pattern (e.g. rails-observer) or creating Callback classes. It's loosely coupled! Please give me a feedback and testing. Thanks.
What kind of transport does it use for the events? Is it all in memory? For instance, if I restart a rails process, will all in-flight events get lost?
There are valid reasons to use dependency inversion but replacing a database with an in-memory store is not one of them. No one ever does that, and if they do they have changed the semantics of the entire system. The ease of changing the data source is irrelevant when major architectural changes will be needed to do anything useful. 
&gt; No one ever does that I have a lot of benefits from InMemory data source to be honest. And I'm not the first who used this approach. So I wouldn't say that "No one ever does that". For one of the system I have I use API as data source, why not, and if API part is not ready yet, but I know the contract for that API, I can mock data in InMemory data source and keep development going. When API is ready I can switch data source and deploy my code. Also I use InMemory data source for specs. It makes them really fast. If you're interested in that topic you can check Uncle Bob's talk "Architecture The Lost Years" with a good description of this idea.
&gt; And I'm not the first who used this approach. So I wouldn't say that "No one ever does that". No one ever replaces a _database_ with in-memory in production without _major_ systemic changes. &gt; For one of the system I have I use API as data source, why not, and if API part is not ready yet, but I know the contract for that API, I can mock data in InMemory data source and keep development going. Use webmock + VCR with example responses. This allows testing the API URL construction (VCR will complain on unknown requests), allows testing the response parsing logic, error handling, etc, etc. It also avoids mocks, and an in-memory store that is only used in tests is just a convoluted mock. Mock as little as possible. &gt; Also I use InMemory data source for specs. Not sure what you are saying here but I assume you haven't written your own in memory SQL engine. More likely you've just configured your ORM/db driver to use sqlite in in-memory mode which doesn't require abstracting a repository. Also tests are rarely slow because the database is slow, it's most often because the data model is tangled and/or things are being persisted when they don't need to be for the thing under test. I also highly recommend using your production DB app (i.e. don't deploy in PG and test in sqlite) in a near production config with parallel tests + randomized ordering, this can uncover a lot of consistency issues that may otherwise only appear in production. 
You can just provide stubing in the library. e.g. http://docs.aws.amazon.com/sdkforruby/api/Aws/ClientStubs.html
&gt; No one ever replaces a database with in-memory in production without major systemic changes. I've never suggested to use InMemory data source for production. The entire idea of using data sources is to be able to plug and unplug those when needed. And I see ways to use InMemory data source for cases I mentioned above. &gt; Use webmock + VCR with example responses. I used webmock to mock APIs, thanks for suggestion. With architecture that I described it was easier for me to create data source than rely on webmock. &gt; I assume you haven't written your own in memory SQL engine That's true, I don't need to write SQL engine. SQL lives on infrastructure layer. &gt; Also tests are rarely slow because the database is slow I can not agree with this one &gt; I also highly recommend using your production DB app in a near production config with parallel tests + randomized ordering, this can uncover a lot of consistency issues that may otherwise only appear in production. That's a good point. Thanks for your opinion I appreciate that. 
&gt; I've never suggested to use InMemory data source for production. The entire idea of using data sources is to be able to plug and unplug those when needed. And I see ways to use InMemory data source for cases I mentioned above. That implies that the argument is that we should pollute production code with abstractions that are only used in dev/test, this is not a good pattern, especially in Ruby. In Java, maybe you have to do this as you have no other options, but in Ruby, you have many options that do not increase your production code complexity just to avoid mocks. If this polymorphism is only exorcised in test, it is just another way to write a mock that is _less_ explicit. &gt; That's true, I don't need to write SQL engine. SQL lives on infrastructure layer. I don't know what this means. SQL can not live in your infrastructure layer unless you are using it as a trival key-value store. You can't avoid knowledge of joins and transactions at other layers. 
&gt; In a way though, wouldn't this same argument show that most "hot methods" would now be optimizing for free? Like, the most executed code will knock down it's worst case? No, it's a dead code optimization, which isn't a bad thing, but it tells you nothing about what happens to code that actually executes. 
why is it [removed]??
Can also use something like vault
Thanks for your question :) pubsub_notifier use wisper gem. So reactable to events synchronously or asynchronously. In case of synchronously, calling event method just like ActiveRecord callback or Observer (But It's loosely coupled). In case asynchronously, calling event method through ActiveJob (sidekiq, resque). krisleech/wisper: A micro library providing Ruby objects with Publish-Subscribe capabilities https://github.com/krisleech/wisper
You are correct about relational databases. Relational databases can't be substituted with "in memory" implementations. I work with event stores, and they are very easily substituted for "in memory" alternatives. Another reason storing transaction state (writes) in a database optimized for queries (reads) is suboptimal. The difficulty of substituting a relational database is just a manifestation of a larger drawback -- systems built on relational databases are always encumbered by the complexity of using SQL to synchronize program data (i.e. ActiveRecord objects) and persisted state.
I've been doing it wrong for all these years. was blind, but now, I see.
&gt; The difficulty of substituting a relational database is just a manifestation of a larger drawback -- systems built on relational databases are always encumbered by the complexity of using SQL to synchronize program data (i.e. ActiveRecord objects) and persisted state. LOL ok...let me know when you find a way to build a useful system that isn't dependent on persisted state.
I'm talking about the drawbacks of using a relational storage model for persisted state. I work with systems every day that persist state without a relational database schema underneath. Not sure why you are laughing at me as if I just proposed some horrendously naive approach that could never work. I have built such systems and they work great. And on a side note, I've seen systems that have so much transactional volume that they actually keep all their state in memory and replicate it across clusters. So even your snarky response wasn't exactly valid.
&gt; Relational databases can't be substituted with "in memory" implementations. Could you please elaborate a little bit on this. Really interested in your experience with that. In my case, data source is responsible for getting data from data store and returning it as a hash back to repository. So as long as data source responds to methods described in repository and returns hash - it works. Speaking about persistence, when repository calls `data_source.update(id:, params:)` it doesn't know how each particular data source is going to handle that request. For database it can be transaction, for in memory it's just a matter of returning expected value (for example: true, or hash with updated params). I see that transactions, sql, http (if data source is an api) should live on infrastructure level and should not leak into application level or core domain. Thanks in advance for answer, really interested in your point of view on current approach.
Sure! A SQL database is controlled by SQL. SQL is a turing complete language. That means it can do just about anything -- and that also means SQL code can't be substituted. I'll give you an analogy: class ExampleClass def initialize(string) @string = string end def execute result = eval(@string) result end end Can I substitute an instance of `ExampleClass` with another object? No. No other object can stand in its place, because any conceivable ruby object could be returned by `execute`. Whether the programming language is ruby, or SQL, any interface you put in front of the programming language must restrict the usage of the language behind it, otherwise it must expose the language itself (which makes the interface useless). Yes, you can implement the repository pattern from DDD. I have implemented the pattern myself. But that doesn't mean you can ever change databases without a ton of effort. It may mean you can effectively test your code in isolation with a substitute repository, but it doesn't make that database schema itself easy to change. You inevitably wind up with all sorts of queries that supply your user interfaces with data -- those queries are going to be coupled to your relational database schema no matter what. &gt; I see that transactions, sql, http (if data source is an api) should live on infrastructure level and should not leak into application level or core domain. All of that is transport. It also can be "business logic" depending on the circumstance. Let's take HTTP. If I stand up an HTTP frontend that exposes a web GUI, then that frontend should be "outside" my application logic -- i.e. my application logic shouldn't touch it. But if that application logic needs to post to, say, a credit card gateway, then _those_ HTTP requests are controlled by application logic. If my HTTP frontend enqueues a "background job" to perform a computationally expensive task, then that code will need to ensure that the job is never performed more than once (i.e. idempotence). Code that assures a background job is idempotent will look mechanical since it will generally depends on infrastructure underneath, e.g. redis. Your post hints at an approach that I endorse wholeheartedly, which is that entities should not _also_ be responsible for interoperating with the persistence layer. In systems built atop relational databases, this always ends up feeling awkward, as you have an in memory representation of the entity state (an ActiveRecord object, for instance), and you have a "disk" representation that is symmetrical. Thus, the indirection between the repository and the entity often feels cumbersome and pointless. In event sourced systems, which I work with, entity state is altered by writing events. It is queried by projecting events onto an entity representation (a data structure in memory). Here's the key difference -- _the repository interface is only used for reading entity state_ -- it's not a bidirectional interface for both reading and updating entities. The result is much nicer -- you don't end up with in-memory mocks pretending to be an entire database. Your repository substitute doesn't have to mimic write behavior! You can test code that writes events with a substitute writer, which simply records the events that were written (instead of writing events to an actual external database).
&gt; I'm talking about the drawbacks of using a relational storage model for persisted state. I work with systems every day that persist state without a relational database schema underneath. You haven't done anything of the sort. Using a SQL DB does not impose some new constraint in regards to the in-memory representation of data vs the persisted state of data. Regardless of the system used as soon as you read from a datastore you should immediately consider that data possibly stale. RDBMS at least give you tools to deal with this, transactions, row locks, etc. Most other systems give you _nothing_, it's up to your code, and more often then not that code is wrong. Unless you have a distributed system expert on your team, it's likely you have numerous failure modes in your system that will lead to inconsistent data. The worst part is that most people don't even realize it, they get a random report of weirdness and chock it up to a fluke in the system. No it's not a fluke, you haven't built a consistent system, i.e. it's history is not serializable, chance are if you were to run a validation pass across the system looking for data consistency, you'll find problems. &gt; And on a side note, I've seen systems that have so much transactional volume that they actually keep all their state in memory and replicate it across clusters. So even your snarky response wasn't exactly valid. We are not using the same definition of `transaction`. When I use that term I mean an atomic update that results in the system having a serializable history. 
This is cool, but a couple points of feedback: 1. put some info in the README, please. It's empty right now, and not very appealing to people who want to get more info on how it's built. 2. is it really necessary to pass the user/repo name to your app so that it can detect the ruby version for you? Seems not much more difficult to simply have users put the version inside the badge url, and remove the middleman. Haven't really tried it or looked through the source code, but isn't your solution potentially a bit slow to load the image, because it has to run a scraper on github first?
&gt; You haven't done anything of the sort. Huh? I was describing what I was talking about. &gt; Using a SQL DB does not impose some new constraint in regards to the in-memory representation of data vs the persisted state of data. A SQL database imposes the need for a translation layer between SQL and ruby, at the very least. &gt; Regardless of the system used as soon as you read from a datastore you should immediately consider that data possibly stale. This is true for the systems you've worked with. Not with event sourcing. Every stream is a consistency boundary. Mechanisms are there to prevent multiple actors from writing to an event stream simultaneously via optimistic locking. So "regardless of the system used" is not true. &gt; Unless you have a distributed system expert on your team, it's likely you have numerous failure modes in your system that will lead to inconsistent data. I teach recent boot camp grads this stuff. It's easy when you're not trying to solve the extremely complex problem of mapping mutable database rows to mutable ruby objects and keeping them in sync. &gt; No it's not a fluke, you haven't built a consistent system, i.e. it's history is not serializable, chance are if you were to run a validation pass across the system looking for data consistency, you'll find problems. Systems I build have affordances for reprocessing already messages safely, protecting the master data in the event that multiple processes contend for the same streams, and fully serialized history. In fact the history is _all_ that's serialized! &gt; We are not using the same definition of transaction. When I use that term I mean an atomic update that results in the system having a serializable history. "Transaction" has a meaning in both the logical view and the physical view of architecture. I'm speaking about it logically -- it can mean checking out a shopping cart, sending a notification, moving inventory, or any number of other logical operations. And my point still stands, very useful systems can be built without persisting state to disk. It's going to become more and more common since for many businesses, every business object they have can be easily stored in RAM without even approaching the limits of modern computers. Anyways, I do appreciate that you put a lot of thought into these discussions, even if I often find myself disagreeing deeply. Cheers!
Which means I actually need to change the container class for that? (where in for example in Dependency inversion - I can just supply a different classes outside of the class?
Ermm, Interesting. First time I see a client supply a stubbing library in the gem itself. Mostly people just extract all dependencies out, so the user of the class can supply with argument the mock class he want's to use. I'll poke deeper into that code, see how Amazon did it. Thanks!
Thanks! Yes, README for the code is on the list - as I say, it’s *very* new :). It’s a scraper primarily because I wanted to use it across about 30 repos straight off, so having to set them all up manually would be a pain. But also, if you have to update that version badge manually too... I think I’d forget, certainly. Better to use the canonical sources IMHO.
Can I ask why you're doing this? Or is it just an exercise? (edit: also, you've basically just reinvented [`SimpleDelegator`](https://ruby-doc.org/stdlib-2.2.1/libdoc/delegate/rdoc/SimpleDelegator.html)).
I am writing a SmartParams object for a Sinatra website. The params consist of SmartValue wrappers which carry the value itself, as well as side-band information. e.g., validation states of values params.contact.status = 'ACTIVE' params.contact.status.valid? =&gt; true params.contact.status = 'WHUT' params.contact.status.valid? =&gt; false params.contact.status.messages =&gt; ["must be ACTIVE or INACTIVE"] 
Sure, and SimpleDelegator has the same broken behavior.
Sorry I don't think there's a way to implement 'truthiness' yourself. `if` compiles to a `branchif` instruction, which uses `RTEST` https://github.com/ruby/ruby/blob/70af8d3c9ca2a46ef1f364783125a747d9426b2b/insns.def#L986 `RTEST` is actually `RB_TEST` https://github.com/ruby/ruby/blob/70af8d3c9ca2a46ef1f364783125a747d9426b2b/include/ruby/ruby.h#L450 `RB_TEST` literally just statically checks for `false` and `nil` - it will never call a method, user-defined or otherwise. https://github.com/ruby/ruby/blob/70af8d3c9ca2a46ef1f364783125a747d9426b2b/include/ruby/ruby.h#L448
"Broken" implies that that's not how it's supposed to work. It's well defined in Ruby that only `false` and `nil` evaluate as falsy in an conditional expression.
Yes, the ISO spec says 'only false and nil are falseish objects' and then goes on to clarify exactly what false and nil are.
It is just unfortunate that nil and false values are not completely, transparently, delegatable. I'll figure something out. 
I just [made a post](https://www.reddit.com/r/ruby/comments/6nicbo/kbsecret_a_ruby_password_manager_using_keybase/) to this subreddit that deals with situations like this! You can use KBSecret to create a fully encrypted session between `n` Keybase users, and then share your environment keys in a structured way: $ kbsecret new-session -l dev-team -r dev-team -u alice,bob,carol $ kbsecret new env foo-api Variable? FOO_API Value? ******** Now, the Keybase users alice, bob, and carol can each access the new API key securely: $ kbsecret env -s dev-team foo-api export FOO_API=pleasedonthackme
ActiveSupport's `blank?` and `present?` were implemented because falsiness is not overridable, so you can use that if you hit a dead end. Evan Phoenix asked Matz on stage at RubyConf one year if this would change and Matz flat-out said he didn't like the idea because it could lead to more confusing programs.
I'm not actually planning to re-write the whole gem, I just used it as example. What I'm trying to do is to write my own service-able gem. And I'm trying to understand if I should go with the module approach (with all the down side of using inheritance) or instead try to write it with composition - which has couple of issues I wrote above. I admin I never used meta programming before, creating methods on run-time that wrap the User methods looks like a nice idea. I have no problem keeping a clear pattern between the two. I will check both how method_name works The only real problem I could see if the above solution is that I still initializing the classes in the main objects (which is mostly a bad thing), and the fact that if one days I will have 10 functionality class, I'm going to have a lot of cases for that switch-case. Also, I'm wondering if that's a 'common' way of writing this kind of API? Thanks for the gem, I will try it once I'm home :) **EDIT:** Hello again saturnflyer, I was checking your blog post and the casting gem and learned new things in the process. Both will be useful, and I will be checking your blog more often now :) Thanks!
Like other commenters mentioned, truthiness is not something you can tweak in Ruby. But you can tweak falseness by overriding the ˋ!` method. In your case the only way to let Ruby know the truthiness of your wrapper is by having a message sent to it. You can use ˋ==` like you did with ˋif w == true`, or you can use ˋ!` with ˋif !!w`.
We've been using [Chamber](https://github.com/thekompanee/chamber) on several projects over the last three years. Secure; mature; well-maintained; plays well with but does not require Rails; easy and intuitive to work with. It's a solved problem.
Nice work, dude!
Have those team members actually written sites / APIs in both? Honest question, for some reason our industry values opinion over experience a lot of times. I have written in both. From my experience, you can't even compare Node to Rails because there is no real equivalent. Sails is closer to Rails in terms of functionality, but the most popular Node web framework is Express. And if you're using Express, get ready to rewrite a lot of functionality that you take for granted in a Rails app. Developer time is a real cost, so my question to your team would be, what's more important to your product, speed of development or performance of site? I'll also add, do you need performance with the same number of physical servers, because you can add another server to a Rails app to scale performance, at the cost of $$. But do the math on how much longer each of your developers spends building new features in relation to the cost of adding an additional server instance. Developers are actually quite expensive, and you should look at them as a cost as well. In my experience, I had to rewrite a lot of stuff in Express that Rails takes care of. A concrete example is that Express knows nothing about a database. You have to either manually handle connecting to a db or evaluate and choose an npm package to do so for you. That's developer time right there, which equals $$. Overall, I regret using Express at my last job for these reasons. Rails would have been fine for our use case. That may not be true for your team, and places like Netflix swear by Node. This is just my actual experience with it.
Also, when you say CMS for a TV channel, what does that mean? That's a lot of bandwidth in your stats, but is that for actual video streaming? In that case I would not recommend actual video streaming with Rails, but I would also not write a video streaming service, I would use AWS S3 and Cloudfront as that's what they're built for. Then your API is just for putting things in the right place. If videos are actually being uploaded, consider uploading to S3 directly from the browser. This will have no effect on your server and is more efficient. Sometimes performance concerns can be fixed with architecture decisions, like offloading intensive storage to a cloud storage service and using a CDN for content delivery. Edit: typo.
I was going to say that this was reminiscent of Embers 'pods' and then see that that was the inspiration. I personally like this since (in trivial cases) it aligns more closely with a domain context e.g. if you have the concept of Orders it forms a natural boundary. 
I did some research today about the difference between `define_method` and `method_missing` (was educational!) and because I'm going to use the API quite often, 'define_method' feels more efficient. However, I'm not sure that's possible as I'm doing another magic on top of that. Here's what works with `method_missing`. class Collaborators attr_reader :collaborators def initialize @collaborators = [ Twitter::REST::Tweets, Twitter::REST::Search ] end end class Twitter def initialize(client:, collaborators:) @client = client @collaborators = collaborators end def method_missing(method_name, *args, &amp;block) collaborators.each do |collaborator| if collaborator.respond_to?(method_name) collaborator.public_send(method_name, client: client, *args) end end end end Now, lets say I want to do it with `define_method`: class Twitter collaborators.each |collaborator| do collaborator.public_instance_methods(false).each do |method_name| define_method method_name do |*args| collaborator.public_send(__method__, client, *args) end end def initialize(client:, collaborators:) @client = client @collaborators = collaborators end end This won't work, and I'm guessing that's because during load-time, `@collaborators` does not exists yet (by the way, `client` is also not defined yet, so how `public_send` suppose to work on your original example above? Do I have to use `method_missing` because of that?
If someone is curious, you can try to do the same with Daru. I spent two hours and got stuck in date comparison. If someone wants to join me in this experiment - feel free to contact with me 
Oh, very nice. This makes a lot of sense as a layout, I like it :)
code academy then ruby monk then start using the books. Substitude learnrubythehardway in there if you'd like
I believe `Array#join` converts items using `#to_str` rather than `#to_s`. You could just `links.map(&amp;:to_s).join`.
DUDE THANK YOU FOR THIS!
If I'm being honest, I prefer the latter. While being slightly more verbose it's much more clear what all the parts are and won't require a special tool to be useful. 
Voting for "Vanilla" as you called it. Years of CoffeeScript put a bad taste in my mouth for "meta" languages. 
TOP kek
Kys
A friendly reminder to everyone: _please reserve downvotes for comments that detract from the discussion,_ not merely comments you disagree with. In practice, downvoting results in censorship — not only of the comment in question but the entire discussion subtree.
theodinproject.com
Came here to ask about this. Paging /u/yez, perhaps you should update your post? Also wondering whether factories might serve better than sprinkling in all those `let` statements...
these are just workarounds, but you could add an `attr_reader :obj` to the wrapper and use `if w.obj`, or define `def to_bool; !!@obj; end` (though you'd need to invoke it manually)
If I understand well, the queue in question live in CI servers. Wonder why the queues are not created at the startup of the CI server.
not super familiar with dependency injection, but from what i've seen from a couple blog posts, it's just that you instantiate the dependency elsewhere and pass it into initialize or something. In either case, the dependency needs to fulfill a contract, and if that involves http, that needs to be stubbed/mocked for unit tests. Whether one uses rspec 'allow' or does it by hand via 'define_singleton_method' or something, isn't it the same general concept?
The test file work queue lives in Knapsack Pro API server. Not on CI server. 
test code tends to be a little more rote than application code. However, to say that DRY should not be followed as strictly in tests is not a sustainable solution. It's pretty straightforward to reduce the lines of code in tests by creating helper methods. If the test code can't be abstracted, then maybe it should be standardized or refactored. Anyway, as for the topic of 'let' being "not used in every example", that's not really an issue since they are scoped by their describe/context block. Besides, one could always just use helper methods instead. 'let' is just syntactic sugar for defining a method within the describe/context block that caches it's result. 
I expected this to be things I disagree with such as the advice to create custom matchers all over the place, but all of these hints were quite informative.
I'd be interested to know how difficult this would be to do with just rack. It seems like each folder could be a microservice
I feel like having a microsorvice per resource may cause more harm that it could benefit -- but, if you were to use just rack, I'd just use more proper ruby-class-folder naming. So, `App::Resources::Somethings::Controller` or something to that effect. There is no autoloader in rack apps to dictate how you name things, so it's all up to you :-) You could technically use the same full class name for the path in rails, but it ends up causing a lot of hackery with the router, and then views still wouldn't work the same
thanks!
thanks!
yeah, the only snaffu I've run in to so far is the semantics around using services/operations in multiple related places -- like, lets say I have to controllers that are functionally different, but use the same model / serializer -- where does the serializer for that 'resource' live? and for 'concerns', this is what I'm doing with them: http://i.imgur.com/48W9zvH.png and then just imported like so: # frozen_string_literal: true class APIController &lt; ActionController::Base include Controllers::CurrentUser include Controllers::JsonApiErrors include Controllers::ModelRendering include Controllers::StrongParameters include Controllers::ErrorHandlers 
Just follow the [The Odin Project](https://www.theodinproject.com/).
Was using `SETNX` not possible here for some reason? Since you’re effectively just wanting to set a Redis key unless it’s already set, it seems like that would have a been a reasonable solution without requiring locks.
I have more complex logic related to creating multiple keys in redis to create test file work queue. 
You'll still need `let` statements with factories, you just have something like `let(:book) { create(:book) }` instead of manually initializing it. I keep my posts within 5-10 minutes of reading so I didn't include a lot of other tools like factories, but may write about them in the future. It is also true that `anything` can be harmful if not used correctly. However, as I state in the article, you can only use `anything` when you truly don't care about what is being passed in or out. I explicitly call out how to use an `instance_double` in some cases where you do care about what is happening. 
Does anyone have experience with this? Is it any good?
Yes, I just realized that after posting the question but thanks for your input. A little bit correction, `Array#join` use both `to_str` and `to_s` but it *prioritize* `to_str` over `to_s`.
Thanks for the write-up, I very rarely see people in the rails world thinking about these kind of races, though they are everywhere. Did you consider using locking/isolation mechanisms of your database to achieve the same thing? (That is, assuming you're using a db that provides them.)
I'm not sure what their use case is for this. The general best practice for structuring a Ruby project is as a gem, and the guide on Rubygems shows you how to create an executable. And I'm not sure why you would create an executable for a Rails app - it's a web app, the whole point is that it's accessible via internet instead of being run locally in your computer. This just seems like they tried to solve a problem that didn't actually exist.
You can run a ruby app without having Ruby installed on your machine?
You can if you create an executable of the app. I'm saying that you can already do that with just a couple of lines in your terminal - you don't need a special compiler for it.
This really isn't a compiler for Ruby as anyone reasonable would understand it, let alone an ahead-of-time compiler. It concatenates the standard Ruby interpreter with your program. I'm sure it's a useful tool but it's a bit much to call this a compiler.
If you have ruby and bundler installed on your system. And the right versions of both for your app, or a ruby version switcher, all of which tell you not recommended for production even though everyone uses them in production. But I wouldn't use it for my own Rails apps, but could see using it to deliver a ruby (or even Rails) app to a customer/client/non-developer user. I have had such needs before. 
I guess it's a "compiler" sort of by analogy with "asset compilation", which is also mostly just a name for putting things together. But yeah, I agree the name is potentially misleading. You could say "assemble" instead... oops, that word is already taken for a technical thing too which this _definitely_ isn't. We're running out of words. 
At first, I was wondering about it but then I thought that actually, I have a problem with locking access to data that I create in Redis DB so maybe let's do locking on Redis level. With redis-semaphore gem, I was able to give a unique name for the lock so I'm doing lock only for concurrent requests for particular CI build ID. I use PostgreSQL. Do you recommend any solution or gem where I could set a unique name for the lock? I don't want to lock row or table in Postgres DB because race condition is not related to data in Postgres. 
That's what gets me: Yes, you need to include a binary for Ruby if someone doesn't have one. I can see the need for that, but there are other gems for this. What makes this different?
Can you point me at some of the gems that allow you to bundle the Ruby interpreter with your application?
I believe Ocra does. There used to be ruby2exe as well. There's also rb2exe. I'm sure you can find other examples in a search. I think the trickiest thing is that these all support old versions, like 2.2 at best. I can't tell if the compiler here supports a more recent version.
Yea, Ruby monk should be after you get a little bit of experience with some other ultra beginner stuff
I can't wait to hear the rant against this.
AKA perl2exe
I think the correct way to interpret this is that Ruby allows periods in method names, but the Ruby lexer does not. If you can get it past the lexer, go nuts.
Why you create queue dynamically and not at the startup ?
It's generally called 'packaging'. 
A better word would be "packages".
There are ways to make it work :) def test․test puts 'huh' end =&gt; :test․test &gt; test․test huh 
Ah, there you go!
Would you like to recommend other gems for packaging you've had good experiences with?
Hey, I listed a few, and my concerns about them, below in the thread.
Traveling Ruby is probably the most used: https://github.com/phusion/traveling-ruby
The reasoning for this is that I tend to prefer Sinatra, and it would encourage interopabiliy between frameworks
This is actually pretty useful for packaging ruby programs for redistribution especially if the 3rd party does not have ruby installed. Similar to perl-packer I have used in the past. Glad it supports both Windows and Linux. 
knapsack_pro gem is independent of the CI provider. I don't have access to the internals of the CI providers. The knapsack_pro:queue:rspec rake task runs tests for RSpec on your CI provider and the rake task asks Knapsack Pro API for the subset of the test file list that should be executed on the CI node. The first request coming to the Knapsack Pro API initialize the work queue on Knapsack Pro API side. So basically a few CI nodes being part of the same CI build will start work at the same time and a few requests to Knapsack Pro API side might happen at the same time but only first request should initialize the work queue.
I'm really happy to see a project that improves the situation of distributing Ruby executables. I tend to sense a note of arrogance in Ruby community that assumes that every system comes with preinstalled Ruby and Rubygems and people are comfortable with both installing gems and managing ruby versions just to run an executable. If we, as a Ruby community want to make Ruby a versatile language used by anyone outside of Rails world, we need to put effort into making it easy to distribute libs including creating executables. For instance, the situation with Go language encourages development of utilities that are 'built once and run everywhere'. I want the same for Ruby so any project making it easier to package and distribute Ruby binaries is awesome in my books! Again thank you!
They are named Singleton Methods: https://codequizzes.wordpress.com/2014/05/06/ways-to-define-singleton-methods-in-ruby/
They call one of the use cases ip protection so it's weird they call it a compiler if there isn't a compile/obfuscate step. 
I think you've misunderstood the article. irb(main):001:0&gt; def test.test irb(main):002:1&gt; puts 'huh' irb(main):003:1&gt; end ArgumentError: wrong number of arguments (given 0, expected 2..3) from (irb):1:in `test' from (irb):1 from /opt/rubies/ruby-2.4.1/bin/irb:11:in `&lt;main&gt;'
I think you've mis-copied my code, that isn't technically a period :)
It seems like there are some concepts here that are mixed up. You're right that it won't work but it's not that the `@collaborators` does not exist yet (although true). It's that the `collaborators` collection is completely different from the `@collaborators` collection. There are 2 scopes you need to worry about here. When using `define_method` in the above code you are in the scope of the class, not the instance which receives the collection. class Twitter collaborators.each |collaborator| do The `collaborators` collection doesn't exist. You will see an error about calling `each on NilClass`. You are inside the scope of the class `Twitter` at this point, not the scope of an instance of that class. You could use `define_method` to forward a message to a collaborator instance that is later set class Wrapper define_method "something" do collaborator.public_send(....) end attr_reader :collaborator def initialize(collaborator) @collaborator = collaborator It's not clear to me what to suggest, however. But, I gave a presentation at a previous RubyConf related to using things like `method_missing` and `define_method`which might help: https://www.saturnflyer.com/blog/unleash-the-secrets-of-the-standard-library It might be better to begin writing up what code you _want_ to write and then get feedback when you've begun building it.
Why rant about it when we can simply bet on when your colleagues will murder you.
Oh, I see now. So `define_method` works on the class level and not the instance. In that case, I'm not sure I can use `define_method` for that specific design. I have couple of collaborator classes - which collaborator is being used is being decided when the class is being instanced. Therefore, I can't build dynamically the list of methods during load time - because I have no context to run `public_instance_methods(false).each do |method_name|` on. I'll use the basic `method_missing` way this time (and I even learned I should be defining `responsd_to_missing?` while doing the research around it) and will try to improve the design in the future when I'm more familiar with meta-programming. I will definitionally check your railConf presentation, thank you very much for you time, this has been educational for me :) By the way, as you mentioned I'm learning alone. I have no one around me that has experience in Ruby and can sit for a code-review with me. I prefer not to spam this reddit with questions. While I read books and do a lot of google research, sometimes you need help to connect it all. Is there a specific platform to get help in Ruby (not rails)? where the main purpose of the platform is to answer questions like so?
Try writing any Ruby application you want and then handing it to someone else and asking them to run it. I'll wait to see when you're done talking them through installing the correct Ruby (no not Ruby 1.8 that ships with CentOS!) and fumbling through bundler so they can run your app.
In your example the first one is the way of doing it in older Ruby versions and the second is the new syntax. I feel like Ruby keeps old syntax quite often in order to make version upgrades easier. Something that might be good and might be bad but it has been a key factor I think for not ending up with a Python 2 to 3 situation
As someone going the other direction, I found [this article](http://www.senktec.com/2013/09/one-way-to-do-it/) somewhat helpful.
Try googling for "What's new in Ruby X" with X being 1.9, 2.0, 2.1, 2.2, 2.3, and 2.4. That should give you some idea of the syntax changes.