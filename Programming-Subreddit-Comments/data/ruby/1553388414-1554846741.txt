Thought about just contributing to what‚Äôs available? 
The problem lies in the Rails team trying its hardest to maintain compatibility across most DB types. This is a very unapologetic implementation of Postgres features that may or may not be compatible with others. To date there are probably only 2-3 PG specific features when we combine the likes of ActiveModel. I have a slew of doubts that the team is willing to include such explicit API's not privy to other DB's.
Just out of curiosity, are you using NoSQL-like db or are you using SQL db but not PG (e.g. MS SQL, Oracle etc..)? If it's the later you should really take a look at PG and how it competes in the SQL world... _And I don't even mentioned MySQL in purpose..._
I don't look at all the details yet but I saw that it isn't targeted to Rails 6. And since Rails 6 is almost out, it would have been nice to be compatible with this version. After all, it's a new gem... Btw, as a PG user (and fan) I can only be thankful.. So thank you for the efforts..
I've got an open PR that is currently targeting Rails 6 beta. So far all things look good. Just waiting on the official release. https://github.com/GeorgeKaraszi/ActiveRecordExtended/pull/13
Great! I know that Rails 6 has some db implications like multiple databases support, but I don't know if it would affect your gem..
It might be relatively easy to change dbs for hobby or small projects (or even large but really well organized ones), but in real world, enterprise applications you're usually stuck with a legacy db and has no chance of changing it. 
It‚Äôs not daily but every week I have a departmental meeting via zoom that‚Äôs recorded. After it‚Äôs done a little Ruby script fires off and posts the video and meeting notes to our internal chat server. 
Oh, yes, Ruby is my lover in this field. If use Ruby for work a *lot*, automatically generating and sending tweets or toots or posts or other things of that nature. I use it to generate thumbnails of images and .pdf files and upload/organise them and the source files onto our server. I use it to organise and push files around our local space and build/update database entries. I use it to consolidate information from many different sources. I guess file-pushing in general is where it really shines for me, especially since speed of execution is rarely an issue in those contexts. I also use it to prototype image/video effect filters before rewriting in something that makes more sense once I have something I like. 
I once automated the daily checking of 1+meg nightly build log with a Ruby script once. That was an afternoon's work that saved me a lot of 'drudgery' ever since.
Support for 'exists' would be great. I use this gem right now: https://github.com/EugZol/where_exists
there is a book about automating the boring stuff with python. 
Why wait on the official release? Why not make an ARE release that passes CI on current Rails 6 beta?
I did. I wrote a tiny server that I call via alexa, it tells me when to hit the road to catch my tram to work. https://github.com/ahmgeek/tram_time
At work I automated deployment for prometheus recording rules..
Not really a daily task but: Sorting pictures / videos recorded with my wives smartphone over the last years by format and date. It took a few hours (I was using the chance to tell my wife about some ruby basics) and has been often used (and ofc slightly modified) since then.
&gt; I also use it to prototype image/video effect filters before rewriting in something that makes more sense once I have something I like. Can you talk more about this? I think this is way outside what people expect with Ruby, and I think many folks would find this interesting, even if it's just using Ruby to wrap something else. 
I‚Äôve created ruby scripts to: 1. Categorize stripe payments and create excel reports with charts. I do this every month and it helps with bookkeeping, has saved me a ton of time 2. Create a program that shows me my stock options and vesting schedule at my job. This more just for fun, as it allows me to play around with forecasting 3. Automatically scrape the websites for apartment complexes I was interested in to give me notifications when apartments I cared about became available Lots of other random stuff too. I love ruby because it‚Äôs just a pleasure to program in. Plan old ruby objects (POROs) are a lot of fun to make for me :)
I made a thing that checks a website and emails me twice a day if a job posting comes up (was for a specific company that I was trying to join a while back)
I made a script that updates my wallpaper every 10 mins and another that checks for spaces in upcoming group walks
I wrote a podcast downloader that gets around the Great firewall, well sort of.
I literally automate everything that can be automated through ruby. I don't get your comment though - you say that you have nothing that is repetitive that you wish to automate. How does this work? Do you create stuff manually rather than let the computer do it for you? "Someone has made an app" often does not lead to the way how YOU necessarily want to have things work.
It pretty much boils down to two reasons. Its a personal stance, and one that is shared by many top open source libraries. That I will only support official releases. The entire gem is based around monkey-patching a good amount of AR's and Arel's code bases. There's a lot of undocumented changes made to AR that never see the day of light in the common changelog's (ex: https://github.com/rails/rails/commit/187870db2fcc58aa0da8bb3f26711664fd5ed611#diff-8dd6f76819c529de42142c380617ac73 or any or all of the changes made to Arel https://github.com/rails/rails/commits/master/activerecord/lib/arel) Beta does not always mean there's not a lot of major changes afoot. So I'd rather not waste my time having to keep hunting down fixes that may or may not be present in the official release. At the end of the day, nothing is stopping you from adding this to your gemfile `gem "active_record_extended", git: "https://github.com/GeorgeKaraszi/ActiveRecordExtended/tree/feature/active_record_6"`
I use Chef and Munki to manage a bunch of iMacs! Chef's DLS is Ruby based and a lot of my automation work involves writing Ruby scripts or config files. That said I wouldn't consider myself proficient or anything, I spend a lot of time looking up how to do things! Definitely not a Rubyist who knows the standard library or anything like that.
Literally automating right now :D
I created a little script to email build urls to my phone so I can test apps at work. https://github.com/mjrode/build_url?files=1
Back then I used Ruby to automate compiling Cordova Android app (including jarsigning, building icon files on many different sizes, and backing up project files to Dropbox).
As a SRE and now as a DevOps engineer, I keep my sanity by automating daily or weekly tasks. That‚Äôs the basis of my job. My language of choice is definitely Ruby because I enjoy it and we‚Äôre a big rails shop. However, we‚Äôve adopted more and more services in Go, so I‚Äôm going to try picking that up for our kubernetes automations / related tasks.
Yeah, anything that talks to APIs I use Ruby for. The HTTParty gem is great for writing quick scripts to interact with RESTful APIs. I also like Ruby for doing quick proof of concept scripts to demonstrate to other developers how to interact with an API. The fact that it reads like human language and has a fast development cycle is great for this.
I have [this XKCD](https://xkcd.com/1205/) taped to my monitor to tell me when it's worth it to automate a task.
I do a lot of automation that involves background jobs on windows boxes. I found this post really useful.....[link Part1](http://abstractcoder.com/2013/07/18/create-a-windows-service-with-ruby-part-1.html) [link part 2](http://abstractcoder.com/2013/08/02/create-a-windows-service-with-ruby-part-2.html)
I'm interested in web scraping, would you mind sharing your script that scrape websites for apartment complexes? Sounds interesting!
You can't really write software to automate your life. But you can write software that automates other software that makes things much more efficient for you. For example, I have perl scripts to set up a WordPress site on my local machine I issue one command. I use command line tools and modules that let me modify the site quickly and easily. To push it out to my production server I issue another command. Similarly, if you have a job where you are just doing the same thing over and over on a computer, it's much better to write a script to take care of that repetitive task for you. Software is all about automating the automations to automated more automations. The more you can automate, the more time you can spend automating other things.
Yes indeed! Do you know the equivalent in ruby?
Just a tip for simple Ruby automation scripts: `bundler/inline` is your friend if you need to use external gems, it lets you download gems directly in your script: require 'bundler/inline' gemfile do source 'https://rubygems.org' gem 'hashie', '3.6' # etc end # rest of your script Just be aware that there is no lock file so absent a version specification it will either use the latest locally available gem or download the newest version. i.e. You should pretty much always specify the version you need. 
You are right there's no magic formula for error free / safe code. The SafeHash always creates a zero item on access (instead of returning `nil`when the key is missing / new). Try this with a "regular" hash: `hash['0x0000'].voted = true` (spoiler: it will crash because it returns `nil`).
I'm currently looking on all those options regarding automation through something like Chef, puppet etc. Do you got any good ressource on this matter?! I'm trying too look on all the options before commiting to any yet, so anything would be appreciated. Cheers
I use BitBar to control and monitor devices via SmartThings (home automation). I wrote the script entirely in Ruby. I can see a few temperatures in my home, if my wife's home or not, adjust lighting in my office, etc. with it. I also have a few local devices that I've written a little app for. It's a simple Rails front end, but it responds to simple GET requests from within the network, so I can send a request to my local server from, say, Shortcuts in iOS, which triggers things like lights and alarms and even my clock's screensaver. Much easier than implementing OAuth in Shortcuts, and much faster than working with IFTTT's delays. I also wrote a little app that searches chapterDB for movie titles. I'm working on converting a couple hundred DVDs to put on a Plex server, but I want as much accuracy and information as possible, so I get the format I need for Handbrake in one command. Lastly, I've automated some local development stuff. When I pull down a copy of the production database for a Rails app I work on (usually every few weeks or so), I have a little script that I run after importing it locally. It clears out the `delayed_jobs` table, sets an admin password, and updates the database with some application-specific things. I did all of that manually for a couple years, but I got fed up and just wrote it out one day. One shell command works a heck of a lot better.
I wrote InvoicePrinter gem to generate my invoices from command line: [https://github.com/strzibny/invoice\_printer](https://github.com/strzibny/invoice_printer) Right now I am trying to use HexaPDF to help me create preview/demo for my book: [https://vpsformakers.com](https://vpsformakers.com) Another example from last job would be a script that composes Blueprint API for me by replacing common error responses and fragments so I don't have to repeat myself too much.
Start ChefRally, it's a great resource! Not sure if Puppet or Ansible have similar programs as I don't use them.
I've got a couple: * Wrote a CLI app that reads my Google Calendar and spits out blocks of time that I'm *not* in meetings. Works well when people ask "When are you free tomorrow?" and then go through 4 or 5 email replies trying to figure out a time that works: [https://github.com/matthewvolk/amifree](https://github.com/matthewvolk/amifree) * I also just finished writing a Google Apps Script that pulls designer and developer hours quotes from Jira into a Google Sheet with their name, the hours quote, the planned start date, the due date, and the issue key. The Google Sheet then calculates their capacity for the week, on a scale from 30% - 100% (base 30% because we allocate 10% of designer/developer daily hours to emergencies, and 20% to meetings). I've noticed that nobody likes maintaining spreadsheets, and so I'm exploring this concept further. If I can automate how Google Sheet data is *entered* so that it is entered automatically from other existing project management tools, then Google Sheets can solely be for reporting.
Once a week I have to fill in a time sheet, get it signed and email it. I wrote a ruby script that generates a PDF fills in the times, dates and two signatures and emails it.
I wrote a small nightly script that fetches &amp; scrubs some data from various sources and then sends it through a data visualization tool to generate various reports (PDF's), and emails them to various distribution lists. If the data didn't need to be sanitized and massaged a bit, the visualization tool may have been able to do it natively (except for the emailing).
The thing I'm most thankful to have automated in my developer lifetime is a "dotfiles" bootstrapper that sets up my development environment on a new machine. Allows me to get up and running on a new Linux or macOS machine quickly with my default vim, zsh + oh my zsh, base16 themes for ST and Terminal, rpec settings, git settings, gem settings, rvm settings, tmux settings, irb settings, etc. Side note: I learned pretty early on that automation while awesome can be a "rathole" of sorts regarding wasting time. I worked with a bunch of former MS people that beat it into my head that it's not worth automating if you're not going to repeat it seven times, YMMV maybe it's five times or three times for you but the general concept has served me well over the years. 
Yup, DM'd you
My entire AWS deployment workflow is written in ruby and we have dozens of random ruby scripts for performing one-of tasks. We even write AWS lambdas in ruby to perform administrative activities.
Hm, I guess I've never come across any similar use case. Code like `hash['0x0000'].voted = true` feels really strange to me. Assigning values to a zero (null) instance seems like a nice way of shooting yourself in the foot üôÉ But, maybe I just haven't had the right kind of requirements for needing something like this. Anyway, thanks for sharing!
I'll take a look on that. Thanks for the tip
* For the last decade I've been using ruby for all file and text wrangling, and conversions that turns out to messy or fragile in "pure" bash, along with reporting, pdf creation and piping stuff between systems. I've looked into converting some of the file wrangling to go, but it didn't seem worth the effort. * Used ruby/rails for all early inhouse webapps. Next wave was written using ruby/sinatra/hanami, but for the last couple of years, I've been using go + standard library. * Completely stopped using python the summer ruby 1.8 was released. Still think python is great, but after having spent time converting all the python stuff, I realized I simply prefer ruby * Powershell - I love the concept of objects, and have a few scripts and heaps of oneliners in my history, but if I'm to describe PS, I'd sum it up as "butt ugly". And I don't just mean the syntax. Luckily, one of my staff has fallen in love with it, so I don't have to ;)
But will this work for an Atom feed or only RSS?
Tried that. Didn't work.
yeah, oops, `css("link").first.text` or `[0]` maybe, or `to_a.first` or `map { }.first` :D
Could you DM it to me too please
This looks great, I starred it for later ;)
I use golang these days but my job is automating things
I actually do not, not at all. if you find something I would love to know
Aren't you going to have to hunt down the fixes anyway though, to keep that PR passing? But I get it. Especially if it does add more work to maintenance, more work is something most of us can't afford. It just sometimes seems to me that when everyone is avoiding merging and/or releasing just on _principle_, it actually does give us all collectively more work. When you have multiple dependencies (including indirect dependencies), that might even work with Rails 6, but have gemspecs that don't allow it, and you're trying to figure out if _your_ dependent thing is ready for Rails 6... it's a big messy thing trying to figure it out, trying to figure out how to get your dependency tree in such a state that you can even _see_ if it works with Rails 6... which after all the point of Rails releasing betas. I'm not sure we're making it easy on ourselves. (I also wish Rails would get in the habit of not releasing major changes and features after the beta, of actually releasing a beta that's like "please test with this one, if it works with this one you should be good for final." If one thinks that working with a pre-release may tell you very little about predicting working with final release, then of course one doesn't want to bother spending time testing on the pre-release! I think Rails has gotten a lot better though). 
I completely agree. But given that, how is a PG specific gem a problem?
And me too, if you wouldn't mind.
I've looked at the XKCD image.... It does seem familiar. But for my case at least, I don't think it quite catches the advantage the Ruby automation script gave me: without the script I had to carefully check 2 and later on 3 then 4 log files every work day. With the script I wrote, it was just: check the log file with the script, in a jiffy *without* having to take much care. That's a crucial and important difference.
Both. 
Not sure if this is what you're looking for, but I have a Rails app to help with productivity. I've been Bullet Journaling for a little over a year now and eventually got into a routine where I split my days into two halves. The first half is "personal" todos which stay pretty static day to day. More times than not, it's completing a habit I'm trying to build (mine each day are Workout, Meditate, Outline/schedule the next day, Read, and do some personal development). The other half is work related and these are specific things that change day-to-day based on deliverables. So I built a small rails app that helps automate those daily journal entries. Moving it from analog to digital helps me keep metrics on how often I hit my goals for the habits I'm continually trying to improve and then compare that to my days overall productivity &amp; happiness.
It's not a problem at all, it's very good that such gems exist actually, because they are specialisations of the generic DB implementation that AR provides and help you get the most out of each engine. What I am talking about is only the naming, which at a first glance lead you to believe it's generic to all db engines, not only PG. 
That's why I've asked :D Pretty interesting and strange that something like this doesn't exist (or at least it is not publicly shared etc) . Cheers ;)
\&gt; You cannot post pictures to Instagram via the API. [https://stackoverflow.com/questions/18844706/how-to-post-pictures-to-instagram-using-api](https://stackoverflow.com/questions/18844706/how-to-post-pictures-to-instagram-using-api) I guess you could reverse-engineer their API, or much simpler, you can make a Capybara/Chromedriver controlled script (can even be headless) to do that for you.
My entire music library is saved in FLAC, which the stereo in my car will not read. I've created Ruby scripts using the [streamio-ffmpeg](https://rubygems.org/gems/streamio-ffmpeg/versions/2.0.0) gem to build playlists in MP3. 
Of course it's possible. They use an API to post it from their native apps, why couldn't you do it with Ruby? All because it's not documented doesn't mean it doesn't exist.
I've built mergebots and workflow tools (usually connecting API's or managing subprocesses). My life outside of work involves surprisingly little technology anymore. I wrote some scripts for helping me find bargain buys for my Magic TCG Commander games. I also started writing a database for cocktail recipes so I don't have to go through all my books
I was obsessing over crypto prices. Literally going from website to website refreshing, all day long. This was definitely pissing my wife off because mid-sentence I would be checking my phone. To keep the peace, I went ahead and wrote some shit in ruby to query the APIs, or scrape the sites to pull the data I was looking for. Then using config files, it would send me a text message if the prices were between my thresholds. I went further, and automated the trades, but thats a dangerous game. The API doesnt respond, or some kind of rounding error, or integer -&gt; float. I just didnt want to fuck up and lose it all. So I used that rather sparingly.
yeah only book I know of is that python book and Wicked Cool Shell scripts, which is of course shell scripting. 
do you have a blog or descript examples of how used ruby for this?
[Hash#merge](https://ruby-doc.org/core-2.2.0/Hash.html#method-i-merge) is the thing you seek. a = {one: 1, two: 2} #=&gt; {:one =&gt; 1, :two =&gt; 2} b = a.merge(one: 10, wow: :yep) #=&gt; {:one =&gt; 10, :two =&gt; 2, :wow =&gt; :yep} a # =&gt; {:one =&gt; 1, :two =&gt; 2}
you can also try http://ruby.bastardsbook.com/chapters/html-parsing/ it's a fun write-up on web scraping too
Argh! I spent hours Googling, but you can't find the function if you don't know what it's called :) Thanks a tonne.
Could you DM it to me too if it's not trouble? Thanks.
That sounds exacrly like what the image portrayed
Sometimes there no substitute for just reading through the documentation. 
Sure. I have a number of ruby scripts in my bin folder. I have a script that backs up my dot files to google drive. My shell prompt is mostly ruby scripted. And many more. 
merge is really useful, btw your javascript mutates a
Can you elaborate on the "constantly cleaning up after me in the background" part? What sorts of tasks does it do, and how do you typically keep them alive? Do you pop open a terminal instance, and just run the script in it? If so, how do you keep the script alive on reboot or things like that?
What do you do with them once formatted? Doesn't the native photo app do that already?
Configuring my systems everyday with Chef or Puppet. Also use it to deregister from Zabbix and Chef when a node is terminated in our cloud providers
Can you walk through your JIRA stuff a bit more? Are you a PjM or engineering manager? I'm curious because I don't know JIRA super well, but I'm kind of shocked that given some estimated time, JIRA can't handle calculating available capacity with the remainder after your pad. Does it really not do that?
I might have made it sound more involved than it actually is. A basic example wouldn't be much beyond pixel manipulation with something like ImageMagick via rmagick, so, say, getting an array of the pixel color values of an image, selecting a color range on which to operate, and doing something with those relevant pixels like color/space/time-shifting them, writing out a new image, and perhaps even calling ffmpeg through Ruby to disassemble and reassemble a video to do this frame by frame. It certainly does get more involved than that, but that is the basic principle. It's all very straightforward.
No, it's not really all that exciting or revolutionary. The file-pushing bit is about as inside Ruby's wheelhouse as anything can get, and as for the video filters thing, maybe the fact that I do it in Ruby is kind of novel, but it's really not all that impressive. If you have some specific question/s, though, I'll be glad to answer them for you.
One of the "secrets" is, when you are dealing with language core classes, or standard library, it is often more efficient to just look in the reference docs instead of trying to Google out the solution. While looking at, say, https://ruby-doc.org/core-2.6.1/Hash.html, you may accidentally spot several useful things about hashes, which will stay at the back of the head and could come to you when needed. 
I work on Mac, so I use launchd and launchctl for scheduling the scripts. The non-Mac version of this would be cron and crontab (at least on UNIX/-like systems, I have no idea on Windows). Apple likes to do things their own way, but launchd and launchctl are actually really nice, and I do prefer their way in this case, though there's nothing stopping one from doing it the cron way on that system either. Mac also has ways of watching folders and running a script whenever something enters that folder, or doing something with files that have been dropped into an app, but that is substantially more involved than just scheduling scripts as mentioned above. I highly recommend the wonderful Platypus app both for opening up different possibilities, and for looking at how it was achieved by that app in the first place, though looking at the code can be a bit overwhelming if you're only trying to see how one specific thing was accomplished.
Regular scripts: 1. For several weeks a year, I have to download rosters and compare them with the roster the week before to know who added/dropped out of sessions I oversee. Its simple but doing it by hand is a serious pain. I wrote a script that, given two rosters, gives me a list of who added and who dropped. Think of it like a customized diff+report. Boils a tedious 1 minute activity fraught with errors to a 0 second activity. 2. When reading or writing manuscripts, I need to know which research studies the manuscript cites most often (say, top 5 or top 10). I wrote a script that takes the text of a manuscript and produces a report of how frequently which citations occur. Granted, this only works on the manuscripts of a few journals that I mainly read. One day, I might get enthusiastic enough to handle any kind of reference format. Web servers 1. Made a web wrapper application for #2 from the scripts above. Hardly use it since CLI is so simple. 2. Wrote a web application that analyzes git repos to understand how much each participant in an open-source project has contributed to different areas of an application. Useful for certain discussions I have with dev teams. It boils a 10 minute manual scanning/reporting activity down to a few seconds. Thats most of the stuff that automates certain tasks for me. I've also written heavier stuff that does more serious work that eliminates certain commercial software/services I would otherwise have to pay dearly for.
Me, too, pretty please.
I'm really interested in this, particularly the bit concerning the Great Firewall. Would you mind elaborating?
Cool, and what sorts of things do you tidy up?
Just out of curiosity, why would you bother keeping FLAC files around if you're going to mangle them with MP3? Surely your car supports AIFF or WAV or AAC or something?
I have done a few and it is what got me started in programming. Please be gentle with the criticism, I was a young lad back then. &amp;#x200B; Home Automation System(python): [https://github.com/midorineko/rpi\_automation](https://github.com/midorineko/rpi_automation) Arduino Stuff (C++): [https://github.com/midorineko/arduino\_stuff](https://github.com/midorineko/arduino_stuff) Alexa Home Ruby (ruby): [https://github.com/midorineko/alexa-home-windows](https://github.com/midorineko/alexa-home-windows) 
In Ruby everything is an object, which means that you're normally not trying to find some random function (that you don't know the the name of) that does stuff. When you have an object and you wonder what you can do with it. Then you look up the documentation for the corresponding class and see what it responds to. `Hash` has quite a few methods, but I'm sure you would have found `merge` in no more than a few minutes. Just an advice for the next time üòÄ
Oh sorry, I indeed was being unclear here. She backups and archives the files on her computer. Then removes them from her phone to have more space. The sorting happens on the computer to have them in smaller folders (which makes opening and scrolling a lot easier on her oldish machine).
Ruby is amazing for task automation. If you do anything that resembles sitting at a computer pushing buttons then it can be automated. If what you do is not repetitive then either you are not an office worker (never seen an office worker that didn't do repetitive work) or more likely you aren't stepping back enough and seeing the bigger picture. 1. Identify workflows/processes/patterns. 2. Write it down. 3. Merge the processes that are just slight variations. 4. Write the code. 
It's a Ruby script to download podcasts but it runs on a digital ocean droplet outside of China. I then just rsync it to my laptop or phone inside China. It's really just security through obscurity rather than getting through the firewall.
Was semiautomatically banning dozens of people every day in my social network (that has no API for that) community using Selenium. Was sending pics to Tumblr queue (that involved using two own gems like [this one](https://github.com/nakilon/directlink)) and an own Tumblr API wrapper.
There is an [instagram-private-api](https://github.com/VicoErv/instagram-private-api) gem. I have tried it and it has some flaws. Some methods do not work properly, like getting a user's followers. That said, it's a port of this [pyhton implementation](https://github.com/ping/instagram_private_api). I think the python version is better implemented and [documented](https://instagram-private-api.readthedocs.io/en/latest/). If you know a bit of python, you might be better of using this implementation.
nice, I did similar things before until I found terraform. Yet for some one off use cases it's still handy. &amp;#x200B; I am curious: how do you package your ruby lambdas ?
after years using bash/sh for many small things I moved to Ruby as my main scripting and automation language. The main reason is the big set of libraries available out there with gems to do everything, usually it's all around the following ones : \- File, Dir and FileUtils are big big friends \- IO is a good one to have in mind when doing quick stuff \- system and its cousins to run other cli tools and commands ([https://mentalized.net/journal/2010/03/08/5-ways-to-run-commands-from-ruby/](https://mentalized.net/journal/2010/03/08/5-ways-to-run-commands-from-ruby/)) \- while HttpParty is nice I found Unirest ( [http://unirest.io/ruby.html](http://unirest.io/ruby.html) ) which is smoother in my opinion &amp;#x200B; and while "scripts" might be just a few lines, the ability to use classes and proper object oriented design when you go beyond "just that one thing" is also very pleasant. &amp;#x200B; finally, if one needs parameters handling and something nicer than rake ... Thor is there ([http://whatisthor.com/](http://whatisthor.com/)). &amp;#x200B; My classic use case is to go through files and directories to rename, convert, send them. In some cases it's closer to reading data through an API and do something with it.
How have I never known of this? Very cool!
I automate very little that I do repetitively, because I don't do much in life that's that repetitive. That said, being able to code has allowed me to perform a lot of one-off tasks that would be unbearably boring and repetitive to do, like mass-tagging photos or MP3s in a collection of gigabytes, sorting and filtering spreadsheets full of information that require logic too complicated to be easily expressed in Excel, etc , etc.
#chef üòâ
I wrote a Ruby script that automates regular backup creation. (Though arguably the thing that automates it is the cronfile that calls the script, not the script itself.)
Not day to day but I use Ruby to create my monthly project based timesheets. It saves me a few hours of cumbersome manual work each month. 
Perhaps JavaScript also has a similar functionality with a similar name; in ruby we have .merge() and .update(). I think at the least one of those names is probably commonly used in other languages too.
I found SO to be even better for the most part, which I can find through Google. SO often has examples AND explanations, and the official documentation in ruby is ... well, it's not bad, and it is not great, it's ok but I totally get when people ask for things on SO or reddit or elsewhere.
&gt; but I'm sure you would have found merge in no more than &gt; a few minutes. You possibly over-estimate people's ability to find something they are looking for. I think it is perfectly fine to ask. If people don't want to answer then they are not FORCED to have to answer. In general it would be better to simply answer the question; or not answer it but to not give peculiar "advice" how to "find stuff on your own". That isn't actually helpful at all.
For sure!
Oooooh FTPS... I've never done this with Ruby but can you post error messages? &gt; The connection works via a ftp client for mac, Last I checked default Mac ftp client does not support ftps. Is this no longer the case? 
I do listen to music at home as well, and I have another older car that supports WAV and I do covert my music to WAV for that car. That's why I keep FLAC. Unfortunately, my current daily driver only supports MP3. I have not tried AIFF or AAC, but WAV definitely does not work. The standard head unit that comes with Subarus nowadays is trash, and I will replace it when the warranty expires. Hopefully with one that supports FLAC.
Given that the title is about an **existing** Rails API, I thought there might be some novel learnings here, but the very first step from the article is: The very first thing you do is &gt; Step 1 ‚Äî Create a Rails 5 App This is no different from the dozens of existing tutorials on Docker+Rails that tell you how to dockerize a brand new `rails new` app.
These parts of Ruby feels abandoned, sadly. It is the same with SFTP and SSH.
I was just trying to give advice about how to understand what to look for and where to find it. Perhaps this time the only thing interesting was merge. But I don't think it hurts to try to help out and explaining how to approach this in the future. Of course it's ok to ask questions. And thankfully people in the ruby community are more than happy to help out.
I reread my first reply and I realize it might have sounded like I was being a dick and tried to say what to do/ not to do. That was not my intention ‚òπÔ∏è
I think it's just to follow along, as the 2nd sentence of that section is "If you already have an app you can skip this section." But I'll add my own disapointment: it's not evident whether this is "Docker for development" or "Docker for production". It implies it given `tty` and stdin_open`, but doesn't go through running tests (like config for system tests) or some of the gotchas of developing inside of Docker. 
Sure! Happy to elaborate. In all fairness to Jira, I don't know Jira too well either. I'm a PjM at a very small development agency, and we just adopted it as our project management tool this past month. I know that Jira can calculate available capacity with tools like Portfolio from Atlassian, as well as a few other plugins like ActivityTimeline Planner, but in terms of just adding up the resource's hours and calculating weekly capacity based on their commitments, I've not found anything that works for me. I'm very open to suggestions, as resource planning is something my team is struggling with at the moment. Currently, my spreadsheet pulls in all tasks assigned to a resource into Google Sheets. Then, I calculate the number of net working days between today and the due date for each task. I then divide the hours quote by that number of working days to figure out how much time needs to be spent per day. This gives me a number like "0.4" hours. I convert this to minutes by multiplying by 60, and then find the percent of an 8 hour day that those minutes take up. A task quoted at 2 hours, due in 5 business days will take 24 minutes, or 5% of a resource's 8 hour day for the next 5 days. It looks like this: [https://imgur.com/Cc03tIp](https://imgur.com/Cc03tIp) But I've hidden some of the other calculations: [https://imgur.com/GqjiZT1](https://imgur.com/GqjiZT1) Like I said, very open to suggestions here. JQL (Jira Query Language) is the closest thing I've found to giving me the data that I need, but it doesn't help in terms of telling me how to best allocate time. 
&gt; with DoubleBagFTPS I'm getting SSL errors and nil class errors. What errors do you get? You can [configure SSL options](https://github.com/bnix/double-bag-ftps/blob/master/lib/double_bag_ftps.rb#L206), or perhaps toggle ftps mode between implicit or explicit.
It might be helpful to get this working from cURL so you know exactly what it takes, which might help guide your SSL options in Ruby.
I'm using a client called Transmit. I also just fixed it (somehow) but going back to the Net::FTP, and doing each bit of the connect slowly, + removing my monkey patch, eek.
At the time is was just saying the the value was nil where it expected OpenSSL/TLS/etc. It was a weird one. I've fixed it now by going to Net::FTP and just going through it carefully.
To be fair everyone thinks I'm crazy for needing FTP again but some third parties just have it that way. It's abandoned kind of within reason. Hopefully I never have to do it again.
Yeah tried that and made some progress. Fixed it in the end by going back to Net::FTP and going through each step slowly. I think the docs weren't clear the first time around so I looked up the source code for ftp.rb which is much better.
I think that's awesome, and I think people would still love to see more about that Ruby can give people access to tools that they would otherwise not interact with because of complexity. If people have used *magik, it is almost always just to automate cropping or sizing. I think that it would be cool to see more people showing off things like "Look, you can hack your colors too, and Ruby makes it super easy!" (I for one have never seen someone proclaim this, and would love to see it.) Thanks for sharing!
People love to be inspired! Especially when it's something that turns out to be easy as well!
Aside from not giving more information than you can find a dozen places elsewhere, this encourages you to embed secrets in your docker compose yml file which is *really* stupid.
Go through the service called buffer.com. They have a good ruby gem. 
According to the article, one of the requirements is: &gt; The table must have unique constraints on relevant columns And then they show this migration: &gt;&gt; class CreateUsers &lt; ActiveRecord::Migration[6.0] &gt;&gt; def change &gt;&gt; create_table :users do |t| &gt;&gt; t.string :name, index: { unique: true } &gt;&gt; &gt;&gt; t.timestamps &gt;&gt; end &gt;&gt; end &gt;&gt; end Is this actually going to create a Postgres native constraint? Because I've been wishing I could do that in a migration for years.
Using this: https://github.com/lambci/lambci I build the package within the docker container and pull it out .
Looks pretty normal to me. I‚Äôve been adding native Postgres index constraints via migrations for a few years now. 
At least on Rails 5.2.2.1 this migration: class CreateUsers &lt; ActiveRecord::Migration[5.2] def change create_table :users do |t| t.string :name, index: { unique: true } t.timestamps end end end Creates two indexes, one for the primary key and one unique index, as expected: railstest_dev=# SELECT indexname,indexdef FROM pg_indexes WHERE tablename = 'users'; indexname | indexdef ---------------------+---------------------------------------------------------------------------- users_pkey | CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id) index_users_on_name | CREATE UNIQUE INDEX index_users_on_name ON public.users USING btree (name) (2 rows) And one constraint, which is for the primary key, which is auto-created: railstest_dev=# SELECT conname FROM pg_constraint WHERE conrelid = (SELECT oid FROM pg_class WHERE relname LIKE 'users'); conname ------------ users_pkey (1 row) At least in Postgres, unique constraints and unique indexes are different, but related things. Creating a unique constraint will also create a unique index. The reverse is not true. I have some cases where I require a unique *constraint*, which as far as I'm aware you cannot currently achieve without executing custom SQL. I want a migration that can do this: ALTER TABLE users ADD CONSTRAINT constrain_users_on_name UNIQUE (name); as opposed to this: CREATE UNIQUE INDEX "index_users_on_name" ON "users" ("name")
Ah gotcha, makes sense. 
vscode is not an ide. I recomand rubymine. https://www.jetbrains.com/ruby/
Is there a free IDE option? I am not serious enough to justify spending money on this just yet.
From the error, it looks like you don‚Äôt have Ruby installed on that machine, if you‚Äôre 100% certain that you have, try restarting VSCode. If that still doesn‚Äôt work, a reboot may resolve the issue.
You either don‚Äôt have ruby installed, it‚Äôs not in your environment PATH variable or VSCode doesn‚Äôt know where to find ruby. The error is saying that ruby can‚Äôt be found.
you can use for 30 days, they offer some free licence under some conditions. 
I'm a Ruby newbie and started using Atom and Sinatra. Being new, gives me the opportunity to focus on the language rather than the file menu and interface of a larger IDE like Rubymine, VSCode or Sublime text
I didn't know I had to install it separately, thanks! Fixed now.
I didn't know I had to install it separately, thanks! Fixed now.
That is an overkill of an advice for a person who doesn't understand common errors yet.
Just use normal windows command line to run Ruby. Not being able to run ruby directly from your editor is not a deal breaker in learning to program. 
You can try [https://rubyinstaller.org/](https://rubyinstaller.org/)
sorry. my fault, I was just seeing the image and just guessing.
if you are using windows, you should try install ruby using windows linux subsystem if that does not work, try rubyinstaller. But, ruby on windows is not such an amazing trip. I dont know your level, but also you could try a virtual machine. 
Oof. That auto incrementing issue is pretty bad. Find or create seems better still imo.
Issue resolved. Thanks for the help!
Ruby on windows actually works quite ok; I tested it recently on another machine. Windows as an operating system is a total nightmare though. Things that are so trivial on Linux really are just very difficult. That other machine did not even allow for installation of WSL so I was stuck using the ruby one click installer. Setting up cygwin was too much of a hassle for me there...
Im confused? &amp;#x200B; I already use create\_or\_find\_by when seeding, is this something different I'm not thinking of?
For what it‚Äôs worth, RubyInstaller uses MSYS2 to install Ruby on Windows nowadays. 
Revolutionary 
Yes, at some point it started doing that! 
In what cases do you want a unique index but not a unique constraint? I think the existence of the unique index alone _will_ make postgres refuse to let you insert/update data that violates it--I think I've seen that happen. So what does adding a constraint to give you? (It makes sense to me that creating a unique constraint forces the creation of a unique index... which I think is what you are saying too... because if it didn't you'd be forcing postgres to enforce the constraint on every data change without using an index to do it, which sounds like bad news). 
Hmm, that is interesting. I think even without Rails supporting it, I've coded up the equivalent semantics to "create or find" manually. That is, create, if you get a constraint violation, find instead. I'm pretty sure my code has been subject to that pk exhaustion issue too... but I don't think I've ever run into it. I guess it would require a _lot_ of second-fork `create_or_find` calls... and we generally use it when we _expect_ the "create" to _usually_ succeed... and Rails default to `bigint` makes it less likely to actually exhaust the keyspace too, that's a big keyspace. It would be maybe good for Rails to take care of it, if Rails is providing the functionality, but I'm not sure how bad it will actually be in practice. Inserts fail sometimes -- even without Rails `create_or_find`. Apparently they usually (always?) lead to skipped auto-incremented pks when they do? And not just using ActiveRecord? And this is not something most of us have thought about before, because it generally does not matter. 
Odd. Are you thinking of the already existing `find_or_create_by`? (Note difference between that and `create_or_find-by`). Otherwise, are you sure you aren't using some gem or local code that gives you this method? It doesn't look like it exists in Rails 5.2 to me.... You could do a `Model.method(:create_or_find_by).source_location` in the console to see where it's coming from. I don't _think_ it's gonna be ActiveRecord code. 
&gt; This is no different from the dozens of existing tutorials on Docker+Rails that tell you how to dockerize a brand new rails new app, which is a trivial task. The hard part is migrating a large existing app into Docker. I don't really see the difference, the only extra 'step' for the large app is likely figuring out some extra system dependencies, otherwise the 'size' of the app is rather immaterial. 
I don't think I've ever seen a `docker-compose.yml` file used for anything other than development so having secrets in there doesn't really matter, not even sure why they are bothering using a password for PG in development 
Why try install ruby on WSL?
So whenever I need to find a stupid method name, I only have to ask rails! (I actually refer to the variant with ! - I dislike methods ending with ! in general, but it is in particular egregious when it is a very long name. Sinatra has a method called .run and another method called .run! - I don't like that either :( ).
THEY EVEN ADDED A '!' TO THE METHOD NAME!!!
I'm saying I *do* want the constraint. Rails, at least up to the latest stable, creates a unique index directly without creating the constraint.
I like bang methods. I prefer scheme's convention of using it for mutations (like Ruby) than Rails' for things that raise exceptions.
&gt; PostgreSQL automatically creates a unique index when a unique constraint or primary key is defined for a table. https://www.postgresql.org/docs/9.4/indexes-unique.html
Your Javascript is actually not correct. If you don't want to mutate `a` then it should be `let b = Object.assign({}, a, { b: 9 })`, I wouldn't really call this 'proper', it's ugly as hell. For what it's worth, this should also really be written with Map rather than using an Object as a Map: let a = new Map([ ['a', 1], ['b', 2], ['c', 3] ]) let b = new Map(a) b.set('b', 9) Which is unfortunately, even uglier. 
yeah, sorry I was talking about two things too. What does having the constraint additionally do for you, why do you want the constraint in addition to the index?
o wait......... lol wow
Just install Ubuntu from the windows app store. It runs on WSL and works much better 
This was literally factored out of ActiveRecord circa rails 4. wth? Sounds to me like someone snuck it back in as a personal todo or something. weird
Interesting. I'm not a PjM, so may not be as knowledgeble here. Sounds like you found a solution that works for you. Plus, you can have more control over adding modifiers to weight various people's estimates by their accuracy, add pads, etc.
That's right, I'd like to clean up the code a bit because I'm sure there are more graceful ways to play with the google app script API. I'm thinking I could move some of the heavy lifting to the script to simplify the spreadsheet, as it will be mainly for reporting and most people won't have any need to filter the data that's available to see. The code is fairly simple right now, I'll post it on GH when I have a chance to take out the secret keys. Open to suggestions!
This is just to follow along. Also, you continue to second part of that article to see how to use delayed\_job and cronjob with docker-compose in dev.
docker-compose yml is only used in development mode, so you can put your secrets which will be used in dev env. When you go to production then you will use env variables. Article to go to production will come soon.
This is just to show how you can put env variables inside of docker-compose.yml. 
`def foo(bar='baz')` means optional parameter, if you use `foo` withour args then bar will be "baz" and if you do `foo("foobar")` then bar will be "foobar" I haven't seen symbol in function params but I think it should be the same as without the `:` ? Not sure about that one
They‚Äôre completely different, AFAIK With ‚Äúfoo(a=1)‚Äù there‚Äôs a default named parameter ‚Äúa‚Äù and you can call function ‚Äúfoo‚Äù without any parameter When you‚Äôre using ‚Äúfoo(:a)‚Äù it requires you to pass a keyword argument (sometimes hash will do) I‚Äôve seen a great article on Ruby method arguments, but I couldn‚Äôt find it now :( 
You might want to change the code runner extensions settings to run in terminal, as you will be unable to use irb/give input with the default settings as the code is running in the ‚Äúoutput‚Äù tab. Not relevant to your current problem, but it might come up a bit later. 
I didn't think they were used together but just wanted to ask about both in want post.
Don't use Hanami so I don't have a direct response for you. But I'm curious what your objectives are? Are you trying to not have any persistence or external data source, and just do pure logical/domain modeling? Or are you trying to implement your own persistence layer?
omg .. now I remember. rofl, I actually used optional params a few weeks ago. its because I'm getting distracted with stupid JS right now and it's hogging all my focus ATM. 
Came here to ask that. I did [my own project](https://github.com/jdickey/crypt_ident/) a few weeks ago where the objective was to prove that unit tests of my authentication Gem had *no* dependencies on or interactions with the persistence layer beyond injecting a `Repository` that implemented a few common methods (like `#all`). That way, if anyone wants to use it with something other than `Hanami::Model` (like Sequel or even *cough*ActiveRecord*cough*), it should Just Work‚Ñ¢. If you're not trying to prove that your Gem is persistence-layer-agnostic, I don't understand why you'd bother. I certainly don't understand why you'd do an `apps/web` application that way; it's easy (and safe) enough to just leave the default database setup in place, do the requisite create/migrate of nothing, and otherwise ignore that persistence is even there. Not including `hanami-model` in your `Gemfile` once the initial app is generated *should* eliminate most of that anyway, when using Hanami's generators for things like actions. OP, what am I missing?
Not OP, but since you're using Hanami, any idea if Hanami 2.0 will basically use ROM.rb for all persistence? I thought I read that it was an intended goal of Hanami 2.0, ROM.rb 4.0 (5.0?) and dry.rb 1.0 to effectively be compatible with one another. If so, that will solve the headaches of non-DB persistence (which might be OP's dilemma), since ROM.rb has adaptors for flat files and more.
Alright, essentially, I come from pure PHP running as CGI scripts, and I'm basically unfamiliar with most, if not all, the function of frameworks -- I never even used Laravel or anything. My issue is that: I can code Ruby, I can code a host of other languages. I am REALLY good with SQL and have VERY complex SQL queries to run on a database that already exists. I don't need, nor desire, an ORM to handle the database for me, b/c my objects already do that with class-level subrouting. It'd probably make querying it far more complicated. In fact, my main interest is an application that does its own error handling, so it doesn't crash itself, has a session system, maybe has a few extra security/authentication features, and can do templating relatively easily. Heck, I even wrote my own SPA "pretty-URL" routers; I look at the way these frameworks do it, and I'm not even sure what's going on with them -- As above, I'm not even certain I need the routing functionality that comes with this stuff, since it'd complicate my class-level subrouting systems. I know Hanami says it's supposed to be designed so that the pieces can be used either together or on their own, so I'm trying to minimize the inclusion of unused components that'd pollute my codespace.
I guess that's a fair enough point. I could just ignore it. I suppose that's the easiest way to handle it.
AFAIK from listening closely but not being in the core team, ROM/dry-rb inegration are *the* marquee features for 2.0. 2.0 is also going to double down on dependency injection using [`dry-container`](https://dry-rb.org/gems/dry-container/) and [`dry-auto_inject`](https://dry-rb.org/gems/dry-auto_inject/). I think [this](https://discourse.hanamirb.org/t/hanami-2-0-ideas/306/2) is still the best summary of what "Hanami 2.0" is supposed to be, two years(!) on. It's going to be interesting, to put it mildly. 2.0.0alpha1 [has been released](https://hanamirb.org/blog/2019/01/30/announcing-hanami-200alpha1.html), but my Sisyphean backlog has thus far prevented me from even seriously poking at it. Oh, and by the way: Hanami 1.*x* uses ROM; it just uses an ancient version of ROM (3.3.3, and 4.2.1 is current as I write this). ROM 5 should be released coincident with Hanami 2, and that should open lots of new possibilities.
A keyword argument would be `def foo(a:)` which would be called like: `foo(a: 'some value')`. `foo(:a)` is just an invocation of the function foo with the symbol `:a` as the sole parameter.
There's instructions here https://guides.hanamirb.org/models/use-your-own-orm/ maybe you can write a script which does this, it's pretty formulaic. Then you can add your own SQL adapter, to issue the plain queries. Just a couple other points: 1. You might consider using Sinatra as well, it's much more minimal in the sense that there is no base generator and you start just by making a single file. Of course there are plugins for all the usual webserver stuff like sessions, auth and whatnot. 2. I don't think ORMs are as intrusive as you make them out to be, all the ones I've seen have a plain "issue query" function, all you're getting on top of that is bonus functionality.
&gt; I want to lean towards more official documentation to avoid confusion Sadly in ruby blogs often contain better documentation than the official documentation. :\ 
May I suggest dropping Hanami and using a simpler microframework like Roda? If you‚Äôre like me and don‚Äôt want hand holding on routing and persistence decisions, then i think you‚Äôll find yourself fighting Hanami on many more issues down the line. Also, Roda is as fast and elegant as an unopinionated framework on Rack can get. I couple it with Sequel for ORM when i need it. FWIW, i‚Äôve been super fussy for many years about how i like structuring things. For now, I follow best practices like DDD and adopt best-of-breed tools like those in DryRb and Trailblazer. But over time i find myself recreating something like Hanami. I‚Äôll probably swallow my pride and just use Hanami in the not so distant future.
Did you consider using Sinatra for your project? Also I knew a Russian guy developing Hanami -- absolute toxic ignorant jerk.
Your limited experience is not a reason to throw good security practices out the window. 
Just one idea but, If really don't need the framework and you want your web server to be some kind of simple interface with the database, are you sure that you want to use Ruby at all? I mean, you are taking the worst characteristics of Ruby (slow serialisation and not being really good at asynchronous code), and throwing away the best part, that it's the expressiveness and flexibility that allow developers to create beautiful DSLs. 
&gt; I want to lean towards more official documentation to avoid confusion [https://docs.ruby-lang.org/en/2.6.0/syntax/methods_rdoc.html#label-Arguments](https://docs.ruby-lang.org/en/2.6.0/syntax/methods_rdoc.html#label-Arguments)
Javascript also has optional params with the same syntax for setting the default. 
That's great, but if you only want to check a specific error, why not also having `valid?` accept an argument to limit what validations it runs? The way Rails does now, if I have 2 `uniqueness` validations and only want the error message for one of them, it will still query the DB twice to check both validations. One use case for what I'm talking about is on-demand form validation, like when you want to use AJAX to check if a specific username is already taken, but you don't care (at this point) if other stuff is valid or not. You can always query the DB manually, but it would be so much cleaner to do something like: ``` User.new(username: params[:username]).valid?(:username) ```
The `foo(:a)` expression passes the symbol `:a` to foo as its first parameter. I suggest reading official documentation on symbols, as there is a lot of misinformation in userland. https://ruby-doc.com/core/Symbol.html
Seems like it would depend on which Edition you got. Also worth to notice that Ruby didn't change that much after 1.9.3 (released 4.5 years ago) (Rails changes a lot much more often).
 def foo(a) Defines a method with one argument, which you've called `a`. You would call it like `foo("some arg")` def foo(a = "default value") Defines a method with one argument, which you have called `a`, but gives it a _default value_, in this case the string `"default_value"`. You can call it like: foo("some string") But you can also call it like: foo With no argument. In which case inside the method, the value of `a` will be the default value you defined when you specified the arguments in the method definition: the string `"default_value"`. foo(:something) Is nothing but calling the method `foo`, with a single argument, `:something`. `:something` is _not_ a variable, it's _not_ the local variable `something` with a funny `:` operator in front of it. Rather, `:something` is a ruby "symbol". A colon followed by a name is always a symbol literal when you see it in ruby. Symbols are kind of like immutable strings, or can be considered "tokens". Or... symbols. Just a unique value, `:something`. 
Do you know what version of Ruby this version applies to? Is the book still relevant?
I think you can already do what you are saying. I've done something like: `account.valid?(:custom_users_validation)` `validates_associated :users, on: :custom_users_validation`
thanks
Thank you!
Hmm that should work, yeah, but it's still a lot of extra code and IMO a misuse of the feature. The main idea of validating a single attribute is allow the model to have multiple validations on it and execute them all for that specific attribute. So let's go back to the `:username` column. Maybe you want to validate that a username is unique, while also having at least 4 characters in length, and it also can only contain a specific set of characters, etc. That's already 3 separate validations. If I were to use your solution I'd need to add `on: :custom_users_validation` on all 3 validations, which would yield an overly complex code for what I'm trying to achieve.
I think you'd just use a custom `validates` method at that point with the `on:` if that would work. But its a bit clunkier than it could be, for sure. 
It should still be fine for 2.6.2 and later, as long as you keep in mind some of the changes (although not all changes are that important really, but there are some syntax changes ... keyword arguments for example, I don't recall them on ruby 2.0.0).
I don't really get the logic of making background job one-liners. A Sidekiq job is a PORO. You can `new` it, inject dependencies in it, and call it to perform its logic. What's the purpose of yet another service layer underneath it? class SomeJob include Sidekiq::Worker def perform(args) end end def test_somejob job = SomeJob.new job.perform(args) # assert results end
&gt; I haven't seen symbol in function params It's calling `foo` with the symbol as an argument.
First I meant when defining and second I havent seen this use when defining the function with a symbol parameter that's not a hash
fwiw, that can be two validations if you make the format `/[a-z]{4,}/`
In the case of Sidekiq in particular, I think Sidekiq is probably better-designed than some other background job libraries in this sense, and I would have to agree with what you say. It's been a while for me but my recollection is that it's not nearly as easy to instantiate e.g. a Resque job for testing as it apparently is to instantiate a Sidekiq job. To be honest, I think I might have been mixing up Sidekiq and Resque when I was thinking about this post. I do want to address your question of "What's the purpose of yet another service layer underneath it?" If the background job code is pretty small and easily understandable, I would agree that there's no point. On the other hand, if the background job contains a lot of code (like a lot of background jobs I've seen) then the value of refactoring the job to one or more POROs is the same as the value of refactoring any big, structureless class or method into some POROs. Thanks for bringing this up - I think my post could be improved if I address these things in it.
Okay, I actually ended up completely rewriting my post in response to this. I even changed the title. Turns out I didn't do a good job on my first try of saying what I was trying to say.
hold up a moment, wouldn‚Äôt this work swimmingly well for aws lambda, travelling ruby, or any other deployment solution where dependencies are difficult to setup?
I've used it on Lambda for small stuff but I wouldn't recommend it for anything serious. Lambda will reboot your process whenever it wants to and the disk state will be wiped so you'd end up re-installing gems a lot and hurt your worst case response time. You also usually want transitive dependency locking for more stuff in a production line of fire. It's most useful when you're writing CLI tools or small ETL/automation scripts where you just need a couple gems. It's pretty easy to install gems in your deployment archive for lambda anyway. 
queue: add to the end of the list (e.g. like a queue at your favorite government office, first arrived first served) stack: add to the top of the list (like a stack of sheets of papers, last one you added if the first one that is gonna get picked up)
I've had that sort of thing asked in an interview. How would you implement a linked list, etc. In Ruby, if I wanted something that acted as a stack I'd use an array but wrap it: class Stack attr_reader :ary def initialize(ary = []) @ary = ary end def top ary.last end def push(obj) ary.push end def pop ary.pop end end # or... require 'forwardable' class Stack &lt; SimpleDelegator def top last end end # or... class Stack extend Forwardable attr_reader :ary def_delegator :ary, :last, :top def initialize(ary = []) @ary = ary end end 
Yeah, totally understand the general concept, I just thought implementing it as basically a linked list looks pretty ridiculous. The book has you creating your own push and pop methods, which is all well and good but I just can't imagine an interviewer asking you to code those from scratch. But I've never been to an interview, sooo \*shrug\*
It's actually quite a common exercise
Stacks and queues are abstract data types... one level ‚Äòhigher‚Äô than an array or a linked list. You can implement either a stack or a queue by using an array or a linked list, simply by constraining the way you use them BUT The choice of using an array or a linked list means your code will have performance characteristics depending on how you use them... Constantly adding one element to the front of a linked list will be faster than adding one element to the front of an array. Adding to the front of an array moves more memory (well, kinda... keep reading) Constantly seeking to the middle of an array will be faster than seeking to the middle of a linked list... you can calculate the middle of an array, but you can only get to the middle of a linked list by traversing every node. In a high school class I show this speed difference in Java code by swapping implementations. I haven‚Äôt personally tested it in Ruby. If I remember correctly from ‚ÄúRuby Under The Microscope‚Äù, Ruby‚Äôs arrays are implemented in C under the hood as linked lists with skip indexes, so you might not see such a dramatic difference in performance.
The main thing to understand is to understand the tradeoffs. E.g a naive queue implementation using an Array will get progressively more expensive as the queue length increases, as shifting from the start requires copying the entire Array, making popping off the queue O(n) for a current queue length of n, while for a linked list approach it is O(1) regardless of the size of the queue (as long as it fits in memory). On the other hand an Array amortises allocation costs over many insertions in the queue. If someone told me they'd implement a queue with an Array in Ruby those are the things I'd immediately ask about to ensure that they actually understand when they might want to think about alternatives. 
IMO, it's good to know _how_ to do it, and why you would want to. I do Advent of Code regularly, this year's [day 9](https://adventofcode.com/2018/day/9) was initially manageable with just an array, but part 2 increased the array size dramatically and the memory copy was just too expensive - converting to a linked list was all the performance optimization it needed.
google lets you interview in ruby, if you state that as part of your interview preferences (source: i work there)
makes sense, thanks :)
Oh thanks, didn't know, not much ruby in the day to day work it seems though, and correct me if I'm wrong but it seems like interviews can be in any language including pseudo-languages.
i don't think they can be in any language, but ruby is definitely one of the supported options. (and yes, not much ruby in day to day work; that's mostly python if you want a scripting language)
For a beginner almost nothing has changed since 1.9 that you can‚Äôt learn in 30 minutes of reading blog posts. Use the 1.9 books and you‚Äôll be fine- it‚Äôs still the same language and for beginners there‚Äôs really nothing to worry about 
Learnenough.com
It's worth knowing how to use adjacent memory arrays but you won't care about the additional overhead 99% of the time. It is more important to know when to use a stack/queue for algorithmic design
Hands down this: [Learn to Program (Pragmatic Programmers) ](https://www.amazon.com/dp/0976694042/ref=cm_sw_r_cp_api_i_QvUMCbWMTR7Q4) Chris is a fantastic author and it‚Äôs an easy read. Was what started me out in college.
Book using ruby 1.9 will be perfectly fine. There are really just a handful of differences that matter from 1.9 to 2.5. Wiki actually has a good overview what's changed: https://en.wikipedia.org/wiki/Ruby_(programming_language)#Ruby_1.9
I've used Sinatra on projects before. Went from that to Roda and then to Hanami. I don't think you're going to entirely escape a certain Eastern European analogue to culture that pervades large parts of the software industry these days. I've noticed it particularly in the Ruby and JS communities but I'm sure it's broader than that. Perhaps the best we can hope for is to work with those individuals who try to rise above that, and then build something that surrounds, isolates, and eventually extinguishes the toxicity. Accomplishing *that* without having the residue seep throughout is a neat trick that we, alas, have yet to master. Having talent is awesome. Having talent and being a genuinely nice, empathetic, people-focused human being is *depressingly* rare ‚Äî in any culture.
not sure if this helps but we use rom-sql directly, which has proven to be quite nice
[This one](https://poignant.guide/)
The Ruby Way by Hal Fulton. 
I liked the old pickaxe. Other than that most ruby books are not ... hmm ... great. They are not bad but of course when you don't know ruby yet, it is "worth" more to invest into books, as opposed to a situation where you already know quite a lot (and then buying a book is not as useful anymore, since you don't benefit as much from it; I bought the pickaxe twice, first time was totally worth it, second time was ... hmm. I don't consider it a waste of money, but I did not benefit as much from it as the first time). I think ultimately, though, after the INITIAL step, where it is fine to get any book, the only way to really get good at ruby (and get a sufficient "return of investment" of your time) is to just keep on writing code in ruby. It is, in my opinion, by far the most effective way to learn/use ruby too - write a LOT. And of course also make notes and store them locally - that has helped me too, when I forget things and just look it up again at a later time. For regexes I can recommend rubular.com - super-quick to build your regex, and you can even get an URL to it which I store in projects to help me re-look it up again. 
30 minutes seems a bit short, but other than that I sort of agree with you - it is totally possible to learn what has changed past ~1.9 with very little time investment. Though I think your 30 minutes is set way too low. :P But I'd say a few days maximum would seem perfectly reasonable - definitely less than a week of casual time investment for sure.
I liked that book-format from Chris a lot. It even is a single .rb file. :) I thought about updating it and publishing that update on rubygems so it won't get lost ... but I am so incredibly lazy and slow ..... I liked the idea of having it all in a single .rb file though. That was a great idea by Chris.
After you learn the basics you *must* read Eloquent Ruby and Head First Design Patterns both from Russ Olsen (Read his blog too)
This. Probably the only really "big" change since 1.9 (from a beginner's perspective) is named arguments. But that's not exactly hard to understand. All of the basics about variables, methods, classes, objects, blocks, .... Remains the same. And unless you're working in a *big* project (e.g. a large rails app), updating 1.9 code to run in ruby 2.6 should require little-to-no effort.
well grounded rubyist! that's it!
Do you think calling publicly a person "absolute toxic ignorant jerk" is an appropriate way to be part of a community?
This is the right way to do it, except for the suggestion to use Sinatra :P
I don't think being a "absolute toxic ignorant jerk" was a good thing in the first place.
Hello, I'm curious: do you plan to use another ORM or no ORM at all? If you want to use another ORM, why `hanami-model` doesn't work for you? Thanks.
I think you are correct; Resque jobs are MUCH harder to test because they are class methods. This has led to people doing this: def self.perform(*args) MyService.new.perform(*args) end which is a reasonable workaround. Sidekiq explicitly deviated from Resque here because I wanted jobs to feel and act much more like normal POROs.
Huh TIL Head First was by Russ
Ups my bad, wrong name
Neat.
Neat, but I'm happy it doesn't seem to be the default. 
Well I mean I'm not starting from scratch I did Java so the concepts are the same for all OOP languages. The syntax is different
Everyone better have their console buffer's jacked up if you have tons of routes.
Cool. Not as useful as `rspec -f d` sadly. I do regularly check rails routes though. Keeps my paranoia at bay.
I mean those gems are full of vulnerabilities... seems very risky to deploy that. But if you must (and it's only internal, and it's only for your personal use, and there is no sensitive info, etc. etc.) you could probably do it with Docker
Yes, to give you a bit of use case I only need to deploy it in locale to understand how it works and then build an equal (and new) application with Laravel. I am literally losing hours and hours trying to solve these conflicts but everytime a new incompatible gem appears... &amp;#x200B;
when you say you are getting gem conflicts, are you installing this app under it's own rvm/rbenv environment or trying to install this app along with other rails apps into your system gems? If you create a unique gemset for the new application using rvm/rbenv, and the app was running previously, bundler should be able to figure out how to install the required files.
With Xcode command line tools installed: &amp;#x200B; `_LIBS="$( xcrun --sdk macosx --show-sdk-path )/usr/include/"bundle config build.nokogiri "--use-system-libraries --with-xml2-include=$_LIBS/libxml2 --with-xslt-include=$_LIBS/libxslt --with-exslt-include=$_LIBS/libexslt"` 
Yeah, nobody uses it anymore as far I know, React Native is a much better alternative.
‚ÄúNobody‚Äù except the 800+ people in the Motioneers Slack.
&gt; React Native is a much better alternative. But OP can't use Ruby for React Native. 
I have to admit that I use marshalling as my data persistence. I write an object (which is a collection of instances of another object type) wrote to disk and read from disk. For the minor sinatra app that needed to store a few types of data, this was way easier than implementing a database.
I'm really looking forward to Amir Rajan's presentation at Ruby Kaigi.
There are definitely new projects using it. RubyMotion is not dead. It's alive and well. React Native isn't bad if you like React development, but it has its own downsides. It's not a "much better alternative" as you say.
I think we all are. Even if we can‚Äôt all be there!
thats why you pipe it to grep if youre interested in specific ones
You should seriously consider biting the bullet and [upgrading](https://edgeguides.rubyonrails.org/upgrading_ruby_on_rails.html), because maintaining a severely outdated Ruby/Rails is like refusing to pay off a high-interest loan. The time you waste with compatibility issues, hard-to-google problems, missed new features, and much more quickly surpasses the time required to upgrade.
Prathamesh, would you consider posting these in r/rails? 
Is there somewhere I can see full api documentation for rubymotion? The biggest thing holding me back from Rubymotiion is knowing it can do the things I need. I need: push notifications deep map integrations payment integrations user locale movement data I'd like: advertising integration OTA updates I'm not interested in a 101 course on Ruby motion. I'm a veteran developer, I need documentation not talks.
The iOS SDK documentation IS the documentation for RubyMotion on iOS. And the Google Android SDK docs are the docs for Android. There *was* a RubyMotion translation of the iOS SDK available at one time, but Apple insisted it be taken down, as a copyright violation. It‚Äôs not that difficult to translate the Objective C docs, and there are many samples that illustrate the use of of those SDK‚Äôs in RubyMotion. https://github.com/HipByte/RubyMotionSamples It‚Äôs a little more challenging to translate Swift examples, but I have a few posts on my blog where I do cover some of the tricks you need.
I was pretty excited to try out RubyMotion a few months ago, but then I came to the realization that I‚Äôd have to buy a Mac to use it. 
You might want to check out http://www.rubymotion.com/news/2019/03/01/the-sleeping-dragon-has-awoken.html?utm_campaign=newsletter&amp;utm_content=14&amp;utm_medium=web&amp;utm_source=rubymotionweekly.com
Anyway.misunderstood(the_question)
It's written using version 2.0.0, I recently lent my copy out to a friend he installed 2.5.5, he is about 3/4ths of the ways done with it and has not ran into any code issues. And yes it absolutely is still very relevant. I really like the teaching style of the book. It teaches you by actually doing real world scenarios and explains the bits along the way.
Done 
I used this pre-baked package to install ruby and Gems...Should I try with RVM? [http://railsinstaller.org/en](http://railsinstaller.org/en) 
I know, luckily I just need to reproduce the App in order to understand how it works so I can start from scratch building a similar application with Laravel. So it is just fror the Local environment
Hot diggity damn, this is excellent news! Thanks for the link!
codecademy where you actually type along is better than any video
But MacRuby definitely is dead (has been for years), and I think that‚Äôs a big reason why people are wary to commit to RubyMotion.
What operating system are you using?
[Link to summary of all changes](https://github.com/rails/rails/releases/tag/v5.2.3)
windows 10
Okay. I'm afraid I'm unable to help you personally as I have no experience of Ruby on Windows, but that is an important piece of information for anyone who can.
Hmm, I'd love to write a blog post like this on how we built a performant Elixir app but mine would just have one line that said: "we called the database less"
also just "my opinion": what is so horrible with javascript? i mean, we all know the gig with "js - the good parts"; but es6 radically changed that. also, with webpack for modules.. after you set it up, it's actually awesome! recently, i build a simple android app and the very first error i encountered was something about threads. I don't care! i don't wanna debug that! events loop is super effective for UIs. and if you need to support IE or other browsers with limited APIs, the problem is not the javascript language..
There is one big question: - Why? I get what rubocop is doing, and it has some option like --autocorrect. I don't quite understand autoformatter's purpose.
None of them. Typically you really should go the oldschool way - book, + practice.
I dunno... weird stuff like this? Which IS the language. And causes endless bugs to trace. https://twitter.com/searls/status/711183478642057216?s=20
Man that was a cool read. I'll probably never use that. I don't have any web apps where I'd need this. But I think Phoenix is really cool, I'd like to migrate my blog to Phoenix. I just need to spend some time learning Elixir.
nice!
Stylistic consistency, especially across a large codebase. A lot of Go folks are really fond of the autoformatter. The real big question is: why not contribute to [Rufo](https://github.com/ruby-formatter/rufo)? ("I don't like its conventions" being totally reasonable, since this looks like it's just a side project for Sam, but...)
If that‚Äôs true, then people need to educate themselves on the difference between MacRuby and RubyMotion. They are not the same. MacRuby essentially died (was superseded) when RubyMotion was created. So it‚Äôs been intentionally dead for a long time. MacRuby didn‚Äôt support iOS development, so it was rearchitected to support iOS (and eventually tvOS, watchOS, and Android) development. It‚Äôs been commercially supported and the owner has many revenue generating apps built on RubyMotion (thus securing its longevity). The fact that MacRuby is dead should play no factor in whether or not someone chooses RubyMotion.
So this is interesting, because while my team was educating ourselves on RubyMotion, we found two references to MacRuby on the RubyMotion site. The first is on the very bottom of the Tour page, which says that it is based on MacRuby, and shares developers with that project. The second place is at the very bottom of the FAQ page, which links to the MacRuby site ‚Äî as if it‚Äôs still a going concern. That‚Äôs clearly a dead project, with the last patches submitted 6+ years ago, with the most recent release being something like 0.13. Since it‚Äôs not clearly explained that RubyMotion is actually a fork or reincarnation of MacRuby, we were left to conclude that RubyMotion must use a 6 year old codebase that is no longer maintained. If RubyMotion is based upon an actively maintained fork of the old MacRuby, then I agree with your statement that it shouldn‚Äôt matter if MacRuby is dead. If it simply vendors MacRuby 0.13, however, then I think it‚Äôs quite relevant. I hope that the new team will clarify these issues on the RubyMotion site so prospects can properly evaluate investing in the product.
Ah, okay. Right, so MacRuby came first. One of the core contributors to MacRuby created RubyMotion and the company behind it and many of the MacRuby core team moved on to working on RubyMotion. So MacRuby stopped progressing as soon as RubyMotion was released (about 6+ years ago). The RubyMotion project is actively maintained and continuing to improve. Good feedback about the website. I'll make sure someone clears that up.
I appreciate the clarification - thanks much. The team's interested piqued again today with this news, so we will re-evaluate the product.
&gt; It‚Äôs a popular language, but it‚Äôs weird. And not in a &gt; weird-wonderful kind of way. In a weird-wtf-are- &gt; you-doing-now kind of way. JavaScript is indeed terrible. Unfortunately there is no way around the www. The www is the single strongest catalyst these days. &gt; So, I joined the Java bandwagon. I‚Äôm even a Java Certified &gt; Programmer Certifications are like penis-comparison contests. Pretty useless. What ultimately helps a LOT is showing the code that you have written, and that ideally works too. &gt; If I had no choice but to choose between Kotlin and Java‚Ä¶I‚Äôd probably shrug &gt; and pick JRuby (HA!), because no one has spent time convincing me that Kotlin is &gt; a better alternative. Because Ruby is better than Java. However had, Kotlin improves on some parts of Java, like Java's mad addiction towards verbosity. &gt; Ok, now Swift‚Ä¶ as an officially blessed language, it‚Äôs appealing, but‚Ä¶ I‚Äôve been &gt; watching the train wreck of this language‚Äôs development philosophy - move fast &gt; and break things - for a little too long to find it at all appealing. Five major &gt; revisions in 5 years. ARE YOU KIDDING ME?!?! I I don't have a huge problem with that per se. Swift should be seen as an approach to replace Objective C. In this regard it works. My biggest gripe with swift is that it is controlled by Apple. I dislike corporate-driven control - even if the design is "independent", these fat companies just have a way too massive influence. Google's Dart is a wonderful example of this too (a bit less so in Go but you can also be sure that Google would not fund Go if Go would not solve use cases Google has specifically). &gt; I‚Äôve also watched people with extensive properties (lots of apps/big apps) in &gt; Objective C attempt to make the transition to Swift, and fail, because the &gt; language keeps changing half way through the process. That also shows that Apple is run by clueless noobs. Ever since Steve Jobs died, the IQ in Apple went down by 80%. (Not that Steve Jobs was a hero - we only have to look at the mafia collusion where Apple and others did not pay wages by conspiring to not cross-hire/poach away devs. The CEOs that are still alive should serve a mandatory jail time for this organized theft and abuse). &gt; Remember when I said I used work on a C-based GUI library? Yah, I still &gt; kinda like C. But Objective C‚Ä¶ yuck. All those ‚Äò[‚Äô and ‚Äò]‚Äô and the overly wordy SDKs. Yeah. Objective C was quite bad. It even had a worse syntax for OOP than C++ - and C++ also has a fairly bad syntax. People should really really have improved on C, SLOWLY, VERY SLOWLY, rather than keep on spawning those irrelevant soon-to-be-dead languages nobody is using anymore. &gt; My old WNDX C stuff was more readable than that. IMO, as a developer of over &gt; 30 years experience, code that‚Äôs not readable is pretty much impossible to maintain. Good thing is that I don't have 30 years experience - but I could very early on see that awful shitty syntax is too annoying to want to stare at for years. There is a reason why I am using ruby. :) You can write terrible code in any language though. People are strange. &gt; And it‚Äôs even harder to maintain/read other people‚Äôs code written in that language. I find that it is hard to read other people's code in every language really. &gt; An then there was RubyMotion. Yo, it‚Äôs RUBY. Remember? The language created &gt; to make developers happy? Yah, that one. I do not recall matz ever having said that. People seem to want to mis-quote or push in slogans they come up with. My favourite interview is still this old one: https://www.artima.com/intv/ruby.html Matz also said that he wants to help people (through ruby); that includes "getting things done". You can see this in some approved suggestions such as the safe navigation operator. Let's ignore the syntax here for the moment and just look at the issue tracker - someone described a valid use case, matz agreed with the use case and eventually added the safe navigation operator. That is sort of a good example of where the focus on human beings is. Ruby of course has several foci (focuses? It always seems so strange in english ... I am pretty sure foci would be the natural plural for any latin word... if that is latin and not greek that is...). Expressiveness is one goal too. Perl is also somewhat expressiveness but less readable than both ruby and python. &gt; When RubyMotion was released, it made me happy. Because I could do &gt; iOS development in Ruby. I am so glad to not depend on apple when I use ruby. :) NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setInteger:9001 forKey:@"HighScore"]; [defaults synchronize]; vs App::Persistence['HighScore'] = 9001 Well, ok - Objective C is shit, we knew that. BUT ... The comparison is still unfair. We compile into a binary with Objective C yes? So that is different than in ruby. The comparison is not completely fair IMO. And I say that as someone who thinks ruby is great. &gt; and RedPotion (a collection of gems like Rails, that help you build iOS apps) class Foo &lt; Bla::Ble title "bla bla bla" To be honest - that is rails-style. I don't like rails style of writing ruby code. It feels so alien. Unfortunately this has become quite popular. :( You only have to look at machomebrew. Personally I think it is quite terrible to focus on this top-level driven API calls in a pseudo-DSL like mini-language. It raises the complexity of what people have to know. And by the way, whoever wrote that code is not a good ruby hacker - you can see it by the way he indents: case args[:dataset] when 'films' It's just wrong. Everyone who has used ruby for some time knows why. Even rubocop (!) complains about it. :) &gt; Ok, I‚Äôve confessed. Those are the reasons I chose to do RubyMotion development. &gt; Those are the reasons I choose to teach mobile development with RubyMotion. &gt; You can make another choice. But, come on, why would you? Most of these reasons seem ... well. Pointless. If it works for your case that is great. I find that to be utterly boring. Then again I also find rails terribly boring. :\ The only part I agree with is ruby. Now ruby is really really great. I can't say the same for everything written in ruby, but as a language? Awesome. 95% awesome or so - hard to reach 100% awesomeness.
AH, i'm just understanding how this now works. I mistook RubyMotion as something akin to ReactNative. Inferring from your comment, that means I cannot write a single RubyMotion app and compile it to IOS and Android, I have to write two separate apps and compile each of them. Is that correct?
nevermind, got an answer elsewhere, this has to do with implicit vs explicit typed languages. nothing to do with interpreted vs compiled or other
Java is a [statically typed language](https://en.wikipedia.org/wiki/Type_system#Static_type_checking) while Ruby is a [dynamically typed language](https://en.wikipedia.org/wiki/Type_system#Dynamic_type_checking_and_runtime_type_information). In short, static typing means that you declare the type of the variable up front, and its type won't change in scope. By contrast, in Ruby you could say" str = "cool" str = 1 and the interpreter would happily let you reassign the variable. In Java, once `str` is defined as `String`, you can't redeclare it as something else in scope. Static typing increases verbosity and rigidity, but it has some significant advantages - it enables [static analysis](https://en.wikipedia.org/wiki/Static_program_analysis) which can find many errors without attempting to execute the program. By contrast, in Ruby, you'll only ever know that `str` isn't _actually_ a string at runtime when you try to call a String-only method on it, and ruby says "whoops, I don't know about that method on that object".
FWIW the creators of phoenix are ex rails devs and that shows in how phoenix is designed. Jumping from Rails to phoenix will feel very comfortable when you do make the change. :) 
This is a great article, thank you. I also have some questions.. Do you maintain two repos? Or do you have a parent repo for both app? How did you manage the communication between your apps (I mean the API authentication)? Finally are you using Docker or Kubernetes or any other CI/CD tool? Thank you for the details..
wow, this is really interesting, so glad I asked and left my message up here. thank you! 
I hate ru...by 1.8.7 :D (close call :D)
THANK GOT THE WORD WAS RURAL!!! I already thought it would be &lt;Ru&gt;ssia ...
I've followed a couple beginner guides, and watched some conference talks from some of the Phoenix devs. I definitely like the layout of the framework. But, some Elixir syntax confuses me. Also, I was looking for a couple of features, that I just could not find. Like, I want an easy way to have a rich text editor, where I can easily upload images into my text. In Rails 5 I did this with a gem for Ckeditor4. In Rails 6, I can use ActionText. I couldn't find an easy solution in Phoenix, and didn't have the time to really investigate. I'm sure I could use something like CKEditor5, and just include the javascript for it. But then I'd have to wire it up to the Ecto(i think that's the DB manager?) backend. And I just don't know how to do that yet. When I have more free time, I definitely want to dive deeper at some point though.
I use formatters in Go and Elixir and they're really helpful. When I write code I want to focus on its meaning, yet I want to deliver nicely formatted code to make it easy to read. Why to care about it myself if I can have formatter do it for me? Just run it automatically after every file save od as hit pre-commit hook, and I don't have to worry about it anymore!
cool. Yeah for sure there will be some adjustment to the Functional Programming style, plus Elixir/erlang idioms. If you're familiar with Unix/Linux thinking of it similar to how you pipe from one program to another cat something | grep some_string because that's pretty much what Elixir FP is doing, simple transforms from one thing to another vs mutation and assignment like imperative programing. If you have an ".edu" account the elixir book is free over at pragprog so you might want to grab that one too. Link is here https://pragprog.com/book/elixir16/programming-elixir-1-6 One huge advantage on the elixir side is execution generally decreases by a factor of ten, i.e. if response times in rails are milliseconds the times in Elixir will be in the microseconds also IME the memory consumption is about at least half as much which is nice in VM architectures. Overkill for a blog but still nice to have as things you would do client side in rails to speed up/offload processing time can now be done server side in Elixir. FWIW one thing you might be able to do is push that functionality up into JS layer and call into Phoenix AJAX API style. Then you could leverage webpacker and something like react + react dropzone + fancy pants. You'll most likely have to pass the file data in binary blobs but it should be doable. I remember doing this in rails at some point on the JS side. Like you said though everything in good time. Also phoenix has a lot of the "socket" style of architecture built right in. When you change files like html templates on the backend they just update on the webserver style a la chrome's livereload functionality but simpler. Oh and if you do things like arduino. Checkout the nerves-project.org LOL there is no shortage of stuff to learn when you're a programmer. Have fun!
I've been a linux user for 4 years now, and I actually started programming with Arduino. I've taken a cursory glance at the nerves project. That's definitely something else on the list of things I can't wait to toy with.
Nice article. I would also like to mention an approach taken by GitLab where they put Golang in front of Rails with [https://gitlab.com/gitlab-org/gitlab-workhorse](https://gitlab.com/gitlab-org/gitlab-workhorse) for those that never heard about it.
&gt; In short, static typing means that you declare the type of the variable up front, and its type won't change in scope. No, it doesn't. Most statically-typed languages feature some degree of *type inference*, which means the compiler will infer the type of an expression for you, without you explicitly declaring it. Java is very limited that way, but in a more modern language, like, say, Haskell or Golang, you can often get away without spelling out any types at all (though in Haskell, type-annotating at least the top-level definitions and crucial expressions is considered good form, as it aids readability and makes error messages more precise). As such, static typing does not generally increase verbosity; *explicit* typing does. A better definition for static typing is that types are checked statically (i.e., without actually running the code).
I‚Äôve listened to a few episodes of The Yak Shave (podcast) where the author talks about this. IIRC, the point of the lib is to run it in your IDE and have it autoformat regularly (on save?). Rubocop can be quite slow to be doing that all the time, especially for larger files. IIRC, the author also wants to strive for a standard set of formatting (no/very little configuration), which is weighed in on from a lot of sources (ie not his style preferences, but those of the wider community), leaving users to not have to think about style stuff anymore. Probably some other things too, but that‚Äôs about all I remember atm. Hope that helps.
That is correct. Although there are tools like motion-flow &amp; it's super-repl that let you come close. There are still some places where you need to drop down and write the code specific to the platform. If you keep your business logic all nice and decoupled from the UI, though, you can share all of that code.
&gt; Certifications are like penis-comparison contests. Pretty useless. I agree completely. The process of acquiring that cert convinced me how useless they are. &gt; You can write terrible code in any language though. People are strange. So true. Although, I've been around long enough to know that I'll look back at any code I've written in the past, and find some terrible aspects. &gt; I find that it is hard to read other people's code in every language really. Reading other people's code is a skill. It takes time to develop, and you need to work hard at it. But languages with sh*tty constructs certainly make it more difficult. &gt; Well, ok - Objective C is shit, we knew that. BUT ... &gt; The comparison is still unfair. We compile into a binary with Objective C yes? So that is different than in ruby. The comparison IS fair. It's not Ruby, it's RubyMotion. And RubyMotion compiles to a binary just like Objective C. &gt; It's just wrong. Everyone who has used ruby for some time knows why. Even rubocop (!) complains about it. :) I know. That's my code (she not he), and I was in a hurry when I created that example for a talk I was giving. Sadly, rubocop doesn't work with RubyMotion. It loses it's mind over the Objective C-like keyword args. That's a pain-point I hope someone has time to fix, REAL SOON NOW. 
FreeCodeCamp has one. [https://www.youtube.com/watch?v=t\_ispmWmdjY](https://www.youtube.com/watch?v=t_ispmWmdjY) &amp;#x200B;
Others already answered that, so I'll just comment on something else. - I learned a bit of Java too and while Java is awkward, and addicted to verbosity, I found Java to be fairly simple actually. They just use terrible names for things that are super straight forward in ruby. I always found things such as: String foobar = new String("foobar"); very odd too. I have to use the word String twice. This is so lame! The second variant appears to have been inspired by "scripting" languages; I noticed the same in C++ when they added auto-iteration over collections with a simpler syntax. Scripting languages lead the way. :&gt; Without them, Java and C++ would still have mega-verbose and mega-annoying ways to instantiate something. Actually Kotlin may also partially be responsible for "inspiring" Java.
&gt; By contrast, in Ruby, you'll only ever know that str isn't actually a string at runtime &gt; when you try to call a String-only method on it, and ruby says "whoops, I don't &gt; know about that method on that object". I don't disagree with the rest that you wrote, but that comment is also bogus. People can always do a .is_a? check or a .respond_to? Yes, that leads to more verbosity in ruby as well, but it is still less than in java AND when people work properly then this error can not happen (because it can only happen when people did not think about possible conversions and sanitizing input; a terrible example for the latter is: end.parse!(ARGV) I don't fully remember the conext but this is typical awful shit that came via OptionParser. I hate code like this. Actually, I hate all methods that are chained onto "end" anyway, but .parse!() is ugly and the by far worst thing is people directly handling ARGV rather than doing it the oldschool proper way - by putting it as a parameter to a method like: def foobar(i = ARGV) or something like that (and still checking on i that it is a sane value).
It's not really type inference you're talking about, e.g. Java has local type inference now, e.g. `var myString = "Hello World"` is valid Java. In go, you have something like `myString := "Hello World"`, same idea. Where they differ is that go (and Haskell) support structural typing, which Java doesn't. e.g. In Go you don't have to explicitly state that an object implements any given interface, as long as the object responds to the methods the interface defines, it works. Structural typing is basically compile time duck typing (Ruby) and contrasts with a nominal type system (Java, C, Rust, etc). An example comparison: Ruby is strongly typed with implicit type definition, duck typing and dynamic type checking. Go is strongly typed with implicit (optional explicit) type definition, structural typing and static type checking. Java is strongly typed with implicit (optional explicit) type definition, nominal typing and status type checking. 
So install Java 10+ and write `var foobar = "foobar";` ?
`'a'..'z'` is a range (returns an Enumerable), e.g. you can try `('a'..'z').to_a` and it gives the alphabet as an array (`to_a` is to convert to an array). `[a-z]` is used in regexes, as in `"i'm using ruby".scan(/[a-z]+/) =&gt; ["i", "m", "using", "ruby"]` which matches the letters from a to z. To get the alphabet string, you can do `('a'..'z').to_a.join` :)
You can do those checks, but they occur at runtime, not at parse time. When you call `foo.split`, Ruby will happily let you try to run that code (and fail) if `foo` is of an object type that doesn't have a `split` method. Statically-typed languages won't; they know at parse time that you're trying to call a method on an object that doesn't and can't have that method, and surface the error before the program even begins running.
it's not a question of implicit vs explicit. in statically typed languages, *variables* have types, and the type of the object a variable refers to has to match the type of the variable. in java, if you say String x = new String("hello world") you have defined (1) a variable, x, of type String, (2) a String object, with contents "hello world", and (3) a link between the two, so that referring to x means you're referring to the object. in ruby, you can likewise say x = "hello world" which defines (1) a variable, x, (2) a string object with contents "hello world", and (3) a link between the two. the main difference is that x itself has no type; it just refers to whatever object it has been linked to. this makes a difference when you say, e.g. x = some_function() versus String x = some_function() in the latter (statically typed) case, you know that x will be a string, even without inspecting the function, because otherwise the compiler would complain, with an error message along the lines of `assigning the return value of some_function(), which is an int, to a variable of type string`.
Thank you for your reply. Can I also add why i've also seen in the parenthesis ('a-z') working?
Parenthesis just make sure what's inside doesn't interact with what's outside before it's evaluated/ran basically, e.g. `'a'..'z'.to_a` wouldn't work as the `to_a` is called on 'z', so that's why the parenthesis are needed. As for ('a-z'), this is just a string (simple quote or double quote) containing a-z and surrounded by parenthesis (in effect the same as 'a-z' without parenthesis). This string doesn't have any special meaning by itself.
Recently started using ruby for work and man, is this library a sight for sore eyes!
Thank you for your help
More details. Why/how?
If someone asked me about the performance implications of stack architectures in ruby I'd ask them if they're familiar with the phrase "rearranging the deck chairs on the Titanic".
Maybe I've misunderstood what you are after, but if not I think you can accomplish what you want by using `select` on an array of hashes. `big_array_o_hashes.select { |hsh| hsh[:key_of_interest] == search_value } `
The idea is that the user provides the search string rather than some ruby code executed in a select/filter
Ah, I see. Well there are libraries to parse user input (but sorry, AFK and drawing a blank about the names) even so I'd think it would be fairly straightforward to pull out the term (s) and associate it/them with the associated search logic. 
Sounds like you want something like [ransack](https://github.com/activerecord-hackery/ransack) but for in-memory use instead of ActiveRecord?
Kotlin is my favorite programming language. I recommend everyone try it out. I don't even hate the extra verbosity of Java. I find it to be very readable. Kotlin makes things nicer though.
So here's the thing. The name of the game is how fast you need to be able to do all of these things. If you can live with always having to traverse the entire set to get an answer back then you can do all of these operations using naive filter operations. I might further argue that if you can fit the whole data set in memory in the first place then such a naive search strategy is probably possible depending on how fast you expect the answers back and how many people will be querying at the same time. That being said, there's a reason why nobody does that at anything approaching large scale. Scale in the sense I'm meaning for the sake of this conversation can be any of the following... The data is too large to fit in memory The request volume is large enough to saturate your CPUs available time spent digging through memory An individual request is expected to be answered in near real time As soon as you need it to be done any faster for any of the reasons above (or any I didn't think of) you have to start building indexes of one form or another. To add insult to injury, you probably have to build a different index for every different unique way you want to query the data back. Building an indexing strategy for some of the more involved query types you mentioned (aka full text search or anything like it) is not a trivial exercise and there are many different algorithms with many different trade offs to consider. There are whole companies, products, and engines solely dedicated to solving that (full text search) problem. Ask this is to say the question you've asked can be very simple to solve if your needs are modest and incredibly difficult to solve as your needs become more stringent. 
Well, there's JSONpath. A ruby implementation: https://github.com/joshbuddy/jsonpath That's one option. If you really do need a string-based 'language' for describing a search that gets parsed and executed. If you don't, just write ruby. I dunno if JSONPath is really non-programmer end-user writeable though. Depends on what you want to do with this I guess. 
Just to tack on the answer varys quit largely depending on the size and scale of the data set. Will it fit in say the available memory of a single process? The available memory of many clustered servers working in concert The available disk of a single machine The available disk of many machines The case of Wikipedia where it merely has to index the whole of human knowledge Or in the worst case I can think of with Giants like Google or Twitter or Facebook so massively huge that it could be said to encompass the whole of human interaction. I have a nice little wiki/ticket tracker that I use for personal purposes where everything easily fits in the memory of my personal machine with room to spare and I and a very small group of friends are the only users. Even complicated searches in such a system are no big deal. A chat system like slack where your user base is easily dissectible into clumps of interacting users isn't too hard. Past a point and my head starts to hurt üòÄ
I would highly recommend looking in to elastic search. It‚Äôs not just searching ruby hashes in memory anymore (you‚Äôll have to index those hashes in to elasticsearch). Elasticsearch supports all of those filters you mentioned and more.
I know that this will be out of scope but postgres is really good at that using indexed JSONB columns. And depending on the context (eg. docker) it might be really cheap and easy to fire up a postgres server by the way..
That'd be a stupid response. There are plenty of situations where knowing and thinking about complexity implications in Ruby makes the difference between being able to comfortably continue using Ruby vs having to rewrite in another language. 
For such a straightforward query syntax, I'd make my own parser.
I agree if the number of data entries is large Although you can implement with ActiveRecord + database Some searching focused features are easier to be implemented via ElasticSearch But if you going for ElasticSearch you need to understand that ElasticSearch is unlike SQL database (in terms of concept and storage) It's quite lengthy to talk about the differences here No comment on custom search query syntax (no experience on it)
Simplest way to remember for Ranges is that a Range will use .. You can of course also use Range.new instead: Range.new('1','9').to_a # =&gt; ["1", "2", "3", "4", "5", "6", "7", "8", "9 But most people will typically use the .. variant, most likely because it is shorter. Other than that localhostdotdev already explained the a-z notation in a regex. If you have problems with regexes, I can recommend testing on rubular.com - you will instantly see what you match, if you match something. It's very useful.
Good one, thank you!
Then how would you make your parser? I guess you would compile the `key:value` to procs, but how would you combine them for OR/AND support?
Let's say I have around 100 hashes maximum per search, and search is repeated quite often but on different hashes, storing in a database doesn't make much sense in my case (otherwise I would have done it already :D)
\&gt; Let's say I have around 100 hashes maximum per search, and search is repeated quite often but on different hashes, storing in a database doesn't make much sense in my case (otherwise I would have done it already :D) Same for ElasticSearch / Solr, it's basically: data comes in, I filter it, I use it, I throw it away
Thanks a lot! jsonpath is quite close to what I'm looking for (I might just need to translate the search query to jsonpath. About the parser, I made a little with Canopy but I'm not sure how to handle AND/OR correctly (with parenthesis). Here is my simple beginning :) grammar SearchParser search &lt;- (separator? query:query)+ query &lt;- (field ":")? [^ ]+ field &lt;- [a-z_]+ separator &lt;- " "
The data is \~100 records let's say. Would take more time for insert them into the database, query them, then delete them :)
Yes, exactly
Yes, I have been writing my own logic, my main issue is with the AND/OR operators but seems like a good parser and a tree traversal would fix it.
I wasn't expecting you to say that. I think the naive filter approach at least to begin with will probably more than suffice for your case. So for every filter type make a function that given the search criteria and one element of the structure you proposed will return either true or false based on whether the element matches or not. The implementation details for each function can use regular expressions or whatever technique you like. Once you have these functions, pass queries and lists of 100 through a select that utilizes the functions and you are off to the races Hope that helps.
Yes thanks, this is what I'm doing, I just need to implement the and/or operators with precedence now (will need to make a better parser (e.g. a PEG grammar to the correct tree) and then implement the reduce basically
procs of procs
No, since those methods are defined in the Enumerable module, they are included together into the classes that have them. I'm curious as to why you're asking. Is it just out of curiosity?
Why asking: I'm working on a logger that when possible explicates collections. Of course when it can, it uses :each_pair or :each_with_index. I'm just wondering whether it needs to also check for :each.
well, that doesn't convince me to say that the whole language is horrible. in every language are those quirks: in ruby: irb(main):010:0&gt; %w[a][0..0] =&gt; ["a"] irb(main):011:0&gt; %w[a][1..0] =&gt; [] irb(main):012:0&gt; %w[a][2..0] =&gt; nil
I'd probably just check `my_thing.is_a? Enumerable`. The only reason for an explicit check for `each` would be to handle the rare case where someone just implemented `each` on their own type but didn't bother turning it into an actual `Enumerable`, I've seen code like that a few times but it's pretty rare. 
Ruby performance: fast enough to stave off a rewrite!
[search_cop](https://github.com/mrkamel/search_cop/blob/master/README.md) will do it for ActiveRecord. Not sure if there is anything for in-memory hashes.
Depends what you want to do, most Ruby people do web dev (e.g. apps's backend and websites), and python devs do a lot of data crunching and some web dev. Personally I use Python sometimes for small things I can't do with ruby (mitmproxy, machine learning, etc.) but I try to send the data back to some ruby code as fast as possible :D.
Thanks, cool stuff even I'm doing in-memory I might copy some of their syntax
I think Ruby is better for learning. Everything is an object‚Ñ¢ clearly demarcating the end of a logical block with end, rather than whitespace is much easier to follow for beginners. Documentation for Ruby is much more readable 
Tbh I think I‚Äôd prefer apps, and web development, also python is quite popular in my area so I feel like it would be tougher landing a job as there is so many more experienced devs locally. Could you maybe point me in the direction to start learning Ruby?? Thanks 
I like [https://learnxinyminutes.com/docs/ruby/](https://learnxinyminutes.com/docs/ruby/) and [https://learnxinyminutes.com/docs/python3/](https://learnxinyminutes.com/docs/python3/) But might be easier to start with [https://ruby.github.io/TryRuby](https://ruby.github.io/TryRuby/) Also I quite like HackerRank: [https://www.hackerrank.com/domains/ruby](https://www.hackerrank.com/domains/ruby) And [https://repl.it/languages/ruby](https://repl.it/languages/ruby) is great to do ruby stuff without installing anything.
Don't learn Ruby unless you learn Rails framework as well. Those 2 are inseparable. Whereas learning Python by itself has many options open up for you.
You will find much more resources to learn (tutos, articles, videos, examples...) if you use Python instead of Ruby, so I think you'll catch up faster with Python. As a beginner, good learning material to guide you through is the most important thing.
i think you forget : [https://rubymonk.com](https://rubymonk.com) 
Yeah it depends on learning style. I feel like Ruby is easier to pick up and play with if you are better a self-learning. Python on the other hand is a little more opaque to the beginner but you will find more instructional resources. The good news is you can't really go wrong with either one.
Is learning Ruby/Rails any harder than learning Ruby alone?? 
Is CodeCademy any good?? I‚Äôve heard good things but nobody has mentioned it here yet 
web dev, ruby For everything else python is more popular.
Nope, but you have to learn more as it‚Äôs not only ruby.
Thanks, moomaka.
Thanks, capn_krunk. 
I would suggest Python personally. If you don't know anything then it is going to teach you things you'll find everywhere. It's also more popular. Ruby is great, but it's very stylistic and powerful and might confuse you should you try to move to other languages
I found 2 courses, one for Ruby then one for Ruby Rails, would it be stupid to do the Ruby one &amp; then do the Ruby rails one???
No, it‚Äôs the expected order : the language is Ruby, and the framework (toolbox) based on it is Ruby on Rails. It would be stupid to learn the later before knowing the former.
Really? From what I‚Äôve seen people are saying Ruby is much more friendly to beginners. If I was to learn Python what sort of things could I create with it?? And what sort of work could I be doing if I went freelance???
Sums it up pretty well.
I think it depends a lot on your goals. If learning programming to become a professional programmer, I think Python is more similar to other programming languages and a better jump board. By learning Ruby first you may unintentionally take a lot of magic for granted Take loops for example. Here's the Ruby way: ``` things.each do |thing| puts thing end ``` This uses iterators which are - classically speaking - fairly complicated. In C you would do something like: ``` for (int i = 0; i &lt; sizeof(things) ; i++) { // some complicated print statement I forget how to do } ``` Python is more C-ish than Ruby, and a lot of other programmers/opportunities prefer C-ish languages: ``` for i in range(len(things)) print things[i] ``` Ruby is a cool language and very productive, but from an experienced eye it's easy to see that Ruby does a lot of advanced things to make you happy and productive. Python does a lot of advanced things too, but Ruby is known for pushing the bar syntactically. I am the type that likes to learn bottom-up most of the time and I would recommend having at least some lower level exposure In terms of freelance work, you can't go wrong with Ruby or Python. They both have plenty of opportunities in web (Rails is common in Ruby and Flask/Django are common in Python). Python tends to lean data science, Ruby tends to lean dev ops/automation
That is not true at all.
This is addressing mostly the freelance question in your post: If you want more immediately marketable skills, your best bet is learning full-stack web development with php as your preference for a backend language. Don't get me wrong, you can make a very good living with ruby, but the barrier to entry for full-time ruby devs is a lot higher, and there are fewer freelance opportunities for ruby devs. There are _so_ many projects on upwork / freelancer for people that want stuff built on top of wordpress / drupal / joomla. It's lame work and they pay isn't super great, but at least there's a ton of it. If you blast out proposals to all of those gigs you're bound to get something (compared to competing with 50 other ruby devs for the 3 rails listings on those platforms). Afterwards, once you're comfortable doing general full-stack dev, picking up another language wouldn't be particularly difficult. You'll also have a portfolio and positive feedback / work history, so you'll have a little bit more of a chance competing for those ruby gigs. note: I am not a full-time ruby dev, just a consultant that occasionally uses ruby for automation and integration stuff. I haven't been down the ruby web dev road before, but I've used a lot of freelance gig platforms when I was first getting started doing consulting work, and I've seen how few obvious options there are for people with a ruby focused skillset.
If you're just starting out, teaching yourself, not doing a bootcamp and are looking for the quickest path to paying clients... you might be better off learning PHP/WordPress and HTML/CSS. Still a lot of WordPress work out there. Alternately, maybe javascript and a front-end framework (react/angular) to use with something like Firebase so you can focus on 1 area. I think Firebase handles auth and probably a whole bunch of stuff. If its between Ruby/Python, then I'd go Ruby if you want to do we Web Dev.
I heard it's good, never tried it though
I‚Äôve went through the process of learning both Python and Ruby and can say that there are a ton of resources to learn either. But as others on this thread have noted: Ruby for web dev and python for data - this is how I use both
not true, you can develop ios, android apps, create APIs, write scripts and much more.
I‚Äôve been exactly where you are before, have done the digital nomad thing, have started web businesses, etc. All this said, there are a ton of freelancing gigs out there for each language, but what are your longer term goals? To build your own web-based company? To do data analysis? Tons of large, well known, ‚Äústartups‚Äù started with Ruby on Rails. The reason is that it is really easy to develop in and progress can sometimes be unbelievable - I can build a decently robust application in a day (easy). Other languages would be much more difficult. However, with great powers comes great responsibility; I‚Äôd layer in learning Ruby as you go. Others will say you don‚Äôt need Rails to develop in Ruby. Which is true, but Rails is great. Akin to I don‚Äôt need shoes in order to run to the store in; it‚Äôs just a lot easier and gets me going a bit faster than making my own shoes. Python is powerful, but I use it for data driven stuff Other languages, React, etc. are great too but no need to go that route right now. Build a foundation then explore. Rails is a great starting point. Also, a ton of great resources abound: Rails tutorial, GoRails, dhh (Rails founder) 
If you have no clear objective in mind then better go with Ruby. Its fun.I think the fact that it is easy or not easy is a subjective thing. For me it was not easy but fun. On the other hand if you compare it to Python I find it easy but boring.
Python, unless you specifically know you want to only do web development. Both languages have many similarities and are similarly easy to learn, but Python has a lot of instructional material based around it and has broad adoption in various fields, making it a better starting point. That said the lessons you learn can be applied more broadly regardless of what you start with. Switching between Python and Ruby is easy once you have learned one language or the other.
I say yes. Rails masks a lot of complexity in its abstraction layers and you'll eventually find yourself asking whether something is rails magic or whether it's Ruby standard library and being confused. For example duck typing things like "find" in active record, which is confusingly similar to but different from Ruby find - convenient sure but very confusing when you are learning. So imo learn Ruby first so you can truly understand how much rails is really doing for you. I work mostly in rails but also have several non-rails Ruby projects so understanding this has real world benefits.
It's ok. I would maybe do it, but would probably go for Rails Tutorial first because you actually build something and can see the power in RoR (ruby on rails). 
Where does python fit into this?? Is python a viable language for freelance work or is it too competitive and will eat me alive üòÇüòÇüòÇ
Long term wise if I was to get good and comfortable with my language, I would hope to work for or maybe make a start up or even work remotely as a freelancer 
Couldn't disagree with you more. Ruby (and RoR) is a fantastic language that is highly marketable, and I would go out on a limb and say that it has much more longevity than php. &amp;#x200B; On Angellist, if you search for jobs under the keyword/skill of: php - 22 jobs Ruby on Rails - 113 jobs Ruby - 114 jobs
&gt; Where does python fit into this?? I can't really speak with any experience about python work, but I think it'd be even more difficult to find paying python webdev stuff. From my perspective of my field, python is even more of a sysadmin-focused language than ruby, so you're likely to find python listed as one-of-many requirements in a devops / integration / etl / qa job listing, rather than a specific "Python Developer" role.
\- Ruby on Rails (I'd recommend GoRails and Rails Tutorial. GoRails slack channel is amazing too - very helpful to beginners and people even post freelance gigs/jobs sometimes) \- Then Ruby (maybe launchschool.com) \- Then anything else. 
I used Parslet back in the day for something similar, hadn't heard of Canopy before, looks like it's newer? Wonder what the differences are. the article I linked at the end has a tutorial and example code for a Parslet-based parser for a query language that handles google/lucene style "+"/"-" rather than AND/OR. http://www.recursion.org/query-parser/#boolean_queries_should_must_and_must_not A long time ago (haven't looked at it in a while), I wrote a Parslet-based grammar that hands AND/OR/NOT (with parens), and a generator that translates the AST to a really weird lucene query. https://github.com/projectblacklight/blacklight_advanced_search/tree/master/lib/parsing_nesting
Okay so first: facebook. Second, of course PHP is not a hip enough language for startups. Third, "ruby" is going to glob "ruby on rails". What you're saying is, there is one job that possibly requires vanilla ruby knowledge and the rest are startups using rails to (most likely) build MVPs as quickly as possible.
\- Facebook was initially developed in php, but hires/develops in many different languages than php. Hell, they created React and the reason wasn't because php could do the trick they were looking for. &amp;#x200B; \- PHP hip. I am not saying php is bad, I am just saying that I wouldn't start there. And the ability to get a job/gig in RoR/Ruby is not difficult at all &amp;#x200B; \- "ruby" is going to glob "ruby on rails". Few points here: 1. Undeniable that there are at least 3x the jobs on angellist for Ruby or Ruby on Rails. I am pointing to angellist as I see that to be a decent barometer for the future of where web-development is going, not the past. Second, tons of companies build on RoR and continue to use RoR; it is irresponsible to say it's used to build MVP's. Several friends have HUGE companies that you would know of that build on RoR still today; companies may also may diversify into other languages for performance reasons as they see fit too. 
I like Ruby better
I just don't think python is a good language for learning though. The prioritization of "pretty code" over functional code. I teach Chef and some of the indentation styles I've seen are really... creative. But as long as the code is technically correct, it runs without issue. I've seen the same students get incredibly frustrated with python because the code is _identical_ to what's in the book/tutorial/etc. But oh, you have an extra space here, that you can't really see, and that's what this crazy nonsensical error message means, your whitespace is wrong. (This is also a big reason why Chef has been so popular and Ansible really hasn't at my job. People with literally no CLI experience can complete my Chef class.) Also, another major gripe I have about Python is that it does everything for you (making for a bloated stdlib), meaning if you go from python to a C (or Rust or Go), you're going to have a lot of catching up to do. (And don't forget: \#lolnotturningcomplete, and Guido thinks a Lmbda is a "one line function"...) Finally, I also think the Ruby community is more friendly. Not to say the python community is unfriendly So in my very biased opinion: don't pick Python as a first language. /u/Zexteh90: this is the book I recommend, it's a lot less dry http://poignant.guide 
Oh! I thought I already read this article. For now I actually settled on a very simplistic "parser" (e.g. mostly split :D) as it mostly fits what I need. And I'm going to move to a full grammar and proper tree traversing when I will need operator precedence etc. Here is what I got: [https://gist.github.com/localhostdotdev/5f851a7ce0ae60a5ae05d3fc98995bcb](https://gist.github.com/localhostdotdev/5f851a7ce0ae60a5ae05d3fc98995bcb) For now I can do queries like this: [https://gist.github.com/localhostdotdev/5f851a7ce0ae60a5ae05d3fc98995bcb#gistcomment-2875420](https://gist.github.com/localhostdotdev/5f851a7ce0ae60a5ae05d3fc98995bcb#gistcomment-2875420) (obviously not fully correct but works quite well)
I prefer programming in Ruby, but in 2019, recruiters are interested in my Python experience. 
Here‚Äôs my advice: Step 1: [CS50](https://www.edx.org/course/cs50s-introduction-to-computer-science), Dave Malan is bar none the best instructor out there for beginners, this class is for total n00bs and covers everything you need to know to get started. And it‚Äôs 100% free, it‚Äôs a gift to the world. There‚Äôs an active sub as well r/cs50 Step 2: Learn Ruby, first do codecademy Ruby Course to learn basic syntax and then jump into the koans or try to complete Head First Ruby Book, or follow the Ruby series on [The Odin Project](https://www.theodinproject.com/courses/ruby-programming?ref=lnav). Step 3: if you‚Äôre still digging it - hit up Rails (try [Rails for Zombies](https://www.pluralsight.com/courses/code-school-rails-for-zombies)), or Sinatra and build something fun. I recommend starting with Sinatra or jumping into Hartl‚Äôs [Rails ](https://www.railstutorial.org). 
https://open.appacademy.io/
Isn‚Äôt Ruby Monk dead?
It‚Äôs great for getting a quick overview of the language and syntax. 
You do know most of the web is built with PHP and all those sites need maint right? Not trying to say what better, just the reality. I love Ruby but PHP powers be web right now and by a wide margin. 
I mentored a friend last year who wanted to learn coding. She actually started off with JS, since she wanted to do front end stuff like React. That said, what we both discovered was that (in her case at least) it really didn't matter which language she chose as your first language. At her level of experience, it was more important to get quantity over quality. It was really important to just get used to reading a codebase for extended periods of time, figuring out how to solve problems, structuring code, learning how to write tests, etc. It could have been very easy to fall into the trap of worrying over the minutiae of language differences, ecosystems, tooling, philosophies, and so on. But at the end of the day, lots of practice was far more important and valuable for her starting out. Eventually she developed her own preferences about what she found effective, and went on to explore all the other stuff. So I'm sorry this doesn't answer your question. But I would suggest just flipping a coin, and choosing either one of them and start practicing. You can do web development with both, so just choose one and stick with it for at least a couple of months, making tons of throwaway projects. Eventually, you'll figure out what you like by yourself.
I do know that PHP covers a large percentage of the web. I once was a PHP developer and loved building on top of wordpress (30%+ of the web). &amp;#x200B; Again, I am not saying PHP is bad. I liked using it 10 years ago. But OP is wondering about Ruby and Python. And honestly, I would never start with PHP in 2019.
&gt; for i in range(len(things)) &gt; print things[i] Er? for thing in things: print(thing) It uses [iterators](https://wiki.python.org/moin/Iterator), just a more traditional style that doesn't involve passing around blocks of code to methods.
I‚Äôm with you - for just getting started Ruby is fun, and that will help your motivation for when things get tough and you‚Äôre smashing your head against the wall!
Oh hell yeah, I even recommend Ruby to OP. But as a side note - if you want to freelance learning PHP is a must imo. Learn both. 
Good starting point: Ruby Freelance, I hire people for Ruby/rails and funny enough, python for a different project. I‚Äôm 100% sure there are a TON of people wanting Wordpress help (php), but I would recommend Ruby all day long. There are enough ‚Äògigs‚Äô out there for each language 
OP. Welcome so web development, where there‚Äôs consensus on everything üòÇ
I don't use Python so I defer to you :)
The Odin project &lt;3 
I think, for most people at least, it‚Äôs important to learn Ruby before learning Rails. It helps you distinguish the core language from the ‚Äòmagic‚Äô.
1. Depends on the gem's license, but generally yes. 2. All the time. Very few projects have no dependencies. 3. A little of both. It's good to reinvent the wheel so you can understand how it works, but when you are building real world applications you should use the existing solution. 4. Could be either. If you're pulling in a big gem to save a couple lines of code it's probably not worth it. You should evaluate each one individually. 5. Most languages have some sort of library management system. 6. If that happens to a popular gem, someone will probably fork it and take up maintaining it. Otherwise, you can keep using it in its current state, maintain it yourself, or rewrite your project so you don't need it anymore.
Learn a language that will get you a job, as that seems to be your main concern. Once you learn something, you'll be able to pick up on new languages with the same family tree, e.g. LISP -&gt; python and ruby. Both are fine languages but in 2019 python will make you more employable. If you are the OCD type, python may appeal to you more because of whitespace indentation, if you want it to read more like english ruby is probably better. However to answer your core question re: employment, you'll probably be able to be a digital nomad easier if you learn Javascript and Node as that's used everywhere. 
Probably not a popular opinion on r/ruby, but I'd argue for python as a first language: * Simple, consistent syntax, whereas Ruby's is a lot more flexible (and hence harder to parse when learning to read code) * There's Only One Way To Do It is restrictive for a lot of experienced devs, but simplifies learning and reduces cognitive overhead for learners. Ruby practically fetishises the exact opposite, which makes much more powerful and expressive, but more complex because of that * Significant whitespace. Don't get me wrong - I *hate* SW, but again it ensures learners write relatively readable code long before they've learned *why* writing readable code is important. * Coding in ruby is a joy, so if you learn ruby first it will ruin you for other languages. Set your expectations lower with less joy-inducing, more restrictive languages and syntaxes and you'll be better able to tolerate other languages instead of being constantly frustrated they're less expressive than you're used to.
&gt; I hear both are the easiest languages to learn Not sure I agree with that. However had, let's ignore it. Ultimately I think it does not make that much of a difference because you can use both languages and both languages are fine. Evidently I am biased in favour of ruby. But python has a few things going that actually are better than in ruby - and one thing has absolutely nothing to do with python as a language. You simply have more users and more developers and also more momentum in python right now. That is worth a LOT. From a design point of view, ruby beats python hands tied and eyes closed. I could give lots of reasons here but if I have to pick a single one then it is explicit self in python. I hate it. EVERY SINGLE TIME I USE IT, it annoys me. I go "why do I have to tell stupid python where self is, why can it not know by default". There are more differences, but I think the biggest single difference is the philosophy. The philosophy is actually the biggest difference; syntax is only secondary. I don't know which aspect you prefer in any given language. Syntax-wise python is acceptable. Philosophy-wise hmmm.... I think ruby's more liberal and open "attitude" is better. For example, take mandatory () for methods versus non-mandatory. People say python code is easier to read because () is mandatory, but this is still bogus because IF this were a huge compelling argument, YOU CAN USE () IN RUBY JUST FINE. Just that people who are not FORCED to use it, tend to not use it. But it varies - I use () all the time when it comes to method definitions. Others omit it. I can understand this too, even though I myself don't do it. But again - philosophy is by far the biggest difference. I came from perl then PHP and I also had the choice between ruby and python. For me it was this interview that decided it in favour of ruby: https://www.artima.com/intv/ruby.html I still think ruby's philosophy is massively superior to python's philosophy. :) If I were young these days, and had to choose ... I am not sure if I would choose ruby. Primarily because of python having so much momentum right now. But from the philosophy? Yep, ruby wins. Design? Yep, ruby wins too. It's not a huge advantage though - momentum is really really important. Look at the shit that is JavaScript - having a de-facto monopoly in the www helps a lot. It catalyzes the terrible nature of JavaScript. I don't regret in the slightest to using ruby though. I think ruby is great. I am also using python but I write a lot more ruby code. Still do so, too, mostly to just get things done (I am less in tinker mood these days and more in get-things-done mood). &gt; what sort of work i would be looking at with each &gt; language (freelance &amp; office) I think this is a TERRIBLE aim. If your goal is to only use languages because you want a job, then you don't care about the language anyway. So use the language that gives you the better job; and more pay. But don't go to use a language because you'd LIKE it, because that may interfere with the dredge that your job may be. Job requirements have, thankfully, NEVER factored into any of my decisions in regards as to whether I would use a language or not. I have had offers of decently paid PHP jobs in the past and I happily rejected them because I can not want to bother my brain with PHP's terrible madness. And money isn't a compensation for wasting my life with this inferior joke of a "programming" language. (It's still better than having no language; but it is so massively inferior compared to e. g. ruby or python that I don't get why people really still write PHP these days).
I don't do web dev! Ok, I do ... but not through rails. I actually do more non-web related stuff in ruby, too. &gt; Personally I use Python sometimes for small things I &gt; can't do with ruby (mitmproxy, machine learning, etc.) What the ... ? You can not do "machine learning" in ruby, because of ... ?
Sounds as if there are more reasons in your case to use python than ruby. Just saying.
Because nobody needs it really. Why would you need it for learning ruby or python?
Because the website is based around teaching you those languages???
It "sums" it up without meaning anything. Unless you mean you use languages solely because they are popular. Which is a terrible use case - it's like delegating other people deciding for you. Terrible. I am not saying that popularity is bad, mind you. It can generate a LOT of momentum which is really really a good thing. But to pick due to popularity ... waaah. If we'd do that, we would all use Java. WHO WANTS TO USE JAVA EVERY DAY......
Ruby has not confused ME when I moved to other languages. Why would it have done so? 
I don't know what you mean with "friendly". Ruby is a lot of fun and you are able to decide on a lot more things on your own than with python. But python is also perfectly fine as a language. In my opinion both languages, while competitors, are sitting in a VERY similar niche. The "scripting" languages niche really.
I don't necessarily disagree with you but ... for loops are available in ruby too. Just that people tend to not use them since they can get away with .each which is a LOT more natural to do than having to use an index (such as through the i loop example in C and python; although in python I think there are also other ways without an index counter variable).
Ah yes exactly! I just wondered about his example. :)
Yikes ... you suggested PHP. Dude ...
Python is the better language for Web &amp; Apps???
Citing Facebook is a pretty terrible reason IMO.
If you think it may be worthwhile, you could actually suggest to ruby core the ability to just include specific methods per se. Matz will very likely listen to your described use case and who knows what may happen from that. (I only suggest doing so if you really want it though. I myself never had a need to distinguish so far between different methods in Enumerable and elsewhere)
This is a Ruby Subreddit, so it is expected people will favor Ruby over Python. I support Python over Ruby because is a simplier language, anonymous functions are just functions (not procs) which will signify A LOT when you begin to do functional programming, and is favored by a broader number of fields, not just webdev.
I mean, it's all subjective. Two big reasons I think someone could get confused: * Many other languages don't do as much "for free" for you as Ruby does. Linked lists vs. arrays in other languages for example. Writing in-place functions (and the cost of copying) for another. I think it could be difficult for someone to learn these things (and how to detect them) in reverse. Someone who comes from lower level languages can spot these right away. Neither Python nor Ruby will protect you here, and I'm not sure learning a C/Java first makes any sense today * Ruby has a very particular syntax. There isn't really a "for" loop in Ruby for example (I mean, technically there is but it's not idiomatic). Blocks are pretty unique as well. I think Python is a more comfortable language for a lot of people coming from lower level languages because it has a lot of syntax that is similar to those languages I'm not here to fight in some language holy war, I just personally think Python has wider adoption and acceptance than Ruby, and I'm speculating as to some reasons why that might be
Maybe the `blah` had side effects? Seems like an error happened while executing it
That is just to get into better\_errors console [https://github.com/BetterErrors/better\_errors](https://github.com/BetterErrors/better_errors) . Sort of way to debug:-)
At a minimum, I think it's important to understand the basics, for sure. But I don't think you need to go crazy deep into Ruby to make progress and to understand what is going on with Rails/development. 
Basically good choices for first language are: javascript, ruby, or (maybe) python. Anything else is madness. Javascript is actually a shitty language, but the tooling to get something impressive done and motivate beginners is unmatched. There's also real good on-ramp - starting from html (ridiculously forgiving), then css (still very forgiving), then actual programming. Without having to learn terminal, git, editors etc. same time - you can start [with something like freecodecamp](https://www.freecodecamp.org/) and get really smooth learning experience. Basically the default first choice. From language quality point of view, ruby wins. It's good, beginner friendly, and it's easy to teach people proper TDD etc. As long as you don't need to run it on Windows, then don't even bother. And it's basically useless terminal program, which to be honest isn't terribly motivating for most beginners. Python is kinda, close enough, especially if you have some data science adjacent background. There's no really any advantage over ruby. [Tooling is awful](https://xkcd.com/1987/), half the online resources are still Python 2, and nowadays it's a lot more complicated language than Ruby since they added 50 features to cover 1% of use cases for blocks instead of just having blocks. Python 1 used to be simpler than Ruby 1, but that's long been false. TDD is also kinda an exotic idea in Python world. There's also related issue that beginners tend to be godawful with indentation, and Python is really unforgiving on that. They learn eventually, but it's another layer of pain. I guess it runs better on Windows at least. Source: I taught a lot of beginners, also all the bootcamps etc. (learning one of those as second or fifth language is a very different story - javascript doesn't really have much advantage there)
I don't know your exact issue, but I see a few things wrong here. 1. Ruby `and` vs `&amp;&amp;` are two different things, especially when setting something with `=` (see https://stackoverflow.com/questions/1426826/difference-between-and-and-in-ruby) 2. BetterErrors sometimes has issues with variable caching/session depending on the server you're using (although it usually shows an error when that happens). I'd suggest looking into the pry gem and using `binding.pry` to open your debugger instead.
That was it! \`&amp;&amp;\` solved it. Thank you!
It is about priorities. Boolean "and" is `&amp;&amp;`, while `and` is control-flow one. So, this code: want_select = options.has_key?(:type) and [:select, :select2].include?(options[:type].to_sym) Evaluates this way: (want_select = options.has_key?(:type)) and ([:select, :select2].include?(options[:type].to_sym)) So `want_select` contains only the result of the first statement. To achieve desired effect, you should use want_select = options.has_key?(:type) &amp;&amp; [:select, :select2].include?(options[:type].to_sym) The `and`/`or` are control-flow operators having very low priority, for allowing code like this: variable = evaluate_something or return 0 very &amp;&amp; important || check and raise "It was all wrong" 
It‚Äôs funny how often this question is coming up recently. I wrote a post on learning resources for Ruby here: https://www.wndx.com/blog/next_steps_for_learning_ruby/ Obviously, I recommend Ruby! üòâ
No, but your reasoning is incorrect, more experienced devs means more job opportunities, not less. Competition isn't really a thing in this job market, it just means more opportunities for apprenticeship, and more code bases to learn from in junior positions.
Eek. I really couldn't disagree more. If you're serious about getting into web development, having a strong grasp on the fundamentals of the language is paramount. 
&gt; python is quite popular in my area so I feel like it would be tougher landing a job as there is so many more experienced devs locally One hole in this: many Ruby shops hire people who don't know Ruby. In fact, of all of the Ruby shops I've worked at (I think I'm on #4 now?) only a few people I've worked with knew Ruby prior. A Ruby shop would easily hire someone who had Python experience. Going the other way can be a harder sell
I think it's pretty obvious that Java is nothing like Ruby or Python, so your example does not make any sense. It's actually pretty ridiculous. If your interests are NOT 90% web dev you should go with Python, because Python is more popular, and that translates to more job oppurtunities, more tutorials, bigger comunity so you can get help and its actually used in more fields (machine learning, desktop applications etc). And is just as easy to learn, unlike fucking Java. And btw, I am Ruby web dev.
Both are friendly, the learning curve does not differ that much to be relevant. And it's also a personal thing. IMO the fields that you are interested count more.
Popular amongst hobbyists, not employers. 
Ruby - for fast scripts (backend, websites) Python - for big data (crowler, ML)
Thanks, shevy-ruby.
Got my first job from the Odin project. I couldn‚Äôt recommend it enough. The section on getting your first job is well worth anyone‚Äôs time. 
What kind of job did you end up getting?
`rumouse` works great for that!
I landed a dev job at a SaaS company working in ruby and rails. I live in Minneapolis so there‚Äôs quite a lot of tech jobs here but few in Ruby - which was great because I was able to negotiate a higher salary than most junior javascript devs. It took longer to get a job however. But it was worth it. 
Awesome! Was your salary what you expected? Did you get steady raises?
Learn ruby the hard way is the original whereas Python even though it came later on, it is widely considered as one of the best book on the market. P.S. learn C the hard way is amazing too!
It was higher than expected - and I‚Äôve found that to be true for Ruby jobs (at least in my area) and I worked my ass off and got a very nice compensation package. 
I advocate for Elm or Haskell.
[You are extremely wrong.](https://en.wikipedia.org/wiki/Zed_Shaw#Books) Python book came out 2010, Ruby in 2014. But it's not a matter of timing, Ruby book is basically "Learn Ruby like it was Python" and it's the worst Ruby book I've ever seen any beginner try, and I've seen beginners try a lot of resources. The Python version was OK, except for the inevitable Python 2 vs 3 issues.
Learned Ruby as my first language, but it wasn't my favourite. Python got me much more involved and in love with comp sci. Im only now revisiting ruby and I can say, it much more enjoyable. But yes, start with Python.
Are you trying to cheat at fortnight? 
I‚Äôd say python. Ruby‚Äôs syntax is more lax so u could probably get away with the desired affect even if u miswrite a line, but this conversely can get u used to expecting the interpreter to pull the slack for u. Both languages have a clean syntax but python is much more predictable IMO. Things work the way they look like they should and when they don‚Äôt u can easily tell where things have gone wrong. Ruby doesn‚Äôt feel like a beginner language to me. It‚Äôs a language designed by programmers for programmers (that‚Äôs every language ever, LOL) and it really shows. To really appreciate how cool ruby is, become moderately good at another language first, then try ruby and be blown away with how weirdly nerdy it is. Ruby is my ideal language, but not me default goto, if that makes any sense; I appreciate it like a work of art.
Hmm libxdo perhaps. https://github.com/riddochc/libxdo-ruby There may be more variant than this. It is a wrapper to xdotool.
Cool - did not know that project.
I'll comment only on a few: &gt; What if I use a gem for a project, and then the gem's author delete his/her gem? You can easily re-host it on rubygems.org, even if you may have to use another name. Always keep backups of all your gems too. It is not an issue IMO. When an author deleted a gem, this often also meant that the author no longer wanted to maintain it. &gt; How often do you rely on gems? I rely on some core functionality - kramdown, prawn ... However had, I also write a lot myself and put it into gems too. There is virtually no drawback for making your own gems, only the time investment. People should publish a lot more gems - it also helps you learn how things work together.
I read OPs interpretation of the job market as fully backward as well. Your comment outlines exactly why. Also, Python is really great at web apps btw. Flask/Django/sanic are all top flight web app frameworks built in Python. In some ways there are more web app options in Python. Learn either language well, and learning the other is easy.
ragnarok online
im getting this ugliest error inside my vagrant &amp;#x200B; Could not open library 'libX11.so': libX11.so: cannot open shared object file: No such file or directory (LoadError) google sucks with this \^
I think it‚Äôs because you‚Äôre running headless in Vagrant. You can use Xvfb. It‚Äôs a virtual display server.
Sounds like there are not enough Ruby devs around.
Congratulations!
The same. I‚Äôve never regretted learning javascript and I use it everyday. Not the same as I use Ruby, but I honestly write JS every single day. I would suggest every new dev, no matter where you are in your journey, learn as much JS as you can. Obviously the job you get is going to have a factor, but you will never waste time learning Javascript. And I mean vanilla JS. Be strong in your fundamentals and only then learn a framework. 
One thing I‚Äôll disagree with here is this: for scripting, I‚Äôd choose Ruby over Python. There are just so many gems and fundamental Ruby objects that make writing scripts and tiny little apps (Sinatra) for some seriously powerful interactions. So many large apps use Ruby scripts to do small little interactions with other API‚Äôs you‚Äôd be at a disadvantage if you didn‚Äôt know just enough Ruby to get by. Seriously, a small amount of Ruby knowledge can go a LONG way. 
Almost accurate. Web dev in Ruby is great. The real power in Ruby is scripting. 
Ruby is fantastic for learning OOP. When I learned that not only could I manipulate objects by calling methods on them, but I could define my own methods or even REWRITE methods that didn‚Äôt do quite what I wanted them to, I realized the power of the language. 
Ruby? Performance? Thats like oil and water.. they both hate each other.
I'm sure a bot already exists. Everyone else in that game is a bot.
Dude, Applescript. You can call ruby from Applescript and vice versa, much easier if you're gonna do UI scripting. 
I‚Äôve has success in the past shelling out to https://github.com/BlueM/cliclick (macOS only)
There isn't, but there is a built-in implied duck type of "objects that only implement `#each`". It's the default minimum interface for `Kernel#to_enum`'s Enumerator constructor.
Yah, inOpinatus, you rock! Thanks !
That last point should definitely *not* be understated, either. Ruby is such a joy compared to ... nearly everything else. I'm good with Python, but it infuriates me.
Autohotkey
You are correct, my bad :) 
&gt; There is virtually no drawback for making your own gems, only the time investment. People should publish a lot more gems - it also helps you learn how things work together. I'll nitpick this - if you reinvent the wheel, your wheel won't be as good as the existing one because it hasn't been tested and refined as much. You're diverting effort that could go into improving the existing plugin into duplicating its work. Rebuild gems all you like for the purpose of learning. When you're building real projects meant for use by other people, you should use existing gems so long as they fit your needs. If they don't quite fit, consider contributing to the existing gem rather than starting your own from scratch. 
This is an interesting thing to play with, but I'm not sure what real-world problem it solves. The "**Why?**" section is basically empty, it contains no rational or real-world use cases, just a list of errors that you can provoke if you try to use this gem without the gem being installed.
It's very *very* unlikely that Matz will break Enumerable up for any one person's use case.
legacy sites are PHP, yes. But in my experience most sites started in the last 10 years are NOT Php, they're either node, python, go, or ruby
https://www.rubytapas.com/2019/01/08/boolean/
You can use "!!" instead of to_bool. :)
You thought Ruby is confusing about booleans so you decided to add even more classes? Nice way no make Ruby a JS.
Thank you Lord Hongli
Don't let untrusted regular expressions kill your servers (cannot be caught with a Timeout ).
&gt; Some people on Twitter were talking about returning to Ruby if the memory usage issue &gt; is resolved, because that's what drove them away in the first place. Bogus. Sorry to say it like that but it is bogus. People who claim the "memory usage" was what made them switch to, let's say, Go ... nope, sorry. These folks aren't the ones who "will come back". That is just completely pointless to even want to claim - even more so as Hongli Lai provided A TOTAL NUMBER OF ZERO SPECIFIC EXAMPLES OF IT. That is not to say that improvements over memory-related aspects would be bad, mind you. I think that is a perfectly fine focus to want to improve. I just find it disastrous to want to insinute that there is an army of invisible, unnamed people who just cant WAIT to "return" to ruby but the "memory situation" has been the one that made them leave ... nope, sorry. Totally bogus.
Head First Ruby is excellent for new Rubyists 
The real-world use case is 1) type annotation e.g sig [Bool]=&gt;[Bool], 2) is for (type-safe) serialization / deserialization (of state) and 3) for using Bool.zero (for a bool default value for always initializing (state) variables. This is just for the universum (world computer) runtime / library (see &lt;https://github.com/s6ruby/universum&gt;). PS: Ruby on Rails also includes a Type::Boolean with a cast method and so on (see &lt;https://api.rubyonrails.org/classes/ActiveModel/Type/Boolean.html&gt;).
The `to_bool` method is an implicit conversion method / function and returns nil if it cannot convert to bool (true/false). `to_bool` is an alias for parse_bool. The `to_b`is the "classic" explicit conversion method / function. 
FYI: Ruby on Rails also includes a Type::Boolean with a cast method and so on (see &lt;https://api.rubyonrails.org/classes/ActiveModel/Type/Boolean.html&gt;). Try a search on rubygems for bool / boolean for more classes.
Great article. To answer the question about shared code / behaviour. If you look at the code (see &lt;https://github.com/s6ruby/safebool/blob/master/lib/safebool.rb&gt;) you will see the shared `Bool.zero` and `Bool.parse` and `Bool::TRUE_VALUES` and `Bool::FALSE_VALUES` shared between `true`/`false`.
I'm not sure I took it like that. I definitely get what you're saying, but that's a pretty strong reaction to a throw-away one-liner. 
You do NOT want to remove the Gemfile.lock. You want to install the dependencies in Gemfile.lock with `bundle install`, that's your only hope. Bundler's job is to keep your dependencies isolated so you don't need to worry about them conflicting with anything external, _and_ to keep track of exactly what version of each dependency was used in the 'last known good' snapshot in Gemfile.lock. If `bundle install` isn't working, then the task is to get it to work. You might need an older version of `bundler` or `rubygems`. You might need an older version of ruby too. (Do you know what version of ruby was originally used with it?) I'd research to figure out what version of ruby/rubygems/bundler was out around rails 3.2.21 release. rubygems.org will help you figure that out for bundler and maybe rubygems itself. 
yeah, but I'd totally want to get it to run before working on upgrading, and I believe it can be done! If it was a pre-bundler version of Rails pretty much all hope would be lost, but with a bundler-using app, it should be do-able with some work. 
There, \* is the splat operator. It uses an array as the arguments to a method. In the conditional block, '%5d' % e is shorthand for Kernel.sprintf.
`*cols` ["splats" an Array into arguments](https://docs.ruby-lang.org/en/trunk/syntax/calling_methods_rdoc.html#label-Array+to+Arguments+Conversion). You can also use the splat operator [in assignment](https://docs.ruby-lang.org/en/trunk/syntax/assignment_rdoc.html#label-Implicit+Array+Assignment) The `'%5d' % e` is the [String#% method](https://docs.ruby-lang.org/en/trunk/String.html#method-i-25) or the "format operator", also known as [Kernel#format or Kernel#sprintf](https://docs.ruby-lang.org/en/trunk/Kernel.html#method-i-format). The `'%5d'` format string takes a single argument (only one "%") that will be converted into an integer that is 5 characters wide. The arguments come from the right hand side of the `%` operator, "e", the element for that position in the table. This makes the table work. 
Thank you:)
1. `*cols` is the splat operator. Here it just take the second element (index 1) to the last (index -1). Since the first one is take and fed to the `.zip` 2.
Thank you:)
I don't need information about Rails. I'm a programmer.
üëã 
Tell that to my linkedin inbox. Clearly a lot of recruiters haven't gotten the memo yet.
I'll keep it simple: Ruby. Ignore the web-dev only niknak stuff. Some the most powerful, most widespread backbend deployment and monitoring systems are built and ran on a pure Ruby stack; Rails excluded. Puppet, Chef, brew! The list of common everyday apps severely gets underscored and undervalued by the Ruby community. (full disclosure: the elephant in the room is largely webdev related stuff, but still!)
long time no see :D that was a fun bug to find, I bet you know where it was hiding :)
Most of the dynamic web is WordPress/Drupal/etc. Chances are that many of their maintainers aren't programmers at all and have no particular loyalty to PHP.
Sometimes I wonder if **Ruby** really do have a memory problem, or **Ruby Rails** have memory problem. &amp;#x200B; &amp;#x200B;
I may have accidentally said you left ZD and were working for that company monad or something. Ooops 
&gt;Suddenly, in the back of your head, you start hearing this whisper, telling you Rails might not be able to handle the huge traffic load without a lot of caching parts. Frankly, If you're splitting your app into two parts because you couldn't handle hundreds of thousands of users in your Rails app you are very likely prematurely optimizing. Sidekiq on its on is an absolute beast and is easily gonna be able to handle 4,000 + jobs per second throughput on its own, do you need more than that? And in the end, like every other web app you are probably just going to be waiting on I/O from the DB. Not bumping into sidekiqs limits. Rails / ruby is much more performant than this article claims. For example, we have a distributed broad crawler running on Rail 5.2 w/ sidekiq and Postgres 11 that crawls up to 50M urls PER DAY, has Billions of rows of data - All running on Stock Rails. The reality is that the majority of users who will claim scaling issues and necessitate complex additions like this are probably no where near the limit. Not only is it unnecessary, but all you are really doing is making API calls instead of method calls and slowing dev down in the future by prematurely splitting this into two projects. &amp;#x200B; &amp;#x200B;
Nah I'm good at ZD for now :)
"Ransack but for in-memory use" is one of the use cases I had in mind writing Rack::Reducer - https://github.com/chrisfrank/rack-reducer You'd need to use URL query strings instead of the nice-looking DSL you've already started to implement, which I guess could be a good thing if your users already understand query strings, but a bummer otherwise.
&gt; FYI: The to_bool method is an implicit conversion method / function and returns nil if it cannot convert to Bool (true/false). `nil` is falsy in Ruby. What is the point of this?
So this is a gem that re-implements functions...ok....
That's really cool, doesn't seem to support operators though (I still have the parenthesis/priority of operations in the backlog but otherwise yes it's pretty much done, nothing fancy, just a reducer like you did :) )
Isn't that technically what all libraries do? 
Nope.
This gem allows rails developers to easily implement a pattern that will reduce controller bloat and help maintain the concept of single responsibility. It's a fork of the interactor gem which includes validations, callback support, and thread safe perform methods. I'd be happy to answer any legitimate questions you have about what it does, but it's also pretty extensively documented as well: https://rubydocs.info/gem/activeinteractor
Poor guy. Looking at the top 500 supercomputers should have been enough to realize that Microsoft only creates toy OS these days. &gt; I very strongly believe that many Ruby/Rust/Go/Elixir/Scala and even some Node developers &gt; who end up doing the WSL dance or run Linux in a VM for development, or use Linux Docker &gt; for dev on Windows are not aware of the full extent of the tax. People are very well aware that WSL is not ... super fast. Even the WSL team has acknowledged this. Windows is a terrible OS, the WSL however had is still a good idea. If you are using Windows to begin with, you already pay a huge price aka slavery. You are not in control of much at all. On Linux you have this situation to some extent partially in that you also depend on other developers, naturally. But there is the POSSIBILITY of more customizability (if that is even a word). Don't like systemd? You can use Linux perfectly well without it. Same for many other components (to some extent). It is not solely a question about ethics but a question of who controls which stack and how. Forced updates that you can not disable? Microsoft follows the philosophy that it owns your computer. I can not agree with this top-down view. &gt; WSL is not an option for me cause Ruby likes lots of small files and lots of stats calls, WSL &gt; has terrible lots of small file performance as documented by the WSL team. That's still rubbish. I was compiling on WSL Win10 in the GoboLinux manner, and while it was significantly slower than on my linux box, it never was a real problem per se. The difference to e. g. the ruby one click installer was small. &gt; As a baseline just running a rails c console without bootsnap was taking me upwards of 30 seconds. I get this here on linux too via bundler installing random shit. ;) The rails people are just crazy. &gt; I like the Windows 10 font rendering, I like the HiDPI support, I like using Lightroom &gt; on Windows and playing Rocksmith on Windows. I like the out-of-the-box experience &gt; and minimal amount of tweaking needed. You can have this for the most part on linux too. Use SLAX, remaster it to your liking, use that. Then the tweaking has already been done. &gt; I felt that if I start booting to Linux I am going to have to fight with drivers, have &gt; stability issues, not have a complete toolset and so on. What the hell are you talking about??? Not a complete toolset? What does this mean? WHAT EXACTLY IS MISSING. Stability issues? What the hell is he smoking? Seriously? Stability? HOW? Of course don't run a clown distribution aka all systemd crappers, but aside from this, seriously? It's not that I am stating that linux is perfect, it's not, it's quite shitty in its own way too. But it works very, very, very well. And absolutely nothing here is SPECIFIC, just random FUD. Don't use crap distributions. So we have to exclude most already. There are still a few points that are valid. Not about stability but about ease of use. While Windows is a clown OS designed by clowns for clowns, there is indeed less maintenance work that the user has to do compared to a typical linux distribution. This is unfortunate. But it hardly means that the other claims are correct... pffft "stability". I reboot like 1x in 180 days or so. Simply because there is no need to constantly have to reboot if the system is working, which it is.
At my job I was given a Rails 4.2 app. As I only had my Surface Pro 3 to work on it was like pulling teeth attempting to get the gems to build successfully. Eventually I just moved to an old Dell Optiplex from 2012, running Ubuntu. Ubuntu on WSL did solve the native gem issue but on both Windows and WSL there was a huge issue with application performance when using the console or dev server. Even on a computer from six years ago it massively outperforms the above. I am developing a Rails 5 application on my more powerful desktop PC from this year and it definitely feels faster, though I would imagine running Ubuntu would still give a significant boost. It's a bit of a shame considering I love writing Ruby yet I'm tethered to Windows for a number of reasons (mostly proprietary software).
Very quick skim through: - no readme - a `binding.pry` in a class You could run rubocop and prettier ruby to have some automatic review of your code BTW.
* Does not handle exceptions e.g. `JSON::ParserError` * Needlessly puts code in `AlexaSkills` module instead of `AlexaSkillApp`. Why create a module if only once class includes it and that class has next to 0.0 methods/code? * Uses `@params` when Sinatra API public is `params` (I'd just stick to `String` or `Symbol` keys, and/or use [`:symbolize_names`](https://ruby-doc.org/stdlib-2.6.2/libdoc/json/rdoc/JSON.html#method-i-parse) * Confusing method name(s?) (Maybe this makes sense as to skills devs?): `AlexaSkills.interact!`. Better to name them after what they do e.g., `AlexaSkills.order_pupusas` * Calls `Faraday.send
I don't understand why devs don't run a *nix CI / CD server on their LAN, and offload e2e and integration testing to it.
It's documented in the readme - see the error handling section :-). to_b is "strict" and always returns true or false (not something falsy or truthy) and to_bool / parse_bool has three values true / false and nil. Nil is for a "relaxed" cannot parse to bool error condition. If you use Bool() you will get a type error (on nil) instead.
I think you're right about operators ‚Äî I can't see an easy way to support OR, in particular, when the data are in an Array. Something for me to think about for v2!
I've always thought that Ruby running on a Mac OSX should be as fast as on Linux. Anyone else here that has done similar comparisons - Linux vs Mac OSX?
in Ruby 2.6, you can use infinity range , like `1..`
I've been developing Ruby primarily in WSL for a couple years and find it to be pretty good. To hear there are performance problems using Ruby isn't news to me either, I think that has consistently been the number one complaint about Ruby. However, I am appreciative to know that the Ruby design of having many files making many stat calls essentially is part of the problem. 
That was a novel alright ... great read btw!
Rubocop is too slow to integrate into "format on save" or "format on paste". Rufo has treated me well, though. Integrates beautifully into vscode.
That was a good read, even though it was definitely way too biased towards rubocop (as the author states). Rubocop does not work as a formatter. At least, it doesn't work well. It's super ridiculously slow. On my machine, it takes close to 4 seconds to format a time that rufo does in under 100ms. The absolute worst part about rubocop is that _it does not align `end `s with everything else_. This drives me absolutely crazy. I wouldn't mind waiting for this formatter every time I saved or pasted if it worked, but I have to wait and then go in and manually format anyways. Rubocop is a great linter though. I wish there were other formatters out there configurable enough to keep up with rubocop's linting configuring, but I don't think there are any out there. If rubocop fixes those 2 issues (white space alignment and speed), then it would be perfect. It's unfortunate how bad those 2 issues make it to use on a daily basis, but I think those 2 things are keeping a lot of people away from it.
Great points an something we're definitely aware of. As I mentioned they are mostly an artefact of the fact that checks and edits are applied sequentially to fit with the overall architecture and that adds a lot of overhead (mostly when you start writing back the changes). It's not an unsurmountable obstacle, but we probably won't tackle it before completing the roadmap for RuboCop 1.0. &gt; The absolute worst part about rubocop is that it does not align ends with everything else. This drives me absolutely crazy. I wouldn't mind waiting for this formatter every time I saved or pasted if it worked, but I have to wait and then go in and manually format anyways. I don't quite get this, so some details would be helpful. I assume you're referring to the fact that EndAlignment doesn't auto-correct by default, but that's mostly because it's a lint check, which the extra implication that you might have misaligned an `end` thinking you were closing something else. The auto-correct can potentially mislead you, therefore the current behaviour. Obviously it's debatable whether that's really the best behaviour or not. 
Thanks!
No argument from me. :-)
Sorry, I could have given more description. I know tone doesn't carry over well in text, I just want to point out that I think rubocop is amazing and I cannot even fathom the amount of work it took to get it to where it is today. My point was when you removed the linting part, and look at it as just a formatter, that it still has a long way to go. What I was talking about was with something like this: module Foo class Bar def thing stuff = if other_thing 4 else 5 end end end end When formatting, it looks like this: module Foo class Bar def thing stuff = if other_thing 4 else 5 end end end end It shifts the `else` over to match the `if`, but doesn't shift the `end`. I've come across this behavior a lot, not just with if statements, but also methods, classes, modules, etc. My team has recently switched to using rubocop for linting and formatting, so we went through and reformatted all of our source files and this drove me crazy for days, lol.
If it's running on a version of Rails that is EOL'd and does not even receive security updates, I'm never going to be comfortable with it as is. And that happens reasonably fast these days. I guess there's still a decision of whether to upgrade or rewrite (or abandon!). I suspect upgrading is almost always the right choice especially if you _don't_ plan on doing significant future dev to add features in the future, you just want to keep it running. But this is a good guide to figuring out _how painful_ it's gonna be either way. 
long overdue improvements to AM::Errors API!
This may be the feature that forces me to look at VS Code Studio instead of SublimeText that I've been happy with. Anyone using the code share feature with ruby?
A related issue filed at the repo : [https://github.com/rubocop-hq/rubocop/issues/6774](https://github.com/rubocop-hq/rubocop/issues/6774) 
Disclaimer: I participated in a project as an author of initial idea and with some mentoring of the author, and I believe it is a good thing (even if it is still in its early days). From readme: &gt; Forspell is spellchecker for code and documentation. It uses well-known hunspell tool and dictionary, provides customizable output, and could be easily integrated into CI pipeline. &gt; Features: &gt; &gt; * Able to check Markdown files and comments inside Ruby, C and C++ source code; &gt; * Correctly skips over code examples and identifiers inside comments and Markdown most of the time; &gt; * Distributed with latest en-US hunspell dictionaries, but can be set to use any other dictionary; &gt; * Includes by default custom Ruby ecosystem-related dictionary (so it will not report as misspelled words like "Gemfile", "args", "middleware" and alike); &gt; * It is easy to create custom dictionary for your project, so your internal terms would not be reported as misspellings; &gt; * Option to auto-generate initial custom dictionary; &gt; * Several output formats, including pretty colorized human-readable, YAML and JSON. 
&gt;But this is a good guide to figuring out how painful it's gonna be either way. Thanks! I have an overly ambitious goal to write a "calculator" gem to actually calculate how painful it would be... 
You can also format on commit
&gt; At this point I‚Äôd like to tackle the general premise of having one true code layout &gt; style for a programming language like Ruby. Allow me to first start that I think rubocop is great; and a great idea. It would actually be pretty cool to have cross-language linters/correcters too. Ruby-to-crystal might be one doable but you can think of llvm also acting a bit similar to that. But anyway. The big problem with the comment is that it assumes that there is only one true style to write ruby. And that goes against a more than one way/point of view. &gt; I think that adopting an universal formatter/code style 25 years into the existence &gt; of a language is unlikely to (fully) succeed if it‚Äôs not driven from the top (Matz). I don't think this is likely to happen because it would pursue a different philosophy. IMO it would be better to fork ruby and model it into a separate/different language in that case (not that I necessarily say that this should happen, although a compiled ruby-like language would be interesting, just to see; crystal is not quite that. I am more thinking of something on the same niche as ... big daddy C. But as we all know the xkcd, we will just end up having more standards... and more languages...). &gt; There will always be strong opposition to whatever the formatter tool authors &gt; decide, as people have built strong preferences by this point in time, and &gt; they‚Äôll need extremely compelling arguments to change them. Because many style guides are essentially just personal opinions. Some make sense but others are hugely arbitrary. It comes down as to how much flexibility a parser allows you to get away with. &gt; gofmt succeeded mostly because it was pushed from the top, pushed from &gt; the start and everyone was expected to use it. I‚Äôm reasonably sure this &gt; ship has failed for Ruby. I would not use a language controlled by Google, but to pick up the example, gofmt seems hugely opinionated too. They use tabs for indentation, despite stack overflow demonstrating that people who use spaces make less money (that is not even a first april joke). Why this sneaky tab insertion into my code? I think tools that care about that, are badly designed. make + Makefiles have the same problem. &gt; I agree in principle with the merits of the idea of unified coding style &gt; and formatting tools without configuration options, but I doubt that‚Äôs &gt; feasible in (Ruby‚Äôs) reality. This is possibly true but don't forget "convention over configuration", or to make it simpler ... a lot of configuration can lead to complexity and loss of fun. I had that problem with vim - it just wasn't fun anymore to sift through gazillion of configuration options. &gt; When I started to work on RuboCop many years ago, it wasn‚Äôt &gt; configurable (it just enforced the Community Ruby Style Guide) &gt; and many people were outraged by this. Because in this case, it actually is the worse strategy. By actually being able to have people adjust the style guide to whatever they use in their projects, they can use rubocop for many different projects and have it enforce the style in these projects, no matter which style guide that is. Even if they have to indent via tabs, as stupid as that is - I think it's great that software exists that helps them go that way, if they have to. &gt; Here‚Äôs a favourite example of mine: def send_mail(source) Mailer.deliver(to: 'bob@example.com', from: 'us@example.com', subject: 'Important message', body: source.text) end def send_mail(source) Mailer.deliver( to: 'bob@example.com', from: 'us@example.com', subject: 'Important message', body: source.text ) end I mostly use the latter myself. But there are indeed cases where it is not clear which way would be superior. def foo(a,b,c) versus def foo a b c I prefer the first, but the second is simpler and easier to type, so I can understand people who use it. The bigger question is whether a language should ALLOW for this - and it fits to ruby's philosophy. That's the biggest difference to e. g. python. Here you don't have the freedom to choose, so python chooses for you. And this can be good or bad - it's good because code will be uniform. It's bad because DSLs by default will never be as pretty in python as-is, unlike in ruby (you can of course use different DSLs that are not evaluated on the python parser level but it's not that simple anymore). &gt; Still, I was quite disappointed with the way the new AST library &gt; was introduced, as to my knowledge the Ruby Core Team didn‚Äôt &gt; really engage in conversations with any of the maintainers of tools &gt; that make heavy use of such functionality and could have provided &gt; them with valuable design feedback I don't think this is necessarily true. One thing that instantly comes to my mind is lack of time; the other may be the language barrier, but I think it is mostly time. I see it with myself - I have been cutting time a lot in regards to computers (including ruby) in general due to other time constraints. I don't think I would have enough time to also "reach out" and get a lot of people involved when I myself already struggle being actively involved in some of the projects. By the way, good article overall. That is deserving of upvote, even if I may not agree on all statements made.
Coders believe they do not need it. Partially because they don't want to share the machine with anyone. If there is a separate machine running tests or anything else there is a possibility of another guy telling him "hey you did some shit" -- they don't want to know when they do shit. They want to hide everything on their own PC and say they are rockstars.
Performance of web apps fluctuates so much from merge to merge and there is so much code to optimize since almost no one in web dev knows algorithms but let's blame Windows in 20-30% speed loss.
Can you give a code example?
Isolate, not iterate? I agree with the other comment we need more info. Why isolate everything? What are you doing with it? You can pass any data type to a function so passing an array is no more complex than passing a string or 1. What you do with it after it‚Äôs passed into the function is what matters
this is for a school project where I need to take a file input and calculate of the Automated Readability Index (ARI) of the given file. The ARI is equal to ARI=4.71√ó( characters/words)+0.5√ó(words/sentences)‚àí21.43 
Maybe too many dots: File.open()
what part of this includes an array? You could take a long string and solve that. How is the array separated?
Post the code that you have. It took more effort to write this explanation.
The star goes in front of a variable name of the argument. That‚Äôs called a splat. That allows you to pass an unlimited number of arguments and turn it in to an array. Which is a little different than passing an array. def function(*array); end def function(array); end function(1,2,3) function([1,2,3]) Sorry, I‚Äôm on mobile, but hope that makes sense.
Read the actual error message. What file do you see being mentioned there ? Hint: IO.rb The IO.rb is being parsed and it contains an error. 
[removed]
Got this proof of concept working today, feel free to ask me any questions :)
Cool! Good performance or not, I've been curious about playing with something like this. Are you planning on sharing this proof of concept or is this strictly show and tell? 
Sounds great! How it's different from something like opal? Is it because it converts to wasm instead of JS? Dis you actually write the actual transpiler/compiler? Or are your using some existing library and you *only* wrote and design the way the ruby code is organized like components?
Yup I‚Äôll open source it once the code is a little bit less hacky, right now it roundtrips the state to JS land and back so it has to be serializable, I think I should be able to avoid that with a bit more thinking though!
Have never actually used Opal so I‚Äôm not too sure how it compares. Does Opal support the Ruby standard library, and can you require opal code on the server? I‚Äôm using emscripten and mruby for compilation, had to write a little bit of c to embed the app and pass data in and out. I‚Äôm using Snabbdom on the js side for the virtual dom, everything else is pretty much glue code.
Makes sense. I'm excited to check it out!
Opal is a Ruby implementation that transpiles to JS, so it's all Ruby. It is a leaky abstraction, so you do need to be aware of it, and not all Ruby code will run flawlessly, but having wrestled with mruby, my guess is that more Ruby will run unmodified with Opal than with mruby. On the server you would just run MRI or whatever Ruby implementation you prefer normally, but you *can* also transpile it server side and run it using nodejs or the like, in which case you can require javascript as well and access it from your Ruby code. It works ok-ish but it's easy to get caught up into issues that are related to how Opal wraps the transpiled Ruby code.
Try this: \` File.readlines('a.txt').each {|line| p line}\`
It has been explained why this is not a good idea here: https://bugs.ruby-lang.org/issues/15723 Note that I refer to "it". There is no compelling reason as to why "it" should exist. Copy/pasting from other languages does not work. For similar reasons ruby does not have the elixir pipe operator. If the main argument is that it saves typing then you can also save typing with the newly added @1 @2 and so forth. What I do not get is people complaining about this being added. It actually makes me angry in particular when there are people who complain about this but they cheered before when shitty OTHER syntax changes were added. This really annoys me. Your shit got added but other changes are forbidden??? Annoying to no end. People should, quite frankly, stop complaining and do this: - IF YOU LIKE SOMETHING, USE IT. - IF YOU DISLIKE SOMETHING, DON'T USE IT. Do note that I am not at all against adding multiple ways. For example, I also don't understand why people think that everything has to be mutually exclusive. The problem is that "it." still is totally meaningless and an ad-hoc given name. Ruby has established standards for some concepts but not for others - "self" and "yield" for example, but no name for block-parameters and no way to access case/when structures as first-class objects.
try this ``` def pets(a, b, c) p a p b p c end pets(*['dog', 'cat', 'chiken']) ```
Well. I did not know that discussion.But tbh, I do like `it`, simple. @1 @2 looks like black magic slightly. Is the first @0 or @1? If there are multiple parameters, I'd prefer to write them out. It's sad that there is compatibility problem, 
You're calling `#call` (`.()`) on `File.open`'s return value. 
You can already hack this in: [https://gist.github.com/Widdershin/b920a8a668f8030d4393e1870adaad7a](https://gist.github.com/Widdershin/b920a8a668f8030d4393e1870adaad7a) Syntax ends up looking like this: &amp;#x200B; \`\`\`ruby p \[1, 2, 3\].map(&amp;this \* 5 / 2) \`\`\`
Like it, but doesn't read nicely using RSpec: ```ruby expect(subject.errors).to be_of_kind(:some_attribute, :some_error) ```
Breaking something like \*every testing framework ever\* seems like somewhat of a downside, if you ask me...
Does this mean we can run Rails in the browser?
That's very interestingÔºåI will show it to others, that's meta programming. Thanks. 
I don't know how does it relate to test framework.
rubymotion
Nice article, really shows how easy monitoring can be!
"If you dislike something, don't use it" only works when you're working alone and never reading someone else's code.
Can't wait for this to come out. Its like Blazor framework what you are trying.
Checkout file.each_line.
@z is nil.
many test frameworks use `it` as a method name, so you'd be directly clashing with that.
Oh, I see. Those bdd frameworks. 
What do you see when you hold your cursor over @z where the curly underline is? &amp;#x200B;
There used to be bindings by jacius - rubygame. http://rubygame.org/blog/ It does not have a current maintainer. :( Gosu may be an alternative. You can package things together e. g. via something like OCR ... or whatever the name was. But it is quite painful to work on/for windows so I am not sure this can be recommended. There also seem to be ffi bindings to SDL.
 rescue EOFError =&gt; eof # do stuff to handle eof else # do stuff if you didn't hit an eof ensure # do stuff that has to happen whether an exception happened or not end 
&gt; Unfortunately I‚Äôve never heart Matz speak about this I do not think matz ever said that. He did of course say several times that the (or one) of the major focus is on humans. But I am not sure he literally said that ruby is for "programmer happiness". https://www.artima.com/intv/ruby.html Quote: "Instead of emphasizing the what, I want to emphasize the how part: how we feel while programming. That's Ruby's main difference from other language designs. I emphasize the feeling, in particular, how I feel using Ruby. I didn't work hard to make Ruby perfect for everyone, because you feel differently from me. No language can be perfect for everyone. I tried to make Ruby perfect for me, but maybe it's not perfect for you. The perfect language for Guido van Rossum is probably Python." There are of course more statements from him over the years. A more recent one was an interview where he also talks about his family briefly. He mentions ruby too. I don't remember which interview it was though ... a few years ago I think. He has a laptop and is in a room somewhere with lots of books and I think his wife also says something lateron in the interview. But that's just from my memory. I don't trust my own memory either. :)
Gosu might be an option. See &lt;https://www.libgosu.org&gt; and &lt;https://pragprog.com/book/msgpkids/learn-game-programming-with-ruby&gt;.
I seriously question not the addition of \`reselect\`, but the idea that you can \`unscope\` things is unnerving. &amp;#x200B; Write code that you are confident with, write queries you know you will need. Adding \`unscope\` in your code tells me that you're unsure about what you want to do with the data you ultimately will retrieve.
Thank you, speaking about packaging I think you mean this one [https://github.com/larsch/ocra/](https://github.com/larsch/ocra/) But it looks like its dead... :/ 
Oh man, if I could write vue style components but without the mess of JS I would be a happy camper.
Here's the thing, I have an array of strings but I want to call the reverse method on the elements of this array. I know that my array $a in the beginning is empty, but the user fills it with his input. Even if $a gets filled before reverse is called Ruby is still giving me an error for calling reverse on Nil. Is there anyway I can fix this?
I added the pool capacity metric, glad it's helpful!
Prometheus is really fantastic. It takes some work to get your head around monitoring the Prometheus way, but once you do, it's just delightful.
https://github.com/gosu/gosu/wiki/Ruby-Packaging-on-Windows https://github.com/gosu/gosu/wiki/Ruby-Packaging-on-OS-X
Cool stuff! Having it pre-render on the server-side could help a lot with the perceived performance issues BTW.
This can be refactored to be much simpler in Ruby, but the exception is due to an off by one error. It‚Äôs executing the check loop one time even if there are zero items(and two times if there is one). This means the code always exceeds the length of the Array, which is why you‚Äôre getting the nil exception. You could fix the while condition, or better yet, use `each` which is the preferred way to do this in Ruby for exactly this reason. So get rid of `@z` entirely and use something like: ``` $a.each do |candidate| if candidate == candidate.reverse # ... end end ```
[Ruby2d](https://www.ruby2d.com/) is awesome and the [Gitter](https://gitter.im/ruby2d/ruby2d) community is very much alive.
Busy-metric is also helpful for quick overview of the system health
Sorry I don't see any report button: /u/jamesgolick [**u/ViralInfection**](https://www.reddit.com/user/ViralInfection) [**u/ViralInfection**](https://www.reddit.com/user/ViralInfection)
Agreed, I spend years trying to figure out monitoring, and Prometheus is the one that gets it right in my opinion.
Monitoring is not easy, it's doable, but it's not easy.
Definitely! Also with emscripten optimisations and caching the mruby interpreter it‚Äôs actually very fast
The problem is that file.readline() is resolving to an error before it can be compared to nil. Perhaps you can use file.eof? instead.
Oh no. @sgrif's contributions to Rails have been _immense_. This makes me sad, and further encourages the catastrophist "uh oh is Rails dying" worries. :(
He has already been focused on something else. 
They/them preferred FYI
Please don't take away from this that the Rails team is wrong or anything of the sort. They have a good vision for the project, it's just different than mine. Ultimately this decision had a lot of factors go into it, disagreements with the team was just one of them.
Wait what ?
Ah, another traveler in the monitoring deep mines.
Downvoters are shitheads.
People can prefer certain pronouns. If, for instance, they don't identify as male, then they would prefer to be called "they" rather than "he."
Was not aware. Whatever they like.
It's mentioned in their Twitter bio. https://twitter.com/sgrif Using a person's preferred pronouns is only polite.
&gt;blog.seantheprogrammer.com/moving... polite not mandatory. 
What would it even mean for a social norm to be "mandatory"?
I did not read their twitter bio.
Bill C-16
Haha entirely fair, I was just providing a source before I realized that OP was sgrif!
Oooooh the spoooooky Canadian thought-police, they're coming to get you! üëªüò±üëª
Thanks for everything! üíì 
We already have people sifting through reddit threads making corrections, so.. üòÇ 
Agreed. Also not a fan of default scopes. 
ActiveStorage is generally a pile of garbage, doing image variants on the fly - which definitely is a pain the ass for product image kind of pictures. And ActionText.... why?
Honestly I wouldn't recommend you actually use this, I mostly did this as a joke.
Thank you, Sean! I am a bikeshed listener to this day (and a yak shave listener now) because of you and Derek. I had a passing interest in Rust, but hearing you talk about it with Derek made me definetely want to learn it. I really hope you can achieve a nice way of doing things and achieve whatever you want :) Also thanks for all the work in AR and Diesel :)
a very politically wise thing to say. :) But yes, I can decide what I can think of what I can tell of the Rails team vision on my own! I just know i liked what I could tell of yours. 
"people" being the PERSON BEING REFERRED TO. I appreciate their correction of how they in fact like to be referred to, so I can refer to them how they like, because I would like to do so. 
I don't dispute that
referring to someone replying to a comment ABOUT THEMSELF as "people sifting through reddit" is ridiculous. Nobody was sifting, it was literally @sgrif themselves replying to a comment referring to @sgrif. I find your agenda unwelcome. 
It wasn't referring to this particular instance, rather generally across reddit. I correctly stated that it is not mandatory to use preferred pronouns, especially when it doesn't make grammatical sense. There's no agenda, it's all in your head. Get some sleep
Yeah, default scope use tends to just scream "I need to have a composer object wrapping me!"
Hey nice idea. The proxying alone would be a huge help to a lot of people
An opportunity to learn something new, what's a composer object? 
Sorry, I wasn't attempting to tell you what to think. Just what I was trying to express. &lt;3
Thank you for the kind words &lt;3
Nothing special really. It's an abstraction over a model that aids you in composing the model, or related models, in the way you need in your controller and/or templates. Usually just a plain old ruby object. I like a composer object any time I know I have a model object that, for most access, I know I'll need to use some default scopes. ``` class UserComposer def find(id) def scoped_find(scope, id) scope.not_deleted.not_disabled.not_suspended.find(id) end def with_config(id) User. end end ``` With a Composer object I don't have to litter my codebase with these common scopes, and I don't have to weigh the pros and cons of setting up a default scope, and the inevitable "but now we need to unscope" conversation that will crop up after a few months of development. This pattern really comes in handy if you have an object that commonly needs to be loaded with relationships pre-baked. Instead of overloading a helper method on a model object with "user.joins(XXX).includes(XXX)" you can stick it in the composer.
Very nice - thank you. So it's similar to a page object/facade? 
Yeah. They address a similar concern, although page objects and facades are aimed at simplifying how you pass data to views. Composers are about encapsulating how objects frequently go together and are accessed. Both concepts revolve around the idea at mitigating controller bloat. 
Got it! Learnt something new today - bless you
Will you be renaming your child?
Ok I legitimately cracked up laughing at this. No, I still love Ruby (the language and my daughter and her name). Also my wife is still a Ruby programmer.
Legit love all your contributions and speaking engagements I've seen. Hope to see more as you work in Rust more. Thanks!
It's also mentioned at the top of the blog. I wasn't trying to criticize you for not knowing, just was letting you know for future reference ‚ù§Ô∏è
Rusty.
The Attributes API was my favourite thing in Rails 5 so there can be nothing but a tide of Thank Yous for that. I had been further hoping that @sgrif would be interested in extending the Attributes API to handle `composed_of`. Now I will have to do it myself 
Easy way is going with Shopify. Otherwise, especially if you want full control + custom stuff, I would do it with Stripe these days (using Stripe Checkout for an easy setup). And a rails backend for handling products / inventory / users. Depends on how complex you need your ecommerce site to be.
Solidus is good.
&gt; it would save a lot typing overall In your example it would save 4 characters. Moreover, you can do `dogs.each(&amp;:bark)`
&gt;Solidus I've used Stripe before but never Shopify. With Shopify, I don't really have to build anything right? Just "configure" it?
Thanks, never heard of Solidus. Seems to be somewhere in between Stripe and Shopify?
We have been doing this for sometime using Opal, and have a complete mature framework called [https://hyperstack.org](https://hyperstack.org) . What is cool about this (and something we have been hoping would get done) is that runs using WebAsm. I hope we can partner on this effort! &amp;#x200B;
I think changes should be accepted based on their individual merits, not "your changes were added so their changes were added." &amp;#x200B; &amp;#x200B;
Out of curiosity, what were some of the disagreements? Thanks for all of your work btw.
Thank you for your dedication and hard work üçª
You can only use &amp; for public method.
Of course, I meant it is a good meta programming demo. 
&gt; Still, I was disappointed when the safe navigation operator as introduced, as it basically acknowledged that it‚Äôs fine to return `nil`. Interesting. I am not familiar with this principle. I take Bozhidar's word on it, since he is something of an authority in the Ruby community, but I'd also like to read more about it. Does anyone have a source/reference? Does this mean that in most cases when methods return `nil`, they should actually raise an error instead? What about `Enumerable#select!` and friends, which return `nil` when the block doesn't match any elements?
&gt; this adds a bit of cognitive overload Small correction: I think you meant "cognitive overhead".
Not trying to be rude, but why? from your twitter it seems you are straight. You just prefer to be gender neutral? 
It just fails to replace what it claims to have to replaced (carrierwave, paperclip, etc) because you're unable to link directly to an image and are instead forced to redirect through rails. 
`--verbose` or is it `--debug`? Anyway there is more info needed, it can be anything from missing ruby headers to missing some C libs
Thanks for sharing this! If that's really his perspective, however, I do have to wonder why he'd accept things into the language he's not fully satisfied, though. Perhaps he's not as obsessed with the details as me, which is not necessary a bad thing. :D 
Thanks for spotting this! 
&gt; "uh oh is Rails dying" worries. :( Calm down dude, have a glass of water. People step down from open source projects all the time, it can be a tough and thankless job sometimes I assume. Guido left Python which he devoted I donno - 30 years of his life to? The Nodejs guy (forgot his name) that came up with the project left it as well. It's a natural part of the process, in fact I think it would be weird if DHH still did Rails 20 years from now. There comes a time when people get tired and want to do something else (actually DHH is the kind of dude who might do Rails till he can't type a keyboard anymore, we'll have to wait and see about him)
I'm not fond of raising errors, although they make some sense from time to time. Most of the time, though, I think there's a more reasonable "empty" value you can return instead of a `nil` - in your example I think you should just return an empty data structure. For something like `"TEST.upcase!"` I'd just return the receiver (`"TEST"`) and so on. The logic for this is pretty simple - instead of having to account for `nil` or a data structure, you always know you get some data structure and you don't need to bother with extra checks. And obviously when a boolean function is returning `nil` it could also be returning `false`, although that usage of `nil` is OK most of the time. What's really bad is code like `foo&amp;.bar&amp;.baz&amp;.something`, as it implies you might have gotten a `nil` at every step of the evaluation. I think the only reasonable usage for the safe navigation operator is `foo&amp;.bar` as a replacement for `foo &amp;&amp; foo.bar`. Chained `&amp;.` are a bad pattern in my book, unless they are the final step of the method chain. So, to sum it up - the operator by itself is not a bad, but the fact that it encourages people to write nil-returning methods is problematic. I hope this makes sense to you!
I did this using a different CSS selector: ``` parsed_page.css('label.text-link').map(&amp;:text) ```
Isn't every Active*** and Rails at all a garbage?
Well put; TIL! FWIW, I submitted your post to HackerNews, and it's [generating quite a bit of discussion over there](https://news.ycombinator.com/item?id=19560479).
&gt; when it doesn't make grammatical sense. Could you provide an example?
&gt; I created Diesel, an ORM for Rust. Yikes. &gt; I‚Äôm in a position where I can meaningfully contribute &gt; to the Rust organization. Ah, the new Reddit hype bubble. The preachers claim how Rust is the future. :) Actually we have had the same a few years ago with Go. People always move into the better promise of the future. Even when languages are completely different, but hey, the preaching can continue! I am sure Rust is going to win the world. Granted, after 10 years TIOBE still barely knows about Rust but don't let me stop ya - Rust will surely be used by everyone soon enough! &gt; The problem is that working on MIT/Apache licensed software &gt; doesn‚Äôt exactly help pay the bills. AHHHHHHHH so the real motive gets through - salary. Which is fine too - happens to everyone. &gt; That‚Äôs why I‚Äôm asking for your help. Helping Rust folks? Why? Rust pays your bills automagically! Just write more code and sell it. 
'they are going to the shop', when referring to one person
I approve of renaming. Andrew + Rust could become Anust. 
You mean adding more complexity into rails is a good thing? I'll never understand the rails crowd. They seem to love and worship complexity. And they have a high burn-out and drop-out rate, as can be seen here too.
&gt; a very politically wise thing to say. In other words - people too scared to say what they mean due to "reputation". Reddit unfortunately works like this too, with the voting. You get downvoted for controversity so we select uncontroversial statements .... :(
How many of you are there? Eight??? I assume you refer to family. It's still a strange thing to reply to, so I understand throwawaybrimsenboy completely. After all you made a decision right? You should not spread out that decision onto several different people since ultimately it ... was you who decided.
That does not make any sense at all. When someone whacks you on the head, you don't say "they hit me on my head!" either.
There are even spell-typo checking bots pestering real people here. I don't understand why bots are allowed to spam - or have more karma than human people.
Even aside from gender or sexuality, which is not even relevant, the issue still persists between singular versus plural. In german you used to have the "royal we" (and german is pretty ... strange compared to english which is more logical and more straight-forward most of the time).
&gt; Guido left Python which he devoted I donno - 30 years of his life to? That statement worded like this IS SIMPLY INCORRECT. Guido did not "leave" python. He is still using python; he is still contributing too. What has changed is that he does not have a wish to want to get as much involved anymore in particular in discussions that are not easy to resolve, such as the addition of :=. While that was the primary reason, Guido also cited a secondary reason related to health/age (although that probably comes as a late second, since motivation waned prior to that after the turmoil). &gt; The Nodejs guy (forgot his name) that came up with the project left it as well. First, it is not "left it as well" because guido did not "leave" python. Second - it is unsurprising that people jump away from JavaScript since it is so horrible. It's still a massive hype bubble on reddit because you are MUCH MORE likely to read from people LEAVING a language but less often from people who MOVE towards another language. And the absolute number of programmers is steadily increasing rather than decreasing, so it's a hype-bubble here on reddit for the most part.
See? I wrote something more generic in a similar way, aka rails worshipping complexity. Now you say something similar - I am glad to not be the only one who thinks this worshipping of complexity to be strange. Upvoted for truth.
So essentially you are just juggling complexity.
but that is what the person you refer to actually wants. maybe instead of are we could use is. they is going to the shop. English will evolve to deal with this, until then we can add some context if we need to be very unambiguous.
Others already suggested .each_line and rescue. There is no huge alternative in every situation to using begin/rescue blocks. Sometimes it can be avoided, like using methods, checking for nil etc... but sometimes there is no trivial way to avoid it, so you should use that to safeguard in your code.
Upvoted!
lmao imagine being this mad about pronouns
That's perfectly valid English.
Try to install it from the command line and see why it says. You‚Äôll know what is the issue.
[removed]
Where starts -Infinity ?!
Love CanCanCan, always rely on it. Good to see some great improvements
In a singular context? Seriously? 
Where ends Infinity?
Yes. https://en.wikipedia.org/wiki/Singular_they
**Singular they** Singular they is the use in English of the pronoun they or its inflected or derivative forms, them, their, theirs, and themselves (or themself), as an epicene (gender-neutral) singular pronoun. It typically occurs with an unspecified antecedent, as in sentences such as: "Somebody left their umbrella in the office. Would they please collect it?" "The patient should be told at the outset how much they will be required to pay." "But a journalist should not be forced to reveal their sources."The singular they had emerged by the 14th century, about a century after plural they. It has been commonly employed in everyday English ever since then, though it has become the target of criticism since the late-19th century. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I'll upvote controversial comments that have good argumentation. But if it appears that the person is just being negative, I'll downvote.
üòÇüòÇüòÇüòÇ
I'm glad you find learning fun.
&gt; &gt; I created Diesel, an ORM for Rust. &gt; Yikes. You need to provide an explanation here. Without it you're just expressing strong disapproval of Diesel (or the idea of Diesel), and it's not clear at all why would you have anything against it.
Haha. How many Canadians have been jailed under bill C-16? 0.
https://en.wikipedia.org/wiki/Singular_they Lots of people learning about language today!
**Singular they** Singular they is the use in English of the pronoun they or its inflected or derivative forms, them, their, theirs, and themselves (or themself), as an epicene (gender-neutral) singular pronoun. It typically occurs with an unspecified antecedent, as in sentences such as: "Somebody left their umbrella in the office. Would they please collect it?" "The patient should be told at the outset how much they will be required to pay." "But a journalist should not be forced to reveal their sources."The singular they had emerged by the 14th century, about a century after plural they. It has been commonly employed in everyday English ever since then, though it has become the target of criticism since the late-19th century. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Why are you being a jerk? Someone asked you politely to refer to them in a different way, analogous to if they asked you to use a new name. If you don‚Äôt want to, don‚Äôt. But either way, just move on and stop whining. English has used the singular they forever. https://en.m.wikipedia.org/wiki/Singular_they All that is new is that some people now ask that you use it consistently when referring to them. Aren‚Äôt there enough things to argue about in the world that we can just do it or not do it and move on?
Desktop link: https://en.wikipedia.org/wiki/Singular_they *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^248604
**Singular they** Singular they is the use in English of the pronoun they or its inflected or derivative forms, them, their, theirs, and themselves (or themself), as an epicene (gender-neutral) singular pronoun. It typically occurs with an unspecified antecedent, as in sentences such as: "Somebody left their umbrella in the office. Would they please collect it?" "The patient should be told at the outset how much they will be required to pay." "But a journalist should not be forced to reveal their sources."The singular they had emerged by the 14th century, about a century after plural they. It has been commonly employed in everyday English ever since then, though it has become the target of criticism since the late-19th century. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It's nice to see that project is not dead yet, but Pundit's approach is proven to be more flexible and easier to maintain.
At -Infinity? `(-Float::INFINITY..1).first # =&gt; -Infinity` (most methods like to\_a, each, etc. don't work)
I'm really interested in using this in DSLs like ActiveRecord. Would love to see stuff like `where(price: ..200)` being evaluated to: WHERE price &lt; 200
Imagine being so insecure about other programming languages than the one you use the most üòÇ
Is there any way to add this to your \`.rubocop.yml\` file?
Given that it's extracted from Basecamp, which deals with attachments to posts and otherwise relatively private files, it makes sense. But as you said - it's touted as a built in replacement to Paperclip/Carrierwave and it's nowhere close.to that. I have a relatively large project that was ported to AS and now it's a daily thorn in the butt. Another major overhaul using something else again just makes me shudder. 
I'd rather see the DSL in the sequel gem `where { price &lt; 200 }`
I like `sequel`, but it's really intrusive, and sometimes behaves unexpectedly in complex queries. Still, it's just a matter of preference.
Have you ever known anyone to calm down when you tell them "calm down dude an have a glass of water"?
Pretty terrible (although it is of course the same as endless ranges; I still do not understand why omission of syntax means infinity). However had admittedly it is not that terrible compared to some other changes. Ultimately it is up to the individual at hand to decide whether to use a certain functionality or not. Code bases have to be kept sane. People may have to determine on which style that is to be used for any given project. For solo-devs this is not so complicated but for teams, they may have to establish what to use, and more importantly, what not to use - and then, no matter how, agree to be consistent about it. Could also use rubocop for it (since most who work in a team-environment will also work on things that tend to be somewhat larger, and almost always also come with tests).
What a terrible utter shit. Now people want to confuse .. with &lt;. Madness abound. The only sanity is to not use insanity. And that comparison is actually showing where insanity leads you to. (I do not solely refer to endless range, but more the next step that you describe here of using .. rather &lt;; insanity is coming).
Hi! I personally used both in different projects but I now prefer CanCanCan approach because it's flexibility and easiness. Also it avoids writing permissions twice: when you need to check permissions on a single object, and when you need to fetch records from the database. The hash syntax of CanCanCan is very powerful and is something I really miss from Pundit. I would be interested in knowing how it has been proven, that Pundit is more flexible and easier to maintain. 
This is a wonderful reason why changes like this shouldn't go in - it encourages people becoming insane.
That is a VERY good question. The whole change does not make a lot sense to me. Why omission of syntax leads to infinity ... beats me. The only thing I can do is to defend my code base against this insanity. To be fair, though - matz actually also mentioned that there should be some concept of infinity in ruby, but it is not clear as to how/where; and OMISSION of syntax will always be shorter than any ADDITIONAL syntax, so it's not really possible to beat endless or startless invisibility (aka missing syntax). Personally I prefer oldschool sanity: START RANGE .. END RANGE No stupid fuzzing about this. Easy to understand. Not all changes were bad but ruby 1.8.x was definitely saner than what came afterwards. Always weird for me when I write this, since I also write a lot more ruby code these days than I used to do in the 1.8.x era ... :\ :/
Some companies would prefer to stay with Ruby for longer, but are eventually forced off it by these performance problems. Pushing that day back a couple of years _would_ be a game changer for many people.
EXACTLY! And to add to this - why omission now means infinity, beats me too. It's insanity! To be fair, though - the change was not primarily about infinity per se, but about "ease of syntax use", so if you come from this point of view, the change is not so "bad". From a conceptual point of view, I still don't get it. What I find most hilarious, though, is that mame (although he is cool), suggested and likes the omission, but dislikes ... @1 @2. Granted, he is not the only one, but I just find it curious how personal taste is so wildly different from individual to individual. People will only ever agree to disagree - and I am sure you can only disagree with that statement, too!
But that is EXPLICIT. (And a bit clumsy). The issue is how omission of syntax would mean infinity. To be fair, though - Float::INFINITY is not really a concept of infinity as such. Otherwise, why would INFINITY be under Float? That is more an implementation detail. Ruby does not have a strong concept of infinity. I would not know how such a concept would have to look like, though. Perhaps we can bake in some monads in a monoid endofunctor through a sneaky (invisible) infinity (I consider omission of syntax to be very same to invisibility). Madness all about. DEFEND YOUR CODE BASES AGAINST INSANITY! And document it well. With working examples.
I don't get what you are trying to explain. Are you saying that its confusing because they/them is also plural? I am just confused, english isn't my first language.
It may actually returns nil with the current implementation, not sure.
&gt; What I find most hilarious, though, is that mame (although he is cool), suggested and likes the omission, but dislikes ... @1 @2. Maybe because the @-syntax is just ugly and pointless, while open ranges make a lot of sense?
-Infinity is a number; it doesn't start. If you mean the range, it starts at -Infiniti (duh) If you mean where would you start iterating `(..1).each`, I'd say the obvious solution is start at 1 and count down to -infinity.
&gt; Now VS Code will use the rubocop-daemon-wrapper script, and formatOnSave should be much faster (~150ms instead of 3-5 seconds). That's quite impressive! 
does anyone have an opinion on [consul](https://github.com/makandra/consul)? it looks green, but [at least] their docs make it look more suited to a SaaS. I'll probably be making a full post asking for opinions on auths for a SaaS in like a week or two, but figured why not throw it out here too. I'm familiar with cancancan and pundit, but want to know if either is still the best tool for my common (but kind of odd) use case. 
Attribute level rules fixes my biggest gripe about cancancan, very excited for this release!
Sounds like you need to check if the page redirects to an URL that exists (e.g. follow the location header). Personally I would use HTTParty with follow redirects, e.g. `response = HTTParty.get('http://google.com', follow_redirects: true)` and then check for `response.ok?` and catch any errors, e.g. [https://gist.github.com/localhostdotdev/b855287d4780df2fc430ea8c56ba2c95](https://gist.github.com/localhostdotdev/b855287d4780df2fc430ea8c56ba2c95) &amp;#x200B;
No, but in other news I've been using [access-granted](https://github.com/chaps-io/access-granted) in a project with simple needs. 
What's the difference with using spring on rubocop?
&gt; it's not clear at all why would you have anything against it. shevy comments like this in every single reddit thread about rust, even tangentially. It's just a thing that happens, like the weather.
Some of us maintain applications that chose to use CanCanCan ages ago and don't have the chance to switch to something else.
While I'm not totally against this idea: `..200` is inclusive, so it should map to `&lt;= 200`. You can use `...200` is you want `&lt; 200`. The problem I have is that you can only do the reverse partially: `200..`means `price &gt;= 200`, but there is no way to do `price &gt; 200` because Ruby doesn't have ranges that exclude their beginning. This makes the feature incomplete and so it feels like a bad abstraction to me.
Good point! Haven't thought about that like that.
The failure output should refer to some log files: `mkmf.log` and/or `gem_make.out`. What do they say?
Anyone know a big open source project that uses CanCanCan so I can compare it to how I use Pundit? This post looks really interesting but I really like the way Pundit fits into Rails projects. Curious to see how CanCanCan fares in real world context.
&gt; parsed_page.css('div.genre-selectors.selectors') You're selecting a `div` with many `label` tags. `genre_list.size == 1`. `genre.css('label')` returns _all_ the `label` tags in that div. `#text` gets the text content for all labels. Hence the long string. Instead of selecting the parent element of the `label`s, try selecting the `label`s themselves: parsed_page.css('div.genre-selectors.selectors label') Now `genre_list.size &gt; 1` and you can just get each `label`'s text: `genre.text`. Don't forget to close your open file descriptor: `unparsed_page.close`!
Look, you can worry about whatever you want - I'm not gonna stop you. For me - I know Rails isn't the most popular stack by far, and I can live with that. I don't think it means I can't get a job 10 years from now. If you feel otherwise there's plenty a stack that score higher on Tiobe. Also I'm all for adding at least one compiled stack to your arsenal, for perspective if anything else.
Thanks for this comment. It is heartening to see people use something that you worked on.
Thanks for your response. You saved me!
My primary issue with CanCanCan is that it's insanely easy to leak queries. After having it in production for 5+ years I can honestly say I wouldn't recommend it for this reason alone. 
&gt; So yes in a way "left" the project and will no longer take part in its development in any meaningful way Au contraire. https://www.python.org/dev/peps/pep-8100/#results
Unfortunately in real world there are more abstractions that require authorization than just ActiveRecord or even Mongoid objects. In a more complicates cases it's not enough to check just the attributes so you end up with defining abilities with blocks which eliminates benefit of having single definition for both scopes and objects. Pundit doesn't rely on any framework or ORM and gives you more control, abstraction and freedom.
&gt; Failed to build gem native extension. That typically means your machine isn't setup to compile C code. You need a c compiler and some associate dlibraries for it. On ubuntu you can normally get by with: apt-get install ruby-dev OSX, you will probably need XCode, Windows, I have no idea. 
I'm not worried about job prospects as much as I'm worried about open source ecosystem and code quality. (Although _eventually_ the latter might effect the former, it might not either. It definitely effects the joy of using Rails or other ruby though). (I don't care about trendy "popularity" at all, in itself). I think the defensiveness in the replies are telling. But indeed anyone can worry about or think whatever they they want. I'm not sure what I'd do about it either way. I like ruby (and for now Rails), and am not in a hurry to leave them. I'm not sure putting our heads in the sand and not paying attention to what's going on is helpful. (I mean, it _might not_ be going on. Maybe everything is fine. But I sense a resistance to even considering it, when it seems to me increasingly like it's going on). On the other hand, sure, why worry about what you can't do much about. I dunno, I'm a worrier. 
Who is resisting considering it? Not me. As I acknowledges rails isn't as popular as it was in it's prime. There's just too many options nowadays for rails to be that dominant. But the quality of the project itself hasn't changed at all. One maintainer leaving means nothing. And very serious companies are still committed to rails and investing a lot of effort. And yes some people will get defensive to alarmist comments...
Here are my thoughts as the language designer of [NGS](https://ngs-lang.org/). The following is implemented in the language: I preferred more uniform syntax: `expr1..expr2` (for numbers it includes start, excludes end) and expr1...expr2 (includes both). There is no ..expr2 or expr1.. `expr1` and `expr2` can be `null` to signify beginless or endless ranges. The syntax only causes `..` method to be called with the two arguments (`expr1` and `expr2`). The method should typically return a subtype of `Range`. Since `..` is a multimethod, you can customize what returns for your own types of `expr1` and `expr2`. One of the subtypes of `Range` is `PredRange` (predicate range) which allows for example `mylines[/start-marker/../end-marker/]` which will return the appropriate elements of mylines.
if you want to be charged for every little job or every little feature shopify is great. i would recommend looking for a true all in one ecommerce solution. 
Wow, man... you‚Äôve already posted 4 times in this thread that you don‚Äôt like this language addition. We get it... you don‚Äôt like it. So, don‚Äôt use it!
Maybe `Net::HTTP.get_response(url).is_a?(Net::HTTPSuccess)`.
Cool thanks I‚Äôll check it out
I like [EvilMartians ](https://evilmartians.com/chronicles) [Thoughtbot](https://thoughtbot.com/blog) has great videos and a decent blog.
Info is all other the place, this subreddit and /r/rails /r/rubyonrails are pretty good, there are also a lot of Twitter accounts, the mailling lists, the newsletters. And then depending on how deep you want to go, you could follow the Github PRs, Github issues, Github commits. Could even follow the whole rails organization and the gems you are interested about :).
Can you share why Sidekiq Pro was not an option? I'm sure the customer paid more in an hourly rate to reimplement it and they don't have: * A Web UI to see batches in flight * Ability to see failed jobs and errors associated with each batch * An API to get real-time status * All the other Pro features so I'd be shocked if price was the issue.
If you use vim, or any linter really, you can get instant feedback: https://github.com/w0rp/ale
Akita on Rails :)
&gt; Look familiar? This would be exactly how these would appear in most Rails routes.rb files. Since both frameworks are built on top of Rack, there are no major differences in routing approaches Hmm, I don't believe Rack (the API or the gem) comes with any routing support, not any API/DSL that looks like `resources :products, only: [:show]`. If hanami's routing looks like Rails', I don't think it has anything to do with both frameworks being built on Rack. Rails uses something called `journey` for routing, so one might guess that hanami uses the same dependency... but `journey` was folded into Rails quite some time ago and I don't believe is available as an externral dependency. It looks like hanami maybe actually uses this? https://github.com/hanami/router Which is not what Rails looks like. If the routing looks similar, it's because hanami's router's implementation was written to mimic Rails' routing API/dsl, not because they're both using the same implementation, and fairly unrelated to them both being on Rack. 
i guess you could say that was faast
I thought the Public files / images problem were solved in Rails 6. Active Storage?
Wow, we have been using Opal for years have a lot of code written in it. Except for a few well documented, and obvious things it is in fact Ruby. A huge amount the ruby specs pass, and its only obvious stuff (like direct access to the heap for example) that doesn't work. We have quite a lot of code that runs on server or client, and I am just not seeing these problems. I have taken a fair number of Ruby gems, and just had them work in Opal, so again I'm not sure why you have this opinion. Can you give some examples?
See a post I just made: [https://www.reddit.com/r/ruby/comments/b91taq/hyperstack\_progress\_report/](https://www.reddit.com/r/ruby/comments/b91taq/hyperstack_progress_report/)
How would this work with other NPM components? Say element ui?
A begin-less Range doesn't need to start. Ranges use Comparable protocol (#&lt;=&gt;, spaceship operator) so -Infinity is a concept that only applies for Integer or real numbers (BigDecimal, Float), not string ranges (`""` is the start), Gem::Version ranges (`Gem::Version.new 0` is the start), etc. The spaceship operator lets you know if the item is in the range (occurs before the end) or outside the range (occurs after the end) so you it even works with a range you can't enumerate.
It doesn't mean Infinity, it means "before the end" which you determine by applying the spaceship operator to the object you're testing and the end object. A range of [natural numbers](https://en.wikipedia.org/wiki/Natural_number), `naturals = ..‚Ñï(5)` would start at 1 (or 0, if that's how you roll) and not include -5 the same way `1..5` does not include `""`
GOOD POINT... I didn't mention this in the video. Its automatic. When we hit const missing we go looking for it in JS land, and if we can make sense of it as a component library, a very thin wrapper is created. There is a quick example on the home page (about the 3rd example down) [https://hyperstack.org/](https://hyperstack.org/) And a detailed doc here: [https://hyperstack.org/edge/docs/dsl-client/components#javascript-components](https://hyperstack.org/edge/docs/dsl-client/components#javascript-components)
I haven't checked the Rails 6 version of it, sounds like I should then.
Mostly related to the integration with javascript. E.g there's been attempts at integrating with React, and the code involved for that was just awful last I looked. If you stick to pure Ruby things are mostly fine, but that's very limiting. At least for my potential uses I don't have the luxury of not integrating with various JS libraries, as replacing them with Ruby implementations would be far too much effort. 
[https://rubygems.org/gems/bootstrap-sass/versions](https://rubygems.org/gems/bootstrap-sass/versions) - 3.2.0.4 - April 03, 2019 (201 KB) - 3.2.0.3 - March 26, 2019 (201 KB) yanked You want 3.2.0.4 if you have 3.2.0.3 :)
Shade?
Very good news!
Yes, mostly because of the price. They don't need the other Pro features to justify the pro acquisition. And, of course, I can't resist a good challenge :)
Great summary of all the things that make HS great.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [What causes Ruby memory bloat?](https://www.reddit.com/r/RubyLang/comments/b95oc8/what_causes_ruby_memory_bloat/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Use a library to handle the escaping. Writing it by hand is tedious, error-prone, and a security risk.
https://www.urbandictionary.com/define.php?term=Throwing%20shade I'd say it's not shade as much as it's just general snark though. Also I don't think it should be in the documentation, since most/all of the rest of Ruby's docs are not snarky.
This is more complicated than a simple gsub should handle. This answer shows you how to do it with the mysql2 gem. https://stackoverflow.com/a/4976645 But the preferred way to do it is via your Object Relational Mapper(ActiveRecord or similar) which can protect against large classes of attacks usually called SQL injection. The defaults handle far more scenarios than you‚Äôll ever consider: escaping strings, sets, times, table+column names as well as warning you when you use strings from the web. The Rails guides cover SQL injection pretty good and how they mitigate it. https://guides.rubyonrails.org/security.html#sql-injection
You should never insert data like this into a sql string. Doing so will leave you vulnerable to sql injection attacks. You need to use SQL parameters. When doing this, you don't need to escape anything and won't be vulnerable to sql injection. &amp;#x200B; [http://ruby.bastardsbook.com/chapters/sql/](http://ruby.bastardsbook.com/chapters/sql/) &amp;#x200B; Go to the part where it talks about running sql in Ruby. &amp;#x200B;
Yep, indeed we point out for that in the blog post. &amp;#x200B;
Sneaky sneaky. 
Alternative take: he's not a shit-stirring asshole. 
ah awesome thanks. 
I'm not writing an application or doing anything that anyone other than me will touch. It's just a script that loads a csv in to a table, no more. I could use python or powershell to do the same but ruby is what I chose, and quick and dirty is fine. 
I'm not writing an application or doing anything that anyone other than me will touch. It's just a script that loads a csv in to a table, no more. I could use python or powershell to do the same but ruby is what I chose, and quick and dirty is fine. 
Can anyone explain how exposing the CloudFlare ___cfduid cookie allows the attacker to run code? 
we will just say our experience has been the opposite. Perhaps overtime Opal has gotten better, who knows.
thanks!
What's snarky about that?
They aren‚Äôt exposing the cookie, they‚Äôre executing the contents of the cookie on the server. Not sure why they picked cookies and why that specific cookie. My guess would be that cookies don‚Äôt show in access logs, and that specific cookie doesn‚Äôt look suspicious. 
Maybe cloudflare forwards it to backend servers too? No clue, but just an idea. Very scary kind of attack, it's a miracle that it doesn't happen more often (especially on NPM)
It's the blind passing of whatever is in that cookie to eval(c) on L9, i.e read some string passed by the client and execute it on the server. That is bad. 
This turned out to be the issue I needed to install XCode. Thanks!
On top of the ones others suggested, here are some of my favorites: \- Big Binary: [https://blog.bigbinary.com](https://blog.bigbinary.com) \- Ombu Labs: [https://www.ombulabs.com/blog](https://www.ombulabs.com/blog) \- Speed Shop: [https://www.speedshop.co/blog/](https://www.speedshop.co/blog/) Also, I'd recommend you sign up for the Ruby Weekly newsletter: [https://rubyweekly.com](https://rubyweekly.com)
Excellent! I look forward to diving through the code of this
My answer: &gt; Q: How many states has a boolean type in a programming language? &gt; [ D ] Other. Please tell If you've forgive me temporarily elevating JSON to the status of a "language" for the purposes of making a remark; note that when receiving JSON from external systems, or even when worrying about the integrity of our own, we have five boolean attribute value states to worry about: 1. True 2. False 3. Null 4. Attribute is missing 5. Attribute's value is some other type e.g. string, number, array 
Ah, thanks, I‚Äôve got the full picture now, and YIKES.
I‚Äôm on mobile and don‚Äôt see what you‚Äôre pointing out
For the lazy, it's regarding \`Object#instance\_variable\_set\` &gt; Sets the instance variable named by symbol to the given object, thereby frustrating the efforts of the class's author to attempt to provide proper encapsulation.
&gt; Sets the instance variable named by symbol to the given object, thereby frustrating the efforts of the class's author to attempt to provide proper encapsulation.
Read the comment, it's not snarky, it's pointing out that because of the ability to call private functions and set private variables, state can be fucked up really easily. The purpose of encapsulation is to - absolve the consumer / user of a class or function from concern over internals - ensure consistent state can be maintained, so that the objects can maintain normal function Using this `instance_variable_set`, I would be able to cause divide by zero errors, forcing littering of unnecessary guards around operations, rather than enforcing only in the adjustment of whatever variable I was using. I could set a nil or string value to another type It's game over, I'd suggest rubo-cop rules to guard against, and cannot think of a single decent reason to use.
I'm not sure I agree with \`0.to\_bool\` returning \`false\` since \`0\` is truthy in standard Ruby, what's your reasoning for that?
Well if it's not snark than it's someone's attempt at a "witty" way of saying "not recommended for use". But if we really need the documentation to say "don't use this method" then why does the method even exist in the language? If there's a problem with the method existing, that a matter for pull requests and such, not for documentation comments. I can imagine someone whose first language isn't English to find that particular bit of documentation a bit confusing since it doesn't directly say what it means, it only implies it. Finally, that's simply not the style of most of the rest of the Ruby documentation, so it feels out of place.
 x = Base64.urlsafe_decode64(e['http_cookie'.upcase].scan(/___cfduid=(.+);/).flatten[0].to_s) eval(x) if x At the least that is easy to find. Although I have to say - I am still not entirely sure about what they claim to be a backdoor here? And then the comment: monkey-patching of the r.send method That is actually a feature that you can duck patch ruby code at will. Next part that confuses me - the original folks published an update? So HOW is this exactly a backdoor??? It's pretty stupid altogether, but I have a very hard time understanding how this is classified as a backdoor. To be honest - the whole article is written as a promo: If your project is being monitored by Snyk He keeps on wanting to promote this for reasons I don't know why. I really really have a very hard time with this article ... Still, people who use straight eval() in their code are suspicious too. Even without malicious intent, in almost every case straight eval is not necessary. There are a few exceptions such as pry: lib/pry/input_completer.rb: gv = eval("global_variables", bind).collect(&amp;:to_s) But I doubt sass bootstrap needs straight up eval()s. 
Yes - one has to wonder why eval() is even used at all there. 
I happily downvoted the link because the one who linked in did not explain what was even meant. So now I needed you to explain this and I upvoted you. The wording in that document seems wrong to me. I am a bit too lazy to file an issue, but the wording is 100% not from matz and possibly not even one of the core ruby developers since ruby does not have "proper" encapsulation in the sense of disallowing people to modify ruby objects at "run"time, all the time. That would be against ruby's OOP concept to provide "strong" encapsulation since you would also LOSE THE ABILITY TO DO SO. But anyone who feels a need should add an issue at: https://bugs.ruby-lang.org/projects/ruby-trunk Although perhaps I may file if everyone else is also too lazy ... Edit: Alright, I actually added an issue since I know everyone else is lazy too ... You guys should create more issues at the bugtracker! Matz and the core team actually asked about more feedback several times (though not so much about documentation per se, but more about how people use ruby in practice, for THEIR use cases; without feedback, how should the core team be easily able to decide on changes, no matter what? So go and provide feedback!).
Wait, is that method **public**? The things you learn - that will be convenient to know sometimes. 
Great Video which really shows the power of Ruby on the FE connected to Rails Models. Isomorphic architecture like this is a so much the future, The days of Ruby on the BE and JS on the FE (with API's in-between for the single purpose of moving data between the client and server code are like the dark ages). I get that you might WANT an APIn (so that other applications can integrate with your BE), but the idea that this is forced on you is crazy. &amp;#x200B; One code base, one model, one set of tests! Who can argue against that being a good thing. I think the problem though is that so many developers define themselves as FE or BE only. This is such a limitation to creativity. &amp;#x200B; As WASM evolves, and Hyperstack builds from Ruby to WASM this argument will become increasingly mute. Frameworks like [hyperstack.org](https://hyperstack.org) and Blazer (for C#) are leading the way, (In IMHO of course). 
How nice. Exactly one of the examples from my RubyKaigi 2019 "How to takeover a Ruby gem" presentation seen in practice...
The whole Hyperstack website is written using Hyperstack with Material UI - this is what the homepage code looks like [https://github.com/hyperstack-org/website/blob/edge/app/hyperstack/components/home/home\_page.rb](https://github.com/hyperstack-org/website/blob/edge/app/hyperstack/components/home/home_page.rb)
Is the React integration still tightly coupled to Rails? That's what stopped me last time I looked - I'd love to use that part, but have no interest in ActiveRecord or Rails.
Having seen your other comment: it is looking at the React integration of HyperStack that is exactly what made me say the above. It's been maybe half a year since I looked, so hopefully it's gotten less messy. 
That‚Äôs the entire point. Hackers published a version of the gem that evals whatever cookie you send to the application. 
`to_bool / parse_bool` is an "explicit" conversion. Think like `"false".to_bool` is `false`. If you want "standard" conversion to false do NOTHING :-) e.g. if 0 puts "truth-y" end 
For client-side OAuth you will need an endpoint which accepts access token from the iOS app. Using that token you ask Facebook API for user details like e-mail etc. And then you use that for authentication. &amp;#x200B; I don't think Omniauth supports client-side flows out of the box so you'll need to write such controller action yourself.
Random thoughts: - rubocop Security/Eval cop detects this (if in your code). With some tweaking (e.g. avoid reading rubocop.yml in gems folder), we could use rubocop to scan gems - I already do a lot of diffing or code analysis to detect such stuff, but having better tooling to achieve static analysis on the gem source _before_ it is even installed (e.g. to catch what could be running in extconf.rb http://blog.costan.us/2008/11/post-install-post-update-scripts-for.html) could be nice: e.g. detect the use of eval and such, or other potentially exploitable techniques - as a community (&amp; I include companies, first and foremost), we should built a sustainable way (finances etc) to have increased resources to work on tooling like https://github.com/rubysec/ruby-advisory-db
Object.ancestors\[1\].send("lave".reverse, "1 + 1") try to find this using automated tools.
&gt; Maybe cloudflare forwards it to backend servers too? No clue, but just an idea. Very scary kind of attack, it's a miracle that it doesn't happen more often (especially on NPM) Neither you nor I know that this doesn't happen more often. We only know about the cases that get found out. How many cases are not found out? 
But there are cases of legitimate evals here and there no? I do agree with most of your suggestions. Also the case for more Rails and less gems is stronger than ever (sure there will always be some library that's not in Rails that you have to use, but we don't need hundreds of packages like Node.js)
Yep, very good example. You can even write the eval part into the cookie and just do Object.ancestors\[1\].send(read\_cookie\[:malicious\]). Well now we're really in a jam no? The unfortunate fact is that a library author can cause mayhem to your application if he is malicious, I don't see an easy solution for that.
Someone just made the same point here https://twitter.com/CallMeWuz/status/1113618286921568256?s=20 
I think it is hard to find a single blog that is worth reading repeatedly just over ruby alone as such. I myself do oldschool google search every now and then and sort of find interesting blog content (oddly enough, some blogs have better documentation and explanation than the official documentation).
The answer is in the link I gave. Even quick and dirty things should be done the correct way. Especially when the quick way is easier than your non-secure way.
Totally agree ,that smartassery doesn't belong in the docs but on twitter, looks really amateurish and more ammo for whoever says Ruby is a toy language.
RubyWeekly is a good aggregator https://rubyweekly.com/ I usually find one or two things that interest me each week
Probably tangential, but thoughts on how WASM will affect this stack in the future?
&gt; When we hit const missing Have you looked at whether there's a performance penalty for this?
Could have been way faaaster - like from the get go. Though it's good to see open source - provided it is under a permissive licence - becoming the norm. It does not automatically mean that the source code is any good, though.
I was checking new audio codecs and aac\_he\_v2 turned out to be badass. could go to 32kb/s and audio quality on hifi was still awesome. But it is still to many clicks in gui programs to convert a folder. Wrote some script around ffmpeg which starts mulitple process and converts a folder. Later also some scripts to record radio with streamripper, convert, check wether i already have it and upload to synology
wat ...
So the malicious version is 3.2.0.3. 3.3 has been out for a while. And I believe the entire bootstrap-sass gem is only bootstrap 3, if you are using bootstrap 4 you aren't using `bootstrap-sass` gem at all. But this is kind of alarming. While it seems it took ~a week for it to be discovered, that it was discovered in a week is still pretty impressive. The write-up doesn't mention _how_ anyone noticed this malicious code; it wouldn't shock me if this kind of attack could go undetected for much longer, and it would be interesting to know how anyone happened to notice this one, as we think about how to increase our ability to notice them. 
My God you're insufferable 
As a followup I opened (free for all) and soon to be OSS a tool allowing to diff between releases easily: [https://diff.coditsu.io/](https://diff.coditsu.io/) it gets the data from the RubyGems (not Github) so you can quickly check what the hell includes a new release compared to the one you use.
Since this comment is on top: [https://diff.coditsu.io](https://diff.coditsu.io/diffs/0ea304d8-67f7-49ac-a979-60f7ade42720) \- my free tool to check for release diffs against data from rubygems (not github). Hope it will help someone.
It's a sharp tool you can hurt yourself with, but sometimes you need a sharp tool you can hurt yourself with. Is why it is both right for it to exist, and for the docs to urge caution. 
Not tangential at all! At the moment, Opal is used to compile Ruby to JS - in the future, Ruby will be compiled directly to WASM (through some clever process which does not exist yet). At this point though, what matters is the DSL and the tooling chain. As Rubyists, we will be able to write code which runs in a browser just as quickly as if it were written in any other language compiled to WASM. The Hyperstack framework (Components, Operations, Models, Stores) then becomes the important 'IP' the framework brings which abstracts from the very fast changing underlying technology stacks. WASM - come quickly please!
True, although this one was found almost immediately after going live. And I think previous cases were often fast as well? Not sure. There are likely others in the wild that haven't been found, which is scary as well!
As others have mentioned, you should be using parameterized queries: statement = @client.prepare("INSERT INTO db.table(name, other) VALUES (?, ?)") statement.execute("Bob", "Other1") statement.execute("Alice", "Other2") (Code not tested; it's based off the examples in the mysql2 gem docs) First, this will help prevent SQL injection attacks. Second, this will help with performance because the SQL engine can cache the parsed SQL statement. (Doing it your way, the SQL statement must be parsed every time because the embedded values change the string). Third, it's easier than adding code to escape all of the variables and the final result is often easier to read. To me, using parameterized queries is the correct quick and dirty way. 
Hyperstack state management uses the concept of *observers* and *observables*. Any object can be an observer, or observable, or both. When an observable object *mutates*, then all of its current observers are notified. **That is the key** All components are by definition "observable" and all components implicitly observe themselves. This means that all you need to do in a component is call the `mutate` method, to indicate your state has changed, and the component will rerender. Other objects have to explicitly indicate they have been *observed* using the `observe` method. &amp;#x200B; So for example a very simple observable class object would look like this: class ClickCounter include Hyperstack::State::Observable class &lt;&lt; self def click! mutate @click = (@click || 0) + 1 end def clicks observe @click end end end This can be shortened to the following using helpers that are built on top of `observe` and `mutate` class ClickCounter include Hyperstack::State::Observable class &lt;&lt; self mutator :click! { @click = (@click || 0) + 1 } state_reader :click end end Now several components may call `ClickCounter.clicks` which will return the current value of @click, *and will also register the component as observing the ClickCounter object*. Sometime in the future, some event will occur causing `ClickCounter.click!` to be called, and all those components *observing* `ClickCounter` (i.e. that had called the `click` method) will be rerendered. In the above example the "Object" is the `ClickCounter` class. This works because in Ruby everything is an object including classes. You can also have more complex stores, where each instance of an object is its own observable store. For example, have a look at the [Stock Ticker Example](https://github.com/hyperstack-org/hyperstack/blob/edge/ruby/examples/misc/stock-tickers/app/hyperstack/stores/stock_ticker.rb) &amp;#x200B; Under the hood this is how it works (if you are interested) Hyperstack keeps a many-to-many map between objects that have been observed and objects doing the observing. The map is built during the rendering process (but any two objects can participate not just components.) Then in the future, some event(s) will occur that will *mutate* the state of some *observed* objects, and any of its *observers* will then be queued for notification. Once the event completes processing, the queue is processed. The observers in the queue may themselves have been observed and so it waterfalls down through the system, until all objects affected have been queued up, and processed. When this process completes all the observers that are also React components are then re-rendered.
It has been restructured, and the gems are nicely layered. For a the basic React DSL you would just need the hyper-component gem, which does not depend on hyper-operation or hyper-model. &amp;#x200B; That said there are still some dependencies on Rails for things like sprockets, and other asset management. We have some of the team working on a standalone version that would just be a NPM package so please stay tuned. &amp;#x200B; To help us understand your requirements, what will you do for the backend (at least to deliver the assets) and what do you use for persistence? 
Only on the first time, then it defines the constant, and life goes on full speed ahead, without calling const-missing again
To answer your original question about gsub, passing \' (I'm leaving off the quotes) is a special sequence for gsub that means "everything after the match", which is why "malley" was being inserted. So, as you guessed, you want to escape the backslash and use \\' (Once again, I'm leaving off the quotes). To escape this string for Ruby, using four backslashes should have worked for you ‚Äî "\\\\'". Using five backslashes should give the same result because you would be escaping the single-quote. "\\\\'".length # four backslashes; evaluates to \\' =&gt; 3 "\\\\\'".length # five backslashes; evaluates to \\' =&gt; 3 In the end, you said that this ‚Äî gives me "O\'malley" ‚Äî which seems correct to me if you are printing out the value in the database in a way that would quote the string. (You kind of lost me at the end with the results). The escape function that Andy pointed out will be more reliable, and using parameterized queries the best of all, but I just wanted to explain this gsub gotcha in case it comes up in other parts of your code. 
Thanks for the write-up! Does this sidestep the need for a state management library like Redux? That is, for parent to child or sibling to sibling data flow, can I just have them observe each other instead of passing data up and down the component hierarchy? (React people, please excuse me if that's not how it's done!)
That is 100% right. It is far simpler than Redux and works like a dream.
Yep that is the whole idea. It accomplishes the same thing as Redux but in a more "ruby-ish" way. You can in fact directly access state between components, but in most cases I would not. Going back to the `Clicker` class, you could just shove the methods (at the class level) inside component "A" and then components "B" and "C" can access this global state belonging to A. Probably in general not a good idea. Better to put your global state stuff in a class (or classes) someplace else. Hyperstack supports (but does not enforce) this view by having a store directory where you can put such classes. The exception might be that component "A" is the only component that will ever mutate the click count, while other components want to only read it. This might be a case where you would put the clicker inside of "A". The Hyperstack team is far less opinionated than the Rails (and Redux) world, and our view is to provide the good mechanisms, and let the programmer decide how to use them. BY THE WAY: One thing people love (and maybe hate) about Redux is that data is immutable. So when you change state you update the entire global state object, and then manually notify components that care. It has some cool advantages, but its not the way we do it. Mainly because it would never work that way effeciently with ActiveRecord.
It's not the CloudFlare cookie, it's just a disguise. Cloudflare has 2 underscores, the exploit uses 3.
I was hoping it was this. I came across this when messing around in metaprogramming, and I found it hilarious! I think it's a witty way to say "You can do this, but you'll probably mess up the author's intent in the process."
That method is extremely useful for metaprogramming. Its use should not be discouraged just because some people abuse the feature in order to circumvent APIs. &gt; Using this `instance_variable_set`, I would be able to _[...]_ You can also set completely new variables on existing objects, even ones created by code not under your control. Just like you can add new keys and values to a hash or new properties to javascript objects. This lets you add more data to your objects without wrapping them inside other objects. Defining singleton methods on specific objects serves the same purpose.
That sounds promising. My apps are generally Sequel and Sinatra on the backend, Sprockets isn't a big deal as a dependency, and an npm package would be perfect actually - we always deploy the frontend asset serving separately anyway (most of the time we prebuild static bundles, but being able to do server side rendering is attractive if it doesn't mean dragging along a lot of extra dependencies). I guess we *could* use Rails just to prebuild asset bundles, but it's extra complexity.. Most of the apps I work on have backends that consists largely of APIs generated dynamically from database metadata that serve up JSON-api compatible responses, and use just the bare minimum beyond Rack. So really it's the Component part I care about - if I can use that without dragging in all of Rails it can quite possibly fit in just fine on my frontends without affecting my backends, but let me selectively share gems to e.g start inspecting our data mod metadata to generate parts of the frontend too. 
I think where we are going to end up is with a Rack app. That won't be hard to extract out of the existing code. HEY WE ARE ALWAYS LOOKING FOR CONTRIBUTORS :-) The other side project a lot of folks are discussing is to make a ActiveModel like class with some kind of protocol adapter so you can access your JSON data via some more Ruby-ish model files. 
How is arbitrary code execution from an attacker anything else but a backdoor?
May i suggest putting a screenshot or link to youtube video of gameplay in the readme?
Sounds interesting. Got any screenshots?
Found some in his source code but they‚Äôre 4yo. Not sure how relevant it still is [screenshots](https://github.com/victords/super-bombinhas/tree/master/screenshot) 
Just a heads up that it's entirely possible to compile \`mruby\` to Wasm right now, and there's nothing really stopping you from doing the same with \`cruby\`, it would just be a bit too beefy. &amp;#x200B; [https://twitter.com/widdnz/status/1112937763383308289](https://twitter.com/widdnz/status/1112937763383308289)
When you say "script", does that mean just top-level code, no classes/methods? Or do you just mean in your program generally? One way to manage it is to replace `exit`/`abort` with your own method that then calls `exit`. That gives you flexibility to add messages, etc., as well as making it easier to change behavior in the future. Another approach is to use exceptions instead of calling `exit`. Rescue all these exceptions in one place and set the exit code appropriately.
This all sounds like excuses for poor programming. I work on a project at work where someone has used internal API features, and forgotten to record what they did and why. Since 2014 (launch) the business has been unable to upgrade a core dependency and we now have 5 years of shit to separate and un-fuck because some moron had a bright idea, likely they felt that it was easier, or a nice to have feature to do this as well. If you leave the API's for objects alone and work on composition via injection and inheritance, you'll have an easier time. Neither thing you've mentioned is needed. Further, the most basic rails singleton enforcement would take an object as an argument and def get_instance() @@instance ||= Instance.new end example https://repl.it/repls/NiftyIllustriousPolygons The class you send in (via constructor) doesn't enforce it's single-ness, the singleton utility class (probably one per-type) does. That way if you wish to re-evaluate single-ness, for example a multi-threaded class with locking, you don't have to keep altering the core behaviour, just the special-case rules.
&gt; This is also the only mention of encapsulation in all of the core docs. Which is sad as it's such a powerful programming concept.
I can see mocking gems and cucumber Devs salivating already 
Come on, using ORM (especially a bad one like AR) for escaping params is like killing a mosquito with a howitzer. It can be done on so many different ways without sacrificing performance and adding unnecessary complexity.
VERY interesting! I would love to see speed/size tests against Native JS/ Compiled JS and (Mruby -&gt; WASM). 
.rb file purely procedural. Rewriting with classes and exit conditions - by time, resources availability, user messages - are popping up all over. Not very elegant. Was reading [intro](https://github.com/piscolomo/ruby-patterns) about patterns - not a coder myself, just a hobbyist - for inspiration and as example observers caught my attention. But they are backwards one to many and not many to one as I think would be required.
As others already said, could you attach a few recent screenshots?
Great news! Thank you, faastRuby dev! ‚ô•
youtube link for who finds it more convenient: [https://www.youtube.com/watch?v=GEe7hHIhyUs](https://www.youtube.com/watch?v=GEe7hHIhyUs) 
RSpec would be best I think, e.g. `expect(5).to be &lt; 4` gives the correct error message.
Oh fun. Thanks for the write up. 
Hmm. There are some ways... I use a pretty stupid way but it works semi-okish. First, I tend to not use exit() directly but a wrapper method such as exit_program() (I use the () just to clarify here what I mean). Then I also may add code such as def register_sigint Signal.trap('SIGINT') { exit_program } end; register_sigint And only exit_program is allowed to make use of exit(). There are a few other strategies, such as at_exit(), but I don't like it because I think it leads to hard-to-control and quite ugly ad-hoc code (but it's ok that it exists; I just would not want to use it when the rest of any system is better designed). I guess it depends a lot on what you exactly have to do in your given project when exiting. Often in my exit_program I determine whether I am allowed to exit or not; I may have to run some clean-up tasks, before exit() is finally called. Some begin/rescue clauses may also be necessary every now and then. It's not really a very elegant thing either ... sort of just what one may have to use for code that is published in the wild. :\ I often tend to have projects behave differently, based on whether they may be run on the commandline + colour support, or in an oldschool GUI (ruby-gtk) or on the www (the latter which seems to become very frequent, even without rails).
I'm not denying that encapsulation is a good concept for programmers to know, but should such things really be mentioned in the language documentation? As far as I can tell, the documentation isn't meant to teach you how to program.
Assertions are as informative as you make them. In my opinion, `Expected 5 to be &lt;= 4.` is also not very informative. This example has an informative error message, and, in my opinion, reads much better than `assert_operator`: ``` assert(booked_seats.count &lt;= 5, "expected at most 5 seats to be booked, but #{ booked_seats.count } were") ``` That being said, I mostly use `assert` when writing helper functions for tests, or when testing for truthiness, e.g. `assert reading.consistent?`.
[removed]
&gt; I have exit control points becoming more and more numerous in my rb script. Any pattern suggested to collect them? This is not a reason alone to refactor. As [my friend](https://github.com/vadimr) once said: &gt; The goal is [should be] to make readable maintainable code, not the most compressed possible. But, without _seeing_ the code, I can offer this: Group by what prints/doesn't, what prints to stderr/prints to stdout, and what exists success vs failure. If you just use `exit 1` for failure with a message to stderr you can use `abort`. You can use `warn` over `$stderr.puts`. Often times I find myself doing what /u/StarStuddedSuperStep suggested: def usage(message) # exit 1 for usage issues abort "#{message}\n#{USAGE}" end def error(message, status = 2) # exit non-1 so executors can differentiate usage form other errors warn message exit status end 
I use it when the expected value is `true`. `assert some_obj.predicate?`
While I think OOP-driven design is better, there is no problem with "purely procedural" either. You can just put exit-calls into a single method anyway. I am a hobbyist too even though I wrote a LOT of ruby code over the years. I think the primary thing to consider here is what the code wants to do, and what you have to do with it; if you have several exit-points then it may be worth to transition into modules first (may be simpler than classes). You can even do stuff like: module Foo def self.exit_program exit Just to illustrate. May seem like extra work, which it is, but it helps a LOT the more code you have already written, and invoking that code or re-using it from other code eventually. I am unaware of more patterns. Typically exit() is quite simple even on *nix. You just pass a number to indicate success or a particular failure. I don't even make a lot of use of that, but ideally people could write scripts to also use "proper" exit codes (but I don't think it is that necessary... the only real thing I sometimes have to do is to run certain clean-up operations such as removing semi-temporary directories or files again).
love it! but will wait till the viscose plug-in supports it better. 
The only thing I don't like about more complex assertions is when I have to lookup what the assertion does. I never have that problem with plain ol' `assert`. I usually prefer a minimal test framework
If you're predicate takes no arguments, you can also use assert_predicate some_obj, :predicate?
Thanks for sharing. _I don't know if Action Cable has has significant changes in Rails 6 bit it would have been better to start with Rails 6 anyway.._
True dat. But OP is right, assert is rarely the perfect choice. If you actually read the source of Minitest, you'll see that all of those other assertions are just wrappers around \`assert\`. &amp;#x200B; \`assert\` is really just the building block for building your own assertions.
Very complete! Thanks for the article! Been wanting to do something with action cable for a while now
This is a cool idea for a service. I'll be taking a look, I have a use case for this. I am currently dealing with headaches that your proxying feature could fix for me.
It's documentation of the ruby 2.6.2 runtime features right? It's exactly docs on what is available for programming, which should include some usage patterns. FFS everyone always says they "learned by doing". Imagine how bar-raising it would be to document anti-patterns on the runtime page. Don't listen, don't bitch when the runtime deprecates your stuff
Title reads like "Creating a cake from scratch using a box of cake mix." Using Rails, Devise, and ActionCable, you are standing on a lot of shoulders. 
Sometimes I want to test if a non-predicate value is true/false, and `assert` is best, but the message is bad. I give my own: object.some_method # should set value_thing to be a true-value assert some_obj.value_thing, 'some_method didn't do the thing' This way when I read the failure I may not have to read the test to have an idea of what broke ("the thing" didn't happen in `some_method`) when the assertion failed.
Updated screenshots added to readme!
How does using only `assert` save you time? If as assertion fails in an unexpected place due to a change you made you now have to read that test in order to discover why it could have failed unless your messages are excellent. Using the higher-level assertions can save you that time by providing extra context around the failure, especially when combined with clarifying messages.
I care less about what the test message says and more about the test being easy to understand. In the cases where I do care about the message I just add a custom message. I find `assert` and `assert_equal` to be enough for 99% of cases. If you were to ask 100 random Ruby devs what `assert_predicate` or what `assert_in_epsilon` did then half of them would probably give you wrong answers
Nice write up, cheers!
I'm not sure how writing the implementation needed for [correct comparison of floating point values](https://github.com/seattlerb/minitest/blob/1f2b1328f286967926a381d7a34e0eadead0722d/lib/minitest/assertions.rb#L204-L218) in your tests repeatedly makes it more understandable (or likely to be error-free) than reading the documentation on `assert_in_episilon` once or twice and having a general understanding that "this assertion works for float-math correctly, unlike `assert_equal`". The same goes for any other place you're repeating work that is already provided by the library in order to allow common understanding amongst your collaborators. This might be easier for you to understand because you're familiar with your code, but an outsider is going to have a difficult time determining exactly what behavior your ad-hoc set of `assert`s is supposed to mean, even if they can determine whether the behavior you've specified with them is truly intentional or not.
I learned Ruby using this book back in 2013 - it's really easy to read and has a good coverage.
My concern is to make the code more readable. Especially conditions controls leading to exit execution. Now are all over the place. I am not concerned about error messaging / exit code since is a relatively short script for personal use. Notifies on Discord if air pollution is high.
Never considered module will see how it fit. Thanks for suggesting. From the patterns git cited before was wondering if the [state](https://github.com/piscolomo/ruby-patterns/blob/master/README.md#state) pattern my help. Assigning a state name to every exit point and .trigger each state when needed. Not sure won‚Äôt render refactoring more difficult though. Isn‚Äôt a state machine per se so not sure would be beneficial to force the script flow in it.
I would update your description to include _condition controls_. But these are the kinds of things that require code examples to offer legit suggestions. 
Arrived last week :D 
Awesome. 
I used Ruby professionally and personally before I read the second edition, it gave me a solid understanding of the language and the nuances of it. I still read the book once a year as a refresher; it's pretty straightforward and digestable
Huh? When you say you installed ruby 2.6.1, how can you have gem version 2.0.3? I don't think ruby 2.6.1 came with gem version 2.0.3
Personally, I would recommend using Windows Linux Subsystem (e.g. Ubuntu in the Windows Store) or VirtualBox + Ubuntu.
I am working with some other community folks to get the codebase ready for collaboration. I've been working on this by myself for a while, and there's a lot in there. There are 5 services. * The management API (written in Ruby) * The endpoints for function invocation (written in Crystal) * The Runners (written in Crystal + Ruby) * The Scheduler - this one handles periodic invocations (just a cron) * The Event Hub (written in Crystal) - This one allows for pub/sub behaviour, but I never put it in prod because there are still some things to be addressed. On top of that, there's the faastruby gem and the faastruby-rpc gem (the one that allows for calling functions from within functions asynchronously). Then on top of the codebase, there's also database, loadbalancer, storage and the configuration to run all that in a swarm or kubernetes cluster! Phew! I will start a series of blog posts about the architecture as we approach the opensource release date. The exact date is not set yet, but the goal is get this done by the end of the month! The license is something I am still thinking about. I would love to see a big community grow around this project. It has to be a license that allows the community to use it and help improve it, and at the same time make it possible for me to have a business around this project, so I can make faastRuby my full time job. I want to make sure there are funds to keep the project well maintained.
I posted some updated screenshots in the readme.
I posted some updated screenshots in the readme.
I posted some updated screenshots in the readme. Unfortunately I don't have an updated gameplay video ready for now.
Yes, I think that‚Äôs what its about. It‚Äôll help web app developers incorporate basic chat functionality into their apps. Not everything has to be a fundamentals write up.
Same for me in 2017. Great intro to OOP as well as the Ruby language.
/r/titlegore &amp;#x200B;
Something no one ever brings up: `assert(...)` is almost always the most readable code. With test-bench I didn't include anything beyond bare assert/refute and frankly, in practice, those contextu assertion messages are highly overrated.
You're assuming there's no other means of supplying the contextual data. In all the systems I work with, for instance, there is rich logging and telemetry that provides the same information. I'm not saying "you're doing it wrong," just that there are other ways to skin this cat.
"Why did this test unrelated to my change fail? I didn't change this code, and I can't tell from the assertions" "Oh, yeah, you have to read those logs over there, or in grafana which you can start up locally like this" "But these logs only tell me what's happening, how do I know if that is correct without it being written down in a test? And why do I have to set up grafana to debug my tests?" One of the ideas around testing is you can look in one place, the test results, to have a good idea why some unrelated thing to your change is not working. Spreading that out across three places eliminates that benefit. An unfamiliar programmer having to look in the logs and set up telemetry collection throws out all those benefits that testing is supposed to be providing you. If your system can't get common testing feedback from a test failure I don't understand how you can maintain any velocity in the face of requirements changes or perform reasonable refactors without internalizing the entire system.
For anyone with a O'Reilly Safari subscription: https://learning.oreilly.com/library/view/the-well-grounded-rubyist/9781617295218/
Why couldn't log output be part of the test result? It is in all the systems I work with (when enabled). I test my systems as thoroughly as anybody and simply have no need for assertion failure messaging. Some people like friendly assertion failure messages. Hell, I used them for years, so to each their own. But there is nothing necessary about them.
Thank you! It looks very cute.
What do you mean with "leak queries"?
When you cannot take advantage of hash conditions you can always use a block definition as `can? :show, Post do ... end` which is basically an alternative DSL to write `def show?` in Pundit. Do you maybe have an example of something you can do in Pundit that you cannot in CanCanCan? This would be a great feedback to improve the library. Thanks
when did you feel the need of switching to a different authorization framework? Which were the reasons? This could help us to improve the library.
This could be a good starting point: [https://github.com/CanCanCommunity/cancancan/network/dependents?dependent\_type=PACKAGE](https://github.com/CanCanCommunity/cancancan/network/dependents?dependent_type=PACKAGE) I personally remember Spree/Solidus or graphql-guard
C3's means of describing authorization is a single function, sort of like this: ```ruby def some_role_name can :read, Foo, { color: 'red' } end ``` This becomes problematic for some data structures. My employer is a health and nutrition coaching company. Coaches have many clients, and these clients are grouped into cohorts. Here's an actual ability in our `coach` role: ```ruby coached_cohort_ids = user.coached_cohort_ids can :crud, ContactMethod, user: { memberships: { cohorts: { id: coached_cohort_ids } } } can [:read, :update], Membership, cohort: coached_cohort_ids ``` These lines were added by a developer that wasn't paying close attention. `coached_cohort_ids` is evaluated for _every_ request, even if we don't care about the ability in question (it's being "leaked"). This kind of thing is far too easy to do with C3.
Can't say I've even had the chance to ponder it. I work mostly with non-profits and organizations whose primary mission is social good. They barely have budget to allow us to work on their projects let alone spend time on things like swapping major pieces like an authorization framework.
(This is hanami the app framework, not to be confused with hanami the VPN-like networking tool) 
The Phobos gem is great for handling everything kafka related, means you only have to worry about business logic.
I've been waiting for the follow up. thanks!!
Here's a fun one: https://www.bloc.io/ruby-warrior#/
https://ruby-doc.org/gettingstarted/
it is often the most readable in source code, but the least informative in it's error message when it fails. I've gone back to rspec again for several reasons, but one is the way it shows you the line of source that the assertion is in with the failure message, making the explicit failure message less important to informing you of what failed. 
i like this way of presenting things. 
Nice reading Karol. Send my regards to Seb and keep the good work! 
How did you get your ruby? Either operating system, rvm (or similar), or compile from scratch?
https://rubymonk.com/ - by far the best resource I used when learning ruby 
Launch School is a great program. They have a bookshelf available for free: www.launchschool.com
App Academy starts you off with Ruby and their entire curriculum is available online: [https://open.appacademy.io/](https://open.appacademy.io/) 
As archlich mentioned, you should specify the OS version (Raspbian? Ubuntu? ...). Anyway, using [RVM](https://rvm.io/](https://rvm.io/) can help you to easily install any version of ruby
The Odin Project
Check out [The Odin Project](https://www.theodinproject.com). It's a guided curriculum for full stack webdev with Ruby (Node and possibly others in the future, but not *quite* yet) and Ruby on Rails. 
Hey Karol. I'm the author of the Karafka framework. Thank you for the great introduction to Kafka and Karafka! Here are some remarks related to your article that I think might be of interest to people that decide to use Karafka: * You've used the Github version instead of the RubyGems one. That is great, but it's worth pointing out, that RubyGems contain the `1.2.x` version while the master on GH `1.3`. We didn't yet release the `1.3` to Github as we're waiting on the dry-rb team to finish last upgrades of gems that we're using. They're almost there and we're waiting due to several breaking changes that they're introducing. * The docs for `1.2` can be found here: [https://github.com/karafka/wiki/tree/1.2](https://github.com/karafka/wiki/tree/1.2) * You don't have to use Responders to send messages to Kafka. There's a more "low level" library called WaterDrop (also maintained by us): [https://github.com/karafka/waterdrop/](https://github.com/karafka/waterdrop/) that allows you to "just send whatever you want"‚Ñ¢ ;) * It's worth pointing out, that if you use an optional Sidekiq Backend, you might lose the ordering feature of Kafka messages receiving, as Sidekiq consumes jobs, not events. Thank you once again for the great article and in case of any problems / questions related to operating Karafka on a big scale (more than 6-10k rq/s) you can always ping me here or via GH!
Very nice example. Thank you! You are absolutely right: this is not how the library is meant to be used. I think we have something in our plans that will mitigate this. Thanks for the feedback
I recommend the following course on PluralSight. Helped me learn ruby in 2 weeks: https://www.pluralsight.com/courses/ruby-fundamentals
&gt; \2. A class method is defined with two parameters, 'array' and 'result=[]', meaning one of the parameters is an empty array. The `result` is an empty array by default, but you can supply another object instead, this is actually important for your second question. &gt; \4. (here's where I get confused) If the element is an array, it calls this method that we're defining on it. I still don't fully understand that. And if it's NOT an array, it puts element in result? Your problem here is not with parameters, but with recursion. Your reasoning is quite right, if an element of the array that you are flattening is an array then you'll need to add every element of that array to the result (but if one of the elements in this new array is yet another array then you'll need to add every element of that array to the final result as well). So to answer your questions &gt; Why can you call a method in a method while you're defining it? Because it's extremely useful to allow a method to refer to itself, nearly every programming language will allow this. Note that you're also not calling the method while defining it, the `flatten(element, result)` part of the code is only called after something else first calls FlattenArray.flatten(some_array), which in turn can only happen after the class and it's methods have been defined. &gt; What is flatten(element, result) doing? How does it know to do what it's doing? One way to test this out is to print the parameters when you enter the method. class FlattenArray def self.flatten(array, result=[]) p(array: array, result: result) array.each do |element| next if element.nil? element.kind_of?(Array) ? flatten(element, result) : result &lt;&lt; element end result end end Then try to run FlattenArray with several different parameters irb(main):023:0&gt; FlattenArray.flatten([[1,2],3,[[4,5]]]) {:array=&gt;[[1, 2], 3, [[4, 5]]], :result=&gt;[]} {:array=&gt;[1, 2], :result=&gt;[]} {:array=&gt;[[4, 5]], :result=&gt;[1, 2, 3]} {:array=&gt;[4, 5], :result=&gt;[1, 2, 3]} irb(main):025:0&gt; FlattenArray.flatten([1,[2,[3,[4]]]]) {:array=&gt;[1, [2, [3, [4]]]], :result=&gt;[]} {:array=&gt;[2, [3, [4]]], :result=&gt;[1]} {:array=&gt;[3, [4]], :result=&gt;[1, 2]} {:array=&gt;[4], :result=&gt;[1, 2, 3]} =&gt; [1, 2, 3, 4] 
&gt; meaning one of the parameters is an empty array No, it will only default to an empty array (if no second argument is given). &gt; If the element is an array, it calls this method that we're defining on it. This is called recursion. It's super cool. &gt; What is flatten(element, result) doing? In irb, try copying your code and execute it with: FlattenArray.flatten([1,2,[3],[4,[4,5,6]]]) =&gt; [1, 2, 3, 4, 4, 5, 6]
Your problem is with recursion (keyword, Google it). The "array" could be only [1, 2] or [[1], [[2]]]. You should write down on paper all instructions/line of code executed with indentation. You should see the recursion is a kind of a loop. It take me a while night at college with mates to understand it. Take it easy.
&gt; Why can you call a method in a method while you're defining it? But you're not. When you're defining the method, you're writing a list of instructions of what to do *when you're calling it*. You're not calling it then and there. So when you get around to calling it, calling that method is no different from calling any other method. That you're in the same method already makes no difference. Think of the method definition as a set of instructions. If I give you this list of instructions, would it confuse you that it refers back to itself? How to paint a square: 1. Divide the square into four parts. 2. If the smaller squares are not small enough for you to reach every part, follow this list for each smaller square. 3. Paint each smaller square in turn. It's the same thing. You're just saying "for this part of the problem, apply the same list of rules", then go back and continue from where you were. 
your issue is around Recursion. think about the class you're making - you are trying to flatten an array (meaning, bring up any value into 1 larger array). if you're iterating through the values of the first array, and find another array, ask yourself - are you trying to flatten it? if so, why make a new function if you've already created a function that will flatten it for you?
Recursion. It's a more advanced programming methodology, and generally isn't seen that often. But, basically, what you're doing is, instead of littering your method with a bunch of conditionals, you're allowing the method to recursively work over a bit of code. If you, instead, wanted to do this conditionally, you'd end up with something like the following: if element.is_a?(Array) element.each do |inner_element| if inner_element.is_a?(Array) inner_element.each do |inner_inner_element| ... and on and on and on Your `flatten` method would become unruly and difficult to manage. And, at some point, if you have nested array upon nested array, *something* will eventually break it. So, since `flatten` already takes an array and does work on it, why not just call it again? That's recursion, and that's why it's useful. And, for your question #4, an array could be something like `[1, [2, [3,4,5], 6, 7], 8, [9, 10]]`. The values 3, 4, and 5 are in an array, which, in turn, are in an array. You come across the first value (1) and you push it to the result. You come across the second value - `[2, [3,4,5], 6, 7]`, which is an array, so you'd call `flatten` on that array. Inside that call, the first value would be 2, so push it to the result. The second value would be [3,4,5]. Another array. You'd call `flatten` again. Eventually, it spits back out the result. That said, I'm pretty sure you don't need `result` as a method argument, instead defining it on the first line of your method (`result = []`). And I'm also pretty sure `flatten(element, result)` should really be `result &lt;&lt; flatten(element, result)`. If you're still confused, I would recommend that you do the following: class FlattenArray def self.flatten(array, result=[]) puts "#flatten called with array #{array}" array.each do |element| puts "element = #{element}" next if element.nil? element.kind_of?(Array) ? flatten(element, result) : result &lt;&lt; element end result end end By adding `puts` statements, you can see some debug messages in the console. Throw a ridiculous array at it. Then see what happens. You could also create a ridiculous, multi-dimensional (that's what nested arrays are technically called) array, and run through it *on paper*. Yes, that white or yellow stuff that people don't use much - work through it, line by line. Figure it out. Hope that helps!
Native on raspbian
There's a lot of things to go into for this code snippets, but I'll keep it short, since I'm at work and maybe someone else will answer in more detail. But feel free to ask follow-up questions. First of all, the `self.flatten` method is not defined on the `Array` class. It is a separate class, for utility purposes, I assume. Also, note that it is defined on the meta-class via the `self` prefix. This means that the method is not called on an object (like `my_array.flatten`), but instead is called via the class path, so `FlattenArray.flatten(my_array, [])`. Generally, `flatten` for arrays means that the contents of nested arrays are put into the main/root array. For example, `[1, 2, [3, 4], [5, [6, 7]], 8]` would get flattened to `[1, 2, 3, 4, 5, 6, 7, 8]`. And in fact, your method pretty much does just that (unless I'm missing something there). The part that seems to confuse you is the recursion, meaning the method calling itself. Recursion is a pretty common way to solve such problems and for now, let's just say that it works because the compiler/interpreter knows how to handle it. The code that is eventually executed is not exactly what you wrote. There are a few things that happen in between and I think the reason why the method can call itself is because before the method body gets parsed, the method signature (ie method name and parameters) gets added to a lookup table, and so once the method body gets parsed and the method comes up in its own body, it can be resolved, because the signature is already known at this point, but that's not so important to understand right now. I don't fully understand it either, yet. But to get back to the `flatten` method, let's see how it would work on my example from above: def self.flatten(array, result=[]) array.each do |element| next if element.nil? element.kind_of?(Array) ? flatten(element, result) : result &lt;&lt; element end result end When we call `FlattenArray.flatten([1, 2, [3, 4], [5, [6, 7]], 8])`, the following happens: *(sorry for crappy formatting)* * *(flatten\_call\_1)* `1` not instance of Array, so `result &lt;&lt; 1` * *(flatten\_call\_1)* `2` not instance of Array, so `result &lt;&lt; 2` * *(flatten\_call\_1)* `[3, 4]` instance of Array, so `FlattenArray.flatten([3, 4], result)` (result == \[1, 2\]) * *(flatten\_call\_2)* `3` not instance of Array, so `result &lt;&lt; 3` * *(flatten\_call\_2)* `4` not instance of Array, so `result &lt;&lt; 4` * *(flatten\_call\_2)* return `result` (result == \[1, 2, 3, 4\]) * *(flatten\_call\_1)* `[5, [6, 7]]` instance of Array, so `FlattenArray.flatten([5, [6, 7]], result)` * *(flatten\_call\_2)* `5` not instance of Array, so `result &lt;&lt; 5` * *(flatten\_call\_2)* `[6, 7]` instance of Array, so `FlattenArray.flatten([6, 7], result)` (result == \[1, 2, 3, 4, 5\]) * *(flatten\_call\_3)* `6` is instance of Array, so `result &lt;&lt; 6` * *(flatten\_call\_3)* `7` is instance of Array, so `result &lt;&lt; 7` * *(flatten\_call\_3)* return `result` (result == \[1, 2, 3, 4, 5, 6, 7\]) * *(flatten\_call\_2)* return `result` (same as above) * *(flatten\_call\_1)* `8` not instance of Array, so `result &lt;&lt; 8` * *(flatten\_call\_1)* return `result` (result == \[1, 2, 3, 4, 5, 6, 7, 8\]) &amp;#x200B; So what we can see is that when a nested \`flatten\` is called, it gets executed and then returns back to the calling \`flatten\` method and only once **our** call returns (so *flatten\_call\_1* in the example above), do we get a result. To better understand this, you should take a look at **recursion** in general. There's a lot of material on it that also explains things like the **call stack**. And if you're not familiar with it, you should also read about **object references**, which is utilised in your example above. Note how the return argument from the nested flatten calls gets ignored in the calling method? That works, because arrays are passed as references (or rather, their references are passed as values). So when the \`result\` gets changed in *flatten\_call\_2*, this change will also be visible once we're back in *flatten\_call\_1*, because both methods reference the same object. 
I think you get confused by the ternary operator there. I also assume that you did not write that code. I myself avoid the ternary operator because EVERY time I see it, my brain takes more time to break the code down. What the code does is indeed a recursive call; if true, aka an array, it will call .flatten. If false, it will simply append to result. So quite simple really. Thanks to ternary it made this simple thing harder than it should be. As for defining a method within a method - I don't see that here, I only see method calls, but you can indeed define a method within a method e. g. via define_method and other ways. I myself very, very rarely do this. Most of the time it is not necessary and it always leads to more complicated code. My code should be so stupid that I never have to think at all when seeing it. Avoiding confusion is precisely one massive reason as to why I do that; and because I am lazy too. By the way you actually interpreted the code quite correctly in your initial description. I really think the ternary tripped you there. Actually, I don't even know why the code is written in that way either - it is not your code right?
Well if you‚Äôre up for some compiling I‚Äôd recommend using rvm to build your dependencies. 
Okay, this is straightforward enough, it's just using recursion. it puts a kind of fold in the logic, but it's easy enough to follow once you get the concept. First thing you need to understand is recursion. The easiest way is to start with a much easier function, like factorial. You could do it the procedural way: def factorial(x) a=x [x-1 .. 2].each do |n| a *= n end a end and that's workable enough for a simple function. But another way you could do it is to go recursive: def factorial(x) return 1 unless x &gt; 2 return x * factorial(x-1) end There's no explicit loop in the code, but factorial keeps getting called with an ever-lower number until it hits 2, at which point the whole chain terminates, and the returns ripple back up the stack of calls and fall out the top. And dammit, that's *pretty* code, as well. Now with your flatten routine, a procedural approach is going to be *really* hard. You've got a list of elements, and you loop through them. Ok. You pull out a few scalars, then you hit an array. How do we handle the array? Well, you loop through it, pulling out items, and if they're all scalars that's easy, but then you hit an array. Fuck. Your loop-and-if-statements are going to get nested and nested and nested infinitely, as you write case after case *of the same damn code* at each level. Something is very wrong here. You're going about it the wrong way. We have code that pulls items out of an array already, it's our loop. So when we hit an array in our elements... we feed *that* array to *another incarnation* of that code. And if *it* hits an array among *its* elements - well we've just written to code to handle that, it feeds that array to yet another incarnation of that code. There's no more nesting off the right-hand edge of the screen. The *same* couple of lines are handing it at every level, albeit in different contexts. When an incarnation runs out of elements, it returns result. When the parent of that incarnation receives the return, it inserts them into its own copy of result - and when that parent runs out of elements, it returns to *its* parent, if it has one. And if it doesn't have a parent, then result is the complete set of flattened elements from the original array. 
Thanks, very nice to hear that :). &amp;#x200B; Good catch about Sidekiq backend, I'll definitely need to mention that one. &amp;#x200B; Yeah, Waterdrop can be used standalone, but I like the overall abstraction of responders and it's a simple one, so wanted to cover it in the article. &amp;#x200B; I think I did a copy&amp;paste from the other project where I had to use master branch from Karafka due to the gem version conflicts with dry-stack, and that's how it ended up here :P. But good catch, I'll need to clean it up. 
Thanks! &amp;#x200B; Haha, I did, although it would be great to know how is sending regards :D.
This episode isn't specific to Ruby, but is still good information to know around the devops side of things with Kubernetes.
It's Thiago mate, I've been with a couple of months with you folks, on the Support Service team. Still messing with ruby though ;)
The line number of the assertion failure is a very important data point to convey, so I agree there. I think there are vast differences in the way we all work, which means we all feel different pains. For instance, I don't work in large, monolithic codebases, and I imagine if I did, I'd have a different perspective on what features a test framework really needs. 
If you're repeating it, I think they are great. Usually though, I see one in some random test and then need to go on a goose chase. As you're alluding to though, `assert` can be just as cryptic if not used properly. While I prefer many small tests with good names, I've also had my fair share of digging through monolithic tests with random asserts - and yeah, that sucks
Thanks :)
woah i just think this is a terrible example. If you want to grok recursion, using ruby class methods to do so is about the worst way to go about it i can think of. If you want to learn ruby class methods surely don't start with something recursive, and if you want to learn ruby default parameters don't use a recursive class method to do it. You should learn about all three of these things, just not at the same time. 
`result &lt;&lt; flatten(element, result)` would create an array containing itself (because flatten returns result, so you'd be adding result as the last element of result). You could indeed avoid having to pass in the "accumulator" result variable, but then you'd need to use `concat`, not `&lt;&lt;`, because otherwise nothing would be flattened.
Reformatting OP's code: class FlattenArray def self.flatten(array, result=[]) array.each do |element| next if element.nil? element.kind_of?(Array) ? flatten(element, result) : result &lt;&lt; element end result end end ------------------------------------------- I wrote a bunch of stuff here about the code, i'm not sure its relevant, as I guess this is a toy chunk of code to illustrate a situation. But here is what I wrote anyway, maybe its useful, if not disregard. I would simplify this a lot. For one, flatten is a built in feature of Ruby's Array class. &gt; 2.5.1 :001 &gt; x = [[[1,2,3],[4,5],[6,7]],[8],9] =&gt; [[[1, 2, 3], [4, 5], [6, 7]], [8], 9] 2.5.1 :002 &gt; x.flatten =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9] For two, this class doesn't inherit from Array, and is only a class method. Might as well just define a function and be done with it. def flatten(collection, initial_result=[]) initial_result + collection.flatten.compact end
Odd. I remember having added something similar to my own ruby code many years ago. I do not remember why I stopped using it, though. :\
Oh, nice :D Hope you've had some fun with Ruby.
Are you planning to go with more examples in k8s in the context of rails? Btw, thanks for sharing..
I could go into other architectural examples of rails apps which uses databases, other services like redis, etc. However, since it is just docker images that are being used to deploy containers, most of the Rails specific stuff would likely be in the Dockerfile which is used to build the image.
Yep you got it.. I meant with other services like redis, sidekiq, etc. I know that there is nothing to do within the rails app (though maybe the secrets...)
This is the second edition, the third edition is not on SAfari.
The link I posted is to the third edition. From the preface: &gt; Earlier editions established this approach, and this third edition expands on it
Yep, that's called recursion -- when the implementation of `flatten` calls `flatten`. I remember it was confusing to me when I first learned it too, although it's hard for me to remember now exactly why. Maybe look for tutorials or textbook material on recursion, whether ruby or not.
You're right. Also, just discovered, O'Reilly have very fragmented offerings. The my.safaribooksonline.com is now different from learning.oreilly.com. The book is available with one of them but not the other.
in english its saying, if i get an array of arrays, call this flatten method again, as in, look into that inner array until you find the elements, and push those into the result array, that way you can give it arrays of arrays.
I see a potentially HUGE problem: Hyperstack became 100% Rails-dependent. This is not good. I went for a website to check how can I use my favourite language to create a standalone frontend app and, unfortunately, all tutorials, examples etc. require Rails. This is not what I want and it should not be a requirement. I remember that back in the days (it was Hyperloop still) it was not like that. Please, don't go that way and provide a first-class tutorials to use it without Rails.
Www.rubymonk.com has pretty good coverage from beginner to advanced topics
RubyConf always seems to be cheaper than RailsConf as it's a bit smaller.
I don't know why conferences hide the previous year's ticket price ‚Äî it makes it so difficult to come up with an estimate for management approval while the annual budget is being made. I've had to skip conferences because of this. Conference organizers ‚Äî please make it easier for us to budget for your conference!
Roundabout 400 usd.
Oh snap, you‚Äôre absolutely right about the &lt;&lt;! Derp me.
We have working to decouple Hyperstack from Rails, its just that documentation is lagging behind. It would be great if you want to contribute to the Hyperstack standalone parts of the project and documentation, please drop by Slack and lets get started! https://join.slack.com/t/hyperstack-org/shared_invite/enQtNTg4NTI5NzQyNTYyLTYzYTZhYTE2MGE5ZTQ0OTAyNDVlMzE5OTk5NWNmZmMzYjhkZGY1MDc3MGFjMGZlYzE5ZWJhZDJiMmQyYzAxMjY
Wow - I consider such prices criminal fraud. People should not support such a ponzi scheme.
Cool work. Isn't it a bit awkward though to call it an encapsulated API when its methods are mutating internal state of other objects? Seems opposite of encapsulation.
I don't know how many conferences you've been to, but that's actually really affordable for a professional programming/computer conf. It pays for a lot of stuff: the venue itself, the speakers (bear in mind that the core ruby team lives in Japan, so airfare ain't cheap), breakfast and lunch for several days for all of the attendees...the organizers aren't getting rich off this. When you call it a ponzi scheme, you're shitting on a lot of hard work that these people do for the sake of the ruby community.
You know how when you bundle install it‚Äôs free? That‚Äôs because Ruby Central, organisers of RubyConf pay for the bandwidth for Ruby gems. The money comes from conference tickets :) Ruby Central is a nonprofit organisation.
True. I have reworded this now
https://web.archive.org/web/20180901160943/http://rubyconf.org/register Wayback Machine rules :)
They can likely reduce this cost dramatically by using mirroring. I wonder why they don't.
I'm sure they will accept your help if you offer to help them, I wonder why you don't.
Just look at the post history of /u/shevy-ruby it's a constant stream of whine and moan.
Find out if they're open to the idea, I'll be there.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [michelson library \/ gem - test simulator \/ runtime for type-safe 'n' functional (crypto) contracts (in yes, it's just ruby)](https://www.reddit.com/r/RubyLang/comments/bb6sth/michelson_library_gem_test_simulator_runtime_for/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Figure it out yourself, I am sure you can find a way to contact them, I wonder why you don't.
Will do!
Btw, the code formatting is messed up a few places (e.g. `&amp;lt;` instead of `&lt;`).
Thanks for pointing that out. I'm wrestling with a new WordPress plugin and I guess it's not fully working yet.
I do not think this has a realistic chance to be added. #map_to makes little sense as name. You can always give it a try at: https://bugs.ruby-lang.org/projects/ruby-trunk The problem is that additions sort of need to have to have use cases that may be useful for more people, in more situations. This applies to #to_h, IMO, but I have my doubts that it applies to #map_to. There are TONS of things that COULD be added, e. g. the whole active* subset, but it does not make a lot of sense to do so for all of them.
i get the sense that "makes little sense as a name" is a reason a lot of methods aren't added. This `map_to` is literally the same thing as `index_by(&amp;:itself).transform_values` just shorter. I would personally lean toward adding more things to the language, especially for this because it's a thing many people should be doing but aren't (they use N+1 loops instead of indexing one of the lists so that it's N) and having this new method might encourage it. There's kind of a tradeoff between "is this method name" perfect and "does it express the goal more simply than the alternative". I would say it does simplify things, and the name is good enough.
Hmm, this Enumerable#to_h? Been there since at least 2.2 it looks like? https://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-to_h
There was previously a #to_h, but in 2.6 it got a block form that's a combo of #transform_keys and #transform values, so: 3.times.to_h { |n| [n, n.to_s] } #=&gt; {0=&gt;"0", 1=&gt;"1", 2=&gt;"2"}
Reducing to a Hash is a case that #to_h with block handles well: [1, 2, 3].to_h { |n| [n, n.to_s] } #=&gt; {1=&gt;"1", 2=&gt;"2", 3=&gt;"3"} It's a pretty specific case to be reducing to a Hash at all, so I think it'd be taking it too far to have a hard coded method for reducing to a Hash with an unchanged key and function-applied value. I think something more similar to transducers would be a more flexible pattern, where the reducing object can be anything, not just an Array or Hash. https://gist.github.com/havenwood/8a56a87f4976b569abe60d03ea5435d1 The first and second arguments of Enumerable methods could even be the reducing object and reducing step, with `[]` and `:&lt;&lt;` as defaults.
Problem Solved! I just saw that my database had the attribute image in capitalized. So I migrated the change and made it image from Image which made everything work fine.
Would like to see an example of how to write a gem with both a pure Ruby implementation and C extensions (or Java extensions), and can build the C (or Java) code on the appropriate Ruby implementations.
`to_h.transform_values`?
You mean mixing up pure Ruby and C extensions? &amp;#x200B; All you need to do is write regular Ruby as you would for any gem and you have full access to the C extension definitions. There's no extra work or configuration. &amp;#x200B; Concerning java extensions, I have never used it before. However, I know Nokogiri uses java so perhaps going through their code could provide some insights.