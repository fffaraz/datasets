Thanks. Celluloid looks awesome! I have a lot material to read through. As far as testing, I think that's the way to go. I will probably implement some of the more complicated algorithms my existing game server does, and then send packets that would trigger this, and see how it holds up. 
No. It's way overwrought. There's many simpler ways to keep a rails app from turning to custard without buying into some dude's weird little theory. Throw a few simple PORO service objects, and presenters into the mix and you got it.
I do like service objects and presenters/view models. I also like validation outside of models, no callbacks, etc. I have not used them, but the Cell gem looks pretty good, the way it encapsulates the views/view_models. I am not sure why you describe it as "weird little theory"? One of the things that attracted me to Trailblazer was the FP/OOP mix. Do you not agree with that or is it something else?
Awesome information thanks!
https://lolware.net/2016/07/17/intelligent-backend-routes-nginx-rails.html
I know this is /r/ruby, but there shouldnt be this much hate on this response. Game and chat servers need to run many asynchronous requests. Node and go are designed for this use case, ruby is not. Take a look at using http://phaser.io/ -- a 2d web game framework, with a TON of community support (way more than any ruby game framework you will ever find).
I've been looking into Trailblazer and Hanami ideas to refactor a monolithic Rails app I work on (80k+ LOC). The ideas are definitely attractive and I opine Trailblazer to have good ones and is modular enough in order to cherry pick the ideas/gems you want to use. However, I wouldn't start a new app going full in with Trailblazer. I'd start with utilizing appropriate OOP design patterns before adopting architectural patterns. I do like the central idea of the Operation as domain logic and factory pattern. It eases testing and aligns test code with production code. That alone is very valuable for large apps.
thank you for saying what must be said
That's kind of what I've settled on as well. Trailblazer has some good ideas, but it also has pretty fixed ideas. It really doesn't do a lot you can't do yourself using PORO, and that ends up being lighter and more flexible. The only exception I'd make is that I think Trailblazer might be better for a novice developer or someone who has never moved out of the realm of realizing you can put code somewhere other than a model / view / controller. The structure it offers can be beneficial to get someone started on a better path. 
I for one would recommend you watch this [Sandi Metz](https://www.youtube.com/watch?v=URSWYvyc42M) video as many times as needed until it clicks. &amp;nbsp; She and Katrina Owen (youtube her as well) are great at explaining the who what where why on testing and refactoring.
aside from the fact that it's very hard to understand what your code does at a glance, there's nothing you're really doing that can't be done with simpler logic. i just can't see what practical use case this would ever have. sorry, i don't mean to sound like an asshole, but right now im working in a codebase of spaghetti/ravioli code so this kind of thing is a sore subject.
You longer have to mount the ActionCable server directory manually. Honestly it makes sense for it to have a default, but it's nice that I can set it where I wish as well. 
&gt;Through many years of working on large Rails codebases, I'd lost much of my enthusiasm for Rails. I attribute much of my re-found enthusiasm to trailblazer. This is really important to me. I am definitely seeking this. &gt;but the ideas behind trailblazer really resonate with me because I see them solving problems I've encountered. This is what is attracting me to TRB. Both the pitfalls you mention seem like they are surmountable. This is great info, thank you. 
as far as chelly picking operations, the gem skinny controllers allows you to do that
Yep. We're on the same page :-) I was just addressing the nitty gritty part of the question. This wasn't intended to be fodder for a "send considered to be evil" post!
I did also like that one, thanks for mentioning it.
I agree with checking out that Sandi Metz video on how to write strong unit tests. For anyone who doesn't have the time to watch all of it. TL;DW - only test the I/O of public methods. This allows you to refactor private methods to your (or your maintainers) heart's content without worrying about breaking meaningless tests. 
Thanks for the great response, I wasn't aware of the to_proc method. Do you mind if I use your response as an edit to the article? (with reference to you of course) In regards to it being a closure as you said it returns a proc which is a closure, the thing I got wrong was the fact that I'm storing the hash into a variable instead of the object itself, which might throw people off. I corrected it now thanks :)
I didn't downvote you, but I probably would have, and not because this is /r/ruby, but because your comment came off as dismissive. It probably wasn't intended but it came off this way because you didn't really go into any detail as to why these were better alternatives in your initial comment. Of course you partially addressed this with this followup, but in reality your response doesn't really answer OPs question which could also be a reason for downvoting. EDIT: Not saying you HAVE to answers OPs question, just speculating on why the hatebears came out.
What's even more toxic is that this is the most upvoted comment, although the statement contains precisely zero arguments :/
I really miss Ryan Bates, this guy is going on for ages about unrelated stuff.
Wow, it's funny! (actually, not).
In one company I use to work we had an ISO security accreditation and part of it was "no employee cannot leave his screen unlocked when leaning a desk" ...so as a gentle reminder we use to set Desktop Wallpaper to Justin Bieber to anyone who forget to do so as a prank reminder :) . Then one day dude didn't check his laptop and took it to important meeting with a client. Boy he was pissed. 
Continuous refactoring is good but that's not really a solution for problems like a bad directory structure.
Thanks for your comment :) 
Pedantry.
I actually *just* discovered this 2 minutes ago. I'm glad both rbenv and rvm respect .ruby-version. I guess it wasn't working for me before cause I hadn't set a global ruby yet.
RVM is a lot messier under the hood right? Does it still shim `cd`? rbenv feels a lot simpler, I really like the toolchain too. 
I don't have a personal vendetta, lol. It just turned me off. I didn't just give up on it before looking into it either, i looked into it a lot and though I appreciate the ideas of introducing more objects, i think the approach is overkill for my needs and likely most people's needs. A simple PORO was all i needed in most cases. If someone has an absolutely enormous, complicated app with many many programmers making commits I guess a more regimented, featureful "framework" like trb could be useful, it just hasn't been necessary for any of the reasonably large apps i've worked on. So for me, it's not a match. :)
personally, I don't like prefixing all my commands with `bundle exec`, even if most people alias it to `be`. I've never had problems with rvm. Do you remember anything specific? I'll have to check out chruby!
If you've never had a problem with it, no reason not to keep on using it! 
well, my new work uses rbenv (which I'd never used before yesterday), so I'm just exploring options for my personal dev machines :-)
I just listened to the whole podcast and while it has very little to do with ruby, it was fairly interesting.
The solution for `bundle exec` is to use bin stubs instead. In combination this should resolve any need to have for gemsets, outside of perhaps initializing a brand new rails app if you switch versions often. 
Largely it's because RVM has caused a lot of hard to diagnose problems over the years. For example RVM actually replaces `cd` with a shim to do it's work. Replacing such critical functionality is considered a pretty bad idea by many. On your setup, you really shouldn't need gemsets with bundler + bin stubs and the rehash gem is deprecated and has been for over 3 years, it's built into rbenv now. 
&gt; with rbenv you just kind of set it and forget it. that's been my history with rvm. :-\ idk, maybe i'm not as much of a power user as I thought. haha
yeah, I hear ya there. It actually came up cause I built a visual studio team services agent for running tests and set it up with rvm, and the manager of our CI environment was all like rvm? ynorbenv?
rbenv clarifications: 1) You don't need gemsets, use Bundler and it will handle this for you. 2) Rehashing after a gem install is a thing of the past, you don't need to do this.
I don't get this... how is it any different from Ruby Weekly? Or is this a very old version of Ruby Weekly?
Apparently is not (?) https://ruby.libhunt.com/newsletter/archive
As others have pointed out, Spacemacs offers an intuitive way to avoid what you're currently doing. `SPC p f` allows you to fuzzy search all files in the project and open them up in your current emacs session. Additionally, you can even split up the windows with `SPC w {/ or -}`. Then you can work on multiple files :D There's obviously way more to it, however anything sublime can do spacemacs can do just as well (and in many cases better).
RVM raised like $50,000 on a kickstarter campaign for v2.0 and failed to deliver.
It does. Put this in your `~/.inputrc`: "\e\e[D": backward-word "\e\e[C": forward-word
hahahahhahahha that's exactly the same you can achieve by doing what's mentioned in this tutorial... and by definition, that's not "out of the box"
I prefer to have my configuration in code and my home-directory in version-control, if you fancy dicking around in iTerm2 menus every time you re-install, be my guest.
Good to know, but it doesn't seem that easy to automate, so I prefer the inputrc solution :-)
http://rubyheroes.com/heroes is a good start.
thanks!
Avdi Grimm, and he's producing the superb [RubyTapas](http://rubytapas.com/) screencasts.
ME
Thank you!
Yeah, here is the original campaign: https://www.bountysource.com/teams/rvm/fundraiser They haven't released 2.0 yet :\ I recall the author gave an update after being called out on twitter and said he had been working on comprehensive tests for all the bash scripts or something like that. I will say that rvm's issues getting 2.0 out the door really highlights the long term risk of using an elaborate tool with that was over-engineered for developer "ergonomics." The maintenance of rvm proved a nightmare, and in the meantime several good alternatives cropped up with a lot less baggage. I gazed through rvm's source a long time ago and decided it wasn't worth depending on a tool with so much obvious "tech debt." I'd recommend switching to chruby/ruby-install because they are reasonably well maintained and much simpler.
OK, I didn't actually know that.
I honestly don't think there's any reason to use rbenv instead of chruby. Chruby is what rbenv was trying to do (simple, non-intrusive, just do what you need to switch ruby versions, the end), but gets it right with a lot simpler code. There are reasons to use rvm over rbenv/chruby -- rvm does a lot lot more. That many people don't want, and would rather have the simpler solution. But I'm not sure why people are still using rbenv instead of chruby! They do pretty much the same thing, chruby just does it better. 
Honestly, I find the straight Rails 4+ Arel query/SQL-writing API pretty good. And has gotten even better recently with support for `or` and `not`. Curious what reasons people prefer an extra layer of API like this. Of course, for those not locked into ActiveRecord, Sequel provides API very similar to Squeel too. 
When I see: module SomeModule def self.included(base) base.extend(ClassMethods) end I know you're using modules wrong. This is a collaborating class, make it a real class instead. &gt; Why can't we define explicitly which methods we would like to use from a mixing? If you have this problem your code is poorly factored. If you start using this you should find one of two things: * The same methods get included in together * There are methods that get included only once, ever In the first scenario, extract these methods into their own module or make a new collaborating class. In the second scenario, put those methods together. If you're tempted to use ClassMethods, stop. Make a new Class for these, create one instance, and assign it to a constant.
This feels like Microsoft Linq.
I wouldn't recommend using completely new gems that you're not familiar with for a customer project. First evaluate them in a personal project and see if you feel comfortable with them. TRB is quite mature but dry-rb libs are still unstable, if you decide to use them you're effectively becoming a member of the community who should be ready to help, and have time and energy to explore things that are not documented, report issues, talk to core devs etc. If that's not your thing and you're not interested in supporting these projects, then I would recommend picking up stuff that you know well already. An alternative approach would be to try them out in an isolated part of your application, where you could just see how things work for you. There's a possibility it'll be just wonderful and you'll be able to use it everywhere. It really depends on the use cases you have. There are cases where people tell me they just migrated awfully complex validation code based on AM::V, to just few lines of dry-validation rules, and there are also people who are just completely stuck not being able to implement what they need. So, as always - it just depends on what you need. If you're worried about typical Rails pitfalls, then I would recommend ditching AR and at least using Sequel. If you're into a completely different approach to persistence, check out [rom-rb](http://rom-rb.org).
That was never an intention or a discussion that was held.
Surprised no one's mentioned Russ Olsen yet. I still refer back to both his books - Eloquent Ruby and Design Patterns in Ruby. Totally worth it on amazon.
It can prevent a minor class of errors WRT typos, but not many given how column definitions in Arel work. I haven't looked at how it's specifically implemented, but it likely also provides more rich type information for coercion of values which can prevent major security issues if you're using MySQL.
Thanks again, modified the post accordingly :)
Piotr, I am going to do the second option, most likely. I am having a little trouble getting my head wrapped around some of the FP aspects of Dry-validation and others. What I usually find is that after I play with it for a while, it is glaringly obvious and no big deal. Fortunately/unfortunately, we are taking on a considerable bit of new functionality, so I don't always have as much time to focus on specific things and spend the time helping the community the way I would like, so that is one of the reasons I agree with your assessment of option 1.
The `INCLUDED` part doesn't seem desirable. Why not just follow the same pattern that ruby uses? module SomeModule def self.module_included(cls) cls.class_exec do # blah end end end
&gt; My modules often define class methods. A common use case is factory methods. Granted, I define specific mixins for each class method, but still, the pattern isn't wrong (as you seem to suggest). Yes it is. Ruby provides `extend` for modules which define class methods, which you can use directly on the module in question without needing to `include` a separate module. If your mixin contains only class methods then there is absolutely no reason to use this (anti-)pattern. If it contains both then it is doing more than one thing and should be separated into multiple modules which are `include`d or `extend`ed as needed.
Yes, my though exactly, but for me it's a good thing!
It's a bit difficult to provide a source that no discussion was held :P. But it *was* an intention of the author (from [#412](https://github.com/activerecord-hackery/squeel/issues/412)): &gt; Back when I built Squeel, the intent (as had been indicated by a core team member) was to roll a popular query gem into Rails core. However, this doesn't mean that it was ever officially discussed.
I see, thanks for the link. Seems pretty daunting to author a gem with the goal of it for it to be a part of Rails.
&gt; This is a collaborating class, make it a real class instead. &gt; If you're tempted to use ClassMethods, stop. Make a new Class for these, create one instance, and assign it to a constant. Why, what happens if you don't?
Rubymine. I used to use vim but then I found a plugin for Rubymine that adds vim keybindings. At that point, why use vim? You need to install a bazillion plugins to emulate the power of Rubymine, and it's a hassle to deal with the compatibility issues between plugins. My favourite features of Rubymine: * jump to method definition * find method usages (finds DYNAMIC ones too!!!) * search entire project The one gripe I have is that the vim plugin was a little lackluster (had some trouble with macros and exiting/entering different modes) so I stopped using it. I'm going to install it tomorrow again so hopefully it's better :)
A factory creating or setting up a thing that has instance methods sounds an awful lot like a class to me.
[removed]
Hi, you can use that kind of functions for "agile" logic implementation. Lambda and Proc are an instruments for your convenience. So, if you don't want to write named function for just one line, use it. def bake(&amp;block) &amp;block.call #do something else end cake = Proc.new { puts "use flouwer and butter" } bread = Proc.new { puts "add eggs!" } bake(&amp;cake) bake(&amp;bread)
Yes, for me it would be too. But it would be an awesome addition, as it provides a lot more flexibility than the regular query interface, and is more readable than using query strings because you can inline the variables.
I'm still interested in revamping the query builder eventually for sure.
I would ask for a refund on your education. What kind of instruction is that? You would learn better on your own by the sound of it
Factory _method_.
Just yesterday I wrote a module that defines some instance methods and a few class methods. It was great. The module is intended to implement the actor computational model. The instance methods are tooling to support handling messages. The module also places a few methods on the _class_ of the actor; namely, a factory method (`.build`), another convenience method to fork a thread and run the actor inside it (`.start`), and a class macro, `handle`, that adds a convenient means of defining handler methods. The code is here: https://github.com/ntl/actor/blob/master/lib/actor/actor.rb The single responsibility principle is _not_ about code artifacts like `module`, `extend`, `include` or even `class` -- it's about the relationship between code and _concepts_. There is no way I could have adhered to the constraints you are implying and come out with something as usable as what I've got -- the _concept_ would be lost. It's also important to note that the user of my module can simply introduce a collaborating object if they think their class that includes `Actor` is doing to much! Critical thinking and analysis serves programmers much better than turning rules of thumb into hard-lined axioms.
Thanks for the reply.
The example I like to use is a class that sorts things. class Sorter def initialize(data) @data = data end def sort @data.sort end end So, you call: mydata = &lt;whatever&gt; myDataSorter = Sorter.new(mydata) sortedData = myDataSorter.sort What if you wanted to be able to sort different data in different ways? You'd need separate implementations of separate classes. Or you can use a lambda: class Sorter def initialize(data, sort) @data = data @sorter = sort end def sort @sorter.call(@data) end end So now you use Sorter like this: myData = &lt;whatever&gt; mySort = lambda { |data| amazingSortMethod(data) } sorter = Sorter.new(myData, mySort) sortedData = sorter.sort Now I can sort whatever data I have with a sorting method I choose that is most applicable to the data I need to sort. Could be useful for collections of objects that don't have `&lt;=&gt;` defined for them for example. It is a contrived example, but it illustrates the power of injecting functionality via a proc or lambda. You could add a setter method for the sort method and change the behavior of the class instance without reinstantiating it. &gt; In my 4 years of Ruby programming I didn't feel the need of using them That isn't surprising. In my 15 years, I wouldn't say I ever needed them. Every now and then they have come in handy and made something that might have been a little complicated a little bit simpler. They are an adjustable wrench in a sense. You can use statically sized wrenches to turn your screws, or you can pull out the dynamically sizable one to do it.
I was reading your original comment as saying that you'd need gemsets to initialize a brand new rails app if you switch versions often, so I was thinking that you'd be starting older projects with older versions of rails. Which probably is a bad idea and in hindsight also not what you meant, but possible without gemsets or bundler. Once you've several projects with different versions of rails you still don't need gemsets, because of bundler.
Yeah, Linq is a nice syntax for sure. It's just funny to sort of see the evolution of languages toward like a masterrace of the best parts of everything.
See also: https://github.com/tenderlove/widen
Cool. That's a very neat implementation!
Personally, because I looked at the code.
SANDI FRIGGIN METZ! - ["All the little things"](https://www.youtube.com/watch?v=8bZh5LMaSmE) - ["Nothing is Something"](https://www.youtube.com/watch?v=OMPfEXIlTVE) - ["Magic Tricks of Testing"](https://www.youtube.com/watch?v=URSWYvyc42M)
I see, thanks for the [raptor warning](http://xkcd.com/292/)!
[Image](http://imgs.xkcd.com/comics/goto.png) [Mobile](https://m.xkcd.com/292/) **Title:** goto **Title-text:** Neal Stephenson thinks it's cute to name his labels 'dengo' [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/292#Explanation) **Stats:** This comic has been referenced 128 times, representing 0.1012% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d7o2ksr)
Good writeup. For me, in my formative programming years, inheritance was very attractive. As I matured and started realizing that code changes frequently and that trying to pull things out of or reorganizing an inheritance structure was painful, I moved more and more towards composition. Now, I can't think of any place were I would want to use inheritance, though I do (sparingly) use modules as mixins.
I would look into existing servers and learn from their architecture, or simply use them. A lot of considerations relate to how many concurrent connections you expect to have. Good examples include [Puma](https://github.com/puma/puma) (good architecture written in Ruby) and [Iodine](https://github.com/boazsegev/iodine) (good architecture and native websockets, implemented in C and serving Ruby applications)\*. \*Benchmark and test servers before adopting them. Results might surprise you. I would consider running each game world in a separate server port and process, allowing multi-cores to be utilized without promoting memory sharing among cores (memory sharing across cores insures a lot or overhead for memory read and write). If you don't have multi-cores, than the only reason to use multi processes would be Ruby MRI's tendency for a global lock. But in reality, when the server is implemented in C, a global lock isn't as terrible (though I would suggest using multiple processes / workers). A server implemented in C could potentially use more of the system's resources concurrently before re-entering the global lock in Ruby land. Another issue is the socket polling system. Ruby uses `select` which is mostly limited to `fd` numbers up to 1024 (not including). This limits your application to less than 1024 connections (subtract database connection, any open files, and stdio)... it isn't as much as you might want. some gems such as [`nio4r`](https://github.com/celluloid/nio4r), [`iodine`](https://github.com/boazsegev/iodine) or EventMachine might provide a better polling system (watch out, some of them use `select` unless instructed differently). Again, this all depends on the number of players you expect. Ruby is faster than people give it credit for and can be easily used for gaming and other high performance servers, but it still isn't as fast as some other alternatives (i.e. Crystal or C)... ...however, a lot of Ruby's "slowness" is actually developers misusing the language rather than Ruby being slow. For example, many developers find themselves, inadvertently, making a lot of String, Hash and Array copies, which is a big performance issue. It's important to remember to change things in-place, using the `!` methods when possible and avoid intermediary objects when possible. Good Luck! EDIT - P.S. Frameworks often charge a price. Use Rack when possible or find small frameworks such as [`rack-app`](https://github.com/rack-app/rack-app) or [`plezi`](https://github.com/boazsegev/plezi) that provide better response times. You can see a good benchmark on [`rack-app's page`](https://github.com/rack-app/rack-app) and decide what framework to use considering feature vs. speed. 
Ouch. Sounds like you're annoyed by the "super learner" title thrown around by the host. The podcast contains useful info. The host-implied hype is the host's personal opinion and style and not a reflection of the guest. I caught myself fast forwarding through the host's parts as I felt them to be cringeworthy. 
I am using trb cells on a couple of rails projects and it's been a big win in terms of speed, drying, caching and maintainability. For difficult crud logic the forms addon might be usefull, i dropped it in favour of simpler creates and edit's(also simpler Models and validations) and let the Controllers(i tend to have more of those e.g with public, private, admin scope) handle the if's in valid/save/redirect /flash. Two or three of those methods e.g. User/Organisation/membership creates are a bit bigger, but i'd rather have such important code in one location, which could also be reform, a fat model or poro. Besides one can simply pick the modules from dry, trb which fit ones needs, so you can give it a shot without big pains. Of course no one stops u from inventing your own super poro magic lib like proposed elsewhere.
Well, you specify the association you're talking about when you're querying. Take this example: Post.joins(author: :posts).where.has { author.posts.id &gt; 0 } SELECT "posts".* FROM "posts" INNER JOIN "authors" ON "authors"."id" = "posts"."author_id" INNER JOIN "posts" "posts_authors" ON "posts_authors"."author_id" = "authors"."id" WHERE ("posts_authors"."id" &gt; 0) 
&gt; What do you mean by this? There is only one way to use the module. Include it in a class! I mean this: https://github.com/ntl/actor/blob/master/lib/actor/actor.rb#L2-L10. This is your code to support a special case of including the module in a particular scope, which gives the lie to your claim that there is only one way to use the module. &gt; If you include a module, both the instances and the class might be affected by such an act. It's up to you, the user of the module, to learn what it does. If you use this anti-pattern, that is indeed true. And part of the problem.
Oh goodness, holy incomplete code review, Batman! You can blame ruby's `include` for that "dual purpose." Include can bring a constant into focus. So if you have a library that defines `Foo::Bar::Baz`, you can make `Baz` accessible to the top level namespace with `include Foo::Bar` -- but doing so also mixes `Baz` into `Object`. That has nothing to do with this discussion and I think you made the mistake of looking for problems to help state your case instead of thinking critically. &gt; If you use this anti-pattern, that is indeed true. And part of the problem. I don't understand what the alternative is. To force users to include and extend separate modules that are related? An important factor that goes into designing a module is to maximize the usability of the thing including it. I think you're ignoring that factor. And you're being dismissive and condescending to boot.
Thank you! That's due to years of polish and engineering effort. Most gems don't have the benefit of such time and attention.
How did I demean or insult you? Is it possible to criticize your code, which *you* presented in support of your argument, without you taking it as a personal affront?
Hmm. I probably would need to play with it more to see what you mean, but in that example I believe the analagous thing would work fine in AR, no? I haven't actually tested this cause I'm too lazy to set up all the data, but: Post.joins(author: :posts).where("author.posts.id &gt; 0") Will that not work in AR?
Sure, but it is also possible to criticize code without being demeaning. "... it is already a mishmash of poorly organized concepts" &lt;-- that crosses a line. Constructive criticism is always welcome, but that is not constructive. I try to signal that I'm _always_ open to constructive criticism for any code I write. Code review that consists of an initial scan for something objectionable -- i.e. a "gotcha!" -- is not something I am as interested in. There's little doubt you are passionate about writing maintainable, legible code, which I think in general is pretty awesome. This is a pretty poor medium to explore whether or not "do not augment classes with modules you include" is an appropriate _general rule_. I don't think it is, but I have an open mind about it. Either way, we'd _have_ to look at actual code to really make an evaluation. That's the reason behind linking the code in the first place. Anyways, I suspect I'd have a lot more in common with your perspectives about code design than not, and I should have had a better showing than this. My apologies and cheers!
``` s.add_runtime_dependency 'activesupport' ``` Seriously?.. More ActiveSupport-ed ActiveSupport wrappers to the God Of ActiveSupport!
Awesome news! We've been using Sidekiq for half a year now and it's the most reliable Ruby part of the system. &gt; After a year of work on the Rails 5 support This surprises me a bit. I always thought of Sidekiq as a fairly decoupled piece of software: It has its own process and the workers look like plain Ruby. Loading the Rails environment seems to be the only place where Sidekiq interacts with Rails. Asking as a mere user: What made Rails 5 support so difficult?
Procs and lambdas are dope. You can do all sort of things with it. First think of procs and lambdas as anonymous functions, however, they have one benefit and that is being aware of the context it is run in (in certain special situations) Take a look at this real world example https://github.com/redcodefinal/pixel_lang/blob/master/lib/basic/07_conditional.rb#L9 and using the DIRECTIONS hash https://github.com/redcodefinal/pixel_lang/blob/master/lib/basic/07_conditional.rb#L98 This let me define a logic structure without having to make a nasty looking if then else or case when block, greatly simplifying the code structure but also, allowing that logic to be saved and accessed without having to be rewritten. If, for whatever reason, I need something act the same way, I can always access the logic via the Conditional::DIRECTIONS hash. You can also do some interesting context switching via Object#instance_exec. For example take a look at this block here https://github.com/redcodefinal/opticon_scanner/blob/master/refurbs/defaults.rb This defines a set of methods to run on an object, these methods will be referenced in the context of the runner (the object running the block via instance exec). https://github.com/redcodefinal/opticon_scanner/blob/master/lib/opticon_refurbisher.rb#L38 https://github.com/redcodefinal/opticon_scanner/blob/master/lib/opticon.rb#L182 Why would you want to do this? Well, this lets you do two RADICALLY different things with the same information. https://github.com/redcodefinal/opticon_scanner/blob/master/lib/opticon_barcode.rb#L40 Both OpticonBarcode and OpticonRefubisher access the same block, but because of instance_exec the context has changed between the two, so the run method acts differently when run by the two separate classes. (One sends the instructions directly to a scanner and the other makes a sheet of barcodes to be printed using that same block) Procs and lambdas are very very very cool and useful. More about instance_exec here -&gt; http://apidock.com/ruby/Object/instance_exec
the built in string transforms are pretty good. there is an issue to convert the whole thing to native extensions, though
I use lambdas over procs when defining because the stabby lambda reads better than Proc.new. 
Very cool! I use this pattern a lot (I like writing esoteric languages) so I use ruby's ability to class out logic appropriately. https://github.com/redcodefinal/pixel_lang/tree/master/lib/basic 
If you like LLVM check out Crystal. It's dope.
&gt; Rails 5 introduced the Interlock API, which provides thread-safe reloading. Nice! One more reason to upgrade soon. We make heavy use of threads in order to run some HTTP requests concurrently. At the moment we can choose between setting `eager_load` to `true` in development or refreshing the page a few times after starting a Rails server in order to not get undefined constant errors... Thanks for the details/PRs, they're super interesting! I need to stop reading and get some sleep, though... 
Two reasons: 1. I don't want to prohibit the integration of the mixin with a class that belongs to another inheritance hierarchy. For instance, some other library that might use inheritance to separate support for celluloid, event machine, and actor. 2. Subclassing is often useful for a _set_ of classes that can be substituted for one another -- for instance, a "postgres adapter" and a "mysql adapter" might share the same interface in a given context, and allow users to write code against that common abstract type -- the "base." There is no such design constraint in play here. Two classes that inherit from `Actor` are going to have wildly divergent interfaces and thus _not_ be substitutable for one another. The reasons are related; if I'm defining an abstract type, subclassing makes sense. The first consideration is invalid because the subclasses _serve_ the abstract type. If I'm wanting to _augment_ a class, modules make more sense, since users of the module do not share some common abstract type with one another. Sure, they are all Actors, but they are unlikely to be useful as substitutes of one another.
No, it would not. It would generate the following SQL, which would be incorrect: WHERE (author.posts.id &gt; 0) 
Ok, I re-read that section in Design Patterns. The factory method pattern literally describes a class that has a method that sets up other objects not related by inheritance. http://imgur.com/YAjfutF I read the full section on the factory method pattern and see that the examples show a factory method belongs to a separate class that is not associated through inheritance with the objects it is creating. If you need a factory to create an object with state so a module you've included in that object's class will operate properly you have smashed two objects into one. And that's not the factory method pattern.
&gt; If you need a factory to create an object with state so a module you've included in that object's class will operate properly you have smashed two objects into one. That isn't the case for any module I've written. The class method constructs an instance of the object, _and_ it supplies configuration that would otherwise be supplied explicitly. Again, it's about usability! There is no case of an instance depending on a class interface. "Smashing two objects into one" is language that better characterizes a beginner's reluctance to introduce design elements and abstractions. That's not really where I'm coming from.
Seriously this. We never have sidekiq issues and it's run, uh.... (checks metrics) holy shit probably 3 billion jobs. Awesome. 
Thank you, I wish I heard this more! People rarely contact me except for problems, as you'd expect.
Didn't even catch that! Thanks. Still doesn't fix the torch thing but I appreciate any and all help!
That would work for me locally, but gemspecs can't contain references to Git repos.
&gt; String/Symbol#upcase/downcase/swapcase/capitalize(!) now handle Unicode case mappings instead of only ASCII case mappings. Hell yeah! 
There are many issues with this code: * You shouldn't need the `$stdin`; you can just do `gets.chomp` * `torch.downcase` doesn't change the `torch` variable; you need to do either `torch.downcase!` or `torch = torch.downcase` if you want to re-set its value. * You could also just do ``` torch = gets.chomp.downcase ``` * `if torch != "y" || "n"` is not what you want. This will always be true because "n" is truthy. Pretty sure you meant `if torch != "y" &amp;&amp; torch != "n"` * You need to use `==`, not `=` to compare variables, as /u/hoomei mentioned * There's no loop anywhere in your code... Example of how to use a loop to ensure you get either "y" or "n": while torch != "y" &amp;&amp; torch != "n" puts "Try again!" puts "&gt;&gt;" torch = $stdin.gets.chomp end I'd recommend using a debugger like [pry](https://www.sitepoint.com/rubyists-time-pry-irb/) to set breakpoints and run through your code line-by-line to help find where things are going wrong.
Uhm, nope :)
Ok, for not pissing everybody here, when I will write ruby, I will not host it to GitHub. ;)
Sorry for my bold sarcasm (it was late at night, and I was angry with things unrelated to Reddit). What I wanted to say is: * you see a gem, which, apparently "does one thing, and does it well" (good README, badges, code coverage, test coverage and stuff) * you install it to use in small project, because it looks suitable for your needs (quick case transformations with readable names, localized into independent module) * ...and suddenly it tugs in entire ActiveSupport Behemoth, includes several of its core_ext's and delegates all the real work to ActiveSupport. In this case, I'll better opt NOT to depend on an additional layer of third-party libraries, just use AS directly. PS: ActiveSupport is not "built-in" into Ruby, you know.
it's all good. the goal of this is to incrementally improve performance on artive model serializers which suffers hard during key transforms. my step next is doing the case transform logic in c so AMS can be faster (i have a plan fol extlaacting a few parts of AMS into native extensions) :-)
Go use [Mocha](http://gofreerange.com/mocha/docs/) `Subscriptions::Manage.any_instance.expects(:setup).returns(true)` With ruby you need complicated DI
&gt; I can figure it out because I have years of experience and am used to untangling indirection, but I don't want to. How will new programmers that don't have the experience to hold all that in their heads figure out the relationships? Here is the crux: If I open up a class and see this: class SomeClass include ActsAsTaggable include SpiffyList include MyMixin include ActsAsWidgetOnSteroids include Liquifiable include RubeGoldberg # implementation end Then I've got a huge problem. If you're trying to find any particular method, the indirection is going to be awful. And there's not enough time in the universe to audit all those modules (and all the modules included by those modules). That said, there is an important technique for rubyists to know: puts SomeClass.method(:build_a_thing).source_location But anyways, back to my point. If I see this: class SomeClass include MyMixin # implementation end Then I know that I need to understand what `MyMixin` does in order to fully understand how to use the class. This is not any different than if I subclassed. A lot of rubyists (including myself!) have some PTSD from dealing with code where modules were overrused to the point of being crippling to productivity. I'm _only_ suggesting, as far as I'm aware, that placing arbitrary limits on what modules can or can't do isn't a suitable general solution to the problems that many codebases face with modules. &gt; Instead, replace module with a class, rename the factory method method to "new" and call it from SomeClass' initialize, or other appropriate spot. This is not something I can fully visualize how to take action on. Would it work like this, i.e. composition? class SomeClass attr_reader :my_mixin def initialize @my_mixin = Actor::Mixin.new end end
So instead of a minimal amount of complexity of passing in an _optional_ argument, you introduce a massive amount of complexity behind the scenes to change the behavior of your constellation of objects? I don't think you can even call that _testing_ if you have a mock framework altering the behavior of the test subject to that extreme. The "complexity" required to alter an objects design to make it testable is always an order of magnitude less than the complexity needed to manipulate an untestable object to expose it to testing.
Everyone's gonna say Sandi Metz. They're right. Also read schneem's blog! 
This article is not a compelling argument for DI, unless DI just means "try to write pure functions when you can." The Ruby Way of passing private data to an instance of a class during initialization has no disadvantages compared to this method, and many advantages. But maybe I just don't get it. The first paragraph admits DI is poorly received but doesn't explore why that is; I'd love to hear it in OPs words. Edit: the initial example that is "fixed" in the article is just horrible... tight coupling to a global. Folks writing code like that should not be fixing it with "DI", they should be learning the basics of OO in Ruby. Then, maybe, there could be room for further improvement, once the limits of those best practices are reached. 
&gt; I'm having a hard time setting a loop and a value check to see if you've taken it or not. This is a piece of 'state' that you need to encapsulate. I would create a player class: def Player def initialize @has_torch = false end take_torch @has_torch = true end drop_torch @has_torch = false end has_torch? @has_torch end end Now you don't need to worry about writing this in a logically branching script, you can just reference the player object, check if the player has a torch and display different results for each room based on that. So this: if door = "blue" &amp;&amp; torch == "y" becomes: player = Player.new ... if door == 'blue &amp;&amp; player.has_torch? It doens' tmake a huge difference now, but you can add all sorts of properties to the player, like has_key?, and the player could have a number of keys, which he/she needs because some doors are locked. The way this is designed you'd have to start keep track of all sorts of state that could very quickly become completely unreasonable when you are designing it as just a series of if/else branches checking a global state. This opens up a whole new world of object modeling your game flow that would vastly improve it's reusability. Also, a lot of those tips on debugging in the assignment I would consider to be outright lies. I use the RubyMine IDE for it's interactive debugging professionally every day. Debug by print statements is not good, IMO.
I suppose you could just tell everyone in the README that they need to add a git repo `gem` in their `Gemfile`. Or provide a generator that does it. Or just release it with a new name. Or get the previous maintainer to do a release, or to just give you ownership. (rubygems ownership is the important thing, you can move the github repo if you want)
In the given example, the answer is to fully compare the hash ids for each entry in the array. So the real process is: * Calculate a hash on X * Look up the data array for the last two digits (in this case, 21) * Traverse that array and return the item with the same id For that last step to work each entry in the array would actually be something like `[id, value]`. So in your example `students[21] = [ [4221, 'Belle'], [3221, 'Sofia'] ]`. The actual implementation inside Ruby is probably similar, except that it's using data structures that would be much more efficient for the task.
Collision is inevitable. u/awj explained the concept that I was confused about. We have to store both the id and the name, not just the name. Thanks!
Why not just store them in an actual Hash? Is this less efficient? students = { 4221: 'Belle', 3221: 'Sofia', } Edit: Nevermind, I guess the article is explaining this point
You would want to use the fat comma (or hash rocket, if you prefer) operator (`=&gt;`) there. Only use a colon in hash assignments if the left-hand side is a bare-word symbol, or a string that can be symbolized. $ irb irb(main):001:0&gt; {a:1, b:2} =&gt; {:a=&gt;1, :b=&gt;2} irb(main):002:0&gt; {'a':1, 'b':2} =&gt; {:a=&gt;1, :b=&gt;2} irb(main):003:0&gt; {1:'a', 2:'b'} SyntaxError: (irb):3: syntax error, unexpected ':', expecting =&gt; {1:'a', 2:'b'} ^ (irb):3: syntax error, unexpected ',', expecting end-of-input {1:'a', 2:'b'} ^ from /Users/mwp/.rbenv/versions/2.3.1/bin/irb:11:in `&lt;main&gt;' irb(main):004:0&gt; {1=&gt;'a', 2=&gt;'b'} =&gt; {1=&gt;"a", 2=&gt;"b"}
Yes, I was just curious about the actual implementation :)
hi thank you for your thoughts. I agree select is probably more than adequate for my practical purposes. I don't think requiring packets to be serial is right for my specific game, but I agree with your general notion of - why am I overlooking a simple/more effective solution. Part of this is a fun experiment to try some new things. I think the take away is - I will just do a simple tcp handling code and work on game logic, and then play around with the socket handling later.
Thanks for writing this, it's great to get an architectural overview, both in case I want to use shrine, and just to see examples of well thought out architecture, and architectural compare/contrast between the various alternatives, it's good to see various ways to do ruby. There are a few passages that I can't figure out what they mean though, and they're talking about something I'm interested in, but I'm just left scratching my head. &gt; Paperclip introduces further coupling by requiring the storage to know about Paperclipâ€™s interpolations. Shrine always generates the location beforehand, and the storage just receives the direct path to where it should upload the given file. I'm not following. I guess this means that every shrine upload via a given uploader are all together in one giant flat directory, do I understand that right? I guess it's a trade-off, simplicity for giving up the paperclip-like ability to dynamically calculate path based on attributes of the model involved? Or am I completely misunderstanding what you're talking about? &gt; This object is defined solely by its data hash. Since the storage can be referenced by its registered name, this hash can now be serialized into JSON, and saved to a database column. Don't understand what this means. Is "data hash" the same thing as "registered name"? And are these both the same thing as the `id` key in the hash shown? If it's a "registered" name, registered where? -- Anyhow, looking forward to the next installment!
Thank you, I'm glad you find it interesting :) &gt; I'm not following. I guess this means that every shrine upload via a given uploader are all together in one giant flat directory, do I understand that right? I guess it's a trade-off, simplicity for giving up the paperclip-like ability to dynamically calculate path based on attributes of the model involved? Or am I completely misunderstanding what you're talking about? I guess I could have been more specific here. Shrine does allow you to have nested directory (if the storage supports it). What I mean is that a Paperclip storage will get instructions: "Ok, upload this file to location `:class/:id/:basename.:extension` ", while a *Shrine* storage will get instructions to upload the file to `/image/45/nature.jpg`. Notice the difference, how the Paperclip storage needs to first apply interpolations to the given path before it can upload, while the Shrine storage receives a complete path already generated by Shrine. &gt; Don't understand what this means. Is "data hash" the same thing as "registered name"? And are these both the same thing as the id key in the hash shown? If it's a "registered" name, registered where? A Shrine "data hash" is a hash consisting of `id`, `storage` and `metadata` fields. The `id` is the location of the file, `storage` is the "registered name" of the storage that the file is uploaded to, and `metadata` is a hash of custom metadata extracted before upload. A `Shrine::UploadedFile` is a value object wrapping this hash. &gt; Anyhow, looking forward to the next installment! Coming soon! :)
About the "registered name", every storage needs to first be registered to be used through the uploader. In the below case, a filesystem storage was registered under a name "disk". Shrine.storages[:disk] = Shrine::Storage::FileSystem.new(...)
Nice, I totally agree. As long as your code is modular, it will be easy to replace pieces that need optimizations later on. I would definitely get something working first and work on performance later. Iodine's first version (written in Ruby) gave ~20K req/sec once I was done with it... But, my first learning version was closer to 1K req/sec and my C version can do more than ~90K req/sec on the same machine. We all learn as we do. So would definitely agree - do first, remember to separate concerns so that it's easy to rewrite section by section and have fun (which is probably the most important thing and the reason we started coding in the first place). You'll learn tons and get a product at the same time :-)
[Collision](https://en.wikipedia.org/wiki/Hash_table#Collision_resolution) cannot be avoided. This is in the nature of the concept. You probably mean [separate chaining](https://en.wikipedia.org/wiki/Hash_table#Separate_chaining) can be avoided via [open addressing](https://en.wikipedia.org/wiki/Hash_table#Open_addressing), with one common method being [double hashing](https://en.wikipedia.org/wiki/Double_hashing).
I think the book said the $stdin was because it's running from terminal but I don't remember exactly. And I tried the while loop and it just kept looping even when y or n was selected so I'll have to maybe try fiddling with that some more. But thanks for the suggestions, I definitely have a few places to start now and that's exactly what I needed! 
I second iruby, I found it fantastic for manipulating datasets and exploring graphs. 
What particular features are you looking for? I'm assuming it offers more nifty features than a standard REPL. In general, when messing around in Ruby, I use the Pry REPL most often. It's got a bunch of bells and whistles that make life *much* easier.
Thanks! Yes, background processing is one of the things where Shrine really shines :)
Rubocop uses the `parser` gem: https://github.com/bbatsov/rubocop/blob/master/rubocop.gemspec#L30
Oh Wow. That's as close as it gets to jupyter, at it seems.] Thanks for the tip
I just started coding in ruby, and the furthest I could get was to write a simple CSV parsing and ETL script. It was way easier in ruby than It was in python (because I was able to specify encodings that I couldn't in python), but still, Python seems to be more mature when it comes to libraries (pandas,matplotlib dataviz etc). I will check this REPL (whatever it means hahah) and pry aswell. I'm a ruby ignorant :(
I used ruby_parser (in combination with method_source and ruby2ruby) to implement Haskell's do notation in Ruby. This worked: def my_monad Monad::Syntax::Do.using(Maybe) do x &lt;- Some(4) y &lt;- Some(x + 5) Some(x + y) end end I obviously never used it in production. :D
The mutant gem uses both of those. Unparser was written for it. If you are at all interested in testing I highly encourage you to check out mutant and mutation testing.
&gt;So, that is implement new syntax on top of Ruby? Yes, pretty much. You can't invent completely new syntax, though - Ruby has to parse the file first before you can do any transformations. In this case `&lt;-` is actually the less than operator and the unary minus. It's translated to `#bind` (aka `then` aka `&gt;&gt;=` in Haskell) calls which do different things depending on the Monad you use it on. In this case the code is translated to: Some(4).bind do |x| Some(x + 5).bind do |y| Some(x + y) end end Which gives you `Some(13)` if you implement `Maybe#bind` properly. [Here](https://github.com/timhabermaas/ruby_monad)'s the code without documentation, but a spec file which shows some of the syntax.
Ah, interesting! Thanks for the explanation.
&gt; Except for the case where perfect hashing is possible, or, Well, these will be specific cases only. Perfect hashing is not something that is part of the general concept of hash tables. &gt; arguably, when you decide to grow your hashmap until things fit. Then you still have a collision. Otherwise you would not know when to grow the hash table. The alternative - allocating a hash table with maximum size - is obviously not a good one. Plus, there are cases where growing the table does not remove collisions - namely those, where you have two values with identical hash values.
You can play around with select2: https://github.com/argerim/select2-rails . Check out this examples: https://select2.github.io/examples.html
In a hobby project I'm using ruby_parser and ruby2ruby as part of a system where code/processes are being edited/changed while the program is running, as part of a graphical/interactive code environment.
for what it's worth: https://github.com/NullVoxPopuli/case_transform/pull/2
Thanks for the explanation. What I like the most about IPython notebooks is the fact that it can act as a self documented process, you can run block by block even repeating the same block until it works and the fact that you can upload it to github and it will be fully rendered there. 
hi rubyists! i've always been scared of writing a c extension for some reason. i've written a java extension before but never had a hang up about it. anyway i finally bit the bullet and gave it a shot. not a super useful or amazing extension (you may not find any real motivation to use it) but i just wanted to celebrate getting past a programming fear i've had for awhile. for what it is worth: if you're scared of trying something in programming, go for it!! i'm rooting for you. :)
Cool! I will start digging it. I haven't even learnerd the basics of ruby yet. 
Sounds interesting. Is your hobby project accessible publicly? Would love to check it out.
neat!! you using helix? i thought maybe it was too uncooked to use yet, though i am very intrigued!
I'm also a happy user of sidekiq. Thank you for all your hard work mperham!
Wow, that's cool stuff!
I have, I should have added to the original post that I am experimenting with raxx because I think plug has some inherent issues
I've got 11 years commercial Ruby experience, and a ton more in other languages before that. I need somebody to motivate me sometimes as well. You know, just push me along a bit on my side projects. I spend all day writing code, it's hard to get motivated to get onto those other projects. I'll scratch your back if you scratch mine. I'm about to go on holiday abroad for a couple of weeks, but when I'm back I'll get in your face if you want. :-)
I'm not sure I even like the idea. Design your modules right so this isn't necessary, ruby's dynamicism is confusing enough when debugging legacy code without essentially making up new modules on the fly by subsetting existing modules. 
hah well! good luck and if/when you get it building comment here as ill want to look at how you did it!
I did the benchmarks now: http://nts.strzibny.name/comparing-wkhtmltopdf-to-prawn-for-generating-pdf-in-terms-of-speed-memory-and-usability/
There is a better example now! Hope it helps.
You should be using symbols instead of strings [here](https://github.com/Berky115/BlueBottle/blob/master/lib/bluebottle/status.rb).
Ok! I did not know ruby had these! reference: http://www.reactive.io/tips/2009/01/11/the-difference-between-ruby-symbols-and-strings From what I gather, ruby Symbols are immutable, and ideal for enums or const variables. "Java =int final" or javascripts "const". Is that fair to say?
&gt;&gt;I got all the tests to pass, and fulfilled the requirements of the app &gt;If you achieve that and get 0 response, there are issues with that company. I totally agree. You took the time to take the test and got it working? Shame on them for not responding. What is the name of the company?
Superficially yes, that is a comparison you could make. An important thing to note is that each instance of a symbol is shared throughout the runtime. So: "hello".object_id == "hello".object_id # =&gt; false :hello.object_id == :hello.object_id # =&gt; true This saves on memory and has some other uses. Note that you're already using symbols when you do attr_accessor :id, :first_name, :last_name, :email or @store[:customers]
oooh! Are you suggesting making it a part of the service itself? I.E setting a status through the service? How would that work if I'm creating a new subscription ex: subscription_service.create_subscription(sally, bella_donovan, ACTIVE) 
Have you tried making a longrunning wkhtmltopdf process?
Local company. Think late game startup that's doing pretty well. To their credit they did respond. They told me that they wanted someone more experienced as a developer. I then asked for feedback on the code I sent and never got it.
Ah, so it's like a static variable you can share around between objects. Neat! The attr_accessor bits where a bit of starter code, I had assumed it was a way of defining variables that later got set by initialize, which I treated like a constructor.
That would be great! And enjoy vacation!
Good to know. However as it looks like it's not that straightforward.
I will also add that I always look on code formatting and sometimes it's off-putting (tabs vs spaces, no space after { etc...). If someone mixes spaces and tabs perhaps he did not program much before... Nevertheless we once hired someone with much worse ("invented") formatting and the guy turned out just fine.
In my point of view all named things are only minor. It only says that you are not deeply familiar with ruby. But you did prove that you are able to do object oriented programming. I think this company is only looking for ruby programmers with a lot of experince. Maybe they used a tool to analyze your code and did take only a look at the score and not at the code itself.
Added a few comments, but its fine. Specs read funny - betterspecs.org will explain why 1 or 2 whitespace issues - rubocop can help but is likely overkill attr_accessor provides getters, you added some to some models and its not needed. 
What about an api that uses POST only to send some parameters in JSON? Otherwise it's basically just getting the data.
Couldn't you use the difference between now and the projected date/time to determine whether to use the long version or not? If the delta between now and the timestamp for the action is within the same day use the short one, otherwise use the long one.
Yeah, supporting parameters `POST`-ing is in the plan for next versions. If you know good example of API doing so, just show it to me, it will help :)
What do "pragmatic" and "opinionated" mean in this context?
I can confirm that the operation approach for structuring Rails applications does indeed work very well even for very large applications far beyond 100k SLOC. As for my choice of tools, I'm very biased. I am the author of [ComposableOperations](https://github.com/t6d/composable_operations) which enables one to easily define operations and processing pipelines. They are completely framework agnostic and I initially build them for data processing. However, they can easily be used to model complex business processes in Rails applications. In my talk [Large-scale Rails Applications](https://www.youtube.com/watch?v=80S6vYwz4DI) at RuLu 2014, I demonstrate how to use operations and operation pipelines in Rails applications. On an important side note, the project is currently being relaunched under the name [ActiveOperation](https://github.com/t6d/active_operation) with a stronger focus on Rails. The core idea of ComposableOperations to be framework agnostic will be retained. There are no plans to do any magic or deeply hook into Rails. ActiveOperation is ready to be used with the exception of processing pipelines â€“ a feature that will soon be added.
I prefer [Authority](https://github.com/nathanl/authority), it has a much nicer API IMO.
Ah, thanks for clarifying. I'm not sure I would choose this approach -- I'd be concerned about an HTTP interface to a _de-facto_ standard created by one programmers' opinions -- after all, that's how we get so many competing standards in the first place. On the other hand, the library looks pretty usable and could probably save some implementation cost on integrating with a third party service. I'll make a mental note to consider it next time I run into a GET-only api.
It sounds like you're describing a super-custom solution... Yet you'd like to use a pre-existing solution. That doesn't add up to me. The solution you describe also really doesn't seem that complicated to implement yourself -- you could just write something like: case time_until_event when (0 .. 1.day) # ... when (1.day .. 1.week) # ... when (1.week .. 1.month) # ... (If you'll excuse the rails syntax I've lazily thrown in!) Alternatively, why not simplify the problem even further and just supply a more generic, verbose message? Something like: &gt; "Event configured to run in **1 month, 2 days, 3 hours and 5 minutes**, at **19:25 on 21st October 2016**
Interesting task to think about! I see there are 2 (or 3) tasks, in fact: 1. say future date in most reasonable fashion, absolute time ("12:04 AM", "tomorrow at 9:17AM"); 2. say future date in most reasonable fashion, relative ("in 30 minutes"); 3. say it "in other words" (if user provides relative, like "in 5 minutes", program shows its understanding by saying "at 12:04AM"; if user provides semi-absolute, like "3 PM", program says "in 9 hours", again, showing its understanding). Am I right?.. If so, solving 1 &amp; 2 (one-by-one) could be a library (or two), but (3) is tricky and should be integrated deeply inside your software, it seems. Though, never seen library doing exactly this (OK, (2) looks mostly like ActiveSupport's [#distance_of_time_in_words](http://api.rubyonrails.org/classes/ActionView/Helpers/DateHelper.html#method-i-distance_of_time_in_words), though the letter is too fancy and inflexibile in the same time, if you ask me).
Sounds like SOAP... we've moved on. On the topic of moving on, we recently adopted graphql. Self describing and super easy to work with.
Submitted a PR to address some typo's I noticed in the README.md :) Nothing special, but, it was distracting to my brain, so I fixed it. :)
Yeah, that's the challenge - (1) can be done in a basic way easily, the challenge is making it always sound perfectly natural, regardless of the supplied time. I'd rather not re-invent the wheel on (1) if someone's already done it, even in a basic way. (2) is exactly what distance of time in words does - the problem though is that I'm trying to 'reverse' it. (3) is the dream - I'm hoping that I can fake it for this application using dotiw and (1).
I'm one to use an auto formatter and take whatever it defaults to. Is my formatting noticeably icky?
&gt; attr_reader Ah, a bit like "public vs private" variables ? https://www.codecademy.com/en/forum_questions/50f0192b102455349200372d Is it a ruby practice to assume things are "public" then?
Ah! So if they where looking at a straight analysis, my codes style choices would destroy it. Good to know, I should have thought about running an analytic. lib/bluebottle/data_store.rb: I don't remember much about my decision making process on this bit, it's likely I forgot to change things in this one when I went through a big old refactor. 
If I find objects calling each other back and forth a bunch I realize it's time to rethink how they are modeling the process. This part is hard. RubyConf USA is likely my last US conference for the year.
Rails has `time_ago_in_words`: http://api.rubyonrails.org/classes/ActionView/Helpers/DateHelper.html#method-i-time_ago_in_words You could add the active_support gem to your project, or there may be another gem which does the same thing.
Is this done using abstract interpretation?
I'm a Java guy, and I would say no, it is not at all the same and that post is not a good guide. The attr_* things are just like code generators. In Ruby, object fields are private.
The vast majority of things will still be applicable in 2.3, but it will be missing some info on a few of the newer features (like keyword arguments) and standard library additions.
I would also like to see python monk come back online!!!
The blog posts have been awesome, thanks for writing them! 
Never heard of her and she has nothing interesting on her github. EDIT: I also checked her github, there's basically no commits she's made on either bundler or rubygems. The interviewer also appears to know next to nothing about Ruby. So effectively this is just a conversation between two noobs. lul.
And for us `rbenv` folks, you might find your own disk usage "interesting". I've been making a regular effort to keep it down for a couple of years, but still... âžœ /tmp du -hsc $RBENV_ROOT/versions/* 319M /usr/local/rbenv/versions/1.9.3-p550 447M /usr/local/rbenv/versions/2.3.0 604M /usr/local/rbenv/versions/2.3.1 52M /usr/local/rbenv/versions/jruby-9.1.0.0 79M /usr/local/rbenv/versions/jruby-9.1.2.0 1.5G total âžœ /tmp When I first figured out how to do this, back when Ruby 2.0 was Teh Noo Hawtness, it had been up to ~11G because I was just trying out everything I could get my hands on back then. Live and learn.
My number one recommendation to anyone learning a language is to not focus on the language. Instead find a project or a task that interests you. Work towards building that project in the language of your choosing, and along the way you'll happen to get better at the language. Yes, you'll need guides and books, to get bootstrapped. But without any longterm goal, most people don't keep up with learning. Ruby is really really good for building CLIs and web apps. That book is an okay place to start for the language, but I would recommend something closer to what you're trying to build. If you want to build a web app Agile Web Development with Rails is great or there's the https://www.railstutorial.org/ which sells for Free 99. You'll pick up language quirks along the way. I have a VERY outdated course of my own if you're interested schneems.com/ut-rails/. Would stick to the videos, the exercises don't translate well. Also as a note 1.9.3 is kinda old. There's plenty of new features in current ruby 2.3.1. However as a beginner, I don't think 1.9.3 is a bad place to start.
Actuality amusing!
what's with the username? ;)
Yea PHP! PHP! .. i'll just spam here . 
This is hilarious!
Finally a proper, factual and honest comparison :D :D
Ask you'r self, do you use such tools with java? How long did you program with java on a daily basis before you used this tool with java? What's about other tools like code coverage? Does every good java programmer use these tools? When you under pressure, do you use these tools? I think the awnsers to this questions also apply to this test. 
examples?
It is a very simple example I will give you that. Does not making things more concise naturally make them more readable? 
&gt; but people coming from C languages will immediately understand the former, not the latter. But is that supposed to be the yardstick against which readability is measured?
If your (metaphorical your) basis for readability is the similarity of one language to another in its design then yes Python would be more readable. However, a lack of understanding of how a language works does not make it less readable.
 I will give you that but its at the end of a file so who cares ;)
Yup, I'd also like to know this. Any reason not to issue pull requests against the existing libs?
Yeah, I agree. The last line shifts the tone from pokey and humorous to slightly smug and self-righteous.
&gt; looks like garble Not garble, just a bit weirder. The thing that makes ruby harder to read isn't the syntax, it is the worry that too much business logic is hidden is some place I can't follow.
I'm of the opinion that once you know a language it reads very easily. So for someone who is familiar to both there probably is no difference. But consider the person who knows neither. I learned python 5 years prior to learning Ruby and, aside from list comprehensions, which are not trivial to understand at first, python was very easy to reason about. For Ruby that is mostly true as well, save for blocks. I had a tremendous time understanding blocks at first. I don't think the person who attempted to explain it to me did the best job, nevertheless with my prior programming experience (c, python, Java) that concept was completely foreign to me and was used quite ubiquitously in the code I was working with. Contrast that to many python programs that don't use list comprehensions, I had a drastically easier time picking up python than I did with Ruby. Of course it's possible that due to working with python so long it was more difficult for me to learn a new syntax than for someone who directly starts with Ruby. In my interviews I work with many people who are using Ruby for the first time and for the most part they have very little difficulty with the language along with my guidance. Overall I think they're very similar and people can get up to speed with either quite quickly if they've programmed before.
`10.times do something end` reads even more naturally to me (which is why I'd have used `do end`, but that might have been cheating). `range(10)` is gibberish to me, 10 is a number, I'm not sure how you can convert that into a range, `1..10` is a much more pseudocodish way to write that (but admittedly having `1...10` doesn't really help)
It's my boss who writes code like that, unfortunately I can't configure him. And he manages that no matter how you configure his IDE, he has magical powers that bypass sensible indenting rules (also sometimes he randomly adds 50 or so spaces at the end of a line).
It's a weird example to use, considering you can write the Python version virtually the same in Ruby: for n in Range.new(1, 10) { print(n) } If you want it to look more similar you can define a `range()` function: def range(n) { (1..n) } for n in range(10) { print(n) }
&gt; It is a very simple example I will give you that. Does not making things more concise naturally make them more readable? You my friend have clearly not spent a lot of time working with Perl, where concision and readability are often on opposite poles. I recently inherited a 14,000ish line Perl codebase, and wasn't able to make sense of the thing until I'd expanded it to 25,000ish lines.
You are right, I haven't spent time with Perl. 
Meanwhile, I am using my up and down arrows, just to read logic because of the lack of visual signal of encapsulation. Python being indent oriented is its worst trait. Edit: the second being magic underscores, eg: `__main__`, `__file__`, etc. Edit2: and yay, double underscore becomes bold in markdown, that's annoying. Every Python program starts with an extern call to an apparently private/unused method, and Smart Tabs are useless to insanely frustrating. You can't just code, you have to vigilantly manage your white space, and just give up entirely if the indentation goes awry. There is no way to know which code was indented under what, so you just have to start over.
I largely agree with your article. I rarely Ruby itself "magical". "Magic" is just stuff you don't understand. However, Rails does **a friggin lot** under the hood, and when I find a DSL that is too clever for its own good, I end up throwing the word "magical" around. 
Magic is a trade-off. You gain developer ergonomics and convenience in exchange for two things: increased contextual knowledge required to work with the project, and an increased likelihood that additional elaborations will resist composition and instead have to go _inside_ the magic interface. It's a significant tradeoff and problems arise if you get it wrong on both sides. You either in a sprawl of tedious, explicit boilerplate or a mess of brittle monkey patches, confusing bugs, and nightmarish nondeterminism.
Well, the initial comment I reacted to said "but people coming from C languages [..]", which I assume would be people familiar with `{}` as a grouping operator of statements, so sure using `{}` instead of `do end` makes it less pseudocodish, but then that wouldn't matter for someone coming from a C background. All in all "more readable" seems ill defined to me, it's highly dependent on context as evidenced by the fact that I started by reacting to someone who thinks code is readable if it's readable by someone from a C background while I'm now reacting to someone who thinks angle brackets are less "readable" than `do end` keywords. One thing that's probably an element in some people thinking that Python is more readable is that there is only one way to do it. You'll never have to wonder while reading code if there is a difference between `do something end` and `{ something}` and if so what it is.
Absolutely, when possible, use Forwardable to do simple delegation. Or, if you want to forward everything, Ruby's [SimpleDelegator](http://ruby-doc.org/stdlib-2.1.4/libdoc/delegate/rdoc/SimpleDelegator.html) can be useful. This approach is if you want to delegate *literally everything*, and in most cases, is completely ridiculous.
Hah. :)) Btw, but still, it's a cool write up man. And I did learn something about BasicObject, so yeah. Nice one.
I'm impressed by the perf numbers. How'd you get it as fast as hiredis while staying in native Ruby?
Who said anything about trading off clarity or readability for concision? Especially when we are talking about language design, it's possible to design ways to program both more concisely and more clearly. Given two versions of the same code with the same clarity I'll gladly take the more concise version, especially if it improves on communicating "what" vs. "how".
it's inconsistent, look at the indentation in many of the files. In many cases your `def` is indented to a different level than the associated `end`
Gotcha, looks sloppy. I'm adding in a "format dat shit" phase into my practice code now. If nothing else its a good habit.
Are you Thibault? Does this use postgres on the BE? 
I'm not totally familiar with where this came from, but based on the test name (array slicing), array[0,1] is saying, starting from the 0 index (:peanut), take 1 element. so you get just [:peanut]
You mean array[2..5]. I don't know what language uses a colon for ranges, but it's not ruby.
I didn't dig deep into it, but maybe this is due to all operations in redis-rb are synchronized. This is not very performant approach because in a single-threaded application you don't need any locks at all and in a multi-threaded app connection pooling is much more performant way. If you make external connection pool like `ConnectionPool.new { Redis.new }` you will have unnecessary level of synchronization inside redis-rb client. Also in oxblood socket IO made using exceptionless API. In addition there could be an error in benchmarks which I haven't found yet.
I was a Textmate user for a long, long time before I switched to Emacs about a year or so ago. I don't regret it and I'm able to do about 99% of the stuff I did in Textmate with (mostly) the same ease as in Textmate and I'm also able to do a lot more than what I did before. While I've heard a lot of good things about RubyMine and have played with it a little, I haven't quite taken the dive for it yet nor really felt the need. I have a (somewhat meager) Emacs Ruby setup which seems sufficient for most things that I do and it consists of tools like [robe](https://github.com/dgutov/robe), [inf-ruby](https://github.com/nonsequitur/inf-ruby), [rsense](https://github.com/m2ym/rsense/blob/8b5ee58318747ca1dde84ee41d48c4f50175cf35/etc/rsense.el) (although I don't use this too often), [rvm](https://github.com/senny/rvm.el), and some other Emacs tools that aren't necessarily related to Ruby, but which make the development experience more pleasant. Those tools seem to be good enough for me to jump around docs and source, do auto-completion, play in a REPL, inspect values, switch versions, load gems, etc. I don't really have tools for style guides or unit-tests though, since those are areas of programming that I kind of shun to begin with :P (shame on me). I use [winner](https://www.emacswiki.org/emacs/WinnerMode), [windmove](https://www.emacswiki.org/emacs/WindMove), and [window-numbering](https://github.com/nschum/window-numbering.el) for my windowing needs. I typically use four equal-sized windows in a single frame and have a function which sets this up automatically through a keybinding (`C-c +`): (defun quadrate-window () "Split the current window into 4 equal windows." (interactive) (split-window-below) (split-window-right) (windmove-down) (split-window-right) (windmove-right)) I also use [ido](https://www.emacswiki.org/emacs/InteractivelyDoThings), [ido-ubiqutous](https://github.com/DarwinAwardWinner/ido-ubiquitous), et al. for tracking buffers, files, etc. Regarding Sublime, I found Textmate to be a better experience, at least on OS X, although I must admit that I was never an advanced user of either. Anyway, I may end up using RubyMine one day since I must admit that is very specialized and advanced for Ruby development and offers features that are truly hard to find anywhere else (even in the One True Editor), but for now I've found my current environment to be sufficient (although, admittedly, I rarely work on "very, very large project[s]").
Thank you!
Yes, I'm Thibault. If you're talking about what we build in the book, then yes, the web API in the second module is built with Rails 5 and Postgres.
That's a great definition, thanks for the article! In that scope, I think that something that is implicit can still be more "magical" or less "magical". For example, for routing Rails chose a class-level DSL, while Roda and Cuba chose instance-level routing. The thing is, both are *equally convenient* to use, but Rails' routing is arguably more complex ("magical"), while Roda's and Cuba's routing is much simpler and also powerful, so it's a clear win. Another example, ActiveRecord has validations defined on the class-level, while with Sequel you do validations on the instance-level. Again, both are equally convenient to use, but with Sequel you can use regular Ruby conditionals (instead of `:if` and `:unless` options), easily use values which are dynamically evaluated, and even have validations performed by a service object (since it's just calling methods on a model instance). So Sequel validations are again a clear win, even though both are implicit. My point is that removing implicitness doesn't have to increase verbosity. You can still choose to implement something so that it's equally convenient to use, but with less "magic". Did you experience that as well?
&gt; How can increased contextual knowledge be considered 'ergonomic' or 'convenient'? It doesn't if you don't have that knowledge, it does if you have that context
I'm glad you liked it! I would argue that Roda is more explicit than Rails routing. The connection between a route and it's controller is all implicit in Rails. You write `to: 'dogs#woof'` in the routes, and it will magically instantiate a `DogsController` and call it somehow. And `resources` implicitly creates a bunch of routes. Roda, on the other hand, doesn't do anything like that for you. As for validations, Rails and Sequel are pretty much equally explicit. The lines of validation code are very similar, even though they appear in different places. But the Rails implementation is definitely more complex (using the Rich Hickey definition of complexity). I guess the question is whether complexity is a kind of magic. If two implementations are equally explicit, is the more complex implementation more magical? You could argue it either way. The two concepts are certainly related, but I would lean towards using them separately â€“ that is, you can have simple magic, complicated magic, simple explicit code, and complicated explicit code.
I consider these to be orthogonal axes: * Clear vs. obscure * Concise vs. verbose For me, I consider code more readable when it is more clear than it is obscure, and when it is more concise than it is verbose. I would probably prefer clear verbose code over obscure concise code, but I would also prefer clear concise code over clear verbose code. I think a good example is explicit iteration with for loops vs iteration with map or filter or reduce. A for loop exposes nitty gritty details of how the iteration happens, which is perfectly clear to someone who is familiar with for loops, but if we don't care about the ordering of the iteration these details are extraneous. Map is just as clear while hiding the extraneous details, making it more concise and in my opinion more readable. Of course it's possible to make code more concise by removing some *essential* details, thereby making the code less clear and less readable. It takes some skill to identify the non-essential details when making code more concise.
How else would approach the situation of making an index that is N1% one query and N2% another query?
i don't even really understand what "an index that is N1% one query and N2@ another query" even means, or how it's related to sorting. I guess I've never had the need. Perhaps you are right that this is a generalizable need. From what I underestand of your problem space, if I wanted a sorted set that was 25% from one set and 75% from another... I'd just take 25% of the items from one set and 75% from another, and then sort them? &gt; the result set will always contain 50% â€œset Aâ€ and 50% â€œset bâ€ and thereâ€™d be no obvious way to change this. The way that _looks_ obvious to me to change this would be to change: result_sets = { top_rated: Post.all.order(rating: :desc).first(50), top_rated_in_followed_topic: Post.all.where(topic_id: @user.followed_topics.pluck(:id)).order(rating: :desc).first(50) } to: result_sets = { top_rated: Post.all.order(rating: :desc).first(25), top_rated_in_followed_topic: Post.all.where(topic_id: @user.followed_topics.pluck(:id)).order(rating: :desc).first(75) } What am I missing? (also probably add a `not` to the first one to make sure they are truly disjunct sets)
I'm still trying to figure out how to get it to be mostly performant: https://github.com/NullVoxPopuli/case_transform/tree/ruru-rust-speed-boost
some preliminary benchmarking $ ruby benchmark.rb Comparison: Rust: camel: 238774.9 i/s Ruby: camel: 13107.3 i/s - 18.22x slower Comparison: Rust: camel_lower: 230641.5 i/s Ruby: camel_lower: 8244.1 i/s - 27.98x slower Comparison: Rust: dash: 243197.8 i/s Ruby: dash: 20350.9 i/s - 11.95x slower Comparison: Ruby: unaltered: 6030498.8 i/s Rust: unaltered: 1960989.6 i/s - 3.08x slower Comparison: Rust: underscore: 291052.3 i/s Ruby: underscore: 169458.2 i/s - 1.72x slower 
And the response was that homebrew is a set of recipes telling your system how to download or build, with a checksum of what it should be. That is tracked by git. A committer would sign the pack by signing a commit. They would be saying this process and this checksum are correct, whether that process is downloading something over https or building from source. 
Any functional language: map print [0..10] or map print (range 10) Not readable enough? (it is when you know the basics of lambda-calculus) map(print (range 10)) All the "foreach" and "comprehension lists" and neat features that improve readability and practicality are actually borrowed from them.
Great to see a new Ruby podcast up and coming. Btw, have you tried Octopod for building your podcast show site? [Octopod incl. great show notes, comments and much more](https://jekyll-octopod.github.io). Cheers.
Thanks, I used http://simplecast.com/ since I've already used their service for another show and found it mostly very good aside from a few annoying quirks. It might sound weird that I'd rather pay for a service, but Ruby5 had its own very old Rails app originally which we rebuilt in 2014 I think. Just the thought of maintaining anything beyond the show itself (which already takes enough time) makes me want to shy away from home-rolling. Speaking of paid services, I'm actually very curious about https://fireside.fm from Dan Benjamin. I kind of like giving money to people who do things well, since I'd be spending much more of my own time (and therefore money) doing a half-assed job otherwise.
It's not so much that Ruby5 fell off the radar. Instead, Code School (who I work with and where I used to regularly host Ruby5 along with other hosts) decided to stop producing podcasts (not just Ruby5) in July. I tried for several weeks to see if they would allow me to continue Ruby5 with a slightly different format (to save costs on my end) but eventually it didn't work out for several reasons. The [announcement of Ruby5's ending](https://ruby5.codeschool.com/episodes/690-episode-645-september-20th-2016) was released on Tuesday morning and I basically rushed to get Ruby Facets together between Monday and Tuesday so hopefully the listeners of Ruby5 wouldn't think they were left in the cold for good. 
Then good luck then with at least (3..10) more lines of setting up the dependency. If you already have a test for the `Subscriptions::Manage` you don't need to test it again. You either do it DRY with mocks and have clean unit tests, or have complicated integration tests. Last year I've built a DI container for ruby, which is similar in usage with Spring Container from java https://github.com/sebyx07/rubybeans But I've found mocks to be a lot easier
&gt; You either do it DRY with mocks and have clean unit tests, or have complicated integration tests. _Or_ you can solve it a different way. You can have the dependencies define substitutes under their own namespaces and use _those_ when testing. I've found that better than both mocks and DI containers.
Thanks for highlighting Simplecast and your backstage setup. No worries. Good luck with Ruby Facets. Cheers.
I like these, but there is value in writing tests before code: it reveals errors in your tests. If you have only seen your test pass (which can happen if you write your tests last), then you don't know for sure if your tests silently pass.
A lot of the advice in this post sounds like bad advice for people who are just starting out with testing. Much of it is stuff I think you should do only after you're comfortable with tests, otherwise you won't really know how to do it right. For instance: &gt; Write enough specs to check all the important places in code but not more. and &gt; When you spot a test which looks like it doesnâ€™t do anything important â€“ just remove it.
Do you then mean homebrew should be doing something to protect against malicious commits in a repo? To me that sounds more like an issue for the repo owner, not homebrew.
There is certainly value in both methods, as well as a mix of using the right methodology when it's appropriate. Usually it comes down to accuracy vs speed.
One thing I've found a lot of developers don't do are negative tests, that is feed bad data into the software to ensure that it fails gracefully and includes proper information for debugging. Nothing sucks more than having to track down the cause to an error due to a useless error message like NameError from an uninitiated constant.
Check out regular expressions: https://ruby-doc.org/core-2.2.0/Regexp.html You can also use rubular.com to test out regular expressions.
This is awesome! I did not know about this! Thank you! Does this look better to you? It still breaks on the .include? but the regular expression does work! http://pastebin.com/9f7YZLGz
Your regex works, though I would write it like `usrPass =~ /\d+|\W+/` (Check out rubular for what that means) As for include? that is going to return `true` if `usrPass` includes whatever is in the parens. EDIT: removed for incorrect info. EDIT2: I'm sure you know this, but this is not the way it works in real-life. There are things called verifications that frameworks such as rails provide you to check a password. That being said, I think regex is a perfect fit for where you are in your Ruby learning. EDIT3-Revenge of the EDIT: Ruby variables are usually written in `snake_case` not `camelCase`. (Google those if you want more info.)
No problem! One of my favorite things about ruby is that methods like `includes?` returns something that would make sense in plain English. You ask "Does the user's password include something?" (`usrPass.include?(something)`) and ruby responds with `true` if it does include it or `false` if it does not! Out of curiosity, why are you learning Ruby?
Case. That's what I'm looking for. Brilliant. Thank you so much!
&lt;%= image_tag("#{response.status}.png") %&gt;
New dev here. Just started using Resque three days ago. So people use Sidekq to process jobs and Resque to enqueue them for the speed? Is that the primary selling point?
What /u/realntl said. I think that Homebrew should adopt a rule requiring repos' tags/commits that it distributes to be GPG-signed using the Git native feature for such. No signature? Users can clone the repo and install it from a local copy, with a CLI flag indicating that they know they're subverting a security measure, but painlessly promiscuous pulls from all and sundry are a bug, not a feature.
For what it's worth, this is by no means ruby-specific syntax - see: [C++](https://www.tutorialspoint.com/cplusplus/cpp_conditional_operator.htm), [Java](http://alvinalexander.com/java/edu/pj/pj010018), [PHP](https://www.abeautifulsite.net/how-to-use-the-php-ternary-operator), [JavaScript](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator), [C#](https://msdn.microsoft.com/en-gb/library/ty67wk28.aspx), [Perl](http://perlmaven.com/the-ternary-operator-in-perl), [Swift](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71), [Objective C](http://iosdevelopertips.com/objective-c/ternary-operations-on-objective-c-objects.html), [Groovy](http://docs.groovy-lang.org/latest/html/documentation/index.html#_ternary_operator), ..... Not **all** languages have this syntax, but it's extremely common!
feedback mode engage! * in ruby, use snake case for objects and camel case for classes. i.e., passNum -&gt; pass_num and usrName -&gt; user_name * you assign that number to passName instead of passNum, this will break your things. * password_length would be a better name * no need to assign variables that you only use once, like passNum .i.e. you could do `if usrPass.length &lt; 8` * no need to nest if-clauses if all they do is abort the process. if you exit the method inside an if statement, the code that follows will be skipped without the need to wrap it in `else` * you'll find that the user name check is easy in ruby. either by using regex, or simply `usrPass.include? usrName` * its preferable to stick your logic in methods to clean up a bit. even if you just stick all your code in one method, and then call it. i.e. def foo .... end foo * Googling "ruby String" or similar for other classes will let you check what methods they have. Often, ruby will have plenty of convenient methods that lets you do what you want in an easy way.
First of all: Thanks! I do understand the points you gave, so the parts I have to do. But I don't really know how I can make use of for example 'each_char' to get there. I somehow understand 'each_char' but somehow not. I do understand that you can pass each single character to a block and add characters, but I don't really know how I can use it to do that with every 'real' word like 'Hello' in my example. How do I "tell" the program to know when there's a consonant and when there's a vocal and to only change consonants to for example "coc" instead of just "c"? Kinda sorry to ask questions like that because it's probably kind of simple.
This is complex for an introductory course, are you expected to have prior programming knowledge in this course? Have you taken any logic courses? The encoding portion is easy, but the decode portion made me really think. Other tips for moving forward: Don't try to write the whole program at once. Write the encode portion. Set that code aside. Write the decode portion. Set that code aside. Then combine them into one program that can be controlled with the flag like /u/menge101work suggested. This page will help: https://ruby-doc.org/core-2.2.0/Array.html Don't worry about the version, a majority of these array functions will never change.
No we're not expected to have any programming knowledge. Normally there's a programming starter course beforce the semester but this year there was none and the professor said he's gonna start from zero. The only things he talked about was what objects, classes, methods, attributes, instance variables and class methods are and how you can create a class or an object. The only methods we learnt until now were class(if that's a method?),attr_accessor, puts, to_s, def, initialize and how to take over methods from another class with require. There was a task where we should create a "roll a dice" ruby-code which I didn't know how to do at first but I got it eventually by doing some research. But with this task, compared to what we learned in two lectures, I'm completely overwhelmed because I don't even know if I can use any of the things we learnt or what I actually have to do. And with English not being my main language it's even harder because I sometimes don't understand the technical terms in English (dictionary helps me most of the times). I know it would be better to ask my professor but it's friday now and it's already evening here so I wont see him. Thanks for the help though.
&gt; How do I "tell" the program to know when there's a consonant VOWELS = %w(a e i o u).freeze def is_vowel?(character) VOWELS.include? character end What I've done is define a constant VOWELS that is defined as an array of single character strings. Where each string is one of the vowels. Since a character is either a vowel or not, all we need then is a method that takes the single character string as an argument and checks to see if it is a member of the VOWEL array. Since you are new to ruby, the %w syntax may be confusing. It is the same as doing: VOWELS = ['a', 'e', 'i', 'o', 'u'].freeze Likewise the freeze may be foreign to you, thats a fairly deep topic to go into, but it's a best practice to freeze your constants. So just go with it. 
That's really rough. I'm sorry. Let me try to give you some more help. During this explanation I'm going to link you to several Ruby API pages. These pages will list the functions you can run on the particular object type on the left hand side of the page. Click any of them to get more information on the right. The first step is to accept input from the user. To do this you need to use a function from the STDIN class. Take a look at this link: http://ruby-doc.org/core-2.0.0/IO.html#method-i-gets Once you have accepted input and stored it in a variable you need to modify it. Let's start with encode. Basically you want to accept a string from the user. You want to iterate (go through each) character in the string and output a new string. Iteration over an array is quite simple so we'll convert our string to an array and iterate over that. Ruby is great because you can turn just about anything into anything else. To figure out how to do this you should take a look at the String class for ruby: https://ruby-doc.org/core-2.2.0/String.html#method-i-split Once you have split the string into an array where each element of the array is a single character you need to iterate through the array and encode each character you come across in the string. So for example if you come across a consonant like 'b' in your string you would add 'bob' to your output string. Since we need an output string lets start by defining it somewhere above our array iteration by writing: output = "" Now we have an empty string variable defined as output. Now we need to add to it in the array, imagine our input_string has been converted to input_array using the split function I linked you to above. We need to iterate through our input_array, we can do that using each. input_array.each do |character| output = output + character + "o" + character end In this code the array we created out of our users input is iterated through one character at a time. Each time we get a new character in the array we set the value of the character to the variable character. So if I have an array ["a", "b", "c"] and I use .each |character| to loop through it, the first time I enter the loop the variable character will be set to "a", the first element in my array. The second time I loop through character will be set to "b", the second element in my array and so on. So given that, when we loop through the array our string output will be updated with the current character plus an o plus the current character again. That's all fine and well, but the problem is that anytime we get a vowel, our program will add the vowel, an o, and the vowel again. This is invalid as the program is only suppose to add a single vowel anytime it comes across one. In order to solve this we need a conditional statement to let our program know that only consonants, or rather, anything that is not a vowel, should be doubled with an "o" between them. To do this we need to use a conditional method called if. This method says that if X is true, do the stuff below. Example: if true puts "OK!" end This particular statement will ALWAYS print "OK!" to the command console. The keyword true in ruby is always true, and since we're saying if true, print out "OK!" it will always print it. Conversely: if false puts "OK!" end This statement will never print anything to the console, because the value of false is always false and if the statement to the right of "if" evaluates to false it will not run the block. (The block is the code between if false and end.) If can be extended by elsif or else. elsif allows you to add an additional conditional statement. If the first conditional statement did not pass, the additional conditional statement will run, if it passes anything in the elsif block will run. Finally else will run as long as no conditional statements in the current if statement passed. Example: if false puts "OK!" else puts "WHOOPS!" end This block of code will print WHOOPS! to the console. If you've been following along up to this point, you can see how this will be useful. We need to test if the current character is a vowel. If it is we simply add a single vowel to the output string, if it isn't a vowel, we encode it with character + "o" + character. I don't want you to get in trouble for plagiarism so I won't write the code explicitly for you here, but you should be able to combine the above if with the above loop to get what you're after. Conditional statements can be structured like this: if variable == "a" #This will return true if variable is a string "a" if var_x == "a" &amp;&amp; var_y == "b" #This will return true ONLY if var_x is "a" and var_y is "b" if variable == "a" || variable == "b" #This will return true if variable is "a" or variable is "b" You can test for indefinite number of conditional statements in your if block as long as you include a &amp;&amp; (and) or || (or) between them. I think you have enough here to finish encode. Give it a try. Once you get the encode portion down and begin working on decode you'll probably have more questions, or at least better understand what you don't yet know. If you need more help, just ask.
The problem with advice for beginners is that many people never get past that stage. All they know is unit tests and are taught to fear anything more complicated.
Well, the error says `cargo not found`, so my guess is that's the issue, like the error message says, the rust `cargo` package manager is not installed on the VM, but your build script assumes it is there to use. I know nothing about rust (except that it's package manager is called "cargo", that's about all I know), just reading the error message you posted. 
I think what this comes down to is my bad bash scripting skills. I'm debugging the if right now -- I thought it was working, but since I've made this post, I can't install the gem locally anymore.
That's good to know, the help I provided in the long explanation above will encode anything, including fake words, numbers, symbols and so on, any input is valid.
2020 is the due date. 
Ah, right on. I think active_model_serializers got it wrong, if that's how they did it. Thanks for writing this gem.
yeah, take a look at https://github.com/rails-api/active_model_serializers/blob/master/lib/active_model_serializers/key_transform.rb but yeah. maybe in a later version, I'll fix the names in both gems. :-)
Can you please format that code? It's really annoying to read code like that. 
I think the transfer_ownership functionality needs to be rethought. If I have a situation where two objects have instance variables pointing to the same shared object, and then I move one of them, then the other object will throw when it next accesses it's own instance variable despite never being referenced directly. It's just asking for the kind of hard to track down bugs this is supposed to solve.
It sounds like your real problem here is that you are trying to solve problems in a language (Ruby) that you don't understand the structure of. I would take some time to learn the basics of Ruby and complete a few exercises before attempting this task. You can google for a basic primer and read a little about primitives, arrays, for/each loops and if/else evaluations. Then do a few entry level exercises (exercism.io is my personal favorite but there are many others). Once you have the bare fundamentals you should have no trouble at all thinking of ways to solve your assignment. Without this knowledge you may stumble across a solution to your assignment by copy pasting code examples you find on google, BUT you won't have a foundational grasp of the tool you will be using for the rest of your class. Save yourself some time in the long run and google out some basic Ruby tutorials and get your brain "thinking in Ruby". We're here to help answer questions along the way, but if learning the basics is too much of a hassle for you, not many here will want to invest time helping you, as you likely won't stick with it.
To an extent yes, but this is recursive and breaks even reading from the variable. Even strings being used in multiple objects (or objects being used by objects) could cause crashes in unrelated code. 
Is 'get_requests' the action in the controller or a private method? Is it called explicitly or in a callback?
It's possible that the external API is returning an error response with an empty body. What's the response status code?
No doubt. But this article specifically says it's for novice test writers.
It's an action in the controller. 
I would say that the best way to avoid petrification is to create meaningful public signatures for behaviors to be tested. Implementation is detail and should be enclosed in private methods. A good way to practice this is through something like Conway's Game of Life. I've hosted a couple of code retreats and I emphasize this principle all the time. Let your code tell a narrative before implementing details.
Difference from [this question](https://www.reddit.com/r/ruby/comments/53wec6/how_do_i_should_i_be_getting_performance_boosts/), which I see you've since deleted, was what I was wondering about. Errors in benchmarking in the first place? Errors in how you cross rust/ruby boundary? Changes in algorithm or scope? 
Maybe it's the mobile app... but what I mean is to indent it all with four spaces or share as a Gist or similar tool. 
hi all! i try to explain my motives for this gem in the readme, but to further contextualize, this isn't a gem for industrial strength performance metrics like stackprof. i think the gem itself still needs work, but it does what it says on the tin and has made it easier for me to do a recurring task in my own time. i hope you will also find it useful! if you have any thoughts about the gem, i've also written out some issues about possible further direction, and i'd welcome your input there. :)
fwiw id recommend even just setting `alias`es for these for the time being
probably a good idea.
it's nearly the same algorithm. I plan to add memoization which should make it crazy fast. If you run `ruby benchmark.rb` from the repo, it'll show you that even memoizing ruby _almost_ approaches rust speed. So if rust does it, it'll be crazy. Most of the speed comes from rust being a compiled language.
Is that the real code? https://foo.bar looks hard coded, and isn't a real domain. 
Nice gem! I prefer looking at graph data visually as opposed to numerically anyway. My only suggestion would be to set a default to gif instead of x11. To me, having that data saved and easily accessible while I'm refactoring helps me more.
Thank you.
They haven't done a great job documenting and publishing the API for all to consume, such is the OSS life. **@matthewd** wrote the Interlock API and wrote the code for Sidekiq to use the API so I didn't have to understand it much.
That's shared mutable state, exactly the thing that causes a ruckus. AFAIK Guilds are opt-in; if you opt-in, you need to implement your code safely.
More concerned with an MITM attack compromising the victim's system and *potentially* using his interactions with GitHub etc as another attack vector. Though, by that point of course, the victim has enough other problems to keep him busy for a while ðŸ˜– Yeah, we've beaten this horse to death, then a pulp, then dust. Have a great day.
Why did it look like you weren't getting performance improvements in the version you posted a question to reddit about? Was it an error in benchmarking approach? 
Oh, it was because the algorithm for transforming the strings was bad: see this: https://github.com/whatisinternet/inflector/issues/18
so, the commit URL that 'fixed' it was just me changing which package I'm using. Like, I just changed my code from whatisinternet's inflector package to calebmer's inflections package. https://github.com/NullVoxPopuli/case_transform-rust-extensions/blob/master/ext/case_transform/Cargo.toml#L16 being unicode aware would be interesting. I'd have to add tests for that. I haven't looked in depth at the inflections package that I'm using, so I don't know off hand if it handles unicode appropriately. 
hmm, i went with x11 mostly to follow with ruby-gnuplot which i rely on. perhaps though i could introduce some wrappers for `configure`, such that you could just call `Graph::Function.as_gif` for setup and be all good?
Wow, thanks alot! This really helped me, I'll try doing that tomorrow and will probably ask some questions :P 
Downside would be lack of support resources if something went wrong. Being on the bleeding edge of features like this is great when things work out, frustrating when they do not. I'd keep the Vagrant machine handy but there's no harm in trying WSL alongside. Many devs report it working quite well. I'm keeping it open as an option for when my Mac gives out. 
Read the source of the script? 
I'd say it depends on what the object is, and what it's supposed to represent. Can you elaborate more on that?
I have never used jruby before. The questions I can ask are thusly: Are you using a Windows implementation of Java or openjdk? Have you tried getting jruby through apt?
Since you said you had no idea where to start, you should know that the first place to start is almost always breaking what you want to do down into smaller parts. You might not end up exactly with what /u/menge101work did, but you'd probably be somewhat close to that. Then, if you don't know how to begin on one of those parts, you probably need to break those parts down into smaller parts. While breaking it down, you'll start to notice parts that match up with what you do know about programming. It can also help to start to do the task manually yourself with some example words. Write down the steps you take in your head to accomplish this. If your example word is "dog", you might have something like: 1) Look at first letter, "d". 2) Is "d" a vowel or a consonant? 3) It's a consonant, so write down "dod". 4) Look at second letter, "o". 5) Is "o" a vowel or a consonant? 6) It's a vowel, so write down "o". 7) Look at third letter, "g". 8) Is "g" a vowel or a consonant? 9) It's a consonant, so write down "gog". Looking at that list, you can see you're kind of doing the same thing three times. "Look at a letter. Is it vowel or consonant? Write down something depending on whether it's a vowel or consonant." Anytime you see that the same thing happens multiple times, there's a good chance you can replace that with a loop. Also, anytime you have to do one thing if something is one way, and another thing if something is another way (like steps 3,6,9 in the "dog" example), that's a conditional (aka an "if-then" or "if-then-else"). So right away you can see how some of the code in this is going to work out: you'll do a loop where you step through each letter in a word, and inside the loop you'll have a conditional that checks for whether it's a vowel or consonant, and outputs different things, depending. What all that stepped you through is making the encoding algorithm (in pseudocode, at least). You can do a similar process to determine the decoding algorithm. Once you have those two parts figured out (or at least attempted), you're in a much much better point to start asking for help. Chances are that when you break something down like this into the algorithm, you'll see patterns or structures that you know how to turn into actual code in your programming language. Like when you see the loop, you might know how to do a loop in your language (Ruby actually has many ways to do loops). Or when you see a conditional situation, you might know how to do an if-then-else. You might see cases where you have to store a value to be used later, and you'd realize "oh, that means I need to use a variable". The more you can fill in on your own, the better. That way if you get stuck, you can ask more specific questions about just a part of the program instead where to start with the entire program. And sometimes simply the act of filling in the parts you can figure out will help you realize how to do the parts you didn't know how to do. I know others helped you more specifically to this particular assignment, but I hope this helps you next time you're stuck in the early stages of a program.
I bet if you show us ~/.bash_history, we'll see some insane things. Also Linux sucks as a development environment anyway.
If this is truly the JSON that was handed back to you, then it's invalid JSON and there's not much you can do to fix it. You could try using regex to escape the quote marks yourself. It I would NOT recommend it. You should either handle the error and try a different random quote, or contact the site owner and ask them to fix it.
It's the openjdk under the linux subsystem - it crashes trying to compile jruby during the rbenv-install process. Haven't looked into it in detail yet though.
why not just do a conditional? people are so afraid of using conditionals in time ruby but in this case it's a) more readable b) equally as safe
[removed]
Ah. Well, let me try with rvm and apt.
Where would you put the validations? In the initializer?
don't know about ruby configure so you can compile it but you can try this one (works great for me) https://github.com/postmodern/ruby-install as for using RVM or rbenv - it is quite outdated right now and over complicated try chruby https://github.com/postmodern/chruby
Nice investigation on why an RCE can be pulled out of Logger!
Well, I worked for a company where we deployed to Windows servers.
Out of the original topic but for my personal interest: what did you use? Apache? IIS? A VM? What was the reason for choosing Windows Server?
No downside, but as a benifit you don't loss a CPU and RAM to running a VM.
The answer largely depends on what version or ruby that you actually want / need to use. I have a 1.9.3 app that I have to help maintain, so I locked down the json gem to '&lt; 2.0'
Ok, so first of all I don't really understand how I am supposed to use the "gets" method or what exactly it does. I read the link but still don't understand. Couldn't I just use the "split" method to type a string and convert it into an array?
Are you using bundler? Cause bundler is the tool to help with that. 
Could you detail me on what is bundler and how to use it? Thank you
Is this just blogspam or meant seriously? Example #1 is a horrible abomination and not at all "writing better algorithms". And &gt; It takes less computational time also. is just the icing on the cake. No, it doesn't. Example #2 is incomplete and wrong (fact &lt;-&gt; fib?)
No. I struggled for a few hours trying to install rbenv/rvm in a Docker image to no avail. I finally realized I can install the specific version of Ruby I need. Need to upgrade the version? Update `Dockerfile` and rebuild the container.
Ha ha me too, I wish somebody told me that I was being stupid. Had to unlearn rvm way of doing things to make it simpler to use docker.
Thanks. How exactly do I define my array as for exmaple "input_array" after using ".split" on the string? Sorry if that's obvious but I really just started :D
That's really odd. Maybe some trailing whitespace or other invisible characters have creeped in? It must be an issue with the string itself, I suppose.
Maybe if you have light weight services you want on the same docker image(shared sqlite or something)? 
But that isn't what this thread is. It was an attempt to be helpful to people that are developing in Ruby on Windows. While I agree that Windows isn't an optimal platform for Ruby dev work, this thread wasn't about which platform to use. It's very similar to someone giving a tip about Ruby and commenting that people should use Python instead. 
or do I have to write:" if variable == "a" || variable == "e" ..." instead of "character"?
Why would you want to use rvm/rbenv in production? Serious question, not trolling. We use CENTOS and build our own ruby packages due to wanting a different ruby version and only use rbenv/rvm in dev. As far as development, no point it having it IN the docker container, but i'd still use it for trying out things locally.
Some interesting ideas. I have comments. * python-style scoping has been discussed in the Ruby community for decades, and it's not likely to ever change. I don't have anything against it, really, if everyone settles on consistent indentation characters, but it's not going to happen. See a joke feature request related to "too many ends" here: https://bugs.ruby-lang.org/issues/5054 * I think having the whole stdlib always loaded is a terrible idea, not only because it means we'd actually have to *load* everything on startup, but because it pollutes the top-level namespace horribly. All languages "require" you to pull in some level of dependencies explicitly, and I personally think it's a good thing. Admittedly, one reason libraries don't even load *themselves* completely is because loading/parsing/compiling Ruby code from disk is a slow process, even on MRI and especially on JRuby. * Module nesting constant lookup may be confusing, as in the case you point out. However, it's also how the following example works: module Foo Name = 'Joe' def say_hello; "Hello, #{Name}"; end end In order to support the above and not cause the confusion you pointed out, we would need a separate place to store lexically-visible constants that isn't the module itself. Possible, but not how things are done right now. * My experience with having unlimited operators is largely from watching the Scala community, where it seems like everyone agrees unlimited operators often leads to very confusing libraries. Basically, everyone decides their own meanings for their own arbitrary strings of symbols...potentially conflicting meanings across libraries. I guess I've never found it valuable to encode so much meaning in symbols when we have natural language to express that meaning. * Re: challenges mixing hashes in positional args with keyword args: don't do that. Both need to be supported for backward-compatibility, so this isn't going to go away (at least, not until some hard choices in Ruby 3.0). * The Symbol vs String distinction is troublesome, indeed. Symbol is both more and less than a String, though: it is idempotent and immutable. You could get there by simply using interned and frozen strings, but then you'd just move the issues to whether you've actually got an interned string or not. And not having them interned means an expensive equality check rather than a cheap identity check. I don't have a good answer here. * "Method names should not be globally namespaced String" I'm not sure I understand. What you've done seems to be simply providing longer names for these methods using a character not currently allowed in method names. Refinements is an entirely different beast; it allows any scope to define a sort of "overlay" on top of existing classes such that the methods in the overlay are preferred. Basically, scoped monkey-patching. It also has a ton of complex problems that have not been solved yet. * Unified destructuring is kinda cool. You might want to suggest it directly to ruby-lang.org. However, the various $ variables are starting to fall ou tof fashion (for good reason), and I'm not sure what this gains you out of just using the variable name again. * Useless bits like class variables, protected visibility, perl-style vars (see previous answer), etc: I agree with all your examples. 
Faster than `apt-get install ruby`?
That seems like a really bad idea to me because I don't trust rvm/rbenv like I do the package manager but its obviously working for you so *shrug*.
Yes post the link. Also, friend, it's generally not good practice to say "I would like some help" and then stop. If you need to include apologies, do so. But still post the question.
Did he die? I loved this talk.
Even for small applications containers are probably a better answer but like I said in another comment, whatever works for you :).
Also if you just want the "trivial handle no edge cases" version, it's this: def reduce(initial = nil) result = initial each do |item| result = yield result, item end result end
actually got another question. when i run a .rb file in terminal, and #inject is used in that file, which #inject does it use? the MRI one, or Rubinius?
First off, despite my purist view/aversion to using third-party package managers in production, doing this in containers is likely going to be more complicated so you might want to keep trucking with your current solution. You wouldn't use one container for all of those. Postgres doesn't benefit much from docker really since you typically run it in a centralized fashion and won't typically have multiple versions running (and it already supports having multiple versions running). People have already made images and docs for it though if you want to go for it https://hub.docker.com/_/postgres/. To start with though, all you'd probably want is a rails container that runs phusion passenger. https://github.com/phusion/passenger-docker (their docs are complicated but as long as you setup the dockerfile right it should "just work") The above has nginx running in it as well (which is not usually considered best practice by the docker community, but whatever) so it'd cover that as well if you want it too (alternatively run nginx separately and proxy to passenger, but that'd probably require some special setup it looks like, I don't use passenger). Docker(more generally containers) gives various advantages (which I won't go into here) but it does require some effort to learn and setup originally. Edit: Ideally you just have one version of ruby and don't bother with gemsets and then you don't have to use rvm or do all the above work, you just use the distribution packages/make a newer ruby package and you're good. Doesn't sound like you can get away with that in your case though.
I think I see now what you're talking about. I downloaded the source, and then looked in `ext/` because the README.md said something about editing the `defines.h` file and uncommenting modules desired. So then I went looking through there, and noticed that it was just looking in the `ext/` folder. So, I started looking at the tk exta and saw that there was some README's in there with a lot of the `./configure` flags. This is nice, but I do wish that they were in some sort of Ruby Wiki page or something. 
In my opinion RVM stopped being useful (or at least of use worth the pain) when bundler was released, years ago. 
I think rvm have prebuilt binaries, so at least comparable in terms of speed.
It was recorded. Click on the link to see it.
haha gotcha. but is it safe to say that the rubinius are for the most part equivalent, so i can study the rubinius code to understand what's going on 'under the hood' for MRI?
Hello! Can you supply an example hash that your program would build? I'm a but unclear on "The Hash keys must be Symbols built from the literal string" etc. 
Glad you figured it out!
Just a moment. What's the difference so between a function and a Proc? 
In my point of view, yes it's faster than `apt-get`. Because it installs ruby in user space. You don't need an admin for this. You don't need to build a specific package for the current linux distribution you use. You don't have to track down issues with different gem version installed with different packages. This makes it faster as `apt-get` when you look at all parts. Only some advantages I see with rvm. The only downside I see is that security updates can't be installed automaticaly.
For what it's worth, you can also simplify those three lines into a single line quite easily: users[:"user#{index}"] = rand(20..50)
Quite. The new Microsoft is as different from the old Microsoft as much as Satya Nadella is different from Steve Ballmer!
Have you tried using it on Windows? Java support on Windows is very good so I would expect JRuby to run pretty well.
What is gonna happen when I type in two words like "Hello World" : will the blank also be defined as an element of the array? If yes, I would have to add it to the "if.." line, right? Because otherwise it's going to get converted into " o " right? If not, so the array would look like this: ["H", "e", "l", "l", "o", "w", "o", "r", "l", "d"] I think. So how would I get back the blank in the output?
could you tell us where you got stuck?
I don't even use docker based system and I don't need it. I wrote about it here: http://nts.strzibny.name/on-managing-ruby-versions/
Im reinstalling it now and will tell you. Even made a script. Running this script on Ubuntu 12.04 I believe. You should get the same error as me: rm -rf /var/lib/apt/lists/* apt-get update &amp;&amp; apt-get upgrade apt-get -y install mysql-server mysql-client libmysqlclient-dev echo "CREATE DATABASE cit DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; GRANT ALL ON cit.* TO 'cit'@'localhost' IDENTIFIED BY 'cit'; FLUSH PRIVILEGES;" | mysql -u root -p gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 curl -sSL https://get.rvm.io | bash -s stable --ruby #/bin/bash --login #rvm install 2.0.0 #rvm use 2.0.0 #rvm rubygems latest #ruby --version /bin/bash --login rvm install 1.9.1 rvm use 1.9.1 rvm rubygems 1.9.1 ruby --version apt-get -y install build-essential zlib1g-dev libssl-dev libreadline6-dev libyaml-dev #apt-get install graphicsmagick-libmagick-dev-compat imagemagick ruby1.8 ruby1.8-dev rubygems ri rdoc rake librmagick-ruby apt-get install graphicsmagick-libmagick-dev-compat imagemagick ri rdoc rake librmagick-ruby gem install gchartrb RedCloth json tzinfo echoe fastercsv test-spec ferret hoe mongrel eventmachine -r gem install ZenTest -v 4.1.4 -r gem install icalendar -v 1.1.0 -r gem install mysql -v 2.7 -r wget https://github.com/joubertredrat/clockingit/archive/master.tar.gz tar -zxvf master.tar.gz mv clockingit-master/cit /opt/. cd /opt/cit ruby setup.rb chmod 777 /opt/cit -Rf apt-get install apache2 a2enmod rewrite echo "&lt;VirtualHost *:80&gt; ServerName tasks.domain.local DocumentRoot /opt/cit/public/ ErrorLog /opt/cit/log/http.log &lt;Directory /opt/cit/public/&gt; Options ExecCGI FollowSymLinks AllowOverride all Allow from all Order allow,deny &lt;/Directory&gt; &lt;/VirtualHost&gt;" &gt; /etc/apache2/sites-available/default /etc/init.d/apache2 restart cp cit /etc/init.d/cit chmod +x /etc/init.d/cit sed -i 's/CHANGE_CIT_PATH/\/opt\/cit/g' -i /etc/init.d/cit /etc/init.d/cit start 
I'd suggest you to go through this video first https://youtu.be/9Wzw84Q-8yc even if you might not use Google container engine at all. You can understand docker and why it's used better and if you wanna do similar setup at all. If you only want to use a single sever or a bunch of servers for your production, if that setup is working well for you, I think it's better if you stick with it, at least for a while, until the documentation and tutorials get better.
Example: &gt; /usr/local/rvm/rubies/ruby-1.9.3-p551/lib/ruby/site_ruby/1.9.1/rubygems/dependency.rb:315:in `to_specs': Could not find 'acts_as_ferret' (&gt;= 0) among 27 total gem(s) (Gem::LoadError)
`end` is for your editor. Otherwise auto format might potential break your entire application and every time you press "&lt;enter&gt;" you will be fighting smart tabs. `end` is going away over my dead body.
First `gem install ocra` Then `ocra app.rb` and this will generate `app.exe` I've gotten `ocra` working with `1.9.3`, `2.0.0` and `2.1.5` but ran into compatibility issues with `2.3.1`.
i'm finding it hard to visualize "ruby drops" -- why the name? it doesn't make much sense to me :D
They gonna drop some Ruby knowledge on your ass. 
This is an awesome post, thanks passenger! There's a lot of confusion about the role of concurrency in application servers, this helps. And thanks for acknowledging Puma has a similar model to Passenger -- personally I think these are the only two app servers for rails even worth considering, at least on MRI. Precisely because of their concurrency model. (Although in Passenger you need Passenger Enterprise to get the truly superior forking+threading model, which puma also has). 
There are no functions in ruby, only methods. If you mean methods, methods are attached to an object somewhere, this includes methods defined in main at the top level. Procs are methods that can be saved to a variable.
Added it.
I don't see why encoding an o into the encoded string would be a problem. Did he specifically say not to encode anything but letters? For example what are you suppose to do if you come across a number or symbol? Unless he specifically states only to encode letters I wouldn't worry about that.
rvm/rbenv only exist today because of CentOS/RHEL and their ancient packages. 
I went to the directory where my app is via CMD, and I did that code you said. The name of the app is 'test.rb'. I did this code: ocra test.rb And I got this Loading script to check dependencies Then, the app runs as if I had clicked it. I cannot find any .exe version of my program anywhere in my desktop.
Introductory blog post: https://medium.com/@Arafat./introducing-tensorflow-ruby-api-e77a477ff16e#.mhvj9ojlj Developers blog post: https://medium.com/@Arafat./ruby-tensorflow-for-developers-2ec56b8668c5#.97tng1qqi Image Recognition Tutorial: https://medium.com/@Arafat./image-recognition-in-ruby-tensorflow-df5d5c05389b#.ty1vygtrg Thanks https://github.com/Arafatk and everyone else who contributed! Thread where it all started: https://github.com/tensorflow/tensorflow/issues/50 
Even without docker servers have users, there is absolutely nothing stopping you from running multiple versions/gemsets on the same server using fundamentals of the os (and gaining separation between each app). The reason the problem space exists at all is because for DEVELOPMENT it was more work or effort for a dev user to swap accounts to develop multiple applications with versioning/gemsets. The problem space just does not exist on servers period. Add in docker or any other of the virtualization solutions on servers and you are actually hurting yourself by ignoring the fundamentals of the system and packaging improperly. 
This isn't correct. Many many people use docker for production and not for development and there's many reasons to want docker in production that have nothing to do with ease of development. I'm not a huge fan of quora but this has some decent answers for why you'd use docker in production https://www.quora.com/Why-would-you-use-Docker-in-production-even-on-a-cloud
You could write your own parser, it would only need to look forward one step to see if there is a comma, identifier or end of object marker, otherwise it needs to put a slash in front of the quote mark.
https://github.com/mperham/sidekiq/wiki
Unsynchronized accesses to a shared object from different threads are already unsafe. This just makes it into an explicit error (at runtime).
Not much we can do to help you without more information. An obvious question would be do you have an application_controller.rb? What does the class definition look like in that file? Can you provide a full stack trace? 
I do have an application_controller.rb, and it's left as it was generated. class ApplicationController &lt; ActionController::Base protect_from_forgery with: :exception end The whole stacktrace is /usr/bin/ruby -e $stdout.sync=true;$stderr.sync=true;load($0=ARGV.shift) /home/alice/Documents/Development/ruby/RuneStats/app/controllers/rune_stats_controller.rb /home/alice/Documents/Development/ruby/RuneStats/app/controllers/rune_stats_controller.rb:3:in `&lt;top (required)&gt;': uninitialized constant ApplicationController (NameError) from -e:1:in `load' from -e:1:in `&lt;main&gt;' Process finished with exit code 1 
&gt; Just put "input_array = user_input.split(//)" ? Correct. You don't have to define the "input_array" as an array in ruby. It already knows you want it to be an array because the .split function returns an array. It doesn't care. Whatever user_input.split(//) returns, it will assign to the variable.
Good work, but the title is a bit misleading. I thought it would be official ruby client.
I don't understand the requirements or what that table means. 
Your examples are of constantizing user input. I think it's reasonable to say never do this, although it might be okay if you are carefully whitelisting, saying 'never' is reasonable. For user input. That's not the same thing as 'never constantize'. Constantizing a configuration setting is common and not a problem. 
The data doesn't need to persist outside of the 'life' of the container. Is it really that unbelievable? I should clarify: I use docker mainly for testing. It's easy to spin up a test image(vagrant/openstack) and have it run docker containers that run the various ancillaries that what I'm currently working on communicates with. Currently I have a sqlite container with just the basic schemas needed because my current project only adds or modifies data, so an empty, temporary sqlite database is preferred.
Ok, what I did know is I just added '|| character == " " ' to the if phrase. I guess that would work too, right? With the requirement of not typing in numbers or something like that. My problem now is: How do I define the variable character? That's what I did until now: user_input = gets.chomp input_array = user_input.split(//) output = "" input_array.each do |character| output = output + character + "o" + character end if character == "a" || character == "e" || character == "i" || character == "o" || character == "u" || character == " " puts character else puts character + "o" + character end puts input_array.join The console says I have to define the variable character. So I guess it has to be so that every element of the array is defined as a character? I don't know how to do that though.
Your end needs to be after your if statements. |character| is only defined inside of the .each block. The block only lasts until your "end" so put the end farther down. Also, I don't recommend putting output to the command line, instead store it in a variable like "encoded_text" or "output," then puts it at the end. Remember that strings in ruby can be added to other strings. So if I have string A and string B, I can do A+B and that will return a single string with the contents of A followed by the contents of B. Also, there is a better way to check if a character is a vowel or space. Create an array by writing COMPARE = ["a", "e", "i", "o", "u", "y", " "] somewhere near the top of your file. Then instead of if character == "a" || character == "e"... you can write: unless COMPARE.include?(character) encoded_text = encoded_text + character + "o" + character end This says that unless the character we're currently testing exists in our COMPARE array, encode the character.
Ok so let's say I do something like this: array = [ "0", "0", "0", "0", "0", "0"] if Random.rand(1.0) &lt; 0.6 # (or some variable) # increment the last element of the array by 1 Which method is there on doing that? And how could I control which element is incremented when I do: else rand(5) +1 
Did the "code" placed in a quote pullout not clarify that for you? How did you even make it to #2? Saint.
More errors: username@tasks:~$ gem install mysql -v 2.7 -r Fetching: mysql-2.7.gem (100%) Building native extensions. This could take a while... ERROR: Error installing mysql: ERROR: Failed to build gem native extension. /home/username/.rvm/rubies/ruby-2.0.0-p648/bin/ruby -r ./siteconf20160928-28197-nlumy6.rb extconf.rb checking for mysql_query() in -lmysqlclient... yes checking for mysql_ssl_set()... yes checking for mysql.h... no checking for mysql/mysql.h... yes extconf.rb:35:in `&lt;main&gt;': Use RbConfig instead of obsolete and deprecated Config. extconf.rb:35:in `&lt;main&gt;': Use RbConfig instead of obsolete and deprecated Config. creating Makefile make "DESTDIR=" clean make "DESTDIR=" compiling mysql.c mysql.c:6:21: fatal error: version.h: No such file or directory compilation terminated. make: *** [mysql.o] Error 1 make failed, exit code 2 Gem files will remain installed in /home/username/.rvm/gems/ruby-2.0.0-p648/gems/mysql-2.7 for inspection. Results logged to /home/username/.rvm/gems/ruby-2.0.0-p648/extensions/x86-linux/2.0.0/mysql-2.7/gem_make.out username@tasks:~$ 
Python does fine and Ruby is faster than Python.
You need to assign the result of the if statement to a variable, then index the array with that value, kinda like this: array[var] = array[var] + 1 Where `var` is the value you saved your random result in. Just be aware that arrays start from zero, so you either need to fill in the first 6 values with zeros or remember to adjust your values.
I'm all for a well written README, but I like to always call `bin/setup` for setting up my service/application and `bin/start` for starting my service/application. This way, if later on you need a new step in your set of start instructions, you can just add it to the `bin/start` script. 
Thanks. I did what you recommended but the problem now is if I put "hello" into the console the output I am given is "hohlollol". So the vowels don't get printed again. How can I fix that?
Ok, so you've got it adding in the consonants, now we need to add in the vowels and spaces. What we can do is put an else in our block, to give a second condition. unless COMPARE.include?(character) encoded_text = encoded_text + character + "o" + character else encoded_text = encoded_text + character end The only thing that will get added to encoded_text in the previous post I made were letters that did no match our COMPARE array. Adding an **else** to the block allows us to add an action to do if the first conditional is not met. So now if the character we are checking is included in the COMPARE array we will add just the character one time to the encoded_text. In fact, we can write this is a less confusing manner using an if statement. if COMPARE.include?(character) encoded_text = encoded_text + character else encoded_text = encoded_text + character + "o" + character end Read the code aloud and it will make more sense than the previous code towards the start of this post. It says "if the compare array has the current character, add that character to the encoded_text string, otherwise encode the character and add it to the encoded_text string." Another thing you may want to know is that encoded_text = encoded_text + character is very long. You can simplify this by writing encoded_text += character What this line of code does is take encoded_text, add character to it, and store the result in encoded_text. It's less code which means less chance to make mistakes. You don't have to use it, but it comes in very handy when you're trying to write code quickly.
I hope to have Sidekiq support Guilds within milliseconds of their release. I am excite, this should hugely improve multicore support and reduce the amount of memory required to peg an entire machine.
Thanks alot! One last question for this one: Why is the COMPARE - array written in screaming camel case / CAPS and not in snake case?
Help me tickle Koichi so he drops it early the next time you see him at a conference. :-p
I probably won't tickle him but I'll ask nicely. :-) Guild Channels are pitched a bit like a dynamic version of Rust's borrow checker, "transferring ownership", etc. I can't wait to see how well or badly Guilds integrate with Sidekiq's existing design (which has very little cross-thread communication and therefore should scale to multi-core very well).
Make a a global variable by prefixing with $. The scope resolution operator is used for constant/module lookup, which is not what you're doing here. To refer to the top-level scope you can prefix the identifier with :: tl;dr =&gt; You can't, because that's not what :: is used for. If you provide some more details we can give you tips on how to achieve what you want. If you're just playing around learning the language, this would be the point where you have to take a break from coding and read some (not terribly) dry material on scope in the ruby language.
That's not how :: is used, it's used to traverse module scopes. You could take advantage of the lexical scoping of blocks. See [here](https://eval.in/652158) for an example.
I posted this in the other thread about the presentation video. I think the transfer_membership functionality, if I understand it correctly, is pretty dangerous and should at least be documented as such. The problem is that it not only moves the direct object, but all objects that object has a reference to, recursively, even if they are shared. There's really nothing else like that in ruby. It more or less means you can only transfer ownership of objects you control the source of because library authors aren't going to be careful about references and something that works today could break your application tomorrow because an instance variable was added to a class. edit: changed transfer_ownership to transfer_membership
yo Mike, why should I even use Sidekiq anymore if I can shunt execution to a different Guild? When ActiveJob inevitably gets a Guild adapter, what are the pros/cons of that going to be?
Thanks guys i got it :)
I wonder how "require" or eval or class opening in one of the guilds would work. Will it change code in other guilds?
I love gitflow, but i can't seem to convince anyone to use it with me. So back to github flow for me.
Sorry, yeah, going from memory.
I think it's for performance. #transfer does a deep copy unless the object is deep frozen which could be expensive for large objects.
Running a virtual machine may be an overkill. You can run docker containers in Windows server now. Here is the recent announcement: [Introducing Docker For Windows Server 2016](https://blog.docker.com/2016/09/dockerforws2016/)
Oh, should have mentioned we are running Server 2012. Anything along those lines?
Awesome help guys...thanks...
Awesome help guys...thanks...
I've tinkered a bit with VMs but Hyper-V is the one I've used least. However, they all share certain characteristics and once your VM is running it should pick up an IP address which you can obtain by running ```ifconfig``` in the terminal. If you're using the server to deploy and run the website I'd install Ubuntu Server - you certainly can install Desktop but I really don't see why you'd want to use it. I'm also not sure what you mean by starting Rails with certain parameters - it sounds like you just require a conventional web setup. Digital Ocean has some excellent tutorials, I used [this](https://www.digitalocean.com/community/tutorials/deploying-a-rails-app-on-ubuntu-14-04-with-capistrano-nginx-and-puma) one to get myself up and running. FWIW I had barely ever touched Linux until a couple of years ago but changing requirements have meant I've had to setup a fair few VMs and it wasn't too bad - Ubuntu Server has an excellent package manager and I find installations far easier than Windows now.
Am I the only one missing what triggered this bot?
You mean official as in, from Google? 
I think it's just a wrapper around Google's Tensorflow, which I think it's written in a fast, low level language (C? Go?) 
In my experience Docker doesn't play along well with Rails for several reasons - migrations, great difference between production and development environments (gem set, assets workflow). Also with Docker you have to manually implement some things that you have out of the box with regular Rails setup, like zero-downtime deployment.
Doesn't have to be from Google. Just in the GH repo or under the GH organization.
Seconded this. I love ubuntu server and use a VM of it for deploying webapps.
Guilds are specialized Threads. You use Sidekiq instead of Guilds directly for the same reason you use Sidekiq instead of Threads directly. Guilds (and Threads) run within a single process and don't provide you with any job persistence, tracking or higher level APIs (e.g. grouping a set of jobs into a batch). Sidekiq provides persistence (via Redis), distribution to N worker processes, Web UI, lots of higher level APIs for job management, etc.
Per the slides ( http://www.atdot.net/~ko1/activities/2016_rubykaigi.pdf ), that is considered "Ruby global data" and is *not* isolated by Guilds. So that other code would change and the act of changing it would probably mean synchronizing the threads across all Guilds to safely make the change.
If I remember correctly dynamic code loading was considered a problem for jruby. Interesting, how'd they avoid that. Synchronize only loading of code? how about extending objects? what about modifying classes/including modules? Otherwise, guilds sound like a great idea.
Copy that. Burn out or fade away.
Pretty much anything that could modify a global object would require synchronizing all of the Guilds / their threads. So ... basically everything you mentioned would be a performance no-no.
IMO you should treat a message between Guilds like a network call. Don't send big object payloads but small messages. Systems which are chatty and/or transfer large objects will suffer poor performance. Ideally Guilds should share large amounts of read-only data and transfer small messages.
That's what I meant to say, thanks. Think I got my head wrapped around it now.
The indication here is that the product simply either doesn't run on modern systems, or isn't documented properly for use. Either way, you can't be too upset general Ruby users aren't familiar with it.
Seems cool. I'm not too familiar with the Redis adapter that ships with rails. What are some disadvantages of the current adapter?
With the current adapter you're stuck with one redis gem, the redis-rb gem. So you can't use hi-redis, redis-namespace, or others. My gem isn't even limited to Redis, you can assign any object that complies with the redis-rb api. Of course, this could change if there's interest in making a Redis abstraction layer. 
Umm... https://github.com/rails/rails/blob/268a5bb010ef91880d9b03b60e5e86ae5521e73c/actioncable/lib/action_cable/subscription_adapter/redis.rb#L9-L11
Exactly, this Let's you easily so that without having have read that source code. You'd be surprised how many many devs don't. I made this because it took me two days to learn how to do this in the context of redis-namespace and a multi process server. I hope my readme will help those in the same situation.
As for me, unless you are extremely lucky (= will get good side project out of the blue) or extremely good at selling yourself (= able to constantly and successfully spend time to engage in new freelance projects), it could be much wiser decision to spend free time for "upgrading" your knowledge and reputation: take part in open source, write blogs, read books, study technologies. This approach usually turns out to be profitable in long- and even mid-term.
Yes, some companies actually look at the stuff you've done and value it when they're interviewing you.
I make an extra $60k/yr (about $80k with write offs) doing exactly what you described and I still get more done at my day job than most. It's quite nice. It helped me pay off my 150k debt in 1.5y. I recommend doing this. I still also contribute to open source projects. 
Yeah freelance stuff. Currently I'm doing stuff for an energy startup I took an interest in. Previously I was helping design consultant companies with their eCommerce clients' sites. 
Yep.
Freelance platforms like Freelancer, Odesk, Elance, etc.
I hire people, and I ABSOLUTELY look for oss contributions
Network locally and put yourself out there. I've found short term jobs paying anywhere from $50 - $90/hr just from networking. 
Yep, thought so. But wouldn't it be somevln? I mean, abbreviating the end part rather than the first?
Not sure on that one, have you thought about using rbenv (or rvm if you prefer) instead though? They make it snap to have multiple versions of ruby for different apps (if you have a .ruby-version in a directory it'll auto-switch to the version in it) and you won't need to use sudo either...
Was thinking about that and I think it's what I'll go with. Thanks. 
Your Foo#foo method is defined as an *instance* method, so this would work: class TooFoo extend Foo end tf = TooFoo.new tf.foo It would make your module a collection of instance methods that a class could use if it extended the module... on INSTANCES. When you do def self.bar(), by contrast, you're defining a method *on the module class itself*. Hence why Bar.bar() works.
Ohhhhhh. Ok, see I was thinking about it the other way, e.g. a class should be a collection of modules. Thanks! I think that helps clear it up!
I don't see how rvm/rbenv/chruby would help with this problem -- you still need to install/upgrade ruby gems, no? I think it's great to avoid them unless you need them. Haven't encountered this problem though, sorry. Maybe report it on the rubygems issue tracker? Or see if it's already been reported? https://github.com/rubygems/rubygems And yeah, seems it's been reported by others: https://github.com/rubygems/rubygems/issues/1726 I'd +1 it (by using the new fancy github emoticon feature, not by posting a contentless comment!), and watch it to see if/when someone comes up with a diagnosis/workaround/fix. 
It's more like a module overwrites the class, intuitively, but it's more accurate to say that Ruby tries to find a method on an object, then if it can't find it, moves up the hierarchy and looks at each module and base class in turn. So in my example, Ruby would look for a TooFoo instance method named "foo", fail to find it, then look up the chain at the Foo module that was extended, and find the #foo method there. If you were to extend a module, then re-define the method, your class's method would take precedence just as if the class was derived from the module as a base class. Ninja-edit: and ALL objects do this, INCLUDING CLASS INSTANCES. This is why Bar.bar is a thing. There's an object instance Bar, that is of type Class, that floats around. Calling Bar.bar calls the instance method on that object. Using def self.bar is a shorthand way of adding *instance* methods to the Class object that you're building when you declare a class. "self" in that case points to the object Bar or whatever. 
Nothing against AWS lambda but the benefit of it was not immediately obvious to me in comparison to a standard framework like Rails. What is your draw to it?
This this great thanks for sharing!
Thanks for your 2cents on this one! I like the FaaS model as: - My micro services (about 10 or so) are short lived (each only doing about 50 jobs, if that, per hour) - I don't want to manage infrastructure (time vs money thing), I've found Elastic Beanstalk a bit unreliable, although I still use it. - Heroku is better, but don't really want the data going to the US/Europe (my database is in Australia, and that latency adds up) - I'd do it in Crystal/Swift but their MongoDB libraries aren't great, well to be fair, I'm sure they're ok, but they don't have great ORMs for MongoDB. ... this has got me thinking, I wonder if there is a dokku equivalent to FaaS (although it'd kinda defeat the purpose).
Rails!=Ruby ;-) Well I'm more of a Sinatra guy myself, however I'm using these for instances where it doesn't make sense to maintain a web application, I.e. long running processes (pdf generation, web scraping, fetching from 3rd party APIs etc). 
Yup, they're awesome, but they seem to be going up market, and aren't even showing their prices anymore... Basically, they raised money, and I'm sure an investor said "raise your prices", which is great for them (as their product is great), but I don't have a big enterprise budget :-(
Here is my shot at it: n, k = [6, 3] a = [1,3,2,6,1,2] pairs = (0...n).to_a.combination(2).to_a.keep_if do |i, j| (a[i] + a[j]).modulo(k).zero? end puts pairs.size
Wow, this wins. Though it only technically works for this puzzle because #combination happens to return the pairs consistently in the right order. Edit: actually I'm wrong. This would always work. The I&gt;j condition basically ensures that the pairs you get out are indeed all possible combinations - order doesn't matter since you're just summing them anyway. The REAL insight of this puzzle is realizing that if you select all pairs (ai, aj) such that i &gt; j, that's the same as saying "select all unique pairs from this list." Cool!
thanks for the hint.
Didn't know about the combination method. Man, ruby iterators and enumerations are just awesome.
You can pick one of this list: https://www.codetriage.com/?language=Ruby.
We have a Slack integration gem that's quite useful. It has some pending issues and there is a lot of potential for more features like reverse integration. e.g. right now it just posts whatever you want from your app to Slack, but you could have it build a webhook and post non-sensitive updates to a Ruby app from Slack. An example could be for a CRM app when you've just had a call with a customer, you just slash command: /update-crm Client1: Call went well. Moving forward with project. It's a moderately popular project, good code quality, and with some more features, it could be even better. Take a look: https://github.com/codelittinc/slacked
Hey! I have several gems/projects, where a helping hand could be greatly appreciated. And I hope they are not that boring. So, in general, what I'm doing currently is trying to adopt Ruby for quick-and-easy experimenting with data and visualisations. Some successes are made on the road, but there are much more ahead. So, basically, there are two "branches" of projects, and not for all of them I have enough time :( * [reality](https://github.com/molybdenum-99/reality) (596 stars): consolidated access to data &amp; APIs about real world (and several libraries under it, for example [infoboxer](https://github.com/molybdenum-99/infoboxer)--hi-level MediaWiki client); * Graphical projects: * [worldize](https://github.com/zverok/worldize) (232 stars), it was started like "just simply draw all countries", but [currently](https://github.com/zverok/worldize/tree/map) is (slowly) developed as a generic "simple map drawing" solution; * [magic_cloud](https://github.com/zverok/magic_cloud) (45 stars only, it is pretty old)--pretty &amp; precise word cloud; * there are also two or three "unstarted" graphical gems ideas, which I had decent plan for, but not a line of code... The catches: 1. Everything here is pretty far from Rails ecosystem, so it could be a lot of fun, but probably not something for your next commercial project; 2. I am picky person, with strong opinions about code style, next goals and so on. But pretty reasonable one. Another thing I am involved into is a bunch of [SciRuby](https://github.com/SciRuby) projects, it is mostly for scientific computations, and a lot of work there too. The catches: projects are developed by students and scientists, code and architecture quality &amp; style may vary significantly; some knowledge of statistical methods and approach is desirable. Hope something of it was interesting.
&gt; (0..(n - 1)).map { |i| a[(i + 1)..-1] }.flatten n.times.flat_map { |i| a[(i + 1)..-1] }
Ah, nice. I didn't realize #times passes the integer as an argument. And I always forget about #flat_map.
lol. this is funny. 
out of curiosity, [i benchmarked the OP's solution and the top one as of this morning](https://github.com/mooreniemi/experiments/blob/master/lib/divisible_pairs.rb) using [Graph::Function](https://github.com/mooreniemi/graph-function), and here's the result: https://github.com/mooreniemi/experiments/blob/master/lib/divisible_pairs.gif
also note to OP: did you mean to use `n`? you assign it but then use `a.length`
Yeah good point, there would be duplication there. And also a4 + a4. 
yes if you want both of these, use \#permutation rather than \#combination
The book is updated to cover Ruby 1.9 as well as Ruby 1.8. The book discusses character encodings throughly. After this book, I'll probably read a newer book anyway, to get a sense of what has been added and to in general better understand certain concepts that aren't the best explained in this book.
Function composition is cool. For the most part Rubyists aim to achieve method chaining, or otherwise performing a series of operations on a calling object. Sometimes it is certainly more appropriate to perform an operation on the returned value of the called method. I'm glad to see a way to incorporate both approaches to chained method calls.
Other post with comments: https://www.reddit.com/r/ruby/comments/54s8me/ruby_api_for_tensorflow_is_out/
I wrote a gem that implements this with a more usable API (IMO), here: [funkify](https://github.com/banister/funkify) Some dude even wrote a blog post on it :) https://spin.atomicobject.com/2014/07/23/ruby-partial-application-first-class/
&gt; funkify nice! how's the performance? when i implemented composition i saw quite a slow down. (see the graph halfway down)
fwiw, i [bm'd](https://github.com/mooreniemi/experiments/blob/master/lib/funkify.rb) it: https://github.com/mooreniemi/experiments/blob/master/lib/funkify.gif 
Logical operations with boolean expressions 
Try Typhoeus and see.
I wonder if this varies between servers. It probably depends on the directive, too.
I just do this: module BookKeeping; VERSION = 2; end
I'm not sure where you are in the exercise in terms of getting tests to pass, but here's how to do this particular part in a gist. https://gist.github.com/Andrewsh86/16f4baf12ccb33a8713fdfaa5e7c2a9e An explanation: In the test file, on line 4 you're requiring the hamming.rb file. Any classes or modules in that file will be loaded and available for use in the test file. You *could* achieve the same thing by defining the module in another file in the same folder as the test and then typing "require_relative '&lt;whatever you named the file&gt;'" in the test, but don't do this as that's not how exercism wants you to do it. I just bring it up to illustrate my point that require and require relative just load classes and modules so that they can be used by the requiring file. Edit: I've done over half of the ruby exercises and I've never had to do anything else but just tag on a module to the beginning or end of my file to get the bookkeeping tests running. there is one that's tricky and actually wants to the version in the class you're creating and not in a module, so keep an eye on that. I don't remember which it was.
I don't think allocations or performance for any of this code would be an issue in practice. And if performance/allocations were an issue and the code was wrapped in a tight loop i wouldn't use any of the approaches at all, i'd resort to something much simpler.
[removed]
(btw hope i am using the right tone here, i'm super flattered you're even talking to me--your work is awesome. not trying to insult you!)
[i started with that actually](https://github.com/mooreniemi/compose/blob/master/Compose.c#L31), but here's the rub: i have to then allocate an array for every second call* because `rb_proc_call` [demands an array](https://github.com/ruby/ruby/blob/598fd0cd944a2b830adbfa4ba3d8b91af09b85a7/proc.c#L842) (i got seg faults otherwise). i couldn't figure out a way around that except using `rb_funcall`, which was in fact faster when i graphed it out. :c thoughts? *in the code i linked to youll see i abandoned that direction before i even reduced it down to a single array. i gave up when i couldnt figure out how i could get rid of the other array and moved on to `rb_funcall`
Yeah perhaps more junior Rubyists tend to do it because I've seen it a lot. I know I've gone through at least a tutorial or two that have shown off the effects of "daisy chaining" methods to a calling object. Wrapping is definitely safer though. There is no worse hell in the Ruby world than trying to find what is causing that nil:NilClass exception.
String literals evaluate to true and the OR shortcircuits. So it's basically returning "a" 
ORMs are fine until you need to scale.
[removed]
I wonder how does it affects throughput.
While I agree with the sentiment, the examples are so horrible, that the point is missed entirely: class User &lt; ApplicationRecord has_many :orders def commit_orders_for_warehouse(warehouse_code) #... end You know wat? Problem is not slowness of transactions here, and certainly not the potential locks stemming from that! The problem is that the `User` is dealing with `Orders` where it should not. Ever. (the S in SOLID). Were you to solve that, for example in a `CommitToWarehouse` service, or a `OrderPlacement` model (mind you: not nessecarily a Record) you would not have the problem, or, at the very least, have a logical and simple place to fix it. The problem most often is not Rails, not ActiveRecord not the MVC or ORM patterns it uses. The problem is people using it wrong and then placing the problem arising from that on the shoulders of Rails, ActiveRecord, MVC or ORMs. Edit: I am not saying you cannot ever have problems in the SQL that AR generates for you:I've seen far too many examples to know how wrong AR can be. But your knee-jerk reaction should be to refactor code into places where it belongs: get rid of `through`, drop callbacks, remove associative validations, evaluate -very carefully- if any record is dealing with other records that are not its immediate neighbors. Then do that again. Extract into more models, introduce extra records, think about adding a Services Layer, or at least defer a lot of work-logic into Jobs. A model should do only one thing: deal with its own (scalar or value) attributes using business rules. A Record should do only one thing: manage that same data in a database; with maybe a scope or two and a validation here and there to ensure stuff does not break. A `User` record is certainly the wrong entity to deal with placing orders in warehouses. The problems OP tries to solve are a typical example of problems coming from breaking the SOLID principle and putting far too much logic into the Model layer in the first place, and then placing it in the wrong classes makes that even worse . By no means do they stem from the ORM being stupid.
Thanks. I'm thinking of rewriting it from: class User extend IncludeModule include_module UserMixin, included: true, instance_methods: [:name], class_methods: [:top_user] end To make it more explicit: class User extend IncludeModule extend_module UserMixin::ClassMethods, methods: [:top_user] include_module UserMixin, included: true, methods: [:name] end 
This is pretty amazing. Maybe this can be incorporated into rails core somehow
https://github.com/NullVoxPopuli/skinny_controllers implements the operations pattern UserOperations::DoTheStuff.new(...).run there are also 'Service Objects' (Gross) But DoTheStuff.new().perform would be ok. When you said command, I was initially thinking something like https://github.com/NullVoxPopuli/meshchat-core/blob/master/lib/meshchat/ui/command/base.rb https://github.com/NullVoxPopuli/meshchat-core/blob/master/lib/meshchat/ui/command/chat.rb
Added `INCLUDED` part in order to use nested modules as [ActiveSupport::Concern](http://api.rubyonrails.org/classes/ActiveSupport/Concern.html) does. I don't really like using this constant, but IMO it's better than overriding Ruby methods :)
It was requirement for tester job I was going to apply.
Then probably this job requires decent knowledge of Ruby. RSpec is a tool of unit testing mostly, it requires understanding the code you are testing.
Yeah, thanks, completely forgot about the most obvious option!
Thanks for explaining. 
Well. That's a very good point actually. You can do both. If you have a completely installed and working folder, you can upload the whole thing to the instance and just run that. That will work nicely. I think the upload uploads the folders content, and not the folder. I just realized that the minecraft.jar must be under /home/ec2-user/data. If it's under /home/ec2-user/data/yourfolder it won't find it. :/ It should look for the folder that you uploaded. I'll create an issue for that and fix it later on today. :) If you would like to do that on the server, you'd have to ssh in and do it by hand. ( copy the right files into the plugins folder. ). So to answer, yes. I think the easiest is if you have configured folder, just upload the whole thing. That should work. :) I'll try that out tonight, so I'm not saying something that is untrue.
FYI you do pay for outbound data.
First, you should really decide if you want command object passed to a different layer (command handler/bus/service/interactor whatever the name) or command which is also responsible on its own for the execution. For the 1st usecase, just specifying the attributes, converting and so on I recommend dry-types or virtus.
I suppose if you require all that then it makes sense, especially if someone else has already taken an approach that robust. Thanks for clarifying!
See reply above: https://www.reddit.com/r/ruby/comments/55n2se/good_command_object_pattern_implementations/d8c2hrc
ah alright, it's been a while since i've messed with the C API, carry on :)
&gt; In fact, there is a lot of requirements to good command object. I don't agree. It honestly sounds like you want a lot of different concerns "baked in" to your command objects. But that sounds like a cohesion problem. Using lifecycle hooks for logging? Questionable, but not unreasonable. Lifecycle hooks for authorization? You have just crossed a line into non object oriented programming.
It isn't really a problem. Your code is running to completion, and then closing, because it's done. Try adding `gets` to the end of a file. That's the method to wait for user input. Then look at running programs from the terminal/command prompt. 
If you want to "see" it running you can throw some "prys" in. http://pryrepl.org/
If you have a module you only want to include parts of your design is unclear. Instead of using the above re-evaluate which methods work together and make smaller modules
The examples are a bit contrived, admittedly. I don't think that the fundamental problem, however, is the (lack of) separation of concerns, which is what I think you're suggesting. No matter how well-organized your models are and how adequately boundaries are established between them, problems like the lock mutex I described in the article can still arise. Ultimately, I think it's more a problem of perspective: we (developers) live in Rails world (or more generally app-tier world), and we aren't always acutely aware of what's happening outside of it. &gt; The problem is people using it wrong I think I agree; more often than not, bad coding behaviors are what get us into trouble. Having said that, sometimes even good coding behaviors are vulnerable. We just can't be ignorant about what happens outside of our code, ultimately.
Having updated ruby through homebrew this morning, rubygems is now functioning as expected.
Splitting queries and mutations seems sensible to me as well. Thanks for providing more details about what you had in mind. I won't let you get away with the following, though. :P &gt; Simply copy-pasting it into a Concern: nothing. &gt; If your problem is with ActiveModel::Model being too much, and not SOLID: good news too: it is actually little more than a convenience module that simply includes a lot of other modules. If moving code into concerns/modules is a non-solution to design issues, why doesn't the same apply for ActiveRecord?
Try checking out https://github.com/cypriss/mutations. We have a team of 25 or so using this, and has worked out very well for us. 
If you can make it to Kyoto - optimally planning a vacation around it - RubyKaigi was an EXCELLENT conference in a beautiful area. Seriously consider it next year!
A command has a single concern -- carrying out some task. Which users have permission to do so is another concern. Consider that you have to depend on the user to answer that question, and thus the user -- or some representation of her permissions -- becomes a dependency of the command object. It is better to use another command object to authorize the user for a given action, I think. Another unrelated concern I see being shoved into command objects by frameworks is translating form data into Ruby primitives. This does not belong in a command. I partly blame ActiveModel for convincing rubyists that every object must be prepared to be wired up to a web page.
Thanks! Will take a look.
Thanks, I'll take a look. To be honest, I have a hell of experience with our homebrewed Command objects, and a hell of opinions about it :) Now I'm looking around how it is done elsewhere (our internal thing can't suit another internal project the best way possible), but it would not be that easy to change my views completely.
yes, you have an old version of rspec. Are you using bundler to manage your gems? You should be. Use RVM to manage your ruby version, use bundler to manage your gems. It's tough to give you any help without seeing your code. But with rspec 3+ you don't use should statements you use expect statments. [Relevant reading](http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/) In some cases the rspec core will need updated. This is where bundler helps.
To be honest, matters are pretty complicated here. What I've listed as an "expected" Command object functionality was just a list of what our current homebrewed solution do, it works pretty well, but it is part of a codebase, not a separate gem. For me personally, there is everfighting set of "ideal architecture" considerations and "pragmatic" considerations, and those YAGNI/KISS/DRY/SOLID/younameit angry daemons. So, discussing the spherical command in a vacuum, I could agree authorization is something outside of command's responsibility. But in reality we almost never have a deal with "clean orthogonal" patterns, it is always some compromises, and some derived pattern composition and so on.
thanks a lot for your help! i will look into bundler and RVM (i think i'm using something called rbenv?) here is my solution code (silly_blocks.rb): def reverser yield.split(" ").map {|word| word.reverse}.join(" ") end def adder(num=1) yield + num end def repeater(repeats=1) repeats.times do yield end end and here's silly_blocks_spec.rb that the testfirstruby people pre-made: require "silly_blocks" describe "some silly block functions" do describe "reverser" do it "reverses the string returned by the default block" do result = reverser do "hello" end result.should == "olleh" end it "reverses each word in the string returned by the default block" do result = reverser do "hello dolly" end result.should == "olleh yllod" end end describe "adder" do it "adds one to the value returned by the default block" do adder do 5 end.should == 6 end it "adds 3 to the value returned by the default block" do adder(3) do 5 end.should == 8 end end describe "repeater" do it "executes the default block" do block_was_executed = false repeater do block_was_executed = true end block_was_executed.should == true end it "executes the default block 3 times" do n = 0 repeater(3) do n += 1 end n.should == 3 end it "executes the default block 10 times" do n = 0 repeater(10) do n += 1 end n.should == 10 end end end so it looks like i either update the rspec syntax, or i figure out which older versions of all the gems that will work? got to admit, i'd rather do the latter so i don't mess up the test code
The lunchtime video is especially riveting (PS. is this the same Argus/[real name redacted] who I met and had lunch/dinner with at RubyKaigi? If it is, small world. I tried to add you on PSN but some privacy setting stopped me. :()
One more vote for "make it a small class with few responsibilities and a common interface". My requirements 1. live in /app/commands 2. Adhere to same interface `CommandObject.new(params).run` .. or `CommandObject.run` which still instantiates and delegates to an the instance method. 3. Accepts very few parameters. That's pretty much all I've ever needed. Of course YMMV.
You see, for me, there is always some balance. Of course, "every-your-favorite-pattern-alread-implemented" frameworks are doomed (in my head, in reality could be pretty successful, have somebody said MVC or CQRS ooops sorry). But at least looking at (probably using, probably not, but at least investigating) how others are handling some abstraction can be insightful. And, probably, sometimes it really _can_ lead to some really useful library. Or so I hope. (At least, links to mature libraries in this thread _are_ helpful: I can understand, what is close to our needs and what is outside the border of actual pattern, and think cleaner about what we need to find OR implement.)
I don't completely buy that. Used correctly (i.e. keeping your memory footprint low, keeping queries well-tuned, some other best practices), a good ORM adds a pretty small overhead to your app's response time. The most recent Rails app I built has an average response time of 60ms with pretty high throughput, and about 50% of that time is spent in Ruby. If those 30ms are precious to you, your requirements as a product probably preclude using a framework like Rails in the first place. If you're Facebook, build your own C compiler, write your app on punch cards, displace hundreds of low-income families and build Earth's largest data center. For everyone else, there's ORMs. And Mastercard.
I _want_ to reason about business operations in a spherical vacuum. Adding in other concerns is what prevents us from being able to do so. The codebases that isolate concerns as a rule are extremely rare, and a lot of teams will feel more comfortable with ActiveRecord style "super objects." I think you miss out on the elegance of the pattern when you take that approach. My experience has borne this out.
When was this? I was just in Kyoto last week!
It was September 8-10. But good that you got to go to Kyoto! What was your favorite attraction?
Oh, I should have been more clear ... `/app/commands/` is a dir. I would never shove them all into one file :)
 I got to see Koichi Sasada give a presentation on Guilds at RubyKaigi this year, and it looks super promising. I can't wait for some more concrete implementations to come out - I'm not sure my foo is strong enough to attempt it myself, but who knows!
I know a lot of people don't like `subject`, but I like it in certain situations â€“ specifically, when you're testing multiple aspects of a single object, without much nesting. It's nice to see, right at the top of the test file, a line that says "hey, this is what all the following tests are about."
Well, I think I typo'ed. I mean... I don't have an `app` directory with subdirectories named after patterns like "`app/controllers`" or "`app/commands`." That kind of directory pattern will cause concerns to get split up into directories. For instance, it might lead to `app/controllers/orders_controller.rb` and `app/commands/place_order.rb`, when I'd rather have something like `app/orders/controller.rb` and `app/orders/place_order.rb` -- this is a crude sketch, in reality I use `lib` as the top level directory.
I don't understand your point. The issue here has nothing to do with code organization (nor an ORM actually), it's an issue of two-phase commit with slow external resources that are part of that transaction which is just not an easy problem to solve. The 'solution' in the post isn't a solution, it's a temporary bandaid that will last until the remaining locking behavior becomes problematic. In the case of the example, the better solution is to put a temporary hold on the effected resources and resolve or fail it asynchronously. 
The suitability of an ORM for large scale applications is impossible to assess _in general_ because the mapping of objects to DB schema isn't predictable or consistent between projects. Many applications primarily consist of _data entry_ -- where users enter information into the system, and that information is presented elsewhere in the application according to the same general shape it was entered. Basecamp is a great example of this. Such applications can scale well on top of an ORM because of the inherent symmetry between reads and writes. Where ORMs become a bottleneck is when the presentation layers and application state layers diverge. This can occur when there is a time dimension -- for instance, versioned entities. Consider this form of question: "okay, but what was the price of the item _at the time of its purchase_?" The answer is almost always to _copy_ the price of the item when the purchase is made, but that won't be as simple once you need to copy more than a single primitive value. To make matters worse, code can accidentally be coupled to the copy of the pricing data if it happens to already be working with orders, since that's the more convenient number to use. Complex operations tend to beget consistency problems when ORM usage is pervasive. It can become necessary to wrap larger operations carried out by a constellation of ruby objects in a transaction to maintain consistency. This generally clocks in at O(atrocious) if you do the math. Another scaling issue that can arise with ORMs is the influence that presentation and reporting have on object design. Charts, dashboards, reports, etc. tend to couple freely to the entire database schema. This effectively acts as a cross cutting impedance that makes changing database schema very difficult -- which _in turn_ makes changing your objects difficult, since the object has lifted its own internal structure off of the database schema itself. So, I don't agree with /u/burning1rr as I don't think their position is all that nuanced or even explained sufficiently, but I'll say that I think ORMs are a dead end for data architectures that need more than simple regurgitation of data that has been previously entered. I think a lot more of our web apps would do better without an ORM than with one. On its best day the ORM just saves you time writing queries yourself. On its worst day it handcuffs your entire data architecture.
I expanded on my answer in my own reply. I haven't looked closely at the use of ORM for simple store and load operations. My familiarity with them comes from the operational issues and reading on the DBA side of things. A major problem in application development is that database loads often increase non-linearly with dataset size and query rates. In those cases, extremely careful design of queries and indexes is very important to your ability to continue growing. At very high loads, queries can be designed with the underlying SQL servers characteristics in mind as well. The problem with ORMs is that they simply don't provide that flexibility, and going the OEM route can paint you into a corner if at some point in the future you need to switch to highly optimized SQL queries. Of course, as you point out, keeping to ORMs as simple object stores significantly mitigates thilese issues. However, if you do try to use an OEM as a full replacement for more traditional types of queries, they can produce some really bad and poorly optimized queries. With all that said, if you are building a simple application, why not back it using a JSON database? MongoDB isn't popular here, but PostgreSQL has first class support fo JSON.
I loved all of the temples that we went to, and already really enjoyed walking around the Kawaramachi shopping area! Great city.
 "a".include?("a") #=&gt; True "e".include?("a") #=&gt; False soooo interesting, why is it this way?? 
thank you for this. the really terse solution got tons of upboats but just wanted to say i prefer this sort of reply bc it walks me through the steps, and i was hoping someone would post something that's similar to a while loop iteration the way i think, while loops work better for me right now, bc you can tell the loop to, say, iterate through 6 elements and stop before rest of the elements get looped on. that's not possible in ruby i'm guessing?
did not mean to use it. it was already there in the editor when i started on the solution to the problem on hackerrank
[same thing i told this redditor](https://www.reddit.com/r/ruby/comments/55bfhm/whats_the_ruby_way_to_solve_this_problem/d8d72ny)
Ditto! The area in and around Kyoto Station was awesome too. Lots of shopping and dining and it's all good!
Regular English prose. describe "Apparatus" do describe "Performing some task" do specify "Some task is performed" do end end end
Right on, I see your reply now. Good stuff!
Ah-HA! Gotcha. Can't say I am personally a fan of this approach but that's completely beside the point. Simple and consistent is better than convoluted and cute. Let's just say if I came onto one of your projects I would stick to the convention and keep on shippin' ;). It's all good.
Hn discussion (some very good pts on why and why not use something like this): https://news.ycombinator.com/item?id=12632646
Where does the OP say anything about Active Record? And even in that case this works so I don't know what's "not even close" about it.
so i wrote a c extension to allow `proc * proc` composition. but i had expected it would perform better than a linear chaining of `map`. any folks familiar enough with ruby's c api / implementation to offer advice on how i could improve it? `rb_proc_call` was considered too, but would require too many array allocations. using `rb_funcall` performed better. (see https://github.com/mooreniemi/compose)
Pretty impressive for you to have divined all that from the OP. Why would he need that for an example like gender?
Male = 0x01 Female = 0x10 Trans = 0x11
Then you can be a smart ass and determine whether or not a dick is present.
Shameless plugin. I wrote a gem not so long ago with that exact purpose in mind and even if you don't use it I would be glad if you had a look at it and gave me feedback. :) https://github.com/pyzlnar/aye_commander
The network calls were really just an embellished way of illustrating the bottleneck introduced by the locking. I've worked on an inventory system (no two-phase commit happening, just a single DB) that had very high throughput, and the locking in a join became a very serious, unseen performance bottleneck. In that case, the solution in the post is the solution, not a band-aid at all. The two-phase commit/transaction nonsense is a very different problem which I never intended to solve in the post.
Interesting. Would love to hear about this in more detail. If you have any examples you can provide, let me know!
everything you've said totally makes sense and this ['a','e','i','o','u'].include?('a') solves my problem but my original question (that screenshot), why that's happening -- still not sinking in. what's it called, can i google it to get more sources on the matter, rather than bothering you over and over again, feeling bad
I couldn't be happier for you all. Phusion has always been one of my few role models building a business in the Ruby space: engineer-focused with little marketing aside from building the best OSS product they can. Passenger Enterprise was my main influence in introducing Sidekiq Enterprise and the formula worked for me too: I'll be over $1m/yr ARR next year. One key takeaway from the article: sell a product or service, not your labor. Freelancing can bring in immediate money but requires one hour of work to get one hour of wages and so can't scale past N hours/week. You'd be amazed at the niches that can provide steady income. [Here's a guy making a living selling automated S3 log processing](http://www.expatsoftware.com/Articles/amazon-flipped-a-default-and-made-me-thousands-of-dollars.html).
I think what might be confusing is that there are two functions with the name include? One if the object is a String. https://ruby-doc.org/core-2.2.0/String.html#method-i-include-3F And the other is include for Arrays. https://ruby-doc.org/core-2.2.0/Array.html#method-i-include-3F Look at the examples. The first is used to see if the argument is a substring of the original object. The second is used to see if an array include a certain item. Especially look at the fact that both these methods only take one argument. You cannot pass more than on item to the function. I think this is what confuses you. You can only pass in one item, but you thought you passed in many, when in face the expression (a||b||c||d..) was evaluated BEFORE being passed into the function call. Hope that makes sense.
Arrays in particular let you select ranges of elements by putting a [Range](https://ruby-doc.org/core-2.2.3/Range.html) inside bracket notation: `ary[0..2].each {|nn| puts nn}` prints the first three elements of `ary`. Enumerators in general support the [take](https://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-take) method for grabbing the first n elements.
What would be the network output on that? And disk I/O? I think 8Gigs are better for 4-5 players. Especially with java being a resource hog that it is. :) But maybe 4 are enough. :)
Not sure if this is what you're looking for: https://www.linode.com/pricing For 8 gigs you would need the $40 package. Hopefully my post didn't detract from what you built, as a Minecrafter, just wanted to mention the option. Minecraft might need more RAM these days, not sure, haven't run a server for over 2 years.
For clarification: I want to work with a very large set of sequential data that has been shuffled. Each element of the array is unique. I'm trying to avoid actually generating the array and then shuffling it, because I feel that would not be efficient at a large scale. As an example: say I wanted to work with all possible 6-character combinations of the letters of the alphabet in both cases (e.g. 'aaaaaa' through 'ZZZZZZ'), but in a random order; generating all combinations into an array and applying a shuffle would be silly. So I was thinking either a Linear Congruential Generator or a 1-1 Function...
Cheers! I've been always a fan of Phusion and have been using Passenger for years.
Holy crap dude, that interpreter is enormous. The whole point of Brainfuck was that the compiler could be written as tiny as possible. Brainfuck can be translated into C very easily by means of some setup code and substituting each character for a specific C instruction. So it should be possible to translate it into Ruby by means of a few gsub operations and an eval. Or maybe a case statement and a loop. In the spirit of Brainfuck, make things as simple as possible.
I know that bf interpreters can be very terse, but I'm not sure if this qualifies as *enormous*. The core of this is just a simple case statement and loop, as you suggested. I could shorten it further by taking the core logic out of the class (which is an unnecessary wrapper). What do you have in mind for translation using gsubs?
nice post to make parslet a bit more popular
Hello, John. I'll chime in with my thoughts on your code. Forgive me if I highlight the parts you need to improve on first, it's just that I'm not entirely aware of the immediate positives. 1. This would certainly be better built and understandable if you were using a gem template. Bundler certainly has a way of doing this with `bundle gem -b &lt;name&gt; `. `-b` creates a binary that gets added onto the PATH. While not mandatory, the conventions make the project more maintainable for everyone. 2. Related to the previous, writing and running tests should prove far easier as well, you shouldn't have to create your own test runner. See more on writing Minitest tests [here](https://github.com/seattlerb/minitest). 3. I understand you wanted to draw something out quickly, with little regard to structure, which is fine in the beginning. Maybe you should improve the overall structure by separating some concerns. For instance, the State class should be in its own file, separated from the [actual running code](https://github.com/Datamine/Rubeef/blob/master/brainfuck-interpreter.rb#L81). 4. Your constructor should set variables that it gets and no more than that. You're instantiating several variables that are not passed in. The latter should be memoized in methods. One example for the `tape` variable could be the following, where you set a default value. Either this or would use a default value in the constructor for later overwriting. def tape; @tape ||= [ 0 ]; end (formatting is trolling me) 5. One thing that I found *really great* about this is that you extracted away the IO dependency from the code. Many beginners commit the mistake of putting everything in one place but what you did was smart. Well done. Other than these, it's just a matter of keeping improving on your code with little refactoring and code narrative. But that's for another day. Best of luck! HTH.
If you were asking for feedback on your use of Ruby, then don't listen to this guy. I had a look at the code, and it's good old, straight-forward Ruby. If you were asking for different ways to implement a Brainfuck interpreter, that's a different story.
Are we looking at the same chart? Unless you count all of 2.x.x as new, 80% are a year behind or more. 
If I worked on a project that was using a year old version of Ruby, it would mean that I was trying to upgrade the whole time and either a) management shut it down or b) there was cruft preventing the upgrade of such magnitude that it was too much work to upgrade. I've seen both cases and those projects are probably still stuck on whatever version they were on at the time I was there. Edit: There have been Ruby versions that were a bitch. 1.8 -&gt; 1.9 was dangerous. These days it's pretty innocuous, and you do have a test suite, right?
Thanks for explanation ezrast and Randy, I sure did mix things up. Coming from web oriented lang (php), my approach was slightly wrong, now I understand better. And also, ri looks nice, line man pages. 
Don't forget that enumeration methods can return an `Enumerator` if no block is given, allowing you to chain them in interesting ways: (1..6).each_cons(2).map { |i,j| j - i }
We are talking about Ruby here. I am aware of the schism in the Python world, but keeping my distance.
&gt; ruby is a very small bubble in software development world What do you mean by that? And what does it have to do with this discussion? &gt; by and large 2.x.x does count as new almost anywhere outside that bubble. Why would Ruby devs care what non-Ruby devs think is recent?
&gt; One of the things I love about the ruby community is how smoothly it adapts to new versions geez, how quickly people forget what are they even commenting on
[GIFV link](https://i.imgur.com/WmQoL.gifv) --- _^I ^am ^a ^bot. ^[FAQ](https://www.reddit.com/r/livven/wiki/gifv-bot) ^// ^[code](https://github.com/Livven/GifvBot)_
A number of things were removed. In 1.8 block parameters didn't shadow outer variables, which meant you could do stuff like assigning to a variable when a block was called like this: a = 10 test = lambda do |a| "do nothing" end test[20] puts a # will print 20 in 1.8.6, will print 10 in 1.9 which you can't do in 1.9, I remember some code breaking because of stuff related to something like that (although I think the actual issue was slightly, something like `lambda do |@something| ... end` which assigned to the instance variable). Something else that broke a lot of our company's code was the change to `case blah when condition: .. end`, which became invalid in 1.9 (now you have to use a semicolon, the `then` keyword or a newline).
I would prefer `Enumerable#each_cons` as it would return an array to work with. &gt; (1..10).each_cons(2).to_a [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10]] &gt; (1..10).each_cons(2).map{|a,b| b-a } [1, 1, 1, 1, 1, 1, 1, 1, 1] &gt; (1..10).each_cons(2).map{|a,b| "#{b}-#{a}=#{b-a}" } ["2-1=1", "3-2=1", "4-3=1", "5-4=1", "6-5=1", "7-6=1", "8-7=1", "9-8=1", "10-9=1"] 
Ruby abi changes make things a bit more complicated, but that doesn't happen every upgrade.
Give Array.select a look. 
 def dash_insert_ii(num) num_arr = num.to_s.each_char.map(&amp;:to_i) num_arr.each_cons(2).map do |subject| joiner = if subject.any?(&amp;:zero?) nil elsif subject.all?(&amp;:odd?) '-' elsif subject.all?(&amp;:even?) '*' else nil end "#{subject[0]}#{joiner}" end.join + num_arr.last.to_s end
wowwww, i've avoided #inject like the plague but this really puts it in perspective, mucho gracio
You could just have it print each map step: ...map do |subject| joiner = if ... end result = "#{subject[0]}#{joiner}" puts "map step = #{result} result end.join + num_arr.last.to_s 
List comprehension. :) def DashInsertII(str) head, *tail = str.chars.map(&amp;:to_i).chunk_while {|a,b| a%2 + b%2 == 1}.to_a (head + tail.map {|e| [e[0].odd? ? "-" : "*" ,e] }).join end expect(DashInsertII("454")).to eq "454" expect(DashInsertII("4546793")).to eq "454*67-9-3"
[Awesome Ruby](http://awesome-ruby.com) *is* awesome. I've been cracking my head for ten minutes trying to remember the always-out-of-date, never-quite-what-I-was-looking-for site that was the go-to Gem referral site before Awesome started up. I still can't, and I can't see how that's anything but a Very Good Thing. They also have a [GitHub repo](https://github.com/markets/awesome-ruby) with a very active community submitting PRs for things they've developed and/or stumbled upon. Check it out! TINRAFOCR, IANALNDIPOOTV, no proprietary interest exists. LSMFT.
Nice, but now you have two problems :)
Lots of good stuff. But a bit long and rambley. I suggest you break it into multiple posts
If your proposal is a new project in itself, do you have to send an existing early version of it, or a detailed plan/proposal is enough?
Mine was just a text + link to one small (to that moment) auxiliary gem I did for the upcoming project, IIRC, I had not a single line of code to the moment of proposal.
&gt; Also did they contact you for clarifications(before/after the selection) ? Nope. To be honest, there is really small communication with Grant Committee, it was just "OK, you are selected", "OK, your mid-term report is received", "OK, your final report is accepted", "OK, here is your money" kind of dialogue. &gt; Btw, I think I watched you on Euruko, you talked about that project, right? Yeah, and failed miserably :) But it was just a first attempt, I can do better.
As a person who came to Rails/Ruby late, this post contains a lot of cultural information I missed.
Let me guess, you're coming from PHP? There's no built-in way in ruby to connect to a MySQL database -- there are potentially several different libraries (not included with ruby standard library) that do that. If you're doing Rails, there is Rails docs. If you're not doing Rails, I recommend checking out [Sequel](https://github.com/jeremyevans/sequel). Even if you plan to eventually use Rails but for now are just playing around with (non-web) scripts, I'd suggest starting with Sequel, just know when you switch to Rails you'll do database access slightly differently. I'm not sure what you mean by 'date function', what date function? The ruby Date class is doc'd here: https://ruby-doc.org/stdlib-2.3.1/libdoc/date/rdoc/Date.html There isn't a 'date function', but there's a date class with a variety of methods. Best way to approach learning ruby, in my opinion, is to start out learning the language as a language -- don't worry about complicated things like database access, just learn the structure of the langauge itself. Including Object Oriented programming if you havne't done that before (how classes and instances work), and also things like blocks for instance used in `each`. Write some simple command-line scripts to test it out. Only then move on to database connections and web apps, using Rails if you like or something else. 
I wouldn't say that. In fact, it was a great decision to start with, it just hasn't kept up with time. 
And it also *can't* keep up, because as the post indicates, build tools written in JavaScript will naturally be better than the ones written in Ruby, because they can be contributed to without the knowledge of Ruby, making them accessible to *all* frontend developers.
True. Nevertheless, when the asset pipeline was written, it was still a good idea. Because Node.js didn't even *exist*.
Except tools written in Javascript aren't aware of Ruby and Ruby features. They can *never* be integrated with Rack, they can *never* be properly integrated into Rails helpers, they can *never* be tinkered from Rails itself.
Nope, they will be written by those who know Javascript only, and as history shows this is never good. Just half kidding.
Look up "opinionated"
Looks like you are confusing Webpack and Browserify. What you are saying about Webpack and CSS is mistaken. 
Look at Linus. I don't mind nice, but it's not the only way. 
Sprockets, in terms of capability, is obviously an inferior product to Webpack. I'd love to see the asset pipeline in Rails become as pluggable as test frameworks are. However, this article glosses over a bunch of problems with Webpack (and instead spends 90% of its time making bizarre extended analogies about Japanese culture and calling you a sexist for not liking Javascript): * **It's the asset pipeline equivalent of a nuclear aircraft carrier.** It's awesome, but it's complexity (that is *exposed to the user*) is immense. Sprockets is complex *under the hood*, but the interface presented to the user isn't really all that complex. You can learn all you need to know about Sprockets in order to use it in like 5 minutes. [Webpack's config file has it's own linter.](https://www.npmjs.com/package/webpack-validator) * **Webpack has one maintainer.** Yes. One. So while Webpack isn't abandonware now, what happens if Tobias gets hit by a bus? I'll tell you - Webpack is dead. Tobias has 1500 commits to Webpack. The #2 contributor has 20. That is not a healthy situation. You're replacing an asset pipeline that *is* abandonware with one that *will almost certainly become abandonware* when the creator inevitably burns out and goes back to their full-time job. * **The docs are not great.** Here's some comments left on Webpack's docs page: "The document is so obscure." "it feels like rocket science" and "It makes me like a stupid". The maintainers of Rails are not, IMO, suffering from NIH for looking at this tradeoff and thinking "sticking with Sprockets is the best thing for our users right now." 
Read POODR. It helped me level-up when I felt like i was stuck. 
Giles is Ruby's crazy uncle that yells offensive stuff at xmas dinner. 
Might as well ask what's the best flavor of ice cream. Or the best spot to vacation at. It's up to you. Try them out for yourself and decide. I like rspec a lot but DHH famously hates it.
Having made that transition earlier this year, I'll say that ember-cli-rails is a huge step up in environment quality. Highly recommend trying to make that switch soon as you can.
take a look at the nascent sciruby efforts. myself, i stick to R for serious computational stuff. 
Build a Rails clone on top of Rack. It doesn't have to be full featured, but it should have a similar API (routing, config, controllers, views, basic models). It will help you understand both what goes into writing a web framework, how to write Ruby in a Railslike way, and might help solidify some concepts.
Sorry to say that, but Sprockets already depends on Node.js, via ExecJS. I don't actually know for what exactly, but I think that you definitely need it for compiling CoffeeScript.
If you are having any issue understanding why people are asking you to quantify exactly what you mean by "readability", consider writing a program that detects "good" food, or "fun" activities vs food that "contains bacon, is deep fried and salty" and "the most active ski resorts in north america by revenue". 
Add pandas to that list. Makes data tables act like r dataframes. 
That's exactly why Webpack is an inferior tool for me. You have to jump through so many hoops to do something very common, you'll have a better time just setting up your own stylesheet pipeline. And by the way, I tried this plugin. It didn't work for me because the plugin's authors don't keep up with Webpack versions.
@mperham The most reliable gem in my stack, processing a gazillion jobs, without any problems ever. You are awesome dude. Thanks!
Time would be better spent on Opal.
Hi, i'm the one who wrote the spaghetti code for lazydeejays in rails thanks to the excellent messenger-ruby gem. Keep in mind this is mostly spaghetti code but it kinda showcases how easy it is to build a bot in a day.
Here's [a gem](https://github.com/cameronsutter/odyssey) that does it.
you can't go wrong with learning minitest. you can adopt rspec later if your needs aren't met. 
Congrats for winning Vienna's 1st Bot Hackathon and thanks for sharing the code even if it's all spaghetti ;-) Cheers.
There is nothing worse than trying to figure out someone else's code and JFM (Just Fucking Magic) to understand where a problem might be and if it's a matter of bad input parameters or an actual bug. I believe you should give short explanations of what's expected in and out of functions when the data in and out is not trivial.
Googling rails poodor got me nowhere. Can you share with me what the POODOR book is ? Edit- it would help if i typed it right lol. I got it :)
So, Giles isn't exactly _wrong_, but I have a different way of looking at the same phenomena. I view Rails and Ruby as two distinct cultures. Rails just happens to rely on Ruby to make it run. Kinda like IBM Notes and NodeJS are totally different cultures, even if they both use a server-side JavaScript runtime to power web applications. Rails culture is full of abrasive personalities who make terrible decisions and don't believe in documentation or stability. Ruby culture is much more polite, but the documentation is sometimes only available in Japanese and there's a bigger tendency for drama.
The complexity of webpack is a serious issue for me. 
Thanks y'all. I started messing around with SciRuby, and I think it'll be hard to beat numpy/scipy/pandas. I thought numerical analysis would be a good starting point for me to learn a new language since I am already highly familiar with these tasks. Thanks for the input!
Yes. This article makes some very good points. Far too many developers just do whatever they like with little regard for practicality. This always end up with an messy patchwork of different languages, libraries, tools, and styles. A good programmer will match existing style and write for readability and maintainability. 
I'm not convinced it helps. I see another line and I think it's a different line. You're then left with a different kind of cognitive load.
Z3 is a tremendously underrated system. This is great to see. 
&gt; short explanations of what's expected You mean unit tests?
[Related talk on the subject.](https://www.youtube.com/watch?v=FKTxC9pl-WM) Fun presentation and mostly factually correct.
&gt;&gt; CSS modules don't require Javascript all &gt; Really? Because my experience tells otherwise. Then your experience is incomplete. CSS modules is a concept, like BEM or SMACSS. It's just mapping CSS class names to be locally scoped to a specific module/component. It can be implemented anywhere, and it doesn't matter if that view is rendered server side in ERB or client side in a React component. It is, however, implemented by webpack's CSS loader and that makes it very easy to use from JavaScript code. That's an upside to importing css through your JS code, which is why I pointed it out in the first place. &gt;&gt; As myself and others said, you just need to configure webpack to extract the CSS at build time if that's what you want it to do. &gt; Again, using a third-party plugin that doesn't always keep up with the Webpack versions and requires jumping through configuration hoops. [ExtractText](https://github.com/webpack/extract-text-webpack-plugin) is not a third party plugin, but it is installed as a separate npm package like every other first party webpack loader/plugin. Adding it to your webpack config involves just removing the style loader you didn't like and adding 2-3 other small changes. I'm not sure what hoops you are talking about, but it's fairly straightforward and for the last two years I've never had a problem with it. &gt;&gt; No tool is a silver bullet. &gt; Tell that to the author of the article. Not even sure what you're trying to say there. I was talking to you. You seem super upset/antagonistic that a JavaScript module bundler doesn't do its job if JavaScript is disabled. I'm pointing out to _you_ that webpack is not a silver bullet, and if progressive enhancement is something you need, then it might not be the tool for _you_. That doesn't make it a bad tool.
&gt; I'm not sure what hoops you are talking about, but it's fairly straightforward and for the last two years I've never had a problem with it. Uggghhh, the whole "I have a leg and it ain't broken" thing. I remember having problems with it when I tried it. Sorry, can't remember the version right now, it was quite some time ago. That's why I assumed it was third-party. And yes, I still consider stuff like installing a plugin and copy-pasting a bunch of config "hoops" when it comes to a task as common and trivial as concatenating a bunch of CSS. Heck, you can look at its Github issues page and see that this plugin has loads of problems, including (apparently) problems with SASS and PostCSS. How is it better than rolling my own CSS pipeline with literally anything else again? &gt; You seem super upset/antagonistic that a JavaScript module bundler doesn't do it's job if JavaScript is disabled. No, I'm only upset that a blogger says "let Sprockets die", proposes Webpack as an alternative and lists "NodeJS" as its only "con". No, it has several "cons", as were pointed out by other commenters.
Although the article is lengthy and deviates too much off the supposed original topic, he's spot on. The one-js/one-css architecture doesn't scale, probably never did in the time when the desktop ruled, and specially now when most of the clients are mobile devices accessing through 3G. Webpack is a swiss-army-knife that does sprockets things and so much more, and enables a new way to program frontend where you don't have to choose anymore between full-server-side or full-client-side. Rails would be wise to just say "farewell Sprockets, we hardly knew ya!" and adopt it before people notice and move the full rendering to nodejs, limiting the rails stack to API layer, a layer which is better served by leaner smaller frameworks like roda or sinatra. 
The next step is to just continue building real things. No way around it. And keep reading everything you can from good ruby blogs and such (I wish there was a good aggregator, I don't think there is anymore). When you get to the next step, you'll know what the next step is and won't have to ask, that's the next step. Although I don't disagree with the other suggestions given here. 
You might want to look at Paul Mucur's patches in [this Ruby issue](https://bugs.ruby-lang.org/issues/6284).
I clicked on the link and the first thing it did was ask for my email address. Terrible.
I'll preface by saying that I got my start in professional development using Perl, then PHP, then Ruby. I've been writing production code primarily in Ruby for over 15 years now with stints in C#, Python, and JS. I personally can't stand Java...far too verbose for my taste. Pros: 1. Ruby is an incredibly expressive and flexible language. 2. Decent debugging tools 3. Lots of libraries and good tooling 4. The web development frameworks available are mature, feature rich, and incredibly productive 5. Great, active community that is helpful and innovative. 6. EASY testing Much the same can be said for PHP, Javascript, and Java, but granted equal competence in languages relevant to modern web development, you will get from point A to point B much faster. The major downside to Ruby is dismal performance compared to JS, Java, C#, or Go. This generally isn't an issue with greenfield web apps, but bad design and architecture in legacy applications (+4yr old) really can take a toll. There also is a lack of static analysis tools and refactoring can be a royal pain (mitigated by the excellent testing tools). I'll just say that whenever I take on a project in another language, I feel that the Ruby ecosystem has spoiled me. The lack of ceremony and boilerplate code required by Ruby applications in general makes development feel faster and more pleasant in general. The opinionated, convention-driven nature of Rails eliminates a lot of support code and you generally can maintain focus on domain logic to get your features and product out the door rapidly. My $0.02 =)
No, because those are often (usually?) more inscrutable than the code under test if you don't understand what the goals are to begin with. Wikipedia frowns upon articles written in an "in-universe style"; there's a place for that attitude in code, too. And yes, I'm a BDD/DDD practitioner. But paging through a few dozen tests will never be a more efficient (or respectful) use of your audience's/potential collaborator's time than a few well-written paragraphs in technical English. Technical writing is not so much a lost art as one that has ostentatiously been chucked onto the rubbish tip and set alight.
Because of the existence of mysql_real_escape_string. Sarcasm aside, Ruby reads really well, and Rails as a framework has made me more productive than anything else I've used so far. I used SilverStripe in PHP before, and it borrows a LOT of concepts from rails (as do many, many other frameworks). I don't think you need to use Ruby over PHP, but I'm a much happier developer now. Take a glance at the book Design Patterns in Ruby (I hope that's the correct title). It was a great starting point for me. 
She explains a _lot_ that I'd been noticing for years and years but never really put together. No surprise that it's so relentlessly mocked in the comments by the poseurs who call themselves the "kool kids". Then again, YouTube comments have always emphasised the Dunning-Krueger effect.
Because it's a way better language than PHP, its creator actually put some thought into its design. 
Shouldn't be downvoted hopefully. I found your comment very interesting and I think it contributed to the thread.
I'll upvote you, but I'd nudge op to a language other than PHP.
I think #1 is addressed by the Attributes API they added. A common use-case for update_attribute I find is either one-off tasks to fix data (which could instead be done via direct database SQL), or inside rescue/ensure blocks where saving the state (such as failure) is more important then the record being valid. I do think callbacks are slowly being deprecated, and will probably be phased out of ActiveRecord. However, I think they still need a few alternatives to replace functionality that still requires them.
I know of a few companies porting their rails apps to php because there are more, cheaper devs. Make of that what you will. 
There are a lot of script kiddies with php background who will maintain your WordPress/Drupal/Magento project for half the price of an engineer. For many projects the quality of work is sufficient. 
PHP has terrible reputation and a lot of it is deserved, but most of it is outdated. The only concern for the future is that companies might not be willing to use interpreted languages for long. In a world where Moore's law no longer works, visitors have higher and higher expectations for websites to load fast, and 100ms loading time can cost you 1% sales, development time doesn't matter as much as runtime performance. I think this is an important thing to consider for anyone learning programming today. 
tl;dr: Ruby is a great language in terms of programmer productivity and happiness, but is by no means the only or best option; the right fit for you will heavily depend on your preferred programming style, the needs of your particular use-cases, and the results of you trying out a few different programming languages to get a feel for them. Also, do some research into the various PHP MVC frameworks as a stepping stone into more "modern" web development, since whether MVC is right for you is going to be a significant factor. ----- There's really no right answer (as tempted as I am to appease my bias in favor of Ruby and very strongly against PHP). Ruby web development (particularly with Rack, and therefore with both Rails and Sinatra) is generally regarded as an improvement upon the use of CGI scripts like with a typical PHP setup for a myriad of reasons (usually around scalability), but that's a moot point if you're not productive in that sort of mindset. In some cases, Ruby and PHP have many things in common. In particular, they are both mature procedural programming languages with an ecosystem very much geared toward web development (while Ruby is often used outside of web development, it'd be dishonest to be in denial about Rails' profound influence on the Ruby ecosystem). Ruby is entering a state of maturity that PHP has already "enjoyed" for quite some time; while both are making efforts to modernize, both are being increasingly-frequently cast aside in favor of more "shiny" solutions. In spite of this, they both are in very common use, and will very likely remain so for many years to come. They also have many differences in syntax and programming style. Those differences are hard to fully describe and quantify beyond comparing equivalent code and examining them firsthand. The most profound is Ruby's implementation of an object-orientation system that is simultaneously strong and dynamic, which helps prevent a lot of the often-unexpected type-related bugs common in both PHP and Javascript without the rigidity of "static" object-oriented languages. Ruby also supports some rather sophisticated metaprogramming techniques (not quite reaching the homoiconicity and program-as-data flexibility of Lisp, but coming remarkably close); these, in combination with the aforementioned object system, are a pretty significant part of how a lot of popular Ruby applications tick (especially ones built on Rails). ----- With all that said, the key aspect to many non-PHP programming languages when it comes to web development is the "Model-View-Controller" or "MVC" software design methodology, of which Rails and Django are examples for Ruby and Python (respectively). PHP has some of these, too, like CakePHP and Laravel; learning such a framework would be a good first step toward making the transition if you so choose. The significant difference is that the URLs of your web-facing software won't necessarily correspond to file paths; instead, you'll define those URLs using a "router", which will then call functions in your "controllers" (which may or may not load data using "models", which interface with a database) to finally render a "view" that produces the final HTML (and possibly JS/CSS) sent to the browser. The MVC approach to web development does introduce more complexity, but with the added benefit of a clear separation of concerns. Unlike typical CGI-driven PHP code, where a single file for a given URL might have to deal with all the concerns of reading from the database, processing data both existing and new, and rendering output for the user's browser, an application designed around the MVC approach allows a programmer to keep all the database-reading code (for example) in a single reusable place (of course, even CGI-based applications can have some of these benefits by using various libraries abstracting these details away, but it's not a complete replacements for all the benefits MVC provides).
Hi, yes I create my site. It is so simple and actually does not have css and js. If you want web development check Ruby on rails or sinatra.
If your question is "why should I use Ruby (over PHP)?", then answer is "you shoudn't". If you are asking "will I be happier programming in Ruby (instead of PHP)?", then answer "you will".
Can't say that I do; but there were at least six J Dickeys in software in the Northwest US when I left in 2003, and I found five the last time I looked on GitHub. For a name that my folks picked because "it wasn't one we'd come across", it's awfully ruddy popular. People who let unit tests smoulder in the bin don't mind making jack-ashes out of themselves.
No one can answer that question better than you. Why not give it a shot, learn the basics, write an application or two. Try doing the same in PHP and then compare the effort involved and how comfortable you are with the syntax/tooling in each environment. btw if you specifically interested in Rails (the de facto standard in Ruby Web Development) you might give laravel ( a Ruby on Rails clone in PHP) a shot.
good luck with long-running background processes in php.
I am using PHP at work. I am looking for a switch for my personal projects.
You should always be playing with new stuff. I'd do a project with Ruby and Rails. And JS / Meteor. And Elixir / Phoenix.
I know exactly how fast php7 is. It has nothing on Go if scaling servers becomes more expensive than rewriting in Go. 
Yeah GO will run code on the webservers faster than PHP, but your web app's bottleneck will almost always be at the database level LONG before you need to worry about rewriting your app in GO. I've gone through this pain with several different projects. They think that switching to a functional programming paradigm, and buying more web servers that still hammer 1 database will make things faster, when it really just reaches your bottleneck faster.
Yeah, there are a lot of differences, as you said. The thing that caused those differences to suddenly "click" was to treat message passing on actors similarly to method calling on objects, thus starting to run more things both asynchronously and under supervision trees. Much like how one builds objects in Perl by "blessing" data structures (embedding them into sets of methods), one builds objects in Elixir by embedding data structures into processes with message handlers. It's worth noting that a bit MVC framework like Phoenix is rarely actually necessary for web development; if you prefer to get some distance from the "Railsy" experience, it's pretty easy to use `Plug.Router` to that effect, and would in fact be a much better learning environment (since you're relying less on Phoenix's callback-hellscape to do everything).
You shouldn't. As in, one is not better than the other, necessarily speaking. Use what you're comfortable and familiar with. Or, use what gives you the biggest job market, or fits your specialties best. Learning Ruby in general is useful however, because a lot of deployment tools and build tools utilize Ruby. Like... Vagrant, Puppet, SASS, etc. Also, working with other technologies often benefits your core one. For example, learning the intricacies in Rails might help you understand some thing in PHP better. Or you might find something is really cool and useful, and do that thing in PHP.
Laravel is pretty standard in a modern PHP shop. It's in the top five frameworks consistently. Just depends a lot on your community if you see any exposure to it. I find some communities are more progressive, while some PHP shops I work with are using a home grown CMS they built in 2001. Different strokes for different folks.
So switch and ask questions when you get stuck. Try Go and get annoyed by it's idiosyncrasies, try Python and start cussing at 'self', try Ruby and roll your eyes at Rails, get overwhelmed by node.js "deprecated before release" ecosystem... Try Haskell, Scala, Elixir, C# and Swift. Dream of learning OCaml one day. And on and on and on... Why you should choose any of those over PHP for learning experience? They are different. They are almost always better. Learning new stuff makes it easier to learn more new stuff. Polyglot developers that actively learn have more opportunities by fitting more jobs.
Have you considered Node? You already know Javascript, and that is a hot technology right now which many large companies are moving to. Ruby is cool, very fun and intuitive language to write, but for web development purposes is basically completely tied to Rails... so you better hope you like Rails.
Yeah, and JavaScript is more popular than PHP of this year.
Thanks buddy! Good luck to you, as well!
So here's the thing. Languages are just tools. In web development nearly any commonly used language can be used to build what you want. Ease of use is related to experience. Developers with an extensive Javascript background are more likely to lean towards Node for back-end because it's familiar territory. JS isn't better than Ruby and Ruby isn't better than PHP. Certain frameworks provide a different experience though and you need to play with them and understand what they're about. I prefer Rails because they lay the groundwork for what they believe is a stable web app, or "convention over configuration". Rails however isn't a wise choice if your needs are simpler. Say you're building a blog. I would rather use PHP in order to keep the project smaller. Small blogs probably don't need extensive data model rules or controller checks to authorize viewing of most pages. Rails is about RESTful MVC and if you don't need that you need to use another framework. Use the tools that are best for the job at hand, and learn how to use them all so you can easily shift to a different tool when the job calls for it.
also consider middleman. simpler than jekyll and more ruby-like. 
Are you also finding a designer? What's the idea?
Whilst I prefer Ruby over PHP any day I think your picture of PHP as CGI-driven is a bit outdated. Most professional PHP development these days makes use of sophisticated frameworks such as Symfony or Laravel running under Apache + mod_php or nginx + fpm.
If you're building a blog Ruby has you covered: Jekyll and Middleman for static blogs and Sinatra for anything small and dynamic. There's also Grape for lightweight APIs.
Even in that scenario, the sooner you hit the database, the sooner you can finish the request. My main point is scaling though. Right now we're only optimizing server-side code in a superficial way. That's because upgrading from 22nm to 14nm gets you a lot more bang for your buck than spending thousands of development hours on optimization. When that limit is reached, which could easily happen this decade, will we start doubling the size of the datacenter every 18 months to sustain the same growth? Obviously, if that happens, there will be a higher degree of software optimization. The only question is, will the number of companies which favor rapid development over hardware requirements, decrease sufficiently as to affect your career opportunities in a significant manner? We can only speculate.
https://www.railstutorial.org/book
I found an interesting website called [Learn Ruby the Hard Way](https://learnrubythehardway.org/book/) that may be of some use to you. It starts off with basic concepts that you should already know but it does cover some more advanced concepts later on. 
Middleman is only "simpler" if you already know Ruby on Rails (e.g. same helpers, views, templates, etc.) Jekyll is "simpler" e.g. easier to get started if you're new to Ruby. Anyways, use what works for you. Cheers. PS: [Jekyll vs Middleman](https://github.com/geraldb/talks/blob/master/jekyll_vs_middleman.md) - talk notes (slides) from the Vienna.rb meetup (titled build your websites w/ ruby).
I'd say read [Sandi Metz's POODR](http://www.poodr.com/)
&gt; mysql_real_escape_string Not to be confused with `pg_escape_string`, of course! Meanwhile, all other frameworks switched to prepared statements rather than escaped inputs, *years* ago...
I guess I haven't read about it in as many places as the OP, but the main benefit I always hear about minitest (and the reason I tend to prefer it) is just that it's built in to ruby. Hell, I didn't even know anyone had been disparaging rspec.
The title seems to basically be clickbait.
That's one of important topics for me. Not "vs" part by itself, but "defining the ways" and understanding what leads to what. I'm indifferent to MiniTest, actually, but articles praising its "rubyness" raise some really important questions. 
Another vote for [Learn Ruby The Hard Way](https://learnrubythehardway.org/book/), and I'd also recommend [Learn to Program](https://pine.fm/LearnToProgram) (I'd follow this one before going through LRTHW) and [Codewars](https://www.codewars.com). If you are interested in web development, then [The Odin Project](http://www.theodinproject.com).
The "go JavaScript" but it's as nonsensical as comparing `do...end` to `{...}`. Unless it's a reference to some stupid argument I'd missed.
I think part of it is using a full-blown lambda where a block is more than sufficient. Granted, I've yet to fully understand why there even is a difference in the first place, but still; the way anonymous functions are used in a lot of Ruby code (especially Ruby code following "The Rails Wayâ„¢") is essentially indifferent from how blocks are used.
i agree with the author that def test_performs_some_set_of_really_complex_actions is more magical than def_test "performs some set of really complex actions" the latter is pretty clear and idiomatic ruby; you can at once tell that someone has defined a `def_test` method, and guess that how it works is that it defines a method and registers it with a test runner. in the former case, it's pure magic that something will introspect your code looking for methods beginning with `test_` and do something special when it finds them. 
&gt; Well, personally I, strongly dislike "DSL-first" approach This is my problem. The simple "pull trigger" example given is horribly unreadable, imo, compared to the perfectly readable "bad" example underneath it. 
Searching Indeed's API by job title, which eliminates duplicates, shows Ruby with 182 jobs in London and 58 outside London so the Ruby job market, like Scala's, is heavily concentrated in London. However, it's the comparison with other languages which gives clearer indicators. For example, PHP(excl. WordPress, Drupal etc.):Rails = 3.6 in London but a whopping 34.5 outside London. Node:Rails = 1.8 in London and 3.9 outside London. Laravel:Rails = 1.4 in London and 8.0 outside London. Python:Ruby = 1.8 in London and 4.1 outside London. Yes, many Ruby jobs are probably advertised outside jobs boards like Indeed but that also applies to other languages/frameworks so the ratios are probably still valid.
That's a narrower definition of clickbait than I use. I guess I consider it to be kind of a synonym for "sensationalist". Arguing that "minitest is not just ruby" seems pretty sensationalist to me. In fact, it's the only reason I clicked on the article.
this is what i'm talking about! the first example you gave. the other ones are gonna take some time for me to parse but thank you, gonna dig in
Huh, I didn't know about each_slice, and reading the docs... dont' understand the difference between it and each_cons. The examples in the docs are identical, are they just aliases?
they're def different, check this out [294] pry(main)&gt; [1,2,3,4,5,6].each_slice(2) {|num| p num} [1, 2] [3, 4] [5, 6] =&gt; nil [295] pry(main)&gt; [1,2,3,4,5,6].each_cons(2) {|num| p num} [1, 2] [2, 3] [3, 4] [4, 5] [5, 6] =&gt; nil
What I commented on the blog itself: ------ I've been using MIniTest for Gem and app development for the last several years; for the last 2+ being Rails-free. I've been doing TDD in one language or another for over 15 years and writing software with the expectation of being paid since 1979, just so you know where I'm coming from. This, and the associated [comment thread on Reddit](https://www.reddit.com/r/ruby/comments/56rbe6/minitest_is_not_just_ruby_it_is_just_rails/), sound as though someone is overly emotionally attached to RSpec and feels his identity threatened because not everyone shares his love affair with the tool. When I went from RSpec to MiniTest, I converted the test suites of the three Gems and apps I was working on at the time. The *smallest* improvement in execution speed was just under 280%. RSpec wasn't written by idiots; if it's that slow, it's because it's *doing a lot more work behind the scenes* (aka "magic") than MiniTest is. MiniTest also has a much more flexible, readable, maintainable custom assertion protocol than RSpec does. Custom assertions aren't "magic"; they're explicit bits of code that take the noise out of your own specs. (Protip: If the number of *assertions* is more than 3-5% higher than the number of *tests* in your test suite, you're not testing your code; you're testing your *boilerplate;* was that your intention?) Anyone who thinks Minitest is "just Rails" really needs to invest more time and effort in learning real Ruby.
DHH?
It's doing fine, lots of jobs out there, though not much of it is greenfield if that's what you're after. Companies are having a hard time finding good ruby devs, and on the flip side, if you're at least a mid level then you'll find a job in a matter of days or a couple of weeks max. No, it's not a huge market like Node, but there are plenty of Ruby jobs available.
David Hasselhoff
 def test_performs_some_set_of_really_complex_actions is Ruby, you're defining a method. It's not magical, it's fundamental. def_test is a method call. Who knows what's happening in that method. As for introspection, that too is a fundamental part of Ruby. It's one of it's most powerful features. As for doing something special when it finds the method, it calls the method! But all this is a straw man and has nothing to do with the argument the the OP is totally failing to refute. 
I think you have totally missed the point of Minitest's "rubyness" and it's sent you off the deep end. The point people are making is that a minitest test IS Ruby. Properly written test code will be a valid example of how to use the method under test. You can copy and paste it into your app with minimal changes and it will work. You can't do this with a properly written RSpec example because it's not Ruby, it's all DSL. This is nether good, nor bad. The two libraries take different approaches to testing, MiniTest is TDD, RSpec is BDD. I use RSpec professionally because I want my tests to be understandable to people who don't code. 
Another plus of MiniTest test architecture is that it follow xUnit approach, that you can meet in almost any other web language. So this skill of writing tests in that way will be much more relevant, than RSpec DSL. * [https://phpunit.de/getting-started.html](https://phpunit.de/getting-started.html) * [https://xunit.github.io/docs/getting-started-desktop.html](https://xunit.github.io/docs/getting-started-desktop.html) * [https://github.com/junit-team/junit4/wiki/Assertions](https://github.com/junit-team/junit4/wiki/Assertions) * [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html) as an example of RSpec like tests declaration is ExUnit in Elixir [http://elixir-lang.org/docs/master/ex_unit/ExUnit.html#content](http://elixir-lang.org/docs/master/ex_unit/ExUnit.html#content) but at least it doesn't try to invent Asserts for all case of life and death and @tag concept is more powerful and clear instead of nested scopes.
Could you please provide an example code to illustrate your point?
&gt; When I went from RSpec to MiniTest, I converted the test suites of the three Gems and apps I was working on at the time. The smallest improvement in execution speed was just under 280%. RSpec wasn't written by idiots; if it's that slow, it's because it's doing a lot more work behind the scenes (aka "magic") than MiniTest is. Can you point me at any of that? I'd love to be able to cite objective speedups.
It is proudly cited by MiniTest everywhere, what else you could expect.
Nada; nor was I complaining. I was surprised to see my name called out an random webpage.
 def test_performs_some_set_of_really_complex_actions &gt; is Ruby, you're defining a method. It's not magical, it's fundamental. Yep. Until the moment somebody says you "if you name your method _this way_, it will be treated specially, and if you call it a bit different, it would not". Nothing fundamental here, nothing in methods/OOP definitions says "call all methods starting with `foo_`". That _is_ magic (something that you can't guess from just reading the code). For `def_test` you can find source and investigate it, for "magical ranner of all `test_` methods" it is much harder.
Literally yes, it is also DSL. But it is a plain function, not meta-programming or complex chain of Matcher Objects interactions. It is easy to follow, that is the benefit. And that is one of the main qualities of test framework at my pov.
Ruby really helps to get deeper in the real meaning of OOP. PHP is much limited in this aspect. But most times these limitations appears to save from "shooting the leg". And for sure nowadays Rails does not have advantages over modern PHP framework in terms of architecture. Some time ago I put my thoughts on the topic Ruby vs PHP http://stdout.in/en/post/ruby-ecosystem-bittersweet-or-we-like-to-hate-php 
For basic use cases, I think it would be much preferable to use [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby) instead. require 'concurrent-ruby' pool = Concurrent::FixedThreadPool.new(5) # 5 threads pool.post do # some parallel work end # wait for work to complete, if you need to do that, also shuts down the pool pool.shutdown There are probably ways to use the concurrent-ruby package to do your more complicated sequencing too, by putting together Futures, possibly using a Dataflow. It's cool to play around with stuff, but concurrency is hard, I think it's preferable to use mature and tested packages in production code, rather than something someone was playing around with to learn how gems or fancy "DSL"s are made. (Personally, I think "DSL" is just another word for "API"). Fortunately, we now have ruby-concurrent. 
The `%` operator is [overloaded for String](https://ruby-doc.org/core-2.2.0/String.html#method-i-25) to provide numeric formatting via `Kernel#sprintf`: float = 5.678 puts '%i' % float # =&gt; "5", truncated puts '%.0f' % float # =&gt; "6", rounded puts '%.2f' % float # =&gt; "5.68", rounded See [Kernel#sprintf](https://ruby-doc.org/core-2.2.0/Kernel.html#method-i-sprintf) for more information 
Sounds interesting. Does that make it more like a Sinatra or Rack experience?
Objection, your honor! My blog is not random! It is controlled by my mind (or so I hope)
That is a reasonable view on things. It really was a toy I was using for another toy. I wasn't aware of the concurrent-ruby gem. Thanks for bringing it up.
More like both rolled into one, but with a feel very close to Sinatra.
Indeed. My point was more that Plug has both their key roles: interfacing with an HTTP server and providing an easy way to define routes.
The `parallel` gem is excellent and does much of this too. https://github.com/grosser/parallel
Both eager and lazy evaluation can be accomplished with and without the use of lambdas (that is, they are orthogonal concepts). A common pattern that accomplishes lazy evaluation is an object like this: class Bar def initialize @foo = nil end def foo @foo ||= get_foo end #... end The eager counterpart would be: class Bar attr_reader :foo def initialize @foo = get_foo end #... end Llambdas (or procs) are often used with lazy evaluation because a lambda can form a closure on the state of the caller. You can do something like this: class Biz def do_something #... end def bar Bar.new(get_foo: -&gt;() { self.do_something } ) end end You then need to implement Bar#get_foo based on the lambda passed in on the constructor. But you could just as easily implement get_foo directly on Bar as a method, and need no lambda to be passed in. So you can see that while lambdas are useful in conjunction with lazy evaluation, any combination of eager/lazy lambda/no-lambda is possible.
Thank you :)
&gt; no '.0' on the end unless the value of the float isn't an integer Not sure what you mean by this part. If you're saying you want to automatically truncate any trailing zeroes, plus the decimal point if it's an integer, then you can use this helper function to convert the float to a string, then print the result: def format_float(float) ("%f" % float).sub(/\.?0+$/,"") end 
Dude, thank you so much for validating my position. Personally, I felt that the way that issue was dealt with revealed a great deal of arrogance. I find the "never a problem for me, so nobody can possibly have that problem" excuse rather annoying. What's the point of investing all the time in a PR if the devs don't give a shit?
Very funny. Not that helpful, but very funny.
Wow, that presentation room looks beautiful. 
That's what I would have said as well. It's exactly what you described (passing the page parameter). Is there more context you can give us? A link to the API docs for the API in question maybe?
It was buddy, it was! Euruko team did a great job in Sofia! ðŸ˜‰
No problem! RSpec seems to be a love-or-hate sort of thing. DHH, for example, is very vocal about his distaste for it. Both frameworks are great, though :)
Build something. Literally anything.
I was serious. I must've misunderstood your question. Are you asking about making the request, which is what I assumed and my answer was thus. Or are you asking about handling the request (eg controller code)? 
Nice post. I think that knowing ActiveRecord and SQL helps a lot to speed up things and every one dealing with rails should learn
&gt; above all, it's important to know what things are doing 'under the hood'. I agree with this. &gt; e.g.: If you need to do any sort of aggregation over the same set of data - use where where you can, and use select for repeated sub-sets of data. I think the key here is "where you can" `select` loads all the records into memory. The performance of a record/object load is relative to the amount of columns in the table. `where` will filter the records and then load them into memory. Allocating less memory will make the code perform faster. I would only use `select` if the block had some complicated business logic that I have in my application (and can't be implemented with a `where`) &gt; This is especially important for large sets of data where using where/ any db query can be more expensive than select. I disagree. Usually the query will be faster than a select. Could you name one example where a query would take longer than a select? &gt; Also, I hugely recommend trying out https://github.com/salsify/goldiloader Very interesting! +1
This is actually quite interesting. I don't think you need the thing model, as what you're doing is way easier and faster using the Sequel Dataset API. I'd also say making ruby your entry point if you're using nodejs already could be reshuffled, in that you could kickstart an express app which maps the webpack endpoints, serves the html and proxies the "/api" endpoints to your local ruby API server. Contrary to all ruby web servers, nodejs servers don't need to stay behind a proxy for performance reasons. Apart from that, it's a nice exercise, and I think that variations of this might become ruby stacks of tomorrow. 
Comment on the bullet gem. I used it recently on our code and it recommended some includes which I added. I ran it again and it said the same includes weren't needed. YMMV. Also, don't use try. 
There's any reason for the express server? I mean this is SPA-based so it will be serving just one piece of html and a bundle.js -- at some point using react router, so that should catch every request and /api/ should go directly to sinatra
I shouldn't have said anything because it's OT and usually ends in a flame war, but seeing as I did... `nils` are bad. They spread through your system in unexpected ways and cause errors that are unexpected and hard to debug. You should write code that explicitly checks for nils and does something sensible. `try` on the other hand says this could be `nil` but I don't care, let's make it the next guys problem.
See my other reply https://www.reddit.com/r/ruby/comments/574par/tips_for_writing_fast_rails_part_1/d8pidju
/u/hmaddocks gave a rough overview but "Confident Ruby" is a great book that goes into this sort of stuff. Highly recommended.
If that would go to production, it would never work reliably without a reverse-proxy in-between, as ruby networking doesn't allow for slow read/writes out of the box. nodejs does. You can use nodejs built-in http server, I just assumed you wanted to use one of the existing express middlewares for API proxying (I don't know about any native, you'd have to write it yourself, which is not impossible). To touch a bit more on how that first request could bring your system down: you are reading the file once per request. How many system-calls are there? How much can go wrong? IMO you could just put that HTML into a string inside your sinatra app, serve it, and even so you'd be dependent of the app server performance and reliability if not behind some apache or nginx. 
[Why's Poignant Guide to Ruby](http://poignant.guide/) is a good starting point, if you want overly whimsical cartoon foxes and lots of bacon.
i have no idea what you're talking about
Who doesn't like bacon?
I second [tryruby.org](http://tryruby.org/levels/1/challenges/0). I also have been working through [The Well-Grounded Rubyist](https://www.amazon.com/gp/product/1617291692/ref=pd_sbs_14_t_0?ie=UTF8&amp;psc=1&amp;refRID=NARJFSW71XMTFB3RKSTF), and it's been helping a lot.
Try to build a sudoku puzzle solver. No looking at solutions already online!
(S)he claims they already know c, so i don't think it's a stretch. Challenging but not overwhelmingly so. It was a project given to me in college where prerequisite ruby knowledge was not expected, and I handled it fine. No need to implement something crazy like Knuth's dancing links algorithm, it can be done brute force or writing methods that replicate commonly used strategies you can find online.
Basically if I have a list of text strings, I want them to be made into simple videos like this: https://www.youtube.com/watch?v=11yiJmAArqM I know there are simple, text to image scripts, and I wanted to know if there is a text to video script.
https://pragmaticstudio.com/ruby I think it is the best course for a beginner. Definitely, worth the money!!! 
They must love Ruby in Spain. I know Barcelona hosted a Ruby conference in 2014. Either Ruby is popular in Spain or Spain is just attractive for the good weather.
FYI: There's also a [sample site](http://staystatic.github.io/sites/webgen/) built with webgen in the Stay Static Series -&gt; [/staystatic/staystatic/webgen](https://github.com/staystatic/staystatic/tree/master/webgen) if you want to compare webgen to Jekyll, Middleman, Nanoc and friends. What your static (web)site builder of choice? Let us know.
Easy to check the current issue board: https://github.com/voltrb/volt/issues/357
Why "RemoteTransactionCreateFailed" and not "RemoteTransactionFailed" or "TransactionFailed?" Using CRUD terminology in DDD (and especially event names) is an anti pattern, I think.
&gt; ffmpeg holy shit sir, THANK YOU
http://danilenko.org/2012/7/6/rails_timezones/
And notice that is not development but instead using a utility. 
Cool! I think adding additional templates would be a good idea too. Just goes to show that Ruby can do anything.
Yeah. It wouldn't be possible without Ruby Together. There are more awesome plan like [rolling out Elasticsearch](https://github.com/rubygems/rubygems.org/milestone/8), [metrics for gems](https://github.com/rubygems/rubygems.org/issues/1439), [TUF](https://github.com/rubygsoc/rubygsoc/wiki/Ideas-for-Bundler#add-support-for-the-update-framework-to-bundler-and-the-new-index-format) and [bundler - rubygems merge](https://github.com/rubygems/rubygems/issues/1681). Please support [RT](https://rubytogether.org/) to make all of this happen sooner &lt;3 EDIT: [A well thought out comment I really wanted to show](https://github.com/rubygems/guides/issues/163#issuecomment-249879922).
That's right. I'd managed to completely suppress it from my memory. Can't see going back there for anything anytime soon.
Is this an ad?
I've just confirmed, there are proxies for plain http servers. I think there's a strong need (or not, depending of what you're accomplishing). I a world with many teams with many requirements, and where you want to enable microservices, you can just create an api in ruby (using sinatra or anything else), lets say, for "bananas", and you can proxy "api/bananas" to it. Ruby has many libraries to handle bananas and price calculation (which by the way, you don't want to do in javascript), and nodejs will queue your requests, redirect to other services, render and serve the pages, etc. Big advantage: you don't need to set up CORS on your ruby app, as it's proxied by your frontend node app. I don't know what you mean by "2 different repos". 
Yup. 
Ok, what's the usual Reddit response? Ask the mods to remove as spam? Or to openly mock? Or both?
So, I'm at a bar in Thailand and working on getting drunk. You've won my attention so here goes... Start with Codecademy. If you are not great with general programming conventions, this will give you a decent intro. If you are rusty (or flat out don't know) html/css, start there. If you are comfortable with the the previous, skip to ruby. Some of the things they cover you will rarely use once you are experienced but for now you just are after exposure. After you complete the Ruby course, continue on to Rails. (Disclaimer: I've never taken this one but the exposure can't hurt.) From there, go to TeamTreehouse. It's about $30 a month but get used to spending roughly that amount. You'll be doing it for a while. Treehouse will introduce you to building an app in Ruby/Rails. It will also introduce you to TDD (test driven development). Do not focus on the testing, just focus on getting good better at ruby and rails. Do everything they offer (it's a fuckload). Once you are done you should have a bit of a clue what the whole ruby/rails thing is about. Now that you know a little (and I mean a little) now is the time to start working on a "blank page" app. Think of something basic to build. It should be curd based (create, read, update, destroy). Use the rails generators as much as possible. Take note of the controller structure. The point is not to build the next Facebook at this point. It's just to get a bit more familiar with something that is not spoon fed to you. When you fail at this stage (and it's cool, you will) now is the time to do Michael Hart's Rails Tutorial ( no way I'm going to link that, spell check is the only thing saving my assignment from Heineken and Johnny Walker Black at this point). Follow it through and once your done, it's time to revisit your previous app. Make another run at building what you started before. Now is also a good time to drop Treehouse (if you haven't already) and pick up a sub to Code School. Use it to get better and fail better at your original app. Once you've completed their ruby/rails courses, you should have a decent idea what you're doing. Now is the time to go back and take a look at testing. Use RSpec. Try to make sense of their (dsl). It will suck. Be prepared. Once you feel burnt out on trying to understand RSpec, do another blank page app. Something different. Your goal is only to fail better. By now you should have a decent idea what you're doing, but you still need to get better. Get a sub to Upcase and read POODR (Google it, I don't feel like typing, my beer is getting warm). Once you have consumed a shot ton of Upcase and understand a bit of POODR, congrats! You are ready for some jobs on Upwork at $25 per hour. Cherry pick things you know you can do, don't fuck it up, and ask for a 5 star review when you're done. Wash, rinse, repeat. Congrats! You are now a year in and a ruby/rails dev! (Sober, day after update: you want to up your rate after you get a few 5 star reviews. I think small fixed bid is the best start. Sure, you can get hosed on the pay but go by the client's reviews and try to find someone who at least appears honest. After two or three gigs, you should be able to go to around $50 per hour.) Keep this up for a year to year and a half, learn, and get a mid level dev job for around 100k. 
i would just downvote if it's above zero net votes and move on. no need to deride other people's source of income, nor try to humiliate them by burying them in the negative. 
No idea. I can't even work out how people make the score hidden! 
FYI: You're invited to add your plugin! How it works? Add a new entry in the [Awesome Jekyll Plugins](https://github.com/planetjekyll/awesome-jekyll-plugins) page. Example: - [**Scholar**](https://github.com/inukshuk/jekyll-scholar) \ (gem: [jekyll-scholar](https://rubygems.org/gems/jekyll-scholar)) \ by Sylvester Keil -- extensions for the blogging scholar. That's it. Thanks. Happy Jekylling.
No it is not. I forget why I did that. What classes would you have for a tic tac toe game?
First stab at TTT would be a Game, Player, and Move. You could add further ones depending on how you track the order of moves, the state of the board, etc. A Board class might not be necessary, for example, because you can deterministically calculate the state of the board purely from a series of moves.
Along with the other answers given, one thing I always remember from one of the tutorials I took when learning was: Classes have state (data/values) and behavior (methods). If you find yourself wanting to make a class but it is only to hold data (state), then you should look at making a struct instead. On the other hand if you only have a group of methods (behaviors), then maybe put them in a module. When you have both, then create a class.
AR does not use the schema.rb file for this. The schema file is a record of what AR figured out by connecting to the DB and examining it. But the schema.rb file is not used for ordinary AR operation, AR will work if it's not there, and basically ignores it. If the schema.rb file is 'wrong', it won't matter -- AR gets info from the DB every time it boots up and connects to it, and uses that. The only thing the AR schema.rb file is used for is recreating a schema in an empty database by loading the schema.rb file, when commands to that effect are executed. I am not sure what the analagous thing, if any, in Sequel is, but some googling would probably lead to an answer. 
A simple google search of ruby gem excel will find many gems(external libraries) which parse and create excel files. For instance, check out the gem [Roo](https://github.com/roo-rb/roo)
The old general rule that many teachers use is nouns or "things" become Classes and adjectives or traits become Modules. Classes are like templates for Objects (instances of the Class) which contain state (aka instance variables) and have methods which return information or change the state of the object (aka instance variables). Modules are more like re-usable pieces of Classes which you can include into multiple Classes.
That book was part of the material for the coding bootcamp I attended and I found it very helpful. It is a great starting point for people with little experience. I'll echo what /u/otishotpie has said: don't worry too much about "the best way" until you have a lot more experience. I would say that most of my understanding of how to do things better has come from time/experience and working with mentors and other developers. There are often *many* ways to solve a problem, and each solution will have advantages and disadvantages. Quality code comes from understanding what those pros and cons are and when to use one solution over another, not a perfect way that is the end-all, be-all. Right now, those examples are useful for helping you understand how to code, not teach you the most efficient or modern means to solve that particular problem.
I just got ["Head First Ruby"](https://www.amazon.com/Head-First-Ruby-Jay-McGavren/dp/1449372651/)
This, I remember going through that book, its really meant to be progressive you can't just flick to the middle and understand it as its designed to introduce someone completely unfamiliar with programming to a lot of basics and terminology. Incidentally I loved that book so much I've bought it for a few people I think who also loved it. I have never seen a better getting started book. The stuff in the back isn't about rote learning from what I can remember they are designed with the mindset of "You now have the basic tools, use Google and Stackover flow and whatever else and see if you can figure these out". It's not intended to be a programming bible, its intended to teach you how to think about programming and the problem solving that goes with it. Chris is actually really helpful and a really nice guy by the way he answers email and twitter questions about that book even 12 years later or whatever it is now, if your confused can always ask him @OtherChrisPine on twitter
Thank you, this is very useful.
Also, assuming the Rubocop warnings are accurate, it's more performant. Haven't benchmarked it myself though, so don't know how much we're talking about. 
`Range#to_a` uses `#succ` method (via `#upto`) to iterate (`#each` and `#to_a`), and `&lt;=&gt;` comparison to understand whether the beginning of range is larger than end (so, empty array should be returned). So... ('a'..'Z').to_a # =&gt; [] # because 'Z' &gt; 'a' # =&gt; false # this is more complicated: ('ZZ'..'aa').to_a # =&gt; ["ZZ"] # because 'ZZ'.succ # =&gt; "AAA" # ...and #upto for strings works the way it breaks when new string is longer than original # (otherwise you will receive infinite sequences most of the time As about ('a'..'z').to_a.combination(2).to_a It is just how `combination` work. You may want `repeated_combination` to receive `['a', 'a']` too.
Yep. Not much to add to it - I've seen people do those over and over. In general, the root cause for this is the lack of an experienced developer on the team. 
The best thing in this article was the link to [Enterprise FizzBuzz](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition).
Favorite reply because of the updates on your alcohol/beer ;) I appreciate it. I know how that can be. Don't let your beer get cold and you nurse your drinks ever to write anything like this. But, again, I appreciate it :)
&gt; None of that is "over engineering" because it isn't even engineering in the first place. If a hardware engineer needs to build an alarm clock, they are aren't going to use NASA engineered industrial grade parts because no one wants to buy a $2,000 alarm clock. Understanding requirements and the suitability of a design to meet those requirements is core part of engineering. Absolutely! "Over-engineering" makes it sound like "engineering" is some *indulgence* that is mostly detrimental but tolerated in small doses.
Sure, it's a placeholder in my example too. Array.new takes any block you like.
Have you had a chance to look at the documentation from the gems entry_straker or richieahb recommended? What are you getting stuck on specifically? Are you familiar with using gems?
Take a look at an [ASCII table](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/ASCII-Table-wide.svg/2000px-ASCII-Table-wide.svg.png). Uppercase letters appear earlier. Your examples work if the upper case letters are on the left hand side of the range. 
jruby trades startup time for running execution. It is, in most cases, dramatically faster once it's running. Load your homepage a thousand times (ie, like in the real world) and THEN load test it against MRI.
This is brilliant. 
Figuring out which part is slow is key, rather than blaming jruby blindly. 
I wish I could, it is proprietary code. :( what is the recommended development server for jruby?
&gt; Startup time of many seconds This is expected, for various definitions of 'many'. I've got a very large monolithic rails app that can take 30-40 seconds to start up in jruby. I just optimise my programming flow around not restarting as often as I might for a small cruby app. &gt; I couldn't even get the homepage to load minutes later Have you looked at the memory consumption of your app? A java process getting into swap will crawl terribly. You might also need to up your heap size - you could be just churning through GC. Also, it could just be that you're pulling in a library that is completely broken under jruby for some reason.
There's a bunch that'll work. Check out https://github.com/jruby/jruby/wiki/C-Extension-Alternatives
&gt; You might also need to up your heap size - you could be just churning through GC. I came here to recommend adjusting the heap size.
`Array#select` is not the winner here, and it's not even close to the answer to this problem. `select` only goes through one item at a time, and OP needs it to essentially go through multiple at a time. `inject` is better here if you want to go the enumeration route, otherwise, I think that `gsub` is the best approach.
Well, it's important to distinguish overly general from abstract. Abstractions can be quite specific, actually. General purpose abstractions are pretty rare. Usually when people are frustrated with code that is "over abstracted" they mean "overly general" -- as in "I asked for a logger and I got a universal notification pub sub system."
You're right, I didn't get exactly what OP was trying to do. Good call.
Too bad the devs screwed over people who bought it with the promise of a perpetual license and then turned around and screwed them. Otherwise a cool technology.
So I increased the heap size to 1G and that actually fixed the issue of it not running at all! Apparently my app needs an ungodly amount of memory. Now Trinidad and Puma both work, Puma a little more quickly but with slower response times once running. Unfortunately the response time is still at least double MRI even after clicking around for a while. There is absolutely no way I can do serious work with a 1-10 second respond time. Edit: I set a bash shell to curl to the homepage 1000x and it is almost bearable now, but still nowhere close to MRI, and I definitely wouldn't want it like this in production.
Glad you got heap issues fixed! If we are slower than MRI it is almost always a bug or a badly-behaved library. I would recommend checking the JRuby wiki for tips on finding perf problems, or stop by our IRC or Gitter and well try to help. JRuby should definitely not be 2x slower than MRI.
They've explained that they can't do that without breaking compatibility. Hence why 2.0 is needed. It's very remote attack vector and the fix changes the behavior of Bundler pretty dramatically.
I haven't looked at the code, but doesn't that seem odd? One would think that a source specified in a particular block or line would effect only that block or line, and outside of that block or line would be as if it wasn't there. That it isn't seems like a bug, and it doesn't seem like fixing the bug would effect any backwards compat except people relying on the buggy behavior. If there really are a lot of people relying on the buggy behavior, a configuration/feature flag might be needed I suppose. 
Puma is the recommended development AND production server.
If they're flaws in JRuby, then we absolutely want to be hassled. Or if you're simply unsure what's causing them.
What do you think? Agree/Disagree ? 
Google my friend. https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-c-and-cpp/
Agee. I would even go a step further. I would remove `Todo#notify_next!`, and have a method `EventPlanning.notify_next_of(todo)` or something. This way, Todo doesn't depend on EventPlanning at all. I am okay with breaking some rules like "Tell, Don't Ask", or the "Law of Demeter" if it means that I have a clean separation. I've heard people calling it "refactoring to making it easier to delete" or something. Or maybe I've been doing too much Elixir lately and my preferences have shifted a bit towards module functions.
* Is there a file named `./app/models/message.rb` ? (All lower case!) * Does this file define a `class Message`? * If you answered "yes" both times, try restarting the server (press ctrl+c, then re-run it) just in case the files weren't picked up for some reason.
Yes thank you for the response as well, they both have the file which is why I'm confused. I'm praying it works in 1hr bcuz that's when it's due.. the code is on www.github.com/mr-cotton/ruby-messenger . Maybe I'm going crazy but I can't see the error.. 
https://github.com/Mr-Cotton/ruby-messenger/blob/74799a8581c542eec2f15358c265090283669740/config/models/message.rb It seems you have accidentally placed the file in **config**/models/message.rb, *not* **app**/models/message.rb To explain this a little more -- Rails makes very heavy use of "convention over configuration". A lot of rails code just works like "magic", so long as you follow various conventions - such as the above. While it's totally possible to define any classes in any files you like, you'll probably need to `require` them manually if you go against the conventions. (And it's not advisable to do so, without good reason!) This is both a good and bad thing for new programmers - because while you may not need to worry about typing all the "boilerplate" code, as you do in many other languages, it's also very easy to fall down into a trap of copying examples without really understanding how/why they work.
ok do you know anything about pattern matching in ruby vs pattern matching in c++??
This means you can dynamically alter the behavior of classes and modules in the standard library. You can add new methods, and rewrite those already existing. As a basic example, try this: class String def say_hi "Hi #{self}!" end end puts "vaish1992".say_hi
I'm concerned about concerns and it's very concerning.
http://www.lmgtfy.com/?q=pattern+matching+in+ruby+vs+c%2B%2B&amp;l=1 This page should provide some insight into the differences in pattern matching between C++ and Ruby.
&gt; I am okay with breaking some rules like "Tell, Don't Ask", or the "Law of Demeter" if it means that I have a clean separation. Literally "Tell, Don't Ask" and "Law of Demeter" are intended to _describe_ what a "clean" separation looks like.
Nice article! I'm in agreement. It's the old inheritance vs composition debate, where mixins are the equivalent of multiple inheritance. I also wrote some of my thoughts about concerns [here](http://www.rubypigeon.com/posts/rails-models-bloated-should-i-use-concerns/). &gt; This style of coding is an inherited relic. Is it, though? I get the impression that this is still DHH's (and by extension, Rails') preferred style of design. A Rails 5 controller class has _61_ modules included into it, by default. I'd be interested to hear Rails core team members' opinions on this topic. &gt; Iâ€™m sure once everything has been sufficiently extracted to small classes, weâ€™ll have a revolution where we relearn how much fun making a thousand-line-long module is. We're kind of already there, just not in the Ruby community. I think Rubyist tend to be particularly zealous about having itty bitty methods and classes, compared to the rest of the industry.
I think they had to pivot their model to make it feasible. Still a frustrating situation though.
Finishing up my application to launchcode.org. Hoping I'm good enough to start their apprenticeship program. *fingers crossed*
Speed and memory usage. Also bundler is a perennial issue. Oh and half baked gems which seem to pollute github.
working on a sync process for mailchimp into my SaaS to avoid having to also build in rich templating for email purposes.
What kind of bundler issues?
Yeah, large (I wouldn't say huge) rails codebase and finding local developers. More and more i'm wishing the original team had gone for something more like Sinatra and less like Rails. I don't particularly like the rails design decisions long term, and at this point we'd pretty much have to start over if we wanted to go a different direction. If they had though, it probably would have taken longer to get to a MVP so... As far as hiring, it sucks because the company refuses to hire for remote and we're a small team without a lot of the "cool/hip" benefits that many startups in the area have.
How closely did the original team stick to The Rails Way? Are there service objects, or anything like that?
&gt; launchcode.org Looks cool, I would be interested in a follow up about the application process and what happens once you get in. Good luck!
I feel you. When I was learning Rails, I found myself understanding it's appeal, but personally preferring Sinatra more. Once you get something up and running in production with Rails, you're pretty much stuck with it and that makes it hard to scale if your app turns out to be successful.
Have you checked out Vue?
Don't forget about caching!
Learning Sinatra (first time dabbling in backend web development)
None. I do PHP development during my day job and I just hang out in this sub because I like to dream of a better future. 
&gt; I don't think that "having everything in one file" is a very strong point against modules My position is that I would prefer one 5K line file over five 1K line files. However, they're both bad, instead you should understand and use classes, which happens to be my main point.
Trying to reduce the memory usage of our app. The business has grown far beyond what the original devs expected (being generous, they just followed the "rails way") so I'm trying to refactor the code so it doesn't use all the memory, and I mean ALL the memory, without breaking everything. 
It's ok little twig template friend. {{ }} luvs you. 
Holy crap. 
@thefixer9 Thank you! :)
Heard nothing but good things regarding PHP 7 
&gt; What happens when you want to filter this dataset in some other way, you likely add a new method to Region, right? If its a primitive, you just use a `select` or whatever appropriate enumerable method. The next person coming along knows exactly what `select` does and they don't have to go find the implementation elsewhere. As a(nother) counterpoint, the next distinct *user* of that data also has to go use select to implement their filter. Now the internals of your Hash are tied to even more pieces of code. Following the advice you're giving, the refactoring from array of arrays to array of hashes would be more challenging simply because the internals of the array are *also* the externals of the array's API. Moving from storing an array of arrays to an array of hashes involves updating every piece of code that consumes that data structure. Aggregate data structures are insidious things. Since they "hold the data" we tend to pass them around and nest them. Eventually that nested structure ossifies as various pieces of code that work on the data unpack the parts they need. You can't simply change the structure because it is now part of the API you're exporting. I guess the point I'm making is that the indirection of a class often isn't a big deal, and nobody thinks hard about the consequences of exposing underlying data structures until they have to change.
I mostly agree. In my experience concerns are often a hiding place for logic that properly belongs in a dedicated class/module/etc. *Especially* when the logic of a module is mixed across multiple modules or even the module/class barrier it can be hard to "see" that some new construct should exist. That said, in some ways the game of "method definition Where's Waldo" is inevitable. Code has an upper limit on complexity in that someone has to understand it to change it. Business requirements, it seems, do not play by this rule. :P The best you can manage is to architect your code such that the tools necessary to understand it are in the places you (or other programmers) would look to find them. Given that whole lecture, concerns are a problem. They mask complexity and responsibilities, and make it difficult to *correctly* identify responsibility with your first (or second, or third...) guess.
Just changed fields and landed my first junior rails dev position at a health care tech startup. Learning how to write tests using RSpec and Capybara ATM because it's something I've never really done.
That's true :D
Starting out with Ruby TDD 
Having to type bundle exec before I do anything for one. 
As other has motioned Structs are great. I usually put my data in Structs. REGION_DATA = [ ['California, US', 'SV1'], ['Illinois, US', 'ORD'], ['Virginia, US', 'IAD'], ['Amsterdam, NL', 'AMS'], ['Tokyo, JP', 'TKO'], ] Region = Struct.new(:name,:code) do def country self.name.split(', ').last end end REGIONS = REGION_DATA.map{|region_data_point| Region.new *region_data_point } p REGIONS.map(&amp;:country) #=&gt; ["US", "US", "US", "NL", "JP"]
Mostly working on improving GitLab performance, as well as keeping GitLab.com up and running (especially in the past few days) along with the various other production engineers. This can roughly be summed up as http://i.imgur.com/mOnvOJG.png.
With Rails 5 API mode you can separate your front end code from your backend, even in different repos, and just make JSON requests from your front end
I'm rewriting a offline-first optics calculator. Built with PouchDB/CouchDB/React/Redux and written in ES6. Backed by a Rails app. It's going well so far. Prototyping things are just a whole lot slower with this stack vs. Rails.
Are you aware of bundle binstubs?
Try programming Clojure for a while. It'll change your perspective on these "principles". 
Ah I see. I just gave it a little read. The reason I'm leaning React is because my current job is heading that way. I've been hoping to have this all figured out in time for this weekend's Ruby Rampage.
Intermediate. Self taught though, so I may be missing experience with things people consider basic. I get paid to develop / implement automated testing tools in Ruby. I spend most of my time either designing out a gem in order to mock a complicated and clunky system my company's application uses for testing purposes. If not that, modifying existing gems like.. watir/selenium, rspec/cucumber, active record. My biggest struggle may not even be Ruby specific but adjusting ruby code to handle interactions with my company's legacy applications. 
forget integration with rails. Build a simple API with sinatra/roda/grape. Build your frontend on node using webpack/babel/react. Use one of the many proxy libraries to proxy API requests to your ruby backend. Use the frontend tools on the platform they were designed to work in, and use ruby for BL, where it will always be solid. 
I felt your pain before. You should checkout https://github.com/byroot/bootscale
Massive mess of old legacy data models that are shared between multiple legacy rails apps that have been around since rails 2. Currently upgraded to rails 4.
You may be out of luck as there are serious issues with Selenium/Firefox right now: https://github.com/jnicklas/capybara It is not clear what the end purpose of this exercise is. If you are trying to scrape web content, you are much better off avoiding the complication of automating external programs and instead use Ruby-native libraries like HTTParty (to fetch the content), and Nokogiri (to parse and walk the DOM). Here is a great example: https://github.com/mattmorgante/nokogiriscraper/blob/master/hostelworld.rb
I have used both and integrating the assertion into dot net was significantly quicker. The SAML libraries make it a breeze to decrypt and verify the signed assertion. It was a lot more footwork in Rails to parse the xml. 
Hopefully they are using Twig, it's much, much nicer than straight PHP templating
I've been trying to get Rails 5 API to mesh with JSONAPI, Authorization with Pundit, and Authentication with javascript web tokens. I'm almost there but all the pieces are scattered and integrate differently with Rails (of course).
What was your field before if you don't mind me asking?
The fact that I used a partial to DRY my code, it was called a few thousand times in one particular request. Moving it to a helper cut render time from 6s to 3s :|
As with all things it depends. Primitives are an excellent starting point to store your data. Not everything needs to or should be a class. But as your needs grow and the primitives are either too general or aren't providing your with the correct interface then sure wrap them or replace them with custom a class. But I wouldn't advocate jumping straight there.
How about something like http://watir.github.io/? It looks to me that Watir will do exactly what you are looking for. 
Checkout the selenium webdriver https://github.com/seleniumhq/selenium I've used this to do exactly what you're talking about. The only set up I remember is requiring the gem and making sure chrome is on your path variable.
For sure. If I was in there making changes, I'd be doing the same thing. I was just interested to know whether the team's opinion is _"we try not to do that anymore"_ or _"it works fine so we still do it"_. Sounds like there's a mix of both opinions.
Godspeed. If you come out alive, let us know.
Hey !, *hug* Trying to make sense of this pre-maturely optimized codebase. Trying to fix the billing and invoicing module in this heap of crap . ( lol ) . Do not use Background processors to manage **every flow in your app** guys. I need some coffee. 
Gluing my angular frontend with a rail based backend as a single page application.
Ya, a lot of the great new stuff (not to mention the incredible speed increases) in PHP7 are very welcome. Unfortunately a lot of the systems I work on are in enterprise and they are stuck on versions as old as 5.2.x of PHP which are past EOL. We are starting the process of migrating to PHP7 and I really look forward to it. That all being said, I do at least get to write my own Ruby scripts for my day to day needs. Ain't nobody gonna hold me down!
HAHAHAHA you think we are using templating at all? :( **:( :( :(**
I'm a junior developer in my first job out of my first career. (Event and project manager for 10 years.) Im working with another junior developer (he's got a better grasp of ruby and JavaScript than I do). We are building a number of one off sites. However our main projects are building an internal and external site for the company Using rails. I'm knee deep in ActiveAdmin, tons of models, odd design choices, and hacked together CSS. Right now I'm just working on getting it to a place where everything works as intended. I'm dreading to see the speed tests as I don't really have an idea on best practices regarding database calls and model setups. I also haven't had experience in launching a full fledged production ready app before. I am looking forward to refactoring my CSS though. 
A lot! I'm currently developing an application to collect information just in time on a national votation and my doctoral thesis is sustained on three apps, all in ruby. Sinatra is my friend, with Sequel. 
watir watir watir it's the way to go way easier than alternatives for what you're trying to do
&gt; https://github.com/byroot/bootscale Thx for the link, it looks definitely very interesting. I'd assume there is a RAM tax depending of the dependency tree, but might help some. 
@hirolau I'm not sure I've got your point. In your example you extracted a class like I did. Do you agree that sometimes data structures are not enough and we need concrete classes?
Are there leaks, or big in-memory caches, or something else?
It's cool to see some graphical work in Ruby (despite the slowness). I was recently playing with Gosu too: https://www.youtube.com/watch?v=QBjPhmk0xZw
The two most senior members on the Rails core team are Jeremy Daer and DHH who currently work at basecamp. Mathew Draper also works at Basecamp. They all communicate over Basecamp and everyone on the core team seems to hang out with Basecamp people at conferences, talks, hackethons etc. I'm not going to dig up every interview and blog post (like [this one for example](http://solnic.eu/2016/05/22/my-time-with-rails-is-up.html)) that indicates that DHH and the powers that be (in my mind, the top brass at Basecamp) won't progress Rails because it currently suits their needs, but suffice it to say with a little googling you could certainly find more. Maybe I'm being conspiratorial, but I really don't think you can say it operates *entirely independently* of Basecamp without additional evidence.
Ah yes, the good old ORM dance.
@jodosha Yes. Structs are mini classes and I use them a lot so I agree with the article. I just wanted to point out how easy it is in Ruby to create a small class AND create objects using the data in the article. 
That's what I came here to say. Command line tools also don't handle *, it's the shell. This way, no command has to implement * parsing.
It's not terrible but there are some gotchas. * Start the rails server with **script/server**. Doing **rails s** will create a new project in your project called **s** * There is no asset pipeline, you need to use front end tools for that, we're using a straight forward gulpfile to compile our sass * Active record is a bit different, no **where** and you can do **Model.find_by_field_name("Value")** * You can use gems as normal, however you can also use **vendor/plugins** which I believe is deprecated as of Rails 3.2 There's loads of other tidbits like this but it's generally been ok. I did a bootcamp from Jan to April learning Rails 4.2 with Postgres so this was a bit of a shock to the system, also in bootcamp you don't experience what a monolith app is like. For example this app has 150 models and trying to wrap your head around how everything is connected is a fools errand. I just try to understand small sections at a time and slowly it becomes clearer how they work together.
I was recently doing many interviews and now I am implementing some push notifications with ActionCable.
It does seem like it should at least be an option, if it's easy to implement. It perhaps shouldn't be the default to allow `*` to be passed to the remote shell unescaped -- what if you actually want to get a file whose name actually ends in `*`? It is possible. So simply refraining from escaping would not be backwards compat. Should prob be an option though. Another workaround would be using straight `ssh` (perhaps `net-ssh`) to identify the exact paths of the remote files you want to get, then getting them with net-scp. 
ok, you are right. It's not allowed on Windows though.
I think it's mostly in the camp of "still do it". The notable exception is work in Active Record where Sean is actively working to move things into classes, however, you still have to preserve the existing APIs etc. so there's only so far you can take it. It's much harder to move everything into classes and have it all be backwards compat, much harder than if you were starting from fresh or you didn't care if you broke APIs. New features are more likely to have a class or two sprinkled in than they would have in the ole' days.
I worked as a research technician in a neuroscience lab. Decided I didn't want to pursue a PhD, and was fortunately bit by the bug while learning to program in my free time.
then use watir. your use case is what it was meant for. it's super easy. i know folks who can't code but can write watir scripts. 
You really scp files down from a Windows server? How novel! 
No offense, but I think I probably know a bit more about how Rails operates than you.
hopefully the primary goal is to update versions. The artifacts of version 2 commands and behavior are the LEAST of your concerns. I can guarantee you that you are currently exploitable.
At work, weâ€™re not deciding on our test-writing style: let blocks like `let(:arg) { 5 }` vs. instance variables defined in a setup method like`@arg = 5.` Iâ€™ve found no disadvantages to let. Iâ€™ve found many disadvantages to instance variables. And so, :thumbsdown: for instance variables. Iâ€™ve written many specs and have read the rspec docs, betterspecs.org many times. I use let because RSpec is slow so the purported advantage of lazy evaluation is not going to make a noticable difference even if I cared about that stuff. Using let removes complextity in your examples by removing setup noise thereby making clear the behavior that you are testing. Instance variables in setup functions pollute the scope and make my test state order dependant. Instance variables in examples add unecassary noise making my examples harder to understand. Let makes it simple for me to easily control the values of my test inputs by using scope. RSpec isn't ruby. If I cared about this I would use minitest. So for me, let makes my tests easier to reason about and removes the problem of test cross contamination. :) 
&gt; So for me, let makes my tests easier to reason about and removes the problem of test cross contamination. I don't think `let` solves this â€” the new symbol is in scope in all contained tests. ?
Nothing wrong with that if that's how you do things, but I try to avoid method declarations in my specs if I can. I like the "fire once and hold results" quality of `let`, too.
We found the PHB!
Actually you're probably right for before hooks, though I'm sure what happens for nested scopes. Instance vars in your examples are a problem though.
&gt; You have to re-implement something using a new framework or library &gt; A library youâ€™re trying to use doesnâ€™t like the other library that youâ€™ve been using &gt; The API youâ€™ve been integrating doesnâ€™t do something you thought it should do &gt; The framework youâ€™re using doesnâ€™t like unit tests and the ones it has are actually integration tests &gt; You thought a model in this new framework was a singleton like in the other one but itâ€™s not Literally every one of these problems (except the last, which is confusing to me) are something that experienced programmers answer before they give an estimate.
Which Ruby version do you use? I don't get quotes in the output with Ruby 2.3.1. You can also try to manually set `:force_quotes` option to `false` (though it seems to be the default for rubies &gt;= 2.0.0), like this: output = "This is a ruby output" CSV.open("output/abc.csv", "a+", force_quotes: false) do |csv| csv &lt;&lt; [output] end
I estimated a project I did as an independent at 400 hours. The client wanted a fixed cost though. I gave them the price based on those hours and the rate I wanted. I still tracked the hours myself and came in within 10%. Like you said. Good developers will answer some of those questions before starting and take the rest into account. 
&gt; PHB Actually, I'm Dilbert. :-) 
I know the organizations of those people and the three people I mentioned that work at Basecamp are definitely still committing code. I'm not saying that DHH, Matt and Jeremy shouldn't have jobs, I'm just saying that from time to time it seems like they may steer the ship to behoove Basecamp. I thought that it was obvious that my original comment was kind of a joke anyway. 
PS: Wasn't sure whether to link to the side proj or not, so doing it [here](http://www.programmingposters.com) - if it gets punished with downvotes (am a reddit lurker, not so much a poster), hopefully it won't kill the question itself, which would be good to get a lead on. 
God does all of that pretty well already..
&gt; Actually you're probably right for before hooks, though I'm sure what happens for nested scopes. The same as with `let`? You either override the value or you don't?
I'd check the mailing list archives. ruby-talk maybe?
Ditto the Google groups `comp.lang.ruby` archives - earliest records still talk in terms of the acronym, not the long form
Probably IRC I'd say, good luck hunting, report back plz
Yup, very strange results given the massive difference from the benchmarks in the README.
Yeah, I misread the wikipedia page. Still, MINASWAN is an acronym, so I don't know why you would assume it has anything to do with One Piece. It just happens to sound japanese, but the acronym is from an english phrase.
The only major difference I can see is that God doesn't use a procfile. Are there other major differences? Also, I've found god to have some tricky heisenbugs when running in production, e.g. https://github.com/mojombo/god/issues/189 I'd be curious to know whether Procodile is more consistent in this regard.
&gt;It just happens to sound japanese, but the acronym is from an english phrase. Yes, that's been established already. &gt;I don't know why you would assume it has anything to do with One Piece I didn't assume that. I was just saying it sounded like a One Piece reference which isn't too far fetched considering how big One Piece is in Japan. I was just throwing it out there since it seems like like the origination of the term had already been figured out.
Ruby/Cucumber for Automation testing. I am also working on a really cool Sinatra based app to view test results re-run failed results and drag and drop Gherkin builder for non technical QA to add tests using existing reusable steps.
Dang. Yeah that's where I am &gt;_&lt;
I use that from time to time. It doesn't serve as *documentation* thought.
Http://vuejs.org -- created by a former google employee, intentionally very clean API and very well architected. Highly recommended. 
How do you deal with csrf token and with authentication/security?
You choose to not use all of it's features because "who needs the rest"? That doesn't make any sense to me. Agreed Capybara is an adventure haha I'm not having any issues with RSpec. I've just noticed that a gather all my resources and knowledge about it from 10 different sources and I wish there was one easy to read place for everything. I'm actually enjoying rspec.info/documentation.
How do you approach authentication, user sessions, csrf protection?
What doesn't make any sense to you about that? I have found the basic features sufficient for my needs. I guess 'who needs the rest' was needlessly glib, perhaps some people do, but in my opinion some of the other features (such as `example`) are needlessly complex for no real gains in readability/maintainability/ease-of-writing in specs. So I don't use them. Every feature is a trade-off, the cost is you need to understand them well (with rspec's crappy documentation), debug them when they go wrong, etc -- the cost needs to be justified by benefit. In my opinion many of rspec's features do not have a sufficient benefit. In my opinion for most people most of the time, but I can of course really only speak of my experience. This is what leads some people to abandon rspec entirely for minitest -- I did try that for a while, but found minitest was missing some features that were too painful to go without (multiple before/end blocks, tagging, I actually do like `let`), and while they can usually be added to minitest with various plugins -- in various states of maintainability and compatibility -- fighting with that made me go back to rspec -- but rspec's basic features I actually need only. For me, rspec's basic features is the right trade-off. I suspect they will be for most people most of the time, but of course I only know my experience for sure. 
Sadly not uncommon. Benchmarks are worthless unless the code is available to reproduce them.
I avoid many of rspec's "fancy" features (no thank you `example`), but actually really like `let` myself. &gt; the purported advantage of lazy evaluation is never actually realized. Iâ€™m most always running all the tests in a file, and so thereâ€™s no time efficiency gain; I don't think this is right. Every let is re-evaluated for _every example_, it doesn't matter if you are running all the tests in the file or not. Only the `let`s referenced by a particular example will be triggered, but if another example references the same `let`, it'll be triggered again. They aren't cached between examples. Same for every `before` block for that matter, unless you do `before(:all)`, which is recommended against unless you really need to do it, because example-independence. Still, I think 'performance improvement' is probably indeed minimal with let, and not a real reason in it's favor (I'd take more readable/maintainable specs over faster specs any day) -- but the only real reason to know for sure is if you measure it, curious if the OP did. &gt; the API [let and let!] and their magic increase the codeâ€™s complexity and so must be balanced out by some other advantage; I think this is the right approach, but I've found let's complexity addition to be pretty minimal. I haven't run into any problems to debug because of `let`, and personally find it _increases_ my spec code's readability and maintainability (which is another kind of 'complexity'), which is the advantage I think makes it worth the added feature. &gt; Let introduces magic and apparently nondeterministic behavior which has broken my tests, and Iâ€™ve only been able to fix by converting to easy-to-understand @- variable instantiations. Hmm, I have never run into this. Apparently nondeterministic, really? Definitely never run into that. But if I had, I probably would have taken the same path as OP, do what works. I might personally have used instance variables only in the examples/contexts/files that had the problem. But I guess if I ran into it more than once or twice, I might start avoiding let prophylactically too. But I never have, and haven't heard too much about people having that problem, curious the nature of the scenario where OP had this sort of problem with `let`, but it's probably lost to the sands of time at this point. &gt; Let has the problem of introducing non-ruby syntax â€” something that looks like an automatic variable isnâ€™t one anymore. Don't know what you mean by an "automatic variable". It's true that let means you can refer to something that looks like a local variable or method call, that it's not clear why it exists, it's just there because of `let`. But I've never been shy about creating 'helper methods' in my specs either, just with `def whatever` -- also part of the general approach avoiding fancy features when straight ruby will do. When you do that, you're also making a method call to something defined in the spec file (which I think is actually way better than a method call to a test helper defined _somewhere else_ and who knows where). So I just think of `let` as automatically defining an accessor method with the same name as the argument. Whether that's actually what's going on or not, it serves as a fine mental model, and makes it no longer seem like spooky ruby magic at a distance, it's just defining a method same as my local `def`s for helper methods, no big deal, not really non-ruby syntax. 
Tom Dalling recently did pretty decent work to have around exactly what you asking for: * http://www.rubypigeon.com/posts/rspec-core-cheat-sheet/ * http://www.rubypigeon.com/posts/rspec-expectations-cheat-sheet/
Things that actually _are_ preconditions, I tend to do in a before block too. In this case, "the article already exists" is a precondition -- you might even want a different spec for calling `delete` on an article that didn't already exist (null id, or id that isn't in the db). I'd use a before block there, but might still combine it with `let` context "with an existing article" before do article # article exists end it 'deletes the article' do ... Or might use a begin block with instance variables for a precondition, but it's not really true that let _can't_ replace instance variables -- either way, I think it's just important to be clear about your pre-conditions. But before with instance variables for pre-conditions is not unreasonable. But I wouldn't let it drive me away from using `let` anywhere, even in cases that are not pre-conditions. I've even sometimes been tempted to make a `precondition` alias for `before`, but I guess that's kind of what `before` is always for, and I am allergic to aliases, so I just stick with `before`. But I find it very helpful to think of it as "preconditions". Not everything you might want to use `let` for is a precondition, some things are just objects you need to use in your example, but the ones that must be assumed to exist _before_ you even test that something is working are preconditions. Which is also what `let!` is for, but it's reasonable to think `before` is more clear than `let!`, which doesn't stand out visually from `let` much. it's not clear to me how always using `let!` instead of `let` "makes [your] intent obvious at any given point in the spec"
To be honest, Tom Dalling's docs I mention above is pretty good effort, but I'd prefer to have something like "editable wiki" of the shortest-cheatsheet-possible. Something that community could support and update. Sometimes I think we are still ridiculously unable to do some "community effort" when it is about documentation/introductions/guides. Recently, while mentoring students, I was fascinated by the fact how hard it is to find good introduction/cheatsheet/guide/reference for most common instruments (starting with RSpec).
Or the logging itself doesn't work(disc full, wrong permissions) but since it's disabled for the health check you will get a nice 200 OK back from the health check but anything that actually logs something might crash.
Then you have a new feature to add, and one of your "instance variables" which wasn't a pre-condition before needs to be now. Better yet, you realize that a particular spec is no longer needed, and delete it. Along with that spec goes the requirement for `foo` to be a pre-condition, and with a mature enough suite, what are the odds you (or a very junior developer) are going to catch that? So you end up with a strange soup of `let`s and `let!`s, which are often as not arbitrary. It's more readable *to me* that nothing be lazy-evaluated, and that anything which *should* change state be explicitly a closure, not just some expression which may or may not be lazily evaluated. Any time "getting an instance variable" changes state, I'm put off. I would use before blocks for everything, but I do find the `let!` syntax cleaner.
A new way of ruby memoization using Singleton class. 
I would look at using: page.should have_selector?("Entertainment"). Capybara waits up to 2 seconds to but I use a block method to set the wait to what I want. I would use something like below def lower_wait_time(wait_time) original_time = Capybara.default_max_wait_time Capybara.default_max_wait_time = wait_time yield Capybara.default_max_wait_time = original_time end lower_wait_time(wait_time){ page.should have_selector?("Entertainment")} 
I've taught (more like guided) several rounds of introduction to programming using this book. It is extremely hard to find programming books that literally assume no prior knowledge of software development. Even the ones that say they do often inadvertently make assumptions that trip up people who are truly new to programming. It is definitely not out of order. As others have mentioned, he provides both a basic solution using only the concepts taught so far, and also a more advanced solution that does use more advanced language capabilities and techniques, but you can ignore them. If you have experience with other languages already, then it is probably going to be too basic and you'll want to look for something more advanced, as mentioned in the other comments.
Ember isnt bad, but I don't enjoy it as much as working with Ruby.
Hi. I started with minitest
Not in the classical sense as it's a processing pipeline for data from many different sources with no way to actually edit it. 
thanks buddy...wow..i didn't know you could even do that in any language. Being exposed to only c++ definitely has its cons. i will look into more :)
His wrk is run as wrk http://127.0.0.1:4563 -c 1000 -t12 -d 10 so he is running it for a shorter time but with way more connections and threads. I ran it with his settings and still got an insane number of socket errors so there is something clearly wrong.
Kevin Ballard here. I already replied to Steve's email, but for anyone following along, I [found the post](https://groups.google.com/d/msg/comp.lang.ruby/bb2s5gwe50I/xT9dfxITw9kJ ) I made that the Ruby Weekly issue was referencing and in that post I linked to the rubygarden page (which indicates the phrase already existed at that time). Of course, it's possible that I did in fact coin it earlier and was referencing my own phrase at that point, but I doubt it. I was pretty new to Ruby at that point, and of course had never talked to Matz, so I doubt I would have said something like that. Unfortunately, I'm also unable to come up with any previous references in my own searching, and it looks like I don't have any IRC logs from that time (since searching the web isn't coming up with anything earlier it's quite plausible that it came from IRC, but someone who kept IRC logs from back then would have to check).
CNt wait to see the results!
why would you post a tweet that's nothing but a link to an article, instead of posting the article?
I'm also having a failure in a simple test. If you have the time, could you help? I'm trying to just select a red x on a page and I'm getting a failure: &gt; ElementNotFound &gt; Unable to find css "delete_daily_log" This is from the failing line: find(:css, "delete_daily_log").click When inspecting that red x, [here](http://imgur.com/a/SlcML) is what you see. It looks to me like there is no id to select. Do I have to use the css selector or xpath?
My [Dockerfile DSL](https://github.com/raviqqe/dockerfile-dsl.rb) is using it. But, I'm not sure whether there can be any practical application. I wrote this just for fun. 
Alright, interesting :)
Ruby has the ability to do Lisp-like things, but it's not a Lisp. I once hired a guy to my team who was writing Ruby because he couldn't get a decent paying job writing Lisp (his first love). His code was highly functional and very solid.
I don't think it's that weird that numbers would be objects, and you won't either if you think about it from another angle. Objects have two things: behavior and attributes. What are some attributes of a number? Well, they can be prime. They can be even or odd. They can be positive or negative. They can be undefined. Behavior might be a bit tricky to wrap your head around for numbers, but numbers can square themselves. Numbers define ranges. Numbers can increment or decrement, be multiplied, divided, square root, etc. When you write "z = x / y" you're calling the "/" method on x and the "=" method on z. So if you have attributes and behavior, you can have a class and an object. A big draw of ruby and rails is readability. The syntax of 1.month.ago is convenient to read and understand compared to something like Month(1, :ago), which might be more correct in terms of what object is creating the date time, but is less appealing to read.
&gt; `1.month` or any variation just returns back a Fixnum irb(main):001:0&gt; 2.minutes.class =&gt; ActiveSupport::Duration
I just had a look on the gitlab source code... Damn, models are scary big. Looks like a nightmare to work with.
So, I wound up learning Ruby for work, and I came at it with a Python/Java base. While learning it I kept a list of things I liked. - The unless control flow, super succinct sometimes - httparty (a great http library) is a dream to work with - rspec is just lovely for testing - metaprogramming facilities (.erb, blocs/procs/lambdas, and class opening/monkey-patching) 
Just don't confuse Rails with Ruby. Rails has a nightmarish collection of libraries and an entire ecosystem of tools to manage them. I would install [rbenv](https://github.com/rbenv/rbenv) (or it's more complex sibling rvm) to allow switching to newer versions as needed. Then you can start playing. Also, irb and the enhancement [pry](http://pryrepl.org/) allow [repl style exploration from the command line.](https://repl.it/languages)
I am an old Lisp person, having written two List books for Springer Verlag decades ago. Of course Ruby is a Lisp. Haskell also.
- exactly, unless just looks really great sometimes. - So, I'm a big fan of the Python library called Requests, and HttParty is the Ruby equivalent, and it "just works" really well. 
Of course it's possible. But why? 
What the other guy said. This is rails, not ruby. Ruby gives you a lot of freedom and also does not judge you for abusing that freedom. The best thing about Ruby is how succinct/concise the code can be. If well written it's a joy to read. 
There is something similar here http://ironruby.net/
Ah, indeed. Lisp is short for "list processor" and ultimately that is all programming is when you abstract far enough. It's a beautiful thought, really. The difficulty is in how best to organise the things that your lists are made up of, and how best to process them in a Von Neumann architectureâ€¦ I now want to drink red wine or whiskey and read SICPâ€¦ 
Sure, it'd be possible. It'd be many many months of work to make it reliable and performant. 
hm, that's pretty cool.. well mission accomplished, now I actually want to learn ruby instead of just passing this course :)
One of the goals of Ruby was to make programmers happy. It is hard to explain exactly what this means but once you've gotten comfortable with it I think you'll find it very enjoyable to write and read. While programmer happiness is very fluffy its gotta be my favourite feature.
This needs more information and examples of the issues documented. Otherwise it is a pure "100% my opinion, trust me" article that doesn't really explain or educate. 
I don't get why would I use that DSL since it doesn't offer anything new or ease of use to already creating a Dockerfile the regular way. I know you said you wrote it for fun, but was it meant to be useful somehow?
Sure. But why not use jruby? Or even mri ruby to start with. Or interop w/ ruby from .net. Why do you want to jump directly to a complicated task?
 Months, years, who's counting?
The enumerable module and blocks stand out as cool features of the language. Here's [a great article](http://yehudakatz.com/2009/08/24/my-10-favorite-things-about-the-ruby-language/) with more. But the best thing about Ruby might be the community. 
When you're building a DSL, you want to very carefully control where and when a term is evaluated. For example, in Ruby, I define a class with: class MyClass end What if I want to write a DSL which allows me to define molecules? The closest I can get is something like: molecule :MyMolecule do end Which is admittedly pretty good compared to most languages. However, notice what's happening - I'm forced to use a symbol (:MyMolecule) instead of a simple identifier (MyClass). Even with this seemingly small difference creates a thorny problem for me, the DSL author: I need to figure out which module :MyMolecule should be added to. (I actually just spent a few hours on this problem; it was a pain). The reason I have to use the a Symbol (:MyMolecule) instead of an identifier (MyMolecule) is that in Ruby I can only use functions to get things done. Functions evaluate all of their arguments, so I'm forced to use a Symbol, which evaluates to itself to get an expression kind of like what I want. Lisp provides macros which allow me to manipulate the AST *before* evaluation, so I can control which parts of the AST get evaluated. In Lisp, I define classes like so: (defclass myclass ...) And I trivially write a macro that could be used like this: (defmolecule mymolecule ...) What's cool is that even in the body of my molecule, I have control over whether the AST gets evaluated or not, so I can really go to town creating my own mini language. In Ruby, I'm forced to figure to think of every expression as a function. Here's another example. Say you want to write a SQL DSL in Lisp: I could create a macro that could evaluate this expression correctly: (select * from my_table t where t.name in ("bob" "jill" "sam") and t.score &gt; 10) Try doing something akin to that in Ruby. In Lisp, we can do this by defining a macro called select. It takes the rest of the list without evaluating the arguments. Obviously, you might actually want to evaluate parts of this expression, and decide which parts depending on the syntax. For example, say you wanted to prevent evaluation of all the SQL special keywords (select, *, where, in, and, &gt;, etc) and anything the syntax determines should be a variable, you could do that _easily_. Then, you could write expressions like the following: (let ((table "users") (names '("bob" "jill" "sam"))) (select * from table t where t.name in names and t.score &gt; 10)) That should absolutely blow your mind if you only have experience with mainstream languages. And that would be _easy_ to do in Lisp. Since Lisp represents the AST as lists, and the language makes it super easy to write and manipulate lists, writing macros is often just a matter of writing list manipulating code. Lisp syntax even makes it easy to splice lists into other lists, for example, to write my molecule definition form, I might write: (defmacro mymolecule (name &amp;body) `(defclass ,name (molecule) ,@body)) The "`", "," and "@" characters are syntax to make it easy to splice lists together. Since code is lists, you can easily write code which writes code. If that's not enough, you can even modify the reader. Common Lisp purposefully leaves [] and {} unspecified. For example, say you wanted to include Prolog expressions in your code. You could override the [ and ] characters to write syntax like the following: [grandfather ?x ?z &lt;- father ?x ?y and father ?y ?z] [father adam seth] [father seth enos] [grandfather ?x enos] # might evaluate to ((?x . adam)) The [] characters might transform their contents into lists that begin with the symbol "prolog". Like so: (prolog grandfather ?x ?z &lt;- father ?x ?y and father ?y ?z) (prolog father adam seth) (prolog father seth enos) (prolog grandfather ?x enos) # might evaluate to ((?x . adam)) And, as you've guessed by now, prolog is just another macro, which allows you to mix prolog into your regular Lisp code, like so: (let ((grandfather-of-enos (assoc '?x [grandfather ?x enos]))) (print grandfather-of-enos)) So next time someone tells you Ruby, Python, {insert your favorite language here} is a Lisp, you can be they don't really understand Lisp. 
&gt; The power of Enumerable I did not know about Enumerable, until I reimplemented `Enumerable#each_slice` as `Array#fracture` and my friend asked why I bothered. Oops :p
&gt; I don't know ruby (yet), but from google it seems that the unless is just syntactic sugar for if ! right? Yes. It's nice sugar, because it can make a cleaner expression of intent, but yeah. `unless CONDITION` is fully synonymous with `if !CONDITION`
One strength of internal DSLs in general is that we can exploit expressiveness of host languages. For example, Dockerfile doesn't provide ways to combine strings, define macros, include part of another Dockerfile and etc but Ruby does.
afaik, you can't use Typhoeus with httparty? whereas with faraday it's one config line. it's also dead simple to stick in middleware (e.g., we have an internal service-to-service schema).
~~The number of threads is based on all threads accessing the same shared memory. If two thread pools don't access the same shared memory than the same limitation doesn't exist.~~ See below for the answer from /u/jrochkind I don't really know enough about the individual implementations, just that Ruby is not very good at lots of threads. The good news is rarely do you need many! Processes are very heavy, when you fork you duplicate all memory. This also means you have no shared memory so the same lock contention doesn't exist, but then you need something else to co-ordinate jobs. There are some libraries like sidekiq and resque that do this well.
What about sub-processes ? Do you think they have the same performance costs as Processes ? What would you do If you had to send 100 emails or ping 100 computers at the same time and get the fastest reply possible ? Let's say by using CRuby. Which do you think is the most efficient way, except from using libraries as Sidekiq etc. ?
The truth is that I tried this with pinging an /24 subnet and a thread pool of 254 was much faster than a pool of 10 or simply 4. Something like this http://stackoverflow.com/questions/9485441/method-to-find-available-devices-from-255-ip-address. Considering that you reply is correct, why do you believe this happens ?
It talks about 2.0, we're at 2.3 now (2.4 soon). So you'll miss a few small things like required keyword arguments etc, but most of the book will be up to date.
I've been spending the last 9 months learning Ruby on the job. Well... My job has repetitive tasks I wanted to learn to automate. I picked ruby and began doing it without asking haha. But I never picked up a book. Not knocking books. Theyre a great offline reference tool. Dash, rubydoc, and simple Google searches have taught me a great deal without ever needing to have a book on my desk. *Edit* - expanding my thoughts - From my perspective preparing to learn a language by finding the frightful resources is less important to just doing it. Pick a small simple task and learn to do it in the language you want. For example, I have to repeatedly pull certain info from a Google sheet and put it into a CSV. I used ruby to pull down the sheet, grab the fields I want, and create a CSV. A task that took 5 minutes manually now takes 1 second. Taught me to connect to a web service. Put data into a file with a certain format. The. Remove lines I didn't want. Simple little project that taught me quite a bit of basics.
It's useless to have more "runnable" threads (i.e. threads that have some calculations to do and don't wait on I/O) than the number of CPU cores. Even worse, with MRI Ruby threads that calculate some stuff (say render a template) won't run concurrently, so you have to either use JRuby or fork the process (and use some kind of IPC) to fully utilize the CPU. If the load is a mix between CPU-bound and I/O-bound you have to determine the number of threads experimentally. If the thread launches other programs it should be treated as doing the same kind of load that the process it launched (CPU-bound if it launches `convert` or IO-bound if it launches `curl`). I suggest using `concurrent-ruby` that has a number of useful classes like ThreadPool, AtomicValue, Future etc already implemented.
Honestly, even a 1.8.7 book would have you learn the language just fine. Might be needing to use some gems or different gems unnecessarily, but the language itself has stayed the same. More optional improvements, and performance that has really come through over the years.
Why wouldn't you just use Typhoeus in that case?
Whups, I guess that has changed :) Rails 4: [1] pry(main)&gt; 2.minutes.class =&gt; Fixnum Rails 5: [1] pry(main)&gt; 2.minutes.class =&gt; ActiveSupport::Duration
I actually used Rails 4.
Yeah I use that all the time, but that's a shell-script kind of trick and I figured OP might not want to get hit with that just yet :p
&gt; Pick a small simple task and learn to do it in the language you want. problem with that is that atm I'll use ruby mostly for web stuff.. but I want to make sure I know ruby as well, not just ruby on rails if you get what I mean
The closest parallel would be ruby 1.8 to 1.9, and the most significant change there (that required people to do a lot of work on their software) was with character encoding. If you have a book that's post ruby-1.9, it'll be missing a few things and get a few things wrong on the edges, but they'll be relatively minor details, you'll be okay. 
I can think of rubyish ways to have the same semantics: select from: my_table do |t| t.name.in ["bob", "jill", "sam"] t.score.gt 10 end Or r = Relation.new r.grandfather :?x, :?z, if_all: do father :?x, :?y father :?y, :?z end r.father :adam, :seth r.father :seth, :enos r.grandfather :?x, :enos They don't look like SQL or Prolog, but you might not want that in your Ruby code. Would it be correct to say that the more unlike Ruby you want your DSL to be, the harder it will be to get it to work that way, whereas Lisp lets you stray arbitrarily far? 
Instead of recording only the internal output, just have it export to a midi file :)
Awesome! Thanks for finding that.
Be careful, in comparison many other languages feel inefficient and unfriendly. You may start experiencing resistance to coding in anything but ruby. 
Oh DAMN that is cool! Could that be used in games? I feel like Sim City could be made for this.
It's cool except the speed. I don't think I could ever use this in a game, at least not one with expansive amount of textures as every texture switch takes ages in the computer world. I would have loved to make a procedural generated automated city (with moving cars, people, planes and all the works.) But the speed is always an issue. 
I do get the insructions. We're supposed to count spaces in a string so they can be put into variables. But the hitch is that the first space we find increments one variable, and then the second one we find increments a second variable, a third one we find increments the first variable, and the fourth space we find increments the second variable...it has to go back and fourth and that's what I'm stuck on.
I mean, are you running a job to send a test email? Did you check the configurations of the gem and the associated mailer?