I'll look into this, looks promising!
&gt; The question "How can you explain successful lookup of unqualified Qux constant in Test#initialize ?" still unanswered. Because `Qaz` is in the lexical scope where your defining `Test`, `Bar` is not, `Bar` exists only in the inheritance chain of `Baz` and inside `Foo` of course. &gt; Module#const_set can assign a constant to a module and register it for scope lookup from anywhere and anytime during a runtime. Yes, this is a critical feature of Ruby, without it you would not be able to re-open classes / modules. &gt; Module#include can assign reference to inherited constant but likely not register it for scope lookup - bug or a feature ?. In addition it inserts inherited module in ancestors list. _All_ `include` does is insert the module in the inheritance chain, it doesn't make anything 'available in the scope'. `Foo` does not exist in `Baz`'s scope either. When a scope lookup fails the inheritance chain is checked. &gt; Scope lookup works from a point of call up to the top level. When fails, it raises NameError exception with fully qualified identifier to the scope of a call. When it fails it proceeds to the inheritance chain, if nothing is found or it doesn't hit a `const_missing` method, then it raises `NameError`.
You could always prework the data with a regex looking for unescapped double quotes that are not at the start of a line, end of a line or next to , and replace them with "". `(?&lt;!^|,)"(?!,|$)` 
Just manually entering and tracking payments. When I try and search how to do this I am plagued with merchant integrations for online payments
If you think of it, please post the bugs.ruby-lang.org issue URL when you do! Based on my experience, I predict you'll get a response (quite likely from Matz himself) telling you that this is not a bug and is a consequence of an intentional design somehow. But what I'm interested is the explanation of why. :)
Agree. If you're having problem with sharing database resources, consider firing up the appropriate AWS service.
If they don't want you issueing live queries against the DB when you don't know what you're doing.... take the data dump and import it into your own database. Use SQLite3 and Sequel. An rdbms is the right tool for this job, that'll still be better than trying to use an Excel spreadsheet (!?) or in-memory manually created ruby 2D array. You'll be glad you did if you are going to work with this data on an ongoing basis. Your "dump the whole database in one giant SQL query" might not be very kind to the db either though in the first place, if you do it frequently. I'd let the db team know you plan to do that and how often. 
[removed]
Yes that is correct.
[removed]
Well this was the easiest to plug right in and test. The data is processing through! I *really* need to get a hang for regular expressions. They're insanely powerful and useful Thanks a ton
"A scale that rates Delphi and Assembly a top language now also considers Ruby"
Why, what specifically do you think is wrong?
Wait... What? Are these just random sentences put together?
We should seriously talk about how to make Ruby not just Rails be more popular. I love Ruby but everyone gives their attention to Python, what do?!
Why do you even care? If you are happy with it why do you need to be proselyte? 
[removed]
I reckon this was the post that triggered that stupid "soccer / volleyball / ice hockey game streaming LIVE!" posting bot to add this channel to its spam list... Probably read this title and thought this channel would be receptive... or full of suckers. Curse you Rabbit_Punch!!! *Shakes fist
[removed]
Actually you made me realize that `proselyte` in english doesn't have the alternative meaning it have in French. It initially meant "new convert" like in English, but by association it now more often designate people that try to convert others to their ideas / ideologies. Not sure how to say it in English then...
Because I want it to be bigger and promote it so others usw it.
regex are well worth the time to learn, useful in just about any language you use and very powerful. Here is a good read that is kind of the defacto regex book. [mastering regex](http://www.amazon.com/Mastering-Regular-Expressions-Jeffrey-Friedl/dp/0596528124)
proselytise
[removed]
TIOBE is a terrible source for programming language usage stats. The numbers are [literally just pulled from search engines](http://www.tiobe.com/index.php/content/paperinfo/tpci/programminglanguages_definition.html) when searching for "&lt;language&gt; programming"
[removed]
The only person I know that championed Perl (over Ruby and Python) switched to Golang for everything.
[removed]
[removed]
[removed]
[removed]
I think people give too much weight to Tiobe, as if it is the one true barometer / oracle. 
I've determined that the server I was trying to get the age header from wasn't responding with it, so this part of the project has been scrapped. Thanks for the response though, appreciated. 
[removed]
Depending on how far you want to go, things can get complicated (source: I built &amp; run [WiseCash](https://www.wisecashhq.com), an app which determines how much cash your business will have on hands, based on planned expenses and income, for the coming year), but here are some links that will definitely help you implement this: * the [recurrence](https://github.com/fnando/recurrence) gem is quite handy * the [icecube](https://github.com/seejohnrun/ice_cube) gem (although I met [performance issues](https://github.com/seejohnrun/ice_cube/issues/33) a while back, apparently now fixed) * PostgreSQL also has built-in "date repeat" functions which can help at scale Again, things can get hairy (think: recurring transactions with occasional exceptions in the series, or different amounts etc), so you'll want to try to pick the simplest model that works for you. Let me know if you have more questions, happy to help.
Unfortunately, GitHub doesn't have a read-only scope for public and private repos https://developer.github.com/v3/oauth/#scopes. Otherwise that would definitely have been used.
I do, Volkswagen don't
Hahaha [logo](http://dic.academic.ru/pictures/wiki/files/76/LogoWriter.png) is 33 and Golang isn't even in the top 50. This list is useless. If you want a list made by people that actually do this for a living, look at the [ThoughtWorks radar](https://www.thoughtworks.com/radar/languages-and-frameworks).
I think this series has the potential to be amazing. "Don't memorize. Familiarize." I could not agree more with that philosophy. Know **how** a language/library/tool/etc. works, not exact method names or syntax, and cheatsheets like this are immensely helpful for quick references.
One thing to consider is that your results may to due to both languages. The same concept explained in two manners might click better. Whatever the reason enjoy the learning.
The irony is - while I design and code a cheat sheet I memorize the whole thing =) Thanks for feedback, very appreciate it.
I agree, but I think Ruby is much easier on the eyes compares to JavaScript. 
Nice, although why is static content being rendered dynamically in JavaScript?
I think that, for many first time JS users, the issues arise in trying to understand problems that JS is commonly used to solve. Understanding an AJAX call and callbacks can seem a lot more difficult than a basic Rails controller. I only use those examples because for many people they are good "early in your learning" examples. You could easily find other examples that flip the tables and make JS look easier than Ruby. Plus, much like PHP, JS can be beautiful in practice but often gets bogged down by tutorials from a decade ago that teach awful, awful coding styles. Ruby has the benefit of the community generally holding their code to a higher standard.
I just hate the style of Python like white space and things like that, its usable just not comfortable for my eyes I like seeing where things end and stuff like that. PS: yes I realize half of you will downvote for this opinion. PPS: what libraries should we port?
Awesome you are enjoying Ruby. Learning to program can be both exciting and frustrating and I'm glad to see you found a language that suits your way of thinking right now.
[removed]
[removed]
&gt; what libraries should we port? You may lay a hand at [SciRuby project](http://sciruby.com/). I've heard, Python shines over Ruby mostly with stellar numpy package and all numerical analysis ecosystem built around it. Also support of GUI libraries and toolkits should be more complete and mature, but for our purposes gtk2 from ruby-gnome2 project is enough.
I always thought Ruby was a great teaching language
[removed]
[removed]
He wanted to make point that you can, but gave me a bad impression. 
I had the same experience. I had learned several languages and then tried python. It didn't click for me. I picked up Ruby and it was a perfect fit. Since then I've gone back and learned python (I'm a professional django developer at the moment, actually), but it wasn't as easy as learning Ruby. I respect python, and I don't mind making a living coding in it. But I love Ruby...
[removed]
Because it's the future!
[removed]
[removed]
[removed]
[removed]
I think this is weird: SomeClass.method do mysterious_method 'value' other_enigma 'other value' end I'm starting to see that in docs for libraries, and I'm not happy about these implicit (invisible object) methods.
I love Ruby, but I also think the language culture values nifty clever methodology over maintainability. I am reading a book now that discusses monkey patching standard libraries like String. I have to say that I think opening and adding methods to (or redefining) a standard library should never be discussed as a serious design option.
It's just an ng-cloak on wrong element, should looks fine now. Thanks for noticing.
[removed]
[removed]
What always annoyed me about Python is just how inconsistent it is in regard to object metaphors. Sometimes things are methods and sometimes (like length on arrays) they are just functions that take an object as an argument. In Ruby, it's all methods.
[removed]
[removed]
[removed]
Not to be overly critical, but introducing so many objects for something as simple as a 50 line DFS is a huge overkill. Having implemented this exact code maybe even a hundred times, it still took me quite a while to orient in the gem's codebase. Especially since you're juggling classes and using dynamic dispatch for something as simple as matching a single character. But to be constructive, here are a few specific tips: - https://github.com/equivalent/maze_magic/blob/master/spec/support/maze_examples.rb this could be parsed from the text file directly, making it much easier to read. - Much like the original algorithm, you're using recursion https://github.com/equivalent/maze_magic/blob/master/lib/maze_magic/maze_generator/recursive_backtracking.rb#L43, which will fail given a large enough maze (doesn't have to be too large). - If you absolutely must have an object for each cell type (Wall, Edge), put those in a separate module, so they don't pollute the *gem-global* namespace. - I'm not sure if using singletons like this is the best way, but probably better than allocating an object for each cell. Still, there are much simpler ways to achieve this using just character constants. - Yes you might oppose that using objects like this is more flexible, but it is not. Your whole layout is based on the fact that everything is 1 character wide. If you were to introduce differently-sized objects, everything would have to be rewritten, so using objects instead of char constants is not more flexible for this particular implementation. - Metaprogramming in place where there doesn't need to be any. - (Ab)using `.call` for everything is opaque. Ruby is not Haskell, and objects are not functions. Trying to use Ruby like a functional language leads to objects trying to behave like functions (which is both inefficient and hard to read). I'm sorry if this comes off as harsh, but I'd rather say something constructive in a direct way, than try walking around the bush, pretending things are perfect. OTOH, it's nice to see people in the Ruby community doing more algorithmic things.
One thing that would really help your documentation is to show figtree parsing an INI file. Suppose `Figtree.load_config` allowed you to also pass in a string instead of just a filename: config = Figtree.load_config(&lt;&lt;-INI) foo=bar baz=qux INI config.foo =&gt; "bar" When I look at the first code snippet of the README to a project, I want to see the essentials of the project exercised in a simple fashion. Suppose I've never heard of this INI format. Show it to me!
I completely agree with ALL of your feedback on this code. Instead of "a separate object for each cell type", maybe you can just create a language and use it, maybe store it in a YAML file. Example: `vertical_wall: |` `horizontal_wall: -` Etc.
entry as a string makes some sense, but wouldn't be the normal use case for this. and sure, showing an ini file could be helpful though id say if youve never heard of an ini file, you prob dont need this gem. :)
You should really consider adding some tests to your project. You could grab some ideas from the [wikipedia page: INI file](https://en.wikipedia.org/wiki/INI_file); more refs in the [External Links section](https://en.wikipedia.org/wiki/INI_file#External_links). Mozilla also has a few examples of valid INI files on their [Mozilla Services: Configuration file specification](https://docs.services.mozilla.com/server-devguide/confspec.html) page. Edit: d'oh. I just saw the spec dir. Keeping the comment for the resources.
[removed]
[removed]
What I'm trying to say is that you're a requesting someone who acquired experience via very very specific situation. There are multiple ways to acquire similar, and valuable experiences. If you change the "fired" to "overridden" you expand the pool for example. 
Thanks! Let me know if you know of anyone.
That **can** be convenient for DSL. Nonetheless, weird. 
In this case, CanCan isn't throwing an exception for the end users benefit. It's not up to them to let your end user know there is a problem. It's their job to let YOU know there is a problem. It's your job to catch the exception they throw using rescue_from and present it to your user in the way you see best fits your application. Their gem may not be in a state that it cannot recover from, but it's in a state that you need to be handing. Or if you are fine with it showing the Rails exception to the end user, that's cool too.
You didn't misunderstand. I suppose, what i'm proposing, is that the error should be raised at an earlier stage. Possible raising a MethodNotDefined somewhere higher up the line that prevents the app from running. This would inform the dev that they have undefined actions that need to be handled. An example of an undefined action being what happens if a user without the necessary auth tries to delete a resource. As it stands, you can ignore this and said user gets an error page. Maybe that's alright, i'm not trying to think this through. It seems like, because the client is able to make any number of illegal or illogical requests to your app, that its up to you to define how much information you willing to provide them about how and why their action failed. In a case where your using CanCan, maybe its enough to send them an error page (with very little details) in some situations. This seems reasonable. 
Yea, I agree. Hopefully CanCan isnt sending them the stack trace. If a user without auth tries to take an action they dont have auth for, an action that they had to manual form in (as opposed to using a form). Then i'm ok with simply telling them they cant do that without any more information. In fact, telling them anything would probably be a bad idea...
&gt; My intuition tells me that you would only raise an error when you have reached an impossible state. That's a good guideline I follow as well. If an error is expected, use `Result` or `Option` types which are much nicer to work with. It's very convenient to use `rescue_from` in Rails, though. So a lot of people use exceptions for control flow.
Websockets are not the only/best way to do streaming.
Good point. I'd argue it's bled out into other areas though. I definitely think of bang methods meaning mutates self, raises an error, or does something a bit dangerous, maybe ought to check the docs one more time :)
Good god, why?
Good point. Do you think Its reasonable to handle irrational requests ( delete a resource they don't own) without raising errors. Are their any auth gems that? 
Ubuntu + MsSQL?
As with most things, it depends. When writing a library that other developers use, you can raise exceptions to let the developer decide what should happen in her app. It is important that all exceptions that could be raised are properly documented. Your end users should never see an actual exception (usually status 500 in webdev land). Another example to throw in here: I always raise exceptions in static site generators when data is missing for example, because they stop the build.
pm sent :)
&gt; In production, you would never want to present the end user with the default exception. It's meaningless to them. It also can provide very important information about the stack being used and how to potentially exploit it. Never show exceptions in production.
Are you looking to build a desktop application or a web application?
I'd rather work with SQL Server than MySql.... but maybe not with that stack. If you are going MS just go all in.
[removed]
It would only allow for a security gap if the default option was to allow access. I would think the default action should be to deny access. On any undefined method assume deny access. Which is what CanCan does, only it seems to achieve this through raising an error and rescuing it. I might be total missing something here though. 
very interesting, i didnt know what
thanks for the resources :) coverage is at 97%, but i def think could be improved! it's a wip, always
Great thanks! What would you recommend for a desktop app?
I have to agree, this is a "WTF Enterprise" worthy implementation. Separate classes for `East`, `West`, `South` and `North`, because, you know 'it could change!'. 
What is the advantage of keeping what appears to be object information in INI files instead of serializing your objects as JSON, or YAML?
[removed]
Draw what you an envisioning in a state machine. If an operation cannot be performed you either end the operation with a message or redirect with a message. CanCan essentially does this for you easily. There is no point in trigger an exception at any other point for this instance. 
[removed]
[removed]
I really enjoy Sinatra. Opposed to rails, it's not as heavy and you have to write a lot from scratch, but for a beginner it's super easy! http://www.sinatrarb.com/intro.html Adding a user interface is accomplished by using views, which are normally written in ERB (but I prefer Haml) #app.rb require 'sinatra' require 'haml' # This defines the path at / and will render the "index" template get '/' do haml :index end Haml templates are also straight forward #index.haml %h1 Hello World! This will create a &lt;h1&gt; tag that says Hello World when you navigate to / in your webapp :)
From experience - beats PHP with Oracle on Windows.
[removed]
Nice use of Parslet. Looks very well done.
Fair enough.
* How is runny installed (system package, rvm, etc?) * What is the output of 'which gem' and 'sudo which gem' respectively?
[removed]
 Thank you guys, no really I like your feedback. They are not harsh they are direct arguments with really good reasoning and explanation. I like that :) plus I always enjoy these discussions. I'm replying from airport from a phone so pardon me for any typing mistakes I fully agree with the fact that the gem is unnecesary complex for just an straight forward maze generating Algorithm. However I am planing to implement more algorithms. That's why I treated code as much extendable as possible. After I implement more algorithms I will maybe merge som classes. Having more algorithms in the gem that will calculate without holding entire map of a path will solve the stack overflow issue when maze is too large, but I still need to do more investigation on that The biggest mistake I made is that I split the algorithm to to two parts (generate instructions and translate instructions to wall representation) they should be together. That way there will be no need for classes North South East West. So good point guys, I didnt like this part of the code either, yet I thought I will get away with murder leaving the code like that:) I'll refractor that Replace maze_examples.rb with a text file... Fully agree with your proposal, it was just fast solution, yet still I would keep the module and just leave there methods that would read the text example from file. So far so good, but now comes a part where our opinions disagree :) The concept of #call. This is not that I want my code to appear more functional, on contrery its more objective. Imagine someone wants to use different algorithm but he is lazy to do pull request. So all he has to do is wrap his algorithm into lambda. My code don't care if the object it is invoking #call it lambda, instance of some class, or instance of Foo.instance_method(:method name). As long as I pass it and it responds to common API (#call) and returns correct format. Singleton objects for wall representation are good idea in my opinion, can you pls have a look on github.com/equivalent/a-maze-ing project? Pls have a look on app/views/mazes/index.erb and decorators in app/decorator. That Wii explain it more. To be honest the Wall Objects in the gem should not have the #to_console method. I should have decorator on that as well, but I left it there for better debugging purpous. In term of memory usage I think having singleton objects is better but I need to run some benchmark/memory tests to confirm this. For now is just a gues ( its like array of true/false objects - same object reference while string is a new instance of string ...I need to double check this) so please coorect me if I'm wrong. I'm at my computer on Tue. so I will run some performance tests and memory usage tests and prepare 0.3 realease in next day or two and would love if you guys could give me feedback :) 
:) I'm not among to be fizzbuzz enterprise. ,https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition But I still think some degree of complexicity is needed in order for the lib to be extendable. I do agree that I overdone with East,West,.. Classes. But there are specs that are describing the functionality. (Best documentation for understanding intentions are the tests )
Perhaps throw/catch is what you're looking for instead of using exceptions? Some info: - https://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/41-exceptions/lessons/93-throw-and-catch - http://rubylearning.com/blog/2011/07/12/throw-catch-raise-rescue--im-so-confused/ - http://www.rubytapas.com/episodes/110-Catch-and-Throw or if you have a CodeSchool subscription: https://www.codeschool.com/screencasts/rubytapas-catch-and-throw
[removed]
[removed]
Nice work. In a similar vein, here is a ruby gem for using HOCON config files: https://github.com/puppetlabs/ruby-hocon
[removed]
[removed]
[removed]
While monkey patching without scope limits can lead to sadness and confusion, refinements can be used responsibly, and are often clearer expressions of intent than subclasses. This can improve maintainability in some situations. Regarding the cultural tendency to prefer clever solutions, I'm not sure that's as pervasive as you think. My observation has been a community preference towards simple, obvious approaches. It's entirely possible that we're observing different segments though (I don't have much involvement in the rails space, for instance, so my views don't account for that significant subset).
[removed]
[removed]
Direct link to GitHub repository, if you're not interested in the examples and justification: https://github.com/jamis/bulk_insert
I was literally just about to tackle this problem. I love you.
Refinements dont bother me. As to culture, yeah I was thinking of rails more.
Never tried slim!
What I've been using. Especially with the benefit of the upsert ability. I do a lot of bulk "create or update" jobs. Though with postgres 9.5 it will have much better native upsert support.
Yeah, I've been looking forward to that quite a bit.
It's reasonable, but not in the context of Rails. You need to build some infrastructure yourself: handle_command(Commands::FinishTodo.new(id: params[:id])).then do |result| redirect_to root_path, notice: "Todo finished" end `handle_command` would add a `on_error(self.method(:map_error))` callback to the result returned from the command handler and `map_error` would take care of mapping the error to the correct http response. E.g. for `Error::Unauthorized` it would redirect to `login_path` or return `401` if it was a JSON request.
[removed]
[removed]
Hey, I'm the author of that code! Would be great to understand what problems you've run into, I last used it a couple of days ago to spin up a new DO server without any issues. The Gemfile constrains the version of Chef which is used so API changes shouldn't be an issue. One common cause of issues is if you're using chefdk, then the version of chef is undefined and it's often setup to be ahead of rvm/ rbenv/ whatever in $PATH and so overrides the version specified in the Gemfile. You can also email be, ben at talkingquickly co uk if that's easier. If you could let me know: * Ubuntu Version * Repo Version * VPS Provider Then I'll have a play and see if I can reproduce it :)
[removed]
I don't think so. But I think noscript tag is a good idea. Anyway, it is not the top priority issue for now. Nonetheless, thanks for your feedback.
[removed]
I've been meaning to do this for a while. Thanks for taking the initiative. 
One or two examples of how to appropriately include this module and call it, as well as a few words about any potential caveats would be most appreciated and helpful to those thinking about using it. Thanks!
[removed]
That is not a method in rails, it's from the [activerecord-import](https://github.com/zdennis/activerecord-import) gem. 
[removed]
Slim is faster, and I personally prefer the syntax. 
[removed]
&gt; But I still think some degree of complexicity is needed in order for the lib to be extendable. From a design perspective, this lib is incredibly _difficult_ to extend. For example you have a [mapping class](https://github.com/equivalent/maze_magic/blob/master/lib/maze_magic/maze_generator/instructions_grid_to_cells_grid.rb) that hard codes dependencies against classes outside it's package, and hides them in `private` methods which serve no purpose other than aliasing. e.g. How would I render the maze in a different way? I get that your trying to write 'extensible code' but creating a bunch of tiny classes doesn't create that. Ruby has very strong configuration based compositional patterns, they make it much easier to create extensible code without turning a 50 lines problem into 15 classes.
&gt; For an app that just needs to have a few routes and views, Sinatra is absolutely a great way to learn. What app just needs a few routes and views? Even beginner apps almost always need some sort of storage or client asset management, which Sinatra doesn't provide. With Sinatra, once you step outside the _extremely_ basic, you're on your own. Don't get me wrong, Sinatra is a useful framework, but my experience is that it's not a good introduction to web development and even in the hands of junior working developers is dangerous. 
[removed]
If you do not need valuations, hooks or custom accessors (the latter could be extended into the gem though), that gem helps you....
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
Well, it looks like `not_if` and maybe even this `execute` command is part of a dsl for Chef. My best guess if you're interested is that at some point it's `eval`-ing that string beginning with 'grep'. And since grep will need '\b' you need to escape the backslash so `not_if` will evaluate it rather than Ruby.
[removed]
Thanks for this. Looks interesting. All of the other state machine gems seem to have fallen into an unmaintained state. 
Thank you! I was a bit thrown off by the single quotes within double quotes. I understand it now!
Looking forward to keynoting this awesome event!!
good work, thanks, looks very interesting and have to be stared ;)
Really disappointed in this. Was hoping for a nice, easy way to write performant code. Too bad 'performant' is out of scope for the C interface to Go.
&gt; CanCan raises an error if a user isn't authenticated, why not redirect non-authenticated requests with something else? Because CanCan as a library does not/should not have any access or responsibility for routing, http, or redirects. It needs to forcefully report back a failure. The proper way to respond to that is the responsibility of another class.
[removed]
Yeah it's absolutely hardcoding but that's fine, I don't know of a use case where I'd want to do some magic DI replacement of a value. I'd make a private controller method to determine the status, or similar. When I said hardcoding, I meant "hardcoding magic numbers in there is bad". Forgot to mention the magic number bit in that sentence, but it's covered elsewhere.
Go really isn't designed to be embedded. Is any VM-based language? Rust will perform and work much better. Skylight's client gem is a great example of a Rust-based extension which performs amazingly well. http://fullstackfest.com/agenda/rewriting-a-ruby-c-extension-in-rust-how-a-naive-one-liner-beats-c
[removed]
[This is the video that got me the idea](https://www.youtube.com/watch?v=IqrwPVtSHZI) of writing a series on extending Ruby *not* in C. I've started with Go because many Ruby programmers I know have switched or have worked with Go already, not so many know Rust. The second reason is that Go is a mainstream language, very popular among rubyists, and I wanted to prove (or disprove) that you can actually do everything with it. Last but not least, Rust needs some deeper, more low level, knowledge. I wanted a soft introduction to the topic and I found myself disappointed by the results, I ran those test an infinite amount of times to be sure I didn't do something wrong. If it was possible to write extension in Python, I would have started with that :) [I also got into a (moronic, on my side) dispute](https://www.reddit.com/r/programming/comments/3mud0e/using_rust_with_ruby_a_deep_dive_with_yehuda_katz/cvirnlz) here on reddit with /u/steveklabnik1, and I started a sort of challenge to write extensions in simple, autocontained languages, such as Go, which, in my opinion, could be the successor of C more than any other language out there, if only they drop the mandatory GC. In short, yes, Rust is in another league compared to Go, when it's about performances, compiler optimizations, and interoperability in general. That's why the next article will be on Ruby &amp; Rust, even though some pretty good material already exist. 
[removed]
Check out this thread: https://www.reddit.com/r/rust/comments/3oamul/benefits_of_rust_compared_to_go_or_haskell/cvw0734 Everything in engineering is a trade off.
Well thanks, I'm not an english native speaker and sometimes I put down arguments in a "too direct way" and I realize it only after reading them again after a few days :)
OMG I WROTE "sneak peek" WRONG
[removed]
Yes, beyond that. Also, using an auto generation tool for most if not all of the doc files.
Ah, I didn't catch that your gem used hashes instead of instantiated models. Cool. I'd still prefer an array of hashes to your block dsl. 
Wait, what? So the solution is to move the `mail()` call to a different method? Doesn't that violate Single Responsibility Principle instead...???
&gt; "A loss in performance was to be expected, Go does not generate binary executable code, but code for its VM, it is somewhat in between Java and compiled languages." Nope. Go generates binary executable code, there's no VM involved at all. What you're seeing is the FFI overhead because a lot of magic has to happen behind the scenes for the languages to interoperate and pass values around.
For my gems I use a combination of the [GitHub Wiki](https://help.github.com/articles/about-github-wikis/) and [YARD](http://yardoc.org/) documentation pushed to [RubyDoc.info](http://www.rubydoc.info/). Aside from that, writing good tests and, if you choose to, [feature definitions](https://cucumber.io/), you should be pretty well set. Looking at tests is usually the best way to figure how a piece of software works since it shows you how to use it and what the expected output is. In general, well written code is self-documented to a certain degree, so bear that in mind. 
[removed]
A different language. I &lt;3 ruby but it is an atrocious language if you want to make *and distribute* desktop GUI apps. Even with things like shoes. IronRuby is a dead project and should be avoided.
+1 for YARD
[removed]
Thank you for engaging, investigating, reconsidering. I hope this brings more candidates into your consideration. 
[removed]
This would have been a lot better as a blog post than a ten minute video that hardly utilises visuals. 
WTF is Tioba?
[removed]
[removed]
same problem
&gt; Apparently I'll also spend 90 seconds complaining about it on reddit. True, but if this leads to OP considering blog posts over videos in the future, you've saved all of his readers a lot of time.
What the author meant to say was "runtime".
&gt; It must run faster! How can we do that? by not using the algorithm with the worst possible performance characteristics? Sure. Native code might be considerably faster, but most web applications are still i/o bound and won't profit that much from the increased complexity.
I used to be a C++ developer and the reason I migrated to Ruby was because I started doing web development and I wanted a platform with plenty of people talking about how to create web apps, their architecture, deployment... After years I started running out of quality material about software design and had a look at new trendy languages, they all promote their superiority based on superior abstractions and more powerful concepts, which is all fine, except that I was never sold into the idea that higher levels of abstractions will solve my problems. Instead I am already quite busy learning new ways to be more effective solving problems with less abstraction. Looking around other companies, Ruby is not that wildly popular, and I hear so many times how hard it is for them to find good people, so from this perspective, I am not that sure about jumping on any language with a smaller community. Elixir / Clojure / Elm / Haskell I know they all have great things and solve big warts of Ruby, but their lack of haters seems to me like a signal that they are not mature yet. As far as I keep getting quality info with my stacks, I am happy to wait a little bit longer until the killer, of the killer, that killed the killer of the killer of Elixir shows up within a few years.
[`String#chomp`](http://ruby-doc.org/core-2.2.0/String.html#method-i-chomp) would probably be a wiser solution.
Good idea
&gt; Native code might be considerably faster, but most web applications are still i/o bound and won't profit that much from the increased complexity. You're right for simple CRUD apps [1], but in every second app I come across a computation intensive task where I either need to write it in a different language or rely on caching/background jobs. I'd argue that the caching solution + background jobs is increased complexity while using a different language is not. There's no additional state (memory / processes) to keep in your head if you simply call a pure function in another language. [1] Assuming db access is actually slower than rendering the page. This isn't always the case.
[removed]
Do you think that this example sucks to illustrate the point? My point was not Fibonacci at all haha Let me know if you have a suggestion! 
FWIW, Java8 has map. So, the function turns into something like: return users.stream().map(u -&gt; u.age);
&gt; I hope you, beloved reader, understand why I think that Java is far from ideal when it comes to teaching the next generation of engineers and overcoming the challenges that our craft presents. I agree 100%, but I think if you lean too far in the other direction there is a lot of understanding that can potentially get lost along the way. I'd argue it's actually pretty important to see the evolution of the craft and the tools and techniques being used today. I think this article is actually an example of a great way to teach these sorts of higher level concepts (like iteration) - explain the basics, use an example, then show the translations between languages and evolution of the technique.
&gt; A note for experienced Ruby programmers: I know you want to tear your eyes out, but please bare with me. The above monstrosity is only for demonstration purposes. I was glad he wrote that.
I'd really love to see an integration between Yard and the Github Wikis so that I can compile my existing Yard documentation straight into Wiki pages.
But you are using different algorithms. When implementing both algorithms in Rust, the first one is about 2.7x slower than the second one. Also, if you have the same branches in match you can use one branch instead of two: `1 | 2 =&gt; 1`
It's a bad example because most rubyists will see the way you implemented Fibonacci with recursion, and say "That is not a good way to do it in ruby, of course, it will be bad performance." The equivalent algorithm in rust may perform just great; but ruby doesn't have tail-call optimization and other things, that make that recursive implementation a poor choice in ruby if you care about performance. Now, I understand that wasn't the point -- the point is basically assume _some things_ will be much faster in Rust than you could do in ruby (which is probably a safe assumption), look how easy it is to use Rust over FFI. Fair enough. But the trick is figuring out _which_ things will be faster in Rust than Ruby, especially with FFI overhead. And your example makes it seem more clear-cut than it may be. 
ruby is actually faster for single thread computations, generally (or at least I've been told by people who claim to have benchmarked it themselves), but like you say phoenix is faster than rails, because the internet is highly distributed and thus concurrency can give you huge gains in performance.
Tail call optimisation only works when a function returns itself with different arguments. This function returns the addition of two recursions. f(a, x) = f(a*x, x-1) is an example of a function which would benefit from tail call optimisation.
Yea, I need up doing that solution, But instead of writing to a file I just made a mini model that holds the 4000 words that I then cache. I know its a crummy solution but the whole point was to have a button that loads a dictionary and have Javascript parse and read a CSV file from S3 bucket into an array is slower than just having a small model load an array of words into the cache. 
The problem with using Fibonacci as an example is that you can use memoization to make it very fast in Ruby. See [this example](http://stackoverflow.com/a/24438837) (ignoring that the post refers to it as caching). That said, I think there are definitely great cases where your technique is valuable.
[removed]
[removed]
I don't know under which circumstances LLVM does TCO. I just know it's not guaranteed and we hope to be able to do so in the future.
Why a Resque clone? Is the Ruby code around the Redis store such a big bottleneck? I would expect Rust to be used for numerical calculations. In fact: I just used Rust to find the roots of a large number of functions (using newton's method). It improved page rendering from ~5s to 0.02s. I was so close to throwing a cache at the problem. I'm glad I didn't.
[removed]
All functions benefit from TCO.
While I totally agree with you, I think Java is a terrible place to start. I mean, FFS, by sticking everything in a class you need to start off with OOP when students are still trying to wrap their heads around variables. You want to teach the bare fundamentals (variables, data types, functions, control structures, etc) plain C is a much better place to start -- there isn't much else there. As a bonus, it gives much better perspective on the evolution of programming languages. On top of that, so many of the languages we use today base their syntax on C that it's kind of like learning Latin. I could also see a case being made for going with Python as a first language -- a sort of "top down" approach, where you learn how to think programmatically and then add in the nuts and bolts later could be beneficial. Java is just kind of in an awkward middle ground, where it abstracts enough away from the user that they don't really get a feel for what the computer is doing AND they need to learn several unrelated concepts just to get off the ground. Honestly, any language where you have to tell students "don't worry about why that is there, it just needs to be there" is a terrible first choice.
Not really. If you have: fib(n) = fib(n-1) + fib(n-2) This will not be optimized, the last call is the + operation/function (depending on language). The recursive calls to fib will not be optimized away, so two exponential calls are used before the single + operation occurs. However, a slightly smarter fibonacci (building in the other direction): fib(0) = 1 fib(1) = 1 fib(n) = fib(1,2,n-2) fib(a,b,0) = b fib(a,b,n) = fib(b,a+b,n-1) Will benefit from it. Of course, TCO doesn't just benefit recursion. A function like: f(x,y,z) = g(x,y,z) will be optimized, as well. But: f(x,y,z) = 1+g(x,y,z) will not have the same optimization. We still have to return to this stack frame and compute the result of `1+g_result`.
[`memoization`](https://en.wikipedia.org/wiki/Memoization) is the correct term. Just in case this wasn't a case of auto-incorrect (which nearly got me). I don't like being overly pedantic, but on technical terms it's important to use the correct one, if for no other reason than to make searching for discussions and papers on it easier. 
Surprisingly, it is. Granted block invocation in JRuby may just be slower than MRI, but I benchmarked using jedis via Java interop (typically rather slow) against using the redis-rb client and my throughput doubled. This was an application we were about to start sharding redis servers for because throughput was problematic. I suppose on the MRI side, this is part of the reason the hiredis client exists. FWIW, the problem seemed to be the way the redis-rb client tries to layer functionality by nesting things in blocks. These don't optimize away very well.
[removed]
[removed]
[removed]
[removed]
Huh, I didn't know that existed, thanks for the pointer. It hasn't been released and requires bundling from the repo; do they plan to release it to rubygems.org with bootstrap 4 final release? I hope. 
Constants, methods and global variables will be shared. 
Thanks! I tried to look it up, but didn't know what the right question was to search for! This is really helpful :)
Thanks a lot for answering and indulging my growing pains in the programming world!
"Don't use loops, they are space wasters, use functional stuff instead" "Don't use functional stuff, loops are better, they take less space" I DON'T KNOW WHO TO BELIEVE ANYMORE
Interesting. What is slightly ironic is that celluloid will be a Rails Core requirement with 5.0 since it's what ActionCable is currently built on.
You'll get to redefine and reuse the SCSS variables either way. The benefit to my mind of rubygems tagged releases is having a clear release trail with defined releases -- I am using (eg) version 1.0.3; I ran into a problem, and after googling and finding a discussion on my problem I figured out that this is an identified bug in 1.0.3 that I can fix if I upgrade to 1.0.4, which shouldn't introduce any backwards incompatibility problems just fix the bug. With direct-from-repo bundling, every single git commit sha1 hash is a potential 'release', and everyone's on a different one, and it's hard to google for known problems in your 'version', and you never know when upgrading if you're upgrading to something stable, or a mistaken work in progress that wasn't really ready for prime time, if you're upgrading to a bugfix or a new feature or maybe backwards incompatibility you aren't ready for. 
&gt; You'll get to redefine and reuse the SCSS variables either way. &gt; Nope (I'm talking about the variables used to customize TWBS itself): Ah, right I gotcha. Yep, there are ways to make this work without the ruby gem too (using bootstrap scss source with sprockets), but not the way the OP describes. There are better ways. The gem you mention is a fine one, as they've already made it work the way it should, that's what it's for! 
Thanks! I got it to run with sidekiq 3.5.1, but I don't know how to install sidekiq 4.0. Nothing shows up for sidekiq when I do `gem list sidekiq -r --pre`. It may be simple to install it some way manually, but I'm not much of a developer so I don't know what that would be.
You might have to actually make a judgement yourself instead of just doing whatever the internet tells you to do. But personally, as someone developing in ruby for 7+ years, I find this article not very useful, it's basically just attracting clicks without much useful guidance or info. 
I run a small Remote Control app on a Raspberry Pi for my parents. It allows them to open and close their garage doors and gates from anywhere. If it weren't for Sidekiq half the functions of the app would lock the site up for 10 or so seconds. Though I'm no where near the throughput these optimizations are intended for, I'm curious if they will alleviate some of the pressure sidekiq and redis put on the tiny rpi.
I don't get the design tradeoff here. Real world performance is going to be dominated by job execution time so I don't know that the benchmarks here mean anything. It seems like you just traded a well documented dependency for more complicated code.
I've said it before and I'll say it again: [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby) is really worth checking out for some concurrency abstractions way higher-level than bare Thread.new (and thus easier to work with safely and efficiently with less boilerplate), but with a lot less complexity, dependency surface-area with forwards compatibility risk, and overhead than Celluloid. Especially Futures/Promises from that library, or slightly lower-level Thread Pools, I think are the right level of abstraction/complexity for a whole lot of concurrency-related problems that don't need the complexity of sophisticated Celluloid. concurrent-ruby is planned to be a dependency of Rails 5, so if you're using Rails you'll have it as a dependency anyway. concurrent-ruby has a really good track record of staying almost entirely backwards compatible for long periods of time, and I think the 'almost' will drop out with the 1.0 release and inclusion as a dependency in Rails. (I am not a concurrent-ruby contributor (except for a bit of docs), just a happy user)
Both are almost identical (single quotes don't support interpolation), so it depends on who you're asking :P - A lot of ruby projects that I've seen only use double quotes for interpolation and single quotes for everything else. - Some companies (like Github) just stick with double quotes for everything, and that's fine as well. I prefer the second option, because it's easy and I don't want to mix the two types.
Both are string literals, so of course both work. In any case at all where you need a string literal, both will work. any method at all that takes a string argument, nothing special about `gem` or `require_relative`. Always. Double-quoted strings support more features -- escaped ascii-writable version of non-ascii or non-printable characters, and interpolation. Some people say to use single-quoted unless you need those more features, which your examples don't. But it doesn't really matter. Neither is really preferable, they are both fine. 
concurrent-ruby is great. It also gives platform specific optimizations for jruby, MRI, etc
Ah but the shift key!
Well if you're going dark on light, this actually reduces the energy. *but who codes with dark on light?*
As a core celluloid contributor, I agree that some things could be faster. However, I'd also like to point out that celluloid hasn't yet reached 1.0 and there are lots of low hanging fruit for optimisations. I'd personally like to see more things cut out of celluloid, and that's what we are currently doing - many things are being moved into celluloid-$feature gems. Additionally, I've been pushing for more efficient code and systematic benchmarks of critical subsystems. I rewrote the timers gem to be several orders of magnitude faster. The other thing to keep in mind is that pure ruby could only be so fast, and that MRI is not a great target for truely concurrent workloads. Celluloid suffers a bit because of the design of MRI, vs say Erlang which was designed specifically around the actor pattern. A null benchmark is interesting in that it shows the overheads, but typical background job workloads might not suffer as much from these overheads as they would typically be waiting on IO.
Nice post. Instead of taking the "we stopped using X and you should to" approach Mike is being honest about his move away from Celluloid - at least for Sidekiq. As an aside, does Celluloid handle periodic timer events any better yet? Both Celluloid and EventMachine periodic events "drift" after a while - at least last time I used either. And yes I know the reason for it, just wondering if anyone has come up with a solution. Probably too much on an edge case.
Single quotes unless you need double quotes. Single quotes do nothing unexpected to your strings and since they do not need to interpolate, they should be faster. This is the answer you are looking for. Technical. Not something about "I like this kind of quotes because they look nice".
afaik, a black pixel uses the same amount of energy as a white pixel. black pixels aren't actually turned off, their backlight is just blocked.
see the benchmark above -- 3% faster?
Some displays use local dimming, if they can dim down the pixel size of a quote mark you might be in for some serious savings.
in other words... we need to replicate this thousands of times across background loads and calculate a confidence interval?
&gt; There is a slight performance benefit, about 3% in favor for single quoted literals This is a myth. If you research the issue properly, and complete a variety of different benchmarks, then it becomes apparent that there's no statistically significant difference between the two: https://viget.com/extend/just-use-double-quoted-ruby-strings
rufus-scheduler was rebuilt in celluloid and features non-drifiting timers. As far as I understand drifting timers are not something that either Celluloid or EventMachine will or should fix. Non-drifting timers require a specific implementation that's more high level than what they offer.
really good stuff! I was about to write a post on the same topic but you beat me to it. First blog ive come upon dedicated to performance. subscribed! 
Great to see someone tested it! One quibble from your link: &gt; Since there is no measurable performance advantage for either, any time (however marginal) spent thinking or talking about a choice between the two is wasted. When you prefer single quoted strings, you have to think when you need interpolation. When you use double quoted strings, you never have to think. (I'd also add, anecdotally, that apostrophes are more prevalent in strings than double quotes, which again means less thinking when using double-quoted strings.) &gt; Therefore always using double-quoted strings results in the least possible wasted time and effort. The author has this a bit backwards by considering efficiency from the perspective of a code's author. Those of us who prefer single quotes do so because we are usually considering efficiency from the perspective of collaborators or future maintainers (who might be ourselves).
Not a myth, I just reported results I get steadily on my system. I even tried the linked tests and measured means just confirm the former results, at big and huge literals instantiations. At smaller strings it falls bellow 5 difference. As the number of iterations are relatively low in these tests(only 100), it may not be quite reliable due to missing/hitting GC major/minor collection and CPU cache burning. I did tested on x86_64 Linux system, can't find in the article on which machine were ran. Btw. bundler config was set to Ruby 2.2.0, I did used 2.2.3 version. Anybody can check himself, only suggest increase by order or two number of iterations. Anyway due to additional work *required* at double-quoted strings, mostly checking patterns for interpolations, they should be generally more expensive, by definition. It highly depends how well is optimized *current* implementation, of course. Making final statements and recommendations, like in the mentioned article, are nothing but naive. EDIT: From the article: *"When you use double quoted strings, you never have to think."* Except escaping unwanted escape sequences interpretation and escaping unwanted interpolation markers ;)
Thread.new
We use docker at my company, and I have to say, I don't see the benefits. You have to learn and keep track of all the quirks to docker and docker-compose, which means often relearning simple tricks from your unix toolbox. For a typical small-medium Rails app that needs Rails + postgres + redis/memcached, I'd still stick to doing everything the old fashioned way.
Expose the method via a web API and only let them access it via API calls. Might be overkill but all they're be able to see is input and output.
Yeah if complete secrecy isn't needed, that's probably the way to go. They can run a `gem unpack` to get the source, but if it's for fun and games then I'm sure that's enough.
Hehe, even that might be a bit too much work for them right now. We are currently working our way through this problem: &gt;Write a function that takes 2 numbers and returns their sum &gt;If the 2 numbers are the same, return double the sum.
Sorry for my delay in response. Day job and all that... heh I have created and updated the following repo: https://github.com/bajunio/csv_generator You'll find two branches aside from master. They include the modifications for removing abort and calling #argument_check from #initialize. Both have already been merged into master. If you have any difficulty accessing the repo, please let me know. I was feeling iffy about the #buffer method and noted that its basically the same as #write_newline. I was very close to modifying #write_newline to behave more like #buffer and serve both the newline return in my command line display as well as the newline when appending to @output_file. I'll spin off a new branch and attempt to clean that up a bit. In regard to the reconfiguration of #initialize to accept params being passed. If I specify something like: def initialize(file, columns, rows) ...magic... end How can I also allow the flexibility to accept passed command line arguments via ARGV[]? You had mentioned creating a method to parse the ARGV[] values, would that mean I would be using a *splat in place of (file, columns, rows) and force arguments through my parsing method? Thanks a bunch for sacrificing your time to assist me. I truly appreciate it. 
I like it! Definitely no concern for security, this is just a fun exercise for them. Now the issue is letting it accept an argument, which I'm sure isn't too difficult...
I wanted to upload my encrypted database to github, so I just used gpg and defined these bash aliases. alias encrypt='gpg -c "$1"; ' alias decrypt='gpg "$1"; ' I dont know much about encryption, is this not enough?
&gt;giving someone code such that they can run it, but not inspect, is both impossible ... and immoral. :| I am doing this for a few people I work with who are absolute beginners at Ruby. I just want them to do some black box testing and discover my method's bugs on their own. I am very interested in the immoral angle though...
Note, you can do memoization using the `def` return in 2.1+ using a bit of trickery.
Compared to setting up your dev environment by hand. Until you're at a larger size, I don't think even Vagrant + Chef is necessary. Yeah, if you have like 20 dependencies, sure, being able to automatically spin up your dev environment is necessary, but when all you need to do is install ruby + gems, postgres, and redis, these tools tend to be overkill. Our setup has a couple of other services, so docker is occassionally useful, but we still find ourselves fighting against it as much as we were fighting against installing and starting those services manually before.
whichever one the team uses consistently
right on !! I am going to alias the quote to the space char, and the space char to the quote - imagine the savings !!!
Write the logic as a Proc, then encode the source for that with Base64. Then wrap that in a method that decodes the Proc source code, evaluates that code to get the actual Proc object, then calls the Proc object with arguments specified in the method: def sorta_multiply( x, y ) logic_proc = eval(Base64.decode64 "UHJvYy5uZXd7IHx4LHl8IHgqeSArIDEgfQ==\n") logic_proc.call x, y end If you want to be especially tricky, you can wrap the logic_proc multiple times: def recursive_encode( string, times ) return string if times &lt;= 0 recursive_encode( %Q(eval(Base64.decode64 "#{Base64.encode64(string)}")), times - 1 ) end That way `eval`ing the resulting string will get you the actual Proc object, but attempting to decode the Base64 string will just get you another Base64 string. :) Of course, if they're persistent they could eventually uncover the source code without much difficulty, but it may foil the student who thinks he's really clever by running the string through an online Base64 decoder.
https://docs.docker.com/compose/ &gt; Compose is great for development environments, staging servers, and CI. **We dont recommend that you use it in production** yet.
YARD
It's an interesting idea. Where it gets complicated is interweaving the dynamic content (forms, etc) provided by services, but not ridiculously so (think Disqus and similar dynamic components of otherwise static sites. Prose (http://prose.io/) solved part of the problem - at least for Jekyll-based sites - in terms of being able to edit and create content via Github. It'll be interesting to see where you take this. 
Oh, so that makes it okay to recommend that users install insecure software.
I used it for a bit at my last job. We used it for encrypting and packaging our product for shipping to enterprise customers. I believe it's what Github uses for their enterprise product as well.
Unpack will extract the files inside any gem to the current directory. So if the gem code isn't in a repository somewhere, you can still get the source.
I suggested this to the authors of Locomotive CMS. They have an excellent backend for their CMS. They just need an API. They could probably compete with contentful.
Just because it happens all the time, and most users are blissfully unaware and not interested in the slightest, doesn't make it OK. I have a problem, you have a program that solves it. Happens all the time. You demand I pay you money for the solution: not really anything wrong with that either, you put work in, you deserve to get paid. Fair deal. But when you add the demand that I cannot know what the code actually does, then something is at odds. It means you don't trust me to keep my part of the deal (don't redistribute your code), but you demand that I trust you. That's not a fair situation, and using your intellectual monopoly to force this situation on me is immoral. That's basically the core of it. And on a more general level, yes, this is part of what Stallman's Four Freedoms are about, particularly the freedom to inspect. It's unreasonable to demand that people run code on their computers (that possibly contain their most personal data), without being allowed to inspect what that code does.
In a nutshell, you're saying: "This code does what you want, trust me, everything is going to be alright, but you cannot look at it, because I don't trust you at all."
I would be telling them that this code *doesn't* do what you want. And to get better at testing, you will try to find the errors in it. Then afterwards, I will show them the source. Trust plays no role in this whatsoever.
I am not sure there are actually any trending or mature rails cms systems. I definitely don't trust that article either though. 
Hey and I will totally agree with you but regardless obfuscation itself isn't immoral, it's how people use/abuse it. Obfuscation will always exist, whether its Adobe trying to protect it's intellectual monopoly, a hacker trying to sneak code under the radar, or a teacheer just trying to teach his class how to do black box testing. 
That article is crap. Every "Top X CMSs" post I've ever seen is just used to drive traffic; ignore them. I say this as the maintainer of Radiant. They mention Radiant and show a picture of Refinery and Refinery isn't even in the list. Radiant is out of date (though I _really_ wish I had time to work on it; I love that project) so any list which gives it as it as an option and doesn't mention that sad fact, is not one I'd trust.
I've been wanting this type of thing for awhile but have been too lazy to write it myself. I'll probably use this if/when I can find some side jobs building sites for clients.
Yeah but what is the difference between that and just looking in C:\Ruby22-x64\lib\ruby\gems\2.2.0\gems to see the source code. 
I use it for the website hosted on my Raspberry Pi http://pi.tafkas.net
Awesome stuff! I love Jekyll. If you want to host your Jekyll blog for free, you can do it on GitHub pages too. [I wrote a piece describing how to do just that for those interested](http://jakeyesbeck.com/2015/07/12/create-a-free-tech-blog/).
Thats not mine, but yep, thats basically it. Useful little trick for wrapping things
Yep, that's my gist, I expressed myself badly - that's what I get for trying to communicate before coffee. I tried to asked if that was what you were thinking of, which it seems it was. It's pretty useful, but I don't think you can chain those as easily/prettily as with method_added, which is a drawback to consider. Thanks again for your input !
https://chrome.google.com/webstore/detail/regexp-tester/fekbbmalpajhfifodaakkfeodkpigjbk?hl=en-US Granted, it's a JavaScript regex tool, but JavaScript regexes are close enough to being PCRE-compatible, that they're almost identical to what Ruby supports, save for the handful of advanced features that you'll rarely use. And http://www.regular-expressions.info as a reference. It's not the best reference, but at least it's decently organized and fairly complete.
Gems are packaged together into a single file under a specific binary format. You can't just browse the contents of any gem like a folder unless you unpack it. EDIT: after posting this I realized that Rubygems probably unpacks gems after they're downloaded into that cache folder. So yeah, you could do it that way. The unpack command lets you do the same thing on any gem that may or may not have been obtained through Rubygems.
I'm guessing they treated their old senior dev like shit so he left without notice?
Check out `bundle open gemname`
I don't know any games based on regex, but [rubular](http://rubular.com) is my go-to for developing and testing any moderately complex regex.
ohhhhhkkkk. I think you have things backwards. that folder isn't a cache folder. In fact Ruby calls the folder that holds all of the .gem files a cache folder. The C:\Ruby22-x64\lib\ruby\gems\2.2.0\gems folder holds the actual files that ruby reads when you use a gem. You can easily tell that by just opening up a file in one of those folder and then using a `puts` statement and then using the gem. I use it all the time to modify gems that are broken on certain Ruby versions. 
&gt; Located in NYC, NO REMOTE &gt; CS Degree , Bachelors or up. grandpasimpson.gif
So we allow recruiters here now?
&gt;EmberJS and/or JAVA What? Why would a Ruby developer have to play with Java? &gt; am an agency tech recruiter That explains it. 
Report this as spam please.
http://regex.learncodethehardway.org/book/
Just because ruby Cassandra connector is immature, and the rest of big data tools have better java integration. Even though you can do a step towards it with JRuby, java knowledge is a big plus. This is based on my experience with Cassandra/Hadoop/mahout/storm/spark. Or, you should be a traditional full-stack engineer with ember experience. So this job ad is perfectly ok from my pov.
Does it just translate to a js framework?
looks more like the ruby equivalent of elm(haskell)
If you are determined to develop Ruby on a windows box, I strongly suggest you look into setting up a VM. You _can_ make it work, but you'll be mad at yourself all the time. Set up a *nix VM and work that way. The fact is, most Ruby devs are working on macs and Linux boxes and deploying to Linux servers, and the ecosystem is heavily biased in that direction. 
This is really ruby on the front end?
Does the number of people who report as spam not matter?
Both use Opal, which is a "real" Ruby :)
More specifically: 1. Install VirtualBox http://download.virtualbox.org/virtualbox/5.0.6/VirtualBox-5.0.6-103037-Win.exe 2. Install Vagrant https://dl.bintray.com/mitchellh/vagrant/vagrant_1.7.4.msi 3. Create a Vagrantfile in your project directory https://gist.github.com/vais/48fde9d54ff68dcdbf25 4. Open `cmd.exe`, `cd` to the directory where you created the Vagrantfile, and run `vagrant up` (this will take a while the first time), then `vagrant ssh` will drop you into bash on your newly created Linux box with the latest Ruby, ready to roll. EDIT: important next step: once in bash, `cd /vagrant` - this directory is a "synced" folder, which means it is *the same* folder that is on your Windows host machine where you have the Vagrantfile. This means you can create a new file in that folder on Windows, and it will magically appear in the `/vagrant` directory on Linux. In practice, this means you can do all your file editing on Windows, but execution happens on Linux. It can be hard to wrap your head around this, but after playing with it for a while (and reading the [Vagrant docs](https://docs.vagrantup.com/v2/)), you will get it. I use this setup on Windows as well as on my Mac. Virtualization FTW!
Thanks. Not a windows user, but have watched a few burst an aneurism trying to set up dev environment on a windows box. 
I am crossing my fingers no one uses this kind of thing in production
[Module#define_method](http://ruby-doc.org/core-2.2.0/Module.html#method-i-define_method) - You're welcome, OP. Edit: [Module#remove_method](http://ruby-doc.org/core-2.2.3/Module.html#method-i-remove_method) while I'm at it. It's generally more flexible to use methods than keywords. You can also use it on... some_obj.singleton_class.send :remove_method, :the_method You can define methods using procs, blocks, lambdas, existing methods, whatever. Very, very flexible without having to use special hard-coded handling for dynamically re-defining methods wherever and whenever.
It's $150k in NYC, it's not particularly well paying. If you lived in Manhattan that is equivalent to an $85k salary in Seattle. 
Yup, you're right--you'll almost always want to use `#define_method` and friends for stuff like this. However, don't you agree that it is sometimes fun to set yourself a constraint ("what I can do using just `def` to declare methods?") and see how far you can go with it? Whether you find something production-worthy or not, you've at least expanded your own knowledge of the platform, and perhaps gained some new insight that may help you down the road. And, of course, it can be a lot of fun, too. :)
Great! Good luck on your path to Ruby (no pun intended :-)
What reminds you of Elm? Explicitly calling `update_dom` is pretty much the opposite of FRP.
I can see your point, but the win in your case feels like a net loss to me. When boiled down to what single and double quotes represent I view them as: Single quotes: Expose a more limited form of string, interpolation is more restricted and escape quotation is limited. Double quotes: Expose a less limited form of string, interpolation is less restricted and escape quotation is less limited. So in my mind, I want to default to using the more limited form given a choice -- and only grant more abilities when required for the task. My default stance on security and systems is that the fewer variables you place on any action simplifies the action for bug tracking and exposure. 
Telnet is a very basic ASCII only terminal package. Your mudlet screenshot shows colour effects, so you have likely used some ANSI escape codes for this. Depending on the OS and/or Telnet client, those ANSI codes might not be supported.
I've worked with telnet/MUD clients before, but not servers. The codes are weird. If you want to make a game have you tried looking at [mudlib](http://lpmuds.net/downloads.html)? Alternatively, what references are you using? Telnet clients encode a variant of constraints for formatting and transaction dialogue.
No, everything in colour is from mudlet itself. The only data from the server is the text you see after.
Moreso the role the language is serving, no so much syntax, paradigms used, etc.
OK. Can we see the code that's actually sending the message "Welcome to vMud" ? At a guess, it definitely looks like you're sending both CR and LF for each line. 
Well good luck with that. Because at work I have RHEL Linux that has different PuTTY settings to SUSE Linux. And both have different settings to Solaris. Though that's more around virtual consoles and implicit echo. If you check the [Telnet RFC](https://tools.ietf.org/html/rfc854) (search for 'The sequence "CR LF"') does suggest CR LF explicitly. Might be worth getting plain PuTTY working and see if mudlet can understand that. It's likely smarter.
Curious why you explicitly opened the singleton class rather than just `def self.foo`
Excellent question! The answer to that would be...I honestly forgot you could do that. :) That's a much simpler (and cleaner) way to express the same thing. Thanks for the reminder.
It's just a implementation of the standard ruby reference. It is still ruby. Not a totally different language. Imho that is why there is not much talk about it. Im my opinion it is the only viable variant of ruby that is usable at all. On a side note, do you see any traffic when you look for MRI, cruby, mruby, rubinius and so on?
It's not a different language but it's a different community , with (sometimes) different gems , different extensions , different places where you go to look for answers . Deployment is different . Web servers are different. Threading is barely done in cruby. I won't get a lot of hits searching for "cruby" because cruby and ruby are synonyms . When people look for "ruby" they 99.99% of the time mean cruby . And you still haven't really answered anything - where is the JRuby community? Why so little job postings for it ? Where are the start ups using it ?
* Startup time. It takes a good 5 seconds just to launch a plain irb session on my main server. * Warmup time. Until the JIT kicks in it's actually considerably slower than MRI. * Once warmed up, it's still not *that* much faster. * Memory use. Java's bit of a pig any way you cut it. * No (practical) C extension support, just FFI and Java stuff. * Concurrent threading exposes scary heisenbugs. * Java. It's not without its benefits, especially for larger scale deployments and long running services, but for most people it's a very hard sell. If [Truffle](http://chrisseaton.com/rubytruffle/) lives up to expectations I expect it will garner a lot more interest in future. For the record, I've been using JRuby for the latest version of [FreshBSD](http://v4.freshbsd.org/). I'm doing some pretty heavy batch processing and making a lot of use of threading (even page generation involves using concurrent-ruby Futures), and for the most part it's been great.
Well, I got it working, and you can see it in the edit. Thank you very much for your help.
This is basically a wrapper for react like architecture. If you like this, I would recommend to have a look at opalrbs Clearwater framework. Also, why not just dive into react and virtual-dom, it's really interesting stuff.
Its pretty useful if you need speed, and all your gems work with it. The latter is why a lot of people don't use it. Not all gems work with it. Most do, but if you have some business critical bit of code, and the options are: 1. rewrite it to work on jRuby 2. Use MRI Chances are you're gonna just stick on MRI and spend those man-hours elsewhere, like whatever sales latest customer promises are
wat
If you look at the sell associated with Ruby, you find yourself saying things like "Github are using it" and "Stripe are using it", and usually end up pushing MRI in the process. I wish there were a few more bigger names on jruby to help out here.
For one thing, reading non-formatted code is tough, gists are a quick and easy way to do so! https://gist.github.com/ This will help the entire community help you. Just keep practicing and you will get there. I was in the same position and had a hard time transferring from a procedural standpoint to objects sending messages to each other. Write the solution out on paper just as trivial as you can to solve it. Good chance ruby isn't too far from it, and then refactor. This is a nice little website to help you grow and become creative with your language. There are some really clever (maybe not best practice) solutions out there that can open up perspectives you might be missing. www.codewars.com
I will bookmark githubgist, thanks for the resources. I will start working things out on paper- i think that will help a lot
Full-on, actor-model or evented threaded code can definitely be hard, but "I want a thread pool so my work gets done six times as fast" really isn't (see the concurrent-ruby gem for dead-simple usage). If you're serving a few web requests a second (or minute!) you'll never notice, but if you're using ruby for data transformation or in a similar pipeline, the speed differences are substantial before threading and essential after. Plus, "real" threads allow "real" threaded servers, which cut down on memory use compared to lots of forking (for me; obviously it depends on your use case, stack size, etc. etc. etc.). 
How do you know it isn't? In general, JRuby works _just like MRI_, it is ruby. All those stackoverflow tags 'ruby' apply to JRuby too. Sure, sometimes you need to figure out something specific to JRuby, those are the things tagged 'jruby' I guess. Similarly, I wouldn't assume a job posting asking for ruby _isn't_ using JRuby. JRuby is ruby. 
Literally just the startup time. Charlie and crew are aware of this and are working on it.
Hey, thanks--this help should clear up a misconception one of my co-workers seems to have at work. 
I played with a Rails 4 app targeting Ruby 2.1 on JRuby 9.0.0.0, and while it did require some fiddling, none of it was to the application itself. You mostly need to replace some gems and the web server. Mostly changing therubyracer to therubyrhino, exchanging the normal pg gem for jdbc one, and swapping Unicorn out for Puma. Admittedly, my test app was pretty simple, but the biggest challenge is replacing gems that install native extensions. If you don't rely on many of those, you can get a simple test running with very little effort.
We use jruby for a very limited service that somebody else wrote who's no longer with the company, and we've had a dim view of it since. This sorta thing gets my gears turning tho. 
I really like ruby, but if you are using ruby for high throughput processing needs you are really kind of self sabotaging. There is a reason why many ruby gems that are at all related to speed are actually C code wrapped in ruby. Ruby is pretty well known for being on the very low end of performance, threaded or not.
Meanwhile I found this www dot spinacms dot com....looks really awesome and easy to use. What is your opinion guys? I am looking forward to build a website, should I try this? 
nice one
LOL
People hear Java and run away... and that's good.
The one time I used JRuby was a script on a machine that required database connection for gathering performance metrics. The machine hosted a Tomcat application, so I knew I could rely on JDBC.
can you give us the name?
Thank you for sharing this! Here is more information on what `--dev` does: https://github.com/jruby/jruby/wiki/Improving-startup-time in short: * client mode where applicable (generally older 32-bit JVMs) * TieredCompilation and TieredStopAtLevel=1, equivalent to client mode on newer Hotspot-based JVMs * compile.mode=OFF to disable JRuby's JVM bytecode compiler * jruby.compile.invokedynamic=false to disable the slow-to-warmup invokedynamic features of JRuby
&gt; - Java. Not really an argument :P. But I completely agree with the rest of your points. I found jruby interesting, as one could use a lot of existing java APIs, but it's not really a reason to use jruby most of the time.
Great tip re: checking the Travis badge. Thanks.
Did you try writing a small Rack endpoint for multithreaded puma? Seems like it should perform just as well without having to patch/rewrite things.
I didn't and it might. Although theoretically a threaded concurrency mechanism would add some overhead, compared to an event loop.
With you there.
that falls down when you're using jruby specific gems 
1. In my opinion, break is _preferable_ to return because it breaks out of the current block, meaning that if you have 2 loops, one inside the other, using return will break out of both of them. Additionally, break can be used to return a value. As far as I know this is the idiomatic way to do it. Where did you hear breaking out of a loop is a bad idea? [Documentation](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-break) 2. Sounds like you need a new method that returns values from both of the methods and compares them. 3. The appropriate way to do this is to either: Pass an argument with a meaningful name and execute one of the loops based on an `if/else` or create a method to contain each loop that way `hit_dealer` has it's own version to call. The second idea is better because it honors the [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) You are trying to introduce a Dealer, and Dealer is a noun rather than a verb meaning that it is a class rather than a method. Perhaps it is time to spend some time looking into creating a class to house your methods? If you can get the concept of classes to click, a lot more is going to make sense about how to implement this. Edit: Removed a sprinkle of humor because apparently it won't fly.
So I guess I could wrap it in something like def cast_time_zone(date, venue) Time.use_zone(venue.time_zone) do datetime = Time.zone.parse(date.strftime('%Y-%m-%d %H:%M:%S')).utc end end then right before I'm about to save an availability I could do something like: Availability.create(start_date: cast_time_zone(params[:start_date], @venue)) Is that how you'd do it? 
Not starting a flame war, but why not use Atom?
I have both, and I find that RubyMine is a lot easier to use when I'm doing pure Ruby work. All the find definition and refactor features and the like are great, especially since they can dig through gems and stuff. It's great. As soon as I want to polyglot, though, Atom fires up. [](/GNU Terry Pratchett)
RVM.
Thanks rsphere. What you're saying makes a lot of sense, Heisenberg approves haha. 1. During a section of the course it was said that break isn't always the best method for exiting a loop. It was a very vague statement. I did a quick google search on the subject to find out that it's just that you need to know HOW to use it. I think it's probably a bad idea to rely solely on using a break in my 'loop do' so I was looking for a different and better way to approach it. 2. Yup, that method you're describing is exactly what I need. I guess I'm confused about how to store the user's 'card_total' into something that I CAN compare against the dealer_card_total. 3. That is also a great idea, I'll consider writing loop methods for the user and dealer separately. I got really overwhelmed earlier when I looked at my code. I was concerned that there were TOO many methods and that it was bad practice, but I guess it's a good thing. I think I need to separate some of it out and definitely have my own file for the dealer only stuff. At least until I have a lot of it written. Any tips on how to stay organized and not get overwhelmed by a billion methods is welcome. Classes are something I have a very small amount of knowledge about. I understand they exist, how about that, haha. No, I mean, I understand there are pre-existing classes like string, and integer etc. but what you're saying is that I can make a 'user class' and a 'dealer' class and house my methods in there. I should read up on that, definitely. Do you think it's worth continuing this by first implementing TDD via rspec? At this point, it seems like the rspec is harder to grasp than the actual coding. Thanks for trudging through my code, it's beyond basic but hopefully I'll nail this down soon.
"They're putting me under pressure to respond quickly (like 1 day)" - Say NO and forget about it. I find it always beneficial to avoid such hurry up deals when they give you no time to decide and think about it.
Have to use a lambda if you want less than or greater than... 
Your case statement is poorly formed. Do you not mean: test = 5 result = case when test &gt; 0 ; "positive" when test == 0 ; "zero" else "negative" end p "result is #{result}" Which yields "positive".
guys, has anyone tried to use when statement with regular expression? I have two characters string to compare, in some cases, I care about both characters, in others, only about the first one. Is there a way to use regular expression so that the second character would be disregarded in comparison when using when?
I wrote it because its obvious Ruby don't check for interpolation here, so it has to be faster _somewhere_ :), it might not be visible in run time though, that's why I wrote "should" :). But that's not the reason I am advocating this.
If you specify an argument to the ```case``` it will be compared in the ```when``` using ```===```, letting you for example do comparisons with classes or lambdas. So when you write ```case test when test&gt;0``` ruby is actually testing if ```(test&gt;0) === test```, which is false. Same with ```test==0```, so the ```else``` clause is used. Easy solution for you: remove your first ```test``` in ```result = case test``` and it will work as intended.
OP: Includes a short interview with with Bryan Braun, the author of Franklin and original owner of "Bitbooks" - the now sadly defunct self-publishing service.
Either remove the `test` from after the `case`, or remove it from each clause. You can do: result = case test when 0 ; "positive" # ... Or you can do: result = case when test &gt; 0 ; "positive" # etc With what you've doing, it's comparing `test` to (eg) `test &gt; 0`, which is not what you want. 
Great write-up. FYI: If anyone wants to build a classic book with jekyll - I've put together a ready-to-use theme, that is, [drjekyllthemes/jekyll-book-theme](https://github.com/drjekyllthemes/jekyll-book-theme). For a live example see the novella "[Dr Jekyll and Mr Hyde](http://drjekyllthemes.github.io/jekyll-book-theme/)" by Robert Louis Stevenson. Cheers.
+10 you, man. This has been something I've been interested in for a long time, but only got around to exploring in CoffeeScript. I [presented](http://mrluc.github.io/hammy/12-7-rum-macros/deck.html#1) it to Ruby folks, and so I [mentioned attempts in Rubyland](http://mrluc.github.io/hammy/12-7-rum-macros/deck.html#35) at the time, but there was only one dead project and the rbx transforms. I agree that the big question is if there's too much of an "impedance mismatch" between Ruby and compile-time. There are *so* many runtime meta abstractions in Ruby; runtime meta is basically Ruby's defining characteristic. Or put in another way, say Matz adopts macros. What does Ruby look like in 3 years? ... No one knows. (Personally, I think that Jose Valim has proved with Elixir that a language can adopt macros and retain its own distinctive style and syntax! Of the examples of accessible, macros-without-read-macros languages out there, Elixir is the **only** one that's both generally accessible **and** has a high adoption of its macro features, ie Scala has them included by default now, though still namespaced as experimental, but you don't see them much; in contrast, you use macros all the time in Elixir).
Saving some people some time, there is nothing in here that is not referenced in http://guides.rubyonrails.org/security.html, if you are using all of this guidance (as you should be) you are already protected. The OP article is valuable insofar as it elucidates how an attacker may view common surface areas in ruby/rails as weaknesses to pry open. 
That's a definite "no" in my book.
You can also take a look at Crystal, that have macros in place of *eval, define_method etc.
Lucky! It can be hard to greenfield a service within a legacy code base. You had the benefit of a compelling event ("falling over"), whereas most of the detritus I work with is more developer aggravating ("hurts velocity" to my manager) than business impacting. I think something that makes a good engineer is being able to right-size change. Find (and plan and deliver) small, iterative changes that rebuild the ship as you sail. Sometimes you do have to take it to the dry-dock, but I find a lot of my mentorship to jr devs goes into helping them understand the source of their frustration and plan a retrofit rather than just feed their call to rewrite it from scratch (often on some new hotness). 
That's great, because pygments was a pain on Windows. The last time I tried Jekyll, I changed the pygments dependency for Jekyll itself and then one of the other gems needed it. I just went to Wintersmith instead.
It depends, if there is a fixed presidence on the match and action you want, if you order the whens the same way it will act as a simple trie short circuit. Meaning if you always want to do action A if the string starts with MA or action B if the string starts with M but not MA as long as you write them in the correct order in the case this will work just fine. Edited to add an example to make it more clear. foo = 'MA this is a test' case foo when /^MA/ puts "MA Matched" when /^M/ puts "M Matched" else puts "default action/sad path" end
You can scan for most of these vulns using [brakeman](http://brakemanscanner.org/). Their documentation of [warning types](http://brakemanscanner.org/docs/warning_types/) is also a good read.
I guess I would hope anyone reading the security guide would walk away with the core understanding that using user input (params directly or content) is a baseline extreme risk and should be avoided or protected in all cases. The guideline does not directly cover all aspects of displaying user created content either -- but woesyou if you are storing content and displaying later without scrubbing it.
Well, my gem isn't in there (yet), so there's that.
[removed]
[removed]
Thanks for the encouragement!
I think you'll still have a problem if one of your dependencies depends on one if those.
Each gem listed there is a link to evidence. 
Some Ruby gems have 'native extensions', meaning they're partially written in C for better performance. This means that you need to have a C compiler available to build them. You're on Windows, where people usually use [this devkit](http://dl.bintray.com/oneclick/rubyinstaller/DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe). Run that file, pick a directory in which to store its contents, then open a console in that directory and run `ruby dk.rb init`, then `ruby dk.rb install`. This *should* solve your issue -- but these things can be annoying and unreliable on Windows, so you might want to look at setting up a virtual machine running CentOS or something in the future. You obviously need to have MySQL installed and running if you're insisting on using MySQL, but I assume you know that.
it's a salary position at a consultancy, so the parse.com project is just their current priority. anyway, i know there are some red flags (and there are ones I haven't mentioned), but I've been unemployed for 6 months, applied to hundreds of jobs, and this is my second offer so far (i rejected the first). 
[removed]
I can somewhat agree with that, but I think that some addition of context would be helpful - as simple as a *_fixed yyyy/mm/dd in commit #######* would do.
[removed]
Great stuff.
Yes. I had the same feeling.
I ended up doing this: when /4\d/ to match any two digits, where the first digit is number 4. Worked well ;-) Thanks for your help.
Good point about single-purpose departments. I have seen a few places - even startups - that have one expert in charge of automating the build server and test suite, but even then I would wager that they are veterans of full-stack who slowly moved into the specialization, and that they are versatile enough to get right back into the trenches and pull weight. That being said, I have a feeling that those companies are few and very far between, and I do think there is a paradigm shift happening that focuses more on developers being responsible for testing their own, and each other's code throughout the development process.
[removed]
[removed]
No they don't. They're always bugs, but are mostly apparent in long running processes, like a rails app. 
[removed]
From the bundler documentation: &gt; In some cases, running executables without bundle exec may work, if the executable happens to be installed in your system and does not pull in any gems that conflict with your bundle. &gt; However, this is unreliable and is the source of considerable pain. Even if it looks like it works, it may not work in the future or on another machine. So no, never assume a gemset will execute correctly without `bundle exec`. The advantage of gemsets is having Ruby version + gems for those Ruby versions contained and isolated by Ruby verson, and by gemset.
Use the 80% approach. Believe it or not, often giving 80% is enough. 
I agree with you that both are doing the same thing. RVM gemsets were invented before bundler existed. I think there is no need for them with bundler. 
[removed]
They are not doing the same thing. - Gemfiles are project scoped. Gemsets are system-scoped. - Bundler resolves gem dependencies. Gemsets do not. - Gemsets change your current system ruby version. Gemfiles specify a ruby version per-project, but throw an exception if your system version does not match.
[removed]
PRs are welcome.
"Yummy config files"
[removed]
I agree OP can stick with bundler. It makes more sense to declare gem versions on a project-level while in development, but the 3 differences I outlined are quite substantial and knowing the difference could prove useful in the future for someone. I simply don't want anyone going forward thinking that Gemsets and Bundler do the same thing. I have heard of cases in gem development where there is an intensive focus on testing across multiple versions of Ruby, irb, and gems (with bundler in the mix). I remember the proponents of the workflow spoke very highly of it. I'm also very curious to hear someone describe this in detail so I can understand it's merits.
Ruby is not rails. Learn ruby and you will be fine. Look at code academy.
Yeah, all programs have bugs, and all programs have bugs that result in memory leaks. Most memory leaks are never detected, but they are still there. What the author is talking about are **known considerable** memory leaks.
Rails _is_ ruby. Learn ruby or you won't be fine. Look at code academy. Edit: I was just having a little fun with [/u/comrad](https://www.reddit.com/user/comrad). Rails is a perfectly valid way to learn ruby, but make sure you dedicate some time here and there to learning _just_ ruby, and also be prepared to be confused about why some things don't work without know ruby first.
[removed]
Thanks for this! Can't deny how good an idea it is to do a _good_ Rails+ActiveJob+Sidekiq tutorial, show developers how to use your API, and get exposure at the same time. Bravo. :)
[removed]
Mr. Semantics-Pants
[removed]
If you've already started down this path, you can make it work. Personally, I'd always recommend people start with learning the basics of ruby before diving into Rails. If you learn best by courses, that might be a course. If the course you are taking does not at least start with some ruby basics, then I think the instructor's advice does not sound legit to me, no, I don't think you'll be making the most of your time (and money?) taking a significant Rails class without having seen ruby before. You'll be at best copying-and-pasting without understanding what you're doing ot make things work -- which is how some courses go; those are not good courses. Especially if you already know how to program in other languages, if you're already a programmer, then you can learn the basics of ruby on your own in your own time in I dunno 4-16 hours or so. Especially if you are not already a programmer and are not familiar with other languages, then, yeah, I don't think that's a good path. Just my opinion, which is what you get on reddit. :) If you're already a programmer and he spends a class session or two on ruby without Rails, that could work. We don't know the curriculum, we don't know enough about the instructor to say if he's leading you well or poorly. :)
Getting a better understanding of common patterns and coding style. Browse through GitHub and look at some of the larger Ruby projects to learn from others.
Ruby is a very useful language with lots of syntax sugar to get things done. But most importantly, it's an object oriented language, and use that to your advantage. I started learning Python and Ruby because I wanted to run away from Java's rigid structures. So I got used to pass dictionaries with data around instead of creating proper class abstractions. I think that's the biggest mistake people do when programming in Ruby. Sure dictionaries (Hashes in Ruby) are useful, but they don't allow you to define methods and enhance your abstractions. Code gets a lot better when you create proper abstractions for your data. 
I know of nothing like that for pg. For different implementation examples, Sneakers is multithreaded as is shoryuken and sidekiq. Note that Sidekiq is LGPL so any project which uses Sidekiq code must also be LGPL licensed. Shoryuken is also LGPL since it is based on the sidekiq codebase.
Thanks, I'm looking for something without a redis/rabbitMQ/AWS SQS/etc dependency, working with just what you've already got in your app anyway, like an rdbms (which is or probably could be postgres). Thanks for the reminder on sidekiq licensing terms. I haven't looked at the code yet in detail, from your own recent comments on switching from celluloid to bare threads, I suspect the multi-threaded aspects of Sidekiq are not actually the hard/complicated/hard-to-duplicate-from-scratch parts. In your view as author, would looking at the Sidekiq code for inspiration, but not actually copying and pasting any code, be a derivation that requires licensing? 
Que. Que. Que: https://github.com/chanks/que It does everything you want. I use it in production. It's great.
I wish I would have understood the concept of metaprogramming in Ruby. Rails seems like a magical black box without understanding what's going on with that. Understanding modules is good too.
I agree. The lesson learned from changing an app piece by piece is invaluable. Rewriting is rarely an option when the business logic is coupled. Besides, when I am done on one end I realize that with something I learned a week ago I can refactor something else I already touched a month ago. I never had that on a green field because it puts you in that position.
Look at Que. Que + jruby = fun ACID. 
thanks!
I will point out that while some of this post is true, it also is a double edged sword. DevOPs is pretty popular as well as some other trends point to generalists over specialists at this point in the market. Specializing down also means that depending on the specialty your value can quickly be marginalized as the market quickly shifts. I have seen more than a few friends who doubled down on specialties over the years get the rug pulled out from under them.
"not too hard" for me, an "expert" (I use the term loosely) in the field. Multithreading is always painful, it still took me a week to convert from Celluloid to bare threads. I try to minimize shared mutable state to make things as easy as possible but automated and manual testing are still a bear. Personally I wouldn't consider looking at several different impls for inspiration to be derivation but IANAL.
[removed]
[removed]
YouTube "Sandi Metz" and I guarantee you'll learn a lot.
I'll need to see a mathematical proof, to prove that **Period** because it's obviously not true if you apply logic to the problem. You're asserting that all types T have memory leaks, with type T being an incredibly general concept that applies even if someone makes custom electronics that are programmed with a custom method which results in a system where it's easy to prove that there are no memory leaks in that particular program. Are you going to argue that entropy in the material from which the memory is constructed constitutes a memory leak? Because that would just be stupid.
Is there some code you didn't provide here, or should I consider the missing methods (get_user_input, prompt_user, deal_card, invalid_command, etc...) to be pseudocode?
[removed]
I wrote you a program unrelated to BlackJack - I assume you like skateboarding based on your GH, so here's something in that vein. :P Copy it into a file and run it. You should be able to figure out most of it! I'll check for questions every once in a while. :) class Board attr_accessor :speed def initialize @speed = 0 end def accelerate @speed += 10 end end class Skater attr_accessor :name def initialize(name, board) @alive = true @crashed = false @name = name @board = board end def skate if @alive while @board.speed &lt; 50 puts "#{name} is accelerating..." @board.accelerate puts "#{name} is going #{@board.speed}mph!" end end crash! kill! end def crash! puts 'DUDE IS CRASHING!' @crashed = true end def kill! @alive = false puts 'DUDE DIED!' end end board = Board.new skater = Skater.new('ETphonehomeslice', board) skater.skate Here's the output: &gt; $ ruby skate.rb ETphonehomeslice is accelerating... ETphonehomeslice is going 10mph! ETphonehomeslice is accelerating... ETphonehomeslice is going 20mph! ETphonehomeslice is accelerating... ETphonehomeslice is going 30mph! ETphonehomeslice is accelerating... ETphonehomeslice is going 40mph! ETphonehomeslice is accelerating... ETphonehomeslice is going 50mph! DUDE IS CRASHING! DUDE DIED!
You don't need to use the `#{time}` syntax unless you're in a string. Try `0 * time + 0.5 * 9.8 * time ** 2` instead. Within double quotes, you need it. So `"The time is #{time}`" is required. But that's **only** within a double quoted string.
Have you tried my_num = 0 * time+0.5 * 9.8 * time **2 Depending on what the formula is you might need some brackets in there too. You're trying to use string interpolation (I think that's what it's called) in a numerical assignment.
Hahaha. Amazing! Thanks for that. So in my GH profile, I'm actually playing [footbag](https://www.reddit.com/r/footbag) haha. Ok, I should have clarified about what I was giving you. I left out those other methods but if you want to look at the original post, you can. I didn't include them because they aren't giving me issues, it's only the ones posted. I can give you my entire code if you're interested in looking at the whole thing and playing with it. You're probably shaking your head already with the noobie code, so no worries. Thanks man!
`#{variable}` interpolation only works inside strings, so that Ruby can tell the difference between the word "time" and the variable `time`. If you're just referencing a variable outside a string, it assumes you mean `time` instead of "time". So: =begin The acceleration of gravity takes a time (in seconds) and goes through an equation to discover the acceleration of gravity after said amount of time. =end puts "Please insert the time in seconds for calculating the acceleration of gravity." time = gets.chomp my_num = 0 * time + 0.5 * 9.8 * time ** 2 puts "The acceleration of gravity at #{time} is #{my_num} meters per second squared."
Rofl! I guess I should have looked at more than the thumbnail. [This](https://avatars1.githubusercontent.com/u/14144347?v=3&amp;s=52) sure did look like skateboarding. :P Oh well, hopefully you can learn something about classes and instance variables from it. The full version is going to be the best to help you with if you don't mind. No head shaking btw. We've all been there and remember it very clearly. You just need to be clear, once you link me the full version, how much information you want me to let on. I don't want to rob you of any victory or satisfaction. :P
By removing the #{} around them I get this: String can't be coerced into Fixnum (repl):6:in `*' (repl):6:in `initialize'
[removed]
Cool, thanks. Yeah, I've got some multi-threaded concurrency experience too. It is fortunate that a queue-feeding job handling system seems like a case where shared mutable state can be seriously minimized, which I agree is about the only way it's sane to do at all, but still sometimes painful debugging and testing. I think ruby-concurrent thread pools might help a lot. 
I don't know where it's documented either, it's just special handling in ruby for the `[]` method that lets it be called like that. It's how the standard `some_array[index]` is implemented, in terms of a `[]` method, and it lets you define a `[]` that can be called that way on any class you are writing too. There is similar handling for many punctuation "operators". class Widget attr_accessor :name def initialize(n) self.name = n end def *(other_thingy) "You just starred #{self.name} and #{other_thingy.name}" end end puts Widget.new("Thing1") * Widget.new("Thing2") # =&gt; "You just starred Thing1 and Thing2" Define a method `*`, you get to call it like an operator. You can also define operator methods for `==`, `===`, `+`, `/`, `%`, `&amp;`, `|`. Maybe some others I am not thinking of or don't know about. I'm not sure where this is documented; in general, I'm not sure where to find to good documentation of features in the ruby language itself (as opposed to the stdlib, which is decently documented). Maybe it's somewhere I don't know either? I think most of us picked this up by noticing it in code we were looking at and researching more (as you've done), or from a non-official tutorial or book. Ruby oral tradition? I dunno. Maybe there's more complete ruby language docs in Japanese? 
These guys are doing amazing work.
I told you to change the line where you do the assignment to my_num. The puts line was fine at the very beginning. I'm also not sure squaring something with ** is a thing in Ruby. I know it works in Python, but I don't think it does in Ruby. I'll just do the code for you, try to understand it: puts "Please insert the time in seconds for calculating the acceleration of gravity." time = gets.chomp my_num= 0 * time.to_f + 0.5 * 9.8 * time.to_f * time.to_f puts "The acceleration of gravity at #{time} is #{my_num} meters per second squared." That should work.
[removed]
[removed]
[removed]
[removed]
What version is this going to be integrated in? I seen a comment asking if its going to be in the next minor or v3 but didnt see a response.
I don't think the memory savings are as pronounced these days, with modern operating systems using copy in write forking. That's why I prefer to benchmark them. Threads generally win for very high end performance, but many would be surprised to see how far fork can take you.
Yes, there is no doubt in my mind that ActiveJob would be tough to benchmark in a controlled fashion. It would be nice if ActiveJob could work over a file (e.g. `IO` in ruby) interface. Then you could create a test file that has a million jobs serialized into it, and simply feed it into each backend with something like `cat`.
I feel like this language feature might legitimize code that is clearly sloppy: ``` x = foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz &amp;&amp; foo.bar.baz.qux ``` You only arrive at code like that when your design is way, way off. And the fact that ActiveRecord is shown in the example is quite apropos; traversing a ruby object graph built out of database schema is just a bad idea period.
There's also mutator methods which allow you to call setters implicitly, which is basically just overriding the = operator for a member. An example would be setting the `foo=` method on a class, which gets called whenever you assign anything to `class_instance.foo`
Rad, thanks for the resource! 
[removed]
Done!
Works perfectly, once again I'm sorry for my own ignorance, rather new at this.
It's on master, so likely will be in 2.3.
This really. Become a Ruby expert and you can just read Rails source if you want to know how to do anything. Learn about singleton classes, learn about metaprogramming. Play around with it, get comfortable with it.
Yeah, I found that issue, where the Que author seems to be discouraging use with ActiveJob, and says it's hard to get working right, for the reason you mention among others. The author seems not to be a fan of ActiveJob, and not a Rails user, which is perhaps not a great sign. I dunno, I'll look into it. Looking around at all the options, none of them work _quite_ like I want. I want a weird mash-up of que and queue_classic (both MIT-licensed), with perhaps different more flexible handling of thread pools using ruby-concurrent (a thread pool per queue maybe? You could still have a single thread pulling jobs, but passing them to different pools per queue to do the work maybe), and with API optimized for ActiveJob use cases. (Most of these were written before both ruby-concurrent and ActiveJob). It'd be awfully fun (for me anyway) to write, but I don't know if I'll find the time. 
That's... nice? I think you forgot a link.
&gt; Ruby feels like it is straining to add more language-level features of limited utility I don't like those sulky vibes. Adding .? to the language is probably insignificant time-wise compared to other improvements and bug fixes. We get it for free, let's be thankful about it. I sometimes (though rarely) need to `x &amp;&amp; x.something` so this is a welcome addition. I wouldn't use it for things like `x.?y.?z` though. It's all about judgment (like a lot of Ruby features). Of course this feature could be abused, but good developers know better. Thanks Ruby team!
mpd or mopidy maybe? I would use one of those and control them using ruby.
I dislike this as an addition to the language. While it will certainly produce more terse code (which is a core Ruby value), I suspect it's also going to encourage bad habits, along the lines of the postfix rescue. It's okay for bad code to be a little painful to look at.
Didn't have the link to the post before, updated
mpd looks like it may be perfect. Thank you! (The hard part will be forcing myself to pragmatically use the C client for controlling instead of writing a Ruby client library. ;)
Yeah! My gut feel was "fix everything else first", but you are right. It's not an uncommon pattern to check for nil and then do something if not. Not always good, but when you are clear in your intent it's fine. I suspect there'll come a time when I go to use `try` outside of Rails and think "hang on, Ruby already has something for this. Neat." And that's been my experience with Ruby: discovering lots of nice little things that make coding delightful. 10 years in and I'm still finding new stuff.
yeah I found that couriers class on SaaS using RoR a little too much if you have no Ruby b/g at all. 
If I have an array and I call on it array[](0), instead of array[0], it totally doesn't work. Besides trial and error, how would I have known from that table that in a definition I can use that former syntax: "def array[](arg)"? I basically trial and errored out that I can do "def []=(key, value)" in a definition as well. I feel like I'm not supported by the documentation in these two instances. It's fly-by-night trail and error over here, and it feels a little weird. Is that table the only applicable resource to these examples? Thanks for bearing with me. I'm not trying to annoy! Just slow to pick up what's going on I guess.
It probably depends on what you're doing with the language. If you're only building a CRUD web service the built-in types work just fine. It only gets annoying if you try to create reusable/generic(ha!) and type-safe libraries.
Gemsets have no real use anymore, use bundler binstubs. 
Sorry - no. The new (default) syntax highlighter will be rouge (in Ruby). See the &lt;a href="https://github.com/jneen/rouge" rel="nofollow"&gt;rouge repo&lt;/a&gt; for more info e.g. note: rouge is pygemts compatible - I guess that means you can (re)use all css styles. PS: Disclaimer - I'm just a (regular) Jekyll user and not a core developer/commiter.
[removed]
[removed]
FWIW, these days I prefer to do this using `arry = [*stuff]` def splatme( a ) [*a] end splatme nil #=&gt; [] splatme 1 #=&gt; [1] splatme [1,2,3] #=&gt; [1, 2, 3] 
[removed]
[removed]
No. It's not a wrapper. Inesita uses virtual-dom for rendering, not react.
It compile to javascript. 
[removed]
Thank you
Thank you also
Here's a rundown of methods and a primer on classes I wrote up for you. Let me know how it sinks in for you. When you run a ruby script file, ruby executes line 1, then line 2, then line 3, etc. until the end of the file. In general, method bodies, classes definitions, and control structures work the same way. They execute top to bottom just like a ruby script (with the exception of loops). # Methods When ruby encounters the `def` keyword, it locates the corresponding `end` keyword and knows everything between is the method body. ruby evaluates the method body for syntax errors, but **does not execute the code**. When the method is done being defined, executing the method name will execute the body of the method. Furthermore, Ruby does not know about the method until after the definition. pry(main)&gt; func NameError: undefined local variable or method `asdf' for main:Object from (pry):2:in `func' pry(main)&gt; def func pry(main)* puts 'executed' pry(main)* end =&gt; :func pry(main)&gt; func executed This is why you can't define a method with a syntax error... pry(main)&gt; def func pry(main)* ~~~ pry(main)* end SyntaxError: unexpected keyword_end ... but you _can_ define a method that references an undefined variable... pry(main)&gt; def func pry(main)* asdf pry(main)* end =&gt; :func ...and ruby won't raise an error until you try to run it. pry(main)&gt; func NameError: undefined local variable or method `asdf' for main:Object pry(main)&gt; def func(x, y) pry(main)* x + y pry(main)* end =&gt; :func You may define method parameters as a means for receiving method-specific data. pry(main)&gt; def func(x, y) pry(main)* x + y pry(main)* end =&gt; :func You may then pass arguments to the method. pry(main)&gt; func(1, 2) =&gt; 3 Here's how the terminology works: - Parameters represent the values passed in - Arguments are the actual values Another way to look at it: - If writing a method you are accepting parameters - If calling a method you are passing arguments That being said, I've heard the two terms used interchangeably from time to time, but that's how I was taught. Above, `x`, and `y` are required, but there is a way to accept optional parameters. Below, `y` is optional. pry(main)&gt; def func(x, y=nil) pry(main)* puts "class of x: #{x.class}" pry(main)* puts "class of y: #{y.class}" pry(main)* end =&gt; :func Here is what happens if we call the function supplying only a value for `x`. pry(main)&gt; func(1) class of x: Fixnum class of y: NilClass Now both values. pry(main)&gt; func(1, 2) class of x: Fixnum class of y: Fixnum What about nothing? pry(main)&gt; func ArgumentError: wrong number of arguments (0 for 1..2) from (pry):40:in `func' # Classes Class definitions work a little differently. The code immediately inside the class definition **is** executed as the class is being defined, but much like above, the methods inside the class are evaluated for syntax without being executed. Notice how 'meow' is not output. pry(main)&gt; class Cat pry(main)* puts 'beginning of the Cat class definition' pry(main)* def meow pry(main)* puts 'meow' pry(main)* end pry(main)* puts 'end of the Cat class definition' pry(main)* end beginning of the Cat class definition end of the Cat class definition Not only is `meow` a method, it is an **instance method**. This means it is only available on instances of Cat rather than on the Cat class directly. You can create however many instances (objects) of a class as memory will allow. Instances are created with the `new` method available on a class directly. Creating an instance is called **instantiation** - this is a common concept in Object-Oriented Programming rather than something Ruby specific. This may seems strange, but after calling `new` instantiates a class, an optional method you may define in the class called `initialize` is called automatically. This is called the **constructor** - another common concept in Object-Oriented Programming. pry(main)&gt; class Cat pry(main)* puts 'beginning of the Cat class definition' pry(main)* def initialize pry(main)* puts 'initialize called' pry(main)* end pry(main)* pry(main)* def meow pry(main)* puts 'meow' pry(main)* end pry(main)* puts 'end of the Cat class definition' pry(main)* end beginning of the Cat class definition end of the Cat class definition pry(main)&gt; instance = Cat.new initialize called =&gt; #&lt;Cat:0x007fba32a3a4a0&gt; If you do not define `initialize` in your class you may still create instances using `new`. In fact, you can create instances of a class without anything in the body. pry(main)&gt; class Cat pry(main)* end =&gt; nil pry(main)&gt; instance = Cat.new =&gt; #&lt;Cat:0x007fc79407d7b8&gt; `taxonomical_family` is a **class method**. It is available on the Cat class directly rather than instances of the Cat class. We can call `taxonomical_family` directly on the class... pry(main)&gt; Cat.taxonomical_family =&gt; "felidae" ...but we can't call the instance method `meow` the same way. pry(main)&gt; Cat.meow NoMethodError: undefined method `meow' for Cat:class We have to create a new instance of Cat in order to do so. pry(main)&gt; instance = Cat.new =&gt; #&lt;Cat:0x007f98cc57c7b0&gt; pry(main)&gt; instance.meow meow
[removed]
&gt; I have seen a few places - even startups - that have one expert in charge of automating the build server and test suite I've seen it but never was that person the one writing tests, that was still on the core engineers. Usually where I've seen a dedicated test engineer it was for products with particularly complex testing requirements, e.g. "Make sure this game runs at 60fps on 150 different mobile devices". The test engineer was writing/building custom infrastructure to handle the level of automation needed. This person is usually a fairly hardcore backend engineer whom also has a lot of sysops knowledge that just happens to be working on test infrastructure. 
[removed]
[removed]
I think the compatibility is really one of the biggest reasons it's not used more, and I think 9k is going to do wonders for its usage (once people start to figure it out).
.? .....?!?!?!!!!!!!!
Split the string, call to_sym on Vector2 and Vector3, then perform the corresponding operation by case. 
I found some official documentation here: http://ruby-doc.org/core-2.2.3/doc/syntax/methods_rdoc.html Look for the section on operators. I learned some things, like how to implement unary operators, and that the element reference operator can take more than one argument if you want. 
[removed]
If you read carefully, Spy sets a hook and bonding.pry is being called in a block, so they are companions, not rivals.
[removed]
Wow. Thanks for the response. The example I gave is amazing in that it worked at all. I see the problem with capitals and agree that doing evals on unchecked code is a bad idea, generally. But, your solution is exactly what I was looking to do.
Mackenziechild YouTube blog
I realized you can make capitals work too, just implement const_missing much like method_missing above. 
Thanks, I'll give that a try. As to your first statement, your point makes sense. What's the best way to do these sorts of 'retry' actions then? Using `until` ?
Tenderlove occasionally posts some great articles, and Thoughtbot tend to have good ruby articles as well. [RubyWeekly](http://rubyweekly.com/) is also an excellent resource
[removed]
YES!
Not telling. Secret.
My personal advice (may not match others' idea of "best practices") is: don't. Don't do that. When I started programming Ruby (15 years ago!), I also tried to write super defensive code. I would check each argument for expected types or values. People (rightly) chastised me. _"If you check for `foo.class==Hash`, then I can't supply my own class that would have worked just fine!"_ So I started trying to duck-type my checks. `raise "ouch" unless foo.is_a?(Hash)` _(no, no, an Array works, too)_ `raise "ouch" unless foo.is_a?(Enumerable)` _(really, all you care about is `each`, right?)_ `raise "ouch" unless foo.respond_to?(:each)` _(well, that's dumb...why not just let it raise an error when it tries to call `each` and fails?)_ These days, I don't check my arguments. Instead of wasting time (mine and the CPUs) on argument type checking, I write documentation about what is expected, I write unit tests. If someone gives your function something you didn't expect, either it will work (yay!) or it will fail. As long as it doesn't fail catastrophicallyas long as it doesn't format someone's hard drive, or stop a pacemakerthey can stack trace the problem and figure out their mistake. Strict type checking isn't very Ruby. Sometimes I wish it was, but it isn't. And I embrace that.
or https://github.com/ffaker/ffaker 
[removed]
[removed]
I always recommend Gary Bernhardt to folks; his talks and Destroy All Software are really good (if not, though, also a smidge dated in certain spots). 
With this script def input_with_checking begin input = gets.chomp.downcase yield rescue =&gt; ex puts ex retry end end input = input_with_checking { raise "Sorry, wrong input" unless input == "expected" } I don't get any errors, but the program doesn't work as intended. The problem is `input`. The `input` inside your `def` is *different* than the `input` outside of it. Unlike, say, Python, Ruby methods are **not** lexically scoped. For a simpler example of what this means, try this script: a = 3 def report puts "a is #{a}" end report It fails with a `NameError`, because variables outside the `def` aren't usable inside it, and vice-versa. Blocks are a different story. Blocks do work that way. But method defs are different from blocks, and method defs do not work that way. So the issue is that the `input == "expected"`, being totally unrelated to the `input = gets.chomp.downcase` variable, is never updated and is always `nil`. You can test this if you like... def input_with_checking begin input = gets.chomp.downcase yield rescue =&gt; ex puts ex retry end end input = input_with_checking { puts "input is #{input.inspect}" raise "Sorry, wrong input" unless input == "expected" } This is almost identical to the original script, except the block at the bottom has been expanded to show the value of `input` before it does the comparison. (Don't worry about the `.inspect`, it just makes the output clearer.) Here's a sample of what I got running this new version of the script: &gt; ruby reddit.rb foo input is nil Sorry, wrong input example input is nil Sorry, wrong input As other commenters pointed out, the way to fix it is to pass the `input` in your method to your block when you `yield`. For clarification, I've also changed the names of the variables at the bottom so they don't look the same (since they all have different meanings/uses). I also decided to output what is now `accepted_val` since it was saved but not used. def input_with_checking begin input = gets.chomp.downcase yield input rescue =&gt; ex puts ex retry end end accepted_val = input_with_checking { |guess| puts "input is #{guess.inspect}" raise "Sorry, wrong input" unless guess == "expected" } puts "Success! Got #{accepted_val.inspect}" Using this script I can get a session like so: &gt;ruby reddit.rb a input is "a" Sorry, wrong input foo input is "foo" Sorry, wrong input expected Success! Got nil So some partial success! Everything looks good... except that `accepted_val` wound up being `nil`. This is because the last expression in your function, when it finally exits, is `yield`, meaning the result of the block is ultimately the result of `input_with_checking` (and the block itself is `nil` when it's not raising an exception). To fix *that*, simply add another line below your `yield` which is just `input`. This will be the last expression in your function, and will be what gets sent to `accepted_val`. That said, using exceptions in the block is a very strange way to go about this. A more straightforward way would be to just have the block be a predicate (i.e., something that is `true` if the input is good or `false` if the input is bad). Here's what I would write for an `input_with_checking` method: def input_with_checking while true input = gets.chomp.downcase block_result = yield input break if block_result == true puts "Sorry, wrong input" end input end accepted_val = input_with_checking { |s| s == 'expected' } puts "Success! Got #{accepted_val.inspect}" Example run: &gt;ruby reddit.rb 3 Sorry, wrong input expected Success! Got "expected" &gt; Hope this helps
Look up "JSON ruby". These days examples are everywhere, no point in replicating text here.
[removed]
**[This Developer's Life](http://thisdeveloperslife.com)** by Rob Conery and Scott Hanselman: The podcast isn't a Ruby podcast - but is incredibly well scored and produced. 
+1 for RubyTapas - best nine bucks I spend every month :-)
[removed]
[removed]
On a ruby forum, the only short answer you're likely to get is: Rails API + [.js framework flavour of the month] But, it really depends on what your project/startup is trying to achieve. Unless you're selling the fact that you're using a particular tech, no one cares except the team developing your product. Find the tech stack that makes your life easiest for what you're thinking of building until you reach the point where you are big enough that your stack choices are putting you at a competitive disadvantage. Then at least you have a base product to inform your big architectural decisions. 
[removed]
But soooo infrequently made. I got really frustrated when I went through the entire back catalog and then... Nothing. Then an episode. Then.... nothing. I'd crowdfund making this regularly produced.
[removed]
[removed]
On one hand I find it a security risk, on the other there are more and more services that integrate with your code and it seems that this trend is increasing. Are you using cloud solution for running your test such as CircleCI? Security risk because they got access to your code as well. It all boils down to trust. Do you trust them, that they won't leak your code. I think that tools such as github, circle ci and code climate will be more and more often targets of attacks. Because hacking them means access to a lot of codebase. Time will show how secure they are. Also, assuming you don't have credentials in your code. What's the potential gain of a hacker getting access to your codebase. Ability to find security bugs?
That is the only thing I can think of but no one has explicitly said that is the reason. Sometimes I feel like the security team defaults to no because it is easier. 
&gt; Now the security team is saying that code climate is a security risk and they want to remove it from the project. I have asked security and no one can explain to me why it is a security risk. Well, it's a hosted service used to analyse your code, which means giving a third-party access to your code. That means you're forced to trust a third party with access to your code who you wouldn't be forced to trust with a local service. That third party could conceivably steal it, analyse it for security weaknesses, extract trade secrets from it, and/or it provides an additional (and highly visible) source for external attackers to compromise in turn. Likewise whatever ports, logins or user-accounts you have to create or privilege for this external service to access your code is an additional potential attack vector to get into your internal systems. Exactly how serious those risks are and whether the risk/reward tradeoff is worth it is a judgement call, but it's fair to say there *are* risks associated with any solution that involves trusting third parties with proprietary assets and/or giving third parties access to your internal systems.
Poor code is likely a much larger security risk.
Can't he also run codeclimate on his own boxes, with your guys awesome new engines?
Lol. He really should just sit down (face to face not over written medium) with them and go over their concerns. Security is both technical and non technical risk mitigation and there may be quite a few issues they are trying to mitigate here. I will say that there is a pretty huge gap happening in the industry right now with a lot of small orgs going heavy devops -- For instance I just read a thread on /r/vim where a dev wanted to expose a default vim rc on all of the production hosts for all of the devs. The top response was someone telling him to just enable a acceptenv on sshd and toss a script in the systems vimrc. There were so many issues with that thread from a security standpoint I felt light headed. all of their devs with access to prod+pii and modifications to config, acceptenv is a security risk, the script presented allowed super easy attacks to take over data from any user. Sometimes security just does not feel like common sense or intuitive. 
May I propose that codeclimate add a security check like this one : http://michenriksen.com/blog/gitrob-putting-the-open-source-in-osint/
psst, the thumbnail image you have of the private keys are actually enough information to ocr it (assuming it is real). Make that all of your examples, consider rethumbing the redacted versions.
Hey, I just wanted to thank you for your in-depth analysis and explanation - not to mention your contribution. I wasn't aware of module_function, so I guess I will have a few things to read up on.
Thanks for the additional comments. In regards to our on-premise product, I just want to note that it can be run without external network access... It has no external dependencies after installation. Now, if you want to integrate with e.g. Trello, then it would need to access that, but it's designed so we do not ever need access to your source code. 
Yes! I'd love to see a GitRob Code Climate engine... In fact I was considering building one last week. Hopefully someone beats me to it. 
Just like how Uber posted their database secret in public code, and forgot to remove or replace it
[removed]
[removed]
[removed]
[removed]
[removed]
sorry a glance at username looked like the blog name, will do thanks.
Slow down there. It doesn't matter what you make as long as you're applying your newly acquired skills to something. Could try making a hangman game, no GUI. Then later add a GUI component. Code a binary search tree from scratch, linked list...the list goes on.
Liked this post, as it really lists out the features and also links to the respective PR's But better than a Changelog entry!
MRI threads are OS threads since ruby 1.9. `ps` and `top` don't generally show threads, they show processes. I think there may be some arguments to `ps` that will make it show threads, but I'm not familiar with it, or with what OS tools are available to see threads; but MRI threads are OS threads. You can get a list of all threads in a ruby process from that ruby process with ruby `Thread.list`. I'm not sure what useful things you can do with that list of Thread objects, if any. More info here: http://www.csinaction.com/2014/10/10/multithreading-in-the-mri-ruby-interpreter/
[removed]
You can also use `htop`
1) build something, anything. 2) go to github and read some code. 3) repeat
The simple answer is that once your client side processing becomes complicated enough you should consider thinking of your Rails app as a JSON API and deal with it in JS. That said, I wouldn't undertake this change lightly. As 'hot' as SPA based sites are they have their own offsetting set of challenges that may or may not be worth tackling. The middle ground is to put enough JS in the browser to handle some JSON requests to your rails backend.
[removed]
no rack 2.0?
[removed]
I'm sure there is a good reason you are using a text file as a 'template'.. but if your requirements are to do multiplication of all values in a hash, except "Joe": x.select { |_, val| val.to_i.to_s == val }.values.map(&amp;:to_i).reduce(:*) Problem is it's all or nothing though, it's not specific in terms of order/selection (no parsing). 
Yeah I was thinking of doing that, using Rails basically as an API and then having this mostly be a JS application. But that basically just bypasses all things that are nice about rails. One way I might get around the main issue communication between the database/ruby code and JS is using a js.erb file! Very far from best practice but hey, could work.
[removed]
Does a rack 2.0 exist?
[removed]
Been learning about attr_accessor since you posted your comment. Variable types; I've put @, @@, &amp; $ in front of 'theDB' to no success. Thanks
Good hint.
[removed]
You need to get good in this: https://www.shiftedup.com/2015/05/07/five-programming-problems-every-software-engineer-should-be-able-to-solve-in-less-than-1-hour On that link, there are 5 exercises to point you to the right direction. In reality, there are hundreds of such exercises that help you become a good programmer and measure your success and talent. It's not about Ruby, it's about programming and computer science. Do you know PKI? Do you know about databases and performance? Do you know about fault tolerance and redundant systems? Networking and network protocols? There are tons of discreet problems and solutions in IT and as a programmer, you can only contribute with your code to the IT world if you are well versed in all this. 
What exactly? I'll give you one more step: * Step 0: familiarize yourself with Google, cause it's #1 coding tool.
[removed]
[removed]
He believes it's too small. I disagree. What do you think? When is a gem too small? What if it's only a few lines of code but it took many hours to come up with them?
What OS are you on? On OSX, it's pretty much: 1. Install ruby. The one that comes with your system is probably outdated. Some people like using [rvm](https://rvm.io/) to install ruby. I don't, but it may make sense for a beginner as the easiest possible way to install ruby and use an installed ruby without knowing what you're doing. 2. Download [SublimeText](http://www.sublimetext.com/). You don't need to use SublimeText, you can use anything you want to write ruby code. Including MS Word saving as 'plain text' (but you don't want to do that, trust me, I just include it as an example to demonstrate there's no magic to SublimeText). But SublimeText is good. 3. Create a new file. Save it as "some_file.rb". Put ruby code in there. 4. Open up an OSX Terminal window. If you don't know how to use the terminal, google for some introductions. But you can type `cd some_directory` to change directories, `ls` to see a list of files in the directory you are "in", and `pwd` (stands for "print working direcotry") to see what file you are `in`. 5. Navigate to the directory your `some_file.rb`is in, and type `ruby some_file.rb`. You just ran your ruby code. So that's the basic introduction to "how do you get to sitting at a keyboard and writing ruby code and then running it." If you're on Windows, you're doomed. Although you can still get started. Actually chapter 0 of "Learn ruby the hard way" has some pretty good instructions for getting started with ruby, what I described above but somewhat more detailed break-down, including for Windows. http://learnrubythehardway.org/book/ex0.html The Learn Ruby The Hard way recommends TextWrangler instead of SublimeText. I've never heard of TextWrangler, but that's fine, it doesn't matter, if you find it easier to follow the exact instructions from there, use TextWrangler, sure. This is just writing a command line utility, of course. Something you run from the command line, with a text-based UI. If you want to write a web app, you use Rails or something else, and there are tutorials on that. If you want to write a native desktop app with buttons and pictures in a window... ruby is not great at this, it does not have very mature solutions for this as far as I know. There are ways to do it, I am not familiar with them personally, ruby is not very popular for writing native desktop GUI apps, although it can be done. 
[removed]
&gt; brief overview of the hash data structure &gt; A Hash is a data structure that organizes data in key-value pairs. There's no such thing as a hash data structure. Please call it hash map... (https://en.wikipedia.org/wiki/Hash_table)
Well, this gem is definitely not 'too small'. It handles different things that are nontrivial, (like logic for sidekiq, signals, etc). You want to know a really, really small gem that's used by loads of people? Check out rails12factor https://github.com/heroku/rails_12factor/blob/master/lib/rails_12factor.rb: module Rails12factor end require 'rails_serve_static_assets' require 'rails_stdout_logging' Only things these two lines do is load https://github.com/heroku/rails_serve_static_assets/blob/master/lib/rails_serve_static_assets/railtie.rb and set logging. 
[removed]
As I said, he needs to get good at it. It's a process, he will not be a beginner once he's there. Or is remaining a beginner an implied goal here?
My smallest gem is [four lines long]( https://github.com/xiongchiamiov/nice-sigint/blob/master/lib/nice-sigint.rb).
When you loop, you must LOOP HARD!
Sorry, I don't know too much about Python, nor do I know much about Windows game development. If you've never programmed before, then your time learning to program in ruby is not wasted. The hard part is getting your mind to think like a programmer, not the particular programming language. But sure, it would make sense to switch to a language that is best for the kinds of things you'd like to work on. But if you will read my comment again, i did NOT say the answer to "can Ruby make windows desktop applications" was "no". In fact, what I wrote was: "There are ways to do it, I am not familiar with them personally, ruby is not very popular for writing native desktop GUI apps, although it can be done." Perhaps someone else can give you more information on how to use ruby to make Windows desktop apps, and perhaps they'll have a different opinion than me on how well ruby works there. I haven't done it myself, so maybe I don't know what I'm talking about. Your question at the top of this thread was not clear that what you wanted was a Windows desktop app. Perhaps post another, perhaps on StackOverflow, asking for how to use ruby to make a Windows desktop app. If you really want your app to be nothing but an old-school text-basec choose-your-own-adventures, but appearing as a Windows app you can double-click to launch a window that does that -- I have little doubt you can indeed get that to work somehow in ruby. I just don't know how personally, I don't develop Windows desktop apps at all. You need to ask your question being specific about exactly what you're asking about. 
I'll try a post over on StackOverflow then. Part of the problem of asking such specific questions is that, as a beginner, I'm sort of just reaching around into a dark room. The other poster's suggestion to get familiar with google is laughable, because as an example anyone can google how to fix something in their car. But first they would have to know what was broken. Then they would need to understand the terminology, and also have the correct tools before hand. Among other issues like finding a wealth of information that isn't relevant to you, and being unable, due to lack of experience, to sift through everything to find what you need. Thanks for trying to answer my questions however. I appreciate it. 
I'm not saying that he should stay a beginner forever, but I personally don't believe that struggling endlessly over very hard problems that you've stated can and should be easily done by "any software engineer" is a productive way to learn. That's more of a bad college professor way of teaching. A better way of learning is experience; practice and increase in difficulty to solve problems you want to solve, so you can self-motivate, not problems that someone else says you should be able to solve.
Thanks for your feedback. Hard_stop is *definitely* not the idea here. It's just for the case where you have a loop that processes stuff for a long time, and it ends when it finished processing that stuff, but also you want it to finish gracefully if it needs to, because a long time passed, or because (in my use case, the main reason I made this) Sidekiq decided it's shutting down, and you better stop soon, or Heroku will Kill -9 you
[removed]
Is anyone looking for a teammate in Rails Rumble? I've never done this before, but I'm interested!
&gt;What's the wikipedia link for? I think it was to call out this section: &gt;In Smalltalk, Objective-C, .NET,[9] Python, REALbasic, and Swift they are called dictionaries; in Perl, Ruby and Seed7 they are called hashes; in C++, Java, Go, Clojure, Scala, OCaml, Haskell they are called maps (see map (C++), unordered_map (C++), and Map); in Common Lisp and Windows PowerShell, they are called hash tables (since both typically use this implementation). In PHP, all arrays can be associative, except that the keys are limited to integers and strings. In JavaScript (see also JSON), all objects behave as associative arrays. In Lua, they are called tables, and are used as the primitive building block for all data structures. In Visual FoxPro, they are called Collections. The D language also has support for associative arrays [10]
If your goal is to make a gui program or game, then ruby or Python is not what you're looking for. Either C++ or C# will work. Have fun!
Hi, thanks for your feedback. Actually, this does not default to installing a signal trap. That would be a very, very bad idea, given the tiny scope of this gem. The Trap is there in case you want to trap them with this library, in which case you need to explicitly call "trap_signals", or in case you have some other "thing" (by yourself or another library) that traps them, in which case you can just tell the SignalTrap that you've received a signal, and it'll stop the loop. The way I use this in production, I let Sidekiq trap them and look inside Sidekiq (sorry mperham) to figure out if the looping should stop. My idea is that if you like this gem but don't use Sidekiq, there'll be either a PR or an issue to add a new "trap" for that library that probably does its own signal handling, like Sidekiq does.
[Nice work](http://i.imgur.com/x0TLKRO.png).
A gem from last year http://twaxdotcom.com/
Thanks. [I work here](https://www.reddit.com/about/team/#sort/new/user/xiongchiamiov), so it's kinda part of my job. Ok, it's actually really a major part of my job.
Ah, I must've misread the code, then. In general, I don't like trapping from libraries - that's a strictly business logic-level concern. It's helpful to have things to available to be able to respond to signal traps, but in my experience, when the programmer isn't explicit in how traps are handled from their own code, you get some rather esoteric bugs. :)
[removed]
They're pretty different. reactor pattern vs actor model. (google dem)
or, find app/views/foo -type f -exec sed -ir 's/(\w*)foo_(\w+)path/\1\2path/g' {} + mv app/views/foo/* app/views/ 
You can use Ruby on Windows. Some gems don't work but for writing a text adventure game you are fine
See https://github.com/larsch/ocra/
https://en.wikipedia.org/wiki/%3F:
[removed]
This is called a ternary operator. It works exactly the same as doing if word val = word + letter else val = letter end or alternative val = if word word + letter else letter end The variable before the question mark is the condition. The part between the question mark and the colon is the return value of the condition evaluates to true. The section after the colon is the return value of the condition evaluates to false.
Small, reusable code is good code. Ideally, large modules are built from many small generic modules. When making a library, fitting into the 'small generic module' category is a terrific goal.
Nice `-exec`. I would have `-print0` and piped to `xargs -0`.
I agree the code above is a bit of a code smell, and I use the NilObject pattern extensively when coding my own projects. (either by using an OpenStruct or a regular Struct) Still it is nice to be able to provide alternatives when thinking about projects.
[removed]
[removed]
This is one of the main reasons I will probably never stop using RubyMine/IntelliJ for Ruby code. It makes Ruby sooo much easier to debug. 
You could try something like this: students = {} str = "59: johonsn jack music 2010" # Split into two groups id, *attributes = str.split # Chop off the last character (the `:`) id.chop! # Save into the hash students[id] = attributes Another thing you can do is to use a [regular expression](https://en.wikipedia.org/wiki/Regular_expression): # Split by non-word characters id, *attributes = str.split(/\W+/) In this case you wouldn't need the `chop`. 
Am I the only one who has never had trouble with this?
So I guess you already checked that the customer_accounts table has a 'leases_enabed' column?
[removed]
Nope - didn't know this was an issue. 
Well, in my application I haven't migrated from other solutions. But thanks for reminding me that it would be nice to write some guides that will help people.
Please correct me if I'm wrong, but that pattern has one major flaw: You cannot send any arguments/blocks with the method(s). By the way, there's no need to include `&amp;block` in the method, like this. It makes the code run much slower, and for no reason.
What potential problem do you see? It currently works with an error message similar to `3 for 1..2`.
&gt; Please correct me if I'm wrong, but that pattern has one major flaw: You cannot send any arguments/blocks with the method(s). I think you're right about that, but it seems like the basic idea could be expanded to allow it. &gt;By the way, there's no need to include &amp;block in the method, like this. It makes the code run much slower, and for no reason. I'm not sure what you mean by that. He gives the reason for it, right?
The top-rated answer is using a Regexp to indicate what constitutes a delimiter. The syntax `/[\s,']/` will match a whitespace character (`\s`), a comma (`,`) or a single quote (`'`), so String#split will recognize any of those as delimiting desired content. For your problem, I'm assuming that you know that the key is in the leftmost position, and is followed by a colon. This is one way to do it: 2.1.2 :001 &gt; student = "48: jackson michael dancing 1992" =&gt; "48: jackson michael dancing 1992" 2.1.2 :002 &gt; pieces = student.split(/[\s:]+/) =&gt; ["48", "jackson", "michael", "dancing", "1992"] 2.1.2 :003 &gt; key = pieces.first =&gt; "48" You can then do what you want with the other pieces (`pieces[1..-1]`); either join them back together, or assign them to variables individually.
Any reasons to use `binding.pry` vs the built-in `debugger` command in Rails projects?
Did you try built-in Darcula scheme? I really like it.
tomthecool is just suggesting leaving `&amp;block` out of the method signature. You don't need it, because you are using it implicitly with `block_given?` and `yield` in the method body, rather than explicitly mentioning the `block` argument. Leaving `&amp;block` out of the method signature and using implicit `block_given?`/`yield` will give you somewhat better performance, at least on MRI. Normally I don't think the perf differences matter all that much but for something like this that could be used all over the place including in performance-sensitive places, it makes sense to use that easy optimization. Since the author already used the implicit `block_given?` and `yield` rather than explicitly referring to `block`, I think it was probably just an oversight on their part to leave `&amp;block` in the method signature. 
Here's one way, depending on exactly what you mean. hash = {} file_handle.each_line do |student| key, value = student.split(": ") hash[key] = value end There are fancier ways to do this in even fewer lines. But this is not complicated. Am I not understanding something about what you need? 
Yeah just never found it attractive haha
100% agree. It's one of the funky things about the app. It sounds like a small detail, but it's not: it's a hurdle to having your dev environment ready to go
[removed]
I browsed around on: http://www.ideacolorthemes.org/home/ and eventually found one that suited my tastes. 
I like leaving the explicit `&amp;block` in there, as you only need to scan the method signature to know it's going to make use of a block -- rather than having to look through the actual method code looking for the use of a `yield` Also the performance impact on most real-world apps (from keeping an explicit `&amp;block`) is going to be absolutely minimal. 
[removed]
&gt; Also the performance impact ... is going to be absolutely minimal You'd think so, right? But surprisingly not: Methods containing an explicit `&amp;block` are over 400% slower: https://www.omniref.com/ruby/2.2.0/symbols/Proc/yield?#annotation=4087638&amp;line=711&amp;hn=1 Although being explicit is generally better, in this case I think omitting the block is justified.
I have always used built-in Dracula as I never liked any of the other schemes on RubyMine.
I found this https://github.com/ChrisRM/material-theme-jetbrains which is pretty neat if you are familiar with them for sublime or atom. Right now, they are my best choice.
This worked perfectly. Thanks and good luck to you in life, sir or madame. 
I like Darcula a LOT.
400% slower (4x slower) is still going to be minimal in the scheme of things, cos we're talking 4x slower with respect to something that is already extraordinarily fast.
From the linked commit err_mess = rb_sprintf("wrong number of arguments (given %d, expected %d..%d)", argc, min, max); So exactly like it does now, just the message is better worded.
Typically, yes. But this is intended to be a core library tool, which could get used all over the codebase; including lots of performance-sensitive areas.
[removed]
Thank you. Especially since plenty of us use many programming languages in our work.
I'm wondering what percentage of your programming is in Ruby? Maybe the difference in people's reaction to this error message is related. E.g. I do 50/50 Ruby and Python, which present the two numbers in the opposite order. So Ruby's error message always trips me up.
I actually thought about that almost immediately after I wrote that comment. I'm employed as a Ruby dev so most of my programming time is spent writing Ruby. I do spend considerable time writing Clojure and Javascript as well.
Weird, I never see this error because I'm perfect.
1. Install Vagrant 2. Configure a VM 3. Write some provision scripts to install git + rbenv/rvm + whatever 4. Forget about reinstalling all the stuff with a new os or machine. 5. Enjoy! P. S. As for me (arch user) rbenv runs much smoother and controls ruby versions better that rvm. And please, don't use an apt method, cause the usual stuff about official reps is a damn outdated stuff. 
[removed]
[removed]
Isn't that kind of like putting a bumper sticker on a car? I mean the requirements for non profit exist to enforce the public interest and for that you gain tax considerations (for you and your supporters). With a benefit company, as I understand it, there is little benefit at all except the label (hence the sticker); and there is nothing stopping you from pursuing profit above all else just like any other corp... 
thats for sure google told me but can we achieve that or not ? if yes how? Em.run {} block doing time tickers, is anything equivalent to that in celluloid ? I think its really a vague area and taboo, not sure why there is not much push on it and people afraid to talk about it, if there are no examples, then people like us cant learn and start and have to choose other language like go
In general I would say: Just don't do this, it's very brittle and error prone. But if your application really needs it, use a [Hashie::Mash](https://github.com/intridea/hashie)
Rails and EventMachine are more or less incompatible. But you can google for how people have tried. That most of the examples you find online are outdated probably tells us something. 
I didn't know about Brightbox PPA. I like that idea.
A more flexible way to do this is to cast to `time`. e.g. `start_time::time BETWEEN '00:00' AND '09:00'`. Then you can just pass in any start/end time you want. 
That sounds strikingly similar to my day, minus the ping pong. Ruby/java/python/go data engineer.
Mostly hookers and blow.
[removed]
I actually like the first way you did it better, it's perfectly clear, and actually even fewer lines of code than your second more complicated way. But can you still use a range as a param to the where? I think maybe? scope :within_morning, -&gt; {where("extract(hour from start_time) in ?", (5...12))} 
Found the rockstar. _
Mostly web development, but honestly most of the web apps are just front ends to get data in that then needs manipulating and working on. Of course some apps are boring things that make others lives easier within the organization. Usually I come in and catch up on email. Review tickets, then code. Meetings randomly interspersed throughout the week. But usually I spend most of the day adding features, fixing bugs (we have apps all through the rails versions 2-4). And working on new stuff that shows up. There are always new projects....Honestly i deal with more js than you'd think. There isn't a convenient way to do what d3 can do in ruby :(
[removed]
Linux system administrator here. I've used Puppet, Chef, Sinatra, Rails, and straight Ruby in the course of duty. Meetings are rare at my company. I'm in a couple meetings a week max, never longer than half an hour. I pretty much live in Vim. Ruby and Ruby DSLs make up 80% of my time at my desk. I'm pretty happy. I get paid to solve puzzles all day. I'm often reluctant to go home. I make in the low six figures.
[removed]
I never had problems with this, though Ruby is the only scripting language I use, clang and gcc errors look too different and the errors the rust compiler can give me are incredibly helpful, so I only have the actual opposite as comparison. For ruby error message I go like this: which line is it? Okay, look at the Line and maybe the error type (ArgumentError in this case) - I don't actually read the error message - I read source and understand the bug from there without reading the error. This is only true for Ruby, though. Anyways, I don't mind better error messages, really. What makes me wonder: why did it take so long to achieve this? ;-)
I want it to be card number, card name, and finally the link in the name. In the second link, I found it easier to view source on the wiki page, then rip and parse that. I tried that technique on the first, but it didn't show any of the links.
&gt; Sure. That's what I meant by "could be expanded." You're missing my point... This syntax was supposed to be *"a better way to do it"* than [Object#try](http://apidock.com/rails/Object/try) from `ActiveSupport` in Rails. But as far as I can see, the *only* way to "expand" this syntax would result in literally the same solution as `ActiveSupport`.
&gt;You're missing my point... Nope. Got it. Thanks. &gt;But as far as I can see, the only way to "expand" this syntax would result in literally the same solution as ActiveSupport. I don't think it would be literally the same. I think the alternative was exploring the idea of having one method call to `deep_send`, instead of multiple calls to `try`, along with a possible default return value provided by the block. Whether that's better or not is an argument to be had with OP. And I confirmed that I thought you were right that additional arguments could not be sent to each method, as the code stood. It would certainly be possible to have `*methods` represent a collection of collections, each representing one invocation of `Object#send`, but as I said, it would be up to OP to argue about whether that's better than chaining `try`s.
Sure, that's one possibility. Again, I said: &gt;Whether that's better or not is an argument to be had with OP. It would also be fairly trivial to allow each member of `*methods` to be either a simple method name (no arguments) or a collection. That's why I thought it boiled down to: &gt;exploring the idea of having one method call to deep_send, instead of multiple calls to try, along with a possible default return value provided by the block. 
[removed]
a) Ubuntu desktop - closer to 3 or so people. This is a small network. b) I'll check out your blog post, thanks!
I'd love to see a test suite for a project built from the ground up leveraging this tool after every initial implementation. I'm guessing the test suite would be unusable.
Why do you need the block-form? since `deep_send` would return `nil` in that case you can just use `||` `u.deep_send(:profile, :thumbnails, :large) || default_thumbnail` 
How do you find it jumping between four different languages?
Another option would be using your existing scopes, but then composing them into a new scope: scope :within_segment_of_day, -&gt; (period) { case period.to_sym when :day ; within_day when :afternoon ; within_afternoon when :night ; within_night when nil ; none #empty scope, you don't want to restrict else # raise an ArgumentError or something? end } ### Thing.within_segment_of_day(:night) I think that will work, haven't tested it. 
This is a bit smarter than I was expecting, but at the end of the day, if you're smarter than your boss, you should probably become your own boss. You'll either be right or wrong, but either way you won't have to drive each other crazy anymore. You have one less annoying boss, and they have one less difficult employee. 
I wake up around 8:00, help my wife get the kids fed and dressed, then work from my bedroom desk until lunch. Grab lunch, head to a co-working space for a change of pace, then work from there until 5:00 or so. Head home, grab dinner, forget about work until the morning.
I fixed a missing `none` in that example. Also you know how ActiveRelation composing works, right? If you did want to do it "manually", you could do it _much_ cleaner than your example above. Your example above for `perform_search`, but cleaned up in a way that will actually work. def self.perform_search(location, activity, start_time, end_time, time_range) scope = self.join.not_booked.sorted scope = case param[:time_range] when "day" ; scope.within_day when "afternoon" ; scope.within_afternoon when "night" ; scope.within_might else ; scope end return scope end There are a variety of ways to do it. But I'd try to keep it simple. I think your original suggested solution is too complicated. Also depending on `params[:time_range]` could be considered a separation of concerns 'smell', better to depend only on what's passed in as an arg (like make `time_range` a method arg, although yeah you've got too many method args now too, heh)
What is updog? 
What does henway mean? 
You can put your script into initializer. Example: https://gist.github.com/SergeiStruk/084fa44482c0a2f27727. I use em-websocket gem. 
Oh that makes sense. 
Yep, I would tend to agree. 
Not much, what's up with you?
I would search for hrefs
I hear that a lot actually. Many Enterprise customers have told me they purchased expressly to remove their Sidetiq dependency since it doesn't appear to be maintained anymore. Happy to upgrade you if you don't want to roll your own. More info: https://github.com/mperham/sidekiq/wiki/Ent-Periodic-Jobs
I do, but would you add the href search to 'table.multicol table'
Only if you only care about hrefs. But we want multiple items of information per pokemon, so the next thing I would do is take my table, split it into rows, and discard the extra rows (at the top and bottom) that aren't pokemon.
When I do n.css('table.multicol table').text.strip I get the table with alot of /n for new line. 
You're getting way ahead of yourself. Keep everything in Nokogiri objects until the very end. rows = red_table.css 'tr' pokemon = rows.select{ |r| r.at '@href' } Now we have all the rows with at least one href, discarding the top and bottom we didn't want.
Is there an easy why to get the css selectors, right now I'm right clicking and picking inspect element. 
never mind, I was just being stupid.
If you do not need a record, the data can be extracted with pluck. Item.pluck("sum(elements)") works like a charm and it saves you the need to build accessors or waste memory on a record you do not need. Same goes for using joins and eager load. If you need the data only, because your JavaScript will format it, you can simply do Item.joins(:categories).pluck("items.name", "categories.name") to fetch the data and you will save a ton of memory and processing time
&gt; For ruby error message I go like this: which line is it? Okay, look at the Line and maybe the error type (ArgumentError in this case) - I don't actually read the error message . . . You made me realize that I don't do it too much either. Now I wonder if it's _because_ Ruby's error messages tend to the obscure with "tVALUE", etc. Especially compared to Python and others.
Thanks!
You don't *need* the block, it is just a matter of personal style. I modeled this after the Hash#fetch method.
Well if you're reading everything into one large hash there's no way unless you create a new hash without the recently read values but you'll need some mechanism for keeping track of the hash reads. There's no baked in way too do this in Ruby that in aware of. I think java might have some stuff which you could use of you're using jruby. Would be a fun project though.
An LRU cache would generally be used in a case where you have limited memory or where your program is long-running and the cache would just keep growing if you didn't keep it to a fixed number of slots. It is more expensive since you have to maintain a timestamp on each entry as well as a data structure that lets you efficiently locate and delete the least recently used entry every time you insert a new one. Depending on your application it may not be worth the effort. A simple Ruby hash may be sufficient.
You point makes sense. But what if this is a file that will be used by a server. Suppose, Elasticsearch during startup loads that hash for accessing some constants?
[removed]
True, as long as your hash is ordered and a delete/re-add is not too expensive to do on every read you can do it this way. You are right that you don't need a timestamp per se, just a way of maintaining an ordered list where the least recently used element is always at the tail.
&gt; serf the internet Seems about right.
But even to work with the attr_reader, for instance, since that would be your setter, you still have to set @name. Meaning that if I did it that way `def name(value)` I'd still have to set @name within the method.
[removed]
Surprised there is no mention of [excon](https://github.com/excon/excon). It's substantially better than `net/http`in my experience.
The fundamental difference is that `def name=(name)` allows your method to be called via the attribute setter format. So in the following example: ``` person.name = "John" ``` The `name=` method would be called and passed the value John, since the interpreter automatically closes the gap between the "name" and "=" when passing the name of the method in the message to the `person` object. How is this useful? For one, you might not have an actual writable attribute called "name" but you want users of your object to be able treat your object as though the attribute exists. Alternatively, you might have an object where you had exposed a writable attribute called name, but now you want to implement some additional logic whenever that attribute is set. The method= format allows you to implement this logic without requiring any changes to external code that is treating it as a writeable attribute.
There isn't an LRU cache built into the ruby stdlib, and there's no out of the box way to use a Hash limited to a certain size with LRU semantics. There are several gems that give you several kinds of LRU caches, just google for ruby lru cache. There's no need to use an lru cache just because "certain key-value pairs are accessed frequently." The reason you'd want an LRU cache is if you can't fit _everything_ into memory. If the Hash is being added to at different points, and it might grow really large, and you can't afford to keep it all in memory, and you want to delete the least recently used keys when adding new keys -- that's what an LRU cache is for. If you're creating the hash all at once and then never modifying it again, an LRU cache won't do anything. You may be getting confused with various kinds of CPU cache, that you generally don't have any control over from ruby (or most other languages). I don't think you have any use for an lru cache. 
[removed]
[removed]
Private setter methods permit `self` as a receiver. Other private methods don't.
Main issue that I am facing is about how to integrate lru_redux with the existing hash? I cannot fand any example on how to do that!!!
I think you are missing the point -- does your file fit into your current hash/memory? If so you probably do not need a LRU unless you are running out of memory. regarding how to use it, it is pretty well documented -- what questions do you have? [Here is an example](https://gist.github.com/SamSaffron/5448865) of how to memoize with it for instance. 
It is, however pretty damn slow as it is a naive implementation. https://gist.github.com/nateberkopec/14d6a2fb7fe5da06a1f6
It is not taboo, EM and general evented processing just never got popular on Ruby due to the fact that you had to have a completely different gem ecosystem to support it. Therefore there are not many people who use it and not many examples. Celluloid does not have the same gem ecosystem issues but is not that widely used as far as I know so again, info and examples are lacking. 
He is not looking for sidekiqs though.
Welcome to dependency and deployment hell.
but `def name(value)` would not allow you to use `object.name` that was created with attr_reader. You've overridden the name property with a method that takes a value. You could write it as something like `def name(value=nil) @name = value || @name end` and then would be able to do `object.name` and `object.name new_value` but that's not near as clean and apparent a syntax as `name=`
But why?
Sidekiq Pro 3.0.0.pre1 is also now available, works with Sidekiq 4.
You're right until you say &gt; both respond (I think) to the following for setting purposes: `instance.name = name` No. You need to define a method as `def name=(arg)` to be able to call it as `instance.name = name`. That's it, that's all there is to it. Both are just methods, yes. I'm not sure what you mean by "I haven't figured out how to test it yet." There's nothing to figure out, it's just ruby code. Write the code, use the code. There are "two options" because it's programming, there are always many ways to implement things. Look, there's even more than two options, we could even name the method: def this_is_a_method_that_sets_name!(arg) @name = arg end Then you'd call it as `instance.this_is_a_method_that_sets_name!("some value")`. You could do that, it works fine. It would be silly. There are as many options as you want, you're writing the code. 
[removed]
No, it's not incredibly slow. I will say though that image processing does not scale very well unless you have really fast drives. 25 threads will often process slower than 5 threads because the system's IO is overwhelmed.
[removed]
[removed]
What I was referring to, doesn't the GIL lock sidekiq when doing image conversion (or w/e) in the sidekiq job (When using MRI) inside ruby (So without calling ImageMagicks `convert` tool) ?
&gt; As things stand, the only way of managing multiple, simultaneous requests using Ruby on Rails is by using multiple instances, which eat up additional memory. This is wrong. &gt; Sticking with the web application example, NodeJS is  unlike Ruby  capable of managing multiple concurrent requests, taking advantage of the fact that it has been implemented using the pattern reactor and its calls are entirely unblocked. Both Node and Ruby are bound to a single CPU core. IO in Ruby is also non-blocking. Evented 'reactors' also exist in Ruby. &gt; Ruby, accompanied by a web framework, is perfect for prototyping, as working models can be built extremely quickly. Unfortunately, it suffers from scalability problems. This strangely keeps being stated, but examples are rarely given. 
 GIL does have this issue in MRI, however this is not different in sidekiq 4 vs 3 as both were threaded -- the sidekiq 3 version just used Celluloid as a convenience layer on top of ruby threads and 4 with some other changes removed that layer to optimize its hot paths. I would expect that most folks would be using this with Jruby in high thruput environments. 
Hard to say. Depends on the gem, what you are doing, etc. I typically recommend people use `mini_magick` as it requires no native code, scales operations across all cores (because it uses subprocesses), etc.
I think the only people who will actually have stories of ruby causing 'scalability problems' are truly massively used applications far beyond the scale most of us will work on. And even there -- both Heroku and GitHub use significant ruby (in _Rails_ even), at enormous scale, quite successfully. I do wish MRI didn't have a GIL, though. 
This is a link to a link to an article. [Actual article link](https://semaphoreci.com/community/tutorials/how-to-deploy-a-ruby-on-rails-application-to-elastic-beanstalk-with-semaphore)
&gt; Most people don't realize how much of a performance penalty you pay for the fine grained locking needed to not have a GIL. You mean if you make all the stdlib classes threadsafe, the synchronization locking you need to do that? Yeah, so don't do that. Leave them as they are. If you need thread-safe classes, there can be separate thread-safe versions available, with the synchronized locking performance penalty. This is largely what Java does, isn't it? I certainly agree that avoiding shared state is the way to write multi-threaded concurrency sanely though. That's largely what you try to do in Java, too, right? That's what you do in any language. Baked-in stdlib patterns and classes for doing so would certainly be great. But I don't think they are a pre-requisite for getting rid of the GIL, anymore than they are in Java, or C, or even Perl. 
[removed]
Scalability in Ruby can become a concern if you are reliant on other web services for data. I've found that even the slightest extra latency on a Net::Http request can be very damaging to the overall application health.
Heroku, GitHub, GitLab, Shopify, Basecamp of course, and more. Plenty of large sites use Rails. It wouldn't be super popular if nobody used it and it if it sucked. I don't get why anyone thinks that.
I bet 1 in every 100 devs actually have a project for which Ruby won't be able to scale to the point to which they'd need. At the end of the day most of us make CRUD apps :)
That's not a problem with Ruby, that's a problem with how you're using Ruby. Two simple solutions to the issue you describe are to use a threaded server model, e.g. puma, or use an evented processing model with celluloid, eventmachine, etc. 
We've tried several common solutions with little luck. We're using puma but it actually didn't change what we're seeing as far being able to easily saturate the workers because the http requests were still a bottleneck. We've tried JRuby as well but actually experienced a performance degradation in some cases. All I'm really saying is that the mechanism for scaling and gaining throughput is expensive in Ruby and not always easy to reason about because of the nature of the language.
Exhausting a thread pool due to a slow external service is a problem in any language, I've seen it happen just as frequently in Java as Ruby. 
Thats a great reason. Cheers.
[removed]
Hey thanks Tyler! You're the king!
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
Promises also help a lot with cb hell. If you can't do promises for some reason, the async library mitigates callback hell quite a lot as well. 
[removed]
[removed]
Personally, I prefer to Lord the internet.
Then your problem may be a Rails or Rack issue, but it definitely is not an issue of the language.
[removed]
Just to expand on the reason to use `:order` over `:sort` in case anyone isn't sure of the different: For anything that is coming out of ActiveRecord, you can use `:order` to have the database optimize the results before returning them. This lets you take advantage of your table indexes, for example. Otherwise you're performing a `:sort` after the fact and losing those optimizations.
Thank you!!
[**@awscloud**](https://twitter.com/awscloud): &gt;[2015-10-29 18:15:13 UTC](https://twitter.com/awscloud/status/659795641204260864) &gt;We want to hear from you \- what language do you think AWS Lambda should support next [#Golang](https://twitter.com/search?q=%23Golang) or [#Ruby](https://twitter.com/search?q=%23Ruby)? ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3qu4kq%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
[removed]
[removed]
[removed]
If I'm executing something a millions of times over I don't want to write it in a slow hipster language of the week. I want something fast, known, stable, and proven. How about C? Yes C. To quote gnu.org 'When you want to use a language that gets compiled and runs at high speed, the best language to use is C.' An SDK would be nice too. It doesn't have to be fancy, just as long as it's functional. EDIT: Downvotes because I don't want to waste CPU and memory that I have to pay for? Hipsters can't understand C.
I don't think this is very useful. Wouldn't it make the app seem faster if the first page load takes slightly longer and then you don't have to download any CSS again? The asset pipeline concatenates everything and appends the hash to the filename, so you can just set the cache to never expire and then the file only ever needs to be downloaded once.
Not to mention that was back in Ruby 1.8.6 days...
Since CSS is render blocking, the idea here is to get the critical css needed to render the initial viewport's worth of layout into the first http response (up to 14k). The second part of the equation is loadCSS (by Filament Group) to async load the full stylesheet since there's no native way to do that (yet). That way the full stylesheet is cached for subsequent views. In theory, you could just getaway with generating critical css for the homepage since the user will have the now-cached stylesheet for subsequent pages and visits. The benefit of generating it for other views is if you think a user could land on your site on a page that's not the homepage, like a user going straight to a contact page from a google result. This critical css technique is one that Google - and many others - recommend to increased performance. Our gzipped homepage, with the critical css in the head, comes out to around 7k, and makes it into that initial response. Additional reading: * https://developers.google.com/speed/pagespeed/service/PrioritizeCriticalCSS * https://css-tricks.com/authoring-critical-fold-css/ * http://www.smashingmagazine.com/2015/08/understanding-critical-css/ This technique may not be as beneficial with http2, but I haven't done enough testing yet to say that 
Do you guys have a repo or something with an example?
Ah! So to recap this aspect of the difference, the `def name=(value)` construction automatically creates a nil value for @name, even if no value is given, whereas the `def name(value) does not? Meaning, the former returns nil with the attr_reader, and the latter I guess would break with the attr_reader?
I think I'm distilling three main reasons for this after studying everyones comments, including yours: 1. the `name=(value)` construction allows for the name to be set via `instance.name = value` and people just like that because it's a nice way to do it. 2. the `name=(value)` construction indicates a setter method, which is nice in code to alert other programs what the method does. 3. the `name=(value)` construction automatically gives a nil value to name when no value is supplied, vs having it be undefined. 4. private setter methods using this construction permit self as a receiver
what is a standup?
What is your favorite part?
Replicate is similar and what we use at GitHub https://github.com/rtomayko/replicate
Can post a larger snippet (gist, pastebin, etc)?
What are you interested in? If you are just talking about automating pentesting and scanning you don't really need specialized language references -- learn the language and apply the pentesting concepts (which are outside of the scope of your implementation language). If you are looking for ruby specific exploit/vectors I don't believe there are books on that topic.
I like Ruby most right now, but if I do too much of one thing I miss the other :P 
No worries, just needed it to be a little more readable. Delete_if has destructive behavior. Check out the docs for more info: http://ruby-doc.org/core-2.2.0/Array.html#method-i-delete_if Try the following: https://gist.github.com/anonymous/42ff3f7f1d42eaf08021 
Just realized I didn't really answer your question. When you are setting symbol_array equal to self, you aren't creating a new copy. You are essentially creating another name for self called symbol_array. The reason map works is because it is returning a brand new array instead of a copy.
I'd say like a full resource like "violent python" with specific examples and libraries/gems in one place. I understand it is possible to google your way looking for different examples and gems as you go through. But it would be much better educational wise, and as a reference, to have them all in 1 book, with best recommendations. For example, what is a great gem/library for carving packets ...etc. You know small things like that in full blown examples save a lot of time and eases the learning curve I believe. edit: typos/formatting.
&gt; In general you throw begin - rescue blocks around a bunch of stuff instead of actually looking at what exceptions could be raised and handling them appropriately. For the most part you could drop all this and the output would be the same to the user, an error message and stack trace dumped to stdout. I would look more closely at the errors than can occur and either handle them gracefully or provide the user with more actionable information. Well, in this case, this was decided based on the needs. Basically what is important is setting the UNKNOWN status in Nagios, because for the user it's just Nagios, they don't know anything about the plug-in and would not fix it anyway. That being said, thank you for your reply, I'll consider it all. 
Yes on 1 and 2. No on 3 and 4. This is not complicated. _it's just a method_. The _only_ thing that makes `def name=(value)` different than any other method is that you can call it as `object.name = value`. (Well, I guess a second thing, it can't define it's own return value. _That's it_). Other than that, it doesn't automatically do anything different than any other method, or permit self as a receiver different than any other method (any private method does). Stop trying to make a theory of it beyond that. It's a just a method, and the way property assignment is implemented in ruby. That's it. There's nothing more to it. I don't understand what it is you are trying to figure out. There's nothing else to figure out. Property assignment `object.property = value` is implemented in ruby as a method `def property=(value_arg)`. That's all there is. 
Then just wrap the entire thing in begin / rescue as you handle all errors in pretty much the same way. This way the next person that looks at this codes doesn't have to try to decipher the somewhat arbitrary selection of what is and is not rescued. EDIT: you may also be able to use the `at_exit` hook for this: http://ruby-doc.org/core-2.2.3/Kernel.html#method-i-at_exit
[removed]
Just to emphasize the `Edit`, avoid doing things like this in views. It will save you a lot of time later on and tends to avoid `n + 1` query issues. Shoot for 0 DB queries triggered in the view. 
[removed]
oh wow.. I wish I had come across this gem before building Polo :)
I doubt there are any existing books on the subject. You might be interested in /r/ruby_infosec 
[removed]
Looks like you have found a good idea for a book or website. I spent some time going through violent python and working the examples in ruby. It was an interesting thing to do.
Oh, I actually wrote [a comment about this](https://www.reddit.com/r/ruby/comments/2q3hng/why_no_to_i_or_to_sym/cn2y7zw) a few months ago! I'll copy it here: --- Quick: what do you expect the following to output? greeting = "aloha" farewell = greeting farewell.upcase! puts "#{greeting}, friend! And, now, #{farewell}." We can definitely agree that the farewell should be "ALOHA" because it was upcased on line 3, but what about the greeting? Intuitively, we might expect that, because `greeting` never got `upcase!` called on it, it should've stayed as "aloha". Let's ask IRB: ALOHA, friend! And, now, ALOHA. Whoops! This (perhaps unexpected) behavior is a result of Ruby's system of **objects** and **references**. I'll go through this program one line at a time, and then draw a quick table that describes the state of the objects and references after the line is executed. ### Line 1 greeting = "aloha" #### Objects Object ID | Value ---|------ 1 | String: "aloha" #### References Variable name | Object ID ----------------|------------ greeting | 1 In Ruby, an assignment operation has two parts: the right hand side (an expression), and the left hand side (the variable name). Line 1 is an assignment operation, so Ruby executes it in two parts: 1. It reads the expression on the right hand side of the assignment: a new String object with the content "aloha". Ruby creates the object, and adds it to the object table as Object #1. 2. It reads the variable name on the left hand side of the assignment: `greeting`. Ruby creates a reference from the name `greeting` to the object on the right hand side (Object #1), and adds it to the reference table. ### Line 2 farewell = greeting #### Objects Object ID | Value ---|------ 1 | String: "aloha" #### References Variable name | Object ID ----------------|------------ greeting | 1 farewell | 1 This is another assignment operation. Ruby executes it as follows: 1. It reads the expression on the right hand side of the assignment: it interprets `greeting` as a reference to Object #1. 2. It reads the variable name on the left hand side of the assignment: `farewell`. Ruby creates a reference from the name `farewell` to the object on the right hand side (Object #1), and adds it to the reference table. Look carefully: there's still only one "aloha" object in the object table. We just have two different *references* to the same object. ### Line 3 farewell.upcase! #### Objects Object ID | Value ---|------ 1 | String: "ALOHA" #### References Variable name | Object ID ----------------|------------ greeting | 1 farewell | 1 The references don't change here. Instead, we read `farewell` as Object #1, and then call the method `upcase!` on Object #1, which *mutates* Object #1: that is, `upcase!` changes the original object rather than creating a new one. Note that, because `greeting` are `farewell` are both references to Object #1, printing *either one* would yield "ALOHA". The lowercase string "aloha" no longer exists in memory. ### Line 4 puts "#{greeting}, friend! And, now, #{farewell}." And we print "ALOHA, friend! And, now, ALOHA.". The objects and references don't change. --- I hope this helps explain what mutator methods actually *do* :) When in doubt, I recommend non-mutating methods over mutating methods, because it's easy to make mistakes like this. For example, prefer `upcase` (which *copies* the string and returns a reference to an upcased copy) over `upcase!` (which *mutates* the object you called it on), unless you have an excellent reason. (Mutation *is* faster than copying, but the difference is small enough that it's almost never going to be the bottleneck in your application. Once you've benchmarked your application, and discovered that copying is *the* problem, that's when you should switch techniques.) As an exercise, consider why the following code snippet *doesn't* upcase the greeting. (If you're not sure why this code behaves differently, try drawing object and reference tables.) greeting = "aloha" farewell = greeting farewell = farewell.upcase # This is the only changed line. puts "#{greeting}, friend! And, now, #{farewell}." One final note: `!` doesn't *always* mean mutation. It just means "dangerous", and mutation *is* dangerous, so that's usually how you'll see it used. Check the docs on each `!` method you encounter in order to confirm what it *actually* does.
I think what you have to say most directly answers the question. It'd be important in this case for OP to look at the [documentation for the delete_if method](http://ruby-doc.org/core-2.2.0/Array.html#method-i-delete_if), specifically: Deletes every element of self for which block evaluates to true. And of course it's important to note the assignment of symbol_array to self creates a reference to the self object which, like you said, has no immutability constraints.
Thanks for sharing!^ I followed along and my local machine runs like a dream :) 
It essentially boils down to [these two lines in `parse.y`](https://github.com/ruby/ruby/blob/9d64a542094efdbcf8fc8b192750d6b0343665c3/parse.y#L915-L916) which specify the precedence of these tokens quite explicitly; the magic is in another castle.
You guys are super amazing! Thank you so much!
So basically, if I run 'rails generate migration [NAME OF DATABASE] [NAME OF NEW INDEX]:string:index,' I will then create a new column in this [NAME OF DATABASE] database? But how do I make this column draw information from other columns that are already in the database? Is there an ID that will help me combine information from the two other columns that I wish to combine? I'm recreating Stack Overflow (It's called Snack Overflow) and I want to order questions based on last_updated and also provide title of question and emails of the user. I'm following the Rails Guides as best as I can but I'm such a newbie!
[removed]
[removed]
[removed]
http://ironruby.net/tools/ Both Visual Studio and Iron Ruby are free.
Your argument is *theoretically* correct. But complexity analysis is all about approximation and Computer Scientists know when to neglect factors that would be inconsequential in the real world. Let's assume your counter is a 64-bit integer, a pretty standard data type on any modern computer. You could index an array of size 9 quintillion, or 9 billion billion. Assuming it only took one CPU cycle to traverse each array element, a 3GHz computer would take almost a hundred years to traverse an array that was too big for a 64-bit counter. So, yes, the required counter size does grow with the size of the input, but it grows so slowly as to be negligible. No serious computer scientist would ever call list traversal an O(log(n)) algorithm. Doing so would needlessly obscure the difference between real O(log(n)) and O(1) algorithms, a difference that could be critical in the real world.
Let me rephrase: we don't want to use background workers or web sockets because it adds to the overall complexity. The behavior I'm talking about is a web service going from a one or two second response to a three or four second response. The problem is that the worker is blocked for the length of the request so those one or two seconds are critical. I understand this is an issue in any kind of thread pooling situation but the cost of extra "threads" in Ruby's case is comparatively expensive considering you have to fork the process. I'm not trying to get into an architecture discussion. I know there are plenty of ways to handle a slow web service response in an application. My only point is that cost of scaling in Ruby can be expensive in comparison to other languages. The notion that only Twitter has run into scaling issues in Ruby is completely bogus. There are a good number of posts where companies have converted a Ruby service into Go, Java or something similar and been able to scale back on the number of servers they are using. Ruby, like all languages, has its pro and cons and I just wanted to point out that, while Ruby can scale, the cost of scaling can be quite expensive. If you're writing a CRUD app that just has to talk to a database, you may never run into these issues, but if you're depending on other services for some of your data, you very well might.
So the usual question: how do you plan to differentiate yourself from Ruby Weekly?
I'm currently using Ruby to power the entire CI system we have at my company as well as writing various system level tools in it ( think image generation for ARM boards )
&gt; My point was that the scaling mechanism in the Ruby application server world is forking the process. No, it's _one_ scaling mechanism, both puma and thin also support threaded calls to the rack app. You say your using puma and you didn't know it can use threads to call your app? 
We are building Docker orchestration platform using Ruby: http://www.kontena.io/
&gt; Threads still operate in the context of the GIL. Only one thread is active at any given moment. IO yields the GIL. Your call to `Net::HTTP` in a thread yields the GIL and all other threads can execute while it's waiting for the request to complete. The thread waiting on IO can processes on other cores as well.
I've used Metasploit before, never knew it was in Ruby.
I use it in jewelry for my wife. She thinks it is pretty!
Then your problem is somewhere else, this usage scenario is one of the primary reasons puma was created.
The test setup was a Rails application with a single endpoint that hit a web service then returned a 200. The web service was another application that's only job was to sleep for a configurable number of seconds and then return a 200. Explain to me how the problem is somewhere else in that scenario.
I use Ruby for systems programming and robotics! 
Ruby for Robotics? I'm interested.
Start with pi-piper! As a systems language, you can easily use it to adjust PWMs, GPIOs and more on units like the Pi.
As I understand it, the `&lt;&lt;&lt;&lt;` should shovel two spaces into the String in `$s`, and calling the `foo` method should display `"foo "`, but that's not at all what's happening. Please advise.
Package your thing as a gem and your users will be able to say `gem unpack foo; cd foo; bundle console` and arrive in an environment very much like the one you've described.
Did you consider using a virtual machine instead? Why waste money on hardware you already have. I can understand that a full dual boot install may seem daunting (and on some machines in fact be a big pain) but a VM should be easy enough. Are you doing any GUI programming? If you mainly do web stuff with Rails you would only need the command line features of the Linux install. You could even get away installing Ubuntu Server and not worry about any desktop environment. (Though chances are that even in a VM it would still be fast enough) How much memory has your current machine? What type of processor? VMs would need a bit more power (though for programming even this would possibly not matter much)
You could run ubuntu in a VM on your windows 10 machine.
&gt; I then tried getting Vagrant, just as reddit has recommended. When I run the .exe for it, it opens up a window and closes it immediately. Vagrant is a command line tool for managing VMs, I don't know what the 'exe' does in windows but you should read the Vagrant docs. The general gist is you create a config file named `Vagrantfile` for your project which defines how the VM(s) are built and which provider to use (e.g. virtualbox) then `vagrant up` from a terminal in the same directory as the `Vagrantfile` starts up the VM(s) as defined. &gt; I have tried VirtualBox, and it has bugs when being run on W10 apparently. It gives errors when I try to start up my virtual machine. What errors and what VM are you trying to start?
Sorry, didn't use VB on W10 (I mostly work on Linux with kvm/qemu/lxc). Short search showed that some people had trouble with various errors in W10, though mostly things that could be resolved. Make sure you have the latest version. Maybe google the error message (if you didn't already). I can't imagine that for such a widely used tool like VB a new OS version of Windows could be a total deal breaker. 
Here ya go: $s = 'foo' &lt;&lt; &lt;&lt;' ' # &lt;&lt;' ' is actually starting a heredoc with a delimiter of a single space def foo p $s end # heredoc ends as there is a hidden space character in the snippet on this line. foo # throws error as the definition of foo is inside the heredoc # $s is "foo\ndef foo\n p $s\nend\n"
Well, it looks like you got the treat. [Here's some candy](http://i.imgur.com/94jou4v.png), and [the trick](https://eval.in/460798) if you're feeling up to it. Happy Halloween.
[removed]
Just starting a project for running async jobs in docker cluster managers like kubernetes in Ruby.
Thanks for the code and benchmark. I'm going to have to go dig up the test setup and see how we had everything configured. It's been a while so I might be conflating the application benchmark results and the sleep test (like what you have above). Time to go see if I was maligning Ruby unfairly.
[removed]
I've used it to make twitter, reddit, and tinder bots before
I freelanced for a year off of an Acer C720 running Xubuntu. Pros: * All of the pros of Linux * Long battery life Cons: * Somewhat small screen (11.6" matte) * 16-32Gb of internal storage * 2-4Gb of RAM * Developer boot options I think the pros out-weigh the cons for many use-cases, though it's not for everyone. I got mine brand-new on Amazon for $200 and had it fully converted to Linux in about an hour. I ran my freelance gig off of it from September of 2014 until October of 2015 (when I finally got a rMBP). At the very least, its an option, and one that I wouldn't discount too heavily. That being said, I love my Mac. 
I've used Ruby for scripts that parse CSVs and connect to REST APIs that run through cron. smarter_csv makes CSV reading absolutely painless.
Hint request: I've sorted out the replacement cypher and the entertaining method calling strategy so I have a handle on what the codes does, is there something beyond the 'stack game' that I'm not seeing?
I would not shell out extra money *just* to get a decent OS. You said you tried Virtualbox, did you try VMware?
Looks like someone's gonna get sued by Pied Piper...
[removed]
We used it for web services. It worked well. 
Well, your interpretation of its mechanism as a "stack game" is a little disconcerting, but that you've presumably determined how it is I'm able to invoke arbitrary methods means you're a good way along. Incidentally, I only needed the encoding for my pseudo-`#send`; the rest is just semantics abuse and a really gnarly workaround for the limitation that my `#send` can't be used to emulate `#define_method `. Please do keep me apprised of your progress; I'd love to see you get there, and will happily assist in the trickier spots.
[removed]
I can't believe no one has mentioned [Homebrew](http://brew.sh) yet.
RPG Maker scripts
I use Ruby for most of my DevOps scripting needs, over Python and Bash. I use the latter only for simple things, and only rarely, often when Ruby wouldn't be an option (e.g. legacy systems that don't have it preinstalled). The most recent things I did with Ruby were a set of scripts to automate creating snapshots of Elasticsearch clusters and restoring them to another cluster, and a script to delete files older than a specified number of days from a Hadoop file system.
[removed]
Yes it's possible to learn and change careers. Give yourself a year at least. Yes it's possible to get work overseas. And remote working is possible too, though more likely at the higher experience levels, which you probably won't hit within 3 years. You should probably check out /r/learnprogramming and /r/cscareerquestions . 
Alas, that's about the size of it; it's just a dead-simple to-do app. The only slightly interesting bit is that it's all done in one route: no parameter means render the entries; a numeric one (according to `#to_i`) deletes the entry at that (1-based) index; and any other gets appended. e.delete_at(p.to_i) || e = [false] + e + [p]
http://imgur.com/76vvRRZ
I use Ruby for everything that anyone would have used Perl for 15 years ago: command line applications, text processing, scripting and automation, data munging, etc.. I've always considered Rails somewhat of a double-edged sword: while it's single-handedly responsible for Ruby's popularity, it's also managed to create a near-universal view of Ruby as a language that's only, or at least ideally, suited to web work. In reality, Ruby is the nicest general purpose programming language ever written and should be used for lots more than just web development.
This is a nice example, however, it would make much more sense to extend it to show how to grab data from the database instead of showing the practice of data stuffing in resque/redis. Stuffing data in the queue is usually pretty bad form as it easily gets out of sync because resque is acting async. I consider the general best practice to be only insert enough data in the job for the worker to be able to grab the data it needs to act on from the trusted source.
That's really cool.
&gt; /r/cscareerquestions Meh...I'd skip that one honestly. The sub has basically devolved into a focus almost entirely on getting hired for a top salary at one of the "Big 4" companies. The members are out of touch with reality. 
Yes I have been doing the remote thing for a while. I lead a team completely remotely, and my engineers are scattered throughout the globe. Some just move around from place to place every few months. It's perfectly possible, but you do need a lot of self motivation, self sufficiency, and of course a company who is used to working remotely. It can be a real challenge if the culture at the company is somewhat resistant to the idea, but in my experience it is *really* easy if everyone is on the same page. At the very least, you need everyone who works in tech at the company to do all of their communication online and in a way that is visible to all concerned parties. We've used IRC and other mediums, there is no wrong answer. One thing I am not down with is a big emphasis on telepresence. You don't need to see me for me to do my job, and the company I work for knows this. Video conferencing eats tons of bandwidth, and it's almost never necessary (though screen sharing often is). Voice is usually plenty, if it's even necessary in the first place (I try to keep as much to text as possible). My profile on dice.com (which I recommend using) states very clearly that I'm not interested in anything that's not 100% remote and recruiters have gotten pretty good about only bombarding me with remote opportunities.
This looks awesome! I've actually got a Raspberry Pi robot that currently runs on Python, but I'll have to check this out.
i use ruby for devops/infosec rarely used for webdev, i actually love the language and hate rails. most of my hacking tools i wrote on ruby actually check https://www.reddit.com/r/ruby_infosec/
Thanks for the response. How did you start out? Do you have any suggestions for becoming an international employee? Is Dice.com the sole source of jobs? 
Yeah, it's been picked up for a while now. Shoes 4 is all built on jruby. It uses some swing components. It all works pretty nice.
It isn't impossible, but remember that Facebook, Google, Amazon and Apple can pretty much hire whoever they like. [Most likely,](https://www.quora.com/Which-of-the-big-four-Google-Microsoft-Amazon-Facebook-tech-companies-have-the-most-selective-hiring-process-for-software-engineers) that won't be you.
&gt; Do you have suggestions on how to become higher experienced in 3 years? Code as much as you can and work on opensource libraries. 3 years can be spent in many ways. One can put 20 hours a week into programming or one can put 80. The later will probably be a lot more marketable. 
[removed]
For fun https://www.youtube.com/watch?v=XD-KrtYOKzo
My chat bot framework, [Lita](https://www.lita.io/) is written in Ruby. I (and others) use it for various tasks, generally in the realm of system operations.
I went down this route half a year back and honestly I could not find any truly budget laptops that were linux certified or came with linux pre-installed. I think the closest I came to at the time was about $750 USD. If you are willing to go with a USED or re-furbished thinkpad, you may have better luck on ebay. As for myself, I rolled the dice, bought a $350 laptop, tried to install a few distro's on it and found one that mostly worked. I have been able to get by on it but never truly felt comfortable on it, mostly because the trackpad is ultra sensitive and not very usable. I've spent hours and hours trying to configure it manually with no success. So I use a mouse and it works fine. Probably I will install windows back on it and go the vm route later. Have a look at this guide: http://drzel.github.io/blog/2015/10/30/open-source-ruby-on-rails-development-environment-for-lubuntu-15.10-as-a-guest-in-virtualbox-5.0.8-with-vim-tmux-and-powerline.html And again, I think it's important you feel comfortable and at home with whatever laptop you go with. Most budget laptops in general won't provide this so I suggest you go into a store and try them out in person.
[removed]
Thanks for this! I love this kind of stuff, but often don't have time(like now) to clone everything down and run everything manually. It would be awesome to see some inspect or p output in comments in each file. If you can manage that, all the folks out here in a constant hurry would appreciate it quite a bit! :D
[removed]
Hey! It was the first pull request: https://github.com/franzejr/ruby-tricks/pull/1, I also will try to add a sort of explanation about each trick. Thanks!
I agree, especially since you don't generally have to *use* `$_`  it's more about knowing that it exists and where Ruby itself uses it. The article still makes sense if you mentally run it through `gsub("$_", "$LAST_READ_LINE")` ;-P
I wrote starting_blocks (https://rubygems.org/gems/starting_blocks) for running minitest tests. My reason: I just want to run the tests without adding guard files or rake scripts. Every project's test setup is different, yet our test file conventions are the same... so why not have a test runner based on those conventions? First step: gem install starting_blocks Second step: sb It will look for any test_*.rb, *_test.rb, *_spec.rb, etc. test conventions. It will find all of the files in your current directory or child directories, and then run them in one shot. If you type: sb watch It will start a file watcher. So if you save a test file, or if you save a file that's named the same as a test file (i.e. saving product.rb will fire the tests for product_spec.rb), it will run the tests. Hit "Enter" to run all the tests. Oh, but there's more! "gem install starting_blocks-growl" will give you growl notifications by typing "sb growl" or "sb growl watch". "gem install starting_blocks-blinky" will turn a USB light from red-green-yellow based on your test results. "starting_blocks-stopplicht" hooks to a node project that puts a red-green-yellow light in your OSX notification bar. And just for fun, "starting_blocks-rspec" allows the gem to be used with RSpec. Does not depend on guard config files, nor Rake scripts... it just looks for tests and runs them. Simple idea. 
I always liked hacking (writing code) as a kid and I went to school for it, but that's by no means necessary. I have an MS in comp sci but it's almost more of a liability than an asset unless you want to work in research (thought I did but turns out I like money too much). If you want to be a web or mobile developer (which is what I would recommend as there is plenty of demand and I think it's pretty fun), the best thing to do is make a github account and start checking in your code there. Even if you think a project is trivial, software engineers spend a large proportion of our time using source control systems like git and it's also a great way to start a portfolio that you can show to potential employers. Dice is a great place to get yourself out there. Much better for tech jobs than linkedin or whatever else. Only caveat is I will say I have never found a job on Dice by searching, I have always been sought out by recruiters who found my profile there. Online courses and codecademy and all that are great, but if you're serious about a career in programming you need to just find an itch you want to scratch and write the code to scratch it. It's not necessary to have personal projects, but if you're self taught I think it's a really good idea to just start hacking away at your own projects. You will learn more quickly and the lessons you learn will stick better because you will *care* about the software you are writing. 
Don't use magic methods that will be deprecated when the next generation of "core developers" come in.
Cool. I'll give sb a try. It does seem excessive to need guard, guard-mini-test and then likely an additional gem or two for notifications/presentation. Stopplicht looks exactly what I want in terms of final presentation.
Raspberry Pi
As others have said you can work remotely. I'm a rails dev and I worked remotely from Turkey for 2 months this summer. You have to learn enough to become hireable, then you'll have to learn how to manage yourself and self discipline. After that the big challenges are lodging and visas. You can 'visit' countries on a visitor visa, which I think is good for ~3 months, but then you have to find another solution for staying. I think the official rule is that you can stay in the EU for 6 months each year. I read some people have figured out ways around this by entering and exiting the EU via certain countries. Finding short term, furnished places can be tough as well. If others have solutions to the lodging/visa issue I'd be interested in hearing about it. 
THB the cheapest laptop you can find will work. Also 15'' and constantly carried? That doesn't sound fun :p
I just map `&lt;F5&gt;` to `:w ; tmux send -t1 !! c-j`. Vim + tmux ftw.
`pry` is good, but `irb` ships with ruby, making it very valuable for adding readline interactivity to scripts that want to run on any old system with ruby installed.
its when people tell each other what they're working at the beginning of the day or something like that. I don't terribly miss it, though.
That is why I said usually, and it is very much usually bad form to stuff data from the trusted and managed (truth) source into a transient job. It is so usual in fact that I am making the case that a general guide should show the normal happy path instead of the unusual path of inserting the data and dealing with it in an async silo. For a mental exercise, quickly think of 5 different background jobs and their associated data (without trying to come up with specifically constructed counter-proof examples); which of these falls into the data-stuff-in-job is good camp? If you are doing this without enforcing counter proof I would wager at least 4 if not 5 of your tasks fall into "don't stuff" land.
I don't need any thought experiments, I have real jobs that would simply not be correct if your guideline was followed. The reality is that the data in the DB can change _after_ the job is enqueued. Whether you should pickup the 'latest' data at the time of job execution or you should use the data as it existed at the time the job was queued is entirely up to the use case. 
The fact that data changes out from under your stashed copy is the problem that almost all times you need to deal with. What use cases do you have where those jobs are constructed to act in a happy path split brained from the underlying (truth) data? In my experience those types of jobs are very far between and few, although seeing jobs implemented that way with silent corruption/errors and randomized output because of that split brain race condition is NOT uncommon. Edited to add: This is such a pervasive design issue that I will say, when I see a stash in a job queue that has more data split brained than just the minimal set of reference back to the truth data source I assume that this is a race condition until the use case is proven out and that is correct 99% of the time. Edited to add: Further, you say you have "jobs" (multiple) that are constructed this way, if you are not talking somewhere around 2 jobs out of 100+ (implying that these jobs were extremely rare and specifically designed) I would feel very comfortable saying at least one of those 2 jobs has an undocumented race condition bug. 
go is compiled you muppet
I for one would find this a great shame, but I'm far more positive about Ruby's Perl heritage than a lot of people are!
It is complicated and requires design and thought around critical section identification but this is how it is done. Each ACID database has toolkits to enforce this type of work performantly when applied to a sane design. I mean this is not new ground in CS, in effect jobs can be thought of as threads and just like in threads you either pass messages (if you can, and again his is the rare case) or if you need to share data you do so via one of the many methods to enforce safety (which happens to be centered around the truth store/db here). Again, unless you are talking about very rare circumstances, if you are passing a stash of data to a job via the queue to act on without performing this type of work against the actual database you are inherently exposing race conditions. If you would simply share one of these mythical multiple cases you have I would probably be able to show you in short order where your race vector exists. For the cases that do exist where you really dont have risk around the stash race, you need to be able to make true statments around a whole lot of assumptions such as: * I do not care that this job runs given any or all of the data or assumptions that created this job and that exist in this job could change given any or all of the data in the stash that the job is acting on is invalid at the time of execution. * There is no penalty or side effect to run this job 1 or more times. * There is no penalty or side effect to run this job one or more times with different or modified data. * There is no penalty to never run this job. * There is no need, whatsoever to track this jobs output or outcome or status in the app's database. * The application basis no logic or state on the outcome of this job. * No third party integration have side effects or changes based on this job. .... That list goes on for a long time -- you are left with a very limited set of jobs that can run via stashed split brain data. 
&gt; you are left with a very limited set of jobs that can run via stashed split brain data. Unfortunately most of the non CRUD app examples live in this realm which is where I live. Running two-phase commit on a system operating at 10k req/s isn't terribly viable. 
YOU ARE AWESOME
Just use pry, your rationale for not using it makes 0 sense.
That's fun.
What about explaining how to parse an arbitrary context-free grammar? You could not use the knowledge contained in this article to write your own programming language. 
Then the expression `[1,2,3,]` should really make you squirm.
I assume, you have a shebang in your script. Could you take a look what is it?
Fuck that guy.
As a community of adults, we should all (not just for ruby) be able to have a civil discourse about what a CoC should and should not contain. We should also be able to accept that sometimes we are wrong or our opinion is not the popular one. This isn't a black-or-white issue where you either have a "you can't say anything unpopular" code or none at all.
One of the funny things is that canvas has a pretty nice json api and a nice gem Pandarus to access but everyone seems to use python or raw curl commands.
it is trying to communicate that gender discrimination and other SJW fuelled discriminatory behaviour is hurting communities.
It reads like a Tumblr ragepost is all. 
Sure, gems don't do anything magic, you can duplicate everything they're doing yourself. In fact, I think `bundle console` will work on any project with a `Gemfile`, not just a gem? In which case you could provide a rake script to create an (empty, I guess, or whatever) Gemfile. Although it looks like literally all `bundle console` is doing is `IRB.start` (or your alternate console of choice from bundler settings). https://github.com/bundler/bundler/blob/20f04aa8923c0d0f02e7a74d5e9609d772351668/lib/bundler/cli/console.rb Bundler also makes sure to load all your gems of course. Not an issue for you if you are using zero gem dependencies. If you are using gem dependencies, bundler is highly recommended. If you're doing it yourself, you'll just want to make sure `./lib` (or any other local directories that should be) are in your `$LOAD_PATH`. That's about it. 
Each province only has 1 tax, province wouldn't need a model
The article specifically mentions a custom CDN header: &gt; Here s-maxage stands for Surrogate cache, which is used to cache internally by Fastly. I don't see what the problem is for sensible defaults _and_ custom configuration.
this: http://diyhpl.us/~bryan/papers2/security/Metsploit%20Unleashed.pdf ? it seems to refer to the course on metasploit
Could also be done inline with a Struct: Province = Struct.new(:name, :rate, :tax) Or, as I would suggest, create a yaml file of objects, e.g. # provinces.yml - name: Alberta rate: 5.0 tax: gst - name: British Columbia rate: 5.0 tax: gst .... and then load that and iterate over it to create the Tax instances. 
What is the overall goal? What are you trying to do? This doesn't look like it should be one method.
Because sadly its connected :( 
The Model is Tax and I'm just trying to create tax records for each province. 1 record would look like: [1] pry(main)&gt; Tax.first Tax Load (0.7ms) SELECT "taxes".* FROM "taxes" ORDER BY "taxes"."id" ASC LIMIT 1 #&lt;Tax:0x00000006a111d8&gt; { :id =&gt; 1, :country =&gt; "Canada", :state =&gt; "Alberta", :name =&gt; "gst", :rate =&gt; 0.05, :created_at =&gt; Fri, 23 Oct 2015 21:32:52 UTC +00:00, :updated_at =&gt; Fri, 23 Oct 2015 21:32:52 UTC +00:00 } The country is set by default in the Tax class, I mostly just don't like the fact that I have 3 arrays and a Constant to generate this class seed data. 
[removed]
Maybe like this? def tax_rates tax_types = { hst: 0, qst: 1, gst: 2 } provinces = [ ["Alberta", 5.0, :gst], ["British Columbia", 12.0, :gst], ["Manitoba", 13.0, :gst], ["New Brunswick", 13.0, :hst], ["Newfoundland and Labrador", 13.0, :hst], ["Northwest Territories", 5.0, :gst], ["Nova Scotia", 15.0, :hst], ["Nunavut", 5.0, :gst], ["Ontario", 13.0, :hst], ["Prince Edward Island", 14.0, :hst], ["Quebec", 14.975, :qst], ["Saskatchewan", 10.0, :gst], ["Yukon", 5.0, :gst] ] provinces.each do |(province, rate, type)| Tax.create!(state: province, rate: rate / 100, name: tax_types[type]) end end
&gt;The country is set by default in the Tax class Right, that feels like two models in one, though. This is why I ask what the overall goal is. You could have reasons for conceptualizing the models in that manner, but they are not apparent to me at this time. But if literally all you want input on is the issue of seeding the database, then I would, as others have suggested, create a flat file (yaml, json, csv, whatever), with the necessary records, write one method to load it from the data file into a ruby array of hashes, write another to create each model, and then use both in combination-- load the array; iterate over the array, creating one model each time. Your intuitions are on point here; that data should not be in the method doing the creating. Honestly, though, it's such a small amount of data, you could throw it all in ruby constants. People do that. If you don't plan on adding any more data to the list, it's an option.
I used RubyMine from v5-7. I tried it on each major release. Every time, I found myself going back to Sublime Text since I had little, no need for the added functionality of the IDE.
1. It's succinct. I just reduced a 70 line class definition down to 20 lines. 2. Method definitions are closures. This means you can use values and lambdas defined locally, which can help writing more functional code. Local scope can also be used to enforce privacy, but I don't know if that's useful. 3. Factory methods can more easily pass it around different conditional paths to create different objects.
I'm happy to see that the Ruby community recognizes this for the garbage it is.
Is this a joke or something? Like it seems so crazy that this exists that I assume it's satirical but I'm not sure...
I'd consider loading this data when you initialize your app. This gist shows how to do something like that: https://gist.github.com/jnunemaker/230531
These statements in OpenCoC are so childish and avoiding any debate that its cringe-worthy. 
IDEs have a tonne of tools to help you quickly refactor, find where code is used, track which files you've changed at a glance, etc. but they're only useful if you spend the time learning how to use them. It isn't exactly practical to spend a month learning the intricacies of an IDE, usually, so scroll through the feature list to find what seems most useful and figure out how that works. Leaving tip of the day enabled will occasionally give you the heads up on something neat. In most cases everything an IDE does can be done without it, but the IDE exists to make it easier/faster/'safer' to accomplish the task (in theory). You use the one tool and it has the intelligence to understand your code, to some degree, and so can help you manipulate it at scale when required without unexpected side effects (or at least with fewer syntax ones).
I think you just hit my factory reset.
I love and use mutant myself, but 100% mutant coverage? That strikes me as unnecessarily pedantic. And this is coming from the author of a library that's historically had a 3:1 test-to-code ratio... In practice, surviving mutations will sometimes be *very* hard to eliminate and doing so isn't worth the benefit of a slight improvement in test quality or coverage. There are seriously diminishing returns the closer you get to 100%, and in many cases I feel like you're actually getting negative returns before you get there. I personally think the best thing to do is set up mutation testing and simply fail CI if mutant coverage goes down. Anything more pedantic is probably not a good idea, and once you're over 90%, even that might be too restrictive sometimes. Getting 100% line coverage is much, much easier bar to hit than 100% mutant coverage and you'll find plenty of people who make a strong case that 100% line coverage is silly. It's that much sillier to try to hit 100% mutation coverage.
Ehhh this is just egging them on. Look what it produced. &gt; safety I can't respect that as a motive for the document. If someone really wanted to eat your eyeballs, deleting their internet comments would in no way dissuade them. 
Safety is probably a poorer choice of words, but this is a short, short section in a much longer document. Good communities have guidelines, lets moderators know what they can and can't do and elevates the discourse beyond assholery. I prefer to discuss things on more strongly moderated forums than less. Weeds out the idiots, the riff-raff, and yes, the assholes. This goes double in a targeted community like Github which isn't a place for assholery in the first place. And with all that said, I think I'm going to bow out of discussing this topic on reddit. Assholery is deeply embedded in reddit's seedy underbelly, and I'm sad that it's visited one of the few subreddits that I subscribe to.
Very interesting. Does it support minitest?
Work in progress: https://github.com/mbj/mutant/pull/445
I like it. Very simple to use.
yeah, sublime is like IDE light. Just the plugins you want and none of the bloat.
I believe you want to use .equals() because strings should not be compared using == in Java. Strings are objects and == compares if they are the same object, while .equals() compares the values.
I have been in ruby community for 7 years now. I have saw only one case where presenter had a quite sexist presentation and it was dealt accordingly without any CoCs. Now all I see is how this pretentious attitude of being progressive is hurting the quality of community. I notice that especially in all the conferences. 
I'm not sure what I just watched... What is the difference between `rspec` and `r_spec`? (https://github.com/cyril/r_spec) Is `r_spec` a joke, or a serious tool? Why would(n't) I want to use it?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/titlegore] [When the Answer to Life, the Universe, and Everything is  \[RSpec\]](https://np.reddit.com/r/titlegore/comments/3rcd1g/when_the_answer_to_life_the_universe_and/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
This has nothing to do with rspec. Just don't monkeypatch core methods to always return true.
haha yea i did, it's super useful. I've been writting seed using methods, this is infinitely better
What makes a class complete, then?
Is Markus working on BlockScore?
Good question :) The reason it's "un-complete" I think it's because technically - It's never going to be initialized (just because it is "designed" to work with the solution code). This class is "worthless", or might even not work properly if initialized and used directly. 
Have you run a performance test comparing this to a regular ("non-bang") method chain? There are two things here which will *decrease* performance: Overriding method missing, and possily the object allocation on the following line? next_value = self.value.public_send(method, *args, &amp;block) Have you considered the fact that some methods ending in `!` do not modify the object in-place, whilst other methods *not* ending in `!` *do* modify the object in-line? It's an interesting idea, but I'm not yet convinced it would be much use in production code.
&gt; The module not only initialize instance of other classes, it also run local methods. That's the problem. Why is your `initialize` method doing so much? Sounds like you have a bigger architecture issue to deal with.
Yes, I see what you mean. The initialize acts as consumer of the methods, and that's sounds like a bad idea. No sure why was it written like that. 
Another question, then. If it will never be initialized, then why have an initialize method? The module is fine, and if included, prepended, or extended from a Class, you'll have access to the methods as instance or class methods, respectively. Subclasses are great, but it's really necessary when you have instances.
I see a lot of people complain about RA and AA when they want more CMSey features, and this looks like a step in that direction.
Nope. Markus is the author of mutant. We are just fans of mutant and we contribute to the tool occasionally. I should also clarify that we mainly apply the coverage rule to new code. If something is an entirely new project (like an internal gem) we shoot for 100% mutation coverage. If we are adding to one of our older projects which does not have full mutation coverage we just try to make sure *new* code is well covered. Mutant makes this easy with the `--since` flag. For example, bundle exec mutant -I lib -r foo --since HEAD~1 --use rspec 'Foo*' will only check and enforce mutation coverage for code touched by the most recent changes to `Foo`. Using this we can maintain a high bar for new code without making small changes require months of refactoring.
To be a little more verbose... `tap` is basically a wrapper that always returns `self` a = [1,2,3] a.first =&gt; 1 a.tap(&amp;:first) =&gt; [1,2,3] So, in your example, you'd use a = [1,2,3,4,5] a.tap{|x| x.reject!(&amp;:odd?)}.reverse! =&gt; a == [4,2] Slightly more verbose, yes, but safer and faster than what you have. 
So you're saying your precious little feels are being hurt because you can't ignore the effect of your conduct on another person's feels? Sounds like exactly the reason people have codes of conduct.
Did you actually read the code? This problem has already been recognised and addressed 
...and the semi official mruby
I'm still partial to also checking the owner of a file. If you can ensure uploads are owned by a dedicated user, you can apply a nice layer of paranoia by ensuring that user also owns any downloads.
This looks like a slightly better implementation of the Rails default scaffold generator. That's interesting I guess but I don't see a lot of use for it over ActiveAdmin or RailsAdmin unless you plan to very heavily customize. If you do plan to heavily customize than this seems to only buy you a bit of default CSS and some simple forms which is unlikely to save you much time over the default scaffold generator.
Is there any reason for your base abstract class to be a module, instead of an actual class? In a class that will be subclasses, I see no real reason that initialize would be a problem. In a module -- yeah I'd say it's a mess waiting to happen. Exactly because modules basically implement multiple inheritance. With a bunch of modules each with an initialize -- unless they all make sure to call super (which yours doesn't) they're not actually all going to be called, the order they'll be called depends on the order they were included, and it's generally just a confusing mess. Perhaps you're using a module because it is enforced "abstract". True, but not really what modules are for in ruby, for a base class that needs an initialize, use an actual class, is what I'd do. That the base class shouldn't be initialized on its own cant really be enforced, but that's okay. But yeah, there may be completely different ways to handle whatever you're really trying to do too, I didn't pay too much attention to what you're actually trying to do
I've been following and using thought of stuff for over 6 years. They are an absolutely fantastic contributor to the Ruby community. Not only do they have great gems, with good documentation, but they usually have a few blog posts to accompany it.
I don't really use many of their packages but I never heard anyone venting about this. Do you have any interesting links?
Paperclip maybe isn't the preferred upload library anymore, but it has been maintained for over 6 years (it has active commits from this month). It has lots of documentation. It is well tested. Why exactly is it a miserable project? And similar questions for shoulda matchers? I'm not sure what your criteria is for 'miserable' - I can't say I've every experienced misery with either of the projects. Why don't you provide a concrete criticism if you have issues.
Then, uh... Why are you worried about it? Like, not trying to be a dick here, bro- but have you ever actually had someone tell you you were doing anything objectionable? Or are you just worried that someone might? My point being, what is it to you? Are you coming from a place where you feel like you're being treated unfairly, or what?
What are we using instead of paperclip??
Shoulda Matchers is terribly managed... Have you actually tried to `bundle update shoulda-matchers` on a project? They keep randomly deprecating/removing stuff that's used in your tests!
I think it's also worth to mention that over time you simply learn how to write code that will have less mutations (which means the code itself will be simpler) resulting in simpler tests (and less tests!). That's one of the greatest benefits of using mutant, I believe. This means that keeping mut-cov close to 100% for new code will be quite natural.
Nice, I was just about to build an admin panel from scratch as a bit fatigued with active admin. I'll this out instead!
I never said it wasn't. Good luck stripping your binaries google fanboy. 
If you have an array like a = [11,22,33,44,55] you would use a.each do |n| puts n end You normally avoid using for loops.
And if you need access to the current index you can do: a.each_with_index do |n, index| puts n, index end
On a stylistic note, single-line blocks tend to be written inline like so: a.each { |n| puts n } Or, using each_with_index like meltingice suggests: a.each_with_index { |n, index| puts n, index } If you are interested in style guidelines for writing Ruby code, see [GitHub's Ruby Style Guide](https://github.com/styleguide/ruby)
The iterating block style described by others is probably what you want. Depending on the application, there are other methods besides `#each` that yield one element at a time. In looking them up, the methods you want may not be directly defined in [Array](http://ruby-doc.org/core-2.2.3/Array.html), but may instead be inherited from the parent class [Enumerable](http://ruby-doc.org/core-2.2.3/Enumerable.html). Check both pages. Always remember to check parent classes.
 sheet1 = book.worksheet 0 sheet1.each do |row| $ary.push(row[0]) Then(/^I want to verify phonenumbers that have been issued$/) do for index in (1...($ary.length-1)) on ARME do |arme| arme.screen('ARQB') arme.enter arme.arqbphoneNumber($ary[index]) 
I like it, interesting concept for a repl, but just a note, i think its called 'levenshtein' distance.
You're right, we still have a ways to go before we catch up to AA and RA in terms of features. Luckily, it's the early days. We'll be releasing pretty flexible plugin support in the next couple versions, which should help us close that gap. (= As far as DSLs go - they're great for starting off, but we've found that they quickly become much less maintainable than parts of the apps using Rails conventions. Administrate uses plain Rails classes to define dashboards, which gives a reasonable amount of customization while being much clearer about what's going on. Where specifically does Administrate fall short? Would love to hear about it - open some issues! https://github.com/thoughtbot/administrate/issues/new
So, you're already using `#each` to get each row. Why not just do whatever you want with the row, inside the block? sheet1.each do |row| phone_number = row.first # do more stuff with phone_number end Or am I missing something? Edit: And if you're using roo, you might try this: phone_numbers = sheet1.map {|row| row.first } Then, do whatever you want with `phone_numbers`. I haven't fully tested this, so if it doesn't work, don't spend much time on it.
That is certainly true. Over time I also got better at writing test cases which would actually kill almost all mutations for a method in one shot. I think mutant looks daunting at first if you think it will end up multiplying the number of tests you have to write. You really end up just end up learning to write better tests.
I think you missed the joke.
That demo image moves really, really fast. 
For a random of N where N is greater than one you are actually returning a random offset but stable N-1 records. In other words, any records after the first returned will be the "next" record(s) directly after the first. 
Yup, you are correct. You can even see in his example the result returns sequential IDs 17 and 18. You'd have to call ```offset``` for EACH random item that you want, not just once. I'm not sure if there's a way to do that easily in SQL, or do you have to do multiple queries?
&gt; Just curious, I would assume you did not sense the sarcastic nature of my post? I did, but I chose to ignore it so that I could be pedantic and make a point. :) BTW the term comes from Michael Feathers's _Working Effectively with Legacy Code_, which is an excellent book that is very relevant to the topic at hand.
You can either run multiple separate queries (which are cheap given any sane schema) or utilize RAND() or RANDOM() on your database to do this -- but these functions tend not to scale well at all (read horrible) after thousands of rows. 
Great thesis. Great to see Ruby as a research topic. Congrats Dr. Seaton.
slowed it down, good catch
I believe you will running the offset version (properly, once per random record you want) will end up benchmarking with better results on just about any schema/db row count. 
Your code would be horribly inefficient in a big database. Here's a few changes I'd recommend: &gt; project_ids = Project.all.collect { |p| p.id } If you want collect all `id`s into an array, then use `Project.all.pluck(:id)` -- this prevents loading all objects into memory, by optimising the SQL query. &gt; Project.find(project_ids.shuffle.first) This is first mutating the *whole* array of IDs, then choosing the first. If your array contains millions of `id`s, that's a totally unnecessary overhead! Instead, use: `project_ids.sample(1)` However, if you just want to choose **one** random record, then there are a few even more efficient approaches - for example: Project .all .offset(rand(Project.count)) .first
Then they don't have to "cd" into the object -- if you don't want to use the functionality, then don't use it, but the functionality should not get in your way. But generally speaking, Pry should be significantly more usable than IRB in every situation -- it was designed to be a better IRB as well as a kind of debugger.
Only trying to help! I recently wrote a script to (kind of) "seed a database", and spent a fair amount of time playing with performance optimisations. (With my original "lazy" code, the import would have taken ~5 days to complete. After some big performance improvements, it takes ~30 minutes.) After going through all that, my eyes are trained to avoid any simple performance killers like this.
rvm.
- https://www.youtube.com/watch?v=8bZh5LMaSmE - https://www.youtube.com/watch?v=OMPfEXIlTVE - https://www.youtube.com/watch?v=v-2yFMzxqwU Anything Sandi Metz related
Looking at the first key in the heap requires that I remove it?
&gt; Looking at the first key in the heap requires that I remove it? You'd run the job and... leave it in the heap? 
This impl is O(1). https://github.com/kanwei/algorithms/blob/master/lib/containers/heap.rb#L193
The article has a bad wrap up. Hash lookups are not always O(1). They may be in ruby (and that is as far as I recall the average notation... Anyhow), but the article is generic. And it's not a simple tool either, the o notation always helpful and amazing and I use it almost every week in programming, but it is not simple. When you take your first recursive method it starts to become tricky... Please don't recommend bad articles that will give people worse ideas :/. It's bad enough that everyone thinks they can be great programmers without studying in 2 months. &lt;/rant&gt;
I keep a running list of talks I've liked here: http://thomasleecopeland.com/2014/10/18/good-technical-videos.html
I looked at the literal line of code that is linked.
&gt; literal line of code It's a comment, and it doesn't look like an accurate one...
It's a worthwhile effort, but I wish the author had stuck with the analogy to dig into the point he makes later about caring about the constants in your complexity analysis. If you have to stop to say hi to everyone you meet, you have to, in practice, watch out for how long that "hi" takes. If I were a beginner at this, there's a chance I'll find it odd that it "doesn't matter" how much time I spend greeting someone when intuitively that feels like "more work."
[Pop (aka delete-min) is O(log(n)) for a Fibonacci Heap](https://en.wikipedia.org/wiki/Fibonacci_heap#Summary_of_running_times).
A complete reinstall of OS X would be like buying a new car because your tire is flat, you don't need to go that far. Personally I use https://github.com/postmodern/ruby-install to install new Ruby versions and https://github.com/postmodern/chruby to change Ruby versions
I find it's one of those, you know where to use it when you know where to use it kind of things. Say you've got a generic object that does something, you use it all over, but at the end of it doing something you need it to behave differently depending on context, so instead of creating lots of different objects, or using flags, you can just pass a block in, and yield to the alternative behaviour instead. Makes it a little easier to create more generic objects.
I barely grok the subtleties of yield, but it's the basis of iterators that facilitate block constructs. It allows the caller to continue processing at the point after the yield.
I've recently been working on a [pet project which will hunt for duplicate files on disparate systems](https://github.com/robacarp/rsync_recovery/tree/master/rsync_recovery). One place I've been using blocks is to keep certain aspects of code where they belong without sacrificing interactivity. As an example, I have a few [CLI classes which handle different modes of operating and communicating with the user](https://github.com/robacarp/rsync_recovery/blob/master/rsync_recovery/cli/search.rb). I also have [utility classes which actually do the work](https://github.com/robacarp/rsync_recovery/blob/master/rsync_recovery/searcher.rb). In order for the tool to have a solid user experience while not muddying the code, I've used [a yield statement](https://github.com/robacarp/rsync_recovery/blob/master/rsync_recovery/searcher.rb#L59) in my utility classes which are designed to update the [interactive portion of the CLI](https://github.com/robacarp/rsync_recovery/blob/master/rsync_recovery/cli/search.rb#L18-L28) via a block. Code samples below. Many edits of formatting. The CLI::Search class calls the worker Search class, passing a block ("searcher.hash_files"): module CLI class Search class &lt;&lt; self def search search_cli = new searcher = Searcher.new start reprint 'Building file list...' searcher.search directory: Options.references[0] puts "#{searcher.files.length} entries found" reprint 'Indexing...' states = {} searcher.hash_files(force: Options.flagged?(:force_rehash)) do |file, state| reprint "Indexing: #{File.join(file.path, file.name)}" states[state] ||= 0 states[state] += 1 unless file.valid? puts "file is invalid, you should probably take a look around" debugger end end # reprint "Indexed #{saved} files. Could not index #{failed} files. Skipped #{skipped} files." reprint "Indexed a bunch of files:" pp states puts 'bye' end def start print "\0337" # save cursor position end def reprint *args if Options.flagged?(:debug) puts *args else print "\0338" # restore cursor position print "\0337" # save cursor position print "\033[2K" # clear line from cursor print *args end end end end end And the worker class yields a status update ("yield file, state if block_given?"): class Searcher attr_reader :hostname, :files IGNORE_FILES = ['.','..'] def hostname @hostname ||= `hostname`.strip end def search(directory: '.') @files = [] list(dir: directory) end def list(dir:, parent: nil) hashed = HashedFile.from_path dir, hostname: hostname, parent: parent @files &lt;&lt; hashed return unless hashed.type == 'directory' Dir.entries(dir).each do |e| next if IGNORE_FILES.include? e full_path = File.join dir, e list(dir: full_path, parent: hashed) end end def hash_files(force: false) @unhashed = @files.dup.shuffle while @unhashed.any? do file = @unhashed.pop did_hash = false if force did_hash = file.hash! state = :hashed else did_hash = file.smart_hash if file.changed_columns.any? state = :hashed else state = :already_indexed end end unless did_hash @unhashed.unshift file next end if file.valid? &amp;&amp; ( file.changed_columns.any? || file.new? ) file.save end yield file, state if block_given? end end end 
I've used ruby for a year and this is the best explanation I've seen
Very good example! 
My favorite thing about this example is that it emphasizes that `yield` is yet another feature in Ruby that allows you to stick to DRY principles.
Thanks for the introduction to https://github.com/kanwei/algorithms. It's super-rare to see the CS "*greatest hits*" in Ruby.
A little disappointing, I thought I would see a practical application of a neural network.
Thanks for posting this. I will try this, but I'm a bit concerned about speed. Bash is rather fast, what about rush? Also: can I use my existing bashrc scripts and functions? Can I use pipes, for example?
The article seems to indicate that Ruby is used instead of bash scripting, and that method chaining (or other programmatic means) is used instead of pipes. However, I haven't used it yet, so take that with a grain of salt.
On my phone, but holy shit this is an awesome and sensible explanation. 
The worst part with ruby shells is the startup time. It will grate against your nerves after time. If you only open a shell once a day and use it throughout, it'll be fine. If you open a shell like once every 10 minutes because you closed your last one, you're gonna have a bad time. I'm *still* trying to figure out a syntax to make arbitrary commands easier (like in here https://www.reddit.com/r/ruby/comments/qr5qe/a_unix_shell_in_ruby_part_3_a_login_shell_and_the/c41gtic). Simple commands are easy, but once you try to pass a ton of awkward arguments, you end up typing a bunch of boilerplate.
You can find a whole ton of Ruby talks on http://confreaks.tv/ since they record most of the conferences.
Well, I don't have a good solution for it, I guess I'd just do nmap '-v -sn 192.168.0.0/16 10.0.0.0/8' I thought about other ways to set options, but haven't got any sane way to do this. 
* Ruby Dir class has glob method; * You can just use regexps instead of globs and iterate over filtered files; * https://github.com/s-mage/rush/wiki/Handbook%3A-Globbing one cool guy (https://github.com/najamelan) moved a rush handbook from the middle of nowhere to my repo, thanks to him
I just may have to try Rush again! One thing I always missed in IRB was being able to mix ruby syntax with normal shell commands (ex: `ls *.mp3 | map { |path| ... }`).
Yeah, it's strange, but it's the best I've got. I'd love to get rid of it; I just need an alternative.
I think you intend the following puts "start" x = gets.chomp.to_i puts "finish" y = gets.chomp.to_i while x &lt;= y if x % 4 == 0 puts x end x = x + 1 end In your code, the while doesn't have a condition specified (I think it's actually using the return of the puts as the condition, which is nil/false). The first time through (2000) works, so it gets printed, and then the program ends.
sorry, i don't quite follow. can you give an example? chitin is 100% ruby syntax. no special lexing (unless you want to preprocess your commands). chitin needs a better way in ruby to express something like a long nmap command
I edited my response based on some additional testing that you prompted me to do.
Hmm, I think it would be easier to parse a custom grammer and transform it into commands and ruby blocks. You would just have to recognize shell operators (`|`, `||`, `&amp;&amp;`, `( )`) and then check if the sub-command contains ruby syntax (`{ }`). This would allow for ruby syntax, while preserving regular shell syntax.
Why not link directly to [the article](http://engineering.pamediakopes.gr/2015/11/06/the-agnostic-query/)?
"Progressive jokes"
Ruby 1.9 had this, it's not a ruby 2.0 feature.
Good to see Rush is revised. I tried it years ago, the older version, and didn't really care for it. Gotta try this one out though
Glad to see this effort get picked up again and taken forward!
If you read your post you have not actually said the problem you are trying to solve -- only some (unclear and unfounded) "solution" you have concocted to the problem you are trying to solve. I suggest that if you actually clearly define the problem for us first (without trying to pull in or intermix your "solution"), and then convey your solution -- it would enable people to give meaningful input. As it stands it reads as this: I have a problem. Here is the solution I have constructed to fix this problem I have not told you about. What do you think about the solution?
I don't share your excitement, a message sender with throttling capability should be a trivial and easily understandable concept. You can even forget about Nagios, it's fully universal thing. Somewhere messages are generated and pushed into a queue. Then, periodically the queue gets worked and messages get sent, utilizing a pre-set throttling and flow control to avoid message storm.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/linux] [Rush  A UNIX Shell in Ruby  \/r\/ruby](https://np.reddit.com/r/linux/comments/3rvor3/rush_a_unix_shell_in_ruby_rruby/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
At first I thought this was about the band.
That was good. The next thing to explain is how to build middlewares.
Its really well done and reminds me of the example from Russ Olsen's book "Eloquent Ruby". If you haven't read it, please do. Best explanation of many aspects of Ruby.