We built are products on Spree, only kept an eye on Solidus. Solid presented itself as a stabilized fork of Spree, ironically claimed by same devs, who notoriously broke API when worked for Spree Commerce. Recent versions of Spree, after the big changes, seem to be finally settled down. 
Maybe you wanna read your comments again. Your previous two comments imply that it’s all about spinning up EC2 instances. &gt; You don't need a devops person to setup 3 nodes on EC2, you need maybe a week of 1 engineers time &gt; A rails app that runs on heroku can be up and running on EC2 in an afternoon. This reads the same as an overconfident dev giving a time estimate they’ll never be able to fulfill. &gt; We're not talking about some complex architecture “Complex” is a relative term that deserves qualification here. In the context of whether or not you need to bring in a devops person, once you’re beyond the amount of web traffic a single server can handle, it’s beyond the abilities of a typical web app developer to scale, so you need to bring in a devops person to make any sort of informed changes. &gt; nor did I claim they such things don’t exist I didn’t claim you did. &gt; Nor is this a scenario where some random client has told a contractor their shit will fit in 3 EC2 boxes What is the wider context readers are meant to interpret from your first comment quoted here, if not as if that figure were given? &gt; nor is it a scenario where a few minutes of down times cost them 6 figures. There is no way to know that from reading the article. Unless you were one of the consultants or the client from the article, you’re guessing at that every bit as much as I am. My entire point was that you oversimplified the hell out of this to the point of coming across like a typical overconfident dev with a year or two experience but thinks they understand every situation back to front. I provided examples here because flippant declarations back and forth without substance get nowhere.
I'm getting `NET::ERR_CERT_AUTHORITY_INVALID` on your https. 
&gt; This reads the same as an overconfident dev giving a time estimate they’ll never be able to fulfill. It reads like something someone whom has done this a number of times would say :) Stop pretending a stock Rails / Redis / Postgres stack is something complicated. &gt; once you’re beyond the amount of web traffic a single server can handle, it’s beyond the abilities of a typical web app developer to scale, so you need to bring in a devops person to make any sort of informed changes If you're engineers can't figure out more than 1 'server' then your issue isn't devops, it's your hiring practices. Seriously if you can't see past a single server how do you make good design choices as an engineer? I don't think it's possible. &gt; What is the wider context readers are meant to interpret from your first comment quoted here, if not as if that figure were given? That setting up a simple Rails / Redis / Postgres stack on EC2 is trivial and is not a full time job for anyone, therefore the monetary comparison between saving $85k a year and the cost of a full time devops person is fallacious. People often think they have complicated systems because there are 4 process types in their proc file and have 50 dynos running, they don't realize these system fit trivially in just a couple real VMs and likely perform much better. &gt; There is no way to know that from reading the article. Unless you were one of the consultants or the client from the article, you’re guessing at that every bit as much as I am. They put the entire site into maintenance mode for 6 hours to move a database. You don't do that at $x00,000 per 5 minutes of downtime... &gt; My entire point was that you oversimplified the hell out of this to the point of coming across like a typical overconfident dev with a year or two experience but thinks they understand every situation back to front. It's a bone stock Rails stack with Redis and Postgres...stop dreaming this is some interesting system. In the past 5 years I've moved a half dozen such systems from heroku to EC2, several at _much_ larger scale than discussed in the article. None of them took more than two weeks and 1-2 engineers (0 ops people) to do. In general you over-estimate the workload of devops. Currently we have around 100 EC2 nodes running at any given time with many more complicated services running under high load than rails/pg/redis and we still haven't found the need for a full time ops person. Devops currently takes about 20-33% of two engineers time (one me). 
You should use Solidus. _Full disclosure: my job is to develop Solidus and so I could not be more biased._ We've worked really hard to following SemVer as closely as possible (this is usually my #1 concern when writing code and reviewing PRs). To me this is the key to a successful community. It needs to be relatively painless to upgrade to the latest version, otherwise it doesn't make sense to contribute back to the project. I think the commitment to compatibility is best shown by http://extensions.solidus.io/, which ensures our extension gems stay compatible across multiple releases. This is a departure from older Spree where extensions were tied to the exact version of Spree (though I think new Spree may have followed us here). We've also improved security (with patches submitted back to Spree and coordinated release), improved performance, built proper extension points, and just generally fixed things which were broken. I think the work should speak for itself, but I appreciate that asking you to look at and compare two huge codebases isn't too helpful. I'm happy to answer any questions here or in our slack.
Thanks for the support
Yep, Sequel has a very well designed query API which allows you to never have to write pure SQL. With ActiveRecord you have to drop to pure SQL quite soon, which is unfortunate. I think this can even demotivate some to write more complex and efficient queries, because they know they would have to drop to raw SQL. Arel can help in certain cases, but for me it's much more complex to use than raw SQL. When you have to instantiate Arel classes directly, then the query interface has failed. Arel is also considered private API, and it does change. Sequel has this implemented right. And rom-sql adds even more advanced stuff on top of Sequel. &gt; It might be the considerable entry threshold, lack of clarity, or the complexity of Arel, or maybe the rather imperfect documentation of Sequel. I find Sequel extremely well documented, once you get used to where to look for things.
The Solidus core team has been made from former Spree _contributors_, but nobody employed by Spree Commerce. None of us have had commit rights on the Spree repo. My experience using Spree was indeed that it broke compatibility a lot and was hard to upgrade. I believe it's key for an open source project to follow SemVar and have relatively painless upgrades so that it makes sense to contribute back. I don't think it's fair to blame this on past Spree devs either, as you seem to imply. Keeping SemVer, especially in what is just a big rails app you're sharing with your users, is hard. It only happens as a very conscious decision and with community support. I have to say "no" to what would otherwise be great PRs because they break compat, keep around old code (with deprecations) that I'd really rather remove, and just generally slow down all work to consider the implications to existing users. All the feedback I've received from users is that we've done a pretty good job here, and upgrades are relatively painless (though diligence is always needed and I'm sure there are places we've made messed it up).
Another option is [Workarea Commerce](https://www.workarea.com/pages/platform), it's an eCommerce product which uses a Rails/Mongo/Elasticsearch/Redis stack. It's not open source in the 'available-on-github' sense, but the licensing includes access to the source code, the ability to extend/customize the application, developer training, and hosting as a service. disclaimer: I work for the company that builds Workarea.
I'd bet we (Solidus) have fewer DB queries. A lot of work has been put into reducing DB queries, especially in the checkout flow. Though there's still places we don't do well and need to improve (ex. line_items with large quantities) We're going to have fewer DB queries even from small things. Spree still uses the DB to store the global AppConfiguration (ie. Spree::Config) which is very slow and hits the DB (or cache, which should have a similar round-trip) all the time (it's also super buggy and prone to race conditions). Solidus uses a plain-ol hash as a backend, so global configuration is set in an initializer (which is where I'd want to set them anyways) rather than a production console. `class_eval` is going to be a perpetual challenge for these communities. It was so prevalent when we started Solidus that extensions often used it without even really needing it. So much code used it that it always seemed like the tool to reach for. I think even the move to `Module#prepend` over `class_eval`, despite only being slightly better itself, has really improved the quality of addons and customizations. Once you're defining a module like `MyExtension::OrderAdditions` to be prepended, it's an easier leap to realize that the mixin itself is unnecessary and you might just need `MyExtension::MyClassWhichOperatesOnTheOrder`. The other way we've migrated away from `class_eval` is introducing pluggable service classes on Spree::Config. These provide clean interfaces to totally swap out core behaviours like taxation, pricing, store selection, etc. It obviously is a work in progress and doesn't cover everything, but it's a much better path forward than overriding methods (like `Variant#copy_price`, which I swear every Spree store I ever worked on replaced) and just hoping that they don't change. We certainly haven't gotten rid of `class_eval` in stores or extensions, but I do think we are successfully moving away from them.
YMMV, but I do agree with the "quite soon". An example would be using `&gt;`, `&lt;` or the `&gt;=` or `&lt;=` variants. There is still no way to "rubify" such operations. 
Don't forget that savings of 84k represent a base 120k heroku bill if not more. Generally an equivalent setup on AWS is about 30% of heroku cost in my experiance.
Heroku is simply a layer on ec2. If it behaves on heroku it will behave on ec2 as long as you have systems people that know what they are doing. The effort over heroku is automation effort.
Everything from Sandi Metz :)
I'm not sure why the downvotes. But ok, here are some examples: * **Inequality operators (`&lt;`, `&gt;`, `&gt;=`, `&lt;=`).** Yeah, it's possible with Arel, but compare it to Sequel's `.where{created_at &lt;= Date.today}`. * **`LIKE` operator.** * **Boolean expressions.** Until ActiveRecord there wasn't any `OR` query, and now there is but you can only `OR` the whole expression, you still cannot do boolean expressions like in this Sequel example: `.where{(foo | bar) &amp; (baz | quux)}`. * **JSON and Array operators.** When I use Postgres I often use JSON/Array columns, and Sequel has really nice [DSL](http://sequel.jeremyevans.net/rdoc-plugins/files/lib/sequel/extensions/pg_json_ops_rb.html) for this. * **COUNT aggregation.** I often need to include a COUNT aggregation in the query without actually executing it. * **Multi insert**. As shown in this blog post, ActiveRecord itself is lacking ability to insert multiple records in one query. Yes, there is `activerecord-import`, but it should be built in. * **`CASE` statement**. When doing migrating data to a new column I sometimes need to use a CASE statement because I need to be able to update multiple records in a single UPDATE statement. Sequel has a nice `Sequel.case` API.
A quick Google search led me to https://github.com/artf/grapesjs
Thanks, all. Incorporating the thinking in this thread, I now have in the README for the [new version](https://rubygems.org/gems/markdown_helper) (and of course the corresponding code): By default, the output markdown has added comments that show: * The path to the template file. * The path to each included file. * The image description (original) for each resolved image file path. You can suppress those comments using the ```pristine``` option. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/github] [MarkdownHelper Updated](https://www.reddit.com/r/github/comments/84h9yc/markdownhelper_updated/) - [/r/markdown] [MarkdownHelper Updated](https://www.reddit.com/r/Markdown/comments/84h721/markdownhelper_updated/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I totally agree. The only real application is to say Happy Birthday, Ruby! Hence I did :) 
I totally agree with you on most of your points and this post is the second one in series "Rails aren't bad. Something is. ". In the first article, I wrote about the issues what Rails provide in our everyday work. In the last article, I want to write more about things related to your last postulate. Honestly, this single post may sound bad when we thought `rails aren't bad, whole evil is related to AR`. I didn't consider it before, will add a note that this post is a part of series. Good point.
I'm quite interested why `Sequel.case({a: 1}, 0, :b)` aren't easily understood? It's a natural order of parameters from SQL standardized CASE statement. It cannot be easier than the original syntax. When we using Sequel interface it give you "much more maintainable code", that's our win. I totally agree with you about more technical issues what AR have. But I wanted to point out (in your opinion) preferences cause that small things impact on a whole application on the end. Lack of support multi insert affected by the validations at model level? Okay, so its impact on the entire design of the application. Cause instead of extracting this responsibility to another layer, we have everything in models. Custom SQL vs ORM interface? It impacts like a hell on the maintainability of code. Does it sound like preferences? Not exactly, it's issue but it's visible when the scale of problems outgrow us.
Hey I wanted to say thanks for this whole discussion we had a couple days ago about not testing the class in question. I really do see your point now after refactorinng a class and not having to change the tests hardly at all because the tests didn't hard-code the list of private methods that were called.
saw this recently - not sure what kind of export ability it has https://subformapp.com/
I'd add that using `.where('column &lt; ?', var)` is not good practice, what if your column name is a reserved keyword in the RDBMS you're using, or what if a chained relation method causes a `join` on a table with a column of the same name, in reality you end up writing .where('"table_name"."column" &lt; ?', var) in PostgreSQL and .where('`table_name`.`column` = ?', var) in MySQL and God knows what in other RDBMS', if you're using a DSL to generate SQL, it's better that it be a more powerful one which allows you to do so consistently IMO.
if you want or like bootstrap, take a look at [layoutit.com](http://www.layoutit.com/build). I used it to make an index with form, then a response/result page. It was easy to break them down in to a main layout and then index and result yield pages.
This is a weird downvote. Have you used lua? Have you used mruby? It's what it's meant for. There are other projects like mruby CLI which do more, but at it's heart it's an embedded scripting language. 
We have fixed the HTTPS issue. Thanks for reporting it.
Thank you!
https://webflow.com/ allows you to export HTML
What, is it like not implemented in MRuby?
Awesome. You're more than welcome to add the nanook gem to the [Awesome Crypto page @ Planet Ruby](https://github.com/planetruby/awesome-crypto). Cheers. Prost.
Oh, as a part of "Rails aren't bad. {X} is" series it makes more sense, thanks for the clarification!
&gt; A core problem is the newness of the ruby CLI options, and relative lack of feedback on the jit process while its happening. I.e., the generated C files are not reused across invocations. That makes it hard to re-run a test. And although it's possible to get debug output when C files are generated, it's not possible to get output showing their compilation or the use of the executables. Do you realise that the generated C files have hard-coded absolute addresses from the VM process in them? They are specific to that process and you can't run them outside that process. It doesn't make sense to talk about using them as executables.
I tested --jit briefly with some scripts and all I can say is that it most likely does something since it's slower:). I think we need to wait some time before there will be anything meaningful to measure. I am testing the execution time with /usr/bin/time -v on Fedora 26.
&gt; the generated C files are not reused across invocations They've got addresses in them from the process which created them - they won't work in another process.
I think that the existing comments pretty much answer your raised arguments, but I'd like to single out this comment: &gt; Multi-insert comes with it's own set of problems, like validations at the model level. This reflects the sedimentation of the rails way in your view. It comes from the fact that AR models has been used as "jack of all trades", namely to bridge business logic and database AND validating user input (to name the relevant concerns in this case). The validation part of AR has been so hard to chew for years, that I've seen people prefer it over setting database constraints. If you'd be used to separate both operations from an architectural point of view, I think that this question would have never arisen. I see this as one of the many legacy flaws of the rails way. To sum it up, validating input data AND adding it to the database using the minimal amount of SQL shouldn't be mutually exclusive. 
Right on, I'm glad you found benefit! I also appreciate the discussion. Thank you for having an open mind. It's how things Get Better (TM). :)
I've solved this problem by generating my JSON with Haskell, which locks down the types. But this could serve the same purpose.
&gt; This reflects the sedimentation of the rails way in your view. Not really. I mostly use Diesel. Sequel, which is considered "better" than AR in this regard (I'm not quite sure why) still offers both model validations and callbacks, but just ignores them when doing multi-insert. AR chooses not to support multi-insert and avoids potential confusion. The Sequel query builder is clearly better and offers much better performanceb ut using Sequel with the same brittle model validations and callback spaghetti won't make things better and neither will religiously avoiding using model validations and callbacks.
&gt; .where(table[:column].lt(var)) This is also AR syntax using an Arel fragment. Using the string version is perfectly fine for a simple query, and since it's closer to SQL, it's more readable. The more you abstract away SQL, the worse things get. If you need to support a dynamic join or awkward column name, just use an Arel fragment.
https://github.com/mattn/mruby-onig-regexp ?
I have searched this and the mruby-hs, which is prefer compare to match or =~
I have searched this and the mruby-hs, which is prefer compare to match or =~ Intel HyperScan seem the fastest and PREC2 is the 2nd fastest regex, there are no wrapper for MRuby
&gt; Sequel, which is considered "better" than AR in this regard (I'm not quite sure why) still offers both model validations and callbacks, but just ignores them when doing multi-insert. AR chooses not to support multi-insert and avoids potential confusion. `Sequel::Dataset#multi_insert` accepts only arrays of hashes, it doesn't accept `Sequel::Model` instances, so it should be expected that it operates on this data directly. &gt; The Sequel query builder is clearly better and offers much better performance but using Sequel with the same brittle model validations and callback spaghetti won't make things better and neither will religiously avoiding using model validations and callbacks. I agree, in that case it's great when your ORM has more possibilities. If you prefer to just build queries and operate on arrays and hashes, then you can do that just as well without models (ActiveRecord's query interface can only be called on models and query results are necessarily model instances). This post is not an advocate that Sequel disallows all the bad things that you can do with ActiveRecord, just that it covers a much wider variety of use cases, while with ActiveRecord you have to resort to workarounds more often.
I've had a talk on the topic (2018-03-12 @ LRUG) if anyone is interested: https://skillsmatter.com/skillscasts/11594-lrug-march discussion: https://www.reddit.com/r/ruby/comments/84mgi3/web_architecture_choices_monolith_microservices/
I'm really nervous there, so sorry that my voice is shaking. Related discussions: * serverless-ruby.org : https://www.reddit.com/r/ruby/comments/835rjj/we_demand_faas_providers_to_support_ruby/ 
&gt; The more you abstract away SQL, the worse things get. Yes, but we are not talking about "deep" abstractions, just wider ones. Sequel just has a wider set of capabilities (enabled by a well-designed internal API), but you're still in total control which queries are being built. Compare it to ActiveRecord's `#includes`, which will in some cases use a separate query, while in other cases a LEFT JOIN. In Sequel `#eager` always runs a separate query, while `#eager_graph` uses a LEFT JOIN. Finally, notice that `.where(table[:column].lt(var))` is also an SQL abstraction, just like `.where{column &lt; var}`, the difference is that the latter one is more convenient to write.
&gt; Using the string version is perfectly fine for a simple query, and since it's closer to SQL, it's more readable. Yes, but I would prefer to build queries that will not suddenly fail when the table is JOIN-ed because I didn't qualify the column with the table name. The only reason why I would write a column name without a qualifier is for readability, even though I know it might break later on. It's much better when you can stick with the query API, which automatically qualifies the right way.
convenient, I need this _right now_, heh. 
Huh. Do you mind filling an issue? I’m sure Joe or myself wouldn’t mind looking into it. The new version should be released as soon as Joe finds the time to do it. I feel bad having inadvertently put some pressure on him to do that based on the post. I got a little too excited finishing up the post before dinner last night. 
I don't have time to check right now so I could definitely be completely wrong but AFAIK Sequel::Dataset#multi_insert will accept anything that responds to .keys and .map, including an array of Sequel::Model.
&gt; will accept anything that responds to .keys and .map, including an array of Sequel::Model. It won't. I've used it a couple of years ago, and it receives an array of hashes, or optionally (I'm not sure about this anymore...) an array of arrays, where the first array are the column identifiers. 
&gt; I mostly use Diesel. I've never used diesel, but I think it's not ruby. My comment was more directed towards ruby. &gt; Sequel, which is considered "better" than AR in this regard (I'm not quite sure why) still offers both model validations and callbacks, but just ignores them when doing multi-insert. AR chooses not to support multi-insert and avoids potential confusion. sequel is a database toolkit library which ships with an ORM as well, and multi-insert is not an ORM feature, so they match there. AR doesn't support it for many reasons (you'd have to ask the maintainers the why), and all you get are patches gems for that. But yes I agree, sequel doesn't save you from using the same ORM features (namely validations and callbacks). 
That's what the docs say... but not what the [code](https://github.com/jeremyevans/sequel/blob/master/lib/sequel/dataset/actions.rb#L479) does
Ok, I didn't believe you at first, but it really does work! This is because model instances also respond to `#[]`, just like hashes, so `object[column]` will retrieve the column value regardless of whether the object was a Hash or a `Sequel::Model` instance. Since this behaviour is not documented, I'm sure it was purely accidental. Yeah, there aren't any tests for multi-inserting model instances. So I think that's fine, because officially it's not supported and people shouldn't expect it to work in the first place.
Nonsense. It works just fine: https://gist.github.com/jamatthews/59b64424b98973f2a81ccc46d36b8a3f
All I'm saying is I met Joe Mastey a couple years ago and he's a friggin swell dude.
The getting user input Questions. https://ruby-doc.org/docs/ruby-doc-bundle/Tutorial/part_02/user_input.html#ex
But ideally an answer sheet would be beautiful lol.
I can file an issue, but I don't have a lot of time for figuring out exactly how to repro, what is unique about my (very complicated) gemfile.lock, for a product I haven't actually used before, was just checking out. 
puts name + “ was born in #{year - age.to_i}”
See your other thread
Wow thanks, its crazy how easy that was. If you don't mind, how did you get proficient in ruby?
Truth
wow, indeed you are right. the items must only respond to `#keys`. I take it back. 
My best guess is that one of your dependencies doesn't have a name or it's not being found in the dependency tree somehow, which is causing the nil error: https://github.com/jmmastey/bundler-stats/blob/ea153e47e13a1c3607d9323fa0e178a1c13e5e29/lib/bundler/stats/remover.rb#L20-L34 If you could share your Gemfile.lock privately it might be something we can add a test for. Joe put a comment in this specific method regarding how it could fail with circular dependencies so that might be another issue.
Ah, could be a `gem ... path:` checkout? My stuff is all open source, I can share Gemfile.lock publicly even. Will try to find time to make an issue report soon. 
Thanks. Yeah, might be something like that. A vendored gem perhaps?
For those watching for updates on that `bundler-stats` PR mentioned in the article. Joe Mastey just released [version 1.1.0][1] with the `bundle-stats versions &lt;gemname&gt;` command I talk about in the post. So you can now all benefit from this little feature. :-) And [André Arko mentioned on Twitter earlier][2] that he'd accept a PR to add this behavior to `bundle show` if someone submitted it. If anyone feels courageous or wants to help me out with this, let me know. :-) [1]: https://rubygems.org/gems/bundler-stats/versions/1.1.0 [2]: https://twitter.com/indirect/status/974343146430595072
The specs you demonstrate are far from being perfect, and some of the statements are incorrect, e.g. the one mentioning that `build` will create the associated record in the database. Do you have a repository of the examples for the book? Mind posting a link please?
Out of curiosity, who wrote Diesel?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/markdown] [MarkdownHelper: What's Next?](https://www.reddit.com/r/Markdown/comments/84pz7d/markdownhelper_whats_next/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
thanks this was good
Honestly, I'd never recommend the Poignant Guide to someone who wants to learn Ruby. It's a waste of time. It is funny and interesting, but I'd only read it after already knowing some Ruby if you can spare the time, just for laughs.
Because it reads cutely.
&gt; This technique improves the organisation of your code. It forces you to do two things that can really help keep you productive over time. I don't think I can agree. &gt; Firstly: naming the concepts you’re creating. When you name something aptly, you explain it, often for the benefit of “future you” or your colleagues. You can name these concepts anywhere you use them. You can assign `Post.where(status: 'published')` to a local variable in your controller, for instance. They don't have to be named on the model. &gt; Secondly: you have one place to look for all of this. If you define scopes outside your models you can end up with arbitrary scopes and conditions defined all over your code base. When you know where all the conditions are defined you’ll know where to look when you want to refactor or optimise database performance. Having one place to look for things leads to "God classes." If you want to organize your queries so that they are easy to find where needed, consider organizing your queries into query objects under a namespace.
I disagree with some of the points this article made. &gt; Easier versioning - data is defined by the query, not by the server And how does this help to an easier versioning? If the data model changes in the server, the queries will need to change, whether in the client or in the server &gt; Reduction in data volume - the server sends only what is requested by the client This is not GraphQL specific feature. With a RESTful API or JSON RPC, you may also fetch only a subset of the data instead of the full objects Also, the data volume sent by the client is increased, because the query needs to be sent for each request. And I've seen huge queries for real world data models. The examples in this article are very simple, "hello world" scenarios &gt; Aggregated queries - allowing us to retrieve resources and their subresources in a single API call Same as the previous point, nothing stops you to return aggregated objects with REST APIs there is no "official" standard for RESTful APIs, so one may design endpoints to return the data that fits better to his/her problem. Btw, I'm not a big fun of RESTful APIs, I kind of like more JSON RPC, which also gives freedom to return whatever you feel like in the results. 
As an example, see what a "normal" graphQL query might be. IMO, this is awful. https://gist.github.com/vruizext/637eae74b4f4540b54611f54e91592ca 
The statement that `build` creates associated records in the db is accurate, though perhaps surprising. See https://robots.thoughtbot.com/use-factory-girls-build-stubbed-for-a-faster-test
Thanks for the update kind internet stranger whom I’ve never met in real life. Are you going to RailsConf?
Yes, in this case this is actually the only reason. Seriously. Otherwise, this is bad: if the method is supposed to return `true` or `false`, and someone introduces a bug that causes it to return `nil` instead of `false`, you've potentially broken some parts of yours (or worse, other peoples!) program. 
If you want to be cute _and correct_, you can do: expect(policy).to_not be_old_enough(12) expect(policy).to be_old_enough(18) 
Ah, you are right, it's the other way around, associated records are created, while the object created by the factory itself is not. You may want to specify a `build` strategy on the association. If you want to go deeper, however, and it works well with isolated tests, is to use `instance_double` or a plain `YourClassName.new`, surprisingly it gets you a 5x and a 10x performance boost even over `build_stubbed`.
oke, im a little bit further. I have now this code : http://lpaste.net/363684 but now I never reached the person with the bow. So please help me 
Should be. Check on github. 
I'm asking obviously because I didn't find anything :) 
Good thoughts - but why are you so scared of JavaScript?
I am not fond of JS (or TS). I kinda liked CoffeeScript but never had the chance to use it in production. Too many teams and companies promote this idea to write everything in JS. 
Why would you use a named scope over a method?
Its because JS has a fairly low barrier of entry I believe. It's also a little like showing a square peg through a round hole at times, especially this "write the same code for back end and front end" stuff.
I'm really excited for Crystal, especially with projects like Lucky and Amber. I can't wait for it to go 1.0 and for it to get more enterprise support. 
&gt; it’s better to just use Ruby in your own projects. It’s faster, it’s clearer, there’s no need for a dependency to do this. I used to think the same, but lately got really used to memoist. Especially in complicated business objects, that fetch some results from DB (memoize1), then do a complex calculation on them (memoize2), then extract some view (memoize3)... &lt;insert imaginary discussion on a good system design that will break this into something something blah blah&gt; Mostly, Memoist attacks "it’s clearer" statement. Of the two below, for me, "with memoist" is definitely clearer! It is DRY, declarative, easy to recognize reading class definition, and scalable for complex methods. # without Memoist def client @client ||= Client.find(id) end def assessibile? return @accessible if defined?(@accessible) @accessible = FetchAndCalculateAccessible end def huge_table @huge_table ||= begin columns = calculate_columns rows = calculate_rows data = calculate_data columns.zip(data) ...... end end # with Memoist memoize def client Client.find(id) end memoize def assessibile? FetchAndCalculateAccessible end memoize def huge_table columns = calculate_columns rows = calculate_rows data = calculate_data columns.zip(data) ...... end For me, this use of `memoize` is exactly "good Ruby": make code cleaner with simple abstraction, encapsulating common pattern and defined with metaprogramming. I am not sure why very common pattern is better to write by hands each and every time, polluting the code of methods with what is not related directly to method's responsibility. The problem, of course, is that Ruby does not have "zero-cost abstractions", and even "not-that-high-cost-abstractions": now you need to think about the performance of the wrapper, and about the additional instance variables (that, for example, will be shown in default inspect and default to_yaml), cache invalidations and all kind of new things. Still love it, tho. PS: On the more philosophical note, I am always fascinated when "we don't need magic, metaprogramming, and abstract out the complexity" comes from Rails ground. So ironic.
this seems so cool but how the fuck do I use it without facebook login? &gt; SAVE XXX'S PROGRESS? well I would like to say "no" but there is no such button :/
Use state, something like: if warrior.health &lt; 20 warrior.walk!(:backwards) @healing = true end And then in your code the first thing you check is if @healing warrior.rest @healing = false if warrior.health &gt; 80 else check_captive end
The only difference between CS and JS is syntax.
Do you have a portfolio?
The only difference between Ruby and Assembly is syntax.
Nope I'm just starting out right now, Till now I worked for companies only so I have a resume about what I did in various places, You can find more about my work profile here -&gt; https://www.linkedin.com/in/dinnu93/
Haha, no.
Build your won blockchain :-) than you can mine as many blocks as you like on your home computer with ruby, see &lt;https://github.com/openblockchains/programming-blockchains-step-by-step&gt;. Happy mining. 
`extend Memoist` There. Happy? 
I agree, that would make the post more-complete. When I sat down to write this, I wrestled with the scope of the post, and tried to keep it targeted to the `nil` / `false` memoizing footgun. In my experience that's a very common problem in real code, whereas I rarely run across memoization of methods with inputs - and when I do they tend to be written well-enough.
You should still check that he's not under attack and entering healing mode
hmm, I thought I did it here : def check_health(warrior) if warrior.health &lt; 20 warrior.walk!(:backward) @healing = true else warrior.walk!(:forward) @healing = false end end 
hmm, When I do this : def check_health(warrior) if warrior.health &lt; 20 warrior.walk!(:backward) @healing = true else if warrior.health &lt; @health @healing = true else warrior.walk!(:forward) @healing = false end end end Then @health seems to be nil 
No offense op, I think this is a much more complete post: https://www.justinweiss.com/articles/4-simple-memoization-patterns-in-ruby-and-one-gem/
Although I'm watching/learning in my free time Phoenix(Elixir), Serverless, Microservices, and following bunch of potential technologies, I'm betting my future on Ruby and Ruby on Rails particularly :) I'm already 9 years a Ruby developer and it seems that every 3 months someone post an article how Ruby or Rails is dying and like no Jobs for Ruby/Rails will be there in few of years. Yet (as a tech lead in company I work for) demand and salaries are higher than ever :) It's simple. There are still new companies emerging, and monolith applications are the cheapest way how to build a product. And when it comes to productivity Ruby on Rails is a clear winner :) Yes there are pitfalls ! But there is no single technology/architecture/language without some disadvantage (on technology or human level). More you learn and improve around particular technology more you learn how to deal with the pitfalls. Learning different other technologies is helpful too. When you reach certain level in technology you notice you learn more about Ruby by learning other languages/technological approaches than by just reading only Ruby related topics. To panic and to say "there will be no market" for Rails or Ruby makes me smile all the time (as I've read it every other month for last 9 years :) ) Ruby and Rails is always evolving they will always adopt to what is currently needed on market :) And before anyone will argue with me Please listen to this podcast interview: https://player.fm/series/all-ruby-podcasts-by-devchattv/rr-342-rails-development-and-more-with-david-heinemeier-hansson
well rails installer gave me some issues before, that i cant recall from the top of my head now but mostly regarding building gems from source and right version of ruby / devkit. but for me its mostly fast download + and keeps libs up to date. and i agree the instalation process might be a little bit weird specially on the devkit part but having a coach to tell them why its a good thing and I rather that than having them to see me googling for 20 mins how to solve a make issue on windows (which is more discouraging imo) 
This is what I needed a year ago. I was determined to make windows work on my PC. The poor thing, I almost threw it against the wall a few times, but after days of trial and error it was working. I have windows 10 though, so now I have WSL which is waaaay easier. Anyway, thanks for sharing. 
I feel like this comment was also a good answer to /u/realntl too. On the word *only* I get the feeling that Andy was using that to draw people in, given that by the end of the post he said: &gt; Naming scopes is only beneficial when you gain extra clarity. Sometimes, with non-#where queries, there is no enhanced understanding from wrapping simple ActiveRelation methods inside a scope. There are no hard rules in programming, just blog post titles that make it seem that way!
&gt; This is exactly the same as defining a class method, and which you use is a matter of personal preference That's a line from the [Rails docs on scopes](http://guides.rubyonrails.org/active_record_querying.html#scopes). I find the syntax of named scopes neat and easy to read so tend to favour them. This entire article still applies if you choose to use named scopes or class methods to build queries like this.
Seems like the ability for scopes to chain and not return nil is a solid reason to prefer scopes over methods. Thanks for the share.
Keep up the good work! I checked out your project last time you posted. I think this is lovely! Sorry, no advice or anything--- just a bunch of high fives and feel goods! Feel good!
Installing a new version of Ruby is trivial... if Ruby 2.5 offers you benefits that lower versions don't then it is what it is.
Nice guide. Just curious, what country are you in where a Windows 7 guide is needed?
Argentina, a lot of ppl that attend to this courses have netbooks (that were given by the previous government) [this](https://www.taringa.net/posts/imagenes/14180562/Los-10-modelos-de-Netbooks-del-Gobierno.html) specs so you cant really throw docker there and expect it works same goes to VM and most of them run W7
Ah government issued Netbooks is something I've never thought about but it makes total sense. Nice work!
It's funny, I wrote an article about that a few days ago. Not in English though. https://codeguida.com/post/1265 In my opinion native ruby on windows (without Linux virtual machine) is meh. You will run into a lot of problems during development. And it's just unnatural and wrong to me. 
Do. Not. Work. For. Free. Seriously. 
Wow, really cool stuff! I hadn't seen your original post so this is really cool. Very nice especially to see anything built in Opal :D Do you recommend any particular use-cases of your software? I can think of a ton myself, but I'd like to know what it's really tailored for. Moreover, how does your project compare to other audio programming solutions, such as [Sonic Pi](http://sonic-pi.net/) or [Sporth?](https://pbat.ch/proj/sporth.html) I think I have an idea of what the differences may be, but I'd like to hear it from the developer himself. Also, I'm curious: what are the features that Ruby 2.5 offers that make it necessary? There's no problem with requiring 2.5 as far as I'm concerned, but I'd like to know what is so desirable.
This is so cool! The reverse scale finder is something I find needing the most when I am jamming in a fragment of a scale and want to know what scale has those notes and what other notes are in that scale. Super cool to have that available all the time and not have to go to some dopey website.
He's not technically wrong. And it's actually an important technicality as it leads to a greater understanding of what programming languages are.
Yes, I agree with you on many points. It is truly a somewhat worrisome situation. Not that Ruby will "die," but that it may perhaps not live up to its potential. It really needs to keep up with other languages as far as performance goes and Opal is a great help, but has not received as much positive attention as it should have. Truly I hope that Ruby-like WASM languages will also get off the ground. Truffle is also exciting, but there are some concerns with it like slow-ish startup and not getting RVM in soon enough. Ruby 3x3 can obviously only go so far. Crystal needs to resolve issues with Windows and parallelization. Definitely a lot of work that needs to be done. I hope the community can live up to the task and make Ruby meet its potential.
Hey, thanks a lot! I'm attempting to make it fully Opal compatible. Actually the only part that i'm missing is the Opal-Rspecs, so that I can run the whole test suite and see what is wrong. 
&gt; Do you recommend any particular use-cases of your software? I can think of a ton myself, but I'd like to know what it's really tailored for. Music creativity and discovery. Coltrane is a gem for those who want to create and improvise. It's the computer aiding the human on music making and not taking his part. That's one of the huge differences of a lot of the projects. Moreover, Coltrane is like an attempt of coding the rules and logics of the music theory in Ruby. That's why I tried to have the least table lookups and have things the most procedural as possible. I have recently rewrote the whole chord finding mechanism to make it feel more procedural. I believe that maybe Coltrane can teach people music theory. I learn a lot when I'm writing it and playing with it.
I personally enjoy using pry's `show-source`, `show-docs` and `edit` features. You can call them with both constants for loaded classes and modules, or instantiated objects. You can also call them for specific methods. If you haven't given them a spin, I encourage you to check it out. It's quite powerful (and pleasant).
bundle open gemname
I suspect anyone using this is unlikely to want to integrate into existing legacy software, so using a recent version of ruby will probably not be a problem. You could consider compatibility with JRuby, which may not have everything in current 2.5 though. But I wouldn't prioritize it until someone asks for it. :)
Sure it does. But Ruby code could all ultimately be reduced to assembly. So Ruby (and all high-level languages) are just a different way of looking at assembly. The defining difference is precisely *syntax.*
lol you could say the same for literally any language.
Wow, thanks a lot for all the information. I definitely have some ideas cut out for me now and I'll keep an eye on your project. I may even contribute a thing or two, if you don't have it already ;) Also, for anyone interested in learning music theory, I would *very highly* recommend [Michael New's tutorials.](https://www.youtube.com/playlist?list=PLTKhUdPIHIuhhCrMuKJWcjnXUfAN3f5Mn) They are truly exceptional and are worth more than many textbooks. I can pretty much guarantee that it will give you a solid foundation for understanding music theory.
This is the new Slack Channel of the project: http://coltrane-ruby.herokuapp.com
I think you may be misreading the docs. Scopes are chainable when defined with methods as well. I'm not sure what you mean about `nil`, whether it's the method or the block form you need to return a relation. 
Net http
do you have to use shrine? ive never used it, but have done work with other ones
Seriously. Do not work for free. If you need a portfolio, why not create a personal project. Contribute to the open source projects. Make an open-source project. Do not work for free. As you're screwing everybody else in the industry this way.
See here https://regular-expressions.mobi/anchors.html?wlr=1
Either this, or watch a quick youtube video on how regex work. You;re lacking some fundamental knowledge around regular expressions.
The instructions are slightly misleading. The description says that it should match sentences starting with “Burgers” but example shows that a “Burger” should also match. That said checkout [http://rubular.com](http://rubular.com) where you can play with your test data. It lists some helpful items too.
Don't use shrine. Carrierwave and Paperclip are much better supported.
Shrine is set up in a super modular way, which I really like but can make it hard to give one explanation for all situations. Without knowing more about your app, here are some questions and possible things to try: * Are you trying the default file-goes-to-your-server-and-then-gets-uploaded-to-S3 kind of upload or the more complex and shinier [direct-to-S3](http://shrinerb.com/rdoc/files/doc/direct_s3_md.html) upload? * For the default type, which part of the upload is failing? Is it the browser-to-your-app part or the your-app-to-S3 part? What kind of errors are you getting? * For the direct type, I'd triple-check the [CORS configuration](http://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) on the S3 bucket to make sure it allows POST requests from *, and then make sure you're POST all the fields you get back from the presigning to S3 as multipart form data, not as query params or JSON. * You say you've got a non-Rails app — what are you using to work with data? Shrine works most easily if it can integrate directly with your ORM via the builtin plugins for [ActiveRecord](http://shrinerb.com/rdoc/classes/Shrine/Plugins/Activerecord.html) or [Sequel](http://shrinerb.com/rdoc/classes/Shrine/Plugins/Sequel.html), or using external gems like [shrine-mongoid](https://github.com/shrinerb/shrine-mongoid). This lets shrine hook into the lifecycle of your models and handle things appropriately when they're saved. * If you're not using an ORM that Shrine supports directly, you'll probably want to take the more manual approach of manipulating the [Shrine Attacher](http://shrinerb.com/rdoc/files/doc/attacher_md.html) directly.
Regex by default doesn't care where in a line a match occurs. You can specify this with the start of line or end of line anchors: /^Start of sentence/ /end of sentence$/ 
this looks awesome. If you resize the terminal does it reflow the text?
Thinking about programming languages as "just a better alternative to plain assembly" is a bit outdated, isn't it? Especially since a lot of modern languages require a VM to function. Ecosystems matter. Platforms matter. CoffeeScript runs everywhere JS runs. You can seamlessly use any JS library in your CS project. Moreover, you can automatically convert your CS project into modern JS and it will work. Because it is *just* a syntax. In contrast, Opal has the same syntax as Ruby. Yet it's not nearly as popular. Its adoption is rather poor, I would say. Wouldn't call syntax *the* defining difference. Modern languages are more complex than that. 
I just found their documentation and ease-of-use lacking. Also just more difficult to find answers and it's not as widely used. What does it offer that the other two don't?
Here you go: https://gist.github.com/janko-m/9aea154d72eb85b1fbfa16e1d77946e5 Thanks for sharing your frustration, I'll link to this walkthrough in the website.
That's not possible, as I just wrote it.
POODR = Practical Object Oriented Design in Ruby by Sandi Metz et al.
I like that one, but https://regexr.com/ seems much more "proactive" about letting you know what's what. You kinda have to earn it a little with rubular, and it doesn't have the same level of detail. 
That’s true, rubular does feel more like a quick reference than anything 
Have you considered sidekiq-throttler?
Have you considered using sidekiq-throttler or similar?
Thanks 👍🏾
I wonder if you could make a wrapper that takes care of this. I wanted to format the help output of my program in a dynamic way. Something like this would be perfect.
OK, how do you suggest?
Thanks for this. I have been meaning to switch from refile to shrine and this is a huge help. 
Depends on the nature of the data involved and the access patterns but a read-write lock around the variable is probably the most common approach, e.g. `Current::ReadWriteLock` from concurrent-ruby. Usually memoization is hiding expensive initialization that is expected to be read many times and a read-write lock gives you a lock-free code path on read with multiple accessors. 
Well done. This gave me some inspiration also 
I think much of my and others of my memoization doesn't matter if it's concurrency-safe -- plus I think it actually _is_ in MRI. Also much of my memoization, the worst a race condition would do is that the initialization code is run more than once when it really could only have been run once, and it's not a big deal that some callers during race condition might get different object copies of the same (immutable) data. So I think it's probably okay. But I could be wrong. But either way, anyone interested in making a memoization module with a similar API `memoize :method`, `memoize def method ...` (in recent rubies)... that uses a concurrent-ruby ReadWriteLock to be truly concurrency safe? 
I love the idea of a slackbot as a profitable side project. I wonder if this is something that there is a limited window on, when slack is/was fairly new and there wasn't a big market of slack integration. (Like it used to be way easier to make a profitable ios game than it is now). I also wonder if the particular feature, sending anonymous messages, is actually contributing to healthy team dynamics or harming them. :)
Hello, I've added a couple of new chapters to the "Programming Blockchains Step-by-Step from Scratch (Zero)" and starting with (crypto) hashes... What's News? Mining, mining, mining! What's your hash rate? Let's find out and use the "stand-alone" version of the by now "classic" compute_hash_with_proof_of_work function: def compute_hash_with_proof_of_work( data, difficulty='00' ) nonce = 0 loop do hash = Digest::SHA256.hexdigest( "#{nonce}#{data}" ) if hash.start_with?( difficulty ) return [nonce,hash] ## bingo! proof of work if hash starts with leading zeros (00) else nonce += 1 ## keep trying (and trying and trying) end end # loop end # method compute_hash_with_proof_of_work Let's try (run) benchmarks for the difficulty from 0 (4 bits) to 0000000 (28 bits)... On my "low-end" home computer the hash rate per second is... about 100 000. What's yours?
I have to point out, in agreement with your second point, that this tool could risk disciplinary action against the entire team. Anonymous messaging in a professional context has a high risk factor for malfeasance and negligence. However, this is a great article on building Slack bots with Rails.
Interesting project. The only thing that really came to mind is since the messages are deleted on their server, could someone use it as a way to harass to a colleague leaving the company unable to take any action because it would be 100% anonymous. 
&gt; I think much of my and others of my memoization doesn't matter if it's concurrency-safe Yea if a class is never shared between threads you don't need to care about it. &gt; Plus I think it might actually be threasafe in current MRI? (Not by contract, but by current implementation, maybe? Could be wrong). It's not thread safe in MRI. Either by contract or implementation. &gt; Also much of my memoization, the worst a race condition would do is that the initialization code is run more than once Sure, but that only holds when there are no side effects and there is no mutation. A common use case I see is initializing a counter or a hash to store cache data. If you re-initialize these multiple times you have wrong code. Also you could have to assume you're only working on MRI or else the lack of locking means you could read a partially assigned value (I believe MRI holds the GIL around assignment). 
I have fortunately not worked on teams where I need to think about risk of disciplinary action for stuff like that. But I have worked on teams where I think anonymous messaging would further encourage some unhealthy culture/relationships, and I'd rather focus on building trust to communicate these things not anonymously. If the trust isn't there, I think the anonymity might just make it worse. 
A couple related tips: I wouldn't recommend using `enum` unless there is a clear ordering to the values, absent that you're likely better off with a `status` string field and a `CHECK` constraint on it in the DB. If you do need an enum, and are using postgres, use their enum type: execute &lt;&lt;~SQL CREATE TYPE client_visits_statuses AS ENUM ('inprocess', 'completed' , 'incomplete'); SQL add_column :client_visits, :status, :client_visits_statuses class ClientVisit &lt; ApplicationRecord enum status: { inprocess: 'inprocess', completed: 'completed', incomplete: 'incomplete' } end This has a couple advantages: 1) You get database validation similar to a check constraint. 2) You can add values into the middle of the ordering without breaking anything or having to migrate all values which I find to be a major cause of needing to alter the ordering query. e.g. `ALTER TYPE enum_type ADD VALUE 'new_value' BEFORE 'old_value';` If you do need arbitrary ordering, the approach in the article has a problem in that in most databases I'm aware of it will prevent index usage for the sort. Additionally since ransake is mentioned, there is a decent chance there are a lot of records here and likely a `LIMIT` at the end of that query. With a LIMIT if the ORDER BY doesn't use an index, you can end up constructing the entire result set in the DB then scanning up to the LIMIT...this is _sloooooow_. Another approach is to use `UNION` to combine the results in the order you want and push down the sub-ordering and limiting. This will trigger 3 sub queries but each should be fully indexes and have a small result set, generally should be pretty fast. Doing this in ActiveRecord will require you to drop to `find_by_sql`. (SELECT * FROM client_visits WHERE status = 'completed' ORDER BY due_date DESC LIMIT 25) UNION (SELECT * FROM client_visits WHERE status = 'incomplete' ORDER BY due_date DESC LIMIT 25) UNION (SELECT * FROM client_visits WHERE status = 'inprocess' ORDER BY due_date DESC LIMIT 25) LIMIT 25
 I agree my tool could be detrimental to many teams. I hope to deploy feature optionally limiting usage to certain channels and disabling direct messaging in the next couple of days. 
You made Code Triage? That's awesome. I've been on there for at least 2 years I think. Nice work, man!
Thanks! I just rolled out a major update to the way HTML emails are styled. Let me know if you've got any ideas or features you wish it had. 
Hello, I've "converted" the pseudo-code published by Sean Soria in ["CryptoKitties mixGenes Function"](https://medium.com/@sean.soria/cryptokitties-mixgenes-function-69207883fc80) into a running (working) ruby script. Try: mgenes_hex = 0x000063169218f348dc640d171b000208934b5a90189038cb3084624a50f7316c sgenes_hex = 0x00005a13429085339c6521ef0300011c82438c628cc431a63298e3721f772d29 mgenes = Kai.encode( mgenes_hex ) p Kai.fmt( mgenes ) # =&gt; "ddca 578k a4f7 949p 4d11 535k aeea 175h 846k 2243 aa9g fdcd" sgenes = Kai.encode( sgenes_hex ) p Kai.fmt( sgenes ) # =&gt; "c9am 6556 7ff7 b9gg 1d11 3853 9f77 6475 77k4 6784 f9gp fcaa" babygenes = mixgenes( mgenes, sgenes ) p Kai.fmt( babygenes ) # =&gt; "9dca 5586 aff7 b99p 1d11 33k5 aea7 67h5 74kk 6744 aafg ffaa" Happy CryptoKitties gene mixing in ruby. Cheers. 
`UNIXSocket.new("/tmp/my_socket")` is how you setup a unix domain socket on the filesystem. Take a look at https://ruby-doc.org/stdlib-2.4.3/libdoc/socket/rdoc/UNIXSocket.html
https://lankydanblog.com/2017/05/12/debugging-a-rails-server-in-visual-studio-code/ I found this link pretty useful and getting up and running. It's for rails but the extensions involved look like they're also applicable to running standard ruby programs. If you're using RVM you'll need to do some more configuration so that the debugger knows the path to your ruby--I don't have that code block on hand but I can look it up later if you need it.
Redmine is really good. 
`UNIXSocket.new` only creates socket instance and associates it with *existing* socket file. I can't see how it is related to the question.
I'm pretty content with VSCode and RoR development. Only downside is that VSCode runs inside an electron container so it gobbles up a GB of ram or more :/
this is super cool. I would love to hear a little more about how you first marketed it &amp; got the word out. 
All you need is a text editor and a terminal, so yes. The rest is just a matter of preference, play around with different editors/IDEs. I use Vim and iTerm2
The only way this exception could have happened is if your uploader classes got loaded before your Shrine configuration. Make sure you've loaded the Shrine configuration first. Also, it's better to ask for help in the [Shrine google group](https://groups.google.com/forum/#!forum/ruby-shrine).
Emacs has Rspec, Git and project support.
Congratulations and thanks for sharing. Why not use PayPal for your payment provider? 
I really like VSCode. I switch between VIM and VSCode depending on my platform. As far as plugins go, it's pretty lightweight. I just use these 10 plugins. https://imgur.com/a/zxr13 https://imgur.com/a/CDU8n
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/zZbZ2BE.png** **https://i.imgur.com/KwgO30k.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
VS Code is a great choice for Ruby. Definitely install vscode-ruby, which is the main Ruby extension. Try to get linting and autoformat working if you are into that sort of thing. I'm also working on a new extension called Bust A Gem that adds support for Go to Definition - [Bust A Gem](https://marketplace.visualstudio.com/items?itemName=gurgeous.bust-a-gem) [github](https://github.com/gurgeous/bust-a-gem)
I use VSCode for javascript and sublime for ruby. I dunno why but Sublime just feels "right" with ruby. Plus it has a superior vim mode. The debugger support for ruby in VSCode is becoming a lot better though.
no, it's loaded in the proper order 
I went from TextMate -&gt; Sublime 2, then 3 -&gt; Atom -&gt; RubyMine (very briefly, we didn't get along) -&gt; VSCode. I guess I've been using VSCode for about a year now, pretty happy with it. Plugins I use: * Ruby (by Peng Lv) * RubySolargraph * GitLens * Rubocop * Rails Test Runner * RailsCasts Theme (with some personal tweaks)
[old but relevant](https://www.reddit.com/r/rails/comments/6sonqz/vs_code_setup_for_rails_development/) [solargraph](https://github.com/castwide/solargraph) is pretty awesome. I have done a decent amount of ruby development with VSCode and tried a bunch of extensions and key mappings to maximize my development flow.. and to tell you the truth, after 5 days of trying vim.. I no longer care about my VSCode ruby workspace. 
My VSCode instances never exceed 300MB usage, and that tones down when I switch to something else or some other process needs a lot of memory. If you have a lot of RAM in your system it may simply be that Electron is using more RAM to perform better.
Holy crap, thanks for the Bust A Gem tip. I've been looking for a way to GTD in gems, it's the one feature of RubyMine I miss.
Thanks for your feedback !
Looks like Medium is having problems.
Thanks! I haven't looked at the code yet, but this is something I have sometimes wanted to do. Perhaps no coincidence, I work in the library/preservation sector, I see you are also either in that or publishing. :)
I prefer [Pry](https://github.com/pry/pry) over IRB for most things. Colourful output and the ability to dive into objects is a lifesaver. ][Example](https://i.imgur.com/a4fYacy.png).
It can be a good alternative. Otherwise, In my blogposts I try to focus on Ruby and it's core and standard libraries. Pry is a tool created from scratch with a totally different mindset. Thank you for your feedback. I appreciate.
There was hardly no marketing at all for a long time. I launched on Product Hunt and other places but it attracted almost no attention. Official Slack app directory brings in quite a lot of users by itself. I only started doing some marketing recently, after it already started making a profit. 
Did not think about it. Does it handle taxing ? A friend recommended a Paddle for me and like it so that did not do more research.
can't you just `$stdout.reopen` and put it at the unix socket
[Opsschool](http://www.opsschool.org/en/latest/) is suuuper good
Troy Hunt's API is rate-limited to 1 request per 1500 ms. https://haveibeenpwned.com/API/v2#RateLimiting One would think that would be a good thing to mention in OP, and consider before building it into a production app. Few apps have more than one password set per 1.5 seconds on average. But what happens if you happen to get two within a second? A 500 error? One of your users waits 2 seconds extra for a response? It just doesn't check their password? Depends on how you write your code of course. I don't know what their gem does. 
omg thank you so much for this, it looks perfect.
If you have an XML schema I'd suggest checking out [jaxb2ruby](https://github.com/sshaw/jaxb2ruby/) (author here). 
I chose ruby for this project because the calculations require large integers (over 200 bits) which ruby has natively and because ruby is just the perfect language for little fun projects like this one anyway. 
Just what I want - web apps to be sending my password around to other services to check how secure it no longer is.
But the password isn’t sent anywhere! I’d recommend reading the blog post on the API itself and how it keeps passwords anonymous. It’s linked in the original article, but here it is just in case: https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/
Ah, I see. Clever. tl;dr for anyone else - you send only the first 5 characters of a SHA1 hash and the API returns a list of all hashes matching that prefix, and you can determine if your hash is in the list on your end.
Yeah I don't think they do tax rates. 
Instaregret. I’ve never regretted things more than offering free work. People are people and they’ll demand even more. 
I completely agree it’s a terrible idea but he’s not screwing anybody. It’s unlikely that he will build anything substantial or profitable for anyone for this to be a thing. He’s likely screwing himself. 
He's creating expectation for others that there will be some idiot willing to work for free. That is not ok.
The newsletter seemed interesting, until I saw [this article that you linked](https://medium.com/@henryw1990/top-10-ruby-on-rails-development-companies-ca3720d1bb5f) in the Aside section. It starts like this: &gt; Here is the best 10 Ruby on Rails Development Company for your business will be a giant pain if you have got no plan regarding the rating, market name and of corporations. thus we have a tendency to found wrote this text wherever we’ve got listed prime Ten Ruby On Rails development in Republic of worldwide. That whole article is written like that and is just nonsense. It seems that you include whatever you find in the newsletter without reading it yourself.
why? shouldn't you focus instead on the libraries that people actually use? like for example rspec has more or less replaced the in-built testing library, and `byebug` has totally replaced the crappy in-built debugger.
try a ``` rails db:setup RAILS_ENV=test ``` maybe? what versions ruby, rails?
There's a lot of cool things in dry-rb ( http://dry-rb.org ) like monads, pattern matching and transactions. https://github.com/solnic/transproc is a nice thing too
I love your RSpec articles! But this part is a bit weird for me: &gt; Avoid using be_truthy and be_falsey matchers ... So you may expect false or true to be returned but when something goes wrong and something else is returned then your test may not catch it. But these matchers are by definition, by name, and by documentation for checking against "truthy" and "falsy" values, not `true` and `false`. They are pretty useful for testing methods defined, for example, this way: def allowed? user&amp;.admin? end Without any user, this method will return `nil`, which will pass `be_falsey` but not `eq false`. One may argue that this definition is "better" somehow... def applicable? user.present? &amp;&amp; user.admin? end # Oh, good girls don't do ActiveSupport! # So, it should be even more "readable" def applicable? !user.nil? &amp;&amp; user.admin? end ...yet I beg to differ :)
Of course you are right. I wrote about it because I saw in many projects that `be_falsey` and `be_truthy` were used when the expected result was always `boolean` value. I will adjust this text to mention that `be_falsey` and `be_truthy` should be avoided when you expect only `boolean` value coming. Thank you for the comment!
I've also recently tried getting better at this. I'm trying out [this Udemy course](https://www.udemy.com/aws-certified-solutions-architect-associate/), just to get better (I've provisioned some servers on AWS before, but it was more like typing tutor, so I'm looking to understand each command and what it does).
Yeah I also think it depends on how many plugins you use. My experience isn't too bad with VS Code but then I'm a former Visual Studio user who learned to discipline himself and limit their number of plugins.
It will change the entire industry. 
It's still dangerous right? 1. If someone potentially know the list of password that might be used on certain IP Address, for first 5 characters I think the number will not be that many 2. If someone can harvest usernames from my site, e.g. github.com/karuna 
!! Ensures a boolean is returned, pretty simple to me. But yes, I agree not perfect, but stronger user typing will yield long term results. I'd probably go with user.present? &amp;&amp; user.admin? The safe operator brings a lot of laziness and adds a level of cognition that junior devs in particular struggle with
I don't know, I have at least 20 extensions installed.
Nope, I spend time to read each article that I include in the NL. That's why I also try to limit the number of articles into it. If there is only one article you dislike on 10, that's a positive ratio. isn't it ? Anyway, it was the first release of the "Aside" section. So thank you for your precious feedback. I'll be even more picky on the next issue for this section. 
Ha, maybe you are right. Every language struggles with optional nulls, look to Rusts &lt;optional&gt; for instance is my counter argument. Should admin? deal with null instead. The same argument could also be used about double bang You didn't engage with stronger user typing also. Dependable functions that return expected results will make for a much better experience 6 months from now when hit a bug because you got a null, or undefined, or empty string or zero instead of a boolean false
I agree with your point-of-vue. I've a [newsletter](http://ruby.devscoop.fr) where I share links and blogposts about the popular tools and gems. On medium, my mindset is to talk about ruby concepts and it's core libraries. Thanks for your pertinent question. :-)
What really helps me in reading gems is doing multiple takes. In the first take I usually don't even get a general understanding (except if it's a simple, focused gem), more often I understand just a small bit and pick up some clues where to go looking the next time. After a few readings things already start nicely falling into place in my mental picture. It's also good to decide which parts you don't need to understand, such as input arguments mangling. A well-refactored code which follows SRP makes it easier to ignore classes/methods that you don't need to understand. Which specific "bigger" gems are you having troubles reading?
&gt; a null, or undefined, or empty string or zero instead of a boolean false I believe that it is relevant problem for PHP with its vague "no-value" semantics, but not for Ruby with a really well-thought concept of truthy and falsy. There is exactly one falsy value except `false` itself, and it is "no value at all". For the sake of discussion, I could've try to invent bug that can emerge from mixed `nil` and `false`, but it would be to easy to prove that the code that relied on `== false` is MUCH worse than `user&amp;.is_admin?` :)
Javascript and python all have differing truthy and falsey values. Just force true and false and your life will be better
Active Storage sounds interesting too.
I'd say that your life will be better if you try just writing in a language you write and embrace its principles and idioms, and never try to invent average safe-enough sublanguage which could be written in PHP, Python, Ruby, JS, and VBA for Excel roughly the same way.
Is there utility in consuming every last detail in a large gem? I would ask yourself that before attempting to consume what is likely an insane amount of data. Some gems’ requirements have requirements. At that point, you’re reading layers of abstraction away from the original content, and are likely poring through mostly content that isn’t even being leveraged to drive the gems original purpose. Maybe stick to a specific and specialized part of a *project,* and leave the gem details out. Gems are just a packaging/distribution format/mechanism anyway. You seem to be approaching the prospect of project contribution from a strange angle.
The "Avoid using Model.new instead of stubbing" example seems odd. The api object should have been injected and thus easy to test.
For a second I thought I was reading [this](https://www.reddit.com/r/ruby/comments/84mdzc/speed_up_and_improve_your_rspec_tests_in_4_simple/)...
Looking forward to Azure support for Active Storage, since the company I'm at requires MS platforms.
Not in there I need much, honestly. But I'll upgrade all my stuff anyway, because that is the way of things. Oh, wait, something not mentioned in the announcement that excites me, is full `attribute`/ActiveModel::Type support in non-AR ActiveModel. The Rails5 attribute/type API is some good abstraction, that I think is gonna let all kinds of plugins and local implementations do cool stuff easily and in a way that works smoothly with existing Rails. 
Let's you check your secrets file into your repo, without it being a security concern. Why would you want to check your secrets/credentials into the repo? For seamless deploy of them, so you're version-controlling them with your code, and/or for a more sensible workflow for setting up new developers (or other new machines) -- just check out the repo, and get the master password out of band. 
I still don't get it. You still have to check the key out of the repo anyway, so why not just getting the secrets out of the repo anyway if you still have to leave the key out? Regarding version controlling it makes still less sense. For example, if someone leaves your company and you change your AWS keys and so on, then you want to manage those secrets outside of the repository so that you could deploy an older version with the new secrets rather than with the old ones that no longer work. Also, your deployment project should have its own version control system. For some new developer it also doesn't make much sense unless you want them to know the production secrets, in which case encryption doesn't help much either, right? I'm still missing the point case that justifies encrypted secrets...
&gt; You still have to check the key out of the repo anyway, so why not just getting the secrets out of the repo anyway if you still have to leave the key out? You mean "keep", not "check" right? For me, because exchanging a single password "out of band" is a lot simpler and more reliable than exchanging a big list of key/values. Especially because the list of key/values changes. Every time it changes, it's got to be redistributed to all places/devs that have it/need it. Or, if it's in the repo, they just pull and use the same master password they already have. Also, I like being able to _version_ my config/credentials with the code. Sometimes you change what keys/values you use in a way that needs to be coordinated with code, now they are both in the same repo, a particular SHA will have the code and the right keys/values for it. But, sure, how useful it is depends on what you're doing, it may not be for everyone! That's why I like it. Although I don't know if I'll use the Rails implementation, or continue using third-party solutions. 
great examples and insight. and one of the nicest simple things explanations of Liskov Substitution i’ve come across. 
&gt; You mean "keep", not "check" right? Right &gt; exchanging a single password "out of band" is a lot simpler and more reliable than exchanging a big list of key/values. Ok, I guess some people are just storing their secrets out of some repository, and in that case it's simpler to pass a single secret when they change rather than all secrets. I was having a hard time understanding this because all our production secrets are stored in a repository, but a separate one, that only those who deploy have access to. In that case getting the latest secrets is just a matter of "git pull". Also, there's quite some time I'm not using Rails and even when I did I approached configuration in a completely different way. I do now recall that usually people would spread their configurations over multiple Yaml files, while I use a single Ruby file to store all configuration in my projects. So, when people are used to this mess I can understand how an API that allows one to check out the secrets in the application's repository can make things easier from some perspective. However it would be much more complicated to run an older version of the application with the new secrets when using such approach. That's why I prefer to keep the deployment project as a separate one and the secrets repository as a separate one with special permissions. In that case I can't see any value in encrypted keys, but now I understand that this is not the usual approach with Rails projects and that maybe it makes sense to introduce such a feature for those projects. I just have that bad feeling about one including their secrets in the repository anyway, encrypted or not, but maybe it's just me.
You say you have that bad feeling about including secrets in the repo encrypted or not -- but you say you have them in a repo, just a different one! What is the benefit to you of storing in a separate repository? 
Nothing really. ActiveStorage is NIH, there have been redis cache stores for rails before (I don't get why this is better, so not excited yet), CSP has been available before as a rack-level gem (for all I know, this just means "rails lets you configure CSP in the configuration files), and I don't get the problem that credentials try to solve, at least doesn't sound neither granular nor 12-factor. I still didn't understand this early hints thing. For all I know you need a compliant proxy server. So no one (exageration alert) will use it in development, as I haven't seen many development setups with a reverse proxy set up. As for production, I didn't understand from docs yet how you can mark the assets that I want to push, so I assume one everything gets pushed, which raises a lot of questions regarding HTTP/2 server push benefits when pushing ALL assets, so I guess I'm also not going to use it on production. When will I use it then? Hopefully there will be performance benefits?
Makes sense. In my environments, there are only 2-5 developers, and they all have access to the production environment. This may not be uncommon. 
ActiveStorage doesn't have enough flexibility for me, I'm excited about using (third-party, not Rails) shrine eventually though!
In my environment it's usually just me, but I still have the secrets stored separately because it's a deployment issue rather than a development one. I use a separate deployment project so that I can change the settings and apply them to different revisions because the configuration is independent from the application. They could be included in the deployment repository itself or in yet another secrets repository. It wouldn't make much difference to the workflow. They are still accessible through a single Ruby file (which could import from other places using some sort of split configuration). It makes much more sense for me to manage the secrets from the deployment project rather than from the application's project itself.
Anyway, in your scenario, it seems that it wouldn't make any difference to store the secrets directly in the repository in clear-text since everyone in the team is supposed to have access to them, right?
I don’t see a ‘test’ section in your secrets.yml file.
&gt;I don't see Go eating Elixir's lunch, and definitely not Crystal either. These are both imperative style languages that offer something completely different than what Elixir / Erlang is offering. If you consider Elixir's lunch to be extremely niche, as in an absolutely tiny minority of apps that need a vast scale of concurrency (Discord as an example) that is at such a level that requires something better than what is available in Go, then yes they won't be eating Elixir's lunch. But if you go wider than that, then I hate to break it to you, but Elixir will very much be weighed up against things like Go, and from what I am seeing it is mostly coming out second best, which I guess is why if I read the output from the Elixir/Phoenix people it comes across as them being slightly obsessed with trying to attract Rails devs, I think they know that head on they are going to struggle so their best bet is to play the "better Rails" card.
&gt; Languages don't really die, fashion just moves on. PHP is probably dead too, but still runs a vast amount of the web. It depends how you measure 'the web', if you measure it by actual traffic PHP runs only a small minority of it, which is why the number of jobs for PHP relative to a language that is claimed to run 80% of the web is pretty low, as strangely enough Barry's Wordpress blog on cabbages with 5k visitors a year that has not been updated for 4 years doesn't generate much revenue or drive technology.
&gt; `== false` Could also be `foo.applicable? == b` with `b :: Bool` coming from some other system/parameter/user/whatever. `?` methods not returning a boolean are simply broken. 
Not true at all, PHP runs the largest amount of web sites, the languages that run the "vast amount of the web" are those that are most used for the largest websites that account for the majority of the traffic on the web, that is not PHP. Which is why the number of PHP jobs does not correlate with the percentage of sites run on PHP.
Can't you give early hints to nginx in prod without having it in dev? That's what I'd do. If your dev really doesn't match production (as mine does not), you definitely need at least a staging server to test such things on. 
Everyone _on the team_ is supposed to have access to them, but that doens't mean I'm comfortable sharing them in the repo. Someone could get unauthorized access to the repo. You could at a later date decide to open source it or want to share the code with someone else, and the creds are all in there (and once in git at all, they're probably hiding somewhere in history even if they aren't in any branch HEADs). (And actually all my repos are open source and public, so...)
I don't understand. Why would you want a secrets repository, which is supposed to be accessed by restricted people, to have its data encrypted? Where would you store the encryption key anyway?
One way is to use a debugger and step through the code. Another thing I tend to like to do is when I bring in a gem that will have a central role in my application is to write a wrapper for it. The more complex the gem, the more likely I am to wrap it That allows you to replicate its interface, and if "something happens" to the gem, you can use that wrapper to port to a replacement without having to modify large parts of your code base. The act of writing the wrapper (and sometimes extending functionality within that wrapper) often leads you to taking deep dives into the gem code. Since you'll have a "destination" in mind, it's easier to follow and understand that particular code path.
The thing about server push is that it doesn't solve a problem, in many cases making performance even worse. Many studies have been released about how you should not push all resources, how buffer bloat gets in the way, and how not supporting http caching out of the box makes server push a less than ideal candidate for most scenarios. The main case for server push is pushing assets which are on the critical rendering path. If this feature allows me to do that, great, if not, it's not something I'd want. If you notice, all those ifs don't play a role for dev, when I'm in localhost and cache is turned off. However, I do need to install a proxy, and get self signed certificates, and bypass browser warnings, just so I can have push in dev.
Have you seen these? - https://stackoverflow.com/questions/626333/embedding-a-ruby-interpreter-in-a-c-app - https://stackoverflow.com/questions/13796922/run-ruby-script-from-c-or-c-program 
I'm not sure what you mean? Literally how can you use that little bit of code in a Rails project? Well you can use it if you want to check if an object responds to a `:presence` method call. But surely that's not what you meant?
Early hint is useful but not very flexible when using with HTTP2 push Also crossorigin can't be set yet https://groups.google.com/forum/#!topic/rubyonrails-core/YJqsbX9sjs0
You were right! Thank you!
Example: I have legacy code that dynamically define method and it got conflict with activesupport's Object#presence
This still makes no sense whatsoever to me. You'll have to start at the beginning.
I'm with chrisgseaton - more info would be helpful. I can only make a wild guess that you're parsing json into a ruby object turning every field into an instance method on the object. If so, why hasn't this been an issue before since this is a legacy codebase? 
Just type "whatever.respond_to?(:presence)" What kind of question is this?
This was implemented recently after I raised a issue request and a member got onigregexp author make this feature available.
Do you mean that the `presence` method was overwritten on an object?
Every time I have done something like this I have used swig: http://swig.org/
This is fantastic. I know Ruby, plus a small number of Tagalog words, but the example Bato programs look so _foreign_ and hard to grok. A great reminder of just how much English keywords can be an impediment to learning programming for those who don't know the language.
I do, but the point is that sometimes there is a huge schema and the 1GB XML file that you get for initial import of data for a new customer uses only 30% of what's potentially inside the XML according to schema. Especially when there is an established format in an industry. So I wanted to see what's really there in a file :)
This is awesome. I had been considering trying to implement something like this myself, glad to have been beaten to it. I need to investigate this more, but it seems like it's entirely Rails/ActiveJob independent? While that's nice in some situations, for those in Railsland I wonder if there's a way to make it more ActiveJob-integrated. I would would to be able to tell it to use any ActiveJob-compatible queue as it's queue, for instance. 
The smallest result set from the 5 character hash prefix is 381. Notably that is the first 5 characters of the SHA-1 hash, not the password itself. The username isn’t sent, the password isn’t sent. I don’t believe it is dangerous. If you do, you can download the passwords yourself or just not use the service. 🙂
Yes, this library fully Rails/ActiveJob independent. I don't think what is a hard to integrate Qyu with ActiveJob.
I get that you needed a supported alternative to Resque but why build your own thing? You're a travel-industry startup, buy good tools and focus on your user. Sidekiq Pro is fully supported, Resque compatible and has a complex job workflow API, known as Batches. $950 and this problem is solved for you. https://github.com/mperham/sidekiq/wiki/Batches
Batches can be used to dynamically create workflows of any complexity and nesting. See these wiki pages for examples: https://github.com/mperham/sidekiq/wiki/Complex-Job-Workflows-with-Batches https://github.com/mperham/sidekiq/wiki/Really-Complex-Workflows-with-Batches Defining large workflows is complex but so is building your own system. And systems which define workflows with a static DSL invariably don't actually work in the real world. There are always cases where you want to conditionally add or remove jobs based on context.
cool. yeah, there reason why is because currently on the $9/m I did a quick dump of the database and ran a command to restore to a fresh local db as a test and it worked really well (I did have to upgrade my local version of postgres tho!)
There's also /r/Heroku , FWIW. This plan sounds logical to me. I think folks sometimes over rely on backups on plans that offer point-in-time rollbacks, but since you're sticking to our lowest paid plan you've got to do a little roll-your-own here to make a more advantageous backup schedule.
haha, I've definitely been there and maybe why I'm overly cautious these days and am wanting to do it myself where I can continually (well at reasonable intervals) just do a quick sanity check that the backups are in-fact recoverable. I'm hoping to not touch this application too much in the future so trying to get the safest "set-and-forget" type of deal going. 
I wonder whether I’d have the clarity of mind to approach this with TDD when faced with the time pressure. I probably wouldn’t, to be honest.
I don't have statistics on that I can share, but our availability is pretty great. IIRC they're both on our shared fleet and don't offer high availability (a replicated hot spare), so I'd imagine uptime is going to be comparable across hobby-dev and hobby-basic plans.
fair enough, I know you can't commit to specific but does this mean the application might be down for full day or are we talking maybe a few times a month it's down for a few minutes? 
“Matz said he had not decided on when to release Ruby3. If three critical points could get to a satisfactory level, he would name the version Ruby3. He used the Linux kernel development community’s approach as a reference. The three critical points are the following: faster processing, distributed computing, and static program analytics. If a new version can perform three times faster than the current version, handle distributed computing, and implement static program analytics, Matz will label it as Ruby3... Now, Mr. Koichi Sasada, a Ruby core developer, is working on a project called Guild. Although Ruby has threading implementation called Thread class, its performance of parallel execution is quite limited. On the other hand, Guild can perform parallel execution while avoiding the difficulty of programming such as lock and unlock controls. Resources: Presentation on Guild at RubyKaigi 2016 (https://www.youtube.com/watch?v=WIrYh14H9kA) Slides of the presentation (http://www.atdot.net/~ko1/activities/2016_rubykaigi.pdf). “ 
&gt; When you start implementing the simplest first `MOV`, you need to check that it works *somehow* What I mean is that you don't necessarily have to write the test *first*, which TDD is all about. Having tests let you sleep well at night. Whether you TDD or not, you should always have a decent test coverage. Your approach to testing is interesting. To me it looks like it goes slower first - as you have to memorize more matchers. After this period you can write tests a bit quicker. I see it as a detail to getting stuff done. I think it's more important for your team to agree on using one style than choosing the official RSpec style.
&gt; What I mean is that you don't necessarily have to write the test first, which TDD is all about. Yeah. In fact, there are several questions here: 1. whether or not write some "testing code" first (being it some test framework, or just `puts asm_eval("MOV 10, A").result`), before any implementation; 2. how to develop it: try to write entire asm interpreter from scratch without checking anything works, and then debug it; or implement it part-by-part, checking those. 3. how to implement tests, if any, how to structure them and so on. What am I trying to say, that "test-driven" approach is not on-off switch (and if you don't strictly write each tests before each part of the functionality, you don't TDD). I'd rather say that important approach is writing tests and _some testing/showcasing code_ more or less simultaneously than follow some strict "what should be first" guideline or "how to structure tests" framework. This way, it frequently _helps_, even in rush and limited timeframe.
Depending upon your use case [mruby](https://github.com/mruby/mruby) may be of interest.
Distributed computing is a form of concurrency, though I don't think guilds have much to do with distributed computing. Maybe the `Guild::Channel` API could have an inter-process implementation.
The code is way to complicated for you to be able to fit it into a whiteboard interview. I also think that the way I would approach it is to first model the vm that executes it and after that model the instructions as ways of mutating the machine state, This would lead to a leaner implementation and the tests can just compare the machine states.
&gt; Requirements: Ruby 2.4.0 or newer Why? 
I use memoist these days...
I think if I were faced with this problem, I'd have a slew of questions. First, how many registers does the CPU have? Are there other instructions not listed? The program says to jump to line 7, but there is no line 7, does this terminate the program? Is it intentional that the MOV instruction loads both from registers and intermediate value? How many bits is each register? Sometimes, interview questions aren't so much about the implementation but what you notice about the question. This question seems partially complete.
Imagine if any other language was developed this way. Imagine: There’s going to be a new version of Javascript. It’s going to be a big deal. But it’s waiting on one guy in Japan. We know a few things that’ll be in it. But it’s mostly mystery meat at this point. How would that go do you think?
Not all Filipinos speak Tagalog. What about those who speak other Philippine languages like Waray, Ilonggo and Cebuano?
Ruby is open source. There are ongoing discussions and code changes that you can read through and even participate in. 
Do they help you deal with cases where the execution of a job is asynchronous (because it’s calling out to an asynchronous web service)? In our case, we need a job to run once this asynchronous job completes.
[It's open source](https://github.com/jjuliano/bato) and doesn't look like too much to translate to those other languages. I speak Cebuano myself and would love to hack on this to translate it when I can.
Just my opinion below :-) I love Elixir &amp; use it in production for data related tasks, &amp; I also use Ruby. While concurrency is excellent with Elixir/Erlang, the raw speed is not always fantastic, and I've actually gotten better results in terms of raw speed with Ruby, compared to Elixir, in particular for CSV reading &amp; text processing (this was some time ago though, things have evolved on both sides since, but still!). I'm very happy with the current JIT work &amp; the global language focus on perf+concurrency: it's great that the designers of the language are now orienting their efforts in that direction. I'm personally OK with waiting on gradual improvements - it's hard to set a clear time frame for such things, where solutions are being tried out &amp; experimented.
It's not a mystery, you can see the code, you can follow online discussions, you can watch conference talks where Ruby core team members talk about the progress made. Also while Matz ultimately decides about the name of the release, features that are planned for Ruby3 are/will be released in earlier versions, like JIT that will be part of 2.6 release. So it's not that big features are waiting for Ruby3, it's that once the goals are achieved, next release will be called Ruby3
I take it that you haven't been keeping up with Elm. Version 0.18 was released in 2016 about the time that Trump won the election. The language is primarily developed by one guy, Evan, and the features for the next version are somewhat secretive. There have been multiple reddit posts in r/elm complaining about the long development cycle. So to answer your question, there will be some disgruntled users and the language doesn't suddenly die. 
Thanks for the feedback! You're right - I haven't listed all the assumptions we had before writing the code. Some of them I didn't think of. Others, because I didn't want to make this blog post too long. I can see that it yields high educational value. The next time I write something similar I will definitely keep your advice in mind!
Hi! (Bundler core maintainer here) You can specify a path to install your gems into that are isolated with the `--path` option, ie: `bundle install --path .bundle`(You can set this for every Gemfile with `bundle config --global path .bundle`, which i use and will be set by default in Bundler 2). I strongly suggest this method over `rvm gemsets` because you very often have to remember to make sure you're using the correct gemset which you can easily get lost in. But with Bundler you don't have remember anything and makes managing isolated gem environments a lot easier.
Checkout the 'singleton' module/pattern for a slightly better approach. http://ruby-doc.org/stdlib-1.9.3/libdoc/singleton/rdoc/Singleton.html https://dalibornasevic.com/posts/9-ruby-singleton-pattern You'll want to create your own wrapper class around instantiating the Redis object, the same way the Logger class in the example on the second link wraps around the open file object.
Having to reestablish a connection for every redis operation is certainly something you'd want to avoid. Sharing a single connection in a global variable raises all the same concerns global variables normally do, notably concerns about thread-safety. For that, I'd recommend the [connection_pool](https://github.com/mperham/connection_pool) gem. The examples there still use a global, but the connection pool protects the state of the wrapped redis connections by ensuring only one caller can be using that connection at a time.
I've come across Kafka in blog posts talking about being a data transfer mechanism for scraped data. I'm curious to learn more about Kafka, and I'm wondering if the following is a sensible use case, or if I'm thinking about it wrong... - Scripts distributed in the cloud load data in a page to scrape, such as with Mechanize or Watir - They are strictly responsible for grabbing the raw page data, or whatever minimum raw elements are required to do further processing (The E in ETL). - Send to Kafka, where a separate process can pick it up and handle parsing and the rest of the ETL chain This feels a bit over-engineered, but I could see a few benefits related to process safety in certain situations. It potentially cleanly separates the E T and L. I'm curious if when people talk about leveraging Kafka in a scraping environment, if this is the kind of workflow they are referring to, and given my blurb above, if people think it's worth learning more about.
I've deleted that last question that ruined my experience so now it exists only as screenshot. https://i.imgur.com/IHqFe7g.png You don't see it to be downvoted there only because there were some supporters that upvoted it later because of reading the flame thread in comments. But that flame is not specifically the important subject anyway. I've started this /r/ruby to ask about better places.
The blog post was also put on r/programming a day ago. But I think r/ruby is a better place for this. 
Great 3x3 article. FYI: Added "Towards The Ruby 3x3 Performance Goal" to the 3x3 article collection at Planet Ruby, see &lt;https://planetruby.github.io/calendar/ruby3x3#articles&gt;. Cheers.
Thanks you so much for you precious feedback. I agree with you that a big amount of gemsets can be a struggle to remember. But RVM provides the possibility to automatically set the version and the gemset for a speciifc project by using the `.ruby-version` and `.ruby-gemset` files. Here is a pretty [concise documentation](https://rvm.io/workflow/projects) about a typical project workflow.
&gt; I've started this /r/ruby to ask about better places -- places that don't have a shit to hit with my originally clean shoes. The tone of your question ("SO is (lot of offences) and /r/ruby is obviously even worse") sounded roughly like "hey, please show me where to find better people than you, dumbasses". The precise answer is ¯\\\_(ツ)_/¯
^ This is an example of leaving useless comments, flame instead of being useful. Thank you for being an example of what I was talking about.
You are welcome. We, useless shit, are very welcoming here.
If a business process is waiting on an external system, you'll need to get a callback, e.g. a webhook. That callback would then enqueue a job.
Well, I'll give you a purely technical answer first: yes, you can apply event sourcing to a single background job -- or "orchestration" of background jobs related to a single task -- without turning your whole system upside down first. There's a lot more to consider, though. I've worked on a lot of aging ruby projects that contain a litany of half finished improvement efforts that didn't amount to much more than another couple of extra entries in the Gemfile and some code whose maintainer left the company years ago. Things like migrations to or from rspec, attempts to use the "interactors" gem, rails engines, etc. all can be brought in on a whim and end up half finished. So, I'd only recommend you actually start putting event sourcing into your production code if you're prepared to see it through to some reasonable conclusion -- for instance, replacing *all* your background jobs so that you don't have some using resque/sidekiq and others using some event sourcing framework (such as mine). Regarding event sourcing being all or nothing... a lot of its benefits are only really going to outweigh the implementation cost when you reach a critical mass of subsystems having been migrated over. For instance, a bit benefit of event sourcing is the ability to write new reports today that include historical data. This is a profound advantage, but it really doesn't work when most of the data you need for your report exists in as-yet-to-be-migrated parts of your codebase. I never advocate teams jump in to event sourcing lightly, or "dabble" in order to get their feet wet. The outcomes just don't end up being worth it. This definitely costs us adoption, but I would rather have fewer adopters that tell success stories than many more who eventually said "screw it, event sourcing isn't worth it."
I see you are proud to be a part of it.
thanks!
Re terminology: I'd be worried about confusing with the `then` from promises, which is somewhat similar, but of course async. If you are using a ruby implementation of promises in your code, you might even already have `.then` use, two different methods, might not be obvious from the code which is which especially in non-statically-typed-ruby. 
For the `expected` method, what does `10**(rated_player/400.0)` mean? What does `10**(other_player / 400.0)` mean? Also `other_player` and `rated_player` do not feel like the correct variable names as it looks like it has to do with the rating. I would extract the calculations out to a private method with a more meaningful name. This will reduce the duplication as well as make the maths more clear.
You can refactor #provisional? to: ```ruby @players.any? { |player| player[:games] &lt;= PROVISIONAL_LIMIT } ``` With Ruby 2.4 or greater you can refactor #game_ended? to: ```ruby @players.sum { |player| player[:score] } != 0 ``` 
Fantastic work and progress so far. I do wish his benchmarks had included Ruby 2.5 so we could compare progress to the latest MRI release.
gems are tools, you gotta understand your tools if you want to be good with them -- or to diagnose/fix them when they aren't working right, or add features to them. But not all of them in all aspects all at once, true. But I think OP is exactly right to want to get into it. 
I actually initially had that calculation as a separate method and got a utility function smell for that. And then duplicate method call when that function was called severa times in the expected method. rated_player is the ranking for that player and other player is ranking for the opponent. And the method itself calculates the expected score for a player based on his and his opponents ranking prior to the game. Maths involved are explained [here](https://metinmediamath.wordpress.com/2013/11/27/how-to-calculate-the-elo-rating-including-example/). 
I think you should extract method refactor out a few private methods from #expected. Also consider #fdiv: 10 ** rated_player.fdiv(400) / (10 ** rated_player.fdiv(400) + 10 ** other_player.fdiv(400))
I like `then` a lot better than `yield_self`. I think a pipeline operator is idea, but I'd use the `then` alias.
I addressed this question in the [initial proposal](https://bugs.ruby-lang.org/issues/14594) about `#then`. I believe that this synonym will lead to clarity, not confusion: get(something).then(&amp;JSON.method(:parse)) # regular values processing get_async(something).then(&amp;JSON.method(:parse)) # future processing YMMV, of course.
I don't think any "operator-y" form will play nice. Formatted the way you show it is kinda OK, but what about this? construct_url ~&gt; (&amp;Faraday.method(:get)).body This raises a lot of question about precedence, parentheses and so on. Also, this version is impossible to backport, which for me is a huge disadvantage. In current production codebase, we run Ruby 2.4.2 and already using `yield_self` via `backports` gem (and can switch to `then` with simple search-and-replace, without switching Ruby version). 
 Thank you. I'll try to get this comparison for RubyKaigi2018. I need to merge trunk with MRI branch for this which is not an easy job as a lot of changes happened on the trunk for the last year. Still I can make an evaluation. The biggest performance improvement for CRuby 2.5 was a removal of trace insns by Koichi Sasada. It gave about 10% performance improvement comparing to CRuby 2.4 on which MJIT branch is based. So in worst case scenario you can substract 10% from MJIT. In reality I think the results will be the same, as MJIT merged with the trunk will also benefit from Koichi's work. More interesting comparison would be with MJIT currently in the trunk (Takashi Kokubun's work adapting MJIT for the current stack insns). I hope to have these data for RubyKaiagi2018 too. 
I don't see how that improves clarity. First, promises are not part of the Ruby language so the async comparison doesn't even exist. Second even if it did exist in some future version of ruby, one of the problems with syntax examples like this tends to be that they are unrealistic or only realistic for a minimal use case. In practice the `get_async` call could occur several layers of callstack away from the call to `then` at which point there is no clarity whether `then` is an async `then` or a sync `then`. 
&gt; there is no clarity whether then is an async then or a sync then. But that's the whole point, probably? Like duck typing and stuff. It quacks as "next step of processing", you apply the next step of processing. You can pass to the same `.then`-structured method direct value, or promise, and it will return processed value, or promise with next transformations gathered.
&gt; This raises a lot of question about precedence, parentheses and so on. It reads like x ~&gt; (y.body), while meaning (x ~&gt; y).body . I think your example is a bit off but as you've written it, what would be the difference? &gt; Yes, but is the only thing since, probably, Ruby 2.0? Keyword args, keyword args without default, probably several others I'm not thinking of. &gt; Also, ~&gt; { foo } is too close to -&gt; { foo }, while meaning completely different thing. Ok, `|&gt;` is a similar operator used in several functional languages for `pipe`. I'm not terribly tied to the exact syntax here, mostly interested in the 'operator vs method' aspect. 
I don't think you can, or should, duck type async vs sync operations.
&gt;&gt; This raises a lot of question about precedence, parentheses and so on. It reads like `x ~&gt; (y.body)`, while meaning `(x ~&gt; y).body`. &gt; I think your example is a bit off but as you've written it, what would be the difference? construct_url ~&gt; (&amp;Faraday.method(:get)).body ~&gt; &amp;JSON.method(:parse).dig('object', 'id') My eyes "parse" it this way: construct_url ~&gt; ((&amp;Faraday.method(:get)).body) ~&gt; (&amp;JSON.method(:parse).dig('object', 'id')) While the "real" structure is this: ( ( construct_url ~&gt; (&amp;Faraday.method(:get)) ).body ~&gt; &amp;JSON.method(:parse) ).dig('object', 'id')
I think the idea is that the concept of `then`, "pass value of self to block and then return it's value," applies the same whether it's a plain value or an async one. The point is that your code wouldn't have to care if the values it was working with were sync or async. I don't know if that fully makes sense in practice, but I see the appeal of it. Also, there are promise libraries for Ruby even if they aren't part of stdlib.
Doesn't that evaluate to the same thing?
I don't really know how to respond to that. Why do you think they should duck type? If I create an abstraction that expects what it is passed to respond to `then`, am I allowed to return a `Promise`? If I am, what happens? Does the top most `get` magically become async?
Strong disagree. Ruby’s evolution should not be constrained by the design decisions of another language, particularly not the dumpster fire that is JavaScript, nor by the choices made in third party libraries. 
&gt; I don't really know how to respond to that. That's exactly what I've meant :) I am not convinced, I see no further way to convince you, let's agree to disagree. &gt; Why do you think they should duck type? In my head (probably high on architectural astronautics), the whole point of promise idea is to turn nested callbacks hell into value objects. So, for me, it feels perfectly natural if at some point we have "immediate" computation chain, and at another point, we have the same structure representing promise computation chain. The interesting example here is `Enumerator::Lazy`, where you can attach `.lazy` in some _enumerable_ computation chain, and what you'll have after applying lots of `.map` and `.select` after that is in fact pretty close to Promise: encapsulation of sequence of computations that are not yet performed.
Here: https://pastebin.com/LpDta3a0
&gt; That's exactly what I've meant :) I am not convinced, I see no further way to convince you, let's agree to disagree. I don't find that to be a productive way to move forward. How about we explain our positions to each other? &gt; The interesting example here is Enumerator::Lazy, where you can attach .lazy in some enumerable computation chain, and what you'll have after applying lots of .map and .select after that is in fact pretty close to Promise: encapsulation of sequence of computations that are not yet performed. I don't see the comparison, when you apply `lazy` you still get an `Enumerable` at the end of the day. When, somewhere in the middle of a chain, you return a promise that means the end result is a promise which has a completely different API than a value. 
Ah, yea that could be an edge case and can see the confusion. Probably I'd not allow this case (if it were up to me) and require that `dig` was also chained via the operator.
Chiming in here. I'm a mod. In this case /u/zverok_kha is trying to be helpful, even if the advice is painful. The one major difference between Rubyists and most other general programming language groups I've interacted with is that we're much nicer (on average) but also that we demand reciprocal treatment. We generally aren't nice for the sake of nice, we're nice because other people are nice to us. I will say that this is on average, and there will always be outliers. SO in general is a bad place to have a conversation but a good place to ask questions if you ask them in a very specific way. Learning to ask for programming help is like learning a new language, there's a syntax and a structure and it takes time to build up fluency. I've been doing this for 10+ years and sometimes I mess up with my phrasing when posting questions sometimes. /r/ruby is generally not used for specific programming questions, but instead conversation about the community, links to blogs, links to conf talks etc. Conversations can get heated because they're less technical and more ideological. If you see someone behaving like a tool here, kindly ask that they clarify their intentions, if they show you to be not altruistic call them out as such, but without stooping to their level. More often than not the bad actors will be downvoted. 
I appreciate the errors this prevents, having just accidentally pipelined the wrong variable half way down a pipeline and spent an hour troubleshooting the typo. But a better question is why use the naive no syntax sugar classic approach? What does yield_self lose me? A: Debugging. If I assign a variable every step of the way, I can easily set a breakpoint or add some debug printout. Sadly aesthetically I don't like it. Generating those blocks is ugly and requires a deeper knowledge of ruby than the naive approach. KISS.
Good coverage. I was hoping for more comparison about how the process of moving to RTL will fit in with the current JIT implementation that is in trunk. I'm also curious if optimizations done now will still be valid if/when RTL is merged in. 
I apologize to /u/zverok_kha for my tone. His exact comment was not offensive or hurting. I'm just ran out of patience with all this.
But it's not like yield_self is exactly like `then` from promises but without async. `then` from promises also has a an error condition path. If you made a non-async non-concurrent `then` that was exactly API compatible with promises... well, with some promise implementation... it would be nice if we had a standard one in ruby... maybe from ruby-concurrent... anyway, if you did that (with an error condition path too), you might have a stronger argument for using the same method name for something just like promise-then, but not async. 
except promises have an "error" path too, raising an exception (or however else error condition is signaled in whatever promise implementation) can be caught and handled/transformed by other things down the line in the chain. That is not true of raising and yield_self. So I'm not sure it's true that your code wouldn't have to care if it was being called in a sync or async context. 
&gt; I think the idea is that the concept of then, "pass value of self to block and then return it's value," applies the same whether it's a plain value or an async one. No, it doesn't. The `value` is either an actual value object, i.e. everything you're used to as a value in ruby, OR it's a promise, in which case the entire chain becomes async and you need to wait for resolution all the way up the chain. You can safely return values in already async call chains, you can _not_ return promises in a non-async call chain which breaks any attempt at duck typing. 
That's not the edge case. The whole point of `yield_self` is chainability. some_parts .map { something } .reject { something } .join('|') .yield_self { |str| "(#{str})" } .yield_self(&amp;method(:some_method_returning_hash)) .transform_keys(&amp;:to_sym) I don't see any operator-y approach to playing nicely here.
`.` is an operator, it's shorthand for `.send(:name, ...)` so I don't really get your position.
&gt; If I assign a variable every step of the way, I can easily set a breakpoint or add some debug printout. It can partially be addressed with the same chainability: .then { something } .then { something }.tap(&amp;method(:p)) .then { something }.tap(&amp;logger.method(:info)) Debugging breakpoints (and especially "go to next step") is harder, I agree. BTW, there is a [proposal](https://bugs.ruby-lang.org/issues/14609) in Ruby tracker to allow this: .yield_self { something }.p # prints value and returns it .next_step 
I'd agree `yield_itself` is a bit unfortunate pick and does not fit to original naming style in core and is unnecessary verbose. On the other hand, `Object#then` is quite illogical, not descriptive and confusing. It has nothing to do with code execution flow. It just passes calling object to a block argument, nothing else. It is a block-receiving variant of identity function (ehm method). It should be only another form of `Object#itself` like common in core methods, not polluting with another separate name to make things more complicated. However it was not well thought-out and damage is already done, like other hasted changes in recent years. It looks like original Matz's ideas and concepts are losing their grasp …
I haven’t been following elm, no, and I’m not suggesting Ruby’s going to suddenly die. Python has one guy, but they have the whole ‘pep’ thing. Maybe Ruby could do with something similar?
*Waits with bated breath for next word from on high*
Im freelancer too and some time ago I've switched to bundler, chruby and ruby-install. Its 4 years since that decision and not missing RVM.
What's wrong withv implementing a pipe operator?
Great response. I was wondering if you had any ideas off the top of your head how you would begin to rewrite this code. I'm dealing with a similar issue where the process goes something like this: 1) make customer and subscribe them via stripe api 2) save the customer token if that's a success 3) if it's not, dont 4) if db transaction goes wrong notify me/clients via sever log, slack notification, email etc. and try to undo subscription via api
Sounds like a project for you!
I seem to recall trying it but I couldn’t get it to work on autosave but if that works I’ll definitely have to try again.
Wouldn't read too much into it, every language is on that list.
yeah I see like Java, PHP, C, C++, HTML, CSS, Perl on there. 
As Redis is a single threaded, is it ideal to write singleton and run on a web server that will be call by urls?
[removed]
SO (and the general dev community) has a heavy bias towards Python, and when you're used to the Python way of doing things, Ruby just feels awful to use and vice versa. 
&gt; This can help in a sense like making quick and dirty features or even enable some easier specs but I feel a lack of confidence when I write Ruby code, a feeling I don’t have in more type safe languages. If you don't feel safe writing code without type safety, you're probably not writing correct code _with_ type safety. With the right kind of practice, anyone can write robust code in Ruby.
&gt; I feel a lack of confidence when I write Ruby code Do not blame dynamic languages for that. Sure, they are not perfect, but if type safety is really an issue in your code, you are doing something wrong.
There are two kinds of languages: Those which everyone hates, and those which nobody uses.
It's not that I'm incapable of writing correct code, but it's a time tradeoff. For example if I make certain types of mistakes in Elm or Haskell, I *know* the compiler will catch it. On certain low-risk projects this means I can quickly identify an issue, make sure it compiles and push out the code with a high degree of confidence that everything's fine. In Ruby I have no such guarantees so it takes more time to realize that correctness has been achieved. But as I said, that trades off with doing things like quicker prototyping, which is why I haven't abandoned Ruby entirely.
I couldn't disagree more. A good compiler can check for many types of correctness, making both writing and refactoring code easier. My experience writing Elm/Haskell code for more complex features is a world apart from writing complex features in Ruby. * Making sure you're handling every nil/Maybes case. * Case statements on enums. If the enum changes I know that I can catch any code that doesn't cover that case. * Accidentally using the wrong variable in the wrong place. This may seem trivial but the compiler catches it before it ever becomes a problem. In longer running processes this means I don't have to wait to get a runtime error. But as I have mentioned in my other comments, this can be a tradeoff at times which I why I still use Ruby. It's not so much "blaming" dynamic languages as it is pointing out tradeoffs.
Start small. The best way is to find a small gem, clone it, run the tests, step through it. You should pick a gem that has a low enough LoC for you to fit the whole thing in your head. If you don't know how a gem is is supposed to work then try writing it yourself. Seriously! If you don't know how auth works then you would be best suited to trying to implement it yourself and learning the core technology and techniques. Similarly for testing, APIs, etc. You focus on learning the "why" and then the "how" because a lot easier to figure out. Learn common patterns. Well-designed gems follow common conventions both in structure but also the abstractions. Servers act like servers (fork-based with preloading for copy-on-write or threaded). Caches act like caches (stuff gets added and expired). APIs act like APIs (need to deal with pagination, probably using REST, authentication, headers) Learn Ruby really well. The more Ruby you know the better, particularly with more complex gems like testing frameworks which do some seemingly odd things at times Learn the Linux interfaces. If you are dealing with processes (e.g. foreman) then you'll want to make sure you have a good grasp of working with them. Experiment, try things And lastly - ask for help! As someone who has released multiple gems, I would bend over backwards for someone who showed interest in learning about and contributing to what I've started
&gt; No quick code formatting tool that I can run when saving a file. Rufo. I haven't used it with sublime but [there's a package for it here](https://github.com/ruby-formatter/sublime-rufo). &gt; Performance &gt; No type safety. 
Thanks I'll check that out. And yeah I heard about Crystal a while back but maybe it's time to take a closer look
I've spent the last week rediscovering the fact that *not* doing DDD/TDD just slows things down. I spent 3-1/2 days hacking on a "simple" bit of code that grew from one, to two, to eight classes as my understanding of the task grew. Changes quickly became a game of Whac-A-Mole against all the corner cases. I threw away the code and (minimal) tests I'd written, spent a day writing up a ubiquitous language (what he refers to as a Dictionary) and writing a slew of (stubbed) tests documenting states and transition effects. Going from all-yellow to all-green on the tests by writing code took half a day. I've been doing TDD of one sort or another for 15 years now, and I still fall into the trap of thinking "I don't have time to sit and think things through with tests." That **invariably** winds up consuming more time and stress than if I'd gone and done The Right Thing from the beginning. Being able to write code fast is nice. Being able to write code that actually does what's appropriate is a bare minimum. Being able to write good code fast, so that you and others can understand it later, is what separates the tyros from the craftsfolk.
I agree with your criticisms. There are a lot of things I really hate about Go, but gofmt is key when a lot of people are touching the same codebase. Ordering your imports, and requiring that all of them are used is great. (Not being able to temporarily comment a line out without running into the dreaded "declared but not used" is going too far though.) I also agree that a lot of the checks that compilers do are very useful. A good linter can catch a lot of those cases, but in that case compiler is effectively a very thorough linter you are forced to use that has certain linter settings that you can't change. If Ruby were packaged with a linter that ran by default and that had sane default settings, that would go a long way towards making it feel a lot more safe when dealing with complex programs. Ruby is currently great for thinking about a problem and poking at it. It allows you to move very quickly and be very expressive. Where it starts to fall down is for big projects involving many people and many modules. Not only does the performance impact start to matter, the lack of type checking leads to bugs that are much harder to debug than the equivalent compile time error you'd get with many other languages. I hope Ruby 3 helps with some of this, but fundamentally I don't think Ruby will ever be much of a threat to a lot of other languages that are less programmer-friendly, but more large-team and large-project friendly. 
I agree with your criticisms. There are a lot of things I really hate about Go, but gofmt is key when a lot of people are touching the same codebase. Ordering your imports, and requiring that all of them are used is great. (Not being able to temporarily comment a line out without running into the dreaded "declared but not used" is going too far though.) I also agree that a lot of the checks that compilers do are very useful. A good linter can catch a lot of those cases, but in that case compiler is effectively a very thorough linter you are forced to use that has certain linter settings that you can't change. If Ruby were packaged with a linter that ran by default and that had sane default settings, that would go a long way towards making it feel a lot more safe when dealing with complex programs. Ruby is currently great for thinking about a problem and poking at it. It allows you to move very quickly and be very expressive. Where it starts to fall down is for big projects involving many people and many modules. Not only does the performance impact start to matter, the lack of type checking leads to bugs that are much harder to debug than the equivalent compile time error you'd get with many other languages. I hope Ruby 3 helps with some of this, but fundamentally I don't think Ruby will ever be much of a threat to a lot of other languages that are less programmer-friendly, but more large-team and large-project friendly. 
I don't understand why something like `|&gt;` couldn't be used? As far as I can tell, `|&gt;` is invalid ruby (or greater than? Doesn't GT have an arity of 2?), so its free to be repurposed. Elixir got it from F#, there's no shame in borrowing it.
Can't you just do `.yield_self { |x| p x; x}`?
StackOverFlow jumped the shark ages ago. 
Yes the size of the team you're working on is such a huge factor in whether a programming language is a good fit. This probably won't be a popular opinion here but I wouldn't want to work on a Ruby project with a large team again. We had many good developers but enough bad developers to make things a total nightmare, but even worse we were working in a codebase that historically had been developed without much thought. Refactoring anything was totally unsafe because there were lots of uses of send() and sometimes even uses where there were no rules about what string or symbol would get passed to it. This meant that the `private` keyword meant basically nothing. That being said the Ruby projects I manage now are very tightly overseen and written from scratch so we're able to avoid those problems and still benefit from the prototyping that you and I are both talking about.
In Elixir, `|&gt;` is a primary method of chaining operations. In Ruby, _method chaining_ is a primary method of chaining operations. Look at this code: some_key .yiel_self(&amp;DB.method(:fetch)) .split('|') .reverse .map(&amp;:capitalize) .yield_self { |array| [BEFORE, *array, AFTER] } .to_yaml .yield_self(&amp;File.method(:write)) In Elixir, this will look somewhat like this (note that our `String#foo` and `Enumerable#bar` methods also go into pipes): some_key |&gt; DB.fetch() |&gt; String.split('|') |&gt; String.reverse() |&gt; Enum.map(...) |&gt; (fn(array) [BEFORE, *array, AFTER] end).() |&gt; YAML.encode() |&gt; File.write() In Ruby with "shamelessly borrowed" operator, it would be -- what?..
&gt; I don't really get your position. My position is: playing nice in chains of other method is PRIMARY `.yield_self` responsibility, not an "edge case"
That's true, and elixir has even stronger forms of "chaining" (i.e. when clauses). I guess the whole debate breaks down on what level you want the abstraction to be. Do you want it to be about method chaining, which ruby already has, or do you want it to be about invoking anonymous functions in a chainable manner? Personally, in the few projects I use it in, I just alias `yield_self` to `pipe`. But i've found myself writing more and more elixir, at both work and on personal projects, so I haven't had to do much ruby lately
https://www.reddit.com/r/ruby/comments/86lqsw/more_yield_self_awesomeness_also_the_new_name/dw7dbb1/
And Python.
This comes from the [The Designer’s Code of Ethics](https://github.com/mmmonteiro/designethics/blob/master/en_US.md), but is perfectly applicable to developers. &gt; You are part of a professional community and the way you do your job and handle yourself professionally affects everyone in that community. [...] *If you work for free, the designer behind you will be expected to do the same.* [...] A designer seeks to build the community, not divide it. https://github.com/mmmonteiro/designethics/blob/master/en_US.md#a-designer-is-part-of-a-professional-community
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mmmonteiro/designethics/.../**en_US.md** (master → 7a7e70f)](https://github.com/mmmonteiro/designethics/blob/7a7e70fd1f2e0f3f274ac5583796285bd9f31009/en_US.md) * [mmmonteiro/designethics/.../**en_US.md#a-designer-is-part-of-a-professional-community** (master → 7a7e70f)](https://github.com/mmmonteiro/designethics/blob/7a7e70fd1f2e0f3f274ac5583796285bd9f31009/en_US.md#a-designer-is-part-of-a-professional-community) ---- 
You can buy some cheap vps, install there ruby and access it using SSH client for iOS. 
Take a look on online REPL for ruby: https://repl.it
[Try Ruby](http://tryruby.org) will give you a very quick and basic introduction to the language. [Ruby Monk](http://rubymonk.com/) has more detailed and structured interactive lessons, though the site itself is not working for me right at the moment.
Imho both Python and Ruby are very nice to work with. Frontend with TS is also a very enjoyable experience. PHP is probably the only mainstream language i absolutely loathe to work with.
There are services like https://aws.amazon.com/workspaces/. Or buy a cheap used thinkpad as a second machine. 
yepppppppppppppppp!
Python fits both.
There are many apps to learn the basics of ruby, like SoloLearn. 
Do you track errors in production? If so, I encourage you to take a look at the exceptions being raised in your application. For us it's currently about 40% type errors and 40% external services failing where we didn't handle the exceptions properly. Besides that anecdotal evidence, here's a list of exceptions delivered to honeybadger ordered by frequency: https://www.exceptionalcreatures.com/bestiary.html the first 4 are all type errors.
What team size would you consider "large"? I have the same experience, but with code size as the metric. At one point refactoring becomes so scary, that you just won't do it.
Or you could try some modern tools over glorified text editors, like RubyMine. Which also has rubocop integration built in...
40% type errors in Ruby? And I'm assuming you are eliminating NilClass errors from this. I see only one thing in that number - poor code quality to be honest. The errors listed in your link and are common though with more junior/less experienced engineers, can't argue with that. Overall you are right, type systems try to help you to point the gun away from your feet. If you already know not to do that, it's less useful (purposefully ignoring compiler level performance etc.)
You will have this same problem with any language, this is not a language problem but a code quality problem. And it's going to be even worse in JS for example - the language structures themselves are different and the barrier of entry is much lower.
With enough experience there shouldn't be any new language-specific problems (e.g. "how do I keep mutable global state thread-safe in XY"). So the only limit to your productivity is the amount of characters you need to type to solve a specific problem. Ruby probably still wins, but not by much.
So teach the team to write better code then. Don't blame the language?
&gt; And I'm assuming you are eliminating NilClass errors from this. I'm not, these are obviously type errors. `NilClass != TheTypeYouExpected`
Sounds like a very challenging task for someone looking to just start learning ruby. 
It's likely that ruby is being installed without the documentation. To confirm: ~/code/ruby/se &gt;ruby -e'p RbConfig::CONFIG["configure_args"]' " '--prefix=/Users/sshaw/.rvm/rubies/ruby-2.3.5' '--with-opt-dir=/usr/local/opt/libyaml:/usr/local/opt/readline:/usr/local/opt/libksba:/usr/local/opt/openssl' '--disable-install-doc' '--enable-shared' 'CC=gcc'" In this case, you can see the option `--disable-install-doc` was used. If I recall, you can override this with rvm with this: rvm install VERSION --enable-install-doc 
And 👍for using `ri`. I used to do [this](https://github.com/sshaw/dotfiles/blob/638756ad494ea3c0c19c3d82b26903ae543b48ce/bashrc#L262-L280) with `ri`. But now I just go to rdoc.info (which is often 500s 😁) or www.ruby-doc.org (and practically *never* StackOverflow 😉).
If you want an online interpreter you can also try https://c9.io. AWS also has a Cloud9 offering but I’m not sure it’s the exact same. 
Hello, I've put together - bitcat - a little sinatra web app (e.g. [bitcat/app.rb](https://github.com/openblockchains/bitcat/blob/master/lib/bitcat/app.rb)) in ruby packaged up as a command line tool that lets you browse your digital bits(s) eg. crypto kitties and friends unchained (offline) using a single-file SQLite database eg. kitties.db. Note: Bitcat includes the gene reader from copycats in base32/kai notation and more. Happy collecting. Cheers. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [openblockchains/bitcat/.../**app.rb** (master → fa199b1)](https://github.com/openblockchains/bitcat/blob/fa199b1793cd289cbfce6b1d7896bff46e8f1f7a/lib/bitcat/app.rb) ---- 
The team was around 8 developers, 3 designers, and the project was over 6 years old. Not a very large team or project by any means. I agree that code size and number of features is a better metric. We found it to be very difficult to onboard new teammates and developers without Ruby/Rails experience. Some of the pain is from Rails, some from Ruby. I have enjoyed working with Ruby and Rails with extremely disciplined teams. That discipline is very hard to maintain and even harder to teach to an existing team. 
I've had similar experiences, of course, but I find that most of the troubles come from inexperienced developers who also make messes in JavaScript, databases, systems they try to architect, etc...
The best answer I can give is event sourcing. Unfortunately, there's quite a bit more to learn on that front than can fit in a reddit post. I'd look into Greg Young's talks, first and foremost. And here's a shameless plug: I cofounded a framework called eventide, which is designed for building autonomous, evented microservices, which you can find here: https://eventide-project.org
I think this is part of why the ruby community is so big on tests. And yes it is a benefit of static languages and languages without side effects that it isn't as problematic. But good test coverage makes a refactor much less worrisome.
Get back to us after you have used another language for some years, and have worked on a project that's over 6 years old, with a large team. :)
It is sad to me. I think a lot of is that python has become more popular. And some of it is people wanting to move to "grass is greener" new shiny things, like crop of newer statically typed functional languages. 
Nice I didn't know about rufo. Have you used it at all? (You say you haven't 'with sublime'). Curious to hear about anyone's experience with it, and if anyone is using it regularly, and how. 
How about something like https://devdocs.io/ ?
Yeah, I use it with VSCode. It works great - fast enough that I can have it auto-format on save without slowing me down.
Some people prefer dynamic languages, some prefer static languages. A smart compiler can make a static language feel more dynamic, like F# for example, but it's just a different way of thinking. Well designed OOP can take you far. I still feel like `nil` should be avoided in your code though, but types are not necessary for that. &gt; My experience writing Elm/Haskell code for more complex features is a world apart from writing complex features in Ruby. Looks like you are writing not confident Ruby code. That's actually a very common issue, especially for devs which come from static backgrounds. I recommend giving Avdi Grim's [Confident Ruby](https://www.amazon.com/Confident-Ruby-Patterns-Joyful-Coding-ebook/dp/B00ETE0D2S) a shot. &gt; Also even if you can write good code, that doesn't mean you or others around you will. Sometimes having tools enforce rules for you can be a good thing. That is true, but you can write bad code in any language. Every language has it's advantages and disadvantages. You might not make nil-related errors but you will have hard-to-change code. Code which needs a big chunk of context to be understood before you can change it, or add to it. The single responsibility principle is easily broken in many languages.
First of all, why are you taking an array, if you want it to be exactly 2, that can fail if you pass a single player too. ```ruby def initialize(players) raise ArgumentError, 'Only two players allowed!' if players.size &gt; 2 # ... ``` ```ruby def initialize(player1:, player2:) @players = [player1, player2] # ... ``` Then ```ruby player[:previous_rating] ||= DEFAULT_RATING player[:score] ||= DEFAULT_SCORE ``` That belongs to the Player class, looks like Player is a Hash, it really should be a class. It looks like this class is doing a bit too much. Maybe you can make a few smaller classes here. Maybe make an ELO value object which knows all the calculations for ELO, and then have this class use that one. Also avoid using instance variables directly, it's safer to use `attr_reader`.
This is reflective of my experience as well. I don't think Ruby does a good job of guiding the developer towards error cases. You also have to be extremely disciplined to check for nil and it's not always obvious when that's the case. 
For me, Ruby makes it easier to get a project off the ground but harder to refactor and add features over time confidently. Alternatively, a very safe language like Haskell is more difficult to get things working initially but when I make a change I have a high degree of confidence that I haven't broken anything and it's going to do what I expect. ¯\_(ツ)_/¯ just my personal experience.
&gt; Some people prefer dynamic languages, some prefer static languages. A smart compiler can make a static language feel more dynamic, like F# for example, but it's just a different way of thinking. Yes I've wanted to give F# a try for some time as I've heard many good things about it. &gt; Looks like you are writing not confident Ruby code. That's actually a very common issue, especially for devs which come from static backgrounds. I recommend giving Avdi Grimm's Confident Ruby a shot. Yes I'm a fan of Avdi's stuff and it definitely helps you develop better ruby. &gt; That is true, but you can write bad code in any language. Every language has it's advantages and disadvantages. You might not make nil-related errors but you will have hard-to-change code. Code which needs a big chunk of context to be understood before you can change it, or add to it. I agree you can write bad code in any language, but some languages won't allow you to make certain types of mistakes. As far as changing code my experience has been that it's easier to change/refactor code in languages that give you all sorts of guarantees like private functions in modules, enforcing the way you handle types, knowing which functions are pure and impure, etc... I feel much safer refactoring code when the compiler won't let me make those mistakes than when I have none of those guarantees.
&gt; Performance, particularly concurrency. Ruby 3 should be at least 3 times faster than 2.5; we should see a better concurrency model with Guilds. &gt; Even things like waiting for my development server to start up eat away at my patience throughout the day. Why are you not running Zeus/Bootsnap/Spring? &gt; I do use rubocop but have to run it manually since there doesn’t seem to be any good plugin for Sublime. I use vim so I've no idea why it might be difficult in sublime; perhaps take some time and fix your setup? &gt; No type safety Its duck typed; type systems are not a panacea and it can be a joy to be freed from the limitations. This IS one of the focuses for the language mover towards Ruby 3 though, although as I understand it, it will be some form of 'type adviser' rather than constraints. 
On a large project, management, culture, people, architecture, and design, are often far larger deciding factors of project success over language. I've worked on projects with more languages than you can shake a stick at and I can think of only one where the project failed in part due to the choice of language ... and even then the larger reason was that no one had planned for how a large feature using language X would be supported in a company primarily using language Y.
You can learn ruby using codewars.com and devdocs.io. If you are ok without any hand-holding. Personally I would never program on a touchscreen device. The ui for text entry and editing is just too shit.
I wonder how much this is Ruby, how much this is Rails? 
Python is used far more widely than Ruby.
Java is far more widely used than Python... So Java is better than Python?!
Nice gem for a common use case. I often run `(something.methods - Object.methods).sort` for finding what methods are available, and `something.im` would be much simpler. The docs for getting it running in pry and irb automatically are also useful. Your screencast shows exactly how I've worked with new gems for years now. So it probably won't be much use to experienced users. However it would be useful for newer users who are unaware how powerful ruby's self introspection is. A couple of pry tricks I think should be mentioned with regards to this style of development: show-source ======== `show-source` lets you see the code of the method in question, e.g. `show-source Geocoder::Calculations.distance_between` shows the ruby source for this method. It even works with methods implemented in c (like `'this'.length`) showing the c source code edit === `edit` lets you quickly edit a method. After editing, the method is instantly updated. For example, with a file `test.rb`: class TestClass def func "hello" end end In pry: &gt; load 'test.rb' &gt; t = TestClass.new &gt; t.func "hello" &gt; edit t.func At this point the default editor will open, with the cursor on the start of the `func` method. Change the return to `goodbye` &gt; t.func "goodbye" 
The project was and is still successful. Doesn't change my opinion about my desire to use Ruby again in the future. 
Good job, mate! 
It's going to take you longer than a weekend to "learn Ruby". Why not just read a book and wait for your MBP to come back?
Without reading the eventual solution i decided to try to implement this logic without putting a second thought to code quality. This is what i came up with in couple of minutes. https://pastebin.com/uqe3XtsA Probably worth mentioning that i am no Ruby magician yet.
I'd just like to be able to use the documentation that's bundled with Ruby, and always available locally, without discovering I don't have what I need when I'm offline.
If you're already in pry, what does this offer over the built in "ls" command in pry?
I’m not sure I follow. Even in irb you can call MyClass.methods.sort
The Ruby website is a reasonable place to start https://www.ruby-lang.org/en/documentation/
If you look at the sidebar or wiki, there should be plenty of books and project ideas listed - or linked in some cases.
Awesome. I'll check it out, thanks. :) 
Part of my problem is I'm still just getting comfortable with Rails. Anything outside of my tutorial experience is foreign to me because I don't fully understand programming and how to build things like a game or any other little programs. Looking at other gems is a great idea though, find a simple one and try to replicate it would be his. Thanks! 
Haha, as soon as I posted this, I thought "I should probably look at the sidebar." I remember other people from various subs getting in trouble for adding questions that were there. Then I saw the sidebar and thought "oops, I'm that guy today." 
Check out launchschool.com, I've been very happy with their approach
Your response is great! I'm checking out "learn ruby the hard way" now. The beginning seems really simple, hopefully It'll get into some fun stuff as I get into it. I'll definitely check out the book. I've heard her name before. 
I would love some. I'm definitely open to suggestions too look at. 
A friend recently passed on his copy of [Eloquent Ruby](https://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104). It's slightly outdated but still holds up.
The quality of the curriculum is amazing - not just links to tutorials and YouTube but textbooks worth off original material, exercises, and projects. They're consistently updating and fine-tuning their courses, the commitment to quality is obvious. Instructors are always available if you get stuck and so are the impressively dedicated, intelligent, helpful fellow students in the active slack. The focus is on teaching the fundamentals to mastery - not just giving proficiency at the latest framework, but developing a toolset to prepare for a long and successful career. The free intro courses are pretty in-depth and give a feel for what the program is like, they're probably the best way to see if it's for you. 
If you are doing (most) things in rails, you are already programming ruby. I think what you are looking for is the dividing line between rails and the core language, which is very blurry. I would suggest to pick a simple problem and make a ruby program to solve it. Some suggestions: - hello world - have user enter some numbers and add them printing the result. - display contents of a text file - write a class that stores some data in a file and can read it again. - etc. The idea is to learn pieces of ruby that you have no contact with using rails. (IO, console output, files etc.) Best would be if you have any process you often do and write a ruby script to automate it. 
try some code katas - the supermarket kata was one of the first things i pushed to my github, and in the five or so years since then, i've redone it a handful of times. not only are code katas a great way to practice and sharpen your skills, they can be a very interesting snapshot of how you've developed. http://codekata.com/kata/kata01-supermarket-pricing/
That argument error is a leftover from the beginning when I thought that 3 player games would also be possible but these wouldn't be ranked. I also wanted to keep things as general as possible and so that ranking class get's all of the information it needs as parameters and doesn't need to call anything else. Player is a hash which originally was built in 'for_rating' method of GamePlayer which is a join model between Game and User. Now I have moved that to User.
I would like to recommend [The Well Grounded Rubyist](https://www.manning.com/books/the-well-grounded-rubyist-second-edition) to the list. You can find it for a lower price if you look around, but this is a very comprehensive and easy to follow Ruby book. It introduces you to all the Swiss army knife features of Ruby.
I used to suggest people start with Sinatra rather than Rails, if they're new to ruby and web-dev frameworks in general. It's got enough stuff in place that you can easily build something that "does something" without getting frustrated immediately, but it's bare-bones enough that you have to think through all the layers of stuff that Rails is doing for you. Then once you go back to rails, you've got a better feel for what it's doing for you, etc...
The [Well Grounded Rubyist](https://www.manning.com/books/the-well-grounded-rubyist-second-edition) is an incredibly good book IMHO. 
Think of a small project that suits Ruby's strengths (or weaknesses) then do it. It's a pretty damn good scripting language, fantastic at text processing, and can do some pretty fun gymnastics via reflection.
LRTHW was how I started, it's a great way to get into it.
Check out [Launchy](https://github.com/copiousfreetime/launchy).
Read about 'cron jobs'. Cron is a program that lets you schedule execution of script
I have a Windows machine, so Cron wouldn't work. However even the Windows equivalent of Cron, Task Scheduler, wouldn't solve my issue. I don't want to schedule anything to launch; I want to launch a program with a certain file ready to go.
`launchy "/Applications/TextEdit.app/"` Look at that. It opens apps.
Why's guide is a must read, very fun6and pure art. 
I'm not familiar with your Journal system but looks like you need create_journal.rb script that: 1. Get current date in proper format 2. Create new journal file somewhere in your system 3. Write some initial data to journal file 4. Open journal file 5. Close ruby script Check docs of File class for details.
This is pretty much what I want. I’ll check out the docs, thanks for the suggestion :)
As a complete newbie to object-oriented programming, I was confused by the denser books such as The Well-Grounded Rubyist -- and ended picking up some bad habits because of that. It's been years, but I think I got most actual use out of The Book of Ruby (by Huw Collingbourne). As a gamer, the examples were easy to relate to. Probably not recommended if you plan to make a career out of it instead of just programming for your own fun, since it's not big on sticking to the standards. But after reading that, I found guides such as Programming Ruby much easier to digest.
i personally find method calls more in line with Ruby's object orientation. Pipes make more sense to me in languages with first-class functions.
Check out the Ruby section of The Odin Project! It's a well organized curriculum, some original, some external, and it helped me a lot to better understand ruby before I jumped into Rails!
I really enjoyed using [Ruby Koans](http://rubykoans.com/). Essentially, it’s just a repo you download with a bunch of tests you run that fail. It gives you hints as to why they failed in the error messages so then you can look at the code to fix them. I liked that I was using my own tools (command line and text editor) and it made me get really good at finding what I need in the Ruby documentation. 
This is the book that unlocked Ruby for me. Sandi Metz’s books (one is mentioned above) have unlocked OOP for me. 
I like Pandoc for this. There's a nice ruby gem that wraps it for you as well: https://github.com/alphabetum/pandoc-ruby I use it on Blindside.io and it works great for markdown -&gt; epub.
I would second the recommendations for both Eloquent Ruby and Practical Object Oriented Design in Ruby. I found myself in a similar position as yourself, having completed a boot camp program that focused largely on Rails. After that I secured a backend dev job as a Ruby Developer, but at a company that does not use Rails. Both of those books were very helpful at solidifying my understanding of the Ruby language and it's design patterns. Eloquent Ruby provides a strong overview off the language syntax, even though it is a bit out of date. Most of the advice it provides is still solid, just make sure to complement by reviewing the documentation for more recent versions of Ruby to see what additional tools you have access to. The Metz book was excellent for learning more professional design patterns, which I found particularly important once I stepped outside the structured design pattern that Rails creates for you. I personally started with the former, focused on that until I felt reasonably comfortable with the various tools and tricks the Ruby language offers, and then moved on to the Metz book. Good luck in your efforts! Ruby is a wonderful language, and I find myself loving it more every day I work with it.
I am not sure that scope is the same. My primary goal is to generate nicely-looking _web_ book from set of simple Markdown files, akin to, say, https://doc.rust-lang.org/book/second-edition/. Being able to _also_ export it as Epub/PDF is an additional requirement (and it also means "constructing" book from a set of files + some structure-defining file). Can pandoc do this?..
Ah I see, yeah pandoc is really just for the epub export. I'm not sure about a web-book generator though. Sorry for the misinterpretation.
I did this a few years ago and it was very good! http://courses.rubylearning.org/catalog?new=true
Operators *are* method calls in Ruby. “a + b” calls the “+” method on a with b as an argument. A pipe operator that takes a block argument, yields the object to that block, and returns the result would fit Ruby semantics just fine. My concern is that, conceptually, I don’t see it fitting well. Pipes are a mechanism for composition in Elixir. Ruby already has solutions for this, and I’m not sure that adding another will help clean things up a lot. Most of the examples I’ve seen for yield_self strike me as Feature Envy that would be better addressed by adding code to the class involved instead of building chains of ad-hoc blocks. 
I’m also in a coding boot camp at the moment..we spent five weeks on just ruby and we are moving into five weeks of Ruby on Rails...I used the treehouse ruby track to help follow along with ruby. It helps teach you ruby with the Sinatra framework, which I saw others in this thread suggest. I also want to recommend the book well grounded rubyist, as others have as well. 
I think it’s on code academy for free too. 
Emacs org-mode with html export and your own css styling.
Actually, I bought it back in with a default value so that I can call it within without a parameter. def powerize(rating = current_rating) 10**rating.fdiv(400) end
I am not sure about what org-mode does. How is this relevant? 
It’s a way to organize information, and export it to various mechanisms. There’s lots of projects that take org files and turn them into various formats like epubs and PDFs. https://orgmode.org/worg/org-web.html https://github.com/ofosos/ox-epub
Yeah I imagined it was some kind of leftover :) Raising argument errors should be avoided most of the time, the only use-case is for methods called from code you cannot control, like the public-facing API of a gem. And even in some of those cases it can also be avoided. Eager generalization is also a code smell, make sure to actually need it before making the change, [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it). If you want to improve your code I recommend [Practical Object Oriented Design in Ruby](http://www.poodr.com/) by Sandi Metz. She also gives talks in Ruby conferences, you can find her on YouTube. She shared a set of [rules](https://robots.thoughtbot.com/sandi-metz-rules-for-developers) she uses to improve your code, if you follow that, it will surely improve your code. I'd add in _avoid if statements_ and _avoid using nil_.
**You aren't gonna need it** "You aren't gonna need it" (acronym: YAGNI) is a principle of extreme programming (XP) that states a programmer should not add functionality until deemed necessary. XP co-founder Ron Jeffries has written: "Always implement things when you actually need them, never when you just foresee that you need them." Other forms of the phrase include "You aren't going to need it" and "You ain't gonna need it". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; Practical Object-Oriented Design in Ruby by Sandi Metz (non-free book, also available as an ebook maybe? -- for when you want to get deeper into Ruby beyond basics and start thinking about programming patterns and program design) I can't advise this book. I just browsed through it. 1-2 few neat tricks but only suitable for beginners. &gt; Learn Ruby The Hard Way (free online book, I think? -- a less whimsical intro that goes a bit deeper than Why's guide) Even worse beginner material. Grabbed the pdf variant and immediately discarded it. Sourcing from this: &gt; https://www.reddit.com/r/ruby/comments/2oiu3d/whats_a_good_ruby_book_for_experienced/ &gt;https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-c-and-cpp/ Okay but no real information that you couldn't google while you needed it. I find it increasingly difficult to find a true reference guide to ruby that advertises structure above programming introduction. I'm less interested in how ruby works. I can see that much by looking at an existing ruby application. My best advise is to take a look at a few ruby libraries and devise structural alignment from them. In few books encapsulating in modules is even mentioned. Neither are the tricks shown how to organize and require those related files. There's just a great focus as this is an entry level language which makes mastering artificially difficult.
POODR only for beginners? I don't agree with that at all. Many programmers (even those writing the gems you might be looking at) could benefit from a lot of the design advice from Metz. _Especially_ someone like the OP who learned all he know about Ruby from a Rails bootcamp.
Not convinced sorry. Browsed through it.
I am planning to get the POODR-book once the new edition is published. Her rules are a bit more strickt than reek's defaults. And especially the line number restrictions are hitting me hard :)
It can be hard at first, but it's really worth it. If you surpass the 100 lines limit for a class it's surely doing too much, try splitting it into several smaller classes, or at least some concerns. Something which can help with that is [Refactoring: Ruby Edition](https://www.amazon.es/Refactoring-Ruby-Addison-Wesley-Professional/dp/0321984137), it's more of a senior-level book than POODR, and you can't read it from cover to cover, you have to stop at each pattern, see if you can apply it, then repeat, but it's definitely a great resource, and it helps you "develop an eye" for bad code. Reek seems to use some smells from the Refactoring book.
Jekyll is a better alternative to Gitbook. All you need is a book theme / design :-). I collect some over at the octobook org. For more about octobook, see the octobook talk notes &lt;https://github.com/geraldb/talks/blob/master/octobook.md&gt; and for a live example &lt;https://github.com/octobook/gitbook-to-octobook-sample&gt;. PS: The [Yuki &amp; Moto Press Bookshelf](http://yukimotopress.github.io/) is built w/ Jekyll and Octobook themes (and GitHub Pages).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [geraldb/talks/.../**octobook.md** (master → 5413d40)](https://github.com/geraldb/talks/blob/5413d4017559ebb898eb3f95eba5198214713973/octobook.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dw9m91h.)
For more (jekyll) book themes (other than octobook), see the book designs repo &lt;https://github.com/bookdesigns&gt;. For another gitbook look alike, see -&gt; http://bookdesigns.github.io/book-git It's just plain jekyll (with github pages). Cheers. Prost.
I didn't use any of these to learn ruby and haven't looked at them in detail (I learned in ruby 1.8 days with the "pickaxe"), but looking at the free samples books in the sidebar and those recommended here -- I think I totally agree that the Well Grounded Rubyist is the best for someone in the OP's position, it looks pretty sweet. 
Yeah, it's functional. It's probably missing some error handling, but this is how you can implement this in a couple of minutes :) I tried to treat this problem more as an architecture exercise. That's why I wanted to answer questions like: - How to structure the code? - How to name things? - What kind of meaningful errors should we have? - What can go wrong?
Interesting... But too much commitment for non-emacs user :)
Oh! BookGit is pretty nice, thanks. Octobook is a bit too simplistic for my taste.
what is a similar poodr book but not suitable for beginners?
...Though, I am not sure that "just theme" approach allows to reproduce what GitBook does. I looked in the theme, and it just naively lists all chapters, while GitBook allows to structure the book in `SUMMARY.md`, and renders it as a TOC. I'll experiment a bit, will see what I can get from Jekyll.
According to Amazon there is a 2nd edition which isn't yet released. And I remember reading from one or the other list of ruby resources that it would be coming in the summer. At the moment I feel that 100 lines for a class is less hard than 5 or even 10 for a method. Thanks for the tip on refactoring book, will add that to the list.
Sorry, probably a dumb question but, what's CRuby? 
No ruby pickaxe http://ruby-doc.com/docs/ProgrammingRuby/ ? I learned ruby only with this offline manual over 10 years ago and IIRC there is really all you need.
http://ruby-doc.com/docs/ProgrammingRuby/
1. Do the Ruby Koans. 2. Build a gem that helps you solve a problem you have. 3. Learn more as you get stuck. 4. Refactor and extend based on what you've learned. 5. Repeat steps 2, 3 and 4. 
Looks like the website is unmaintained, but I'll leave it here for posterity in case it comes back as it is my favorite site that I learned from. And that is https://rubymonk.com. 
I am not. Do you want to write one based on jekyll? :)
I think you've got some great suggestions here. I would also maybe encourage you to use http://exercism.io Specifically, I would encourage you to do the challenges and then read the feedback and redo the challenge with the feedback in mind. Also, look at other people's solutions and offer feedback of your own. This will do two things for you. First, it'll give you a thorough lesson in idiomatic Ruby. Ruby gives you dozens of ways of doing things, but there are ways that are preferred, either because of brevity, cleanliness, efficiency or readability. By getting feedback on your code, you can start to see where, maybe your way works, but maybe there's a way that is considered better. That's one of the things that I think is hard to learn from the books I've personally read. The second benefit is that Ruby is as much a community as a language. By engaging with other Ruby devs in this way, you prepare yourself for the kinds of interactions you will need to have to really benefit from being a Ruby developer instead of developing in some other language.
curious why you want to learn ruby more/better -- is it to hopefully find a job, or maybe just b/c you're tired of not knowing it well? main reason i ask is b/c i always advise people to avoid IT at all costs. so if you just went to bootcamp and were successful in finding a gig or were in some other way successful, i'll have to add that as evidence - or reverse evidence - to my pov. i never thought there was much to ruby, but i like the creator dude, and i like japanese culture, and the couple times i've messed with it it seemed not any more horrible than any other wack programming language i'd used, so maybe i'll give it a try again sometime soon. the 'hard way' guy, Zed, had a good screed against rails back in the day that i guess he got scared about and took down, [but it still exists](http://harmful.cat-v.org/software/ruby/rails/is-a-ghetto). so he may just be an asshole, but being able to read something from someone who at least occasionally and half-heartedly criticizes some particular aspect of the going tech religion is probably valuable.
There are a few tutorials out there that are “MVC from scratch” and you essentially build a basic version of Rails. I found this to be super valuable when I was competent in Rails but wanting to understand more of the magic. Gluck!
I'll go look at those, that would definitely be good to learn the instructions &amp; outs. 
Codecademy
Cron Jobs are something I've always had an issue learning - anyone know some good tutorials - agnostic or ruby both ok
Go binge watch every video on YouTube with Sandi Metz Read https://rubyblog.pro There is also great official documentation, very readable.
I’ll try this, thanks 
[softcover](https://github.com/softcover/softcover/blob/master/README.md) does everything you mentioned. Created and maintained by @mhartl author of [Ruby on Rails Tutorial](https://www.railstutorial.org), itself a book published using softcover.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [softcover/softcover/.../**README.md** (master → 9358b80)](https://github.com/softcover/softcover/blob/9358b80c1361d1268d2df4dd81c17ef129912848/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dwam7qa.)
Design is a matter of taste :-). Octobook is a **collection** of themes. "Just started" so for now there are only two or three (book) themes. Anyways, the first question you have to ask yourself - do you want an all-in-one page book or one page per book (like gitbook). The octobook-2018-theme uses the all-in-one single-page book approach. PS: If I find the time in the next week will try to update the bookgit (it's the design from the rust book) and make it a "proper" octobook theme. Octobook uses a "manifest", that is, book.yml for it's gitbook-style summary.md. Good luck. Tell us how it goes. Love to see your book(let). Note: If you use Jekyll - there's also a [reddit/r/jekyll](https://www.reddit.com/r/Jekyll/) and a discussion group &lt;https://talk.jekyllrb.com/&gt;.
Yes, operators are methods, but method calls aren't function calls in Ruby – they are message passing that may or may not correspond to an actual method. Functional composition is a mathematic concept and functional languages derive further behavior from those principles. But, AFAIK, message composition isn't even a thing. So I see piping for function composition only getting more and more awkward in Ruby as we go down that path. Imagine, for example, that you "pipe" onto a message that doesn't even correspond to a predefined method (caught, say, by `method_missing`). What does that even imply?
Yea why not? What's the harm in that? it's a proc which is just a function. Why should you have to make a distinction in how you call the proc? Why not have first class functions in the first place?
precisely because then it’s not ruby anymore: message passing between objects is the philosophy of ruby. and everything is an object, even functions and classes. grokking this is the key understanding why ruby exists. 
Why does that bug you? It’s true. 
I think it's kind of definitions-y. Not "explicitly" using the `send` method, to me, doesn't make a message being sent not "explicit".
I think it would be nice to add that true reason most ruby developers use `private` is to say: Hey, this is for internal use only, so don't worry too much about these methods. At least that's how I code most times. Private methods by definition don't need to be tested, can change at all times and sometimes are even a little messy. I say that because as I was learning OOP and Ruby, I always read these kinda of information explaining that `private` methods can't be accessed outside and stuff. I was like, ok, but why is that so important? Some say for security reasons and that bugged even more, I mean, what if I'm coding a music library, why is security so important? So the click for me was when a work colleague said: `Private` means: "these stuff are mine only, don't mess with these!"
I did not know of peps, but it seems really nice: https://www.python.org/dev/peps/
Ah gotcha. I thought you meant that they were different mechanisms, but you actually want to stress even more that there the same mechanism. I was coming to defend the Smalltalk-inspired idea that all method calls are messages at the end of the day - seems like you agree.
Indeed! All methods are messages!
thanks for the comments! i've posted a link-back to this thread on my original method driven development post :)
&gt; After I spend some time to investigate the cause, I found that it seems not caused by generated code's performance but compilation overhead because the amount of delay is not changed by just stopping to call generated function and always falling back to interpretation, and the majority of delay does not appear once all ISeqs are compiled. Hi, Takashi. It is hard to say for me w/o detail investigation. I have only one suspicion which is thread synchronization overheads (waiting for access to data shared by threads) when you have a lot of task in compilation pipeline in one thread and another thread is permanently adding more tasks. Changing heuristics how fast we add iseqs for compilation might help. I'll resume my MJIT work in May. There are a lot of things still to work on it. It is still in very experimental phase. I am experimenting with a Light-weight JIT and because it compiles very fast (spending tens of microsecs for function compilation which is in more than 100 times faster than MJIT using C compilers) it could be used as tier1 compiler without parallel compilation. So it could help to solve the problem in the future. MJIT using C would be a tier 2 compiler which is called less frequently and generate better performance code for more frequently executed methods. I'll talk about the light-weight JIT on RubyKaigi2018.
cool! would be awesome if there was a way to sort by stars or downloads and also return more results.
Oh come on. If you’ve got 12 years of programming experience, you’ve already got more experience than a lot of working programmers. You’ve (hopefully) already learned a lot of the patterns taught in the Metz book. So what does it matter if you find the book to basic for yourself? You should probably be reading Knuth (if you haven’t already). The OP is clearly far less advanced than you, so why are cutting down suggestions for the OP just because your too far beyond them?
Yes, that would indeed be awesome. Maybe I'll add it later, depends on whether people will actually use it. We'll see...
I want to become a programmer for various reason. I've done a business that would have benefited from me knowing web development to keep costs down. 90% of my business ideas are centered around the requirement of this knowledge. Job market for web-dev's is better than me going back into sales or culinary which is my background. I'm just done with that as a career path. I want to learn how to program, inside and out. I chose a education path without knowing much about the field and they taught me ROR. It's given me the knowledge to do exactly what I need to do and I've loved it. I want to know more, because the more I learn, the more I'm discovering things that I want to know about. Understanding OOP at it's heart is something I want to do. Ruby is the tool that I'm needing to do it with because that's the path I'm already in. I'm an obsessive person with things, so I have a hard time being content with knowing the service of things. I like to have a deep understanding of what I'm doing. I will learn other languages as my projects evolve outside of the tools that Ruby is good for. I don't want to lack an understanding of the fundamentals when I go to learn the different nuances, structures, and syntax of a new language. 
I can't thank everyone enough for their input and suggestions! I've got a plethora of resources to start getting into to achieve my goals thanks to everyone here! I have upvoted everyone who's commented and saved this post for future reference as I go through my journey! 
Considering the overlap that `then` has with promises, and this is basically the forward pipe operator, why not something like `pipe_to` ? paragraphs .pipe_to { |paragraphs| cleanup_forbidden_markup(paragraphs) } .pipe_to { |paragraphs| join_too_short(paragraphs) } .pipe_to { |paragraphs| realign_by_timestamps(paragraphs) } .pipe_to { |paragraphs| next paragraphs unless options[:split_parts] paragraphs.each_slice(PART_SIZE).flat_map { |chunk| [part_header, *chunk] } } .pipe_to { ... } 
This is good, but what is "a receiver of the same family", what does that mean? The same class? Something else? I could look this up myself, I always forget exactly how ruby protected works, or I could ask OP to do it for me and add it to their post ha. 
"a receiver of the same family" means the class instance or one of its children. As you can see in the example, the `Mailbox` class inherit from `Receiver`.
What does "it's not ruby" mean? Ruby is not a religion. It's a language. It changes over time and there is no reason to be all fundamentalist about what is what is not ruby. If it's useful, if people want it, if people are capable of building it then it should be built. I don't recall pledging allegiance to what ruby is supposed to be, I don't recall memorizing a holy text handed down by a messenger of god. It's a programming language. It exists to solve problems. If something can be change to make solving problems easier or more fun then by all means go right ahead. 
Namespaces don't matter, something else in the same module namespace is irrelevant? That's what I always get confused about. 
Yep, I think it's less "security" than code maintainability and comprehensibility. 
Yea I was really hoping for something off the shelf so to speak. We're crushed as it is and I'm kinda shocked this isn't already a thing.
Good summary, but this part stood out: &gt; The Kernel#send method has a specificity that can be useful in some cases (testing, etc..). Using `send` to circumvent `private` or `protected` in tests probably means you're breaking the encapsulation and testing implementation details rather than overall behaviour of the class. If there's a need to use dynamically generated method names in tests, then prefer `public_send` over `send`, since it obeys the visibility rules.
Ah man, you beat me to my own post. :-D
Now I get all the precious precious upvotes muahaha. 
Perfect name for it
FWIW the dude that owns this repo has a dozen or so AMAZING ruby projects that most experienced devs drool over because of how helpful they are. He's was dev #1 at instacart.
I went through half of this site a couple of months ago, and it really helped me understand some of the ruby philosophy. I found trying to learn to program rails without knowing ruby is really confusing. I went back a few weeks ago, and the site seems broken now, so it may not work for you. 
Try my book https://mindaslab.github.io/I-Love-Ruby/ 
Its not about being fundamentalist. Its about making something that has a recognizable theme that guides choices. Languages are opinionated, which is why we have so many of them. Ruby's designers and maintainers have chosen an OO direction strongly inspired by the message-passing of SmallTalk, because that's what keeps them sane. Do you complain that your local Italian eatery doesn't cater to your desire to have Ramen noodles? Or that a Chinese restaurant place doesn't make pizza at the same time? Of course not. You can simply order take-out from both and take it home, or go to a food court that has both. So if you really want to mix OO and FP on the same plate, then either use a language that serves both (like Scala) or split your codebase into modules written in different languages (most companies go this route). But if you absolutely *have* to remain in Rubyland at all times and *insist* on still getting served whatever you want, then that does sound quite fundamentalist.
To future people: (Logged as an issue)[https://github.com/ruby/rdoc/issues/615] Just tried the same thing in a fresh Ubuntu 17.04.4 installation, using the ruby and ruby2.3-doc packages, with exactly the same result.
Have you tried [gem server](http://guides.rubygems.org/command-reference/#gem-server)? Maybe that’s a dumb question, but just thought I’d ask.
Can't this all be done fairly trivially with `dtrace` on osx?
I think that this profile gives you "ruby tracing" capabilities, i.e. which ruby methods are called, instead of which syscall/C functions. 
`dtrace` does that too http://ruby-doc.org/core-2.2.3/doc/dtrace_probes_rdoc.html
That sandbox trick is pretty dope tbh. I am a rails dev for 2 years now and didn't know that.
Thanks for a quick reply. I saw Apipie before but have to admit that I don't like that approach much. I would probably prefer just a comment that gets parsed.
&gt; I have only one suspicion which is thread synchronization overheads (waiting for access to data shared by threads) when you have a lot of task in compilation pipeline in one thread and another thread is permanently adding more tasks. That might be the case. I'll investigate the lock duration to fetch/add an ISeq to a queue. Your tier1 JIT project sounds very interesting. I'm looking forward to learning its details at RubyKaigi2018. I'll give a talk about some works on portability and stack-based compilation there.
Thanks, I was planning on emptying my Twitter account and this was quite effective :)
Careful with using it in production since it locks records.
Another tip. Thanks.
Thank you so much for this tip, I will update my article to include it
What is your goal? Do you want to find a job in the future or something else?
Came to say almost exactly this. ActiveAdmin is an absolute nightmare. Admin areas should be optimized for user workflows, not a web view for your database tables. I don't mind Devise too much, but tying it (or an equivalent) into Rails core would be hellish.
💕
If you want to go into Devops maybe. There’s also Sinatra but don’t expect to get a job with it.
Well as a Ruby developer I had no problems getting it running, however instructions to install the bundle are currently missing from the readme. You could release this as a gem to make installation easier.
I do 90% of my work in [Chef](https://chef.io) and it is a delight.
I've never really gotten into professional Rails dev and I've been using Ruby for nine years. However, I wouldn't say that I use Ruby for everything everyday. I would say I'm more of a professional Scala developer for the last couple of years. Ruby is still might go to 4 scripting and rapidly developed web projects, generally using Sinatra.
Maybe you have seen the light, but working with Chef is a struggle for me.
Totally makes sense.
With you everything is fine :) So you don't need Rails if you use ruby only for automation and testing. In addition to the rails, there are many other interesting frameworks. If you are interested in web development then try for example Hanami. 
I'd say the fact that we differ on Devise further confirms how much authentication doesn't belong in a web framework :-)
I think context matters (time frame, budget, etc). Devise provides a ton of things out of the box that many companies need and would spend months adding on top of their 100 LoC authorization module. Others don't. I guess... This is why it's good these things aren't mandatory. 
&gt; It basically means this- let’s not create 6 different gems to handle file attachments — each gem having it’s own community, syntax, philosophy and slightly different features. Instead, when we see a very common web development problem (and file attachments reoccurs in a huge number of projects), let’s bake it into the framework. Well, over time there's bound to be multiple solutions to the same problem, in any language. Instead of Rails creating yet another file attachment solution, why not choose an existing solution that they think works best, and maintain only a Rails integration for that gem inside the Rails repository (instead of reimplementing the whole thing)? That way you get core functionality that's maintained by the whole Ruby community, not just the Rails community. &gt; I don’t want to have to memorize ActiveAdmin syntax, RailsAdmin, Administrate and what not. We all have much better things to do with our time. Why would in your opinion an admin component baked into Rails necessarily be the "right" solution? In my experience gems not tied to any Ruby web framework have much more impressive features and flexibility than Rails-specific gems. I think it's because it forces you to choose a good design, instead of splitting the gem into "Rails engine" drawers. A good example is Devise vs Rodauth. &gt; I’m sure we can agree on an approach that works for most people and bake it into the framework. Again, in my experience many solutions that Rails came up with don't work well for as many people as some generic alternatives. For example, Sequel is arguably a much fatter Swiss knife than ActiveRecord, but when the Rails team had the option to accept Sequel as the official ORM, they still kept ActiveRecord, which I will never understand. &gt; Those developers that want more freedom don’t choose Rails anyway: they choose Sinatra Yes, and if you are migrating to Sinatra/Roda/Cuba/Hanami/Grape, but so far you were using only Rails-specific gems, you have to completely overhaul your toolset. Whereas if you were using generic gems with Rails, you can keep using those same gems when you switch to a new Ruby web framework.
Excellent point - thanks! I've never made a gem before so I might as well learn now. 
&gt; I don’t want to have to memorize ActiveAdmin syntax... Plus, how would it being baked into Rails avoid the need to know it's syntax/API? 
What's giving you difficulty? The DSL is simple, well-documented, unsurprising, and easily extensible. The biggest complaint that I'd level against Chef is that it's really slow (because Ruby), but that's fine for the things I use it for.
Yes, it is worth continuing to learn without working with Rails. Is it optimal? Depends on your goals.
Not all applications are web applications. Rails is specifically targeted towards web apps, if you are doing something different then you will not need Rails. However, some of the pieces that make up Rails are nice to use for other projects, like ActiveRecord for example
Given the option, I usually go with rails_admin.
Interesting. At first glance this looks a lot better than other ruby DI stuff I've seen, more rubyish and with less overhead. But I don't totally get it. I have to spend more time with docs, but if you wanted to put more example/demos in the initial README, that would be helpful. Like, I'm pretty sure I can guess what the `settings` are, but I don't really get the other blocks. (/not a Javaist, not someone who's done a lot of "DI"). 
Yes. I think Rails is clever, and more robust than one has a right to expect given the complexity of it, but coding by convention is not the best habit to get into.
&gt; I'll grant that with Active Storage, we've arguably crossed the bright line between being an underlying framework/library and supplying part of the application.. I'd say that also happened with actioncable, as rails maintains its own websockets infrastructure, instead of just attaching, as it works in rack. It would be great to see it take a step back and see what worked so well with activejob , where rails just provided the sprinkle and let the bj frameworks do their thing. It's a part of rials that gets so few commits thanks to its stability.
maybe you need a second longer example on the first page, or a linked page (yard can do that, have other doc pages) that goes into more detail. Like, assume someone knows very little about DI except basically what it is -- like you were when you came to DI -- and show them how you'd use alki to do something useful. The phrase "DI" gives me hives from seeing how it's often used, but I too have arrived at needing something like it sometimes, I think. 
It's certainly less common than Rails work, but I've used Ruby for scripting at all my jobs (I was introduced to it this way) and have only used Rails at my current job. Ruby is an incredible scripting language. I love making commandline tools and writing one-off scripts to answer a question. It's a great language to express thoughts in.
Your last line is exactly how I feel about Ruby!
That makes sense, but then it’s hard to build complex workflows, as the jobs are just enqueued by random callbacks all over the place.
Ruby is great for non-rails applications. Love it for different types of projects except when there needs to be a desktop user interface. 
I did not know that. That's hardly a sandbox then!
&gt; The biggest complaint that I'd level against Chef is that it's really slow (because Ruby) Chef (client) isn't slow because of Ruby, it spends little time executing Ruby code. It's slow because it has a fairly insane architecture. The only part of the Chef architecture where performance matters (the server) is written in Erlang.
I can only speak to my experience but I find that most businesses that start with Rails eventually end up with a monolith and end up tearing it down and stripping it back to mostly Ruby anyway. While it’s good to learn as a beginner or purely as a means to get stuff done it can turn into a steaming mess very quickly. Solid Ruby experience will serve you just as well or if not better IMO. Solid experience with Ruby will allow you to pick up Rails and it’s nuances pretty quickly. If you were to start looking at Rails I would start with Ruby on Rails API. In short yes, It’s worth continuing without Rails it will make you a better developer.
From the context of a RoR developer, I think ruby is the reason why rails is so great. Metaprogramming with ruby is so cool to play around with and allows you to do a lot of unique things. Additionally, its pretty well supported with a strong community and there's a lot of speed improvements coming with ruby 3.
I haven't worked in Ruby at work for a while, but when I was, we primarily worked with Sinatra and a bit with Grape, and I loved it.
The problem wasn't subclassing a struct instance, it was, once again, Rails' infernal autoloader!
I have never touched rails and Ruby is my whole job
I stopped using Rails and instead switched to [Padrino](http://padrinorb.com/)/[Sinatra](http://sinatrarb.com/), and now am watching [Hanami](https://hanamirb.org/).
Question about attribute_method_suffix and prefix: what if I need to define multiple prefixes or suffixes? How can I do that?
It has to be admitted that Ruby is trending downwards in the jobs market. At least as far as Indeed.com trends indicate. Ruby and Python used to be roughly equal about 5 years ago. Now Python:Ruby is 3.5 in London and 6.8 in the rest of the UK. What's interesting is that Ruby's presence, unlike Python's, seems to be concentrated in the capital. Once you move outside London Ruby jobs are very thin on the ground. Ruby seems to have a bigger presence in the U.S. jobs market but even here we see Node.js and Python trending upwards whilst Ruby and Rails have long since peaked. Github stats show a steep decline in Ruby and PHP relative to other languages.
Have you tried Clojure? Cleanest syntax I've ever seen.
I’ve written my fair share of Lisp. It’s true, Lisp has the cleanest syntax because there is almost no syntax. But I still prefer Ruby for practical scripting like working with Files. And having the option to use mutable state when it’s simple is a great freedom for me. Dynamically typed OO is also a blessing in Ruby. I can use it to clean up code by using objects to vary behavior, without the boilerplate of a static type system. Trust me I’ve been bitten by the Lisp bug before, but nothing confirms to my brain like Ruby does.
I use Sinatra and Padrino on a daily basis. Absolutely.
Struct and OpenStruct are both pretty slow. I tend to only use them for prototyping
The issue wasn’t Rails it was require_dependency from a gemspec.
Where does require_dependency come from? Ruby files _never_ get loaded twice without an autoloader present.
Sounded like a gemspec from a gem, made it sound like that line was in there twice? Though it does seem like a bug that the file wasn’t required which would have only executed once.
I have dealt with how ruby loads files via require (and the monkeypatched version you get when rubygems is loaded) for a decade now. I've also seen the flavors of errors emitted by ruby autoloaders. I'm fairly certain this is a problem caused by an autoloader (probably activesupport) trying to reload code. Even if I'm wrong, it's a drop in the bucket of how much time I've wasted trying to chase down autoloader mishaps.
Ruby have borrow many from Perl,it’s suitable to write admin scripts 
I think that Chef problems aren't really tied to Ruby and it would've had the same declarative/imperative mismatch with any kind of DSL. At first it looks like recipe describes the *state* of the server but as soon as you're doing any real work you actually describing steps to get to that state, `notifies` being the prime example.
You can pass multiple names: attribute_method_suffix '_max?', '_duplicated?'
&gt; ... and the 100 LoC authorization module teams used to paste in to their lib directories in 2007 [Restful Authentication](https://github.com/technoweenie/restful-authentication)? 
I agree with you, I haven’t talk to Matz in years so I am not sure,but I have the same hopes as you
Indeed! The problem is inherent to Rails, not to Ruby. Yet another example of why Ruby in Rails is more RailsScript™ than Ruby. But that's fine. It's it's own thing; a particular variant of a broader language environment. The counsel that inheriting from Struct.new is hyperbolic drivel - but only from a Ruby perspective. In the bizarro world of Rails and all of its contradictions and disregard of Ruby, the advise is sound. But advice that is sound in a particular framework that contradicts the precedents of the language itself is a reason to question the framework's design sanity. In this case: yet another reason. We have a saying in our Ruby work: Give unto Rails that which is Rails. Meaning, isolate as much valuable code as possible from Rails, and when it's impossible to compartmentalize our assets from Rails, yield to Rails' particularities. The best way to not have to fight with Rails is to not be in reach of Rails. 
Purely speculative, but I hate to see a request for help go unanswered: If deleting isn't working can you overwrite it with a blank/empty document?
I've never used `ActiveModel::AttributeMethods` but seeing it here reminds of [how Perl's Moose can handle attributes](https://metacpan.org/pod/distribution/Moose/lib/Moose/Manual/Attributes.pod). Too much magic, maybe..?
Yes, Rails autoloader has cause many a strange problem over the years. To make things 100% bulletproof, I've seen folks do stuff like this: X = "foo" unless defined? X And while it's hard to argue against making software bulletproof, I never do it. The great [Ara T. Howard](https://github.com/ahoward) seems to make it a habit of doing this. 
That should get a hundred upvotes; here's mine. In the last few years while maintaining our legacy Rails apps, we've taken to isolating our code, as much as feasible, into separate Gems and relying extensively on tools like RabbitMQ and YAML/JSON serialisation. Then we got smart and stopped doing new apps in Rails at all. 
Struct is slow? That’s news to me. I thought the intention was for it to be faster than native Ruby because it’s implemented in C. Maybe it was just intended to use less memory. 
Also, if you're trying to keep your code functional or imperative ("Tell, Don't Ask"), Struct/OpenStruct instances visible outside a class should be a major code smell, except as "result" objects. And those, as you say, you'll want to replace with proper attributes once the structure stabilises. We've been using [`'Dry::Struct`](http://dry-rb.org/gems/dry-struct/) value objects for that purpose for a while now, and evangelise them.
Not sure i'd totally agree. Lots of hype around fancy newer languages, but that doesn't mean that ruby/rails is dying. Take a look at the methods that most of those studies are conducted- usually something along the lines of posts on stackoverflow, which is actually a measure of the new issues not satisfactorially resolved elsewhere. Ruby/rails has a great community and a huge body of knowledge that addresses most of the common issues that any given individual would likely have, therefore they wouldn't need to make a new SO post to ask about that. So really that data is more accurately saying that ruby/rails has fewer problems that havent already been answered, rather than that it is dying.
At least this is a very popular option. Why someone would port the part of rails that most flyes in the face of good OOP, however, is a mystery to me. 
I was thinking about getting an array of embedded documents (from the parent doc), removing desired item from that array and then saving the doc again. That might work but looks like a workaround rather than a solution. 
I've written lower-level services and microservices without rails, using either just Rack on its own, or adding Grape to the mix. It's also heavily used in our CI and DevOps workflow as discussed elsewhere. The biggest issue I had with moving away from Rails for everything was missing the language extensions that you get for free with ActiveSuport &amp; friends - you even run into Stack Overflow answers asking "how do I do x in Ruby", which have answers that don't work without at least some of Rails loaded. You get used to it though. It's all about what you need though. If you've got no need to do something thinner than a full-blown Rails stack then you need to work out what your motivation is for ditching it. If it's just for professional development you might get more mileage out of adding another language to your repertoire.
Sorry for offtopic, but I am wondering: is it your choice to place it as a "Member preview"-class Medium article? It is kind of "soft paywall" now ("Become a member now for $5/month to read this story and get unlimited access to all of the exclusive content on Medium." it says to me. I believe that not-logged-in, or rare Medium users aren't seeing this.)
&gt; The DSL is simple, well-documented, unsurprising, and easily extensible. Right. Especially the default behavior of `file`, `directory` and `git` resources.
I think the ruby standard require functionality *can* load the same file twice, if you refer to it with different path strings that resolve to the same location (unless that's changed in more recent versions) - but you've got to be holding a pretty big footgun to have hacky requires all over the show littered with `..` etc to do that.
100%. You could look at small problems that need to be solved maybe. I had some data that needed to be structured and all i had was a page that was copy-pasted. Or maybe you could play around with a scraping project or something
Every now and then... I see something simple yet awesome... this is one of those things.
Dumbest issue in the history of issues. Inspired http://factoryboy.readthedocs.io creation for this stupid non-issue that offended no one, ever.
Well I DO work with female devs and asked. They thought the change was stupid as well. And found the factory_boy py library hilarious as a rebuttal.
I worked on MongoDB years ago at this point. One thing I do remember is that embedded documents didn't work how we wanted them to. Presumably you don't have Mongo support? Your workaround you describe is what you would do in DynamoDB (the AWS NOSQL DB). Did you ask here: /r/mongodb/
I have coded in many languages for over 25 years... been CTO in the finance and telecom industries... Imposter Syndrome should NEVER affect you... Awesome stuff... thank you
I was thinking about Opal for this... you should also think about building a site for teaching / learning around this... you have SO much of the bones created already... and you said you are a web guy... so 
You've got some great one liners!
What surprised you about their behavior? I found the [docs](https://docs.chef.io/resource_file.html) fairly comprehensive. (Unless you weren't being sarcastic.)
Great news. Add the the "Benchmark Driver Designed for Ruby 3x3" to the [3x3 articles collection](https://planetruby.github.io/calendar/ruby3x3#articles) at Planet Ruby. 
File and directory creation was surprising because `recursive` is `false` by default, `git` is surprising because it doesn't have a way to pass the SSH key and requires some weird wrapper scripts.
`mkdir` isn't recursive without `-P`. I agree that the `git` resource looks suboptimal if you're using a passphrase-protected ssh key, but I generally haven't used or needed the `git` resource-- there's a lot of ways to pull things down with Chef, and if I was going to do anything *too* fancy, I'd probably be using Jenkins or write something purpose-specific.
Matz is notoriously nice, hence the MINASWAN acronym: Matz is nice and so we are nice!
that's one thing I really like about the Ruby community-people try to be nice to each other b/c Matz is nice :)
I was at the conference as one of the volunteers - your talk was great! We heard very good feedback from it :)
wow, I'm very glad to hear that! Thanks a lot for volunteering and making the Bath Ruby conference such a great success! ([Notes of my talk is here](http://www.sihui.io/brain-friendly-code/) for those that are interested.)
Medium's paywall sucks. They're applying the principals of one publishing domain to another domain where those principals don't apply. They will drive readers off the platform and writers will follow. It's the endgame for a blog service. And it suggests that Medium is really in trouble at this point and that their business model isn't viable. That said, open Medium links in anonymous browser windows. A number of extensions automate the use of anonymous windows by associating host names with anonymity: http://www.ilovefreesoftware.com/29/featured/open-in-incognito-extensions-for-chrome.html 
It looks like you've already inspired someone: https://github.com/jeremyevans/sequel/commit/c8385afd1891de701e07f80c9981065f1f2db852 ;)
Wow. Where do I start? &gt; I have yet to see a Rails project (or any other project for that matter) that didn’t need an admin dashboard at some point. Well, none of Rails app I worked with (it would be about 15 of them) needed it. Especially they didn't need any half-assed solution like any default admin panel would be. If it's really needed, you can build it in reasonable time. That's the thing with Rails, you know, prototyping is fast. &gt; If you have a database, if you’re keeping records — someone eventually will need an easy way to see and modify them. You assume that there is one-to-one mapping between models and business logic. It usually is not. Just giving people access to your databasae tables won't get you far - they will screw up your data totally or they won't know what to do. Again, if you need people modify record from admin panel - build one. &gt; Having a “choice” slows the developers down when switching projects, fragments the community, and causes us to waste energy by recreating and relearning the same thing over and over again. Maybe. But it's a little price for having what chaices give you - possibility to choose the best solution, not the only one. Plus, having one true solution is actually a huge risk - what if maintainers decide to go the way you don't like or break your project? You're screwed, because you don't have a choice. That slows everything down as hell. &gt; let’s not create 6 different gems to handle file attachments — each gem having it’s own community, syntax, philosophy and slightly different features. Instead, when we see a very common web development problem (and file attachments reoccurs in a huge number of projects), let’s bake it into the framework . That’s why Rails 5.2 will introduce ActiveStorage. Yeah, right. The story is actually completely different. Do you remember first upload gems out there? I do. They were a mess, lacking basic features and ridden with bugs. That's what always happen with immature and young technologies. It's not an accident that Rails team introduces ActiveStorage now - they waited for solution to mature and be stable and now propose a unified interface to them. &gt; And that’s why we have ActionCable. Does anyone really uses it for any other purpose than impressing your manager? I mean, it's such a resource hog, I cannot really imagine someone being serious about using ActiveCable in production. Luckily, we have alternatives (namely, AnyCable), but from the level of this blog post I have no doubs the author has never heard about it. And obviusly it's wrong, because, you know, choices. &gt; The rest of us are waiting for Rails to make web development easier by finding common solutions and best practices for common problems. Finally, a part I can (kind of) agree with. We all need some best practices and solutions. And... We have! There are tons of gems you can use right away with your Rails app, without imposing it on the rest of the world. That's a great value. Please, don't try to spoil it by reducing Rails target to kind of apps you do.
Yes, that is important when you don’t care about the returning value of the block or when you can wrap the code with the benchmark measurement. Sometimes you still need to subtract the time manually, that’s where the monotonic clock is useful.
Ruby 2.2 will be EOL after march (this month) https://www.ruby-lang.org/en/news/2018/03/28/ruby-2-2-10-released/
Yes, it's my choice to make it a "Story for members". I'm experimenting with that setting for a while. According to Medium: &gt; Currently, Partner Program writers are paid every month based on how members engage with stories. Some factors include reading time (how long members spend reading a story) and applause (how much members clap). Each member’s $5/month subscription is distributed proportionally to the stories that the individual member engaged with that month. So if someone engaged with 10 stories in a given month, their monthly subscription would be distributed to those authors only.
What is benefit of using turbolinks instead of react router?
Thanks for mentioning `Dry::Struct`. I wasn't aware of it but it looks very interesting.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/github] [Project structured\_log Goes Public](https://www.reddit.com/r/github/comments/87vr53/project_structured_log_goes_public/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I maintain a toolkit that is comprised of 50+ gems. I never worry about compatibility with Rails. None of the gems we publish are warrantied to work in Rails, and we tell our user community as much. It's not really a matter of having to code defensively. It's a matter of someone choosing to continue to leverage Rails as a vehicle for adoption knowing full well that adoption is a path to social capital and the monetary capital that comes with it. Personally, I want to leave behind code that teaches how to design software rather than code that reinforces all the worst traits of geek society and psychology. When Rails devs stop indulging in constant reckless shortcuts, they'll be ready to understand how to design systems so that compatibility with an app server framework is irrelevant. But no one can learn that good stuff from Rails. It's a self-perpetuating hole-digging device that doesn't lead to better practice. If my software is good, it'll stand on its own, and I won't have to ride Rails' coat tails. In fact, I would be dishonoring myself and my teachers if I allowed myself to behave merely as a Rails sycophant. The Ruby ecosystem will improve by leaps and bounds when we all stop trying to balm our geek loneliness with Rails sycophancy. 
Also [Benchmark.measure](http://www.rubydoc.info/stdlib/benchmark/Benchmark#measure-class_method).
I'm assuming you are the lib's mantainer (sorry if you aren't). Any plans or guides on how to use this with an Expo app that has not (and will not) be ejected?
The languages displacing Ruby are Python and Javascript, not new ones. I referred to Indeed.com job stats and Github presence not Stackoverflow posts. I'm not arguing that Ruby isn't an accomplished, mature language. Just that it's losing some of its mindshare to other, established technologies.
Read your note in between of my rest time. Makes my brain comfier and relaxed.
glad to hear that! 😌 
Hey Sinatra Activerecord! It’s you!
cool but why xml rather than json or some format that's less of a clusterfuck?
You can configure ruby via various roles like: https://galaxy.ansible.com/geerlingguy/ruby/ https://galaxy.ansible.com/rvm_io/ruby/ - official rvm role https://galaxy.ansible.com/zzet/rbenv/ 
Got it, thanks. I was just wondering how it looks from author's PoV.
Does json has something like xslt? I could image that being possibly useful to view logs in browser and stuff like that. I have no relation to this project so I have no idea why they picked xml but my guess would be because it's more powerful than json (when you include technologies around it too).
Thanks!
I think that should be `name.capitalize!`
I expected click-baity content ("you don't need WebSockets!"), but this is actually a thorough explanation of the alternatives and their trade-offs with a nice summary table at the end.
Glad you liked it, that's exactly what I tried to accomplish :) I was a bit reluctant with the title since I didn't want to click bait people in something they wouldn't like.
I usually use Benchmark.realtime method to measure elapsed time. By looking at the source code, it seems to already use the clock monotonic since Ruby 2.3: http://ruby-doc.org/stdlib-2.3.0/libdoc/benchmark/rdoc/Benchmark.html
TIAL \(Today I actually learned\) how websockets work and that I don't need to implement them for my existing sites! Great read OP. Thanks.
Thanks! Hope the animations helped :)
Wow, never heard about Server-sent Events. Thanks! 
They did!
Something to note, we ran into issues with Passenger/Nginx bumping 2.4.3 to 2.4.4 and we had to manually update rubygems via `gem update --system` and rebundle to resolve it.
I use this sort of logging for automated testing. I don't want issues with whitespace or escapes, so I use XML. Actually the default indentation I usually use is -1 (all on one line), not 0 (no indentation) or 2 as in this project. That said, it would not be hard to change the output to something else. (The real-time log is a text file that is constantly flushed. Only when the log is 'closed' does it get converted to XML.)
Well, you'd have to buy `name.io`, but you can have as many subdomains as you want.
Thanks for the comment :D A lot of people don't know that there are alternatives to web sockets. I have this conversation (the post) at least three times a year. Even when people do know about the alternatives they don't know how to use them or they have some misconceptions about them. Not to repeat my self, I decided to write the conversation down into this blog post, and enrich it with more technical explanations and references to all the reading material I used to gather that knowledge. I hope the animations helped and that they were clear.
is there a jekyll tutorial on how implement that? I know express has one https://github.com/bmullan91/express-subdomain
No plans yet, but I think I would need react-native-turbolinks inside expo platform and it would need help from expo creator to do that.. Open a issue ticket please...
That’s the right way. But looking at the Ruby ecosystem, there are plenty of libs measure w/ Time.now. That’s why I wrote the article. 🙌
I can't be misusing it, because I never do use it, and I advocate removing its use everywhere I encounter it. An "admin" is a very lazy role to assign users of software systems, because the human beings seated in those roles almost always have a much richer role in the real world. Financial types and business developers want to look at financial data. Support staff want to be able to diagnose and rectify problems that users cannot. Your marketing department has a very different set of needs like tracking call to actions, clicks, etc. The presence of an "admin" role is almost always a tell that your organization is short changing the software needs of people within your organization. If you give all these different types of people a single autogenerated pile of CRUD views, it's going to be insufficient for everybody, for different reasons. Each _actual_ role is going to need that interface to be elaborated and specialized for their needs. With a single "admin" interface, you're going to be introducing changes for all actual roles, and end up with a complete mess. The time saved by ActiveAdmin is inconsequential next to the amount of time that eventually gets wasted. It's not hard to build better interfaces for the people that work at your organization. They deserve better than an "admin" interface.
Nice, I've been waiting for 2.5.1 for literally months, for some bugfixes for bugs identified and fixed soon after 2.5.0 came out, that did effect me. 
Wow the MRI EOL schedule has... escalated quickly. 2.3.0 is only a bit older than 2 years old, and 2.4.0 (the soon to be oldest non-EOL MRI) is only a bit older than a year old. If you installed an MRI more than 15 months ago and haven't upgraded, you are about to be EOL'd. 
I believe that will be true for any ruby upgrade ever? I think? 
Then I'm not sure what you think I should have inferred from the presence of "Admin" in the name of the gem. #1. There are plenty of tools to connect to a remote database that developers can use. They allow much better views into the system than autogenerated CRUD pages, because developers gain the full benefit of a query language (e.g. SQL). #2. Developers should not be going behind the scenes and changing data directly, outside the features deliberately afforded by the UI. I haven't needed to do something like this in years, and when I did, it was because I didn't know what I was doing and I made lots of mistakes. Not really a good reason to install a gem like ActiveAdmin.
&gt; There are plenty of tools to connect to a remote database that developers can use. They allow much better views into the system than autogenerated CRUD pages, because developers gain the full benefit of a query language (e.g. SQL). And lose all application callback and validation logic. &gt; Developers should not be going behind the scenes and changing data directly, outside the features deliberately afforded by the UI. I haven't needed to do something like this in years, and when I did, it was because I didn't know what I was doing and I made lots of mistakes. Not really a good reason to install a gem like ActiveAdmin. I don't agree. There are plenty of use cases for things developers should be able to do that users should not. I think you're assuming here is based on a model where you have a team of 50 mediocre developers vs a team of 5 good developers. The needs and use cases are completely different.
I've never had to before.
What could make you think I optimize for big teams? A few good developers is the only way to go. And good developers don't need rails consoles or admin pages, because they wrote good software that doesn't need it's UIs circumvented in order to "correct" the state. I thought you were talking about "looking" at data, to be honest. We can disagree about this, but let's get back to the main point for a second. Rails absolutely should not add ActiveAdmin (or it's ilk). 
&gt; And good developers don't need rails consoles or admin pages, because they wrote good software that doesn't need it's UIs circumvented in order to "correct" the state. I'm guessing we work on very different problems at very different scales. I don't have time to write UIs for every random need that may come up, I make bulk changes in a rails console at least once a week because the types of changes need are always variable and I can do them in ~10minutes vs what would likely require several days of UI development, that may only be used once or twice in the entire life of the company. Admin pages are always useful, any time biz asks a question about why some model is acting some way in some other system, I need to look at the data, and I may need to change it, and I want callbacks and validation to run. Again, I'm not spending a week to build a UI to answer a question that can be figured out with a little data exploration. Now, if all you do is build trivial CRUD apps, you many not see the need, but that is no reason to blanketly dismiss a useful feature.
I understand it's three versions... it's also 15 months. 
Uh, that would be a negative on building trivial crud apps. Backend systems that process millions of transactions without errors or the need to "cleanup" data is more accurate. Again, this doesn't need to be in something like Rails.
entirely different company than what? I've never seen Phusion or anyone I know who works for it pretend to be anything but Phusion. Not sure what you mean. 
Thanks for the post. I will try to use SSE next time I need long pooling or notifications in my services. 
[Towards the Ruby 3x3 Performance Goal by Vladimir Makarov](https://developers.redhat.com/blog/2018/03/22/ruby-3x3-performance-goal/)
Thank you for a great read. I aspire to the same when I write on Medium.
If your user initiates some long process and has to wait for 10-30 seconds, will you use server-sent events or respond with some spawned job id and initiate JS polling loop?
To check for intersection between 2 sets you could do: [1, 2, 10, 11].to_set.intersection([1, 3, 5, 7]) =&gt; #&lt;Set: {1}&gt; returns 1 since 1 is common
Express is a web server, which means it actually runs code when you visit a page on your site. That code can do different things for different subdomains. Jekyll is a static site generator. Jekyll runs once and generates plain static files that are then served by another web server (in your case it sounds like GitHub pages is doing the serving for you). That web server is what would need to be configured to serve different files in response to different subdomains. You probably want to look at GitHub pages to see if it supports configuring a subdomain as your customer domain. It's possible that there's no special config for subdomains and that all you have to do is make a DNS record pointing your subdomain at a separate GitHub pages repo with just the files for that subdomain.
You introduced the concept of "absoluteness," not me. Let's bring this into context. I made light of active admin by hyperbole meant for the sake of humor. There are lots of people like myself who have seen rails app after rails app that have been _harmed_ by the decision to install active admin, and then turn it into the de-facto interface for "admins" of the company. I get that you have a specific and different intention in mind when you use the gem. Great. That's not the point of my post. The point was that many of us write off the gem as being useless at best, harmful at worst. Why is that? Well, that "week" you think you'd spend writing an "admin" interface might not take a "week" for us. And it might not even matter next to the liftetime cost of exposing user interface that couples directly to database schema. So, we'll happily stand up actual interfaces designed for humans by humans in lieu of what we perceive to be autogenerated junk. So, neither of us are actually making absolutist "claims." The context of this thread, starting with my original reply, was one of humorous hyperbole. as I said. It wasn't a moderated debate, or scientific peer review. It was poking fun at gems that the author of the original post claimed ought to be baked in to Rails itself. And with respect to accuracy, and knowing when it is needed, I really don't care whether I meet your criteria of a good developer, as I suspect you don't care whether you meet mine. I aim to put all things in their proper context, neither overgeneralizing nor overspecializing. As one human being to another, though, I appreciate that you bring a different viewpoint. Cheers!
oh right, I forgot about that. That was silly, they got a lot of crap for it, I'm pretty sure they learned not to do that again. My experience with their software is that it's super solid. 
Content was much better than the title lead to believe. Almost didn’t click because of the click-baity ness, but changed my mind after reading the article. Seems like SSE is the way to go, although with Rails now having WS basically built in, that’s probably the “easier” method. 
If you use server-sent events, does the browser keep a connection open to your web server for... as long as the window is open? So you need a web app server that can handle tons and tons of simultaneous socket? Or does it somehow offload this to the real web server (apache, nginx, whatever), you don't need to worry about it in your puma/passenger/unicorn/whatever?
Client JS polling loop is a pain, messes up your logs and drives you crazy in development if you don't do something about it. But I still use it, cause I'm scared of websocket/sse, not really understanding them, heh. 
why dont you just do `@color_match &amp; guess`?
Could you post more of the code? I just copied and pasted it based on what you said and got the correct answer. How are you instantiating guess and color_match? Are you sure they're the same (try running `puts guess` and `puts @color_match`.) Is it possible one is a Set or is otherwise being uniqued? Also, note that if color_match is R, O, O, G and guess is R, R, R, R you'll get 4, since each R in guess will just match on the first one in color_match.
.include? looks at the entire @code array at once so it only goes in and +=1 once per i. You could use a count of i's in @code, but I prefer to use hashes as such: ``` arr1=["R","O","Y","G"] arr2=["R","R","O","B","I","V"] arr1.map{|x| [x,arr2.count(x)]}.to_h &gt; {"R"=&gt;2, "O"=&gt;1, "Y"=&gt;0, "G"=&gt;0} arr1.map{|x| [x,arr2.count(x)]}.to_h.values.sum &gt; 3 ```
I loved the way you wrote the article, but I'm sad to point out that your information is incomplete and leads to a wrong conclusion. For example, WebSockets provide reconnection handling through the `onclose` callback. Yes, a new connection (WebSocket) object needs to be initialized, but the feature is still there. Moreover, SSE events might be supported by many servers - but only on HTTP/1.1. This can present a huge problem if an SSE connection is attempted within an HTTP/2 stream. For example, when Ruby on Rails is used for SSE, the socket is "hijacked" from the server and handled independently, breaking any possible HTTP/2 connections. This also spawns threads that clutter the app for no good reason. SSE is an older technology, it's not new to HTML5. Still, there's a reason SSE isn't as wide spread as WebSockets even though it's older. SSE wasn't as accepted by browser or server maintainers due to the way the connection handling was designed. WebSockets solved many of the issues that prevented SSE from being widely accepted (such as adding protocol level `ping` capabilities). Other ,inor inaccuracies were also distracting. For example, you wrote that: &gt; It’s important to note that WebSockets convert their HTTP connection to a pure TCP connection. **This both wrong and misleading**. TCP/IP is a streaming based protocol while WebSockets (which, just like HTTP, run as an added layer over TCP/IP) is a message based protocol, allowing clients and servers to have distinct knowledge of the data (message) boundaries. The distinction is huge, as it allows for JSON data to be transmitted without worrying about data fragmentation of concatenation. --- Having said that, [Ruby support for WebSockets is in a bad way](https://bowild.wordpress.com/2016/07/31/the-dark-side-of-the-rack/). I'm trying to fix this with the [iodine HTTP/WebSocket server](https://github.com/boazsegev/iodine), but it's a long uphill climb. On Ruby, unless using AnyCable, iodine or LiteCable, SSE might perform better, but on any other platform (and especially considering the client side of things), WebSockets are by far superior.
couple weeks til you know your way around?
to_set should come with a disclaimer that a "require 'to_set"" is needed. :) anyway, doing a to_set.intersection seems like a long way to type "arr1 &amp; arr2" ?
Ok, I took the "Learn Ruby in Y minute" for experienced programmer. The Rails framework is really about memorizing. It's easy for those who want to make it their main framework but quiet hard if someone demand you to build a quick project with it. Like setting database, I thought it's easy to connect to different type of MySql with Rails but sadly no it's quiet a work compare to Laravel.
&gt; The Rails framework is really about memorizing. I disagree. 
Why not use set union? ``` arr1 = ["R","O","Y","G"] arr2 = ["R","R","O","B","I","V"] arr1 &amp; arr2 =&gt; ["R","O"] ```
op says "trying to capture how many elements the two have in common" ..... "For instance, if array1 is = [R, R, O, G] and array two is identical, it only shows three matching elements". He's also using an integer counter so I assume he wants a number. So for his example where he wants 4 but is getting 3: arr1=["R","R","O","G"] arr2=["R","R","O","G"] arr1 &amp; arr2 will result in 3, the same as his erroneous result. He wants how many of arr2 are matched to arr1, which is 4, which is provided in both my examples above.
It definitely is! Enjoy! :)
Ah, I missed that distinction. Set theory doesn't offer much in that case that easily counts dups. We could always embrace enumerable methods. arr1.collect.each_with_index { |el, i| el == arr2[i] }.count(true) 
&gt; For instance, if array1 is = [R, R, O, G] and array two is identical, it only shows three matching elements. OP wants @color_match to return 4. What do you think @color_match &amp; guess is going to return?
Laravel has a good career at my location but I'm trying to freelance and with Laravel, it's waste of time because the framework is too big for small project like the blog post, which is faster to build in Rails, but sometimes those kind of blog post also require to have API for mobile, a lot of backend service, crons job, mailing and real time with websocket which fall inbetween Rails and Laravel. I know both Rails and laravel could do both but the complexity, time and difficulty is the concern. I like Laravel though but as a developer, thing get bored and Ruby's syntax seem to be really intuitive and that make coding fun and hence having a good productivity. That what I'v heard of from other Rails developer, **Productivity**. About the database problem I complain is that. I setup Rails project without choosing database then I want to use Mysql from XAMPP but it's not just like eloquent where I only need to change the MySql server and database information, I need to do extra work just to get MySql run and that could done like 1 minute with Laravel.
&gt; arr1=["R","O","Y","G"] arr2=["R","R","O","B","I","V"] arr1.collect.each_with_index { |el, i| el == arr2[i] }.count(true) It's more like step over arr1 and see if arr2 at the same index has the same value, if so return true otherwise false. Then collect the truthy values and count the trues. It only works if the arrays are sorted. It also relies upon the arrays being the same length, because it's checking positional equivalence. I wasn't suggesting it as a serious solution. The right approach is to create bags of words with hashes like your approach and compare them.
&gt; So you need a web app server that can handle tons and tons of simultaneous socket connections? Yes, your server needs to be able to handle loads of concurrent connections. Though I'm not sure how any system would solve that except for detecting inactivity somehow. &gt; This is an issue with websockets too of course. I think ActionCable does some weird stuff to try and get around it? I forget/never understood the details. I wasn't aware that ActionCabel does some magic to solve that. I'll have to do a deep dive to see what is happening. &gt; Which is part of why I've always been scared of websockets heh. It's a tradeoff, as everything is. Perhaps Long polling is better suited for your needs. It periodically releases connections so that may be better for your needs.
To be honest, the last time I did that I just did a polling loop with a sleep of 2 sec. I decided to use that approach because: 1. It was in the admin section so I didn't care too much about UX 2. If the process is extremely slow then there is no point polling data in real time, the user wouldn't know the difference
It's about the same (implementation cost). To be honest, I prefer using SSE because it's just a mixin away, I usually only need to push information, and I usually generate Rails projects without ActionCabel (and then have to add them back in later). But I do understand why Rails decided to add WS. They are the all-around solution. You can push and receive information, most people know about them, and they are the first solution you find when you google for "real-time web".
**I believe you are mistaken (and sometemis wrong) on some of the points you make.** Here are the explanations: -- &gt;For example, WebSockets provide reconnection handling through the onclose callback. Yes, a new connection (WebSocket) object needs to be initialized, but the feature is still there. Perhaps you misunderstood, they don't offer it out-of-the-box, as in it's not part of the protocol, you the developer have to add it. **I mentioned in the article that all discrepancies between WS and SSE can be solved with libraries (when it comes to pushing data)**. -- &gt; Moreover, SSE events might be supported by many servers - but only on HTTP/1.1. They also experience more disconnections (by design) and end up very similar to long polling as far as resource consumption is concerned (albeit with a nicer code for the JavaScript client) That is true, but can be resolved if you keep a heartbeat. Note that WS also suffer from the same issue if you don't send a heartbeat. **Any browser, proxy, load-balancer will kill an idle connection after a certain time.** -- &gt; Moreover, SSE events might be supported by many servers - but only on HTTP/1.1 **True, though the same is true for WS** since they depend on the `Upgrade` header that was introduced in HTTP 1.1. The only method that universally works is Long polling. -- &gt; In addition, existing SSE support often breaks and HTTP/2 connections (which is part of the reason many Ruby servers don't support HTTP/2 just yet). I'll be hones, I don't have production experiance with H2. But I reasearched this while writing the article. From what I've read SSE should function better on H2 since it keeps a constant connection from the browser tab to the server. **So that may be an implementation problem, not a protocol problem.** &gt; For example, when Ruby on Rails is used for SSE, the socket is "hijacked" from the server and handled independently, breaking any possible HTTP/2 connections. This also spawns threads that clutter the app for no good reason. Now I understand your point. You are reffering to the fact that **Rack isn't HTTP/2 ready*** yet. There are still issues and as far as I know it is being worked on. &gt; SSE is an older technology, it's not new to HTML5. Still, there's a reason SSE isn't as wide spread as WebSockets even though it's older. They were created 2 years apart. &gt; Although SSE was presented as an improvement over the long polling, it's mostly synthetic surge around long polling techniques, especially where connection handling is concerned. **From reading the RFC I wouldn't agree**. SSE opens and keeps a conection open nad sends data when it has some. If the connection is idle for too long it's killed and then the client tries to reconnect. This was a good mechanism back in the day when infrastructur was harder to come by and was much more expensive. To solve this issue you just keep a heartbeat. Given, it's not the perfect solution, connections do drop when your internet acts up, but the automatic reconnection handling solves that (at least for my use cases). WebSockets solved many of the issues that prevented SSE from being widely accepted (such as adding protocol level ping capabilities, minimizing disconnections, preventing CGI applications from blocking, etc'). &gt; WebSockets solved many of the issues that prevented SSE from being widely accepted (such as adding protocol level ping capabilities, minimizing disconnections, preventing CGI applications from blocking, etc'). As far as I remember, and what I have read, WS ended up being more popular because it was a full-duplex connection, therefore it could solve all your real-time needs, while SSE is only half-duplex. Of all the thing listed I would only agree with `preventing CGI applications from blocking`, since WS utilizes a pure TCP connection instead of HTTP. In my opinion, all other things listed are non-issues or insignificant features (ping being a full-duplex only feature). &gt; &gt; It’s important to note that WebSockets convert their HTTP connection to a pure TCP connection. &gt; This both wrong and misleading. **Read the RFC**. It explicetly states that a HTTP connection is utilized to do the handshake, and so that HTTP server would see it as a HTTP request. Afterwards, HTTP is abandoned, and a custom protocol called hybd is used for further communication. **I wrote all of this in the article, and even linked to the RFC protocol specification.** &gt; TCP/IP is a streaming based protocol while WebSockets (which, just like HTTP, run as an added layer over TCP/IP) is a message based protocol, allowing clients and servers to have distinct knowledge of the data (message) boundaries. The distinction is huge, as it allows for JSON data to be transmitted without worrying about data fragmentation of concatenation. This part grinded my gears somewhat since it's a misconception I hear a lot. TCP is a **reliable streaming protocol**. Meaning that if I have a large message that can't be sent as one chunk over the network it gets spli into smaller chunks and sent that way. Those small chuks can arrive in any order (front-to-back, back-to-front, random), but the protocol numbers the chunks so that the receiver can order them. This is literally how TCP does this. This is in contrast to UDP, where the receiver has no way of knowing in which order it should put the chunks together. **Therefore we use TCP when we want to reliably deliver data, and UDP when we want to send a single atomic datagram and have to constrain our selfs to the size of the datagram.** Note that there are more things that make TCP a better fit, like acknowligments and packet resending. And note that UDP isn't useless, in fact you can implement TCP with UDP (an exercise we had to to in college). When you send a HTTP encoded message or hybd encoded message, or any other message for that fact it will get split into pieces and sent to the recipient where he pieces are assemled in the order they sender specified. **So your claim is false** except for the part that HTTP is an application level protocol, and that it introduces boundries to it's self. -- &gt; On Ruby, unless using AnyCable, iodine or LiteCable, SSE might perform better, but on any other platform (and especially considering the client side of things), WebSockets are by far superior. **I think you are in the wrong here.** I'm not sure how an implemetation of a protocol could make the protocol better or worse. The whole point of the protocol is that it porvides a standard interface. -- I haven't yet read the two proveded liks, so there may be another comment later in the day.
I hold the opposite opinion, I don't like Rails eating the world and integrating everything into the core, it crowds out alternative approaches. I'd rather have multiple libraries handling assets, real-time communication, uploads etc that could be chosen for specific needs.
&gt; TCP is a reliable streaming protocol. Although true, I think you may have misunderstood me. TCP/IP is a reliable **streaming** protocol, while WebSockets is a reliable **message** protocol. These are very different things. Messages (unlike data streams) might be more than a single packet or a single packet might contain a number of messages. The WebSocket protocol, feeds the client each message as a distinct entity. Unlike TCP/IP, which forwards the streamed data as a whole. There's more in my post that you have missed, but it's late for me and I'm off to bed. I will point out that while you might have more experience writing applications that use WebSockets or SSE, I as quite certain that I have are experience writing servers that provide WebSocket / SSE services to applications. Personally, from a server implementor's point of view, I highly recommend WebSockets. **For example, from a network perspective, one-way heartbeats are a waist of time**. They offer the server the chance to recognize a lost connection, but the client will never know the connection was abnormally lost (meaning the browser will keep waiting for SSE on a stale connection that's invalid). Another example is the question of long polling vs. short polling. SSE is exactly long-polling and was designed to allow better use of this technique. I think you were thinking of short-polling when you were disagreeing with my statement. Also, libraries have nothing to do with WebSocket vs. SSE. Libraries just make coding easier by allowing us to reuse existing code. No library is required to reinitiate a WebSocket connection, just a line or two of code (usually a single line, depending on how you wrote your client).
&gt; Also, libraries have nothing to do with WebSocket vs. SSE. Libraries just make coding easier by allowing us to reuse existing code. No library is required to reinitiate a WebSocket connection, just a line or two of code (usually a single line, depending on how you wrote your client). The same goes for SSE. I literally gave an example that keeps a heartbeat in the post. That's not the point, the protocol doesn't provide a mechanism for that, you the developer do. And I mention in the article that most implementations provide a mechanism/library for that bridges the gap. -- &gt; For example, from a network perspective, one-way heartbeats are a waist of time. They offer the server the chance to recognize a lost connection, but the client will never know the connection was abnormally lost (meaning the browser will keep waiting for SSE on a stale connection that's invalid). You are aware that most, if not all, WS libraries keep a heartbeat? Else the connection would be killed off while inactive. The exact same is done in SSE. For that reason I would argue you ar in the wrong. But to humor the latter point you make, the SSE JS API offers a callback to detect an errored/broken connection. The problem with SSE is that the server doesn't know when the client dropped until it tries to send a message to it. -- &gt; Another example is the question of long polling vs. short polling. SSE is exactly long-polling and was designed to allow better use of this technique. I think you were thinking of short-polling when you were disagreeing with my statement. **I will prove my claim that SSE is not logn polling by referencing the RFC here https://tools.ietf.org/html/rfc6202 and the specification here https://www.w3.org/TR/eventsource/#processing-model**. Polling constitutes that you constantly request for new data, if keeping an open connection is the same as constantly asking then everything can be considered either long or short polling. -- &gt; TCP/IP is a reliable streaming protocol, while WebSockets is a reliable message protocol. These are very different things. Messages (unlike data streams) might be more than a single packet or a single packet might contain a number of messages. The WebSocket protocol, feeds the client each message as a distinct entity. Unlike TCP/IP, which forwards the streamed data as a whole. I will quote my previos comment &gt; Read the RFC. It explicetly states that a HTTP connection is utilized to do the handshake, and so that HTTP server would see it as a HTTP request. Afterwards, HTTP is abandoned, and a custom protocol called hybd is used for further communication. I wrote all of this in the article, and even linked to the RFC protocol specification. I think you are hung up on semantics here, without actually reading the post throug. It explicetly states which protocol is used after HTTP is abandoned and even links to the RFC. I did misunderstand your point in the previous comment. Your correction here is truethy, higher level protocols implement logical boundries, TCP is only used for transport. &gt; I will point out that while you might have more experience writing applications that use WebSockets or SSE, I as quite certain that I have are experience writing servers that provide WebSocket / SSE services to applications. Personally, from a server implementor's point of view, I highly recommend WebSockets. I agree with that point. I haven't implemented a server as of yet so I can't atest for that perspective. I don't have a favorite, I try to use the apropriate tool when possible. Though that said, your comments regarding SSE are misleading.
Oh the good old days of long polling
Did you even read what he wrote? he said "on osx", osx has dtrace. And it doesn't look like rbspy is using it. Downvoted.
arr1=["R","O","Y","G"] arr2=["R","R","O","B","I","V"] # init a hash with uniq key mapping = Hash[(arr1|arr2).zip([0] * (arr1|arr2).size)] arr1.each { |e| mapping[e] +=1 } arr2.each { |e| mapping[e] +=1 } # mapping result { "R" =&gt; 3, "O" =&gt; 2, "Y" =&gt; 1, "G" =&gt; 1, "B" =&gt; 1, "I" =&gt; 1, "V" =&gt; 1 } 
what is the difference between tcp and http connection ? Why does the author want to convey when he say websockets first use http and move to tcp 
TCP is the transport protocol for HTTP. The WebSocket handshake looks like an HTTP request, but after the handshake is done, HTTP 1.1's Upgrade feature is used to switch protocols. Thus the connection is dropped from the application layer HTTP to just TCP and the over the TCP connection the HYBD protocol (application layer) is used. I wrote the same in the post and linked to the RFC explaining it.
While some approaches here look promising I think the easiest and safest way to not worry about counting duplicate entries more than once is to delete them as we go. ``` code = %w{R R O B I V} guess = %w{R O Y G R} matches = guess.each_with_object([]).with_index do |(g,a), i| mi = code.index(g) a &lt;&lt; code.delete_at(mi) if mi end puts matches.size ```
You will always have the choice to choose what you want. I just think Rails should be opinionated so that most projects use the same solutions.
You will know your way around one admin system that's use across 90% of projects if it's baked into the framework. As it is now you'll probably have to learn 2-3 admins if you stay in Rails long enough
Thank you You mean to say sockets use tcp protocol but other methods use http protocol ? 
Yes and no. Socets use the HYBD and HTTP protocols in conjuction on the same TCP connection. So they convert their HTTP connection to HYBD connection. All other methods just use HTTP over TCP.
New projects will most likely use libraries conveniently placed in Gemfile and some of the existing projects will move to libraries provided by Rails because these libraries will be supported as long as Rails is supported. So development of other solutions will be crowded out.
I'm not exactly sure what you want, but I can see a couple options as potentially useful. If you just want to know how many elements in `guess` match any element in `code`: guess.count { |el| code.include?(el) } If you want to know that elements in `guess` match the elements with the same position in `code`: guess.zip(code).count { |a, b| a == b } I like the suggestion I saw in another comment about keeping track of the count of each letter in a hash (although you may not need that information). Here's how I'd implement it: guess.zip(code).each_with_object(Hash.new(0)) { |(a, b), acc| acc[a] += 1 if a == b }
Well [here's](https://github.com/jwhitish/learning-ruby/blob/master/mastermind.rb) the whole embarrassing thing... Still at the 'does it work at all' stage of learning rather than the 'is this the most efficient way'. Eventually it will also have to check for how many of the positions are the same as well, but got caught up on counting how many items were the same.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [jwhitish/learning-ruby/.../**fb546d73570248abe245c5913496571c5e7491c1mind.rb** (master → fb546d7)](https://github.com/jwhitish/learning-ruby/blob/fb546d73570248abe245c5913496571c5e7491c1/fb546d73570248abe245c5913496571c5e7491c1mind.rb) ---- 
Ragarding &gt; Yes, you do link to the RFC, but both your text (in bold) and images claim the protocol is pure TCP/IP, which is much scarier than a message oriented protocol with an API that responds to messages (or events) rather than a data stream. I'm sorry to point out that providing a link to the RFC doesn't make the incorrect statements less misleading. Here is the quote from the article: &gt; It’s important to note that WebSockets convert their HTTP connection to a pure TCP connection. In other words, a WebSocket connection uses HTTP only to do the initial handshake (for authorization and authentification), after which the TCP connection is utilized to send data via the hybd protocol. It's clearly stated what and how is used. I do agree that the animation is misleading but after giving the article to a few frineds they didn't notice that the text changed when I animated both protocols. -- &gt; Here again you point out a statement that is unfounded, adding a link that shows that nginx does support WebSockets (rather than showing that WebSockets aren't supported). After you configure it to do so, yes. And it says so in the text you qouted. &gt; Hmm... did you read the RFC you're referencing and the description about long-polling? It's quite clear by reading it that it's an attempt at improving long-polling and solving some of the (mostly) client side issues. Since you linked to it I guess you read it. How can the described proces, of the client constantly asking the server in short or long intervals be the same as opening, and keeping, a connection open to the server. The linked RFC even clearly differentiates streaming from polling. -- &gt; It didn't help much with server-side concerns, as long polling and SSE implementations (on the server) are almost identical. I don't have much experiance with this. But I don't see how long polling is different from a regular HTTP. While SSE streams data and utilizes the connection in a different manner, I'd claim that SSE is implementation wise more similar to WS than LP - both keep the connection open and send data to it as and when they see fit (with WS having the added benefit of it being full-duplex). &gt; The issue I was referencing is known as the half-open connection, which would leave the browser (which doesn't send a heartbeat) hanging. First the article states that this is an issue that polling services don't experiance. Second, you are correct this is an issue. The browser will hang until it times out. Though SSE enables the server to set the timeout of the client. &gt; I guess if I took my time to write such a detailed and long post I'd be pissed off at anyone claiming I overlooked any information. You clearly did a lot of research, so it pains me to say that you missed important information regarding networking concerns. You are right. I am emotional because I put a lot of time into researching and fact checking everything. But what angers me in this conversation is that we are eather constantly misunderstanding each other, or that one of us is blind to the other's arguments. &gt; SSE is less "safe" to use and is more likely to experience message failure than WebSockets. This is always true, but even more so on mobile networks. I would argue they are the same. I can't test it at the moment, but if I find the time I will. Both rely on the underlaying TCP connection to do the heavy lifting. SSE will reconect automatically, WS will detect the dropped connection and reconnect. I don't see how they are less safe though. They are as safe as HTTP. &gt; Errors are more likely to be detected when using WebSockets. True, all full-duplex connections provide more information than half-duplex ones.
&gt; Since you linked to it I guess you read it. How can the described proces, of the client constantly asking the server in short or long intervals be the same as opening, and keeping, a connection open to the server. The linked RFC even clearly differentiates streaming from polling. Long polling doesn't reflect the interval of time on the client side - it reflects the time interval on the server side. Log polling opens a connection and defers / pauses the connection. The connection remains open until data is available. The data is sent through the open connection (pushed). Depending on the client, the connection might need to be closed and re-established at this point or it might be kept open in wait for another event. When using long polling, there should ( in theory) be no interval between polling connections. The moment a connection is closed, a new one should be opened. &gt; SSE will reconect automatically, WS will detect the dropped connection and reconnect. I don't see how they are less safe though. They are as safe as HTTP. This assumes the network level doesn't experience errors. This isn't always the case. SSE will reconect automatically only if the connection was closed without a network error. If the connection was lost (rather than closed), SSE will (hopefully) time out. WS pings will shorten this "window" and minimize connection loss. &gt; You are right. I am emotional because I put a lot of time into researching and fact checking everything. But what angers me in this conversation is that we are eather constantly misunderstanding each other, or that one of us is blind to the other's arguments. I really hope it's us misunderstanding each other. It's a great blog post and I assume it will be here for a long time. My hope is that the few incorrect details in your blog post could be updated to better reflect the cons and pros of each approach. As it stands now, I fear that newer developers might misunderstand the technologies, which you try so hard to clarify. I'm not claiming SSE isn't terrible. It was created to improve the internet and simplify long-polling techniques and the hacks and protocols that started to sprout around it. However, I believe WebSockets provide a better (as well as newer) approach at the cost of client code complexity (many people don't know what to do with a full duplex connection and there are more things to consider). I might be biased since I'm looking at this from the server's point of view rather than the application's point of view. Also, I don't know how many HTTP/2 servers will end up supporting SSE since it adds a lot of complexity (while WebSockets will never be initiated using an HTTP/2 connection, so server implementors don't need to worry about that). After all, too many technologies assume the CGI approach towards HTTP requests, which isn't very SSE friendly.
Wow. That’s amazing. Didn’t know it existed.
Whoah! That is so much simpler than the hash thing! (And doesn't require another gem to work!) The first two lines are exactly what I was trying to figure out. Thank you!
&gt; I'm pretty sure they learned not to do that again. Until they come out and apologize publicly, or make some other effort to demonstrate that they understand why it was wrong, I can't see any reason to believe that they know better now. &gt; Everyone has bad ideas sometimes. If they had acknowledged it as a bad idea, then I'd be more willing to write it off, yeah. But at the time, one of their employees basically told me outright that I "had no right" to feel deceived. When given the opportunity, they doubled down and insisted that they were right. So, admittedly this is just my opinion, but fuck that guy, fuck the managers that told him to behave that way, fuck the people who paid the managers to do it, and fuck the shareholders who profited from it all.
my relationship with system load numbers is essentially "what's that? 7? that seems high. or low."
I keep forgetting some people do deploy Ruby as desktop apps. Fair enough but I think it's a little dismissive to call something "fairly trivial" when no one else has built a zero-code, low-overhead, cross-platform profiler for Ruby. That's an amazing feat by Julia.
See this FAQ on the front page of the Ruby bug tracking system because people ask this so often. https://bugs.ruby-lang.org/#Floating-point-numbers TLDR: the floating point data structure is not able to represent all real numbers with perfect precision. This should be obvious, because there are an infinite number of real numbers, and a finite number of bits in your computer.
thanks!
fyi, this is not just a Ruby thing.
&gt; Long polling doesn't reflect the interval of time on the client side - it reflects the time interval on the server side. &gt; &gt; Log polling opens a connection and defers / pauses the connection. &gt; &gt; The connection remains open until data is available. &gt; &gt; The data is sent through the open connection (pushed). Depending on the client, the connection might need to be closed and re-established at this point or it might be kept open in wait for another event. &gt; &gt; When using long polling, there should ( in theory) be no interval between polling connections. The moment a connection is closed, a new one should be opened. Ok. I don't see the difference between what you described and what WebSockets do. How do they differ? &gt; SSE will reconect automatically only if the connection was closed without a network error. If the connection was lost (rather than closed), SSE will (hopefully) time out. WS pings will shorten this "window" and minimize connection loss. As far as I know SSE will still try to reconnect even when there was a network error. To test this out I just walked to a cafe with my laptop open, the moment I connected it to wifi the connection was re-established. But WS will reconnect faster than SSE. &gt; I'm not claiming SSE isn't terrible. It was created to improve the internet and simplify long-polling techniques and the hacks and protocols that started to sprout around it. However, I believe WebSockets provide a better (as well as newer) approach at the cost of client code complexity (many people don't know what to do with a full duplex connection and there are more things to consider). I might be biased since I'm looking at this from the server's point of view rather than the application's point of view. Also, I don't know how many HTTP/2 servers will end up supporting SSE since it adds a lot of complexity (while WebSockets will never be initiated using an HTTP/2 connection, so server implementors don't need to worry about that). After all, too many technologies assume the CGI approach towards HTTP requests, which isn't very SSE friendly. I didn't quite get the H2 and WS part. But I do agree that the CGI/Rack approaches to request handeling have issues regarding streaming data (in general). Are you aware of any alternatives or some reading material. I did skim through the post you linked in your original comment but didn't quite understand how you could implement a connection pool without using threads, select, poll, and epoll but I'll have to deticate more time to it. &gt; I really hope it's us misunderstanding each other. It's a great blog post and I assume it will be here for a long time. My hope is that the few incorrect details in your blog post could be updated to better reflect the cons and pros of each approach. As it stands now, I fear that newer developers might misunderstand the technologies, which you try so hard to clarify. Would perhaps an update of the animation suffice? I do agree that it's misleading. And thank you for the kind comment.
Computerphile / Tom Scott: https://m.youtube.com/watch?v=PZRI1IfStY0 explains why in more detail. Also, see the nerdiest/coolest URL ever https://0.30000000000000004.com 
&gt; Long Polling allows the server to push data, but it doesn't allow the client to send new data (the client will send data using a separate connection). I think this is the part where our opinions differ. I do link to the definition of polling (CS term) in the article - it states that polling is any kind of waiting for a response from another party by actively checking if there is a response available. I also link to the definition of long polling. What you are describing is a half-duplex connection. Which isn't by its self a polling mechanism. SSE streams data from the server to the client, meaning that the client only asks the server once to be notified about events. I haven't checked, but I would guess that browsers use event based interrupts to handle streaming, which is fundamentally different from polling. &gt; The idea was to allow the server to keep the IO objects and requiring the server to take care of the WebSocket protocol details (allowing the server to use whatever design it deemed best). That's a great idea. It would make things much simpler for all kinds of streaming responses. Though I would figure that it would become hard to detect stale connections and clear their IO objects then. Though I could think of a few solutions to that issue. &gt; Even on the server side, there's no actual need for threads, but epoll / poll are required (select will break down and can't be used for long term concurrent connections without adding sever limitations). It's possible by using an event queue. All events are pushed to the queue and handled from the queue. libuv (node.js) uses this exact design. I ended up staying up late and reading through different material about handling a large number of concurrent connections and figured that `libevent`'s `kqueue` seems like the way to go. Though I would guess that `epoll` would also do the trick quite well. &gt; It's your blog post. Do you think the animation is the only thing you would like to clarify? I ended up updating the animation and changing the word TCP connection to HYBD connection. I also updated the table at the end, as it containt the tab typo which you pointed out, completely missed that, the table is from an really old version of the post. 
Hey! I've updated the wording in the article to make this clearer as, by now, 4 people have complained that it's confusing.
&gt; I think this is the part where our opinions differ. I do link to the definition of polling... You can find more information [here](https://stackoverflow.com/questions/11077857/what-are-long-polling-websockets-server-sent-events-sse-and-comet), [here](https://stackoverflow.com/a/28197906/4025095), and [here](https://stackoverflow.com/a/10029326/4025095). This might mean that you will need to update your description (in the blog post) about long-polling... however, I would just fix the name (to short-polling), since this seems to be what you actually meant to write about. &gt; I also updated the table at the end, as it containt the tab typo which you pointed out... Nice, it looks better now that the limitation of 6 connections is clearer. I would consider could adding a bit of a warning about multi-tab performance in the conclusion. For example, what happens when I open the same web page in 7 tabs? The answer would be that the 7th tab wouldn't load the web page (there are no available connections to request the page, they are all busy). Even after the web page finally loaded (after an SSE connection was lost and before it was re-established), the implementation is broken (no connections available for SSE). I don't know about you, but I often open a bunch or tabs, especially when I'm chatting on Facebook or doing something similar in real time... so I'm assuming the warning might be important for some developers. &gt; I ended up updating the animation and changing the word TCP connection to HYBD connection. Where does the HYBD name come from? I thought the protocol is called WebSockets. I couldn't find any reference to HYBD. &gt; Though I would figure that it would become hard to detect stale connections and clear their IO objects then. Since the server will be in charge of these concern, it's okay (the server has enough data to handle these situations). The application can provide callbacks that respond to the network events, but the application (in theory) wouldn't have direct access to an IO object. For example, consider this Websocket Ruby chat application (run in `irb`, I took the example from [here](https://github.com/boazsegev/iodine/blob/40daa31c148cad548a59b0e2f6b3c4f8eef4ec89/examples/redis.ru)): require 'iodine' # A simple router - Checks for Websocket Upgrade and answers HTTP. module HTTPRouter # This is the HTTP response object according to the Rack specification. HTTP_RESPONSE = [200, { 'Content-Type' =&gt; 'text/html', 'Content-Length' =&gt; '32' }, ['Please connect using websockets.']] WS_RESPONSE = [0, {}, []] # this is function will be called by the Rack server (iodine) for every request. def self.call env # check if this is an upgrade request. if(env['upgrade.websocket?'.freeze]) env['upgrade.websocket'.freeze] = WSChat.new(env) return WS_RESPONSE end # simply return the RESPONSE object, no matter what request was received. HTTP_RESPONSE end end # A simple Websocket Callback Object. class WSChat def initialize env @name = env['PATH_INFO'] &amp;&amp; env['PATH_INFO'].length &gt; 1 ? env['PATH_INFO'][1..-1] : "guest" end # seng a message to new clients. def on_open subscribe channel: "chat" # let everyone know we arrived publish channel: "chat", message: "#{@name} entered the chat." end # send a message, letting the client know the server is suggunt down. def on_shutdown write "Server shutting down. Goodbye." end # perform the echo def on_message data publish channel: "chat", message: "#{@name}: #{data}" end def on_close # let everyone know we left publish channel: "chat", message: "#{@name} left the chat." # we don't need to unsubscribe, subscriptions are cleared automatically once the connection is closed. end end # this function call links our HelloWorld application with Rack Iodine::Rack.app = HTTPRouter Iodine.threads = -2 Iodine.processes = 1 Iodine.start The application uses the `iodine` gem (an HTTP / WebSocket server). So you will need to install it first. &gt; figured that `libevent`'s `kqueue` seems like the way to go. Though I would guess that `epoll` would also do the trick quite well. `libevent` is an abstraction layer. Under the hood it uses, `poll`, `epoll`, `kqueue` and even `select`, depending on the system and the configuration. `kqueue` is used on BSD systems (there's a Linux port as well, but it wasn't incorporated into the Linux kernel) and `epoll` is the newer Linux variation. This is rare case in which a newer technology is of lesser quality than an older one (`kqueue` is superior by design). `poll` is the older (though more portable) variation, but it uses linear time, which hinders performance. 
&gt; Where does the HYBD name come from? I thought the protocol is called WebSockets. I couldn't find any reference to HYBD. Fixed. I'm not sure where I got that name from I thought I read it in the RFC, but after looking at the link I provided I couldn't find it.
Wise decision. There are a few more notable differences, like websockets allowing binary, but it's overall a good post explaining the options for streaming over web protocols.
Months?
&gt; It's an alternative to having to run a production console or drop to raw sql every time you need to look at the data. And it is better than those alternatives because...?
[For anyone like me which has no fucking idea what this is about](https://www.cryptokitties.co). Also, all about this [hodl](http://knowyourmeme.com/memes/hodl?full=1) thing the repo descriptions keep going on about.
I deploy with Chef / K8s depending on project, in both cases the version is read from `.ruby-version` which is committed to the repo. Ruby version is checked and upgraded if needed on each deploy either by baking it into the container or changing the version installed with Chef. I'm not sure what you would need a long restart window for, the new version is pulled and built while the old version is still running. I guess the CPU load could be an issue if you're compiling ruby on each box, which isn't a great idea, use packages for whatever OS you're using, e.g. brightbox PPA for ubuntu or build your own. You do get some amount of extra CPU load due to bundler needing to do a clean install for the new version, but I've not noticed this having enough of an impact on app performance to be concerned.
https://bugs.ruby-lang.org/issues/14403
At edX we used AMIs configured via Ansible. Aside from major language upgrades that might be backwards-incompatible with the code, language upgrades should not be dependent on code changes. Ideally, to mitigate issues, you should deploy language upgrades on their own. For other projects, I am using Docker. Similar principles apply—upgrade the language separately. 
With nginx, for example. Jekyll makes your website ready to serve. You need some way to serve them.
I never said the happy path is very wide.
Build a new docker container with the correct ruby, blue-green deploy, no downtime.
I agree that ActiveAdmin/RailsAdmin don't belong in Rails, but disagree that data cleanup is never needed. I've seen bugs make it to production that corrupted millions of rows of data.
There is nothing Jekyll specific that has to happen. Build a site and set it to the subdomain you want. Build another site and set to the other subdomain.
I believe it's also newish, but I'm having trouble finding docs on what version of ruby it was added in. 
This. Passenger is the true nightmare. Never really know why it works or why it doesn't. 
[2.3](https://github.com/ruby/ruby/blob/v2_3_0/ChangeLog#L1169) - [feature 11782](https://bugs.ruby-lang.org/issues/11782)
Not really an answer to your question, but some might find it interesting. I work at Heroku. I maintain the Ruby buildpack and "own" the Ruby experience on the platform. When a new Ruby comes out we compile it and make it available on the stack. For the most recent version it was up same day of the release. People can get the new version by specifying it in their Gemfile (though really Gemfile.lock). Internally we communicate when security patches are made. We have a security team. They look at the CVEs and grade them for severity/ease-of-exploit. Based on that they make recommendations to any teams affected (i.e. "DROP EVERYTHING NOW", or "upgrade whenevs"). From there it's up to each team to rev their versions and report back to the security team. MRI supports last 3 versions of Ruby, and a new version is released every christmas day. So subtract 3 from the current release on christmas day and that version is no longer supported. For example 2.5 was released this last Christmas, which means 2.2 was no longer supported (though they did do one extra security release cause, they're nice). I personally try to stay on the latest patchlevel of what ever Ruby minor version i'm on. I.e. if I have a project on 2.5 right now it's using 2.5.1. I generally try preview releases on a staging app. I try to upgrade and stay on the latest when they come out. If I had a really big app I might wait a month or so to see if there is an x.x.1 release with some bugfixes. Heroku review apps are great here. You can open up a PR with the new version, you get all your tests run and a staging app deployed all in one place. In general I find that lagging behind in releases or trying to skip versions to be pretty painful (unless there is a HUGE bug or really bad behavior, for example 2.1 GC did not play nice with some people's apps AT ALL). If the team is looking for a time trigger as to __when__ to upgrade, a week or month right after a new release comes out is a pretty good trigger. Then you also get to utilize all the cool new features earlier. This also has the side effect of most apps using versions pretty close to one another so devs aren't surprised by behavior/bug/feature differences when switching apps. 
I'm not sure what had been the deceptive part around "Raptor" ... but I've been using Passenger for years, and that's been the easiest way to deploy Rails apps for me. So, thanks again for all the OS contributions.
Change .ruby-version, Gemfile, run tests, open a branch. Wait a green CI, merge the PR. CI deploys on Heroku, done.
I i really a string? 
We use Salt Stack &amp; bump the ruby version in our config file, we use RVM still to not mess with the running production code dependencies install it and dependencies along side it, then after ruby gems are installed, apps deploy w/ updated ruby version in gemfile it does a rolling hard-restart rather than a typical rolling phased restart. Often we'll target the non-autoscaling servers first, then the auto-scaling ones second so there's no interruption/delay of service Old ruby versions get cleaned up after deploy
On Cloud Foundry: * upgrade buildpack to desired version * `cf push your-ruby-app` * that's it!
&gt; i really a string? Yes, both `String#%` and `Fixnum#chr` return a `String`. Ruby doesn't have any kind of character class.
Depends on where do you work. In my country 99% of Ruby vacancies are Rails. In US only 50% -- you can see it from job search sites feeds.
 Most importantly: *don't copy code unless you understand what is does*. Read [the documentation for `Net::HTTP`](https://ruby-doc.org/stdlib-2.5.0/libdoc/net/http/rdoc/Net/HTTP.html). Your not closing your file descriptors. A long running process may runout of them and error. `JSON.parse(request.body) || {}`. Under what circumstances will `{}` be returned? Check HTTP response content type before parsing is as JSON. What if HTML is returned? You should [request/response lines](https://github.com/bajratech/khalti-ruby/blob/master/lib/khalti/transaction.rb#L14-L20) into a `get(path)`, `post(path, params)` methods. Create an exception class (or several), catch the various exceptions that can be raised by your HTTP and JSON code, and raise a meaningful exception using your class. [No need to use interpolation](https://github.com/bajratech/khalti-ruby/blob/70a40a0778f6c40c93d11891bf26833e34943ea3/lib/khalti/verification.rb#L15) when the variable is already a `String`. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bajratech/khalti-ruby/.../**transaction.rb#L14-L20** (master → 70a40a0)](https://github.com/bajratech/khalti-ruby/blob/70a40a0778f6c40c93d11891bf26833e34943ea3/lib/khalti/transaction.rb#L14-L20) ---- 
[Specification](https://bugs.ruby-lang.org/issues/11782): &gt; +'foo' returns modifiable string. &gt; -'foo' returns frozen string (because wasters will freeze below 0 degree in Celsius). Wow. 
For me personally it's a system update as I use system Ruby. At work we update Salt definition which is then used during a Docker build (we use Dokku).
Ha, that's a good one.
https://stackoverflow.com/questions/13185814/how-github-enterprise-protects-the-code-they-deliver-on-virtual-machines https://news.ycombinator.com/item?id=9930838 http://blog.orange.tw/2017/01/bug-bounty-github-enterprise-sql-injection.html
I'm not sure you could hide the code unless you prevented them from accessing the machine. If you absolutely need them to not see it then perhaps you could provide them with a VM appliance / image which will run the site on a predetermined port. That's all I can think of 🤔
You should look into turning your app into [an executable](https://www.ruby-toolbox.com/categories/packaging_to_executables). It does not necessarily mean that one wont be able to see the source, and I'm not familiar with the linked solutions. But it's worth checking out. 
thanks!
Use a language other than ruby. 
- When a new version gets announced, I, or one of my colleagues PRs a change to our base images. (Alpine and Debian variants) Rebuild sends webhooks to a bunch of places, so most apps automatically get a new PR with that new base image. CI load spikes as we rebuild a few hundred Docker images and test basically the entire organization's codebases. - Teams deploy new Ruby version within a week, typically. May take a month or so to hit production, but our staging servers tend to run on the latest base image. (ChatOps bot will DM any people that deploy to staging something that runs on an old version of the base image.) - While Ruby versions may get EOL'd on their own cycle, we use _one_ (or two) internal base images, and the EOL for those is 4 versions out-of-date. (Our chat bot pings the devops team before deleting those images from the Registry, but does that automatically once approved.) - We also run a Canary staging server which runs the canary version of the base image that gets rebuilt every hour, and some of our teams prefer to just use that for their work.
It doesnt work that way, supposedly..as he's asking on this subs. Anyway, all above solution feedback should have work, if there is *no effort* to checkout the written code on their side.
Great work. Loved it.
I have updated the gem source code with all the information provided above. Please take a look and let me know if I am missing anything. Thanks
Thanks!
No worries. But you're not quite there yet. Think simpler. Hone in on a specific post. How can you access that one post? In scraping, names like 'lpowm' are often randomly generated, or change from week to week. What's something about that post that reads (mostly) humanlike, and is unlikely to change? Inspect the element.
Do you mean `cron`? You can just make the Ruby script executable, give it a shebang line, and then add it to the `crontab`.
You want 'Create a basic task', 'Start a program', put the Ruby interpreter path in the program box, then put your Ruby script path in the arguments box.
that did it. for some reason in the arguments tab if I had a space in full path it went wonky. thanks a bunch!
That's pretty normal. Arguments to programs are separated by spaces. So if you ran the command ``` ruby /path/to/my program/with/spaces.rb ``` ruby would be passed 2 arguments instead of one. The first being `/path/to/my` and the second being `program/with/spaces.rb`. I'm pretty sure that ruby takes the first non flag argument as the file to execute and since `/path/to/my` doesn't really exist, it fails to run. If you want to have an argument that has spaces in it, you need to put that argument in quotes. So it would be: ``` ruby "/path/to/my program/with/spaces.rb" ```
Have you had any luck?
is this an april fools joke?
This is really interesting, I'd love to read about how you did this.
Unfortunately not, I had one quick pass at it last night. But most likely won’t get an opportunity to look again until tonight. But I appreciate the support!!
**Code style:** - Use `amount.to_i` instead of `Integer(amount)` - use `#==` instead of `#===` - Try running your code through Rubocop. There are some other issues a static code analyser will find **Testing and error handling:** You only test happy paths. * What if the server doesn't respond? * What if the API key is invalid? * What if the connection times out? * What if the server returns a response you don't expect? **Configuration:** * I cannot configure timeouts for HTTP connection. See [The Ultimate Guide to Ruby Timeouts](https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts) for more details * I can only configure your gem via env vars. It's a good pattern with Ruby Gems to expose a simple Configuration object; even an `attr_writer` would do in your case. **Error classes** You probably don't need this: class KhaltiError &lt; RuntimeError attr_reader :data def initialize(data) @data = data super end end As instead you can just do: class KhaltiError &lt; RuntimeError; end raise KhaltiError, "Invalid API_KEY" 
I had to use at_exit in order to clean up open files in my cucumber suite cause the effort involved in going through all the instances wasnt worth it ¯\\\_(ツ)\_/¯ i inherited some kind of monster
A 15 minutes video just to say "There is a method named `merge` which can merge scopes. Oh and check out default scopes, they are cool". Honestly it was not that bad until they introduced default scopes, that's a big no for everyone decent at Rails. Why show it in educational videos, as if juniors didn't have it hard enough.
&gt; So much words said and I still gave you no reason for avoiding at_exit right? Well it seems that every project using this feature is sooner or later being hit by bugs related to its behavor and tries to find workarounds So the argument is, if your code breaks someday, you shouldn’t have written it in the first place? Interesting write up about the pattern coming out of the language feature. While I agree that the code in use isn’t exactly endearing to look at, it makes it elegant to use. Which is what Ruby is all about, isn’t it? Make your language and libraries programmer friendly to use. Pay the cost of doing the complicated work in the library so that it’s users don’t have to. 
A gem for creating the charts perhaps?
I'm already using an external gem, and a js library for that. Unfortunately. Is it possible to drop a js script into a the custom gem file, and use that as your gem?
If you split your app into database web API + web app, then you could make a gem that wraps your API’s functionality for your web app. similarly, if are using any 3rd party web API, you could write a wrapper gem for it.
You can use ExecJS to do that but if you're a beginner you may find it very complicated.
Yea I'm a beginner to rails. I just need something quick, so I can gain some marks in my project.
Yes anything. Once we make a gem ourselves and it's somewhat relevant to the application 
.
I'm still really really confused. You have a boss or a client who is literally saying 'hey, we just want some features, that do anything.'
It's a college project. This is a sub part of the project. 
Not sure if I’m in the right place. But the link always contains the following ‘?tagged=ruby’. I could use RegEx and use .link(:url, /?tagged=ruby).click. But will need to wait until I get home to test it. 
Make a gem to support comments that can be attached to arbitrary other pieces of content. Add them to your charts thing, so logged in users can comment on charts.
Now you're thinking! Yes, you could use click. But then you still have the problem of having to revisit the hashtag page every time you want to view a new post. Is there a better way?
So, `\x00` actually means "one byte zero". And "\u0000" means "unicode codepoint zero". I suppose in different unicode encodings, unicode codepoint 0 can be other than one byte 0. For instance in UTF-16, it's two bytes of zeroes. I don't know what "\u0" is supposed to mean in an ASCII-8BIT/binary encoding, that's just a ruby mystery that it lets you do that and what it expects it to mean. 
&gt; Sure, but this is in utf-8 What makes you say that? &gt; # encoding: ASCII-8BIT
They do have different encoding (expected is utf-8, actual binary), but that should not matter: irb(main):001:0&gt; u = 'a'.encode('utf-8') =&gt; "a" irb(main):002:0&gt; u =&gt; "a" irb(main):003:0&gt; u.encoding =&gt; #&lt;Encoding:UTF-8&gt; irb(main):004:0&gt; b = 'a'.encode('binary') =&gt; "a" irb(main):005:0&gt; b.encoding =&gt; #&lt;Encoding:ASCII-8BIT&gt; irb(main):006:0&gt; u == b =&gt; true irb(main):007:0&gt; u =&gt; "a" irb(main):008:0&gt; b =&gt; "a" 
Why should the encoding not matter? When we know "\u0" is different bytes in different encodings?
Any chance you can post the entire test in isolation in a gist or something?
An unnecessarily snarky comment on free educational content just to say “Thanks for the video, but you might want to include a disclaimer about default scopes. They are usually frowned upon because they can lead to headaches.” Honestly your tone is unnecessarily rude. 
you can use a ruby encoder software to somehow encrypt/obfuscate the source code, i.e. https://www.rubyencoder.com/ and deploy it like this
Because it **can** be different bytes in different encoding, but they are not when talking about utf-8 and binary encodings: irb(main):001:0&gt; a = "\x00".force_encoding('utf-8') =&gt; "\u0000" irb(main):002:0&gt; b = "\x00".force_encoding('binary') =&gt; "\x00" irb(main):003:0&gt; a == b =&gt; true irb(main):004:0&gt; a = "\x04".force_encoding('utf-8') =&gt; "\u0004" irb(main):005:0&gt; b = "\x04".force_encoding('binary') =&gt; "\x04" irb(main):006:0&gt; a == b =&gt; true 
Because while it **can** by different byte sequence, it is not in this case (talking about utf-8 and binary), besides: irb(main):001:0&gt; "\x00".encoding =&gt; #&lt;Encoding:UTF-8&gt; irb(main):002:0&gt; "\x00" == "\x00".encode('binary') =&gt; true irb(main):003:0&gt; "\x00" == "\x00".force_encoding('binary') =&gt; true irb(main):004:0&gt; "\x04".encoding =&gt; #&lt;Encoding:UTF-8&gt; irb(main):005:0&gt; "\x04" == "\x04".encode('binary') =&gt; true irb(main):006:0&gt; "\x04" == "\x04".force_encoding('binary') =&gt; true 
I've figured kinda out what is the problem but have no idea if there is a bug or not... With test file require 'minitest' require 'minitest/autorun' class Foo &lt; Minitest::Test def test_with_bf expected = &lt;&lt;~EOF a \x00 b \x00 c \xbf d EOF r, w = IO.pipe w &lt;&lt; expected actual = r.read(expected.size) assert_equal(expected, actual) end def test_without_bf expected = &lt;&lt;~EOF a \x00 b \x00 c d EOF r, w = IO.pipe w &lt;&lt; expected actual = r.read(expected.size) assert_equal(expected, actual) end end One gets this as an output: Run options: --seed 58584 # Running: F. Finished in 0.003157s, 633.5929 runs/s, 633.5929 assertions/s. 1) Failure: Foo#test_with_bf [test.rb:20]: --- expected +++ actual @@ -1,7 +1,8 @@ +# encoding: ASCII-8BIT "a -\u0000 +\x00 b -\u0000 +\x00 c \xBF d So we can see that `\xBF` is the problem here (probably because it's invalid character in utf-8). The test without it passes. But on the other hand, the diff does not mark the `\xBF` as different and instead marks the `\x00` and `\u0000` as the cause. Is there a bug in the diff thing? Should I report this to minitest? 
One is a null byte, the other is a Unicode null, so it's actually two bytes of 0
I still have no idea what the fuck it's about. Is it like pokemon or some shit?
AFAIK `binary` is just alias for `ASCII-8BIT`: irb(main):003:0&gt; Encoding.find('binary') =&gt; #&lt;Encoding:ASCII-8BIT&gt; but it's possible I understood this wrongly
I'm doing a presentation tonight and I always like to have a text version as well, so if someone can't make it or if they want the code samples they can go there and grab them. There may be a video version too if I'm lucky, I'll post that here if there is one. The presentation is how to get data out of JSON apis and standard webpages, and even how to POST data if you need to. There's quite a few examples and reasons of why you'd use the specific method. Basically it's a nice primer for building scripts that interact with websites!
I've been thinking of hopping over to the nginx/unicorn side of the fence and seeing how green the grass is.
Authentication 
Is it greenee?
👍 Note that `JSON.parse` and `URI.parse` raise errors too. 
A web app in Ruby that's not Rack based... What are you using here? 
We changed from this gem to [Akismet](https://github.com/jonahb/akismet) last week. Works flawlessly, and easy to implement in most ruby apps. 
`request.halt response.finish_with_body("")`
What are your thoughts on query objects versus defining more scopes on the model?
API Clients shouldn't expose class level methods, because they lead to handle only one account at the time. In my understanding, your current design assumes one Khalti account. By looking at the `KHALTI_SECRET_KEY` that is unique for the OS/Ruby env. If you expose instance level methods, you can instantiate as many clients you need, one for different Khalti account.
How did you get on with this? Think outside of Watir, back to the main ruby methods involving Regex. How could you get the links to all the posts on a page, rather than just one at a time?
returns this: [1] pry(#&lt;Rack::Session::Cookie&gt;)&gt; continue ::1 - - [03/Apr/2018:21:12:00 +0800] "POST /users HTTP/1.1" 200 - 10.4500 2018-04-03 21:12:00 +0800: Read error: #&lt;NoMethodError: undefined method `each' for "":String&gt; /home/alex/.gem/ruby/2.5.0/gems/rack-2.0.4/lib/rack/body_proxy.rb:36:in `each' /home/alex/.gem/ruby/2.5.0/gems/rack-2.0.4/lib/rack/lint.rb:708:in `each' /home/alex/.gem/ruby/2.5.0/gems/rack-2.0.4/lib/rack/body_proxy.rb:36:in `each' /home/alex/.gem/ruby/2.5.0/gems/rack-2.0.4/lib/rack/chunked.rb:23:in `each' /home/alex/.gem/ruby/2.5.0/gems/puma-3.11.3/lib/puma/server.rb:757:in `handle_request' /home/alex/.gem/ruby/2.5.0/gems/puma-3.11.3/lib/puma/server.rb:438:in `process_client' /home/alex/.gem/ruby/2.5.0/gems/puma-3.11.3/lib/puma/server.rb:302:in `block in run' /home/alex/.gem/ruby/2.5.0/gems/puma-3.11.3/lib/puma/thread_pool.rb:120:in `block in spawn_thread' 
My bad, it should be `request.halt response.finish_with_body([""])`.
Thanks for sharing =) I like this pattern of injecting an object to help you interact with the storage in the way you need and not in the way that your storage mechanism provides... and I actually do things in a very similar way =) What I do different is that instead of creating a new QueryObject I just add those methods to the model and I move the function with logic `popular_sport_posts` to a kind of "facade" module or object... Although you don't actually say who has that `popular_sport_post`=) And other thing that I do slightly different and I want to show you, because maybe you can find something interesting is that I prefer not to use the mocking helpers from rspec like `instance_double` and use a regular fake object instead... for example in your example o would use something like... class FakePost attr_reader :comments def initialize(attrs) @comments = attrs[:comments] || [] end end class FakeComment attr_reader :published, :created_at def initialize(attrs) @published = attrs[:published] @created_at = attrs[:created_at] end end class FakePostsStore def initialize(posts) @all = posts end def sport_posts all.select { |p| p.category == 'sport' } end def sport_posts_count sport_posts.count end def sport_posts_with_published_comments sport_posts.select { |p| p.comments.any?(:published) } end def sport_posts_with_recent_published_comments sport_posts_with_published_commehts.select { |p| p.comments.any? { |c| c.created_at &gt; 30.days.ago } } end private attr_reader :all end describe 'popular_sport_posts' do def popular_sport_posts(store) Blog.popular_sport_posts(store) end def store_with(records) FakePostsStore.new(records) end def post_with(attrs) FakePost.new({category: "sport"}.merge attrs) end def comment_with(attrs) FakeComment.new(attrs) end context 'when sports posts count is less than 2' do it 'returns sport posts' do other_posts = [post_with(category: "other")] sport_posts = [post_with(category: "sport")] store = store_with(sport_posts + other_posts) result = popular_sport_posts(store) expect(result).to eq sport_posts end end context 'when sports posts count is less than 11' do it 'returns sport posts with published comments' do without_comments = 1.upto(7).map { post_with(comments: []) } with_unpublished_comments = [post_with(comments: [comment_with(published: false)])] with_published_comments = [post_with(comments: [comment_with(published: true)])] store = store_with(without_comments + with_upublished_comments + with_published_comments) result = popular_sport_posts(store) expect(result).to eq with_published_comments end end context 'when sports posts count is more than 10' do it 'returns sports posts with recent published comments' do with_old_comments = 1.upto(7).map { post_with(comments: [comment_with(published: true, created_at: 31.days.ago)]) } with_recent_comments = 1.upto(7).map { post_with(comments: [comment_with(published: true, created_at: 29.days.ago)]) } store = store_with(with_old_comments + with_recent_comments) result = popular_sport_posts(store) expect(result).to eq with_recent_comments end end end You would need to have a kind of "repeated" fake store but I think it helps reveal the expected data structure and to have a place in your tests where you are explicitly defining the thing that you want to interact with... Well that's all... It would be nice to see your thoughts about it =) 
Is this one of a series of posts?
[Update: just to be clear, by 'recursive' I do not mean a markdown file that includes itself, I mean an included file that includes other files.]
You should still be able to use ruby in it by appending a `.erb` file extension, e.g. `my_styles.sass.erb` The ruby gem for compiling sass will no longer be maintained.
I'm not sure this'll effect [sassc-rails](https://github.com/sass/sassc-rails), because I believe it uses the sassc library. But I've been using it for my last few projects and it's been pretty darn amazing thus far.
Yes. What you're describing is especially good when matched with domain driven design (DDD) and behavior driven development (BDD). I use DDD and BDD to create use cases in simple language such as "I am a [role]. I want to [goal]." Many people use DDD and BDD with similar kinds of language, such as "As a [role], I want [feature] because [benefit]." DDD and BDD help you explore the problem based on the user's perpective, and the business stakeholders' perspectives, rather than based on the technical feature. This tends to turn up many assumptions and also ideas for experiments. https://en.wikipedia.org/wiki/Domain-driven_design https://en.wikipedia.org/wiki/Behavior-driven_development
I haven't used `default_scope` in a codebase and not regretted it at some point in the future. I've ended up adding as many (or more) `unscope` calls as I would have manually added the scope, but with a lot more frustration when finding out where an `unscope` is need. Use with caution.
What does this mean for sass-rails? Is there a way to swap it for dart sass?
It does, sassc-rails uses libsass: https://github.com/sass/sassc-rails#sasscrails--
Seems like a big win for Dart. 
I dunno, Sequel looks more like an alternative SQL syntax than an ORM. 
Big deal for me. I don't use Node for anything and don't have any intention to start.
Agreed. I think you might need both though. 
Can you explain why this is a win for Dart? I'm clueless why dart sass would be the alternative to sass-rails
I recommend you to take a look at [rack-attack](https://github.com/kickstarter/rack-attack), open-sourced by kickstarter. https://kickstarter.engineering/rack-attack-protection-from-abusive-clients-4c188496293b
I’ve been hearing from at least one software partner that Dart is poorly-supported and seems to be on its way out. One plans to move from Dart to Java for server-side stuff. 
Because the canonical implementation of the most popular stylesheet language is going to be written in it. And, there's [this](https://github.com/sass/dart-sass/issues/248), though it's obviously very very early. 
The relation between everything Sass and Dart Sass is that Dart Sass is implementation that fully supports the Sass spec. If Sass 9000 comes out with some great features, they'll be in Dart Sass, at minimum. LibSass may or may not include them. So if you want to use feature X in Sass 9000 in Ruby, you may have to use the Dart Sass binary, or created some tie it into Ruby via Dart bindings. But if a new maintainer steps up, they Ruby Sass may never go away. I would read these: * http://sass.logdown.com/posts/7081811 * http://sass.logdown.com/posts/1022316-announcing-dart-sass 
I take it this affects SCSS users too?
Also this is good for bitcoin! 
Currently, It supports only one Khalti account. I will consider multiple Khalti account on next major release. Thanks!
Hey amalagg, you’re right, that’s the one-liner to do it. We’ll mention that in the article. Thanks! :)
Nice name! *^I ^don't ^have ^the ^experience ^required ^to ^comment ^on ^the ^actual ^code, ^will ^use ^as ^learning ^tool*
Creepy. Why do you want a tool like this other than to creep on people?
Well, it's geared to OSINT (open source intelligence) uses. For example, I use it occasionally to run analysis on ISIS or Al-Qaeda supporters on Reddit for a publication I write and edit for. It can be effective to determine if someone might be botting or pushing an agenda, too. 
Thanks! Feel free to PM with any questions. 
Are you using a particular cache in these blog posts? I'm just curious.
You need to write Ruby logic to do this. ``` abort 'too many arguments' if ARGV.length != 3 ```
What a timely article! Looking to improve our test suite in the near future.
The issues describe in the article are not specific to ruby, similar stuff is actually causing me a lot of pain on the current project. I have to say it seems like the support for testing, looking at something like Timecop, is much better in ruby, probably in dynamic languages overall since we get comfortable by stuff compiling without issues. I think developing an environment where your team can trust their test suite to great extend is extremely important and liberating. Working on a project where you are showered with constant false alerts and random test failures can be downright depressing.
looks great! will try it out after work. Thanks for sharing! =]
I don't have any experience with sizable codebases in dynamic languages so it is just my gut feeling that when working with static types, people put a lot of trust into them. That means that they can be less inclined to test thoroughly since entire class of errors is caught automatically. This can, however, result in insufficient testing that misses edge cases or some business logic quirks. I am guilty of this as well, demonstrated by my mention of Timecop. If I were to write a function that depends on specific time like your payroll example, I would design it in a way that it takes the times as arguments, without any dependencies on side effects such as the system time. This seems correct and it would make testing that function easy. But I would not even realize, at least immediately, that there should be a way to test it when has to rely. Just because I am thinking about how I would implement something like Timecop in Java, I am already realizing that this should be a separate function that can be then mocked in an integration test, but in the end it still gives me no way to actually test it easily by changing the system time. I think that in a dynamic language environment, since you have to rely a lot more on your test suite even for basic checking, you "get to" spend more time thinking about these kind of scenarios.
You are right, I just really dislike the use of something like `default_scope` in an edutational video, it can do more harm than good, so I most likely overreacted. That is no excuse to be rude :)
&gt; That means that they can be less inclined to test thoroughly since entire class of errors is caught automatically. Insightful observation! &gt; If I were to write a function that depends on specific time like your payroll example, I would design it in a way that it takes the times as arguments, without any dependencies on side effects such as the system time. I agree that trying to inject a time whenever possible instead of relying on a system time is the way to go. Thanks for sharing! :) 
Just curious, it doesn't sound like you use Ruby at work, why are you hanging out on this subreddit? Are you using Ruby mostly for scripting?
Cool! But still creepy. Politically a tough time to make this kinda stuff sound not evil.
you might want to look at [Thor](http://whatisthor.com/). it has lots of options to deal with arguments to a script and even provides a nice way to have docs for your script.
That is a common pattern, yes. Another approach would be to use something like a result object (e.g. https://www.rubypigeon.com/posts/result-objects-errors-without-exceptions/). If you are going to bubble errors up to users of your gem, I think it is generally a good practice to wrap those errors in an internal error class so that users can just do something like ``` begin parse! rescue =&gt; IndexJellyFishGemError # handle error end ``` though one might argue that you should just allow filesystem-related errors (e.g. `Errno::ENOENT`) to just bubble up as-is.
Thanks! That's very helpful. I hadn't heard of result objects, so I'll read about it. 
I don’t think recommending a framework for building a CLI as the answer to “how to error when less or more than three arguments are given” is really the best route. While it’s true that Thor is pretty nice, it’s severe overkill in response to the question.
Hi, great stuff. TIL about `stub_const`. Just a few questions: - Why did you do a `stub_const`, it seems like you can just use the actual data. - Redis tests, have you looked into things like [fakeredis](https://github.com/guilleiguaran/fakeredis) and what is the thought process behind using or (in this case not using) it?
Thanks, I've been using the Result objects pattern for awhile without knowing what it's called. Do you use the Result object pattern throughout your code?
happy learning :)
I like [Clamp](https://github.com/mdub/clamp) a lot.
I don't actually use ruby for anything right now. I've played with it occasionally throughout the years, never used it for a real project. I think it's useful to keep up with many different languages and tools even if you don't have a time or use case for them right now as they often deal with overlapping problems (and often in their own specific way) that you can apply to you work.
If you want something more focused try https://github.com/ioquatix/vips-thumbnail which can be easily combined with https://github.com/ioquatix/utopia-gallery and https://github.com/ioquatix/jquery-litebox for simple photo pop ups that work both on mobile and hi-dpi displays
`vips-thumbnail` was definitely one of the gems that I looked at, but for me it was lacking the following: * the user needs to manually save the file (ImageProcessing returns a saved `Tempfile`, ready to be uploaded) * it didn't use [`vips_thumbnail()`](http://jcupitt.github.io/libvips/API/current/libvips-resample.html#vips-thumbnail) * the "helper methods" approach doesn't scale for the reasons I described in the blog post * the Ruby code is written using tabs instead of spaces (I and most of the Ruby community prefers spaces)
A file based API might make sense in many cases but not all, especially if you are streaming to remote storage. vips_thumbnail didn’t exist when I wrote the original code but it might be something worth exploring. The ruby code does many similar things. The helper method approach is perfect if you just want something focused on resizing, but you are right as soon as you want to do more complex operations you need to compose that yourself. I’m glad you like using MRI which mixes tabs and spaces :D Good work on your gem :) 
&gt; A file based API might make sense in many cases but not all, especially if you are streaming to remote storage. That's an interesting point. Yeah, other than saving the processed image to a file, libvips also allows you to save it to an in-memory buffer. I don't know if in other languages this allows streaming, but ruby-vips just returns file content as a string, and I'm always vary of dumping file contents into memory. Is there a compelling reason to use that over saving to a temporary file? In my benchmarks I didn't see a performance difference. &gt; I’m glad you like using MRI which mixes tabs and spaces :D That's also a good point :P &gt; Good work on your gem :) Thanks!
It always confuses me how developers in Ruby community understand ISP principle. &gt; Clients should not be forced to depend on methods that they do not use. In your first example callers (Programmer, Administrator, Techincan) are not _forced_ to depend on Computer's methods that they don not use.
Shouldn't it be `204 No Content` if you have no plans of returning anything?
One reason to check out this gem: support for [libvips](https://github.com/jcupitt/libvips). If you have an app that uses ImageMagick to generate thumbnails, you could see a dramatic speed increase by switching to libvips. For instance, in my case, I saw about a 10X improvement! Also, the new chainable API is pretty dope and can really help reduce code bloat in your image processing code. (Full disclosure: I worked on this release.)
For my use cases, I rather save it to a file (and take the latency hit of having to talk to the disk), then take the RAM to keep it all in memory and have to pay for the RAM. When vips is generally good at _not_ loading the whole output into RAM when it doesn't have to, and is generally so much faster than IM even when I'm saving it to a file. 
So I took a look into this, and there's no bug here, because this is expected behaviour in Ruby. When Ruby prints non-printable characters in any encoding, it prints them with the `\x##` format, while things like UTF-8 characters are printed with the `\u####` format. You can see that they have specs for this more or less in https://github.com/ruby/spec/blob/master/core/string/inspect_spec.rb. For instance, take a look at the following: irb(main):068:0&gt; p 0x00.chr.force_encoding('utf-8') "\u0000" =&gt; "\u0000" irb(main):069:0&gt; p 0xBE.chr.force_encoding('utf-8') "\xBF" =&gt; "\xBF" irb(main):070:0&gt; p 0x00.chr "\x00" =&gt; "\x00" irb(main):071:0&gt; p 0xBF.chr "\xBF" =&gt; "\xBF" This is just the way Ruby prints non-printable characters, so Minitest and the test is not marking the `\xBF` as different because in both cases it is not different. Whether this is the expected or desired behaviour is another matter, but from the looks of it, it's not "incorrect", at least given that the behaviour is intended.
Yeah, I also always choose to rather save to disk rather than load into memory, because when the images are large you don't risk running out of memory, and when the images are small then it doesn't matter either way. You just need to make sure the temporary file is deleted after the processed file is uploaded/streamed.
&gt; If you have an app that uses ImageMagick to generate thumbnails, you could see a dramatic speed increase by switching to libvips. For instance, in my case, I saw about a 10X improvement! Fun fact: in the ImageProcessing test suite, the libvips tests are 4x faster than the ImageMagick tests :)
John Cupitt is a fucking beast, he keeps pushing out new releases for a multitude of languages, and he is really responsive if you have any questions or issues.
Thank you for your feedback. `Integer(amount)` throws an exception if amount provided is not number. This is the reason behind using this instead of `amount.to_i` I have fixed lots of issues reported by Rubocop and already pushed to the repo. Do you recommend any useful links that I can follow to improve testing and error handling? I haven't got chance to look into the configuration section. I will get back to us later. 
I'm actually currently using shell-out-to-vips-command-line in my current (non-shrine) code. jcupitt tried to convince me to use libvips instead, in part because I could do streaming, but [I wasn't having it](https://github.com/jcupitt/libvips/issues/777#issuecomment-337936144), haha. One thing I'm doing is having vips (via command line) do all my operations in _one_ vips stream (convert format from tiff to jpg, resize, change color profile, etc). When using `vipsthumbnail` command line, I believe it will not write any 'intermediate' files to disk, just do it all. When I looked at how the _previous_ implementation in ImageProcessing was using MiniMagick, and looked at the implementation of MiniMagick, it looked like MiniMagick would be writing a temp file to disk for _each_ transformation. One for converting from tiff to jpg, another for resizing, etc. I figured that might actually be some of the reason my vips implementation was faster. I don't mind (and prefer) writing a file to disk instead of buffering in RAM to save RAM, but reading and writing a handful of different files for _each_ derivative created seems excessive. Do you know if the new ImageProcessing implementation, using the vips adapter, will let me make multiple changes in one pass with only one file written to disk, the same way the `vipsthumbnail` command line will?
I've worked last year on a node project using sharp, and I was very impressed with libvips due to speed and memory usage. It was kind of flaky using it in a docker alpine image (some operations using SVGs that I needed segfaulted, had to resort to using a custom node-sharp image on ubuntu(?)), hopefully it'll improve there. I was actually quite bummed out that it wasn't as used in ruby, glad that you guys stepped up, will gladly use it next time I handle uploads and image processing.
Given the question I'm assuming that introducing him/her to other possibilities is more than answering the question but opening possibilities. To me, the road is more important than the destination.
&gt; Do you know if the new ImageProcessing implementation, using the vips adapter, will let me make multiple changes in one pass with only one file written to disk, the same way the vipsthumbnail command line will? Yes, in the libvips module each operation uses the `Vips::Image` of the previous operation, and at the end the `Vips::Image` is written to disk. As @jcupitt already described in the GitHub issue you linked, that will create a pipeline. There are no results written to tempfiles in between operations. The `ImageProcessing::MiniMagick` implementation was also updated to build a single `convert` command, and soon it will be updated to use `magick` for ImageMagick 7. Each operation now just adds CLI options to the existing command, including the `#resize_*` macros. The `MiniMagick::Image` class is now completely avoided, which makes me happy because I hate it (having maintained it for a long time); it's overly complex and inefficient mostly due to the in-place processing with `mogrify`. When I found out that libvips simply doesn't support processing in-place, due to its streaming nature, I realized we don't need that when using ImageMagick either, and it makes things so much simpler to reason about.
Nice!
&gt; s First of all, thanks for your feedback. When it comes to Ruby, the ISP can seem to be less important or even not important at all but I wouldn't underestimate it. &gt; "Clients should not be forced to depend on methods that they do not use." In Ruby, we use duck-typing technique. It quacks like a duck so it is a duck (no matters whether it does other things or not). But this principle is also stated as &gt; Many client-specific interfaces are better than one general purpose interface. And this one lays a little bit closer to Ruby, don't you think? *Programmer* should not have access to some of the methods from Computer interface. Same for *Administrator* and *Technician*. But it also depends on a context. Take into consideration a Repository pattern. For example its implementation - *PostRepository* with public methods like: *get_by_id, get_all, get_by_id_with_comments* etc. We use this repository in different places and in each of these places we don't need whole repository interface. But in this particular situation, I don't see anything wrong in such solution because I don't see any risk in such rich interface. I think that following ISP along with SRP helps us to not create "GOD" classes which have too much responsibility and simply do too many things.
I don't think the specifics matter as much. In ruby, we can restate the ISP like this: don't depend on an interface that you only use parts of. In other words, don't take a dependency on an interface with low-cohesion. It's the flip side of SRP, in a sense.
Almost same boat as you, except, less then a year in as well. Anyway I built something using Sinatra / Postgres / Sequel and Slim because I wanted a one page app( actually it's two pages). Long story short I ajaxified (using fetch mostly) 99% along with other js / dom stuff. TL/DR - I return everything .to_json, period. I find creating the Html (if needed) to work just fine in javascript. Actually I don't even see a reason to create the html in slim, for what reason? I'm sure it could be done but imagine it would be a lot more work with no payoff. 
I think I understand what you're asking about and here's how I would do it just because where I've worked previously the "look" of the thing changes all too frequently. I'd use as much ajax as possible, but route it to endpoints that can return html based on data and views that I can control independently if needed. So a little more in-depth and complex than just writing plain html in a heredoc, but you get the advantage of using layouts and partials if needed, which may keep things more simple and less repetitive.
Mostly worked in Rails, but the idea is the same. Where I work, we send JSON responses from the server and consume them from a React.js frontend app. We did it like this because we also will build a mobile app for the same app and we can't push HTML views to a mobile app (a native one). In your case, do you *need* JSON responses? The payload sent to the client will be smaller, and this may or may not affect the performance much, but if you need JSON responses then .to_json everything. It will require some time (based on the app's scale) which translates to added cost. But if you don't need it, then keep using HTML responses, nothing wrong with that. 
I know it's hard to find projects, but try to make something that engages you! Do you have other interest you can code something related to? Say you like to run, make a simple program where you can add runs you've had into a database. Or do you have problems you could test to solve with code? Can't decide what to eat? Make a randomizer with your favorite food. These are the kind of projects that at makes me love coding, hope you find one!
You could use something like emblemjs to enable you to keep writing slim-like syntax, but as handlebars.js partials that are templated out by JS on the client.
I strongly recommend trying out https://adventofcode.com/ and putting solutions into a github repository. They increase in difficulty and will allow you to use lots of language features in Ruby, plus they're clever and entertaining. I know it may not quite be what you had in mind but I think it'd be fun and good portfolio material.
"I'm not the creative type, but I enjoy coding" this sentence makes no sense to me :) Don't let traditional creative arts make you feel . inferior! Anyway, you're totally right. Many people shy away from saying it around here, but if you want a real, breathing application, through which you can hone your skills in ruby, testing, web (let's face it, ruby is mostly web), then most likely, you want to eventually roll a rails application. There are tons of fun things you can do in rails. Make your own little twitter clone. Make a simple social network. Make shared todo-lists. Try out stuff. Your portfolio (aka your github profile) looks particularly strong if you throw contributions at some open source projects. - many bigger projects label issues that are well suited for first contributions - for instance: https://github.com/sinatra/sinatra/labels/good%20first%20issue 
Tried the Watir RegEx above, still no joy. But thanks anyway appreciated.
I want to emphasis upon the fact that Ruby language alone isn't that worth as you learn it with framework Ruby on Rails. This is very important to understand. Having said that both Ruby language and Ruby on Rails framework isn't that hard to learn. I have wrote a blog post for beginners to start with Ruby on Rails and Ruby language http://haidrali.com/newbies-introduction-to-ruby-on-rails/ I have listed few project which could be good for showcase in portfolio. * Social Media post schedule (you can start with Twitter and Facebook) * To do list manager Its very important to put your portfolio work live somewhere, I would recommend upload it on **Heroku** *its free as well*. Also put your work on Github, Because hiring companies demands your coding style.
While you're wondering what project to try, I sincerely suggest checking out The Odin Project, https://www.theodinproject.com/ - it's a free open source web developent programme with Ruby on Rails - you start by the basics for both front end and back end web development, which will probably not take you too long, and then get into Ruby more extensively, after that Rails, then front end again. There are no mentors, but there is a Gitter chat which a lot of people use to ask questions and share stuff. The cool thing is that there are small projects after every few lessons and big ones at the end of each part of the curriculum and you upload everything on github so you can use it as a portfolio. For example, the final Ruby project is a command line chess game. It won't be easy, I think, and you'll need a lot of self-discipline as there will be no teachers, but it was very, very helpful to me. 
Fantastic! Thank you so much!
Two options. First find open source projects you’re passionate about and start digging through the projects issues and submitting pull requests even if it’s just for documentation updates, tweaks, etc. This will get you ready faster for working in an organisation with others that isn’t so insular like working on your own projects can be as well as learning git which you will 100% use. Second build something you actually want to build or that solves a problem you experience. This will give you the motivation to actually produce something tangible. Good luck! 
Absolutely! Drumming is a hobby of mine. I'll take some time and think of a project related to that. Perhaps a rudiment randomizer. Thanks for the advice, friend. This has really got me brain storming. :)
What's your code? Are you working directly with the HTML? Which method on [this](https://ruby-doc.org/core-2.2.0/String.html) page (begins with an S) takes a regex and returns an array? (you can do a ctrl+F) P.S. If you want the whole link, you'll want /[\w\d\/\-_]+\?tagged=ruby/
Something like this should work, assuming your slim template is located at views/things/index.slim ``` get('/things') { slim :'things/index', layout: false } ``` But I'm not sure I totally understand your question. If you have dedicated slim template files, why do you also want to write inline HEREDOC strings?
I mean, it’s fine to suggest Thor. But Thor is not only more than he needs but also doesn’t necessarily make it extremely easy to fail when args != 3. If you want to introduce something then answer the question under the constraints the question was asked and _then_ mention something. Like “do this ... and if you want to build a larger or more complex CLI quickly and easily you can use Thor. 
My understanding of ImageMagick is that it loads the entire image into a RGB16 buffer so it's not as efficient as vips.
I don't think I mentioned anywhere dumping to an in-memory buffer. Yes, that would be silly in general when alternatives are available. Streaming the output row by row is definitely preferable. Most high level APIs (including VIPs at the moment) can't stream output, e.g. to a socket. But I think that's the right approach if you want to minimise latency.
&gt; Is there a compelling reason to use that over saving to a temporary file? Let's make that more specific - is there a compelling reason to save the result to a temporary file as part of the API vs just letting the user do that? I think the compelling reason is that file-systems introduce a lot of semantics and surface area to an otherwise simple process. If you want a simple, composable library, returning a `VIPS::Image` is definitely preferable because that way you can just compose operations together and finally call `#write_to_file`. In addition, I'm not sure how you handle the case where the source image isn't big enough for the resize operation. With `vips-thumbnail` this decision is easily signalled to the user by `resize_*` returning nil (resize operation wasn't possible) and the user can then choose to make a symlink, or update the database row, etc. So, I think the compelling reason is: "Keep the surface area small and focus on just the specific task at hand". As an example, what happens if the temporary file could not be created? It's an additional class of errors that the user has to deal with that actually might not be relevant if they simply want to stream it to a remote service (e.g. S3). Anyway, they are just different approaches, neither is right or wrong, but you asked me if there was any compelling reason and for me those are the things I considered.
So we have two sentences: 1. Many client-specific interfaces.. 2. Client should not be forced.. Both represent the same rule, only rephrased. The same rule, said differently. Don't you think that the example of ISP violation should sattisfy both? Your example satissfies the second one and contradicts the first one. In my understanding it's not about limiting the interfaces to be as narrow and client-dedicated as possible. I've come up with an example: ```ruby class A def x(arg) #.. end end class B def x(arg) #.. end end ``` Two classes, one interface. Both classes implement the same interface. So clients will call both object in the same way (method with one argument). Let's now assume that there are one client that doesn't need to pass the argument. The argument is irrelevant in the client's context. And Ruby will still enforce the client to pass the argument. So in that case it makes sense to _segregate_ these interfaces. ```ruby class A def x(arg) #.. end end class B def x #.. end end ``` Two classes, two different interfaces (method's arguments matters). All the sudden this phrase gain fairly different meaning:: &gt; Many client-specific interfaces are better than one general purpose interface.
I agree that we should use common sense when following rules and principles. Still, bad understanding of a principle creates confusion.
[Here's](https://github.com/jstrait/beats) a drum machine i found written ruby, maybe make a copy? Written using [this gem](https://github.com/jstrait/wavefile) Happy coding :)
I'm looking to become one! I'm helping my husband find a job and learning a LOT in the process. I've had a couple web development classes, dabbled with C++ for four months in my teens and HTML/CSS in my 20s for a few months, so I'm not completely in the dark! It is still quite the commitment to take on, so any active communities besides reddit and stackoverflow would be of great assistance! Thanks in advance! :)
Ok. Now I see your point :) I think you're right that this is a single rule no matter we describe it using first or the second sentence. Example from the link you posted is fantastic. It changed my point of view a little bit. This whole discussion is caused because what you said first. Definition ISP in dynamic-typed languages is very unclear or let's say doubtful. But I think I have to go a little bit deeper, think about it again and make changes in my article. So much thank you for this discussion and please check PM in your inbox :)
I also agree that we should always keep common sense. We use these rules/principles/patterns to achieve some benefits, not just to fulfill/apply them. So if benefits aren't clear, applying rule will lead to nothing. &gt; There are principles outside of SOLID that are very important to learn, too. No one said that solid principles are the only ones that are right. No doubts that there are much more rules/patterns to learn :)
Why would you freeze inside initialize?
To make sure that all instances of your class are frozen by default.
I have some :) https://github.com/zverok/lmsa
Just curious, what's the use case?
Use case for freezing in general or just freezing in the constructor? On freezing in general: There's no _practical reason_ to do it. It doesn't make your program better or faster. But it makes your code and your architecture better. Saying ".freeze" strictly makes your object immutable. There are enough articles about "why immutability is good", thread-safety is the main point. Also it kinda guarantees that nobody can change your object from outside (like instance_variable_set and instance_eval {} and others). It's a good way to write a self-contained object that works always and everywhere, without any possible imaginary situations. On freezing in the constructor: Because I don't really need some objects of my class to be frozen and some of them to not. I need either all or none of them. Constructor is the best place as freezing is a part of the object initialization (RAII principle).
Right, it's just a point I always bring up when talking about SOLID (particularly when there's a blog post series about it).
I believe Sharp tends to use memory buffers over the file system because many cloud systems give plenty of RAM but very little disc. It's generally safest to load from the socket into a memory buffer, process to a second buffer, then post the result back. (jcupitt here btw)
For this specific application, the lure was not Ruby in itself but the simplicity of getting CRUD done with Sinatra. I can see that Ruby is better for many other applications and indeed it's my language of choice for most other things. What is changing in this app is that all server-side code now exists just to do database access and reply to Ajax queries. So one could ask, would people still use Sinatra if SPA was the original approach. I've since found many articles about Sinatra-based APIs, that's another approach I'll look into.
Because the HTML will be passed to things like getElementById(some_div).innerHtml(this_here). Slim works perfect if you're loading the page for each GET or POST, but this being an SPA I am trying to never reload.
Yeah, I meant freezing in constructors. Sorry, I still don't get why you would want that. Could you provide a concrete example? Where do you use your library? I've never felt the need to make frozen objects by default, so I am curious what problem it solved for you.
I use it mostly in plain objects and "operations". By plain objects I mean PORO, that's the most obvious use-case. In operations (aka service objects) I pass dependencies and freeze the object (also usually I put pre-configured instance of this class to some global container to reuse it). Later the only available public method (like 'call') takes arguments and does something using those saved dependencies. Here are some examples: https://gist.github.com/iliabylich/a1eaed81ac7a7a6fac5e1aed6b0ea9fd . They are a bit far from reality, but I'm sure you understand that I can't share the code from my private project. The example with operation is more complete, hope it shows the idea. &gt; I've never felt the need to make frozen objects by default Is it because you've never seen any libraries mutating your objects? I want to be sure that when I pass any of my objects to an external method/function it doesn't mutate it. If it does I instantly get a FrozenError and pass a .dup to the method (or remove it from my gemfile) And just in case, if you are looking for any use-case in the context of the default Rails app most probably you'll not find it. I'm pretty sure that all high-level Rails classes (AC::Base, AR::Base, etc) have mutations, so freezing them simply breaks the app.
Cannot test-run now, but I'll try over the weekend. Thanks much!
can you add some sample names and output you need for those? probably regex might be better choice here...
For example: Input: amy smith brown Output: Amy Smith Brown Input: amy smith-brown Output: Amy Smith-brown Input: Amy Smith-Brown Output: Amy Smith-brown It would be fine in the first instance, but if somebody uses a hyphen (-) it no longer capitalises the second part, because Ruby is treating it as a single word. I haven't got onto Regex yet, I was hoping there would be a way to code this purely in Ruby.
You almost got it. Here's what you need: gets.chomp.split(/\b/).map(&amp;:capitalize).join Explanation: `split` can take a separator argument, which is space by default. The separator can be a string or a regular expression. The regular expression `\b` means [world boundary](http://www.regular-expressions.info/wordboundaries.html) and the nice thing about it is that it has zero with. This means that the separators you use (the spaces and the hyphen) are preserved when doing the split: "alberto santos-dumont".split(/\b/) &gt; ["alberto", " ", "santos", "-", "dumont"] You can then apply `capitalize` to all the strings (this won't affect spaces or hyphens). But at the end you must join everything without adding spaces. One thing worth mentioning is that if someone inserts a name with repeated space ("Julio Iglesias") those spaces will be preserved with this method, but would be "compacted" with your original one. You can split and join again (`.split.join`) to avoid this.
well, I'll try to see if I could get a non-regex solution, but imo this is best suited for regex &gt;&gt; s = 'amy smith brown' =&gt; "amy smith brown" &gt;&gt; s.gsub(/(?&lt;=^|[\s-])[a-z]/) {$&amp;.upcase} =&gt; "Amy Smith Brown" &gt;&gt; s = 'amy smith-brown' =&gt; "amy smith-brown" &gt;&gt; s.gsub(/(?&lt;=^|[\s-])[a-z]/) {$&amp;.upcase} =&gt; "Amy Smith-Brown" 
 More examples to help see what happens: names = ["amy smith-brown", "amy smith brown", "Amy Smith-Brown"] names.map { |name| name.split.map(&amp;:capitalize).join(" ") } =&gt; ["Amy Smith-brown", "Amy Smith Brown", "Amy Smith-brown"] # The default argument of split is a single space: names.map { |name| name.split(" ").map(&amp;:capitalize).join(" ") } #=&gt; ["Amy Smith-brown", "Amy Smith Brown", "Amy Smith-brown"] # split also accepts regex. / / matches a single space: names.map { |name| name.split(/ /).map(&amp;:capitalize).join(" ") } # =&gt; ["Amy Smith-brown", "Amy Smith Brown", "Amy Smith-brown"] # A naive attempt might be to match empty space or a dash: names.map { |name| name.split(/ |-/).map(&amp;:capitalize).join(" ") } # =&gt; ["Amy Smith Brown", "Amy Smith Brown", "Amy Smith Brown"] # /\b/ matches words. It's easier to see where it splits if we join with "*"" names.map { |name| name.split(/\b/).map(&amp;:capitalize).join("*") } # =&gt; ["Amy* *Smith*-*Brown", "Amy* *Smith* *Brown", "Amy* *Smith*-*Brown"] names.map { |name| name.split(/\b/).map(&amp;:capitalize).join } # =&gt; ["Amy Smith-Brown", "Amy Smith Brown", "Amy Smith-Brown"]
Here's a trick: Don't use factories and rspec. So many articles are in the spirit of "my tests run slow as balls, here's how to speed them up by adding more complexity". No shit they are slow if you're doing million database inserts (via AR with all the validation/callbacks) before every single test case.
What testing tools or frameworks do you suggest instead? Please also keep in mind that in many cases tests with rspec are already created and your job is to jump into the app development and you have to speed up things
Don't persist stuff you don't need to. Use `build` or `build_stubbed` 
What does 'concurrent requests' mean here? I need more docs! 
There was the Query Objects blog post that was making the rounds a couple days ago. Basically it pushed complicated queries for models into their own classes. The level of effort only seems prudent for large applications but the biggest benefit I saw was your ability to stub those query objects with data and not hit the database at all. You could probably stub them with a Factory bot build or just write the hash yourself. 
Is this a joke?
You could probably use fixtures as the data to return from a mock. I think using factory girl in that respect would be easier though. If you need to mock out something from the internet (the only time I've seen fixtures in use in a production app before) and don't want to write the data yourself then something like VCR would be your best bet.
You know I used to favor slim over HTML tags/erb, but when I learnt React, I changed my mind, because of components and it also has interpolation anyway. I return json.
Fixtures do not insert individually. Everything gets inserted once before entire test suite and each test runs in the transaction that gets reverted before next test case. This is why it's stupidly fast compared to factories.
You can find examples in [the]( https://gitlab.com/honeyryderchuck/httpx/wikis/home) [wiki]( https://gitlab.com/honeyryderchuck/httpx/wikis/Make-Requests), and the [examples directory](https://gitlab.com/honeyryderchuck/httpx/blob/master/examples/hackernews_frontpage.rb) has an example of an "hackernews first page scraper". Docs are however a WIP, hopefully it'll improve with more feedback. 
To what concurrent requests mean, there is a paragraph in [the README](http://honeyryderchuck.gitlab.io/httpx/rdoc/files/README_md.html) explaining that. The TLDR is: it reuses sockets for same-host/same TLS cert requests using the best solution: * if HTTP/2 is possible, it will multiplex all requests concurrently in the same connection; * if HTTP/1, it sends as many requests as possible using HTTP/1 pipelining; * if pipelining is not supported, it falls back to 1 requests after the other using keep-alive connections; * if connections are closed by the server, it reopens a new socket for each new request. when a multi-domain query is performed, it's all balanced in an event loop using non-blocking I/O. Hopefully it's easier to use than explain :) 
Now do HTTP/2 server pls.
If you need a crud'ish API, a rails json api is a lot easier to roll than sinatra. Comes with total scaffolding that is actually totally decent. 
Check out [LaunchSchool](https://launchschool.com/join/ecab684a71). The free prep course and free books are the best introduction to Ruby. The courses themselves are the deepest and best curriculum I've found in learning programming well.
I did the client to test a server I have. Will release when ready. 
`ruby ./script.rb` But before that you have some dependencies you need to install. So run `gem install nokogiri` first.
Troll
We don't really need a post which simply lists all the other posts, do we?
&gt; But as a Ruby / Rails programmer, the language is very difficult to use — require/include is extremely primitive and dangerous, all symbols are in a global space, the language is too un-specified and difficult to support real IDE's, etc. I feel like you don't actually program in ruby. It seems you're trying to drag expectations from other languages/environments. If you're using rails, you'll rarely use `require`, include is used for extending classes and probably shouldn't be `/`-ed with require, symbols being the same object is by design, and I'd anecdotally say that the majority of ruby developers don't use IDE's. ¯\_(ツ)_/¯ &gt;I find that even in small Rails apps, Ruby makes refactoring too difficult to do as often as needed. So nobody does it. And jumping into other peoples' large projects is usually an awful experience. Most hard-to-refactor ruby app's I've seen suffered from - Poor test coverage (unit and/or integration) - Gigantic classes and/or violation of SRP - Inconsistent code style and architecture choices These are problems that will be experienced in any language. Lastly, I think that ruby is very easy and delightful to use. Most people I know who use ruby don't do it because of performance or portability. They use it precisely because it is easy and delightful to use. Maybe ruby just isn't your cup of tea? There's nothing wrong with that other than trying to make others feel like it is their fault.
It might be an improvement to be added at a later time. As of now, you'd have to build an array of them yourself and pass the to the client in the same call.
Hey thank you for this. It solved part of the mystery for me. Are the other "require" lines gems, too? If so, do I repeat the process for them? 
I read "destroy all software" as a sentence and was so confused for a moment
What exactly do you thing is a joke?
Is there a download all option or do you have to download all the videos individually? 
i find ruby super practical and joyful to use! Rails less so, but while I don't know what the core ruby devs work on other than ruby, I know DHH really does work in Rails... but on a single particular project, that may be unlike what many others do with it. 
&gt; I feel like you don't actually program in ruby . . . The opposite is true: I've programmed in Ruby since 2008, and have 300+ Github stars on my open source Ruby projects. Accepting this as true, would that change your answer? &gt; Most hard-to-refactor ruby app's I've seen suffered from [ ... ] These are problems that will be experienced in any language. Not true, in my experience. Different languages have different common problems.
&gt; But, so.... why are you working in ruby then? it is sad to me that you are for whatever reasons forced to use it when you don't like it as a language. It'd be like if I had to write Java as a day job. Thanks. Yeah, I've got expertise and years of experience with Ruby and Rails, and so the jobs come up easily. In my own startup's code, I'm using languages which give me the feeling of more respect for the application developer. And the feeling that the language developers actually use the language.
&gt; It seems you're trying to drag expectations from other languages/environments. Absolutely! I'm holding Ruby to high standards; comparing the experience of using it with modern 2018-era programming languages.
'net/http' and 'uri' I think should be installed with Ruby. But you might want to go ahead and install them just to be sure. Running 'gem install xxx' will install the latest versions, even if some version is already installed. 
Sorry, that should say in new lines above __END__ 
I would change it such that, given your experience and OSS, I’d expect you to contribute ideas, patches, blog posts, and entire projects to the Ruby community which work towards the future you imagine. After 10 years of writing ruby and making contributions you surely understand that the community welcomes to improvement, but doesn’t react well to aimless complaint.
So to which languages are you comparing Ruby to? I'm programming in Ruby since 2001 and there are things that I don't like (e.g. `require` is okay but Python's `import` is "better"; better namespacing control instead of `module`/`class` would be great). However, compared to any other language I've ever used Ruby is still by far the most enjoyable one.
Just click download on each video. It’s not that big of a deal! The content is amazing Das videos are some of the best videos I’ve come across definitely worth watching 
Here's a Ruby script to download them all. https://github.com/kimchanyoung/get-all-destroy-all-software
Wat. 
Before we can give you advice about why your script isn't running you need to tell us how it is failing. What command are you using or action you are taking to run the script? What is the full text of the error you are receiving? Additionally: * Please don't wrap the whole program in a begin/rescue/end block as advised elsewhere, that is redundant. * You don't need to install net/http and uri. * Please consider adding in a sleep(somenumber) in the script where you loop over a list of URLs and fetch them to avoid slamming the remote webserver.
TL;DR: I "compiled" The Ruby Reference from various sources, to be comprehensive, modern-looking and book-like, like other languages have: https://rubyreferences.github.io/rubyref/
quick feedback: looks great!! thanks for this... may be add these two as well? * https://www.ruby-lang.org/en/documentation/faq/ * https://www.ruby-lang.org/en/documentation/quickstart/ and https://github.com/rubyref/rubyreference say page not found...
thanks for fixing the github link.. yeah, I meant direct inclusion :) I'll try to contribute as well... if you already have items to tick off, you could open issues so that ppl could try to help with them first... :)
*blush* yes, libvips is my main spare-time project
This looks very nice and handy!
The back and next buttons at the bottom of each page lead to 404s.
We're working on this kind of thing (IoT on Rails) at Apiotics. https://portal.apiotics.com. We're not yet at the point of supporting a household socket via a Pi, but we're certainly interested to talk with you about your project so that we can support it.
Nice work! Coming from python, when I started learning Ruby I was kind of miffed at the absence of something like this. However I found David Black's [The Well-Grounded Rubyist](https://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1617291692/ref=sr_1_1?ie=UTF8&amp;qid=1523109621&amp;sr=8-1&amp;keywords=the+well-grounded+rubyist) to be a decent substitute.
Awesome! 
Fixed.
Did this work for you? I've tried but then it says I need to log in or sign up. I have a old account from years ago and when I log in with it I need to give my payment details. I've just clicked the link. https://www.destroyallsoftware.com/screencasts/account/checkout?discount_code=7thbirthday&amp;plan=annual
Could you please elaborate on what you had in mind? 
Same here. I hadn't been on the site in 3 years or more and it took me straight to payment details once I logged in. So they got their US$30 for a month. I've already cancelled and will remember next time. It's probably a better value if you're a junior- to mid-level Rails developer who sees all of Ruby through the Rails lens, instead of properly vice versa. YHBW.
Looks nice. What's you plan to keep this up to date so it doesn't become outdated like other references you mentioned? If the plan is just "you'll keep it up to date" how does that really differ from others who also planned to do the same but eventually stopped updating?
Wow! This is great. After years of programming in ruby I have memorized a list of pages where I can find these details: rubydock, apidoc, blog articles, etc. I have never seen these all in the same place. This is super helpful. Thanks!
Thanks for your help! I added your changes and appear to be getting further. This is what was returned: C:\Users\Administrator&gt;C:\ruby2.rb Got category: {:name=&gt;"adobe-photoshop/", :pagecount=&gt;3935, :next_page=&gt;1} Got post_url: https://www.gfxtra02.com/adobe-photoshop/photoshop-mock-up/1041084-cm-planner-edition-custom-scene-1123396-updated.html Traceback (most recent call last): 17: from C:/ruby2.rb:32:in `&lt;main&gt;' 16: from C:/ruby2.rb:32:in `open' 15: from C:/ruby2.rb:33:in `block in &lt;main&gt;' 14: from C:/ruby2.rb:33:in `each' 13: from C:/ruby2.rb:35:in `block (2 levels) in &lt;main&gt;' 12: from C:/ruby2.rb:35:in `upto' 11: from C:/ruby2.rb:37:in `block (3 levels) in &lt;main&gt;' 10: from C:/ruby2.rb:37:in `each' 9: from C:/ruby2.rb:39:in `block (4 levels) in &lt;main&gt;' 8: from C:/ruby2.rb:28:in `get_url' 7: from C:/Ruby25/lib/ruby/2.5.0/net/http.rb:609:in `start' 6: from C:/Ruby25/lib/ruby/2.5.0/net/http.rb:909:in `start' 5: from C:/Ruby25/lib/ruby/2.5.0/net/http.rb:920:in `do_start' 4: from C:/Ruby25/lib/ruby/2.5.0/net/http.rb:935:in `connect' 3: from C:/Ruby25/lib/ruby/2.5.0/timeout.rb:103:in `timeout' 2: from C:/Ruby25/lib/ruby/2.5.0/timeout.rb:93:in `block in timeout' 1: from C:/Ruby25/lib/ruby/2.5.0/net/http.rb:936:in `block in connect' C:/Ruby25/lib/ruby/2.5.0/net/http.rb:939:in `rescue in block in connect': Failed to open TCP connection to **CM**:80 (getaddrinfo: No such host is known. ) (SocketError) Do you know what's causing the socket error? _________________ Edit: I just ran it again and got this: C:/Ruby25/lib/ruby/2.5.0/uri/rfc3986_parser.rb:21:in `split': URI must be ascii only "https://www.filenext.com/za2bfo3do1md/Decoration_set_05.rar.html\r\xC3\xDC" (URI::InvalidURIError)
Good point. FYI: I'm trying to put together free (online) ruby getting started guides and booklets at the [Yuki &amp; Moto Press Booshelf](http://yukimotopress.github.io/). Some guides for now include: - How I Start - Let's Build a Gem Together! by Steve Klabnik - Hoe Developer's Guide - Build, Package and Publish Gems with Rake Tasks - Ready-to-Use Build Scripts by Ryan Davis, et al - Best of Practicing Ruby by Gregory Brown, Luke Francl, Magnus Holm, Aaron Patterson, Solomon White, et al - Programming Cryptocurrencies and Blockchains by Gerald Bauer, et al - Gem Series ++ Web Services (HTTP JSON APIs) the Modern Micro Way by Gerald Bauer, et al - and more
I'm not super great at the command line - and had some issues with the mkdir portion at the beginning of the script. I'm using an imac and terminal. I had to put sudo before running the script to get it to work properly. If you run into: get_destroy_all_software_screencasts.rb:13:in `mkdir': Permission denied @ dir_s_mkdir - /destroy_all_software (Errno::EACCES) from get_destroy_all_software_screencasts.rb:13:in `&lt;main&gt;' using *sudo* before you type ruby makes it work 
&gt; require/include is extremely primitive and dangerous How are `require` and `include` even related? What do you find 'primitive and dangerous' about them? &gt; all symbols are in a global space Do you mean constants? i.e. classes and modules? If so they aren't all global, use modules for namespacing. &gt; the language is too un-specified and difficult to support real IDE's, etc. Rubymine works great so I don't get what you mean here. &gt; I find that even in small Rails apps, Ruby makes refactoring too difficult to do as often as needed. So nobody does it. I have exactly the opposite experience. Ruby is very easy to refactor unless your test coverage sucks. Java on the other hand, no one want to make major changes as you often have to unroll huge class hierarchies due to the anemic type system. &gt; And jumping into other peoples' large projects is usually an awful experience. How is that different from any other language?
You're original post is a poorly written rant with no details and no examples and I'm fairly sure some misused terminology. Someone with that level of experience should be able to enumerate and discuss their issues with a language in a much more complete and accurate way. So personally, I'm significantly less likely to take you seriously.
And then you upgrade rails and miss a breaking change in ActiveRecord because your test suite doesn't actually exercise the code that runs in production...
FYI, you cite Rust as a language with a "up-to-date, full, free, official language reference", but its reference is neither up-to-date nor is it full.
Hey, but that's the whole point of this project: to be easily kept up-to-date! 1. Most of the source is taken from Ruby source and ruby-lang.org source, so on next version, you just run scripts, see what new classes/documentations/libraries are not covered, insert them into structure.yml and whoosh you have a new book. It is like 1-2h tops (unless the whole structure of Ruby sources and docs will be changed significantly, which is unlikely). 2. All configs, scripts, and design is opensource and available on GitHub, so if at some point I'll lose interest in (1), or will be dead/offline, it is easy to fork and continue. That was the main idea of the project.
I just use a microservice I’m running for this nowadays: https://github.com/alvarcarto/url-to-pdf-api Works fine, unless you need page numbers, then you’re back in manual-page-layout-land. 