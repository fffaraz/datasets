You should check with DHH before you do anything with this. He owns the Ruby on Rails trademark.
My suggestion to you is to rewrite your documentation in a more formal tone rather than first person. If I read the documentation on the Rails site, it wont say "I used the MVC design to divide the code into three layers, which I think works well for a website design", it says "Understanding the MVC pattern is key to understanding Rails. MVC divides your application into three layers, each with a specific responsibility." You have no need to justify Zen at this point, your tone tells me you are still trying to sell it. Your tone should be telling me that you've already sold it, and that any information at this point is a courtesy from you. In your comparisons against other CMS you may want to just do a side-by-side checklist rather than a paragraph comparing them from your point of view. You may have a very valid and experienced view, but as a developer I want the quick and dirty on what Zen offers over WordPress. Let the bloggers write the opinions. I think you have something great and I hope Zen stays around! I'm looking forward to trying it. 
STDIN is the STandard INput. There's also STDOUT (output) and STDERR (error). When you write something into a command-line based program, you are writing to STDIN. When your program writes output e.g. with *print* it writes to STDOUT. As far as Ruby is concerned, STDIN/STDOUT/STDERR are treated as open files. You can read from STDIN, and you can write to the other two. 
Over and above what other people have said about `STDIN` representing the standard input stream from within Ruby, it's also a predefined constant in Ruby. Ruby has a number of important built-in variables and global constants that are useful in various contexts. To get a quick look at them check out these lists: + http://www.zenspider.com/Languages/Ruby/QuickRef.html#pre-defined-variables + http://www.zenspider.com/Languages/Ruby/QuickRef.html#pre-defined-global-constants Since Ruby defines both a `$stdin` variable and the `STDIN` constant, it's also worth look at this to get a sense of when you might use one or the other: http://stackoverflow.com/questions/4279604/what-is-the-difference-between-stdin-and-stdin-in-ruby.
I'm reading your site on an iPhone and the side bar renders improperly when you zoom. Just an FYI. 
Just to let you know, I integrated Grape and Sinatra together into a single template. This should be a helpful starting point for building a quick little RESTful API ([Grape's wiki](https://github.com/intridea/grape/wiki), [Sinatra's readme](https://github.com/sinatra/sinatra)). Update: the actual link is this - https://github.com/gnarmis/rocketship
Awesome article. This should help with load times of the app at work.
Grape is a great choice. I recently decided to just create a template that integrates Sinatra and Grape together. It ended up being pretty simple and easy: https://github.com/gnarmis/rocketship 
...is this post satiric or not? I can't even tell anymore.
Noted :)
I've heard rubyists (on the rogues podcast iirc) wondering why anyone would use Sinatra when Rails comes with so many features (particularly security ones) that you'll end-up having to recreate. From this perspective, a framework for Sinatra appears to re-invent the wheel at the expense of the 'liteness' that makes Sinatra so attractive in the first place.
1.9.3. There's no real reason to install 1.9.1 anymore. If it taught 1.8.7, I'd say install 1.9.3 anyway. There are some differences, but for the most part the things you'll be learning are all the same. So just go for the latest stable release.
There are a number of differences between 1.8 and 1.9, which is why a bunch of people still use 1.8.
Most of the people using 1.8.x have deployment issues and existing codebases to worry about. If you're just learning, this is not an issue.
1.9.3 - if you are just starting, you won't and don't really need to know the differences.
Just to be clear: the syntax isn't inspired just by bash. I often refer to bash because it's the most common shell. However, the syntax used by shirt is common to bash, /bin/sh, zsh, ksh, csh, rc, and others. I had a look at chitin. It looks pretty cool, definitely some stuff in there I haven't seen before.
So, In ruby you can do: "SomeString".downcase #returns "somestring" If you call join on an array of strings, it concats them: ['a', 'b', 'c'].join #returns "abc" So if you have an array of characters, you can do: some_array.join.downcase
Out of curiosity, you do realize that you can call .downcase on an entire string, right? Plus, calling .downcase on something that is not an upper case letter just returns the character. Something like this: l.map { |line| line.downcase } will replace just about all of your code. At the end of that you can go ahead and join them if you just want one string: l.map { |line| line.downcase }.join
Dear Newby Rube: I will not try to answer questions you did not ask, as the others did, which can just complicate matters. But I will explain how to simplify this. However, I will make some suggestions, in keeping with The Ruby Way: (a) Learn to use meaningful variable names. "l" sucks, not just because it is not descriptive but also, depending on the font, it can be hard to distinguish between lower case "L", "i", and "1". I will use "federalist" for the name of my variable. (b) Learn to use regular expressions. Just about any advanced language can often be made vastly more functional by use of regular expressions. They can be funky, and even difficult, but they are very valuable. Having stated that, I would do it this way: federalist.each do |row| row.downcase! # Replace string "row" with lower case representation. row.gsub!(/[^a-z]/, ' ') # convert anything but "a" through "z" to a space. end And there you have it. That is all. These could be further combined into row.downcase!.gsub!(/[^a-z]/, ' ') but I kept them separate for purposes of illustration. Also, to clarify what "moger 777" stated, because it was pretty ambiguous: gsub is actually a general character replacement method. THIS PARTICULAR use of gsub, that is to say: gsub!(/^a-z/, ' ') does indeed replace any character which is not 'a' to 'z' with a space, but that is not an inherent property of gsub, as his statement would seem to imply. 
Can't resist a putt... l.map(&amp;:downcase)*" " ...although its probably not much good for a newbie!
I'm not sure if homework questions are off-topic here or not, but assuming that they're allowed you should at least be up front about it. (It's usually pretty obvious, and you posted something very nearly identical to this a couple of weeks ago.) Also, if you want help, you should start by telling us what you've already tried. *Have* you tried to solve the problem on your own? Do you know about the [Ruby documentation website](http://ruby-doc.org/)? Have you tried Google or Stack Overflow? So, having said all of that, I would start by looking at the [documentation for the String class](http://ruby-doc.org/core-1.9.3/String.html). It may help to know that the name for what you want to do is *concatenation*.
Quote: "... the name for what you want to do is concatenation." Eh? No it's not. Even if concatenation is needed in the implementation of this (and in most cases it should not be), it is only incidental, not central, to what he wants to accomplish. 
Can you explain the &gt;*" " part?
Beautiful stuff. I like what you did to fit ruby into a shell's world. The next step is for someone to figure out how to fit a shell into ruby's world.
`String#*` is synonym for `String#join`. 
To be fair, it would probably get closed on there as being homework!
Nope, you don't have to install all gems. You can do `bundle install --without group_a group_b`. Bundler ensures that the proper versions will be loaded and that all versions play nice together, independent of which gems you might have installed.
One huge, emphatic "YES". I started with Ruby in Windows about 7 years ago, and I still use a Windows PC side by side with my development machine daily. Unless you're developing _for_ the Windows platform (.NET, Visual C++, etc) I couldn't recommend dealing with the shit you'll otherwise no doubt deal with.
If you concat using the "join" command then how can you insert a space (" ") in between each string?
like this: join(" ")
um, from the OP we're discussing. But rather than go into that, banister, since you seem to have some mental model of this -- what do you beleive the difference between `clone` and `dup` is _supposed_ to be. Why are these two diff methods, when are you supposed to use em differently?
This looks really interesting. Do you have any benchmarks?
Sure. `clone` is exactly like `dup` except it also copies the singleton class as well as flags like `frozen`. Neither says anything about whether it's a `deep copy` - whether a deep copy takes place is instead determined by the `initialize_copy` method. Note that when you implement `initialize_copy` *both* `dup` and `clone` use it --- they should ALWAYS behave the same (with regard to the depth/shallowness of the copy) -- their only difference is, as stated above, whether the object's flags and singleton class are copied. In the code below, i have implemented `initialize_copy` such that both `dup` and `clone` create deep copies. You can also see in the following code that `clone` also copies the singleton class: class Trick attr_accessor :x, :y def initialize(x, y) @x, @y = x, y end def initialize_copy(orig) @x = orig.x.dup @y = orig.y.dup end end # =&gt; nil t = Trick.new("hello", "world") # =&gt; #&lt;Trick:0x00000100d76d00 @x="goodbye", @y="world"&gt; def t.pig "pig" end # =&gt; nil t_dup = t.dup # =&gt; #&lt;Trick:0x00000100d329c0 @x="hello", @y="world"&gt; t_clone = t.clone # =&gt; #&lt;Trick:0x00000100d1d2f0 @x="hello", @y="world"&gt; t_dup.pig # =&gt; #&lt;NoMethodError: undefined method `pig' for #&lt;Trick:0x00000100d329c0 @x="hello", @y="world"&gt;&gt; t_clone.pig # =&gt; "pig" t.x.replace "goodbye" # =&gt; "goodbye" t_dup.x # =&gt; "hello" t_clone.x # =&gt; "hello" t.x # =&gt; "goodbye"
see my answer below: http://www.reddit.com/r/ruby/comments/ql4s5/making_deep_copies_in_ruby/c40by6w
It's the same as .join(" ") only with fewer characters. It's actually less readable (if only because it's unfamiliar). I learned it playing ruby-golf and couldn't help showing-off! 
I've not tried playing with audio in ruby but I know other languages store an array of samples. I suppose it depends on how you're doing the synthesis. If you post some code it will be easier for people to offer suggestions.
The link is right, but you just gave me an idea which will for me. So the /maps url source has the javascript with these JSONs at statajax. I think I can work with parsing those. Thanks!
IMO overkill unless you have further variation between note behavior, or additional methods you want to attach to them.
Fair enough. I just want a note in there in case a newbie sees your post and thinks it's better because OO is better. OO is only better if it results in simpler, more maintainable code overall. That's all I'm saying.
I had to tweak around with it a little bit, but it worked! Thank you so very much! 
That is hilarious. Performance? On an application that plays notes on a speaker with 250 millisecond delays? From a sound library? In an interpreted language? That reads text from a file? And you are worried about an object definition and an instance variable? Edit: I need to go to bed. :)
I have a ~/local/ folder that has everything I have installed for my user. export PREFIX=/Users/seydar/local cd project ./configure --prefix=PREFIX make make install RVM does pretty much the same thing, so I'm glad the idea of installing things in your home folder is taking off. I have only once run into issues with installing everything in ~/local, and that involved me passing an extra parameter to the configure script.
Yes I do realize that, but for now I will take whatever method works, unless there is a better way.
Is `#lazy` really necessary? Clojure and Python 3 got this right: even if a sequence is filtered or mapped it does not become realized on demand. It gets evaluated when it is needed. If you want to realize (materialize) it into a memory-occupied array, you can do it explicitly. Defaulting to be lazy and providing `#to_a` for explicit realization is better than defaulting to be eager and providing `#lazy` for explicit lazy evaluation. Because once evaluated sequences cannot back to be lazy while lazy sequences can be evaluated any time.
Ah, sorry. Will do.
I agree. Using users.map { |u| u.team.name } is fine with me, but I see the utility of Enumerable::Lazy when it comes to stringing together several different methods. 
He is right. Compatibility always wins from the point of view of language design.
latortuga, thanks for pointing to demeter law. My example really wasn't a good one to demonstrate laziness, so I've changed it to another one: data.map(&amp;:split).map(&amp;:reverse) The data is **processed** here (rather then just getting users team names) and that's why it's natural to use lazy enumerator chaining.
I've got an idea, reading up on the Monitor pattern. Turns out there are a couple different ways to implement Monitor with regard to what happens on signal, as covered here: http://www.baptiste-wicht.com/2010/09/java-concurrency-part-5-monitors-locks-and-conditions/ It doesn't seem to be documented anywhere what model ruby uses (it may even differ between ruby implementations? awful). I was assuming it used what article calls the "Signal &amp; Wait (SW)" design. However, if it instead uses the design that article says Java uses too: &gt; Signal &amp; Continue (SC) : The process who signal keep the mutual exclusion and the signaled will be awaken but need to acquire the mutual exclusion before going. That would explain what I'm seeing. When a checkin happens and a `signal` is sent, a single waiting thread is awoken, but doesn't neccesarily immediately acquire the mutual exclusion first -- some other thread might get it first, and steal that just checked-in connection. By the time the awoken process gets the mutual exclusion, there's no connection left. If that's how ruby works, it explains it -- and AR's connectionpool design needs to take account of this and work differently. I've got a couple ideas. 
Ah, no problem.
The Law of Demeter is taken far too seriously. It's a general principle that you should think about, not something that you should religiously adhere to IMO.
This is way too much work. 
Why do you think that?
Yup. But it might be an okay approach on a huge app.
[Ask and it will be given to you.](https://gist.github.com/2039850)
Wow. I have people swearing about how cool my script is. I can die happy.
wwhoooooosssshhhh
 person = { :first_name, "Albert", :last_name, "Einstein", :email, "al@wormhole.com" } This comma separated hash syntax is deprecated and does not work with v1.9 forward. callback1 = proc { puts "Hello." } callback2 = lambda { puts "Hello." } callback1.call callback2.call # proc == lambda Procs are not exactly equivalent to lambdas. They maintain different scope. `Kernel.proc` creates a proper Proc object now, not a lambda like it did in 1.8. (If that is what you were attempting to convey.) Otherwise, this page is **awesome**. It's a pretty handy cheatsheet, and I could have used it a few months ago when I started getting back into Ruby. Heck, it's a great thing to show someone who is interested in Ruby. I personally would have loved to have seen this from day one, or similar.
The reason for this is that the comments interrupt the flow of the reading of the code. It is better to have a block comment that explains what the code is doing, and then have all the code, than have a comment for every other line.
More like ... &gt; the nokogiri devs are over estimating risk and some developers are over valuing .gemspec files
The reason STDIN is being used in this case is because "gets" on its own (i.e. Kernel#gets) has a behavior of prioritizing reading from a supplied file before stdin. If you're not using that behavior then Kernel#gets will read from STDIN too.
Can you point me to the line where the title question is answered concisely? Can anybody? Furthermore, why don't they create a FAQ instead of this impenetrable post?
The Law of Demeter was never intended to be a total rule, just food for thought. `user.team.name` is hardly bad design. The argument is, "What if the `team` object changes its API from `team.name` to `team.title`?" If that happens, you would have to update all the references in your application. Better to create a `team_name` method on the `user` object. That way, if the `team` API ever changed, you only need to update it in one place, and you can keep using `user.team_name`. The other advantage is that no other object that uses `user.team_name` would need to know about the `team` object. That's nice to think about and all, but in practice it can be a time waste creating all those accessor methods and actually contribute to the confusion in your API. If you get used to seeing `team_name` all over the place, you might make the reasonable assumption that the `team` object would have a `name` attribute. Except it doesn't. How were you to know? Or, if you really have to, why not just alias the `title` method as `name` on the object to support the old API? But ultimately it comes down to the fact that bad design isn't avoided by following a bunch of rules. It's mitigated by thinking carefully about the design of your objects in the first place. `team.name` was well chosen; it's very clear what we're talking about, and it's very unlikely to change. How many great APIs have you seen that break the Law of Demeter? What about APIs that use method chaining? It should be clear that the Law of Demeter isn't the final word in any design. It's just a little koan to muse on while you're developing your object's APIs.
Want more feedback? I'm willing. 
In light of this, what are your thoughts on my 'refactoring' of the presented code? https://gist.github.com/2040939
Did you bother to read the log referenced in the error message?
It does. Very slow. And there is no incremental build so you rebuild everything when you add / modify one page. I'm addressing this in the next incarnation of zenweb, which is powering my blog, my website, and tenderlove's blog (soon). I'm currently working on a template site that uses skeleton and has sensible defaults/styling... but pretty isn't my strongpoint so I'm going slow.
&gt; "The absence of a gemspec is a risk mitigation tactic." #4 in the TLDR... you couldn't even get to the 4th line? Really?
Well, of course - I've always programmed for 1.9, myself. I was merely commenting that it's silly to recommend using 1.9 when trying to learn from a 1.8 book.
Well my only i18n page only had about 20 views, so I have no idea how things would work on a large project. Cucumber definitely isn't the best tool for polishing things though (and checking that everything is translated seems like polish to me).
Bullocks, I'm old enough not to have someone else decide what is best for me.
I was about to suggest exactly the same thing. It seems like that's a much better solution than just *asking* for an RC release (what are we, primitives?!).
I'd write it in a more declarative style: deps = Find. enum_for(:find, root). grep(/\.java$/). map { |f| File.readlines(f) }. map { |lines| [find_package(lines), find_imports(lines)] }
Leave _why alone.
PM me your email address.
Guys/Gals give your self a huge pat on the back! It was this very subreddit when why disappeared that I was able to ask who is interested in helping rebuild try ruby. Without this sub reddit try ruby would have taken a lot longer to come back online. It would have also been a lot less secure to boot. TL;DR: This subreddit rocked. it helped hugely with the communication side of pulling try ruby back together.
Wow. That's pretty great. I especially like the "What? It could happen!"
&gt;You'll also notice the old trick of checking how many rows were affected by the operation and breaking out of the loop when it deletes fewer rows than the LIMIT specifies. This is done with only a slight abuse of ActiveRecord's update_sql (a delete is an "update"-ish, right?). Would you (or someone else) expand on this idea a little bit. This is done to break the loop when all the records have been deleted?
Declarative style always messes with my head, but I'm glad to see that I can read it more and more as time goes, and I am learning to appreciate its benefits.
Seriously, it doesn't even require analysis. People should have a right to privacy
They didn't -threaten- it. They -destroyed- it.
I'm down voting this for _why. thank you _why, carry on
Where is _why? _why lives in our hearts where the best of us go to live on and on.
Hrm... should I use for trademark infringement? :P
 import _why _why.wisdom.spread() _why.leave_alone()
Okay, it's not spelled out concretely, a little bit of deduction is left to the reader, but what I got from that was: The 'risk mitigation' 'here be dragons' type warnings mean that they want to actively discourage people from using unreleased versions built from master. If there was a gemspec, ruby projects using bundler could simply point to the git repository to get a bleeding edge version via: gem 'nokogiri', :git =&gt; "https://github.com/tenderlove/nokogiri.git" and bundler would compile it for them, (memory corrupting bugs and all). Even without bundler, it (would) be a simple clone of a git repo &amp; build locally. git clone https://github.com/tenderlove/nokogiri.git cd nokogiri gem build nokogiri.gemspec gem install nokogiri-x.x.x.gem Without a gemspec, you would have to create one yourself before you do either of these steps. They're pushing to actively avoid people using bleeding edge versions from master. I'm assuming people have used it in the past, and had bad things happen to their system. I'm not going to weigh in on whether the risk justifies this or not, but that's what I interpreted their reasons as. **TL;DR;** it's not because it's hard, or causes problems, **it's to stop people building from master** &amp; shooting themselves in the foot with bugs.
Can you elaborate on why you found that Ruby syntax wasn't enough to replace bash etc.?
Sure. Passing arguments: Let's run nmap, shall we? In bash: nmap -v -sn 192.168.0.0/16 10.0.0.0/8 In chitin: nmap -:v, -:sn, '192.168.0.0/16', '10.0.0.0/8' nmap -:v, -:sn, '192.168.0.0/16' =&gt; '10.0.0.0/8' It's just slightly uglier and more of a hassle. I'm totally open to any and all ideas no matter how strange to make it better. It's sort of like putting a flying car on the roads today. The infrastructure just *isn't there*, and you'd have to tailor your flying car to work with the current infrastructure if you want it to be adopted. In an ideal world... I don't know what chitin would look like.
And what about those parens?
Fact: _why is now a Python programmer and is active in the Python community. He recently attended Pycon.
self-whoring: I saw him speak at that CMU event. He was fucking awesome. Walked around with a flower in his lapel because he said he didn't want to live in the sort of world where men didn't regularly wear flowers in their lapels.
You're absolutely right.
I'm interested in the newer [ruby-gir-ffi](https://github.com/mvz/ruby-gir-ffi#readme) (Gnome2 and 3) and [ffi-efl](https://github.com/jeremyz/ffi-efl#readme) libraries (Enlightenment 17).
Repeat: I wasn't concerned about it, I was making a point. Maybe you think old-school ideas about making programs efficient are laughable. As you say: hardware today is obscenely powerful. But it is also often obscenely wasted. The other day I downloaded an open-source program for my Mac. It was 145 MB. Not so big, you might say? Well, that's 15 TIMES the size of the entire hard drive that was in a typical computer in an office in 1990, 20 years ago. Is the program that much more powerful then? No, it's not. That typical machine I mentioned of 20 years ago had a full installation of Microsoft Office on it, with lots of room left over for file storage. Most of the power of today's "obscenely powerful" hardware is actually used up compensating for the insanely (in comparison to those days) bloated, sloppy, and slow software that is written today. I've been there, and that's just the truth. And I'm not blaming it all on the app developers; the simple fact is that many of the tools, including OS and modern scripting languages, contribute a lot to the outrageous increase in size and decrease in speed. But yes, OO architecture is a very large part of that relative inefficiency. Once again: is your OO code example an example of that? No, not particularly. But adding unnecessary overhead to your programs is a BAD habit. You just happen to be programming at a time (all that obscene hardware) in which you can get away with those kinds of bad habits. That doesn't mean they're any less bad. But it does mean you are very fortunate, compared to the programmers who came before. 
Python code lol? :)
Blerghhh, too much...
Yes, that's true. It was a bit sloppy of me.
We don't need no stinkin parens!
that was the irony, bitches!
[GUI Frameworks on Ruby Toolbox](https://www.ruby-toolbox.com/categories/GUI_Frameworks). Looks like [Shoes](http://github.com/shoes/shoes) takes the top spot. 
Pics or it didn't happen
There seems to be some disagreement about whether to use hyphens or underscores in gem names. If you use hyphens, do you end up needing some custom line somehwere to make sure rubygems and/or bundler will `require` the right file?
Thanks. I irks me that their tl;dr at the top of the post needs yet another tl;dr. It's par for the course in my experience with writing in the Ruby/Rails world.
Out of boredom I wrote this :) class Player class Note Notes = { c4: 261.626, d: 293.665 }.freeze def initialize(note, duration = 250) @note, @duration = note.to_sym, duration end def play raise ArgumentError, "Unknown note: #{@note}" unless Notes.has_key?(@note) Sound.beep(Notes[@note], @duration) end end def play(*notes) notes.each do |note| Note.new(*Array(note).flatten).play end end end p = Player.new p.play :c4, :d, :d, :c4 =&gt; 100
I wouldn't believe anything he says. He's crazy. It was a joke on his name. Jesus...uptight bastards.
oh sure maybe so but I stand by it. _why was a treasure. Too bad some couldn't just leave him be.
Other than 'wasted CPU/space' of an install, which I agree isn't a major problem, the real potential problem case is if one of the dependencies is a native gem that _can't_ be installed on the production machine due to missing headers/devel-packages (and aren't actually needed in production anyway, so it's only a problem because of gem/bundler dependency resolution. With the case of assets, there are of course other ways to manage deployment that don't require the precompiling on the production machine itself, which some people sometimes prefer -- perhaps because they really don't want a JS runtime on their production machine, or the CPU cycles to run it) I believe there was a post on reddit recently with a linux distro manager complaining about bundler/rubygems, where this was at the root of his complaint (although he didn't quite say it like this, it took some reading between the lines to figure out exactly what was giving him a problem)
I put assets in `lib` if they're say, another project I maintain, like a singular jQuery plugin, my custom reset.css, or like the JS tracking codes my company requires us to deploy on our apps (and generally maintain individually to our apps), or custom jQuery Mobile/UI JS and CSS from ThemeRoller. Assets in `app` are things that we develop _for_ the application, like the specific js and css written for the app in conjunction with our views. Basically, if it's not specific to the app, it doesn't go in `app`, and if it's not mine, it's a `vendor`. `lib` is stuff we're responsible for, but it's also not specific to the app. also, s/js/coffeescript &amp;&amp; s/css/sass, etc etc. edit: for a rails app. For a gem, yeah, it's kind of not clear.
Lol who still uses rdoc? YARD 4 life!
It depends... Are you targeting only one platform? If so - check qtruby or macruby, otherwise your only choice is jruby (RedCar editor is using jruby and swing, worth taking a look). Other libraries like wxurby or fxruby aren't maintained or there's no resources to do so. Shoes is a nice framework, but it lacks some of the layout features that would make it useful for creating GUI apps.
Isn't it good enough to be able to do this? assert_equal [1, 1, 3], thing.to_a.sort
Okay, maybe I see now. But I'd expect assert_equal_unordered to have the same semantics as assert_equal on two arrays _but for_ the order. But: assert_equal [1], [1.0] # pass assert_equal_unordered [1], [1.0] # fail 
That is an interesting example of a Rack implementation, but introduces far too much of a security risk to be used in production environments.
Well, pretty much any time an imaging library throws an out-of-bounds error at you, chances are it knows what's up. `(317x47+317+47)` is the key here, I think. I'm afraid I'm not very familiar with RMagick, so I can't debug any specifics, but it seems you're asking for a rectangle rather than a point. 317+317 &gt; your 629, whereras I'm guessing before that it's ~310 or something, which is why the error isn't thrown until then. I don't get why you're drawing a red line, either... Anyway, I would highly recommend looking into ChunkyPNG, an excellent alternative to RMagick, as long as you're working with PNGs, of course. Just for fun, here's my solution: img = ChunkyPNG::Image.from_file 'oxygen.png' p img.row(img.height / 2).map { |e| (e &gt;&gt; 24).chr }.join.squeeze
I figured it out, the last two arguments are the width and height of the rectangle, not the positions of the corners. I fixed it and got it. The reason I was drawing a red line was from earlier when I was trying to make sure I was iterating over the hidden message correctly. Do those two lines of code really solve the problem? I'm new to Ruby, my total solution was about 8 lines. Thanks for the help :)
 $ ruby get_feeds.rb /usr/lib/ruby/1.9.1/open-uri.rb:35:in `initialize': No such file or directory - ./data/feeds.yaml (Errno::ENOENT) from /usr/lib/ruby/1.9.1/open-uri.rb:35:in `open' from /usr/lib/ruby/1.9.1/open-uri.rb:35:in `open' from get_feeds.rb:10:in `&lt;main&gt;'
Well, I started with QBasic about twelve years ago, picked up the standard Web technologies along the way, and was a PHP programmer for way longer than I'd care to admit. I finally started using something useful (Python) about two years ago, and then Ruby maybe six months ago. It really is wonderful how much of the low-level stuff is abstracted away by high-level languages. Learning Ruby, like anything, is all a matter of finding a suitable starting point and letting Google guide you the rest of the way. Do the [Ruby Koans](http://rubykoans.com/), pick up a decent book, and then just constantly try to do new things, starting from the very basics and working your way up. There's no real "supposed to" for languages like Python and Ruby; they're general-purpose, and can literally be used to program pretty much anything. Of course, performance is a factor, but not a strict limitation. Either way, exposure is the best teacher, so just try to always be on the lookout for something new to program; it's all about consistently building up your repertoire and internalizing it through repetition.
My answer: 98% of the time, yes. That's why it is in question. At least on my code it is 98% of the time but I have a very specific design/testing style, so I'm not counting myself.
Come again? Did I accidentally name something the same as something else? Did a quick Google for "Polishing Rubies" and didn't find anything the first time around.
This is getting off topic, but.... If the 'right' way is for == to be object identity and eql? to be value equality... but stdlib 'Numeric' over-rides em to end up being the _reverse_.... I question how 'right' that stdlib is. It doesn't get more basic than Numeric, if even Numeric can't get it right, it sounds like there is no 'right'. Now, Numeric is confusing becuase ruby enforces singleton pattern for integers at least. 1.object_id == 1.object_id But note String also over-rides == to not be object identity. "a".object_id == "a".object_id # =&gt; false "a" == "a" # =&gt; true From where do you get your information that "==" is 'supposed' to be object identity? If such core stdlib classes don't do things that way, apparently ruby itself didn't get the message! Seems to me the 'right' way, as established by ruby stdlib is, "do whatever the heck you want and there's no predicting it" Grr. But wait, then we've got #equal? for actual object identity, so why would we need #== too? Are you sure you're right about #== 'supposed to be' object identity?
I'm using the Airbrake gem with [Errbit](https://github.com/errbit/errbit) on an own server for several projects. Errbit has support for Redmine as well but I have to say I've never bothered to get the two to talk so I can't help much there.
It doesn't really answer the question, though. Yes, from a "Number 6" perspective he shouldn't have to answer the question of why he resigned, but on the other hand people are still curious about his motivations. Like, why did he feel such a need to be anonymous to start with? It's not like Ruby programmers are frequent terrorist targets or something. If there's something about the community that made him feel the need for anonymity, it would be good if it was identified.
The are the same. The gem serves the service. Without the service, you cannot use the gem. Has that changed?
http://docs.exceptional.io/getting-started/rails3/ It has its own gem, much like airbrake :)
[This is my branch](https://github.com/terrcin/redmine_airbrake_server/commits/master) to give you an idea of what we've done. We were using AirBrake as we needed something quick, but then couldn't move away quick enough. Can't assign exceptions to someone, can't leave comments on exceptions etc... We're much happier with our new setup.
&gt; If the 'right' way is for == to be object identity and eql? to be value equality It's not the 'right' way, it's just the default way. Ruby BasicObject defines these and documents them: "At the Object level, == returns true only if obj and other are the same object. Typically, this method is overridden in descendant classes to provide class-specific meaning." "The eql? method returns true if obj and anObject have the same value. " I edited my previous comments to make this clearer. &gt; But note String also over-rides == Yes. IIRC Ruby runtimes may enforce singleton patterns for String. &gt; From where do you get your information that "==" is 'supposed' to be object identity? The Ruby BasicObject defines == and .equal? as object identity. &gt; Seems to me the 'right' way, as established by ruby stdlib is, "do whatever the heck you want and there's no predicting it" Little bit. :) The documentation is pretty good these days. &gt; But wait, then we've got #equal? for actual object identity Yes. Ruby requests that subclasses do not override this. &gt; Are you sure you're right about #== 'supposed to be' object identity? Yes in BasicObject as defined by the Ruby API, but not in subclasses that override == 
Not sure why you are being downvoted but I have one question. What's this for exactly? Is it only for when you don't have a DB on your dev box? 
Mongo :(
Fact: Stating something as a fact doesn't make it one.
I use Airbrake (the service and of course, the gem). I've never had a problem with it.
How is windows support? Also does it require X11 under OSX? Thank you for your work on this library.
Could it just be that your terminal is not set right to display ISO-8859-1? Ruby doesn't really do any particular encoding by default. Debugging char encoding issues is one of the most painful things, it is true. What version of ruby, 1.8 or 1.9? What is the ultimate goal, what's actually going to happen to the text? Is your goal to output it to a terminal, or to do something else with it? Do you want to save it in ISO-8859-1, or you want to save it in UTF-8 but representing the same characters?
maybe if the syntax highlighter didn't show comments as bright green
you still use subversion? You must be very lonely ;)
Ah, I haven't really tried a full-fledged Sinatra backend yet. Good to know. I've been happy with the EJS templater. I understand your statement about the client. I of course make extensive use of validations and hooks on the backend to ensure data travels as expected. As long as you clamp down on data validity I think you've solved most of the trust issues. I wrote 'heavy-client' code for a company for years whose business had massive risk for fraud and gaming but with robust validation on the client and the backend we suffered very few if any client related security issues. I can't think of a single case. We saw lots of attacks on what you might call "social" vulnerabilities, though.
ruby 1.9? string # known to contain ISO-8859-1 encoded # this just tells ruby 1.9 that the bytes in the string # are already in ISO-8859-1 string.force_encoding("ISO-8859-1") # that MAY be all that's required, it ought to be translated # to UTF8 when it's saved to the db. But it doesn't hurt and # will avoid confusing to also do this, which tells ruby # to trans-code from ISO-8859-1 to UTF8 in the in-memory # string string.encode!("UTF-8") If that doesn't work, there'll be some painful debugging to be done, char encoding debugging is always painful. 
I just installed Gitlab at work to replace our SVN this week. Excellent product. 
Try using [youtube-dl](http://rg3.github.com/youtube-dl/), which apparently also supports blip.tv.
sorry, it's really a pain, I don't have time/energy to do it for you. You can't always believe what someone tells you about the actual char encoding of a string they give you. sometimes they are wrong. 
[This](http://www.i18nqa.com/debug/bug-utf-8-latin1.html) page suggests those "Ãƒ"s showing up means... if I understand it right... that your source text may be UTF8 already? That seems unlikely or you wouldn't have had the problem to begin with. But I dunno, try `string.force_encoding("UTF-8")`. Sorry, character encoding debugging is really tricky and painful. For me anyway. 
Actually, 44. With whitespace and comments, no less. http://www.reddit.com/r/ruby/comments/oyszn/gem_rails_like_sinatra/
that's good, right?
Excellent, I'll give it a shot.
I really wish it wasn't so convoluted to install and configure Gitlab. I've tried it like three times now and each time it has not worked. There are like a dozen different install guides in several places across the github account, half of which appear to be outdated, and ALL of them are targeted towards specific platforms, either Ubuntu or Fedora. I'd be fine with giving a list of dependencies and distro-generic steps to install, but instead I have to dig through 4 different installation shell scripts, figure out how to convert it to Arch Linux, then hope it works. I'm sure I'll get it working eventually, but really, the documentation needs a lot of work.
Nice work, thank you. The bonus feature rbenv is especially helpful.
That's because of the dependencies. You need to install mySQL, redis, gitolite, nginx, unicorn, rails, ruby, and also create a user and set up the home directories. Too many moving parts and any bit can go wrong.
&gt; Read carefully. I will say this only once. The nested routings in Renee is nice to dry up your code. I see what you did there. &gt; If enough people vote for ticket 31, Sinatra will also have this: [1] https://sinatra.lighthouseapp.com/projects/9779/tickets/31-nested-resources Sinatra already has namespaces in contrib, no?
I use cuba frequently for internal apis, sinatra for more full-fledged websites. I haven't used Renee. Cuba is VERY small and basic, but gets the job done in a simple and straightforward way.
Excellent, I did not know about this.
Thanks for the feedback. What about Sinatra makes you want to use it for more full-fledged websites vs Cuba?
[I made you a Gist](https://gist.github.com/2176075). Demonstrates reading a source that's explicitly declared to be ISO-8859-1, converting the data and outputting to terminal, then writing to a file that's explicitly UTF-8. Includes a test file; if you `git clone` the gist you should be guaranteed to get the test file in the right encoding. The `file` command should report is 'ISO-8859 text', and the md5sum is c130e4613d8589de2b343e79bc460ae4 Works correctly for me on ruby 1.9.3p125 (2012-02-16 revision 34643) [i686-linux].
Absolutely! I just found it a bit surprising. 
That is awesome!
Good concise writeup. I agree with 99% of this. Just not the stupid single quoted strings thing.
DBI should have been used by rails. It wasn't. The rails team chose to write their own data access layer from scratch. Then other people thought that was too heavy so they wrote sequel. That's the way the ruby community is. Instead of using something that exists and making it better we always write a new one. Go to github and search for anything. Search for REST, twitter, CMS, Single sign on, admin, pagination etc. You will see tons of attempts at accomplishing the same thing and the chances are most of them will be half finished, poorly documented, or no longer maintained. All that wasted effort. Such a shame. 
How can they just decide not to use and and or and go for &amp;&amp;, || instead? They mean different things in ruby... I forget what but I think one checks if it evaluates to zero or something. 
I always used single quotes when possible but there doesn't seem to be any reason to do so: http://stackoverflow.com/questions/1836467/is-there-a-performance-gain-in-using-single-quotes-vs-double-quotes-in-ruby
'and' and 'or' have very low precedence, lower than '='. While it can occasionally be useful for readability (like in Perl's "or die" idiom), a lot of the time they're just a subtle bug waiting to happen.
Can you explain more please?
Perl legacy, like the trailing if/unless. They _are_ kind of nice to have sometimes.
80 char line limit is stupid and unnecessary... "break long lines intelligently" is better. Otherwise I pretty much agree with everything.
I understand the precedence difference between '&amp;&amp;', '||', 'and', 'or', but I think it is generally more clear if parentheses are used instead of assuming the next developer who looks at your code is going to interpret the precedence the same way. Parentheses are just a more declarative means for defining precedence. 
I do this. It's much easier to read what's going on.
Github didn't become popular because of their ruby skills. They are popular because they saw a need and have worked hard to build tools that developers want to use.
If you want raw SQL access to the Database, checkout [DataObjects](https://github.com/datamapper/do#readme), which supports [SQLite3](https://github.com/datamapper/do/tree/master/do_sqlite3#readme), [MySQL](https://github.com/datamapper/do/tree/master/do_mysql#readme), [PostgreSQL](https://github.com/datamapper/do/tree/master/do_postgres#readme), and will automatically switch over to using the [JDBC](https://github.com/datamapper/do/tree/master/do_jdbc#readme) on JRuby.
No. There's no reason. Especially when you talk about using "self." for singleton methods (which I agree with) because it makes them easier to refactor and move around. Converting single quoted strings to double quoted strings is a waste of time, so just use double quoted strings for everything. Those who say they can't tell whether there is interpolation inside the string at first glance need to switch text editors.
I guess I prefer Python's mantra of there should only be one and obvious way of doing something.
&gt; # good /(?&lt;meaningful_var&gt;regexp)/ =~ string ... process meaningful_var I never knew you could do that. I always tested regexes the other way round, ie `string =~ regex`, and named groups don't create new local variables when done that way. 
The only reason I use single quotes is so I don't have to press the &lt;shitft&gt; key. 
.wav files are not "Microsofty" and .aiff files are not "Appley." And if they were, would it really matter? Just use .wav, it's more or less the universal uncompressed audio format. There may be some gems to help you, but you can certainly just write them yourself. If I recall, there's not much to them besides a small header and then raw uncompressed PCM.
emacs does it that way == matz does it that way
Yeah I know, I just never knew about the local variable creation feature of the Regex `=~` definition (the String `=~` when called with a regex doesn't do this).
Yes, and they've written some amazing code that many other big sites use. The larger your codebase becomes, the easier it is for bugs to be introduced.
Perhaps competing with Rails is the wrong mentality for lightweight frameworks. I use Rails for even small projects because it just has so many conveniences built in making me develop faster. Padrino is a good example of a framework that tries to elevate Sinatra to compete with Rails, but it just feels like exactly what it is: something that tries to be Rails but isn't as good as Rails. My boss once made us use it for a production application and at the end, we'd just recreated Rails' built-in conveniences. Rails is already great. There's room for frameworks with other competitive advantages, though. Perhaps an opinionated framework that's made to plug directly into Backbone.js or something. 
Make one. Though I don't care, upvotes say you aren't alone. Averaging less than 5 links a day, I just personally don't think there's a need to splinter the subreddit yet.
But nobody uses Ruby without Rails. Edit: Really? I need the sarcasm tag? *&lt;/sarcasm&gt;*
Well this is [/r/ruby](/r/ruby) and there is [/r/rails](/r/rails) so I guess people just need to just post better? Maybe a header on top that says - "RAILS POSTS GO TO [/r/rails](/r/rails)" -
Would be nice, I agree. 
I got it and upvoted. Shame someone didnt. 
I think more readers should _politely_ remind submitters of the official policy that Rails specific stories go in /r/rails. Maybe one of the mods could bold the note about /r/rails in the sidebar?
Cuba seems like a very interesting micro framework. Apparently it's really, really fast. Glancing over the source code quickly, it seems very cleanly written, well documented and *tiny*. I like it.
No, that's the expected output. If your terminal is UTF-8, the UTF-8 line looks good, the ISO-8859-1 line (original encoding) _should_ look like garbage. If your terminal is ISO-8859-1, it should be the other way around.
Nested ternary operators. \**eye twitch*\*
So, forgive me if I'm being unpatriotic, but why does Ruby need concurrency? Personally, I see Ruby as mainly a Web language. And concurrency for building web pages comes at a lower level. You don't build 1 page for 1 request with 10 threads. You build 10 pages for 10 requests with 10 threads. You don't need concurrency in Ruby for that, you just need 10 worker threads in Passenger (or whatever). So is this a big push to get concurrency for, like, sysadmin-centric Ruby? Or something more like a desktop app?
Sometimes, you crunch the numbers, even if you're primarily building web pages. We deliver web pages and json/xml api results, but we'd love to be able to parallelize some of the obviously parallelizable things we do, both in real time and offline.
If your article is called "The current state of ruby concurrency", and you don't mention the GIL, your article is of little value.
Because not everyone uses ruby for web programming. Also, ruby's purpose isn't to support rails or web programming, it's supposed to be a general purpose programming language. I wish there was less focus on web programming with the ruby community :( 
GIL is related to the interpreter, and not the language. Different interpreters work the concurrency problem around in different ways. JRuby has already done it, Rubinius brought in Actors. Probably IronRuby won't be affected.
The whole article is about libraries, and not the language. I'd argue that talking about interpreters is closer to talking about the language than what's actually here. An overview of which interpreter is where on concurrency/threading/GIL or what's happening in MRI 2.0 with concurrency is more like what I'd expect from this.
Why would he use FFI when he wants to create a .wav file that he can open **in other programs**. He just needs to know the structure of a .wav file... On .wav format: https://ccrma.stanford.edu/courses/422/projects/WaveFormat/ or http://www.sonicspot.com/guide/wavefiles.html
JRuby has excellent threading support, with a TON of tools from the JVM to help you do things concurrently. Rubinius also has excellent threading support. I *just* gave a talk on this at RubyNation: here's the slides: http://speakerdeck.com/u/davetron5000/p/dont-fear-the-threads-simplify-your-life-with-jruby
Thank you karatedog! I can figure out everything to actually _make_ the file... but I can't get it to save it as a .wav. There's some sort of arbitrary difference between a binary file and other file types. Basically, I understand it conceptually, but certain aspects of the mechanics are eluding me. The kinds of things that expert programmers don't even know they are doing (they handle these things off-hand without even thinking about it. There must be some metadata to store the rate and bandwidth...
Well, most of my Ruby goes in an ActiveRecord model. But it pretty much all ends with the word "end" at some point or another. But I disagree. Rails does not deal with concurrency. As I said above, Passenger does, by running the app in several different worker threads, which Ruby knows nothing about. MySQL (or other database) also deals with concurrency, because it's got several worker threads talking to it at the same time. But rails itself is single-threaded. The other guys here have really valid points, about Ruby doing things other than serving web pages. I think of Python when I think of interpretative languages for OS/desktop stuff, but Ruby is just as valid (or would be if it had easier concurrency?). But building Ruby to serve web pages using threaded processing internally, using more than one process per request, is in my opinion moving in the wrong direction. Sending out HTTP is all about what you can send out RIGHT NOW. If you can't send it out RIGHT NOW, then you should have some other background task working on it, and your RIGHT NOW data that Rails sees is just a status report. If you need more than one thread to build out your HTML, you've gone about something wrong. Because if it takes you more than a few milliseconds to turn that request into a response, then people are going to lose interest. That's deeply studied by people with much more time and money than I have. Plus, web servers are already all about concurrency. If this is a real web site, you're going to have (for a trivial example) 10 users hitting it concurrently anyway. Building 10 pages 1 at a time using 10 threads each isn't any faster (and might be slower) than building 10 pages all at the same time using 1 thread each. Can a web app benefit from parallizing, for example, populating non-inter-dependent template sections, or running database queries, or aggregating some external site? Sure. But every time I've ever seen something like that, the best path forward has always involved a few steps back to saner times, and a re-think of what that particular chunk was supposed to do in the first place. Bottom line: How do you parallelize the processing of your web page? Send out the base site HTML first, RIGHT NOW, then fill in the heavy-computational stuff with an AJAX request or 4. That's parallel.
Yeah. So many ORM systems, and yet none of them seem to support SQLite FTS indexes. Or at least, none of the ones I've looked at.
Sorry if you took it as a personal insult. It was, if you look closely, a series of questions.
I just find it odd that there isn't a file-type that isn't associated with Apple or Microsoft, even if, as you point out, in this case it doesn't matter.
Yes, okay, I am aware that there's a difference between a thread and a process. I was not aware that this was a semantic discussion. Let's just say, Passenger is already highly parallel, and more than capable of filling up all the available process/thread space on a server without the Ruby app having any multi-threading in-built. Depending on other performance factors, perhaps. The bottom line here is that at any given time, Passenger with its 10 configured workers is working on 10 requests *at the same time*. I posted elsewhere about my feelings on HTTP requests that take enough server resources to consider needing threading. And furthermore, as I've said elsewhere, if you've got 10 users using it, you're already running 10 threads (in 10 different processes), and you didn't have to write a single line of thread-safe code. The essence of my question was: Are you really pulling down multiple external URLs for *every request* to a certain page? If so, yuck. If not, cron job. My own most recent foray into site aggregation is, in my opinion, [ugly](https://gist.github.com/2211339). I definitely agree that splitting it up (by process in my case, threads weren't separate enough for urllib) was a requirement to even get it to a tolerable speed for my own internal use. I can't imagine running it live on a public server, under any conditions, other than as an AJAX request that has a lot to distract from it.
Indeed, JRuby is a great platform for building concurrent applications. JRuby is able to tap into man-centuries of research into building multithreaded programs present in the JVM, and if you run into limitations in Ruby itself there's a whole wealth of other JVM libraries to tap into. JRuby has been the winner of every benchmark I've done regarding Ruby concurrency. BTW, I wrote Celluloid ;)
The GIL is ireelevant, IMO. There are two excellent Ruby implementations, JRuby and Rubinius, which don't have a GIL and support thread-level parallelism through fine-grained locking. JRuby is able to tap into man-centuries of research into building multithreaded programs present in the JVM. If you'd like your threads to run on multiple cores, use JRuby or Rubinius. If you're content with a GIL and your program being stuck on one core per VM, by all means, use YARV.
Multithreaded web applications can serve more than one request at a time. Throughput-wise, one Ruby VM, running a multithreaded Rails application, is in general pretty much always going to be faster than N Ruby VMs running a single-threaded copy of the Rails application across N CPU cores. The same thing goes for single-threaded Resque workers versus [multi-threaded Sidekiq workers](http://mperham.github.com/sidekiq/). Keeping everything in-process is extremely advantageous from a performance perspective, because a sufficiently intelligent VM is better able to manage resources than multiple independent copies of the same VM that can't pool and share resources. Frontend web applications within a service oriented architecture *need* to be able to do parallel scatter/gather operations across the services they need to render the page. Making requests one-at-a-time means the page latency is, at a minimum, equal to the sum of the latencies across all services. Making requests in parallel, at a minimum you are only slow as your slowest service.
out of interest, what is the relationship between cool.io and celluloid? 
Bundler is great. It's especially easy if you install your binaries and vendor everything. The bundle command that works best for my system: RUBYOPT='-rpsych' bundle install --binstubs --path vendor/bundle 
Celluloid::IO replaces cool.io ;)
Have you released these yet? If not can you post back here when you do as I'd be very keen in looking at them.
Side note: is it wrong that I consider you a coding robot? All the work on Celluloid and family: wow I've been meaning to try it. Hopefully this weekend if not sooner.
In the CAD world the object model used to define geometry is generally not the same as the model that gets written to a file. So there's a natural dividing line between the working model and the storage model. Reading and writing the files requires translating between the two models. And, considering the multitude of CAD file formats out there, the set of possible translations can be rather large. On top of that, any given project may only use a small subset of the available formats. My plan is to keep each gem simple; one gem for each file format and one for the working model. Partly because it's logical to do so, and partly to keep the whole thing manageable. I'd like to avoid requiring handlers for formats that aren't presently needed. Similarly, I'd like to avoid requiring all of the CAD-related gems just to read or write any particular format. I'm not yet sure how to do all of that and I was hoping the community had a canonical place for file handlers to live that would guide my decisions. Should I have a namespace for DXF, and another for DWG, and another for STL, and so on? I like the DSL idea, but the "foo.save("myfile.dxf")" seems like it breaks encapsulation and separation of concerns. I'd rather that MyCadGem not have to know about every possible file format. BTW, why is Prawn in it's own namespace instead of something more obviously related to PDF handling?
cool thanks! I'll have a look. Projects always turn out to be bigger than you originally think :-)
I've only got time for a quick glance, but I see you're overriding the simple backend to lookup translations in a CopycatTranslation table. Does this mean there's a query needed for every key you render or does it still get cached somehow?
I don't see the big deal. It seems like a silly rule to make. Your first condition should be the most likely case. If the most likely case is a IF NOT then use UNLESS instead. It's easier to read.
http://en.wikipedia.org/wiki/Au_file_format Or raw [PCM](http://en.wikipedia.org/wiki/PCM). WAV AIFF and AU are just raw [LPCM](http://en.wikipedia.org/wiki/Linear_pulse-code_modulation) wrapped up with a nice header.
Which one?
I spent a month of my time working on it. 99 cents is what you find under your sofa ;) The app supports AirPlay. If you have an AppleTV then you can watch it on there. The app also works great on the iPad.
Thanks, used 6H7RY7KXYE34.
I agree with you (and the author). If it reads easier as unless...else then I don't see the big deal. 
How so? You can use single quotes in HTML, CSS, JavaScript, Ruby, etc. This is a serious question, not mocking or anything.
Do you know which ones? I'll go ahead and cross them out. Thanks!
Thanks! Used PJN637X9HWPA
I just used W7F79F6TAK7J. Thank you. It appears that LYAFEWW6RPMM and W9H9NHR6HNMM are gone as well.
Thanks for letting me know.
Yes, we do a database query for every key. In many cases this will be acceptable. To implement caching will require tradeoffs, and different users will have different preferences. For example, using an external system such as Memcache or Redis introduces an external dependency that makes the engine more complicated or expensive to deploy, which will be OK for some users but not for others. Also, it isn't obvious that the performance will be that much better than the indexed key lookup from the database. On the other hand, one problem with using an in-process cache is that with multiple web application processes you can't have automatic cache invalidation when the database value is updated. We could have each process invalidate it's cache every 5 minutes, but that means after an update there will be a period where some app servers show the old value and some the new, which is probably acceptable but still a tradeoff. We'll look for some feedback or suggestions about how urgent this is and what would be a good approach, but we want to keep it as easy as possible to use. 
NM...said it was already used. Look like they all have. If you get any more promo codes, let me know. Would love to check out the app.
How is celluloid(or just the celluloid actors if that's what you mean) more advanced than akka?
This probably deserves a blog post in and of itself, however Celluloid uses a combination of threads and coroutines to allow concurrent objects to process multiple methods simultaneously, allowing cyclical call graphs between concurrent objects. Akka's Typed Actors, the closest thing to Celluloid and recently released less than a month ago as part of Akka 2.0, don't support this behavior, which IMO makes them a lot more useless: http://doc.akka.io/docs/akka/2.0/scala/typed-actors.html You'll also need a few dozen lines of additional boilerplate to get them to work. In typical Scala fashion, Akka remains a poorly homogenized, overcomplicated solution. There's still a few features Akka has, like Transactors, which I'd like to add to Celluloid (via the Cloby gem) 
Okay in a traditional actor setup each actor can only handle a single message at a time, you're saying that in celluloid you can process two methods at the same time(I assume using fibers)? Is that the standard behavior? I think I'm confused because you compared celluloid to an actor implementation when this is something else. I will have to play around with celluloid, it looks well done.
Yes, the name I've seen used for it in most of the academic literature on the matter is "actor-based concurrent object oriented programming" which is the phrase I've generally adopted for describing Celluloid. You might take a look at one of the papers on the topic, ATOM, a concurrent object oriented programming framework for Python: http://python.org/workshops/1997-10/proceedings/atom/
I'll make 5 more tonight.
I get the lack of "proper", but I was getting at a perceived (on my part) lack of "intuitive" or "discoverable". Someone searching for a PDF gem might not think to search for a particular crustacean. Fortunately google figures it out for us. Regardless, that's not really my point here. I want to name my gems in a way that will make sense to anyone searching for similar functionality. I asked about Prawn because it seemed like a well known reference point and I thought there might be some community pattern or reasoning for naming it that way. I wasn't trying to drag us into perl vs ruby land.
So name your gem something obvious. The point I was making is that there really is _no_ "proper" here. Personally, I think that mentality is a waste of time (most of the time). I'd name it something fun like "DaWG" simply because I can. ETA: Make that "DaWG the File Writer".
All codes have been used.
Just added more. Get em while they're hot!
No need to install a gem. Just use `bundle --binstubs`. Here's the [manpage](http://gembundler.com/man/bundle-exec.1.html)
How so? After I binstub, I no longer need to use `bundle exec`. Am I missing something? Edit: Reference: http://robots.thoughtbot.com/post/15346721484/use-bundlers-binstubs
1) That will mess you up if you're doing gem development. (conflict of bin directory) 2) This is automatic, with binstubs, you have to be explicit about which one you're running from.
For #2, I believe it only adds overhead for commands that use your ruby executable.
Of course, this doesn't work if the executable is *only* installed in a bundle, and not on your system.
Well, gitlab is actually the easy part. gitolite is a bit of a pain (twice as much if you are migrating from gitosis). Setting up unicorn properly was a bit difficult, but that is technically unnecessary.
Thanks for the pointers. That's given me a lot to read, but it's helpful. &gt; It's not a good idea to extend the File class ever. But... File::DXF::write() is so intuitive. Oh well. I guess it's not the ruby way.
&gt; def self.Line(*args) &gt; Geometry::Line[*args] &gt; end Use snake_case for methods and variables. Geometry:: can be omitted. def self.line(*args) Line[*args] end OO is important in such project, make sure you are naming methods, using inheritance and mixins properly. The namespace can be CadGen::Dwg, CadGen::Dxf etc.
For those who use rbenv I found this: [https://github.com/carsomyr/rbenv-bundler](https://github.com/carsomyr/rbenv-bundler). Thoughts on which is better?
Sure. I got the impression those were pretty standard.
paint looks nice! Reminds me of [colors.js](https://github.com/marak/colors.js) for node. Terminal colors do a lot to make CLIs fun. :)
Nokogiri is awesome. The website on the other hand is.... troublesome....
I love [bindata](http://bindata.rubyforge.org/) for binary data I/O.
I used 7WWFH7TLNTTW
kthxbye, lol :)
Thanks. I'm already using bundler and I found Github's style guide (it was all over reddit, how could I miss it?). I'm mostly in agreement with the style guide, but I'm not a fan of 2-column indents. Good thing it's just a guide :) I had the impression that all of the cool kids were using yard these days. Is TomDoc the new hotness, or just what Github uses? 
For one, rbenv-bundler only works if you're using rbenv.
I rather like Tire, which is an elasticsearch binding. It's really well done, a little finicky in spots, but between it and elasticsearch, it makes fulltext multilingual search _super_ easy. I also have been digging on neography lately, we're using neo4j for a project at work (I actually just gave a [talk](http://www.github.com/jfredett/neo4j-talk) on graphs at a workshop last night!), it's a really nice API binding to neo4j. It's still young, but it's still very useful. All that aside, my _favorite_ gems are my own! I wrote [sortah](http://www.github.com/jfredett/neo4j-talk), which is for sorting emails, it's still being developed actively, despite the fact that I haven't committed to the repo in a while (I'm planning and prototyping next steps). I also just put up [graphable](http://www.github.com/jfredett/graphable), which is a piping fresh extraction from a live codebase, it's presently in a pre-release state (it's on rubygems, but it's not really ready for use (will be making it 0.1 when it is)). It's designed to work with a very minimal ORM API (ideally just `.all` or `.each` on the class, and `.to_node` or `.attributes` on the instance) and from that and some class-def level DSL, extract a neo4j graph representation of your database, complete with indexes and metadata. It's pretty ambitious, but I think it's really a promising gem which will ease the introduction of NoSQL like graph dbs to discerning (read, paranoid) DBAs everywhere.
Interesting. How are you sanitizing the input? I mean, I see that you have forbidden syscall pipes but I'm interested how you set that up. I'm fairly new to ruby, so I don't know if this is an option in the interpreter or in your server software. For instance, how are you stopping users from executing: hah = %x[shutdown -h now]
I was always curious why people do such things. Don't you use irb?
awesome_print annotate_models wirble hirb
I miss one thing. When I submit a solution and it's ok it would be great to have link "next problem".
You can perhaps think of it like a function definition. So: { |x| x + 1 } is analogous to: def myFunc(x) x+1 end So when you do something like: myArray.map { |x| x+1 } What you're telling Ruby is to pass that block, or proc (the terms are not the same, but for these purposes they're somewhat interchangeable), or inline function, or however you want to call it from some other language you might know. Anyway, you are passing that block to the `map` function as an argument. `map` then iterates through the members of the array, and runs your block for each one, passing the member itself as the argument (`x`). The `map` method is not the only one to accept a block. You can write your own: def do_something_with_hello (&amp;block) block.call('Hello') end do_something_with_hello { |x| puts "#{x} World" }
The link you've provided, while very cool, is a contrived example and is likely adding much overhead mental gymnastics. In very simple terms, a Proc/lambda is an anonymous function: a block of code that isn't tied to any object and can be carried around and invoked, AND brings along it's local scope with it. tip_percent = 20 tip_calc = lambda { |a| a * (tip_percent / 100.0) } tip_calc.call(30) =&gt; 6.0 tip_percent = 25 tip_calc.call(30) =&gt; 7.5 It's not a perfect example, but it demonstrates that it's a block of code that keeps it's scope (in this case can access the tip_percent variable) and is executed when #call is called.
Did you write the iOS app in any Ruby variant? I'm looking for a way to do that.
Yeah, that *really* doesn't seem like it would be $25K worth of work...
I had to edit the post a bit at the end because it was too long :P Hopefully everything is still understandable :)
weird, that works fine for me with 0.6.7 under ruby 1.9.2-p318 Chronic.parse '2012-03-25 00:00' 2012-03-25 00:00:00 +1300 and even Chronic.parse '2012-03-25 00:00 UTC' 2012-03-25 00:00:00 UTC
This project is aimed at beginners. Installing a VM with Ubuntu is hardly a reasonable alternative for a newcomer that is already intimidated by the command line, especially considering they'd still have to build everything via terminal, but now in a virtual OS. I certainly have no use for this, but I definitely get it!
How will this even work in the context of Apple's walled garden and new rules for sandboxing applications?
Agreed, use your downvotes sir.
This is absolutely fantastic. I cant appreciate it enough :) all other great replies too (and I love length. it's better than brevity when I'm trying to learn, so I dig that too..)
That was excellent. Really my only questions are near the end. 1. what other type of code might go in the yield method definition (just as a real-life-example). I'm guessing it would be yield, and then something else to do something with that code which is passed in as a block? 2. why would one want to convert a block into a proc? thanks again
Prawn sounds sweet. In that vein, how about some nice plotting libraries? I've yet to find something truly satisfying pretty much anywhere.
How you showed creating our own each/select method was what really made it click. that was a perfect way of explaining a real world example. thank you!
Time for a newbie question...What is 'snake_case'? I'm reluctant to use names that are too CAD-specific. The more research I do on these file formats the more I find that they're used for a lot of other things too. That, and, to my ear at least, "Computer Aided Design" is starting to sound like a relic of the dark ages of engineering terminology...back when computers were wondrous and new and we'd all have flying cars by the year 2000. These days it seems like the we're aiding the computer as much as it's aiding us. But 'CAD' seems to be part of the language now, and I don't have a better idea.
Thanks for the code suggestion. I've made the change and pushed it to github.
TomDoc looks interesting, but I'll stick with yard until I graduate to the big leagues, or until rubygems supports it.
Not enough sarcasm in your system, eh?
 while wtf = (wtf.to_i + 1).to_s Dir.mkdir wtf Dir.chdir wtf end 
I hate to be _that guy_, but Rails stories go in /r/rails (look at the sidebar if you don't believe me). Although I'm curious, if this is geared towards beginners, why aren't they targeting Windows (the defacto OS of most classrooms)? If they are targeting OS X, why not also provide a pre-configured VM of Ubuntu/Fedora? If you deploy Rails apps to Linux, why not dress it up to be a learning environment? Also how did they come up with this $25K figure?
That's why I left the quotes on, I figured some people might be able to understand the hyperbolic title as a straw man statement.
is lambdad a typo or is that the actual plural? 
&amp;#3232;\_&amp;#3232; This is about re-invigorating the community and lowering the barrier for beginners on the systems they actually use.
Why did you choose tire and elastic search over solr or sphinx or some of the more popular search tools.
One example: Many gems require external libraries that are native to linux, not osx. It is easier to set up a rails environment under linux than it is under osx because you can get all those libraries directly from your package manager. I am a rails developer / linux guy and I work with several osx rails developers - it could be that they don't know exactly what they're doing. It takes me all of 5 minutes of work from 0 to rvm and a couple rubies with all the ancillary libraries (ncurses, libxml2, etc).
To be pedantic - all hashes or signatures prove is that you're getting the original code from someone that can run GPG. They say nothing about whether or not that code is safe or trustworthy. I agree with the major point of your statement, though: github all the way.
&gt;Vernor Vinge Holy crap. Stallman looks stoned out of his mind. 
ah i see. What is a domain specific language? I see that very often.
It's basically a fancy way of naming a certain syntax specific to a use case. For the long story you should take a look at this Wikipedia page, it does a better story at explaining it than I do: http://en.wikipedia.org/wiki/Domain_Specific_Language
That's perfectly right.
upvote for not saying "hackers" (te debe haber costado &gt;:D)
Lo escribÃ­ asÃ­ pensando en vos y en pote :P
[Um?](http://cuboxlabs.com/people/work-with-us/)
Rails was right to write their own DB layer. I find this very sad, especially since i know most of the maintainers, but DBI back then was simply not workable. It was already crufty, slow and unmaintained. The burden of fixing the many issues with DBI combined with the lack of a serious maintainer made choosing it for Rails a non-starter. Oh, and let's not get into how hard it is for a ruby beginner to set up or use for the first time. While there have been some improvements, even now DBI lacks the appeal of ActiveRecord, DataMapper of Sequel. This is probably for the best, DBI is an older idea for an older time. 
As a relatively new rails dev the asset pipeline is the best recent additions to rails. I found it much more difficult to maintain and correctly load a multitude of JS assets. I hated having to modify my layout file every time I wanted to try out some JS... now all I have to do is drop it in a folder. Wow and for anyone new to javascript Coffeescript is brilliant.
yes precisely, it's a lost battle because the Ruby community (i.e. Rails community) suffers from delusions of grandeur but I keep trying, just in case.
Good. He deserves it.
Absolutely agree with "ES really is just a breeze to use" If anyone hasn't set it up before and played with it, it is worth the time.
I love you. Why didn't I think of this?
&gt; The idea that frameworks like Rails are no longer necessary is silly. After all, the real change is that weâ€™re sending back JSON documents instead of HTML! That sums it up.
The only thing I might like is having the nice domain names, but I imagine a few minutes of shell scripting could do the necessary hostfile hacks.
I might consider using POW if it was written in pure Ruby (no extra dependencies). Having POW written in Node.js with CoffeeScript seems like needless exoticness.
I hear this argument at least once a month. I have no idea why some people refuse to learn the order of operation for these operators. Of all the arbitrary information we hold in our heads every day, *this* is the one which drives people over the edge?
Well said, Eric.
I love the idea of contributing money to open source efforts, and I think Yehuda is awesome. I just don't think Rails.app is that useful. Better to put together a script to set up rvm, homebrew, and all that. 
Because I don't use OS X.
You shouldn't even need that. Most Linux systems come with zeroconf enabled these days.
Damn right. "I don't like language X, so I'll write a pre-processor that turns language Y into language X" is the most foul and rank code smell there is.
Sadly, I'm on OSX like the rest of my company. It's not a terrible OS, it's just not Arch. :( 
hmm, any links on how to use it for nice web addresses? I'd love to be able to do something like "rake zero" and have it spin up the appropriate thing so I can do `&lt;project_name&gt;.dev` or something like it. Maybe rake zero:restart to reboot it? It could manage ports for me and stuff? I've got about 3 different web apps I'm juggling right now, all on different ports and with different configs. This would make my life easier (and pow doesn't -- apparently -- work with the latest node).
I don't use OS X. Instead I use a combination of tmux, iptables and /etc/hosts to get the same exact effect.
Looks interesting, but it doesn't seem to follow Ruby style very well. Like huge indention, Array.new instead of literals, no spaces between "=", etc. That's nit-picky but you did ask :)
[interactive_editor](https://github.com/jberkel/interactive_editor) $ irb &gt;&gt; vim --vim-- class Dog def bark; puts "woof!"; end end dog = Dog.new dog.bark --/vim-- &lt;save and quit the vim session, goes back to the irb session&gt; "woof!" &gt;&gt; 1+2 #=&gt; 3 &gt;&gt; vim &lt;opens back up the above vim session where you can modify the code and run it again&gt; Demonstrating the workflow made more sense to me that explaining it at the time, but I hope that makes sense. Just an easier way to prototype quick ruby code. You can even open up existing vim files within irb and save temporary sessions to disk as you'd like. 
&gt;Yes, it's reasonable, but I probably wouldn't use it for that -- if you follow Martin Fowler and Pramod Sadalage's idea of "Polyglot Persistence", then it makes more sense to use something like Mongo for that stuff. Since I am such a follower, I've never used it for a document store. Sigh.. Elastic search or search, mongo for document store, memcache for caching, postgres for relational data. So many servers to maintain. It sure would be nice to be able to combine these to one service. Well I don't want this to turn into a tech support session but thanks for your tips and advice. 
This is very interesting because I recently needed something like this earlier at work, unfortunately we couldn't really use anything that required an install or a library (Our IT department hates development, long story). Basically we have to hand-code most of our work. I may have to borrow some of your code and see if I can adapt it, we ended up going with a short-poll to emulate roughly what we wanted. Great Job!
That's what Chef is for! I know it seems complicated, but it gets easier if you make use of services like Heroku, or make use of re-usable infrastructure / things like Chef/Puppet to manage your setup. One service implies a single point of failure, which is antithetical to durable architecture! :) 
Woah on the GPL purge. It saddens me that so many developers sharecrop on OSX.
Wow, now that's way cool.
Not in my specific example, no. But more generally? Totally.
When I said one service I meant a better elasticsearch. if for example elastic search was very fast it could double as a document store and maybe even a replacement for memcache. Three servers in one and resilient! 
I'd be glad if my code could help you!
You could probably use it for that, but I guess my thought boils down to SOLID. Namely, the SRP.
The default ruby Logger supports a 'formatter' argument already, taking a lambda or similar (the Rails logger does not, which is a travesty someone really ought to fix). So the "However, it tries to make your log mesages more readable" is not something it's neccesary to provide a whole new logger class for, just a formatter to default Logger. * And I'd strongly recommend providing a duck-type-compatible 'formatter' API like default ruby logger, in addition to your sprintf-style format setting. Also allow all these options to be set by methods after init, not just in init arguments. * And overall make Yell "backwards compat" with stdlib Logger, it should duck-type the same, including ruby stdlib Logger #new calls should work as-is with Yell. It should be a drop-in replacement for stdlib Logger, with extra features. (Again, it's a travesty that Rails logger is not; this diversion in API is what keeps people from easily sharing and and replacing loggers in existing apps). * For instance, the ruby 1.9.3 stdlib Logger features of sending log file in block etc should also be supported. 
 dir = 'a' loop do Dir.mkdir dir.succ!; Dir.chdir dir; end
Surely the solution is for rails to use the official logger then? With mayb a wrapper to maintain backwards compatibility.
I just meant don't waste your time trying out the codes and just go buy the app instead.
You might add to your readme a clearer description of what the problem with existing loggers are and how Yell solves that problem. Personally, unless someone makes a good case for the problem with the standard stuff, I'm not gonna wanna add the extra overhead of another gem. You say what Yell does, but I don't get a strong feeling of its differentiating features from Logger or other loggers.
I just wish they would improve Windows support in Rails.
agreed. I used Rails as an example of what NOT to do. When creating a new logger with additional features, make it duck-type-compatible with the stdlib logger, either by sub-classing it, or just duck-typing it. So my suggestion is to do that with Yell. 
My entire gemfile is annotated here - maybe you'll like some of these. https://github.com/sixarm/sixarm_ruby_gemfile
Thanks for the comments so far. I updated the README - hope it's more clear now. Yell is still very new and there is a lot of room on how this gem might develop. I have some things in my pipeline to add to this logger and I'm currently working on further adapters that I have not released yet (syslog, mongodb, etc.). For now you can already write to Graylog2 (available as separate gem), which was what I needed initially. I am aware that there are loads of loggers out there already, most notably [Log4r](http://rubyforge.org/scm/?group_id=203) and [Logging](https://github.com/TwP/logging). I've been working with Log4r for a long time and always found it a bit cumbersome to set up. It's a great logger - don't get me wrong - but I think there are more elegant ways to set up application logging.
Java interop and real threads to name two things
Oh, so the reason is for the features of the JVM?
This looks cool. Has anyone implemented a mix-in that reloads a concurrent object as it's source file is modified, for fast development? Also, if the authors are reading this, how close is D-Cell to being production ready? Is it stable?
RUBY needs a SERIOUS amount of work to separate the user stuff from the system stuff on Linux. Users should not expect to be able to install gems and things themselves, they should be installed as part of the OS and the packaging system. Allow for locally installed gems inside the source tree should be the way to go, but the rest should use what came with the OS/Distro.
This is not to install gems, but to package them so they can be installed in the target system which may not have access to the internet. Its akin to needing sudo to use tar to "tar up" the contents of a directory in your home directory.
Why *isn't* it the default?
I'm curious about this too. Performance issue? Bugs?
Oh Tenderlove... Is it too late for #sundayhugs? 
I think it was disabled due to bugs found during development that haven't been tracked down yet.
You can include two modules indirectly. Module has a #included method, which receives the class it was included in as an argument. From there, you can send any additional includes you need. module A def method_a end end module B def method_b end def self.included(klass) klass.send(:include, A) end end class YourClass include B end Now YourClass has all the methods from A and B, since B tells it to include A, once it itself has been included.
That said, I think I prefer two includes for what you're describing. It's clearer what behaviour your classes will have that way.
Unfortunately Ruby's TCO cannot handle mutually recursive functions, so it's not very useful: class Tailcall def fact_helper1(n, res) if n == 1 res elsif n % 2 == 0 fact_helper(n - 1, n * res) else fact_helper1(n - 1, n * res) end end def fact_helper(n, res) if n == 1 res elsif n % 2 == 1 fact_helper1(n - 1, n * res) else fact_helper(n - 1, n * res) end end def fact(n) fact_helper(n, 1) end end
I think you want [ActiveSupport::Concern](http://api.rubyonrails.org/classes/ActiveSupport/Concern.html)
What you posted first actually DOES work -- if the original Some::Module is doing nothing but defining ordinary methods with `def`. If the original Some::Module is doing fancy stuff to add or call class methods when it's included, it won't. And your solutions are what others have posted here too: * just give up and do a double include * manually do a `self.included` and include Some::Module at include time * ActiveSupport::Concern nicely abstracts that away and allows for multiple levels of inheritance, but might only work in this case if the original Some::Module (which I understand is a third party dependency) used ActiveSupport::Concern too. 
To put it in terms closer to the question: module MySharedModule include SomeModule def some_method puts "do important stuff" end end module ModelModule include MySharedModule def some_method super # do important stuff puts "do additional important stuff" end end class MyModel &lt; ActiveRecord::Base include ModelModule end 
No, since it is utterly redundant with Array. 
I can't tell if you're being sarcastic or not but a google search for "[ruby logger](https://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=ruby+logger)" takes you right to it.
What version of OSX are you on?
Define GCC. I'm a moron with zero prior programming experience. 
GCC is the C compiler you would need to build ruby from source. It's not included in the OS by default, nor should it be. It's provided by Apple as part of XCode, which is an unfortunately large download, or included on the discs that came with your Mac. If you were on a more recent version of OS X, the latest XCode release has a "command-line tools only" option that is a much smaller download. There's also the [GCC Installer](https://github.com/kennethreitz/osx-gcc-installer) that I believe the new tools are based off. Edit: Looking again at the original question: &gt; I can't d/l XCode due to my version of OSX. If you dig a little more on the developer site, you can probably find an older version of XCode to download, I'm going to assume you need 3.x. Also, there's a perfectly suitable-for-learning ruby included in OS X since 10.5. Edit 2: Keep an eye on this project, which is looking to alleviate the pain you're feeling right now: http://www.kickstarter.com/projects/1397300529/railsapp
I had the same problem as you (also on 10.5.8). If you can find your original OSX discs, there is an older version of XCode on the disc you can use. If you have any problems, go check out [the rails tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book?version=3.2#sec:rubygems) for some step by step instructions. If you search on google for some of these issues you'll probably find some answers on Stack Overflow. Good luck and happy Rubying! 
http://beginrescueend.com/rvm/install/ If you followed the instructions(!!!), you would have seen this part: Find the requirements (follow the instructions): $ rvm requirements If you run `rvm requirements`, then you'll see what you need to install. 
I've been trying to update ruby so I can install Rails for almost 2 weeks now! Every time I get around one problem there is another. I tried xcode and gcc, rvm and rbenv. Going to just run a virtual machine with Ubuntu. 
Didn't Apple also release a slimmed down version of just their CLI tools?
He's missing a compiler. Neither MacPorts nor Homebrew will help him (yet). First, he has to get gcc onto his machine.
It is not as easy to get up and developing quickly on a mac as it used to be. Personally at this point I would just do it in a virtual machine using [vagrant](http://vagrantup.com/) There are multiple advantages for using Vagrant for your dev. * development system is often the same or similar as your production machine. * you don't need to run other services constantly (mysql, postgres, mongodb, etc) * roll the VM back to a snapshot if you mess it up. * contained. It is easy to issolate a VM for app specific server configuration. * maps VM folder to local folder so you can use your editor or other software on your mac instead of in a VM. * easy networking automatically configured. * repeatable configurations if you want to use chef or puppet. * very easy to get up an running quickly * All the advantages of Ubuntu. (package management, etc). Also use [RVM](https://rvm.beginrescueend.com/) as it does make life easier. When the results of kickstarter project are released, I'm sure that will be the easiest way of getting a dev setup running on OSX.
You need a compiler in order to build Ruby. On a Mac, the compiler comes with a set of tools called Xcode. I believe the version you need is 3.1.3. It can still be found on the Developer downloads pages. You will have to create a membership account at [Apple's developer site](https://developer.apple.com). It's free. Then go to [the downloads page](https://developer.apple.com/downloads/index.action), unclick every checkbox on the left except "Developer Tools". What you want should be on page 5. It's about a gig, so give the download time. As other people have said, if you still have your install discs, it should be there, in a folder called something like 'Optional installs' - that name may be off. For everyone recommending Kenneth Reitz's GCC installer or Apple's slimmed-down command-line tools, I don't think either are available for 10.5.
vagrant uses ruby. the question is regarding installing ruby on OS X that doesn't have ruby preinstalled yet and is missing the required tools to install ruby in the first place. edit: I've been told. It'll work and probably is the better idea instead of trying to install it directly.
Not available for 10.5, I don't think.
This is your best option if you refuse to upgrade OS X. 1) use install CD to install an old version of XCode (which will install a version of GCC) 2) install Homebrew or MacPorts (One or the other, they can conflict) 3) Use either of those to install ruby, or if you want to future-proof yourself, install rvm, then install ruby with rvm. All of these things have easy to follow instructions, but they involve lots of use of the Terminal. If you are unfamiliar with a command line, here is a [tutorial](http://linuxcommand.org/learning_the_shell.php) that should help. It is for Linux, but the basics are the same as OS X.
Nope. https://www.virtualbox.org/wiki/Downloads There is an OS X dmg package.
Not sure if this is really an option for you, but if you're on an older machine anyways it might be best to choose a remotely-hosted option that you can ssh into. Linodes are pretty cheap ( 20$ a month ) and can be configured to run rails on passenger / just ruby in a matter of minutes.
The only issue with Homebrew or MacPorts is that I had a hard time getting everything to work right for either piece of software on my old PowerPC mac running 10.5 (can't go to 10.6 on PPC either) but hopefully that isn't the OP's problem.
Thank you! I already had virtual box installed and was downloading an Ubuntu ISO. This tip will no doubt save me lots of time!
&gt; Why develop locally? Simplicity, responsiveness, tools, **speed**..
This. If you're not going to be compiling and developing iOS or Mac OS X apps, there's absolutely no reason you need the latest and greatest XCode. If you have a Mac, you should have the installation disc, and that does have Xcode on it. Install it. Forget about Xcode and GCC, and then continue on. (I honestly have no idea why the installation of a development environment can be so difficult for some people.)
I had the same problem and solved it using the following steps (or you can install a guy rvm manager called jewelry box) - rvm get head rvm install 1.9.3 --with-gcc=clang rvm gemset create myApp rvm use ruby-1.9.3@myApp see http://stackoverflow.com/questions/9938274/ruby-1-9-3-with-rvm-on-mac-lion-installs-but-doesnt-show-up-in-ruby-or-irb/9949290#9949290
If you have (or can find a friend with) the Leopard installation disk (that comes with every Mac) XCode is on there... I'm not sure if older versions of that disk work, but it would be worth a try to ask around.
[Installing Ubuntu inside VirtualBox](http://damiensaunders.com/general/how-to-install-ubuntu-using-virtualbox-on-a-mac-2-712) and [Installing RVM in Ubuntu](http://rubysource.com/installing-ruby-with-rvm-on-ubuntu/).
How in ANY way are the steps to get ruby to run reliably and correctly on OSX for an app almost certainly to be deployed to linux ANY bit more difficult than the steps to get ruby to run reliably and correctly on linux for an app almost certainly to be deployed to linux? vi over ssh..? I don't even.. This guy is having difficulties getting ruby up and running, you're pointing him to vi? I wouldn't use a command line editor locally for primary development. I typed a few other lines out about vi, but then I realized that was really more of my opinion and deleted them out - but I'm still going to put forth that *most* people are going to be more at home and work much faster with a GUI based editor. And no, they aren't clicking through their menus or something. As far as saying EC2 development turnaround is AS FAST as on a local machine, this doesn't even make sense, you're on some 1.7GHz shared EC2 box with no RAM for which you have to navigate a separate OS with all development done through ssh in and you're telling me this is a fast setup? Where you have to upload all your assets by hand every single change? Where you have to have an SFTP drive or SFTP client open to look through files (or spam 'ls ...' over and over)? No, it isn't. This is just ridiculous.. 
It's called git, you don't upload anything, your changes are made on the remote and committed. It is the workflow for virtually every significant open source project in any language from the linux kernel, all the way to ruby and rails themselves. (some folks do use emacs). If you are one of those people that program in an IDE for these languages we should just stop communicating now. The OP didn't say he has never programmed before just that he is new to ruby on the mac. 
Does the CLI tools come with GCC or just LLVM? I ran into this issue a couple of days ago and have yet to find a suitable answer.
Try: bundle install --path ./local/path/somewhere maybe. Not really sure either. Exactly what bundler does under what options can be confusing, I agree. 
I don't know. I'm on almost every ruby/rails list on the planet and I don't think I've ever seen a job ad calling for someone with Ruby scripting - if there's money in that it's very hard to find (at best). The money's in the web - which is why Ruby is popular - it's the lingo for Rails, Sinatra, and a bunch of other web-frameworks.
You're asking the wrong question. Why do you want to write computer programs? What do you want to do with a computer? You've told us what you don't want. Once you've worked that out then find a community that will support those goals. In answer to your second question I've used Ruby for apps programming with MacRuby, I use it for Museum exhibition work, machine interfacing and control, graphics programming as an embedded scripting system, the list is endless. Ruby is a general purpose programming language. I used it before Rails existed and will continue to use it when Rails is done.
I have a ruby script to forward emails to the clickatell email to sms gateway. I had a large website that used ruby-not-rails for the whole backend for a flash based front end, worked great.
I use ruby for systems integration and workflow automation. I glue a bunch of security tools together with it. In other work, I have made a high-speed DNS packet parsing library, a pcap parser, and a SIM integration library. I have made extensive use of external Java libraries via jruby (which can also be done via jython). Beyond that, I find ruby to be a pleasure to code in.
&gt;the language qua language matters less than what free open source libraries/frameworks are available You said it better than I ever could. I should have definitely asked about the community moreso than the language. 
Yep, I know that the money is in web framework development but I'm trying to feel out the rest of the community. Sounds like it is pretty robust. 
so, then, it depends on what you want to do! What do you want to do that isn't a web app? I do web apps, but if you ask about another domain, you can get answers from people who know about how strong the open source ruby community and tools working in that domain are; or if you don't get any answer, maybe that'll be telling. 
It's insanely robust. I spent years in Python only to switch to Ruby even for non-web-related coding. Your mileage may vary, of course.
Popularity is important to the extent that an active community develops libraries, provides documentation, and helps squashing bugs.
Puppet and Chef are popular tools for sysops. https://github.com/puppetlabs/puppet https://github.com/opscode/chef
For my curiosities sake - what features and power do you see in python that you don't see in ruby? AFAIK, Ruby is the more powerful of the two, as a lot of new language features can be implemented in pure ruby instead of having to touch the compiler for python (basing on [Yehuda Katz's post on decorators](http://yehudakatz.com/2009/07/11/python-decorators-in-ruby/)).
Ruby is used for plenty of non-Rails things, including Puppet, a configuration management tool used to manage hundreds of thousands of servers at places like Twitter, Redhat, the NYSE, Nokia, Digg (lulz), Match.com, Los Alamos Labs, Google, NYU, Zynga, and Sun/Oracle (yes, java.com's servers are managed by a Ruby application). The only way anyone could think that Ruby is only used for Rails is if they knew very little about Ruby. Thankfully that seems to be the case, so you are excused. ;) (former Puppet core developer here)
Our web application server is written in 100% Ruby, no Rails used. Only Rack. You can do web stuff without Rails. Actually - I'm happy that I haven't been using rails for the last 6 months.
Issues are currently disabled for the repository, you might want to enable those :)
When I installed Ruby on my Mac with Snow Leopard, I did exactly this. Using the Apple developer site to download Xcode 3.1.3 is extremely easy and once I installed everything the first time, I never had to worry about updating Xcode or downloading anything else -- I never even open that folder on my computer.
oh my god, thanks so much to author! haven't tried it yet, but looking forward to it; hoping it works without passing source flags in 1.9.3, but we'll see, and even if you need source location flags this is a reasonable install process. **edit**: It installed on an out-of-the-box 1.9.3-p0 without the need to manually pass `--with-ruby-include`. Meaning that it can be installed with a listing in a Gemfile and `bundle install` even if it wasn't previously on that system. **you are my hero**. thanks so much. **edit2**: Crap, except `where` doesn't work, crashes the interpreter. Oh well, debugger without `where` is still better than no debugger. 
Whoops. Thanks
Well, it is on the side bar. Although, I can't tell you much more than that, as I really haven't tried it yet.
Don't forget they have separate 'watch' or compile modes. You would need to use compass compile as well as compile the haml when changes are made to either the .haml or .sass/scss files respectively 
jekyll is awesome, but for a blog I want comments. What do people do for comments with a jekyll blog? Disqus? Any other options? (Actually what most people seem to do is just not have them, which I am not a fan of)
I agree Disqus is a great way to go. By using it you don't have to have any home-made spam-filters or authentication mechanisms. 
If you're using rails, you may need to install sass-rails.
Disqus has worked well for me so far, too.
I've never seen a ruby job ad either, but I've been making a good living for the last 6 years from ruby.
I think (but I'm not certain) that you're SOL if you want to run Ruby on an iOS device. However, if you want to look at running Ruby on a mobile device in general, you could start with Ruboto on Android: http://ruboto.org/
This will definitely help those who absolutely need to use `ruby-debug`. Curious to how `ruby-debug` compares to Ruby 1.9's built-in debugger (`require 'debug'`)?
Nice sum up :)
I knew about `set_trace_func`, I've even jumped deep into `ruby-debug` before, it's freaking amazing it exists, because it's a huge mind-f*@k. I never knew 1.9 implemented it's own debugger, was this in 1.8.x? Very interesting, postmodern, you rock.
I remember reading about this new shiny built-in debugger in the release notes of 1.9.1. @tenderlove has also mentioned it on multiple occasions (usually in response to someone complaining about the lack of debuggers for MRI 1.9). I guess the fact that most developers were already using ruby-debug on 1.8 (and later ruby-debug19), combined with the slow adoption of 1.9, the new feature got overlooked.
Here's the hacker news thread on this release (some interesting comments): http://news.ycombinator.com/item?id=3797487
I'm developing a Mobile App for Android with Rails at the moment. I'm plainly using JQuery Mobile for the frontend :). 
Couple of points worth noting. In your example @user.editor? and @user.admin? don't actually return true or false, but return the first associated Membership model for which that role is defined. It's still 'truthy', but not actually what is described. Similarly it seems to me that those roles really should be checked in the context of a group (especially since it's defined on the join table) and not used as a global context. If you've got a busy app and a user is a member of lots of groups, then becomes admin in one group, they suddenly have admin access to all groups. If that's your business rules, that's fine but I've never worked on a site like that. I've always had to build something to check a role for a particular group, e.g.: @user.admin_for?(@group) or work with the join model directly so it's scoped properly. 
agreed. I used to use this for dynamic variables until I was shown the .send method. I dont know if there is ever a real need for eval.
Perhaps through Guard but then again, why? just run the watch commands in two separate terminals/tmux windows/screen sessions, whatever.
Why is: expletive = expletive.upcase better than? expletive.upcase! Seems to be a neat way to coerce results that should always be uppercase.
I thought that such a setup would crash massively.
I kinda like the combination of Disqus and a static blog. I'd like to see something like that in an engine. Load the comments only if you care or scroll to the bottom. 
RhoMobile is Ruby based and is stellar for mobile development. I have several apps out on both Android and iOS and I love how it makes cross platform development sooooo easy. I could even release my apps for Blackberry, if I cared enough. http://www.rhomobile.com/
I guess it's becoming fashionable these days to shun the features of ruby and code like you were using java. Personally I think that's dumb. There is nothing wrong with att_accessable. In fact it creates functions for you that you can redefine at any time. Honestly if you think attr_XXXXX is code smell you should not be using ruby. 
I think you didn't understand what I wrote. I wrote that exposing internal state of objects is wrong. I didn't write that using attr_* methods is a code smell but using them to expose things that should be hidden and relying on those things *is a code smell*.
My reply to joedirt123 also applies to your comment.
&gt;I think you didn't understand what I wrote. I wrote that exposing internal state of objects is wrong. It's not wrong and you proved it by writing a method to expose the internal state of the object. def public_reader? @reader_visibility == :public end This method exposes the internal state of the object. &gt;I didn't write that using attr_* methods is a code smell but using them to expose things that should be hidden and relying on those things is a code smell. I am pointing out that you are wrong. If anything I would call your "solution" a code smell. It's overly and needlessly complicated. Either way you are exposing the internal state of the app but in your example all you are doing is renaming the method. As I pointed out before the attr_xxx methods actually create reader and writer methods for you. In effect all you have done is done is to create an alias for the instance variable. 
Nope, it doesn't. It answers the question "does this attribute instance has a public reader?". The fact that the information about it is stored in an ivar called "reader_visibility" is just an implementation detail.
I have cases where I use attr_reader but set it as a private method. In general I tend to avoid exposing instance variables outside of an object because that leads to pain.
It's all about encapsulating application logic.
Out of curiosity, do you use any form of autotest/guard?
My first thought was that I didn't understand why anyone would decide to make their virtual CPU similar to x86... Thankfullly it isn't *actually* similar to x86, just using similar instruction and register names.
Can you (or someone else) please explain to me what the point of building your own CPU is? What could you be able to do with you in the game? /layman
Nice post. Tell don't ask issues aside, there's a world of different between inquiring truthy/falsy on an instance, and comparing a value to a symbol. This is lost in tons of ruby code. Oh hey, it just changed from a string to a symbol, oh hey, it just changed from a symbol to an object I delegate to... It also becomes quite clear when you have to change say, controller code, because it was written as: if post.reader_visibility == :public when things change
Cool, just wondering, since I haven't been able to get guard successfully working yet!
&gt;After his rewrite, you sent it a message (is this a public reader?) and it gave you an answer. You did not directly read its internal state management mechanisms. When you declare an attribute ruby creates a method for you transparently and every time you access it you are sending a message. All he did was to basically create an alias for that method. He is still exposing the internal state of the object, just doing it with an unnecessary method. &gt;It's not 'java-like' to adhere to single responsibility and specifying public APIs. It's just writing good code. solnic's article was great and it's important the more of the ruby community comes to understand that we aren't free of needing to design good abstractions just because we have a powerful language. Labeling the most powerful features of your language "code smell" and refusing to use that power isn't a wise thing to do. I will repeat myself. In practical terms his solution does not offer any more encapsulation. It's just an alias. He is exposing the exact same state just using a different method name.
I was trying to find how is the latency and uptime with GitHub pages. Any of you have any experience? thanks. 
The generated pages are actually hosted by [Rackspace](http://www.rackspace.com/), so the uptime and latency should be really good. I've been using GitHub Pages for 9 months now and I've never seen my website down or slow. 
I was reminded of [Core Wars](http://en.wikipedia.org/wiki/Core_War), especially how the CPU had 16 opcodes.
Aha! That makes a lot of sense. 
Yes, in fact this library is a thin wrapper around nokogiri SAX parsing. I don't like writing SAX code, though, because I feel it is unclear especially if you couple it to your actual business logic in any way. I wrote this to alleviate the need to write SAX parsing code for a use case I have run into time and again. I am not sure about nokogiri supporting DOM/xpath from streaming files - that's worth looking into. Still, I think the Saxerator api is very easy to use compared DOM/SAX/Xpath - though I fully admit that there are cases where those choices would be superior. It all depends on what you're doing.
Creating gh-pages is already dirt-simple, but reading through your README docs the meat of what Tonic does is a lot cooler than just throw up a gh-pages site. Nice work!
&gt; IIRC it also supports DOM and xpath from streaming files. I can't find that, but with the Reader API, you can call #inner_xml or #outer_xml for any node you're interested in, and selectively then construct a DOM tree from that, if you want small DOM fragments. What you're thinking of sounds like the XMLReader interface. Nokogiri's Reader interface is a simplified version of XMLReader (the main omission is that I don't think Nokogiri's Reader interface support skipping over sub-trees without returning them - I think you'd have to use #outer_xml/#inner_xml to achieve that; that said, I haven't used the Reader interface much). 
A blog post discussing image upload methods in Ruby on Rails. Specifically explaining the advantages of the CarrierWave GEM. The post also demonstrates how to integrate CarrierWave with Cloudinary for uploading images to the cloud, using smart image resizing, cropping, conversion and optimization and delivery through a CDN.
What issues are you having with Guard? I used it as my main means of testing for [Saxerator](https://github.com/soulcutter/saxerator) -- maybe that example will help. I never even set up a rake task for tests because guard was so convenient. I want to mention that no matter how long your tests take to run, Guard is still handy. Even just the second or so it takes to run tests manually with a rake task or whatever is an interruption, and it takes one more thing out of your mental stack so you can focus on just developing. I highly recommend it.
While your response makes perfect sense theoretically, I'm not entirely sure how to implement it. Do you mean write the proxy server as it's own .rb file, require it, instantiate it and pass it the information/signals via methods? Or do you mean that they should be entirely separate animals that pass information/signals via TCP connections?
Rails posts belong in /r/rails.
It's all Ruby, why use processes? I'd just launch a `Thread`. Something like... def start @proxy = Thread.new do # proxy code here end end def stop return unless @proxy @proxy.kill @proxy = nil end post '/start' do start end post '/stop' do stop end post '/set_port/:port' do |port| @port = port stop start end This would only shut down accepting new connections; if you want to break the existing connections, you would have to keep track of the connection threads as well and shut them down. But basically, this is the basic concept. (putting "proxy code", start and stop in its own class would be better, but it's 5am :p )
It doesn't include my lib directory so the requires in my test files break, and I haven't been able to figure out if there's a setting or something that I'm missing. So I've been using autotest instead.
Sweet, this makes perfect sense. I think I just needed to see an example. Thanks a lot!
I will think more on a REST API. I thought something like that.
This part of my project I can open-source, the other side of it I will not be able to (proprietary). I'll let you know when I get it done and ready.
Thanks! That's what I started doing a little bit ago.
Hi, sorry for my English but thanks for the reply. &gt; the unique problem seems that Coffeescript and sCSS are not supported in assets pipeline. I may be wrong but the examples I've looked didn't use that technologies. &gt; .. about layout MyEngine::Engine.config.layout_name I'm not sure it does the same thing because I don't want to use excusively main_app or engine1 layout but I want to "merge" them automatically when a specific engine is requested. 
Why do you want the proxy server to do this work, rather than the server itself gathering the information it needs to return the required response?
Hmm, that's an interesting explanation to say the least. One of the primary purposes of this application is as a repeater to take a single HL7 datastream in and repeat it out to a destination after re-writing the header of the stream. The other purpose is to HTTP post a subset of the datastream to a Rails application for use elsewhere. Since the primary and secondary purposes are independent of each other (and the primary purpose needs to run all of the time while the Rails app does not) I decided to split it into two "projects" that are related and yet separate.
Something is wrong with your load path I reckon. Not guard's fault perse, but I didn't do anything special to get mine working, so that is a bit curious.
Writing a CISC would be crazy :\
&gt;The problem wasn't that the code was using attr_reader which the blog spends too much time harping on. From where I stand that was the entire point of the blog article. That using attr_ is code smell. &gt;The problem is simply that other objects need to know things they shouldn't like how @attribute.reader_visibility returns a symbol like :public. That's code smell too. The proper thing to do is to make them enums/constants. class Foo module VISIBILITY PUBLIC = 0 PRIVATE = 1 end end f = Foo.new if f.reader_visibility == Foo::VISIBILITY::PUBLIC 
I agree with your conclusion.
I'm by no mean a ruby expert but if you do something like this: https://gist.github.com/2349284 you get the self documentation of the first approach and the flexibility of the second 
Do what the standard library does. 
Your example actually won't work as the "bar" method on the Foo class is declared as an instance method, not a class method. You'd be looking for the following instead: class Foo # note the "self." prefix def self.bar(options = {}) # ... end end
That solution would be ok if the method you're delegating to accepts a hash of options, but I was talking about a general case when you want to delegate to a method with some random signature (e.g., just of two arguments) that you're clearly not going to change.
Ideal, (or so i have been lead to believe), when writing methods its better to pass through the variables as hash even if they won't change. Its generally meant to stop your code have calls like foo(1,"hi") that are far less descriptive than foo({:count =&gt; 1, :welcome_text =&gt; 'hi'}) Like i said, not an expert just something i have been told 
I find this to be rather pricy for what you get, but maybe that is just me. $160 a month for 200gb bandwidth is rather steep, even when compared to what for example Rackspace charges for their Cloud Files. Most of their extra features are really simple to implement yourself. Carrierwave with Minimagick for image transformations using Compass(or something else) for spriting backed up by Amazon S3 or Rackspace Cloud Files. I don't know, it just seems like a lot of money
I generally agree with you -- but I am curious as to why you would not just use forwardable/rails' bastardized version of it. I know you mention wanting to avoid it, but they're so nice...
Test behavior, not implementation. If you care about the method signature of your method, then set it to what you expect. If you're just passing arguments because, who knows, then you are programming an interface that says "I don't know what this should do and have no strong opinion." You should build and test the interface that you use. If the implementation changes you should not have to change the interface. Don't test the delegated method, test your method.
I knew about `Module#delegate` from Rails, but the project I'm working on is an independent library so I can't use this method without introducing a new dependency (the thing I don't want). `SimpleDelegator` from standard library doesn't suit for the case as delegation is not a primary responsibility of the class, I need to delegate only a single method for the shortcut purposes. Finally, I learned about `Forwardable` module (and `SingleForwardable` that works better for the case) and used it for delegating and aliasing. The question itself was asked more out of curiosity because I wasn't sure about the right solution for a handmade delegating method. All these `delegate` methods that generates delegating methods are working with `(*args, &amp;block)` at least because they're dealing with a general case and I thought maybe for a specific situation (when you have a concrete method with a known signature) it might be not the best way to go. And then came question about testing this thing in both cases. All the comments ensured me that if the main role of the method is delegating (but not wrapping another method with some logic and ending up with the same signature just by coincidence) it's more reasonable to go with a generic arguments list and test only that delegation is really happening, but not test behavior again (in my case method I'm delegating to is under my control and is already tested).
Eh, it works, if you have a willing client representative or a "functional" dev on your team. Except that never really happens in wild.
Dude, I'm basically you. That question could have been written by me down to the age of the MBP and I can honestly tell you that I've gone through 2 ASUS, 1 Acer, 1 Toshiba and a single, majestic Lenovo Thinkpad Edge E320 (had the privilege of trying out various brands at work) that runs Ubuntu as if Mark Shuttleworth designed it himself. It's a tad pricey but I'm sure you can find cheaper offerings from Lenovo that are [Ubuntu Certified](http://www.ubuntu.com/certification/make/Lenovo) and run just as beautifully. EDIT/sidenote: all but the Toshiba actually performed fairly well but none nearly as well as the Lenovo.
I bought an ASUS off Amazon during a promo almost two years ago, been running Ubuntu on it since I got it (http://www.amazon.com/gp/product/B003V4AK4I). It has had ups and downs (I had issues with sleep for awhile, the track pad thought it was a mouse) but overall it runs great now - various updates and such have fixed all my problems. I use it for daily rails development and have used it for android dev as well. My biggest gripe is that I get around 2 hours of battery life in Ubuntu but I usually keep it plugged in so that's not really an issue.
I'm not a big Apple user, so I find Mac trackpads just as odd. Actually, all trackpads have odd responsiveness, since they're trying to imitate the movements of a mouse. If I'm going to be using a laptop for extended periods of time, I will just plugin a mouse. For those who swear by MBP trackpads, I wonder if it's possible to buy them from the OEM and install them?
Also, IBM :)
I'm of the opinion lately that there isn't much reason to run on MRI other than startup time and startup times. Performance is killer. 
Clever girl
Definitely a MacBook Pro if battery life is important for you. Thinkpads are also very good and most of my friends use one (I have a macbook though), however I don't believe that one can work like 10 hours on the battery as most of linux distros are not optimised enough. I also wanted to buy a laptop for linux a year ago, but lack of good support for ie. nvidia optimus scared me away. Now I'm going to buy a new macbook pro, because I got used to the platform and everything works fine. Anyway, laptop is just a tool, so go and get anything that works for you.
Checkout [VisualRuby](http://visualruby.net/), which allows you to build your UI using Glade and GTK2. Can also package/publish a RubyGem containing your Glade UI.
Can't wait for part 2!
Checkout [VisualRuby](http://visualruby.net/), which allows you to build your UI graphically. It uses Glade and GTK2, and can be packaged into a RubyGem.
Thank goodness for google cache.
I documented my experience with an Acer TimelineX [here](http://blogs.law.harvard.edu/djcp/2011/11/kubuntu-11-10-on-the-acer-aspire-timelinex-4830tg-6450/). It was really easy to get working, everything works well and it gets 7 to 8 hours on the battery for &lt; $700. Yeah, it's not hands off, but it was pretty easy. Love it.
Awesome link! I can't stand buying a notebook with a Windows license only to blow it away and install Linux of some kind as the first thing I do with it. **Edit:** having actually looked at it, the screen sucks: &gt;15.6" 720p High Definition LED Backlit Display ( 1366 x 768 ) I got a 1440x900 screen by default on my 4+ year old 15 inch laptop - downgrading the screen is a serious deal breaker unfortunately :(.
thanks for this. it makes me feel good to see other people who share this opinion. 
What's the point?
Agreed. I used to think method missing was cool as hell but I've run into so many gotchas, I prefer that people not use it anymore. But I guess this is just a bit of fun code, so.. no biggie.
Im my experience, the better the brand the better the Linux support. I had an old Dell that had very few issues, other than being an old slow turd. Like postmodern said, ThinkPads are pretty good too.
That's not what English sentences look like. 
Thanks a lot. 
The System76 laptop choices are bad right now because they're just about to refresh - probably just about when Ubuntu 12.04 hits. It might be worth waiting a couple weeks.
Interesting idea. I found [this page on Wikipedia](http://en.wikipedia.org/wiki/Windows_refund#License_refund_policy) - seems relatively old info, but I think I will try calling up manufacturers locally to see if they will do it. Seems unlikely, but at least asking the question should stir stuff up (maybe only a tiny fraction though)... The thing is, I don't really care about the amount of the refund, as long as I get something, and post them back the COA sticker or something.
I also have the x120e and Arch ran great as well - no problems whatsoever! Everything works out of the box - just have to setup laptop tools, etc. Only switched back to windows for Dota 2.
How long until the video of your talk might be available publicly?
Thanks! I'm hoping that at some point in the future, it'll be just as easy to get started with Ruby as it is with PHP today. We're almost there. Almost. :)
i've got acer aspire 7750g and a sony vaio vpcf23s2e and i am running ubuntu 11.10 on both. i am totally happy with those. if youy can afford, a lenovo thinkpad as postmodern said would be great.
Why does a company think it's a God idea to have half a dozen lines with multiple options in each line? who is going to do hours of research just to figure out which Lenovo is right for them? 
Sure shows how dynamic Ruby can be (with ease).
Why would you say that? This is the proper way with ENUMs. That's the way APIs have been written since way back when. Unfortunately ruby doesn't have ENUMS so this is the next best way. The benefits of this are numerous especially over returning arbitrary symbols or writing dozens of is_something? methods. As a bonus if you have a decent IDE you get code completion. 
Great posts. Keep up the good work! Really looking forward to part 2 of this [TUTORIAL: DEVELOPING HTML5 CANVAS GAMES FOR FACEBOOK WITH JAVASCRIPT â€“ PART 1](http://manuel.kiessling.net/2012/04/02/tutorial-developing-html5-canvas-games-for-facebook-with-javascript-part-1/) Going a bit off topic - recently I was trying to build a GUI for a Ruby desktop app and found there are no recent/good newbie tutorials. Would you perhaps consider writing a beginners series for Ruby GUIs? ;)
How is this related to ruby? 
Buy a mac with minimum memory and harddrive, and replace them later yourself.
[minitest](https://github.com/seattlerb/minitest#readme)
Why use a regex at all? Why not just iterate through the characters and look them up in your hash? Also I think it's more idiomatic to use has_key? for the if statement in your gsub block.
I was thinking on what you said and I've benchmarked it, my solution is faster than iterating every character of the string, also, I can't make the iterating work because my special chars are represented by two bytes, so neither .each nor .each_byte catches the whole char; maybe you can post your solution so I understand the best way to do this
It's possible, but its a huge pain in the ass to find the link for it. You want to search for FreeDOS lenovo and then follow the chain of links. 
From my experience IBMers still favour ThinkPads, even though they are no longer part of the IBM family of products.
Obviously, a company who has many business-type customers. They like lots of options, gives the illusion of control/power. :)
I've always wondered if you could buy MBP trackpads OEM, and install them into stock laptops.
Now if they would just stop packaging their own customized (broken) rubygems. &amp;#3232;\_&amp;#3232;
**Warning:** Misleading Title. Ubuntu isn't creating these packages, BrightBox is. I never understand why Ubuntu packaged [1.9.1](http://packages.ubuntu.com/lucid/ruby1.9.1-full), but never upgraded to 1.9.2 or 1.9.3. I wish they'd hurry up and upgrade, 1.9.1 did have some constant scoping bugs.
the frustrating thing that is _ruby's_ fault is why those patches they are including in their version of mri 1.9.3 haven't made it into mri 1.9.x mainstream release yet (i think most of em haven't even been accepted to ruby trunk). They're things that lots of people want, and that seem to be as stable and mature as most anything else in ruby -- thus ubuntu's decision to patch them in. So why aren't they in ruby yet, even though they've all been circulating and being custom-applied by those in the know for quite a while?
in ruby 1.9, if the string is properly set as UTF-8 (I think you're dealing with UTF8 here?), .each should catch the whole char, regardless of how many bytes it takes to represent the char in UTF-8. In general, you'll probably find it profitable to research how ruby 1.9 deals with char encodings. It may or may not suggest a different approach than you are taking, but it will save you trouble down the line. Some research on unicode will probably also be helpful. Did you know that "Ã¡" actually has _more than one_ valid representation in UTF-8 (or any other unicode encoding?). See "composed" vs "decomposed". I don't _think_ ruby 1.9 will take care of that for you automatically; you'll want to make sure to convert to a unicode normalized form first, and then sub on the normalized form. char encoding issues are one of the most confusing things anyone ever has to deal with; if someone doesn't think they're complicated to deal with, they just haven't yet run into the edge cases that make them realize their simple approach is broken. 
In Ruby 1.9 you can use String#chars to get an Enumerator of chars (you can use an Enumerator as an array and call .map on it). In terms of asymptotic complexity both solutions are equivalent but the regex is probably faster just because it uses C... it also depends on the frequency of special characters to replace. Looking back at your original question, have you looked into the "u" or Unicode option for regex? If you are using 1.8 it might help you out.
I should have mentioned, but I was running jruby 1.6.6 for work, can't choose to use ruby 1.9 unfortunatly I've been dealing with encoding problems since I work, as I live in a country that basically uses latin1 by default, but I didn't know "Ã¡" has more than one valid representation actually. I gave irb (jirb) a few tries on my solution before concluding it was possible, after banging my head against the table about the "pipes in brackets" thing it works like a charm I'm just wondering if the solution sugested by kewldude606 is really better
12.04 has 1.9.3 available: $ apt-cache search ruby1.9.3 ruby1.9.3 - Interpreter of object-oriented scripting language Ruby, version 1.9.3 
Nice! It's been a while since I've setup a Ubuntu system. If Ubuntu already has a modern ruby 1.9 package, does t hat make this post a non-story?
Well, 12.04 is still in beta, and this PPA is available to people using something older. 
here's a blog post on dealing with UTF-8 data in ruby 1.8. It seemed to have some good tips that I hadn't previously known about, and I think you aren't either from your code. Like /u on a regex, and pack/unpack for unicode codepoints, working even in ruby 1.8. Assuming your data is UTF-8, which I think it is? http://blog.grayproductions.net/articles/bytes_and_characters_in_ruby_18
right, I don't even see why this is all that important, as I thought anyone doing serious ruby work on ubuntu was already using rvm. Is there any reason to use the apt-get version of ruby over managing it with rvm? When I first started using ubuntu I was really enamored with apt-get, but I've since learned to at least check the projects pages advice on installing rather than rushing to 'apt-get install..'
John you asked for karma whoring on your google page for this post so here I am. Your student government attempts are bad, your karma whoring is bad, and you're just bad. Fuck off.
I haven't checked in ages since I compile my own Ruby to avoid that foolishness. I don't like apt in my Ruby OR my RubyGems. The Ubuntu community docs [quoted me on the subject](https://help.ubuntu.com/community/RubyOnRails), so they must agree :)
mmh sounds like reinvent the wheel ... [narray](http://narray.rubyforge.org/)
Unbelievably wrong. He could change the internal implementation of is_public_reader? to add more checks. This should be transparent to a user of the class. I rarely let myself get drawn into internet arguments because they seem fruitless, but I seriously cannot fathom you being a programmer and misunderstanding this point.
Pretty much this. I don't see any reason to use the packages for Ruby when you have the convenience of installing multiple Ruby versions and gemsets with RVM.
That's just rude. I don't particularly care about karma, because I don't reddit very often. I only asked for upvotes because most people aren't aware of the project, and I think it's something that could benefit a lot of Ruby/science people. My roommate tells me it's not good form to ask for upvotes, so I've removed the note from my gchat. Still, this was kind of uncalled for.
RubyGems hasn't been broken since 10.10, ie: gem update --system works fine in 11.04 &amp; 11.10
1.9.1 refers to the compatibility version. In Ubuntu 11.x that means 1.9.2 (and 1.9.3 in 12.04)
So to get ruby 1.9.2 via ubuntu packages, one must be on ubuntu 11.X **and** know that the package is labelled 1.9.1? This is why I changed my opinion on the suitability of using rvm on the server for using 1.9.X+ rubies.
I did some benchmark, using, the benchmark lib's bmbm method, doing the action 50000, my regex solution not only performs better, it performs way way way better: Rehearsal --------------------------------------------- regex 0.070000 0.000000 0.070000 ( 0.016000) iteration 10.559000 0.000000 10.559000 ( 10.559000) ----------------------------------- total: 10.629000sec user system total real regex 0.000000 0.000000 0.000000 ( 0.000000) iteration 10.596000 0.000000 10.596000 ( 10.596000) 
For my development machines, RVM ftw, but I really prefer native packages for production. 
yeah, I saw you said that, I would definitely not have predicted that, interesting, very curious why that is that way now! 
&gt;Hipsterism? Seriously? Yes. &gt;First of all I don't say using attr* methods is a code smell, I say that relying on internal state of objects is a code smell and it can be somewhat detected by looking for usage of attr* which may or may not indicate that your code rely on internals of objects. Well you are wrong. You have to rely on internal state of objects. That's what object oriented programming is all about. In your example you were relying on the internal state of the object. You just chose to give it another name. You wrote an unnecessary wrapper around the state. First of all your first mistake was to represent states as symbols. That's dumb because there are an infinite possible symbols. You of course know that so you decided to compound the problem by writing a method for every "allowed" state. Now your code is going to be like this def is_public? ... end def is_hidden? ... end def is_started? .. end def is_finished? ... end You are still exposing the internal state of the object but in order to avoid "code smell" you keep writing functions. If I saw a programmer do that I would fire them. &gt; This is a code smell and in fact it's a very well known code smell in other languages. First of all what may be code smell in one language may not be in another. Different languages have different features and different idioms. I would contend that you refusing to use features of ruby and instead writing getters and setters for everything stinks up your ruby code. It's not idiomatic, it's not beautiful, it's not pleasant smelling. Secondly in other dynamic languages using properties is not code smell and is perfectly acceptable. That's the agility promise of dynamic languages. You declare properties (or attributes) and later on if you need to do additional processing you write a function with the same name and adapt your code without breaking signatures. Thirdly in other languages people use enums. &gt; If you expose internal ivars to other objects people may rely on values that should be hidden. That's why you create a module and put the enum in place. &gt;If you want to use enums, like you suggested in other comment, then it's gonna be a bit better but it only makes sense if an enum value can be shared across the system and is a constant thing The alternative is to write a getter and setter for every possible state. Welcome to java. Thanks for making my original point. You want to avoid using a feature of ruby and code like you were writing java. 
I don't like that *class &lt;&lt; self* notation. It's not a very good way to express its behavior (granted neither is *self.* for that matter) and it's easy to miss. I haven't seen it very often in the last two years Also I'm not sure that I would call a dynamically modified object a singleton. Not because it's wrong, per se, but it might create confusion with traditional singletons This nitpicks aside, Russ Olsen's books are awesome
Great post! I'm a PHP developer and I've learned Ruby but everytime I read a Rails tutorial I get lost. So maybe Sinatra is better option for me. There's too much magic happening in Rails I can't keep up. You kept it simple here though and I'm looking forward to the next post. 
&gt; Iâ€™ll admit I was both intimidated by, and skeptical of, design patterns before researching them, trying to differentiate them, and writing them in Ruby. &gt; It turns out theyâ€™re not that complicated to understand and often feel clean to use. &gt; In practice, Iâ€™m finding them helpful in general Ruby code. In Rails, Iâ€™m still evaluating the benefits and drawbacks of presenters in particular versus app/helpers. I agree, but I wouldn't say it that way -- a design pattern is _nothing but_ an architectural suggestion, that's been abstracted by people with lots of experience writing code to solve a particular problem, who realize "hey, here's a common sort of architectural problem and what we've found to be a nice clean way to solve this problem." You can be using a 'design pattern' even if you don't know the name or even if nobody's given it a name. Giving it a name just makes it easier to realize "oh yeah, here's that nice way to do this architecture I've used before," instead of having to re-invent it from scratch yourself each time. * Some things advertised as design patterns suck. Don't use them. * Some design patterns don't fit your actual context (or conflict with your framework that wants to do things differently); don't use them there. * If it _doesn't_ feel clean to use a certain pattern, either you're doing it wrong, the pattern sucks, or the pattern is not applicable to your case. The whole _point_ is clean code. * You don't decide to "use design patterns" or "not". It doesn't get you out of having to think about the correct (simplest that will give you the needed level of flexibility) architectural/design solutions. * It's not a contest to see how many named design patterns you can use at once. * They're just some helpful suggestions of ways people who have come before have figured out to solve common design problems in OO software, nothing more, nothing less. * Don't take Java as a best practice for design pattern use. :)
This is a good tip, I had been using &amp;block in a number of places and had no idea.
I was joking about the name. Isengard is name of Sauroman's tower fortress in Lord Of The Rings. The name is actually "eigenclass." Googling that should give you what you need. Here's a decent explanation: http://blog.madebydna.com/all/code/2011/06/24/eigenclasses-demystified.html 
Heh, not up on my Rings. I do know what the Eigenclass is but that's not what we're after here... 
useful stuff!
I did not! thanks! Looking at it now... using it for very simple stuff seems like a lot more lines of code and thinking compared to split(regex). But maybe just haven't wrapped my head around it. Always more in the stdlib to discover. 
contributing to open source will get you more respect in the ruby community then this certification.. also.. $150 is a non-trivial amount of money...
Here's an example using StringScanner: require 'strscan' s = StringScanner.new(%q{word word 4+5+6 "a phrase"}) until s.empty? s.skip(/\s+/) case when word = s.scan(/\w+/) p [:ident, word] when int = s.scan(/\d+/) p [:int, int] when sym = s.scan(/\+/) p [:sym, sym] when str = s.scan(/"[^"]+"/) p [:str, str] end end I also recently used StringScanner as a general parser: https://github.com/judofyr/rcpu/blob/master/lib/rcpu/asm.rb
yeah, you know what, StringScanner is pretty sweet. Thanks for letting me know about it, y'all. 
Not worth the $150. Work-history and your github profile are more important to employers hiring Rubyists.
I've yet to see a correlation between certification and performance as a programmer. I also see no correlation between performance on a programming interview test and certification. This is based mostly on Java hires. Oddly enough, I've seen people with Java certs who are unable to complete a programming test in Java but are able to complete the test when I allow them to use python or ruby. 
LOL No.
We went evented because we need the I/O concurrency and because it stresses the CPU scheduler less, not because evented is "fashionable". Phusion Passenger has never exposed its multithreaded internals externally. There will be no visible changes as far as the Rack apps themselves are concerned.
Yeah, it totally makes sense. Didn't mean to imply otherwise with the fashionable comment. Lots of projects are going evented with great results.
awesome, thanks; this sounds great. Thanks for clarifying that there's no change revealed to the rack apps themselves -- I was worried there might be. Although, actually.... is it possible this could lead to optional positive changes for the rack apps themselves? Right now, my understanding is, even if a Rails app is `config.threadsafe!`, ~~rack~~ **phusion passenger** _still_ won't be able to send overlapping concurrent requests to a single instance, it will end up synchornizing the requests anyway. A rails app with `config.threadsafe` is _able_ to receive multiple overlapping concurrent requests (in seperate threads). Would the change to passenger pave the way to allowing passenger to give the rails app instance requests like this?
I have no idea what you mean. Rack only specifies how your application object is supposed to look like (e.g. it must respond to #call, and it must accept an 'env' parameter that looks like this and this). It's up to the application server implementation to decide how to use that object so to me the statement "rack still won't be able to send overlapping concurrent requests to a single instance" doesn't mean anything. Perhaps you mean "*Phusion Passenger* still won't send overlapping concurrent requests to a single instance", meaning that Phusion Passenger won't call #call on the same Rack object from multiple threads. This is true. We didn't and still don't do that, at least right now. Multithreading support at the application level is not yet supported, but we now have the proper infrastructure in place to make it possible in the future.
&gt; we also feel that we havenâ€™t properly communicated our development progress to the public, which could possibly have resulted in the perception that development was slow. I will admit that I had begun to worry about this, wondering if passenger was still being seriously developed. **So** happy to learn my misperception was merely a result of lack of communication. The 3.2 improvements sound great, they're exactly the right things that were needed to improve passenger. Passenger is incredibly solid software, which seriously improves ease of ruby webapp deployment by it's existence as freely available software, phusion are heroes to me. (One that phusion only mentions in passing, instead of highlighting on their 'what will be new' page, but that people who need it are going to love: "3.2 also supports multiple Ruby versions at the same time, something which many people have been waiting for." But each of the first two they DO highlight: better ApplicationPool, evented internal I/O model -- are awesome and welcome for their consequent performance improvements )
awesome, thanks so much for answering my questions, and being available on reddit. Makes it much easier to be confident in passenger's future for my particular application's requirements. 
I knew because [a very old version of rails]( http://apidock.com/rails/v1.1.0/ActionView/Helpers/TextHelper/truncate) used split(//) to split unicode chars (like Japanese). Before they added ActiveSupport::Multibyte::Chars and support ruby-1.9.
Is the ruby gems update will it ever be fixed? I never understood why I have to use apt get to update, and that is always 2 years old :(
I'm wondering, would it be possible to force functional principles with some clever meta-programming? 
Local variables are kind of outside the reach of meta-programming. You really need to modify the ruby source code itself (although not by much) to get this kind of behavior. At one point I was seriously contemplating doing just that, but began to realize it might not be worth it unless their was a community effort behind it.
The more I learn about languages like Haskell, the more I start wishing Ruby enforced some of this, but at least in the meantime we can start considering non-functional-programming a code smell?
Yea, i thought that would be a problem. Maybe a (somewhat dirty) solution would be to have the 'functional' gem interpret the code as a giant string, replace all variable assignments with constant assignments, then eval the string.
While this is a pretty neat intro to FP for people who've had no previous exposure, the way it's worded "No:" "Yes:" is a bit misleading. Please don't write code like this: module Enumerable def mash(&amp;block) self.inject({}) do |output, item| key, value = block_given? yield(item) :item output.merge(key =&gt; value) end end end First: WAT Second: Do you see output.merge? It's making a new hash object for each iteration of the loop, and throwing it away. Functional? Yes. Wasteful? Also yes. Let's compare: ["ride", "the", "dragon"].mash { |s| [s, s.length] } to output = {} ["ride", "the", "dragon"].each { |s| output[s] = s.length } The functional version is more complicated and confusing and creates objects (one array and one hash) for each iteration of the loop. tl;dr: learning FP, good! Using this code in real-world Ruby programs, bad!
You should use a functional style if it makes your code clearer. You shouldn't just use it for the sake of using it. Ruby isn't a functional language, and often the imperative versions of things which use mutation are simpler, faster, and use less memory.
[Ruby 2 has lazy enumerators](http://blog.railsware.com/2012/03/13/ruby-2-0-enumerablelazy/), so you can now do things like `Prime.each.lazy.map{|prime| prime ** 3}.take_while{|prime| prime &lt; 100}`.
You need to be a bit more specific. As you can see from the OSI model, networking is a huge topic. 
If only we had a House Un-Rubyist Committee to root out the cancers. 
Nah, I don't think you want to use Ruby to evaluate Ruby code. I haven't checked it in a while, but the Rubinius guys just never got the performance they expected with a 100% Ruby back-end. Some of their code is in C/C++ and will probably remain that way for some time. I don't think that's necessarily bad, but it's unfortunate that Rubinius has to become a complete separate project instead of a competing Ruby branch.. I think for Ruby to advance as a language it needs to go back to it's Lisp roots. It _is_ possible to be fast and give developers a hook into the AST.. if anything, playing around with the AST in Ruby would make it easier to do certain types of performance tweaks that are just cumbersome in C/C++.
I believe the issues outlined can be applied to any larger community in general. But yes, good to keep in mind and try not to get sucked into. Slightly OT: "Or how the Spanish social security system, which they defended, was founded by a pseudo-fascist dictator named Franco." Was this to confuse them or was this a real argument? I just don't see how it could be one. 
Just a suggestion - how about actually making opcodes readable? (e.g. not 'prn' but 'print') It made sense to use three letter abbreviations several decades ago, but today it's just pointless. Just because everyone else is blindly following a braindead tradition doesn't mean it's a good thing.
Why certainly. Ruby provides a very nice Socket API. [TCPSocket](http://rubydoc.info/stdlib/socket/1.9.2/TCPSocket), [TCPServer](http://rubydoc.info/stdlib/socket/1.9.2/TCPServer), [GServer](http://rubydoc.info/stdlib/gserver/1.9.2/GServer), [UDPSocket](http://rubydoc.info/stdlib/socket/1.9.2/UDPSocket) are good places to start tinkering. Ruby also supports many higher level protocols out of the box ([Net::](http://rubydoc.info/stdlib/net)), with additional `net-*` libraries on [rubygems.org](http://rubygems.org/search?utf8=%E2%9C%93&amp;query=net-). If you need direct access to raw packets, checkout [packetfu](https://github.com/todb/packetfu#readme) or [dnet-ffi](https://github.com/emonti/dnet-ffi). (I'm also trying to finally release [ffi-libnet](https://github.com/sophsec/ffi-libnet#readme)). For a real world example, I recently wrote simple [TCP](https://github.com/ronin-ruby/ronin-support/blob/network_proxy/lib/ronin/network/tcp/proxy.rb) / [UDP](https://github.com/ronin-ruby/ronin-support/blob/network_proxy/lib/ronin/network/udp/udp.rb) proxies (will be available in [ronin-support](http://rubygems.org/gems/ronin-support) 0.5.0), only using Ruby's Socket API.
Book is really extremely actual even having in mind year of publishing. Fibers, new syntax - everything included. It's probably best Ruby book on the market.
There's a lot of us out there without a faction. Sometimes our work struggles for visibility because we don't have a faction to promote it
http://www.networkdictionary.com/networking/am.php 
Shouldn't implementation details ideally not be a factor when designing code? Is the memory consumption problem more of a garbage collection problem that doesn't necessarily have to become a ruby programmer problem?
I thought it was gonna list sensationalist title as one of the three cancers. 
&gt;Book is really extremely actual even having in mind year of publishing ??? Has anyone really been far even as decided to use even go want to do look more like?
You described some general theories on human nature and took examples from of a subset of humans: the ruby community. I'm not sure this belongs to r/ruby.
I would mercilessly mock any of my coworkers if I found they had written code like this. I appreciate the goal, but this totally violates the [Principal of Least Astonishment](http://en.wikipedia.org/wiki/Ruby_\(programming_language\)#Philosophy). As a favor to whomever is going to be debugging your code in the future - please don't override core parts of the language.
No, that's rather a thing of blogs, not Ruby ;)
I focused on Ruby because it's the community that I want (and work every day) to get rid of these cancers.
if you're already a developer I'd advise against it. 
It's all based off BSD sockets and a lot of C tutorials translate well to ruby if you've any experience with C Additionally it can scale well too using event-machine (em-http too), 1.9 threading (only recommended for slow clients), JRuby threading for native threads. It also supports non-blocking BSD sockets and Select/EPoll (with a gem) if you want to write your own highly scalable stuff or just research how it is done, remember someone else has probably solved your problem already!
To back up your point, here's an example of opening [SCTP Sockets using Ruby's Socket class and Socket/Protocol constants](http://yob.id.au/2007/01/31/sctp-in-ruby.html).
[False friend](http://en.wikipedia.org/wiki/False_friend). In Latin-based languages "actual" means "relevant today".
I'm more than happy to leave cucumber dying on the side of the road. This sort of overly verbose and tedious testing is a form of procrastination that convinces programmers they are being effective. 
The target are members of the Ruby community, so it belongs to /r/ruby.
I've found this is the best approach too. The overhead of putting each unit test into a cuke scenario is too much, but it covers the high levels well. 
Don't you think you are contributing to the toxicity of the Ruby community? I think you are. 
I don't know, man...you might have to study for a bit. Ya know, brush up. ;-)
ha ha. it does have that. I left that discussion out of it but maybe that was a bad thing. 
I think you've confused things a bit there. There's basically nobody working on Ruby packaging for Ubuntu as far as I know. There's a Debian packaging team working on Ruby, and Ubuntu uses their packages. The Debian Ruby maintainer is the guy who argued for a while then stomped off; however, he [came back and decided to work with the Ruby community after all](http://www.lucas-nussbaum.net/blog/?p=708), for which he deserves kudos. Right now things are in a bit of a transitional state. However, there will eventually be up-to-date Ruby packages for Debian, and hence Ubuntu, and 1.9.3 will be the default.
If you like the MacBook Air, look at the [Asus Zenbook](http://zenbook.asus.com/). And as a Mac user of 20+ years, I'm looking at moving to Linux at this point because it's becoming increasingly painful to get a working Ruby + RubyGems development environment going, because of [Apple's purging of GPL software from OS X](http://meta.ath0.com/2012/02/05/apples-great-gpl-purge/). You basically have to use something like MacPorts and install half a Linux distribution in /opt, or else you end up battling [32/64bit compatibility problems](http://forums.pragprog.com/forums/148/topics/4362), old versions of libraries that break RubyGems and require [library path hacks](http://www.marvinmarcelo.com/rvm-libz-1-2-5-dylib-and-zlib-on-mac/), and so on.
If you're interested in becoming a ruby developer, I'd recommend that at the same time you pick up a book on rpsec as well. You need to know testing as much as you need to know the language. Plus you can learn the language by writing tests to see if your understanding of how code works is correct.
If you want to be taken seriously by ruby developers, forget about this and go find an open source project to contribute to. There's got to be one somewhere you can contribute something to. Start by picking a simple one, clone the repository and start reading the test code. Then add a test on your own and offer a pull request to the original project authors. Then you're on your way. You'll meet some people along the way who'll have no patience for you and will treat you like you know nothing -- forget them. It happens to everyone and don't let it slow you down. 
 require 'shellwords' Shellwords.split(string)
Haha sorry tenderlove. All your commits mean nothing without this certificate of achievement. ;)
super has downsides (just like everything) but it is *idiomatic*. Whatever your code may be, it is not idiomatic. Nor does it "preserve idioms in Ruby subclassing". The idiom in Ruby subclassing *is* super. Your code completely wrecks subclassing idioms by introducing some newfangled out-of-box semantics that only serve to surprise and annoy the programmer who has to come behind you and wonder why super doesn't work any more. 
i dont get it
Sure it does, but this article doesn't. If I were to describe some critical thinking and gave **examples** in Ruby, would you say this belonged to r/ruby? I wouldn't, personally.
T-shirt, but no pants. Today is PANTS OFF DANCE OFF day.
heh, right on
Which one would you recommend for a beginner?
By pulled, they mean added to the default `Gemfile`.
The goggles, they do NOTHING!
It looks like one of two things is happening: * You're trying to call `rails s` in a directory that doesn't contain a Rails application; or * You're in a Rails app directory, but script/rails isn't being called. In the first case, generate a new Rails app as suggested: `rails new app_name` In the second case, or if generating an application still didn't work, try this: `script/rails s` If neither of these suggestions work, then I'm out of ideas. I don't use Windows anymore and I never used it for Rails development.
You have to have a rails app to start one. Rails is a framework for writing web apps. You can't "start rails". You can create a new bare bones rails app with `rails new whatever`. Then you can `cd` (or whatever the Windows CMD equivalent is) in there, and `rails s` to start it. It won't do much though, except give you a pretty static welcome screen. You've got to write your app. Rails is not drupal. I recommend the official rails guides. http://guides.rubyonrails.org/getting_started.html
I am using rails 3.2 installed from here - http://ruby.railstutorial.org/ruby-on-rails-tutorial-book?version=3.2#sec:rails_installer_windows
I was gonna say it's not an ORM cause there's no R, but I guess R can stand for REST. 
Thanks for the comment. I am typing rails new app_name for some reason I don't think it's creating the file but I'm not sure why. The server problem is most likely because this computer isn't recognizing the command to create the new app. If that makes any sense at all..?
http://imgur.com/aQcB3 also it says: "c:\Sites&gt;cd new_app The system cannot find the path specified" at the bottom 
looks like it has associations, so doesn't that make it relational? I'll definitely be looking into this. I was just struggling with activeresource when I came across this, and realized that the validate() method advertised in the API docs doesn't actually work and hasn't been fixed in 4 years. What the hell is up with activeresource? For auth, can I just pass the user/pass in the url like AR? http://user:pass@lvh.me Does it work with ssl? 
I'm using pry for debugging these days. Does debugger have some advantage over just dropping binding.pry in your code where you want to debug? The pry console is so damn slick, I don't think I could live without it. 
The redis_failover gem has been rewritten to sit on top of ZooKeeper for its reliability and distributed synchronization. This new version now deals with network partitions, thanks to ZooKeeper. From the README: redis_failover attempts to provides a full automatic master/slave failover solution for Ruby. Redis does not provide an automatic failover capability when configured for master/slave replication. When the master node dies, a new master must be manually brought online and assigned as the slave's new master. This manual switch-over is not desirable in high traffic sites where Redis is a critical part of the overall architecture. The existing standard Redis client for Ruby also only supports configuration for a single Redis server. When using master/slave replication, it is desirable to have all writes go to the master, and all reads go to one of the N configured slaves. This gem attempts to address these failover scenarios. A redis failover Node Manager daemon runs as a background process and monitors all of your configured master/slave nodes. When the daemon starts up, it automatically discovers the current master/slaves. Background watchers are setup for each of the redis nodes. As soon as a node is detected as being offline, it will be moved to an "unavailable" state. If the node that went offline was the master, then one of the slaves will be promoted as the new master. All existing slaves will be automatically reconfigured to point to the new master for replication. All nodes marked as unavailable will be periodically checked to see if they have been brought back online. If so, the newly available nodes will be configured as slaves and brought back into the list of available nodes. Note that detection of a node going down should be nearly instantaneous, since the mechanism used to keep tabs on a node is via a blocking Redis BLPOP call (no polling). This call fails nearly immediately when the node actually goes offline. To avoid false positives (i.e., intermittent flaky network interruption), the Node Manager will only mark a node as unavailable if it fails to communicate with it 3 times (this is configurable via --max-failures, see configuration options below). This gem provides a RedisFailover::Client wrapper that is master/slave aware. The client is configured with a list of ZooKeeper servers. The client will automatically contact the ZooKeeper cluster to find out the current state of the world (i.e., who is the current master and who are the current slaves). The client also sets up a ZooKeeper watcher for the set of redis nodes controlled by the Node Manager daemon. When the daemon promotes a new master or detects a node as going down, ZooKeeper will notify the client near-instantaneously so that it can rebuild its set of Redis connections. The client also acts as a load balancer in that it will automatically dispatch Redis read operations to one of N slaves, and Redis write operations to the master. If it fails to communicate with any node, it will go back and fetch the current list of available servers, and then optionally retry the operation.
The only thing pry lacks that I know of is being able to step through your code, but I've learned to get around its absence by just pasting in a few extra pry calls. I had no idea the debugger was broken.
Have you tried Ruby 1.9's built-in debugger? require 'debug'
Can it set breakpoints, forge return values or move up/down the call-stack, and other traditional debugger functions?
Why are you talking about Rails since it's a gem to build skeletons for Sinatra apps?
Wow this is the height of insanity. In order to keep up a service (redis) you need to install another service (zookeeper) and keep these daemons running. 
Alright! Next question, where can I get this functionality? Most users wouldn't want to build their own debugger on top of pry. Also newb question here, do the `up`/`down` command actually move execution up/down the stack (rolling back/forward method calls), or does it just move your local scope up/down the stack.
I have. It seems to fail miserably under multi-threading too -- it's dropping me into completely the wrong place.
You should learn C. If you're going into security, it's important that you understand things at a low level, and C will give you that. The BSD sockets library is pretty much canonical for working with IP, and all unixes support it. The ruby libs are built on top of it. Of course, you can do networking just fine in ruby, but so much stuff is abstracted out, you might not get the picture of what's going on underneath, which is critical if you want to understand the security implications of networking code. 
Hurrah! Another gem name that looks impossible to google!
True. But try googling "[rubygems her](https://www.google.ca/search?q=rubygems+her)", it returns good results. I try to use [references](https://github.com/remiprev/teamocil) [to](https://github.com/remiprev/annyong) [Arrested](https://github.com/remiprev/helloh) [Development](https://github.com/remiprev/her) when naming gems :)
I had no success with user:pass@example.com, but here's a middleware class that worked for me: class HTTPBasicAuthentication &lt; Faraday::Middleware def call(env) env[:request_headers]['Authorization'] = ActionController::HttpAuthentication::Basic.encode_credentials('username', 'password') @app.call(env) end end
If there's a built in debugger, why a debugger gem? Somehow, I didn't even know ruby had a built in debugger. Odd. I assume that's MRI only? 
I was pretty excited to see this, because we recently implemented a similar feature for our in-office homerolled framework. It ended up being quite convenient at times, but unfortunately, unbearably slow. How does the performance of Her hold up?
Tangentially related: &gt;&gt; charlie.set_status! "asynchronously winning!" =&gt; nil &gt;&gt; charlie.report =&gt; "Charlie Sheen is asynchronously winning!" This usage looks like poorly done [futures](http://en.wikipedia.org/wiki/Futures_and_promises) (and [my implementation](http://pastie.org/3806498)), in that there's no way to deal with calling `charlie.report` before `charlie.set_status!` has finished updating. So my question: do futures have any place in DCell or the concurrency of the future? Are they being overlooked for a reason? edit: herp derp https://github.com/celluloid/celluloid/wiki/futures but still, I'm interested to hear why the ! method doesn't default to a future.
blank is one of those words that loses its meaning if your say often enough :)
blank blank blank blank blank blank blank blank blank My mind is now a blank.
As a lisp programmer, I must say this: While every community has its issues, you've got it a lot better than a lot of other languages.
Yes, the up and down calls cause a session to start on a binding further up/down the call-stack. I wrote a C extension called [binding_of_caller](https://github.com/banister/binding_of_caller) that manipulates the cfp (current frame pointer) to generate actual bindings for previous stack frames -- you can change state in higher up stack frames and they will actually affect that caller. Furthermore, it gets ALL stack-frames, so you can move right up the stack to the birth of the program. AFAIK ruby-debug was more limited in this regard.
because the author couldn't be bothered: "Gon gem â€” get your Rails variables in your js" Summary: a mechanism by which you can export the contents of variables in your rails app 'seamlessly' into your Javascript variable space. Also apparently supports Sinatra. Editorial: a bad design pattern.
&gt; Certain byte sequences are invalid in any given encoding. Wrong. str.force_encoding("binary")
I've been trying to get a database full of multi-encoded garbage working in 1.9 and having all sorts of problems like this. So annoying!
What have you been doing to find and correct bad bytes? Something like OP, something different?
Ya I'm also this encoding issues with ruby 1.9. I wish they would have just made binary the default encoding for strings.
Because it would so much better if the database stayed as multi-encoded garbageâ€¦
To clarify, I'm not actually fundamentally objecting to ruby 1.9's char encoding model. Maybe my attempt to give this a catchy title brought out the wrong kind of haters. I am objecting to ruby 1.9's inconsistent implementation of the tools it gives us to deal with it's char encoding model. More importantly, I'm providing some sample hacky code for dealing with one sort of thing you are likely to need to do (whether you realized it or not, it might be the answer to your problems), and asking if anyone else has anything better. 
I've been trying a number of different approaches. I believe I last left off with something [like this](https://gist.github.com/2415017). Using that to transcode the characters on the way out until I can fix the actual database. Then the middleware will transcode their copy and pasted trash on the way in so this doesn't happen in the future.
&gt;Itâ€™s unfortunate that this process is so cumbersome, but Iâ€™m hopeful things will improve. Yeah...the author *made* that process cumbersome. I can knock out the following in an eighth of the time: 1. Install command line tools instead of Xcode. Save yourself from the AppStore, and 4gb of downloading. 2. Install homebrew 3. brew install rbenv 4. Install ruby Its a nice newbie guide that goes through a lot of detail, but I don't agree with editorializing it and calling it painful when there are literally 50 guides or [automated installers](http://robots.thoughtbot.com/post/8700977975/2011-rubyists-guide-to-a-mac-os-x-development) to do this exact thing.
you're assuming that, or you're sarcastically suggesting it while pretending you're assuming it? Will do. I did not know where to file issues for ruby, I do now! I am thinking I should file this in the "ruby-lang" project, as a "feature" request? I ~~"assume" since you're so interested in this~~ (no, I don't, but I ask) that if I mis-file it, it would be awfully kind of you to find it and re-file it correctly for me. https://bugs.ruby-lang.org/issues/6321
Amen
Why not just use [iconv](http://rubydoc.info/stdlib/iconv/1.9.3/Iconv) to strip out bad chars?
Have you tried passing the Strings through [Iconv#iconv](http://rubydoc.info/stdlib/iconv/1.9.3/Iconv)? I've used it to handle a [database dump of mixed encoding Strings](https://github.com/postmodern/postmodern/blob/master/lib/gawker.rb#L21-24).
I knew someone else on Reddit was a Markov chain generator that somehow gained sentience definition of love boat parts
Thank you so much for this. As a complete noob, I was having a lot of trouble getting set up. I wish he included instructions for rails also!
If you've got any rails questions feel free to pm me, I'm glad to help. 
yep, understood, I just didn't know where the right place to file issues with ruby was (and still got it somewhat wrong), I believe in filing issues, just haven't gotten in the habit of filing them for ruby itself, appreciate the reminder and pointer, didn't need the harangue! I think a lot of people aren't sure if what they've found is _really_ an issue worth filing or not, and have the experience (with _other_ open source projects, not saying with ruby) of issues being usually simply ignored (thus being a waste of time; perhaps because they filed it in the wrong issue tracker nobody uses anymore but it's still up; or just because it doesn't attract the attention/priority of anyone who can do anything about it) -- or worse filing issues resulting in them getting berated for doing it wrong (filing the issue, or writing their code wrong resulting in the spurious issue), or bringing up an issue that there's already 10 tickets and a years-old flamewar about. I think that's why some people are hesitant to file issues. Me, I'm not afraid of getting berated, but I have spent too much time in my life trying to file issues that end up getting ignored, and sometimes it takes someone in the know saying "*this* is the right place to file the issue, and there's at least a 50/50 chance it won't just get ignored". I also think my attempt to put a title on this reddit to attract attention backfired, attracted people who wanted to say "right on brother, here's [incoherent and misinformed unrelated complaint]", as well as defensiveness from people who wanted to defend ruby by telling me I was doing it wrong. Okay, next time, remember, catchy and still positive title -- "Ruby 1.9 char encoding is so awesome, it leaves me surprised that it's so difficult to do X in a manner performant, complete, and consistent with the stdlib's behavior!"
Hmm, are you writing an application, or are you writing a gem? If you can make it into a gem, this'll be handled for you -- everything in lib/appname will ordinarily be on your load path. Making it a gem especially makes sense if you plan to share it with others; but it can be a pain to gemify the logic from your app, it does require more engineered abstraction. If you are writing an app for yourself... I'm not sure the guide on _rubygems_ that says changing the `$LOAD_PATH` is a bad idea applies. it's a bad idea in a gem; it's perfectly reasonable thing to do in your local app. It's dangerous to do in a gem precisely because you do not want to make assumptions about what some user of your gem has done to their `LOAD_PATH`, or do weird things to that user's load path. If you're writing an app, you are that user, and you can do whatever you want. (Of course, there are still reasonable ways to modify your LOAD_PATH and ridiculously confusing hacky ways to do it. I don't completely understand what your goal is, and have no opinion on whether whatever you're doing to your LOAD_PATH is reasonable). 
For my projects I like to see issues down to "Your project can do X and I tried to get X to work but it isn't working" since that means the documentation could be improved and I often move such ruby tickets to the DOC category. The ruby tracker is nice to it's reporters. We've been good about triaging bugs and separating features and so-forth. Some bugs may still take a while to get fixed, but ruby doesn't get released too often so I don't see a problem with that.
infrequent release schedule is, sadly, a slight disincentive to file issues, it's a fairly self-less act, since you won't get a fix in time to not have to workaround it for what you're working on right now. on the other hand, too frequent release schedule is too much instability, so, you know. I try to file issues, the easier a project can make it, the more people will file. One thing with ruby is I'm never sure how to find 'the ruby webpage' that will have correct information about (say for example) where the issue tracker is and any issue tracker guidelines. For a particular project like Rails or Sinatra or what have you, I know how to google em and find the project page with correct (usually) up-to-date info. Look arond for a ruby homepage with this info, I end not not sure which page is 'the' page, or which page has reliable information that is likely to be up to date. 
I might take you up on that, thanks!
That's what I was using in 1.8 but it's deprecated now. It had those nifty flags that made everything easy. Iconv.new('ASCII//IGNORE//TRANSLIT', 'UTF-8')
The new `find-method` is basically a ruby-aware `ack` or `grep`. It can search through all methods in a namespace looking for code that you specify, and return the list of methods that contain that piece of code. Here is an example of running `find-method -c index` inside the `Gem` namespace: https://gist.github.com/2417846 As you can see from the gist above, all methods that contain 'index' in their sourcecode are returned. The new `show-source -a` command is also very handy - it can show you the source code for every monkeypatch of a given class/module, see here for a look at the `String` monkeypatches: https://gist.github.com/2405083 
Phew! Quite a few misconceptions here, I'm afraid, but that means lots of new stuff to learn, which is never a bad thing. Let's start from the top. As tenderlove mentioned, `require` looks in all of the directories specified in the `$LOAD_PATH` global variable for the file you specify. The array will almost never contain your current working directory, thus the `LoadError`. There are several ways to correct this, but the most common approach is simply to append it to the list prior to issuing any `require` calls, like so: $LOAD_PATH &lt;&lt; File.dirname(__FILE__) `__FILE__` is a reference to the current file, obviously enough, and `File.dirname` simply determines its directory. Now that the load path knows to search the proper directory, you can avoid the use of `require_relative`, which is both wordy and frowned upon as error-prone in sufficiently complex programs. It's not clear what you expect `require 'empty'` to do. If you've defined a global `empty?` method within the script, the solution I suggested above should fix your problem, but more than likely you've misunderstood how methods work in Ruby. It's `foo.empty?`, not `empty?(foo)`.
Thanks for the tips HazierPhonics. I've tried adding the line $LOAD_PATH &lt;&lt; File.dirname(__FILE__) prior to require calls as you said and changed the require_relative back to the usual require 'someClass' and it works now. Does this mean that I've to do this for all my class files I'm working on? 
Awesome! Glad it was a simple fix. The fact that `$LOAD_PATH` is a global variable means that you won't have to do this for all of your files. As long as it's properly set in your program's main point of entry, all of the descendent files should work as expected.
I get it now! What you said explains everything clearly. Thank you!
It's a fine solution today. I filed https://bugs.ruby-lang.org/issues/6322 so we'll see how long it will last into the future. My bet is that it will be removed in ruby 3.0, but matz may surprise me and allow it to be removed for ruby 2.0 even though he prefers compatibility for ruby 2.0.
I don't _think_ it does anything that String#encode doesn't do anyway though. My inclination to mess with it to find out further is reduced by all the warnings in the docs not to use it if you care about cross-system compatibility or forwards compatibility. 
Why not?
&gt; He obviously doesn't need the Ruby Certification to be taken seriously He needs way more than the Ruby Certification to be taken *seriously*.
why? just curious
The entire third paragraph.
You go on at length about what we should do, but you fail to give any compelling reasons. It also seems like a pain in the ass.
Because it's global and could screw things up in code you didn't even write when that code goes to require some module later. Generally a project will have one 'lib' directory that is intentionally part of the load path and includes name-spaced modules under it. That way there's a reasonable convention about where to look for stuff.
like ~/path/to/folder ?
RubyGems 1.8.23 is also out with the same fix. Two security issues were fixed: * RubyGems did not validate SSL certificates (the dreaded OpenSSL::SSL::VERIFY_NONE problem). * RubyGems allowed HTTPS-to-HTTP redirects. And in fact rubygems.org did redirect gem downloads from HTTPS to HTTP (also fixed). Either of these mean that an attacker could MITM your `gem install` or `bundle install` and give you malicious gem contents. You'd be owned when you required the gem -- possibly sooner, in fact, because `gem install` itself provides mechanisms for arbitrary code execution. It's also important to note that RubyGems does not default to HTTPS. I highly recommend using `source "https://rubygems.org"` in your Gemfile and the following in your ~/.gemrc: :sources: - https://rubygems.org 
broken link
Awesome, confirmed that pull-request fixed it. :) Although, looks like the Makefile got borked, will have to wait for the code to settle down.
I do not understand why RubyGems does not use full HTTPS for everything. An attacker should not have any opportunity to tamper with rubygems.org data (metadata or package data). Hasn't the myth that SSL slows down web-servers been busted yet? Still, I'm glade this was spotted and fixed.
Looking forward to this.
part 2 http://www.youtube.com/watch?v=sB-IifjyeLI
Wouldn't be my first choice, but yeah... Usually if it's a local ruby source file in say your lib folder underneath a parent I'd just go ./lib/library.rb 
Wow, I really need something like this! I've been walking the XML programatically in Nokogiri but it's tedious. Hopefully this will work for me.
On macosx, the easiest way to get gtk working would be via homebrew. If you've got homebrew installed, it's just brew install gtk. After that, 'gem install gtk2' and 'gem install freightrain' for freightrain + gtk extensions. Side note - freightrain also works with qt and wxwidgets. Thanks a lot for your interest!
It looks like you'll have to have pre-existing knowledge of Objective-C and Cocoa Touch. :-\
I'm having trouble understanding what "replace without transcode" actually means. I mean, if I have a string containing octet sequences which are invalid in UTF-8, then what I have is not a UTF-8 string. If I remove the invalid sequences then by definition I'm transcoding to a UTF-8 string; it's just a lossy transcode because I'm stripping invalid or non-representable data in the process. Anyway... Surely what you really want is to read the string as binary octets, sniff the _actual_ encoding by looking at the data, and then transcode from that encoding to whatever you're using internally -- which I sincerely hope is UTF-8. And then, ideally, write the fixed data back to your database. (I've faced similar problems. In fact today I encountered a file containing a UTF-16 BOM which had been UTF-8 encoded.)
 * Original content * Two years of work Let's get it some upvotes!
Yes of course I know shoes :-) and while it's certainly a worthy project on it's own I didn't want to follow their direction. Freightrain was born when I realized that if I wanted to build a Ruby desktop app I woild have had either to 1) deal with ruby/gnome and all its c-like syntax or 2) turn over to shoes and accept the huge coupling between interface representation and behaviour that comes with it. Shoes is great, nothing to say about it really... But i don't think it's suitable for complex and well layered desktop apps. That's the reason why I made freightrain - I wanted to be able to easily create interfaces and be very decoupled from the actual widgeting system.
Imho: Shoes is, and will continue to be, an awesome graphical learning environment for new programmers, but not a fully featured Desktop GUI Toolkit.
To clarify, is this correct? x = a || b means x = (a or b) means if a x = a else x = b end
Intent.
Fair enough as to semantics of "transcode". What I mean is I have a string which ought to be utf 8, and I want to leave it utf 8 (the #encoding should remain utf 8), but if it has some illegal bytes in it, I want to remove/replace them right now on purpose -- to avoid some future ArgumentError "illegal UTF8 byte". There may or may not be some other "correct" encoding. It may really be (eg) UTF8, but just have a bad byte in it. It may have MIXED encodings in it. To try and heuristically "sniff" the encoding would be a lot of work, and still fail often. It's not necessary or desirable for my particular cases to try and guess which substrings may "really" be a certain encoding. I have terrible data from legacy sources, it's not worth it to write complicated heuristics, I just need to be able to display it in all it's corrupted glory so it can be fixed by hand if needed. Except utf 8 is just one example -- I need to deal with data, often from legacy sources, in a variety of encodings that suffer from these problems (and sometimes write gem code for others to use, with their own local encodings. I work in a university library, and libraries end up dealing in all sorts of weird old legacy data, internationally. Some data that's literally decades old.) Does that make any sense? Ruby recognizes this desire as reasonable when you are transcoding from say UTF8 to UTF16, or cp866 to UTF8, or any x to any y-- the #encode method has a :invalid=&gt;:replace option for these cases. I need the exact same thing, but my input currently has some #encoding (for example UTF8, but it might be something else), and I do Not want to change the string's #encoding -- I just want :invalid=&gt;:replace behavior. Make any sense? Not sure where I'm going wrong in trying to explain this -- I think I've been dealing with it so much that it seems obvious to me and I've lost the ability to explain it to anyone else maybe 
It means nothing, the goals aren't the same. "embedded" is not limited to smartphones. I'm thinking robots, console games, etc
Blergghhh gtk, nice idea though, but blerghhh
Blergghhh gtk, nice idea, but blergghhh
'brew install gtk+' works on my mac mini with Lion... It wasn't 'brew install gtk' but 'brew install gtk+'
I think I asked a stupid question. 
I think he's implying you could use macruby to write a beautiful GUI cocoa app 
out of interest (i hvaen't looked into it), but why wouldn't it be much work? surely it would require you to write a ruby C extension that wraps the cocoa objc API -- and cocoa is pretty huge and complicated.
neat
+1 for a Cocoa extension! :D
Well, go on...
there are some small examples in the /examples folder on the github page. Also, for a bigger example, there's a solution of a ruby quiz i wrote long ago,[here](http://github.com/bolthar/intersect)
This is gayer than a George Michael concert :-)
Oh come on sexy, you just gotta have a little faith... faith... faith...
Regardless those questions are still pretty meaningless until it's clear what his code is doing. For all we know it's a simple bug that he's overlooking.
awesome work! i was wondering about this particular problem just the other day!
Better love story than Titanic
The reason I picked vim is that it is already there in every box I need to use. It's a small reason but you should know about this. Depending on your job you might need to jump to thousand of boxes in your career, and knowing it's already there saves time.
Well I never knew that. Here's my public thank you to Emacs for not making ruby syntax suck!
IMHO, Vim is for editing files. Emacs is for doing everything else. Seriously, emacs text editing tools are barely sufficient for editing text, whereas with Vim it's incredibly painful to try and do anything but edit text. Want the single most powerful and extensible IDE available at the command line? Use Emacs. Want to edit files at the speed of thought? Use Vim.
Interesting. I feel like being able to inspect if a longrunning operation is done or not could be very useful for a distributed work-queue type thing, or in my case, simulating trades between game objects. The determination may take a very long time (AI has to do potentially a lot of work), and I might have multiple concurrent, conflicting requests. For example, imagine an object which needs :widgets, and puts out several offers stating how many widgets it wants to buy to many widget-providing objects. It then checks to see which objects have responded. If the response is deemed "acceptable" then the value is retrieved, and a second action "Make Sale" occurs, as well as several other actions "Cancel Request" (so that the old offers are pulled off the queue for the other object. Naturally, this relies on being able to quickly query the state of the future, and also be able to cancel the future in the event it's result is no longer needed. The former seems reasonably simple (though I don't know exactly how it all works, so I speak from ignorance). The latter seems harder. It's a natural thing to implement in a language like Haskell, essentially I need a monad which runs an implict "unless cancelled?" after each line of code which the future runs. Since that will wildly impact performance, it may make sense to invert that dependency to the method implementing the future, but that's crappy too, since ideally the method doesn't know about it's calling-convention (for lack of a better term) Then again, these things are fibers internally (or threads?). If so, and the Future object returned from `#future` handles it's own fiber, then you could just send `#kill` and halt the work "the easy way". In any case, it's a wildly interesting problem, and certainly a new hammer with which I will be looking for nails. :)
So, are you saying that vimscript is easy to write &amp; create extensions for? I'd personally love to see org-mode for Vim - but it probably won't happen due to the difficulty of writing utilities for Vim. Most Vim extensions are related to editing. Or, perhaps you're saying that Emacs' extensive use of hand-cramping key combinations (just to avoid modes) makes for a fast and easy file editing? I've used both, and stuck with Vim - of course that's mostly because I prefer using the bash shell directly over extensions.
What is the significance of this? Also, why does it cost money?
Try both, then decide. :)
Interestingly, I used emacs for something like 13 years. I coded C, C++, Java, assembly, lisp, html, etc with it. When I started learning ruby, I had so much trouble getting emacs and ruby-mode to do what I wanted, that I actually switched to gvim. Now I do everything in gvim and I haven't touched emacs for almost 2 years.
When I start my computer it starts Emacs. So editing with it is instantly. But I don't have to switch between different kind of key bindings and any improvement I make to my configuration can be used for quick and for long hours working. 
Cool. I remember I bought the peepcode video introduction to emacs a year ago or something. Maybe I should actually watch the whole thing and learn from it.
A pretty great mode for Emacs: http://orgmode.org/ Basically it's a tool to organize, write texts, take notes, etc. Here are a few talks about it: http://orgmode.org/talks.html
On which distros is vi/vim not installed by default? 
&gt; But I never heard of a long time Emacs user switching to vim. Here's one. I used emacs for more than 5 years. At the job I was at, I had to work on bunch of different boxes over horrible quality phone lines. None of the boxes had emacs installed so I had the choice of using pico, vim or ed. I was stubborn for a few weeks and used pico until learning the basics of vim. A couple months later, I was really starting to love it. 8 years later, here I am, still using vim over emacs.
Too bad you didn't realise that Emacs can edit files over ssh (or other remote protocols) and you really don't have to care what editor is installed on a remote box.
This is a problem I also have. If I find anything, I will let you know.
Cool stuff! But I'm not sure why you'd use this over https://github.com/andrewvc/em-zeromq , which integrates the C bindings into EM, which should be faster (though I haven't benched this one).
I haven't programmed ruby in a long time so can you explain why's that's sacrilege? From the looks of it, I'm guessing the 'net' in `from net ....` is unnecessary so the only reason I can think of that it would be there is to make it look like how some other programming language imports modules. My first guess was that you were emulating Python and looked it up and it looks like I'm right. The only questions I've got left are: 1. What is ObjectSpace? 2. What does the call to `load 'blasphemy.rb'` do?
This guy gets it. : P
Hm? I did very little "customizing". The "use case" for something like this would be to avoid having to type require 'net/http' require 'net/pop' require 'net/ftp' Sure, there are far saner ways to do this in "native" Ruby, but the Regex I use is a fairly general one that will capture anything of the form "from x import y" and call `require x/y`, which is usually the expected result.
So, this is actually pretty cool. HazierPhonics is typing the 'from net import' string into irb (interactive ruby, a REPL), then loading the blasphemy.rb file into irb. Since the string wasn't assigned to a variable, you'd think that it would be an orphan, sitting around waiting to be garbage collected. But those objects live in ObjectSpace, so the string can (weirdly) be found.
Pretty much spot-on, but not quite. The "beauty" in this is that it could in fact appear directly within a file. Ruby does not consider naked strings a syntax error, though why that is I do not know.
I hope no one thinks that this is reasonable production code.
In fact, this approach is on par with em-zeromq in term of performance cause: * there is no need to use (relatively heavyweight) ffi calls and allocations, * EventMachine written in C++ and use native bindings instead of ffi, * libzmq do the same things as EventMachine + Ruby -- event loop and string manipulation. But main reason (as @tureus said) is simplified deployment and integration, cause integration ffi-rzmq into event loop of EventMachine is not pleasure task. It were simpler for me to implement zmtp1.0 than consider all circumstances with this integration.
You are right in every term :)
Simple benchmark with draft version shows that it slightly faster than ffi-zeromq, but it is could be not true at the moment, cause more ruby logic added to implementation. When using with EventMachine, I expect it to be on par with integration ffi-rzmq into EventMachine's event loop or even slightly faster. Other issue with benchmarking: what is to be measured?
&gt; It's no different... But it is. While I realize that some method of String *must* be getting called, it's not `#new`; observe: class String def initialize(str) puts 'foo' end end 'naked' String.new 'constructed' # =&gt; foo I understand that they probably get turned into a method call by the parser, but what point is served in *allowing* for naked objects?
I can't imagine why they would?
Hey, thanks. :) The whole RVM/Ruby version choice is orthogonal to this gem, really. The process which will be run is: bundle exec rake... 
You can overload require, or make your own python_require. :)
You misunderstand. I'm not asserting that there's no way to do it, I'm asserting that there are *many* ways to do it, and that it's therefore unreasonable to have a single supported method in the standard library. When you hit an invalid byte in UTF-8, there are at least the following possibilities, with random example scenarios: * The byte is an invalid inserted byte, and you should discard it and move on. * The byte is half of a character written in UTF-16 by mistake, and you should discard two bytes and move on. * The byte is a corrupt first byte of a character in the range U+07FF to U+FFFF, because a UTF-8 file was processed as Latin-1 (say). You you should discard three bytes and move on. * The byte is the start of a UTF-32 character written in error, and you should discard four bytes and move on. * The byte is part of a UTF-16 character with variant appearance, and you should discard four bytes and move on. * The byte is part of what was supposed to be a musical note in a box, formed from a combining symbol diacritical plus a regular symbol. You should discard *six* bytes and continue. Those are just the simple cases. You might write a Latin-1 character which is a multibyte start in UTF-8, meaning that two valid characters then look like part of an invalid UTF-8 three-byte unit. And so on. Now, if you have domain knowledge, i.e. you know what kinds of data and what kind of error you are expecting, you can eliminate a lot of those possibilities. You can also filter out disallowed characters from the output you get by discarding invalid bytes -- after all, if you discard an invalid corrupt byte that's part of a multibyte sequence, the remaining bytes might decode to a control character, combining diacritical, string escape, or something else you don't want. But a standard library function cannot do all that for you. That's why I'm saying that you should write your own UTF-8 cleanup code that does what *you* need it to do, and not expect the standard library to provide same. Again, been there, done that. Also, going to UTF-16 and back is very definitely *not* the way to do it, because UTF-16 only supports Unicode characters up to U+10FFFF, whereas UTF-8 works up to U+7FFFFFFF. At this point both UTF-16 and UTF-32 should be considered legacy encodings, and you shouldn't use them unless you have to for compatibility reasons. Finally, Ruby is doing what the Unicode standard and RFCs say must be done, as [Wikipedia explains](http://en.wikipedia.org/wiki/UTF-8#Invalid_byte_sequences): &gt; RFC 3629 states "Implementations of the decoding algorithm MUST protect against decoding invalid sequences." The Unicode Standard requires decoders to "...treat any ill-formed code unit sequence as an error condition. This guarantees that it will neither interpret nor emit an ill-formed code unit sequence." So the fact that sorting out errors in corrupt data is up to you is intentional. System-provided decoders are required to throw an error when they hit an invalid byte sequence. That's how it has to be, because there's no single safe way to fix errors.
Until you forget about it and do something like: puts "in Python, you can say 'from module import x, y, z'" which will happily throw an exception because you don't have module/x.rb. How about this instead? def require_multiple(dir, modules) modules.each { |m| require "#{dir}/#{m}" } end require_multiple 'net', %w[http pop ftp] 
If ruby can find and either raise or replace invalid bytes when transcoding from one encoding to a different encoding.... and do so in a 'good enough' generic context-independent way.... ...then why can't ruby simply provide this _same algorithm_ for intentional use by developers _without_ transcoding from A to B? This does not seem either impossible or unreasonable to me. It does seem useful to me for a use case I run into a *lot* and I think I'm not alone. It definitely doesn't **have** to be that way, I contest your assertion that is "has to be that way." Ruby **could** expose that same algorithm for use without transcoding from A to B, right? You are perhaps arguing that this generic app-independent functionality is useful when transcoding from A to B, but would be of no use to most people when staying in char encoding A, but just wanting to identify and replace bad bytes? It would definitely be useful to ME. I myself think it would be useful to lots of people, but I guess neither of us knows for sure what would be useful to many developers. This is a very odd argument, in which you try to convince me that something ruby *does* in another context is impossible in my context, or try to convince me that I'm wrong about what functionality I need! I **have** implemented the functionality using ruby code taking advantage of `#valid_encoding?` and `each_char`, that does _much_ the same thing as I'm asking for (it's in the OP), but it's not completely consistent with the built-in behavior, and is presumably much less performant being in ruby rather than C. It **is** doing what I need it to -- I realize it can't possibly psychically fix any bytes that don't mean what was originally intended, but it can fix bytes that will later result in an ArgumentError "invalid bytes in utf-8" if not otherwise fixed. This **is** what I need for my case, and it's exactly what `#encode` can do, so long as you are transcoding from A to B. Even though it can't catch every possible 'bad' char (ie, Latin1 that is legal but means something differnet in UTF8), it's in `#encode` because it's often useful _anyway_, when domain specific fixes are infeasible, or may still leave some edge cases behind unfixed, and you'd rather do a 'good enough' fix to make it legal (eg) UTF8, instead of raising. It's just that my own implementation, isn't entirely complete or consistent with the built-in one used for an `#encode` trans-code, and is surely much less performant than the built in implementation in C. So it still seems quite reasonable to me for ruby to expose this functionality it already has for transcoding from A to B, to be used without a transcode. That it won't do **more** than it does, does not seem to me to be a reason not to provide it. 
Oh boy, I hope I can be a Ruby Developer with this Certification that requires me to use a deprecated version. 1.9.3? That's for jackholes!
I ain't givin' you no tree-fitty, you goddamn Loch Ness Monster! Get your own goddamn money!
Sweet Discovery 
I've recently created a microsite for cheap Rails/Ruby hosting (http://www.hosting-rubyonrails.info/) Long story short, there are some really cheap shared hosting providers (like HostMonster or Vexxhost) where you can host multiple sites, but deployment will be never so easy as with Heroku. However I was quite surprised how easy it was to setup hostmonster with newest rails 3.2.3. Hostmonster uses apache passenger for rails/ruby apps. The problem with AWS is that you have to admin a new server on your own and compiling passenger/nginx/apache is horribly slow on micro instance. After that the app runs ok. The problem with Heroku is that if you have a really low-traffic site, Heroku will stop your app after a few minutes without getting a request. The next visitor on your site might have to wait for more that 10seconds to start it up again. Next requests are faster of course. 
Depending on one's own bounds of "inexpensive", Heroku stops being so for it's non-free offerings: if you need redis, mongodb, etc, or more than one web worker. Of course, if you can do what you need with free heroku, that's pretty inexpensive. 
nice, that's super useful. In your summaries you don't mention if they offer ruby 1.9.3, or just 1.8.7 (or some other versions of rubies). If you wanted to add what ruby versions they support, it might be helpful. ruby 1.8.7 is end of lifed in about a year, I'm trying not to deploy _anything_ new that's not on 1.9.3.
I'm not arguing that it is _impossible_, I'm arguing that it's _the wrong thing to do_. If you want a dedicated #fixup_corrupt_utf8_string method, request it from the stdlib maintainers. I suspect you'll get the same answer I've given you: that the problem has too many variables for a one-size-fits-all solution. &gt; I have implemented the functionality using ruby code [...] but it's not completely consistent with the built-in behavior And the fact that this troubles you illustrates my point. &gt; and is surely much less performant than the built in implementation in C If you need high performance, use iconv. But seriously, how many corrupt records do you have, that fixing each one up once in Ruby is a bottleneck for you?
Objects can be created without #new getting called. There's the Class#allocate method which does exactly that, although in C-land you can allocate an object without calling #allocate either.
You want Python in Ruby? Fine. Let me show you *docstrings*: &gt;&gt; puts """Hello world!""" Hello world! =&gt; nil
I think I've done everything I can to explain why repairing corrupt UTF-8 data is not as simple a problem as you seem to believe. Feel free to request that :invalid =&gt; :replace be supported for UTF-8 to UTF-8 conversions.
 class String def allocate puts '#allocate got called!' super end end 'naked' String.new 'constructed' #=&gt; *crickets* I would really love to find out what method is actually being called, if any, to put the string into ObjectSpace, but it doesn't seem to be `#allocate`. : /
ok, now it does message =&gt; string conversion only once for Pub socket :)
https://m.twitter.com/wycats/status/193629465375547392 This alternate link will work without requiring javascript. This comment generated by an [automated bot](/r/link_unscripter).
Best part is there are 4 forks already.
What does that even mean?
Good proof-of-concept, but **tweet_poster** kinda fulfills this need for twitter, and that's the only site you seem to "correct."
Twitter was the low hanging fruit. It also does altdevblogaday.com currently, and I'm adding more as I find them. As to tweet_poster, we serve different needs. tweet_poster is for people who want to read tweets on reddit. link-unscripter is for people who want to visit twitter (to retweet, reply, follow, etc) without loading the full interface.
I think what Yehuda is talking about is that lots of people want Rails to be able to do whatever they want, while lots of other people want Rails to stay small and focused on the original goals instead of trying to please everyone. For me, Rails is awesome. It does everything I want and since version 3 I can much more easily replace the parts that I don't agree with. But I do think that its workflow has become more complicated, although I think the complications are justified. Newbies may not think so though because they don't fully understand the problems that the complexity solves.
translates to: people are trying to turn rails into java
I jusy don't buy this argument. Rails more or less replaced Java frameworks so as web apps gain complexity there's going to be similarities. Despite any similarities, the Ruby language is flexible enough that there will always be a big difference. Rails will always be an evolutionary step beyond those frameworks
people are worried that a framework is going to turn into a language?
I think you said it just right. It _has_ become more complicated to use, and this is unfortunate -- but it's become more complicated in order to do things that needed to be done, and there's no obvious easy way to do em any simpler. 
Are you asking for clarification, or just rudely misquoting me for trolling purposes?
I agree that this post doesn't belong here, but not for the same reason. A tweet like this about the future or present state of Ruby from somebody on its core team would be fine, per the sidebar: &gt; A reddit for discussion and news about ruby programming But, this is a tweet about the future or present state of _Rails_ from somebody on _its_ core team, which is not fine: &gt; Ruby-on-Rails posts are encouraged to be posted in the /r/rails subreddit
Totally. Also, redditors should wait for Yehuda to write a well thought out blog post. Don't jump the gun, the karma isn't worth it.
He has a point. It wasn't that long ago that we heard we should stop using attributes and start writing getters and setters for every variable in order to avoid "code smell"
"Make everything as simple as possible, but not simpler" -- Albert Einstein
That's totally the right approach for any software design, and especially framework design. And believe entirely that the Rails team is _trying_ to do that, and doing it to the best of their abilities, and I have no magic answers to do it any better. It still ends up sometimes not as simple as we all would like. _Could_ it be simpler? Could someone more clever figure out how to do it better? Will the rails dev community itself figure out how to do it better with more experience and trial and error? (probably). **When writing code to do non-trivial things, "as simple as possible but not simpler" is a problem statement, not a solution!** When we all go back and look at our code from 2 years ago and think "geez, i can't believe I wrote that" it's usually either "Wow, that is totally not as simple as it could be" _or_ "Wow, that's totally _too_ simple and not flexible enough to do what ended up being neccesary." Although more often the former than the latter -- it's easy to write code that's "simpler than possible", but it also usually reveals itself as being such quickly when it doesn't actually _work_, heh. (And i'm not sure einstein really said it, but it's a good one no matter who said it. Also it's peer "make easy(/common) things easy, make difficult(/unusual) things possible.")
Catchy. Will retweet.
 def method_missing(*args) args.join("\0") end from net import http, pop, ftp ObjectSpace.each_object(String) do |str| next unless str =~ /from\0(\w+)\0import\0((?:\w+\0?){1,})/ parent, submodules = $1, $2 submodules.split(/\0/).each do |submodule| require "#{parent}/#{submodule}" end end [Net::HTTP, Net::POP, Net::FTP].all? # =&gt; true Look, even more blasphemous! (bare words technique courtesy [wat](https://www.destroyallsoftware.com/talks/wat)) **edit:** doesn't work in 1.9.3, but *does* work in 1.8.7. I'd be interested to know why.
It doesn't work in IRB :P
This is the kind of technique you only use when there are no other programmers on the project. For a crew, this is a terrible code practice of the unnecessary-abstraction variety.
Yep, that was it. Works in 1.8.7, and is awesome.
I don't think Rails has replaced Java frameworks. They're both geared towards different problems. Though, jRuby is pretty freakin' sweet if you want the best of both worlds!
what the fuck is this avalanche of stupidity?
This should have been posted on [/r/rails](/r/rails). Also to note [ActiveResource](https://github.com/rails/rails/commit/f1637bf2bb00490203503fbd943b73406e043d1d) will be removed from Rails in 4.0.
The first IMFMessage class is broken. @agent is an instance variable so the if statement will always fail because it is run at class definition time.
Woops. You're right. That's a great catch. Thanks! I'll fix that when I get a moment tonight.
Thanks man. I appreciate that.
&gt; Thereâ€™s a neat gem called text which has a module called Soundex that has methods for generating a soundex object. You can combine this with method_missing to catch and try to correct typoâ€™d methods, based on the fact that similar sounding words tend to generate the same soundex code. This sounds like a really terrible idea for anything except a cute demonstration of weird ruby tricks. I hope nobody takes it seriously. Allowing typos in your code get through anyway sounds like sort of maybe an okay idea, until you realize that if you have a typo'd method call getting to #x only because of a soundex match, if you add a completely different method #y, it may change that typo'd method call to no longer call #x, but now call #y, or even some completely third method #z. You've got code which is appearing to change itself behind your back (of course, it's really doing exactly what you told it to, like all code, you just told it to do something that was a really bad idea). 
and another one, man, I can't resist, meta-programming is like the topic most likely to start a flamewar among rubyists (but I'm not trying to start a flamewar!). In "Chapter 25: Creating Self-Modifying Classes", here's a different way to accomplish the same thing using ordinary ruby modules and `extend` instead. I personally find this way cleaner, easier to understand, easier to debug, and more flexible. (It also shows that the boundary between 'meta-programming' and just plain 'programming' is somewhat porous). module EthansDestruct def self_destruct puts "This message will self destruct in 5 seconds." sleep 5 message = nil # kind of anti-climatic? end end module EveryoneElsesDestruct def self_destruct puts "You weren't supposed to see that..." set_off_explosive # 'MERICA! end end class IMFMessage def initialize @agent = retinal_scan if @agent == "Ethan Hunt" self.extend EthansDestruct else self.extend EveryoneElsesDestruct end end end (In fact, I don't believe your original example will work, because the iVar @agent set in your `initialize` isn't defined at class-load time. But it's at class-load time that you try to use the value of `@agent` to decide which methods to add to the the _whole class_. There will be some way to refactor your example to work, perhaps doing `define_method` in the initiailizer itself instead of class definition body. But I submit using #extend is a lot more straightforward, easier to understand, and easier to modify or extend later.) That `self.extend some_module` trick to customize a particular instance based on instance state determined in constructor, is actually one I end up using not infrequently. You can even let the client code tell you at object initialization time which module to use to extend! This trick may or may not be considered an application of the GoF 'strategy' pattern, not sure. 
cool, that is more reasonable! 
&gt; surely it would require you to write a ruby C extension that wraps the cocoa objc API I think MacRuby already does that part for you, one of MacRuby's features. I think? **update** Actually, looking into it (by reading MacRuby's webpage, heh), you CAN easily use Cocoa from MacRuby, it looks like -- but it's because MacRuby is to ObjectiveC as Jruby is to Java. It's not that it has a built in ruby C extension for Cocoa, it's that it let's you interact with _any_ ObjectiveC objects in MacRuby, same as you can interact with any Java objects in JRuby. The result is the same though as far as Cocoa, and i think Cocoa and other OSX system services are in fact the motivation for this design. http://www.macruby.org/documentation/overview.html
That is indeed a valid point. I was thinking of a more one-off example, like the original post. If you are going to catch the same exceptions in many places throughout a project, grouping them together would save you TONS of time. If you just want to make a single rescue block look pretty, grouping the exceptions together and throwing them in an initializer or something would just complicate things unnecessarily. Now, continue to laugh at my noobishness, r/ruby
[Lighten up, Francis.](http://www.youtube.com/watch?v=0OnpkDWbeJs)
You know, you are absolutely right. With Capistrano you can easily set this in the config/deploy.rb file- set :scm 'git' set :repository, 'ssh://user@github.....' And then uncomment out the Passenger lines in that file enable yourself to install, restart, etc. I may look into hosting my app on a VPS if you're getting those kinds of results. 2 dynos on Heroku (theoretically) can serve 8 requests a second from what most people say. That's more than a tenth of what you could get with $35 with a Hexxeh VPS according to your numbers! Another question, what kind of round trip times will you see with a server hosted in Europe if I'm in Canada? Is there a significant lag? I ask because with all the new laws, I'm trying to migrate my stuff out of US jurisdiction. (Canada isn't technically US jurisdiction, but tends to play rather nice with our southern neighbours with these things.) 
Really useful info! Thanks! I also have a question I hope you can help me with: Is it generally recommended to go for a VPS (rather than shared hosting) even when deploying small/low traffic Rails apps? I had read that on shared hosts you can not install your own gems and instead have to make due with pre-installed gems. Is this true and is this always the case? Thanks in advance :] EDIT: One more thing, in the case of cloud hosting where you get billed on a per hour basis - does this mean my app gets stopped until someone tries to access it (similar to Heroku)?
I wonder why they would try to eliminate "Calling steps from step defs". It seems to me like you gain a little bit of reusability
Well, I guess that is the problem of DRY...
I didn't realize ActiveResource could only be used inside a rails app.
Thanks. I'm confused though. &gt; I can assure you that connections are shared across threads. But then everything else in your post seems to go along with "connections are NOT shared accross threads." (You didn't want to deal with thread-safe manner of spawning new connections, connection list stored in thread-local var, whether connections are shared accross requests depends on the threading model of your web server, etc.) Did you mean you assure that connections are NOT shared accross threads?
 [cough](https://github.com/codegram/spinach) Edit: I'm bias when it comes to large amounts of `eval`
CRAP. I missed a "not" there. My apologies for the confusionâ€¦ I fixed my comment.
Hello, World!
Whatever happened to passenger standalone being able to serve multiple apps? 
Since the tests were last updated in 2008 I don't put much faith in them. hunspell has advanced from 1.1.12 to 1.3 since then while aspell only from 0.60.6 to 0.60.6.1. When I'm done converting rdoc-spellcheck to hunspell I'll let you know the results on misspellings on ruby's documentation.
In Ruby, a standalone non-assignment expression is valid and a string is a valid expression in its own right. This is also true for JavaScript, Python, and Perl, I believe.
Too bad I was thinking it would be a good answer to POW on linux. Oh well.
I used [ffi-hunspell](https://github.com/postmodern/ffi-hunspell#readme) with [yard-spellcheck](https://github.com/postmodern/yard-spellcheck#readme) and my only complaint is the dictionaries do not contain programming terms ("refactored", "namespace", etc).
I like Netbeans. [This thread](http://www.reddit.com/r/programming/comments/9bcul/dear_proggit_is_there_an_alternative_to_eclipse/) might interest you.
I've recently started using Rubymine. It's definitely one of the better ones, for not-gigantic projects.
This! I can vouch for Sublime Text 2. It's not really your full fledged IDE, but it does everything I want it to and more.
vim
I normally work in the terminal using `ruby`, `irb`, `rake` and `gvim`. As for IDEs, checkout [RubyMine](http://www.jetbrains.com/ruby/) and [Aptana Studio](http://www.aptana.com/products/studio3).
Vim and... Nope, just vim.
&gt;The "what's hot" in Ruby editors right now is Sublime. TIL... and WOW. Thx for the link.
I have used emacs religiously for decades, but I occasionally try other things, and I don't think anyone should start using it now. I will be trying sublime soon!
Hit the thread just to vouch for Sublime Text 2. Of particular note are the Ctrl-P (open file-in-project based on partial string match) and the awesome plugin installation system Ctrl-Shift-P. It pretty much obviates those clunky sidebar trees, especially if you've got an SSD. Say you're also an aspiring polyglot and discover you're missing, say, coffeescript or less. No problem. Support is less than 30 intuitive keystrokes away via that Ctrl-Shift-P magic. Awesome stuff. My only real gripes relate to Linux support: 1. The file menu can't be hidden in Linux, the way it can in Windows. 2. ST doesn't behave all that predictably when invoked via sudo, and pretty much sucks for when you need to edit files that require root access. It supposedly got a fix for that on OSX, but I've seen no such functionality for Linux, which is unfortunate for system administration work. ("YOU SHOULD BE USING VI FOR THAT!" No. Shut up. I don't want to.)
What environment supports runtime debugging (breakpoints and variable inspection? For added points, line-by-line edit/re-compile/re-execute - like Visual Studio for C# 
I expand on this by saying, I use Netbeans plus a terminal. I still like to execute the scripts from the commandline. Likewise when using rails I open a terminal with byobu to run rails server and rails console. I also do all my git commands from the terminal even though netbeans 7 has git support built-in. Some old habits just die hard.
mvim these days
Ah, good to know, I'd never used Sublime before. In that case you're probably better off with Sublime since the E-TextEditor trial is limited.
Previously I would have sugested RadRails, a fork of Aptana Studio made by Aptana Inc. However, they've merged into the same product known as Aptana Studio 3 after Aptana, Inc. was purchased by Appcelerator. But yes, Aptana Studio is great. Built-in git support; various tabs or panels for useful things like file browsers, terminals, and in-file navigation; great support for Rails, jQuery, and other web-centric frameworks; plenty of options for syntax highlighting since Aptana Studio 3 supports textmame themes; and good project management; and it's free/open source software!
I've found the the lint plugin exceptionally useful even for JS and ruby syntax in general. Pretty ruby is also awesome. And you have auto indenting of HTML tags. Not much more you can ask for. 
emacs
sublime text 2
upvotes for redcar! It's sort of slow to boot up and gets updated spuriously, but once running is fast, simple, and almost never crashes anymore. (Plus it's written in JRuby!) Works in both Windows and Linux, but of course it doesn't lend itself to the Windows workflow. (Unless you keep a git bash open anyway)
I'm a mac user that switched from TextMate to Sublime. I think they're both good editors, but I was impressed with the fast text searching in Sublime and decided to try it for a while. After using it for a day it really grew on me and I made a permanent switch. I guess you just have try it for yourself and see if it fits. 
*irb*. Instead of slow edit-compile-run cycle of static-typed languages within an IDE, Ruby is more suitable for type-run-type-run cycle in [REPL](http://en.wikipedia.org/wiki/REPL), which is irb is about. When you shape your code the right way, just copy-paste it into a method in an editor (any with Ruby syntax highlighting is good enough). This is especially common for non-web applications which you seem to have in mind.
+1 for Janus and vim I started off with TextMate and never really liked the Ruby IDEs, and after a few week-long false starts with vim I finally took the plunge. I also experimented with Emacs for a bit but that didn't work out too well. Also, check out [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh) for making your terminal shenanigans more fun (and check out my superjarin theme!)
I think it would be a good idea to put the data in YAML files so they dont clutter your program :) 
realestate.com
Plus one for sublime. I used it so much I actually bought it. ...still won't pay for winrar though...
It's $59.00 ... and I just bought one. Even in Beta, sublime has totally eclipsed Textmate, which was my (ok ... everyone's) go-to for a long time. Considering that the application MAKES me more than $59 in a single day, I figured it was more than worth it to throw a little cake their way and help enable development of what's turning out to be an awesome text editor.
&gt; Lots of people just use vim though. What do you mean, "just"?!? :p
do you mean realestate.com.au ?
Personally? VIM. It's all I'll ever need in an IDE for any language ever. It does have a steep learning curve though taking the half an hour to go through vimtutor can start you on your way pretty strongly. I've also found watching other people use VIM can let you in on some very useful tricks. Check out [this site](http://vimcasts.org/) if your interested, also checkout the vim subreddit.
While I admire the goals of the project, this statement is a bit off-putting: &gt; For Ruby to succeed it must succeed on Windows. Ruby has **already** succeeded. The main reason I switched to ubuntu ~5 years ago when starting to learn ruby is because windows did not have any reasonable ruby options. If someone wants to learn ruby but has only windows, installing ubuntu and ruby on it is one of the easier barriers to overcome.
I run both Windows (at work) and Mac (at home), and I've tried many many editors. For something quick, NotePad++ or Textmate works but they, like all the others, have flaws in things like syntax highlighting that make them impossible for me to use for long term sessions. I started using RubyMine when looking for a Ruby IDE that didn't crap it's pants trying to syntax highlight Cucumber step definitions. While not perfect it's a FAR cry better than the others. The intellisense, error highlighting and productivity enhancements made it well worth the money. 
Why do you need a kickstarter for screencasts?
Valid question. Here's what I put on the Kickstarter page...if you want to talk it out more, give me a shout...or we could discuss here.... "Good question. The first answer is to gauge interest. I think this could be really cool. I've talked to a few people who think the same. But screencasts are a lot of effort. I want to make sure I'm spending my time on stuff people want and this avenue helps me figure out if this is one of those things. The second answer is that there is some cost with gearing up to create high quality screencasts. I would also like to get some help for things like logo, animations, and other things to help take the polish up a notch. The remainder will cover the time that will go into researching, recording, and producing each video."
So now raising money on Kickstarter becomes habitual for OSS and documentation projects. Did this start with Yehuda Katz or have there been similar projects before? Now, don't get me wrong. I think this is an interesting option. OSS being financed isn't new. Quite a lot of projects would not have seen the light of day without being backed by some large company. So maybe that's a step in the right direction. And even if at first glance it may look suspicious to some people, it may be a step in a direction where the OSS community (especially the users) can help finance projects more directly. Just I'm not sure, if screencasts are the right medium for something as complex as digging into the Rails source. But maybe that's my personal taste. I'm no great fan of screencast and video tutorials. I always have the feeling, that they waste time and are more difficult to follow than a simple text.
Hmm... or, f*ck Windows.
FTA: &gt; We need to make a version of Ruby that is explicitly written and optimized for Windows. NO. Ruby is just fine as it is, and if you can't figure out how to use it on Windows, you're gonna have a bad time doing much else with Ruby anyway. Now, deployment of Ruby or Rails apps on IIS? I can see a niche market for that. Windows server is still around, although in a much smaller marketshare than *NIX-based servers. But for development? No, this is just silly. See ph0rque's comment below about either installing Ubuntu. I'd say even installing a VM would work fine, too.
That is definitely fair angle on screencasts in general...they aren't for everyone...and they may or may not be good for this type of content. And that to me is the biggest benefit of an avenue like Kickstarter for this type of project. You put in some amount of work upfront to try and best communicate your idea to your audience and in return you get real honest feedback and a serious gauge on interest in the project. 
No plugins? How does anyone use vim without nerdtree? 
I keep multiple cygwin bash shells open on windows by default all the time. Even when I'm working in java or python. Some of us old unix guys just assume that there will be a shell window open at any time.
Sir/madam, I suggest you are thinking backwards. Examine the evidence: https://github.com/mruby/mruby There are more appliances than Windows computers in the world. Appliances will soon support Ruby. Win.
Succinctly and rudely put. I must say that I agree to some extent.
Gedit never gets any love, but frankly gedit works great for coding. There is a great guide [here](http://rbjl.net/18-you-don-t-need-a-macbook-to-code-ruby-and-rails) for configuring gedit to work great with ruby and rails coding. It's lightweight, fast, and super-easy to learn. The only problem I have is when enabling the integrated terminal and file browser, it makes it really annoying for when I need a plain text editor for non-coding.
While I think the mingw distribution of Ruby on Windows is great, I will thank you for your contribution to win32utils. It is extremely useful.
I've backed you, whilst personally I don't plan to ever have the need to use Ruby on windows, I admire the fact that you contribute 2500+ gem downloads a day and have faith you could do a pretty good job at making one of my favourite languages more accommodating for everyone. Good luck!
i think geany is a much better gtk based editor. i use geany on linux, sublime on mac, for mostly ruby nowadays, python before that
Not totally off base, my examples use exaggerated numbers and I'll make more obvious note of that. There's nothing to prevent you from from passing in a hundredth of a second, or any time value. Thanks for bringing it up
from my experience, being forced to use windows as your development environment tends to mean either you are working for a game company or you are working for a larger enterprise organization that has an in-house software department -- in either case, you don't really have the freedom to switch (which is nonetheless unfortunate). if you work for a web-app company and are using windows as your development environment (or heavens forbid, iis as your deploy environment), you're probably doing it wrong (and costing yourself a ton more money &amp; headaches than are necessary)
OP, I suggest you try multiple different editors, to get a feel for how each one helps and annoys you. In some ways, some editors' advantages won't be noticeable until after you've encountered some obstacle with another editor. When you start out, don't be afraid to learn more about your editor and what makes it great, a lot of stuff you won't find easily in the manual, so try youtube or blogs to see what other people do. Personally, I have gone through quite a few editors: * vim * gedit * NetBeans * RedCar * gedit * SublimeText 2 It can take awhile to find something you like.
totally agree
How about http://mocra.com/? Mostly RoR from what I can see.
Try 'rvm notes' for further instructions. I'm running Ubuntu and after installing rvm I had the same issue; this line was what fixed it for me: If you wish to use RVM in an interactive fashion in other shells then place the following line at the end of your shell's loading files (.bashrc or .bash_profile for bash and .zshenv for zsh), after all PATH/variable settings: [[ -s "/home/blacklotuz/.rvm/scripts/rvm" ]] &amp;&amp; source "/home/blacklotuz/.rvm/scripts/rvm" # This loads RVM into a shell session. 
Blasphemer!
Well as they say, [Knowing is half the battle......](http://www.youtube.com/watch?v=pele5vptVgc)
I'm embaressed to admit I still use JEdit. At the time I started using it, it was the best option I could find that: * was basically just a text editor (not some fancy shmancy IDE), with programmer's features like grep search-and-replace, goto line, etc. * including ruby syntax highlighting and class outline features that worked (as well, as HTML, CSS, and javascript syntax highlighting) * and worked on both Windows and OSX (I use windows at work, OSX at home, and want the same text editor in both). * was free. (At this point 6 years later, I'd consider 'cheap' too, not just 'free'). It's done the job, but it's got it's idiosyncracies and UI parts I dont' like, and the ruby packages for it don't seem to be updated that well anymore which gives it some rough edges as ruby evolves. These days, I think there are better options that fulfill my bullet points above, that are probably mentioned elsewhere in this thread. But I'm too lazy to switch, I hate learning new tools (I like _writing code_, not spending time on tools!), even though I know switching to something better would be a more efficient use of my time in the long run. I hate spending time trying to switch to something then realizing it won't work for me. Eventually i'll bite the bullet and do it, maybe this thread will show me what's worth spending time switching to. 
Sweet. I consider $60 at the top end of, but still within, 'cheap', that's not too steep. $200 or $400 like some actual commercial IDE's will cost you, now that's steep. :)
Or maybe it's just an _actually good_ IDE? I mean, it's clearly a 'development environment'. Of course, so is WordPad, if that's what you use it for. :) Is it 'integrated'? Well, it's got a buncha features integrated with each other, and integrates with some external tools such as git and others. So maybe it is an IDE, just not an over-engineered bloat of an IDE. :)
I actually came here thinking no one liked vim on ruby community, thanks :)
Your comment makes no sense at all. 
Of course!
I agree that 'all that version switching stuff' makes everything unfortunately complicated. But the reason people often use rvm/rbenv is because their machine didn't come with the latest versio of ruby, and it seems the easiest way to get a recent ruby version on there. Someone maybe needs to write a good guide for newbies on how to use ruby-build to upgrade your ruby without ruby version switching.... although I'm always scared to replace a ruby that came with my distro or OS, who knows what might depend upon it. 
Hmm. I agree that Rails pattern of sharing state with views through iVars is terrible. It's gotten me into trouble before, it can be confusing to debug and maintain. That part can of course be fixed without going all the way here. I'm not sure there's anything wrong with before_filters. They're awfully useful, and have never gotten me into trouble before. While I see how this is, in some ways anyway, in theory a 'purer' OO design, I'm not sure it's worth it. Going this far away from Rails conventions makes your code less understandable for future maintainers, and potentially takes on some risk of the gem not being supported in future rails versions. I'm not sure it's worth it for benefit here that's not entirely to me. (I _would_ like to see an easy way to not transfer state to views with ivars, but keeping the rest of rails controllers largely intact). I'm not sure I buy that separate action methods in one class violates the 'single responsibility principle'. It seems like you could use this same argument to argue that ANY class with more than one method violates the single responsibilty principle -- different methods always do entirely different things. Should every class have only one method? There actually might be real legit arguments for that! But it'd just be a pain to develop. 
./configure, make, make install existed for years. But lets sidestep that: You have a recent java? Try [jruby-complete](http://www.jruby.org/download). 
I think reading other people's code is a great way to get better at writing code of your own; I'm curious how this will turn out. From reading over posts at the Google Group, I feel a niggling feeling at the back of my brain saying "Wait! They're missing something important!", but the alcohol is preventing it from saying anything more...
Vim with a bunch of plugins. If you are just starting in CS, do yourself a favor and learn an intelligent editor like vim or emacs early.
Also like to add, you can create a rvmrc file by running the following command in the root of your project directory: `rvm --create --rvmrc 1.9.3-p194@my-special-project` You can replace `1.9.3-p194` with whatever version of ruby you want that you currently have installed and change `my-special-project` to whatever you want. Being able to create different gemsets with different ruby interpreters per project is pretty awesome. RVM makes that process pretty much painless.
That's just for a hacking session example as part of the rubinius introduction. If you open the slides, you'd see a big trollface right there :)
I'm always glad to see some Rubinius hacking going on.
Can we just remove "unless" altogether? The times it burned me because people don't know to work with it is increasing steadily. I for one can't intuively read `unless something`, so I always write `if !something`.
I am deadly serious about perl style strict and warn (and taint for that matter).
This question's title is more relevant than the question itself. The foundation of a great RoR developer is not so much the knowledge of Rails, but the depth and breadth of his Ruby expertise. A framework is just a convention that should work 60-95% of the time, but it is those corner cases that make a project difficult. In order to shine as a RoR developer, you need to understand the Ruby way. dabaracus is right, it depends on a variety of factors. The best employers are ready to teach, but you must demonstrate that you have the right stuff. Genuine interest in writing elegant code is probably the best attribute of an aspiring developer and of an accomplished coding guru. Most places are not interested in hiring superstars, but people that will embark on a journey, learning and teaching others, while delivering progressively better results.
Well, you don't have omniauth.info.email, but that's not really unless's problem. If you're going to invert the logic with unless, then obviously you need to invert what happens when the conditions match. unless omniauth.info.email user = User.new else user = User.find_or_initialize_by_email(omniauth.info.email) end But that's not really a great use of unless anyway. "Unless I have an email, create a new blank user, otherwise, create a user using the e-mail," seems too stilted for me.
Anecdotally, I got hired with no prior Rails experience by demonstrating broad expertise in Web development, experience with frameworks similar to Rails, and a willingness to learn. 
When comparing it on devices (Android and iOS) there's a big difference in performance. The iOS is a lot snappier and the UI is generally a lot quicker. On Android it can consume a lot of RAM too. The main reason for picking Rhodes over PhoneGap was because I couldn't do a lot I wanted to e.g. easily store movies, JSON API require the commands to be in the body of an HTML request. I wouldn't use it for something like this again but for more simple applications possibly; as long as Android wouldn't be considered a target OS. I don't really regret using it because I learnt Ruby, which is amazing :) but I would have descoped my project and done it completely natively. Oh and my App doesn't work if you're on wifi and have a firewall oO something I didn't know until yesterday lol. 
IIRC from listening to the Laser guy, it's not totally trivial due to some of the semantics. You would definitely be interested in LASER (over at carboni.ca) It's 7 months stale (author is working for google now), but the source seems pretty hackable, and the tool is very cool.
I think putting an "unless" at the end of a short statement is great because it matches how I think/use English. That's why "unless"-"else" is confusing. I wrote something like this just yesterday: https://gist.github.com/7691b52b48068bd4d6bd
Isn't this a duplicate effort with RubyInstaller?
Well, yeah, you can improve the prediction by benchmarking a lot, but who knows how it will go in production if there's a sudden spike in traffic like the "Reddit effect" etc. But even if you got a perfect prediction, I dislike the fact that you have to accept worst case running time for all operations :(
nice. I hope I still remember this next time I'm in a situation where it will be usefull.
No. As chrisledet pointed out, I plan to optimize the code specifically for Windows. In addition, this isn't just about a version of Ruby built just for Windows. It's about development and (especially) testing for Windows.
interesting, I did it kinda differently (and mis-read and input and output actual strings instead of arrays), but still 5 lines. i'll add mine as a comment on your gist. 
Awesome. You definitely beat me in golf :P
I always forget the trick people use where instead of `.collect {|s| s.strip}` you can do something like `.collect(:strip)` or something. I dunno, I never use it in real life, I prefer less magic more clarity for 5 or 6 extra chars. But I woulda used it here if i could have remembered how it worked, heh. 
Well, if u can do it in 5, I wanna see the complexity of it. You can put it here.
&gt; I prefer less magic more clarity for 5 or 6 extra chars. Yup! I'm so glad more and more people are seeing magic this way. It's more headache than it ends up being worth. The `#collect(:strip)` magic is the one type I'm not that against as it's so ingrained in ruby now.
couldn't be **any more obviously** a homework.
If your homework is fun enough, it's easy to get others to do it. And if you don't think homework like that is fun enough to do it yourself, you're in the wrong program and will never be a good programmer. Which is all the punishment you need. 
Except what is that magic? It's not just `collect(:strip)`, cause I tried that and it didn't work, heh. 
yep, almost identical! But you missed `Hash.new(0)`, which I think actually makes the code more readable, but it's a matter of opinion. 
I think it's actually `#collect(&amp;:strip)`. The &amp; tags it as a "proc" or something internally.
Agreed. I wasn't aware you could specify a default missing value in the initializer like that. 
~one liner in the spirit of FP, Ruby a = [%w{A B C}, %w{A C E}, %w{E F D}, %w{D A J}, %w{E D J}] puts a.map{|x|x.combination(2).map{|y|y.sort*?,}}.flatten.inject(Hash.new(0)){|x,y|x[y]+=1;x}.map{|x|x*?,}
There is no such thing as magic in programming. There is only code you understand, and code you don't. Labelling the latter as "magic" says more about you than about the code.
Assuming the list initialization doesn't count in the line number, here it is in 3 lines (2 if output doesn't count): LIST = [ ['A', 'B', 'C'], ['A', 'C', 'E'], ['E', 'F', 'D'], ['D', 'A', 'J'], ['E', 'D', 'J'], ] hist = Hash.new(0) LIST.each{|a|a.combination(2).each{|key| hist[key.sort] += 1}} hist.keys.sort.each{|key| puts "#{key.join(", ")}, #{hist[key]}"}
Ha, I don't like the new hash literal syntax in 1.9 either. I realize I may be in the minority. Yeah, nothing's really "magic" in programming, obviously. Personally, I want fewer syntax rules or patterns to remember. And don't want especially tricky meta programming code. I want everything to be transparent and clear on it's face what it does, from knowing the basics of the language's syntax rules. I think that's what most people want, and what people call 'magic' is when they don't get it. Of course, once you understand exactly how something works, it's not 'magic' anymore. But the irony is that a lot of ruby 'magic' (not talking about simple things like new hash literal or `&amp;:auto_lambda`, but the more complex meta-programming 'magic') is actually intended to _hide_ how something works from you, thinking it's doing you a service so you won't _need_ to understand the messy details. But until you understand em anyway, it's "magic" to you. 
true dat.
oh, also i've tried E and Sublime is much better in every way that I can think of besides name succinctness.
I've been hiring programmers for a long time. If you don't have much experience, then the best way to get hired is to build something on your own that you can point to and say "I made that". This can be open source contributions, or your own website that does something interesting. For entry level I will also want to know that you have some basic knowledge about things like web dev and databases. Do you know what database indexes are and why you need them? Can you explain basic HTTP requests and responses? Also keep in mind that in most big cities good programmers are hard to find. Don't assume there are a bunch of awesome programmers applying to the same job as you, there probably aren't unless you're applying to some popular company like google. 
 ruby-1.8.7-head :052 &gt; class &lt;&lt; x; self.class; end =&gt; Class Yeah that's the same exact thing as x.class.class isn't it. Yip your explanation and the docs are pretty clear, now that I look again. Intuitively I felt like c should be an instance of the "anonymous (unamed) class" that Class.new returns. But that's silly... c *is* my anonymous class, an instance of class, like it says in the docs. Then calling #new on that anonymous class gives me an object, which is an instance of my anonymous class. Cheers - I think my brain switched off completely some point today.
EVERY command line unix script you write should return proper exit codes, non-zero on failure. Certainly non-zero if any 'exceptions' happened that kept it from finishing; if it's a script that 'checks' something to make sure it's 'okay' in any way, also non-zero for 'not okay' state. If you JUST do that, you've made huge strides. Dealing with scripts written by others (both legacy in-house and scripts provided by vendors for dealing with vendor software), this is _the biggest_ problem I run into, keeping me from easily re-using those scripts in my own changed logic flows. Weird arguments can be figured out and documented without code changes. Improper exit codes can't be changed without hacking code I'd rather not touch. 
ESR's [The Art of UNIX Programming](http://www.amazon.com/The-UNIX-Programming-Eric-Raymond/dp/0131429019) covers this and more in great depth. Required reading for anyone who finds this article enlightening.
yup, i know the feeling.
Emacs or Redcar (when I want easy access to the file system structure) on Linux, InType on Windows
I bought it as well for work. Totally worth the investment. Support is lacking, but whatever.
Solaris is a nightmare in this regard.
What does Solaris do? I've been able to stay away from it for the most part - the only think I remember is that EOF doesn't exit the shell.....
All threads are effectively green in MRI, not just in 1.8.7. This is due to the GIL. MRI has no real multithreading support so look to JRuby or something else if you need it. I chose to design my non-rails app to be multiprocess so this is less of an issue.
Handwaving over many details, ruby allocates a chunk of the heap to put objects in: 1 | 2 | 3 | 4 | 5 Then traverses them in-order and adds them to a linked-list of free objects. This causes them to be in reverse order on the linked-list: freelist â†’ NULL freelist â†’ 1 â†’ NULL freelist â†’ 2 â†’ 1 â†’ NULL freelist â†’ 3 â†’ 2 â†’ 1 â†’ NULL freelist â†’ 4 â†’ 3 â†’ 2 â†’ 1 â†’ NULL freelist â†’ 5 â†’ 4 â†’ 3 â†’ 2 â†’ 1 â†’ NULL When allocating an object ruby uses the first item on the linked list: object = freelist freelist = object.next_free So the freelist now looks like: freelist â†’ 4 â†’ 3 â†’ 2 â†’ 1 â†’ NULL and further allocated objects will appear in reverse order across small allocations. When ruby needs to allocate a new chunk of heap to store more objects you'll see the object_id jump up then run down again.
https://github.com/larsch/ocra ... Used it for my rubygames.
[Why's](http://www.rubyinside.com/media/poignant-guide.pdf) is a common start. You could also try out [Hackety Hack](http://hackety.com/). [Codecademy.com](http://www.codecademy.com/#!/exercises/0) is going to start free Ruby tutorials sometime here but I would recommend checking it out anyhow. Javascript will get you accustomed to Object Oriented Programming for when the Ruby lessons are released. When you know HTML and CSS you'll be equipped to really put your Ruby to use!
http://tryruby.org/ do this! http://tutorials.jumpstartlab.com/ I stumbled upon the Jumpstart lab materials after seeing a presentation for the hungry academy by living social at a dc tech meet up.
teamtreehouse.com is decent for learning your foundations...
This. Not only do manpages look much better than `--help` output, but they force you to document related files and significant ENV variables.
If your command-line util executes other commands, use this style of system(): system('prog', '--arg1', value, '--arg2', value2) This will run the program as it's own separate process with separate arguments (not within another shell). This prevents arbitrary command/option injection. Additionally, checkout the [Shellwords](http://rubydoc.info/stdlib/shellwords/frames) module in stdlib. If you need to trap the `INT` Signal, but only in a certain part of your program, use a `rescue Interrupt`: setup begin do_critical_stuff rescue Interrupt end wrap_up
[Learn to Program](http://pine.fm/LearnToProgram/?Chapter=00) by Chris Pine. The free version is awesome and it's all you need. It uses Ruby and it is geared towards people with no programming experience. I did buy the expanded version, but only because the free version was so awesome and I wanted to support the writer. One thing I love about it, even the free version, is it includes lessons for you to try which is what really solidified the learning for me.
None of the new 'svcs' stuff uses return codes of any kind. "svcs enable nfs" returns 0 regardless of if it turned that service on or not. Even worse, it doesn't report anything to any log. It's a horrid OS.
http://tryruby.org and http://rubymonk.com are right up your alley!
I did run into this problem, on a MacOS machine with an oldish 10.5.8, and had not previously seen news on it. How many other redditors have run into it? This article sort of explains, but still leaves me curious about what's up. Okay, I understand that * it's just https connections to rubygems it has a problem with; * and `gem install` doesn't by default use an https connection (apparently? that actually surprises me) * but new rails applications with current version of rails generate with a Gemfile with an https rubygems source in it. * which is why those who get the problem get it with `bundle install` bug not `gem install`. Okay. And then it seems like for some reason openssl versions prior to 1.0.1 are the ones that exhibit the problem. Does anyone have any idea of the nature of the problem with openssl prior to 1.0.1 that get in the way of rubygems? is there an unusual or new feature of openssl that rubygems uses somehow or something? And it's got something to do with recent ssl related security fixes in rubygems, which I don't entirely understand. Is most everything else somehow not using openssl right?
Lots of great suggestions here (learn the hard way and Koans are great IMhO). Hell, try out all the suggestions here and see what approach you like. Go to a local Ruby meetup too. Dive in. There are tons of people out there willing to take a little time out of their week to mentor you. Ruby developers are wicked awesome. I just started in January (no prior experience) myself and I am currently doing an Apprenticeship. 
Lynda Ruby stuff is pretty good. The rails stuff though is out of date. Go for the free Micheal Hartl [tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book) for rails. 
it's these entry level positions that are elusive.
[railsconf 2012](http://confreaks.com/events/railsconf2012) There are only a few sessions online because they are still editing it and it will take till the end of may for them to upload it all.
Yes that's what I mean. 
Fair enough, yes, that is true.
http://astonj.com/tech/best-way-to-learn-ruby-rails/ Just skip the Rails bits if you don't want to learn Rails as well.
thanks for the Input, I'm definitely going to create 2-3 examples that I could be proud to point to.
Mad helpful. Thanks for the input.
Also, Manning (the publisher) has the right idea. They included a free eBook (PDF/Kindle/ePub) with the purchase of the print book. Handy since I have dual-monitors and handling a book can be a bit awkward while trying to type along.
are internships in ruby/rails out there? Think it would be a good strategy to go to a employer and ask if I could shadow their current rails developers?
Nope, doesn't matter. I'd take someone with 2-4 years experience doing actual programming over a fresh CS grad. 
https://groups.google.com/forum/#!topic/rubyinstaller/bp2m_yCXXco/discussion
RubyMotion is made by Laurent Sansonetti, the author of MacRuby. You can't get better that him for this task :) That being said mobiruby is coming this summer if being open-source is a requirement for you but it's definitively not on the same level!
Sexy. Any Android equivalent already out there or in the making? 
The Well Grounded Rubyist, by David A. Black. Good so far, but I'm only in chapter 2. :P From what I can tell, the entire Manning catalog has this program. It's a shame their Rails 3 book (apparantly) sucks.
It is indeed. And if you're wondering why my text is all so large, it's because I like to sit back a few feet from where I normally sit while reading/programming.
I'm currently learning with The Well Grounded Rubyist by David A. Black, and it is _fantastic_. It assumes no prior programming experience, and introduces you to each concept in turn. It was the most highly recommended to me by members of this subreddit, and is mentioned in the sidebar as well. Plus it's new enough that you won't be learning the "old" version of Ruby.
There also [mobiruby](http://mobiruby.org/) in the making due to release this summer
Somebody who wanted to develop iOS apps but didn't want to learn Objective-C? I mean, an Apple Developer account is $99 (I think per year), so it's not entirely unreasonable.
Ruboto: https://github.com/ruboto/ruboto/
I see your fizz buzz script and propose you attempt [these fun little problems.](http://projecteuler.net/problems) Click on About to learn more, but it's just a bunch of math problems which require the use of a computer to solve. (Like finding the sum of all the even Fibonacci Numbers smaller than 4,000,000) It's useful for getting used to the syntax of new languages. :) Enjoy!
My fiancee's brother introduced me to that site as well. I plan to try a bunch of them once I've gotten through the beginner book. :)
That "UNREGISTERED" on top can raise bad thoughts.
It's perfectly fine to use Ruby in a functional style! Use OO when your problem has truly hierarchical elements.
I hope that is the case. Stay alert, the internet is watching you.
Once you get past the first page or so, they start getting way more about dynamic programming and number theory than you'd expect.
I love that book! I didn't really understand 'self' (chp 5 I think) until I went through that chapter. For Rails I would suggest Michael Hartl's [tutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book) it's free and up to date!
David Black is an awesome author and Rubyist. and I heartily recommend him.
You can define a method for a single instance of an object? Whoa.
the best IDE so far is rubymine but it isn't free...but is cheap considering all the features than it includes, you can try it for a trial... if you came from java then maybe you know intellij idea, the best ide for java..rubymine is the same company... JEdit, emacs, vim, sublime, redcar, are text editor, these are faster than an ide and for dynamic languages maybe the best election, but if you're confortable with an ide rubymine is the best option if you wish try a txt editor, the best are emacs, sublime and textmate (only for mac)...emacs is really hard to learn but very customizable and powerfull, sublime is an alternative to textmate and very used...
I think the point was that you don't get an opportunity to evaluate whether it's any good before purchasing.
Apple already did that for him.
CTRL+B can run ruby in Sublime Text btw
I develop on a system that has 1.9 installed. Will the code be backward compatible with 1.8 ?
More precisely, this is the work of the Compiz grid extension, which is activated by default in Unity.
Hah, I posted this 5 years ago. I have no idea if it still works.
This is a pretty great writeup. I always feel like I'm just skimming the surface of what Pry can do for me just because I don't take the time to sit down and learn it. This make me want to plunk myself down for an hour or two and learn all the neat tricks.
Whoa, so many downvotes. I do not think that people got my message fully. It was a satire about Internet privacy and the quantity of information that a simple screenshot can posses. Sometimes the Internet really seems to be always watching everything you do. However, bobsalot, thank you for the reply and letting me know. I actually thought that the unregistered message (which I got when I tried sublime) was about piracy (I should check my eyes :) ). Didn't know about the beta clause.
Comments are welcome!
[Started!](https://github.com/Kerrick/project-euler-ruby)
Yeah, an uninstaller.
Well, I use SVN on Aptana. I'm not sure if Sublime has an equivalent good plugin with GUI. The one that I see on wbond is not free.
Ah, SVN, you poor soul. Y U NO USE GIT?
School Research project. They (IT dept) use SVN and provide a SVN server.
git-svn my friend if you must. Also, git requires no server, and Github is free for students.
how does that work ? is that SVN or github ?
git-svn is a tool that allows you to run git locally then commit things back to an svn repository. But if you aren't required to use their SVN server, just get a free student account.
That's the problem, I'm required to commit code to their server.
The only reason I used to install Aptana was for its static analysis stuff. Haven't found the equivalents in any other IDE or gem. Not that I've used it in the past 2 years though...
Remember Pry has a live documentation system, so typing `command -h` (or `help command`) should provide enough information for you to get started with a particular feature :) Also just try typing `help` by itself, we've improved it a lot recently so it should be easier to digest.
The plus/minus one is called Cola Git GUI and it's useful for staging/committing/pushing/pulling/merging stuff in a git repo. The cherry one is called Giggle and it's useful for browsing the files and commit/branching histories of a repo. [screenshot](http://i.imgur.com/3mX00.png)
Developing what with Ruby?
I don't know what do you want to develop but Ruby On Rails isn't the obvious choices for everything. Although I love it. I think, before developing in Ruby, you should learn Object Oriented paradigm. But you can learn it with Ruby.
### Technologies: * You already know you'll need to learn Ruby. * After you learn Ruby, learn Rails. They aren't the same thing. * You also need to understand HTML and CSS through-and-through, because even if you only do back-end work you'll be speaking HTML and CSS in your views along with your designers. * Learn the version control system of the shop you plan to work for. If you don't know which they use or if you're going on your own, learn git. * Get comfortable with the Unix command line (Terminal on Mac/Linux or Cygwin on Windows). * Learning JavaScript is a good idea as well, because you should understand what the front-end developers on your team are doing--or if you're on your own, you'll need to do client-side programming. * Find a good text editor (or IDE) and get used to it. _Really_ used to it. Learn its keyboard shortcuts, its plugins, its quirks. You'll be spending a lot of time in it. I suggest vim, emacs, Sublime Text 2, or Aptana Studio. ### Concepts: * You'll need to understand basic programming concepts. Object-orientation (in Ruby: methods, objects, classes, modules), controlling the flow of a program, debugging, running test units, and such. * You'll need to understand Model-View-Controller architecture, because that's the way Rails works. * You should understand the ins and outs of your version control system, including how to efficiently use branches and ideally how to use an online repository site (github, Google Code, etc.) * You should understand the way regular people interact with computers. Have a basic idea of UX (user experience) design. * You should know how to deploy an application ("to the cloud" if you will). Whether you deploy to a rails-specific host like Heroku or Engine Yard, or you deploy to your own Virtual Private Server, know how to get it up and keep it running. * You should know the basics of how HTTP works so that you can optimize loading times. Speed means a lot to your users even if they don't consciously realize it. There's probably more I didn't list here as well. ### Sarcastic Stuff ;-) * Always know your PHP put-downs. * Be ready to complain every time a new version of Ruby or Rails is released. I mean _sky-is-falling_ level complaining. * Be sure to tell everybody that you use Ruby on Rails. Don't just tell people that ask about you being a programmer, tell everybody. Tell your mother. Tell your pastor. Tell your neighbor's dog.
I'm mostly interested in web development. I have a good grasp of HTML and some Javascript knowledge, and I've been learning Ruby lately.. I'm just curious what other things would help make me a successful developer in terms of prerequisite skills, desired skills, etc.
maybe [this](http://c2.jam.net.ve/ID159w) help you
I'm currently learning Ruby from [The Well-Grounded Rubyist](http://www.manning.com/black2/). It's a great start if you don't know _that_ much about programming or ruby, though if you've never programmed anything at all it may go a bit fast. If you're _really_ new to programming I suggest reading the free [Eloquent JavaScript](http://eloquentjavascript.net/). It holds your hand and teaches you _good_ programming habits, albeit in JavaScript. Plus, the future of the web is likely going to be client-side-heavy, so learning JavaScript is a good idea.
IAMA lead engineer at a ruby/rails company. We would look for these skills, roughly in order of importance, from a junior engineer: * Some ruby/rails/java/other programming experience * Able to write ruby code using blocks + general familiarity with ruby syntax * Able to model the back end of a web app on a whiteboard (e.g. understanding ActiveRecord associations) * Able to write a method that takes a block as an argument in ruby. * Rails app code sample * javascript/jQuery/Prototype experience * SQL experience If you had absolutely no coding experience, then you should have everything but the javascript and SQL. Those are bonuses (but big bonuses).
The problem is that "web development" is a very large field nowadays. That implies a ton of things (if you want to do everything by yourself). Developing a simple website and developing a full social network with scalability, security, etc in mind is not the same thing. So the required skills are not the same neither. Being a "successful developer" takes practice. Starting from scratch, count around 4 years minimum, learning (practicing) everyday (and not 1h everyday, more like 10h). It's really not just theory, you need to make errors, to see bugs, to learn about security, performance, etc. You need to think as a programmer. I would say one of the most important thing is Dont Repeat Yourself. You need to learn to detect patterns and factorize everything.
Awesome stuff. Thanks for the tips!
Thank you so much for this! I wish I had this years ago when I was just starting out. Do you have any idea how to get into using more specific technologies? For example, using memcache, app deployment without heroku, redis, mongoDB etc. All these specific things are often required to be hired, but I never get a chance to work with them because I don't have enough working experience with Rails.
That's pretty much all you need to get started, along with a good understanding of database schema. I wouldn't worry too much about diving super deep into Ruby first. As long as you have a good understanding of the basics, you can learn the rest as you go. Just start making Rails apps :)
sorry about that. But here I think people can understand that how to handel. It was first try to write something like this. Will run code before posting in blog. thanks for suggestions.
Isn't [Locomotive](http://locomotivecms.com/) exactly that?
True, it might not be the at the same level as RubyMotion but at least ruby programmers will be able to develop for the iOS, something which is currently not possible.
Depends mostly on shared hosting. Hostmonster for example allows you to install gems. However if you use some exotic gems that need C extension compilation you might run into issues. On the other hand basic C extensions (source packages) for mysql, postgres gems are available on most hosts. 
The title and the article have no relations together.. And the article is funny. Why he's not using pkill? Or even killall -9 process_name? Or even kill -9 \`pidof processname\` I suppose this is the article you wanted to link to: http://glen-noronha.blogspot.in/2011/11/recursively-listing-directories-and.html The code is pretty long to do such a simple thing.. This is pretty hard to read ruby code. You should look more in depth at the Dir class, especially the [].