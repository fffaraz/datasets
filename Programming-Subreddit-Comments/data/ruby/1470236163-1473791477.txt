I know, I was just pointing out that it was weird.
I've seen Crystal before but this article has forced me to give it a try. 
No idea, it broke for me this morning, I'd love to know myself.
I generally think DSL's are not a great idea and I would find another way to accomplish a task.
I'm put off by the looks like ruby, but looking like ruby isn't a goal bit. I can just sense an uncanny valley that would hit when I'd try to do something I'd do in Ruby and have it not work. It'd be much cooler to just take the YARV instructions from the ruby code and use LLVM to compile that to a super-fast binary. That said, I'd like to try it out, but I've got a backlog of things "I'd like to try out".
gah, rake. 
https://github.com/ruby/rake/compare/v11.2.1...v11.2.2 &gt; +Bug fixes: &gt; + &gt; +* Fix unexpected behavior with multiple dependencies on Rake::TestTask Hooray for github. Hooray for standardized tagging of versions in your repo. Slightly less hooray for a bug fix message that I have no idea what it means. 
Just wondering what the post title of "double check your Gemfiles" means, if it's referring to anything. I usually DON'T upgrade rake because they have introduced unexpected bugs with Rails as recently as 11.0.
Well u seem to have yourbmind made up so there's really no point in explaining anything but gems like factory-girl and activerecord finders can't be done without a metaprogrammi ng. And those are just off the top of my head.
X-Post referenced from /r/programming by /u/schneems [How to fix a bug in open source software](https://www.reddit.com/r/programming/comments/4vzba6/how_to_fix_a_bug_in_open_source_software/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Big fan of your work, so nice to know we align on that :)
They absolutely can be done without metaprogramming, just not with the same syntax.
Sad but because of "syntax is kinda Ruby, but it's not the goal" when you try to translate the Ruby code into Crystal, you end up with diff of 95% of lines rewritten, so while it's still pretty by structure, it's not the less time-consuming for Rubyist than to rewrite in, for example, Go.
Wasn't block splatting added in 0.18?
IDK. &gt; Nakilon created this gist on Nov 8, 2015
It depends on what code you're porting. If it's the gist you provided, then it's going to be a lot. But that gist seems designed to have a large % diff. I ported over ActiveSupport::Inflector (and its cousin, Inflections), and there was ~75% that was just straight copied over. Most of the changes needed were simple to do, such as changing single quoted strings to double quotes. 
I'm fine with extra code if it is more explicit. I've programmed long enough to know magic is the devil.
That gist is a computer program, I mean a real program -- it is about to program the computer to compute. It is about A.I. solving a puzzle for few minutes. Source files with boilerplates and abused OOP of unnecessary classes of one-line-long unnecessary hello-worlding methods would probably have smaller diffs.
Oh, ok. Still, I was surprised by the tone of the "questions". I am unconvinced that there will be enough good questions to allow for an interesting interview.
Woah, that's really cool! Thanks for Sidekiq, btw.
Thanks I feel like a bit of a dunce for not catching that. I would have used the `each_with_index method` but I want the counter to start at 1 and not 0. 
Great write-up. If anyone is interested in Jekyll I've put together an [Awesome Jekyll page](https://github.com/planetjekyll/awesome-jekyll). If you want to compare Jekyll to Middleman, Metalsmith, Hugo, and friends you might browse the [Stay Static samples](https://github.com/staystatic/staystatic). Cheers. PS: For more Static Site News you invited to follow the [@statictimes](https://twitter.com/statictimes).
I couldn't replicate this (ruby 2.1.5).
They withdrew rake 11.3.1., so check to make sure you aren't currently accidentally using it. Your `Gemfile.lock` is probably specifically the thing to check. 
I wish the article went with a higher top count. Having Rails, etc. to me seem like givens where as I'd be more interested in seeing the next popular
Ruby has implicit returns, the value a method returns will be the value of the last line the method executes. Of course there is nothing wrong with the explicit version, and it is sometimes necessary, but returning implicitly is a little cleaner.
Beginners might as well just use Michael Hartl's railstutorial.org (also free book) which is already updated to Rails 5.
If you'd like to understand what the big deal is, then [read this](http://blog.rubygems.org/2015/04/13/permadelete-on-yank.html). Tl;dr: For a long time, gem authors were only able to "soft delete" uploads on RubyGems.org. About 1 year ago, the policy changed - and gems can now be *hard* deleted. This is controversial. The old policy was in place for good reason, and only changed after lots of discussions around the pros and cons. See also: How the [removal of a NodeJS package](http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) broke thousands of projects, a few months ago.
I have skimmed through Daniel's book. Hartl's videos complements his book, without watching those you miss out on a lot of carefully explained things. Hartl's tutorial is very beginner-friendly and I don't think an additional beginner book is necessary to complement his tutorial. IMHO. And certainly new/budding Rails developers shouldn't wait for any more material to get started, a Rails 5 updated tutorial is already here, use that. Don't wait.
Right on, things can be confusing. If you click on the OP link, you can see one of the screenshots is the rubygems.org version list, with a big red arrow pointing out that there's an 11.2.0 and 11.2.2, but no 11.2.1. 
I was more or less generalizing. A more specific answer may have called out express or web frameworks in node. Based on your definition of framework I guess I could see an argument made that node is a framework; I think a closer analogy is .net is to c# as node is to JavaScript. I would say it's more of a standard or runtime library, something that lives closer to the actual language itself. What u think?
So this is using implicit returns as the other poster mentioned. This looks much cleaner than what I initially presented. Appreciate the help, thanks!
Thanks!
That's why I put this link in this subreddit. My love for Jekyll.
Or just use Bundlers inline Gemfile feature: require 'bundler/inline' gemfile(true) do # `true` means install on demand source 'https://rubygems.org' gem 'faraday' end
That's basically the reason why I wrote this blog post: https://crystal-lang.org/2016/07/15/fibonacci-benchmark.html But it can't be helped, fibonacci and factorial are one of the easiest and simplest programs to compare benchmarks. Also note that in my article I talk about adding the possibility of mutating BigInt, and I think we'll eventually add that into the standard library.
17) sal = Person.new('sal', 'toure') ^ this is the ArgumentError but your greet method should be like this : def greet(person) "Hi #{person.other_name}, my name is #{person.name} " end
Thanks!!!! it work 
This is really impressive. I'm in the process of building an app at the moment with the intent of learning my way around ActionCable. Figuring out how to display new information as it comes in is definitely a new challenge for me. That being said, these tools and guides really help me understand what I need to do. 
Check out [websocketd](http://websocketd.com) which will pipe stdin/stdout to a WebSocket. Then you can write a simple single-page app as a client using JS.
`instance_eval` is the what you are looking for. my_obj = My_object.new my_obj.instance_eval do some_method() other_method() end
You could use instance_eval in a method. Monkey patching object lies the path to the dark side. def do_something(&amp;block) my_obj.instance_eval(&amp;block) if block_given? end do_something do some_method other_method end
That's why he's not using Python.
Sinatra might be what you're looking for... It's a bit simpler than rails. And is suited for this type of thing. http://www.theodinproject.com/ruby-on-rails/sinatra-basics
It's real code from metasploit: https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/android/browser/samsung_knox_smdm_url.rb#L62
Nifty, but that isn't done in the screenshot...it's just a bunch of really fucked up indentation.
he learned after uploading w0rm.py
Nice find, this was my first thought too.
Well.. metasploit, so that doesn't surprise me.
nope. major mistake, unrealistic is exactly what that says. you have to fight your editor so hard to end up with that code. (don't watch the show, is the scene set at a perl convention?) Edit: turned meanness down from 9 to 7; thanks /u/rolfea
Well he is in vim, at least! The episode shows him using Kali Linux and the Metasploit framework, which is indeed written in Ruby.
That indentation... this show needs to have a cross-over episode with RuboCop.
you are the worst 
I'm super new to Ruby, so forgive me if this is obvious, but what's the benefit of calling Hash.new(0) instead of @server_payloads = {}?
You can also do something like, arr.to_enum.with_index(1).each do |item, i| # ... end
Hmmm. I can't remember exactly when or which gems now since I've started using one or two versions previous when doing more hobby work.
Every value in the hash is initialized with 0 rather than nil. So rather than @server_payloads[:z] ||= 0 @server_payloads[:z] += 1 you just write @server_payloads[:z] += 1 You can do more exotic things by using a block to initialize: [8] pry(main)&gt; z = Hash.new { |h, k| h[k] = [] } =&gt; {} [9] pry(main)&gt; z[:x] &lt;&lt; 1 =&gt; [1] [10] pry(main)&gt; z =&gt; {:x=&gt;[1]} 
I absolutely love pry. That's all I had to say here.
It's especially handy when you want to define methods using runtime data (yes I know it sounds like a terrible idea but it's come in handy before)
A lib like [pad_utils](https://rubygems.org/gems/pad_utils) would allow you to do just that. It has methods like [insert_after_first](http://padutils.padstone.io/PadUtils.html#insert_after_first-class_method) or [replace_in_file](http://padutils.padstone.io/PadUtils.html#replace_in_file-class_method).
Thanks for teh learnings. Turns out I was part of a telephone game. The "knowledge" came from [this SO answer](http://stackoverflow.com/a/4028362/386665) which came from [this example](https://www.ruby-forum.com/topic/1210854) which seems to only apply to splat method arguments (a guessed claim that might itself be false).
Oh, good point, I missed the wrongly indented `end` on what I thought was the 'outer' def. 
[They did, but apparently messed it up or something](https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/android/browser/samsung_knox_smdm_url.rb#L62)
Try this: story = {:story =&gt; {:content =&gt; params[:body]}}
Apart from the fact that this was taken directly from Metasploit as others have said, I think this is most likely. I haven't watched the second season yet, but given that Elliot is a hacker who's more than a little neurotic, it probably fits his character to write messy-styled code, especially if he's in a rush and/or copying it piecemeal from somewhere.
The reason it reloads live is a [feature of the underlying language](http://erlang.org/doc/reference_manual/code_loading.html), [erlang](http://erlang.org).
Thanks! That did it, how ever, is there a way to only do it in one place (IE, I have Sup 3 times in the file, and I only want to replace the second one) 
Yeah, I know how that site works, thanks.
I know that DNSSimple is using Hanami, and they've hired its creator Luca Guidi. Simone Carletti gave [a talk](http://confreaks.tv/videos/railsconf2016-developing-and-maintaining-a-platform-with-rails-and-lotus) about it at Rails Conf this year. 
This is a topic which I am interested in a lot too. Just wondering, how much of an improvement does nested transactions give? I see the article list 300 tests and 7.8s. What is the test duration without nested transactions?
no, that's not how HTTP works. 
Great post, thank you Mike. 
Most people I've seen use a text editor and a command line to develop ruby. Is there a good reason to use an ide with a dynamically typed language like ruby?
https://www.youtube.com/watch?v=4FFG1NqKzCg
It can't be done like that. You'll need to use Javascript to fetch the updates. You should also looking into streaming with Sinatra as that may be of use to you.
https://en.wikipedia.org/wiki/Chunked_transfer_encoding https://en.wikipedia.org/wiki/Server-sent_events
You can use ReactJS! (Which has server-side rendering), ...of course ReactJS is written in JavaScript, but you can also use Opal (a library that compiles ruby to JavaScript) and that works with ReactJS too...
Yes, it makes perfect sense. I didn't look at it that way. I'm learning Sinatra (and web development) and thought maybe there was a way to do it without the need to use JavaScript, but if it needs to be done client-side I guess I have no other option.
Thanks. I thought maybe it could be done without the need to use JavaScript, but it seems I need to follow that path. I'll check about streaming with Sinatra.
Thanks. This was a good read. I still have a lot to learn.
Basically, I was trying to do something like this: @message1 sleep 0.5 @message2 sleep 0.5 @message3 sleep 0.5 Thought maybe there was a way to do it without the need to use JavaScript, but am going to try to do it that way.
Thanks! I'm going to check both.
How does the time factor affect which language is used?
Not sure about Sinatra, but this is baked into Rails. http://api.rubyonrails.org/classes/ActionController/Streaming.html
GET, POST, UPDATE, and DELETE do make a lot of sense when thinking about databases. If you only think about web applications being some veneer and business logic sitting on top of a database, then yeah, everything sounds like it's one of these 4 verbs. Start thinking outside of the box of just a database and you quickly find these verbs lacking. Streaming video and audio, for example, are not implemented in such a way. Any type of experience that requires opening a channel between client and server is not likely implemented how you're thinking everything is implemented.
Ok, so there's a few things that can be improved here. 1) Try to stay away from writing code that depends on hardcoded indices like this when 'Boston' data[0].each 2) The data structure can be optimized, instead of multiple hashes use one and use better formatting data = [ { 'Boston' =&gt; { 'New York' =&gt; '12:02', 'New Haven' =&gt; '13:50', 'Providence' =&gt; '15:13', 'Boston' =&gt; '16:36'} }, { 'Chicago' =&gt; { 'New York' =&gt; '8:19', 'Albany' =&gt; '11:40', 'Buffalo' =&gt; '17:21', 'Cleveland' =&gt; '21:12', 'Toledo' =&gt; '23:18', 'Chicago' =&gt; '5:28' } } ] to data = { 'Boston' =&gt; { 'New York' =&gt; '12:02', 'New Haven' =&gt; '13:50', 'Providence' =&gt; '15:13', 'Boston' =&gt; '16:36' }, 'Chicago' =&gt; { 'New York' =&gt; '8:19', 'Albany' =&gt; '11:40', 'Buffalo' =&gt; '17:21', 'Cleveland' =&gt; '21:12', 'Toledo' =&gt; '23:18', 'Chicago' =&gt; '5:28' } } 3) when you do this data[1].each do |j| data[1][j].each do |jkey, jval| puts " #{jkey} -&gt; #{jval}" end end You have assigned the hash to j, so basically you are trying to call something that doesn't exist, like this example in irb 2.3.1 :064 &gt; j = data[1].first =&gt; ["Chicago", {"New York"=&gt;"8:19", "Albany"=&gt;"11:40", "Buffalo"=&gt;"17:21", "Cleveland"=&gt;"21:12", "Toledo"=&gt;"23:18", "Chicago"=&gt;"5:28"}] 2.3.1 :065 &gt; data[1][j] =&gt; nil 2.3.1 :066 &gt; You could use data[1].keys but that is just sort of backwards thinking. 4) Use more dynamic code, a neat feature with using hashes is the .has_key?(foo) function so you could test to see if the key is there then retrieve then output the values team = gets.chomp if data.has_key?(team) data[team].each {|k,v| puts "#{k} -&gt; #{v}"} else puts 'No team available' end 
I believe those are specifically the requests for HTTP. Somebody may correct me on this since I don't know how the other protocols work, but they may use different approaches.
Everyone forgets PATCH. 
That's kind of the theory of the "REST" API, what you've just caught on to. It works in general, but sometimes doesn't, as a generalized theory. 
And HEAD
Yes, that's exactly the theory behind the [Kingdom of Nouns](http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html).
About copying the gems. Does this make any problems with gems that have C code?
I haven't used this particular gem, but I can vouch for this general approach if your test suite / app has expensive db stuff (giant models, lots of save hooks, etc.)... Canvas-LMS (https://github.com/instructure/canvas-lms) has about 18k specs (excluding selenium), and using nested context-level transactions shaved 25% off the total runtime (could be more, we just haven't applied it everywhere). In our case we made a gem (https://github.com/instructure/once-ler) that adds `before(:once)`, `let_once`, etc. ... they behave like `before`, `let`, etc. but peform like `before(:all)` thanks to nested transactions under the hood. It's worked out really well for us so far.
sometimes, yes. 
Typo in this line: &gt; Let‚Äôs write a simple task an put is the file named `Rakefile` in the root of our project:
What does this do, if you don't mind me asking? EDIT: I just read in the docs this makes headers be silently swallowed but I don't understand.
I did it the way you said, it all works great. I don't need the values to be uppercase ever, they just come lowercase because that's how the file I'm getting them from is but since it's SQL it's supposed to be uppercase. Thanks though, I did what you said and it all worked. It's scary, I don't know what to do now... EDIT: Side note, do you know if it's bad to push CSV files to DB's this way? I'll be running this program on a few hundred servers every day at like midnight and the CSV file I have to use at work contains around 10k entries instead of just 30 like mine lol.
``` INSERT INTO products (product_no, name, price) VALUES (1, 'Cheese', 9.99), (2, 'Bread', 1.99), (3, 'Milk', 2.99); ``` Or look at `COPY`. 
Real hackers dont need your weakass leet either? Wow, that hurt my eyes.
Use [parameterized queries](http://sequel.jeremyevans.net/rdoc/files/doc/prepared_statements_rdoc.html) to avoid data escaping the quotes, aka SQL injection.
That's amazing. LOL, I will definitely be using this. 
I don't' think this is related to the Ruby Programming language at all. Probably needs to be moved to the appropriate sub-reddit. 
this dumb bot posts like every day. thanks for the easy account creation, reddit i bet you anything the joke is that its written in ruby
Dumbass.
Thank you it really helped :-)
Thank you :-)
Works like a charm! thanks!
/u/zverok_kha's regex might look like it works at first, but there's an issue with it: irb(main):001:0&gt; "I am\ntrue" =~ /^true|false$/ =&gt; 5 irb(main):002:0&gt; "true false" =~ /^true|false$/ =&gt; 0 irb(main):003:0&gt; "afalse" =~ /^true|false$/ =&gt; 1 `^` matches the beginning of a line and `$` matches the end of a line. They're also being attached to the words on either side, so you're really matching lines that begin with "true" and/or end with "false". To match the beginning of the entire string use `\A`, and to match the end of the entire string use `\z`. You also need to enclose `true|false` in parentheses to make sure you're matching just the words and not "starts with true" and "ends with false". --- `/\A(true|false)\z/` is what you should be using. If you don't need to use the value, you can make it a non-capturing match with `/\A(?:true|false)\z/`.
Is there any advantage to doing it this way instead of having a simple cronjob that calls the letsencrypt client and have it renew the certificate automatically? (Source: https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-14-04 )
Yes, but you should really be running it on a cron not because it simplifies management but in the event Lets Encrypt issues a revocation, your server is on top of it and can issue a new certificate shortly after the prior one is revoked. LE/Custom ACME server issues a bad cert or a key gets leaked (which is entirely possible and fairly common), the time it takes for them to issue a revocation and start issuing new certificates should be hours, not days or weeks. Putting it on a cron makes it easy for the service to handle revocation and reissuing, without requiring a button. Meaning you can rotate your certificate 28 times a week if you'd like, with no penalty to you and no extra work on your part. Seems like if you're going through all the effort of doing certs through LE, why neuter it and get rid of one of the biggest benefits?
I wonder if she heard about the ruby tuesday closures?
Talk of other build tools, but no mention of make? üôÅ
Good point. I use cron and rotate certificate weekly and as you said I could do renewal more often than that. It's easy to change cron configuration to run rake task every 6 hours: http://beyondscheme.com/2016/setting-up-automated-ssl-for-rails-app-with-lets-encrypt#add-certificate-renewal-task-to-cron
Valid point! I'll take a look at it in the next post. thanks :) 
&gt; llvm is a compiler framework, but Ruby is an interpreted language I think the question is why does it have to be an interpreted language? Why can't it be compiled just-in-time, as languages like JavaScript are? And could it use LLVM to do that? LLVM helps you to emit great machine code, but if you use it to emit slow code, it won't help you magically make it faster. The Rubinius project have tried using LLVM to make Ruby fast, and it hasn't really worked because they use it to emit code that's not much better than what the interpreter was doing. The work to emit good code from Ruby, using LLVM or something else, is a really hard problem. It would need a big team and tens or hundreds of millions of dollars. We know how to do it all, but we also know it's a lot of work. Other options like Truffle (which I work on) take an approach which is much simpler conceptually and also actually produces much better results, but it's far too radical for Ruby to adopt. They don't want the massive disruption it would cause. Evan Phoenix has an interesting idea about a half-way between what Truffle does and LLVM, but it would be a major project and you'd need a team of experts working on it full time. Where would you get them from and who's going to pay them? It's a tricky problem for Ruby.
Cool! My implementation of this is [here](https://rubygems.org/gems/linnaeus) and [here](https://github.com/djcp/linnaeus). Nice tear-down of the math parts.
I don't think your code is the problem, you need to consider the DB involved. I would guess that the DBs throwing this error have some other code which is holding a lock on a table when you attempt this, if that lock doesn't expire within the timeout it will complain. btw 'several thousand rows' is tiny, the size is extremely unlikely to be the issue, but rather the workload it's under. 
I'd try using it via [Sequel](http://sequel.jeremyevans.net/). The JDBC API direct is kinda confusing and low-level and hard to work with, although I don't know enough about it to identify any bugs in your code. (But do you need to close the connection as well as the statement, if you're done with it?) If you're getting the same problem via Java without JRuby even involved, then it's not really a JRuby problem, you might try asking in a Java forum with your pure Java code. Once you get it working in Java, it should work the same in JRuby. If you really want to use JDBC API directly. But it also may be that there's something wrong with the database you are connecting to. You say you don't have the problem with your "own" database, even though it's the same version of the same database, so the one you do have a problem with must not be "your own", and must differ in some way? Perhaps just load on it, it may not be able to truncate the table because it's busy doing other things? I dunno, I'm no Oracle expert, have barely used it. It may be that what you have is an Oracle question, rather than a JRuby or Java question. "several thousand rows" is not a large database, that's a small database. But if it were me, the first thing I'd do is use it via Sequel to not be dealing with the JDBC API directly, perhaps without knowing what I was doing and using it incorrectly. Sequel provide a higher-level and harder to make low-level mistakes API. 
It works on the "another location" database via your SQL Developer tool too? 
Sorry if I seemed condescending, your original post gave me the impression that you hadn't understood the difference between compiled and interpreted languages, which is clearly false. &gt; [...] does it have to be an interpreted language? One of the most important things in Ruby development is metaprogramming. If you look at Crystal, a compiled language inspired by Ruby, many of the metaprogramming abilities we are used to from Ruby are not available, as it is very difficult to do this in "static" compiled code. &gt; Why can't it be compiled just-in-time [...]? With 1.9 Ruby switched from the original implementations to what used to be called YARV, which is JIT-based. A completely static interpreter would never be able to achieve even the "slow" speeds you are used to from Ruby. Another important thing I'd like to say that Ruby was built around the concept of valuing developer time (through convenience) over computer time. You shouldn't write your driver/OS/whatever in Ruby, just like you probably shouldn't write your shell script/webapp in C/C++. EDIT: I should probably mention that I am neither a true Ruby expert, nor a compiler/programming language engineer. Take what I wrote above as the opinions of a (I'd like to think) well informed hobbyist.
https://github.com/rubyomr-preview/rubyomr-preview - this was promising
it's helpful for me. thanks!
Not provided natively by RSpec. Use [shoulda-matchers](http://matchers.shoulda.io/docs/v3.1.1/) gem. Produced by highly-regarded thoughtbot.
Things like metaprogramming are difficult to achieve in a compiler, but we do know the techniques to solve them all. The only thing holding us back is time and money to implement them in Ruby. I maintain a website listing papers that explain the solutions http://rubybib.org. Valuing developer time is exactly why Ruby needs a JIT - the JIT should do the hard work of optimising your Ruby code for you, saving even more developer time.
Thanks! Yes, I'm actually kind of pissed that not enough ML libraries exist in the Ruby world. I'd rather use Ruby than Python.
Looks nice and much more refined than my implementation. I'm curious though. Any specific reason for using Redis? Or was that just a thing you wanted to do?
There are two schools of thought on testing ActiveRecord associations. Testing Directly ----------------- The first approach is to directly test whether the association has been configured on the model class. You can use the [shoulda-matchers gem](https://github.com/thoughtbot/shoulda-matchers) (like doublecastle mentioned) and it would look something like this: RSpec.describe Post do it { should have_one(:author) } end Or you can use the `reflect_on_association` class method provided by ActiveRecord to see if the association exists: it 'should have_one author' do expect(Post.reflect_on_association(:author).macro).to eq(:has_one) end Testing Behaviour -------------------- Some people believe that you should [test _behaviour_, not configuration](http://naildrivin5.com/blog/2016/05/23/test-behavior-not-configuration.html), and so they don't directly test that the association exists. Instead, they test that the object works the way it's supposed to, in regard to the association. A test in this style might look something like this: it 'has an author' do author = User.new(name: 'Drew') post = Post.new(author: author) expect(post.author.name).to eq('Drew') end It's not _directly_ testing that the association exists, but it will fail if the association doesn't exist. I hope that helps!
Bookmarked.
The next big step is getting the openssl library working. That should open up a lot more use-cases (like running RubyGems).
cool stuff and 74% accuracy for first try +1
Honestly, see if you can report him on any site he bothers you. Make him the site administrator's problem, it's not your responsibility to deal with users misusing a site to harass other users. Block him on everything. Find out where he works and who his manager is and bitch until he either backs off of his own volition or someone else makes him. If he is consistently harassing you everywhere, then it's ok to push back so you can use the internet in peace.
He was out of line, in my opinion. Yes, we would rather you send emails that we can easily mark as spam. Not comment on OSS projects.
I really don't want to report anyone, I was just surprised to his reaction to my "stop spamming" comment. He completely picked up the wrong context and turned it against me calling him names
I've been addicted to DRYing my code the past few months. It's very satisfying to refactor a working piece of code to make it smaller and easier to read, and finding repetitive code is one of the first things I look for. 
Yeah, fuck that guy. I don't know how he thinks he can be a succesful recruiter by pissing off the people he's trying to recruit anyway! 
mirror to subredit discussion /r/programming https://www.reddit.com/r/programming/comments/4wwh7j/link_to_discussion_recruiter_is_spamming_comment/ 
How can a gem that's existed for at more than 11 years, before Rails 1.0 final -- still be at version 0.5 without a 1.0 release! 
Hi everyone, I've created new Github organisation and project it-recruitment-code-of-conduct/it-recruitment-code-of-conduct that I'm hoping will evolve into community driven guide for recruiters to follow (even if only 1 recruiter ever read it) and resource to reference recruiters to in similar future events. I've included this particular case in this PR https://github.com/it-recruitment-code-of-conduct/it-recruitment-code-of-conduct/pull/2 Can you pls review and give me some opinions ? + more content that bothers you from recruiters would be appreciated in PR . Thank you 
There is a very nice German word for it: Hauptversionsnummernerh√∂hungsangst. (Fear of increasing the major version number.)
I am also sub to a bunch of medical subreddits and was really confused when this app didn't seem to be all that useful for medical documentation. For personal stuff, and back when I was a sysadmin, I documented everything in markdown text files so this would be very useful for that.
I prefer to keep my views free of any JS. Thanks for the pronunciation correction. 
I'm talking about your edit.js.erb view, why would you inject the whole JS file again into it, effectively redefining the date_picker_init function, rather than just calling the already existing date_picker_init() function in the same spot? I mean this: $("#remote_container").html("&lt;%= j render "edit" %&gt;"); $("#edit_contact").modal("show"); date_picker_init(); Vs this: $("#remote_container").html("&lt;%= j render "edit" %&gt;"); $("#edit_contact").modal("show"); $.getScript("&lt;%= asset_path "date_picker_init" %&gt;"); Additionally, getScript requires another server round-trip. 
Eh it's not that big of a deal. More funny than anything.
You're great! Thank you kindly!
It's amusing to see responses to your posts Chris from people that are not yet familiar with the work you do :). Anyway I have nothing to add beyond that I would really like JRuby/Truffle+Graal to be production ready. Thank you for doing amazing work to speed Ruby up!
Well I know what I'm doing today. If this works, it could be really awesome for a microservices platform with 100+ repos. Thanks!
Awesome! let us know how it went?
That is the height of dork humor.
Lifetime of free enterprise edition if I do? I found the ‚ù§Ô∏è.
There's a bug in the code. See my PR: https://github.com/mperham/sidekiq/pull/3098
I like the fact that several people have found this: https://www.reddit.com/r/ruby/duplicates/4x2eqy/found_an_easter_egg_in_sidekiq_this_morning/ and yet because they linked to master, it now points to random parts of the same file. 
Feel free to ask any questions if it will help you figure out if Doctor can be used for your medical documentation usecase.
Counter-offer: how about a firm handshake and a free Sidekiq shirt if you go to Rubyconf this year?
Good read. I've been struggling with a similar bug for about a year now on and off, so this motivates me to debug and figure it out!
Update. This article contains a few inaccuracies. Please see the updated version here: http://www.viva64.com/en/b/0418/
Methods are the foundation (of any language, really). They let you build custom instructions/recipes/tricks/operations/actions for everything. Arrays and hashes are just containers. Arrays are always number indexed, so when you want an element you use its position to fetch it: a = [1, 2, 'hello', 5.0] a[0] is 1, a[1] is 2, etc Hashes are key based/indexed: h = {a: 1, b:2, 100: 'hello'} h[:a] is 1, h[:b] is 2, h[100] is 'hello' Both can store any value, typically, and that's quite powerful to think of. So, both are containers. Arrays always have number keys, which correspond to their position. Hashes can have number or word keys. There are several nuances depending on the language, but these concepts are pretty universal.
Hah. I knew it was going to be display when I started reading. It's really fun because people often forget it exists and it often can be called without failing. I have seen the same case before when someone made q custom display method to retunr html, then later someone figured it name clashea and renames it but then forgets to find all references. 
yeah, I just noticed that it seemed to have changed the format of the version on output! Gem::Version.new("2.0.0-rc1").to_s # =&gt; "2.0.0.pre.rc1" Weird. I guess rubygems really wants there to be a '.pre' in there? I dunno. Okay, so this is actually a better and shorter way to do it anyway, actually: ["2.0.0", "2.0.0-rc1", "2.0.0-rc2", "2.0.0-preview1"].sort_by {|s| Gem::Version.new(s) } # =&gt; ["2.0.0-preview1", "2.0.0-rc1", "2.0.0-rc2", "2.0.0"] There we go, the OP gem in one line! I'm not sure if you're saying `preview` is supposed to come _after_ `rc1` and `rc2`, but I believe whatever way rubygems itself sorts, that is what bundler and rubygems are actually going to use to decide what version comes after what other version, so is by definition 'right' -- which is another reason to use rubygems to do sorting instead of your own reimplementation, you are guaranteed to get the same sort order that rubygems uses where it matters. &gt; And I just realize that due to the nature of these version patterns, the gem could just be: &gt; versions.sort If you mean what I think you mean, then actually nope. ['2.0.5', '10.0.0', '2.0.22',].sort =&gt; ["10.0.0", "2.0.22", "2.0.5"] PS: Here's another useful thing you can do with rubygems api: if Gem.loaded_specs["some_gem_name"].version &gt;= Gem::Version.new('2.0') puts "some_gem_name needs to be at least version 2.0, but the loaded version isn't!" end
It was worse when it was still called `Object#id`.
Still learning here. Will give it a try, thanks for the quick response. Will update once I get chance to edit my yml
The sqlite3 driver simply opens a file, reads from and writes to the file, and when it's done, closes the file. If multiple processes (programs) need to read and write the file simultaneously, the driver relies on mechanisms provided by the operating system to lock and unlock the file to prevent data corruption. By contrast, postgres and mysql drivers establish connections to other daemons (background processes). Instead of directly reading from and writing to files, the drivers send requests to the daemon and receive responses back. The daemon is responsible for managing concurrent (simultaneous) access, and for handling files and locking. The daemon has to be started (turned on) in order for the driver to connect to it. 
 display itself load send select test trust # and so on There‚Äôs plenty of really weird stuff coming from either `Kernel` or `Object`; also this: irb(main):023:0&gt; Object.new.private_methods.size =&gt; 75 irb(main):024:0&gt; Object.new.methods.size =&gt; 61 I sometimes wonder if it‚Äôd be a good idea to come up with a smaller base object class inheriting from `BasicObject` and adding just a few methods (`inspect`, and maybe some stuff useful for meta-programming), and use this one instead of `Object`.
To present it a bit differently than mwpastore: - SQLite3 runs "in-process", when you start your application it becomes an SQLite3 "server" as well as client (not exactly a server per-say but that's the idea) - Postgres and MySQL are standalone servers, your application is completely independent and connects to it. Hence you have to start both in order to be able to use them.
The purpose of Demeter is to shield any callers of a class 'Project' from its internal structure, making it easier to change. For example, having a method 'Project#user__name' shields any callers of 'Project' from a potential change of the method name in 'User'. Generating prefixed proxies (delegators) for each method on 'User' onto 'Project' kind of defeats the purpose of Demeter since it no longer shields callers of 'Project' from changes in 'User'.
This is a very important topic, and the blog entry reflects a common and incorrect perspective. An example of a violation of the Law of Demeter is a situation where Alice is in a store buying a backpack, Bob is the salesperson, and you write the following code: `store.salesperson.sell_backpack_to(alice)`. There is no reason to reach into the store to find the salesperson and to send the message `sell_backpack_to` from there. The "correct" way of writing the code is to have the salesperson object available, so you can do `bob.sell_backpack_to(alice)`, or, even better, `Transaction.new(seller: bob, buyer: alice, items: [backpack]).call`. The blog entry discusses two ideas: 1. ` string.strip.downcase.tr_s('^[a-z0-9]', '-‚Äò) ` 2. `project.user.name` The first one is not a violation of the Law of Demeter because it's a set of transformations. We're calling `downcase` on whatever came out of `string.strip`, then `tr_s` on whatever came out of `downcase`. The second use case is more complex: 1. This is a Rail app, so `Project belongs_to :user` 2. `name` is a property on `user` 3. This data is likely joined from SQL with ActiveRecord (though even if it comes from a different store, the point remains) 4. It suggests using delegation to "remove" the violation We should not call `project.user.name` because it *does not make sense* to refer to a project without knowing the user it belongs to **IN THE CONTEXT OF BUSINESS LOGIC** (*). **A project and its user should therefore already be two separate objects you have access to in your code.** More importantly though, **the project and its user refer to the same logical business unit**, which might be called "project information" or something similar. The blog entry then suggests using ActiveRecord's `delegate` method, which is named like the Ruby `delegate`, to "remove" the Demeter violation. All it does is hide the violation, and here is the reason why: **THE LOGIC IS THE SAME**. `Project.user_name` where `def user_name ; self.user.name ; end` is the same thing as `project.user.name`... And the reason why is because that's how the code is built. There is no shift in perspective, no new way to refer to the information. **The correct solution here is to not try to get to the user's name through the project.** That's it. That's how you avoid a violation of the Law of Demeter. ---- (*): In scripts, sometimes you gotta do what you gotta do. Hope this helps.
Sqlite3 doesn't need a server, it's just a library loaded by your application and stores its database in a single file. It has many advantages over MySQL and Postgres for development since you don't need to start a server, authenticate, create a database, make a user, grant privs, and the 20 other things you need to do to set up a database on a "real" database server. However, it's generally not as fast and doesn't scale as well as MySQL or Postgres, so it's not usually used in production, just development.
 Called id for nil, which would mistakenly be 4 -- if you really wanted the id of nil, use object_id
I guess theoretically it gives you the _option_ of implementing that method locally at a future point, keeping it's API the same, to continue shielding the caller when needed. But yeah, I'm suspicious of the auto-delegation too. I think it's good to know and understand the Law of Demeter and what it's intended to do -- which I think the OP really could have gone into more about. If you're just cargo culting it with auto-delegation, you're likely to not actually get as much change-management protection as you think you're getting. 
In theory, `def user_name ; self.user.name ; end` is different because it gives you _one_ place that the `project.user.name` appears, so if a project's `user_name` is later to be determined differently, you have one place to change the implementation, and all callers don't have to be modified at all. Which is of course the point of the Law of Demeter. But I think you're thrust is correct. And just madly applying automatic delegation all over the place to lots and lots of methods is unlikely to actually give you the kind of change-proofing you want. But personally, my conclusion is that `project.user.name` in a Rails app is probably just fine. Is the invariant that a project always has one and only one user likely to change? If it does change, you're probably going to have a whole lot of code to change anyway. 
sqlite3 is a database, just like postgres and mysql, but it is not a _service_ -- and postgres and mysql are. A _service_ in this context is a computer program that is running all the time, communicating with other computer programs over a network such as the Internet or a home wireless network. Services such as postgres and mysql can actually be configured to start automatically when your computer boots. However, on some computer setups (say, a Mac running Homebrew), you may need to start them manually, or take extra measures to ensure they start on boot. Because sqlite3 is _not_ a service, a sqlite3 database is managed directly by your computer program without talking over the network. This has the advantage of being much easier to set up, but services like postgres and mysql are able to offer much better performance. This is first and foremost because they can be run on entirely separate computers as your computer program. Twice the computers means twice the computing power, in this case.
This. To put it a tiny bit simplistically: Rails is managing a .csv file, not a database. 
&gt; Which is of course the point of the Law of Demeter. I think the point of the Law of Demeter is richer than that. Demeter violations always occur with _query_ methods, inevitably. Command methods usually either return nothing or they return something that is ignored by the program. Demeter violations reflect a habit of propagating data structures throughout the program, instead of encapsulating them within objects. Indeed, `user` is not a "real" object when used/abused by `project` to get after the `name`. It's just a naked data structure. The opposite of Demeter isn't delegating, it's Tell, Don't Ask. Queries aren't messages. Tells (command methods) are messages. Of course, when you have a `project`, and you want to render the user name on a web page, in my view there is actually nothing wrong with calling `person.user.name` (providing you aren't causing unanticipated SQL queries). Presentation (e.g. painting web pages) is literally a transformation of data structures. It doesn't need to be object oriented! This is the reason why altering application state in a `GET` request is a no-no; when we are operating in a space where the application state itself is not being managed, the design is fundamentally different. It's basically a big ole transformation just like the `string.strip.downcase.tr_s('^[a-z0-9]', '-‚Äò)` example. To put that another way, an HTML document is a tree. A tree is represented in our programming language by a deeply nested object graph. Ergo, you are going to need to trove through objects to spit out HTML. The fundamentally different nature of managing application state and presenting a user interface ultimately drove me towards adopting CQRS for most applications. Okay, rambling done now!
I've been interested in event sourcing for quite some time (the main driver being this fellow ‚Äî https://rubyconf.eventer.com/rubyconf-australia-2016-1489/event-sourcing-or-why-activerecord-must-die-by-sebastian-von-conrad-1933). I've also recently been using more and more of the dry-rb family of gems (http://dry-rb.org/) which promote immutability of data being passed around the application. The next logical step from here is definitely an immutable data store. I had a whole bunch of questions around how you deal with validation and optimisations with snapshots, but the GH issue tracker seems to have covered them all. Will definitely keep an eye on this for the next time we need event sourcing!
No. Reread what I said. Rails does not provide a method for using prepared statements when using straight sql. At least not as far as I can tell. I said "String interpolation should never be used with SQL"
The Law of Demeter (it's a [name](https://en.wikipedia.org/wiki/Demeter), so always capitalised) will *save your bacon* when applied to your own code, or to third-party code you use in your app (e.g., Gems). Less so for language standard libraries. As (I believe) "Uncle" Bob Martin phrased it, LoD applies to code which is *subject to change*; when was the last time you ran across a breaking change in the standard library from one version of Ruby to the next? In my experience, force-applying LoD to standard-library code such as your example def slug(string) string.strip.downcase.tr_s('^[a-z0-9]', '-‚Äò) end is *mostly* a mistake. I say "mostly" as a too-quick read of code can hide things that may plausibly change over time. Going back to the `#slug` example: is this the only place this logic will be applied? (If not, we likely want to DRY things up by *Extracting a Method* or *Extracting a Class* to handle the details). Let's look at the different steps involved and see what's subject to change? 1. `#strip`: Nope; the standard method is very stable and every single "slug" implementation I've ever seen requires that leading/trailing whitespace be trimmed; 2. `#downcase`: Similar to `#strip` in this context; forcing consistent case reduces the possibility of false negatives through typos; 3. `#tr_s`. While the standard method is very stable, the regex being passed in makes the reader stop and mentally parse it, and could conceivably change (that's a pretty draconian limitation IME). How would _I_ do something like that (or "how _have_ I done something like that") when given that legacy code to maintain? After satisfying myself that it is covered by tests sufficient to catch any breakage (such as characters being improperly replaced or not), I'd do one of two things. **If the existing code is largely procedural, not making use of simple utility classes or objects,** I'd probably write def slug(string) _cleanup_slug(_slugify(string: string)) end def _cleanup_slug(slug_string) slug_string.strip.downcase end def _slugify(string:, unacceptable: '^[a-z0-9]', replacement: '-') string.tr_s(unacceptable, replacement) end **If the existing code is relatively modern, making use of numerous small utility classes and objects,** I'd probably do it this way: # Get "slug" for string, with all characters matching an "unacceptable" pattern # being replaced by a "replacement" character. class Slugify def self.call(string:, unacceptable: '^[a-z0-9]', replacement: '-') _slugify(_normalise(string), unacceptable, replacement[0]) end def self._normalise(string) string.strip.downcase end def self._slugify(string, unacceptable, replacement) string.tr_s(unacceptable, replacement) end end def slug(string) Slugify.(string: string) end **Note** that these refactorings aren't *primarily* concerned with the Law of Demeter; it's more concerned with leaving clues to the *next* maintainer about what's being done and why. Here, we *inject* values for `replacement` and `unacceptable` with for-now-sensible defaults; those can be overridden if necessary without touching the code. Similarly, the `._normalise` method does some basic "cleanup" that's intrinsic to our understanding of the *concept of* a "slug", while the `._slugify` method is the "main logic" that simply uses values that are passed into it. Easy to understand; easy to test; easy to maintain. What's not to like?
SQLite is easier to install and get started with, doesn't change the security posture of the system, and doesn't bring a bunch of new jargon like "schema" or the idea of authenticating to a database. It's better for the common case: someone making an app that'll never see production. 
Cool, Sandthorn is doing the exact thing he talks about. :) Thanks for sharing that link. Love to help you get into this pattern if you have any questions.
&gt; ["2.0.0", "2.0.0-rc1", "2.0.0-rc2", "2.0.0-preview1"].sort_by {|s| Gem::Version.new(s) } Nice! &gt; I'm not sure if you're saying preview is supposed to come after rc1 and rc2 preview should come before rc. &gt; ['2.0.5', '10.0.0', '2.0.22',].sort When 10.0.0 comes, I will put up an effort to update this gem. For now, versions.sort is good enough: https://github.com/JuanitoFatas/ruby_version_sorter/pull/1 What stopped me from using Gem::Version is I am sorting Ruby versions, not RubyGem versions.
&gt; I can at least understand why those methods exist OK why? :) Because I honestly can't understand why every object that I use have access to `select` or `test` methods.
He posted in the wrong place but he's not the one who comes away from it looking like a jerk IMO
Scaling on Heroku is really costly, something like Digital Ocean works much cheaper. Edit: That was a stupid comment, I'm leaving this for context, though. Sorry guys ;( Now to clarify a few things, * Yes digital ocean was a bad example, I was only trying to make the point that heroku is really costly while scaling up. * I love heroku, I use it a lot, and in terms of development there is nothing else I'd rather use. But heroku's pricing goes up quite steeply and so scaling up tends to cost quite a lot, so I mentioned so. Heroku provides the best tools, addons and deployment is always easy. It does quite a lot, but at a high price. If you can spare the money then go ahead, you can't do better. 
heroku's definitely not cheap. You also get things you don't get from DO. I really don't want to do my own OS upgrades and OS and core software security patches. Good in-house sysadmin'ing isn't cheap either. Heroku's quite expensive, but they do quite a bit more than DO, and do it well. 
Every time I see a comment like this about Heroku vs somethingelse (especially DO) I have to wonder if the commenter even understands what service Heroku provides.
With hirefire, yes. I don't think so directly. 
Or perhaps with something like cloud66 Edit: http://www.cloud66.com
Yeah, i think your point is interesting and worth thinking about. I'm not entirely sure I buy it, but I still buy LoD for it's more surface-level "if I change this I have to change that" defenses. Which delegation _sometimes_ can accomplish, but probably not when you do it automatically generated with wild abandon. I also think ActiveRecord graphs is probably a place you want to worry _least_ about LoD in general. In part because it's just baked into AR's design to ignore LoD (with all the disadvantages that come along with that, it's certainly popular to say AR is designed poorly, I'm not neccessarily in that camp, but it is what it is) -- auto-generated delegation all over the place is just lipstick on the pig, and likely to not give you much actual future-change advantage. But also, I ran into this comment on the c2 wiki on LoD: &gt; If a fundamental structural relationship in the domain really does change then its almost certain that a clients requirements of the interface will also change and thus the facade provided by the outer objects hasn't bought you anything other than an extra layer (or even several layers) of code to maintain. Conversely, a structural change that is not domain oriented should be hidden behind a bridge where it cannot affect the exposed structure. AR associations are almost always 'fundamental structural relationships', almost by definition. I was thinking along these lines too, when I said similar above, "Is the invariant that a project always has one and only one user likely to change? If it does change, you're probably going to have a whole lot of code to change anyway."
Still cheaper than one person in operations.
Exactly. We've considered moving from Heroku to DigitalOcean or Linode, but would have to outsource operations (we wouldn't hire since it shouldn't be a full-time job for a company of our size). Ops is costly, and we would spend more by moving off Heroku. Edit: it blows my mind that people see Heroku prices and don't equate them with salary costs. A single, good devops person is NOT cheap, and we all know what salaries look like in our industry. And, Heroku's operations team is very competent, and (as noted in the linked article) very developer friendly.
Ah thank you! The problem is I used RSpec's match_array, which check if the elements of Array are the same but ignore the order. I'll fix. Thanks!
I don't know why you're getting downvoted. You're dead-on. If the tool becomes too costly, it's time to switch tools, not just throw more hardware at it.
I've never run into that problem, but if you know of a competitor that provides roughly the same services with higher quality, please let us know! What are you using for production now? 
Scalable, performance and whatever else the parent comment is saying.
Yes, if they had their own data centers their costs would be lower. Edit: Spelling
&gt; But switching over once scaling starts to take over is a good idea. ...but then you have bigger problems to worry about! And your manager is begging you to just pay Heroku and get back to building features. It takes fortitude to move your entire infrastructure just as the business is starting to take off. This is Heroku's business model, and why they should just be avoided IMO.
I guess I wonder what you mean by scale. The app I work on has a non trivial amount of traffic and we find Heroku to be completely worth it.
You are correct. Edit: ["HireFire | Autoscaling Heroku Dynos"](https://hirefire.io/)
Does Heroku support auto-scaling? I haven't been a customer in a while, but when I was auto-scaling required using (a paid) extension. HireFire and others did not work the way we wanted, ended up building it ourselves.
Wow I didn't know about activate, but that's perfect timing for something I'm working on right now.
Unless I'm missing something, there is no real reason to include a 2nd parameter when defining the rec_sort method. In the 3rd line of rec_sort, you could just return an empty array.
Does this code even work? Looks like elements are never pushed to the sorted array. Transcription typo or perhaps error in the book?
This is the short version. That is the learners version def sort arr return arr if arr.length &lt;= 1 middle = arr.pop less = arr.select{|x| x &lt; middle} more = arr.select{|x| x &gt;= middle} sort(less) + [middle] + sort(more) end p(sort(['can','feel','singing','like','a','can']))
Sure, but is there any use of the sorted array? It seems like at the end, it will always pass an empty array as the 2nd param. I can't find anywhere that data is actually stored in sorted. edit: I'm blind.
you handle things like OS upgrades/security patches yourself?
Well this one is easier to make sense of because I can recognize it as an implementation of Quicksort. But that first algorithm is a load of garbage.
The top comment from the author is: "ZeeMee‚Äôs traffic is really cyclical, so we only have to run it in ‚Äúreally expensive‚Äù mode for a few days of the year (application deadlines). ... Rails+Heroku is an easy way to get a product off the ground quickly, give you the flexibility to scale up as your traffic grows, and we‚Äôll switch off of it when (cost to switch) &lt; (cost to continue)." (https://medium.com/@phuitsing/hi-dmitry-8791f38d0d31#.hm6uc9m0g) Maybe the author should have put that right at the top of their post, as it's a pretty important business insight that runs through the article's technical insights. 
oh, sure, I was less thinking about downtime (and I'm sure there'd be a way to script a zero-downtime deploy DIY too), than just the energy and time and skill to keep on top of security patches and other software upgrades. But you may like it better and/or be more skilled at it than I. 
Weegeeisgoingtokillm sucks
The algorithm used is selection sort. Google it - it's really to understand by itself, though it's usually implemented in-place. The code uses recursion, or more precisely tail recursion: https://en.wikipedia.org/wiki/Tail_call. Any loop can be replaced with a tail-recursive function by hoisting the loop variables into arguments of the function that is to replace the loop. In fact many languages omit first-class loops entirely, providing only tail-recursion. This often results in two functions (like sort and rec_sort), the role of the first being just to call the recursive function with all arguments initialized (corresponding to initializing variables before the loop in non-recursive code). Note though that thinking recursion == loops is a bit too simplistic, since the other way, going from recursion to loops, is not always straightforward. If you are really struggling to get it, consider how the code would look if you eliminated rec_sort and rewrote sort using a loop: def sort unsorted sorted = [] while unsorted.length &gt; 0 smallest = unsorted.pop still_unsorted = [] unsorted.each do |tested_object| if tested_object &lt; smallest still_unsorted.push smallest smallest = tested_object else still_unsorted.push tested_object end end sorted.push smallest unsorted = still_unsorted end sorted end
&gt; keep on top of security patches and other software upgrades I don't really do this. I just throw away the old cluster and build a new one with a fresh AMI. The trick is to make the build-a-new-cluster-and-migrate process automatic, quick, and painless. But that's an interesting/fun challenge for me.
Hi, can someone with experience with this lib help me? Is Glade the best option for WYSIWYG ui?
https://github.com/pry/pry/wiki/Editor-integration
How does this differ from/improve upon [Wisper](https://github.com/krisleech/wisper)?
Wow.Thanks a lot!
Sounds very interesting. Go ahead!
Very interested.
The link given tells you exactly how to edit a file (either the one where you binding.pry or any other) from within a pry session and have the change take effect in the pry session. Given your level of detail about "still not figuring it out" I do not know how to help you. Good luck.
With all this talk of concurrency being native to newer languages, I really hope someone can write a ruby interpreter than can utilize some of that.
It would be interesting to repeat that experiment using JRuby.
Your query generates two rows with one value each, but you seem to be assuming that you're getting one row with two values.
Great job, man. Just checked out some of your videos and found them to be very helpful. Thanks!
Wow, numbers finally! So if I understood correctly, the bottleneck is Redis PubSub. Phoenix being Elixir/ErlangVM, I assume the message passing of jobs from web-to-job handler is either done in process (is this how it is being done in Elixir?) or by sending message to a remote actor in the job handler process. So they cut the man in the middle effectively (although I wonder, what happens if the job process crashes and is fed messages? Are these buffered somewhere? In a pubsub scenario, they'd just be in the pubsub service ready for consumption). ActionCable (IMO) could use some new adapters for this, and the best way I see to implement such a similar flow would be to do the whole publishing using ZeroMQ message passing (maybe even Sidekiq/Resque?). 
Passing a block to `fetch` will run that block for each row in the result. If you want to get all the rows at once, you need `fetch_all`. Here's a [cheatsheet](http://www.tutorialspoint.com/ruby/ruby_dbi_fetching_results.htm).
"a payments problem + mandatory change to hosting stack had taken is down. Back in a bit." https://twitter.com/ponnappa/status/764366917515685888
ah my bad. i'm starting to get the hang of it now-- thanks!
THIS. thank you!
But why all this mental gymnastic ?? Ruby is all about writing nice code that could be understand in few moments.
Glad to help.
It's amazing to see that only with function definition and function application, it is possible to achieve so much... It's mostly about aesthetics. It could be a bit pragmatic with recursive memoization as explained here: http://blog.klipse.tech/lambda/2016/08/14/y-combinator-app-ruby.html
To me, the fact that we can have recursion without using names is 'so much'. The lambda-calculus is not intent to be use in any real-life scenario. But it is part of the foundations...
`bin/rails s`
This reminds me a lot of how some of the JavaScript module loader systems work. All dependencies are explicit and injected into small components and those components are used together to build a system. I'd be interested to see how a system written in a dry-rb style compares to a JavaScript app written with modules.
* GitHub uses Sinatra for its API * Travis uses Sinatra (and it's open source) * [Clearbit](https://clearbit.com/) uses Sinatra &amp; Sequel * [Citrusbyte](https://citrusbyte.com/) uses Cuba/Roda/Sinatra &amp; Sequel * [Kontena](http://kontena.io) uses Roda &amp; Sequel (and it's open source) Those are the ones I can think of at the moment :)
Yes. I use Ruby at my day job and do not use Rails in any capacity. The very little web dev completed with Ruby is mock services in Sinatra. 
For a while now I've been wanting to write a gem. Ive been using the [interactor](https://github.com/collectiveidea/interactor) gem at my job, but there were a couple of features I wished it have. So since this two thoughts crossed I decided to write my own. For fun and practice. Feedback is welcomed!
I previously worked at a startup and now at a major university. Non-Rails Ruby is a big part of both codebases: for operations (Chef, Cap, scripts); and for small(-ish) web services (Sinatra). As a developer who now focuses on ops, I actually prefer to avoid Rails where possible, as it's enormous and tends to be unnecessarily slow to test. (That's not to say there isn't a place for Rails: it can be an enormous time-saver, particularly for newer developers. But it is overkill for many applications.) 
I work at a medium sized university and use the Ruby version Cucumber to create automated tests. We create a page object model using a wonderful gem called Site Prism and test a non-ruby application. We use this to replace manual QA when possible for acceptance testing. I also created an app to manage test results re-run tests and create gherkin via drag and drop and that uses a java script front end with some bootstrap for styling and a Sinatra back-end. Rails would have been total overkill.
This debate arrose a bunch when we first started creating a page object model for our test automation in Site Prism. In that model you have page classes which can have nested classes called sections that can contain sections. To get to a member of one you can chain down to them in the manner of: page_class.section.section.some_method but for easier maintenance and debugging (which is often not thought of up front) we follow Demeter and propagate down the 'chain' with smaller methods so we can call page_class.some_method. Propagation following Demeter takes more time up front but has saved me many headaches in debugging/changing code later.
&gt; Two issues I've had with Padrino is how they load everything That's an issue I had with everything I tried with Ruby. Furthermore, when using simpler stuff like Sinatra or Roda you are completely on your own, so you start putting together some ad-hoc code and it of course doesn't look pretty, as you have better things to do, like I dunno...building the actual app :) I would love to see people trying to use dry-system in places like sinatra/roda/whatever-that-is-that-you-use and see how it can help in organizing code, the only "barrier" that you gotta break through is getting used to the fact that you use an application container, which is not a popular thing to do. I hope people will just give it a shot and I'm 100% sure it's gonna be appreciated, as the impact it has on code organization, clear separation of concerns and *composability* is profound. Once object instantiation is no longer something you need to worry about, things are *so much simpler*.
In an API-only world, Dd you think there would be much advantage to only using sinatra for controllers, and still using ActiveRecord and ActiveModelSerializers for models / rendering?
I'm interested too :)
Most of the non-Rails projects I've seen are using Sinatra. Honestly I've yet to see one worth writing home about. More often than not they lack strong architecture and just wind up becoming a mess. At least Rails can be familiar. Rails projects usually have the other problem: adhering too much to the Rails architecture when you should break away. But TLDR, yes, but if you're going to do your own thing then you'd better be a Ruby wizard to justify the choice IMO. For small apps and scripting though, I think vanilla Ruby is fantastic
ActiveRecord is arguably the biggest reason someone uses Rails. If you're keeping it then you mindswell keep all of Rails since you're more or less just tossing out Rack middleware and rendering engines that you'll probably end up subbing in for any real production system. I guess the real question is why. Because Rails is a large dependency? Because Rails is magical? Performance? Because it's cool to hate? I think those are all valid reasons, just beware of reinventing the wheel all over again
Gotchya. thanks. I think my next step in performance tweaking is either upgrading to Rails 5's APIController, or starting at `ActionController::Metal` and including just the modules I *need*. (I'm on Rails 4 atm) edit: also, ActiveSupport has a lot of handy things in it.
I like having the view layer so that you can support things like active admin (or another admin layer). It's really nice to have that crud stuff easily available.
It is super handy, yeah. I wonder if it'd be possible to have active admin on a separate app / server entirely? so it doesn't affect the performance of your API?
The only times I've seen ActiveAdmin mess with an app is when octopus was configured so that the user table would read from master (the idea was to avoid race conditions with payments on the user). So, that's basically a database level interaction that caused the slowdown and you're not going to avoid it just by moving ActiveAdmin to another server. If you're talking about the overhead of rails in your api process, then I think you're absolutely correct that keeping the process serving your api lean is a win. But, in this case, you can't share business logic between your admin interface and your user interface. That's probably another benefit tbh but the companies I work for are small and can't really afford the overhead.
One of my previous companies uses Ruby as a command line app to read XML using nokogiri and convert it to a format that can be consumed by another app. The Ruby app is even packaged into a windows executable and released to customers for them to use it to consume their own custom XMLs.
&gt; In an API-only world, Dd you think there would be much advantage to only using sinatra for controllers, and still using ActiveRecord and ActiveModelSerializers for models / rendering? Yes, I definitely think so. I think Rails has many advantages in a full-stack app, but in an API it doesn't. One benefit of using Sinatra/Cuba/Roda for APIs is that it keeps the code that route and code that handles the route together (Rails splits it into config/routes.rb and app/controllers), which is nice because with APIs is much more important to have a good overview how your endpoints are organized. I've also found that Cuba and Roda's routing tree approach makes it much easier to organize input validation (params), which is very important and much more elaborate in APIs than in full-stack apps. About ActiveRecord and ActiveModelSerializers, if you really love them (and if you love ActiveSupport), then it's fine (Travis does that). [sinatra-activerecord](https://github.com/janko-m/sinatra-activerecord) provides a nice glue between the two. However in these situations I always advise people to consider using [Sequel](https://github.com/jeremyevans/sequel), because [Sequel &gt; ActiveRecord](https://twin.github.io/ode-to-sequel/) and [ActiveRecord ‚âØ Sequel](https://twin.github.io/activerecord-is-reinventing-sequel/). Also there are many excellent generic alternatives to ActiveModelSerializers, like [Roar](https://github.com/apotonick/roar) or [Yaks](https://github.com/plexus/yaks). But if you're happy with ActiveRecord and ActiveModelSerializers, you can definitely use them outside of Rails.
I work for a massive corporation and code in plain Ruby. Most other projects are C# or Java though. 
We use rails and rails on jruby, but also chef, Capistrano (to deploy not just rails apps) and random ruby utilities (driving pipelines or etl or whatever else). 
Thanks for your reply. - Don¬¥t model all your objects / models with Event Sourcing. At first we did that and it became really hard to do simple queries. Its was really hard to know when we started and did¬¥t had the experience running an Event Sourced system. - If you use read-models "models that are created from events" (CQRS), you have to get your head around eventual consistency. The big upside when you model an object with Event Sourcing is that you can stop thinking in database schemas and can focus on the object. All you save are events and they have one schema. In what language / platform are you running Event Sourcing?
There is a lot of new objects this creates for seemingly no reason which will cost you in the long run as well, in adaption to the wealth of singleton methods to act as instance variables and a hidden call method that calls your call method and returns the result in yet another class instance. I'm not a fan of the idea that is perfectly fine to throw class instances around in Ruby like it's free because it's not and it can get out of hand very easily. 
A friend of mine created this repo: https://github.com/shime/rails-free-ruby Feel free to contribute :)
I use Ruby a ton for automating interacting with AWS.
Segment the PRs down to related blocks (as you would expect random PR's being delivered to you) this way he is free to choose none, one or all of them based on their merits. make sure the PR note clearly explains what the purpose of each is. Submit them and give a week or two, if the original author does not pull them in at that point you can decide to fork your own version. This gives the author time to view and act, and lets you do the work without feeling like it may be for naught. 
Upvoted
To be honest, I'm a strong advocate for Ruby. That's just the title of the page. It's an interactive tool for having arguments and as such it's a good place to argue the above and educate people on the differences :) People like yourself have useful knowledge and could share it on the linked page.
Sure: http://benchmarksgame.alioth.debian.org/u64q/ruby.html For the typical work I do, the benchmarks it beats are the ones I most care about (eg, I am not that interested in calculating pi or mandelbrot, but do spend a lot of effort with Regex and string manipulation), also be sure to read the article I linked above, which is something not captured by benchmarks (Ruby is faster with memory because it preallocates)
I'm the author of [Iodine](https://github.com/boazsegev/iodine) (the Ruby server). I just moved the code base to C (it's pre release, available only from GitHub at the moment)... The reason I'm saying that is that I couldn't find low level access to some important network OS features (i.e. `kqueue` and `epoll` polling)... are you sure it's possible to write network analysis tools with Ruby? How low level can we go with Ruby (where networking is concerned)? As a side-note: If you want to help test Iodine, that would be great. I think I'm done (I tested on Linux, OS X and FreeBSD), but I might have missed something...
Sounds very cool. If you do create a chatroom somewhere to talk about this, please also post where to find it so that myself and others can follow the discussion there :)
Contact the author and wait for 3-4 days. If no reply, then fork, rename and make you own thing.
I thought Travis executed the tests you wrote. How then does Travis differ from simply running RSpec yourself for example?
We have used Padrino/Sinatra several times in our company, and also made internal scripts to process MS Office documents (using win32ole) with Ruby. We use ActiveRecord and ActiveSupport in some projects but never used Rails. Examples of companies using Padrino (you can see Coca-Cola there): http://padrinorb.com/guides/introduction/examples/
If you write tests that don't actually test functionality, then Travis will say everything is good to go. While the tests aren't testing what needs to be tested. My point is that, just because Travis (or any CI) is in use _does not mean that a passing status has any meaning_. Make sure the tests look good and then pair that with the status of a Travis build and you can make a determination on whether or not it's valuable use of a CI service. **edit** fix typo
We have built an open source framework that has not been publicly released. I have started giving talks about it in my local user group, and we hope to have an alpha release soon. Documentation is the main blocker right now. It's quite a bit more complete than other implementations -- it covers not only writing events and projecting them into entities but also caching, message dispatching, consumers (to connect services to other services), and more. It's less about "use event sourcing for your persistence layer instead of ActiveRecord" and more about "build autonomous services that use event sourcing to maintain their internal state."
I would first ask their current interest level in the project and if they are interested in you taking over the project or becoming a committer. If you are taking over a public project with an existing userbase, please consider backwards compatibility and a migration path for any breaking changes.
Not at all! This is because `.call` and `#call` are actually two different methods with the same name. To not overcomplicate it, one happens at a "class" level (the one you send the args to) and one at an "instance" level (the one you redefine in your command). When you call `Command.call(array: :whathever)` what this actually does behind the scenes is it initializes a new instance of Command with the arguments you send as instance variables, so by the time the instance `#call` is called, it has access to all the instance variables you sent as arguments. To not enter too much on why you can access `@array` as just `array` maybe it can help you if I write the command this way instead: class Command attr_accessor :array def self.call(**args) instance = new(args) instance.call end def initialize(array: nil) @array = array end def call @result = array.sample end end I'm of course oversimplifying some aspects, but hopefully this helps you understand.
Ruby is faster in all aspects except math. Numbers are treated as objects in Ruby so there is a slight overhead. 
You need to consider your interface contract. If this were a web service, on finding multiple records you might return something like: ` { code: 200, records:[record1, record2], errors:[] } ` the object that is returned between finding n results and 0 results should be the same. For 0 results you would return: `{ code: 404, records:[], errors: ['No records matching the given criteria were found.'] } ` The interface is the same because you have a hash with keys code, body, and errors, which have the same type for success of failure. code is a fixnum, body is an array of Records, and errors is an array of Stringified error messages. Extending this, if this is interprocess communication, if on success you return an array of Records, then, as /u/2xvj/ said, you should return an array with all matching records, which would be empty. I think you will want to return more data in the event of a failure so that the caller can make smart decisions about how to react to the empty result.
Also ruby 2.3 introduced the [safe navigation operator](http://mitrev.net/ruby/2015/11/13/the-operator-in-ruby/), which may make your need for nil checking much easier. 
It's not a bad practice if it makes sense for your use. An empty array may also make even more sense, if it ordinarily returns an array of records. I don't see any need for a 'null object'. If it returns an array of records when records are found, I'd return an empty array when none found. If it can only returns a single record when found, I'd return nil when not found. 
we use metasploit at work a lot... its a rather large ruby codebase. https://github.com/rapid7/metasploit-framework.
Sure thing. I'm sure there will be an announcement here when we do :) We actually use the event store database as our message bus. The usage pattern is similar to Kafka. It works remarkably well, actually.
I emailed this morning. :)
I stopped reading when I saw the subtitle named "Dependency Injection". ;-) If one day the dry-rb ideas become mainstream, I'll move to different languages/tools new enough to be unscathed by all of this corporatese. Just like when I quit Java back in the day.
Do you mean geteventstore.com? We use it and have had a very positive experience aside from the documentation being incomplete and the HTTP API having some pretty iffy semantics in places. I looked at Sandthorn, and it's interface seems pointed towards dropping event sourcing into an otherwise CRUD/resource/model centric design. It's not for me, but I'm at least glad others are doing event sourcing in ruby.
I used Sinatra for APIs in two (medium/big) companies before and used Ruby for scripting and automation in two others.
You can try taking your code, finding loops and turning them into recursive functions. That's what they had us do in school. If you're trying to traverse binary search trees or something of that nature, I would look up a video and try to implement it yourself. 
Practice. You can look up practice problems that call for recursion. Also, if you're in New York, you may be interested to hear that I'm giving a workshop at Coalition for Queens this Friday on preparing for interviews as a software developer.
I really liked the basic recursion exercise in *Learn to Program* by Chris Pine. You take a 2x2 array that represents a map and use a recursive function to count the number of land tiles on a continent. Totally recommend the book.
I'm going to have to take a look at the answers here, as my path to learning recursion was baically: -write recursive Fibonacci() -tell it to keep running -cry when python/ruby/perl crashes -hang head in shame and go back to being a server monkey
So I end up using it when I've got a complex structure of same items. We had a giant tree of data that each had to do a complex operation based on its parents. So my method did the calculation, then called itself on each child node. So like it was suggested, you can turn loops into recursive functions. I would say that loops are better because you aren't building up a bunch of nested scopes, but it makes sense if your data structure is more complicated than a list. Maybe implement a binary tree? They tend to recourse for about any operation you want to do with it
+1 for Elixir. It somehow manages to be even more attractive an fun than Ruby IMHO.
Oh boy, I get to talk about something I learned! So this is called the **Null Object Pattern**: https://en.wikipedia.org/wiki/Null_Object_pattern And here's a great talk by Sandi Metz (Ruby-centric) about it: https://www.youtube.com/watch?v=OMPfEXIlTVE http://www.sandimetz.com/blog/2014/12/19/suspicions-of-nil 
You just have to spend time with it and it will come to you, there does seem to be two different types of programmers; ones that intuitively consider/understand recursion and ones that find it unnatural but can eventually understand well with effort. I think this has some correlation with your type of reasoning (top down, or bubble up). I will say that if you are in the camp that needs to spend effort against recursion I have found that many times until the dev has spent the effort they also tend to have blind spots related to stacks, queues, sorting, state machines and language features like map/reduce/lambdas. 
I generally start with the terminating condition(it's got to stop sometime). Then I fiddle around with it from there. Probably not a good strategy for getting through an interview but it gets me there eventually.
But understanding why it crashes is important. It makes an exponential number of method calls. It's a good example of how and why not to use recursion. 
Totally agreed! While there was definitely shame felt - you're right that I learned a lot from the episode.
I can teach you all there is to know about recursion, but first you're going to have to learn everything but the last thing there is to know about recursion. Also, this is true for any number of last things. For example, if you know all but the last 27 things about recursion, I can teach you the 27th last thing. I can also teach you the first thing.
There are a few types of problems where you can use recursion. Just go through them from easy to more challenging until you understand them: - The simplest case is just as an alternative to an ordinary loop, but that's not very useful. - Slightly more useful is to use recursion to 'hone in' on a solution, like in binary search. This could be done with a loop but is a little more elegant with recursion. - Recursion becomes really useful when it's used to 'branch out' and conquer a problem, (e.g. in many sorting algorithms). This would be very awkward and difficult to do with a loop. I created a [Recursion tutorial](https://www.learneroo.com/modules/71/nodes/398) that goes through each of these steps, and it's available for free.
Learn Haskell. At least, the basics. You don't have to dig into it too deeply (it's one helluva rabbit hole to go down, TBH), but spend a few weeks getting your feet wet with it. Even if you don't stick with it, just picking up the basics of a purely functional language will make you a better programmer, and you'll be able to apply many of the concepts you learn in Ruby, including recursion.
Recursion is great, but it's used way more in coding interviews than in actual bread and butter programming. When I interviewed at Google, 70% of my problems ended up involving recursion. But when I do regular programming, it's under 1% of the code I write. I'm not really answering the question, I know.
Empty array or use the null object pattern
That is true. I may have been too quick to suggest Elixir as the next best thing; I'll admit, I'm currently on the Elixir hype train after having tried it. Ruby has its own nuances that one needn't learn, but will vastly benefit from as they program in it more, but Elixir starts off with nuances. OTP pattern and functional programming in itself can be daunting for a new dev, whereas Ruby can be picked up relatively easily for a new/jr dev.
its a ruby subreddit, why not give a ruby example or an example at all? 
Yes, the name of it is not that clear in this context =) I started to use it via the Arkency gem https://github.com/arkency/http_event_store Your right Sandthorn tries to have a similar API as Active Record on the object (model) level. When we designed Sandthorn we followed the Domain Driven Design patterns and took influence from a talk by Jim Webber https://skillsmatter.com/skillscasts/2325-rest-and-ddd. It would be interesting to have a look on how solve stuff in your solution.
The Little Schemer by Daniel Friedman was the book that really made it click for me.
Essentially CI is a process of an agreement of the codebase and well defined behavior given in specs. When the agreement isn't fulfilled, either the specs or the codebase don't match each other. CI might be even handled via some set of Bash scripts and it'll work just fine. CI is also a process that is not dedicated to a framework or language. It's all about configuration or what green build means to you. In here, we're using Jenkins with Gerrit (both are hosted by us). These are kind of dinosaurs but play very well with each other. Gerrit is a code review tool, whereas Jenkins manages build process. 
yes. listen to this.
That means only that your team doesn't really follow style standards strictly. I prefer having indentation error as a compile error instead of ending with messy code because people don't want to setup their editors (opinions don't really matter here, that's the point of style guide)
&gt; State and Boolean column are columns that should be indexed as there would be a lot of rows but only limited number of values in those columns. Isn't this typically not the case?
It sure does, but shit happens - and in my case I can't even complain because the most frequent offenders happen to also be the client. I just fix it, grumble - hope it's not blowing up something horrible in production and move on. They would also disagree pretty intensely if I told them their opinion doesn't matter.
Jenkins is pretty horrible in terms of end-to-end user/administrator experience. QuickBuild is much better on every front and provides free licenses to FOSS projects: http://www.pmease.com/
In benchmarks I've seen Ruby tends to be faster at things that support web stuff (string manipulation) and Python tends to be faster at things that support data science (numeric manipulation). I think the relative speed of either language is influenced by what they're most heavily used for, because observations made working in those domains help to determine where improvement efforts should be focused. (In addition to fundamental differences in each languages Object/Memory model that others have already mentioned.)
Git Lab. It's OSS, self hosted, comes with git repo hosting, a CI server, configurable CI runner, a container registry, and chat app called mattermost. I use it at work and it is amazing. The CI and docker runners are great. 
I fix then when I come upon them, but having panic'd calls at 10:00 at night because of a space is not something I am happy to hear. Sometimes I do leave them, because if I fix them then I show up in the git blame, and I don't want that either.
tools for artisanal software development
I like the concepts, but probably wouldn't add a gem specifically for this. I would probably extract it into my own app. However, I could see the benefit of having these methods should be part of Rails core.
Have you looked at github's documentation for handling webhooks? Using their gems, it literally takes about 5 lines of code to create a sinatra app that will do something with their hooks. I use this to publish our private npm modules to a sinopia server that we're running as well as kick off a visual regression suite that we wrote (just a casperjs script). So, if you just want to run rspec or minitest automatically when you push to github, you could roll your own very easily. Note: I'm usually against inventing shit here that's already been invented there by smarter people who also wrote documentation for it. I think this is a case where you can break that rule without too much pain.
You can try to find a beginner friendly project by searching Github for labels like "beginner", "beginner-friendly", "easy" etc. Here is a list of such labels, and some projects that use them: https://github.com/lucev/beginner-friendly
Looks interesting! Thank you
Ok, that bit about Ordering made me do a double take. "A inherits from B? Then PresenterA calling super should go to PresenterB, even though PresenterA doesn't inherit from PresenterB." That's really cute.
This is pretty interesting. However, I'm not able to reproduce the author's results. here's the script I'm running for the test: require 'benchmark/ips' require 'rspec/mocks/standalone' require 'factory_girl' require 'active_record' class User end FactoryGirl.define do factory :user do end end Benchmark.ips do |bench| bench.report('object') { User.new } bench.report('spy') { spy(User) } bench.report('double') { double(User) } bench.report('instance double') { instance_double(User) } bench.report('factory') { FactoryGirl.build :user } bench.compare! end and the results: Warming up -------------------------------------- object 181.834k i/100ms spy 6.100k i/100ms double 38.182k i/100ms instance double 16.593k i/100ms factory 1.561k i/100ms Calculating ------------------------------------- object 3.745M (¬±24.3%) i/s - 17.274M in 5.001737s spy 74.067k (¬±36.1%) i/s - 311.100k in 5.053701s double 948.723k (¬±27.2%) i/s - 3.971M in 5.025158s instance double 225.938k (¬±30.1%) i/s - 912.615k in 5.009665s factory 19.261k (¬±30.6%) i/s - 82.733k in 5.051546s Comparison: object: 3744779.5 i/s double: 948722.7 i/s - 3.95x slower instance double: 225937.9 i/s - 16.57x slower spy: 74067.3 i/s - 50.56x slower factory: 19260.8 i/s - 194.42x slower
So you made a new table, migrated over data then deleted original table and renamed the new table? In this case my data was already about 30 days behind due to lack of monitoring. It wasn't a big deal for it to be hung up for another 4 hours. I wanted 1 command that I knew was going to work so went with the inline option. 
Agreed. No reason to add another dependency. Would be nice if implemented in Rails though.
I could use a comparison to Draper. What made you want to write something new? What does it do better/different than draper?
thank you!!!
Right. I tried inheriting from `ActiveRecord` but I don't have a db setup for it so I didn't finish that experiment. I figured that as the object became more complex the overhead to instantiate it would become larger than the doubles and spy.
Good article, well written and I love the article long analogy. Can you share some API and libs you opine are sharp?
I have a couple gems that I'd like to get features for that I haven't had the bandwidth for and would happily accept PR's if you're looking for something. I tend to keep Github Issues pretty stocked on these repos. I wouldn't say they are the easiest projects to work on, but I've found them fun problems: https://github.com/jbodah/spotifuby https://github.com/jbodah/spy_rb
David Dollar, former Heroku member, gave a good talk at Heavybit on the "developer experience". In the talk he references "small, sharp tools". That really stuck with me and I really love the concept. The talk is definitely worth a watch. https://www.heavybit.com/library/video/developer-experience-design/
You can also simply do sum = (num* (num+1))/2 
This isn't a new problem. In fact it's a problem that's been around in the Ruby community ever since Rails first started gaining popularity. It happens with every new language or framework that gains popularity. Take a look at node.js, it's currently sitting where Ruby and Rails was back in 2005. It's exploding in popularity and it's entire ecosystem is changing rapidly making maintenance of any sizable project a complete nightmare. *Maturity in an ecosystem takes time.* I stopped using Rails many years ago because of this problem. I couldn't guarantee maintainable code bases for my clients. Rails, and Ruby as a consequence, as a community and ecosystem just simply wasn't mature enough. But as time has gone on it's matured to a great degree. There's always going to be new gems, with people trying new things but the community at large has started to standardize on gem usage. They are maintained, well tested and secure. It's why I've returned to using rails in the last year. Things have gotten so much better.
I find it irritating when people conflate ruby and rails as the same thing. Like any programming language, ruby has its issues. For me, the upside of its expressiveness and readability hugely outweighs the brittle experience that gems lends to the experience. Rails otoh is an application. Disavowing oneself of ruby for the sins of rails is like saying you hate C because you don't like the way postgresql works.
You can look at [Google Summer of Code organizations](https://summerofcode.withgoogle.com/organizations/?sp-search=ruby) and what OSS projects they wanted students' help. Despite the fact that GSoC itself is (almost) ended, I suppose any of those orgs will be happy to accept newcomers' contributions. At least, we ([SciRuby](https://summerofcode.withgoogle.com/organizations/5131000665341952/)) definitely will :) Also, you can take a look at some of [my gems](http://zverok.github.io/), several of them are under active development and I'm also willing to accept students' contributions and mentor novices. Though, my work is not of huge popularity :)
The code between `do` and `end` (a "block") is a [closure](https://en.wikipedia.org/wiki/Closure_(computer_programming)). Crudely, this means this code can be passed around just like you can pass, for example, and Integer around but it retains it's original scope. `return` returns from the scope of the `SimpleAdding` method instead of from the scope of the block like you might be expecting.
What have you moved into ?
I enjoyed a decade in ruby and rails ecosystem . But the time has indeed come for serious introspection on if I would like to continue or catch up with new skills .
Thank you all very very much for the input. It will likely take a month or so to pull everything together but I intend to post back.
&gt; But now, development choices that seemed innocuous a long time ago are beginning to impede the company‚Äôs ability to develop new features and test new business ideas. If ^ is the issue, that isn't a problem unique to Rails. And the benefit of ease-of-development is the capacity to move your early business to a scale where, gasp, rearchitecting is necessary. That's a feature, not a bug. I work at a company whose core tech was laid down in Python and Node. All of the problems listed in this article apply to our stack and technical decisions as well. Hindsight is 20/20, but 2nd system problem is real. I read the list of design advice in the linked article and none of it really goes against Rails. The biggest challenge I think is: Balancing the need to move quickly within inadequately understood business problems (eg accepting edge cases that don't work) with the need to understand and change the functionality at a later period in time. As a senior engineer, a lot of my leadership is helping juniors understand what the appropriate level of effort is, and when they should write the docs and polish the tests, and just move one. On the flip side, it's helping them navigate complexity and channeling their frustration with imperfection into reasonable design improvements. Rewriting code should be a conversation with history, not a screaming match. And back to the original quote, you'll often find that being able to "test new business ideas" is an organizational challenge as much as an engineering challenge. Change is hard, and that's not a problem unique to using Rails. At the end of the day, it's about our commitment to improve things and our empathetic thinking and communication, more so than it is about the toolchain.
This is the "I had a bad experience with X so there's a problem with X" fallacy. Bad/bloated/crusty/rotten code is a symptom of bad/bloated/crusty/rotten organizations, not any tech. Plenty of firms have managed their dependency debt well enough. 
The ruby/rails ecosystem today reminds me of Java in the mid 2000's. Lots of demand led to lots of beginners jumping in and starting learning and building software. Some of this code was okay or even good. Most of it was bad. And there was a lot of it, and that gave the ecosystem a bad rep. The same thing will be true for JS/node in a few years. The same thing for elixir/phoenix a few years after that. It's the nature of the "new hotness".
Yessss this is perfect! Thanks so much!
exactly. every long term project is going to suffer from technical debt, no matter what the language or framework. unless you pay that down early and often, you will run into this issue.
Because Ruby is supposed to be natural to read.
and &lt; &gt; &lt;= &gt;= are concise, very well known and natural to read. 
I think we tend to forget. Rails is largely designed for small, experienced teams doing full-stack work in a highly integrated system, and it's really, really good for that. Unfortunately if you hire a bunch of inexperienced developers they are going to make a mess no matter what you give them. Giant Gemfiles (more generally package dependencies) are not a problem with Ruby: they're a problem with open source software being developed by people who don't know better (or maybe don't care to know) Ruby is excellent, and so is Rails. You can't blame tools when you abuse them or don't use them as intended. You still have to follow fundamental software construction principles. If anything I really do feel like Ruby is reaching an influx point. The hype has pretty much died and now Ruby feels like it's being viewed as the safe option instead. I feel like it will generally be picked by people with a lot of Ruby experience (which is a fairly common thing to have now) who have lessons learned dealing with former wild applications
Okay, you win. Good job. Obviously you are right and someone just felt compelled to write a gem because they were bored and not at all confused by the readability of Time comparisons. Congratulations, you win the internet today.
That's exactly the sentiment i'm going for. Even in the case of cutting food there are many cases where chefs use specialty devices that would be safer and quicker such as a mandolin for slicing crazy thin things. Knives still are crazy useful, and like chisels there's not really a better way to make them safer. However it doesn't mean that's a trade off present in __all__ tools. 
I don't care about the gem -- I was reacting to you saying it should be pulled into core. A gem is fine -- feel free to pollute your code with that, but no way in hell should it become core. anywho thanks for the win, celebrating.
What is so suprising about it? It was the same with jQuery/Javascript and probably there were also other frameworks/libs in other languages that influenced the according languages community that much that for a lot of people they got synonymous. jQuery finally made Javascript easy. It took care of Browser differences, gave you some pretty good animation possibilty and you didn't have to knew anything about the DOM to be a "Webdesigner" working with jQuery. You just needed to know how to use $(). Rails is somehow the same for Ruby. The fact that Ruby mainly gained it's popularity through Rails success probably didn't help. Don't saying it's ok, but it's nothing mystical or new.
You can do this, but a) let is lazy, so if you don't reference var inside your test it will never be instantiated, let! is eager and will happen immediately, and b) the test is really just what happens in the it block, it runs the context it needs for each test, so if you don't include actions there or in a before context, they won't actually run for the test. I think you need `browser.goto("http://base-uri.com/#{month})` to be in a before block, like `before { browser.goto("http://base-uri.com/#{month}) }` and then this MAY work for you.. I haven't used Watir myself but this looks like basic rspec otherwise. You may also want to include the variable you're iterating over in the it blocks text, like "has some content on the page for #{month}" so that if one month fails, you can tell it apart from the other months at a glance.
First things first, it sounds like you are just a student and which case I would strongly advise against this project prior to administration knowledge and approval. There have been way too many times when some student decided they can build a better system and once they release their system get into hot water for violating some aspect of the acceptable use policy. You really want to get administration approval considering you are handling private credentials. Beyond that, I willing to bet that current software is probably driven by some kind of Java software as it the case with a ton of enterprise applications. Buy again, if you can get approval, it should take long to figure out which software they are using. 
The `&lt;=&gt;` operator implements the following rules: if a &lt; b then return -1 if a = b then return 0 if a &gt; b then return 1 if a and b are not comparable then return nil Every class that implements this operator can use the methods `max`, `min` ans `sort` of the Enumerable module (not only arrays can be sorted that way but all enumerables). Effectively the sorting algorithm of `sort` will call your method (a Ruby block is basically a anonymous method or lambda) and 'ask' which of the two values is larger. Depending on the result of this method call it will move one of the two values or leave them. Details depend on algorithm, a simple bubble sort would just compare two adjacent values and switch the smaller one to the frront. Though `sort` won't use this. A far as I know it uses quicksort in which case it will compare against a 'pivot' value and divide the values in two groups, then recursively do the same with each group and so on.
Looks like rails again. &gt; It's why I've returned to using rails in the last year. Or are you asking where he moved from?
Calm down, Gauss.
I may get a few details slightly wrong here, so somebody correct me if I do. Basically the *sort* method on an enumerable object (which arrays are) takes a block (hence the curly braces -- note that *do |x, y| ... end* would work just the same.) As might be pretty obvious, *x* and *y* are two values from within the array that are to be compared. The spaceship operator (**&amp;amp;lt;=&gt;**) is comparative, and will return -1, 0, or 1 depending on the values of *x* and *y*: -1 if x &lt; y, 0 if x == y, and 1 if x &gt; y. Using the values -1, 0, and 1 returned for each comparison allows the *sort* method to do just what it is supposed to: sort the objects. I hope that helps. I might have a bit wrong here or there but I believe that's the basic idea behind what's going on.
Yes, you can create `it` blocks in a loop. But I think you want your prep stuff inside the it block -- or put a whole `describe` block inside the loop, and put them in a `before` block. Think of it this way, when that file is loaded, all the `it` test blocks are _defined_ but then they're all run later. Your bare prep stuff is run before you define each `it` block, but you want it to run before each it block is _run_. Either put it inside the `it` block itself (which will work fine, although be poor style), or make a whole `describe` inside the loop, with a `before` to run your prep. Think of your loop as being looping over months and _defining_ the tests for each month. You can do that. You can define whole `describe` blocks, with `before` blocks in the loop too. Even without a loop, you need prep code in a `before` block, not bare in the file, so it will be run before the test is executed, not right before it's defined. 
Pretty simple one, the argument in Hash.new will set the default value for any new hash keys that aren't set with an explicit value. The each iterates over the array values and setting a key if it is not in the hash already. Plus, from before sets it to zero. If it does exist it adds 1. Thus, it is counting the array elements with the array string being the key and the count the value. On phone, so some things may have autocorrected and I still missed it. 
this was elucidating! combined with a friend who just explained to me Lvalue and Rvalue. i've been thinking of `counts[name] = counts[name] + 1` as a math expression, like algebra, rather than the left side setting the value and the right side asking for the value. thanks very much! also -- used pry for this. would you step, then type out various variables or objects to see their values?
It depends on your background -- are you used to debugging or not? I qould suggest if you are new to development you just use it as a simple REPL and place puts in the loop for instance so you can inspect the variables as it changes each loop. When you are learning your needs are usually to understand what is happening at a fundamental level, which is a little bit different than how you use something like pry for debugging (where it is very clear what is happening in that each).
Hi, in most cases your friend would be right about LValue and RValue being relevant. In this case however Ruby is a little bit different. Ruby will see the assignment line as: counts.[]=(name, counts.[](name) + 1) Where `[]=` and `[]` are method names that set and get the values in the hash. If you're not at the point where you fully understand Ruby classes and methods yet you can disregard this comment. When you understand `Hash#[]` and `Hash#[]=` are methods, you can grok how the `Hash.new(0)` default might work. Here's a simple example how you might implement it: class Hash # If you're actually running this snippet, rename it to MySimpleHash def initialize(default_value) @default_value = default_value @values = [] # naieve store for hash values end def [](key) @values[hash_key(key)] || @default_value end def []=(key, value) @values[hash_key(key)] = value end private # naieve hash function def hash_key(key) key.each_byte.inject(:*) end end 
Do not throw out algebraic mindset though. There are languages that would throw an error on `a = a + 1` for the very reason you were baffled by it. Pattern matching in Elixir/Erlang is driven by this logic, for example. You are likely to learn some of them-if only to increase your outlook-if you keep growing as a programmer.
Well, I wanted to create an API only app. Found [this](http://edgeguides.rubyonrails.org/api_app.html) just now. Thanks
I am experienced. That is why I was surprised. And I've already tried Sinatra, but I've got no time for boilerplate. 
i cannot wait to unpack this!
I recommend writing some simple gems that scrape web data. your fellow students will learn the basics of gem structure, and you scraper gem can be incorporated into a web app. I frankly wouldn't start contributing to open source without having collaborated on making an OSS project and learning the basics of collaboration and git based workflow. 
look at grape as well. 
Yeah you could throw the pry in and inspect the current local variables through each iteration of the loop. Basically your friend helped a lot and the above comment explains what's really going on. Thinking of it as a setter and then a getter is a good way to think of it right now. Puts would give you the output very quickly which is easier in this case to read. Sometimes it's worth putting in the pry so you can inspect what variables are and see what would happen if you ran bits of code. 
please tell us your affiliation: is this a research project? a community service?
Rails is great for building APIs. It even has API only mode built in now. Saying build it in Node, is like saying build in with Ruby and Rack and no framework. It doesn't compare directly. Node is just a JS interpreter, so you would want some framework like Express too.
&gt;see what would happen if you ran bits of code. by this do you mean input an arbitrary argument for a method, stuff like that? i just feel like pry is this super powerful thing but all i'm doing is using it to get values of objects.
I'm trying to set up a simple RESTful app and the amount of things makes it confusing
I don't want to even get close to Node. I've had enough with it for the next year. :P
Like Sinatra?
what things? it shouldn't take more than about an hour to go from nothing to getting a rails app + dummy API running on heroku
Express does about the same thing as Sinatra.
I wouldn't recommend using it. I'd much prefer a normal Rails project in API mode and active model serializers. That's how I did it before when rails_api was a separate gem. I think Grape adds too much complexity and DSL.
When you're searching for things about Rails, it can help to limit your search to the past year or so. You probably found a lot of outdated information and things that people aren't doing with the current version of Rails. With Rails 5 you just need to generate your project with a flag and it will be configured that way automatically.
What I mean is if your pry is before `binding.pry` `counts[name] = counts[name] + 1` you could actually copy and run the code in the console so you can see the new result for `counts[name]`
Thats fair. I didnt list frameworks, that's my mistake. For a prototype project I just think node with something like express is super quick to get up and running. For a situation where you just want to basically test "is this idea viable "
Do you need to learn webpack and babel to develop something with node.js? Cause... yeah. 
Can we define "small-medium" and "lower-traffic"? We have &gt;70 models in our application which survived a TV spot on prime time with just one server(40‚Ç¨/month) (whereas any investor predicted that our service will crash under the load) and I still think that dry-rb (haven't looked at the other two) would increase the complexity by several magnitudes. We did implement a selfmade presenter system but apart from that it's pretty standard Rails.
&gt; I was recently speaking with a CEO of a successful, rapidly growing company whose business is based around a large Rails app. Up to this point, Rails has delivered on all of it‚Äôs promises, allowing him to get the company to where it is now. But now, development choices that seemed innocuous a long time ago are beginning to impede the company‚Äôs ability to develop new features and test new business ideas. This is most definitely not the first time I‚Äôve heard exactly this problem. Definitely not the first time I've heard it either but also in no way unique to Rails. If fact I can't think of a single 'rapidly growing' company I've been in involved with or heard stories about which didn't have to go through fundamental re-architecting when it reached a certain scale, regardless of what tech is started with. 
One important fact I think this article fails to mention, which backs up its argument, is that a lot of big companies have started as massive rails stacks and transformed into more scalable platforms that enable rapid development for their teams. PagerDuty, Twitter and Github all started life as monolithic Rails apps and, afaik, Github still is.
I know that Twitter migrated to Scala but according to [this guy](https://www.quora.com/Why-did-Twitter-switch-to-a-Java-based-front-end-after-successfully-using-Ruby-on-Rails-with-200-million-users) which apparently is a SE at Spotify it wasn't a mistake to choose Rails to begin with. It just later turned out to not be the ideal solution. I don't know about PagerDuty but according to some technology lookups they still use Rails and Wordpress (what a combination). Do you know what they switched to? But generally I don't understand how that backs up the argument. If some big company migrates it's C/Java-backend to Go, does that mean C/Java doesn't scale well or is slow? Facebook uses PHP but also contributed a lot to the language because it was just not good enough for them. Does that mean PHP is the way to go because Facebook did it successfully?
To be honest I mostly looked into dry-validation (bc it was in this subreddit). Maybe it's just me but for me it is a very-verbose (or explicit as they label it) way of doing the same thing with a fancy DSL which isn't that explicit anymore in my opinion. Example: `required(:age).maybe(:int?)` I mean I can guess what it does in this case but "maybe" for me means it could also be a string and just "may be" an integer, anything would be valid. I personally find `validates :age, numericality: { only_integer: true }` more explicit and more clear by just looking at it. The only reason I see to use it is if you want to decouple validation from your model which is a legit concern but I've never encountered the need. Also I don't really like the "abuse" of the syntax to create completely new semantics. What if I want to use binary operators in my validations? The "abuse" of `&gt;` makes it hard to understand at a glance if this is DSL magic or an actual comparison, etc.. Also it doesn't DRY up anything in my opinion, it just changes the DSL. I know that you can reuse the schemas but I can't think of a way where this makes sense. The example in the documentation just cries out loud for a second model to be introduced. Maybe it makes more sense if you work on dozens of projects?
&gt; Maybe it's just me but for me it is a very-verbose (or explicit as they label it) way of doing the same thing with a fancy DSL which isn't that explicit anymore in my opinion. This is a **data** validation DSL, it's not the same thing as AM::V/AR::V. Try to write type-safe validations for a big, deeply nested data structure with AM::V - it's a huge PITA, and this is one of the many reasons why I'm working on dry-v...to make it simpler, safer and faster. &gt; I mean I can guess what it does in this case but "maybe" for me means it could also be a string and just "may be" an integer, anything would be valid. "Maybe" values are a well known concept in other langs, it's just not something that's popular in Ruby (yet :P) so there's a learning curve involved ¬Ø\_(‚äô_ ñ‚äô)_/¬Ø &gt; The only reason I see to use it is if you want to decouple validation from your model which is a legit concern but I've never encountered the need Yep that's the thing - I stopped validating data using domain objects, it's an anti-pattern. Data coming from the outside world should be treated as a boundary, and should always be validated/coerced prior sending it to lower levels of your app. See the recent Rails CVE with `params` data sent directly to AR's query API causing a security risk. I can't stress enough how important this is. Literally every Rails app I've seen have controller actions with security holes and/or silly bugs where crashing the whole app is as simple as sending a request with some garbage in params. On a larger scale this results in pretty serious consequences where your exception-tracking software is flooding your inbox and fixing bugs can take weeks or even months. This is the direct result of the approach most Rubyists use for data validation - ActiveRecord + AM::V. It's obviously needed to perform all kinds of domain-specific validations at the model level, I'm not questioning that of course, but the lack of understanding about type-safety and how to deal with data at the boundaries of your apps is troublesome. &gt; What if I want to use binary operators in my validations? The DSL is used only for composing rules, the actual validation logic is implemented in predicate methods, where you can use whatever you want. This is a strict separation, by design, as we want to support very complex rules too, allowing arbitrary code in the DSL would make it much harder or even impossible. &gt; The "abuse" of &gt; makes it hard to understand at a glance if this is DSL magic or an actual comparison, etc That's just an alias for `then` method to make things more concise, just like `&amp;` is an alias for `and` and `|` is an alias for `or`. These are small syntax details though, I wish people focused more on how powerful this is instead ;) Anyhow, the DSL is still evolving, we're gathering lots of feedback and keep improving things. FWIW I'm not very happy with `&gt;` and use explicit `then` instead, but there was no other operator available that could represent implication. &gt; Also it doesn't DRY up anything in my opinion, it just changes the DSL We had cases where people ported their AM::V-based models to dry-v resulting in ~50+% less code, so I guess it actually does DRY up things.
Spotify is another that I forgot, huge app and user base. PagerDuty still use Rails but have split it out into more microservices, from my brief discussion with their engineers. The argument is that Rails is great for rapid development in most environments. The fact that companies move away from it when they get to a certain scale is not a criticism of Rails, it works and can scale massively but at a certain size organisation a monolithic app no longer works well. There is no single framework for all applications of all sizes.
That's basically how I already use Ruby. I've already switched pretty fully to Elixir/Erlang for anything that needs to fit into a client/server model (like web applications), but Ruby is still about as ideal as it gets for me right now when it comes to writing up single-user software (though I've been experimenting with some other options lately, like Rust and Scheme and even a bit of Tcl).
Very helpful advice! I had to create a context nested beneath the `each` loop, and then had to put the `goto url` in a `before(:context)` block. Worked beautifully. And the failure messages were super opaque without interpolating the month name into the `it` text, so thank you also for that tip!
I wholeheartedly agree. Ruby for the web just can't cut it in a world where JavaScript is fast (and maturing), the JVM has sane languages and frameworks, and Elixir/Erlang is (finally) picking up steam. It is, however, still a great option for the kind of glue work that holds everything together.
The biggest problem with the ruby community is the sharp turn towards SJW issues instead of programming.
To give a little more context: I'm building this app for personal use only. It it a web interface to manage deploys of my other projects. It's main functionality is to create files in static directories and deploy them to S3 (which statically serves them as individual websites). So in essence my app is designed to edit the source code of these static websites. It uses `aws s3 sync` to push the changes to S3. This is a really important feature as these static sites are large (they include media files) and I can't just push the whole thing to S3 every time. I can build the `dist/` folder into `tmp/`, but I can't edit the source code of the subprojects used to build `dist/` unless I copy them into `tmp/` on a per-request basic (resource-intensive, undesirable)
Just wanted to quickly mention that functions and methods are not two different things. Methods _are_ functions, with a little bit of extra functionality sprinkled on top (e.g. implicit receiver argument).
You ever thought of just spinning up a linode box, turning backups on and just running it there? 
I just had a quick looks through all the code, and it looks good! It proves that you understand Rack, routing, controllers, views, DSLs, gemspecs, testing, RSpec, etc., so I'm guessing it will be pretty helpful when you're interviewing for jobs. If you have any specific questions about the codebase, feel free to ask.
For a bit of context at PagerDuty, as of August 2016, we use Ruby (&amp; Rails), Scala, Elixir (&amp; Phoenix), Go, Swift, and Javascript (&amp; Ember), each language &amp; framework chosen depending on the team &amp; problem that it's best suited to help solve.
Not sure I wholly follow. Ruby can absolutely cut it as a language driving web servers. Rails is terrific in that regard, and the throughput on jruby is downright respectable. The closest thing to the kind of "glue work" you mention that I do is things like accounting systems. So, yeah, Ruby is fantastic for that, too.
 You can also use AWS, their free tier will get you a micro instance for a year. The instances can persist data to disc, that's not a problem on AWS. Maybe if you use ElasticBeanstalk I guess... I'd go with Digital Ocean. You can get a decent VPS from them for $5/mo. Their web UI is a hell of a lot easier than Amazons. 
I love Ruby, but these days I cannot justify using it as a server-side language when there exist more attractive alternatives. Scala and Elixir are my server-side picks since they have the same level of expressiveness that Ruby has without sacrificing concurrency, performance, and scalability. I can stand up a new service just as fast in those languages as I can in Ruby, yet I have a clearer plan down the road if I ever need to scale.
Because in the (very likely) case that something will go wrong with the server you maybe don't want to spend all those cycles setting back up nginx, puma, ruby, etc, etc. Back your shit up, you will thank me later.
This seems like a very good candidate for micro-, or at least smaller services. 2000 models is unwieldy. 
Puppet and Chef are written in ruby, and don't really have anything to do with web development. Our mobile app is LAMP for historical reasons I haven't fully understood yet as I'm new, but we deploy it across 5,000 servers primarily with Puppet. 
If what you say is true, they're not developing their app on Wordpress, nobody competent would. Without delving into shit, app.pagerduty.com likely runs Rails (www.)pagerduty.com likely runs Wordpress. www was drupal at our last shop (I hate drupal with a passion and never touched it, I'm not exactly sure who did, probably corporate marketroids), but the actual app that I worked on was all Rails. The only bridge between the two was a "login" link on www.
Thank you it worked when i changed to ARGV.shift 
&gt; Multiple options are good. Use the right tool for the job. I agree with that, but each tool should also have the reason for their existence, something that makes it better than the alternatives. If a tool doesn't have that, then developing it further is meaningless (other than for legacy code) and just steers people away from discovering better tools. Not necessarily saying it's Rails (although ActiveRecord is), but just something to keep in mind.
Yes yes it is!
Yes, they can coexist peacefully, but I was replying to the implication made by mistyfud that Ruby can no longer be used for the web anymore and has been replaced by Javascript or &lt;insert some other oh-so-shiny language here&gt;, which is obviously not true.
Ruby has never been a web-only language. It's just that people typically learn Ruby from Ruby on Rails. Understanding Ruby is assumed to be synonymical to understanding RoR, which is not always true.
Not bad actually. You documented your code well. Here's one minor thing: route ? route : check_variable_routes(url, http) I would rewrite this like so: route or check_variable_routes(url, http)
I actually do have a couple questions, but unfortunately I cannot ask them at the moment. I will have to send a pm tomorrow. Thanks checking it out and giving feedback!
My therapy for a four month drupal contract in 2012 was compiling the below list. Some of this may be obsolete, some of this may be wrong, but it was a thing then in my experience. - Bloated. A blog/store we have is over 300,000 lines of code. - Slow. Ridiculously slow. Slow on good hardware. Frustratingly slow. It endlessly wastes your time as you try and do anything with it. - Every module you add increases the slowness as call_user_func is ran on potential functions your module provides. - So it's naturally a bad idea to write new modules for granular functionality, the best approach for performance is instead cramming everything into one gynormous module file. - The fact that you have to clear your caches all the time to fix random errors suggests caching is inherently broken. It's a stupid little first step in troubleshooting. The only thing I know about that requires some basic stupid first step like that is power-cycling a cable modem, and your cable internet provider's WAN is, well on second thought, probably not as complicated as Drupal. - dblog lacks a search option and limits you to 200 results or so. Worthless amounts of garbage fill that up pretty quick. - In the database, logs are even stored retardedly: why do they serialize an array to store templated data? Do they LIKE creating all this extra load? Make the fucking message be a text field. - Validation error, please try again. An obnoxious, vague error message for which Google has tens of thousands of hits, no good answers. Assholes seem to like posting the URL to that search phrase within Drupal.org, which returns nothing but the cries of lost souls and their unanswered support requests. - Drupal 6's file management is broken, randomly inserting the wrong path into the database and frequent preceding forward-slashes. It was good they rewrote it, but suggests significant defects by design that they had to. - .inc, .php, .module. Fucking annoying. WTF can't they make php files end in .php? - An API that is its own fork down the road into a cold, dark programming netherworld where any new design patterns or programming paradigms will never take on. It's obsolete and awful by design. - Completely non-object oriented. As PHP's object orientation improves, Drupal will never take advantage of any of it. - Except where it does use objects, it does it totally randomly and pointlessly. - Passing everything by reference. - Random breakage. Fixing it is worse than fixing Windows--aimlessly Googling around, trying fixes willy nilly. - Some shit remains inherently broken and has to be fixed with some hack, a bandaid on an artery wound. I've given up trying to understand why things break with Drupal, they just do. (Email logins, Ubercart, D6's file management) - Varying quality. The core poll module needs a contrib module to work properly. Ubercart had a sudden bug with sending email to blank email addresses (on a site that had been up for months) that is mysteriously fixed with a newer version. Some modules don't work at all despite being "stable." Or something is fixed in a development release when it's been two years since a stable release and a year into development. - Notoriously bad learning curve. - Good luck hiring people with a drupal background. - Absolutely NO respect of a development lifecycle. In the real world, people don't do everything on production servers. They have development, staging, and production servers. Drupal is oblivious to this. - So good luck to you if you ever need to migrate just the content of your website or just the configuration data or anything else. - Source control is pointless. You document what you did in an error-prone process. - I have a special dislike of coding PHP in textareas. Every time I've seen this it signifies the wrong/bloated/poorly hacked approach to a problem. I don't think any competent PHP programmer in the history of PHP has started a project with the actual intent of having users code PHP into a textarea. - Fatal error: Allowed memory size of 256MB exhausted. I see it in one site's production logs randomly, I can't go to /admin/user/permissions on another site because of it. Why the hell does loading a log file need more than two fucking hundred fucking six megabytes of memory? - /admin/user/user/list doesn't let you search by username. - Stupid proprietary SQL: "SELECT * FROM {node}" - Ambiguous, needlessly short primary/foreign key fields in EVERY table. - WTF did Drupal 7 condense the menus? Are all these extra page loads to do what I could in Drupal 6 faster supposed to make it easier for me? You know what else goes through pointlessly complex UI revisions all the time? Windows. And even Micros~1 has kept the start menu the same for 17 years. - Is arg(0) going to be the expected and useful part of the URL structure, or is it going to be node, which is worthless? - Default URL structure is stupid. Search engine friendly URLs shouldn't need bolted-on functionality. Isn't even done with any regularity on drupal.org. - The `Drupal` javascript object is its own unfortunate level of complexity. Good luck googling why Drupal.settings.foo doesn't exist when it should. - Weight: Completely counterintuitive. Why should a negative number be listed on top? In the real world, objects do not have negative weight. Would it have been *that* difficult to call it position or order? - When editing destination paths in the menu, Drupal thinks it knows more than I do. Why node/93 is valid and about/contact is not will never be known. Why does it even do validation on a destination path? Why is it protecting me from myself? Why can't I just link where I fucking want to? It's not like I won't find out eventually if the link doesn't fucking work. - You cannot sort lists of content--which sucks enough on its own. But it especially sucks if you have 50 content pieces to edit and because it doesn't display the last-updated field it's sorting on (who wrote this POS?) so it's far too easy to lose your place. What kind of 1997-era bullshit is this where you can't even sort a data table on its fields anyways? - Can't change machine names once you've entered them. - An endless barrage of security updates in modules AND core, demanding hours of QA time to verify any upgrades. - Why are .tpl.php's spread across the themes directory and templates directory? - I had been a PHP developer for 11 years and never in my career have been as demoralized, demotivated, distraught, disturbed, disheartened, disenchanted, dissatisfied ... as I am with Drupal. - A stupid, ridicule-worthy name I just hate; it rolls off the tongue like some foul-tasting glop I'm spitting out. I die a little time every time I read it. I can't say Drupal without saying Fucking Drupal. 
Odd that Grape isn't listed. It's quite a bit more popular and more actively developed than half the frameworks in that list.
Rails is an excellent tool for building JSON APIs. 
&gt; The very first solution, that comes to our mind, is to throw an error in case of a failure. This is the simplest approach implemented in every programming language. This isn't true. The simplest way to signal an error is with a return value (or crashing, heh), and there are many languages that don't have exceptions. 
&gt; Not necessarily saying it's Rails (although ActiveRecord is) Do you mean the pattern or the implementation in Rails? I think there are applications where AR is perfectly suitable and where it's not. I don't think that DM is better than AR in all situations. Both have their place.
No it's not. It's a tool built for another time, later retrofitted for JSON APIs. People still use Rails to do this stuff because it's an easier sell, but it's awkward at best compared to the alternatives.
If you need fast routing, take a look at roda. 
Do tell.
I agree with Ibrtdj. However, as a minor nitpick I would say: `route || check_variable_routes(url, http)` The [`or` and `and` keywords are banned](https://github.com/bbatsov/ruby-style-guide#no-and-or-or) according the style guide. If you **insist** on using them, then [this is how they're used](http://www.virtuouscode.com/2010/08/02/using-and-and-or-in-ruby/) 
Yes it would fail the if block if i had entered 0. My question was, the script wasn't stopping to get the value from the user which was corrected as suggested by /u/rumbling_trashcan. Yes, i had to make few modification such as blowfish = Crypt::Blowfish.new(kee) as per the Crypt documentation where the kee should be a string valid b/w 1 and 56 not an integer. 
Uh, maybe you're unaware, but Rails 5 has an API mode now, where you can set up your project specifically to be a JSON API, right out of the box.
The proof is in the pudding to me. It's not just technical reasons for the success but also how the monolithic architecture reflects an early companies structure. Rails or not is rather irrelevant to me
I agree with your point, but actually I meant [Sequel](https://github.com/jeremyevans/sequel). Sequel also implements the Active Record pattern, but is much better designed and more featureful than ActiveRecord ([Sequel &gt; AR](https://twin.github.io/ode-to-sequel/), [AR ‚âØ Sequel](https://twin.github.io/activerecord-is-reinventing-sequel/)). I don't think it's good that Rails develops ActiveRecord as another similar library to Sequel, if it doesn't do anything better, because it just steers people away from using a better library.
There are security implications of forking to the shell like that. Even if your strings are properly sanitised, you've introduced shell as something that needs to be trusted (Shellshock anyone?). This might not be a concern, depending on your use case.
There are two problems with that. The first is that a Crypt::Blowfish key is supposed to be "up to 56 bytes long". That is very different to "a number up to 56". You should easily be able to see that your code only provides 56 possible keys, and you could write a Ruby loop that would try all 56 of them in seconds, making this trivially cracked. Secondly, you should probably be aware that a gem described as a "pure ruby implementation" for any cryptographic system is going to be completely unusable from a performance point of view. The gem credits "Bruce Schneider" with the algorithm, but they spelt his name wrong. Schneier was quoted in 2007 (nine years ago!) stating: ""At this point, though, I'm amazed it's still being used. If people ask, I recommend Twofish instead." You probably don't want to use Blowfish in 2016.
Thanks man. That makes sense.
I'm not sure what your experience is so I can't speak for you. It may be something easy to deal with, but it's completely foreign to me. I don't want to be hit by any of those "unknown unknowns". And of course it makes sense to have an accountant, but since I know little to nothing about what they do it's kind of a black box for me. Anyways, the time that I've spent has been in doing different research for the type of company I wanted to create and also speaking with various accountants to see if I could find what that puts me at ease. 
Yeah, unfortunately it's really popular in the Rails community to create ActiveRecord-specific solutions :/. Many libraries which are extensions for ActiveRecord are not needed in Sequel (e.g. [activerecord-import](https://github.com/zdennis/activerecord-import)). In general I didn't experience much pain. I needed an ElasticSearch library, but then I manually indexed/deleted in service objects rather than in callbacks, so it was fine. Only file attachment libraries were too ActiveRecord-specific, but now it's fixed with [Shrine](https://github.com/janko-m/shrine). I really understand the laziness, I admit that it took time to understand Sequel. But the more I was discovering its features and design, the more I was motivated to learn it. And I feel that this process has made me a better developer.
Collecting payment is #2 or tied for first. 
I've always asked for 50% upfront and have been a stickler about clauses in my contracts that define extra work and costs associated with them. It helps with collecting payment when you already have half of it. But ya, running after clients for money, especially corporations, is no fun.
Actually, all that the `rails --api` mode does is it removes view-specific middlewares and controller models. It doesn't actually make building APIs easier than regular Rails. Frameworks like Roda and Grape have many advantages over Rails when building APIs. One of the main ones is the ability to handle the route right after you declare it, which is much more readable. It is one of the reasons why GitHub is using Sinatra for its API and not Rails, because Rails forces you to keep this separate in config/routes.rb and app/controllers. There are many other things that Rails is missing in comparison to other web frameworks, just to name a few: * Ability to hook in a DRY way other libraries for serializing objects into JSON (e.g. Roar or Yaks, which have many advantages over ActiveModelSerializers) * Automatic "405 Method Not Allowed" when a route has been called with unmatched HTTP verb * [Proper streaming](http://rosenfeld.herokuapp.com/en/articles/ruby-rails/2016-07-02-the-sad-state-of-streaming-in-ruby-web-applications)
https://github.com/rack-app/rack-app
Lots of points of view, I love it ! Thanks a lot to all of you for your point of view ! If you have more details to share, or know people with the same issues, or people with some good advice, don't hesitate to share the thread with them, I'm sure everyone would love to hear what they have to say. Thanks again !
It's a tool with some basic assertions that are all completely overwritable. If you don't like the base assertions, you can write your own. You can pass in a configuration file with the few rules you do or don't want to enforce. Complaining that running Rubocop without making any adjustments makes it a bad program is an argument from ignorance. Not a very powerful position to be in. It's like arguing that Apache is a bad web server because it doesn't work great because you don't want to learn how to configure it.
I have considered it. There are some sites online that try to streamline the process, but the rates are really low since they are based on a global economy so it's hard for me to compete I think the biggest blockers for me have been getting clients/work and knowing what I should charge for work. I've posted ads online to get some work under the table or in contract, but I just don't have a good concept of what is appropriate for the market. Of course that's the type of thing I could figure out with time, but as someone who hasn't put much serious thinking into things, that would be something I would be curious about: what costs/taxes/breaks am I forgetting about? The biggest motivations for me are freedom to live wherever I want to, having a well-stocked portfolio (although open source can substitute for that), having a better understanding of work and its worth, and the ability to work on a lot of different problems
Definitely finding clients is the biggest obstacle. Most good freelancers get started because they have a network of clients to begin with and just get work from them. To continue to get work you have to both leverage your network of clients to get new clients and be able to approach new clients in a way that will get you more work.
This sounds fun! We will take a look :)
My brother Mislav works at GitHub, so one day he just mentioned that he likes that they're using Sinatra for the API :)
It's hard to decipher the actual point being made in this article. Ruby has functions already (not only are methods sugar on top of functions, but there are `lambda` and `proc` for when you don't want to attach it to a class), and it's not entirely clear to me how a "data type" is different than a class. The article has a bunch of talk about 'the internals of Ruby' this and 'it breaks Rubinius optimization' that, but I'm not concerned about those things. What core language issue is being addressed here?
&gt; The project should die in a fire, and its authors should feel ashamed of ever publishing such pile of crap. If you publish sentiments like this I don't welcome your opinions. Someone wrote that code and thousands of people use it and enjoy it. Please remember there are real people producing these things that you feel a desire to hyperbolically mock.
I absolutely agree. Having an active networks makes for easier times when work slows down. In the beginning it is very much a chicken and egg type of thing. For anyone that is interested, I wrote an [extensive article about freelancers finding work last summer](http://www.letstalkdesign.co/professional-hints/how-to-find-new-clients/).
Because sinatra is awesome :D
Here is a direct link to the actual ByeBug article: https://www.sitepoint.com/the-ins-and-outs-of-debugging-ruby-with-byebug/
It can be misleading if interpreted incorrectly, but it is definitely useful. 100% coverage does not mean that all code is thoroughly tested, but anything below 100% means that it *definitely isn't*. The article correctly points this out by saying that 100% coverage is not some magic goal to attain or an indicator that everything is working correctly. It is instead a simple bare necessity. Having less than 100% test coverage literally guarantees that you have some logic in your code about which you have no way of knowing whether it works as intented, or indeed at all.
That is funny... On the same blog, he explains why software projects are always late and in the sidebar, there's a *Hire me* link. "Hum, no thanks, I like my projects to be delivered on time and budget".
Ugh, if the issues you describe are happening to you frequently you are suffering from a lack of skill (or self awareness of your skill level), it is not that quoting is impossible. 
Postgres queries are run through a "planner" which determines the optimal execution method. Even if you have defined an index on a particular column, the planner can decide not to use it. Why would the planner decide not to use an index? Because sometimes reading the table sequentially is faster than reading a collection of rows at random table locations. In fact, if the index returns more than 5-10% of the rows in the table, it will likely not be used. This is especially applicable to boolean or enumerated columns because of the limited number of values. For example, if your rows are roughly evenly distributed 'true' and 'false', the index would be returning 50% of your table at a time - at which point a sequential read will be faster every time. You now have the overhead of maintaining the index and you are gaining nothing. However, if 5% of the rows in your table are 'true', and the rest are 'false', then queries for 'true' rows are going to use the index and be much faster indeed. This is a good read on the subject: https://www.postgresql.org/docs/9.1/static/using-explain.html tl;dr depends on the number of "states", their proportions in your table, and what you are usually looking for.
Wow. Thank you for that insight, I wasn't quite aware of PostgreSQL internal mechanism to overlook the index. I will read more about the planner and update my article regarding it.
Related http://www.paulgraham.com/diff.html
I'm surprised this didn't happen already, good invisible improvement. 
https://github.com/NoryDev/somewherexpress/pull/33/files Actual diff if anyone is interested.
What about this? http://ruby-doc.org/core-2.2.0/Method.html#method-i-unbind
Cool beans.
This is largely due to too many douche coders writing bollocks Ruby.. FFS make it clean, simple, write fucking tests c**t. Observe SOLID. 
I'm a supporter of abstraction when it comes to databases. Might look into this at some point.
&gt; too many douche coders writing bollocks Ruby You've never looked inside a PHP codebase have you? 
try ColdFusion too... its an inner circle of hell.
So many bad devs. But you're gonna get those anywhere. I'm busy being a lone rails/ruby dev among php/laravel devs. Its hell. They don't write tests. Their apps have a ton of problems that should never even be a thing. Tooling is a joke. I literally can't even. 
Yeah I didn't know either. Luckily I've never had big flash now messages.
C42.in, the company behind RubyMonk is bought by an investment group.. I'm assuming they won't continue sponsoring this platform, since it's down for quite a while now. http://economictimes.indiatimes.com/small-biz/startups/go-jek-to-set-up-development-centre-in-india-with-acquisition-of-c42-engineering-codeignition/articleshow/51048406.cms
&gt; Great, I don‚Äôt want to make decisions, give me some conventions Excuse me, but isn't that what you get paid to do? Making thoughtful decisions about code organization, design, and architecture is part of the job description, right? Trailblazer looks interesting, and I don't want to take away from it -- much of the article was informative and well thought out, but I've seen this attitude before and find it counter productive.
"It's a poor craftsman that blames his tools." Ruby has some problems, and yet I love it. Same goes for JavaScript. And as for PHP, right now I'm working for a company that built a successful telephony product with PHP which has scaled impressively. A lot of the pain points mentioned are there, but they're good developers.
Bye.
Oh man. RubyMonk was probably the best code/tutorial site I've ever used!. It has been down for a while, I'm starting to doubt it will be up again.
One example of tooling: you have app/models/foo.rb and spec/models/foo_spec.rb. Vim's rspec plugin can auto-run the specs when you change the associated model due to this convention.
Yes. But my critique wasn't about Trailblazer itself. Someone with the attitude reflected in my original quote will follow the letter of the convention introduced by the concepts directory, but completely miss the spirit.
Not an rspec user, but the same plugin works fine for libraries, right? `lib/foo/bar.rb` can run `spec/foo/bar_spec.rb`. The coupling there is just symmetry between source code structure and unit test structure. In fact, I believe it will work fine for your example without any specialized configuration for e.g. the `models` directory. That particular feature isn't my cup of tea, so I admit my bias, but the realm of "development environment creature comforts" doesn't seem like it ought to be a driving force behind design decisions.
Yeah no. Not the right subreddit for this. This subreddit is about the computer programming language.
Is it bad that it bothers me more that the title is misspelled than the fact that this is the completely wrong subreddit?
The described difference in return behavior between procs and blocks is incorrect -- there is no difference. In both of them, `return` returns from the method the proc/block was _defined in_. You get 'unexpected return' if the context the proc/block was defined in doesn't allow return, it wasn't in a method. But in fact they work the same. I will demonstrate that below. Also, the examples are confusing because the statement `puts x` actually returns nil for any `x`, so `return puts x` is actually always `return nil`, although with a side effect of printing to console. In my examples I'll avoid that. def my_method yield "method" end my_method { return 'block' } # =&gt; raises `LocalJumpError: unexpected return` def my_method(proc_argument) proc_argument.call "method" end my_method(Proc.new { return 'block' }) # =&gt; still raises `LocalJumpError: unexpected return`! def proc_method Proc.new { return 'proc' }.call puts 'method' end proc_method # =&gt; returns 'proc', `puts 'method'` is never called def my_method yield puts 'after yield' end def calling_method my_method { return "returned early" } puts "after the call of my_method" end x = calling_method # =&gt; x is set to 'returned early', neither of of the `puts` statements # execute and print anything to console, because it returned early Procs and blocks behave identically with regard to `return` -- in both cases, the return will cause a return from the _place the proc or block was defined_, and in both cases you'll get a LocalJumpError if that place doesn't allow 'return' (because it's not being executed as a method body). Procs and blocks are essentially identical semantically -- a block is just a syntactical construct used as a shortcut for passing a proc to a method as an argument. Ruby _could_ exist without blocks (well, except for the one you need to give to `Proc.new` to define a proc!), but compare this: array.each(Proc.new { |i| puts i }) To this: array.each { |i| puts i } A block is just syntax support for passing a single proc argument to a method, to make it so much nicer to read and write methods that take a single proc argument. Well, plus, `Proc.new` still needs a block passed to _it_ to define it, but we could imagine a different ruby that does things differently, say: x = Proc begin puts i end array.each(x) But fortunately we don't have that ruby, we have the one with blocks, because they are part of what make ruby so nice -- the ease and clarity of passing a single unit of code as an argument to a method, which turns out to be something you want to do all the time. 
I was curious about trying contracts.ruby and had considered even trying to build something on top of it to automatically and/or easily formalize duck types in some way a little like go's protocols or something, but then I started reading about [RDL](https://github.com/plum-umd/rdl) and I think it can already do everything I wanted to do...was tentatively doing to call it "Duxedo", to, you know, formalize ducks :-} 
RDL looks way cool. Duxedo is such a good name I'll be personally offended if you don't release a package with that name someday.
WTF? This is a waste of bytes to transmit and of seconds to read.
Is pythonmonk in the works also? Thanks for the hard work!
I think it's worth noting that Bash for Windows could be very useful for this in the future (it's still very much in beta). I've been doing some testing and was able to get the Linux version of Ruby running fine, but there are a few issues regarding file/folder monitoring which makes working with Rails or anything else that watches for changes a little frustrating. Depending on what OP is doing, this may be an option worth looking at if he doesn't want the overhead of a full VM.
Unfortunately not an option as it looks like the beta Bash is for Windows 10 only.
That's true, it's Windows 10 only. But if you ever update, it's a pretty cool feature. It's native support for Linux binaries - no virtualization or anything.
The problem is, is that the output from `ri` is a mix of plain text and Ruby code, so a syntax highligher will not know the difference between the two. For example, try `brew install highlight` and use this command: ri UniMIDI::Input.gets | highlight -S ruby -O ansi Which give me this output: http://i.imgur.com/UTwKLBl.png As you can see, the syntax highlighter is very confused as to what is Ruby code and what isn't. IMO it is better but the results vary, as seen here: http://i.imgur.com/6DyEhQM.png That one actually highlights some Ruby code but also highlights a nice amount of non-Ruby text and kinda just gets in the way to me. Furthermore, piping into `less` results in showing some ugly hidden characters, as seen here with `ri CodeRay::Duo.new | highlight -S ruby -O ansi | less`: http://i.imgur.com/5mesCJR.png Using the `-r` option with `less` drops those characters but output is unexpected as it will sometimes drop the character after a `^H` which ends up with `CodeRay::::uo..new` which... sucks.
Feels like a classpath issue to me. 
Rails lets you put things in any direct sub-folder of app/, and it works just like any other existing folder in app/. Since 4.0 I think. I make frequent use of this. 
ah yeah of course, I forgot to mention them (will do an update today) Well yes I fully agree that resquent specs are better in sense they provide full experience of how the request is behaving. But problem is the way how Request specs report errors. It's bit easier to discover errors in controller spec. My understanding is that the recommendation is to use both: Controller to have mock internals while Request spec will do the full smoke test experience (hitting DB and every layer). I fully agree with this approach but didn't wanted to turn that Article to Request vs Controller test debate/guide, more focuse on the `match` matcher as JSON comparison tool. But I'll definitely mention something there. 
....or more like Controller spec helps you do your TDD cycle right (no matter if you choose mockist or integration path) while Request spec will ensure everything actually works (as a smoke test) :) 
Use the bash that comes with git
In Rails a named scope is essentially a lambda if I'm not mistaken. Though I can't think of any time other than that which I needed to use them.
no douche coders use ES6? They all write SOLID code? duuuuubious. 
It looks like that argument to `scope` can be a lambda or a proc. All the examples in the docs show lambdas, though I'm not exactly sure why. Maybe the authors of the docs think `-&gt;{}` reads more nicely than `proc{}`.
&gt; . Blocks are one of the few things in Ruby that are not objects Reading that, I immediately dove into irb: irb(main):001:0&gt; loop.class =&gt; Enumerator irb(main):001:0&gt; pp begin.class irb(main):001:0&gt; def m(&amp;block) irb(main):002:1&gt; pp block.class irb(main):003:1&gt; end irb(main):005:0&gt; m { hello } # =&gt; Proc indeed. appears so. But maybe I am looking at it wrong. Do you have any deeper information on this? 
Have a look at: http://iamvery.com/2016/03/21/ruby-blocks-are-not-a-thing.html Basically, "block" either refers to the syntax (`do`/`end` or `{}`), or the hidden internal implementation inside the VM. Instances of the `Proc` class are able to call into the hidden internals, and that's how you use blocks as objects/values.
thanks again for this! everyone is having fun running your code and thinking of ways to improve, and appreciate that you've been super helpful and friendly! such a great way for us to get introduced to the process of contributing to an open source project.
Here's an article posted on here a couple days ago. It does a good job of explaining it. http://blog.redpanthers.co/lambda-vs-proc-vs-blocks/
I use lambdas all the time, I don't think they are rarely used at all. But yeah, lambdas and procs are _often_ more or less interchangeable, I wouldn't worry about when to use one vs the other. If you run into a case where it matters, you'll know. 
Almost anything that can take a proc or a lambda as an argument can take either one. They are basically interchangeable -- especially as far as the _caller_ (the thing provided the lambda or proc) is concerned. In both cases, you just take a thing and call `thing.call(args)` on it, and it works. You can also pass either one to a method with a block argument using the `&amp;` syntax. 
IIRC the ampersand converts a block to a proc
It's not going to make any speed increase in development mode as rails will reload the code from disk instead of caching it. Unless you've turned all of those off in development 
Side note: this is a great subject, that I have come back to multiple times as I've been learning ruby. Taking the time to understand it can be greatly beneficial. Block usage can really simplify your code. Being able to take some generic method, and insert just a little bit of behavior into that method by calling a block makes it much easier to avoid copy/paste coding. The biggest key for me was mastering the `#inject` method. The rdoc is deceptively short and sweet, but understanding what it does when you pass it a fleshed out block, or a value and a block, or calling it like this `#inject(:+)`, teaches you a whole bunch about the hidden `send` calls happening in inject, and really grounds you in exactly what a block does.
Hrm, I've never done that in Sinatra/unicorn. Guess I'll poke around.. if you have any links.... I'd really appreciate it. 
I think for a beginner there is really only one important concept to understand, and that is how to make functions that accept blocks (either using `yield` or being more explicit using `&amp;block` and `block.call`). In this use-case you won't need to call `Proc.new` or `Lambda` - the block provided when the function is invoked will be converted to Proc. Lambda and Proc have a lot of other use-cases related to functional programming (this is Ruby's version of the "first-class functions" paradigm you see in Javascript), but it'll be less common in Ruby than, say, Javascript. You'll also find people trying to be really fancy and use all the difficult, metaprogramming aspects of the language. They'll probably be using Procs and Lambdas as a matter of style (the hipsters of Ruby ... ok, I may have done this myself at times).
Besides, `scope` is basically the same as defining a class method on the model. 
After few hours of browsing different blogs on the topic, this was my conclusion, Thanks a lot for confirming :)
Lambdas check that you are calling them with the correct number of arguments. I use them constantly as I feel that more correctness checks are always better.
Keep in mind faster_path is faster not so much because it uses Rust but rather because it uses simpler code that handles fewer edge cases. Sprockets also uses faster code when it can (i.e. not on Windows). Try it if you want but just know it's not 1:1 with the Ruby stdlib.
This is pretty cool
why not store the image to your file system? check the time stamp of that image before trying to fetch a new image. 
Are these all plugins for web frameworks?
wow this sounds amazing! Are there any tutorials/videos/blogs on how to use it other than the original doco? And be nice if someone can link more blog post about this.
I think they are all pieces of its own overall framework. 
Since it's every time shared by someone else, it probably means that many people find it useful. I agree that blog posts are good visualisation, I'm sure someone wrote about dry-rb. For the record, 80% of things shared here and on RubyFlow are about Rails or Rails-specific. So for people who aren't using Rails that also tends to get a bit boring ;). So for a non-Rails person like me, even if it's not something I'm using, it's nice when people share generic tools that can be used with any web framework.
&gt; it's nice when people share generic tools that can be used with any web framework. No argument there. It's just a frequency thing. Spam comes to mind. I can't think of another project that gets posted here so often.
I really wanted to use dry-validation, but the documentation doesn't really go into how to use it as a replacement for strong-parameters. I tried to figure it out myself for a couple hours, but could never get it to act as I needed, especially when trying to handle errors using active model serializers as easily as strong-params Maybe I'll revisit it in the future, because I absolutely hate strong-params for defining complex per-action schemas.
dry-auto_inject looks like a horrible anti-pattern.
Well, dry-rb is a collection of gems that are actively developed so we have frequent releases. Not sure why posting about that here is annoying. It's like saying that every other post about every other gem is spam and annoying. I really don't understand your reaction.
I'm talking about this code: AutoInject = Dry::AutoInject(my_container) class PersistUser include AutoInject["user_repository"] def call(user) user_repository &lt;&lt; user end end This is a classic service locator pattern, which is very arguable pattern at least. You can read about this at [wiki](https://en.wikipedia.org/wiki/Service_locator_pattern) and look how many disadvantages there are. The main thing - dependencies are really unclear (in comparison with dependency injection). The second "bad thing" for me: include AutoInject["user_repository"] Technically it's a module (constant), but in the fact it's just a global variable, it's a preconfigured object. It's just a global registry. And there is a thing - I do not think, that mixing configuration and declaration (in this case class declaration) is good practice. But in this case they are mixed. It means, that you have to configure you registry before you require file with this class. It's not even calling registry in constructor or other method. I could use "dry-auto_inject" just as a simple service locator, to get objects which I need in multiple places, and which have other dependencies. But I would pass all the dependencies into constructors of objects. For example: my_container.register('user_repository', -&gt; { UserRepository.new }) my_container.register('notificatior', -&gt; { SmsNotificatior.new(config) }) my_container.register('user_notifications', -&gt; { UserNotifications.new(my_container['notificator'], my_container['user_repository']) }) 
Totally. The one I ran into that drove me insane was the word Processor and more recently Provider. These words add nothing!!!
Except in Rails, models aren't models, they are your persistence mechanism which has nothing to do with business logic. So you either move your business logic somewhere else, service objects, or you move your persistence somewhere else, repositories, or you have a great big pile of mud, the rails way. 
I'm very new to ruby and Rails but I come from JS where it's similarly always drama within the community over something. Just do what works for you and your workflow and don't get bogged down in the politics.
Definitely. I just assumed I was using it wrong since the documentation doesn't go over my use cases/assumptions. I'll open an issue sometime next week.
No. A model in Rails is in no way required or associated with ActiveRecord. You simply have the ability to extend a model with ActiveRecord. Read the Wikipedia article on MVC. Business logic goes into the models, and models DO NOT mean persistence. Simply drag your service object into the models folder. Done. Edit: Revel in the amazingness of having related code near each other in a beautiful hierarchy of namespaces and not having two switch between folders every 2 minutes! What you are describing is a pile of mud. This is a pile of mud. 8 years of experience here sorting through mud like this, and I am telling you - this is the very definition of unnecessary complexity.
yeah, I actually hate the name 'service object' skinny_controllers, trailblazer, etc call them operations -- which I think makes worlds more sense.
If I remove the path it spits out this: D:/Ruby23/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:55:in `require': cannot load such file -- gobject-introspection (LoadError) from D:/Ruby23/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:55:in `require' from D:/Ruby23/lib/ruby/gems/2.3.0/gems/gdk_pixbuf2-3.0.9-x64-mingw32/lib/gdk_pixbuf2.rb:17:in `&lt;top (required)&gt;' from D:/Ruby23/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:55:in `require' from D:/Ruby23/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:55:in `require' from D:/Ruby23/lib/ruby/gems/2.3.0/gems/rsvg2-3.0.9-x64-mingw32/lib/rsvg2.rb:18:in `&lt;top (required)&gt;' from D:/Ruby23/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:55:in `require' from D:/Ruby23/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:55:in `require' from D:/Ruby23/lib/ruby/gems/2.3.0/gems/squib-0.10.0/lib/squib.rb:4:in `&lt;top (required)&gt;' from D:/Ruby23/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:127:in `require' from D:/Ruby23/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:127:in `rescue in require' from D:/Ruby23/lib/ruby/2.3.0/rubygems/core_ext/kernel_require.rb:40:in `require' from C:/Users/pchi/Documents/RubyTest/Hellow.rb:1:in `&lt;main&gt;' Single or double quotes produces the same results. But if I added the /Ruby32/bin/squib inside, it spits the above error in the main post.
for me, the name is just bad. I like the term 'operations'. Unfortunately, people understand 'service object', regardless of how related-to or not the class is. If I have something that communicates with Stripe or some other API, I'd call that a service object.... cause the api I'm interacting with is a service. :-)
you should look at rails. There is always a ton going on to provide conventiony things.
one of my personal tasks for when I have freetime in about a month or so is to be able to group things together into pods (like in ember). so, instead of having app/controllers, app/operations, app/policies, etc you'd have - app/ - resources/ - events/ - model.rb - controller.rb - operation.rb - policy.rb - etc Hopefully I can just make it a seperate gem, so just anyone can try out / slowly migrate to the new structure. 
yea, require_relative is really for things that are in your local path, so not a lot of help. I would check your all env paths are set, HOME and ruby is in your paths (think you said you set that already). The error sounds like it finds the gem, but doesn't load properly. It could be a problem with the gem, or you may need to even specify the platform. Sometimes gems are put into lib/$version and not /lib etc. Tons of stupid fun stuff to try. uninstall the gem, and install with --platform=ruby
Sorry to hear you're frustrated! I was interested, so I made [a quick search for mentions of dry-rb within /r/ruby](https://www.reddit.com/r/ruby/search?q=dry-rb&amp;restrict_sr=on&amp;sort=relevance&amp;t=all), and discovered this is actually the first ever posting of the main dry-rb homepage (the original poster isn't affiliated with dry-rb, so they must've just found it interesting, which is nice to see!). The other 6-7 postings directly mentioning dry-rb are spread across the last 4 months, and they're announcements, tutorial-style blog posts, and a conference talk. Like sonic said, we're working on these things actively, and we hope to continue to share interesting news and stories as we go. You can trust that we won't just go sharing our homepage willy-nilly :)
probably because it's a family of libraries than a monolithic library. different people nibble on different parts of it. in contrast, libraries like hanami seem to be take-it-or-leave-it propositions, and get posted less often. 
op here. I'd love to be an author of this pull request but I'm not :) Just found it worth sharing
for now have this in your gemfile: gem 'squib' gem 'gobject-introspection', '~&gt; 3.0.0' gem 'gio2'
i think you mean soccer.json ;p
&gt; 6-7 postings directly mentioning dry-rb are spread across the last 4 months, I think that is a hell of a lot of self promotion. And let's be real about this... it looks like the project launched about 5-6 months ago so to me that seems like a lot of posting. If I search this sub for "Introducing" and then look for other projects as spammy as dry-rb, I don't find them. Do you? This is the crux of my argument. &gt; and they're announcements, tutorial-style blog posts, and a conference talk Let's get real here too... I see an article posted twice and a project rename in that list masquerading as news. Makes the project look thirsty/desperate IMO.
u/solnic I'd love to see a response from you that addressed my OC, since I do see most of the spam coming from you. Is there a reasonably complex app built with dry-rb that I can evaluate? Something larger than a toy app, that starts to really show the benefits of using dry-rb vs Rails?
I don't understand. Can anyone explain?
Deoptimization is the process of *removing* an optimization that was based on an assumption that has been invalidated. The first example uses constant folding, but the second one, method inlining, might be more accessible. Say you write a class that calls the same method over and over in a loop. The VM could inline that method to save on jumps/method invocation setup/etc. but then you have some code come in and change the definition of the method. Deoptimization is the process of checking for these cases and reverting the optimization that is now invalid. It's basically a given in JIT code, especially for dynamic languages. In this case it looks a bit restricted since they have to keep some VM internals consistent, but it seems like a great step forward for 3x3 and may pave the road for further optimizations later. 
Ha. I guess you must be from the United States - in the rest of the world it's called football ;-) PS: There's already a great nfl database - see https://github.com/BurntSushi/nfldb by Andrew Gallant. Let's you download the SQL (PostgreSQL) data as far as I know. Not sure about the JSON export - can't be that difficult ;-) Note: However, all the "machinery" is in Python.
Interesting, thanks!
I may not understand your problem exactly. But.... a thread in a Rake task is in a different process than your web server. They'll never be able to see each other, you'll need IPC to kill a thread in your server from a Rake task. Also, this won't scale once your app is deployed. Edit: if you share some code I can help more with the pry wtf. 
Hm, so I think your suggestion just gave me a clue to why I'm running into this issue in the first place. C:\Users\pchi&gt;bundle install Could not locate Gemfile or .bundle/ directory I have no clue where my Gems have been being saved in the first place.. Nor do I know how to find out.
Neat. I found this similar (maybe related to openfootball as it uses flat files) for American Football that appears to be out of date: https://github.com/opensport/american-football.db 
Thanks for highlighting the (American) Football repo. Yes, the [data schema](https://github.com/sportdb/sport.db.models) and machinery works for all kind of team sports (hockey, rugby, etc.). You can find all ruby gems in the sportdb family in the [sportdb org on GitHub](https://github.com/sportdb) (and on RubyGems for download - of course). PS: You might also be interested in the beer.db (see [/openbeer](https://github.com/openbeer)) - same idea - also kind of related to football;-) Cheers. Prost.
Great. But how come it is local? Do I need to have a server to host it?
Can you show some code that describes what you're talking about here? Preferably a non-toy example?
&gt; and models DO NOT mean persistence. Isn't that what I said? &gt; Simply drag your service object into the models folder. Done So you're saying the 'type' of the object is determined by the name of the folder it's in? And your definition of "a pile of mud" is having too many directories? Dude, you need to invest in a decent text editor. PS Wikipedia, LOLZ
"The implementation is pretty ugly" ... I find that hilarious compared to trying to read Lisp. Beauty is in the eye of the beholder I guess. I for one love ruby because it reads the most beautifully to me.
https://c9.io/
Seconded. Cloud9 is a great IDE for developing. 
Thirded. c9 is about as close as you're going to get to a real development environment on a unmodified chromebook.
Being a long-time Sinatra user, this looks pretty good for a few apps. Good job on the home page. I submitted it to HN and it apparently was not submitted yet, maybe you want to give it an upvote to get it visibility. It may be in the [newest](https://news.ycombinator.com/newest) feed still. Edit: typo
&gt; I do see most of the spam coming from you Since March 16th I posted 6 links about dry-rb gems. 2 about dry-validation, 1 about dry-types, 1 about dry-transactions, 1 about dry-system and 1 linking to a conference talk. Spamming? Seriously? We had probably more than 50 gem releases during that time and nothing was shared about any of these. We're trying to share information that's substantial, whenever some important milestone is reached, we also try to cover that by a blog post to give people more insights, rather than just pointing to a changelog. I always thought this is a nice thing to do to let the community know about what you're working on. You're clearly attacking the project and the people behind it, which is not a nice thing to do given that it's an OSS project, built by people in their "spare" time, people who simply try to improve the ruby ecosystem. I've found your feedback to be toxic and unpleasant. When I see something that doesn't interest me, I just don't read it. Downvoting and attacking people like you do is just sad. &gt; Is there a reasonably complex app built with dry-rb that I can evaluate? Yes, but it's not OSS, so I can't show it &gt; Something larger than a toy app, that starts to really show the benefits of using dry-rb vs Rails? There's [Berg](https://github.com/icelab/berg) which is a simple CMS for running a site with a blog section, but I wouldn't call it "reasonably complex" and at this point it mostly shows our preferred way of structuring and implementing a web application (using DI for everything, moving away from classic MVC, not using a typical ORM, etc.).
awesome, looks promising ‚Ä¶
 thank you @cpg, it's a honor! I'm a big Sinatra fan myself, but you can see that from my code. I used parts from the Sinatra api Syntax DSL, because I think it's really readable! And because I love it. : ) 
I posted a question there to get traction. May want to answer. It could be great to be on HN. Come to think of it, it's coming up Monday morning (though I am in the US West coast) and it could get lots of exposure if it makes it to the front page.
I was thinking of getting myself a white board for stuff like this but I'm not at that point yet. May still get the white board though üòÄ.
not running a (local) server == need javascript. If you are ready to have some server running (locally or on the cloud for you), you can do what you want and you will have to generate HTML from your server. To get started, have a look at http://rubyonrails.org/ for a very extensive webg framework, or https://github.com/soveran/cuba#cuba for example. The rest will be API plumbing, mostly. Good luck!
Thank you for your reply. I was planning on learning rails but it's too much information to assimilate just for this small project. Is there a way of running something like coffeescript in the browser, compiling it on the fly, without a server?
If rails seems daunting, have a look at cuba then, it might be simple enough for you. The part with coffeescript compiling on the fly requires an initial server to send the data on the client (and updates it). Also if you don't like javascript, you will soon no longer like coffescript...
Most of the gems are usable for a quick overview (I use them to get a quick idea of whether the system follows OOP principles). For anything serious though I can recommend visual paradigm (https://www.visual-paradigm.com/) and the UML tools. I don't think think you can currently import Ruby but you will end up with a better result in terms of having a tool you can use to engineer an application.
Do you know any gem that are not related to rails?, I mean just for ruby?
How does it stack up against Go? I can't find any comparisons that make sense.
If you want try something a bit more unusual, you can use [opal](http://opalrb.org/) - a ruby to javascript compiler. While it is better to compile on the server (faster and smaller pages), it is completely possible to do it complete in a single html file. [See this codepen for fetching reddit stories from a selected subreddit](http://codepen.io/nanothief/pen/GqVZJa?editors=1000). It technically does satisfy your goal of a custom start part using ruby, without running a local server and not having to write any javascript. Note that I've never used opal in a serious project, so I can't give you much feedback there. It does work fine for this example though! Source: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;script src="http://cdn.opalrb.org/opal/0.10.1/opal.min.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.opalrb.org/opal/0.10.1/native.min.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.opalrb.org/opal/0.10.1/opal-parser.min.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.opalrb.org/opal/0.10.1/promise.min.js"&gt;&lt;/script&gt; &lt;script src="http://code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.opalrb.org/opal/0.10.1/external/opal-jquery-0.4.2.js"&gt;&lt;/script&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;Opal.load('opal-parser')&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/ruby"&gt; require 'promise' def get_json(url) promise = Promise.new HTTP.get(url) do |response| if response.ok? promise.resolve response.json else promise.reject response end end promise end def refresh loading_indicator = Element["#loading-indicator"] reddit_news = Element["#reddit-news"] reddit_news.children.remove subreddit = Element["#subreddit-chooser"].value subreddit = "all" if subreddit == "" loading_indicator.show get_json("https://www.reddit.com/r/#{subreddit}/top/.json?sort=top&amp;t=day").then do |json| json["data"]["children"].each do |entry| data = entry["data"] title = data["title"] comments = "https://reddit.com#{data["permalink"]}" url = data["url"] reddit_news.append "&lt;li&gt;&lt;a href='#{url}'&gt;#{title}&lt;/a&gt; [&lt;a href='#{comments}'&gt;comments&lt;/a&gt;]&lt;/li&gt;" end end.fail do |res| reddit_news.append "&lt;li&gt;&lt;p&gt;Could not fetch reddit&lt;/p&gt;&lt;/li&gt;" end.finally do loading_indicator.hide end end Document.ready? do refresh end Element["#refresh-button"].on :click do refresh end &lt;/script&gt; &lt;h1&gt;News summary&lt;/h1&gt; &lt;button id="refresh-button"&gt;Refresh&lt;/button&gt; Subreddit :&lt;input type="text" id="subreddit-chooser"/&gt; (leave blank for all)&lt;br&gt; &lt;p id="loading-indicator"&gt;Loading...&lt;/p&gt; &lt;ul id="reddit-news"&gt;&lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;
I've done this a few times now. It's good information to have out there for people needing help setting this up. javascript code on this blog could use some cleanup.
I'm sure there's a simpler way to say "Businesses kickstart software projects".
Golang is a fascinating language, I really love it, for it's imperative perspectives on writing code in "idiomatic"/"good for reading" way. However it's a precompiled language opposed to Ruby lang, which is a just in time interpreted language. I really love rubylang too because it's code beauty. One of my friend made a comparison in with golang 1.6 a month ago, and if i remember ruby 2.1.2 + rack-app v3 was 4-5x times slower than golang with core http lib. How ever, rack-app aims to have beauty and simplicity in a DRY way with ruby, so the two can be compared like apple to orange. Golang is awesome for code efficiency with more traditional syntax that close to C, and ruby is the world most OOP language right now, with aiming developer happines by human close syntax and with a gem for almost everything. (Gem is something like remote package in golang) It's a common saying in ruby: "if it's more than 5 line, there is a gem for that" :)
This is super COOL! I will look into that, thanks a bunch!
I used to use nitrous.io, which is a very good option. For the last several months, I have been trying an alternative setup: I rent a large memory multi-core VPS from an inexpensive service provider, and use Google's SSH Shell Chrome package. Having two or three SSH shell windows open lets me have a repl open, and a few edit windows. I supplement this with a codeanywhere subscription, which I don't use very often, but it does give me a handy file browsers and an "IDE like" environment. EDIT: I use this setup for Ruby, Haskell, Julia, Scala, and Python. The advantage of this setup is that it works the same if I am on a regular laptop, and I can do some coding on my iPad and Note 4 "phone."
What are the units on those benchmarks? Hooks for instrumentation would be great, although I suppose I can use existing rack middleware for that.
thanks, I'll check this out
There's a bit about it in the [Rails Security Guide][rsg]. [rsg]:http://guides.rubyonrails.org/security.html#session-storage
&gt; You unjustly attack Rails and the existing community best practices with your blog posts and talks and release notes It would be unjust if I didn't have any arguments. &gt; I usually point out the mistakes, but you are very dismissive of constructive criticism as well Where?
My favorite is your post http://solnic.eu/2016/05/22/my-time-with-rails-is-up.html. You correctly assume what counterarguments you'll face and then beg the question. &gt; I know many will say ‚Äúbut Ruby is an OO language, use that to your advantage instead of trying to make it what it cannot be‚Äù - this is not true. First of all, Ruby is an OO language with functional features (blocks, method objects, lambdas, anyone?). Secondly, avoiding mutable state is a general, good advice, which you can apply in your Ruby code. Ditching global state and isolating it when you can‚Äôt avoid is also a really good general advice. But you also dismiss my (what I believe to be) constructive criticism in this post, which is that your project spends too much time promoting itself and too little time showing interested Rubyists who are also occasionally frustrated with Rails (e.g. me) substantial proof of your apparently emotional argument against a very productive status quo. &gt; Is there a reasonably complex app built with dry-rb that I can evaluate? &gt; &gt; Yes, but it's not OSS, so I can't show it I mean... seriously? That's your answer? Can't you make one?
Discussion on hackernews https://news.ycombinator.com/item?id=12381131
See the repos / commits on github e.g. [github.com/openfootball](https://github.com/openfootball) for the latest updates. The more people help the more updates and leagues ;-) It works like a wiki (e.g. wikipedia for data). The football.json gets (auto-) updated with a script (for now about min. once or twice a week - for leagues on monday). PS: The match schedule json includes the complete season, that is, all matches (past and future).
Not necessarily the only option. See [chromebrew](https://github.com/skycocker/chromebrew) for installing some important stuff without the need for crouton.
They have a benchmark in the benchmark repo: https://github.com/rack-app/rack-app-benchmark. Shows Roda about 10x slower than rack-app for 100 endpoints. The benchmarks are a little unfair to Roda/Cuba because they don't take advantage of their main feature of nesting routes in a tree.
conversely you can use `none?`. I.e. if I have a a hash like this: hash = { a: true, b: false, c: nil } then calling hash.values.none? will returns `true` because the keys at `b` and `c` are falsey. You can optionally pass a block to `none?` in the same way as `all?` (you can also leave off the block to all if you want to just do a truthy/false check)/ 
~~Quicker~~ is to check for the opposite: [detect](http://ruby-doc.org/core-2.3.1/Enumerable.html#method-i-detect) if one is true. Then you'll only run through the whole collection if all are false, otherwise it will stop as soon as it finds the first true value: {a: false, b: true, c: false}.detect {|k, v| v} =&gt; [:b, true] or {a: false, b: false, c: false}.detect {|k, v| v} =&gt; nil Edit: No perf gain. See [here](https://www.reddit.com/r/ruby/comments/505dxz/how_i_can_check_if_all_the_element_in_a_hash_are/d71ml63). Thanks /u/tomthecool for spotting my mistake.
P.s. A common example where this behaviour is NOT followed - intentionally, by design - is when validating data before saving it. For example: my_data.validate Should collect ALL errors rather than aborting after reaching the first reason for invalidity.
Oh well, it did not catch on. I tried to promote it in HN because I think this sort of thing is quite cool.
Generally (i.e. excluding Rack-specific details), the client-side session data is encrypted and saved in a cookie. The cookie is then sent with each request by the browser; the cookie is then decrypted and the data made available to whatever might need said data. Since cookies are limited in size, the recommended approach is generally to use a cookie only to store some identifier (like a user ID), then use that identifier to lookup the rest of the session data server-side (i.e. from the database or some other data store). It's also more secure in some respects, since there's less of an available attack surface to obtain session secrets (since they still live server-side; even if the cookie is decrypted and the login session forged, the secrets in question are still subject to server-side controls).
This is literally the secret NO ONE wants you to know about! A few years ago, I got started in my one bedroom apartment. I discovered that I could BUY AND SELL _tiny_ Rails apps, thousands and thousands of times over, by linking to instructional blog posts on reddit. After just six months had gone by, I got my first _hundred thousand dollar check_. And I'm here to share with you the secrets I learned about _crafting the perfect rails application_. For just three easy installments of 19.95, these secrets can be yours.
To tell you the truth, I have little experience with Roda , could you give me a week to discover how Roda works , and what feature set it provides ? Than I can answer meaningfully your questions! :)
Cool, looking forward to it :)
Likely so that you don't have to install the compilation (and cross-compilation) dependencies. Here's the relevant dockerfile: https://github.com/hone/mruby-cli-docker/blob/master/Dockerfile
Also worth checking [Enumerable](http://ruby-doc.org/core-2.3.1/Enumerable.html) mixin documentation. It has many useful methods such as `any?`, `one?`, `inject`
@mperham , I made a little refactoring in the code base, by your notice, what do you think now ? : ) I erased the method completely, and used middlewares for those endpoints, where this custom env formatting is required.
&gt; But you also dismiss my (what I believe to be) constructive criticism in this post, which is that your project spends too much time promoting itself and too little time showing interested Rubyists who are also occasionally frustrated The time that is spent on "promoting" the gems is probably roughly 5% of the total time we spend on developing the gems, writing docs and supporting users. Your "constructive criticism" is not constructive, and it's not even a criticism. You call me a spammer, you try to convince people that 6 posts about 4 *different gems* over the course of 5 months is spammy. How am I supposed to react to this? Apologize for posting a couple links on this sub? Stop posting links? We're not allow to let the community know about important releases from dry-rb? You said we should focus on providing proofs, first of all - that wouldn't be productive at all, we have already lots of people using the gems, and they need support from our side. That's really enough. Secondly, the gems are unstable, writing a "reasonably complex app" using unstable gems will require constant updates, and may potentially confuse people. We have so little time to develop the gems *and* support the users that I can't imagine that we'd add "maintain a reasonably complex app that uses the gems and is a great proof that these gems are helpful" to our TODO list, simply because it wouldn't provide much value in the long term. &gt; I mean... seriously? That's your answer? Can't you make one? I can, but for now I choose to work on the libraries instead, as the backlog is too big. Once most important tasks from my list are done, I'll focus on writing a book about this, which will go through an example app.
Awesome, I check this after work, thanks @notmymiddlename! :)
If you're in an environment with ActiveSupport (like Rails). you can use `blank?` or `empty?` on arrays and hashes. 
not quite what the OP is looking for
I like your version better than mine. Actually, OP may be more interested in something of the form: colIndex = 1 hsh.values.none? { |row| row[colIndex] } Since this appears to be a column in a database query.
One solution I've seen is to have an authenticate endpoint that returns, among other things, a token. That token is then passed as a header for other endpoints that require authentication.
If you're using Rails and RSpec: RSpec's request specs are, in their words, [a thin wrapper around Rails' integration tests](http://www.relishapp.com/rspec/rspec-rails/v/3-5/docs/request-specs/request-spec). I would certainly say what you're describing falls pretty close to a controller or integration test. You're essentially asking the question "Does this request with these fields to this endpoint result in the expected behavior?" Since "expected behavior" could be "the server returns a 200 code and sends an email", it seems more integration-like than controller-like in its scope, but Rails is merging controller and integration tests together into one unholy confluence anyway. Either/or.
Right, so I've created a lot of integration tests external to our repos using Postman and SoapUI. But its time to start writing proper integration tests in Rspec.
I'm not familiar with Postman and SoapUI, but I happen to be building a JSON API in Rails for work myself, and I'm using request specs to do it. Integration tests are [super easy to write](http://guides.rubyonrails.org/testing.html) if you're using Rails! If you want any specific help, send a PM and we can chat non-public. 
The Roda creator has already sent you a PR: https://github.com/rack-app/rack-app-benchmark/pull/1 ;)
You don't want to persist the session, an API should be stateless where authentication is concerned. Instead store the token in your DB and check it every time an end point is hit. It will help you to skim though the [Bearer Token Usage](https://tools.ietf.org/html/rfc6750) for OAuth2. In summary though, for an API you should have a POST /oauth/token that accepts a username or password (you can use basic auth for this if you like but params from the request body works too). If the credentials checks out, create a token in your database and return it. Consider using the [standard response](https://tools.ietf.org/html/rfc6750#page-10). Now when hitting up other endpoints that require authentication send an [Authorization](https://tools.ietf.org/html/rfc6750#page-5) header. Check the token against your DB and if it's all good return the response, otherwise fail with a 401 Unauthorized error.
&gt; We have a fundamental disagreement about how often an immature project (which you have just admitted yours is) ought to promote itself OK, let me repeat myself, and few others from this thread - dry-rb is *a collection of libraries*. The only library that was shared here 2 times, instead of just 1, is dry-validation, which runs already on production so I wouldn't call it "immature", unstable (from semver pov) yes, but not immature. You complain about the fact that we shared links to 4 gems over the course of 5 months. If these gems were not part of the same organization you wouldn't say a thing, I suspect. 
Going to try this approach. Thanks!
&gt; You unjustly attack Rails and the existing community best practices with your blog posts and talks and release notes. I'm don't think it's a good idea to step into this discussion between and you /u/solnic, but I just can't avoid it. There is nothing just or unjust about criticizing rails. Rails is not a person. It doesn't have feely feels that can get hurt. And even if it _were_ a person, constructively criticizing people is a just act as well, but that's beside the point. There is absolutely _nothing_ wrong with advocating against technical ideas one believes to be inferior. Nor is there anything "spammy" about advocating for technical ideas one believes to be superior. If /u/solnic buys an email list from a technical recruiter and starts blasting emails out to all of us announcing a new version of dry-*, _then_ we can talk about spam. Till then, he is posting links to important, maturing projects to a subreddit dedicated to the subject matter in question. At any rate, many rubyists have arrived at the conclusion that there are better methodologies and approaches to writing software than The Rails Way. As the Billy Joel song goes, they may be right, they may be wrong, they may be crazy. But for those people, the ruby community is not the vibrant, "nice" place that is for rails users -- it's a scarce, scant ecosystem often fraught with other users who will scoff at you for thinking outside the established norms you call "best practices." How about being excited that ruby is _increasing_ in its technical diversity?
https://tools.ietf.org/html/rfc6749 start here. 
I was so ashamed to not fully read roda documentation before creating a example application :S
thanks for the response
The doorkeeper gem is not exclusive to Rails iirc. Generally you don't want to implement your own auth schemes and rely on an established library.
So with an unverified free account you can get 550 free hours per month which actually isn't enough for continuous uptime. If you verify you can get 1000 hours free. But to verify you have to add a card, and I don't know it what scenarios they might charge that card so I have to research. Still 550 is enough to keep it alive during most of the hours the people I care about seeing it (future employers) will be awake, and it will just be a little slower if they access in the remaining one or two hundred hours late at night mostly (I'll have to add more granularity to the class to work on a timeclock)... although that wouldn't work right since I'd have to have the thread running, and it gets killed when the dyno goes to sleep right? The rake task kills its thread on exit so I'm not sure how to keep it alive? 
I don't understand you. Why you did you say I assume all here are guys?
They're responding negatively to the fact that you addressed the message to "fellas". I think a lot of people here don't understand gender-neutral terms of endearment.
love it! Could have used this a few weeks ago when not getting forms to play nice, and reform wasn't working either. 
Or words like "fellas" and "guys" aren't as gender-neutral as we sometimes tell ourselves they are.
We used JWT tokens in our latest api. They are really great because I can have an expiration dates in the payload, and then I don't have to save anything on my end about the authentication.
Controller tests can be tricky because they mock some stuff and not others. For example, they don't render views/body unless specified and often times skip middlewear. I prefer full blown integration specs, or request specs in this case. Source: @searls told me to stop writing controller specs, so I have. Example: Tweet: https://twitter.com/searls/status/573270179347488768
&gt; There is nothing just or unjust about criticizing rails. I didn't mean it in the moral sense. I mean his arguments against Rails and the Rails Way are not justified. I used the wrong word, my mistake. If you read the post I linked, you'll see it's full of emotional arguments as well as things that just aren't true. I've noticed this in the release notes for dry-rb projects; you get the sense you're supposed to hate Rails, but they don't really ever provide a convincing argument for why. And when you point it out, you get into a fight on Reddit instead of "Hey, here's this thing you can look at that shows why our patterns are the bees knees." &gt; Till then, he is posting links to important "Important" I think gets to the crux of the disagreement again. How would you define, objectively, an "important" software project? (And I still have an open challenge to anyone to find a project that posts as often as this one does, important or otherwise.) &gt; How about being excited that ruby is increasing in its technical diversity? I am excited... and wary. (Have you seen Javascript-land?) I have my problems with Rails, but not the ones that /u/solnic writes about (we've gotten into this on a previous dry-rb release announcement thread). I'd love to see a better way. But it's got to be as convincing as Rails, and its devs can't just yell at people who ask them to put their money where there mouths are.
&gt; OK, let me repeat myself ... dry-rb is a collection of libraries I understand that. Rails is, too. Let me repeat myself: what other project (or collection of projects) posts announcements here as often as that?
I like how you make it work nicely with form helpers. You build up the nested resource problem, but never actually solve it though. You also don't touch on how to interact with the form object from the controller. This is a great start though, and I'm actually going to tweak some of my own PORO forms based on your thoughts. I use virtus as well, which might be overkill. Anyway, great read, I just feel like you left me hanging.
JWT is amazing. Sessions live in the token, and are not persisted. They're amazing.
Can you define please , what type of comparison interest you? 
I was using thor when I was building native websocket support for the [Iodine](https://github.com/boazsegev/iodine) server... thor suffers from it's own limitations. If you find a Ruby testing tool, it might be interesting... but I believe it might suffer from performance limitations that have to do with Ruby's String handling (testing connection establishment **might** be fine, but testing actual messages might be a prove difficult)...
You do need cookies. A typical authentication mechanism works by creating a token that expires after a certain number of days when user successfully logs in. You would store this token on your server-side DB (a DB that supports TTL helps) and also on the browser's cookies. Every subsequent requests, you'd need to check the token in the cookies. If it exists and valid (check against the DB), user is logged in and server can fulfil the requests. If it doesn't exist or invalid, you assume user is not logged in and should redirect user back to the login page.
I tried what I can to serve your request. Well, this framework is really something... First I never seen ruby code "uglified" before, so it was a new kind of experience. I updated the benchmark repository with this framework, but I would suggest you that stick with sinatra instead, if you love both of the framework but needs something in production. I've seen some serious hardly readable code before, but this was a new level in almost every aspect. The framework lack clean code, and other principles, and lack any kind of test, so I take this is just a fun stuff of course. :D To compare the two, I think rack-app follows a slightly different principles, that focuses on DRY and well documented and tested application api, where almost-sinatra achive minimalism and code size at the highest factors. Cheers, hope I could helped your question!
[Rodauth](https://github.com/jeremyevans/rodauth) should actually be a good fit here, it supports API authentication (using JWT) and can be used with any web framework and ORM (all other authentication frameworks are Rails-specific). It's implemented using Roda and Sequel, by the author of the two libraries.
&gt; I mean... seriously? That's your answer? Can't you make one? Here is one - https://github.com/icelab/berg. But I'm sure you will just find another thing to complain about. Why do you assume that because you haven't seen an open source Ruby application (seriously, how many are there anyway?), that it's not used in production? I also haven't seen [Shrine](https://github.com/janko-m/shrine) used in decent-sized open-source Ruby applications, but many people told me that they're successfully using it in production. If you take a look at the dry-rb Gitter channel, you'll see many people using it and being happy about it.
You make a really great point about that. I had considered turning this into a little series of posts so maybe I'll use this as the continuation. Because I sure don't want to leave you hanging :)
&gt; I understand that. Rails is, too. No, it is not. It is a monolithic framework, its individual components are not meant to be used standalone (even if it's possible, nobody does that). It consists of 8 gems, they are always released all at once. You're comparing apples to oranges. &gt; Let me repeat myself: what other project (or collection of projects) posts announcements here as often as that? I don't know and it doesn't matter, because you refuse to understand the difference between an organization and an individual project from that organization, and this discussion is pointless, so EOT from my side.
This looks great! Unfortunately I can't use it at the moment (Just get a `TERMIT: We are sorry but something went wrong.` message). It seems that the last published version in Rubygems is `3.2.0`, which used the Google Translate API. Version `3.3.0` which uses Bing will probably fix it, but it's not available in Rubygems yet :).
I just checked that 3.2.0 works correctly, and is using Bing. Can you provide the command that you use ? Maybe you still have the old (2.x.x) version installed (termit -v) ?
Haha, awesome! You're doing great work. Thanks for sharing it with everyone else too.
... not ... rails? but it's such a great programming language!
I have no connection to the author/poster or skin in the game here, but I am confused by this comment. It's an article targeted to compare and contrast Elixir to Ruby, to a Rubyists point of view. Recently it seems there has been a lot of interest in the Ruby community regarding Elixir on reddit, on twitter and on hacker news for example. Which may be for good reason, the similarities, the connections to core Rails contributors, etc. Were there posting guidelines that were not followed or does /r/ruby hate /r/elixir ?
Rails isn't a programming language, it's a framework built on top of Ruby... Actually, it's a framework built on top of Rack (which is on top of Ruby). Rails isn't the only framework out there, but it is one of the heavier ones, offering more features to ease development. ...But, magic always has it's price, and Rails often comes with a high performance price - especially when ActiveRecord is used carelessly (but also when it's used properly). Rails comes with all the features you're likely to need (and a lot you probably won't use). These features weigh on your application and it's assumed that the performance price is worth the ease of development. Rails applications often become a nightmare to maintain due to the design assumptions made by the Rails framework (model bloating and controller bloating are good examples for this common issue). This is why, sometimes, an alternative is required. This is especially true as your application's client base grows. Plezi doesn't provide many features, only the MVC skeleton. For example, Plezi assumes you will bring your own database gem or ORM (maybe `Sequel` or a specific database gem that allows you to make some specialized / stored SQL calls)... This approach is the opposite of Rails and means you grow your application up, adding features as they are required. Writing micro-services with Sinatra or Plezi is much more effective, IMHO, then using Rails.
I was definitely being sarcastic. Thanks for taking the time to explain though. 
The [Volt framework](https://github.com/voltrb/volt) was pretty darn solid and well-designed back when I used it; it has websockets and a slew of other amazing features, e.g., it uses Opal so that all code on either end of the application is in Ruby, similar to Node.js. Sadly, it hasn't been developed for a while, although the maintainer is openly looking for someone to take over development.
i think it's quite ugly: https://github.com/boazsegev/plezi/blob/master/lib/plezi/router/route.rb#L104
Have you look into hosted 3rd party PaaS like [Pusher](http://pusher.com) (I work for them) or Pubnub? There are also open source solutions like [Slanger](https://github.com/stevegraham/slanger) (built in ruby and can use Pusher's library) or socket.io (node.js).
four space indents in code example. no thx :D
Take a look at https://github.com/eventmachine/eventmachine Allows you to write application using the same IO principle as node. 
I use Akka.Net, works well especially for distributed platforms. 
why are you telling me this?
This isn't actually a question. It is a link to a blog post. Easily mistakable since it ends in a question mark. As an aside I would recommend eventmachine as a last resort. There are simpler ways to do this (As outlined in the blog).
&gt; Good day fellas,
1) inheritance is not super useful property that you have to rescue by all available means 2) hiding mechanism that mutates user classes and changes their behavior is recipe for disaster, zen of python is right on that one
Wow! What amazing gem. Let's see how it goes with this.
I did. I'm not into paying money to a third party that locks me in with a proprietary API that requires a total rewrite if I ever decide I'm being overcharged.
I remember being impressed with it, but I also felt it was too opinionated for my taste. It was also very browser oriented, meaning I could use it comfortably for writing API access points. I was part of a node.js game development that used socket.io and realized I wanted something closer to the metal and Ruby oriented - especially since I wasn't writing only for browsers. 
I agree with number 2, that's why the mixin information is in the documentation and why the first example you see implies that the original class was augmented. However, meta programming is a powerful tool. No need to throw it in the garbage just because someone said you shouldn't do it in Python - Python isn't Ruby (thank god).
There's [Phoenix](http://www.phoenixframework.org/) if you want to work with Elixir.
Sky's the limit kiddo
I'm very thankful for Rails and I don't think "it's all Rails' fault"... For example, before Rails I was coding in &lt;shamed emoji here&gt; PHP... Which was terribly inconvenient. Rails gets a lot of stuff going - it's cool to draft a big project using an agile monolith framework. But ever since RoR 4, I moved slowly away from Rails. I'm very thankful, but I also realized I want more modularity and a lighter and more stable core. I'm somewhat frustrated with porting old Rails 3 and Rails 2 projects to newer versions that seem to grow more complex and feature rich with every release. As thankful as I am to Rails, I found myself more comfortable avoiding it whenever I know I'll need to maintain the application over a long period of time. 
Exclusive range.
My bad I thought you were looking for alternatives not posting one.
In this case 0...length is the same as calling 0...self.length
Is there anything specific that made you want to avoid it when you know you'll need to maintain it for a long time? 
holy shit! how do i know i'm inside an object? i think i get what you're saying but i don't know how to verbalize it.
Context, I guess. That def method is a part of a larger class, isn't it?
I think the plainest way to think about it (which isn't entirely accurate but hopefully you get the point), is that it's like calling a "sibling" method. In the above, it'd be any object that included the Enumerable module (arrays, ranges, and such). Here's another example class Person def first_name "Joey" end def last_name "Joe Joe" end def full_name "#{first_name} #{last_name}" end end `first_name`, `last_name`, and `full_name` are all instance methods on a Person. They share the same scope (any given instance of Person), so when you call a method inside that method, it looks for it that same scope. 
i totally get it now, thanks!!!!!
yaaaassss thank you!
Oh yeah. Wow. My brain just made up an assumed context. That's freaky. Edit: I think this is the first time I've downvoted my own comment.
For-loops are syntactic sugar -- which is frowned upon* --, use `(0...length).each { |i| ... }`. Edit: * for good reason, the best reasons. \trump I'm not totally up for explaining right now. But, it has to with for being a loop expression -- which doesn't create a new scope -- instead of a function which accepts code block -- that does create a new scope. Etc.
To expand on this, if you have seen the `attr_accessor :var`, `attr_reader :var`, and `attr_writer :var` functions, these functions will create the `def var; @var; end` and `def var=(_var); @var = _var; end` functions for you. Accessor creates both, then reader and writer create a single function respectively.
I wouldn't beat yourself up too hard. I had the same thought you did. The method shown is being added to the `Enumerable` module. The contract for `Enumerable` only requires the class it's mixed into to have an `each`. For certain other `Enumerable` methods to work, the class being mixed into must define `&lt;=&gt;`, but it's optional. That's the entire contract and it's part of what makes `Enumerable` so amazing. For this newly added method to work, the code must either define a `length` method in `Enumerable` in terms of `each` or it's relying on the class being mixed into to have a `length` method defined. If the former, I'd posit that's not terribly efficient and risks being masked by the `length` definition of the class being mixed into. If the latter, the contract for `Enumerable` has been broken. Of course, it's all orthogonal to how `length` is being called here. But I think it's worth noting because you can wind up with a `NoMethodError`, which might otherwise be confusing. Edit: Fixed bad formatting.
Also, I think the "return self unless block_given?" is wrong, as it won't add the expected index in an enumerator chain. IIRC it should be "return enum\_for(\_\_method\_\_) unless block_given?" so that the returned enumerator wraps the method.
How about `1.times { y = 2 }; y # NameError`. Although, I'm pretty amazed that side effect is still around. I thought it was removed in 1.9, but I just confirmed it in 2.3.1. Edit: here's the pre-1.9 side effect that i am thinking of: x = 0 (1...3).each {|x| y=x} x # 1.8: 2; 1.9+: 0 y # NameError
+1 for concurrent-ruby. I just used Futures for the first time the other day, what an awesome thread abstraction üëåüèº
Meta programming doesnt have to be remote and hidden. Explicit mixin doesn't change anything in terms if functionality but means a lot in terms of understanding of what is happening.
Hmmm... I think your missing the "meta" in "metaprogramming"... From wikipedia: &gt; Metaprogramming is the writing of computer programs with **the ability to treat programs as their data**. It means that a program could be designed to read, generate, analyse or transform other programs, and even modify itself **while running**. the whole idea is that things happen as a result of code interaction. If you write a mixin in a class, it isn't "meta" programming - you wrote that in. But if your code reviews a class and sees that an inheritance chain link is missing and then corrects the issue by adding it (instead of crashing or simply failing) - that's "metaprogramming". And yes, I consider this feature as an error correction and prevention feature rather then an obscure thing. It would be better if every time a developer wrote a controller they would `extend` the instance module and `include` the class function module... or was it the other way around? or should I really force people to remember? and what if they did one but not the other? The program simply does it for you by fixing any missing inheritance chain links when you call the `Plezi.route` function. Easier, cleaner and less error prone.
you don't have to explain meta programming to me, i'm doing ruby professionally for 8 years now. &gt; the whole idea is that things happen as a result of code interaction yes. and it can either happen when you explicitly include a mixin which does *meta-programming* in the `self.included` method or it can happen implicitly like in Plezi, where you send off your class and it gets modified without there being any hint in the code to that. the problem with implicit mutation of your classes is that what code implies is different from what is happening. code implies this class is self-sufficient and can be treated as such in other parts of your system, that's the assumption everybody who's looking at class definition will make and they will be wrong. that can lead to bugs, unexpected conflicts in functionality or increase cognitive load on people new to your codebase. think about it - in specs you would require this class and test it but in production it would be a different, untested class serving your traffic. if class inherited something or included mixing explicitly there would be a connection point to external functionality. and without any restrictions on that functionality too - same old meta programming. and it would have the same behavior in production as in specs. there is literally **no** reason to replace explicit mixin with implicit, hidden class mutation. it saves one line but brings a world of trouble. EDIT: &gt; It would be better if every time a developer wrote a controller they would extend the instance module and include the class function module... or was it the other way around? http://apidock.com/ruby/Module/included
&gt; there is literally no reason to replace explicit mixin with implicit, hidden class mutation. it saves one line but brings a world of trouble. I love that we have different approaches. I, however, can see plenty of reasons to replace as explicit mixin with as implicit (but expected) mixin. The question of beautiful code is the least part of it. I also deeply understand your concerns. I had to implement my own version for a virtual function table when exposing some of the functions to the web or to websocket events (inherited functions are never exposed unless explicitly defined in the controller class). Method name conflicts can arise and functionality can be easily altered (intentionally or mistakingly)... ...but these things also happen when you intentionally write in a mixin. Nothing is stopping these issues from cropping up no matter which technique we prefer. This is especially true for boilerplate and framework code. The line `class MyApp &lt; Framework::App` is so common, we never think twice about name collisions or anything else. We overlook the line when debugging, because it looks as common as pie. In the end of the day, it's always about knowing what we're doing. I think I spend at least 50% of my coding time debugging my own code as well as others'. Explicit mixins never prevented these issues from cropping up. These things crop up because we didn't know about the collision - the mixin / DLS or inherited (even where implicit) were never an unknown since the code was expected to work one way (and didn't)... i.e. a Controller is expected to be a controller and have the functionality related to a controller. 
&gt; implicit (but expected) mixin it's expected in context of that demo script but in any larger codebase these classes and route definitions will be moved apart into different files. and you haven't addressed the fact that you're testing one class but using a different in production. if framework decides to change it's internals in a way that conflicts with existing class declaration - your specs won't catch that. &gt; Explicit mixins never prevented these issues from cropping up but they provide clarity and point of reference to external implementation my class is about to be augmented with. this clarity is much more important than having 1 line of code less.
Did something similar with concurrent Ruby a while ago. Is there any reason you used a countdown latch to block and wait for execution? Calling `#value` on a future in the `pending` state will block until the value can be retrieved, so something like the following works: require 'concurrent' def fibonacci(n) n &lt;= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2) end [30, 31, 32, 33, 34, 35].map do |n| Concurrent::Future.new { fibonacci(n) } end.each(&amp;:execute).map(&amp;:value) See: http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Future.html
That was an example of using a time out so you don't block the endpoint waiting for one of the results.
Hehe, thanks, I should mention that at the end ;-)
 Ruby: Files w/tabs = 4495 Files w/spaces = 334398 Go: Files w/tabs = 206236 Files w/spaces = 3998 That means, out of the files analysed: * 98.67% of Ruby files use spaces. * 98.10% of Go files use tabs.
Fascinating! Even with Go's fmt tool, Ruby is still more consistent. 
This is pretty cool idea. I'd like to see an example of what it would look like.
Use griddler - https://github.com/thoughtbot/griddler/ And pair it with one of these transactional email services - https://github.com/thoughtbot/griddler/#adapters And you're off to the races!
SPACE SPACE SPACE SPACE SPACE
Rails itself has a bad case of overmodularization. Just try and follow the ActiveJob codebase. https://github.com/rails/rails/blob/master/activejob/lib/active_job/base.rb#L58
Ruby has syntax comfortable for 2 space indent. 99% of ruby code use 2 space indent. Use of 2 space tabs is ridiculous.
Thank you. This one uses ruby which has been a good fit for this project since it is much more readable than other languages. http://codeartproject.com/journey There will be a show in San Francisco on Feb 23rd too. Let me know if you have any questions.
Totally, thanks! Nick pointed out that Action View is the same. I know that much of Active Record is as well from personal experience. This is also a good example of when people shouldn't assume that Rails or whatever library they're using is the gold standard. Coders are subject to mood swings and different coding styles fall in and out of fashion. The important thing for me is that we learn from this and don't make the next ActionWhatever in the same style and structure. I also think it's important to empathize that at the time most of the libraries were written proper OO design wasn't really talked about and concerns were the hotness. Re-writing it all to be OO from scratch is basically impossible at this point, but efforts can be made to clean up while we go. I'm trying that with Sprockets, but there's just so much side-effect behavior that can't be eliminated it's tough. 
Thats awesome! Wish I could attend.
An empty, default Rails 5 controller has 61 mixins ‡≤†_‡≤† [1] pry&gt; RootController.ancestors.size =&gt; 68 [2] pry&gt; RootController.ancestors.reject{ |a| a.is_a?(Class) }.size =&gt; 61
One comparison that I really like explaining how to think about include, from Sandi Metz, is that its basically the same as copy pasting the entire module into your class, since it will include all the behaviour of the module..
Wait, weren't you just telling us how using spaces is dumb? At least be consistent in your rant ;)
Interesting article. In my experience, modules are great for integration points. Suppose any ruby object could become a rails controller action like this: class MyAction include Rails::Controller::Action def action respond_to do |format| # etc. end end end This actually could help _improve_ the quality of the underlying library code. The module can be thought of as a "mesh point" between the users' code and the library. Currently, your `ApplicationController`contains all that rails machinery _and_ all of your application's code. This means that the underlying machinery can't view the users' code as an abstraction. Specific to the example above, `#respond_to` could then be extracted out of the controller module altogether, which would likely lift a lot of code out of its implementation. With a module like the one above, the machinery can deal with a generic Action interface. I've used this strategy a lot with my own libraries to great effect. I offer a module that you mix in, along with a virtual method or two that you're supposed to implement, and maybe a class macro or two that allows you to concisely configure your implementation. Then my library code is completely separated from the users' code, while still allowing the user to have a convenient interface.
Very true! Copy pasting with another level of indirection.
[If you have to ask...](http://i.imgur.com/RJloi1t.png)
Using a module to expose an interface is a great use. Good module.
gist lets you define your own tab spacing. [Like so](https://gist.github.com/Ryuujinx/b512f57c5521b2cda9ab66eed959783d?ts=2)
it's just the name that ruby gives the top-level object. it has no practical impacts as far as I'm aware
I think it's just all the changes... Instead of a modular approach, the whole API is adjusted with each significant enough of a release. I just got tired of keeping up. When I use a modular approach with Rack, choosing the gems I need, the updates are usually smaller and more spaced out (even though they might be the same amount of work over all). Also, I suffer less of a overhead, meaning I can often delay scaling (although it's usually a non issue except in my head).
oh nice!
I guess we'll simply agree to disagree. The multitude of approaches is a good thing. P.S. &gt; and you haven't addressed the fact that you're testing one class but using a different in production. The question of explicitly doing something vs. implicitly doing it doesn't change the way tests are (or should be) performed in any significant way. I fear this argument is based on prejudice and fear rather then rational usability. It is the same as the C prejudice against the infamous `goto`. `goto` is a wonderful way to keep error handling DRY and can help ensuring held resources are released whether our code encounters errors or not... But, since we are told to avoid `goto` as beginners we hold on to a restraint that is no longer relevant for us when we write advanced code. Should I avoid `goto` in C just because I had no sensible need for it as a beginner? In the end of the day, its all about the developer knowing what they're doing. &gt; it's expected in context of that demo script but in any larger codebase these classes and route definitions will be moved apart into different files Yes. They will. But if a developer doesn't know what classes they are using as their application's Controller classes, I doubt there's anything you or I can do to help them - explicit mixins won't cut it... If they do know a file contains Controller classes, the separation into different files is irrelevant.
While `== 0` is technically faster, `.zero?` is easier to read. With the difference being minimal, go for easier to read. require 'benchmark' n = 50_000_000 Benchmark.bmbm(15) do |x| x.report("zero?") { for i in 1..n; 0.zero?; end } x.report("== 0") { for i in 1..n; 0 == 0; end } end results user system total real zero? 2.710000 0.010000 2.720000 ( 2.709000) == 0 1.990000 0.000000 1.990000 ( 1.996962) 
Damn your document title.
Not to start a flame war here, but isn't it kind of weird to have a `.zero?` method and not a `.one?`, `.two?`, `.pi?`, etc. Like consider: x.zero? &amp;&amp; y == 1.5 That's just plain odd. So then for readability now you should do x == 0 &amp;&amp; y == 1.5 Which makes sense now, but then somewhere else in the same code base if I'm just checking x, do I use the `.zero?` convention now? x.zero? Now there's a consistency problem here, because some places use `==` and others use `.zero?`. I fail to see in a sufficiently large code base how `.zero?` improves overall readability. Indeed I'd say it hurts it. Plus if I'm going to grep for some constant, do you really think I'm going to run grep trying to find `.zero?`? No way, I'm going to grep for `[0-9]+` which won't find this at all. This is a very funky code smell, TBH. I see very little benefit here.
No. Almost no one use something but 2 spaces for Ruby code. Cause Ruby code looks nice with 2 space indent. It look much less pretty with longer indent. So only novices try to use other indentation. But they quickly switch to 2 spaces. Cause everyone use 2 spaces, and it looks pretty for Ruby code.
I think that it is more of a matter of probability... Chances are you going to check for *null*, 0, or empty more so than one, 1.5, two or pi. I get your point though. If i were comparing something like in your example, I would use `==` in both cases for consistency reading. However, if I'm doing a check elsewhere for just a zero value, I may opt for `zero?`.
`something.zero?` is not one character away from assigning `0` to `something`.
`.life? == 42` `.everything? == 42`
MUSASWUS
You can always disable the rule that you don't like throughout your whole project or in one part of your code.
&gt; With the difference being minimal Totally depends on what you're doing. That difference will look massive in certain situations(like the difference between 30 and 60 fps in real-time stuff). I know ruby isn't usually used for super optimized stuff but it still has to perform sometimes and it pays to know the difference then. On a side note I much prefer the consistency of using "== 0". I also don't see how .zero? is more readable in anyway but to each their own. To be fair I haven't written ruby in a long time.
It's only kind of weird because humans are kind of weird, and we write the code primarily for humans. Also, 0 is a special number. Arguably the most special. We check if numbers are 0 more often than any other number. Or so I claim, based on a strong gut feel! *A meta-consistency argument against your argument:* Isn't it kind of weird to have Array.empty? and not a .size_one?, .size_two? etc?
zero is a more common thing to check for than 1.83282, 2, 5, etc. Also, never check against a float like that, every time you do, a puppy is killed.
&gt; In most cases, zero has a "special" value, Indeed. And often depending on business-logic too. E.g. a float could be considered zero even when it is not completely zero. Or a monetary value that has 0.1 cents; an amount that can never be handed out, would be considered zero and so on. Edit: with *float* I mean a *float-ish value*. For example: `Weight.new(1/1E36).zero?` might well give `true` in some physics simulation. Wheras `Weight.new(1/1E36) == 0` is nonsense. But more important, `zero?` is a lot more precise than checking if something is *equal to the `Integer` ` 0`*, which is what `== 0` does. For example Float already takes this into consideration, but I'd argue that ruby is mistaken here because `0.00 == 0` should return false. Because the float `0.00` is not equal to the Integer `0`. At all. 
&gt; Because the float 0.00 is not equal to the Integer 0. At all. Why? Ruby provides means for "exact" equality (`equal?`), but in "everyday" situation you just want `10.0 - 10.0` to be `== 0`.
that's totes valid :-)
But you probably don't consider `"0" == 0` to be true. Or `false == 0` to be true. Or `Date.parse(1970-01-01 00:00:00) == 0` or even `1/1E36 == 0` and so forth. In my world, a float can never be equal to an int. Just as comparing a Date with a User or a PdfDocument with an Integer is silly (and this is what makes a lot of bugs in both PHP and Javascript, actually). You are right to say that the values both things represent might be comparable. Some semantical pseudocode: `Float(0).value == Int(0).value` might make sense. I guess Ruby can compare a float and an integer because both are a subtype of Numerical. So, in that way it might make sense; but semantically I think it is rubbish.
I don't hate it. I just haven't been convinced and they respond poorly to challenges. I want to like it actually. 
Every possible integer (maybe even possible object?) should have its own comparison method on Numeric. `1.one?`, `1.two?`....`1.activerecord_model?`, `1.string_of_length_33?` That's just how object oriented programming works. Actually, maybe we should just define all those on the base Object class. Yes, that's the ticket...
For me one amazing product of Ruby modules is Sequel's, Roda's and Shrine's [plugin system](https://twin.github.io/the-plugin-system-of-sequel-and-roda/). Think of it as *conditional* module inclusion; you have plugins as individual files which represent features, and when you "load" a certain plugin, internally the file is required and contained modules are included into core classes. Notice the plural; instead of having one god object, you have a fixed number of core classes. Since these core classes contain the whole behaviour of the library, and plugins can extend each core class via modules, that means that even a feature that requires changing all core classes can be packed as a plugin. This way, instead of having a single method which contains parts from multiple features, each feature is neatly contained in a separate file. This also means that you only have to `require` features that you actually use. Is that a good module? :)
That style guide is full of shit, ignore it completely.
The subject of the posts are clearly marked in the titles, so easy to skip. I define spam partially as advertising that I don't care about. But this is a public forum and just because you don't care about it doesn't mean others don't. I am an infrequent reader of this sub and only heard about the whole collection of dry-rb through this. I am glad it was posted.
&gt; Premature optimization is the root of all evil. And coming from games, ruby is slow as all get out.
Go ahead and install the latest stable, and use a tool like rbenv to keep stuff up to date. 2.3 has some pretty decent improvements over 2.2.*. Edit: to answer your question more directly, if a g works with 2.2, it'll work with 2.3. I'd be surprised by exceptions. 
I run 2.3.1 on all our production environments and it's fine 
2.3.1. you'll have no trouble. changes between 2.2 and 2.3.1 are relatively minimal, most gems did not even need updating to work on 2.3 
2.3.1 is dope and has lonely operator support, which is also dope.
[MRI](https://github.com/ruby/ruby) (in C) mixes tabs and spaces...
OK. The other bit of my feedback shouldn't be ignored due to the spam bit. It's really hard to find clearly reasoned (with code) justification to back up the anti-Rails talk that permeates their writings. 
I don't have much experience in OSS rails projects. I do have 6 years experience in RoR enterprise projects. Two that are rather large (400K+ lines of code). Due to my experience with those large applications, I started feeling that "The Rails Way" did not scale. We were seeing a tremendous slowdown in development after about 6mo to 1 year. This led me to do research on hexagonal rails and architecture that emphasize PORO business rules/objects and minimize the framework. Jim Weirich and (Uncle) Bob Martin both have great videos on this. This Dry-rb seems to fit right into this thought process and so, from the little bit that I have gone through, I am very intrigued. To address your point: I don't think it will be easy to get anything that has been worked on for the period of time I mention above, to be able to really see the scaling point, in the public domain so that it can be picked apart and analyzed, so the "with code" is a pretty tall requirement. Skeptics that don't have the same experience will just say that it is "toy" or you are doing it wrong. Just to be clear, I am not saying (what I assume is) your opinion (that rails scales and we don't really need anything else, so don't bash it) is wrong. It just hasn't been my experience. To elaborate further, I find that there is a lot of rails "magic" (stuff that just gets taken care of and I don't know how or why and it takes a long time to figure it out) and I therefore have to either walk the golden path or struggle to work around it and figure it out if it is a bug (rarely!) or if it is something I don't understand about the underlying assumptions. I don't want to spend that time when I could be spending that time learning something in my PORO business objects.
Is your node websocket server really that abstracted? That might be the result of it being part of a large codebase. I think most server-side websocket libraries already have a pretty simple API. I've found the complex part to be adding access-control and authentication. Maybe try faye with sinatra - [here's](https://devcenter.heroku.com/articles/ruby-websockets#create-websocket-app) a tutorial. I think the complexity is going to be about the same as using the [ws](https://github.com/websockets/ws) library with Express, although of course you'll have the benefit of writing Ruby instead of Javascript. 
I mean it's easy enough to convert tabs to spaces in Sublime Text, so why wouldn't I do it and stick to convention?
I feel like python should have been included in this. EDIT: Also, as a first time poster in this sub, I wonder if I should expect to be downvoted into oblivion for that.
Wow, I took a peek at your source code for Iodine, the C extension actually helped me understand more about websockets than I knew before posting this question. Haha so since my post I've decided to keep learning node.js in hopes of thor being my savior. Goal 1 is still get a graph going of simple response times, but down the road I need to have custom headers on these thor messages.. any insight into how websocket's custom headers are different/same as http custom headers? :o -at the mercy of thor 
RVM or bust... I'm kidding, of course, use whatever you want. 
I Think you be happy to hear, that one of my friend making a webserver that use the Golang great concurrency mechanism , and create rack-handler with it, so it will be rack compatible. Please note, that this will not increase the ruby code speed.
There's `hash#dig` which is a start! :)
We have a lot of this kind of thing at my current job, it's not my favorite.
Instead of raising a custom error, like: `raise "You need to include a function for #{self} for hungry?"` You could use Ruby's own error class for this kind of thing: `raise NotImplementedError`
That looks like what the juniors on my team come up with. Abstract classes in Java (C#) make sense, because polymorphism requires work in Java (C#), and you don't have modules / mixins to share behaviour so you're stuck with inheritance. Inheritance is a poor (inflexible) way of sharing behaviour, and ruby has polymorphism out of the box, thanks to duck typing. In addition, inheritance is a focus on what your object *is* instead of what it *can do*. Don't base your ruby practice on Java's (C#'s) shortcomings.
A problem with not explicitly declaring some type of "not implemented error" is method_missing can cause you to miss the issue altogether and just have some weird behavior. Good to know about the actual NotImplementedError class though.
... You lost me at passing around Money as floats. Good luck.
meh, IMHO sugar cruft like zero? actually reduces readability -- just looking at your point, you do realize that yeah we check for 0 more than other numbers but by special casing that check now we have created two visually unique ways to handle one type of action. ` x == 0` `y == 1` etc are all uniform and once you read and unserstand once you have one thing to track. Start tosiing in `x.zero?` `x == 1` `p.one?` and you now have different code to understand for the same actions -- is .zero? implemented as `== 0` how is it different? what about `.one?` why is it special cased? I would much rather read a uniform `==` usage in code than have randomly named/aliased methods that in the end present less information about what they do and how they do it. 
Have you tried TryRuby yet? I'd start there. If that's not challenging enough, take a look at Ruby Koans and exercism.io.
Thanks
`Numeric#eql?` is same-class-equality: `1.eql?(1.0) # =&gt; false` `Object#equal?` is identity not equality: `1e100.equal?(1e100) # =&gt; false`
Come join us over at /r/dailyprogrammer
cool thank you
The whole idea of an abstract class is you can't instantiate it. In languages where it's built in it's usually a compilation error.
Ah, gotcha, but isn't that the `raise` in the `initialize` method in the post?
[codewars](http://www.codewars.com/?language=ruby) was definitely my favorite way to learn Ruby.
Thanks, looks really cool
What book are you using ? I'm learning ruby as well using The Ruby Programming language by David and YuKihiro
You won't get charged unless you upgrade your dynos or use payed add-ons.
Though I think permutation is what you are looking for, I would also suggest using more descriptive variable names for readabilities sake.
[Array#repeated_permutation] (http://bit.ly/2bLmbJ5) 1) case : binary ~ decimal ranges = -&gt;n,digits { [*0...n].repeated_permutation(digits).to_a } ranges[2,2] #=&gt; [[0,0], [0,1], [1,0], [1,1]] ranges[2,3] #=&gt; [[0,0,0], [0,0,1], [0,1,0], [0,1,1] ... [1,1,1]] 2) case : binary ~ ranges = -&gt;n,digits { (0...n).map {|e| e.to_s(n) }.repeated_permutation(digits).to_a } ranges[16,3] #=&gt; [["0","0","0"],["0","0","1"] ... ["f","f","f"]] 
&gt; In most cases, zero has a "special" value, so .zero? That's not what it's for; `i.zero?` is just as clear as `i==0`. The difference is that it something went wrong and `i` is actually a string or some other non-numeric value, `i.zero?` throws an exception while `i==0` will cheerfully return false as if nothing was wrong. 
I'm not an author of the library, just posted the link. Will try to summon him here, though :)
This direct integration with onigmo is definitely a better approach than what I did. My library started out as a bit of a fun experiment, and grew into a "complete" solution - but was always a little flawed by my attempt to define my own "parser" instead of using onigmo directly. I'm also rather intrigued by some of the behavioral decisions that differ from my tool. For a start, the inclusion of a debug mode sounds interesting (I'll play with it later). Most of the other differences seem to stem from the facts that my gem (A) does not attempt to work for "irregular" patterns, and (B) was originally designed to generate **all** strings that match a regex; then only later extended to generate a single example. In hindsight, generating only a single example (Regex#random_example) is a far more useful feature, so it's good that you focused solely on this.
There was enough [in these challenges](http://cryptopals.com/) for me to extensively learn Ruby.
Thank you. Will ask on Stack Overflow. Hate to work with RVM.
There were not floats in my example. You *read* 0.001 as a float. Probably because when you type `0.001` into IRB it interpretes that as float. But again, read it as *an example*, where the exact details matter little: should I spend 60% of that example code to explain that the numbers are bigdecimals when that is totally irrelevant for the point I was making? Now, about dealing with floats. Let me give an example: Given a euro, I want to share it amongst 3 friends. Usually you'll first calculate some distribution, which will be floats. Then with these floats, you'll calculate the distribution. Probably ending in (Note: following is BigDecimal) 0.33, 0.33, 0.33, calculate the leftover cent and distribute that using some algorithm that fits the business. For the above example, it helps to calculate back to BigDec ASAP. But when that same algorithm is applied to distributing 0.01 or 0.02 amongst 3 users, or distribute 1 dollar amongst fourhundred users, you'll want to deal with floats as long as possible. Which, incidentally, is what e.g. the `distribute` helper in Money does.
nice work, thanks for sharing!
Thanks very much! :) You are most welcome. :)
Cool! I'm gonna play with it later today. Excited!
Thanks buddy. :)) I hope you will like it. :)
I'm not at my computer but I'm thinking maybe you could check self.class. Seems kind of crude though.
So don't use rvm? 
I agree with the sentiment that you shouldn't try to write Ruby in the idiom of a different language, but not with the idea that the Java model is inherently inferior. It's just a different view of the world with its own advantages and disadvantages.
&gt;There were not floats in my example. You read 0.001 as a float. Probably because when you type 0.001 into IRB it interprets that as float. But again, read it as an example, where the exact details matter little: should I spend 60% of that example code to explain that the numbers are bigdecimals when that is totally irrelevant for the point I was making? What I read is you chose to give an example related to using .zero? that was specifically formulated showing floats given basically the only topic that you do not use floats in in the way shown. And again, your example is constructed to show a price as a float (big or not) and not an int in code. You could have chosen any other example with floats to make your point but you chose to display one that was fundamentally incorrect. &gt;... Which, incidentally, is what e.g. the distribute helper in Money does. I think you mean `allocate` (and in your specific case with equal allocation percentages you mean `split`), and no you do not want to deal with float as long as possible (nor does Money), you want to limit the float operations to the minimal set the for problem scope. Either way, I don't really care what your take on this is -- you lost me when you gave an example constructed to show money being passed around as floats. Your choice of an example does matter in this case as your example's subject matter inherently shows lack of quality and understanding... If you were to have picked just about any other subject matter for floats/.zero? it would not negate your voice on the matter. Also if you are working on banking systems please let me know what software I should avoid. 
I don't think they're shortcomings. They're deliberate design decisions that make maintenance and debugging easier at the cost of more code to achieve the implementation. As for the capitalization of Ruby, not what I've seen in books and Wikipedia page also treats it as a normal proper noun.
Oh :O, honestly I thought web sockets was a brand new protocol.. That's okay though just means I need to go deeper into learning the history of http is my guess. Back to usefulness, so as long as the server looks for custom headers on a web socket request from the client.. It should be the same format as http headers in the GET string? 
Thank you for insight, the road of learning something new is always putting me in positions of asking people like yourself for so much information. 
The setup is similar to bitbucket, setting github as a remote, and pushing to it. This link may help: http://stackoverflow.com/questions/22906917/how-to-move-git-repository-with-all-branches-from-bitbucket-to-github
Is this what you are trying to do? a = [0,1,2] b = [0,1] c = [0,1,2,3] list.each { |item| print '[' ; item.each { |i| print "#{i}," }; puts '],' } [0,1,2,], [0,1,], [0,1,2,3,], =&gt; [[0, 1, 2], [0, 1], [0, 1, 2, 3]] There are some extra commas, but you get the picture.
I think exercism.io is great, but it is a little different than what I think the OP is asking for. It provides feedback on coding technique and style as opposed to a set of exercises.
I always use this to expose my rails routes to my client side js. You can choose the way you want it, you can make a resources object and nest your resources in there or just expose them in the Routes object. I added both options in the example below. &lt;% depend_on Rails.root.join("config/routes.rb") %&gt; (function() { MyApp.Routes = { resources: { posts: { index: '&lt;%= Rails.application.routes.url_helpers.posts_path %&gt;' } }, postsPath: '&lt;%= Rails.application.routes.url_helpers.posts_path %&gt;' }; })(); And now you can use this `MyApp.Routes` in your javascript like so: `console.log(MyApp.Routes.postsPath);` or use the resource object: `Myapp.Routes.resources.posts.index` (and name the file something like `javascripts/utils/routes.js.erb` and include them in your `application.js` file.
Impossible. Metasploit for macOS need to use RVM.. Sadly.
Yes! I have programmed quite a bit in Java. I know what an instance of a class is. In java from what I understood, instance variable of a class X is an object of type X. What threw me off in ruby is the fact that instance variables can be assigned as arrays or other objects. And that it is declared in the class itself. Anyways, that link helped a lot!! Now I get it. The class variable can be changed throughout the different instances/objects of the class. While instance variable is limited only till the vicinity of an instance. Changing it for one instance wont change for others. If you do get time, then could you answer the other two question? The main difference between the methods "things" and "self.things". And why do we not have to make an instance of the class to modify its instance or class variables. If not then its fine! Thank you so much! 
No worries. So... Ruby is tricky because it allows you to do many things. And because there is metaprogramming, you can virtually do anything. Nothing is really restricted like in Java. You wouldn't get an error if you change a Class variable ( "static" in quotes because it's not really static ) through an instance variable, but you will get very weird behaviour, so you should avoid doing that. :) That said, for ruby, the first thing you need to understand is the 'Singleton' class. And I'm not talking about Singleton as in the pattern, I mean the [Singleton Class](http://www.devalot.com/articles/2008/09/ruby-singleton). I couldn't find a really good description about it, but this one will sort of do. :) I'd recommend you read this book: [Eloquent Ruby](http://eloquentruby.com/) Will make everything much clearer. Or do this guide [Learn Ruby The Hard Way](https://learnrubythehardway.org/book/) or this one: [Ruby Koans](http://rubykoans.com/). Which is learning ruby through writing tests. After you get what singleton class / methods are the self. indicator will get better. Self is sort of like this in Java but not. :D It marks the receiving object. If used in a Class like this: class Whatever def self.cool_func end end The receiving object is the Class, because in Ruby, everything is an object. Meaning the method will be available when you do this: Whatever.cool_func And if you do it like this: class Whatever def cool_func end end Now if you would call Whatever.cool_func it would give you a method_missing exception because cool_func is NOT part of the Whatever object. But it will be part of it once you create an instance out of it. So this would work: Whatever.new.cool_func And than come @@ variables. These are part your plain public static's "sortof" like in Java. They have a bunch of other things going on for them, but mainly they are shared and can be edited from either a class or an instance and it will change for everyone. I'm sorry, this is, like a HUGE topic, so sorry, if I kind of sound vague. Better people than me described this a LOT better. :) **EDIT**: Try this one explaining what @@ does: http://stackoverflow.com/questions/5890118/what-does-variable-mean-in-ruby 
First, thank you so much for writing Learn Ruby on Rails (the first book). I'm almost finished reading it and it's been a delight. My background is that I've done a little programming over the years, mostly just personal stuff that's very small. I could go on and on about all the things that were great but I'd like to point out one thing that was a bit demotivating for me. I got towards the end of the book and it just felt like...link soup. I appreciate it when someone takes the time to point out someones options on learning things, and you even took the time to say that some sources were out of date or just not worth it. That's great, but I felt quite overwhelmed with the dozens upon dozens of links towards the end of the book. As someone with quite an inquisitive mind I found that I steadily worked through the entire book over this weekend until I got to the end of the book, where clicking on each link lead me down a rabbit hole that sucked the time right out of me. I would say my signal to noise ratio was phenomenal for the first 90% of the book and then I completely lost focus and went off on a tangent. The kind of tangent where you go to youtube and 3 hours later you wonder how you got there. Anyhow, I don't want to be negative for such a wonderful book but I just wanted to give some feedback and say that you're awesome. 
Hmmm. I have GitHub repositories and know how to migrate Git repository. The problem is how to migrate issues on BitBucket. If you commit to commit to (or PR to) my project, I will add-remote regextest repository to GitHub this week-end!
This sounds like a typical example of "just because you can, does not mean you should" feature. While I can see a few legitimate use-cases, I see far more dangerous ones. The example OP gives about "current_user" is not only an ill advice if you have all your threads tamed. It is actually is rather dangerous because people could become other people with nothing more than some server-config changing. The only legitimate usecase I can think of is to store some environment-variable details. For which we have dotenv. Or maybe to centrally store connection pools for a database or some other resources that are very safe to share but expensive to set-up.
That's exactly what it provides: a set of exercises to complete while also getting feedback. I'm not sure what you mean by "as opposed to a set of exercises." 
I guess it is a matter of perspective. When I think of the exercises to learn the language, I think of a set of exercises that take me on a tour of every aspect of the language, like the old ruby koans, or the exercises in a book on ruby. When I think of exercism.io, I think of it as a limited set of exercises that provide an opportunity to get (and eventually give) feedback on particularly interesting problems. I will admit that I have not been to exercism.io in about a year or more (right after exercism/Katrina appeared in Wired magazine), so maybe they have exercises for every aspect of ruby now.
Ah this makes a lot of sense. The first link clears up a lot of things. You have been a great help. Thank you very much!! 
Eyyy, cool. :) Very glad, I could help you out, man. :)
&gt; As for the capitalization of Ruby, not what I've seen in books and Wikipedia page also treats it as a normal proper noun. I stand corrected. &gt;I don't think they're shortcomings. They're deliberate design decisions I don't think making polymorphism hard(er) to achieve was a design decision. Forbidding multiple inheritance, definitely, to avoid repeating the mess that it generates in C++. Losing easy polymorphism is an unfortunate side effect of this decision, I believe. &gt; that make maintenance and debugging easier at the cost of more code to achieve the implementation. I think more code makes inevitably more noise, and more difficulty in refactoring. If you have three layers (Interface -&gt; Abstract class -&gt; implementation, quite common in Java) to jump up and down to figure out what is happening as opposed to a single layer (as you can do in Ruby or JS), that will hinder debugging and maintenance. NB: To be clear, none of my statements are meant as a judgement against Java as a whole, only as observations of the difference between Ruby and Java *in this specific aspect*.
I agree with the premise: to fully understand a solution you have to understand the problems that were solved. I don't agree with the conclusion that the personality types that are always compelled to go deep down the rabbit hole have ever or will ever run the world. No real world problems can be understood by one "hacker". Complex problems require teams of people overlapping their strengths, understanding and experiences. Web development is no different than any other complex solution. The stance that a solution can only be used by someone that fully understands the problem that it solved is fundamentally flawed and at the root of [Not Invented Here Syndrome](https://en.wikipedia.org/wiki/Not_invented_here). The author talks about "The Good Old" days where he had to troubleshoot his sound card and how great that was. He wasn't solving a novel problem, he was a kid fiddling with a sound card. Does he think that the sound card was hacked together by some dude that had full knowledge of circuit board plating technology, robotic soldering protocol, mining and purifying fundamental elements, sonic wave patterns, input and output devices protocols, and hardware controllers? Fuck that. When I get into my car my phone automatically picks up a podcast right where I left off. Fucking sound card magic. At some level we all are using complex solutions to solve our own problems without having an understanding of the problems already overcome. I wonder if he is "hacking" rubber tire technology because he needs to understand how to grow a rubber tree in order to drive a car. The problem has been solved adequately, the [solution doesn't need to be reinvented](https://en.wikipedia.org/wiki/Reinventing_the_wheel) over and over and over. The author is hoping that the web development world will come to the realization that he should be the one to do it all. We all need to come to terms with the vast complexity of the computing world. No one person can do it all. If you are, you are building a system that is unmaintainable, brittle, and out of date before you are even done. Good engineers use existing solutions and understood tools to simplify problems so that people with less knowledge can build on that solution. That perspective comes through a humility that doesn't come easy for the "hacker" personality. The author has a choice to grow as an engineer, find a world with unsolved problems to "hack", or to keep thrashing around angrily in a world that doesn't have much need for "hackers" anymore.
Lots of bigger mail providers (SendGrid, Mailgun) have this functionality too. Inbound mail parsing API is probably an acceptable search term.
&gt; It internally uses Thread.current#[]= method Noooo! Snatching defeat from the jaws of victory here. This method should really be named Fiber.current#[]=, as it's actually local to the current fiber and not the thread. This is what you want if you're (ab)using thread (actually fiber) locals for dynamic scope, but is broken in pretty much every other case. To remedy this problem, Ruby added the Thread#thread_variable* family of functions which are *actually* thread local and play well with things like Enumerator or frameworks which use fibers like Celluloid. Unfortunately this isn't using them, so beware if you ever use Enumerator and expect to be able to access them.
[Why?](https://media.giphy.com/media/1M9fmo1WAFVK0/giphy.gif) EDIT: Well, [the pull request](https://github.com/rails/rails/pull/22630) introducing it says it all. It's just something DHH wanted, because reasons.
Yeah it's pretty bad in there actually. I don't think it's even consistent how wide they consider the tabs to be.
I'm curious what benefit this has over just using long memorable phrases as your password with some symbol substitutions. With a long enough password that is hashed and salted, it already takes too long to reasonably brute force the password and dictionary tables become far too large. It seems like its just hashing a password twice which does not do much for adding security. Would it not be better to just generate the random string randomly and use a password manager? I mean, with this utility you end up needing one anyway.
Are you sure it's Metasploit that needs RVM, rather than the `MSF-Installer` package you linked to? It looks like `MSF-Installer` is not the only way to install Metasploit on OSX, googling around. But I've never used Metasploit. 
You should compare the strength of the key vs. the hash using zxcvbn: https://dl.dropboxusercontent.com/u/209/zxcvbn/test/index.html 
Thank you for the kind words and the constructive feedback. I'll give some thought to pruning the links in the last chapter. Or at least reminding readers that the links are there for reference and purely optional.
Agreed completely. But I'm also getting tired of seeing passion defined as "off the clock coding." Fuck that noise.
&gt; Later on, for example, if you want to move to a different web server that has different guarantees around threads, then you're in trouble. Major parts of Rails (ActiveRecord, I18n to name a few) rely on the fact that request is processed in its own thread. 
I don't understand why you'd want to do this. Some example use cases would be nice. 
Word.
One way to circumvent password reuse would be to have a unique passphrase for every site/whatever you register to. Something like: username$#(website)&amp; for the passphrase means you can change it for each site and have a unique password each time
That's less secure than having unique random generated passwords for each site. If I can reverse-engineer one of your passwords, I can reverse-engineer all of your passwords. Also, this code is a boneheaded way to secure something: word = Base64.encode64(Digest::SHA512.hexdigest (Digest::SHA384.hexdigest (Digest::MD5.hexdigest (Digest::SHA1.hexdigest word)))).gsub("\n","") + Base64.encode64(Digest::SHA512.hexdigest (Digest::SHA384.hexdigest (Digest::SHA1.hexdigest (Digest::MD5.hexdigest word)))).gsub("\n","") I strongly recommend that you recuse yourself from the development of any security software for a few years for that monstrosity.
Curious. Is ruby your first language, or is this a learning project? Because I see like a lot of things here, which you can improve in the world of ruby. Like: if $options.secret == true. There are two things wrong with this. Global variable, and why == true? Why not just $options.secret? If it can be anything else other than true, like, nil, and so on and so forth, I would rethink using something else. You use indentation inconsistently. This whole thing: def ask_passphrase(prompt="Enter passphrase: ") if $options.secret == true $passphrase = ask(prompt) { |q| q.echo = nil } else $passphrase = ask(prompt) { |q| q.echo = "*" } end $passphrase_verify = $passphrase return $passphrase end Can be rewritten like this: def ask_passphrase(prompt="Enter passphrase: ") $passphrase = ask(prompt) { |q| q.echo = $options.secret ? nil : "*" } $passphrase_verify = $passphrase $passphrase end And there are some other things in here that you seriously need to rethink. Good luck! Nice project though. :)
Discussed here: https://github.com/rails/rails/pull/22630#discussion_r47997074
 def magic(word) word = Base64.encode64(Digest::SHA512.hexdigest (Digest::SHA384.hexdigest (Digest::MD5.hexdigest (Digest::SHA1.hexdigest word)))).gsub("\n","") + Base64.encode64(Digest::SHA512.hexdigest (Digest::SHA384.hexdigest (Digest::SHA1.hexdigest (Digest::MD5.hexdigest word)))).gsub("\n","") return word end Indeed. Magic. There are plenty of good key derivation functions. This isn't one of them.
The actual generated password is actually generated after the truncate function, thus it's not immediately reversible unless you can guess the other missing half of the base64.
If by "off the clock coding" you mean _doing it for free_, yeah that's bullshit. If you mean personal projects, I guess it depends. If you are absolutely fulfilled by your day job coding wise, you're living the dream - there's no need to spend MORE time coding. Personally I just crave a little off-hours programming because I like making things purely for myself without outside constraints. I don't think anyone _has_ to "prove" that they're a "real hacker" by coding 200% of the time. That being said, I think everyone would prefer to work with people who are passionate about their field. By passionate, I just mean _they like what they do_, they're _interested_ in what they do. Programmers are both fortunate and unfortunate that there is little barrier to entry. You don't have to drop a couple hundred thousand dollars to practice. Coupled with booming demand, tech being "cool" now, we're getting all these people who don't care _at all_ about what they do, it's just "a job". They don't want to learn, grow or experiment, they just want to collect a paycheck. When you don't like your job, your output tends to suffer. Programming generally being a team sport, this is kind of annoying for other people on your team. But whatever, that's life. We're all going to be replaced by machines sooner or later.
[PBKDF2](http://ruby-doc.org/stdlib-2.3.1/libdoc/openssl/rdoc/OpenSSL/PKCS5.html#method-c-pbkdf2_hmac_sha1) is included in the stdlib and a reasonably secure approach. Iterations should be quite large as documented.
The problem with that chunk of code isn't reversibility. I was making two unrelated complaints - one about your suggestion to make patterns in your input (bad suggestion due to reversibility and replayability) and one about your "magic" function, which is bad implementation (due to those hashes being Surjective, or at least MD5 is - you should be using bcrypt or PBKDF2. You are making very fundamental security mistakes. I am *seriously* suggesting that you do not design security software until you've spent *a lot* more time learning, and never ever make any security focused code on your own.
Thanks!
Another post with "in my time it was better" and "the good profile is to be like me".
To make it a lot more secure, you'd have to choose a random salt and keep that stored. That may be not what you intended with the application. But even with a static salt, the PBKDF2 solution is incredibly more secure than your first version.
Thanks for the input, I'll take a look to implement that when I find time. Update: I just wrote a sample code. require 'highline/import' require 'openssl' require 'digest' require 'base64' word = ask("Enter a word") salt = "vZppDiuceUa0xf1+gODZ+g==" iter = 2000 keylen = 120 puts Base64.encode64(OpenSSL::PKCS5.pbkdf2_hmac_sha1((Digest::SHA512.hexdigest (word)), salt, iter, keylen)) Would something like this work? It'd still go through with the truncate function to make sure the user gets the password with their specified length, but a key length of 120 with the SHA512 hashed version of the keyword looks nice to me. What do you think? Edit: I forgot to mention I generated the salt with SecureRandom, but I don't think it should be random since it would defeat the purpose of the app. 
This is the kind of "feature" an expert beginner uses because he refuses to learn better approaches developed by earlier generations and instead relies on his own ingenuity.
I'm a bit busy at the moment (sorry D:), but yes, that is a big problem. I guess you can just put it up as a mirror for the code, and setup email alerts on github for issues. Stop more issues on bitbucket and redirect to github, handle all the issues on bitbucket, don't think you can move it.
&gt; without adding entropy I disagree with that. Even a base64 encoding increases the entropy, as it doubles the number of possibilities that any dictionary/brute force attack would need to try: The original and the encoded version. However, with that said: If this tool does become widely used, then it will **only** double the number of guesses needed, for precisely this reason! So especially if the attacker were to use rainbow tables, there's not *much* to be gained here.
For example, not that I'm actually going to try, I wonder if I could hack any of OP's online accounts by brute forcing with an encoded version of the top 100 most common passwords? Or that of anyone who starred this repository? You get the idea.
This is not how entropy works. Your process does not add any entropy. It makes a brute force attack harder if the attacker doesn't know the process. This is called security by obscurity and should be avoided whenever possible. A simple example: def magic(word) "12345" + word end It makes the word longer but doesn't add any entropy. If an attacker doesn't know, he will have to try longer passwords and the brute force attack will take longer. But if the attacker knows (which should always be assumed) then he just prefixes every guess accordingly and the `magic` function achieved not a single thing. Perhaps even easier to understand: If your input password can only be `0` or `1`, then Hashing it will just yield either `H(0)` or `H(1)`. Even if it's 512bits, there are only two values possible. And even worse, a hash function may get the same value for `H(0)` and `H(1)` and therefore actually remove entropy.
1. There is an original definition of hacker, and it has nothing to do with breaking into systems. "Crackers" took the word and started calling themselves hackers, even though they weren't. This is also why cracking security systems is now called hacking. 2. I'm sure there are some Free Software/Open Source hackers who evangelize more than writing code, but (despite what the jargon file may say) since the terms hacker and hacking aren't limited to code or tech they could easily be a "social movement hacker" if they wanted to take on such a title. 3. The jargon file was not written by one person, though it was/is maintained by ESR. See http://www.catb.org/jargon/html/revision-history.html 
Yeah my bad, I should have phrased that differently... You may not be adding any entropy, but you're still doubling the number of guesses needed. *(Assuming the attacker does not know for sure if the password is encoded!!)*
If the password is not brute force-able to begin with, then why would you bother to use this tool??? And again, if you just want a random string, why would you bother to use this tool? - You're just encoding `SecureRandom.base64` with the above algorithm. Why not just use `SecureRandom.base64` itself as your password? I'm sorry. but I don't see any point in this library. At best it's just a random string generator (and a poor one at that, since you are losing entropy by truncation). At worst, it promotes bad password management practice and encourages the use of easily crackable passwords.
I understand your point. I guess we will have to agree to disagree. Cheers.
&gt; (nothing big like systemd) Is this purposely supposed to sound like Linus's linux kernel announcement? Because it does lol. Edit: An actual question. If you are already happily using systemd, is there a compelling reason to use imoortal instead?
I'm not sure I would say it has _nothing_ to do with breaking into systems. Revisionist history not withstanding, I think 'hacking' and 'hackers' always involved figuring out how to re-purpose official systems for your own uses or projects without official permission. Which is something that has _something_ to do with breaking into systems. 
I don't think "it makes polymorphism harder" isn't the right way to think about it. It makes it explicit. The declaration can be tiresome but it also means you don't spend time trying to figure out what in the world is actually getting passed into your method and static analysis is easier. In fact, in some ways I think refactoring is easier in the Java model. If you're not sure what will happen if you rename some method or change its parameters you can always just change it and see if it still compiles. I have to see that in practice I don't see a lot of places where an interface and an abstract class are used at the same time (and frankly I see a lot of programming directly to an object without reference to an interface too) but I think both the interface and abstract classes are pretty powerful tools that work well in the environments they were created for. To sum up my opinion, I think the Java model is basically trading some pain up-front with less pain down the road. Whether that's a sensible trade-off depends on your personal preferences, the type of project, and so on.
Any reason to use that over another tool like `god` ( http://godrb.com/ ) ?
people are still using unicorn?
There's too many nice things in 2.3.1 to justify going back to 2.2. I've been using it in production as well and it's fine - no issues.
Hi, coincidence perhaps. Regarding systemd, I don't use it, mainly because I work with FreeBSD, but some colleagues using ubuntu 14/ruby had this need of how to properly follow a pid after forking and unfortunately they didn't have systemd, if I am right systemd is not available in all linux distros. 
I don't know if ``god`` allow to follow the pid, or support yaml for configuring, I focus more on covering this issues: https://immortal.run/post/the-problem-to-solve/
Of course.
God is quite terrible. Eye is much better version of god: https://github.com/kostya/eye
Nice, thanks for building this wrapper! Will take some time to play around with it shortly. 
Awesome! Let me know if you will have some issues or suggestions.
Do you think ActiveRecord::Enum is a bad idea in the first place? I could def be persuaded of that argument. I'll look into how actual db enum types work in activerecord, I'd want them to work in a db-independent (mainly postgres or mysql) way, and result in a decent ruby activerecord API on the ruby side. ([Rails guide](http://edgeguides.rubyonrails.org/active_record_postgresql.html#enumerated-types) says "Currently there is no special support for enumerated types. They are mapped as normal text columns") But if you're going to use ActiveRecord::Enum at all, is mapping to strings a significantly worse idea than mapping to integers? I would be shocked if the performance/storage-space difference is all that significant in postgres for all but the largest most performance dependent contexts. Actually, if postgres enum is just treated as String by ActiveRecord... I bet you could use ActiveRecord::Enum with 'string' values, with the backing data actually being a postgres enumerated type. That might be an interesting thing to look into, I'm curious and might do it when I have time. Might be the best of both worlds -- making ActiveRecord::Enum support of 'string' values actually even more useful. 
Some examples: Sentry's raven-ruby gem uses it to pass some data about errors around. I've seen it used in a multi-tenant Rails project to pass the tenant ID to various ActiveRecord default scopes to ensure tenants only would see their own data. I believe DHH tweeted on the subject, something along the lines of globals being sharp tools: useful but to be handled carefully.
Hi, there are many supervisors and is very difficult to compare each of them, I basically started immortal to cover some needs that where missing or not [properly working](http://serverfault.com/q/752839/94862), besides implementing something what could work in any *nix like operating system. The main needs that I cover: * Easy CI/CD flow (run.yml) the idea behind is to control the status of the app within the deployment. * Distributed logging, log locally, remotely, both, or pipe to your own logger * Follow Pid (unicorn example). I wrote a little about it here: https://immortal.run/post/the-problem-to-solve/ Work still in progress so any help feedback would be appreciated. 
Hm, I'm thinking if you were to use a type like this combined with ActiveRecord::Enum with "string" values, you might get the best of both worlds -- because you'd also get ActiveRecord::Enum's support, including preventing on the client side from setting to any non-allowed value, query methods like `record.monthly?`, automatic scopes, etc. Of course you can set all that up, everything ActiveRecord::Enum does, yourself manually too, there's nothing ActiveRecord::Enum does you couldn't do in a few dozen lines of your own code, it's just a utility for a common pattern on the client side. Interesting idea, I'm going to try to find some time to play with it. PS: If you don't use ActiveRecord at all and think it's a bad idea, that's a defensible and reasonable argument, but kind of a irrelevant foundation to discuss specific AR features. :)
Lucky for you this has [mostly been addressed](https://github.com/SchemaPlus/schema_plus_enums).
Looks like that's just support for migrations (just for postgres). Which is certainly useful. Although I'm not really opposed to writing raw SQL in migrations either. 
you may ask at github if heroku does not offer proxying nginx, it does not imply its uselessness ‚Ä¶
Are you taking inspiration from Erlang's supervisor trees?
Not really, based/inspired more from [daemontools](http://cr.yp.to/daemontools.html)
`includes` will only perform a join when you've also used `joins` or `references`. Otherwise it performs two queries which is usually more performant. Active Record does use a query cache, on a per-request basis. It's generally cleared in cases where we know it to be invalid. We don't use an identity cache however. So if you do `User.all` twice in the same request it'll only perform one SQL query, but the resulting Active Record objects will be different objects. It doesn't introduce a significant number of stale results or support issues.
&gt; Is there a way to intentionally use it when using AR from contexts that aren't a request at all? Yeah usage from Active Job and Action Cable were the reasoning behind changing to the executor API
I've been staring at the source for a few minutes, which actually looks the real meat is in ExecutionWrapper. Still don't quite have a sense of how it's supposed to be used. It would be awesome if someone would write some class header rdoc with usage examples/summary. 
This looks really, really cool. So far this conference is pretty awesome. Does anybody have a link to Matz's type system talk/slides of the talk? I'd really be interested in what he had to say about that.
Does anyone have an ELI5 version of the attached presentation?
You can use [`#send_file`](https://github.com/sinatra/sinatra#sending-files).
[This](http://www.sinatrarb.com/intro.html#Static%20Files) should do the trick. In this case you should set public folder to be your wallpaper folder and the `get` method should return basename (`File.basename(files.sample)`) of the file.
Ruby doesn't really multithread at the moment due to the Giant VM Lock (GVL) which means only on thread runs at once. The proposal is to make separate object spaces (called Guilds) and replace the GVL with a Guild Lock that means threads working within different Guilds can run concurrently.
I think GVL usually/originally stands for "Global VM Lock"?
I would serve an image itself randomly def '/img' do File.read random_image end def self.random_image Dir.glob('/Users/foo/pix/*').sample end
I have tried to use refinements, but it's surprisingly difficult to get working. You have to have `using` present in the file that uses the refinement, which isn't always easy, if your code is calling code in another file. Also, any use of dynamic dispatch (e.g. `send`) won't work. And by "won't work" I mean, "use the non-monkeypatched version of the method instead" -- which often proves incredibly infuriating to debug.
Thanks for sharing these.
The downside of this approach is that it adds a new concept (Guilds) that have to be implemented in rubinius and jruby for no real reason other than compatibility. I don't understand why more folks who want off the GVL don't use MRI alternatives.
I see where you're coming form, but this is a pretty simple concept that I don't think would be too difficult to implement. It's just a few rules around object access and 1 or 2 new classes. EDIT: [Ruby Core member @zzak says the current implementation is just 400 lines of C](https://twitter.com/_zzak/status/773906835094974464). Obviously that will grow, but if you can get a PoC up in just 400 lines, that's pretty good.
The presentation goes over some 'gotchas' in JRuby too for actual thread-safety, that Guilds would address. Concurrent programming is hard no matter what, even in JRuby. I think collectively people are still struggling for the 'right' concurrency abstractions to make it as simple as possible to write concurrent code without race conditions -- even the languages promoted for being great for concurrency don't all use the _same_ abstractions. (Scala, Go, Erlang, Haskell, Node/JS, etc, all somewhat different approaches to concurrency). "Guild" might not (or might) be the abstraction you would come up with if you weren't constrained by MRI's history -- every language comes up with different ones because the architecture and context and goals matter. But it's definitely not entirely useless in JRuby, even imagining a world where JRuby was the only ruby and you didn't need to worry about MRI compatibility, it's not useless in JRuby. Of course, in the world we're actually in, being able to write code that works in both JRuby and MRI is _hugely_ valuable, a large benefit ruby has. Not everyone wants the JVM. 
yes there are better more robust alternatives, but if you want something dead simple here you go ;)
Interesting but not necessarily what Ruby needs. Parallel execution is annoying. You *always* have to give something up to make it work. This proposal understands that, and tries to compromise by providing message passing parallelism in addition to the existing non-parallel concurrency model. Two problems: * The guild model would work, but it's kind of weird. Weird stuff needs to be really good to be worth it, and I don't see why this is better than any other random solution. * Presentation glosses over a key problem: Class synchronization. What if I monkey patch String? Are we getting a lock every time we call a method? This proposal is either slow due to class synchronization, or basically equivalent to fork + an IPC library. Compared to fork, it'd be faster for IPC, slower at GC due to stop-the-world.
if this proposal is successfully implemented and adopted, would that eliminate the need of background job or sidekiq?
We might still have a GVL lock when we open a class, or define a method, but both of those aren't things that happen at large volume in ordinary Ruby code. And presumably refinements will still work fine if you need to tweak stuff on a by-object basis.
From a tactical perspective, it doesn't seem like a big deal. But everything included in the standard library adds additional maintenance cost to every implementation of ruby. Ruby is better served by being judicious about adding new modules. This one doesn't seem necessary to me.
True, but execution is either inside a method or not. As long as the world stops while you're switching out the method dispatch table entries (to point the method name at the new code) I'd think it should be fine? (I'm an experienced ruby dev, but haven't actually looked into the internals any)
ruby-concurrent Actor (or any other implementation) doesn't get MRI to multi-core parallelism of course. Erlang says Actors, Go says goroutines, Node says non-parallel async evented, Haskell says... I don't even know what, maybe that with immutable data you're good? I think you over-simplify if you suggest that 'Actor' is the consensus solution or something. Part of the reason differnet platforms have different baked in concurrency models is because it depends on your choice of many other architectural decisions. Of course, many of those decisions are already made and not easily changeable for both MRI and ruby as a whole. So that provides some design constraints too. Would it be ideal to 'standardize' on some existing concurrency abstraction that can minimize race conditions and also support backwards-compat parallelism in MRI? Sure. It's not surprising to me that Koichi didn't come up with one. But did come up with something that tries to take the best of what's been collectively learned about concurrency, and can be applied to MRI. I do think it's over-simplifying to suggest that this is a solved problem with a single solution across CS/software engineering, even without the constraints of existing MRI and ruby. If it was, every new platform claiming to get concurrency right wouldn't be using different models from each other. I'm not sure what you're suggesting should have been done different. Do I understand right that you're suggesting MRI should be scrapped and everyone should just use JRuby, and JRuby/JVM is all the concurrency abstraction anyone will ever need built into the language? I guess you can suggest that if you want, maybe you can convince everyone to stop using MRI if you say it enough on reddit....
This actually does not work. It freezes the browser and displays: HTTP parse error, malformed request (): #&lt;Puma::HttpParserError: HTTP element REQUEST_PATH is longer than the 2048 allowed length (was 2641)&gt;.
What does not work is that If I do this: get "/random" do @photo = send_file(Photo::Random.get) erb :random end module Photo class Random def self.get Dir.glob("/Users/.../*").sample end end end and &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My First View!!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;p&gt; &lt;img src="&lt;%= @photo %&gt;" alt='image' height="750" /&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; I get the image but always full screen and the view is not picked up. It seems that send_file overrides erb :random. 
Nope, Sidekiq allows you to distribute jobs across many processes and machines, handles retries, provides a nice monitoring UI, etc. Guilds allows running threads in parallel within a single process and provides no higher-level APIs or job abstractions.
Thanks for your kind words. Great to see it in use. To add a class to the slide the class directive should work e.g. try: %class yourclasshere or &lt;%= class yourclass here %&gt; Cheers. PS: Note, there's a dedicated [forum / mailing (called wwwmake)](http://groups.google.com/group/wwwmake) for Slide Show (S9) and friends. Just in case. PPS: Would be great to share your reveal.js template / theme - no need to worry about pull request - having your own (customized) copy is great - that's the (distributed) design.
I agree with /u/mperham a 100%. A 150% even. Just think about it. You get back to your project like a month back, and think, this is shit, I want to re-write it. You start pluking out code, but are you sure that the functionality is still the same? Is it still working the way you expect it to work? How can you know? YOU DON'T! That's where tests will shine, because you refactor, you fix things and the tests are still green, you can be confident that what you are doing is good. I recently took over maintaining a Gem. Boy oh f#cking boy. I'm refactoring a lot, and without tests helping me out, I would have basically said, f#ck it, ain't worth it. And than I find out that some of the tests are actually lying. Imagine that. Somebody is relying on that gem to work properly just to find out that it actually isn't. :/ Even for own projects. I sometimes don't write tests for short gems. Or short code. But for even a tiny bit bigger app, I write specs. Because I need to practice writing specs, mocking collaborators, and also, I know, that in a month, I will have zero ideas how my own gem works. Another benefit is contributors and PR checks. They submit a PR, and how do you know that they didn't break something? But you probably know all this. :)
&gt; Are you assuming the people behind "Guilds" have not done such an investigation? I think guilds are threads, 1. without lugging around the baggage that MRI currently brings with it, 2. with an additional caveat that you cannot pass mutable objects between them. Currently, threads are less than ideal because of that aforementioned baggage. Will guilds address that baggage, or work around it? If they work around it, don't we now have new baggage? I appreciate your response. I'll remain cautiously optimistic about them, I suppose. I should say that my preference is for threads to be made truly parallel on MRI. Barring that, I think using alternative runtimes is a fine choice in favor of adding new things to the language, unless those things are so awesome that they stand on their own.
You can omit the `then` keyword and put that case on the next line(s) operator = input[1].to_sym result = case operator when :+ then num1 + num2 when :- then num1 - num2 when :* then num1 * num2 when :/ if num1 or num2 == 0 puts "You broke the calculator" else num1 / num2 when :% then num1 % num2 else nil end puts "&gt;&gt; #{result}" 
Ruby is better served by improving itself and not getting weighed down by what might be difficult for alternative implementations. Being easy to implement for JRuby and Rubinius never was a design goal for Ruby and I can only hope it never ever will be.
Code is written the first time, and then revisited many times. Tests are an investment taking this into account; the first time they provide some help, but their main benefit comes with each "revisit" that you do to the code later on. You should write them not thinking about "you, now", but thinking about "the person who will read my code in the future" (it might be you in 3 years, or a coworker, or a collaborator). To me, writing software is a lot like mining, and writing tests is like putting pillars and security measures to prevent collapses. It would be much faster to dig up earth without these "extras". But when the first earthquake arrives, you will want them. In software, earthquakes are changes - any change - minor improvements, security updates, bug fixes, or new functionalities. And they happen quite often when a project is alive. Not building countermeasures against change is unproffesional and often fatal.
That doesn't help. That just means you need to synchronize the cache instead of the table.
I believe that "if" is broken, since num1 will always be "true". You could do: if num1==0 or num2 == 0 Or: if num1.zero? or num2.zero? Debating good code.. would a divide by zero be best handled by puts? You wouldn't in general take that message and input it into something else. Personally I would consider: raise "You broke the calculator" if num1.zero? or num2.zero?
/u/dinogrin if I weren't a poor college student I would buy you gold, thank you so much.
Look at it this way, your tests are not separate from your code. If it's just a small project, you can _get away_ with a poor test suite. Anything on professional scale is a disaster waiting to happen. Unless you have tests that ensure the contract and stability of your code, you can't be sure of the side effects of any change in a complex system. The best you can hope for is to manually test your own changes, and poke around looking for regressions. At the enterprise level ... that's a good way to lose your business for flakey software. The time it takes to implement _Feature A_ is the time it takes to implement the feature _and_ write the tests for the feature ... include that in your time estimates (which will be wrong anyway).
An alternative thing to consider; maybe there's something wrong with your requirements? TDD is fantastic at exposing the risk of constant invention when writing code. We like to solve problems and simple features can turn into entire frameworks and platforms if left to our own devices. By establishing some kind of acceptance before any code is written, it provides a constraint and milestone to determine when something is "done". Without a clear understanding of what you need to do, and without any acceptance, test suites can become the bed of edge cases that normally bloats software and feels like a waste of time because you're building complex fixtures, creating elaborate mocks, and trying to invent new problems to cover. Writing tests for preexisting code can sometimes be a lot easier than working on new features because you have a much better idea of what is expected. It's been my experience that TDD requires more time spent understanding the problem and planning a solution than writing tests or code. In fact, I'd say writing the actual implementation has been the least time intensive part of practicing TDD. That shouldn't be taken as "TDD takes longer than just hacking out some new code" because the reason the implementation usually takes the least amount of time is due to the tests defining a clear and coherent API and a much more thorough understanding of the problem. The time you'd normally spend debugging and trying different things is instead captured in those tests and persists throughout the life of your implementation. Think about all those debug statements and the trial/error code we tend to write that we then just delete before committing our code. That's a lot of effort that gets wasted that could benefit us and our code if it was captured in a test. For me, that's one of the most compelling reasons to practice TDD, so that the time I spend making sure my code runs correctly is protected now and in the future. As for your time and sanity, I'd say make sure you understand the problems you're working on thoroughly and focus on satisfying just those problems and nothing more/less. That should give you precisely enough testing. 
&gt; You may be writing more test code than necessary! That is a common mistake for beginners. It's also common for beginners to write *less functionality* than necessary. :) It may be that the author's code isn't quite as complete as they believe it is and that therefore writing the tests feels like a comparatively larger chunk of work. Of course, good tests will make that problem visible, but writing *good* tests is its own art.
That's sweet. Good luck with your studies, and take care.
Christ. That's what I am trying to push for. Less "test every line!" And more "what do we expect to happen from function X?" So e can actually update the code and not have the tests freak out with every minor change. 
Doing things just because your class is making you do them can be demotivating experience if you don't find the problem interesting. Try finding something outside of class to work on. For me, the most interesting part of problem-solving is identifying the problem - finding something that's difficult or annoying really motivates me rather than having a problem handed to me that has a clear solution. Try and find some problems of your own and fix them - try automating some slow or annoying thing that you often do. Most teachers are fine helping you get your head around issues with outside problems that you bring in as long as you don't disrupt the class with them.
Yeah, you want to make sure output's what you expect for a given input and nothing explodes on the way. The bit in between can be stick-it-on-mechanical-turk for all the end user really cares.
for more concise/rubyish approach, you can combine with division line to output division result unless either number is 0 puts (num1.zero? | num2.zero?) ? "broken" : num1 / num2 
I do the same. Some things are more suited to TDD than others. Sometimes I experiment on implementation, maybe write some proof-of-concept code. Then once I know how I'm going to break things up, I start writing tests and might TDD the rest. It's hard to write tests for a class or piece of functionality that you haven't even designed yet. I don't think "tests first" is meant to be taken that literally. At the end of the day, tests are tools. They should be there to make your life easier. Give you confidence to ship changes, and give you permission to refactor without worrying you've forgotten some edge case.
Thanks you too 
I think people started using GVL when we got YARV in Ruby 1.9, though I think GIL is probably still appropriate (since YARV is a bytecode interpreter).
`num2` can only cause the div by 0 right ? 
So a big gap they havent taught you is modelling and problem description. Ie: blackjack - you have cards, which are a kind of object - what makes them valid individually? They come in a collection, what makes that collection valid? - you have two piles for 'seen' and 'unseen'. Are these like the other collection? - how does a card go from seen pile to unseen pile? - are the cards ordered, if so, how? The game itself, you have hands - what are the rules for a starting hand? - what is valid/invalid (bust)? - how does a card get from the unseen pile to a hand? Etc. You know this, and if i asked you to describe solitare very simply, you could likely solve it knowing some of the above - even though some concepts are completely new, some old. Next tip: google it. Its not cheating to know your approach and read others; you will learn new things. 
The penny drop moment for me years back was that TDD is more about design than testing. It's a tool to articulate your assumptions, to remove initial inelegant designs without breaking everything and winnow your code down to its essential function. If you treat testing as a chore then it will be. If you use it to make beautiful code then it's a joy. Just my experience.
Thank you for posting this - I was beginning to think I was alone in this frustration! Also still in my junior learning curve myself and haven't had the experience of working in a TDD environment just yet, so on my own I'm finding the experience of testing to be a challenging one! I'm on board with the why...just find no joy in the actual doing! Like...I don't live for testing like some of my peers seem to do. Was starting to think I might be broken! Oh well! Onwards and upwards! Have to do things we don't like to do sometimes in order to get better as usual! Nothing more coffee and practice won't cure! :) 
I've been around Ruby since 1.8.7 but ... Clearly I haven't been paying enough attention. Thanks.
Can you provide the content of the `lib/tasks/localization.rake` on line 2? Something is attempting to load the `lib/localization` file, but the file path is not resolving correctly.
It is normal. There are several code paths that lead to the same code. For example an if statement needs to be tested for every conditionals, that's several lines of tests for one if. Have a look at this discussion, I know it was useful to me: http://programmers.stackexchange.com/questions/299796/is-it-normal-to-spend-as-much-if-not-more-time-writing-tests-than-actual-code
Also, it'd be useful to see a `ls -al` of the html folder and possibly all of it's sub-folders.
Jumping from javascript to Ruby seems like a big gap to make. If you're dead set on it, I recommend learning how to think about the task at hand first in plain english, then in simple psuedocode (ignore syntax and formatting rules), and only then, once you have a gameplan, begin coding.
rake gems? Try... gem install bundler bundle install Is there a particular rake task you're trying to run? What's the context here?
Speaking as a person that writes automated acceptance tests the description of the test is more important than the actual automation. The cucumber gherkin which is written by BA/QA/Testor working together to vhet out the test cases becomes the formal definition of how the feature that we built should work. The actual automation of the acceptance test is secondary to the formal definition of what the feature is supposed to do. When you create a feature the nuances are fresh in your mind and testing with a formal definition seems like overkill but what about 1 year later or 5 years later? The formal definition is what saves you. The automation of that definition is just icing on the cake. I have 5 years experience and can usually have the test 95% automated before the feature is done by the developer. 
You're right, I copypasta'd OP's code without proofreading 
 username@tasks:/var/www/html$ ls -al total 80 drwxr-xr-x 15 root root 4096 Sep 9 06:11 . drwxr-xr-x 4 root root 4096 Sep 9 06:03 .. drwxr-xr-x 6 root root 4096 Sep 9 06:11 app drwxrwxr-x 14 root root 4096 Jul 12 2008 cit-0.99.3 drwxr-xr-x 3 root root 4096 Sep 9 06:11 config drwxr-xr-x 3 root root 4096 Sep 9 06:11 db drwxr-xr-x 2 root root 4096 Sep 9 06:11 doc drwxr-xr-x 2 root root 4096 Sep 9 06:11 index drwxr-xr-x 2 root root 4096 Sep 9 06:11 lang drwxr-xr-x 4 root root 4096 Sep 9 06:24 lib -rw-r--r-- 1 root root 1060 Sep 9 06:11 LICENSE drwxr-xr-x 5 root root 4096 Sep 9 06:11 public -rw-r--r-- 1 root root 385 Sep 9 07:04 Rakefile -rw-r--r-- 1 root root 3798 Sep 9 06:11 README drwxr-xr-x 4 root root 4096 Sep 9 06:11 script -rwxr-xr-x 1 root root 7639 Sep 9 06:11 setup.rb drwxr-xr-x 5 root root 4096 Sep 9 06:11 test drwxr-xr-x 4 root root 4096 Sep 9 06:11 tmp drwxr-xr-x 4 root root 4096 Sep 9 06:11 vendor username@tasks:/var/www/html$
I am going to buy the book today. Thank you for the suggestion.
The db at this point doesn't have any records in it. So when I run the code I am expecting something like: #&lt;ActiveRecord::Relation []&gt; Followed by a the code exiting and returning back to `$` The code never exited after seeing the above output. That is what gave me the clue that I probably needed to disconnect from the db after the query. After adding the code you suggested, I am no longer seeing any errors on exit and the code exits cleanly.
Its free online :P
OK, using that ideology (great advice :) ) Im stuck here now: username@tasks:/var/www/html$ rake gems rake aborted! cannot load such file -- parsedate /var/www/html/vendor/rails/railties/lib/initializer.rb:159:in `rescue in require_frameworks' /var/www/html/vendor/rails/railties/lib/initializer.rb:156:in `require_frameworks' /var/www/html/vendor/rails/railties/lib/initializer.rb:88:in `process' /var/www/html/vendor/rails/railties/lib/initializer.rb:49:in `run' /var/www/html/config/environment.rb:10:in `&lt;top (required)&gt;' /var/www/html/lib/tasks/localization.rake:4:in `&lt;top (required)&gt;' /var/www/html/vendor/rails/railties/lib/tasks/rails.rb:7:in `load' /var/www/html/vendor/rails/railties/lib/tasks/rails.rb:7:in `block in &lt;top (required)&gt;' /var/www/html/vendor/rails/railties/lib/tasks/rails.rb:7:in `each' /var/www/html/vendor/rails/railties/lib/tasks/rails.rb:7:in `&lt;top (required)&gt;' /var/www/html/Rakefile:12:in `&lt;top (required)&gt;' /home/username/.rvm/gems/ruby-2.3.0/bin/ruby_executable_hooks:15:in `eval' /home/username/.rvm/gems/ruby-2.3.0/bin/ruby_executable_hooks:15:in `&lt;main&gt;' LoadError: cannot load such file -- parsedate /var/www/html/vendor/rails/activesupport/lib/active_support/core_ext/string/conversions.rb:1:in `&lt;top (required)&gt;' /var/www/html/vendor/rails/activesupport/lib/active_support/core_ext/string.rb:2:in `&lt;top (required)&gt;' /var/www/html/vendor/rails/activesupport/lib/active_support/core_ext.rb:3:in `block in &lt;top (required)&gt;' /var/www/html/vendor/rails/activesupport/lib/active_support/core_ext.rb:1:in `each' /var/www/html/vendor/rails/activesupport/lib/active_support/core_ext.rb:1:in `&lt;top (required)&gt;' /var/www/html/vendor/rails/activesupport/lib/active_support.rb:30:in `&lt;top (required)&gt;' /var/www/html/vendor/rails/activerecord/lib/active_record.rb:31:in `&lt;top (required)&gt;' /var/www/html/vendor/rails/railties/lib/initializer.rb:156:in `block in require_frameworks' /var/www/html/vendor/rails/railties/lib/initializer.rb:156:in `each' /var/www/html/vendor/rails/railties/lib/initializer.rb:156:in `require_frameworks' /var/www/html/vendor/rails/railties/lib/initializer.rb:88:in `process' /var/www/html/vendor/rails/railties/lib/initializer.rb:49:in `run' /var/www/html/config/environment.rb:10:in `&lt;top (required)&gt;' /var/www/html/lib/tasks/localization.rake:4:in `&lt;top (required)&gt;' /var/www/html/vendor/rails/railties/lib/tasks/rails.rb:7:in `load' /var/www/html/vendor/rails/railties/lib/tasks/rails.rb:7:in `block in &lt;top (required)&gt;' /var/www/html/vendor/rails/railties/lib/tasks/rails.rb:7:in `each' /var/www/html/vendor/rails/railties/lib/tasks/rails.rb:7:in `&lt;top (required)&gt;' /var/www/html/Rakefile:12:in `&lt;top (required)&gt;' /home/username/.rvm/gems/ruby-2.3.0/bin/ruby_executable_hooks:15:in `eval' /home/username/.rvm/gems/ruby-2.3.0/bin/ruby_executable_hooks:15:in `&lt;main&gt;' (See full trace by running task with --trace) usernames@tasks:/var/www/html$ At least you are helping me get closer to solve it. Thank you 
Ruby weekly is kinda already a thing http://rubyweekly.com/issues/314 I think people will be confused by this naming.
Agreed, the name is confusing.
This is another case of the same error. It looks like this is a Rails project, have you added the `lib` folder to your autoload path? http://stackoverflow.com/questions/19098663/auto-loading-lib-files-in-rails-4
As a sysadmin I love ansible since I don't need to be great at programming, but it struggles when you need to apply complex logic since so much of that is abstracted away. The great thing about ansible is you can write a custom module if you need to access logic that Python provides. I can even have one of my developers do it for me really quickly and I'll know it's more solid than I could write. 
From the Readme &gt; I could go on and on with further refactoring this code into a more elaborate &gt; project. I could, for example, separate all the different classes in different &gt; files. I stopped because I satisfied myself with the current level of &gt; organization in the code.
It took us a couple of months total, we've got a lot of moving parts though. We're also using Tower with it and that was a learning curve on top of ansible itself. We're running: Kong API gateway Nginx/haproxy/maxscale LBs Percona Xtradb-cluster Rabbitmq cluster Consul / consul template Windows running .net services for the backend All of that is on premise and also replicated to AWS, but the stack provisioning and also code deployments are fully automated through Jenkins/ansible. Love it, can't imagine how long doing the same thing in chef would have taken. 
What are you trying to do exactly?
Well, the task is to get http response times over 5 minutes to a given website. That's literally the instruction I was given. Thus I was going to whip up a script that has a while loop to fetch resources from said website. Then I was going to time it using the builtin benchmark gem, but I didn't know if there's another better way of doing this task. I found [descriptive-statistics](https://github.com/jtescher/descriptive-statistics) and was thinking about using this too, so I could get fancier output for the top 95th percentile of requests or the mean, average, standard deviation, etc. Does that clear it up, or is there a better way?
No, it'll be run from any location that isn't the server. I'll check out rest-client. Thanks!
I use httparty for almost all requests and just a simple Time.now - start_time. I've used descriptive_statistics for metrics after the results were loaded in a db. It's not very sophisticated, but works very well.
ONLY 4-5 times? Wow, I wish I was that quick and I've been coding for decades. Any fool can knock a test together that tests *something*; it takes a great deal of effort to test *exactly* what is required and *everything* that is required. It costs more to fix bugs in QA hence the fewer make it that far the better. It costs a *ridiculous* amount more to fix bug in production so spending '4-5x' writing tests is time well spent. http://www.superwebdeveloper.com/wp-content/uploads/relativecostbugfix.png In closing though learning what to test is an acquired skill and I recommending a combination of TDD and BDD to give maximum coverage. 
Hopefully this will shed some light: ‚ùØ pry [1] pry(main)&gt; eval &lt;&lt;RUBY [1] pry(main)* string = "\n" [1] pry(main)* RUBY "\n" [2] pry(main)&gt; eval &lt;&lt;RUBY [2] pry(main)* string = "\\n" [2] pry(main)* RUBY "\n" [3] pry(main)&gt; eval &lt;&lt;RUBY [3] pry(main)* string = "\\\\n" [3] pry(main)* RUBY "\\n" [4] pry(main)&gt; eval &lt;&lt;RUBY [4] pry(main)* string = "\\\\\n" [4] pry(main)* RUBY "\\\n" Eval takes a string, inside that string the backslashes have already done their thing. Those two backslashes get you one literal backslash. Edit: u/2called_chaos has a better answer a minute ahead of me.
Unfortunately, I don't think so. The last time I had to deal with more advanced zip stuff, I ended up writing a wrapper around the `zip` command line utility using [Open3](https://ruby-doc.org/stdlib-2.1.3/libdoc/open3/rdoc/Open3.html).
Yap. same format.
In your version, you did some simplifications, such as making no validations about the user input, e.g. it will accept numbers as input. But that makes your code much shorter than the original and indeed is quite easy to follow. Nice work there. I particularly prefer to create more abstractions when I program, so I don't a bigger number of lines as long as I'm able to comprehend the abstraction each class represents..
&gt; Jumping from javascript to Ruby seems like a big gap to make. I don't think it is. Both languages can be used for trivial projects or very complex ones.
I'll admit I really haven't touched Javascript in like 8 years, but I wouldn't think of it as being an appropriate tool for large, complex projects. Has my impression always been wrong, or has Javascript changed recently?
I played around a bit in pry and I think for some use cases this would work fine.
I'm newish to programming, but I think your second bit of code shows your intention more explicitly. 
I feel sorry for anyone that believes that TDD, BDD, design patterns or any such thing are "strict". They are parables meant to guide not rigid shackles to free one of thought when developing. Everything in moderation.
The hardest thing to do when writing code is to change an empty file into meaningful code. When doing TDD you are shifting that cost (which will exist no matter if you do TDD or follow up with tests after coding) to the test creation phase. As you get more experienced the amount of time will reduce -- but not dramatically. The time cost you are feeling (should be) thought and consideration on what needs to be tested and how you can start to realize the construction of the code to fulfill those tests.
Is Array(foo) secretly a type check? It works on a hash, a set, an empty string... the boolean 'false'....
If we have no control over the initialization of `foo`, how about: ``` (foo || []).many? ```
why not `foo.present?`
Yeah, tell that to my coworkers. Every little change will break all their tests, regardless if the functions still do the same thing.
I think `if foo &amp;&amp; foo.lenght &gt; 1` is the most readable (except for 2.3 `if foo&amp;.length &gt; 1` maybe) `Array(foo).length &gt; 1` sounds weird because you're testing for existence and lenght by converting to an array. Reading that, I wondered what the hell has more than 1 value but is not an array. So unless that's the meaning you want to convey.. There's also `foo.try(:length) &gt; 1` if you really expect to also get objects that are not `nil` or `Array`..
Great write-up! How have I not heard of this? So much documentation... I'll give this a try in my next side project for sure. 
Thanks!
This is one of those "Clever" and "Best Practices" responses, but it's important first to do it the "wrong" way since OP is learning about it. This is why I love the format of CodeWars. You wouldn't ever see this kind of answer while learning by yourself unless you posted to Reddit or saw it on a site like CW.
If you can justify the cost I'm personally a fan of Jetbrains IDEs. But well it's never really a need. If you want to try alternatives I would start with free ones including Atom which is pretty popular now.
It's not impossible to do development with just a text editor, but I find Ruby Mine saves me time and catches issues that I might have missed otherwise. It's worth it. If you do want to stick with emacs I don't understand why you're using tmux instead of multiple buffers in emacs though.
It's basically the same thing. Thanks for the input, I'll probably go with RubyMine.
Thanks for the input, much appreciated. This project is hundreds of thousands of lines of code so looks like I'm going to need to bring out the big guns.
I saw this as one of the best answers after I submitted my answer above. Took me hours to solve this question.. only to realise it can be done in 1 line! Grrr
I use emacs exclusively, unless I am in a pair programming environment, (which I don't really like) and then I use whatever we are using. I seriously doubt I will ever leave emacs, certainly not if I have choice. For me, it boils down to control vs ease of effort. With Emacs I have way more control, but it is a pain to learn eLisp, maintain all the packages, etc, which kind of come for free in the IDEs. If you build yourself good macros, use rubocop and similar tools, figure out how to run tests and are comfortable with managing emacs (possibly the best, most extensible, but hardest to learn IDE), I don't see any reason to use anything else. 
You're mixing rails into your ruby.
I would love to do that! Do you have any tips? My guess is I'm not using emacs correctly. I basically just navigate to the file I want to open and use `emacs -nw` to open it. Then if I need another file I just quit and navigate via command line to it and open it again with `emacs -nw`. It's basically just like splitting up within emacs except I use `tmux` outside of emacs.
This won't work because the return value of `foo&amp;.length` when `foo` is `nil` will be `nil`
How do you manage your windows and project file structure for large projects? Buffers and split frames? Tmux?
Guys; I agree. I should have explained why this is a good answer. I'm sorry /u/drhectapus! Would you like me to break it down for you? Or am I too late for that? 
It's not a typecheck. The rules for `Array(foo)` are pretty simple: if foo.respond_to?(:to_a) foo.to_a else [foo] end 
I think the real question here is why do you have some value that could either be a `nil` or an array. In general, you want to avoid having two different types of return values. If I had to do this I'd probably do something like: array = foo || [] if array.length &gt; 1 You could also do a slight variation length = foo&amp;.length || 0 if length &gt; 1 EDIT: to expand on the `nil` issue, I'd expect wherever you're getting `foo` from to be returning an empty array instead. 
Sure, no problem. Thanks!
I just use a student license really.
Mechanize is not able to work with JavaScript. You could use capybara and phantomjs instead.
You might be able to scrape a site with some Javascript but probably not without understanding how the site works in detail. For example, you may be able to post to login.jsp since it still is going to the server but you'll have to get any extra hidden fields and such for that to work. Selenium, Capybara, and PhantomJS are all possible solutions but you may need to be able to control the site's source so you can add hooks to make scraping easier. I really like mechanize and have done some pretty neat/horrific things with it but most of the time screen scraping is like trying to pound a nail with a really big rock. It may work but there is almost always a better way to do what you are trying to do.
I did find a lot of hidden fields in the form and with the script, I only filled what was necessary which was the username and the password. However, submitting the form doesn't really seem to work since the page that it returns doesn't even have error messages in it. I was thinking there would be something I can use together with Mechanize that would address the JS forms problem.
Which do you think would be faster when scraping content from a web page?
I used to use Vim very proficiently before watching this video: https://www.youtube.com/watch?v=JWD1Fpdd4Pc Now I use Emacs with Evil mode and I just couldn't be happier and more productive. The result of my transition is stored in my dotfiles if you're interested: https://github.com/josemotanet/dotfiles/blob/master/common/emacs Lots of customizations, shortcuts, plugins for all sorts of things. At the end of the day, my hands don't hurt and my brain doesn't fart from all of the lack of productivity.
This should be waaaaaaaaay higher. I tried both Sublime and RubyMine, and frankly, didn't click with them (for reasons). I still find Vim + TMux + Oh-my-Zsh (+ other Unix tools) to be the best IDE for me.
Here comes a very opinionated answer. Colleagues of mine are each using a different setup and we're discussing a lot about the pros and cons of each setup - plus I see how fast they're able to work due to the limitations / of what their editor enables them to do respectively in the same amount of time. Plus - if you have to wrap your head around the editor in order to work properly or it the editor enables you to work faster and think about your code instead of how to accomplish an editor action. That being said, I've used Spacemacs (emacs with vim keybindings) / Vim with Tmux, RubyMine and Sublime myself for quite some time now (professionally) - and I'm clearly recommending RubyMine. Sure, everyone has it's own favorites - but when it comes down to fast working speed, navigating through big projects and low amount of mistakes, IMO RubyMine is simply unmatchable. It's a really powerful IDE. To just name a couple of examples: - tracking where partials are being used (you don't have to grep for different partial include possibilities, just invoke the command "find usage") - searching for method definition and usage (search for method usage is the same as above, method definition is just as easy, just another command. If the method you search for is actually a database field, it will let you know as it knows the difference.) - refactoring (RubyMine as a little popup menu for several different refactoring options, or you can just keybind them. Really easy) - autocompletion (no need for you to generate ctags, much much better suggestions than the other ones) I hope this helps you a little bit. Even if RubyMine has a much lower learning curve than the others, you should probably give it a couple of days. I haven't seen anyone switching away from RubyMine, just the other way around. I've heard colleagues say: "why didn't I switch earlier..." more than one time. I almost forgot, I'm not working for the company developing RubyMine or have any kind of connection to them. I'm just a developer who enjoys comparing editors as it's my main working tool and I can't to waste my time on inefficient tools. One more thing: I often hear vim is superior because of editing speed. I think every experienced developer knows that everyday coding isn't as much about typing speed as it is about navigating, understanding and refactoring code. So "look how fast I can move my cursor to line 10" always makes me chuckle. The "as fast as the speed of though" thing often clearly doesn't come true. Nevertheless RubyMine supports Vim keybindings.
School assignment maybe?
 I'm still new with emacs but I've used vim for ruby &amp; rails development for several years. My recent switch to spacemacs has been precipitated by the incredibly rich plugin ecosystem backed by a community that acts as a defacto standardization committee. I guess it's hard to know what the missing pieces of your workflow are, but I'm sure they are there. In particular, the features that I use the most are : Window Splitting : take any current window and split in two! **Ctrl-w** (to start a window mode) followed by 'v' to split the window **v**ertically or followed by 's' to **s**plit the window horizontally. File finding is a huge crazy world that largely depends on your configuration. I must say that I would 100% advocate for improving on the emacs skills you've already developed. Spacemacs for me has been amazing.. there's a quote on the documentation page - "¬´I feel that spacemacs is an aircraft carrier and I am playing table tennis on the deck as a freerider.¬ª" I've gone deep in a few places in my exploration and it's hard to understate how incredibly powerful emacs is. It's open source, free (in freedom and beer) and even if you become an expert it is highly unlikely you will ever stop learning. Not to say that if you won't be productive if you only learn a tiny bit - I'm still very much a beginner, but with the very limited features that I've mastered I'm at least as productive as I've seen anyone with a non-big-two editor. There are supportive communitites at /r/emacs (and /r/spacemacs ) for questions and a zillion articles and howtos to help you through the initial transition.
Why do you need so many windows, though? If you need to be able to quickly access the many places you navigated between, https://github.com/boyw165/history seems to do a better job.
I would find a better teacher / school. Paying or even going in debt for this is a crime.
You might give [Spacemacs](http://spacemacs.org) a try. I originally came to it from Vim, so I use it in Vim mode (well, hybrid mode actually), but it's also completely possible to use it in Emacs mode with all the usual Emacs motion commands. A few things that Spacemacs brings to the table that I've found invaluable: * NeoTree: quick tree-based file navigation * Helm: Autocomplete all the things! * Projectile: Works with NeoTree and Helm to turn any git project into an Emacs project * Search: Uses your favorite grep-like, including `ag` and `ack` * All the language packs you could want, and not just the syntax definition files but whatever makes sense (e.g. the Clojure package includes CIDER) It might be worth trying out before you give up on Emacs completely. That said, I *love* JetBrains tools and don't know what I'd do about Java without IntelliJ. I've heard nothing but good things about RubyMine too.
just require active support core ext
I would much rather do the following. `if foo &amp;&amp; foo.any?` It removes the ambiguity that often comes with unless statements and is easier to read. With Ruby 2.3 you can use the same thing in an abbreviated form: `if foo&amp;.any?`
Can you share code? I've use mechanize to do quite a lot of actions on Pinterest, may be able to help. I suspect your just missing an auth token when submitting the form.
Good write up. If you set high expectations for what you want out of a library, seldom will the existing offerings pass muster, I find. When my research leads me to a library that checks all the boxes, so to speak, I am always so pleasantly surprised.
Edit: OK, I looked around and saw some of your other questions and think I missed what you meant. Go through the emacs tutorial. It will help you with visiting files, switching buffers, splitting windows, etc. If you have a big screen, it can be fantastic to have multiple (6+) files open all at the same time for a big refactor, etc. That is the way to go. Once you are comfortable with moving around, then start building macros for yourself for things that are common and a pain to type, like creating a function, adding string interpolation, etc. That is where things really speed up. But remember: The power of emacs is in its extensibility/control/customizability. If you don't (can't/wont) spend the time to learn it and practice it and extend it, it probably isn't worth it. Original response: File structure: I don't change from the Rails standard much, so I do everything by visiting files, etc. I am on a Mac and Term2 is pretty good. Regarding buffers and split frames for editing, yes! Shells are a little different. Within emacs, I have gone back and forth on this. Originally, I would spawn multiple shells (renaming them), each for different tasks, like running tests, rails s, rails c, etc. Then I would just jump back and forth between those buffers, cut and paste or whatever, as needed. Since I was at that pair programming place, I went back to vim. Then, when I got out of that place, I went back to emacs (5 months ago?), but I had gotten so used to doing things in term2, that I stopped spawning separate shells in emacs. I never use tmux unless I need to log into some other box. What I would really like to do is improve my eLisp to where I can automatically replace a method name in every file, refactor a highlighted area to a separate method, etc. Jim Weihrich had something like that at some point, though I am not sure it was ever published.
Yeah, no thanks.
oh shoot! I missed that!
It's fine if your project depends on active support. None of my projects do, and I'm much happier as a result.
That's a pretty good point. I am a pretty satisfied user of jruby, but I don't use rails for anything other than a frontend HTTP server. I find my hesitancy about guilds diminishing somewhat. Perhaps they'll be awesome.
Using the QR code is fairly (somewhat) standard with 2FA. However, you could use Twilio or something similar to use SMS to send the codes.
Most [TOTP](https://tools.ietf.org/html/rfc6238) (colloquially known as 'Google Authenticator') clients allow manual entry of accounts. The underlying ROTP gem can expose all the info you need. A workaround would be to scan the QR code on your PC and pull the data from [the URI](https://github.com/google/google-authenticator/wiki/Key-Uri-Format) it contains.
What I dislike about this solution is that it assumes I have only a single device I want to use for TFA. Why no `has_many :authenticators` so I can add and remove different devices? The workaround is to disable TFA and scan the QR code with all my devices before re-enabling it on the site. Too bad a lot of websites make this assumption. Regarding generation of the QR code: error correction level H [is overkill](http://blog.qrstuff.com/2011/12/14/qr-code-error-correction) for screens, the code can be smaller with level L. It's not like a part of the code can torn off the screen. And why not let RQRCode [render SVG](https://github.com/whomwah/rqrcode#svg) instead of an HTML table? We're stuck with IE8 anymore :P
I mean, yeah, but unless you are going to devote a ton of effort to the task (like, probably involving some of your own extensions) you aren't going to get an emacs setup that does everything Ruby-specific that Rubymine does. It'll get you plenty of the way there, to be sure.
you can try Dir.glob(...) do |c| next if File.basename(c) == '.' || File.basename(c) == '..' end or checkout [Pathname](https://ruby-doc.org/stdlib-2.3.1/libdoc/pathname/rdoc/Pathname.html) in ruby stdlib
Do you think it would be easy to scrape data of a page with just PhantomJS? I'd like to mention also that the scraping would include an image of a product. Or would it be easier to use Mechanize since you mentioned that it's possible to pass cookies over Mechanize which leaves me to decide whether to go back to Mechanize after logging in with PhantomJS or not. 
Thanks! Yes, that was my experience too, nowadays I'm really happy if I find a library that checks all the boxes.
&gt; This is a silly reason to prefer an editor. It's just a waste of time to fumble around like this until you learn the structure of some huge new codebase. One more way how to look at it is like this: Kent Beck (if you don't know who he is google him) use to ask random developers of company "describe me the whole application with 4 objects" if they use independently the same/similar objects then he knows the team has good understanding what they are building. If they describe different object then you have problem and team don't understand the product. So if you are a contractor hitman that just want to jump into the project fix some bugs for 3 months collect money and go to other project then yeah maybe you don't need Vim. If you are developer who is seriously contributing to the project for next year or two, you need to understand the system. There is no other way around you need to learn the system !. Yes you can print UMLs and CRS cards read Documentation and so on, but code changes! The only true code is the Documentation to the product source code. You need to read it. And yes you can that with any editor, but like I said you will never feel so bound to the code like when using Vim.
Although still relevant, this article is two years old.
Filter them out using `File.basename` to get the name of the file without any directory info, then use the regexp `/^\.{1,2}$/` to match a filename that only consists of `.` or `..` So like this: %w(/etc /bin /usr/bin /usr/lbin /usr/usb /sbin /usr/sbin).each do |dir| Dir.glob("#{dir}/**/*", File::FNM_DOTMATCH).reject{ |x| File.basename(x) =~ /^\.{1,2}$/}.each do |c|
Depends on you and the project requirements. If you can write JavaScript as well as you can Ruby and you don't have anything tying you to Mechanize them you could just use PhantomJS directly. If you aren't that confident with JavaScript, or you already have pages of Mechanize code you don't want to rewrite, or you have to use Mechanize for some other reason, then Mechanize+Poltergeist might serve you better.
You'll eventually learn the project structure anyways. The difference is just how much time you waste in the meantime. And with a large enough team project nobody knows where everything is. As far as vim, I know a bit more than that but the emacs philosophy appeals to me a lot more and I prefer emacs as text editors go. I simply don't think you need to become a vim wizard because you need to edit configuration files with it once in a blue moon.
https://ruby-doc.org/stdlib-2.1.3/libdoc/find/rdoc/Find.html
Yeah, I'm not a fan of this either. 404s _might_ be a developer-caused error in production, but usually not. The middleware that renders responses for all exceptions also logs them. They should probably be handled specifically, instead of going to the generic, catch-all exception handler.
&gt; And with a large enough team project nobody knows where everything is. then the stuff needs to be extracted to gems, Rails engines, microservices, or they are not defining their object with clear names (or they don't do objects composition at all) I'm not saying you need to know every line of the code, you need to understand how the application is structured and documentation for that is code. if code is not expressing the intention you are doing it wrong. It's just I find developers using Vim to understand the application far more than developers that use other editors as they are forced to. And even if you have several teams with several operation chanels, developers using Vim seems to be less affected by Conways Law as they understand intention of their colleagues from other teams better. But I have no data to prove this this is just my observation. So yes you can have supper huge monolith that no-one understands. No mater what editor you choose you are screwed as that needs to be refactored (or extracted to lib and so on) and maybe you are better with Ruby Mine as it can map all 3000 Classes that you have in the system. So Vim is worthy editor for Large even Huge applications, but if the code is Badly written then it may not be best choice as if you end up scrolling via 3000 line model you you will not have a good time. 
`+ 1
According to this benchmark I just ran: https://gist.github.com/anonymous/e374a51e83d54362b4621a17cb404a7d Its O(1)
what workaround did you use?
Well, I believe Riot Games (League of Legends) runs at least part of their infrastructure on Chef (ruby), so I would be really surprised if they didn't run their game servers, as well.
thanks a ton! I am not planning on doing anything crazy, so I anticipate switch to jruby will be fine. however I will look into crystal lang now because that sounds awesome :) 
well it's interesting but i'd never use it in production ;)
Rubinius https://github.com/rubinius/rubinius also has real multi threading, though I haven't used it so can't comment on how well it works. It'd let you avoid the JVM or switching languages though. Edit: From a practical standpoint, if you do a test you'll see that with MRI ruby you'll only use one CPU/CPU core no matter how many threads you use and thus will only have 1 "thread of execution" executing concurrently. With JRuby/Rubinius the threads should be spread out by the scheduler like you'd expect. However, on the IO things you're dealing with (waiting on sockets, network activity, etc) it'll look like nodejs or similar in that while ruby is waiting on the IO it can go off and do computation with something else. So you're mostly limited on how much computing power you can grab.
Chef is a configuration management tool, which is _very_ different from something you'd use to write a game server handling millions of concurrent players. For their chat system they use Erlang (http://highscalability.com/blog/2014/10/13/how-league-of-legends-scaled-chat-to-70-million-players-it-t.html). For the actual game server they probably use something like C++.
That's understandable! I would argue that Ioughta does its thing at startup, so there's minimal risk to in-flight production processes, but I also understand the desire to keep a minimal bundle and exclude unnecessary gems. Thanks for the feedback!
Yes, Chef is configuration management, but they contribute a tremendous amount to the Chef community to (Like Berkshelf) to not use Ruby in any of their services. Writing the whole thing in C++ is great for a big monolithic app, but for a game and everything that runs it they probably use much more than C++ and Erlang; They also use PHP (Zabbix) and a lot of Java (repose/apigrove). It's unreasonable to assume that they only use Erlang for the chat services and then use C++ for everything game related, then and suddenly become language agnostic for their infrastructure and completely shun C++ and Erlang. I'm sure they use a myriad of different languages for all parts of it. Textures and 3D may be built in C++ for obvious reasons, but a game is more than characters, trees, and water. 
I just mean, the thing it does is not something i have a need for, also it feels "too clever" and the syntax, though nice, is definitely un-rubyish and it's not immediately clear what it's doing or how it works. I typically don't like 'magic' APIs, no matter how concise they are.
the vast majority of ruby threads would be waiting on io. I think the biggest issue would be having game logic run side by side (each "world" would have enemies, players, etc). obviously this would be horizontally scaleable but this is likely to be a very (very) small hobby game, so I don't want to plan on needing multiple servers :) is there a reason why i'd stay off of jvm? gem compatibility issues? I am probably going to use a very limited number of gems, so it might not be a problem. thanks again!
thanks! it is not going to be web based, but pheonix is probably *another* hobby project i'll explore :) the gist has shown me I was completely unaware of gserver. I implemented my own (probably half baked) code that does similar. so "io" would be the socket you can read from? thanks a ton!
Yeah, I basically agree. It was kind of a "well, I wrote it, and it turned out okay, so I might as well publish it" type situation. Anyway, again, I appreciate the feedback. 
Unfortunately, your results are a bit misleading since this benchmark is really MRI's best case. In practice, you're likely to see slower or at least, less consistently fast, results. The reason is that `:send` must consult the global method cache and if the entry isn't there, it needs to perform a far slower full method lookup and then replace something else in the cache. The default global method cache size of 2048 is easily overwhelmed by a trivial Rails application. Unless you're configuring the `RUBY_GLOBAL_METHOD_CACHE_SIZE` env var, you're going to see cache contention. And while the cache replacement strategy is deterministic, it's essentially random to you, so you could end up blowing away a hot entry and potentially wind up in a thrashing scenario (unlikely, but still possible). In your microbenchmark, you haven't loaded very much code, so you probably haven't exhausted the global method cache. Moreover, you go into a tight loop in a single-threaded application, without any opportunity for other code to update that cache. In that case, you'll always be able to find the method in the global method cache and it will indeed be fast. But in the real world, there is likely other things running between your `:send` calls that will update global method cache.
I'm sure you're right that there are better options. I am not super comfortable with js to use node (I've used a lot of js, but I don't feel like I've ever really written *good* or clean js). go is something I thought about, but haven't pursued yet. thanks!
Personally, I'd rather avoid manual multi-threading and used either single-threaded approach with EventMachine (clients put their events into a list, a timer registered with reactor triggers, calculates new state of the world and sends updates to clients) or higher-level abstractions like actors.