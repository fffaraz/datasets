this is incorrect, according to the text above, you are supposed to ignore whitespace.
Pedantic nitpick: Your first sentence is not true unless you interpret the term "language" absurdly strictly (i.e. regarding semantics only and ignoring core library features, which may be valid in an information-theoretic context but not in this one). Brainfuck is Turing-complete but it can not emulate any non-esoteric general-purpose language as it has no ability to perform file I/O, spawn a new process, or do anything else that involves making system calls.
This is entirely wrong. The GVL applies to Ruby code execution, most IO occurs off the GVL. The example of 10ms of execution and 50ms performing an HTTP request will only hold the GVL for 10ms and the 50ms HTTP request can occur on another core than the one processing Ruby code, it won't use even use 50ms of CPU execution time, it'll just send the request, do other things, then handler the response when it arrives.
you have selenium at your arsenal for javascript-capable browser automation as well
strictly speaking it's active support, which i use in plain ruby projects all the time. 
it's aesthetics, btw
Sure. Active support. It's a can of worms that sometimes is worth opening.
It's common practice among many languages to use `_` as a "placeholder" variable. For example, if you run a static code analysis tool it may warn you about "declared but unused variable names" in your code; *unless* you never really intended to use that variable, and can just name it `_` to silence the warning. 
This meaning is supported by the language in that `_` is the only formal parameter that can be used more than once in an argument list. It works the same way in argument lists of methods and blocks.
Re-implementing a good chunk of (say) POSIX just for the sake of a Ruby interpreter had honestly not occurred to me. I stand corrected.
You probably misread me since you are saying exactly the same thing than me...
I would just Enumerable#group_by (https://ruby-doc.org/core-2.3.1/Enumerable.html#method-i-group_by) :P
&gt; Because of the GVL, the number of core doesn't matter. It does matter how many cores you have as it determines how many off-GVL processes can execute in parallel. &gt; It's all about the IO vs CPU ration of your units of work. It's more about the parallelism of off GVL work. I/O is mostly idle time for the thread, however in many cases there is setup / receive work that may be done off GVL, such as parsing an I/O response. In a lot of situation that time can be more expensive than the network request, e.g. HTTP-JSON requests between internal services. 
&gt; I do get the insructions. We're supposed to count spaces in a string &gt;&gt;&gt; Skip all whitespaces in the string &gt;&gt;&gt; Keep track of the number (location) of non-whitespace characters Honestly, I don't think you do understand the instructions.
[http://www.dictionary.com/browse/esthetics](http://www.dictionary.com/browse/esthetics)
&gt; However, just because you can doesn't mean you should. Was I somehow unclear that it was a bad idea? I'd apologize for my statement offending you, but I find myself failing to be sorry.
So you keep running each JS command inside the same JS context? What if some command messes around with the JS context such as monkey patching core classes? How do you isolate the JS calls from each other? And wasn't an advantage of multiple Node processes that they could run in parallel? Do you run one Node process per thread? If not doesn't this serialise every JS command as it runs through the single Node process?
Time is the most difficult thing when it comes to coding...sigh
This problem is academic at best. A non academic solution to this problem would be: no_spaces = string.tr(" ", "") half_length = no_spaces.length / 2.0 even = half_length.floor odd = half_length.ceil
Have would you compare this to another similar project, [Alaska](https://github.com/mavenlink/alaska)?
This really should be easy - but I have no idea what those functions are supposed to take as inputs to produce reasonable outputs, and what they are. Can you give anyone an example of how that python library is used?
Looks awesome. I will try to take it for a test run in one of my projects.
It's æsthetics btw. 
Oh my god you're right.
Will this be public domain like your other bounty?
But it's not "someone else's" project. I want to be partners with these programmers, projects are profit-based. I don't understand why it happens that way. I want to make a good team, but was faced with the reluctance of developers to create a team and help each other.
It's a shame it's licensed under the GNU Affero License.
But why people just don't want to make a good team? The team is the power that should be the priority. 
Maybe you are right. Thank you for your response. 
What license do you wish for? And why (what difference does it make)?
Rats! I googled and couldn't find a similar project before starting this. I wish I had. This would have been a good starting point. The projects are very similar, they both have the same goal, but as it stands I believe my execjs-fastnode is a more complete (if younger) solution. The major issue I see is that Alaksa doesn't separate different contexts. The following should not work. context = ExecJS.compile("var a = 2.0;") #=&gt; #&lt;Alaska::Context: ExecJS.eval("a") #=&gt; 2 It also has taken a more relaxed approach to matching the other ExecJS runtimes behaviours (stack traces not exactly the same, the context issue, a few nitpicky things like that) whereas execjs-fastnode passes the full execjs test suite (currently with a very minor caveat on old node versions). Alaska uses a Unix socket for communication, which looks like it worked out better than my approach (simpler code, easier synchronization). I'll probably adopt this.
GNU Affero means that you need to license your server under the GNU Affero if you use it on your server. That's unacceptable for 99% of use cases. 
I take it you've never dealt with character encoding bugs. Or concurrency. 
Thanks for this - I love pure Ruby code that does things that you'd normally use a C extension or the FFI for. Have you looked at how fast it is?
Congrats and thanks to Thomas Leitner (the author of the library - more than a year of work, more than 25000+ passing test assertions) and best, yes, great care (e.g. micro benchmarking and trying alternatives) to make it fast (if that's possible with ruby ;-). PS: Background: Thomas Leitner is the author of kramdown - the fastest (all ruby) markdown converter. PPS: From the EuRuKo 2016 slide: Read–Optimize–Write Performance e.pdf Time Memory File size hexapdf 1.006ms 46.960KiB 21.770.465 origami 3.301ms 153.628KiB 21.796.847 pdftk 681ms 123.152KiB 21.874.883 qpdf-comp 1.517ms 65.172KiB 21.787.558 smpdf 37.539ms 647.440KiB 21.188.516
I'm not certain from your post if you're trying to get independent contract work or corporate employment work. If it's the former, getting low-balled by foreign worker rates is pretty typical and you just have to fight to make contacts and pitch your skills until you find someone who recognizes the quality of worthwhile labor over cheapest possible labor. If you're trying to get a full-time corporate or startup job then you just have to find the matching opportunities and self yourself to the hiring managers. Especially for entry level jobs people are looking for motivated youngsters with solid personalities that they can train up. Really, either way, you just gotta work on your personal salesmanship skills
Blatant spam. 
FYI: You can find Thomas Leitner's EuRuKo 2016 talk slides (in HTML) about HexaPDF online titled [Working With PDFs in Ruby](http://talks.gettalong.org/euruko2016). Tip: Use the spacebar to flip through (the slides / pages). PS: Or watch the video recording (starting at around 13min30) on YouTube - [EuRuKo 2016 - Day 2 Lightning Talks](https://youtu.be/WnlgKWCt8wQ)
&gt; How can I get hired over a senior developer who was laid off by his job? People with more experience cost more and aren't needed for many tasks which are likely more busywork (read: general feature development). &gt; A Senior level developer can complete something in 1 hour, that it takes juniors over 10-20 hours This is likely true in many cases, but there are a few other factors here. For one, a senior developer should charge *a lot* more. Even if they didn't, demand is so high right now that any senior developer charging a low rate will just get snatched up and there will still be jobs. I also don't think many senior devs are looking for entry level Rails experience. MVC out the wazoo gets boring pretty fast in my opinion. Really senior has to do more with specific skill sets and the ability to work without supervision, not being able to do things quick. The returns are just not high enough to only hire a bunch of experienced people (although I do know some companies do this). Also if you're looking on somewhere like Indeed or something and looking at job postings then, yes, they will be flooded with posts for senior devs. As I said above, the market is super hot right now so seeing tons of openings is not a surprise. 1 year of experience makes you experienced and already much more valuable than you were a year ago, so you have that going for you. In my personal opinion people with a small amount of experience are the best ROI because they have enough knowledge to get started and only need a little direction Is the issue that you aren't finding job postings? Is it that you aren't getting interviews? Is it that you are getting interviews but aren't getting offers? Also, what are your standards? Have you written off certain job postings for any reason? My guess is that it's more likely that there are just a lot of people in your shoes meaning lots of similar competition. That doesn't mean jobs aren't there (unless you live in the middle of nowhere, then you might want to move to a tech hub). I'd suggest networking, going to startup events, and going to meetups. There are lots of small companies who are looking for people who probably can't afford to and don't find it practical to advertise on major job boards.
Looks cool. I've been using PRAWN for years.
Step 1: Understand problem Step 2: Design solution Step 3: Implement solution Nothing good ever comes from skipping a step. ;-)
You need to keep it as a dynamically-linked library (IE separate binary), from my understanding. Ruby has no concept of this. I'm not 100% sure if that's how it works, though. 
I work on a new faster Ruby VM so I'll definitely be trying this out. We love pure Ruby code because we can optimise it all together.
High level, nothing Ruby-specific, no code samples and a CTA that asks people to sign up for your crypto company's mailing list which offers a service to solve the problem which the blog post tries to convince the reader is hard? Spam.
&gt; I feel it's "specific" enough as the web development field has a lot of jobs. But what is "just web development"? It is something like "development of generic web projects"?.. Like content sites with comments and mail lists, and then some small local shop site, and then some content site again, and that's it? Or probably you develop some specialized social network, and it would be better to know something about sociology and graph theory and group dynamics -- not necessary, but the guy who knows some of that has more chances to receive the job. And on the other site you could make a great use of your last NLP book, because they want support bot which is really helpful, not standard "how can I help you" bullshit. And next one have overgrown simple log analysis script and could use some rubyist aware of modern bigdata tools and approaches. And so on. So I'd say not "further specialize in niche subjects", but rather "grow yourself outside 'just web developer'" mindset.
I've also looked for libraries which can help out with that, but to no avail. So, I've ported [Haxl](https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/) to Ruby which also takes care of a bunch of other things like batching, caching and implicit concurrency. But it's closed source. I have to convince some people first... :/ If you want to implement it yourself, have a look at free monads which are a general solution for these kind of things. Quite some time ago I tried to implement them in Ruby, here's a Redis client written using my (not-production-ready) library: https://github.com/timhabermaas/ruby_effects/blob/master/examples/redis.rb
The issue is that When I apply for a job, people are picking other candidates over me. I am simply not as appealing as a candidate compared to the other people who applied for that position. There are people who probably have better portfolio's/resumes/experience than me. When I job hunted a couple years ago I was able to get interviews left and right. Now I have a 0% success rate at getting an interview. It feels like I'm blacklisted or I'm just that undesired and need to relocate. BTW I haven't found a single position yet that allowed below 2 years of experience, so maybe I'm being filtered out instead?
I bet you could do this with const_missing, no? might want/need to require a prefix for all molecule-class names or something to make it sane/sanitary, and not even sure then it would be a good idea, but... just in case you didn't know about const_missing, method_missing's less well known cousin :-) I used it with Bryce in this gist https://gist.github.com/bkerley/754df43c98e116e82003 to emulate Elixir's pipe operator in ruby, which Akita later liked enough to copy into his gemified version of the same idea https://github.com/akitaonrails/chainable_methods
Am I the only one who uses a visual debugger for Ruby? I never liked the idea of writing "pry" or "byebug" in my code to diagnose a problem. When I debug, I jump around the codebase enabling/suspending breakpoints or changing my breakpoint conditionals. It never seems practical to do it by modifying the code itself.
That's cool. I went from Rubymine to Sublime to Atom precisely because I wanted to get away from the busy gui interface of rubymine. Reminds me too much of Eclipse/Java and that's just a PTSD episode waiting to happen.
Did anyone else read this as 'Bugeye'?
*using the Clarifai API to actually generate tags for your images Looks like up to 5,000 images tagged per month on their free plan
You don't &gt; enabling/suspending breakpoints or changing my breakpoint conditionals... by modifying the code itself. You use debugger commands to do that, e.g. b &lt;line number&gt; sets a breakpoint. 
In jruby you need the `debugger` gem to get actual debugging -- actually stepping through your code with next, step into, step out of. Pry wont' do that on any platform. (unless it has the pry-byebug plugin on MRI, that is). 
Ah, but how do you get to a prompt where you can issue that command in the first place in, say, a Rails app? I am interested in exploring byebug's "remote debugging" capabilities, which may be the answer to that, but I haven't yet. I think it would be more convenient to be able to set breakpoints graphically in my source code editor (which is usually what i'm looking at when I decide I need to debug, of course), but I dont' think this enough to switch to RubyMine. :) If byebug's remote debugging features work well, I wonder if there's a way to make a sublimetext plugin that lets you graphically set breakpoints, hmm. 
I think a find with the parent element included (spaces denote the level) should work. I try not to ever use ids for selectors uless there is no other way. find('.table-buttons i.fa.fa-times-circle')
Sure, you can't beat a good debugging UI, ask anyone who's used Visual Studio, but I was specifically responding to that comment. Ruby mine most likely sends the same commands to the debugger that you can send yourself via the CLI
Tests. Unit tests. Integration tests. I love them.
I think there is a big point they are missing as well with this. It is not last line but last line evaluated. We as a community should avoid this kind of returning. def bad_example(x) if x.zero? do_a_thing else do_a_different_thing end end This is a pretty simple example so it's easy enough to understand, but once you start adding branches to this a reader can easily become confused as to what value is being returned when. The method will break if someone adds anything after the if block's end. 
I came here to say the exact same thing. Shouldn't that return value be caught by unit tests? This possibly the most effective argument for having tests in the first place.
 def better_example(x) return do_strange_thing if x.odd? x.zero? ? do_a_thing : do_a_different_thing end &gt; The method will break if someone adds anything after the if block's end. Unless those methods are mutating data instead of returning useful values, sure. Readability and programming styles are two different problems though. It's not that hard to use early returns with postfix if/unless when you do need a value. Edit: My inner troll compels me to add a run-code-after example for people that want to maintain unreadability. def ragequit_inspiring_example(x) ([(x.zero? ? do_a_thing : do_a_different_thing), do_another_thing])[0] end
I agree, I was just showing off an anti pattern, yours is the correct way.
One of the reasons I usually prefer to be explicit about returns (and of course unit test). If a developer removes or changes a line like ```return some_thing(some_other_thing)``` without considering the usage of the return there is something very wrong with that developer whereas ```some_thing(some_other_thing)``` being the last line should indicate to a developer that it is a return value but requires active thought to understand that.
&gt; Outside of Broccoli you won’t be able to reference WORST_PART. You also can’t discover it via the constants list. class Test REALLY = "not really" private_constant :REALLY end Test.const_get(:REALLY) # =&gt; "not really" Okay.
Fucking a man. How can you change the return value of a method and pass the build? The author talks about experienced engineers introducing bugs. Smh. 
Also came here to say this ❤️
Visual debuggers certainly are nice, although I don't know of any outside of RubyMine. I think it's technically possible to integrate byebug breakpoints with vim/sublime, but unfortunately that tooling just doesn't exist at the moment.
A vital part of any project when you language lacks even the most rudimentary type checking. Ruby is great and all, but things like this just don't happen in C++ or Go or most other languages. Even dynamic languages that require you to explicitly return something don't have this problem. This is a Ruby feature that makes methods exactly one keyword shorter but also often makes you unintentionally return things. That seems a bit odd to me.
Martin Fowler would have asked where his tests are at. 
Great! I hope you'll be able to open source haxl. To separate code with logic and code with side effects, seems to be pattern that is getting more popular.
&gt; Ok, so you have still modified your production code to cater to scenarios only used in testing. I'm not sure how exactly redux-saga works, but this description could then be used to optimize your code during runtime (e.g. cache requests which have already been done or execute requests concurrently without polluting your production code with thread or cache details).
5k for free is pretty good. The pricing looks reasonable to me.
Feel free to use this: http://answer.market/answer/1PdDMhsUKzdk4KGThJ1yyh3kkAEaKnmLPu
Wouldn't you just use a key function to limit the number of partitions?
To add "the opposite" opinion here, I tend to perceive as a "code smell" almost any attempt to "fight" the language rules and features. (Like [banning](http://zverok.github.io/blog/2016-02-23-control-flow.html) `and`/`or` for some misty reason.) I mean, when it is related to Ruby, which I am in love with :) For PHP this principle is... well, not that relevant. And in this particular case, "implicit return" rule "teaches" me to _always_ think of return value. OK, not 100% of my methods return something meaningful, but I always at leas try to think in this terms. (And `self` as a last statement of "command" methods seems pretty useful convention for chainging subsequent operations on same object).
You know Rails let's you create whatever sub-folders you want under `./app`? Just make a `./app/notifiers`, `./app/finders`, whatever makes sense for your app. No configuration or code needed, it'll just work, Rails will auto-load anything in an `./app` sub-folder. 
I can confirm this. I have app/#{whatever} in one of my side projects.
yep! I am aware of this, but I don't really know what I would call the other folder. like "business_logicy_classes that don't always talk to the database"? idk
&gt; but I don't really know what I would call the other folder. Well, maybe *that* is where you should start. As a rule of thumb, if you can't clearly define a specific task or goal for a class you probably have multiple classes wedged together. That, or it goes in `app/services`. :P
&gt; If it's not obvious from the method name that this is a query method, I'm likely to use an explicit return. Isn't that kind of ignoring a bigger problem? *Why* is it not obvious from the method name that this is a query method? I think your solution is a good one for that situation - and I definitely agree with you about not blindly following style guides - but the situation itself should be extremely rare. In the absence of type information, it's only *more* important that method and class names accurately reflect intent.
This reminds me a lot of a few articles a read back in the day of using rails engines in your rails apps for splitting a part functionality like this. Rails Engines aren't so-easy-your-grandmother-can-do-it, so it seems it never caught on. I do like this pattern though. In Pheonix, are the controllers, templates and views organized the same way they are in rails? or are they more free form / however you want?
Usually those are called services.
Come for the websockets, stay for the speed and FP :)
in order to escape callback nightmares, i have been been slowly migrating my models to shitty a `event_sourcing` model where `/models/users/create.rb` and `/models/users/update.rb` and `/models/users/find_or_create.rb` where I have specific classes doing what normal hooks do.
I think i'm going to use trailblazer's reform for those kinds of validations. Seems to be a good pattern - request based as well.
Personally, I would save on module name length and organize it something like `app/operations/user/notify_registration.rb`. Then an invocation of it reads pretty cleanly too (`User::NotifyRegistration.new(...)`). As an added bonus, YARD will document this nesting so the `User` class documentation will list `NotifyRegistration` as a class defined under that namespace.
basically keep your head up and *keep applying to jobs*. "it's a numbers game" is way too true in this industry, from personal experience as a 'bootcamp' / self-taught developer. With nearly 3 years experience it still took me 200+ job applications to get an offer. And I had trouble staying motivated to apply, so it took me 6 months to send those 200 applications. In those six months of unemployment, I added numerous projects to my resume. I tried to use technologies I was fluent with so that I wouldn't be tempted to abandon the project (which happens so often with hobby code). But at the same time I challenged myself to learn how to integrate other concepts, such as NodeJS, Selenium, multithreading in Ruby, websockets, and HTML5 audio. It's true that I'd have been better off doing contract work, though, and I don't think the pay rate is that important if you just need pieces for the resume. You've heard "A Senior level developer can complete something in 1 hour, that it takes juniors over 10-20 hours" but don't take that to heart. The distinction between 'junior' and 'senior' isn't always that clear cut. 
I'd never run into Clarifai before so this is fantastic. Thanks for posting this! :)
Thanks for the honesty. I felt pretty discouraged because it makes me feel like I'm bad.
They are kind of an underdog when everyone talks about Google Cloud Vision and MS Cognitive Services. There's a pretty comprehensive comparison in [previous blog post](https://blog.rebased.pl/2016/10/04/computer-vision-1.html) -- watch out for the "To avoid cluttering the post, we present the raw results on a separate result page." piece with link.
tl;dr: no
Ruby isn't dying - it's dead. Killed by political correctness, gender politics and anti-white bias. 
I really enjoyed. Great post. Now, I need more :D 
I'm so of the argument even existing. It's like those people live in echo chambers of the bleeding edge. 
Are you on the right sub? 
fuck, I think you misunderstood that, I mean it would be dumb to assume that everyone who browses T_D acts like that, hell, I browse it myself
Typo here: `def multiply_eqaul(_,_)` Also is `_` special in Elixir? Otherwise I would have thought `(_,_)` would be functionally equivalent to `(x,x)`.
Instead of having one long running job, have thousands of short running jobs. Have one job run on your normal schedule that enqueues a job for each user you want to process. All you jobs should finish in less than 30s so the sigkill won't interrupt anything. If you can't handle that many jobs at once record a last processed time for each user and every hour enqueue jobs for the quarter that was processed least recently.
What do you mean by "too many jobs" here? What exactly stops you from splitting this work into 100,000 jobs?
Why do you think that's too many jobs? I've easily had millions of jobs queued up. With proper architecture you can easily sure your jobs run always, and places like Stripe use idempotency keys to allow you to retry a job without charging someone twice (if it ever comes to that scenario). I think you may need to challenge some of the assumptions you're making about your long running job.
Because I'm using delayed job, which seems to be my only option that supports extreme reliability... The only thing that is more reliable (and takes advantage of PG) is Kue, but that doesn't work with Rails 5. From what I gather in GitHub issues, DJ seems to have issues at 200,000+ jobs
Quote from another reply in this thread: &gt; Because I'm using delayed job, which seems to be my only option that supports extreme reliability... The only thing that is more reliable (and takes advantage of PG) is Kue, but that doesn't work with Rails 5. From what I gather in GitHub issues, DJ seems to have issues at 200,000+ jobs
That would be good although deploying those reliably is above my skill level. I've done that once before when I helped someone deploy Druid, and it was completely agonizing. For this project, I've been tasked with a very hard (and very rewarding) project, and it's outside my comfort zone (which is fine), but I can't go too far outside it or I will be lost. I was planning to start with heroku, then immediately after hire someone who's very skilled to get it done right, and possibly rebuild it from the ground up in Go once it's up and running.
Can you explain how this works in terms of asynchronous code? I thought ruby is syncronous but that seems odd if error/exceptions can happen while something else is looping? I thought exception completely aborts the perform method no matter where it is, and then calls error after it... (basically by not allowing perform to 'see' it) 
Sidekiq has no such problems with durability: https://github.com/mperham/sidekiq/wiki/Reliability
If you do end up going down the RabbitMQ route you might want to take a look at https://github.com/fac/tom_queue. It allows Delayed::Job to hook into a RabbitMQ queue so it's not hitting the database to poll. It certainly helps with the performance when there are lots of jobs, though I don't have any hard numbers to hand.
You are basically talking about an ideal use case for AWS lambda. 
Aren't those PRO features?
I solved it with this! http://stackoverflow.com/a/12606786/794481
Underscore is special: &gt; If we didn’t need to capture a value during the match, we could use the special variable _ (an underscore). This acts like a variable but immediately discards any value given to it—in a pattern match, it is like a wildcard saying, “I’ll accept any value here.” https://www.safaribooksonline.com/library/view/programming-elixir/9781680500530/f_0020.html
&gt; Are there ways that the Ruby community can revitalize or bring back some of the energy that we had 5-10 years ago? I think this is a great question. Personally, I think we can do a lot about it, by reading and writing about many great libraries that we have, and contributing to things that really matter. For example, there is usually a lot of talking about concurrency in Ruby, and I'm so happy that our Ruby community has created great projects like [Concurrent Ruby](https://github.com/ruby-concurrency/concurrent-ruby) and [Celluloid](https://github.com/celluloid), both of which are whole ecosystems on their own. And if we need Node.js' reactor pattern, we have the [EventMachine](https://github.com/eventmachine/eventmachine) ecosystem, with wrapper web frameworks like [Goliath](https://github.com/postrank-labs/goliath). Sure, maybe it's better to use the "right programming language for the job", but sometimes it's a big advantage to stay in Ruby, and it's great to know that we have this option. One important thing that I think would help in revitalizing is not to make everything so Rails-centric. There are so many awesome Ruby web frameworks, that have many advantages over Rails, so we should try to focus more on generic solutions that can be used by everyone, rather than soutions that are Rails-specific. For example, I'm so happy that we finally have a generic authentication and account management framework [Rodauth](https://github.com/jeremyevans/rodauth), which can be used with any web framework, as opposed to Devise/Sorcery/Authlogic which can be used only with Rails. And also [dry-rb](http://dry-rb.org/)/[Trailblazer](http://trailblazer.to/) are great ecosystems of generic libraries. And generic libraries are great, because you can use them regardless of the web framework. Finally, I don't think that this podcast answered the question on how we can revitalize the Ruby community. Participants seem to mainly just state that the statement "Ruby is dying" is untrue, instead of trying to understand the reasons why people are asking that. Specifically for the JavaScript ecosystem, I feel like Rubyists don't really understand all of the different tools there, but for some reason they still like to criticize them. At one point in this podcast someone called [Yarn](https://github.com/yarnpkg/yarn) a "frontend framework", which was a bit too much ignorance for me. It's totally ok not to understand an ecosystem which is changing so rapidly, but I think it's good to be aware that Ruby and JavaScript toolset aren't mutually exclusive, and that this doesn't mean that the Ruby community should go to the other extreme and stick with the same tools for 10 years just because.
I've been using Tesseract in my personal side startup with much success (legally: we've been publishing ebooks and many authors just gave us their old print copies), so haven't had the need for anything more fancy or commercial. As far as I know Tesseract is what Google uses as OCR backend for their services (Docs, Translate etc.).
Celluloid, goliath are pretty much dead. Hardly anybody uses trailblazer, dry-rb (which IMHO is also terrible) or Rhoda either. Now I don't fault people for trying to build new things, I think that's awesome but people are ignoring the basics here. How about cleaning up the rubygems repository of dead gems that don't even work with later versions of ruby? How about working on the language itself so we can have less memory usage or get better performance. How about gradual typing or inferred typing or something. How about working a better way to package your dependencies so you don't have to install them on every deployment. Oh here is one. How about building something that can compete with drupal or wordpress or any one of dozens of PHP apps which all seem to work amazingly well for so many people. Oh and one last thing. The number one reason why people are leaving the community is because the community has become toxic with SJW idiots. For a long time every Ruby Rogues episode got dominated by SJW topics and programming was a secondary consideration. I for one am tired of the society hating on cis white males and arguing about why somebody got offended by some small and inconsequential remark somebody made on a mailing list or here on reddit. When that shit flared up I started looking at alternatives. There is no reason to stay where you are not wanted and the SJWs who seem to be in charge of the english speaking ruby community have made it perfectly clear they don't want whites and males coding in ruby anymore. Can you blame people for leaving?
One thing I forgot to mention is I also have to follow a rate limit. Perhaps I could send the last processed at time and it subtracts the time and sleeps for that amount?
I'm in agreement, but I think ruby could certainly use a renaissance. To revitalize it, I think we need to build stronger community around the exciting frameworks that aren't rails. That means meetups, conferences &amp; podcasts. I hope to do more this next year for my own part.
What kind of rate limit?
&gt; statements like yours are not true Reflexive downvoting, disparagement of concerns, speech suppression and personal insults are perfect confirmation: the Ruby community is now a social/political group that stomps anything cis male. Note the antipathy in the community for Matz himself!!! The energy we had 5-10 years ago is dead - the community was too trusting and accepting. In multicultural groups, MINISWAN turns out to be a fatal flaw. Lesson learned: if you want your community to survive, keep the SJW out!!! A possible salvation: Japanese community does not seem to be infected. Respect to Japanese brothers for your gift of Ruby! Keep the westerners at arms length - do not let them infect the core!! Thank god for the firewall of language and culture - perhaps Ruby can be reborn in the west in 10 or 20 years. Another possible approach for westerners: "altRuby". Let your code-of-conduct prohibit SJW and speech policing. Fork the community, exclude the SJW, refocus the spotlight on code. The great Linus Torvalds shows the way: do not compromise. Better to have a small &amp; dedicated technical community than let hordes of SJW take over and kill it.
I don't think it's a problem, but it was indeed the wrong bet in hindsight. celluloid-io bet on the "factory socket" pattern, but it was non-existent before in network libraries, nor it took off after. It's still fairly easy to write wrappers around it while keeping Socket API compatibility, but it's virtually impossible to ensure the stability of the reactor if you don't control all the layers. 
I agree, and disagree a bit. As Python's asyncio library and many experiments with eventedIO/coroutines show (celluloid-io was just one), it's possible to keep the "blocking" nature of the language and Socket API and make it all non-blocking underneath. But for all of this to really take off, this would have to be a standard library feature. And past experiments in ruby just show you can't mix both "blocking" and "non-blocking" paradigms in the same cake. 
When they are talking about the difference between JS meetups and Ruby conferences...man, that hit home. My SO is a JS/PHP developer and hanging out with her is a lot more interesting than meeting up with Rubyists, at least where I'm at. They're generally accepting of the fact that I'm approaching JS from a "How can I use this inside Ruby &amp;&amp;/|| Rails?" direction and have provided me some pretty interesting ideas. We absolutely need to work on Ruby-as-a-Community.
Yeah, the company I'm working with at the moment wrote it and uses it in production.
&gt;There are many people as well that use Trailblazer, Define many. Define it in terms of a percentage of rails web developers. &gt;What about people on older versions of Ruby that are still using these gems? Is anybody still using 1.X. Are we ever going to clean it up? Every time I search for a gem am I always going to get twenty gems which have the almost exact same name? &gt;The Ruby core team are always actively working on it, but I suppose that many niceties of the language have the performance tradeoff. But you have Crystal. Yes we do have crystal. Crystal IMHO should be adopted as ruby 3.0. Let's get the core team working on it, there is still a lot to do in order to get it to 1.0 but it's already pretty great. It's fast, it has a decent type system, it doesn't use a lot of memory, it's easy to deploy, and it adds a few features to ruby which should have always been there. Failing that I think you will continue to see people leaving ruby for crystal or elixir or whatever. &gt;This is also being explored by Matz and the team. Last I heard they rejected it. &gt;Try bundle --path=vendor/gems That doesn't work when you develop on a mac and deploy on linux. &gt;This has already been discussed, and svchator's comment below having 36 downvotes confirms that most of us agree that statements like yours are not true. No what it does say is how toxic the community has become. Any disagreement is handled with this kind of lynch mob mentality. Instead of having a conversation with the guy the downvote brigade comes in and buries the post. If his real identity was known he would have been hounded on twitter and eventually kicked out of the community. You guys just made his and my point. 
Ah right, probably should have included that in there as well. Thanks for explaining it mate, I'll add it in there soon
I explained in my other reply. I don't want an interactive script. I want a script that automates steps that are otherwise manual due to being part of an interactive program, as in fdisk is interactive. If there is a way to do the fdisk steps without having to open up the program's interface, like by using options/flags, then all the better. I'll check the man page on it. Your mention of stdin, etc. is very interesting. I'll look up examples within similar contexts. 
&gt; Is anybody still using 1.X. Are we ever going to clean it up? Every time I search for a gem am I always going to get twenty gems which have the almost exact same name? Yes, some people are still using 1.8.7, but of course very few. Also, I find it better to search libraries through awesome-ruby or GitHub. But ideas and contributions on how RubyGems.org can be improved are always very welcome, so feel free to come up with some Rake tasks for that and suggest them on the repo. Donating to RubyTogether will help as well. &gt; No what it does say is how toxic the community has become. Any disagreement is handled with this kind of lynch mob mentality. Instead of having a conversation with the guy the downvote brigade comes in and buries the post. If his real identity was known he would have been hounded on twitter and eventually kicked out of the community. It's hostile to say that people who are fighting for social justice are bad people, and giving that statement without any argumentation whatsoever is guaranteed earn you downvotes. If someone says: "could you please include a CoC, it would make many people feel more welcome", why do "cis males" make a problem out of that in the first place?
In that case, you probably need to either parse stdout/stdin/stderr (whether that's through Ruby or Bash or whatever), and feed that back into Chef to work with. What you're describing can definitely be done (I've done it recently with a work project and multipathd), but I can't say it is very wise to do. Anytime you're calling out to shell, you should hopefully have a *very* good idea of exactly what to expect...or be prepared to encounter everything.
&gt;But ideas and contributions on how RubyGems.org can be improved are always very welcome, so feel free to come up with some Rake tasks for that and suggest them on the repo. It's going to take a lot more than a rake task to clean up the rubygems. But I love your smug attitude though. That attitude will really help attract people to the community. &gt;It's hostile to say that people who are fighting for social justice are bad people, They are not fighting for social justice. They are not even fighting for justice. &gt;If someone says: "could you please include a CoC, it would make many people feel more welcome", why do "cis males" make a problem out of that in the first place? Because the COC will only be used to attack white male cis people. If a christian objects to the participation of a homosexual on religious grounds the COC will be used to kick him out of the community. If the homosexual objects to the participation of a Christian once again the Christian will be kicked out. Same goes for if a muslim objects to a christian or a jew vs vice versa. The COC is not about justice or fairness or equality. It's about imposing the will of a select group of people on everybody else.
I am really liking crystal these days. The community could use more people and it's a really nice language.
Agreed.
&gt; That doesn't work when you develop on a mac and deploy on linux. I use `bundle --standalone` to package gem dependencies with my projects in a way that obviates the need to even have rubygems running in production. (`ruby --disable-gems` will actually prevent rubygems from loading and monkeypatch `require`) Then we use `fpm` to package up the ruby project as a `.deb` file that we can then easily install on production servers. Works great. All you need to make this work is to set up a build server that is running the same operating system as you run in production, which is a small ask, if I may say so. &gt; Any disagreement is handled with this kind of lynch mob mentality. Instead of having a conversation with the guy the downvote brigade comes in and buries the post. This goes both ways. I've been downvoted by "anti-SJWs" many times. &gt; If his real identity was known he would have been hounded on twitter and eventually kicked out of the community. Undoubtedly there are a few vocal people on twitter who are happy to brandish their social capital to ostracize those dissenting views. It is ugly, for sure, but the ones I'm thinking of aren't particularly into ruby, really. All that said, bringing in a term like SJW is an indicator that you're bringing tribalism, not critical thinking, to the table here. You don't get to disposition someone else's motivations for taking their particular stance on a topic. Likely most people you'd call SJWs are _not_ motivated by personal gain.
What is the compelling reason to use Ruby outside of Rails ecosystem except Sidekiq? It's just yet another interpreted language. EventMachine is poorly designed and maintained (you still can't load SSL certificates from string) and even when it does what you want it to do it doesn't perform very well. Thin-backed Faye chokes with a chat room with 50 clients sending one message per second. 
&gt; dry-rb (which IMHO is also terrible) or Rhoda either. Dry-rb/Hanami guys should just use Java, Scala or Haskell.
Hard to argue with a plethora of arguments you provided for this statement...
Basically, dry-rb folk want their programs to be kinda type safe and kinda explicit (especially when dealing with failure). Haskell and Scala are way better tools to write such programs.
&gt; I don't have a skin in this game LOL - just a transparent lie. More gaslighting.
This is the bottom line: "Including Others is code word for excluding norm white males". People on both sides of this issue already know it is true. The tell is the strong emotional reaction it brings and the demise of the Ruby community that we have all witnessed. In reaction, disaffected whites could follow a three-step program: 1) repeat the mantra everywhere: "Including Others is code word for excluding norm white males" 2) withdraw participation from any SJW controlled community especially Ruby 3) embrace identity politics and form mutual support networks with your own ethnic in-group. WDYT? Could a movement like this take hold, even on a small scale? What weapons could diversity advocates employ to subvert such a movement?
Shrine looks like a good library and I'm looking forward to using it (btw, great job explaining the design choices). Other stuff is, well...nothing to write home about. Pry? Some people rather had a multi-threaded profiler https://bugs.ruby-lang.org/issues/10602 HTTP? What about fully asynchronous, load-balancing, short-circuiting clients in Finagle? Testing? Every language has a testing framework of some description that gets the job done. Rails though is something different, no other web framework has so much useful stuff built around it.
Sorry to have missed it - but I was at Ruby Conf Portugal, which has a similar, whimsical view on how we should enjoy our time together
&gt;What do you mean by "external dependency?" C libraries. For example pg, mysql, nokogiri etc. &gt;Yeah, so? Do you have a reason to reject this approach beyond laziness? 1. It's more work than I would have to do with other languages. 2. It's extra costs I shouldn't have to bear. 3. It's a shit ton of work to get around a shortcoming of the language. &gt;I use and support jruby. It's nice. Deploying jar files is still not as nice as deploying proper packages. No you don't get it. You don't have to deploy a jar file, it's that all your external dependencies are jar files and will work on all operating systems without you having you compile some C lib. &gt;Who knows the degree? I do. &gt; I took no offence. I expressed no offence. It certainly sounded like you took offence. &gt; Perhaps you assumed I was offended because you further assume that I'm a SJW who is offended at any and every term that I don't like. Yes I am assuming that. &gt;But the vast majority of people I've met in the ruby community are sincere in their desire to see a more inclusive tech community. Why? Why is the color of a person's skin or their gender or their religion important to ruby? &gt;I think if you focus on the activists like Coraline Ada Ehmke and their followers it's easy to gain the impression that the whole community is this way. She has a HUGE following. She was voted the ruby hero award this year and she is hired as the community representative at github. She is a major player in the Ruby community. She would not have gotten where she is without the support of the majority of the community. &gt;And I think if you at least tried to walk a mile in her shoes you might be able to understand where she's coming from, even if you find her means harmful. How would I do that? Should I code in a dress? Should I have homosexual sex while coding in ruby? How does one code in ruby in another person's shoes? 
Well, that's handy. string &lt;&lt; strings.join('') # awkward string &lt;&lt; *strings # whee! Edit: Though thinking back to the &lt;&lt; part of that... str &lt;&lt; str &lt;&lt; str str.concat(str).concat(str) That's all it's doing, each &lt;&lt; is a chained method call obviously. Edit 2: Thinking back, it may have to be written like this unless there's a syntax change... string.&lt;&lt; *strings Minor but irritating.
Oh, that'd be awesome. Let me know if there's any improvements that you can think of!
"Rumors of my death have been greatly exaggerated". So how often do we get these posts? Once or twice a year? 
&gt; Crystal is a strongly typed language. However, this does not mean that your code needs to be littered with type annotations Should be "statically typed" not "strongly typed". Ruby can also be considered strongly typed, see https://en.wikipedia.org/wiki/Strong_and_weak_typing#Variation_across_programming_languages.
Crystal spam post of the week.
agreed
&gt; I hope this short introduction managed to pique your interest +1 spelled pique properly Oh and nice overview too 
There's a part of me that wishes he would have started with Ruby 15 years ago. EDIT: accidentally a pronoun
Of course it would. Would it be practical or worth your time? Well, that's less sure.
AKA "whatever Excel does" 
The SOLID principles strike me as being kind of wedded to a Java-ish view of the world. 
If you're not using Mailcatcher for email testing, get it installed, and try starting locally to see whether you receive the email. Even so, it's strange that your tests would be running at startup.
(I may get some things wrong but this is my take) Chuck who runs the podcast is on another podcast Entreprogrammers, where him and 3 other guys speak frankly about their business and issues. (Chuck has been doing this for some years I believe) On the Entreprogrammers Chuck spoke openly about issues with his 'editor/assistant'. After replacing his editor one panelist (Sam) was upset, thinking she had been treated unfair by having the issues discussed openly. Chuck and Sam disagreed so much that they parted company. Another panelist (Coraline) wanted to use the new position on the podcast for affirmative action and Chuck wanted to just use the best people regardless, so Coraline left as well. I think others left in solidarity. They set up the new podcast with the old Rogues editor. I'm OK with it, as I think Chuck is a decent person and was trying to do the right thing. And I found it had lost it's original interest and was happy for it to reboot. I'm sticking with RR, I've enjoyed the latest RR episodes a bit more again.
[The new podcast](https://www.greaterthancode.com/) is very good so far, too.
That was ~~fantastic~~ tremendous
r/rails
Starting with Python and Ruby I would say they have a lot of similarities on the surface and any would be a good choice for someone getting started. With that said here are a few points: Ruby is probably more widely used for web stuff while Python is currently used for a lot of Matlab/Octave/R-like scientific programming. Depending on what you want to accomplish this could be relevant. Python might be a little easier to grasp at first, but all the object oriented stuff was added on as an afterthought, so it all looks a bit hacky in my opinion. Ruby was built from the ground up as an object oriented language and to me it's one of the best in that regard. Ruby has a concept called blocks, which has only surfaced more recently in other languages. After you start using blocks it's kind of bothersome to go back to other languages that don't have them. Python code is considered to be more readable. I agree with this on small snippets of code, but it's really not the case on big codebases (especially when using object oriented code in Python). Regarding Django vs. Rails, and after having done some biggish projects on both I would personally recommend Rails. Django is harder to get started with, and from experience I can also say that migrating old codebases to newer versions of Django is harder than doing the same with Rails. I haven't touched Django in a couple of years though, so you can take that with a grain of salt. Regarding content on learning I would say reddit really isn't the right place to look. Google is your friend for material, and reddit is a good place to come ask questions if you get stuck. Both /r/python and /r/ruby have pretty helpful communities I guess. Hope this clears up some of your questions :) EDIT: TLDR; After using both python/django/ruby/rails for a number of years I ended up finding ruby more enjoyable to code in, especially as projects get bigger/longer. 
Thanks, that's silly that they broke up because of something so small. 
&gt; One of the reasons of rapidly growing complexity and potential security problems is the lack of type safety at the boundaries, like HTTP params lol EDIT: Sorry this was a low effort response. The problem I have here is that the example is completely contrived, and it doesn't matter where the integrity of the data will be validated, you're going to have to react to that and leverage some level of defensive coding for your application. You would implement these checks with or without the snazzy JSON parser, it would only make a difference what is being checked. He says don't write: def process(collection) collection.map { ... } if collection.present? end When you could use this amazing tool and write: process(my_collection) if result.success?
Very helpful! Okay I'll give a shot. Since I have tried Ruby before, without googling, aren't *blocks* the same as *unnamed functions* in JavaScript? When it comes to the language choice, I'd say I want a "do-it-all" language (which I know is stupid). But it's been so long since I acquired my front-end skills, I just badly want to create a fully functional webapp. If it'll be easier in Ruby (which I hope so, I fumbled hard when I tried Django), then that's nice. But I must say, it should take a while before I get comfortable with `| |` and `do` `end` floating around. They just look so weird :D
&gt; potential security problems only if you aren't using an ORM. :-\
Excellent post!
&gt; aren't blocks the same as unnamed functions in JavaScript? They play a similar role, but scoping and binding are non-issues in ruby. &gt; it should take a while before I get comfortable with | | and do end floating around. They just look so weird Give it a week and you won't see them anymore.
You should be checking that your input data is duck-like if you are using duck-typing. By which I mean you need to know what the object has to be able to do and you should throw an exception in your method/class/whatever if your duck doesn't do what it has to do. %i(quack swim fly).each do |action| raise DuckException("Duck doesn't #{action.to_s}") unless duck.respond_to?(action) end # Code above is contrived and not meant to be production code. 
Username checks out.
I have programmed professionally in Clojure, Go, PHP, C, Ruby, Python, Java, and Perl. Of the C-style languages Ruby is by far the easiest to pick up — consistent, idiomatic throughout, intuitive. _Rails_ is complicated though. 
Couple clarifications: Chuck fired Mandy because he thought her job could be done for less money. After the change, Sam made some [public remarks](https://twitter.com/geeksam/status/776147792657993728) on the topic, and Chuck fired him because of it. The rest of the panel quit in solidarity.
I thought the video he posted was very gracious and apologetic. I'm not sure I understand the ire being directed at him. 
Yes, that's known as a hybrid concurrency model, where you leverage both forked child processes and threads within the children. See the `parallel` gem for an API that allows either threads or processes. I find that MRI starts to get sketchy above 50 threads per process but that's a very general number, YMMV. You'll probably want to leverage connection pools to share network connections, see my `connection_pool` gem for help there.
A lot of things for me to research in your two paragraphs! Thanks a lot for the information. Another thing I've been thinking is: Is it possible to distribute processes between different computers as "nodes" or something? I've read some stuff regarding druby but didn't give much attention to it. 
While threading is one way to deal with this sort of problem, there's a separate approach that you might want to consider. Your class of problem is sometimes referred to as "embarrassingly parallel". Each datum can be operated upon independently. Unlike a nuclear simulation where the calculation on one neutrino changes the calculation for a neighboring neutrino, you can retrieve/parse/ping a web site independent of the others. Such an application is often fed by a queue. One process/thread queues items to be processed. You can then run one or more consumers to retrieve from the queue and execute your logic on it. Want to process records faster? Add more consumers. Each consumer could be implemented with threading, but it's not necessary. Multiple consumers can coexist on one system or be on any host with the requisite connectivity to the queue. (I'm referring to a queue external to Ruby, not a Ruby Queue)
There's /r/learnruby/ and /r/rails. IRC is also a great place to ask questions. There are also plenty of excellent books on Ruby as well as Rails listed in the sidebar on the right -----&gt;
One other possibility of implementing sum of array elements is `Enumerable#reduce`.
Seems like something sidekiq might be a great fit. You get the parallel processing through threads but makes it easy to have multiple nodes pulling from the same queue.
Your comment helps me realize that I just don't understand the whole context. Probably none of us do from the outside except Chuck and Mandy. All I can respond to is the video he posted (which seems extremely genuine) and the semi-ambiguous tweets (which seem extremely supportive of Mandy), so I should just withhold judgement. Twitter just seems like a terrible place to air professional grievances in general. I did listen to the podcasts on which he discussed Mandy, and I think that was a lapse in judgement on his part to bring up those issues so publicly.
array[5]["firstname"] The first index accessor, 5, gets the sixth element of the array, and that element is a hash. The second accessor, "firstname", gets the value of the key from that hash. More verbosely: hash = array[5] value = hash["firstname"] value 
Probably not. A lot of tooling choices are just pure preference. My recommendation is to learn how to set up vagrant boxes and try out different tooling setups. That way, you can figure what works for your workflow. Try RVM on one and Rbenv on another. Definitely learn bundler. It's the de facto gem dependency manager. It's good to understand rack, but I wouldn't start out with it. Also, a lot of stuff you're talking about it isn't just Ruby. Env variables are system based. &gt; The reason being, I want to understand what is going on under the hood from the start. For Rails I think this is a good idea. There was a book that came out a few years ago called "Rebuilding Rails" where you build a rails like framework starting with Rack. However, I'm not sure you are will get as much out of learning how Ruby runs under the hood (at least at first). It's more important to learn object oriented principles and how Ruby implements them. If you would like to learn more about how Ruby runs under the hood like how it's lexer works, there's a good book called Ruby Under the Microscope that gets into these concepts. That being said, I think it's more valuable to learn more fundamental principles like OOD first.
Crystal has macros which let you do some deep voodoo magic shit I don't understand at all. It's like metaprogramming on acid.
&gt; I find that MRI starts to get sketchy above 50 threads per process Could you please define *sketchy*? The problem I'm struggling with in Ruby, is that you need threads to do blocking IO, so, how do you decide how many threads to give to, e.g. the Puma server (which has the limit set pretty low by default), if your web requests happen to turn around and make web requests to an external API. If all you got is 50 threads, you can accept 50 requests, which will all wait for the response from the API, and all other incoming requests will be stuck in the server's queue (and potentially time out). If the backend API can handle unlimited concurrent requests, I should have no problem having unlimited number of threads (requests) hammering it (limited only by the OS's resources). But there is your ominous warning about going above 50 in Ruby. How can this be reconciled? And particularly, how do you configure Puma? How do you know how many threads is enough? What will happen if you set it to 9999 threads? Just interested in hearing more opinion/pointers from someone who everyone knows has done their fair share of threaded programming in Ruby... Thanks!
Crystal's macros just let you interact with AST nodes. The same thing is already possible in Ruby.
Packaging is only one of many problems in lambda. I worked at a competitor for a time, and the problems all these platforms have are very similar: they're typically somewhat hard to manage and source control. They're hard if not impossible to debug for all but the simplest function. They have limited support for packages, and what support they do have is usually somewhat idiosyncratic. I think serverless solves a real problem, however I also think that the current incarnation is only useful for simple tasks of this nature. Anything more complex is not something I would trust in a production environment. I know some people are running some very complex stuff in lambda, but I wouldn't run it in production and I almost certainly wouldn't run anything that I actually have to rely upon.
#**Happy sixth cake day!** Today’s your sixth Reddit birthday. You’re officially six years old. Happy cake day! :)
&gt; array.select { |e| e.is_a? Hash }.detect {|hash| hash.has_key? 'firstname'}['firstname'] Awesome, but I'd probably use this solution as it's nil safe (works even if *firstname* is an invalid key not found in any hash in the array). array.select { |e| e.is_a? Hash }.map { |e| e['firstname'] }.first
As a got who mostly does python but likes ruby, they're both "do-it-all" language, where it can be used for nearly everything (as long as libraries exist/it doesn't require speed or lack of a runtime). ruby isn't javascript or php. That said since the languages are so similar python "won" in most non-web areas so you have better quality/better supported/more choices in libraries for many things. For example python is the only well supported non C++ binding for Qt(the best cross platform desktop ui). Python also has good support for libraries for scientific programming: https://wiki.python.org/moin/NumericAndScientific In ruby you may have access to these sort of libraries but they won't be as well maintained or sometimes you'll have to write your own or bind to c.
...I don't get it. You can handle input data like it's primitive untyped binary in Ruby just like any other language. If there's a problem with input/output it's a problem with your code, not the language. I don't need a nanny interpreter telling me that I have to do things a certain way when I encounter a problem with my own crappy code. https://ruby-doc.org/core-2.3.1/Array.html#method-i-pack I'll have to worry about binary representations of input/output data in some low level typesafe language. Why should I blame Ruby for having to worry about the exact same problem for the exact same reason? The standard library has tools for this. If it's too slow for my needs in Ruby then I can write something up in another language and call it through Ruby.
So what did they say that Ruby is bad for multicore programming and threads If tools as sidekiq solve this problem ? I am just being devil's advocate here.
I guess it will quickly reach its limit and fail. That's the purpose of thread pooling isn't it ?
It is not what you are asking for, but I need to point out that simply changing the interface from an open ended text area to segmented line items will greatly simplify this for all parties involved. natural language processing is a very complicated field and minimizing the amount and type of segmenting you must do by steering the user's input will only have the effect of making your task easier and the output cleaner. For instance if you give the user a fixed set of number (the 1 in 1 cup or 1 dash), the type of measure (gram/dash/cup/gallon/etc) and an open text field for the ingredient you will marginalize your NLP task down to normalizing variations in ingredients (green onion vs scallion for example). 
Something like the Microsoft LUIS API might be able to let you build a model for natual language understanding: https://www.microsoft.com/cognitive-services/en-us/language-understanding-intelligent-service-luis
Thanks, that is basically what I have been doing so far (looking at popular projects on github)
Yeah I didn't mean Ruby itself under the hood, more understanding web frameworks under the hood before diving in to rails.
Yeah, probably, but there are some things I'm unlikey to do a check on. Like if I expected a string-like object, i'd probably not check that it implements the needed interface. Where as a passed in database connection I think I would check.
will do, thank you!
Generally, long lasting tasks should be spun off to Sidekiq. Sidekiq will scale to hundreds of processes. I have some customers running 5000+ threads to chew through **lots** of jobs/sec.
That's a really tough question. I think you spend already a few hours trying to answer it before posting to reddit, don't you ?
People have already done this. https://www.google.com/search?q=nlp+recipe+ingredients&amp;oq=NLP+recipie
Ruby has the best community, it's just not on Reddit for the most part.
holy shit this is awesome. My google-fu completely failed me. Apparently knowing the term "NLP" is required. Thanks much!
Correct, which is why I noted things like sidekiq allow us to use ruby and solve real world concurrency problems with the language we love. But that doesn't absolve MRI of it's justified reputation for being pretty lousy at concurrency :) I mean certainly if we were to rank languages as to how suited they are to concurrent programming, we'd rank MRI ruby pretty far down the list...
That is a good question. I am not sure who registered redditrrubyco-20.
Mixing threads and processes can lead to unexpected and obscure bugs, see http://www.evanjones.ca/fork-is-dangerous.html and https://cppwisdom.quora.com/Why-threads-and-fork-dont-mix. I would suggest avoiding mixing the two, unless necessary (or unless it's a simple application for learning purposes, which is what it sounds like yours is).
These tokens aren't secure. They are effectively passwords stored in plain text. You should securely salt and digest them as you would any other security token 
Only if you aren't aware of the consequences and don't have things thoroughly tested? https://github.com/NullVoxPopuli/rails_module_unification
Yup, it's a great addition to Rails 5. For this tutorial, I wanted to focus on how easy it was to add this functionality and see how it worked. `has_secure_token` is also missing a decent way of expiring tokens (from what I know)
I agree that it's a bit of a misnomer. They're only secure in the sense that they're generated by a secure random method, meaning you shouldn't be able to attack them by predicting the token or forcing a collision. A naive implementation of token auth using has_secure_token would be insecure, strictly speaking, but probably good enough for more uses if the author takes reasonable steps, such as expiring the tokens periodically. The true authentication mechanism is a password that has been properly salted and digested and the token is only granted upon a successful authentication against the password. The usual value of a harvested password is that it can be used to gain access to other accounts it was also used for, because humans are dumb and just repeat one password for everything. Chances are that if you harvest a set of plaintext authentication tokens, they'll be of very low value because they're random and possibly expired. If you're really paranoid you can go a step further and sign the token with a shared secret. Just don't do anything stupid like share the key over regular HTTP or use a broken cipher or store it improperly or perform non-constant-time comparisons. TL;DR: Use HTTPS, grant access tokens from secure passwords, expire tokens periodically. You'll probably be fine. If you require more security to protect *really important stuff*, use a more robust method that grants access with signed tokens. I've heard that the cool kids are using JWT these days.
Sure, but for an article to help teach people about testing techniques-- why add the complication to something that otherwise has an expected and recognized default? Anyway, thanks for the article. I didn't previously realize what the differences were. I haven't yet had the need to learn much about mocks and stubs but hear the terms tossed about. 
Clickbait, more or less. Checked another few articles on the site and also found them bland and shallow. If only people would speak when they have something to say, remain silent otherwise …
Well, YAGNI is a static definition - it's easy to define YAGNI with a set of frozen-in-time specifications. You write the simplest solution and you're done. The problem is you're gonna get a change request the following day, and then another, and then another one. Every time you'll have to re-evaluate if _adding that single 'if'_ for the sake of simplicity or evolve your design. Some design choices are, in fact, aimed towards better maintainability, and this comes at a cost. The proof? We've all seen huge Rails projects built on a too-strict adherence to the YAGNI paradigm, to the point where no refactoring is done and you end up with huge bloated classes. Finding the right balance is really a matter of experience, there is no easy recipe for that IMHO.
Splendid.
Typically I do this: 1. On authentication, render the raw token and the identifying attribute (username, email) 2. Digest and store the token 3. On the token auth step, lookup by identifier and do constant time comparison of the token digest to prevent timing attacks (this is why devise got rid of it) 4. Expire the tokens every so often.
Where I work now we use Python to do this, and where I've worked previously we've used Java, so there's no gem that I can recommend. One might well exist. Here's the high level overview. We have a queue that contains messages in RabbitMQ or Redis or whatever. These queues are data stores, you can think of them like a database. A queue is a common [data type](https://en.wikipedia.org/wiki/Queue_\(abstract_data_type\)) that you'll encounter pretty frequently. We have processes that process the messages from various sources and then add them to the queue. A process then grabs a message from the queue and removes it from the queue and does whatever it needs to do with them. The code that handles the queuing is pretty simple, generally.
Well it seems to be for me because e.g. there's a difference If you download 5 files in 2 seconds or 5 and a more important one If you want to ping sweep a network and get real time results. Why is it async messaging as the processes run in the background and can send messages by themselves to one another? I don't see the difference from the perspective that an O/S works with multiple cores to deliver you concurrency for every day applications. 
I wonder If you can suggest a book on multicore programming and concurrency, threading etc. Google isn't the solution for everything and not always a reliable source to learn such things. In simple words "how did you start learning" about this subject ?
But you have to learn from the ground up in order to use the tools efficiently. I'm in the phase of learning and I currently can't distinguish why someone could choose processes vs threads and vice versa. I once ran something with Jruby and although it takes - obviously - some more time to start, it's very fast when using threads.
Yeah, good point. Thanks!
That's not the same as hoisting. That's because you're writing your statements directly on the main object in irb. To my main point, though: do you disagree that scope and binding are non issues in ruby while being pita in js ?
This is not hoisting. When Ruby encounters statements like if false x = 1 end puts x Ruby makes x available when it reaches the body of the conditional, whether the branch is executed or not. The result is as if the code was written x = nil if false x = 1 end puts x This is a special case and not the rule. Ruby does not do something like this for every method definition or every variable declaration.
I've learned from a number of places, but primarily from doing it. Doing it is important because, largely, each language has its own rules for this. In Ruby, for example, the model of multiple processes makes the most sense for tasks that are independent of each other. In Java, it makes much more sense to use threads, the JVM is so heavyweight to begin with that it doesn't make sense to spin up more than one JVM. There are a lot of great books on Java concurrency (threaading). You should definitely check some of those out, if you know Java. If you don't know Java, try learning Go. It has a powerful concurrency model and it's a very well built language. Threading isn't a big thing in Ruby, and it's not as natural as it is in other languages. These are common problems, but unfortunately I don't have a good immediate recommendation for you on this since I mostly learned through doing it and from my work rather than from a more academic standpoint. :-/
My example wasn't perfect. I made it clearer, but it doesn't explain ruby's behavior in exact terms, because I was trying to be brief. The differences aren't minor. Variable scoping behavior in JS differs from the norm enough that we call it "hoisting" to help explain it. In JS this happens for every declaration. In Ruby this happens in specific cases. In JS the implicit declarations are available when you enter the scope. In Ruby you'd get a NameError because they aren't available until the statement is reached. Ruby's behavior is just what people expect from lexical scoping, except that when the interpreter sees a local that could exist, it defines it so that it always exists from that point onward.
Very slick. I was recently dealing with this exact problem with some JSON and had to write some code I'm not so proud of to solve. This should help a lot.
I joined the podcast as a panelist a few episodes ago. So far, as far as I can think without checking, our episodes have been pretty much all technical. One possible exception is the "Is Ruby Dying?" episode which doesn't get too deep into any actual technical stuff; it's more high-level.
all the things you mention are individual components. To use them all on every project would result in unnecessary boilerplate. By the way, when you say you want to learn web frameworks under the hood before learning rails, it sounds like learning sinatra could be beneficial. - deployment / env variables - these are different things. - env variables are straightforward - deployment can range from relatively easy (heroku, github pages) to incredibly complex - bundler - essential to basically every ruby project. start with this - rackup - a command from the rack gem. - only necessary to learn very basics - rspec - only if you're doing automated testing. - testing is the type of thing you do for "high quality" code but it's by no means necessary for personal projects. - general code organization practices - there are plenty of tutorials on OOP in ruby. However it takes time and practice to feel totally comfortable. 
FYI: For easy (re)use I've updated all factbook.json datafiles, see the [/factbook.json](https://github.com/opendatajson/factbook.json) repo. Cheers.
I love RPGMaker. I wish there was a new version with the latest ruby. My best guess would be to port any gem you need directly in to the system. Open up the source for the ZIP lib and copy over the code. You'll probably have to make some modifications.
Still dealing with humans, still dealing with egos, and honestly a podcast like RR is nearly the place recording and coding merge.
The startup time would kill these specific benchmarks but have you tried running on jruby? I could see possibilities where the would be running in a REST service
&gt; As expected, the conference came with some big announcements. The first of which was Matz’s keynote on Ruby 3 typing. He shied away from optional types. He expressed concerns about jumping on the typing bandwagon simply because it’s popular and questioned whether adding types violated the DRY principle in some ways. Matz then gave an overview of what he called “soft typing”. His plan is to make Ruby better at understanding the interface being used in a method. It’ll check that interface against the provided arguments. Ruby remains dynamic and duck typed but gains improved introspection for what went wrong. In theory, this would provide better error messages and improved IDE support. This sounds pretty great to me actually, just the right thing to do with ruby. I'm less convinced of guilds, but maybe don't understand the use cases they're intended for, or how I'd use them. &gt; Part of that means freezing strings by default probably won’t make it into Ruby 3. Thank you, Matz, that is the right choice! Thanks for the English language write-up!
&gt; That's just ruby limitation - you can't override `&amp;&amp;`, `||`, `!` etc., so gem needs to be creative and use `&amp;`, `|`, `~` for boolean operators. They unfortunately have "wrong" precedence. I'm not entirely sure what you mean... Firstly you *can* override `!`, just like any other method in ruby; the only reason you cannot override `||` and `&amp;&amp;` is because these are *operators* and not methods. (Similarly, you cannot redefine the meaning of `if`, `case`, `begin`, etc.) class Foo def ! # Whatever end end Secondly the boolean AND/OR methods have the *same precedence* to one another, as their logical AND/OR equivalents - i.e. `&amp;` is above `|`, just like `&amp;&amp;` is above `||`. Ruby's operator precedence is very standard, with the possible exception of the `and`, `or` and `not` operators - so I'm not even sure why you'd want to redefine that.
For the record, Shrine is the most actively developed file-upload utility https://ruby.libhunt.com/categories/144-file-upload?order=activity
Thanks for that suggestion! I got pretty far with this approach using 7zip's 7za.exe with the negative side effect that it doesn't really have a silent-mode that doesn't open up a console window in the background. Tried working around that with IO.popen, system() and piping the output to NUL with no effect. Do you know of any other ZIP-Processing standalone Executable by chance?
Love it too for it's ease of use, but one certainly quickly gets to it's limitations :) A new version with an updated Ruby build would be awesome - though I kinda dislike the map layer system of the newer iterations. I feared that I might end up integrating a gem by myself &amp; resolving all the external references - was hoping for another way.
Yes and no. The problem probably hasn't changed much, but the technical environment sometimes does anyway. New Rails versions, etc. Also for instance, some of the existing gems integrate rather tightly with ImageMagick, and haven't done very well with the changes to ImageMagick related to CVE-2016–3714. Also even when neither the problem nor the environment changes, a fuller picture of how it's being used can show problems with the API, reasonable things it isn't flexible enough to do easily and forwards-compatibly, but could be. You want maintainers keeping on top of always making the gem better, while still balancing backwards compat etc. At least I do. In general, even with the problem doesn't change much, I've seldom been able to use a gem dependency that's completely abandoned for more than a year or two after that, at least without forking it. Not saying the other gems in this area are 'completely abandoned', but it's a continuum. 
You're looking for `||=`, [the Or-Equals operator](http://stackoverflow.com/questions/995593/what-does-or-equals-mean-in-ruby).
This does the trick: variable ||= '*' Or for setting the variable as the argument, or '*' if the argument is not set (in one line): variable = ARGV[2] ||= '*'
bear in mind that `variable ||= '*'` and `unless defined? variable; variable = '*'; end` have different behavior when `variable` is already initialized to a falsy value.
Oops, I completely forgot that 2.x made `!` into a method, it used to be operator (as was `x != y` which was syntax for `!(x == y)`) in 1.x. Anyway the problem is that to express "variable x is between 1 and 9" we want expression like this: * `x &gt;= 1 &amp;&amp; x &lt;= 9` (or even `x &gt;= 1 and x &lt;= 9`) Neither of these is possible, and we can't define own operator, so we'll look for the closest sensible option and do: * `x &gt;= 1 &amp; x &lt;= 9` Unfortunately that parses as `x &gt;= (1 &amp; x) &lt;= 9` which is totally wrong, so we have to do this: * `(x &gt;= 1) &amp; (x &lt;= 9)` This is best syntax possible in ruby 2.x. Alternatives like: * `Z3.And(x &gt;= 1, x &lt;= 9)` (supported) * `(x &gt;= 1).&amp;(x &lt;= 9)` (supported) * `(x &gt;= 1).and(x &lt;= 9)`(hypothetical) are generally even worse (except when you have array of conditions, then `Z3.And(*conditions)` is actually quite reasonable). This won't be possible until ruby changes its mind about `&amp;&amp;` or at least makes `&amp;` (or some custom variant) have sensible precedence. [Python has similar issues and here's some discussion](https://www.python.org/dev/peps/pep-0335/) - their examples are numpy and sql query builders. Such overrides would be extremely useful.
Thanks for these blog posts, very helpful. I already had a good impression of shrine, but hadn't used it in a project yet. I've definitely been convinced to use it in the next project where I have an option. 
Thank you for your response, this will definitely help me go in the right direction. I'm not that familiar with search engines and didn't full understand the disconnection between them and an rdbms. 
For multi-line blocks, I prefer .each do 
&gt; when to use .each do vs .each { I use braces on single in-line statements 1.upto(5).each { |x| puts x } and a do block for multi-statement blocks 1.upto(5).each do |x| x = some_method(x) x = another_method(x) end I believe this is current preferred style. So with that if in your block, i'd use a do block rather than braces.
 &gt; files = Dir[Dir.pwd+"/**/*."+ext] I'd change this to: files = Dir["#{Dir.pwd}/**/*.#{ext}"] This created a single string using variable interpolation. or files = Dir[Dir.pwd + '/**/*.' + ext] Single quotes, because there is no interpolation. Spaces around operators and method calls or variables for readability. 
Thank you.
Nice, thank you.
This files.each do |file| File.open(file).each { |line| if line.match(search) puts file end } end could be files.each { |file| File.open(file).each { |line| puts file if line.match(search) } } But readability goes down when you fully one-line like that. So this is probably best: files.each do |file| File.open(file).each do |line| if line.match(search) puts file break end end end Once you match a file, there is no need to search the rest of the file. Imagine a 2 terabyte file, and the match is in the first line. Or also, a large file with multiple matches. It'd be also advisable to perhaps break this up into some methods. For instance, the logic for looping through all files can be isolated from the logic to search a single file. def search_file(file_name, search_term) File.open(file).each do |line| if line.match(search) puts file break end end end files.each { |file| search_file(file) }
This is useful, thank you. Didn't think of using a method.
I feel like if I wanted to do something stupidly simple and quick I would write it in php. Just so I don't have to deal with all the shit that tends to go with web based ruby stuff. On the other hand I have worked an a massive multi-engine rails app and it was absolutely miserable. The nice thing about php is it tends to work on most hosts with almost no setup. 
Q: When would choose PHP over Ruby? A: In 2003. :D But seriously, I'd say if you tend to want to do everything in Ruby now, then do that until you run into a particular use case where it feels harder than what you used to do in PHP. You might want to check around and see if you're overlooking something simple, though. For example, the first comment mentions a lot of baggage that goes along with Ruby-based web stuff, and you'd probably agree if you were trying Rails for the first time to do a very simple site. However, if you take a look around you'll find some other options that are nearly as simple as the (old school, non-framework) PHP way of doing things.
I feel like you still run into the PHP-y case in Ruby from time to time, when you're using functions instead of methods. If the function you want is not available of the class of the return value from the previous message, you've still got to nest them so you're not totally out of the woods with Ruby. Some language offer pipe operators (like Bash or Elixir) where you pipe the return value as an argument to the next function and it reads just as well without having to encapsulate logic in classes. Example: foo |&gt; String.reverse |&gt; String.upcase |&gt; IO.puts # "OOF"
Does anyone know why this is happening? I am trying to install Ruby for the first time and it's stopping me right at this point?
Do yourself a favor and use a VM. Ruby is painful on Windows every step of the way. Yes it can be done, but why put yourself through the hassle?
Run as administrator?
* PHP is faster. * PHP is an easier codebase to maintain. * It's easier to hire 20 PHP developers that can jump in on a project than it is to hire 20 Ruby/RoR devs. * It's blindingly simple to scale a highly available PHP application. * You can host a PHP application anywhere and do it in an hour if you take your time and then scale out to anywhere for thousands of concurrent users in a few more hours. 
Not sure it's the one used there, but you could start taking a look at `curses`. [This article](http://stac47.github.io/ruby/curses/tutorial/2014/01/21/ruby-and-curses-tutorial.html) is the first tutorial I've found on google, seems good for a quick start.
My guess is (based on that the first thing in your prompt is Access Denied) this is related to setrbvars.bat (that is run when you double-click the icon), and more specifically to the last command, ruby -v - because when your start the "Start Command Prompt with Ruby" you should see (active Ruby's) version string at the top (edit: [like this](http://imgur.com/Jk9rBS4)). To check this, if you open up the prompt, and type "ruby -v" I guess you will get that "Access Denied" again which I would guess is because of some Windows ACL thing. Does the account you are trying to start the prompt from have write access to the location you installed (probably as an admin) Ruby? (or some other path that Ruby needs to write to) If nothing else works, you probably need to always start the command prompt by right clicking the icon and choosing "Run as Administrator" (or check in the shortcut's properties Shortcut -&gt; Advanced -&gt; Run as Administrator).
the only proper way to run ruby on windows is *to not*.
I've been developing on a VM on windows for a year and it has worked out quite nice. A putty batch script goes a long way.
My PHB is holding a gun to my head? And even then ... ;) Seriously, only in cases where it's something simple that we need to be able to deploy anywhere quickly without worrying about environment compatibility issues. 
I'm tempted to delve into the wild undocumented C API to embed Ruby as a scripting language in a compiled executable but I can already sense the amount of work likely involved. I'm really lazy and have some new games to beat. Not sure if I'd aim to cut down the work involved by embedding Ruby in C++ Gosu or by embedding Ruby with the Gosu gem inside a C application. I mean, you *can* just run with Gosu if you don't mind rebuilding an entire toolchain and series of scripts for a game but then you run into the problem of how to get it on an end-user's system without making them install Ruby, up to date gems, Gosu and possibly the Ruby devkit if they're on Windows.
Interesting. Crystal is definitely on my list of languages to try. Now it just made it a bit higher on that list ;)
Thanks for taking a look. I believe the project does work with SQLite, which is [incompatible with heroku](https://devcenter.heroku.com/articles/sqlite3). Initially I tried the 'pg' gem but was unable to get it to resolve SSL issues while using plain ruby, and after switching to jruby i found out the 'pg' gem is not compatible.
Changed job. I was never married to php, but didn't mind it either. TBH I kinda wanted to work on something hackernews wasn't going to shit on me for using. 
Piggybacking this to answer too. I did PHP professionally as well for about 8 years. I knew it inside and out as a language. I used many of the frameworks that came out over the years... cake, CI, Yii, Symfony, etc. I was good at what I did. But, like you said in your OP, it always felt like going backwards. I always felt like, no matter what framework or tool I was using, that I was jamming a square block into a triangle slot. I stuck with it because it paid the bills. I dabbled in other languages over the past 15 years as well for work. I used to do C++, Python, Java, etc. But PHP was what was hot and had the paying clients. I eventually got fed up with working with PHP... I wasnt happy and no money was going to fix that. Then, about 4 years ago I discovered Ruby. My jaw dropped at how extendable it was, the natural flow it provided. After a few weeks of learning I no longer felt like I was trying to fit things in that triangle slot.. I felt like the one defining the slot. I now do Ruby (and Rails/Sinatra) full time for web. I write apps, scripts, automation tools, and even my own Gems. I love the beautiful language it is. That's what made me switch.
Language no. Nothing about php was preferable. I had better mastery of the stack though. I miss that, but can chalk it up to me being too lazy to learn it now that I have devops down the hall. 
Where's the code? Articles on Ruby Gems (or any other topic in programming) lost a lot of punch if they can't back it up with some code or maybe that's just me.
Here's a tutorial I've used in the past for this exact type of thing: https://stac47.github.io/ruby/curses/tutorial/2014/01/21/ruby-and-curses-tutorial.html
:)
you might be interested in the [chainable methods](http://www.rubydoc.info/gems/chainable_methods) gem. not sure how widely it's used yet. 
totally agree. plus you'll learn some basic linux skills that are always valuable.
thanks for the suggestion, ill check it out
Ruby hasn't given me any serious problems on windows. Use it for scripting regardless of whether I'm presently using windows or linux.
If the project is using Travis-CI for testing on various Ruby versions, you can just use the information from the project's travis configuration file to see what's needed.
Read the installation notes in the documentation/readme. This is only a problem for native gems, which aren't very common. There are a few very popular ones (e.g. Nokogiri, pg, mysql2) but most gems are pure Ruby.
When possible, I like all of my test setup to be self contained in each individual step but think moving from `let` to instance variables is a nice middle ground.
VSCode for ruby now is very basic. notepad + some colors
Gems can use the [`requirements` attribute](http://guides.rubygems.org/specification-reference/#requirements) to signal an external dependency, but this is rarely used.
Woo for regexes over rspec!
Nah it's all good I get its more of a joke than a serious "php sucks" comment, but yea I was just thinking that whole meme might die once PHP7 is the norm (or more likely be replaced with a new meme). I wholly agree with you though; use what you are comfortable with, and don't chase FOTM languages. &gt;it's no fun feeling like you're constantly fighting against your tools I'd say I only learned Ruby because of Jetbrains' IDE similarities between RubyMine and PhpStorm...it really made a huge difference in learning once getting over the initial curve.
Slides somewhere?
Ah that makes sense. That's a nice example too. I notice they use the "&lt;&lt;-EOM" token to have the code begin executing C instead of Ruby. I'm guessing that's where the need for a native library to be installed comes from. If the C code in that section tries to call a function that isn't defined in that embedded C code, it would instead need to get it from a C library, which would have to be already installed. Would it make sense and is it possible to embed C code that wouldn't need a native library if the need for it arises? For example, if one wanted to use the stack to perform some algorithm, they probably don't need a native library for their embedded C code, it would just be operations. In that case, wouldn't the developer installing the gem be oblivious to the gem using native code aside from a "building native extensions" while installing the gem? And it would install without any issues?
The problem is that the specific name of the requirement can vary not only between platforms, but between different versions of the same platform. That means it's a pain to automate, so you're back to relying on humans getting it right.
I'll just stick with RubyMine...
Tried it, but it just wasn't as good as Atom. It's mostly the plugins that don't work as they should. 
My issue with instance variables in RSpec is that it's ambiguous what object these variables are being set on. In Minitest it's obvious, because you define the class yourself. You don't explicitly define any classes in RSpec so, unless you know exactly how it is implemented under the hood, it's confusing.
No but I am using it for Crystal
I tried it and despite fiddling with the official Ruby plugin for a while, I couldn't get it working. It was worse than coding in gedit etc because it would tab the Ruby code for you but the wrong way. I gave up and went back to Atom. For Rails development I use RubyMine anyways.
Just now on [Stack Overflow](http://stackoverflow.com/questions/40499132/transliterate-waka-waka)...
Pretty much, yes, aside from the fact that it restricts which Ruby implementations you can use (Nokogiri has code for both MRI and JRuby, so double the effort; most gems will only implement one, and you can't use it on the other).
http://imgur.com/Hgta0ba Infinite loop. Unresponsive. Overheating.
Honestly, you shouldn't have to know, it should be automatic. Unfortunately, people are involved along with computers, so it's harder to fix than just one of them alone
Advice: at least try to solve your assignments before asking for help online. Then post what you tried and what doesn't work as you intended it to do. In the long run, you want people to help you do the assignment and not people do the assignment for you. 
Pmilter is a simple and programmable mail filter server software. You can control smtp server like postfix or sendmail via some mruby scripts. Pmilter is one-binary. So you can deploy and setup environment very easily. Enjoy!!
True, I guess I shouldn't have used the terms TDD; just testing. I think part of my issue is that I'm not sure what exactly I'm supposed to be trying to test, per convention? For a simple method such as that, do I just want to be testing that my class is calling the method from the mixin properly (and then the mixin's method would have tests to make sure it actually grabs the data properly)?
Python is more popular in when it comes to scientific computing and big data analysis. Ruby (I believe) is more popular when it comes to web development. The major difference come down to programming philosophy imho. Ruby is more about expressiveness and flexibility while Python emphasizes correctness and consistency.
Right how could I forget about Homebrew and Puppet! Those are two big non-Rails projects.
Well, gem is updated and it supports both `!` and `~` now. There's already `Z3.And(x &gt;= 1, x &lt;= 9)` and friends as alternative. Z3 also internally supports lisp-like syntax `(and (&gt;= x 1) (&lt;= x 9))`, but there are issues with exposing this. Range constraints are very common, so they could use some special syntax support, it just might require more monkeypatching of `Range`. I'm not really sure if setting up fancy DSL wins that much compared with just requiring a few extra parentheses - most DSLs would require a lot more than that.
It is very confusing for the newcomer, but after you've been through it a few times you'll realize it's not that much of a problem in practice. Gems with native code are fairly rare (in part because many developers try to avoid them), tend to be just a few fairly popular/high profile ones, googling for the name of the gem that failed install and the error message usually gets you what you need, and if you're on OSX, even the `brew install` command to enter to fix it. 
Use both! Both languages are great. I have to say I prefer Rails to Django but in general I prefer to use Python. Great computing libraries, fun for personal interest projects, and I just like the syntax more. Definitely no reason to limit yourself though. Ruby is popular if you're only into web development but Python is probably more generally useful (and is also popular among web developers). 
I don't know. I would get down to the function that actually requires an external connection, and just stub it.
&gt; Is there any reason why I couldn't just forget about Python and focus on Ruby instead of it? In general, and perhaps with experience, language and syntax are irrelevant. Learn good practices in OOP development, these are applicable to any other OOP language. To which I guess I am saying, pick one and learn it as well as the deeper language agnostic skills of OOP development. (good testing practices, SOLID design, design patterns, how to spot anti-patterns, code smells and how to deal with them, etc) I personally prefer rvm and bundler (ruby) to venv and pip (python). But then, I got into the details of ruby first. I work in python professionally. I write ruby for personal projects and sometimes work stuff. Python doesn't have anything like rake, that I'm aware of, that makes a big difference to me.
I don't get it. Of course throwing an exception is going to be faster than going through all the layers of AR to build a create query the push it over a socket and handle the result. What's next? A benchmark that shows assigning a variable is faster than writing to disk?
Thank you for using them tools! Please spread the word so that more peeps get to use them. I totally love God's Own Country!
Give them feedback that you could have used more of that prep?
True. Without feedback, they're blind. I'll do that.
The answer is never in your testing framework. Make your object more testable and your problem will go away. Specifically, create an `SSHCommand` class that encapsulates the side effect of running an actual command over SSH. Then define a substitute for it that can be used in testing. Then change the interface of `LinuxDevice` so where you can vary the implementation of the ssh command object. This means adding an additional argument to the constructor. Then add a factory method, `.build`, that constructs an instance of `LinuxDevice` using the implementation of `SSHCommand` that actually performs work over SSH. class SSHCommand def call(*arguments) ssh_command(*arguments) end class Substitute def initialize @commands = {} end def call(*arguments) @commands[arguments] end def add_text_output(text_output, arguments) @commands[arguments] = text_output end end class LinuxDevice attr_reader :ssh_command def initialize(ip, ssh_command) @ip = ip @ssh_command = ssh_command end # Avoid needing an IoC container def self.build(ip) new ip, SSHCommand end def current_uname ssh_command.call('root', 'uname') end end Now, in your tests: ssh_command = SSHCommand::Substitute.new ssh_command.add_text_output "some-uname", ['root', 'uname'] linux_device = LinuxDevice.new '127.0.0.1', ssh_command uname = linux_device.current_uname assert uname == 'some-uname' 
Also ask this on r/Python.
I take it as a caution about attending to micro-benchmark performance improvements unlikely to effect your actual app. 
Puppet is python no? But chef is ruby
Some reasons not to choose Python: - Default function args which persist beyond each call - \_\_dunder\_\_.(self - Guido's anti-functional bias - Multiple inheritance - Passing self to methods for the rest of your life - virtualenv - import re - Decorators - no ++ -- - if \_\_file\_\_ == 'main' - no Perlish q%() string helpers - Explicit return instead of everything an expression (Ruby) - Back-to-front comprehensions logic - 2 vs 3 version wars - Crippled, single-expression lambdas - No ? : ternary - Quoted string dict keys instead of :symbols (Ruby) - No switch/case - Compulsory significant whitespace 
It is not even funny. Your question is at least fourth with same title. Answer: - wants stability and better job? then stick with python - wants more joy from the language? then use ruby
I'm primarily a Python programmer but I much prefer most of Ruby's syntax. Just a couple of things I actually have to disagree with here. &gt; virtualenv I make no claim of virtualenv being perfect, but I have to admit I've had significantly more issues with bundler than virtualenv. &gt; Decorators I've actually wished these existed in Ruby. There's no equivalent in Ruby. One of the key things decorators do is that they are evaluated first on file load. I admit this property isn't always useful, but when it is there really are not any _clean_ alternatives. Examples of things this makes trivial: Pub/Sub, Plugin systems. &gt; Explicit return instead of everything an expression (Ruby) This can be nice but is often insidious. People often return things from functions/methods they didn't intend do such as references to internal structures, etc. This can cause a lot of issues when gems are updated, especially when the Ruby community is so reliant on the code itself being the documentation. If data is returned from a function/method, intentional or not, people will use it. ---- That said, a few of the reasons mentioned really stand out to me as a Python developer. &gt; Crippled, single-expression lambdas Congrats, you've stumbled upon my absolute most hated thing about Python. &gt; Quoted string dict keys instead of :symbols (Ruby) There are days I'd have considered killing to have tags/symbols in Python.
My only gripe with python is the whitespace 
It's worth mentioning that Ruby does have some very well developed scientific tools (see sciruby.com).
Add Vagrant too
In Python you have Django, Flask &amp; Hyde. Also as Django was released before RoR, wouldn't Rails be following in the footsteps of Django? ;) Nor would I say Ruby rules supreme on the web. Python is used a lot too; Mozilla, Instagram, Disqus, *Reddit*, Youtube, Dropbox, Quora, Pinterest, Bitbucket, and so on.
I'm wondering if instead of philosophy the stated "Ruby expressiveness and Python correctness" - a result of the different type of users. My assumption that average python user scientist would care more about correctness rather than the average ruby web developer and recognized bicycle inventor.
&gt;There are days I'd have considered killing to have tags/symbols in Python. There are days I really wished Ruby would have first-class **Enum** support (string-based type), as well as first-class **Option** (struct of enums). Then you would get type safety you don't get with strings. Bonus points if you could "case" on Option with "any/all/none" matcher. But using untyped symbols doesn't solve any problems that exist with strings (except saving on typing quote chars), and yet makes you feel the full pain of expecting input which could be either string or symbol, with different APIs. Especially relevant in web/network world where external input comes in as strings.
I had no idea AR can't even manage 1k tps writing most likely 2-4 columns—definitely worth the effort to illustrate. It would have been much more useful to understand the proportion of time dedicated to serialization vs waiting on io.
When you need to hire someone.
Ansible is Python
Rails was tracking with web standards a lot better than Django. Spent a year writing Django after 3 years of Rails and was regularly frustrated when I couldn't do what I had come to think of as modern web dev in Django.
Nope, completely different things. :)
All good points.
Are you working with a web application? A gui? A command line?
Actually, I was hoping to see another benchmark "proving" that eval runs code more slowly than typing it directly into a source file by failing to account for differences in the implied algorithm.
I went from RubyMine -&gt; Sublime -&gt; VS Code. I moved on from RubyMine because it decided to spend 100% of my cpu indexing files non-stop for hours even on insanely small projects. I use a good computer for development, so the churn was unexpected. It's nice to have the plugins for Ruby, c#, go, all together so easily, but I miss a lot of features that rubymine had for rails/javascript. Overall, vs code is not that different from Sublime, but does provide a few more features. Not ruby specific, but it is nice to run and debug my c# and go code so easily.
I'm well aware and you're right, that works perfectly _in theory_. In practice however you don't have to spend too much time in the gem ecosystem to realize that this isn't actually common practice. Unintentional return values, unintentional return values everywhere!
No there is no reason to forget about Python and focus on Ruby. But that's just me. Personally I strongly dislike Python and love Ruby.
I move more or less daily among PHP, Javascript, Objective C, Swift, Rails, Java, and occasionally C++. I have an interview for a ruby gig today. My ruby is a little rusty. Switching languages takes a little time. For a little while I have to look up how to add to an array, how to stick something into a hash. What an array/hash literal looks like. What are the loop/iteration forms again exactly? Which quote characters are valid and which do they mean? Occasionally, I find myself mixing language constructs up like using single quotes in C or curly brackets in ruby functions instead of end. So it would be nice, for my interview, to have all that shit handy so I can refer to it quickly. That's why. Sheesh. I found https://www.dotnetperls.com/ruby - its pretty dang good.
Interesting that this was downvoted, but there were no comment replies. Your reasoning seems clear. As a PHP dev learning about Ruby, I do have to agree with your last point about packages being kept locally within the project vs globally somewhere in your user profile. I find it much easier to understand the workings of a third party package when you can easily peruse the code within your IDE.
Another thing I haven't seen anyone mention: My day job involves coding in Java, Ruby, Python, and JavaScript. It's easy for me to switch between Java / Ruby / JS. They all have a nice hybrid OOP / functional style (since Java 8 and ES6 at least) and there's little cognitive burden. On the other hand, I wince every time I have to switch to Python. Even within my single company, code organization in Python is all over the place. It's the only language in that group that seems to actively resist / punish standard one-class-per-file code organization. I end up needing an IDE for Python more than Java, which is really amusing to me. Then there's the v2 vs v3 thing. When we adopted Java 8, everyone quickly got on board. Same for Ruby 2.3+ and ES6. Python? Nope, half of that shit is still v2. I feel like my company is a microcosm of what's wrong with Python.
[String concatenation](https://www.techotopia.com/index.php/Ruby_String_Concatenation_and_Comparison), it's adding the value of `aGoodThing` into the string you're sending to `puts`. So if `aGoodThing = 'reddit'`, `puts` will output: "I \*really\* like reddit!" You can also use [`String#concat`](http://ruby-doc.org/core-1.9.2/String.html#method-i-concat) to add to the string, it's a little more verbose than the plus operator, but it can be useful to show the concatenation intent. Further edit: You can also interpolate the value directly with `#{}` like so: puts "I *really* like #{aGoodThing}!"
I think the example in the OP is confusing because somebody avoided spaces where one would normally expect them: puts 'I *really* like ' + aGoodThing + '!' 
The last example using double quotes is the preferred style in the Ruby FOSS community.
yuppp
It looks like they pull their info from the awesome rubysec database at http://rubysec.com/ You can check a specific app's Gemfile from the command line for free with [bundler-audit](https://github.com/rubysec/bundler-audit), which uses the rubysec ruby-advisory-db too. 
&gt;I have light understanding My first instinctual response is pretty much "fuck you". But maybe that's not quite adequate. Over the course of my career I have worked deeply and exclusively in each of those languages for over a year at a time and I learn very fast. Now I maintain a lot of different systems in each of these different languages. Sometimes, I get rusty in one if I haven't used it in a couple weeks and I find myself mixing up syntaxes. But make no mistake - there is nothing shallow about my skills or experience. Your language example is shit, BTW as many multilingual people will pull words from the wrong language if they haven't got the right one at hand and haven't used it lately. Spinglish is a thing for a lot of hispanics. In restrospect - maybe I should just leave it at "fuck you". Blocked.
Depends. Format becomes better when you're having to cast the things format('Downloading "%s": %i3.0\%', thing, progress * 100) Or you're doing something mashing like a hash into a string URL_FORMAT = "%{cdn}/%{version}/data/%{lang}/%{item}.json" @info = "this particular client's special hash" items_to_download.collect do |item| HTTParty.get(URL_FORMAT % @info.merge({item: item})).body end I think it's more useful if the `to_s` is awkward.
Why would it need guild support? Guild support is a means to enable true parallelism given the constraints of MRI. Remove those constraints and threads are fine.
As of now Crystal doesn't have any threading support so it's in the same position as ruby.
It's normal, and acceptable. Unit tests aren't supposed to reach out to external systems, like an ssh server, so you need to stub it out somehow. Having said that, you probably don't want to rely _solely_ on unit tests. If you want better coverage and more confidence in your tests, you need a couple of seperate end-to-end tests that actually _do_ connect over ssh. You don't need many, and you don't need to run them as frequently as the unit tests, but they are pretty important.
In last year's RubyConf keynote, Matz made it very clear that breaking backwards compatibility in a dramatic (Perl 6 / Python 3) way, especially without a smooth upgrade path, was absolutely off the table. In this year's keynote, earlier today, he also rejected type annotations and LLVM. Crystal is source-incompatible with all Ruby programs (other than trivial or contrived ones) and has mandatory type annotations in class definitions, and the Crystal team decided they were comfortable with this a long time ago. Matz and Ary admire each others' creations, but from what they have said, they are in agreement that the two languages are and should remain separate. They are different, and will probably continue to diverge, because they have different goals. Ruby will never be totally type safe or the fastest language. Crystal will never be the DRYest or most flexible. Also the concurrency models are not similar, Ruby is well designed but complicated by decades of compromise and legacy. The guilds proposal really exemplifies this. OTOH Crystal is sleek and modern but still needs a lot of work, and the single-threaded CSP implementation exemplifies that.
&gt;I don't get offered the job. I get told I didn't 'pass the tech interview'. Which is bullshit. But I think the person doing the interview is just afraid of not being top dog anymore. checks out,
Actually got it - but thanks for your opinion random low information poster on the internet. Your valuable insight is duly noted.
So, if you're talking about the `select` in `Enumerable` you're referencing something called "symbol to proc". Essentially the basics of it are that the `&amp;` invokes a method named `to_proc` on the object next to it. For symbols this is [implemented](http://ruby-doc.org/core-2.3.1/Symbol.html) as something that looks like this: class Symbol def to_proc Proc.new do |obj| obj.public_send self end end end What this method is doing is returning a new `Proc` that, when called with an object, invokes the method with the same name as the symbol on that object. `select` takes a block (or Proc), invokes it on every object in a collection, and returns the ones where that object returns true. Conceptually you could do this with nearly any object. Here's an example of a class that truly never helps you: # This class refuses to do anything helpful, ever. class NoNoNoNo def to_proc Proc.new do |obj| false end end end n = NoNoNoNo.new [1,2,3].select(&amp;n) =&gt; [] In practice ... you probably don't want to do that. People will have a hard time understanding the code involved since custom implementations of `#to_proc` are extremely rare.
Is it just me -- this post has lowered my faith that there was a plan that could approach the stated speed goals. 
I think it's called "double dispatch"
When you do `select(:reverse)`, you're not passing a function as an argument. You're passing the *name of* a function (a string, more or less), which will then be used to dynamically find and call the method of that name. This is in contrast to something like Python or JS, where you can actually pass the method itself. 
I think the following property should hold for `map_by`: `a.map_by(key, *rest).map(&amp;:first) == a.map(key.to_proc)`, but it doesn't for `rest == []`. Expressed in other terms: The return type of your method depends on the number of arguments which makes generic use very hard.
Single method libraries are probably not used much in the Ruby community, though they seem to be used in the Javascript (the famous String#blank? comes to mind). Personally, the hassle with dealing with such a dependency far outweighs the benefits. I would probably just implement such a method in a utils module inside my project if there is a need.
Having a CoC in Ruby as a language doesn't have anything to do with how a specific gem/project/whatever is handled. It doesn't even mean that CoC's in general are bad. And I don't think it was "proven", since Ruby **did** end up with a CoC anyway and from Matz comments I would say he was never against it, but rather inclined to a specific version. You should maybe be more argumentative, because "ridiculous" and "useless ideas" are not really a base from where you can make critics to something that is actually trying to stop people from behaving the way you are right now. 
Nice write-up! [Sonic-Pi](http://sonic-pi.net/) is a great introduction to programming from music; or music from programming. And the community has been pretty great, too
i would prefer if people returned self, over nil, so chaining can continue. but that said, why do so many ruby programmers not consider the return value? it begs for an explicit return and implicit self/nil return. 
 irb(main):001:0&gt; array02 = [] =&gt; [] irb(main):002:0&gt; array02[3] = 4 =&gt; 4 irb(main):003:0&gt; array02 =&gt; [nil, nil, nil, 4]
Thanks! But lets say I don't know what that index is. Lets call it "x", something the user would provide. I'm looking to match "x" to indexs of array01 and copy it to array02 at the same index if there's a match. 
https://ruby-doc.org/core-2.2.0/Array.html#method-i-find_index idx = array01.find_index(4) array02[idx] = 4
The plan for Crystal is to enhance the scheduler so that fibers will run on different OS threads, but it's unclear whether or not Crystal will offer direct access to plain-old threads. It's kind of interesting that neither project is at all satisfied with plain-old shoot-yourself-in-the-foot threads. Guilds come with an ownership model, and Crystal has channels.
I appreciate you're help totally but just posting syntax doesn't help me understand what's happening. Thanks again though.
Yes! I definitely used that so I'm sorry for not mentioning it on the post. I'll update it now - thanks for writing the book.
Well I could say just asking for one tiny little change at a time doesn't make me understand what you need :) What is it you want to achieve and what is it you don't understand?
And here I thought that "writing a C extension for Ruby in 2016" was "write it in Rust" :D
&gt;new Gtk3 demos have been added &gt;http://ruby-gnome2.osdn.jp/hiki.cgi?Samples &gt; Last modified:2011/06/11 10:12:05 Could you link me to where the new ones are?
Hosting. However, you can host Ruby on a lot of cheap hosts now so that is less of a big deal. It still requires more maintenance and setup on most hosts.
=&gt; https://github.com/rustbridge/helix
I wish there was something similar for Qt 5/KDE 5. It'a a shame that they went all-in with ECMAScript.
Serious question (and I'm not trying to be mean): What does your code look like without methods?
I have updated the post. I think it looks gr8! No problems at all =D
I have updated the post and have shared some code. It's beautiful right???
I don't intend to be mean but, [this](https://github.com/styleguide/ruby) is 100% worth the read. If nothing else it gives you an understanding of what good code should look like.
So looking at your code, it seems that you are not familiar with Object Oriented Design. Your code is entirely procedural, meaning, it executes from top to bottom once. It's not reusable, it's not extensible, it just **is**. The reasons you want your code to be Object Oriented, which in turn requires you to create methods, are many, but some of the primary ones are: * It makes your code easier to organize * It makes your code easier to understand * It makes your code more maintainable * It makes your code more testable * It helps you reduce complexity, reduce duplication, and just simplify your code overall. Those reasons especially fall into place when you are designing something that is clearly Object Oriented, that is, something with real world counterparts. I could go into more detail about OOP, but there's *plenty* of resources out there. I'd recommend reading [Practical Object-Oriented Design in Ruby ](http://www.poodr.com/), but like I said, there are plenty of resources out there. OOP is definitely something that programmers struggle with when first learning, but once you grasp it, you quickly learn how powerful it can be. 
I was under the impression that code is meant to read top to bottom? :$ And you're right I keep hearing that Ruby is OOD related but I never really bothered to see what it meant... That book is a bit pricey but I'll definitely lookup OOD stuff.
`update_worth(Items)` should work if you call it right after your array creation. It's a global method there, so what are you doing? def foo(bar) puts bar end bar = 'foo' foo(bar)
I'll take a look at it, although I'm mostly interested in figuring out methods first
This is exactly the kind of code that everyone writes when they're just starting out. A lot of people refer to it as procedural code, where everything just kind of executes in order and there's a lot of repetition. I recommend reading about Object Oriented Programming and Ruby, it'll probably speak to you.
I thought that there were ruby bindings for Qt, did they stop to create those bindings?
I'm glad people are being nice to you about this :) You should really get yourself a copy of Practical Object-Oriented Design in Ruby. It'll really make things much clearer, and I think you'll find writing Ruby a lot more fun as well.
using that you need to know rust and ruby c api?
People have given you some practical reasons why functions (and classes) are useful. I'd like to share a more philosophical motivation. (Also: holy wow, your code. It's remarkable how neat and "together" it is despite your not using functions.) What you are currently doing is solving a problem. What you could be doing is **building a machine that knows how to solve a problem**. It sounds like extra work, and if we were talking about a physical machine, it would have been. But making code is cheap! You don't need to buy spare parts, you can make them almost for free. But what's the benefit? Well, if you have a machine that knows how to solve a problem, then you can tweak it just a little bit to make it solve a different problem. And if the machine gives the wrong result, it's easy to check whether each individual part is doing its job correctly.
&gt; PHP is faster. Is it really? Maybe in benchmarks on certain things but in general? The lack of an application server adds a lot of per-request overhead, no? &gt; PHP is an easier codebase to maintain. I saw your point on dependencies but I personally never had a problem so far. Talking about code I guess it's pure preference. &gt; It's easier to hire 20 PHP developers that can jump in on a project than it is to hire 20 Ruby/RoR devs. Did you ever try? We had no problems whatsoever, we didn't had the need for 20 though but we had more than enough candidates. We even had PHP/Java programmers working on Rails projects after 2 weeks. &gt; It's blindingly simple to scale a highly available PHP application. Any different than with &lt;insert any language&gt; applications? You add more workers/machines, the first bottleneck most people will encounter is the or a database. &gt; You can host a PHP application anywhere and do it in an hour if you take your time and then scale out to anywhere for thousands of concurrent users in a few more hours. I give you the "PHP works on 99% of webhosts" but then again if you are doing something serious you have a proper hoster (and ruby has pretty good coverage nowadays) or a dedicated server and setting up ruby is as easy if not easier than PHP imho. --- I don't know if I don't count because I have about 8 years experience with Ruby by now but it was years ago when we survived TV-spots on prime time with a single server for 80€/month (and a TV spot creates [HUGE spikes](https://www.youtube.com/watch?v=zvm1BU8XgLs)) with no downtime whatsoever whilst all investors and the TV channel predicted our server to crash for no good within seconds. Now we have 2 rails/DB servers and 2 loadbalancers/asset servers one of which does absolutely nothing but waiting to takeover in case the other one dies. So 4 servers in total but only 3 are doing something (and we talking ~80€/month servers, no magic super server). We have good traffic and due to botnets trying to crack accounts even more so. First step would be to give the DB a dedicated server and add more WWW workers. Plenty of room to scale and it's easy as pie. Oh and an average page generation time of 110ms on the front page (which is loaded).
Not POODR. It's a great book, but it shouldn't be a first OO book.
No. Lets say I'm an intermediate Ruby dev, POODR first or Confident Ruby?
Your code is pretty ok. An experienced software engineer would do a lot of things differently, but that's a matter of experience and doesn't matter much at all. For experienced engineers doing it 'right' the first time takes very little effort, so they'll say it's worth doing it right immediately. But if you're less experienced figuring out which things should be abstracted more and in which way can be a lot of work that does not necessarily pay off. If this code will become part of a larger system (like for example a web application) then it will become more important that you make it more flexible. But if this is just a one-off tool you use to parse some stuff and then continue with your life then the code is great as is. Just a small hint for where you might employ a method in this specific file: puts "Thank you for voting! Remember that voting twice is a crime!" puts "Press enter." did_vote = true can_vote = false cand2votes += 1 gets This should be in some methods. You repeat it a lot of times, and it has some behaviour you might want to change like the voting message or the way people make the vote. Note that setting the local variables can't be done from a method, so that should either be in a closure or you should totally rearchitect and make your behaviour into a class. There is a great talk about this by Sandi Metz located here: https://www.youtube.com/watch?v=8bZh5LMaSmE She starts out with a very long method, comparable to your large procedure, and she explains why and how she refactors it to be just a couple of easy to understand lines. In my opinion it's one of the greatest software engineering talks around. I definitely recommend watching it if you have 45 minutes to spare.
I don't think it should be anything _but_ a first OO book. It seems clearly aimed at people with no background doing OOP.
That is sad for ruby and other languages. The dev of Gnome created GObject and GObject-Introspection in order to make easier the creation of bindings and this is really great.
Wha?!
Good article! I wish more programmers had a stronger grasp of probability.
Thanks! I could do one on bayes rule. If people keep reading em' i'll keep writing em'. 
I think it's aimed at people who have used an OO language and have some idea what methods are, as well as *some* mental model of objects, even if it's not an accurate one for Ruby. The first chapter of POODR is about what *design* involves, and there are literally only two and a half pages introducing Object Oriented programming – and covering a lot of ground, as it even gets into the fact that classes are themselves objects. Then it immediately jumps into Designing Classes with a Single Responsibility. The chapter after that is about dependency injection. It's a great book – I meant that when I said it the first time – but all of that is going straight over the head of this OP, at least. It's not the right book for a basic introduction to what OOP means and looks like.
Haven't read Confident Ruby, but if you're comfortable calling yourself intermediate, then POODR is a must read.
without watching your linked video I'll attepmt to shorten the thing you showed #ruby stuff to determine if invote can be a vote def wow_a_voter (invote) puts "Thank you for voting! Remember that voting twice is a crime!" puts "Press enter." if invote == "1" cand1votes += 1 end if invote == "2" cand2votes += 2 end #repeat above until 5 gets end #at end of function call did_vote = true can_vote = false I think thats how it could be done? :S Now that I've watched that video, I have determined that it all seems useful but I don't know how to do any of it :c I'm sure ill learn eventually
Thanks!
okay, after I figure out methods maybe I'll take a whack at classes, assuming i Dont get too confused :p
Ruby in Twenty Minutes tells you how methods work better than I can : https://www.ruby-lang.org/en/documentation/quickstart/2/
I'm trying to think out how I would make a machine know how to do... the things I'm trying to do. And the things I'm trying to do is pretend to be a government &amp; private sector? Not exactly but kinda. This maybe due to my lack of inexperience with Ruby or coding in general, but I honestly can't see how I would build a machine that knows how deal with end results of lets just say minor government stuff (like voting &amp; the national ID). Solving the problem of getting results then doing something with them myself, I can imagine. But I figured I should learn some other things that ruby can offer like methods &gt; (Also: holy wow, your code. It's remarkable how neat and "together" it is despite your not using functions.) I make extra sure that I can understand my code when I go back to it in less than 10 minutes. I have gotten lost in my code before... and that sucks!
They have some definition to the goal: optcarrot (frame rate?) should run 3x faster than Ruby 2.0.
Is it feasible to implement these changes in pure Ruby code? Thus, the implementation could be shared between Rubinius and JRuby.
Generally we are fine with any patch being in Ruby or as Java. Most Ruby code isn't a perfect concern, and getting the functionality in is most important. See core/src/main/ruby in our codebase.
Is there anything anyone with only a bit of experience in Java and Ruby can do? I just started programming a few years ago and I'm still in school. I can make basic web apps and mobile apps but I've never done any systems programming. That said, multithreading makes me moist.
Haha no, but I think it just reminds me how nice some people in the Ruby community can be. In another context, this post would have been flamed to hell by mean spirited posters.
The two are exactly the same (except that sometimes you need parenthesis because otherwise things are parsed as if they are part of a parameter/surrounding function call, this can be the case with blocks or if you have a method call as one of the parameters). E.g. `mystring.gsub! /apple/, "orange"` works as well and so does `print("Hello world")`, and `print mystring.gsub /apple/, "orange"` is the same as `print(mystring.gsub(/apple/, "orange"))`, but obviously the fourth example is preferrable to the third one (I had to check in ruby what it would do).
That particular method will run into some issues with variable scope, but you've got the right idea. Here's a very simple, practical example: def prompt(text) puts text return gets.chomp end Then elsewhere in your code you can write things like: firstname = prompt "What is the first name (Capitalize first letter)?" lastname = prompt "What is the last name (Capitalize first letter)?" Now, in the future, if you want to change the way you prompt your user for information - perhaps you decide that `strip` is preferable to `chomp`, say - you only need to change one line of code and your whole program benefits. So your program is both shorter and more maintainable.
Yeah, things can get really confusing with this syntax if we start doing things like: {}.is_a? Hash &amp;&amp; 1 == 1 =&gt; TypeError: class or module required {}.is_a?(Hash) &amp;&amp; (1 == 1) =&gt; true I sometimes wonder what's the best practice regarding calling methods in ruby
This is some pretty Java-ish looking Ruby. 
Well, why don't you just pick one style and stick to it? It's not the language that is being inconsistent here, but the way you use it.
Both. Spaces instead of parentheses is prettier, but can introduce ambiguity in nested or complex calls. Ruby also supports implicit hashes *and* keyword arguments, so method calls get even more fun. I really appreciate Ruby's syntactic flexibility, honestly. It feels like a good fit with how flexible the language is overall. ____ One thing Ruby very much is not, in any way, is "just pick one". You'll start seeing that *a lot*. You're welcome to pick one and stick to it, but the language itself will have multiple options.
The don't use terms like 'moist', it's a micro-aggression. Or something. idk. It doesn't matter anymore since trump 2016. lol, Trumps going to lock all the SJWs up! 
Yeah, thats why I choose to bleed charisma! *Aaand* act like they're my friends! haha! But this subreddit does seem nice though, being nice is important for newcomers whose feelings can get hurt easily, and other people who merely glance at the community to see if there is any kind of toxic people. Toxic people has turned me off so many different things... A lot of the posts I've gotten are helpful, so thats good :)
I don't know exactly, but presumably because that's too major a change to be included in a `v2.3.1` --&gt; `v2.3.2` version bump. After a little research, I found [this commit](https://github.com/ruby/ruby/commit/9a21c28426e1021afd0f4d7314d707d578f60256) which updates rubygems to `v2.6.8` - which was [released](https://www.ruby-lang.org/en/news/2016/11/09/ruby-2-4-0-preview3-released/) as part of ruby `v2.4.0-preview3`. We can expect to see ruby `2.4.0` released on Christmas Day, as this has become somewhat of a tradition.
Imma use my gay card. Bam. Now I'm allowed to use words like moist.
I think there are some good ideas with these patterns that can translate to a dynamic language like Ruby however the examples you chose are not real examples. I think it would be a lot more beneficial to the readers of this subreddit if you used examples based on production code you wrote for your clients.
I would start by setting up a toy Rails application using a tutorial you find online. I think that will give you a good idea of what commands you are likely to find in your own project. One of the nice things about Rails is that most projects have similar setups (at least in the development and test environment). If there is a file called `.ruby-version` that will tell you the version of Ruby you need (or the version that is most likely to work). This might also be in the file `Gemfile`. The `Gemfile` will also have the version of Rails that the project uses.
Interesting. Thanks for clearing that up.
It's mid-november and we just got a x.x.2 release. 2.1 is already on patch 10, 2.2 on 5. If the release planning hasn't changed from previous years, I'd say ruby is showing signs of stability, which is only a good thing. 
[Except when calling `super`!](http://stackoverflow.com/a/5147548) Totally hate this feature because it's non-obvious.
I'm just curious. How long have you been code with Ruby? What language did you use before Ruby?
I've been with Ruby for like 2 years? Probably more, but I dont remember. But it was mostly an on and off thing, on being weeks of coding and off being months. Until recently. I pathetically tried to learn C# once, that was fun. Same for Java, C++ but gave up... For some reason :\ I used to be super gr8 with the windows cmd coding thing, but gave that up because cmd coding thing wasn't cross platform so I could'nt do my [leet awesome hax ](https://i.imgur.com/Q8ZNXS8.jpg?1)on school computers anymore. Those days were fun... 
Gosh i love how Hanami is turning out. Silliest of silly questions: Hanami is an all-or-nothing framework, right? I've inadvertently started adopting Trailblazer because parts of it can be integrated (e.g. decorators) without swallowing the whole framework. Any chance that is possible with Hanami?
To me name and id are two totally different attributes. Finding it hard to name may indicate that mapping is confusing itself. Maybe you're making it overly encapsulated for a small matter. Just return the id value. 
I would call that user_data
I wouldn't say Hanami is all-in ... but that might depend on you definition. Hanami Model ReadME &gt; Like all the other Hanami components, it can be used as a standalone framework or within a full Hanami application. Coincidently, I noticed this repo today https://github.com/apotonick/gemgem-hanami And the trailblazer readme says: &gt; Since Trailblazer decouples the High-Level Stack from the framework, it runs with virtually any Ruby framework. We are constantly working on documenting how to do that. &gt;Trailblazer with Hanami - coming soon!
No, you don't have to use all of Hanami. For example, in one project I'm working on, I just skipped the model layer altogether and am just using Sequel without any problems. (Admittedly I'll have to figure out how that works with 0.9.)
single responsibility principle. is that what you were asking? when using sequel, i don't like that every entity (model) can change the database itself. and making entities with an activerecord pattern isn't dry. 
I am certain Trailblazer will work with Hanami, and also be officially supported. I worked with Nick Sutterer, the creator of Trailblazer, very briefly to create a hanami-trb demo app, but it's probably out of date already. He personally prefers Hanami over Rails. 
Hi you can follow these fews steps http://hanamirb.org/guides/models/use-your-own-orm/ This is updated to v0.9.0
&gt;single responsibility principle. is that what you were asking? I don't think single responsibility means that every entity has to have it's own repository. A repository is by definition something that holds different things. &gt;i don't like that every entity (model) can change the database itself. and making entities with an activerecord pattern isn't dry. 1. Why don't you like it. Something has to change the database. Why not consolidate your change code in one place where the change takes place. 2. What do you mean not dry? Looking at the code samples it's much more dry.
&gt;A repository is a storage-independent object that "mediates between entities and the persistence layer". Ok but why does every entity need it's own repository? &gt;We could do, and have done during development, "persistence" as reading and writing CSV or YAML files, with no knowledge of the actual persistence mechanism leaking beyond the Repository layer. You could do the same thing without the repository pattern. &gt;Need to migrate to a hypothetical NooTrendy.io service API? I believe there is a thing called ActiveModel which does exactly this. &gt;my experience doing considerably less ambitious things with AR has consistently been that the corner cases bleed you with a thousand chainsaw cuts that you expected to be a dozen paper cuts. It seems like claiming Hanami has no corner cases is a bold statement. I am betting that it just has different corner cases which are also going to bleed people. &gt;Design matters. Yea but I am not saying there should be no design. I am asking why this design is better than all other designs. &gt;Especially if you're working on a system that's going to live a long time, or that is at risk of needing to scale quickly. The DDD Repository pattern, which is what I understand Hanami to be using a variation on, helps you do that survivably. Rails has been around a long time. There are countless large apps that have lived a long time. How can you claim Rails is not capable of doing that "survivably"? The way I see it this is just a new fad. The Dry-rb people read a couple of design pattern books and decided to implement J2EE stuff in ruby. So now you have endless scattering of code across endless files and endless levels of indirection and layers of code. In addition to being entirely too verbose it makes it super hard to understand what is going on. Customer calls, complains their balance is wrong. Now you have to look at fifteen layers of abstraction to see exactly where the problem occurred. 
thanks!
The announcement (as usual) just says "See the ChangeLog for details", but does anyone actually know how to figure out which items in the [ChangeLog](http://svn.ruby-lang.org/repos/ruby/tags/v2_3_2/ChangeLog) pertain to this release? I.e. how to find out what are all the things that changed since the 2.3.1 release? Or is everything in the ChangeLog, going back to Thu Dec 25 16:14:10 2014, *not* present in 2.3.1, but present in 2.3.2? Sorry if that's a stupid question...
&gt; Ok but why does every entity need it's own repository? Because you want to keep separated the queries/commands for a given database table. To give you an ActiveRecord analogy, you don't create all the scopes in a single AR model, but you split them according to the database table. So `User` defines scopes/queries/commands, for `users` database table. In Hanami it's the same. You use `UserRepository` to define queries/commands for `users` database table. Both Hanami repositories and Rails models have a one-to-one relation with a given database table. &gt; I believe there is a thing called ActiveModel which does exactly this. Kinda. ActiveModel doesn't have adapters, while ROM has plenty of them: http://rom-rb.org/status/ Hanami::Model is based on top of ROM. For now it only supports the SQL adapter, but it will support all ROM adapters in the future. &gt; It seems like claiming Hanami has no corner cases is a bold statement. True. 
objects are lovely, but they wouldn't allow me to quickly access values of multiple users given only a name, so O(1). i'm imagining i'd end up with a data set like [user_data_object, user_data_object] which would end being an O(n) lookup. right?
It's hard to say without seeing your exact code an use case. I think this is the perfect case for an object. Hashes are fast and do exactly what you need, but the readability is less than clear. You can make a class that exposes an explicit API then when you're using an instance of that class, you don't have to worry as much about trying to remember how the data is stored, you only have to remember how to use the api. You still have the hash naming problem, but at least the method gives you context about what you're expecting to get back: class UserSearch def initialize(user_hash) @username_id_hash = user_hash end def find_id(name: ) @username_id_hash.fetch(name) { raise "No such user #{ name }"} end end user_search = UserSearch.new("schnems" =&gt; 4) user_search.find_id(name: "schneems") # =&gt; 4 on the topic of naming intermediate data structures, I like adding `_hash` or `_array` to the end so that it is a little more clear how it should be accessed. At a glance it could be confusing for example if you have a hash with integers as keys, or you're indexing an array both could look the same in the source code output = variable[5] If it was `variable_hash` it would read a little better for me and help prevent the facepalm errors where you're using one data structure, but you think it's another. 
Maybe `user_data_hash`. Or `username_id_hash` but the longer it gets the harder it is to fit in your head.
Subclassing and delegating to hash are WAY slower: class Foo &lt; DelegateClass(Hash) def initialize(foo) super end end looks_like_a_hash = Foo.new("sup" =&gt; "baz") acts_like_a_hash = looks_like_a_hash["sup"] # Way slower than a hash require 'benchmark/ips' hash = {"sup" =&gt; "baz"} Benchmark.ips do |x| x.report('delegate') { looks_like_a_hash["sup"] } x.report('hash ') { hash["sup"] } x.compare! end # Warming up -------------------------------------- # delegate 92.746k i/100ms # hash 164.586k i/100ms # Calculating ------------------------------------- # delegate 1.042M (±15.6%) i/s - 5.194M in 5.123109s # hash 4.795M (±22.2%) i/s - 22.548M in 5.005388s # Comparison: # hash : 4795338.3 i/s # delegate: 1042306.6 i/s - 4.60x slower If you're going to delegate because you need it to act like a hash, I would simply use a hash for the speed. If you don't need those features, I would use an object for the usability.
Frankly, I prefer to provide simpler abstractions instead of applying exactly what is on the DDD book. DDD isn't always justifiable for small projects. That stuff has an harder learning curve than repositories, which are still a better than AR models. Also, this would keep out totally beginners. People &gt; Design Patterns 
&gt;Because you want to keep separated the queries/commands for a given database table. Again why? Your answer seems to be "because!". Why not put each repository in a class and have the repository deal with all types of persistent objects? &gt;To give you an ActiveRecord analogy, you don't create all the scopes in a single AR model, but you split them according to the database table. So User defines scopes/queries/commands, for users database table. I like this. It keeps all relevant code about a model in one place. It makes it easier to track and reason about your code. &gt;In Hanami it's the same. You use UserRepository to define queries/commands for users database table. Both Hanami repositories and Rails models have a one-to-one relation with a given database table. In hanami I have to create at least two classes for reason that I can discern. I am asking what the reasoning is behind this. 
This is great. Thank you.
Great news. A while back I've put together the Planet Ruby. You're are more than welcome to (re)use the sources, see &lt;http://planetruby.herokuapp.com/sources&gt; or &lt;https://github.com/planetruby/planet&gt; Keep it up. Cheers. PS: For putting together your own news reader/planet site - an alternative option is the [planet pluto feedreader gem](http://feedreader.github.io) in Ruby. 
If an object is allowing you to access data and also in charge of persisting it, then that is two responsibilities. This first causes some conflict if you want to add another persistence strategy. Imagine we wanted our object to be loaded/stored either from an api (load), database (save/update), or memcache (copy). Which one would the model be responsible for -- all three? Would the object need three find methods? A better solution would be to have multiple repositories that were independent of the common reader object. That would work out even better if the repositories don't all share the same attributes (e.g., api has uuids, but you want to use integer ids for your database). Another danger is that if your model lets you read variables and also persist, someone else in your team/organization might get clever and try to write to the database themselves. By separating these responsibilities, you could give a copy of your reader object to others, and deny them the repository object. I realize that many folks find this irrelevant because they are tied to the rails way of dong things. But I also feel that many developers don't try to explore new ways of doing things precisely because the rails way dictates a one-repository model paradigm.
Yep, you're right. About using. I wrote that some tips is just interesting solutions and allocate is one of this :)
Not even for testing logic inside objects with extremely expensive initialization that gets in your way? One quick `allocate` and you're right where you want to be. No need to copy/paste your way into a maybe-working test object.
Force closing upon launch for me. Android 7.1.1 on Nexus 5X.
Hi! What did you try? If you have trouble, please open a ticket at https://github.com/ruboto/ruboto/issues
the only issues is that the redhat seems to stop http://torquebox.org/ development. There is no activity there
Actually I think I misunderstood what Ruboto was. I was trying to install the "Ruboto Core" app from the app store and launch it. I wasn't aware Ruboto was a full framework.
We'll have to look into that!
Oh bummer, I had my hopes up.
Yeah, I had 10 seconds of "Holy shit that is awesome!" followed by "Wait...that is TOO awesome :("
Thank you Confreaks for producing and publishing videos of a number of tech conferences. I am aware it takes a lot of work, attention and strong intention to produce such volume in high quality. Your sharing your work with the world shows your commitment to the tech community. I have deep appreciation for your service. 
I am using prawn table in https://github.com/strzibny/invoice_printer but not sure what styling do you need?
But these things behave differently. irb(main):001:0&gt; 10/4 =&gt; 2 irb(main):003:0&gt; 10.to_bn/4.to_bn =&gt; [#&lt;OpenSSL::BN:0x0000000202ca40&gt;, #&lt;OpenSSL::BN:0x0000000202c9f0&gt;] The divisor only returns a remainder on Bignum. 
&gt; 1500 entries in a database selecting only 100 Are you sure? - node has limit 100: https://github.com/llaine/benchmarks/blob/d2d75126fcac126944192ad0c2b8df43518c0a23/express/app.js#L12 - D has limit 10: https://github.com/llaine/benchmarks/blob/d2d75126fcac126944192ad0c2b8df43518c0a23/vibed/source/app.d#L23 - JRuby has no limit: https://github.com/llaine/benchmarks/blob/master/ruby/app.rb#L28 This benchmark is useless.
i would call it by what it's returning: user_id. that way, when you use it in your code, it's clear what you are actually passing. 
`Company` is actually just a plain class, which defines [`.all`](https://github.com/llaine/benchmarks/blob/master/ruby/models/company.rb#L3) to return records with 100 limit. But I agree that D should be updated to 100.
http://jerodsanto.net/2013/10/ruby-quick-tip-easily-count-occurrences-of-array-elements/
Yea just as daborious said its not really a good idea to do that. When you delete an item on the next iteration the index will increase but some of the items might have shifted in the array so you never process them. If you check out your array at the end of the block it will contain the remaining 3's that are needed to get your pair count correct because they are never run through your block. I would go with annoyed_freelancer solution or something like this. I just threw it together so not that great. But it keeps track of matched numbers and checks against that instead of deleting them. matched_pairs = [] pairs = 0 c.each do |item| if c.count(item) / 2 &gt;= 1 pairs += c.count(item) / 2 unless matched_pairs.include? item matched_pairs &lt;&lt; item end end puts pairs 
Another option (and, for a server, my recommendation) is to use the brihhtbox ppa: https://www.brightbox.com/docs/ruby/ubuntu/
&gt;Every failed project looks like a scattering of code across "endless files and endless levels of indirection." More classes isn't what makes code easier to read, understand, and maintain -- it's fewer moving parts. That inevitably leads to more classes, but they must be organized in a way where you can ignore the details. Messy projects suffer from too many layers of abstraction for no good reason. &gt; I'm not suggesting this to belittle you in return, but to remind you that we shouldn't always assume that it's others that don't know what they are talking about. Back at ya buddy. Some languages force certain design patterns on your due to their structure and limitations. You don't code Haskell like you code Java and you shouldn't code ruby like you code in Java either. &gt;You have the same problem with ActiveRecord. No. Certainly not the same degree. As for callbacks well I don't know anybody who uses them like that but I guess it's possible. &gt;Oh, the balance is correct in the model, but the value we keep up to date in memcache is stale because the controller action taken by the user adds an account transaction but doesn't touch the account properly. Clear the cache and that will fix the problem. I like how you have to inject memcache into this discussion as if using ROM obviates the use the use of memcache and eliminates the problem. &gt; When the concern is encapsulated in one place, you know exactly where to look. Yea that's what I am saying. Put your code in one place, don't scatter it out all over the place in different files. &gt;Consider that not a single major bank in the world uses the ActiveRecord pattern to store balances. Yea they don't use ruby so what? Also bank balances are eventually consistent. They are not transactional. That's why it's possible to overdraw your account.
&gt; Messy projects suffer from too many layers of abstraction for no good reason. That is exactly what I see when I look at a giant pile of ruby on rails gone wild. They are messy for a different reason. A much more tangible one. Changes to any line of code have far reaching implications to the rest of the system. _That_ is an actual mess. You turn the ignition to start the car and tailpipe unhinges and drops to the ground. I've seen rails projects with hundreds of files in `app/models`. That's _guaranteed_ to be mess. I've seen projects that have thousands of files arranged in directories and subdirectories. That has the _possibility_ of being neat and tidy, depending on the skill level of the programmers. &gt; Back at ya buddy. I can presume you don't have any experience with ruby systems that have been designed better than what you get with The Rails Way, because otherwise your perspective would be different. &gt; Some languages force certain design patterns on your due to their structure and limitations. You don't code Haskell like you code Java and you shouldn't code ruby like you code in Java either. I don't code ruby like I code in Java. I don't even code in java. I code in ruby like I have to actually maintain the code I write. &gt; I like how you have to inject memcache into this discussion as if using ROM obviates the use the use of memcache and eliminates the problem. It absolutely is part of this discussion because it's a typical countermeasure for teams that have lost control of their database performance because they cannot manage the expansive list of callsites that traverse the database schema. You can't easily make changes to the database to improve it's performance when doing so breaks the interfaces of all your "models." So what do teams do? They put the data somewhere else where it can be queried efficiently, and use triggers and callbacks to try and maintain consistency. Put some control around data access (like what you get with ROM) and suddenly all sorts of better optimization opportunities arise. &gt; Yea that's what I am saying. Put your code in one place, don't scatter it out all over the place in different files. Then why don't you put your whole program in one file? You are suggesting that I meant objects should not be cohesive. That isn't the case. &gt; Also bank balances are eventually consistent. They are not transactional. That's why it's possible to overdraw your account. I write financial software in ruby, I am kind of an expert on this :) My point was that you can have as many moving parts involved with the ActiveRecord approach, even when you don't have as many classes. If you consider _how much code_ stands between `account.save` and the eventual `INSERT` or `UPDATE`, there's way more indirection involved with the rails approach than any system I work with today. Of course, you can then counter with, "well I don't really have to know or care about how ActiveRecord works behind the scenes." In a well designed system, _you can say the same about all those extra files you seem so offended by_, and with even more confidence, because you aren't using inheritance for code reuse. I've worked with many rails projects for years. Every single one of them turned into the exact same mess whenever features that didn't map nicely to data entry (e.g. CRUD) started experiencing significant churn. ActiveRecord begets models that are distinguished from another based on what table they belong to -- which is quite often the wrong design right out the gate. Frequently a single database table contains information from many different concerns. I don't think rails is all that terrible, if it's applied where it's most suitable. What I don't understand is why you're actively advocating against other alternatives that may serve quite a few projects much better than rails/ActiveRecord.
Gotcha, thanks.
What about Hugo? I'm using it right now. Very good one https://github.com/spf13/hugo
I figured it out. Apparently there is an issue with Ruby 2.3.1. Downgraded to 2.0.0 and it works.
seems like a step in the right direction
&gt;I can presume you don't have any experience with ruby systems that have been designed better than Back at you buddy. &gt;I don't code ruby like I code in Java. I don't even code in java. I code in ruby like I have to actually maintain the code I write. These design patterns are from the java world. &gt;Then why don't you put your whole program in one file? Because that would be as silly as creating a new repository for every class you want to persist. &gt;I write financial software in ruby, I am kind of an expert on this :) I have overdrawn my account so I am 100% certain it's possible to do so. &gt;If you consider how much code stands between account.save and the eventual INSERT or UPDATE, Ah this is a very powerful against using an ORM. &gt;I don't think rails is all that terrible, if it's applied where it's most suitable. What I don't understand is why you're actively advocating against other alternatives that may serve quite a few projects much better than rails/ActiveRecord. First of all you are lying when you say I am actively advocating against other alternatives. It doesn't really help you when you have to resort to such lies. I am advocating against THIS alternative. 
I just finished a fairly large project with Middleman and really liked it. Although, due to it not having the same level of users as Jekyll, I fear it will become abandonware in the future. I hope not though. It's a great framework. 
It's been around for a very long time and has its origin pre Jekyll. In addition, the developers are quite passionate about the product so I don't see it going anywhere soon 
Ruby 2.4 will show deprecation warning if `Fixnum` and `Bignum` constants are used directly allowing us to update the code. They will not raise error in Ruby 2.4. Additionally, libraries will take care of handling this in their code as well.
The hands-down coolest thing I saw at RubyConf was [this talk](http://confreaks.tv/videos/rubyconf2016-that-works-quines-and-other-delightfully-useless-programs) about [quines](https://en.wikipedia.org/wiki/Quine_\(computing\)) and other weird programming stuff. The demo at the end is *astounding*.
To OP: s/Nanonc/nanoc/
FYI: Hugo is great and included in the [Alternative (Language) Edition](https://twitter.com/statictimes/status/799705697776758785) poll - the (leading) candidates include: [Hugo (Go)](https://gohugo.io), [Sculpin (PHP)](https://sculpin.io), [Hakyll (Haskell)](https://jaspervdj.be/hakyll). Cheers. 
Middleman
Yes, the downside of Hugo include - no plugins (it's an all-in-one binary); the Go Template language is somewhat "special"; no (built-in) asset pipeline (e.g. css preprocessing, etc.) and so on. Cheers.
That's good to know because I definitely think it's the best one out there.
I've used Jekyll in the past, but have been using Middleman now for a site at work, at it's worked great.
Not very familiar with D but from what I can see both it and the JRuby tests should be using all both cores on the machine for application code, while the node setup is limited to one. Running a pair of node processes would be a more accurate comparison. 
...and yes, 1+3 says that classes and modules are also Ruby constans.
I mean, sure? It's pretty standard OOP.
But you can't appreciate happiness unless you go PHP first.
Question: I just started my first web dev job. I was hired based in my front end skills, but as it turns out they also need me to run the server back end. As in the server sits behind me and I'm expected to just learn how to work everything like I'm full stack. The last guy left behind a bunch of Perl books, so that's what I've been using for submit forms and captcha. Should I just ditch the Perl road before I get too deep and go Ruby? 
I am assuming that you are trying to learn these languages in the context of web development. If you have never learned a server side language before, there are a couple of things that you might consider before making your decision. Ruby is an object-oriented language. Seriously, everything is in an object. Therefore, you will have to have a firm grasp in OO. Now, to build web apps, you will need a framework like Sinatra or the more popular Ruby on Rails. Rails will do a lot of things for you and perhaps obscure some things. It is great to build apps, however, I feel that beginners learn how to type ruby in the Rails context instead of really learning Ruby and then learning Rails through that. PHP has been around forever. I believe that the current version is PHP7. One thing that makes PHP great is that you do not need a templating engine like a lot of other server side languages to render content. You can think of PHP itself as a templating engine / language. You can build web applications without a framework but I highly encourage to use one. Something like CodeIgniter or Laravel will help you build your apps a lot faster. My advice is for you to learn PHP first. You can download something like MAMP (a development tool that installs apache and mysql servers for you) and start building right away. PHP docs are good enough for you to look up things like functions and data structures implementation. Lastly, there will be a lot of information on the internet. Some of it might be good and some might not be so great. Whatever language you choose, take it step by step! All developers had to start from where you are right now. One good resource that I can give you is the harvard summer LAMP (Linux Apache Mysql PHP) course on youtube for FREE! https://www.youtube.com/watch?v=mVLdOBijoco&amp;list=PL8BGR1rr1-s57o_Jz_myzQQPUzlVBdBJ_
I've done both, but currently do Ruby. Both have their pros and cons, but I wish I had learned Ruby/Rails earlier than I did. One thing to consider is salary ( http://www.indeed.com/salary?q1=php&amp;l1=&amp;q2=ror&amp;l2= ). My suggestion is to do a tutorial in each language (and pick a decent php framework like Laravel) and then decide. We'll be here for help when you make your decision :)
&gt; PHP has been around forever Ruby and PHP have been around for about the same amount of time. It's just that Ruby didn't really take off until rails, which was in the last decade or so
You are right. But what I meant was that PHP has been used in web development for longer than Ruby.
Stay away from PHP. If you are the kind who looks for life-long improvement, then it will eventually eat your soul. It may take 10 years, but that's actually worse, because people will keep recommending you for PHP jobs. Brrrr.
Yep, I've oversimplified the thing :)
If you want to work in web development and don't want (or don't have possibility) to move far away from your city, I'd check the jobs postings available for PHP and Ruby in your area. Working remotely is an option, but it's not very common to see remote job offers for junior web developers (although they exist). PS: Ruby is my language of choice, but after 7 months learning it (as well as Rails), I just realized that 8/10 job postings in my area are asking for PHP and it's related frameworks. Edit: Added 'remote' and more text.
A lot of Perl books are based on the outdated CGI web model but there are a couple of decent Perl web frameworks, Mojolicious (http://www.mojolicious.org) and Dancer (http://perldancer.org) if you're forced to stick with Perl. Otherwise, go with Ruby on Rails or Sinatra depending on the size of the site.
Looks a lot like [clearance](https://github.com/thoughtbot/clearance). I'd be interested to hear what the author(s) think the advantages are over Clearance. 
Yes, if you're trying to earn a living or support a family the personal choice element goes out the window. There are way more jobs in PHP, Java and Javascript than Ruby so maybe it's best to learn these 3 first. Here in the UK Python is 4th after these 3 with about twice as many jobs as Ruby.
Damn, CGI is outdated?? Well, guess I learned a bit at least. Literally a guy walked into my work area last week and said "Oh, the old website used to send a copy of the submitted contact form to the fax machine. Make this one do that, too." I barely had a clue about how the server worked and they wouldn't take no for an answer lol. I managed to get it going with a print server and Perl, but I guess I should cut my losses at some point if I want to be up to date by the time I leave this position. EDIT: Perl isn't required. The local Linux hobbyist has been handling it so far with the help of an occasional web dev. Perl was just what I had books for. 
Nice article, always interested to hear more about Crystal. Very tiny nit: it seems like the author conflates "lightweight processes managed by the main program" with "cooperative multitasking," but I believe the former can also characterize preemptive multitasking environments (e.g. Erlang).
Ruby and don't look back.
Well, I've summed up some of my feelings here: https://www.youtube.com/watch?v=K3ZwqIlPC3s To summarize it though: rather than being a complete authentication solution (which monban-generators can generate for you), monban is a toolkit for designing your authentication system to work the way you want. When you use an app engine in rails there is a barrier between your application and user authentication and having to make changes is often difficult.
My concern with this is that when you don't specialize, you can't utilize the tools available to you. By making it non-rails specific you either have to make a separate gem to act as the glue or you have to create the glue yourself (integrating the User model, views, etc.). Looking at the rodauth repo, I found rodauth-demo-rails an in it the readme says: This is a demo site for Rodauth that runs on Rails, showing how you can use Rodauth in a Rails application. It probably doesn't follow the Rails-way of doing things, as I don't know or care what that is, but it should hopefully at least provide an example of how it could be accomplished. Which is concerning if you actually are using a Rails app to me. The repo doesn't show any of the glue code mentioned so I can't gauge how difficult it would be to incorporate into your application. To me Rodauth looks like only one step above warden. I could be wrong and I will look into Rodauth, but I can see a place in the world for both of these gems.
I agree Warden is the best counter-example here. It works on anything that uses rack, sure, and as a result of going to an incorrectly low level of API abstraction is a huge pain to do anything with, other than just trust Devise does the right thing for you with it. 
As an aside, I'd definitely be interested in looking at Rodauth's features and security. If both of these statements are true it might be worth changing Monban to use Rodauth for it's backend. Do you have any information demonstrating these claims that I could look into?
interesting, thanks that's helpful. 
This is so much fun to watch :) thanks @rubyross!
List is my to do list of the 4 chores I have, I don't know if it's written right but my teacher said I was on the right path. We have to make our rspec be able to use the post and delete methods in sinatra. I've been working on it for almost 7 hours today and haven't made much progress. 
Your spec is incomplete, it's not testing what is says it should be testing. Did you write it yourself? You are also not storing anything in a database. Is this intentional? You should associate an ID with every todo item, so you know which one to delete when you get a delete request (or you could just do it in the order in the list). You are using 'list' like it's an ActiveRecord model, this is not the case. 
You can see all its features listed on the [website](http://rodauth.jeremyevans.net/documentation.html). Some features that stand out in comparison to other authentication frameworks: * 2 Factor Authentication (TOTP, SMS or recovery codes) * Password Grace Period (think GitHub's "sudo" password confirmation) * JWT authentication (essentially this gives JSON API support to all features) About the security approach you can read about [here](https://github.com/jeremyevans/rodauth#security). The basic idea is that Rodauth stores password hashes and tokens in separate tables, which the main database user cannot access. That way they cannot leak via SQL injection. But definitely read that section for thorough explanation.
I hacked away on it a bit more before you responded but here is the code https://gist.github.com/Mr-Cotton/e5b26467c68ee1a2985d532eac47f860/revisions The only spec file I got from our teacher was the first one called 'get' which finds 4 chores. I searched on a lot of sites to find out how to use sessions and couldn't really get much of a clear idea on how to change the params for the list. It's nearly 2:15AM, I'm going to sleep so I'm well rested for my other comp class tomorrow.
You will need a lot of help on this. Tell your teacher that you are pretty lost. I don't know if your teacher wants you to store stuff in a session, but if so, let's go with that. First, look at your test. If we start sinatra and run the spec, we see that the first `get` test runs correctly. This is already pretty nice. The `post` and `delete` requests fail. Hmm how's that? Let's look at the specs. describe 'updates the page' do it 'can add items to the list' do response = RestClient.post 'http://localhost:4567/todos', :list =&gt; 'water dogs'.to_json, :accept =&gt; :json content = JSON.parse(response, :symbolize_names =&gt; true) expect(content.size).to eq 5 end end The spec seems off. Usually when we `create` something by `post`ing, we don't get everything back, but that might be the requirements, so we'll go with that for now. We run the test and what do we see in the logs of our sinatra app? 2016-11-22 09:52:29 - NoMethodError - undefined method `new' for nil:NilClass Where are we calling `new`? Ow, on `list.new`, so list isn't anything. Maybe you should've been looking at `session[:list]`, and instead of calling `new` on something, you should have been appending to the list. Now, for your delete test, we see you are issuing a delete request to `'http://localhost:4567/todos'`, however, in your app, you define `delete '/todos/:id`, which is a different endpoint. So that's your first mistake. Then you use `find`, which is a ActiveRecord method, but you are again working on a list, so I would suggest you look at the index of the task you want to delete, not at a non-existing 'id'. So, fix the tests first, and then fix your code. If you don't know how to do this, my suggestion is that you start with more basic exercises.
I hope to be back at RubyConf next year talking about how normal applications work on Truffle. I don't think it would be possible to further integrate Truffle into JRuby classic and get the same performance as we have. I've got a whole video on why this is https://www.youtube.com/watch?v=b1NTaVQPt1E. It's really hard to talk about memory for a managed runtime like the JVM. The JVM is adaptive and garbage collecting. If your system has RAM available why should your JVM try to operate in less memory. Truffle has a larger memory footprint than JRuby at the moment, which has a larger footprint than MRI, that's true, and it may be quite a bit larger. However we are experimenting with a statically compiled version of JRuby+Truffle, that runs without a JVM, which will have a much lower footprint.
PHP so that you can appreciate Ruby later.
With Rbenv I seldomly run into issues. Unless the gem does require external libraries that does differ from OS to OS.
“liberal_parsing”? Let’s get politics out of our coding languages. Make Ruby great again.
You are right to be weary about using the environment variable and conditional to make the test pass, as tempting as it is :). My first thoughts are: 1. Is there a way to mock the node being online? 2. Are there cases where the user might not need a node to be online, rendering that raise unnecessary?
Not funny. I assume you're joking, and know that the word 'liberal' is frequently used in programming contexts for another of it's definitions, "(especially of an interpretation of a law) broadly construed or understood; not strictly literal or exact." 
https://gist.github.com/Mr-Cotton/e5b26467c68ee1a2985d532eac47f860 This is what I have updated, I hardcoded it so that all the tests work but I dont know how I would access the session[:list] and delete or add them by order 
Rbenv solves ruby version issues but not gem dependencies. Unless you compile a new version of ruby for every project you work on and then install the bundle to global.
Wrote this (if you didn't guess from usernames matching the website URL). If you have any questions about the feature or rails feature work in general, let me know.
A terrible idea, most probably arising from demand in the webdev community where "Ignore errors, never crash" seems to be the guiding mantra.
Or from the consulting community, where "the data in this file is worth $2mil, get it read" is the guiding mantra. Sometimes you can't go back and smack the guy who generated a file to get him to do it right, because he's fired, or works for the competition, or the source data is gone.
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 3845 times, representing 2.8144% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dabdkgz)
&gt; Slightly related: is there any reason to use CSV these days? It's not like it can do something that YAML, JSON, or even XML can't do. it can be trivially imported in a spreadsheet, that is what most non programmers use to do tons of stuff. If you have to do some quick data analysis and visualization you can dump a csv, import in excel/numbers/google docs and just fiddle with it a bit. Also, an enormous amount of entities (banks, IMF, various governments, statical offices etc) publish data in CSV, because they have been doing it for decades, it makes perfect sense for tabular data, and all the tooling around it has facilities to handle it. Switching to anything else makes no sense. 
CSV is for data which can be organised into coloumns and rows. Basically anything serious and of significant volume. Json is for serialization, xml for structured data and yaml because it is easy to read in in ruby. Right tool for the right job
I agree with you in principle, but I too have had experiences where i had to deal with an invalid CSV generated from a separate (often third-party) system I had no control over, which was not going to be fixed. :liberal is off by default, as it should be, but if some fairly simple 'liberal in what you accept' rules keeps people from having to re-invent the wheel for dealing with a very common invalid case (unescaped quote), seems useful to me. For your last question, one of the common reasons I still use CSV is when clients/users want to be able to upload things they exported from Excel for processing. Fortunately, Excel does not produce invalid csv. The other one is a legacy system of some kind where that's all it's got, which is much more likely to. 
https://github.com/manveru/ver Iam not sure how up to date this is and if this still works. I think it should.
&gt; Finally, it happened, I’m not developing applications in Rails anymore. Right now Elixir is my first class tool, and I’m happy with it. Stopped reading right there.
What spreadsheet software are you using that doesn't properly escape on export, though?
No, not how I would do it. `:liberal_parsing` might as well be called `:non_deterministic_parsing`. I would write a sanitizer that addresses the particular problems present in the input CSV. If you don't understand the problems, you cannot trust a lax parser to correct them.
If t is worth $2 mil I would analyze the file and write a special parser for it, which handles the specific weirdness of that file. I would not want to trust something which automatically tries to do the right thing.
You don’t need any special knowledge or software to take this course, though any experience with HTML or CSS is a plus. You don’t even need to know the Ruby programming language. I’ll walk you through EVERYTHING
For huge data with the same schema, Json can have a big impact because of key duplication. 
Given this sort of structure. A full URL may look like: https://ws-use.test.com/1.0.0/accountNameTest/contact-service/contact-group/{ID}/member/{CONTACT-ID} But the important part being there can be multiple 'parameters' in the URL, each within their own bracket, but only a single one within a bracket. 
The received way to do this is to use ActionDispatch::Routing from Rails. You should be able to require just the parts you need. However, if you want to do it quick-and-dirty you could use something like this: # route_string = '/contact-group/{ID}/member/{CONTACT-ID}'; params = {'ID' =&gt; 42, 'CONTACT-ID' =&gt; 55} def build_route(route_string, params) route_string.gsub(/\{[^}]+\}/){|p| params[p[1..-2]] } end
Ya, I felt the same way at first, that it's a bit much to create a gem for a single method. I've been using it on my own projects for the past couple of years mixing it in as a module, copy/pasting it every time. After a while that repetition started getting to me and I decided to make it it's own gem. Feels cleaner to me now for whatever reason. There's also the fact that I've gotten so much use out of it that I wanted to share it, and there's no better way than publishing it on RubyGems to get it into the hands of the community...
Yes, this. I've been using this exclusively in a Rails context and am often blinded by that. I was secretly hoping someone would jam it up like this. Gonna have to think on this one for a bit.
You're right, but there are also other methods to archive this problem,. Just like i said, I'll describe them in separate posts, and sum up all things. It's a very good idea to include also informations about witch method is safe and witch is not.
learning and using Either monads will serve us well for when we develop in something other than ruby. it's good to know idioms that cut across languages. and it's not just haskell, monads have entered the lexicon of scala, swift, javascript and more. 
First thing I think of when I see stuff like this is PHP's API which is a total mess. Makes me think of its quote escaping with like 5 different methods and global switches. I don't think this is as bad as that but I can understand peoples apprehension. It's like how HTML parsers all have quirks cause of the lax regulations on specs. I'd rather have a gem to pull in that can pre-process my shitty.csv into clean.csv that I can push to ruby afterwards. 
This screencast is fantastic, absolutetly recommended! Gary rocks and the code he writes and the way he writes it is super-accessible
except monads without 'do syntax' are an ugly mess.
Or you can do the rails tutorial online for free. https://www.railstutorial.org/
could you give an example of what that would look like? i mean, how would it handle success/failure with do...end syntax?
What? I'm just talking about Haskell monadic do syntax. Google it. 
my bad. thought you were talking about ruby
Hehe np sorry I snapped 
TL;DR, here are 4 (it was 3 prev.years) grants: * Ruby System for Elementary Statistical Analysis * Subproject libraries for Ruby/Numo (Numeric analysis library) * Tensorflow.rb * Rubex - A new language for writing Ruby extensions I wonder whether this selection shows current Ruby Association targets, or rather which of Ruby sub-communities are aware of the grant :)
Ruby Performance Optimization was a great read!
how do you do markdown in evernote?
Actually it is 40% off ALL their books.
Re: $SAFE yo may want to put a disclaimer in there that $SAFE does not provide a way to run untrusted code safely at any setting. 
Can you provide a reference?
Awesome projects. Especially excited about Rubex.
On behalf of the entire internet. Thank you. Your efforts to maintain our ability to use browsers as they were designed, e.g. bookmark pages and open links in new tabs will be forever appreciated.
I wrote this guide on how we structure our js files to be maintainable and compatible with Turbolinks: https://github.com/rstacruz/rsjs - hope it helps those struggling with getting TL to work. :) 
If you're building a SPA app for a podcast site that's some serious over complexity. I'd almost argue that turbolinks is overkill for something that isn't really interactive/requiring a lot of browsing.
¯\_(ツ)_/¯
I'm porting a rails 3.2 app over to rails 5 and turbo links 5. So far everything is going great I'm happy with the speed improvements. we haven't run into too many hiccups. We did have to use the meta-tag to disable turbo links history caching which made a lot of things easier. We're also hoping to use turbolinks-iOS to build a native hybrid app.
Just call the variable when you're pry'd. You also do ls to show available. Methods and variables and show-method to show a method 
&gt; Try to implement something as succinct as that in Ruby! def match(word, candidates) candidates.select { |otherword| word.downcase == otherword.downcase.reverse } end [6] pry(main)&gt; match "dog", ["cat", "god", "fred"] =&gt; ["god"] &gt;However, this doesn’t look anywhere near as nice and performs no where near as well as the elixir version. def strip_vowels(string) string.gsub /[aeiou]/i, '' end [10] pry(main)&gt; puts strip_vowels("harry") hrry + because ruby is not tail call optimized by default this is "safe" in ruby for even long strings unlike your example.
From being at RubyWorld (the major Japanese focused Ruby conference), yes these are more what they're focused on. That and IOT, which isn't represented.
Haha well done, I really shouldn't have asked that question Although I should have pointed out for the vowel one that it was meant to be using recursion in order to illustrate the pattern matching, elixir has something similar to the above as well
There's a fairly simple explanation for the + vs &lt;&lt; String performance : * String#+ is creating a new string * String#&lt;&lt; is appending a string to the existing one (which most probably uses the optimization from DynamicArray avoiding costly reallocations)
Correct. What many people new to Ruby don't realize is that `a += b` always desugars to `a = a + b`. So if `+` is an immutable operator, `+=` is also an immutable operator. Actually *any* operator of form `a X= b` desugars to `a = a X b`, e.g. `a ||= b` desugars to `a = a || b`. Therefore, using `+=` on strings, arrays, etc. will always declare a new object and copy the old one, not change the old one in-place. If you need to append to the original object in-place, rather than create a copy and append to the copy, use `&lt;&lt;` or `.concat`, not `+=`.
You can also prepend a method with $ to get the method definition to show up. 
I've recently retired `pow` in favor for `puma-dev`. It works well with ActionCable web sockets and SSL.
I don't know what the value of that would be but you know what would be cool? If you could do syntax highlighting in an editor based on your heredoc inticator query = &lt;&lt;-SQL This gets highlighted as SQL SQL js = &lt;&lt;-JAVASCRIPT This gets highlighted as javascript. JAVASCRIPT 
Sublime Text, VSCode and some other editors support that already!
the variable `line` is out of scope by the time you get to the `puts` line. after a few minutes of googling, i *think* i found an article on scope that makes any sense, here: https://github.com/Devbootcamp/reference/wiki/Ruby-Scope -- read the introduction, then skip to https://github.com/Devbootcamp/reference/wiki/Ruby-Scope#local
You are not closing the File properly. There seems to be a quote too many at the end. The whole line based iteration can be simplified: File.foreach 'voterinfo.txt' do |line| if line.include? string puts "This person has already voted: #{line}" else puts 'This person has not voted.' end end
RubyMine too
In the future (and this goes for everyone else) fucking try it first, and then post a comment saying if it worked or not.
Ruby doesn't need to create the parallelism - your computer's processor automatically extracts the parallelism from an online dataflow analysis of the linear machine instructions that implement the Ruby interpreter. It does this for all programs. It's called out-of-order execution https://en.wikipedia.org/wiki/Out-of-order_execution and works with a super-scalar architecture https://en.wikipedia.org/wiki/Superscalar_processor. Look up how many arithmetic units your processor has. What do you think it's doing with all of those if not running them in parallel? As I said, the interpreter overhead may get in the way in practice. Lower overhead versions of Ruby like Rubinius, JRuby and JRuby+Truffle will definitively see this effect for real.
Define sleek
Sorry if I sound like a dumbass, i'm fairly new to programming. But yeah, an IDE like netbeans (except i fucking hate trying to get ruby to run on netbeans) would be great
No worries at all. I wanted to make sure I wasn't steering you in a frustrating direction. [Rubymine](https://www.jetbrains.com/ruby/) is pretty popular. [Atom](https://atom.io) isn't bad if you want less than an IDE but more than a text editor.
Perhaps [RubyMine](https://www.jetbrains.com/ruby/) then?
Square brackets on the outer structure? If it's supposed to be a hash those should be curly braces, and if it's supposed to be an array there shouldn't be keys in it.
My key take-away: if you want immutability in Ruby, use value objects. I never thought about it this way, though in hindsight this is completely obvious - if you complain about other code modifying your, e.g. *arrays*, why are you passing *arrays* around the system? Just, you know, [stop it](https://youtu.be/Ow0lr63y4Mw). For some definition of boundaries, use primitives inside boundaries, use value objects across boundaries. What do you think?
The best way would probably be to use the new Array/Hash #dig method (see http://ruby-doc.org/core-2.3.0_preview1/Hash.html#method-i-dig). It works like this (assuming the variable `x` holds your content): x.dig(:rare, 0, :endangered, "crane") You should note that the array only holds **1** item, a single Hash, and not three. If these should be three hashes, you would have to surround them with braces, otherwise Ruby combines them.
Also, 25% off PragStudio training. https://pragmaticstudio.com/courses/ruby 
I purchased this when it first came out and it's been super valuable. Nate's a great guy and the content is top notch. The slack channel is active and interesting. I suggest it for anyone who wants to squeeze out as much performance as possible from a rails app.
&gt; Go back to the 1960s and have fun; the rest of us want to learn new stuff and get what we need to do done faster, better. LOL please do watch [Joe Armstrong interviews Alan Kay](https://www.youtube.com/watch?v=fhOHn9TClXY) at CodeMesh 2016, I promise you will see the 60s differently. If you really want to "learn new stuff and get what we need to do done faster, better", you kinda *have to* go back to the 60s and start over from there. But the tone of your reply is understandable - I can see how the title of Tony Arcieri's post, taken out of context, may sound offensive and link bait-y. But I believe the historical context of that 2011 may be Zed Shaw's notorious Rails is a Ghetto post, which must have been still fresh in the readers' minds at the time, so I believe this post was titled a bit tongue-in-cheek. Also, consider who the author is (also the author of Ruby's celluloid actors implementation among other things) - so I think *"Somebody profoundly misunderstands the language, and/or is trying to keep his psychological investment in his current stack of choice secure enough that he doesn't have to really learn new stuff"* is a bit misplaced. I guess my point is, there's gotta be more to it than that. But all I hear back is more of the wild-eyed "excitement". Oh well. Maybe the second coming truly *is* upon us *this time*.
so how would i reformat it so that those would be three separate hashes? would it look like: [ {very_rare: "red_tailed_hawk" =&gt; 30, "turkey_vulture" =&gt; 25 }, {protected_species: "swanson_hawk" =&gt; 18, "osprey" =&gt; 14 }, {endangered: "bald_eagle" =&gt; 5, "crane" =&gt; 7 } ]
A good point. Blogspot is a bit shit for code, and it takes some scripts just to prevent it from messing with code indentation. If anybody knows good ways to add code highlighting, definitely let me know. 
I was actually thinking about something similar today, and the best I managed to come up with (assuming you aren't on windows) was to have ruby execute the shell command for switching wifi on/off.
In linux you should be able to achieve this with one the following ways: * Turning of wifi radio by modifying /sys variables. Basically open a specified file and write a 1 or 0 into it. * Using DBus to force NetworkManager to disconnect. You'd need to find a DBus Ruby gem and figure out how to interact with NetworkManager APIs. This is probably the most ideologically correct way of doing things, but also it would be the most difficult. * Call 'sudo ifconfig &lt;interface&gt; down' with system() or ``.
Imagine you have a parser and you are writing a test that shows that two different texts have the same parsed representation. assert_equal parsed(&lt;&lt;TEXT1), parsed(&lt;&lt;TEXT2)
Well it would be more helpful to OP if you actually mentioned the shell command. 
Close - you have to wrap the values using the braces `{...}` but you just moved the first brace one word to the left. The correct version would be: [{very_rare: {"red_tailed_hawk" =&gt; 30, "turkey_vulture" =&gt; 25}}, {protected_species: {"swanson_hawk" =&gt; 18, "osprey" =&gt; 14}}, {endangered: {"bald_eagle" =&gt; 5, "crane" =&gt; 7}}] This would give you one Array with three Hashes, each of which holds just one key-value pair: the first one has one key `:very_rare`, the second hash a key `:protected_species` and the third one the key `:endangered`. The nesting you are using seems unnecessary complicated for the use case, why not just use the following: {very_rare: {"red_tailed_hawk" =&gt; 30, "turkey_vulture" =&gt; 25}, protected_species: {"swanson_hawk" =&gt; 18, "osprey" =&gt; 14}, endangered: {"bald_eagle" =&gt; 5, "crane" =&gt; 7}} I.e. one Hash with three key-value pairs and the keys `:very_rare`, `:protected_species` and `:endangered`.
Good question, I'll add it to the OP. Windows 8
[Mechanize](http://mechanize.rubyforge.org/) to rescue.
I like Casper for this sort of thing. You can use it with phantom or slimer and get all of the js interactions on the page. Downside is you need to write js (used to support coffeescript until 2.0). The reason I like this setup is that you have one tool that runs your script so there aren't a lot of links in your tool chain. 
don't get me started on Docker :) ... Just joking, I agree, Docker rulez but there is always place for raw technology configuration :) ...specially for junior developers learning from scratch, or if you have broadband limitations like I do, and you cannot afford pulling layers for every small change. ( I will write a blog on that soon one day :) ) 
You could also use something like Vagrant with shell provisioning. I cooked this up from the Rails development environment: https://github.com/josiahcampbell/rails-dev-box
I use Selenium Webdriver or Mechanize. 
I do appreciate the idea, and both Vagrant and Docker are awesome tools to do this job but imagine you are junior Developer, you have no idea what you are doing and no clue how virtual provisioning works, you just want your first Ruby on Rails project up and running. The simplest way for you is just hardcode install everything. 
Pertinent question here in terms of real world application I suppose is whether this matters in situations where you are behind a caching layer, which will likely give you better performance than hitting the DB in the first place. What I'd really like to see is some seamless API endpoint cache which automagically expires when the relevant data is changed. 
This is very relevant for a project I'm working on at the moment, thanks for sharing. I'll do the proper benchmarks.
So what about the "faster" part? 
So where are the benchmarks? How much faster PostgreSQL is compared to say `oj`?
Related: https://dockyard.com/blog/2014/05/27/avoid-rails-when-generating-json-responses-with-postgresql 
Excellent, any indication of how much memory it uses compared to MRI and JRuby?
This is definitely a great tip but I feel like if I'm going through the effort I'd rather cache for performance. This gets rid of my ability to get computed values and business logic without writing them in postgres 
Not an incorrect bit but for those just hearing about truffle and being blown away by its performance, it is important to note that truffle is very fast but also has some trade offs. First it has all of the C extension issues of jruby plus some (based on how it works at low level and running on JVM) -- so do not expect to be able to port over code that relies heavily on C extensions unless there is plain ruby alternatives. Second it is not complete yet, I am pretty sure it will not run rails apps at this point. Third, because of how it works to JIT and deoptimize ruby code there is a substantial memory trade off to gain that performance as many of the structures in memory must be maintained in multiple versions -- reducing the JVM memory granted to a project will come at a cost of substantially less performance gain. From what I had seen when testing this a few months ago the sweet spot was something like 3x the MRI memory being that point where the performance started top drop pretty hard after warmup. 
&gt; it has all of the C extension issues of jruby We're hoping to solve the C extension issue by interpreting C extensions. We can already run some C extensions like oily_png and psd_rb, and some of openssl. I did a talk about this at RubyConf. https://www.youtube.com/watch?v=YLtjkP9bD_U We hope that JRuby+Truffle's support for C extensions will actually be a strong point compared to Rubinius and JRuby.
Finally starting watching your videos even though I've been registered for ages. Thanks for all your work!!
Do you mean something to show a differences between two objects or structs, not a screenshot but more of a diff??
You gave us a lecture on AJAX one time at DBC last year
Issue is fixed. Sorry. There were too many connections on the server and had one of those strange 'Too many files opened' errors. I raised the limit and it should be back up. I'll be adding additional servers in a few weeks and a load balancer to help.
Without more explanation as to why, I would probably use rspec/minitest and write my own helper functions. I have also heard of the [approvals gem](https://github.com/kytrinyx/approvals) which can be used on top of rspec. From the docs you can do `approvals verify --ask` &gt; The option --ask or -a, which after showing you a diff will offer to approve the received file (move it from *.received.* to *.approved.*.). The default is true. If you set this to false, then nothing happens beyond showing you the diff, and you will need to rename files manually. In rspec you would do something like: Approvals.verify(your_subject, :format =&gt; :json)
Agreed. Almost all the popular languages are object oriented and I think it's a good design. That said it's not one size fits all and we should stay open to other paradigms.
Yep, this is functionality which I looking for! (To make tests easily, without need to describe all result values of an object) Thanx!
https://github.com/dogweather/digbang
We also interpret inline assembly. But we're actually interpreting the source code of the C extension part, while running the actual libssl.so as native code, so it doesn't matter anyway.
agree, I will add rbenv manual when I have time. But for dev machine it's ok
You can install ruby from an apt repository. I think it's the easiest solution.
and the post you are responding to shows that you can actually gain security by choosing the non specific workflow -- in which case username verification/enumeration by an attacker is no longer a vector or given that you should rely upon as reason to spill the beans at every turn.. If it is not clear to you, the article says it is not a big deal to enumerate active account names because you have a sign up form that spills the beans already, whereas this post is saying that the sign up messaging and workflow does not at all need to spill the beans.
Put the part with `Rake::TestTask` outside of the `task :linux do` block and name it differently. Then define a dependency on it for the 'linux' task, something like the following: require 'rake/testtask' namespace "unit" do desc "linux tests" task :linux =&gt; :test do puts "debug" end Rake::TestTask.new('test') do |t| t.libs &lt;&lt; 'test' t.test_files = ['test/test_helper.rb', 'test/test_linux_class.rb'] end end
Hey we talked about this on Gitter! Thank you for adding this feature! I will definitely be using it soon!
Using `rvm` in production with cronjobs isn't too big of a hassle if you reference the ruby wrapper instead of the bin (similar to how phusion passenger handles rvm). Personally, cronjobs are more of the issue for me. If you end up adding several web servers, you will have repeated tasks running unless you make one of the web servers the 'master'. Even then, I like my web servers to be configured identically. Sidekiq Enterprise or sidekiq-cron levitates the need for a master server.
Where is the enumeration attack?
Show me the output of rails --v, have you created a rails app? Check railstutorial.com
&gt; On the one hand it does seem useless, and easy to fool - just copy and paste from the password field. Go ahead and find a password field and give that a try.
What initiatives are planned?
if you installed using RVM you need something like this in your .zshrc [[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; . "$HOME/.rvm/scripts/rvm" 
 This is what I put in response to u/disclosure5 So what we are planning and working towards at the moment is designing a tool where users can do three major things: See a ranking of how politicians and companies score on certain climate change problems, see the relationships between these entities (such as campaign donations), and view competition that is helping the environment more (kind of like eat this, not that). The practical impact is to help empower individuals around the US to see how they can be responsible consumers/voters and work towards eliminating the irresponsible actions of large organization. Does that help? I would love to answer any specific questions you have!
Thanks, I have responded on Gitter to continue our discussion there.
Perfect! Thanks!
I use chruby myself, but yeah, if you need to load some rc type file for your rubies management that looks correct. Thanks for adding some input! They probably are using rvm as a new user.
I didn't look to much at the src as I have to leave soon, what I did see looked good though. Anyway consider rewording your readme. Things like `The application is`, `Create an application`, and `Deliverables: The source files..` don't really serve any purpose and make this read like a textbook - not something you made yourself. 
So proud of how far you've come &lt;3 :')
I managed to do it with rvm, I was using rbenv and there were some issues. Thanks everyone
I mean no, I'm not going to. I've been able to do it before. Not sure why other people having different experiences seems to bother you so much.
I think you're mistaken about having done it before. And even if you somehow magically have done it, most people can't. So your point about the redundant password field being useless because you can copy/paste it is invalid.
Using them is generally the design pattern. They are essentially free vs accessing the instance variables directly Ah I see. You are expecting another method to be called when you parse the input. Ruby devs generally avoid this because the methods getting called should be private Code like this `expect(robot.position).to receive(:left); robot.left` would not work if position were a private method. You want an object to have a public interface that you interact with and keep everything else hidden. Then you call the method to see that the method call triggered the change in state that you expect
I was recently for something exactly like this! Perfect
Ok dude. Go ahead and feel validated. You sure told me! I mean, you really didn't, but whatever.
like python? How does python do it?
He means drawing the window on screen like a native app. And yes - it can be done 
You might be looking for [Gosu](https://www.libgosu.org/)
&gt; Why does the position object return new positions in left, right, etc. Why not leave the current position in the position object? The `Robot` is instantiated holding an instance of `NullPosition`, so if it was to mutate the current position, I'd have to add additional logic to check if the current position is `NullPosition` or `Position`. This way, the `Robot` doesn't need to know what position it's in, it just sends the message to it's current position and it will return a new position. For example, when sending `move` to `NullPosition` it returns `self`, but sending `move` to a `Position` will determine where that is and pass it back to the robot, effectively separating concerns. Edit: To address your example of `left` and `right`: actually, you are right. It is also fine to simply have `NullPosition` ignore these two requests, while `Position` would mutate its `direction`, though, there's a pleasing symmetry between the four methods here that would be lost. I'm not sure which is better. &gt;Also, why separate out the validation of position in bounds outside of the position object. Why not push the bounds inside the position to ensure all positioning is valid? Yes, this is an interesting point. The way I see it, the `parse` method needs to look at the user input and determine which command to call. The `when "place[/regex/]"` allows valid place calls, and non-valid place calls continue through the `case`, eventually ending up at `InvalidCommand`. There may be situations where further validation would be required, for example if some knowledge about the current instance of Robot was required, however it just so happens that in this case, all syntactically valid `place` commands contain valid parameters, so no further validation is required.
Tkinter, pyqt, kivy...
Three different approaches: https://github.com/ruby-gnome2/ruby-gnome2/tree/master/gtk3/sample/tutorial https://github.com/jruby/jrubyfx/wiki/Getting-Started https://github.com/zach-capalbo/flammarion
Seems very focused on API actions? Also useful for HTML-rendering actions?
it could be! skinny_controllers just adds the rails-glue (aka: implicit lookup, cause us devs are lazy) around operations and policies. I can't think of a reason why it _wouldn't_ work with html actions. :-) Also, you may also be interested in: https://github.com/NullVoxPopuli/rails_module_unification/ (if you have ideas for a better name, I'm all ears. haha)
Cool, so I'm correct you designed it thinking only of the API use case, but can conceive of it being useful otherwise too, as there's nothing actually API-specific about it? Might be useful to put that in the README, it wasn't obvious from the description it was about API, but then all your example code and scenarios were about AMS and API, so I was left wondering if this was specific to AMS/API or what. Also btw, you don't have a blog, do you? I was looking for one for you before but couldn't find one, to add to rubyland.news. And yeah, rails_module_unification does look interesting. And does need a different name. It's really mostly (entirely?) just about changing the conventions for where Rails looks for files to load classes, maybe something in the name that suggested that. 
The [scenic gem](https://github.com/thoughtbot/scenic) helps with managing database views, including materialized views.
When I was primarily using Perl, I used the Perl gtk libs to write GUIs. Here is a ruby gem - http://ruby-gnome2.osdn.jp. it covers gtk/gnome 2 and 3!
Very good news. The asset pipeline is becoming more and more of a hindrance. 
To create games I only know [Gosu](https://www.libgosu.org/), but maybe there are other options. There are some books about it, like [Developing Games With Ruby](https://leanpub.com/developing-games-with-ruby/read), and [Learn Game Programming with Ruby](https://pragprog.com/book/msgpkids/learn-game-programming-with-ruby). There are also tutorials and talks on [YouTube](https://www.youtube.com/results?search_query=ruby+gosu). For making desktop apps, I like [Shoes](http://shoesrb.com/). I've made a few simple apps with it and it's very easy to use. 
These ones look very interesting. Thanks.
Ugh webpack 
Screw this.
&gt; Not a fan of using components to decompose the Majestic Monolith. But whatever floats your boat! We have a 300-model, 35kloc app in Basecamp 3. Shopify has, I believe, a 700-model 200kloc app. Both Majestic Monoliths, and happily so. &gt; If you, for organizational reasons, want to split the Majestic Monolith, then I think going with completely separate apps is a better way to go. *Sigh* It's stuff like this that increasingly leads me to tack "_not_ rails" onto "I program in ruby" when I am introducing myself to tech people in other communities outside of ruby.
Outside of rails, components are understood to mean something very different than the cbra.info. Outside of rails, monolithic applications are understood to be an entirely undesirable architecture (even among _single component_ applications). On top of that, the substitution of feeling "happy" with an architectural approach for critical analysis of the alternatives is flat out anti-intellectual. The rails community that once pushed the envelope has now settled into what it's going to be in perpetuity, never making any substantial improvements.
What is meant by "component" outside of rails? It means something different in every framework I've ever used. I guess I agree with the principal on lack of curiosity, but I am still curious what you are talking about. I've used a lot of other web frameworks, and Rails supports namespacing via modules (not great but that's ruby), separating apps into engines (if you want, I don't, most of what I write is app-specific), and I suppose separate apps if you want. (I have a monolith of my own, but I really wouldn't know where to begin... its problems all have to do with complicated domain logic, not being one app.)
It's just the word. 
I assume this is not what you mean? https://developer.mozilla.org/en-US/docs/Web/Web_Components
How do you know it's not the right way to do it?
5. https://github.com/ffi/ffi
Clarifying question: Have you ever worked on a rails model that had reached 2000 lines of code, and double that in tests?
I've been working on cbra.info based app for about 2 years now, with a client side framework in play as well. I just wanted to say all of what you've written in this thread resonates strongly with me. 
The standard way would be to include it as an extension: http://guides.rubygems.org/gems-with-extensions/ However, I think the *easiest* way for a private gem would be to just include the binary in the gem's `/bin/` and execute it from there.
I think you're confusing "never making any substantial improvements" with the "Plateau of Productivity" from https://en.wikipedia.org/wiki/Hype_cycle. A mature 10-year old technology should be quietly kicking ass and being productive for teams still using it. Don't hate it because it's not changing every other day. Traditionally, Rails has picked technologies that move the ball forward. Sometimes with success -- REST -- and sometimes not -- turbolinks and pjax. And sometimes, to move other balls forward: Coffeescript to ES6. It's fun and cool and hip(ster) to bash technology. "OMG, you use Rails!?" "WTF, you're still on jQuery?" And that's a horrible sentiment to have. We stand on the shoulders of giants. Technology always builds on other things. Think about it. Maybe, you've gotten jobs, made a living and a nice paycheck from the free work of 100's of people who made Rails 1 and onward. Gone to conferences and made yourself a better programmer, maybe even a better person. To hate the thing that helped you get here is disingenuous. 
Personally, I'd be happier if they introduced `--node` flag that'd let you plug in any Node pipeline (probably via manifests and/or livereload). Maybe in a future release.
IMO autoloading (and general "automagical inclusion") is a problem in Rails, but it's not big enough to justify abandoning the framework altogether. And it's kind of a legacy issue. If you want to get rid of it, you'll have to pull Python 3 on Rails and/or Ruby. I'm not sure DHH wants it and I'm pretty certain Matz doesn't want it.
I'm not suggesting anyone abandon rails altogether. I still use it as an HTTP server (though I don't use it for much else). Ultimately, I starting this sub thread citing a quote by DHH as another example of why I don't identify as a rails programmer.
It's kinda weird that they ignored npm for years, but jump as soon as yarn is released. It's like they thought "oh look, yarn took cues from bundler (e.g. the lockfile) and our prodigal son wycats is involved, we will deign to recognize the node ecosystem now".
Hmm. Maybe you're looking for something like the rails_module_unification (the gem)? 
I've never really run into any issues other than the occasional goofiness where I have to kick the server to get it to recompile assets. Nothing like the nightmare I've seen from colleagues diving into webpack for the first time. 
Sometimes, when you have a big team of developers you may lose control over the Gemfile. Getting an app Full of gems that doesn't make sense or even broken gems, deprecated gems and so on. What are the key aspects of a gem do you usually look for to allow it or not to live in your precious gemfile? What do you frequently look for in a gem to say "- Ok, this is a good library"?
Why would I do that? And that has nothing to do with DHH's statement.
DHH has publicly talked about their rewrites. Not as a, "wow we had to rewrite this POS codebase" but more as a "it's good to rewrite every few years to catch up with new technologies and learn more about how the web has changed."
Trying to use modern front-end tools like Redux are a pain with the Sprockets workflow. From the React-Redux bindings README (my emphasis): &gt; If you don’t yet use npm or a modern module bundler, and would rather prefer a single-file UMD build that makes ReactRedux available as a global object, you can grab a pre-built version from cdnjs. **We *don’t* recommend this approach for any serious application, as most of the libraries complementary to Redux are only available on npm.** I've run into that a lot - new frontend libraries assume a JS/NPM-oriented workflow and you have to do extra work to install and then manage upgrades with the old school (Sprockets) everything-is-global way. At one point it was totally fine to put blobs of .css and .js and under `vendor/assets`, but I think that time has passed, particularly for JavaScript. And that workflow has always been poor for managing upgrades; I know for popular assets like Bootstrap people will wrap this workflow with gems, but that can lead to awful scenarios where you can get conflicts with other gems that provide their own Rails Engine frontends (I ran into a nasty one with ActiveAdmin at one point). Maybe more importantly than installation workflow though, most tutorials these days for things like React are teaching an NPM-heavy workflow with ES2015 syntax (including the import syntax, e.g. `import React from 'react';`). When you're brand new to these technologies like me, it's difficult to figure out the proper way to set up webpack and babel in a Rails project and make it not fight with the asset pipeline (I did try the `react_on_rails` gem, but ran into some errors with code reloading, so settled on the official `react-rails`gem which has some downsides like putting everything in global scope). React, Redux, vue.js, Elm, TypeScript etc. are only going to increase in popularity as time goes on (for good reason), and if Rails doesn't keep up with providing a happy integration path, people are going to just use something lower-friction as a backend. Furthermore, using webpack with ES2015 allows you to do to "tree shaking," which removes un-imported (and thus unusable) JavaScript modules from libraries you're using, thus reducing emitted JavaScript size and improving your site's performance. webpack is even capable of componentizing CSS, although I haven't tried it out to know if that also means it falls under the "tree-shaking" capabilities: https://www.bensmithett.com/smarter-css-builds-with-webpack/ And if you want to use something new like Elm with Sprockets, correct me if I'm wrong, but you'd have to write your own custom pre-processor for Sprockets to handle .elm files (probably creating + publishing a new gem in the process) instead of just grabbing the Elm NPM package that already exists and adding a config line to webpack to tell it use that for .elm files. TL;DR Sprockets was awesome for its time, but front-end assets have long since moved on and Rails can't afford to lag so far behind anymore. It would be much simpler to leverage webpack as an official workflow rather than trying to port features over to Sprockets IMO.
Use YAML instead of ruby for configuration stuff then read the YAML file. Google "ruby YAML config" for some guides and gems to get you started 
Try TOML instead of YAML and the tomlrb gem; I can't stand YAML after having made the switch
In our shop, we treat gems like any other form of technical debt. *Does the value added now outweigh the cost in the future?* Some of the things that affect cost in the future: * Did the gem cover all of our requirements? Did we need open that thing up? * What are it's current issues? * How often is it updated? These all affect how much time we will spend maintaining that gem. We do gem updates every week so we love gem maintainers who keep great changelogs Here's some opinions on some of these gems: * **VCR** - I hate not knowing what the raw test requests look like. Use [webmock](https://github.com/bblimke/webmock) and paste those huge request body strings right in the test. I'd rather be able to see what's going on in a larger spec file then hunt down a bunch of cassettes. * **FactoryGirl** - I think FG gets sllloooowww as data/domain models scale. We love fixtures and using database transactions in test. The [fixture_builder](https://github.com/rdy/fixture_builder) gem let's you use your domain model to build your fixture yaml files (love those validations, and you can even use FG during this step). For capybara and fixtures, there's plenty of tutorials on how to setup non-transactional tests for feature specs. * **CanCanCan** - Again doesn't scale well. Check out the [authority](https://github.com/nathanl/authority) gem and separate your authorization code based on your resources. * **Draper** - This is not decoration. Sure, it helps with the global helpers in Rails, but this ain't decoration. Decoration never changes the interface of an object and draper adds view logic to a model. Ugh. Love rspec, paranoia, papertrail, pg_search, dot_env, money-rails. 
In "ruby", I'd use [sequel](http://sequel.jeremyevans.net/), because it handles this a lot better than ActiveRecord. In Rails/ActiveRecord, it can be done (I've done it), but it's kind of clunky and can be confusing. "Isolating in gems" won't really get you anywhere -- if all the gems are loaded in the same app, dealing with ActiveRecord is exactly the same as if they weren't in gems, the fact that they are in separate gems doesn't make dealing with separate databases in ActiveReord any easier (or really any different at all). Isolating in gems won't do what you hope it will (because it's hardly 'isolating' at all, separate gems loaded in the same app all share the same ActiveRecord stack) You might be right to avoid actual AR associations between databases though -- AR _can_ handle _very simple_ associations between databases, but it always seems like a gamble as it's hard for me to predict/remember where it's going to break. Avoiding cross-db relationships is reasonable. As far as how to tell ActiveRecord that different models are in different databases, like p2r says, base classes that do an `establish_connection` to connect to the right database, and then models from each database extend the appropriate base class. This is what you'll have to do whether you put the code in separate gems or not. If you aren't going to (even potentially) re-use the code between applications, I wouldn't do seperate gems -- although I might do separate module namespaces within your app. 
What a good example of a gem using FFI? The best one I have found so far is [scrypt](https://github.com/pbhogan/scrypt).
Looks interesting. Anyone want to do a compare/contrast to ActiveModel::Serializer?
Nice. Looks like it has easier per-call configurable serialization too, with your example render jsonapi: post, include: [:author, comments: [:author]], fields: { users: [:name, :email] } , which is something I always missed from AMS. 
Code reviews also welcomed!
I went with the yaml solution, but if you have time would you mind walking through this code? I've never seen "ostruct" and "OpenStruct" before. Also what's with this line "class &lt;&lt; self" ?
AMS has this? (I'm also a contributor to AMS - NullVoxPopuli on github) One of my goals to cleanup AMS is to integrate /u/beauby's jsonapi gems into AMS, and eventually replace the AMS stuff. AMS *should* just be a collection of rendering styles that people can choose from with tight glue to rails.
Looks interesting! How does your approach compare to jsonapi-resources?
No but I feel like the microservices camp shifted the goals significantly. Now, if your app doesn't have at least three independently moving components (preferably in three separate processes) you're labeled as a "monolith".
The importance of continuity of code maintainers is indeed often overlooked. But it's important for continuity of architectural strategy, which sometimes a single continuous maintainer doesn't even manage, and _can_ be maintained over a handoff, with a lot of work, if the new maintainers decide to put in the work. /u/schneems had an incredible presentation/blog touching on this, which now I can't find...
Could you put some benchmarks up? Would probably help adoption.
[Enumberable](https://ruby-doc.org/core-2.3.3/Enumerable.html) is a module for making enumerators. [Enumerator](https://ruby-doc.org/core-2.3.3/Enumerator.html) includes the methods from the Enumerable module.
Aha! Here it is. http://schneems.com/2016/05/31/saving-sprockets.html
Yeah, they are full of shit. And most microservice architectures are just distributed monoliths. A database over HTTP isn't a whole lot different than a database over SQL. Ten "microservices" querying each other over HTTP represents the same _lack_ of modularity that characterizes monoliths.
fun talk :-)
Why don't you try out the first two to see? In general, yes. I don't know about comments in path, I don't think so. I am not sure if there is a safe way to 'sanitize' user-input paths like this. But do be aware you can turn a relative path to an absolute path with `File.expand_path`, which will also resolve and remove any `..` parent components. 
Main difference is that jsonapi-resources is an opinionated rails extension, whereas this is a plain ruby library. It has framework integrations, but zero requirement. One can think of it as lower-level as jsonapi-resources.
This seems like a good solution to use gems from ruby which may not be supported in elixir. you could potentially do things transfer sockets to ruby as well, so elixir could "forget" about certain connections and just have the ruby code take care of it.
The first thing that comes to my mind: https://github.com/mixtli/net-snmp The problem with writing an extension is that it will be tightly coupled to the MRI environment (which might also be a positive things, depending on what you want to learn). The talk at https://youtu.be/YLtjkP9bD_U explains how FFI simply works with JRuby/Rubinius, and the things JRuby had to do to make C extensions work.
Thanks. It looks very promising. I might give it a spin. 
My first thought when I read this was, oh I can answer this, I went through this. Then I remember that that was the best part of ten years ago, and so I have to think back and damn it's hard to try and remember what you've forgotten, but here goes. Programming is a difficult endeavour; I'm not sure that many people ever get to feel like they've mastered it, but we do get to feel like we are improving and making things in better ways than we used to. But what can you expect on that journey? **Expect to feel out of your depth:** There are going to be moments when you just don't know what a thing is, how it works, or why you do it that way, or why don't people do it this that seems like it should be obvious? But that's ok; you're coming on as a junior, if the company/team that has hired you is serious about having a junior you'll have room to learn and grow as you go. Which leads into: **Expect to need to ask questions:** And don't feel bad that you have to. Of course, you won't want to interrupt people right in the middle of an important thing. It is commendable to try and find out some stuff on your own, but the chances are that, at some point, you are going to hit a wall where you need to ask, why doesn't this work? Why is that a better way to do this? And that's ok; the best juniors want to soak up every piece of knowledge gained by experience of those around them who have that greater experience. Learn as much as you can from them. **Expect to be looking up lots of stuff, everything people mention that you don't know it, look it up:** This will happen a lot. I had to look up heaps of stuff in my first few years in particular. Smart, experienced people, know stuff that you just haven't encountered yet, so when they talk about it, maybe even just in passing, go find out what it is. Some of it will be intriguing, useful stuff that you'll want to discover more about and will help you grow your skills a lot. **Expect everything to take longer than you expect it to:** And I do mean practically everything that is not a text change on a web page, especially when you are starting out. In this job we are constantly doing things that we have never done before, or failing that, in a way that we have haven't done them before and as such estimating things is tough. Add to that if you are working on an existing system that has been around for a while and is not a simple thing. Don't despair, though; it's ok to say things like, I don't know yet, let me go find out how hard that is and get back to you. Timebox an investigation into it, and then report back. Getting the information and managing expectations around it are skills that are just as important as your tech skills, and if you can get good at that you will go far. **Expect to feel awesome when you figure out a thing that you thought you would never be able to do:** All of these make it sound like you have a tough road and it will be if you want to get really good. Like I said programming is hard. However, the upside of all this is that when you figure out a thing, especially a thing that you thought you would never be able to build/understand, then you will feel amazing. You will realise why you love this job, despite its ability to make you feel like an absolute idiot on a daily basis. Don't just build big long things, build small things/features often, the quick wins that you can accrue this way will help you feel a sense of achievement, especially while you are finding your feet and spur you on to do more. It's a great career. I love being a programmer; I love working with Ruby. I wouldn't change it for the world, and I hope you can find that kind of home with it too.
/u/chris-herring's points are all great! I'll add a few thoughts...these are less about things to expect, and more a few strategies to help cope with them. **Break things down into small pieces:** Ask seniors to help you break down projects into small incremental steps. The idea that everything will take longer and be more complicated than you expect has already been said. But this is my advice for how to actually cope with that beyond just setting your own expectations. Perhaps you're assigned what seems like s small task, but since you have to understand so many different facets of your technical stack to get this one little thing done, there's so much to learn that it can feel impossible. Heck, sometimes even just understanding what all those layers/steps are can feel impossible. My advice is to do a little research, break it down into the smallest steps you can think of, write that down, then take that to a Senior Dev and ask whether those are the right tasks to accomplish your goal or whether there's a better way. Doing some leg-work yourself before asking for help will show that you're trying, and asking for help will show that you both want to use the company's time effectively and that you want to learn and fit in. It's a win all around. **Perfect is the enemy of good:** If you're a CS grad, understand that much of the theory you learned in school is great, but you are (most likely) not doing pure research here...your company has hired you to build and complete a project. You can't get hung up on the best theoretical way to accomplish something...sometimes you need to just actually produce the desired output. Now, that certainly doesn't mean "write any terrible code that gets the job done", but rather what I mean is that you need to be careful not to spend weeks trying to make something perfect when you could have done a good-enough job in days. Perfect code is not likely much more valuable to your employer than good-enough code. Of course this is highly subjective, and I can't quantify the difference between "good enough" and "perfect"...but in time you'll be able to find the right balance. **Don't take it personally...** ...when testers find bugs, or when other engineers critique your implementations (unless they're being jerks about it). Just look at these as opportunities to learn how you can do better next time around. There really is no single correct way to write your code (especially in Ruby), but there are a number of great techniques as well as a number of generally bad practices. When other devs suggest a different approach, try to figure out what about their solution might be better than yours. Is it easier to change? Is it easier to test? Is it more performant? Is it easier to understand? Maybe it just is more consistent with the patterns already in use across a large existing codebase. You could certainly let all these conversations get you down if you view them as pointing out your deficiencies...but that's not what they're doing. Instead, they're trying to teach you. Of course you'll have to use your judgment to figure out whether someone is just offering their personal preference, or if it's really sage wisdom. **Learn to write tests:** If you listen to everything else that has been said, you'll figure out that there's a good chance that code you write will have to change. Maybe because there was a bug, or you found a better implementation. Whatever the reason, if you write some decent tests up-front, you can be a lot more confident when you go to refactor it. If test-writing is new to you, find someone on your team who cares about it (not everyone does) and ask if you can pair-program with them while building something new and writing tests. Especially if you want to do TDD, getting into the right mental model is just so much easier if you have someone who can walk you through how they do it. This, IMO, will also make you much more valuable down the road. __Edit to add one more tip:__ One thing I did when I was first starting out which, looking back, was really valuable for me was to review the commits from other developers. I started doing this by just looking at how they fixed defects. The nice thing about a bugfix is that they're usually really surgical in scope so you don't have to have a deep understanding of the whole system to have the necessary context for just a few lines of code. Plus you've usually got a brief bug report you can review to understand the functional requirements pretty clearly. Yet despite their simplicity, they can teach you a lot about lots of different areas of the application you're working on. Then you can graduate to reviewing code which implements new features. This is a great way to passively learn how the other developers think about the system, what kinds of patterns they're using, etc. It can also be a great way to learn something new about your programming language - again, especially in Ruby where there are so many ways to do any one thing. If you're using something like Github, you can easily tag the developer in a comment and say "Wow, I didn't know about Array#count - that's handy!", and in one simple step you've learned something new, started building a relationship with another dev, and shown that dev you actually want to learn.
Command inheritance makes sense but validation should be limited inside the commands to Paramus level validation. Business logic validation belongs elsewhere. I forked your repo for my idea of position containing check on validity. https://github.com/pcresswell/toy_robot I also think direction could be improved such that a direction object could calculate the resulting x,y position given a starting x,y position. This allows you to hide the internals of direction better instead of step calculations being done outside of direction object. 
what do you mean by "reverse one of the directories" and "include comments in the path so that the portion of the string is ignored but not by regex?
Something to add to "Expect to ask questions": **Know how, and when to ask questions** It's really easy to think "Well the seniors are going to know the answer to my question, so there's not much point in bashing my head against it when the information is easily available". In my first internship, one of my co-workers gave me some advice that helped me more than a lot of stuff at uni did: **You must try, and then you must ask.** When you're stuck on something - say a test is failing and you're not sure why - beat your head against it for 20 minutes. Even if you can't fix the problem, try to use this time to figure out what is happening, and why. Once this 20 minutes is up, you can use the knowledge you've gained over this time to ask a much better question. Instead of saying "Hey Dave my test is failing and I don't know why" you can say "Hey Dave, something weird is going on with this test. I think that it's saving something to our postgres instance, but when I check psql I get blah blah blah". This not only helps whoever is helping you fix the problem - they have more information available to fix it with - but it shows them that you're willing to actually *try* to fix things on your own. And who knows, maybe they'll be asking for your help at some point 🙂
Really nice info and tips from the top post. The only thing I can add is: Ruby is not a very beginner friendly language because of all the convention over configuration stuff. You might find a lot of meta programming magic that is hard to google.
By reversing the directory I meant if in the path you go to directory A and then into directory B, if there's something in the path to denote going back up to A. By including comments I'm asking if there's a way to have certain parts of the path string ignored. Eg &gt;File.Open("%This part is ignored%Users/A/B/file.txt") would be treated as &gt;File.Open("Users/A/B/file.txt") Highly doubt that using the %s would do the trick though. Mainly just wondering about how extensive the syntax for paths is, whether it's literally just directory and file names sandwiched between "/"s or if there's something deeper
Right. For some reason I thought that repository methods only accept actual entities as argument and do not accept hashes. But I was wrong.
The Symbol.all_symbols call is just giving you all of the symbols currently created as an array, just whatever happens to be in the ruby runtime at that moment. The map call returns an array which is the result of the block you pass to it applied to each of the array elements. Map just means do something to each element of the array and give me the results back as another array. Did that help? Wasn't quite sure what you were looking for?
Thank you so much! That is the perfect combination of technical speak and laymen's terms. It makes it much easier to understand. I try using Ruby-doc.org but find it very technical. I guess I just have to keep referencing it and pick up the concepts through exposure. Do you have any other resources for a noob like me?
Thank you! This was helpful. I am just starting to understand the different ways of writing syntax and why one might be better then the other. I also didn't know about implicit values so thank you :)
Also the returned "gibberish" from IRB makes more sense now. I thought I had broken it and didn't realize it was returning classes.
Awesome! Thank you for your help
Regarding various serialization formats, jsonapi-rb is currently aimed at generating JSON API (as per the http://jsonapi.org spec) only. Depending on the details of other specs, gaining support could be as simple as creating a new renderer (though this is not a priority at the moment). Regarding a "JSON API input validator", there's already the jsonapi-parser gem, which is part of jsonapi-rb. It does not support inline nested associations at the moment though, as this is currently not allowed by the spec. Apart from that, deserialization happens in three phases in jsonapi-rb: first the input is validated against the spec, then a flat hash is built out of it, and validation happens afterwards. So your check for accepting a collection association would happen as simple parameter validation, looking for the `foo_ids` key on the result hash.
You're right, I will try to do that during the coming week. I would like to create some kind of generic way of testing JSON API compliance + benchmarks (c.f. https://github.com/json-api/json-api/issues/1098), but it's probably too ambitious at the moment, so I'll start by making a simple benchmark for jsonapi-rb.
I personally think this is the best book for a beginner learning Ruby. It's free online: https://pine.fm/LearnToProgram/
Great, jsonapi-parser sounds like exactly what I was looking for, thanks!
You're completely right, I'm not sure how I managed to mess that up. Thanks, I've edited it.
I made this because I wanted to read /r/talesfromtechsupport in a more comfortable way :)
thank you so much that makes so much sense now!
That is awesome! I'm going to use this.
There are so many little conveniences. I made this PyCharm tips video: https://www.youtube.com/watch?v=tRg7-9LI7Pk&amp;index=4&amp;list=PLEtC2iwVrNRZdd5HqafuFMWjG-V_i16rO&amp;t=1s PyCharm is made by JetBrains so almost all of these tips apply to RubyMine as well.
rubymine license server http://jetbrains.tencent.click
Thank you. Is this legit?
For Python, right?
PyCharm is for Python that is correct. RubyMine is made by the same company and they are very very similar. Most of the features are the same so if I were to do a RubyMine version the video would almost be identical.
I use RubyMine and I'm surprised on its ability to provide useful autosuggest and refactoring in the face of Ruby's meta programming.
 http://technology.customink.com/blog/2015/06/22/rails-multi-database-best-practices-roundup/
Ruby Installer for Windows currently ships with an older version of RubyGems, and, without going into too much technical detail about SSL certificates and such, the solution is to update to latest RubyGems, and you will be able to install gems: 1. Download https://rubygems.org/gems/rubygems-update-2.6.8.gem to your computer, say C:\Users\Administrator\Desktop, then, on the command line, run the following steps. 2. C:\Users\Administrator&gt;gem install C:\Users\Administrator\Desktop\rubygems-update-2.6.8.gem 3. C:\Users\Administrator&gt;update_rubygems After this, you should be good to go and install any gem that does not require compiling native C extensions. If you need this (and you will most likely need this), follow [these instructions](https://github.com/oneclick/rubyinstaller/wiki/Development-Kit) to set up DevKit for your Ruby installation.
I personally don't use an IDE as I prefer the Vim+tmux combination (just Vim is fine as well). It might take some time to get used to Vim if you never used it before but it definitely worth. I think many rubyist share the same opinion and if you are interested this is a good starting point: [Chris Hunt / Ruby Productivity with Vim and Tmux](http://www.chrishunt.co/talks/2013/04/04/ruby_productivity_with_vim_and_tmux.html)
Debugger is really nice and practical. There are some problems (really long time to hit debug point, pry is better at that) with it when you try to debug classes with multiple nesting inside arrays etc but looking at our codebase we have only one such subproject with too much meta programming. In 99% cases its fast and easy to use. You should probably just get the 1 month trial and check how it works. Looking at few youtube videos is a big plus, because you might not even know about a lot of features.
I used Rubymine before. Now I use vim+tmux. You can use pry debugger with vim. Writing code close to the terminal level is quite empowering and once you grok the basics, it will become your IDE.
You might check out something like cloud9 or nitrous for doing rails :)
Not a chance
https://github.com/Inityx/robi/issues/3
You're welcome :)
If you're into Atom, Sublime, etc. and are an experienced dev, you might be doing yourself a favor by trying vim or emacs. These things are so tried and true, have such a huge ecosystem and are used by such greybeards that they end up being incredibly nice to work with. Apologies if you've tried already, but it sounds like you might be ripe to get into em if you haven't.
It is definitely not essential, I would guess most of us on here just use SublimeText (or even vim). But a significant minority do use RubyMine and like it. Definitely not "essential". 
I've been doing Rails dev since the early 2.x days, and I've tried several times to use RubyMine, but I find that the complexity just gets in my way. If you'd really apply yourself to learn how to use it fluently, it might be worth it. However, it definitely feels sluggish compared to just using SublimeText or Vim and a terminal.
Rubymine is really useful for Ruby development. I learned to code ruby via vim and a command line, and then found Rubymine and I enjoyed it more. Rubymine has tons of features I find convenient and helpful, powerful refactoring tools and interactive debugging. You can do all these things via Vim/pry/debugger/whatever but Rubymine wraps it up in one useful package. Also has docker deployment support, support for all kinds of non-ruby but relevant files. JS, html, coffesscript, markdown, etc. There is a plugin for just about anything that will make the IDE support almost anything.
You're right, I was thinking more of rails and other frameworks like rspec, etc
The sinatra app, is nicely written! Good job.
It would be better to just have your 3 files, plus another for seed data. You don't really need a DB for this, you just need to create a small amount of data to run through it, which you will probably do in your specs anyways. Another question that might be useful as you progress is why do you think you need Rails involved? i.e. what "free methods" do you think you need, and why is the stlib not enough? Even if I'm interviewing someone to work on a Rails app, I'd be hesitant if they reach for Rails/ActiveRecord/ActiveSupport for an interview code test, unless there's a great reason for it.
this question shows if you understand algorithms for directed graphs. introducing rails as a solution might not give others confidence that you understand how these types of problems are solved
Yeah it's overkill you don't need Rails to test plain old Ruby (if this is the reason you're choosing Rails) Just make a Gemfile with rspec in it, create spec/spec_helper.rb . Require whatever classes/files you're using, and also rspec. use spec_helper in your test files. 
So for this question, if I were say screen sharing with you, you'd expect a certain amount of just ploughing through general overhead in terms of things like: require 'pry' require './list.rb' require './node.rb' RSpec.configure do |c| c.color = true c.formatter = 'doc' end in my _spec file before I even get into writing up some tests. And then the requires at the top of each class and say generic methods like self.all in those classes which will call from class constants within the classes (allowing me to just check up on my nodes if I wanted to? Do some people have a directory they can just clone that might have a generic _spec.rb set up with the configuration and maybe a file that is like class1.rb and class2.rb that already require each other so that they can get started? Or would that be weird? I'm trying to get an idea of what a pro interviewee would do or a pro interviewer would expect. The only reason to 'rails new' is to just so I could add the classes and the spec all hooked up with no time at all. Lastly, for a question like this. A large part of it is just implementing the linked list itself right? So much of this is going to be creating the node and list classes before even starting on the .cycle? function? Thanks so much! 
ah! I'm able to use 'rspec example_spec.rb' to run tests right now. I was wondering why just 'rspec' itself wouldn't work. If I include a gemfile and set the directory up like that, I'll just be able to call 'rspec' on the CLI? So much of my Ruby learning happened inside apps that I am actually facing an unexpected learning curve in terms of creating a nonapp environment for things like testing single classes or methods. I guess outside of academics and interviews that doesn't come up so much.
My solution is 30 lines long including a looping and non looping test case, a `Node` class and the `contains_cycle?` function which is 7 lines long. Don't over think it.
The question is to write one function. That is all. No dependencies, no tests, no data. Just one function.
Your solution is what you'd come up with in an interview setting? Can you post it?
&gt; no tests, no data. Just one function Then how will you know if it is right? 
Quite a few ways to approach this but this is how I'd do it: **Create a new directory to work in if not already provided:** `mkdir linked_list_cycles` **Create a Gemfile for rspec** source 'https://rubygems.org' gem 'rspec' **Bundle, hopefully nothing breaks ;)** **Create a spec for the node:** # spec/linked_list_node_spec.rb RSpec.describe LinkedListNode, type: :model do end **Expecting that we'll get an error since LinkedListNode doesn't exist, so create it** # linked_list_node.rb class LinkedListNode end **Still red, need to require it in our spec** # spec/linked_list_node_spec.rb require_relative '../linked_list_node' RSpec.describe LinkedListNode, type: :model do end **Outline our tests for the _contains\_cycle_ method** # spec/linked_list_node_spec.rb require_relative '../linked_list_node' RSpec.describe LinkedListNode, type: :model do describe '.contains_cycle' do it 'returns true when a cycle exists' it 'returns false when a cycle does not exist' end end **Run, still green, start with true path** # spec/linked_list_node_spec.rb require_relative '../linked_list_node' RSpec.describe LinkedListNode, type: :model do describe '.contains_cycle' do it 'returns true when a cycle exists' do a = LinkedListNode.new('A') b = LinkedListNode.new('B') a.next = b b.next = a expect(LinkedListNode.contains_cycle(a)).to be_truthy end it 'returns false when a cycle does not exist' end end **Red, _contains\_cycle_ doesn't exist, create it** # linked_list_node.rb class LinkedListNode # ... def self.contains_cycle(node) end end **Red, expected true, got nil** at this point you could joke about just sticking true in the contains_cycle method and really TDDing it out or just jump into implementation # linked_list_node.rb # ... def self.contains_cycle(node) cursor = node.next while cursor &amp;&amp; cursor != node do cursor = cursor.next end cursor == node end **green, then fill out the false path** # spec/linked_list_node_spec.rb require_relative '../linked_list_node' RSpec.describe LinkedListNode, type: :model do describe '.contains_cycle' do it 'returns true when a cycle exists' do a = LinkedListNode.new('A') b = LinkedListNode.new('B') a.next = b b.next = a expect(LinkedListNode.contains_cycle(a)).to be_truthy end it 'returns false when a cycle does not exist' do a = LinkedListNode.new('A') b = LinkedListNode.new('B') a.next = b expect(LinkedListNode.contains_cycle(a)).to be_falsey end end end **green, the interviewer will probably inquire if this works for all cases or what happens if we have a loop that doesn't loop back to the start. Modify the test to cover this...** # spec/linked_list_node_spec.rb RSpec.describe LinkedListNode, type: :model do describe '.contains_cycle' do context 'cycle exists' do it 'detects root cycles' do a = LinkedListNode.new('A') b = LinkedListNode.new('B') c = LinkedListNode.new('C') a.next = b b.next = c c.next = a expect(LinkedListNode.contains_cycle(a)).to be_truthy end it 'detects tail cycles' do a = LinkedListNode.new('A') b = LinkedListNode.new('B') c = LinkedListNode.new('C') a.next = b b.next = c c.next = b expect(LinkedListNode.contains_cycle(a)).to be_truthy end end end #... **running this will result in an infinite loop, time to revisit the _.contains_cycle_ method** # linked_list_node.rb class LinkedListNode #... def self.contains_cycle(node) visited_nodes = [] cursor = node.next while cursor &amp;&amp; !visited_nodes.include?(cursor) do visited_nodes &lt;&lt; cursor cursor = cursor.next end visited_nodes.include?(cursor) end end **green again, to conform to the requirements you should also add a _#data_ method that returns @value** **EDIT: to solve using [Floyd's algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare) which eliminates the need for a tracking array** # linked_list_node.rb # note the safe navigation syntax requires Ruby 2.3+ def self.contains_cycle(node) slow = node fast = node.next&amp;.next while (slow &amp;&amp; fast &amp;&amp; slow != fast) slow = slow.next fast = fast.next&amp;.next end slow == fast end
I think I'd ask the interviewer if they'd like it done with tests or not. When I interview I like using basic tests to help outline the general outline of the process we're tackling. In my experience it helps the interviewee as well as myself as it facilitates discussion into the direction to take while solving the question
The interview question doesn't really care all that much if it's right. They care what your code looks like and how you got to it. If you're in a live interview, thinking/talking your way through a unit test or two is plenty of testing. If it's a take home test, then writing a test or two for it will probably get you some bonus points. 
Not OP, but Byebug is all I use right now and its quite effective.
Go through some of the videos here that interest you, Thoughtbot is a great resource for intermediate Rails developers: https://thoughtbot.com/upcase/the-weekly-iteration
Could you add an ID attribute to each of the involved element in this case, then select with "#" instead? Might be easier. 
You might be able to use nth-child matcher to isolate the button you need. 
You can write tests with [Rspec](http://rspec.info/) which is very popular in Ruby community. There's also [Minitest](https://github.com/seattlerb/minitest). For debugging, you can watch Jim Weirich's talk on [Mastering the ruby debugger](https://www.youtube.com/watch?v=GwgF8GcynV0).
`first('.myclass').find('mycity, ca').click` or `all('.myclass').first.find('mycity, ca').click` The latter may be preferable as I don't think the former has waiting logic.
you can use `find_all(&lt;css_selector&gt;).to_a` to get an array of nodes. You can then use `.first`, `.last`, or other array methods
[removed]
Yeah, it seems so. That would fit with Google's strategy to offer certain capacity for free each month vs Amazon's, where they provide you with a free tier for the first year, but charge you for everything afterwards.
What the heck are you talking about? What has this question got to do with Rails/ActiveRecord/Databases? Here is a quick solution that I just knocked up in (literally) 2 minutes: def contains_cycle?(node) known_nodes = [node] while(node = node.next) do # If the node has already appeared before, then there must be a loop! return true if known_nodes.include?(node) known_nodes &lt;&lt; node end # We have reached the end of the list, with no repetitions false end 
I'd probably go for something like this with relevant specs: class LinkedListNode include Enumerable attr_accessor :value, :nxt def self.contains_cycle(node) node.each_with_object([]) do |n, visited| return true if visited.include?(n) visited &lt;&lt; n end false end def initialize(value) @value = value @nxt = nil end def each(&amp;block) return to_enum unless block_given? yield(self) nxt.each(&amp;block) unless nxt.nil? end end
You can make an IDE from Emacs and Vim, both free of charge. I code in Emacs and with melpa packages it offers everything I need: code completion, full featured debugging, repl, project management, code style linter etc. Best it can be used for almost any programming language and is available on any operating system. Learn once, use everywhere. My 2 cents... 
Doesn't that almost approach the territory of pseudo code? It doesn't necessarily work perfectly but it's the untested gist of the idea? One thing I did here definitely was not stop long enough to really think through the pseudo code in my head before starting to code and ended up having to backtrack a major blunder.
Capybara author here. Ignore the solutions telling you to use `all` and `find_all`, they are generally more trouble than they're worth due to Capybara's waiting behaviour. The best solution is to add something to the page which makes the link you're trying to click specific enough that there's only one match. If that for some reason isn't possible, for example if you're using Capybara to test something you can't change, you have the following options: 1. Use an `nth-child` or similar selector, as in `find(".my-class:nth-child(2)")` or whatever. 2. Use `match: :first` as in `find(".my-class", match: :first)` the match option is a little strange though and it might raise a few eyebrows.
&gt; One thing that had killed me is I had two classes, one for list (and one for nodes) which was defeating the entire point of the nodes, but I didn't realize that at first. It's actually fairly common to have a two class implementation of `LinkedList`, so that isn't too big a problem. It just wasn't needed in the context of this question. I think there are a couple edge cases in your answer, you may want to try out some more inputs with it. EDIT - I think it's fine actually, indentation got me at first glance. Here is my version: def contains_cycle?(node) slow, fast = node, node loop do slow = slow.next fast = fast.next&amp;.next return false unless slow &amp;&amp; fast return true if slow == fast end end
You are definitely onto something here. On the whole, while I feel pretty good about my Ruby learning process, this is certainly a the gaping hole that I'm now scrabbling to fill in: the process involved many prepackaged exercises with test suites included, either downloadable or on the web so that I'm doing my extreme rudiments in environments that are already set up. Then I went straight to Sinatra and then Rails and started working with those as environments. But there is A TON of things skipped in the leap from figuring out what a hash does or an array is to working with routing in Sinatra, namely everything about knowing how to set up an interview solution with tests, or a basic file structure from scratch. I included my solution a few comments up if you're interested. I'm moderately satisfied with it. I didn't automate the creation of my seed data which another poster showed me I could have done really eloquently. Also it took me way to long to implement the linked list itself for testing purposes (I chased a rabbit down the hole of a separate List class that defeats the whole purposes of a linked list by putting it in an array call nodes *facepalm). And to be honest I overheard a discussion of the concept of this solution in a restaurant over the summer. At the time my first thought was, "gosh I'd never have thought of that." But I feel like a lot of common interview questions require exposure to some clever gothchya solution, or at least a stroke of uncommon inspiration. I may be too cynical on that front. I haven't seen enough questions to really say that, but the recursive solution to nth fibonacci (which I don't like as much as the linear one anyway) has me thinking that. My interview is tomorrow so I'm not sure I'm ready for a real impressive smash up, but I'm going to keep lining them up because they really force you to get into the nitty gritty and carve out your weaknesses. One last thing, the comments in this thread really run the spectrum of how people think about TDD/BDD in an interview situation. There is everything from 'run your tests' to 'talk out your tests and get a pseudo codey not necessarily unbuggy thing together'. I guess if I'm eventually to white board I should get used to the latter. But I am really inclined to test drive whenever possible. Thanks for mentioning that it may have been good instincts that led me to sniff out the overkill of Rails to this situation. I think n00bs all feel terrible most of the time and need all the help encouragement they can get!
Do you think it's realistic for someone to be able to come up with the O(1) space complexity solution in an interview situation, or is it really something you'd need exposure to beforehand? Is the 'tortoise and the hare' type implementation a study of something that can come up and will be helpful, or a clever trick for interviews and a test of your preparation? 
I'd recommend https://rubytapas.com as well, though he only has a few videos on there for free.
The reason for this is that some of those functions are defined or overloaded by Active Record, and some are not. #present? is an object-level check, which basically asks if the object ( in this case, the collection ) is non-nil. If you call that on a collection/active record reflection, it will load the entire collection, and then ask if that collection is non-nil. #any? is implemented over #count, which is why you see the counting behavior. #count is performed efficiently, but when you are just asking if count &gt; 1, you probably want #exists?. ( See: http://apidock.com/rails/v4.2.7/ActiveRecord/Relation/empty%3F ) #exists? is just asking "is there one record in the database?", which is why it is the most efficient of the three, and is usually what most people want. It actually forms a SQL query which is specifically going to tell the engine to stop once it finds a single record ( SELECT 1 as one ... LIMIT 1 ). ( See: http://apidock.com/rails/ActiveRecord/FinderMethods/exists%3F ). The weirdness usually is understanding why #any? and #exists? are different : it's easy enough to understand present? by understanding that it's not touched by AR at all. But the reason why #any? and #exists? are different actually has to do with the fact that #exists? processes set conditions in the query, whereas #any? is actually operating over #empty? when the association is not loaded. It should be noted though, these benchmarks, particularly the #any? vs #exists? benchmark, will get much closer as more joins are added and especially when you add ordering. When you do an ORDER BY, you will require loading the entire result set, and then the gains of LIMIT 1 become less remarkable. EDIT: Additionally, if the collection is already loaded (such as an with an included assocation), the situation is actually reversed. #present? is by far the fastest, only checking for non-nil. #any? will revert to collection.length, which is basically an Order(0) operation, but #exists? will actually do the processing again within your record cache, making it the longest of the three. It should be noted that trying to adjust or plan for this is probably a Bad Idea, as checking associations' load status is probably not something you should be concerned with writing application code. More often than not, the association will be unloaded rather than present. 
This is actually really good to know. I'd forgotten the wisdom about starting with a brute force/naive approach and jumped to the cycle detection, which actually could make me look like I didn't even consider storing all the pointer values which I did!
I think from a practical perspective, you are right, exists? is probably a better choice. "why" is probably a simple matter of history. I'm not sure, but I would suspect "any?" predates "exists?", because "any?" is a part of the Enumerable interface and would be a natural overloading candidate. There are fringe cases where "any?" is faster, but that's only when the association is already loaded. 
Interesting read. I didn't know all these rules for when table locking might occur. FYI using domain models in migrations is always a bad idea. Who knows how that domain model might change in the future breaking any migration using it. 
&gt; in my opinion, someone asking interview questions like this should consider any reasonable solution a success, not only the optimal one. This is helpful. Sometimes if the brute force or naive solution is obvious to me I avoid it (such as store pointer values in an array) because I think it's a trick. I have to fight that and remember to just go for green before refactoring or anything else. The DB thing was an initial blunder on my part. I wasn't exactly sure how to implement a linked list at first and considered taking advantage of rails relations, the file structure, the baked in specs, but that was the start of quickly realizing how to set up something way simpler and also figuring out the simple linked list implementation. 
I think that would be a much bigger breaking change than changing INT to BIGINT.
Thanks for the feedback! Agreed, using models in migrations is risky and definitely requires watching out for breaking issues like that. I've even seen people actually define "empty" models within the migrations themselves to help avoid those types of issues e.g. class SomeMigration &lt; ActiveRecord::Migration class SomeModel &lt; ActiveRecord::Base self.table_name = "some_table" end def change # use SomeModel safely for basic operations here end end Still not quite as ideal of just using SQL for these types of changes though.
Thanks for capybara!
some applications rely on ordering of those things. Using UUIDv4 would be a breaking change with dire consequences 
You can default to using UUID’s for primary keys in generators if you want. I submitted that patch last year: http://www.mccartie.com/2015/10/20/default-uuid's-in-rails.html
Oh yea great point, I've definitely run into that before! This gem raises an exception if you try to mix schema with data changes in the same migration to help prevent these types of headaches!
I mean, if you are concerned about keyspace you could just use int16 and have as many possibilities as a UUID.
Did not know they existed, a quick google did not bring anything up for rails tough. TIL
Or where you don't want to reveal how many things there are by putting the ID in the URL.
Hint: lines = File.readlines("blah") lines.each_with_index do |line, index| # Here you have the line and the array index in the lines variable. end Stop thinking about searching the entire file in one go, think about searching each line atomically. 
&gt; Friends don't let friends use INT as a primary key. The rails community lost it. Your blog's not going to have 2.1 billion articles. Your online store won't have 2.1 billion items. You Ain't Gonna Need It. It's unnecessary overhead in 99.9% of tables for the 0.1% which might need it one day.
Well if you build blogs, then yes. I'm working in an app that generate about 100 million records per day. While we delete them weekly, if we used int we will have hit the end of the sequence in around 1 month.
Rails is a framework used at all sorts of scales, it shouldn't be defaulting for the minority. &gt; I'm working in an app that generate about 100 million records per day. 100 million records per day in one of the tables. What percentage of your tables are likely to ever reach 2.1 billion rows? And how far in the future is that likely to happen? Most tables it makes more sense to just monitor instead. It's not hard to keep an eye on max(id) and warn devs when it reaches say 70% of the datatype's upper limit. Then you can use tinyint for your employee_id until you have at least 180 employees. It's not they'll hire 80 of them over night. Friends don't let friends default to BIGINT.
Honestly with how good WSL is sounding in the future it will probably be the better route to take.(if it isn't already)
&gt; lines = File.readlines("blah") &gt; lines.each_with_index do |line, index| &gt; # Here you have the line and the array index in the lines variable. &gt; end I'm not quite sure I follow... Could you please ellaborate?
In practice, however, relying on the client to generate good UUIDs is fraught with danger, even if you control them. Trusting the client to do the right thing is always a bad idea. Additionally, there are some great advantages to monotonic sequences: 1. They're smaller. This can be a big deal if you're working with tons of rows--that space actually does start to add up sometimes. 2. In some databases, primary key indexes are faster to construct for them. This depends on how the UUID type is stored (Postgres, for example, doesn't use clustered indexes so there's little performance downside to UUIDs as primary keys there) 3. Using keyset pagination becomes a whole lot easier. `OFFSET` with `LIMIT` is the source of a lot of performance problems. Of course, you're right that the impact of these might not be a problem for many applications. Also, I think base 64-encoded UUIDs look fine in a URL.
I generally recommend not forcing dependencies on your end users. Unless you have very specific issues you shouldn't be requiring dependencies for a simple API client. JSON is not needed unless you are stuck supporting 1.8. Requiring faraday just creates the chance for conflict with the user's app. If you want to give them the option of the underlying HTTP client you can use something like httpi(http://httpirb.com) but for the majority of use cases, Net::Http is fine.
&gt; The point is, there are a lot of apps that do reach this limit. A small subset of tables in a small subset of apps. You're defaulting every table in every app because of that. &gt; No one ever thinks they'll hit this limit There are 3 types of tables to distinguish from this perspective: 1. Will overflow a 32bit int primary key eventually 2. Could overflow a 32bit int primary key eventually 3. Will not, under any circumstances, overflow a 32bit int primary key. Those tables are created by engineers who can use their brains to enable bigint for 1 and 2. &gt; Defaulting to BIGINT isn't a big deal anymore (not like it used to be) HIV isn't as big of a deal as it used to be either. Take this example: logs: id BIGINT auto_increment (1 billion rows. Will overflow one day) user_id BIGINT (100 rows. Will not overflow) product_id BIGINT (1000 rows. Will not overflow) action_id BIGINT (4 rows. Will not overflow) 11GB overhead from using BIGINT in 3 foreign keys which would always fit in INT. 15GB overhead if you include id, which was prematurely set to BIGINT, but at least that one saves us a painful migration. Twice the size the table is supposed to be. That's not even counting any indexes (which would also be double in size), temporary tables or effects on runtime performance. All of this because twitter didn't have foresight or monitor datatypes on their database?
People really should consider moving off of Windows 7 as it is already entered End of Life for mainstream support. Extended support will end in early 2020. https://support.microsoft.com/en-us/help/13853/windows-lifecycle-fact-sheet
But if the first bug report was in 2009, according to the article?
&gt; For some time &gt; 2020
You calculated primary keys, I'm talking about their respective foreign keys. I actually miscalculated, it's more: 4 bytes overhead * 3 foreign keys * 1.000.000.000 rows = 11.18Gb 
Also worth noting that depending on your backend, you may not actually see that size overhead, or you may be paying that same overhead regardless of if you're using 32 bit integers or not.
I would recommend reading [POODR](http://www.poodr.com/), it's a great intro to OO in ruby context. I'd also recommend searching for talks by the author, Sandi Metz - many of her conference talks are around OO.
That's no excuse for tailoring rails for narrow use cases. 
You are absolutely right, if you run them in the wrong order, things will probably not work like you expect. But, practically speaking, I've found it REALLY useful: composable, easy to extend with customer-specific logic, etc. As an example, I get a request to export 6 months of data from a specific data set within a given bounding box, for a specific set of categories, etc. You probably get the picture. I can make a really light weight rake task for this, and it gets saved in code, documented, etc. It's easy to re-run 12 months later.
I agree. When I need my tasks to take arguments, for example, that is the moment they no longer are actual rake tasks, but commands instead. The only state I think is warrented in rake-tasks, are some environment-variables that you can drop in a `.env` file and leave there; things like a $DB_URL, or a $SALT or so. Anything more dynamic, and it no longer is a real Rake task, but a command.
I disagree with your logic. You're only considering the chances of this happening while not taking into consideration the cost of it happening. Think in terms of pain. While maybe 0.1% of all apps will ever __need__ this, those that do hit it are guaranteed to be high volume apps. By definition you won't exhaust your IDs unless you're using lots of integers. The downside to running out of integers is HOURS of downtime just for the migration. This doesn't include any downtime you incur before you realize that your system is blowing up. While it might not be a common occurrence when it does happen it is extremely painful. When we look at the flip side of things, what is the cost? Your primary concern is in storage space. By definition if you're not using all that many IDs, then you won't need as much storage space in the first place. It's just not a concern. If you really want to optimize for this case you can, as Jon mentioned, do so, by setting your keys to 32bit integers. Would you rather your default assumes your app is wildly successful and plans for that eventuality, or assumes that it is mediocre at best and is extremely miserly with memory? You might have noticed most of the comments on this thread aren't crying that this is a waste of bits, but instead asking for the default to go __further__ by using UUIDs. I appreciate the concern and I understand where you're coming from. However I would argue that the "narrow use case" is a low volume app without that many entries in the DB that REALLY cares about the memory size it's taking up. &gt; For context i'm in the top 50 rails contributors, and wrote the tweet quoted in the article. Yes, i've personally run out of integers in an application, and seen more than a few really smart people shoot themselves in the foot doing the same. Here's a semi-related blog post to my thoughts on tool design https://www.schneems.com/2016/08/16/sharp-tools.html 
You are correct. It's especially bad when using task dependencies and IMHO it breaks the entire rake abstraction (to have tasks with arguments). However, in practice, it is pretty useful. Perhaps an alternative to rake may be more suitable?
Example #1 was pretty confusing due to the same name of the tasks. Is it running both tasks because they're called the same (like in example 3) or because of the `=&gt;`?
Thanks! I (sort of) understood the significance, it just confused me a little that they were called the same. It would be a clearer example if they had different names so you understand exactly what's going on. namespace :db do task :environment =&gt; :outside do puts "db:environment" end task :migrate =&gt; :environment do puts "db:migrate" end end task :outside do puts "outside" end Is this what is happening? I'm still a tad confused. 
Nope. 
To be fair... it doesn't matter. &gt; #Contributing &gt; Contribute in the way you want. Branch names and other bla-bla-bla do not matter.
that's rad
What is the rationale for `#round` to default to nearest-even? When is this preferable over the previous behavior? Update: Here's the discussion about the change. https://bugs.ruby-lang.org/issues/12958
`compare_by_identity` for set looks like a bad design, it should be part of the constructor or a subclass..
Looks good. I like how you used bang methods.
Here: https://www.microsoft.com/en-US/download/details.aspx?id=53314 - it is a 150MB PDF file. 
What's wrong with Ruby's standard library URI.parse ? Every URL is a URI. 
This depends on a number of factors, so it's hard to answer in the abstract. The first question is, "how did you install Ruby"? The answer to several of these question depends on that. Specifically * where do the gems live * where does the under-the-hood ruby code live * how does it update Here's some small insight into the questions I can answer: &gt; where do... the globals live It depends on what specifically you mean by "globals" here. `$var` globals? Or something else? &gt; how come I don't always need a Gemfile A `Gemfile` is used to configure Bundler, a tool for managing gems. If you're not using Bundler, you don't need a `Gemfile`. 
for those too busy/lazy to dig into this, the reason is that standard round-up will create an upward bias, leading to a set of rounded numbers having a greater average than their true average, which means the numbers don't best represent their original values if round-even is used, then there will be equal amounts of upward and downward rounding, which (on average) balance each other and thus no bias is created. the numbers will continue to be as true to their original values as possible of course, this is not applicable to the rounding of a single number in isolation (ie. the more numbers that are rounded the more balance there will be), so for a single number it may seem odd and explicitly defining the type of rounding might be a better choice
Nearest even is the least biased way, and it's IEEE 754 standard mode for a reason. It's totally ridiculous to have broken floating point arithmetic, like ruby used to. I'm glad they finally fixed it.
It's for consistency with `Hash`.
FYI, the "http" part is a scheme, not a protocol https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax
god, I miss VimMate. It was everything you needed in an IDE: graphical folder browser on on the left, docked, tabbed terminals on the bottom, gvim in the main pane. 
After reading more, I get how it is more balanced now. I am now confused why they would fix it for Float but not change the BigDecimal behavior (I might be missing something).
vim-fireplace is for Clojure rather than Ruby, but it also offers this feature in addition to its REPL integration, and it's *amazing*. I like IDEA's IDEs a lot, but the simple, powerful workflows you can put together with just Vim plus a couple of plugins are really impressive. EDIT: Accidentally a language.
mqybe not breaking money calculation gems?
Thank you and everyone involved for making the search results better! I use DDG many times daily and the method level instant answers for Ruby are already super useful, so I can't wait to see either improvement live!
Very kind of you to say so, thank you! I'll pass that on to the rest of the team.
I use Janus Vim https://github.com/carlhuda/janus it's collection of vim plugins that make vim as close as IDE as possible :) ..I'm using vim over 7 years now, not changing it to anything else ,no way :) 
Everything is wrong. You will understand that as soon as you start using it. Here is what you need to do in order to add a parameter to the query string using URI.parse: uri = URI.parse url uri_params = uri.query.present? ? Hash[URI.decode_www_form uri.query] : {} uri_params.reverse_merge!(default_params) uri.query = URI.encode_www_form uri_params uri.to_s With Furi it is just: Furi.defaults(url, query: default_params) 
Yes, I know that. I was thinking how to name it. And stopped at 'protocol' being the default and 'schema' being an alias because 99% of developers call it protocol. 
I suggest using ripper-tags instead of ctags s lot faster and a lot more accurate
Alright I can see params being awkward since uri.query doesn't return a hash.. I agree that causes a good amount of boilerplate.. especially when doing set_form_data etc in Net::HTTP.. Why not use URI + your API for params to reduce boilerplate? I don't go out of my way to re-write https://tools.ietf.org/html/rfc2396 is what I'm saying
I quite like the manual approach here. I never need to mutate URI parameters like that -- what circumstances would cause that need to arise? If I ever did, a few lines of code are far cheaper to maintain in the long run than an extra library dependency.
Do you round money?
Agree. It depends on the problem you are solving. I didn't consider writing a library until I got into a lot of it. You may explore the Rails or Rack source code that have a ton of URL processing code to see an example of the hard working with URLs. 
Interesting idea! Doesn't work in production when ruby is installed as root but run as a user specific to the app. I suppose this is when I will hear about how I should be using Chef or something, but we are phasing out this part of our business and switching to PAAS as much as possible specifically because I don't have time to do it properly.
just write a shell script that calls ruby-build, switches to the ruby just installed (with chruby, rvm, whatever you're using to make the ruby installed by ruby-build usable), then does `gem install bundler`? 
If you're using rbenv, which also uses ruby-build, you can use [rbenv-default-gems](https://github.com/rbenv/rbenv-default-gems).
So if you aren't using a `Gemfile`, you aren't using bundler. Gemfile is just for bundler. If you don't use bundler, then `require 'gemname'` will load the _latest version_ of the gem installed in your system gems. (Not true for very old rubies which required a `require 'rubygems'` first, but rubygems has been automatically available since I think ruby 1.9, older rubies not really relevant anymore.). Where are the "system gems" installed? They are installed in the "ruby" directory, but where exactly depends on if you are using 'raw' system ruby, or rvm, rbenv, chruby, etc. But all those things just let you install multiple rubies, so each ruby obviously need to be in different places. (You can do this 'by hand' without a tool like chruby/rvm too, but it's a pain). To see where, under your currently used ruby, gems are installed, just pick an installed gem (or install one), and then run `gem which [name of gem]`, say `gem which bundler`. That will show you where that particular gem is installed, it'll be in a directory with all the other gems installed in the system gems for the particular ruby version you are currently running. I don't entirely understand your other questions, can you provide more context on what you mean by 'under-the-hood Ruby code', 'globals', and 'how does it update' (what's "it")? If the "it" in "how does it update" is "ruby", then the answer is "it doesn't." You can install new versions of ruby when they come out, either replacing the previously installed, or using a ruby version switcher like chruby, rvm, or rbenv, to have multiple rubies installed at once and switch between them. `rvm` is quite popular and, when it works, "just works", but a lot of experienced rubyists prefer `chruby`, which does less, is much simpler, has fewer bugs, is easier to debug. `rvm` will also install rubies itself, with `chruby` you use another tool, typically either `ruby-build` or `ruby-install` to install rubies to the location `chruby` will look for them. (Theoretically you _could_ just install from source, but it's usually easier to let a tool do it for you). 
It does.... My lib is only about good and logical API designed for an url processing at scale and precision.
For those who don't know it, also check out addressable, it's pretty great. https://github.com/sporkmonger/addressable
To avoid errors, display formatting is the last thing that should be applied to data, so it should be done in JS or maybe even CSS. It should not be done in Ruby.
It looks really cool though :)
I think it's a common misconception that strong mathematics is necessary to be a good programmer. Strong mathematics can be very helpful but in general the bulk of programming work is more about keeping clear abstractions and not repeating yourself in code. Further I suggest that you continue your mathematical studies but don't let any hardship in that department constrain you in your search for a job. Rather you should focus on building applications in Ruby or any language of your choice. As you become familiar with many of the common types of applications that are available to build particularly in tutorials you will increasingly become familiar with the mathematical Concepts that are most useful and that context. I realize that's probably not the answer that you're looking for however I hope you still find it helpful.
Big O notation is extremely important for interviews. You should be able to defend the efficiency of the algorithm you created to solve a particular problem with Big O if asked to do that. It's not difficult, fortunately. I've had to deal with the fibonacci sequence once for an interview question and found that guy to be overall insufferable, and looking back on it being thrown a useless question about something that implies a certain background (I knew what one was but didn't know it was called that) makes me even more glad I didn't get hired. /rant. 
boolean logic.
Lots of good answers here. I suggest learning game theory. It really helps me when I am designing full functions. It's essentially boolean logic, forced through a set of conditions, and the outcome is either equilibrium (cooperative games) or 1|0 (competitive games). I'm over simplifying but I really find that taking a course or reading a book on game theory will change the way you think about things. Your decision process will be affected by the knowledge! 
Set and graph theories 
I agree. Learning about patterns, implementing them, learning how to test Really Well, finding out how to organise a gem, experiencing a refactoring of spaghetti app, optimizing an ugly slow query, etc. In my 18+ years of development, I've only needed red/black balancing, Fibonacci, or tail recursion optimisation in interviews, never in any Real Code. I do need listeners, decorators, presenters, extraction, anti corruption layers, file and directory structures, decoupling and so on, on a daily base. 
TBH, these features all sounds like they suck: minor tweaks and no cleanup of the stdlib wasteland. Pretty much what I'm used to seeing from the closed cabal of ruby devs.
Are you familiar with logic and algebra? Great, you've got enough to be a programmer. In the real world, as you get better, you're going to need to understand data structures and algorithms and the computational cost of each. Go get a book on DS&amp;A and understand it. Explain things in Big-O. Then do some basic statistics. Most real world applications in the modern era are going to involve statistics even if it's just figuring out averages and percentages and 95th percentiles. At that point, you should really be focusing on software architecture: design patterns, domain driven design, knowing the benefits of MVC vs CQRS, etc. The rest of the stuff you're looking at is basically interview tricks. They're fine, and they're good puzzles to help expand your knowledge, but they don't require _deep_ study.
`(class &lt;&lt; self; self; end)` is the same as `singleton_class`. I guess the code you're looking at was written to work with ruby 1.8.
Thanks, that clarifies it a lot. It's from a gem, so it especially makes sense that they'd want it working with 1.8.
[It performs assignment iff the LHS is falsy.](http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html)
I completely agree. I found it in the RSpec gem source code, and it's taken me a bit of time to understand everything it's doing, but I've learned a lot. Thanks for the explanation!
&gt; It's identical to [...] No, it depends on what `some_code` does -- see [this comment](https://www.reddit.com/r/ruby/comments/5hkw91/can_someone_explain_what_this_code_does_class/db13wo9/). 
we use that to cache things like data connections that reach out to third party services and have to auth on initialization. def connection @connection ||= Connection.new(some_auth_token) end
Actually to be frank, no it doesn't. 1.8 was deprecated years ago.
So does that mean this might be code that hasn't been updated since 1.8 was deprecated? 
I mean, for loops aren't used as much in Ruby, but that's not the problem here...how do you write out your solution beforehand? Can you write your solution in pseudocode? If you can't, but skip straight to JavaScript functions, that could be a problem later on. If you can, and just have to frequently look up the appropriate Ruby functions, that's fine and to be expected for a language you use less often. So which is it? Once I know I might be able to provide more advice.
In Ruby you'd probably represent this via more functional constructs, although I'd do this similarly in JS as well. A `for` loop is extremely rare in my JS code and usually due to some language oddity. POLICE_IDS = (1..7).reject(:odd?).to_a FIRE_IDS = SANITATION_IDS = (1..7).to_a POLICE_IDS.product(FIRE_IDS, SANITATION_IDS).select { |team| team.reduce(:+) == 12 }
Usually I pseudo code it and look up the methods I need- thats kind of how I ended up writing the loops out in js. The js was more to get an idea of how it would play out. I assumed i would be using a block in ruby, but couldnt figure it out.
Thanks for the example. Do you have a long form example?
The so called "long form" based on your code would look like this. Without seeing what you tried in Ruby it's hard to know where you're struggling but my guess is it's just basic syntax. If you find yourself falling back to writing javascript like psuedocode then you're probably lacking a fundamental understanding of what you're trying to accomplish. It's common for new developers to just start coding without explicitly determining what they are trying to do. (1..7).each do |police| (1..7).each do |fire| (1..7).each do |sani| if (police != fire &amp;&amp; police != sani &amp;&amp; fire != sani &amp;&amp; fire + police + sani == 12 &amp;&amp; police % 2 == 0) puts "police: #{police}, fire: #{fire}, sani: #{sani}" end end end end
If it ain't broke, don't fix it :)
I have been programming for about 10 years, and work for an analytics company, and I suck at maths. This comment is so correct. 
I'm not sure what would have given you that assumption. I'd strongly encourage loading up irb, the ruby interpreter in terminal and testing small code samples. I do this when I'm not sure what something will return or if I need to verify syntax on something.
Here is the ruby way: (1..7).to_a.permutation(3).find { |x| x.any?(&amp;:even?) &amp;&amp; x.reduce(:+) == 12 } [Array#permutation](https://ruby-doc.org/core/Array.html#method-i-permutation) returns all arrays (in this case, of length 3) of the elements of the original array in different orders. This handles the department numbers being unique. Then we want to `find` the first permutation that satisfies the conditions: one number is even (for the police department) and the total is 12. These conditions are checked in the block, using `&amp;:even?` as a shortcut for the block `{|y| y.even? }`.
Passing a block to methods as you call them is a huge part of what makes Ruby tick. You'll see that pattern a lot. If you're familiar with JavaScript and specifically Node.js, it might help you to remind you that this pattern is present with JavaScript "callbacks" too. The code... app.get('/', (req, res) =&gt; { res.send('Hello, World!'); } ...involves calling a function and passing a String to be the route, and a function that accepts two parameters to be the code run when the route is triggered. You're passing behaviour. The Ruby code... app.get '/' do |req, res| res.send 'Hello, World!' end ...would be the equivalent if this were implemented in Ruby instead. Another good way to understand Ruby blocks is to learn about them from the other side. Learn about the "yield" keyword and practice making methods that take blocks as arguments. You'll get to see what goes on under the hood.
Ok, so instead of thinking of the whole thing at once have you tried breaking it down into steps? Given two strings what procedure would you use to tell which one was further 'up' the alphabet?
We'd still be living in the Stone Age with that attitude.
If the other gem does the same thing, then just fork and send PR. If not, then come up with a different name.
You could google sorting algorithms and implement one yourself ? You know: using loops, conditions, etc..? Does that help ?
A very simple sorting method would be something like this: 1. Go through all the items and compare the current item with the next one. 2. If the next item is smaller then swap its position with the current item. 3. Keep doing this this until no more swapping is required. This means the next item always larger than previous.
Ut's memoization
This is not necessarily correct. You are assuming `self` is a class, but it could be an instance in which case your code is incorrect.
It also depends on what `self` is.
It's basically a shorthand for a ||= b # same as a ? a : b # if a is already initialized then do nothing else give it a value # more correctly though if a is not falsy
Have you actually tried to write a solution yourself? You'll get more help when you run into a problem to ask a specific question than you will when you ask people to do all the for work you. Anyways, it helps when you break down what you want to do into smaller steps: * enter a keyword, either the name or phone * it will read the file for the keyword, find the line with the keyword * delete the information or just replace it with a blank space
'f = File.open("coords.txt", "a") do |ofile|' 'puts("Enter a keyword:") query = gets.chomp.to_s name = File.open('coords.txt') matches = name.reject { |name| name[/#{query}/i] } matches.delete_if { |name| name[/#{query}/i] } puts "The person has been deleted" This is what I have so far. If I put the File.open to w or w+ instead of a, it deletes everything. Where is the problem?
&gt; A single unified namespace is one of our best design choices. Agree to disagree I guess. &gt; It prevents a malicious user from publishing a backdoored, destructive or otherwise harmful gem that has the same name as an established gem. This is untrue. DNS itself is the only central name registration system we need. A domain name is a valid namespace, and even more secure than fake namespaces using rubygems today. I could publish a gem called "dry-bananas" and pretend it's part of the dry-rb project. &gt; We don't need six "actor" gems, half doing one thing and half doing another, we need collaboration between programmers. I am not interested in salvaging someone else's gem that they haven't even updated in four years. And they probably aren't interested in collaborating with me because they are evidently no longer interested in their own project. Every gem on rubygems I've looked at that offers abstractions for concurrency misses the mark of what I was looking for when I wrote my library. I am not motivated to go spend my free time on projects that don't achieve what I am looking for. Plus it's hard to introduce a radical idea in an existing codebase. We need to be writing new libraries in order to try out new ideas. A community where all the library names are all already taken is severely hindering radical breakthroughs.
Yeah. Honestly, telling my users to do this isn't all that bad IMO: `gem "ntl-actor", require: "actor"`
If you really need the deletion to occur within the same file that you're using for input, you might want to consider this approach: * Open the input file for **reading**. * Open a temporary file for **writing**. * Loop through each line in the input file, deciding whether or not you want that line to appear in the temporary file. If it belongs, write it to the temporary file. If it does not, skip it. * When you finish that loop, close both files. * If everything completed successfully, delete the input file and rename the temporary file to the original name of the input file. To read how to do several of those things, you can consult the [File](https://ruby-doc.org/core-2.2.2/File.html) and the [FileUtils](http://ruby-doc.org/stdlib-2.2.2/libdoc/fileutils/rdoc/FileUtils.html) API docs. There are several ways to do it, but File is generally good for opening, reading, writing, and closing files, while FileUtils might be more helpful for other operations like renaming and deleting files. 
I suggest you do a search for your issue. For what you're doing, almost all questions you have, have already been asked. [https://lmgtfy.com/?q=ruby+remove+single+line+from+text+file](https://lmgtfy.com/?q=ruby+remove+single+line+from+text+file)
You can just use grep (or sed) for this. grep -v keyword oldfile.txt &gt; newfile.txt
I believe this is what is called a bubble sort? I managed to do this using recursion... now I'm not sure if I could get this working without it, but the code seems to work! Thanks to everyone for the replies. Any critique or advice is helpful. # unsorted = ["large","guy","and","in","bread","charge"] def sort(arr) length = arr.length swapped = false (length-1).times do |test| if arr[test] &gt; arr[test+1] arr[test], arr[test+1] = arr[test+1], arr[test] #p arr swapped = true end end if swapped == true sort(arr) end return arr end #puts sort(unsorted) p sort(unsorted) p sort([4,3,2,1]) p sort(["z","y","x","w","v","u","t","s","r","q","p","o","m","n","l","k","j","i","h","g","f","e","d","c","b","a"]) 
RubyMine is great. The ability to quickly find source definitions was a game-changer for me. Its vim plugin is awesome, gives you best of both worlds.
Sorry, I meant in the `Gemfile`. In my code, I don't use the `gem` method at all. (Actually, in production environments, I don't even have rubygems loaded; I pass `--disable-gems` to `ruby`)
Yup my bad, not caching.
well it depends, it's like with learning Ruby on Rails. Some prefer to learn Ruby lang first and then jump to Rails. Other jump to Rails directly and figure out how Ruby works from there. Same is Janus. Some find it too frustrating to deal with plain Vim as Ruby editor and jumping directly to Janus hepls the transition. 
You could do this! Look into the csv library. Learn how to convert from array-of-arrays to csv format, which you can then open in excel. In an array of arrays, each array is a row in your spreadsheet, and then each item in the array is a cell in that row. Look up array to csv and vice versa, some good tutorials on that out there 
Yes, the [RubyXL gem](https://github.com/weshatheleopard/rubyXL) can read and write .xlsx documents (but not .xls). The syntax is a little weird but not too hard to figure out. But I've used it and it works great.
I think roo is the best gem out there at this point for excel and also supports google sheets and libre/open office. 
It would have been a lot better to just come up with your own name.
Sorry, I should have been bit more clear and less pedantic :) `class &lt;&lt; self` opens the singleton class of `self` so what I was saying is your first code is correct when `self` is a class, but `self` can be an object, in which case your code doesn't do the same thing. Eg. irb(main):001:0&gt; class Fish irb(main):002:1&gt; end irb(main):003:0&gt; Fish.bark NoMethodError: undefined method 'bark' for Fish:Class irb(main):004:0&gt; (class &lt;&lt; Fish; self; end).send(:define_method, "bark") { p "Bark" } Here we have opened the singleton class of Fish... irb(main):005:0&gt; Fish.bark "Bark" =&gt; "Bark" and added a method to it. This is exactly the same as your code, we have added a class method. In fact this is the mechanism that Ruby uses to add class methods. But we can do the same for an instance of a class. (Classes are instances of class Class so the mechanism is the same) irb(main):006:0&gt; guppy = Fish.new =&gt; #&lt;Fish:0x007fb5ea10eeb8&gt; irb(main):007:0&gt; guppy.bark NoMethodError: undefined method 'bark' for #&lt;Fish:0x007fb5ea10eeb8&gt; irb(main):008:0&gt; (class &lt;&lt; guppy; self; end).send(:define_method, "bark") { p "Bark" } Here we have opened the singleton of the `guppy` object, and instance of `Fish` =&gt; :bark irb(main):009:0&gt; guppy.bark "Bark" =&gt; "Bark" and added a method to that. This is not the same as the code you posted. This method has only been added to guppy, not other instances of Fish. irb(main):011:0&gt; shark = Fish.new =&gt; #&lt;Fish:0x007fb96fa95990&gt; irb(main):012:0&gt; shark.bark NoMethodError: undefined method `bark' for #&lt;Fish:0x007fb96fa95990&gt; 
You're getting downvoted because you went ahead and did a thing that lot of people find really annoying, not because you disagree with how rubygems is structured. I agree, it would be better if we had better gem namespacing, but we don't. 
There is some idiot in the world for every case of stupiditity. If we care about them too much, we don't progress.
&gt; File.open to w or w+ instead of a, it deletes everything. Where is the problem? `"r"` is the proper mode if you only want to read the file. `"w"` is if you want to just empty the file completely then write to it. `"a"`will append data on to the end of the file, which is useful sometimes. You don't need to keep the file open the whole time, and you can re-open a file using a different mode. Get the data in/out then close it again, right in the block you give when you open the file up. Try this. data = File.open("example.txt", "r") {|f| f.read.split("\n")} # f.read gets a string, then we split into an array on newlines so no chomp needed p data.reject {|x| x =~ /#{ARGV[0]}/} # p data is like puts data.inspect which is really useful sometimes # ARGV[0] gets the first command line argument from when you open the file. Put something simple in the example.txt file like, cat dog and pig or whatever else you like. Call the file from the command line with `ruby example.rb cat` with several different arguments, including things not in the file. Then call it with just `ruby example.rb` without any arguments. Play around with the example code until you figure out how to represent your data structure and get rid of what you don't want in a safe way. Check [this link](https://ruby-doc.org/core-2.2.0/String.html#method-i-split) for how to make use of split to convert your input data into neatly separated string entries in an array. Don't worry about getting it into the file until you've worked out the rest. The simpler you try to do this, the faster it will go for you between attempts. Try to figure out what the code is doing and why. Check the documentation to help you, it's hard at first but it will save you a lot of misery later on. Also try to figure out things like, what's the most effective way to represent each entry of data once you have what you want out of it. That will help you write the logic that does stuff to the data before you put it back in a file.
[removed]
I tend to separate different projects with different sessions, while I use windows and splits for project related stuff, like logs, consoles etc. I wrote this in ruby because: this is r/ruby, I'm ruby developer, tmux is extensively used by ruby developers. If you don't like this script, but would like to use it, I have one written on sh https://gist.github.com/askhat/784dbd1b856a0e138fd6192abee67abc
For those who somewhy don't like this script being written in ruby https://gist.github.com/askhat/784dbd1b856a0e138fd6192abee67abc
They've changed their minds on this: https://bugs.ruby-lang.org/issues/12958#note-18 Thankfully. I completely agree with [Mathew Murphy on this.](https://bugs.ruby-lang.org/issues/12958#note-16)
Nice ty
Is this just a referral via codequs.com? FYI the final price on udemy.com is $10.
I hate it when they fix the bug, and then unfix it because some lazy idiots can't be bothered to upgrade their faulty software that depended on the bug.
&gt; You're getting downvoted because you went ahead and did a thing that lot of people find really annoying It was either that or not be in possession of the motivation to spend my free time designing, building, testing and documenting an open source library. I agree that my approach is suboptimal, but aside from being incompatible with other gems named "Actor" and an extra bit of explicitness when declaring the gem dependency I don't see how I've potentially inconvenienced anybody in any material way. &gt; I agree, it would be better if we had better gem namespacing, but we don't. Yeah, we have to make do with what we have. Contorting the name of my library to avoid all the taken ones ranges from annoying to utterly infeasible, depending on the popularity of the intended name.
`::` is indeed for namespace resolution, but you can actually use it to invoke methods! `'foo'::size` is 3, but it's best you promptly forget that. Methods defined directly on classes (class methods) are almost invariably invoked with `Class.method`, but that you *can* do it with `Class::method` is a large part of how this notation came to be widespread; that it stands out a little better than `.method` is probably the rest of the puzzle. `#` is (or certainly should be) strictly used to indicate instance methods.
&gt; we need collaboration between programmers. A single namespace encourages that This is not borne out by practice and what we can observe. Collaboration between programmers by force, which is effectively what the constraint of a single namespace does, doesn't happen. Or at least, it doesn't produce terribly desirable results. Developers of similar value systems collaborate together, not just developers with similar problems. It's the similarity of the conception of the solution that brings developers together. That's a matter of maturity - and maturity isn't something that can be reconciled by force. It takes time. And often, a solution is needed in a far more constrained period of time that what it takes to reconcile incompatible degrees of maturity.
What do you mean by "no cleanup of the stdlib wasteland"? What kind of changes would you like to see?
&gt; often, a solution is needed in a far more constrained period of time that what it takes to reconcile incompatible degrees of maturity. When you're using software to solve a problem who are you solving it for? If the answer is "me personally" you don't need to use a service like RubyGems. If the answer is "my friends" you don't need to use a service like RubyGems. If the answer is "my company" you don't need to use a service like RubyGems. In these cases RubyGems sure is convenient but you are never forced to use it. You can [set up your own gem server](http://guides.rubygems.org/publishing/#serving-your-own-gems) or make any other distribution arrangement you feel like. This lets you fill your immediate need for a solution to your problem. If the answer is "the community" then you do need a service like RubyGems, but disputes over gem name with the rest of the community does not serve it, regardless of whether name collisions are allowed. If you're bringing something to the community then there is always sufficient time to come to maturity.
https://bugs.ruby-lang.org/issues/12172 has the additional details
I don't know why they chose the `#` specifically, but the reason that they don't use `.` is because class methods can also be invoked with `.` and the symbol is very visible when reading. I've seen this convention in other languages in the past, but I'm not sure if ruby came up with it or if they got the convention from elsewhere.
&gt; I'm not sure to what extend this is useful extent*
&gt; When Ruby (as well as many other kinds of code) is interpreted/compiled, all line breaks are removed. Whitespace may be, too, I can't quite recall. So when desugaring happens, do the line endings get replaced with semicolons?
Does it only take affect if there are two items in the array?
&gt; If the answer is "the community" then you do need a service like RubyGems, but disputes over gem name with the rest of the community does not serve it, regardless of whether name collisions are allowed. But without the possibility of name collision, there would also no longer be the possibility of disputes. The _place_ where a gem is hosted would become part of its canonical identity.
&gt; wrt metaprogramming Can you say a couple more words about this. 
Say you're writing the documentation for `Enumerable#all?`. The one-liner to actually CALL that method is: `Class.new.include(Enumerable).new.all?` And that would just be stupid. Even if we're not writing the documentation for a mixin, and instead for some class `Foo` with instance method `bar`, a one-liner to invoke the method owuld be: `Foo.new.bar` which is still cumbersome. It's simpler to just arbitrarily select a notation that a) can't be confused for something else in the language and b) allows us to succinctly symbolize 'an instance method of a particular class'
Iterating through permutations or combinations of sets of things is an _extremely_ common and fundamental task. Understanding what permutations and combinations are and how to work with them is thus pretty darn useful. Another extremely common and fundamental task is building conditional expressions, i.e., logical expressions based on logical operations. Having real fluency with them is very helpful. It's also common that the kinds of thinking you'll be doing when conceiving of approaching a programming problem are analogous to the kinds of thinking you do in a logic proof, so it's good practice.
I feel your response lacks consideration of how software libraries are developed. I feel you just haven't thought this through with respect to history or politics. &gt; without the possibility of name collision, there would also no longer be the possibility of disputes We've already tried this (the github gem server) and it didn't remove the possibility of disputes, it simply moved the nature of the dispute from direct, "hello fellow Rubyist, I wish to change X in your library" to indirect, as described below. It had many additional unattractive qualities. There was no way for a user to trust any particular fork of a gem without an audit, and it was lots of work for end-users to merge together various forks of differing quality into a usable piece of software. Most people don't want to publish entirely different implementations of the same name, they want to easily distribute the small fork they made, so this is what lack of name collisions would be used for. Some popular gems had competing, incompatible forks. For example, a gem would get two popular forks that added different features, so one name would become three. Time would pass and somebody wanted to use the two forks together and would merge them to create a fourth version, but not submit a PR because they two features had outstanding PRs with the original source. Time would pass and the original author, unaware of this fork, would also resolve and merge the first two PRs, but in a different way. The fourth author, unaware, would add another feature atop their fork, so now we have five versions. Of course, this new feature is not easy to merge with the first author's version. So then we had five competing forks disputing over the same name. The same dispute as before, "what does name X mean?", but much harder to resolve as different people would be using the different author's versions. Furthermore, people expect that name X always means the implementation started by Y. This is a foundation of trust for all the major package managers. If you can convince Debian to change this policy then please come back to us with some patches. &gt; The place where a gem is hosted would become part of its canonical identity. This is already true, and is orthogonal to whether or not that hosting site allows collisions. For example Sidekiq Pro is distributed on a separate server.
Yea we know what it does, but why the &lt;&lt; array "stack" operator? 
&gt; I don't know why they chose the # specifically I think it's a Smalltalk thing. The Java community does it as well.
Edit: Now I feel just plain stupid. So, I guess the non-edit part only applies if you want to put namespaces inside a singleton class for some crazy reason? mod = Module.new mod::Derp = Class.new # Because hey, why now? &gt; but it's best you promptly forget that. It might be worth remembering a little bit. Ruby won't let you use `::` to access constants located inside an object directly so you're reduced to using methods in a chain that does so. It's potentially rather annoying if you ever try to avoid polluting global namespace by sticking some things inside encapsulated objects. Using BasicObject prevents the outside from polluting the inside, you're in the wilds if you want to prevent the inside from polluting the outside while still having unqualified access to that outside. At least, so far as I'm aware. The only time you'd have to resort to any qualified access in the latter case should be when you try to access internals from the outside. obj = Object.new class &lt;&lt; obj Derp = Class.new end mod = Module.new # Using a block would pollute namespace here class &lt;&lt; mod Derp = Class.new end obj::Derp # TypeError: #&lt;Object:0x...&gt; is not a class/module mod::Derp # NameError: uninitialized constant #&lt;Module:0x...&gt;::Derp obj::singleton_class::Derp # OK mod::singleton_class::Derp # OK I guess you could just suck it up, inherit BasicObject on all the things and prefix `::` on *all* the outside things but that feels like even more of a hack to me. idk.
&gt; some lazy idiots can't be bothered to upgrade their faulty software Seems like a bit of a hyperbole. I've got some software that expects rounding to behave like "normal" people expect it to. Seems like this would catch many people off guard. Too big of a change for a minor version in my opinion. I completely agree with this comment: https://bugs.ruby-lang.org/issues/12958#note-16
&gt; No, I think it's wrong to argue for changing the platform because you had to pick a different name than "actor" for your gem. I'm not asking for the platform to change for my one gem. I'm pointing out a problem that I happened to notice _because_ of one gem. &gt; The empathy goes both ways. Spending the time and energy to offer critique is a contribution. I _do_ think you should change how RubyGems works -- I don't even need to imply it. I'll tell you right now. And when folks offer me criticisms for my libraries I thank them because they help me improve. I get that you maintain a project that a lot of people use. I've submitted a patch to it, and I know what the code base is like. Insofar as I have benefited from your work on it, I am very grateful. I want to help improve it. I guess what would help me be more constructive is to understand all your objections to relaxing gem name uniqueness across sources, so I can see if it's possible to address them with a more formal proposal. &gt; When your problem is "I can't use 'actor' as my gem name on RubyGems.org" That's the _symptom_, not the _problem_. The _problem_ is that namespaces inherently fill up, and rubygems.org has already amassed a pretty expansive one. I get your reasons for not wanting to address it -- in your view, doing so would result in a net negative. However, recasting this dialog as me being petty about my gem name is not nice. Internet discussions can get to a crappy place sometimes, and I can't be held blameless, so, well, whatever. Anyways, cheers. **EDIT**: I should also note that if a solution could be agreed upon that worked for everyone, I would be more than willing to do the leg work to implement it.
From trying to understand the patch assigned to that issue (but I don't know much about the Ruby internals, so take it with a grain of salt) I don't think there is a maximum on the length of the array, but it has to be a literal array and used immediately so (`a = [x, y]; a.max` won't work, even if you never use `a` again, which should be kind of obvious)
&gt; I've been trying to express that your issue effects so few users (~40 per day, at most) and such a large impact (all users, millions) that it isn't worth the time to try to fix it. Then why is it an issue that I simply upload my gem as `ntl-actor`?
There's two features here. The first is the C implementation of Array.max will make that ~10 times for any array as it bypasses the each method and just does everything at the C level. This will work everywhere all the time. The second optimisation is a special-case optimisation that occurs whenever [a,b,c].max is detected in the code. It skips the array initialization and just does the max calculation, running about twice as fast as x=[a,b,c];x.max would.
&gt; your comment does not help us extract requirements for making it better, nor does it suggest a way forward that is achievable using limited developer resources Yeah, that's the persistent bummer that's the constant companion of sizable projects. I don't like the idea of having the gem package name have a different naming scheme than the module's namespacing. I'm convincing myself that this isn't the hill to die on, and put a prefix on all the packages. But the way it is now expresses it the way it is in its native namespace without any wasted motion (except for installing it).
but the m3u8 and the link is always changing (new file)
Our aim is to write bite-sized blog posts about the new features coming up in Ruby and Rails. See some of the past posts here: http://blog.bigbinary.com/categories/Ruby-2-4 , http://blog.bigbinary.com/categories/Rails-5
why?
I'm sorry, I don't really know what you mean. "a csv"? `app.rb`? What does your app look like? It sounds like you are not using Rails? Are you using any framework? 
No i am not using Rails, i am using Sinatra at this point. a csv file, comma seperated values. app.rb is simply the name of the app i run to make the app run on my local machine.
Munificent: larger or more generous than is usual or necessary. From "Module UNIFICation". (I dumped that suggestion in the issue as well.)
I find it useful for keeping up with new API, thanks!
I've recently just created a rails 5 app, which has been professionally pen tested (and had all minor issues resolved). I may do a write up explaining some of the lesser-known vulnerabilities to look out for. 
The _real_ (pun intended) reason to do this is that storing and manipulating money with floats is a really bad idea. 
Gosh. That sounds like something that can be done. Callbacks have their time and place. Specifically they tend to be a good fit for small applications. I find that eschewing callback and using method calls inline is more clear (easier to debug) and scales to applications small and large. 
Numbers I could see use cases for... Eg. coercing a number intended as a percent to be between 0 and 1... But full strings? I've never come across a desire to manipulate strings in this way.
Fun one-liner for implementing `clamp` that I always enjoyed: num = 36 =&gt; 36 [5, 20, num].sort[1] =&gt; 20 
We have a use case to clamp the cost of a thing to a min-max limit. The cost should not be less than min and should not be more than max.
Ember.js uses the term 'pod' for this. Not sure where the term originally came from.
Haha, that's clever
That'd be awesome! 
Use `File.read("sequence.txt").chomp` to read the whole file to a string and strip newline characters.
Welcome to programming. I think one good way to get started learning how to debug is to take a very short sample input string, and go through the ruby code doing what the computer would do for each line, on pencil and paper. Then you can understand exactly what the code is doing, and if it's doing what you want. 
Codecademy.com is a good start.
Okay, thanks! I'll check it out.
Okay, I will.
The mnemonic that works for me is: **.** - Period/One; only one class you're calling methods on **#** - Pound/number/many; calling methods on one of many possible child instances of a class I know it's dumb but it's worked to keep me from constantly double checking while I'm writing tests
Congratulations you just played yourself. Russian provided you with a solution to "see how far each A is from the next one". But what you really wanted was to "see the index of each A in a given DNA sequence".
Why Ruby? I love the language, but I would advise against it for a game project.
&gt; Or the reverse. Suppose a class doesn't need attr_readers at all but the test has to check them. Can I add that in RSpec, or only let RSpec access them. In this case, I usually add the attr_reader anyway. You probably won't (shouldn't) have more than, say, 10 instance variables in a class, that's already too many, but you could put them all in one line. If you insist on avoiding adding the attr_reader, you can always ask the instance for the instance variables using something like: expect(my_object.instance_variable_get(:@attribute)).to eq("Hello")
1. Install RSpec (if not installed) 2. Require rspec (inside the spec file) 3. Name the file '*_spec.rb' 4. You have to write your test within`RSpec.describe` block eg ``` RSpec.describe "#reverse" do it "message to describe what your test do"do # your expectation end end ``` 5. Write your test 6. Run it using rspec path/to/file 
For getters and setters look into using Factories or fixtures, factorygirl is a popular gem. For temporary methods I'm not sure what you mean, but maybe look into stubs and mocks. 
It scares me, I couldn't read it :O. def method_missing? puts "Don't read, just comment" end 
what's the game?
Do you have a more concrete example? Why does your spec want to look at the internals of the object rather than its behaviours?
If you need to inspect the insides of a class to check it's operations, you've failed decomposition. If something indicating of a result is hidden, you hid extra. If making it public goes against the class design, your design is faulty. All in all, I have yet to find a case where inspecting privates of a class would stand for a correct solution.
Refactor the class. Seriously. Objects should be tested using the same standard public interface used by your application. If you can't test your object the same way it is used, then there is a failure in design. Otherwise, define your attr_accessors in a module and then within your test: myobjectinstance.send :extend, MyObjectTestHack
Sure! I didn't mean any hate, I was just kiddin :D. 
The first and third should make plenty of sense, as should the second now that you know that `#any?` without the optional block returns whether any of the elements in the collection are "truthy" (that is, not `false` or `nil`).
I think you misunderstood what `.any?` is for. https://ruby-doc.org/core-2.3.3/Enumerable.html#method-i-any-3F It takes a block, without a block, it adds a block `{ |obj| obj }`; as all values in the array return nil, `.any?` will return false.
&gt; Third one... wat?! How could you expect any other value than `3` to come back? I've never used any language that would not consider the array length to be `3`. C, C++, Perl, Python, Ruby, JavaScript, PHP, all behave this way for arrays of null values.
.any? without a block can be used as shorthand for "are there any truthy elements in this array?"
If your array has potential for nils, and you don't want to include them, use `#compact`
I didn't use it for ruby as it wasn't around then but I like exercism.io a lot for learning, it gives you failing tests and you make them pass, a little like Ruby Koans (also decent, but depending on experience a little slow/basic). You also get to look at other peoples solutions when you're done which is good for comparing different ideas/approaches. It's hasn't changed in ages but http://www.puzzlenode.com/ is an interesting approach, a little like project euler, but more programming focused and less math centric.
Yes, I understand. The no-argument version of `any?`, where you do not supply a block, is looking for "at least one truthy value", is what I meant. Becuase the default value when you do not supply a block to `any` is `{ |x| x }` (or the equivalent), and the meaning of that identity function evaluated as a boolean is of course just "a truthy value". 
I'm not entirely following what you get to here: &gt; Becuase the default value is basically { |x| x }, and the meaning of that is "truthy value". `nil` will be falsey when passed to `{ |x| x }`.
Now it all makes sense. 
Instance variables can be read and written via #instance_variable_get and #...set. If the class does not need attr_readers then do not add them (see above). Tests that would be checking it would not be checking class functionality. It does not make sense to add methods for tests only in Ruby as * you have all the options to access instance state and * you should be really testing the abstract data type, i.e. the public behavior. In some cases it may make sense to add a bunch of methods via #extend to an instance but I would be reluctant to do it because of the potential to modify class behavior. Edit: formatting
One of the goals with the [test framework I wrote](https://github.com/ntl/test-bench) was to make it easy to put a small implementation and the tests in the same file: require "test_bench/activate" def some_method "hello" end test "Returns 'hello'" do assert some_method == "hello" end # # OR if you want nesting context "Some method" do test "Returns 'hello'" do assert some_method == "hello" end end You may find it's a little easier to work with for testing small snippets of code or methods.
https://repl.it/ErK3/0
&gt; I want to see how far each A is from the next one. For example if the code goes AGTCATGA, I would like for the script to read the A array as (1,5,8). No, that should be [1, 3, 4] - or your description is not what you want. You result array sounds more like you want absolute positions in the array based off 1 (instead of 0 as is usual). input = "AGTCATGA" data = Hash.new {|h,k| h[k] = []} input.each_char.each_with_index do |chr, idx| a = data[chr] a &lt;&lt; (idx - (a.last || -1)) # alternative: data[chr] &lt;&lt; (idx + 1) end require 'pp' pp data Does that work for you?
You linked to the homepage, not the article in question. https://snyk.io/blog/differences-in-version-handling-gems-and-npm/
Nothing strange about the third one. You have 3 indexes in your array so it returns 3. You are setting each of those indexes to nil. length doesn't factor in if your indexes are truthy or falsey, it doesn't care, it will just return the number of indexes found in the array. You are not asking if those indexes hold any values. You could filter the array to not include indexes which aren't truthy, and call length on the filtered array, which would produce a length of 0. 
I don't know if I can agree. There is no reason you can't ship an object with methods that allow the user to inspect the object. The purpose of a car may be to travel distances, but each and every part within it can be tested by a mechanic. I care little about private methods, though -- the interface that other code should use is always straightforward. Tell, don't ask, right? If you see a public method that returns data, _don't couple other code to it_. `attr_reader` is fine, in my view, for that reason. Encapsulation isn't about hiding state from the rest of your code, it's about designing the your code so it doesn't depend on the state of other objects. Thus, the only benefit that private methods offer is protecting other programmers against themselves. I find it's best to assume the programmer knows what they are doing, and if not, make sure you are not affected by their mistakes. All that rambling about private methods is to say, it's absolutely okay to surface methods that allow tests to verify the behavior of an object. &gt; In some cases it may make sense to add a bunch of methods via #extend to an instance but I would be reluctant to do it because of the potential to modify class behavior. I also do this, as well. I put a module named `Assertions` within the class namespace, and extend it at runtime to offer assertion predicates. For instance: dog = Dog.new dog.bark dog.extend Dog::Assertions assert dog.barked?
&gt; In npm, versions must strictly comply with Semantic Versioning 2.0. Really? Cause npm packages sure don't _act_ like it, I get backwards breaking changes without major version bumps all the darn time from npm packages. Am I just especially unlucky, most people don't have this experience?
Usually algorithms books focus on languages that are closer to the machine so you get an idea of the running time based on your own algorithm. But you can practice algorithms in any language, it's the concepts that matter. E.g. you can go through my [algorithms tutorials](https://www.learneroo.com/subjects/8) and solve the challenges in Ruby if you prefer. 
They don't have to comply semantically, just syntactically. At least they tried, I guess? _____ Hmmmm, I wonder if there's a tool that can test semantic SemVer compliance, and yell at you if you break rules. Or if I could make one...
And here I've been using `#select{|x|x}` like some kind of barbarian
I don't really know how you'd test that, especially in a dynamic language. 
http://rubykoans.com/ Pair that up with either an [irb](https://en.wikipedia.org/wiki/Interactive_Ruby_Shell) or [pry](http://pryrepl.org/) session to figure out how the language works from inside it. You can get the answers the koans expect from figuring it out inside Ruby. I started programming with Ruby and started *that* with codecademy. I had to unlearn a lot of bad code from there so don't be surprised if you need to unlearn bad code from there too. You might have to google for how to do specific things, which isn't bad. When you're a little more comfortable, you can try https://www.bloc.io/ruby-warrior/#/ too.
I agree and further once you get the base algorithms understood it is very unlikely that you will find any further state of the art documentation on algorithms in ruby until those are well aged. It helps to get comfortable reading papers in C and psudocode if your goal is not to just get the basics down but stay at all current. 
Gang of Four?
I prefer to read general purpose of algorithms. I try to figure out which algorithm solve my problem. After that i read the algorithm examples in my prefered language like ruby. Then i try to write the algorithm in my projects. Recently, i use the recursive binary search algorithm in my project. In that point i see the some examples from https://github.com/kanwei/algorithms. Also you can see the old post on reddit about the algorithm learning with ruby https://www.reddit.com/r/ruby/comments/31iqlx/tutorials_on_learning_algorithms_in_ruby/
why?
dude wtf your code: ['abc','cdef','xy','z','wwww'].select(&amp; -&gt;(o) { o.size == 4 }) is exactly the same as ['abc','cdef','xy','z','wwww'].select { |o| o.size == 4 } what's the point of passing in a lambda?
Hope so; explains why I don't know it
&gt; It's just the select(&amp;:size.() == 4) part which seemed impossible. [Of course it's not impossible.](https://eval.in/699129) That said, it really shouldn't be used for anything other than learning or entertainment purposes.
I use this in production. Great library. Great maintainer.