* Specifically for React we have [Rails meets React](https://blog.arkency.com/rails-react/) e-book where testing is described. * You might enjoy [The Hitchhiker's Guide to Modern JavaScript Tooling](http://reactkungfu.com/2015/07/the-hitchhikers-guide-to-modern-javascript-tooling/) which describes the confusing ecosystem and many people enjoyed it. * [Approaches to testing React components - an overview](http://reactkungfu.com/2015/07/approaches-to-testing-react-components-an-overview/) - a very long article about the various ways you can test React. * And our three older articles not React related. Bear in mind they might be a little outdated. We now more often use ES6 over Coffee. And React over jQuery for manipulating DOM: [CoffeeScript tests for Rails apps](https://blog.arkency.com/2013/07/coffeescript-tests-for-rails-apps/) , [Testing client-side views in Rails apps](https://blog.arkency.com/2013/09/testing-client-side-views-in-rails-apps/) , [CoffeeScript acceptance tests](https://blog.arkency.com/2013/12/coffeescript-acceptance-tests/) * The general idea is that you choose a testing and assertion framework in JS and look for gems which integrate them with Rails. Follow their readme and enjoy testing your JavaScript code. 
I really wish more developers thought like this. I *try* to do this on gems that I add that are not my go to gems. Ironically, Clearance is one of my go to gems for authentication because it typically does just want I want. Odd that the author didn't mention that gem.
Remind yourself that developers have two modes: 1) I am a god. 2) I have no idea what I'm doing. I always ask people that express an interest in development if they can handle feeling like a moron on a regular basis. I've been writing code professionally for 25 years and I *still* have days where I feel like I'm an idiot.
&gt; From now on saying "this is bad code" is offensive and against the code of conduct. &gt; Not really I'm not saying that telling someone their code is bad is offensive or against the code of conduct.
Tests are useful, but I'm lazy and a terrible programmer.
In addition to things that others have said, finding colleagues or a community that you can interact with is helpful, IMO. You're discouraged? Other people get that, and someone who really understands might either just let you vent a little, or maybe even help you get over a hump that you're struggling with.
You could do something like this to see how often frozen strings are being called in your example class String def self.frozen_count @frozen_count end def self.frozen_count=(num) @frozen_count = num end String.frozen_count = 0 def freeze String.frozen_count += 1 super end end "foo".freeze puts String.frozen_count 
Thanks for your response. I hadn't even considering doing a wrapper method.
I never test private methods nor classes, but often, testing them through the public interface makes these tests complex and large. To use the example in the article, but make it slightly more complex: class Person class Secret def to_s return "EGG123" if is_easter? return "JINGLE123: if is_christmas? "1234vW74X&amp;" end def is_easter? # complex code to detect easter holiday. Maybe even using some public .ics. end def is_christmas? Date.today == Date.new(Date.today.year, 12, 25) end end private_constant :Secret def show_secret Secret.new.to_s end end Now I would usually stub out the Person::Secret#is_easter? in my tests, in order to not have to setup too much of the outside world for every test using "show_secret". Obviously, there should be one or two tests to actually test, via the public API, that is_easter? works as expected. * Is it considered bad practice to stub out private methods or constants? * If so, how do you keep your unit tests from fanning out into a giant array of combinations (secret when cristmas and not easter, secret when easter and not christmas ... and so on) 
Thanks, I ended, figuring out what I was doing wrong. I wrote it down so I don't have to go through this again next time.
You know, I never thought about that. I'll have to look up exactly how selenium-webdriver interacts with curb. However, I can tell you that it works great on our website, which relies heavily on both jquery and ember.js.
Yeah I set up Ruby correctly and made sure ruby -v was outputting it correctly.
Wow, that's an amazingly detailed writeup. Thank you for the research.
You should be able to spin up your own threads just fine. The only thing to be aware of is that thread creation can be expensiveish and each allocates memory for its own stack, so if you plan to have lots of short-running threads you may want to use a thread pool rather than just spinning up your threads ad hoc. concurrent-ruby already has threadpool support.
Yeah, I couldn't figure out why selenium-webdriver would have anything to do with curb, I think it may not! 
I am imagining some system that tracks any backend URL mocked on the front-end, and ensures that those URLs are also tested as controller tests, and return the same thing they were mocked as. Seems theoretically possible, but probably more trouble than it's worth. *Oh wait*, it looks like that's what `pact` that paneq mentioned tries to do. Intersting! /u/mordocai058, do you have experience with pact specifically or things like it? I don't have an opinion about whether full-stack JS integration tests are "worth it" -- but I am dissapointed in all the crappy options i have available. /u/mordocai058, do you have troubles with unreliable intermittently failing Capybara JS tests, or have you managed to avoid it? And do you use a front-end framework (react, ember, etc)? 
We use angularjs and we have problems with intermittent capybara JS tests but are -mostly- able to avoid them. As in they fail about 1/10(edit: probably less) of the time on average I'd say. At some point in time or another we have hit every single one of the problems you mention in your blog post (we came to the conclusion that deadlocks are indeed a "#2 problem" and due to database cleaner kicking in too early. We managed to avoid them for the most part by changing the couple problematic specs to wait a bit longer at the end through expectations) However, new ones like to crop up that happen more often and then we have to fix them. There are a couple things in your article that I plan on trying because I have not tried them (though someone else in our team may have tried them at some point) like turning on eager load and turning off concurrency. As far as pact, I have not used it nor something like it but it seems like a lot of work/weirdness for something that is still not quite accurate since it isn't using a real browser. Personally I think i'd rather deal with feature tests and get more real-world results. Btw, a link to your post (and cached version) is now on our company wiki so we can point new hires to it rather than having to explain all this.
&gt; Can I just plug it in and rip? Yes. I've done this last year (puma + parallelizing SOAP requests using concurrent_ruby's `Future`) and the production server didn't blow up yet. You "just" need to take care of the usual concurrency issues. E.g. Rails' autoloading is annoying and you need to be careful not to [leak connections](https://bibwild.wordpress.com/2014/07/17/activerecord-concurrency-in-rails4-avoid-leaked-connections/)
Aw, thanks for the compliment, glad you found the post useful. I can't think of any other domain where 10% of the time random false positive failure would be considered "not that much". I think it's kind of ridiculous -- although I understand that feature tests are so valuable that you decide the pain is the neccessary cost. But a situation where we all need to accept (say eg) 10% of the time random failures _and_ spend lots of time on new confusing problems cropping up all the time that we have to fix -- to me clearly indicates a broken ecosystem. I'm surprised it isn't discussed more often. I literally spent hours of research/experimentation on this before realizing that it probably _wasn't_ just me, before starting to suspect that _everyone_ was probably running into these problems (once I started to understand what was causing them). And there are TONS of forum questions and GH issues filed on these, where the maintainers reply implying, if not outright stating, that the only reason you'd run into this problem is because you don't know what you're doing, and once you know what you're doing you shouldn't. 
I wasn't butt hurt. You're just clearly being pedantic for the sake of being pedantic. It makes you feel better about yourself? Fuck, I don't know. But pointing out 2 autocorrect errors just to point them out? That's douche town. 
I'm not sure what you mean -- you can definitely use your own threads to do work, and concurrent-ruby is a good way to do it. You can't use your own threads "handling requests". But yes, if you have two operations that need to be done in your action, and they don't depend on each other, and you want to wait for the _max_ of each of them instead of the _sum_ of each of them -- then threads are a fine solution, and Futures or Promises from concurrent-ruby are a great way to do it. 
I don't understand, why was there an ORDER BY involved in the first place? first_or_create is adding it? Odd. I mean, I guess it is called `first_`. Hm. I am surprised that the order slows Postgres down so much in that use case, hm. 
Yes, the `order by` is added by this function but it also wasn't expected by me. If you think about it it makes sense though.
Why not use find_or_create_by then?
found where I learned about this: https://github.com/SeleniumHQ/selenium/wiki/Ruby-Bindings#using-curb-or-your-own-http-client
I looked at pact more after making that comment and it largely solves the problem at a request/response level but to actually make sure your app works you need to be running it with a browser and it doesn't do that (yes, i'm saying even mocked-with-pact JS front end specs aren't good enough for this). My argument in pact's case is you are trying to mock out the browser and that that is a mistake. If I used pact I'd still want feature specs though I might have to have less. As it is, i'd rather just deal with feature specs.
This. There are many things you can do to improve performance, but always start with the most simple ideas! * Rather than doing `.where(...).first`, use `.find` instead. * If you're being slowed down by lots of database calls, consider if it's practical to make *one* query, and store the result in memory? * If you're still being slowed down by too many database calls, perhaps you need to implement a bulk insert? This is can be a *little* harder to get right, but the performance boost can potentially be huge.
That's fine, you are free to ignore my opinion. That opinion is that all pact is doing is "putting lipstick on a pig" and it is still mocks and mocks suck. I do have experience with mocks.
Kinda confused by this comment, you're absolutely correct, did I imply anything to the contrary? 
It looks to me like you're missing an 'end' after line 29. It might be that you could change 30 to be 'elsif' 
See! I knew it would be obvious. Thanks- i have code fatigue from staring at the computer. 
misspelled 'first' on L20 as well. https://gist.github.com/b-random/dce9d35b2ddab11a7898#file-rock_paper_scissors-rb-L20
Thanks.
I programmed in C exclusively for several years doing device driver and firmware development. And in practice, `goto` tends to be used in conjunction with a single exit point specifically for handling failures. Generally you see this pattern: void some_function() { int fd = fopen("some/file", "r") // etc. if (!something) { goto error_1; } char *buf = malloc(2048); // etc if (!something) { goto error_2; } return some_struct; // happy path exit, all resources allocated are now the responsibility of the caller to clean up error_2: free(buf); error_1: fclose(fd); return 0; } Of course, it's been a while since I touched C, but that was the pattern that was used pervasively in the Linux kernel source, for instance.
Yea, that is exactly what I mean by `Largely it's related to unfounded goto hate.` Been there too man, but most of my C work was to bare metal microcontrollers. ANSI-89 C + the lack of a FPU will make you do all sorts of entertaining things :)
&gt; We did not bother testing at just the Ruby 2.3.0 upgrade without "# frozen_string_literal: true" applied, so we don't know which of the two factors had the bigger effect. I'd be very interested to see the effect of simply upgrading the ruby version.
Yes, that would be much better option :) I think I didn't expect the `order by` to be added to the query but one is always learning :)
I will run through the instructions again now and let you know how it goes. Thanks for the advice.
Thank you. Fixed it.
I've seen this point raised a few times now but it's not clear to me how giving it up/make breaking changes would help. I've read about the tricks the MRI team has done to enable generational GC in Ruby 2.1 w/o breaking compatibility - is that where the possibilities ended? Could you provide some pointers?
awesome, will do.
great blog post! scary stuff - I will probably keep AR out of it for now, thanks.
As you both said, this is a really unfortunate wrong decision of the optimizer. I would be interested to know why this happens. What version of postgres is this? Can you reproduce it with a similar dataset? Any other factors like an uncommon configuration that might play a role? 
If you want fast tests you don't use FactoryGirl. 600 tests in almost 5 minutes on Travis? That's pretty damn slow. In contrast I have a project with 1600 tests, plus Capybara/PhantomJS tests (super slow). The whole thing runs just over a minute. Will throw parallel tests just to keep everything under 2minutes as the project grows.
My work was related to speeding up running single test (or may be a file). 
&gt; Unfortunately those days are gone Nope, this is not a black-or-white situation. All it matters if you, me or other let affect it our lives, our way of thinking. I'm ignoring attempts of control and power masked behind meritorious intentions. Do the same. It's only you what you can influence. *This* shapes conditions at which you and indirectly others would live.
FYI: As an alternative [Brad West](https://twitter.com/bradonomics) has started a [Jekyll Weekly Newsletter](http://jekyllweekly.com) in 2016. This week newsletter #6 is out.
How would Kafka help in this situation?
ruby has the [retry keyword](http://makandracards.com/makandra/5991-use-the-retry-keyword-to-process-a-piece-of-ruby-code-again) just for this type of situation
Thanks for the suggestion. I'm definitely going to try that out. I don't know how I've been writing ruby so long and not known this...
I really really hope rails switches to this so that I can stop crossing fingers while nokogiri builds. Yes I know it has gotten better but still remember the bad days. 
And for JRuby and Rubinius.
Good to hear. I've only used Nokogiri which has always been good enough for me, but glad to hear that there is a lighterweight implementation of xml/html parsing. I was secretly hoping that it'd support xpath 2.0 since it doesn't have a libxml dependency...but I'm guessing that's a hard problem overall.
oh okay thank you i get it now
That is a bummer. 
I haven't written a test that hits the browser in ages. Quality, implementation cost, and maintenance cost have all improved drastically. If the boundaries between your front-end and backend are good, no integrated testing is necessary. Coarse grained monitoring suffices. However, establishing those boundaries is beyond the reach of most teams because they simply don't know how.
It's worth noting that all (most?) sorting algorithms rely on exactly one comparator, so any sorting algorithm can take a comparator as a parameter. You could consider a sort generator that takes a comparator function and returns a full sorting function. That's basically what this is doing, but it's just running the intermediate function immediately on the object. 
Well said. @whistletits try to play with the comparator algorithm to get a feeling of how it works: `['aa', 'b', 'ccc', 'ddd', 'ee', 'f'].sort { |x, y| x.size &lt;=&gt; y.size}` Also, every time you don't understand Ruby standard library behavior you might want to try checking that code in rubinious implemention: https://github.com/rubinius/rubinius/blob/4eec62a07d6b3cbdfee3c4ce0b6e6a18498641a4/kernel/common/array.rb#L1699-L1737
Switching away from a libxml based parser means Rails views that use Loofa would have worse performance.
&gt; If you have big documents that you need to deal with fast, you may need ~~Nokogiri~~ another tool, but otherwise, this is a nice, clean setup. I've had nokogiri choke on far too many XML files.
/u/ackondro has already captured the high-level details, but if you're interested in a little more detail, Ruby (at least, MRI) uses [quicksort](https://en.wikipedia.org/wiki/Quicksort) under the hood. If you look under the ["Algorithm"](https://en.wikipedia.org/wiki/Quicksort#Algorithm) heading on that page, you'll see that in Step 2 values less than the pivot go into one group and values greater than the pivot go into the other group. This is where the supplied comparison operation is substituted: the function substitutes test values for one of the input params and the pivot for the other param and goes from there. It's also worth noting that you can yield a coherent function by supplying anything to the block that returns the way `&lt;=&gt;` returns: array.sort { |x, y| (-1..1).to_a.sample } Will randomize the list (there are better ways to do this) by returning a random comparison value for every pair, so don't think that there's some sort of structural magic going on that means that you HAVE to use a comparison operator. In practice, of course, I've never seen a sane usage of `#sort` with a block that didn't include the `&lt;=&gt;` operator. [](/GNU Terry Pratchett)
&gt; people who believe otherwise are just deluding themselves for convenience. This strikes me as a bit disparaging. I wrote browser tests for years. I know exactly what they bring to the table. Life is better without them.
Auto-requiring files just based on their existence seems like a bad idea to me. That's a recipe for shooting yourself in the foot in 6 months and not realizing why. I would just have `require` lists. If you want to load stuff under cartesian/ when you `require 'cartesian'` then just list them in `cartesian.rb`, so that when you want to use cartesian mazes you just require the one file and it does the rest of the requiring for you. The only time that glob lists are really appropriate is when you're building something that expects arbitrary and unknowable-ahead-of-time file lists (like Rails initializers). For a library, you should be explicit insofar as you're requiring things that you wrote. As an argument against your mechanism, consider that Rails has a convention-based autoloader, which will search the load paths for a file matching the name of a missing constant. If you try to use `Mazes::Cartesian::Grid` and the constant doesn't exist, ActiveSupport will search the load paths for a file matching `mazes/cartesian/grid.rb` and load it. If that file happens to not produce that constant, then Rails gives you the "Expected /some/file.rb to define File" error message. This is flexible, but often leads to confusion and unexpected behavior. In order to ensure that the constants you expect are used from the files you expect and are produced in the order you expect, you should explicitly require them.
Radix sort and some related algorithms don't use comparisons.
Yep. They absolutely are better off with an application that can be rigorously tested without going through the GUI. EDIT: I should mention, there are some web GUIs that are complex enough in their own right to merit focused testing. Trello comes to mind. I think capybara can be a useful tool for testing them, but that's contextual. As a general rule, software can be made incredibly robust with isolated tests.
My point is that it isn't rigorously tested if you don't have browser tests. Since we both have a differing axiom and neither of us seem to have any proof to offer, we should agree to disagree (like I said a couple comments ago).
Does Satan have a GitHub?
Nice. I am currently using [ronn](https://github.com/rtomayko/ronn) but it isn't being maintained. Why should I switch to md2man? Thanks.
Instead of `cattr_accessor` try this: class &lt;&lt; self attr_accessor :foo end Good information about what is going on here: http://apidock.com/rails/Class/cattr_accessor
Hi, For my Ruby projects, I use [Yardoc](http://yardoc.org). It's mature project which provides also plugin system to extend the features.
 [1, 3, 5, 7, 9].inject(2) { |result, number| result * number } # =&gt; 805 No, and what? 001 &gt; [1, 3, 5, 7, 9].inject(2) { |result, number| result * number } =&gt; 1890 002 &gt; [1, 3, 5, 7, 9].inject { |result, number| result * number } =&gt; 945 003 &gt; [1, 3, 5, 7, 9].inject(&amp;:*) =&gt; 945 In other words, what the author showed is wrong code, and a wrong evaluation, and it's not how you calculate the product of an array. "Double the product of an array" might be OK, but then, the answer is 1890. Interestingly, it's correct later, when showing the "less verbose" version.
So. Many. Typos. [1, 3, 5, 7, 9].inject(20) { |accumulator, number| accumulator + value } will return a NameError because `value` is not defined. Even in his first code example: def sum(numbers) result = 0 numbers.each do |number| sum += number end result end `sum` is undefined and the method will error.
cool thanks! here is the commit in the project where the change was implemented: https://github.com/NullVoxPopuli/skinny_controllers/commit/791889ec54df36f02635b7c3725f5a6c808bb166
I tend to use swagger.
You might have encountered a bug in Ruby 2.3.0. That is a very big problem that it happens, because it can make nil go far undetected. Running `nil[:a]` properly throws an error, but not on assignment. I tried something like `1[:a] = 1`, and it also properly throws an error. But I found that `nil[1] = 1` also reproduces your bug and just returns nil. I know Ruby syntax very well, but I can't figure out what the interpreter thinks you've written. I think it's a legit bug, it would be great to report it.
This was fixed but a 2.3.1 release hasn't been cut yet: https://github.com/ruby/ruby/commit/c79402c4f0e40a3ebebda9761e47ff1b3d12ed53
As janko-m already said, this is a bug, please report it: https://bugs.ruby-lang.org/projects/ruby/wiki/HowToReport The correct behavior is to raise a `NoMethodError`: $ ruby -ve "nil[:a] = 123" ruby 2.2.3p173 (2015-08-18 revision 51636) [x86_64-darwin15] -e:1:in `&lt;main&gt;': undefined method `[]=' for nil:NilClass (NoMethodError)
Already been reported and fixed: https://bugs.ruby-lang.org/issues/11976
Isn't that specific for APIs documentation?
We really liked TomDoc as well, but yes, unfortunately it seems like abandonware atm... It felt better than Yardoc, but c'est la vie. If you find a better option I know our team will be all ears!
I've used yard-tomdoc in the past. The tomdoc spec hasn't changed so this might just be a case of a "finished" gem. If you are using GitHub Pages to host the docs I made https://github.com/site5/rake-tomdoc at my previous gig to automate that process. 
I use Atom with the package 'yard', so Ctrl+Enter to generate the docs. With a small script I can 'yard doc' to generate the html, start 'yard server' and 'open localhost:8808' to see all the documentation.
Just require your dependencies. Nothing not future proof about it. Rails attempts to get around this with auto loading end up turning into a huge mess, workaround on top of workaround. Your version is even more basic, and could wind up with performance problems. It's okay to have the man file in a gem or module require a bunch of its components, so you can just require that main file and get everything else. There may be cases where pre requiring things based on traversing the file system really does make sense, but wait until you encounter one, try the straight require first until you have a sense of where it works fine and where it doesn't. Setting the load path as desired is also always okay
Why would anyone downvote this comment? It's a really good advice. With `#fetch` you can either specify that the key is required (`hash.fetch(key)`) or that the key is optional by providing a default value (`hash.fetch(key, default_value)`), not to mention other things you can do with the optional block.
 File.exists?(config) or raise "Configuration file #{config} not found" x.is_a?(Numeric) &amp;&amp; y.is_a?(Numeric) or raise "Only numeric values expected" halted? || waits_for_halt? and raise "Process already halted" This abomination is exactly why all sane style guides ban `and`/`or`
`lib/assets/stylesheets` should work fine, what version of Rails are you using? You can also get the list of search paths by running `Rails.application.config.assets.paths` in the rails console. &gt; PS - that's my plan for altering bootstrap Not sure what this means exactly but if it's your plan to extend bootstrap you should probably pull it in as SASS so you can modify variables / use boostrap's mixins. Much cleaner than trying to override all the resulting css rules.
&gt; Rails.application.config.assets.paths For some reason the command doesn't work for me I'm using 4.2.0 Also, the tree (require_tree) seems to be only accessing app/assets, not vendor or lib assets. It's very difficult to order my own overriding CSS over a vendors, since the only way I can get it to work is in the app/assets with the tree, which necessarily comes before.
Ok that command works. It shows even lib as a path. To test I have a my_css.css file in both the lib and the app/assets folder. If I move the exact same CSS between them, it only works when in the app/assets folder, not the lib/assets folder.
The advice doesn't make much sense in the context of OP. Replacing `[]` with `fetch` would just lead to `nil.fetch(:a)`. Of course it's good advice in general, but it seems unrelated.
&gt; /= require my1_css ## doesn't error, doesn't work Doesn't do anything as it isn't a valid directive. What you've done should work so something is probably missing here, can you post your full code somewhere?
You don't have to. first_name = gets.chomp first_name.capitalize! Should work just fine.
Yeah I'd like a nice style sheet as well. I looked around a few months ago but didn't come up with anything tangible.
I document everything with Yard. I find it quite easy to add into a project and it has a lot of great customizable options. I find it documents and links everything together perfectly. I like the "--one-file" flag as well for smaller projects that don't require many doc pages. 
Hey, update the original post with the answer here so people don't have to read all the way down.
I think the first example is a great use of `or`: list = movie_doc.at('ul#actorsList') or return You could also do this: list = movie_doc.at('ul#actorsList') return unless list But it's not as nice. However, the second example doesn't seem to be that great. I think the excerpt using `unless`/`if` is much clearer. Which is, of course, to say that much of the choice here is very subjective.
I wasn't being a dick, there is no need to jump to conclusions when you don't even know what the comment was about. The 'structure' was a bunch of libraries in one repo/project with a shared test suite and he was creating a 'gem' for each library but considering they are all inter-related and share a test suite at the project level there is no need to create gems for them as they are not, at least as described, separable units of code. The original linked project was an automated way to create these quasi-gems. 
what about first_name = gets.chomp.capitalize!
Those who get serious about writing internal doc really ought to check out [Inch](http://trivelop.de/inch/), which will either motivate you or madden you by showing how well you've done so far and how much is yet to do. It supports TomDoc, YARD, and RDoc. (Does anybody outside the core Ruby team use RDoc anymore?) No association with the project, just a happy user back when we had enough devs to write code *and* doc on our team.
...and this code is bad, because...? ...and in such cases, you prefer to write —...? 
Confusing for whom? And it is so, because... (sense is not clear, can be mixed with somethin else, or what)? 
You see... Familiarity and readability of idioms definitely IS subjective. But it is not constant even for single developer, and its exactly why those blog posts should be writen: next time some readers of it will see this idiom, they would be slightly less alienated by it. Now, why it seems for me `or raise`/`and raise` examples are good. Two things: * statement modifiers quickly became less readable when modified statement is longer than "very short" (modifier becames "not in focus of attention"); * good, detailed error messages, with lot of context, is good thing. Soo, how I see it: # pretty readable raise if snafu? # if can be missed/neglected by reader raise "Dude, it's SNAFU because of good, solid reasons" if snafu? # completely out of focus of attention raise "Dude, it's #{situation_description} in context #{ctx.inspect} "\ "because #{good_reason.inspect} expected, yet #{really_bad_thing.inspect} received" if snafu? # OK, it's ridiculous example, but for example writing parsers # I frequently need to tell something like # "&lt;smthng&gt; on line 7:15 in &lt;document&gt;: &lt;statement type&gt; not expected &lt;in condition&gt;" # but THIS is clear (ok, subjectively, for me): snafu? and raise("&lt;smthng&gt; on line 7:15 in &lt;document&gt;: &lt;statement type&gt; not expected &lt;in condition&gt;") # and can be rewritten in several good ways, like: snafu? and raise "&lt;smthng&gt; on line 7:15 in &lt;document&gt;: &lt;statement type&gt; not expected &lt;in condition&gt;" snafu? and raise "%s on line %i:%i in %s: %s not expected %p" % [message, line, pos, document, statement, context] snafu? and raise "%s on line %i:%i in %s: %s not expected %p" % error_context # ^ here right statement is still to complicated to be readable with # modifying if, yet in current state it is CLEARLY readable even # for quick scanning "ok, checks for snafu and fails somehow" # and it is still readable even for complex conditions: snafu? || Time.now.year.leap? &amp;&amp; isnt_it_ridiculous? and raise ..... # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ # This is part till my 80-char-border marker and I even intentionally # sometimes leave it so - with pretty long lines, when "error details" # going out of focus
The raise versions, if used as guard conditions at the beginning of a method, are MUCH clearer - they differentiate between the 'check things are as we expect' and the 'let's do stuff' parts of the method. If those checks are occurring during the body of your method, it's probably clearer to use a multi-line if or unless statement. One-liners are generally a bad idea in the 'let's do stuff' part.
It might help to know that the analogous operation exists in the Clojure standard library for nested immutable data structures. It's called assoc-in https://clojuredocs.org/clojure.core/assoc-in Seems like the rule is basically to create maps (hashes) if a key does not yet have an associated value along the way, even if the key is an integer. user=&gt; (assoc-in {} [:users 0 :name] 'Matz') {:users {0 {:name Matz'}}} user=&gt; (assoc-in [] [:users 0 :name] 'Matz') IllegalArgumentException Key must be integer user=&gt; (assoc-in {} [0 1 2] :foo) {0 {1 {2 :foo}}} user=&gt; (assoc-in [] [0 1 2] :foo) [{1 {2 :foo}}] So the function differs from your "bury" proposal in that last example. One this that's nice about the Clojure example is that you pass a "key path" as a separate argument from the value. This is nice when you'd like to insert new elements to the key path and perform a different `bury` operation later. Doing the same with variadic arguments can be cumbersome by comparison. That said, the symmetry with `.dig` is very appealing.
You could also have `dig` yield its result (or nil) to a block if one is given. Then either replace the element with the block's result, or if there's some reason to yield to the block without replacing it (I can't think of any though) then implement a `dig!` method to do the replacement.
A bit off-style-guides but i have used in the past a series of custom methods like this Hash#add_arr (key,valuetoadd) Which is effectively close to hash[key] &lt;&lt; valuetoadd rescue hash[key]=[valuetoadd]
I love [Hanna](https://github.com/rdoc/hanna-nouveau).
Confusing for everyone. You had to write an article to explain proper usage. 
Im thinking about writing an API in Grape, but I just dont know how to take my ruby level to say be employable in the field. I hear a lot of talk about programmers are those who create, but it doesnt seem like it's easy to move from this step that we are currently at to the next level without mentorship. For example, not to say I want to build the next github, but how did they get so good at Ruby(the founders)?
Heh thanks didnt realise you could do like that. The things you miss eh?
Every bit counts man. I mean, those hard challenges over at r/dailyprogrammer are certainly more involved than fancy methods. Anyways, there is a subreddit called r/monthlyprogram that's supposed to be dedicated to more substantial projects. I'm not sure if they've posted a second one, but the first project was writing your own unit testing library. Barring that, you could always keep adding features to the projects you've done so far for challenges. I'd also check out the wiki in r/learnprogramming for ideas.
Downvotes happen automatically. It's part of how the voting system is obfuscated. Don't take it too personally.
ok thanks for the encouragement. I sometimes feel frustrated about the lack of help to get to that professional level among coders, but you have been a good counterpoint. I see so often an outcry for programmers and there are lots of us that would die for a role but we need a little guidance.
You're welcome! I completely understand about the whole project thing - a lot of times it seems like everything is either too easy or too hard. These have been great resources for me. Of course, as you continue to learn it won't take long before you start seeing project ideas everywhere, haha. Now if only o had the time to do everything - I suppose getting off of Reddit would be a good start. :)
It sounds like you need to build something real so that you can start seeing where the gaps in your understanding are. I'd recommend the [100:10:1 method](http://blog.fogus.me/2015/11/04/the-100101-method-my-approach-to-open-source/). Think through how you'd actually build all 100 of those projects. Some things you won't be able to imagine, and some things you'll feel are right at the edge of your current skillset. That should give you a pretty good path for improvement.
Are you looking for a pure ruby job or a ruby on rails job because I hardly ever see postings for pure ruby work without web dev.
On a related note, [here's my go at `#bury`](https://eval.in/524941). It nicely(?) demonstrates the fundamental asymmetry that makes such a mechanism unlikely to ever make it into core. :/
Think about something you do frequently or something that your do occasionally that is repetitive. Automate whatever that is. A lot of my personal play projects involve the process of scraping some data from a website somewhere, putting that into a database and then make a little website that serves up the data in a more useful fashion for me.
We could use some help over at SciRuby (http://sciruby.com). If you're a student, you can apply for GSoC; otherwise, maybe you'd be interested in mentoring?
I do concede that your semantics makes more sense than mine, but there's bound to be somebody out there who'd want `Hash#bury` with a numeric key to create an `Array`; there's simply no way to make it completely "unsurprising" outside of being unpleasantly explicit. I confess that my wanting `#bury` is mostly an appeal to symmetry. I'd certainly find a use for it here and there, but more than twice and I'd go looking for where I missed an opportunity to generalize.
You start by building something small. You make it about the experience, not the final product. You increase scope and build something slightly bigger. Rinse and repeat. In parallel: try reading code from great open source projects. Pick simple issues from those projects and attempt to replicate them. See if you can figure out how to fix them and contribute.
If I'm gonna spend the time and effort to learn something new, I honestly think I get more benefit from going the extra mile and learning Elixir/Phoenix (which I'm doing). I'm not talking about leaving ruby, not at all. I'm saying that if you made a list of pro's and con's of learning hanami vs. phoenix, you would probably gain more advantages by diversifying your knowledge base (and you would probably bring more to the Ruby community). But if you want to totally replace (ditch) rails, then yeah I see why Hanami could be a good choice. 
Only one application can listen on a port at a time. 
Obviously, I'm not running both apps at the same time. Like I said, the server works but it doesn't accept external connections, only localhost.
Before [line 83](https://github.com/hankbao/owasp-igoat/blob/master/server/igoat_server.rb#L83) and [93](https://github.com/hankbao/owasp-igoat/blob/master/server/igoat_server.rb#L93), insert the following: &gt; :Host =&gt; '0.0.0.0', This way the server(s) will listen on any IP address.
I don't do much Sinatra but set it just below class GoatServer... You can also do it when starting the server via command line ruby goat_server.rb -o 0.0.0.0
One issue is your create statement. If the first row of the CSV does not match the product name then you are creating a new row in the CSV. I think you probably want that block of code (everything under the else) to be outside of the foreach loop. Example: If your CSV has five rows and you are trying to create a project called 'shirt.' If shirt lives on row three then, with your current code, you would never load the shirt from the CSV. You would always be generating a new row each time. (Unless I am misreading this, I'm looking at it on mobile) 
Thank you, you're right. I just can't figure out how to write the correct logic...
Step through your code and make sure that's the order in which you'd like to do things... You probably want to parse the entire CSV until you either find it or don't. If you reach the end without finding it, that's when you'd want to add it.
That very task is probably the final goal of your assignment and this makes it very hard to answer that question without doing it for you. I recommend you take the advice given to you here and step the code the code yourself on a piece of paper. Pretend like your the computer and run each line. Make note of the current value of each variable and I can almost guarantee you'll hit a point where the next step _you know you need to take_ is not the next step _the code tells you to take_. Be careful to only do as the code directs, otherwise this exercise would be entirely pointless. 
My dream scenario: 1. Submit PRs to those projects to remove its usage. 2. Send a PR to Ruby removing the feature because **there's literally no usage of it in the wild anymore**. 3. No Step 3
I've only heard of one performance improvement that Ruby 2.3 makes that can significantly affect a Rails app, and that's to enable immutable strings. I don't know of any other significant improvements to Ruby 2.3, performance-wise. Are these benchmarks using immutable strings?
Do what I do. Make little text adventure games~!
What about adding a little help to the String class? class String def mutable String.new(self) end end Then, the fix for some of those examples is: s = "".mutable s &lt;&lt; do_something() s &lt;&lt; do_something_else() the intent is clear.
For what it's worth, the image is an SR-latch which does actually somewhat behave like the Ruby operator...kinda... tl;dr just don't use it. 
What if i want it to show all and not just 1-4 in the array?
`User.all`
This is what I have in my ERB file: &lt;% if @sites.is_a? Array %&gt; &lt;% @sites.each do |site| %&gt; &lt;!-- list to make things inline --&gt; &lt;ul class="site_tab"&gt; &lt;li&gt; &lt;a href="/site/&lt;%=site.id%&gt;"&gt;&lt;%=site.text%&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="/delete_site?site_id=&lt;%= site.id %&gt;"&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;% end %&gt; Would Site.all work there would it not because it's not iterating through it
That is because `Site.all` is not an array. You would have to call `@sites.all.to_a`. However, I do not recommend that. `Site.all` is an `ActiveRecord::Relation`. You can call `Site.all.class` to get the exact name.
I believe this was inspired by perl's.
Rubber duck the problem -- it is silly but verbalizing the problem (even to an inanimate object) can really help your thought process work through those kinds of walls. 
 users = User.all users.size #=&gt; 85 users.class #=&gt; User::ActiveRecord_Relation users.kind_of? User::ActiveRecord_Relation #=&gt; true users.kind_of? Array #=&gt; false users.kind_of? ActiveRecord::Relation #=&gt; true users.is_a? User::ActiveRecord_Relation #=&gt; true users.is_a? Array #=&gt; false users.is_a? ActiveRecord::Relation #=&gt; true 
*operators
Indeed, .. and ...
I'm also mad about this. After seeing "swt", I'm assuming maybe something for GUIs. Edit: https://github.com/shoes/shoes
As opposed to `bond` : https://rubygems.org/gems/bond ... A tool for autocompletion ?
My company has been gobbling up all the Ruby talent we can find. We're hiring another 150ish this year. If you're looking for a good way to get in the door on Ruby development take a look a learning test automation with Ruby Watir and Cucumber. Test automation developers are hard to come by so it's a lot easier to get in as a junior.
Aha, makes sense. FWIW, I'll gladly accept PRs and do releases for tailor. If people are still using it out there and willing to keep it alive, I'm happy to facilitate that.
Agreed, I have a half dozen programming languages on my resume and lots of other IT tech, and Ruby is the only one that gets inquiries.
Same here.
I get way more messages on Linkedin in regards to some older Javascript experience I have up there then I do for Ruby jobs. That being said, it is wayyyyy harder to find Ruby developers. Or at least it seems that way given how hard it is for us to hire people. 
Hey Ya-Ying, Didn't mean to ignore you, I've had the flu for the last week, so now I can send you what I did. So, to start with I don't know exactly what is causing your issue or mine, but I was able to fix my problem, so I saved the info/links that helped me out. Most of the other info I found on StackExchange and the rest of the internet didn't help my specific problem, or it did and I didn't understand it. These are not my step by step instructions, just my resources for solving my issue. Here they are, I hope they are helpful: "Holy Shit I finally set it up. Here are the resources that helped. How to setup postgres database for local rails project: http://stackoverflow.com/questions/19953653/how-to-set-up-postgres-database-for-local-rails-project I came across your question when looking for the same answer. I attempted to follow the instructions @prasad.surase gave you. The problem I found is the ppa repository is going to depreciate soon on 12.04 LTS. Instead I found this link and it really helped. PostgreSQL setup for Rails development in Ubuntu 12.04 1. Install postgresql and admin tools through the package manager sudo apt-get install postgresql libpq-dev phppgadmin pgadmin3 2. Login to postgresql prompt as the postgres user sudo su postgres -c psql 3. Create a postgresql user for your project create user username with password 'password'; 4. Setup your postgres user with the same name and password as your Ubuntu user and make him a postgres superuser alter user username superuser; 5. Create the development and test databases create database projectname_development; create database projectname_test; 6. Give permissions to the user on the databases grant all privileges on database projectname_development to username; grant all privileges on database projectname_test to username; To end the postgresql session type \q Update password for the user alter user username with password ‘new password’; Ruby on Rails We replace the values in your config/database.yml automatically. If you have your Rails application in a subdirectory or want to change it from our default values you can add the following to a codeship.database.yml (or any other filename) in your repository: development: adapter: postgresql host: localhost encoding: unicode pool: 10 username: &lt;%= ENV['PG_USER'] %&gt; template: template1 password: &lt;%= ENV['PG_PASSWORD'] %&gt; database: development&lt;%= ENV['TEST_ENV_NUMBER'] %&gt; port: 5432 sslmode: disable test: adapter: postgresql host: localhost encoding: unicode pool: 10 username: &lt;%= ENV['PG_USER'] %&gt; template: template1 password: &lt;%= ENV['PG_PASSWORD'] %&gt; database: test&lt;%= ENV['TEST_ENV_NUMBER'] %&gt; port: 5432 sslmode: disable RailsApps Project: http://railsapps.github.io/rails-environment-variables.html Are you using a bash shell? Use echo $SHELL to find out. For a bash shell, using the Gmail example, edit the ~/.bashrc file and add: export GMAIL_USERNAME="myname@gmail.com" You’ll have to open a new shell or restart your terminal application to continue. " I know this all might seem kind of vague, but it is helpful to me. If you have any specific questions, please ask and I'll do my best to help.
Is there specific reason you're pursuing rails specifically? Although you will likely be able to find work in rails, there maybe more flexibility in other languages. 
I'm somewhat new to Ruby but it seems that `unless` statements are simply `if !true` "shorthand", right? Like you can accomplish the same with an if statement, right? It's nice to have options but as someone coming from JavaScript I couldn't see a desperate need for `unless` statements. Of course I've only been learning Ruby for a week or so now, so what do I know.
I am having trouble finding enough mid-level to senior Ruby developers to hire, the demand is extremely high. 
yitney!
If you're a beginner to Ruby, Shoes will probably make it tough to get started. It's kind of an advanced topic. I would make some simple web apps/pages first and then come back, once you're more familiar.
You can also just use ssh if you are on an environment that allows that, no additional bundler configuration needed. `gem "mygem", git: "git@github.com:user/repo.git"`
Love (and pay for) GoRails, but autoplay videos are really annoying, especially on a hotspot data connection. 
This is data from Indeed.com. I don't think I've ever even looked at Indeed as a Ruby developer, and we don't use it for hiring/recruiting at my job. We're a remote Rails shop, so we stick to [WeWorkRemotely](http://www.weworkremotely.com)
IMO it's not a clear cut answer to be honest, there are alot of things to consider. If you don't have a degree in the field or experience I would guess Rails probably has a lower barrier of entry versus an entry level Java gig. Alot of the decision comes with where you feel like you want to work, and what you feel like you want to work on. Although you may be surprised most of the large corps are using ruby/rails to varying degrees. It sounds like you are trying to break into the industry - so in short yeah it's probably not a bad starting language. It might not be a bad idea to check out node and angular as well, sounds like you have some experience with java script so syntax wise it shouldn't be overwhelming. 
That was my bad, forgot to remove the autoplay from the URL when I posted it. Totally agree.
We're hiring 150ish people. Most of which will be developers. I find it hard to believe 150 devs makes 5-10% unless Columbus Ohio has close to 30-50% of the ruby developers on the planet.
It's a great way for folks to learn what not to do.
Huh, what not to do? 
No, it wants to forget all my settings because it's a new user (root). I'd like to run rubymine with my regular account, then when I hit run it should ask for a password and run it using rvmsudo.
The chart is for Ruby jobs on one particular job board (Indeed). I've never posted a job to Indeed, for example, so all the folks I've hired (Ruby or otherwise) don't even appear on this graph.
So, I'm in my second automation role - first doing solely automation - and I'm really afraid that I'm gonna get pigeonholed. Should I be concerned? All I want is a full stack dev role, not necessarily even in Rails.
That really depends on the company. At many places I've worked test engineers are testers and part of QA. In fact that's how I got into automation, I thought "they're approaching this from the wrong angle" at my old company and was able to step in and start making changes. In my current company, test engineers are engineers and part of development. TEs pair with app devs and participate in code-reviews. They spend a good portion of their time building services (mocking third parties and the like) and tooling.
I more mean in the sense of looking for a new role. I'm not really certain how a resume like mine is viewed by prospective employers, and I loathe full-time QA - especially UI automation.
I fall on the side of Go: language features should be removed in favor of simplicity unless there's a good use case for a feature. Being used six times world-wide fails that bar **spectacularly**.
The thing I hate is the constant bombardment from recruiters that somehow found your resume and give you calls for Senior positions that require 7-10 years of Rails experience...
Six times worldwide in public gems, sure. A quick scan at work suggested our code base has just increased the number of uses worldwide by 33%. We employ 20 engineers - I am thinking it's in wider use than you might think.
If you don't mind me asking, what company do you work for?
Ok, thanks. I'll take a closer look. 
Here's out careers page: https://www.covermymeds.com/main/careers And our public github: https://github.com/covermymeds 
Ive never met anyone who only uses SQL for their programming job. At my job I use almost all of these langs.
You look like a young version of SuperHans from Peep Show, http://4.darkroom.shortlist.com/980/733dab033fe115f62cb381e164d22568:9fb74a041f2eea369e14b4c437a1ebd7/hans-hero.jpg
Why not add yourself to a group that has access to the ports?
Don't be just a ruby programmer. Be a critical thinker and understand multiple languages. You don't need to be an expert in a language to make a good living. You can easily make 100K+ being adequate as long as you have a passion for learning and pick things up fast.
Not to sound stupid but what's the diff between junior developer and "higher than junior"?
At least you went to school for accounting! I've a masters in Clinical psych and I'm trying to leave that field to do data science. It's a bit of a learning curve, but once you get the ball rolling, it should help. It's really overwhelming, though! Few of my dev friends suggested making things as a way of learning. I have to agree with that.
I've been doing this for 10+ years and I can honestly say I'm not an expert in any language. I've had jobs programming in ruby, c#, java, and python. Don't learn a language, learn concepts. Learn how to solve problems. The language is just a tool. Your approach to solving problems is where the real money is.
It's just accessing shit from parent scope.
These (Jim's *Decoupling from Rails* and Uncle Bob's [*Architecture: The Lost Years*](https://youtu.be/WpkDN78P884)) are two of my all-time favourite presentations on architecture in Ruby. Your app is not your framework is not your language, and too many would-be Rails apps (including our first several) ran up onto the rocks by failing to fully appreciate the implications of that.
Totally useless. I love it! This should be merged with the Ruby repo!
https://github.com/iridakos/table_flipper/blob/master/lib/table_flipper.rb#L2 &gt; Did you mean? alias_method SCNR ;)
Well, I think there's a market for what you're doing. Good luck with the site and the new baby :)
TIL about Module#prepend. Pretty cool, thanks.
I wrote about closures here: http://www.blackbytes.info/2016/02/ruby-procs-and-lambdas/ But the idea is that you can access variables and other stuff as if you were in another scope. 
I mean, someone would have to pay me more to program in javascript full time, so higher salaries for javascript sort of make sense. Hazard pay.
Couldn't have said it better myself. Maybe it's just the nature of things, but when I was in school, I was taught that global variables were a bad thing and that you were to avoid them at all costs. Now they just call them Closures.
I would also be very interested in this, as discussions about dektop app development in Ruby often end in the mentoin of shoes, with no actual real world examples or mature applications using it... A commercial product for GUI development with ruby seems to be http://www.rubymotion.com/ , but they also don't show examples of desktop applications. I really wonder why there seem to be no thriving projects for Ruby GUIs, maybe because of the shift towards web applications?
Parent scope is not the same thing as the global scope. There are many parent scopes but only one global.
Fair point, that makes sense.
You've got to be kidding me. That's the exact ruby experience I have. Where are you located?
Thanks a lot.. But why is it used amd when to use it? 
Columbus Ohio, but we hire remote folks.
Ah cool
Could you please expound on this? I don't understand.
How about researching the possible addition of type annotations in ruby? You can start here: https://bugs.ruby-lang.org/issues/9999 There's also a *ton* of talks and blog posts discussing it, so there's a wealth of research material available. * How does this compare to other languages? * How does the potential change affect ruby's "duck typing" philosophy? * What are the political motivations driving the future of the language, and (in your opinion) are these a good/bad force for the community? * What existing (possibly experimental) tools already exist to add some type annotations in ruby? (For example: different ruby implementations like infraruby, or gems like typesafe-ruby.) * What would be the performance implications? Development time implications? How would it affect testing, and confidence in code functionality? * ............. There's a huge amount you could write about this!
I was watching a video the other day about SOLID principles in Ruby. At the end of the video, Jim Weirich acknowledged that SOLID was envisioned for static languages. He asked if there might be a set of design rules universal to dynamic languages like Ruby. That could be an interesting--though daunting--exercise. 
I would go with any of the already mentioned ones (Concurrency or Type Annotations), but I must admit when I clicked your post I was thinking about the later. There is [this really good talk](https://rubyconf.eventer.com/rubyconf-australia-2015-1223/towards-a-higher-level-language-by-erik-michaels-ober-1746) by [Erik Michaels-Ober](https://twitter.com/sferik) in which he points out some ideas on typing. Other interesting talks include Matz's (Ruby creator) take on [the future of Ruby](https://www.youtube.com/watch?v=85ct6jOvVPI) and Tom Stuart's [Consider Static Typing](http://codon.com/consider-static-typing).
Big thumbs up on this book. Some great ideas in it that feel applicable to pretty much any GC'ed language
I think Metaprogramming is a great Ruby topic. Talk about some of the common patterns and ideologies. 
Closures are most commonly used in Javascript, if you want to have 1 function and each time you assign the function to something it stores its own unique state, like passing in the parens, so you can have the same function but every time you assign it you can have it store something and then effectively that function works differently every time for each variation of it when its really just the same function... Not sure if any of that made any sense, it's 2am and I'm far from a teacher. Works well in web development, looping to create things and each of those things having their own diff properties etc without writing a new function for each one
Why is the Kindle version pretty much the same price as the paper version?
`Module#prepend` adds a given module to the method lookup chain of a receiving module, like `Method#include`, but where `#include` puts the given module behind the receiving module, `#prepend` puts it ahead. The upshot is that `#prepend` is ideal for decorators. [1] pry(main)&gt; A = Module.new [2] pry(main)&gt; B = Module.new [3] pry(main)&gt; C = Class.new [4] pry(main)&gt; C.prepend A [5] pry(main)&gt; C.include B [6] pry(main)&gt; C.ancestors =&gt; [A, C, B, Object, PP::ObjectMixin, Kernel, BasicObject] 
There's lots of Ruby research at http://rubybib.org/
You can just `#freeze` it? 
I do actions other than the index,show,new,create, etc. a fair bit. However, you don't want like 4 or 5 of them, that's typically when you're probably going past cleanliness. The reason i don't mind having 1 or 2, as sometimes Index or Show doesn't really make much sense either. Sometimes I want something more specific like "send_test". Maybe that send action shares private methods inside the same controller.
The ruby community is mostly an offspring of rails. That means most people in ruby are here for web development and these days most people make web apps either way - there is little demand of desktop apps. Rubymotion is also focussing on iOS and Android afaik.
Good point, I agree with you. If the logic is simple enough, I will just use query strings in the index action. I have edited the post to reflect this thought.
Yes, but then `'/auth'` becomes hardcoded (only `config.ru` should have it). Meanwhile, I came up with this hack: before do self.class.set :views, "#{settings.root}/../views#{request.path}" end For reference purposes, this is the test project layout that I am playing around with: ├── app │ ├── controllers │ │ ├── 0001_application_controller.rb │ │ ├── auth.rb │ │ └── main.rb │ ├── helpers │ │ ├── application_helper.rb │ │ └── auth.rb │ ├── models │ └── views │ ├── auth │ │ └── home.erb │ ├── main │ │ └── home.erb │ └── layout.erb ├── config.ru ├── console.rb ├── Gemfile └── Gemfile.lock
CGI.escapeHTML was re-written in 2.3. Apparently this has made rendering ERB templates a lot faster.
So what happens when you need to apply more than one filter at the same time? Seems like this is useful for simple cases, like the one used in the example, rather than more complex ones (think catalogs with a lot of of filterable attributes on their items). P.S.: Just to clarify, I'm all for simple, short and sweet controllers, not advocating you shove the filtering logic in the controller.
Here is your code correctly formatted and with comments. # The Message class is defined here class Message @@messages_sent = 0 # This is a class variable, denoted by the double-@ # This method is called whenever we do Message.new, and take two arguments def initialize(from, to) # Set a couple of instance variables that belong to the instance of Message @from = from @to = to # Increment the class method by one @@messages_sent +=1 end end # The Email class is defined here and inherits from Message. That means # all the methods in Message are available here and can be redefined here. class Email &lt; Message # Called when we do Email.new def initialize(from, to) # This means "call the same method you're in from the class further up" # which in this case means "call initialize in the Message class" super end end It sounds like you're struggling with the concept of the object model in Ruby. You may want to read [this reasonable introduction](http://rubylearning.com/satishtalim/ruby_inheritance.html). HTH.
Code snippets are more informative but I will assume that when you mean "more than one filter at the same time," you mean something like `GET /inbox?state=pending&amp;received_at=yesterday&amp;has_attachment=true`. Assuming you have a catalog-like complex logic, I would go with one of these two solutions: - Solution 1: Have one dedicated `InboxController` with only one `index` action, and put all of the filtering logic in this controller. To make things even clearer, or if `InboxController` is already used for other actions, I would call the controller something like `FilteredInboxController` or `Inboxes::FilteredInboxes` with one `index` action. Or `Inboxes::FilterController` (filter is singular) with one `show` action. Or something like that. Then all of your complex filtering logic would just be in that controller. This is the solution I would choose for small to medium logic. - Solution 2: When he filtering logic is so big (more than 100-150 lines) that you really want to put it elsewhere. In this case use your usual tricks to abstract information out: a Filterable concern would be my solution of choice. Or use a service object if you really want to? Then you include or use this logic in your `InboxController` `index` action. No need to have a dedicated controller for the `index` here, since you already have one level of indirection with the concern/service, you don't want to have 2 levels of indirection. 
99% of us people are not Amazon and Facebook, so I wouldn't worry about such use cases. But yeah we agree on extracting logic somewhere else when needed. I just wanted to emphasize that I would extract only when absolutely needed. :-)
Im familiar with join, how are you suggesting it be used?
Yeah that's a fair point. A consistent code base makes it more predictable. I guess in general keeping track of all your routes &amp; controller actions is tricky regardless of where you put em. Was looking at the main project im on at work, and we're mostly just the standard action names, minus like 1 controller out of 20-30.
I see- I thought the length changed with every iteration, but it is constant at 4... makes sense now.
You can replace your loop with it - there may be some additional steps however 
Agreed
Edit 2: The code I originally posted is wrong, because `Array#sample(n)` doesn't do random selection with replacement. ---- def structure_number characters = (0..15).map {|d| d.to_s(16) } [4, 2, 4, 8].map {|length| characters.sample(length).join }.join('-') end Edit: For anyone downvoting, and in case it wasn't clear, OP asked how using `join` would help, as compared with the method being used in the gist. characters.sample(length).join This means to pick (pseudorandomly) a number of characters from the `characters` array, equal to the value of `length`. Then, those picks are joined together into a string. [4, 2, 4, 8].map {|length| characters.sample(length).join }.join('-') So, this would make strings of length 4, 2, 4, and 8, and join all those strings together using the `-` character. `Array#join` already contains the logic for putting a character (or characters) in between a list of strings, without also adding "an extra one" at the end.
Much easier, what is the (16) and where do the letters come from?
It means interpret as base 16 numbers for the string. 0-15 in base 16 is denoted with 0-9 and a-f.
While this is the idiomatic way to do it, I'd say it's not beneficial to just give solutions to beginners rather than belong them along to the solution. Especially if you don't explain exactly what is happening.
I'd agree with that, but in this case OP asked for an example of how using join would help. I guess that wasn't clear enough for some, so I'll try to explain it further.
You can use it with other bases, as well. There are some examples in [the docs](http://ruby-doc.org/core-2.2.3/Fixnum.html#method-i-to_s).
Wow I always thought sample was random sample with replacement. IDK why I never considered it may not have been...
For what it's worth, I accepted at least part of your criticism, based on the notion that others might misunderstand my intent, and since I didn't post my comment as a direct reply to his query about using join. Also, he had already shown that he understood `sample`, so I figured he'd understand the second line of my method. He did inquire about the first line, and I agree that that line might have benefited from more explicit explanation.
Not at all. I typically am much more explicit, but was responding quickly, and thought as though I was answering a very targeted question. That's why I mentioned the direct reply thing...it might have been better understood in context.
This is a better version of what I was trying to do in [this comment](https://www.reddit.com/r/ruby/comments/485zkx/learning_ruby_something_hurting_my_brain_but_im/d0hc029). CHARACTERS = '0123456789abcdef' def random_chars(repeat=1) (1..repeat).map { CHARACTERS[Kernel.rand(CHARACTERS.length)] }.join end def random_chars_alternate(repeat=1) (1..repeat).map { CHARACTERS.sample }.join end def structure_number [random_chars(4), random_chars(2), random_chars(4), random_chars(8)].join('-') end def structure_number_alternate [4, 2, 4, 8].map {|length| random_chars(length) }.join('-') end Commentary: If you're going to call `structure_number` more than once, it probably makes sense to put `CHARACTERS` into a constant (assuming it's going to be the same every time). The `random_chars` method picks `repeat` random characters from `CHARACTERS` **and allows duplicate choices**, which is what `Array#sample` doesn't do the way I expected. The `random_chars_alternate` method is an alternate way of doing the same thing, using `Array#sample`. The `structure_number` method should be very readable and obvious, regarding its function. The `structure_number_alternate` method is another way to do the same thing, using `#map` in a fairly idiomatic way.
I never knew him and I'm not even a Rubyist (although I'm a fan of the language and I have deployed code to production) but I've watched a few of his talks and really enjoy listening to him. He's a very good presenter, enjoyable and fun to listen to and I'm sorry he's no longer with us.
That answers that. Thanks!
[Why not math and string formatting?](https://eval.in/527151)
Can you give an example?
The `super` call in Ruby is quite unique. Let's first start with Object Oriented concepts (outside the realm of Ruby specifically). When you define a class, A, you're grouping logic you feel is specific to A in that class. If you want to make a more specific A, you generally subclass A, and create a new B. What you're saying is that you want B to behave just like A except where you've explicitly noted. The simplest example of this is: class A def first "Hello" end def second "blah" end end class B &lt; A def msg "Goodbye" end end In this example, B behaves exactly like A when you call `second`, but when you call `first` they each return different values. This is not always desired, sometimes we want to _enhance_ a return and so we want to call the superclass' (in this example, A) implementation of a method and perhaps modify that. class C &lt; A def first super + " World" end end This `super` tells Ruby to find the an implementation somewhere up the hierarchy (in our example the hierarch is A -&gt; C so it looks on A) for a method named the same as the one we're in (`first`) and calls it, returning it's value. Then we modify it's return in the subclass and return a completely new value! Now, not all methods take no arguments. In fact, most methods would require at least one argument to be useful. So we can call super like any other method. If we had a method like: class A def do_things(a) a + 10 end end We can create a subclass and still use `super` to reuse that behavior. class B &lt; A def do_things(a) super(a) + 2 end end In this example you can see we're just _forwarding_ the value in `a` to the super method. This pattern is so common the "naked super" will automatically forward all parameters to the super method. So if you have a method that takes 10 arguments (please, never do that -- use keyword arguments or break the logic apart in some way) instead of typing `super(one, two, three, four, five, six, seven, eight, nine, ten)` to pass all the values you can simply do `super`. --- So in your example, you're simply using `super` to instruct the `initialize` method of the class `Email` to call the `initialize` method of it's superclass (`Message`) and forward all arguments instead of rewriting the logic in the subclass. This allows you to keep logic centralized where it belongs. You should always strive to have only one part of your program do a particular thing (not always possible, but you should always be on the lookout to accomplish this goal). This has the side effect that when you need to change the logic, you only have one place to change it instead of 100 (which can introduce hard to find errors).
I wish I knew. Amazon pricing is an enigma even for authors and publishers. We've got no control over it. That's why I've been constantly tweeting that the best way to get a kindle version is to buy the .mobi from PragProg ($24) and upload it yourself. If that also sounds like too much, then wait for 40% off promotions from PragProg.
URL schemes and rails controller conventions have absolutely nothing to do with REST whatsoever. Have you read the section on REST in Fielding's dissertation?
It's called the index operator, or subscript operator. Maybe that will help your searching.
Not that there's anything wrong with Rails, but why have there been so many Rails-related posts here lately? They really belong in /r/rails.
Another thing to remember is that you **don't** have to give each controller a separate file. It is perfectly fine to nest one inside the other in the same file, which really cover the laziness case. 
Absolutely! I just finished reading the book "Metaprogramming Ruby 2nd Edition", and would definitely recommend that if you're going to look into it :) 
String#titleize isn't a Ruby method
I just hate to see Ruby being thought of as nothing more than a DSL for Rails, when it's actually a fantastic general-purpose programming language that is easily on par with (or, in my opinion, much better than) Python.
Ah, I see. Maybe try to add "Ruby" or "Ruby Remote debug" runner under "Run / Edit configurations" with sudo/rvmsudo somehow configured there? Did you try to ask their support via email or twitter?
This was interesting right up until you posted that create method and then said services are shit. You have written a service but called it a controller. The reason you got away with not breaking it out to its own class is because it's trivial enough to implement in 144 lines. Get back to us when you have to implement something complicated. I think the many controllers idea has some merit, but more thought is required than just haphazardly throwing some objects together and calling it a resource.
(Almost) one-liner: f, a = list.group_by(&amp;:itself). # grouping list items by its own value map{|num, group| [num, group.count]}. # convert this {val =&gt; [occurences]} into {val =&gt; count} group_by(&amp;:last). # group by count in group sort. # sort (by key - count in group) last # receive last item # last item will look like: # [3, [[6, 3], [9, 3], [7, 3], [11, 3]]] # ^ ^ # freq array of [number, freq] # # ...so, all you need now is: [f, a.map(&amp;:first)] 
The group_by is a good way to do it. def mode(list) list.group_by(&amp;:itself) .map { |k, v| [k, v.length] } .sort_by(&amp;:last) .reverse end Then just take as many entries as you want from the start of the resulting list of [number, count] pairs.
Any theme you want to see included? Let us know. Cheers. 
&gt; Side effect of the Turbolinks-enabled mobile app approach - guaranteed to be fast on old/low-spec devices b/c the Javascript is so simple. I have no dog in this fight, but that claim on the face of it is stupid (or if we're being charitable, "incomplete at best" and "depending on a whole chunk of excluded context to not be completely meaningless"). You simply can't meaningfully compare the time required to render a template on the client-side to an entire server round-trip and claim the server round-trip is faster, because it depends **entirely** on the specific device, connection and ambient network conditions at the time. Sure, a low-spec device on a 4G connection might be faster to request a chunk of AJAX, but a high-spec desktop machine tethered over a 3G connection is going to be far, far faster to render a client-side template. Frankly I'm surprised anyone needed to write an article to demolish what looks like such a silly, meaningless claim.
 list.group_by(&amp;:itself).group_by{ |x| x.pop.size }.max # =&gt; [3, [[6], [9], [7], [11]]] Edit: Probably slower, but looks better: list.uniq.group_by{ |x| list.count x }.max # =&gt; [3, [6, 9, 7, 11]]
You're gonna wanna make a connection to the database and render a different view depending on the result. I would recommend using the Sequel gem to connect/query to the database, but here is another simple way to do it: def user_exists?(username) # connect to db # check if user exists # return boolean end get '/:username' do @user = params[:username] if user_exists? @user erb :username else erb :other_page end end
Oh. ummm... are you pretty new to programming? You should look up some ruby/database tutorials. You need to make a connection to a DB (using the appropriate database gem), make a query to the db using that connection, and then get the result of the query. You need to install a gem that works as a driver to connect to the database. There are gems for mysql, postgres, etc.... But I like the Sequel gem because it works as a universal driver for many different kinds of databases. 
I had no idea how to do it with OAuth, and that is definitely a nice solution for Heroku :)
I love how terse ruby can be. 
This strange to me. Almost all the job listings I see are for junior devs, with junior salaries. I am not really seeing any senior positions at all. 
Maybe it's based on location? I'm in Boston like several others here and from what I can tell every company is dying to get more experienced people.
The differences are centered around a Struct's intention to **bundle a number of attributes** together. Examine the following struct and class definition: CandleStruct = Struct.new(:open, :high, :low, :close) CandleClass = Class.new { attr_accessor(:open, :high, :low, :close) } As Structs are intended to merely wrap values, they can be used for value-based equality checking. Two structs are equal if they have the same struct subclass and have equal member values. c1 = CandleClass.new.tap {|c| c.open = 1; c.high = 10; c.low = 1; c.close = 5; } c2 = CandleClass.new.tap {|c| c.open = 1; c.high = 10; c.low = 1; c.close = 5; } s1 = CandleStruct.new(1, 10, 1, 5) s2 = CandleStruct.new(1, 10, 1, 5) c1 == c2 # =&gt; false s1 == s2 # =&gt; true Additionally, let's examine the ancestry tree: CandleStruct.ancestors #=&gt; [CandleStruct, Struct, Enumerable, Object, Kernel, BasicObject] CandleClass.ancestors #=&gt; [CandleClass, Object, Kernel, BasicObject] As we can see, Structs inherit from Enumerable, allowing you to conveniently iterate through the *values*. s1.to_a #=&gt; [1, 10, 1, 5] s1.max #=&gt; 10 s1.each_pair { |key, value| puts "#{key}: #{value}" } 
Hard to say. I'm in Seattle. 
I think this is an important point. If your app is more about just showing content than about rich interactions, a server-rendered approach is probably best and using something like Turbolinks or pjax is a great way to speed up navigation around that content. However, if your app includes a lot of interaction with the user that isn't just navigation and simple HTML forms (for example, TodoMVC works with `localStorage` and triggers more than just form submit events), maybe a full app is a better choice. I think, in general, devs tend to use the wrong tool for the job a lot, but I also think the "right" tool for the job is pretty subjective most of the time and you can frequently get the job done pretty well even with the wrong tools. :-)
Does that 5x number including the Heroku performance weirdness we saw this morning? Or is that after it settled down?
&gt; Well, I was being quoted from Twitter, so forgive my brevity. Fair point - apologies. I tried to nod towards that with "depending on a whole chunk of excluded context", but I probably should have given you more of the benefit of the doubt. ;-) &gt; maintaining and creating a Virtual DOM necessarily requires more Javascript execution that Turbolinks... This has performance consequences on low-CPU Android devices. I think that's interesting, you may not. That's true, but the whole point of a vDOM is that it's *as lightweight and diff-friendly a representation as possible*, so it's an open question whether that extra CPU is actually a factor in practice, or merely a trivial theoretical technicality. (It's also worth pointing out that this is also only in the worst possible case for client-side vDOM-based systems, where the model has changed and a significant update *does* need to be performed. If no update needs to be performed then the diffed-vDOM approach is likely *hugely* more efficient, because you aren't re-laying-out, re-rendering and re-painting the DOM at all, which typically takes *orders of magnitude* longer than fiddling about with pure javascript objects in memory.) The vDOM-based solution's speed depends on a host of factors including vDOM size, precise details of the internal vDOM representation, device CPU resources and efficiency of the JS runtime, but unless you're loading tens of thousands of nodes in a smartwatch I suspect it's unlikely to be a factor in practice - in my experience you're probably looking at tenths or hundredths of a second's difference at most. Conversely I build games for low-end mobile devices *and* browse the web on a high-end mobile device for at least two hours every day (damn you, train commute!), and I can tell you first-hand that while JS doesn't always run fast on embedded/mobile devices, on a poor mobile connection you can be looking at as many as *whole seconds* for a server round-trip. And I say that as a *huge* believer in Progressive Enhancement and server-side rendering. I still think it's a hugely under-appreciated architecture for web-development in a modern industry full of twelve year-old hipsters in love with AngularJS, but realistically in most cases if you're comparing the raw speed of an entire server round-trip to executing a moderate amount of client-side JS, you've already lost the argument for most reasonable scenarios. &gt; Much of why Turbolinks is passed over by small shops is this "network FUD" - that we cannot meaningfully compare the performance of Turbolinks and a clientside rendering approach because network conditions are variable. It's a shame people are passing up on a good architecture for invalid reasons, but it doesn't make an invalid or meaningless comparison valid just because you'd *really like* it to be. The correct approach to arguing against client-side web-dev hipsters who claim a server round-trip is too long to wait for a chunk of HTML is any of the following: * The vast majority of websites on the net are still static HTML pages linked via anchor tags causing HTTP requests. Clearly, then, a server round-trip is *not* too long for the overwhelming majority of users, regardless of what a lot of client-side-framework-fanboys might try to claim. * If literal milliseconds of response-time are still important to you, it's important to factor in the fact that on the *first* page-request (*before* you've even had a chance to demonstrate value to the user and win their patience) a static page merely requires the HTML and CSS to be loaded before the user can interact with it (and the unobtrusive, progressively-enhanced JS can be loaded and run out-of-band, in the background, without blocking rendering or user-interaction). Most client-side frameworks must do all that *and then* have the entire framework JS and templates downloaded, parsed, executed and output rendered *before* you can do *anything* with the resulting page. Even if they're faster once everything's loaded, that first page-load can be a right arse. Just ask [disgraced client-side-JS poster-boy Twitter](https://blog.twitter.com/2012/improving-performance-on-twittercom). &gt; I want to be clear about the general claim I'm trying to make - Turbolinks performance is comparable to many clientside rendering approaches. That's a fair point, *as long as* you have a decent network connection, and it's certainly important to combat the silly, disproportionate a-whole-server-round-trip-will-cause-people-to-leave-your-site-in-disgust FUD from client-side fanboys. However, there's a world of difference between "*in some ideal situations* a server round-trip is *nearly* as fast as a bad client-side implementation" and implying that they're *necessarily* comparable in speed in general. Frankly, if the front-end guys have suckered you into arguing about comparative speed you've already lost the argument (much like client-side JS advocates about SEO, accessibility or discoverability/parsability). The trick is to point out how irrelevant wanking over a few tens of milliseconds is to UX, compared to all the meaningful differences between server-side and client-side rendering, and all the benefits that server-side offers you that client-side doesn't.
I'm a big fan of Structs for value objects, and the [Values gem](https://github.com/tcrayford/Values) is very nice if you are looking for an immutable struct with some of the nice features of Ruby's built in OpenStruct. It's worth noting that I've had trouble with the Rails autoloader using this syntax: class Person &lt; Struct.new(:first_name, :last_name) end vs. this syntax: Person = Struct.new(:first_name, :last_name) The error is usually: TypeError: superclass mismatch for class Person Using the first example, when the file is subsequently read in on reloads, a new superclass is created (`Struct.new(:first_name, :last_name)`) and doesn't match the superclass of the existing `Person` class in memory. This isn't a deal breaker, but I do prefer the first example because it's easier to decorate the class with methods just in the class body, like this: class Person &lt; Struct.new(:first_name, :last_name) def full_name "#{first_name} #{last_name}" end end To please the almighty Rails autoloader, the alternative is to do something like this: Person ||= Struct.new(:first_name, :last_name) class Person def full_name "#{first_name} #{last_name}" end end 
/r/dailyprogrammer
Yeah, given the size of that, it's probably the vdom generation before the actual rendering. Just like most vdoms, first render is slow since the VM isn't warmed up yet. :-\ I've got a [PR open for server rendering](https://github.com/clearwater-rb/clearwater/pull/20), which will help there. It's just not ready yet to merge in, IMO.
The recommended way to customize a struct is: Customer = Struct.new(:name, :address) do def greeting "Hello #{name}!" end end Customer.new("Dave", "123 Main").greeting # =&gt; "Hello Dave!" **Not** subclassing it. Subclassing an anonymous struct creates an extra anonymous class that will never be used.
TIL Ruby now has an identity method (`itself`) that was added in 2.2.0. Awesome.
I benchmarked your solution and the one-liner at the top and while yours is faster over 100k runs, depending on how big the sample is and how often you run the function that performance difference might not matter. It comes down to preference, but the one-liner is so much clearer to me that I would prefer that approach. *** Edit: Order of magnitude off on my sample size.
From the docs http://ruby-doc.org/core-2.2.0/String.html#method-i-capitalize &gt; Modifies str by converting the first character to uppercase and the remainder to lowercase. Returns nil if no changes are made.
Nicely done
Doing it the same way as you did: def mode(list) freq = list.inject({}) { |h, v| h[v] += 1; h } num = freq.values.max numbers = freq.select { |k, v| v == num }.keys [num, numbers] end print mode [1, 2, 3, 4, 5, 6, 6, 6, 9, 9, 7, 7, 7, 9, 11, 11, 11] 
A very primitive game loop for a text adventure could be structured as follows: while true do # get user input (e.g., via gets) # process user input which changes the state # display changes to user (e.g., via puts) if state.game_over? then puts "Again?" if gets.chomp == "yes" then state.reset else break end end end You should set up a state outside of the loop which holds, for example, the current room, etc.
&gt;Is there a way to have ruby go back to a certain line? (Ie: restart the game from a certain point) Many games have loops at or near the top level of the code to solve problems like this. There are lots of ways to structure this, but here's a simple example to show what I mean: loop do # The ask_for_player_name method returns nil if no one wants to play, or # a String containing the player's name. player_name = ask_for_player_name break if player_name.nil? initialize_game(player_name) loop do # The ask_for_player_action method returns nil if this player quits, or # the value 'restart' if they want to restart from the beginning, or # a String containing the player's command. player_action = ask_for_player_action(player_name) break if player_action.nil? if player_action == 'restart' initialize_game(player_name) else handle_player_action(player_action) end end end Of course, this is just a toy example (and it's not very object-oriented). It's meant to just give you an idea that you can use to structure your own code according to your own needs.
Any more questions for Thomas about kramdown, Markdown, and friends? Will try to get (invite) Thomas to answer here (or ask in person on Thursday). Cheers.
Got it. The word 'hack' threw me for a loop. Isn't this what Faker is for? 
&gt; Isn't this what Faker is for? Yes. A common use case is to use Faker in conjunction with something like [factory_girl](https://github.com/thoughtbot/factory_girl). But instead of defining factories with strings, you generate the strings dynamically with Faker. This randomizes your test data. Sometimes it's difficult to predict what actual humans will use for inputs in a form field. Randomizing the test data allows you to cast a wider net, so to speak, and can (hopefully) catch more edge cases. The "Generating test data with factories" section of [this article](http://everydayrails.com/2012/03/19/testing-series-rspec-models-factory-girl.html) describes this in more detail. I hope this helps.
Well you could use airflow? (Airbnb uses Airflow to trigger Spark, Cascading, Hive, MR, ML, Ruby, Python, MySql, and all sorts of other tasks...)
&gt; This was the clue that the author is at the expert beginner stage of development You mean that our 1 year old project is at an "expert beginner stage" compared older ones? Yes. If you mean me in general, well I wouldn't say working on Java/JEE apps with 10k service classes + DAOs + Form objects + etc is beginner stage. Or several Rails app with less services/other but still a very fair amount. &gt; Why not just put the entire application in one big file, then? As everything in life, it's a balance. Why not program everything procedurally in C or assembly with just one "main" function? Of course you want to leverage OO+FP+whatever. The key thing here is not to prematurely abstract, which some developers (junior or senior) tend to do systematically. Creating services+DAOs+design patterns all over the place != "senior developer". I used to do this but fortunately "saw the light" and repented. &gt; Having to jump up and down within a file is no better than jumping between files For most developers who I have talked to (including my current coworkers), it is. &gt; The only way to eliminate jumping between files is to establish boundaries and organize objects into namespaces whose hierarchically allows for the reader of the code move freely between different levels of depth Agreed, it's what we do in our app. We organize similarly related objects in their respective folders/namespaces etc. &gt; they dismiss indirection without understanding what it takes to organize that indirection into a structural design I use indirection when I have no other choice. Unfortunately it is too often abused and you end up with your classic Rails big ball of mud app. - https://twitter.com/dhh/status/703982922953576448 - https://twitter.com/dhh/status/703978406971625472 - http://www.joelonsoftware.com/articles/fog0000000018.html I guess our difference is that we just do not work in the same circles. If you work at very large companies (Amazon/Facebook/etc) or large companies, the problematics are not the same: it is maybe a good idea to systematically use a service for this new piece of functionality and whatnot. For small startups to some mid-sized companies (1 to a dozen developers), you can often get away with simpler solutions. After working for very large corps, my preference goes to small companies, YMMV. Lots of senior developer working at small startups dream about being hired by Amazon/Google and try to apply their pattern to their current job. This usually does not work well, because the scales are very different. I am trying to raise awareness that services objects all the time everywhere is probably not a good thing in a small/medium environments. Just try creating a few more controllers next time, you might be surprised at how it makes certain things easier.
Aww, I did say it's a _little_ hack!
Haha, I'm sorry if I gave you a hard time! I genuinely thought I was missing something. 
TIL! This is neat, but a little hairy since you really don't see that pattern used anywhere else. At least it shows they are looking out for the folks who are trying to migrate from Rails 4 to 5. Godspeed to them - I've never tried to jump major versions in Rails without just recreating the entire app.
From what I've read it seems as if your ruby version is corrupted on your file system some how. I'd reinstall it from scratch.
&gt; I've never tried to jump major versions in Rails without just recreating the entire app. 3 to 4 was no problem at all. 2 to 3 was almost impossible. (and I don't remember 1 to 2, although I did ONE app 1 to 2!) I think they learned their lesson from 2 to 3, and have been trying to ever-increase ease of upgrade ever-since. I am anticipating in-place upgrade of 4 to 5 being no problem. (cross fingers knock on wood). 
at my old job we went 2 to 4, and the boss decided to scale back from 3 devs on it, to just me, and keep the same timeline. This also meant the other 2 devs were developing new features on r2, which I had to keep current with r4 as I ported the rest of 2 to 4. I think all my grey hair came from that 5 months.
OK! By default Rails stores your sessions in a cookie as encrypted data. So if you open Chrome's dev tools, and look at Resources &gt; Cookies, you'll see a session cookie in there.
The two prior answers were both mostly correct, but incomplete. By default, Rails stores your session parameters in a cookie. Technically the cookie is not encrypted, it's just stored as base64. So it's not human-readable as is, but can be decoded easily. You can put anything you want in session variables, not just :user_id. But be careful, because all your user-defined session data cannot be larger than about 2k. Sessions are actually mostly under browser control. A new session is defined per both machine and browser: if you log in using Firefox, then open Chrome or Safari and visit the same site, you should be required to log in again. You will be logged in as the same USER, but they will be separate sessions. The session ends when you logout (i.e., your code calls reset_session, which is a method built into Rails). You can also just set :user_id to nil, but that's a dangerous practice, especially if you are storing any other user-specific data in the session. If you do store other session data, and you just change the :user_id without nulling the other values or using reset_session, the new user will inherit whatever other data is left in the session. For reasons like that, it is good practice to not store user permissions or anything of that nature in the session. Just put :user_id in the session, and store any other permission or authentication data in the database. If you close the window or tab for that site, the browser will also timeout the session after a period. Try it: log in, leave the site, then go right back. You will still be logged in. Leave the site, and be gone for an hour, then go back, and you will have to log in again. I'm not entirely sure how long that takes, and it may vary between browsers or be settable in a cookie. The default value seems to be adequate for most people. Some sites will reset your session right away, or after a few moments of inactivity even if you are still logged in. That is done on the back-end. 
&gt; Technically the cookie is not encrypted, it's just stored as base64. So it's not human-readable as is, but can be decoded easily. This is wrong. As long as `secret_key_base` is defined in `config/secrets.yml` the cookie is encrypted. A default app created via `rails new` generates separate keys for dev / test and expects an environment variable with it in production, heroku for example generates this for you on a ruby/rails build pack. &gt; because all your user-defined session data cannot be larger than about 2k The limit is 4k. &gt; If you close the window or tab for that site, the browser will also timeout the session after a period. This is controlled by the cookie, a cookie without an expiration date is cleared when the 'session ends' (when the browser is closed). A cookie with an expiration date expires on that date, it's completely in your control on the back end. Rails default cookies don't have an expiration date so they clear when the browser closes, but it's trivial to change this to make them last for a day, a week, a year, whatever. &gt; Some sites will reset your session right away, or after a few moments of inactivity even if you are still logged in. That is done on the back-end. That can be done on either side... 
&gt; assigns a cookie, with the key user_id, which is stored on the client's browser. It assigns a key within a single cookie which contains the entire session store. The session store is Rails is basically a serialized and encrypted ruby hash. &gt; assigns the string to the flash (a temporary cookie that resets after one request) `flash` is stored in the same single session cookie referenced above, it is cleared on the next response. &gt; As for reset_session, that is calling a method defined elsewhere doing whatever you need to do to log out a user--presumably assign a null value to session[:user_id] That method is from Rails and just kills the entire cookie. 
Dude this is most incredible, does it really search all of Wikipedia for answers on just about anything? I bet this could be used to drive some sort of web based trivia game.
Usually want to `inspect` the object too: tap{ |obj| puts ?&gt; * 40, obj.inspect, ?&lt; * 40 } 
Would love to know more about both of these. I have no issues debugging. What does the output look like? How is it useful?
I use the 'google-api-client' gem and I auth with Google with a 'Service Account' and '.p12' key both obtained from https://code.google.com/apis/console. There are several different ways to auth but I find this the simplest. Then an example of authing and querying the events in a calendar is something like the following: https://gist.github.com/johnknott/861fc101e9876593f841
`?&gt;` is equivalent to `"&gt;"` I.e. `?&gt; * 40` is equivalent to `"&gt;&gt;&gt;&gt;&gt;&gt; ..... &gt;&gt;&gt;&gt;&gt;&gt;"` This is a fairly obscure, and rarely used piece of syntax. Here's the documentation: http://ruby-doc.org/core-2.3.0/doc/syntax/literals_rdoc.html#label-Strings
Wow. I came up with something like this first: a.each_slice(4).to_a.map { |a| a.inject(0){ |sum, x| sum * x } } But your solution looks more like ruby-esque. Lovin it. :) EDIT: Using your example I managed to write it like this: a.each_slice(4).map { |a| a.reduce(:*) } Do you know what the main difference between each_slice and each_cons is? EDIT 2: I see. each_cons carries the result over to the next array (right?) So I basically misunderstood the question :x EDIT 3: Okay nvm. I got `each_cons` now. :) thanks for the explaination.
&gt; a.each_slice(4).to_a.map { |a| a.inject(0){ |sum, x| sum + x } } It's also not equivalent :) `each_slice` would output `[[x1,x2,x3,x4], [x5,x6,x7,x8],..]`. It also returns an iterator which will eventually get evaluated, so there is no need to call `to_a` anywhere.
What does the (:*) do in reduce?
It's worth noting that what we're seeing is a usage of Ruby's [`Symbol#to_proc`](http://ruby-doc.org/core-2.2.2/Symbol.html#method-i-to_proc) method. When a method expects a block and receives a symbol, Ruby calls `#to_proc` on that symbol. In this case `:*` is the symbol name of the multiplication operator (which is actually syntactic sugar over a multiplication method: `Fixnum#*`) [](/GNU Terry Pratchett)
Not exactly. `Symbol#to_proc` does something like this: class Symbol def to_proc Proc.new { |obj, *args| obj.send(self, *args) } end end If you call the resulting `Proc` of `:*` with a `Fixnum` as the first argument, then the method `Fixnum#*` will get called, as you said. However, it is only using the method name. Thus, you could do: addition = :+.to_proc addition.call(1, 2) # =&gt; 3 addition.call("Hello", "123") # =&gt; "Hello123" In the first case the method `Fixnum#+` gets called, while in the second case `String#+` gets called. I find that pretty cool :)
This is true, though I've noticed a lot of the standard library functions use the bang methods in a similar fashion: modifying in-place, returning `nil` if the function does nothing, etc.
That'd be really helpful, I've had many bugs
I believe `ignore` is deprecated in FG for `transient`. `ignore` isn't mentioned in the README anymore, `transient` is. 
Good one :) Yep, it's also on the plan.
This shit is fucking retarded, honestly. What's wrong with you that you can't use Pry or a debugger? 
Yep. I'd say it's a lot like using snake case when you're in C or camelCase in JavaScript. Technically not necessary and a lot of noobs to the language don't do it all the time. 
Just a joke - reference to https://xkcd.com/446/
[Image](http://imgs.xkcd.com/comics/in_popular_culture.png) [Mobile](http://m.xkcd.com/446/) **Title:** In Popular Culture **Title-text:** Someday the 'in popular culture' section will have its own article with an 'in popular culture' section. It will reference this title-text referencing it, and the blogosphere will implode. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/446#Explanation) **Stats:** This comic has been referenced 22 times, representing 0.0216% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d0miqd4)
1. Your blog post never said anything about this being restricted to production use. 2. I wouldn't use your approach in production, i'd use a logger. 3. Your code is equivalent to `puts "HERE!!!!!!!!!"; puts x`, it's retarded shit you do when you first learn programming before you learn about proper debugging tooling. I can't believe you thought it important/interesting to write a blog post about `puts "HERE!!!!!"`. Tenderlove's post was actually interesting as it introduced a number of introspection/reflection capabilities of Ruby.
This is the implementation: https://github.com/judofyr/nokogirl/blob/master/Rakefile#L10 However, this can sometimes be a problem because you can unintentionally install a beta/pre-release of the nokogiri gem. For example, here is a very similar gem: `bundle`, which installs `bundler` as a runtime dependency: https://github.com/will/bundle/blob/master/bundle.gemspec#L10 And, as discussed in the [issues](https://github.com/will/bundle/issues/3): &gt; At the time of writing this: &gt; gem install bundle --&gt; installs bundler-1.8.0.pre &gt; gem install bundler --&gt; installs bundler-1.7.13
hmmm What exactly does def mean? Define?
"def" is a reserved keyword that is used to define methods.
Way to ruin the joke, TOM :(
 /home/wpennock/.rvm/gems/ruby-2.2.2/gems/bundler-1.11.2/lib/bundler/runtime.rb:80:in `rescue in block (2 levels) in require': There was an error while trying to load the gem 'uglifier'. (Bundler::GemRequireError) Looks like your project is trying to load the gem `uglifier` but it hasn't been installed yet. Does your Gemfile specify uglifier? Did you run `bundle install` first? 
Yes it specifies uglifier 2.5.3 and yes I ran bundle install just before running rails server. 
That's the sort of thing that made me like the ruby ecosystem.
I built one that works via email. I haven't played around with it for about a year; simply as a proof of concept, but it works. https://auth.vaas.me/ While it is not open source, the instructions on the page should give a good idea of how the backend auth works. From there, your app would need to handle the redirects of displaying the auth login for multifactor enabled accounts and proceed to login once a successful return has been received from the auth system. It is similar to a SSO handshake.
&gt; Nokogirl — because developers can't spell http://github.com/tenderlove/nokogiri Is that really a problem for native english speaking people?.
Assuming you had an array of each row as an array, this would do the trick: rows = [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5]] columns = rows.transpose Columns would be [[1,1,1],[2,2,2]...[5,5,5]]. 
What exactly is the point? ActiveRecord is definitely the better choice in a professional environment simply because it's more popular and a higher chance of being maintained. The article points out that Sequel only has one developer which is actually not really good. The article also states that Sequel has 0 open issues as opposed to ActiveRecord's 300, which I would think people are just going to complain more cause of popularity
I don't see anything wrong with that at all -- or anything unexpected or surprising. I mean, I think, and I'm not alone, that Sequel is better designed in many ways than AR, both internally and with regard to API. You _can_ just use Sequel now instead of AR in your Rails app of course, if you want to. I think there are even plug-ins that will make all the generators and everything work with Sequel? So why doesn't Rails just adopt Sequel and abandon AR? Well two main reasons (or two main reasons I think are legit, aside from political reasons): 1) Backwards compatibility, this would suck for current users. 2) AR still has a variety of features that Sequel _doesn't_ have, AR is a lot heavier weight in arguably 'good' ways as well as bad, you miss some missing things when you switch to Sequel. So in the absence of Rails abandoning AR and adopting Sequel, which I think is legitimately not feasible (at this point anyway) -- AR borrowing all the best parts of the better-designed Sequel is _exactly what I'd want to happen_. Right? This is why we do open source. I mean, I think all of ActiveRelation was inspired by Sequel, and ARel is the most significant great thing to ever happen to AR. Great! Why not? If the OP finds this state of affairs either surprising or alarming, I'm not sure why! If they just mean to be showing that Sequel is 'better' than AR -- many of us already believe that, but there are a variety of reasons many of us usually choose to use AR instead, starting with but not limited to it's first-class Rails support. Although I occasionally find a responsible way to use Sequel, and am generally pleased when I do (although occasionally bump up against something missing in Sequel I miss from AR, especially around associations). But yeah, Sequel is awesome, and if there are people who don't know it yet, nothing wrong with advertising the fact, and I guess nothing wrong with advertising it by comparing AR and Sequel in the way the OP does. 
The point is that ActiveRecord is more popular even though Sequel is better. And we shouldn't be using libraries which are more popular, we should be using ones which are better. When you're dealing with millions of records and need to be creating complex queries, popularity of ActiveRecord isn't going to help you with ActiveRecord's lack of features. Sequel has 2/3 of ActiveRecord's issues, so we can't really say that people aren't complaining on Sequel. If you have an issue, where do you think it would likely get answered sooner, on Sequel's issue tracker or Rails'? In my experience on Sequel is always within a day, and on Rails it usually gets flooded by other issues. Why is a single developer not good, if 0 issues are maintained? Why would there be another developer if they're not needed? People are contributing with PRs and issues, so there is still outside maintenance.
This is kind of a strange implementation, what is the point of `version` combined with `public` but without `must-revalidate`? To clarify, the `version` check is done on the backend via an etag check, but if you tell the client, and especially intermediary proxies (via `public`) to cache the response forever it's unlikely you'll ever get hit by those proxies again, or at least not until they drop the data due to lack of use or for some other internal reason. Maybe it will work if you also set `s-maxage` and the intermediaries happen to respect this header. tl;dr changing the version definitely won't invalid all the caches out in the wild so you better make sure anything you mark with this method is set in stone and will never change. Or you can deal with multiple versions out in the wild for weeks or months after changing the version. 
&gt; What exactly is the point? ActiveRecord is definitely the better choice in a professional environment simply because it's more popular and a higher chance of being maintained. This is just wrong. Sequel has been around a long time and has been used heavily by many organizations.
Upvoted. Interesting point of view, that it's actually good what's happening. For some reason I just cannot think that way: for example it also bothers me that hanami-model is reinventing ROM :) If the Rails team is trying to preserve backwards compatibility, I think it's better to do only bug fixes without new features. What features have you found that AR has and Sequel lacks, which are related to interacting with a database? I think ActiveRecord is heavier because you require all the features that you need and don't need, rather than being able to include ones that you need through a plugin system. Well, I think it's a problem that AR's first-class integration with Rails is attractive at first, but then later on you realize that the actual ORM functionality is actually more important to you (and that Rails integration is easy), but now you can't really go back. I just think it's easy to fall into that trap, especially the bigger the community is around it. I just feel like I want to help the community to forget AR and upgrade to Sequel, so that they can bring communication with the database on the next level, especially when doing data migrations, or calculating some complex statistics.
Are you suggesting that Rails should drop ActiveRecord and just use Sequel? Or that developers, at least for new projects, should use Sequel instead of AR with their Rails apps? You're the author of the OP right? The point of the article was to argue for one of those things? I love Sequel, and think overall it is 'better' than AR, but better in most ways still leaves reasons to choose AR. I still mostly choose AR for Rails projects. I always use Sequel for something without a Rails dependency. While Sequel is better, there are some features AR has that Sequel doesn't, that I run into when using Sequel, particularly around associations. Also that some things I occasionally need are plug-ins in Sequel that may not be fully mature/reliable (like dirty tracking). Also, the fact that AR is guaranteed to work and integrate properly with Rails, and be understood by other Rails developers, really does matter. Also of course, existing projects already written with AR. I suspect most (but not all) of the reasons Sequel is faster is because it does less; if you add in all the plug-ins to make it do what AR does, I suspect the performance will be closer. Of course, sometimes you don't need those things, and Sequel lets you not use them unless you need them (which means you need to figure out how to enable them and use them when you do), while AR doesn't. But I love Sequel, and the more people that know about it and try it out the better, sure. And I love that AR is adopting things from Sequel, since I'm using AR often, the better it gets the happier I am! 
That's a perfect attitude! I often tend to lean towards finding-a-silver-bullet attitude. That's why I would always choose quality over familiarity. It is a big benefit that people know ActiveRecord, but I just don't think this upside is nearly as strong as having a more quality database interaction in your app. I know that ActiveRecord can't/shouldn't be dropped, so I'm advocating the second thing, that developers should use Sequel for new projects instead of AR. I greatly share your love towards Sequel.
I'd simply setup Devise as usual (i.e. with database authentication) and add a `before_action` to the application controller, which redirects the user to an auth code form if a token in the session does not match an expected value.
can we discuss [this bit of nonsense](https://github.com/judofyr/nokogirl/blob/master/Rakefile#L11)? p.install_message = [$/+%+*+*msg.length+$/]*2*msg+$/ 
I don't think I've ever said that 0 issues meant high quality, just good maintenance. And since Sequel has amount of raised issues comparable to ActiveRecord, I think it doesn't fall into the "unpopular" category. But I agree that if a project has only few issues in total it doesn't say much. The same with many issues. But I think it does make sense that ActiveRecord has more open issues, because they are put in a queue with all the other Rails issues. In general I think comparing open issues makes sense when total amount of raised issues are comparable. Yes, a lot of issues aren't actually bugs, but when you're comparing projects with similar amount of issues, both projects will probably continuously receive non-issues, so I think we can still compare general numbers. EDIT: I think that problems you've mentioned are generic to maintaining any library. About a single maintainer, the main reason Jeremy is one is because he's great at maintaining and has time. The only way there would be room for another maintainer would be if Jeremy was less great, or/and had less time. So I really think this fear doesn't make any sense in this case, because it's caused by a situation being positive.
The updating happens in your gemfile using bundler. gem install won't update your current application.
&gt; Is there a Ruby way of doing this without a for loop? Transpose does not explicitly use a loop, yes. However, look at the [source](http://ruby-doc.org/core-2.2.0/Array.html#method-i-transpose), you will see that transpose uses a for loop internally. I agree that is it likely that OP meant explicitly using a for loop, but I thought it worth mentioning.
So? You claimed that AR was "definitely" a better choice, presuming to know that Sequel is not used enough to be stable or viable long term.
Definitely, and that's something I meant to add in an edit. Transpose does not scale very well with larger data sets. I haven't looked at the code for it, but I wouldn't be surprised if it's doing an n-squared loop for this.
The log shows that you're still using 4.0.2 version. Change your rails version in your Gemfile to 4.2.5 and run `bundle update` and then restart your server.
Apparently updating Rails from 4.0.2 to 4.2.5.2 fixed it. 
Ah, the latest Paperclip requires 4.1 or better so that explains it. Glad you got it working :)
I never made any such presumptions, simply going from what the linked article states, the author clearly omitted that Sequel is actually a very popular gem ( &gt; 2500 GitHub stars). 0 open issues and 1 maintainer in nine years is the opposite of widespread popularity which is clearly stated in the article. With only this information, there is no way to not be weary of thinking that support might be dropped for Sequel, requiring additional thousands of dollars in a professional setting to be spent
I created a small gem as a wrapper for this in ruby: https://github.com/AirspaceTechnologies/google-cloud-vision. Feel free to test it out!
&gt; If you tell clients to cache "forever" (actually I think a year is the longest the spec allows?) It's kind of ambiguous in the RFCs, the older `Expires` header from HTTP/1.0 specified a limit of 1 year but the RFC for `max-age` references the `Expires` spec but specifies no hard limit on the value in `max-age`. It does require that implementations that choke on numbers greater than 2^31 to treat it as 2^31 which somewhat implies that values greater than 1 year are OK. The implementation of `http_cache_forever` seems to use 100 years: https://github.com/rails/rails/blob/ba438dbfaed4d6bc62ffc519993770753eb74259/actionpack/lib/action_controller/metal/conditional_get.rb#L228
&gt; What features have you found that AR has and Sequel lacks, which are related to interacting with a database? I can't remember them all now, but some things that come to mind are more sophisticated handling of eager/pre-loading (Rails `:includes ` that decides on it's own whether to do a join or a separate fetch is great, as you can specify the intent "I will be using this association" without knowing what other things may be added on to the relation that might require one or the other strategy), AR's ability to automatically save assoicated objects when the main object is saved; various things that require extensions to work in Sequel, and I'm not sure how mature/reliable/supported the Sequel extensions are (dirty tracking being the most pertinent example); being able to include default additional scoping in associations (or is there a way to do this in Sequel?). More things I'm not thinking of now. I'm _sure_ there are ways to work out or work around all of these things with Sequel; I'm not interested in arguing about it; I like Sequel. But when I've used it in the past, I _do_ occasionally hit up against something I'm used to AR doing for me that Sequel won't do. I don't remember them all now. Looking further based on my memories about eager loading/preloading woes, [this documentation](http://sequel.jeremyevans.net/rdoc/files/doc/advanced_associations_rdoc.html) scares me, compared to how straightforward it is to do the equivalent in AR. 
Ok thanks!!
We really aren't. I'm not sure what the point this article is trying to make, but I'm not looking to Sequel for features to copy. I'm responding to the needs of the community. There is of course bound to be overlap
&gt; but I'm not looking to Sequel for features to copy I believe that. I just stated that ActiveRecord is reinventing Sequel, not that it does so knowingly. However, if ActiveRecord doesn't have advantages over Sequel, moreover if AR's features are a subset of Sequel's (which I try to prove with my two articles), then it's questionable how worthwhile is it to continuously reimplement features that already exist in Sequel vs just using Sequel instead. And I've really gone through ActiveRecord most notable updates, showing that the vast majority overlaps with Sequel. I think it's good to respond to the needs of the community, I just think the community should be focused around a tool which is better, not the one that's part of Rails.
I'm not trying to justify my choice, I'm just trying to figure out why people are using ActiveRecord, and speaking my opinion that ActiveRecord is a redundant library, so that people maybe rethink their choice. The main reason is that I want to help the community to have the best developer experience, which is why I'm so active in open source in general. A personal benefit of Sequel being more popular would be that it's easier for me (and others) to find a job where Sequel is used. &gt; If you can't convince us on merits alone then complaining isn't going to do it either. Part of convincing that a tool is superior is demonstrating how the alternatives are not ideal. Some people may then see their pains: "Hey, yeah, I'm also having these problems with ActiveRecord". Sometimes you can't evaluate which tool is better, and sometimes you can. If Sequel has so many advantages over ActiveRecord and ActiveRecord so little over Sequel, then the conclusion is obvious. But I agree that positive motivation is generally better than negative.
[BAM!](http://stackoverflow.com/questions/34420554/there-was-an-error-while-trying-to-load-the-gem-uglifier-bundlergemrequire)
Active Record's feature set is definitely not a subset of Sequel, nor is that even a reasonable metric to define "better". Maybe you should consider focusing on why you think your app is better off with Sequel in your articles rather than attacking the work of other people. This article as it stands just send childish
I already did write a post about why my app is better off with Sequel, as did some other people. However, now I wanted to write a blog post about why *other* peoples' apps are probably better off with Sequel, which is a bit more engaging. It's really important to start with the "right" ORM, because later on it's almost impossible to make the switch. I'm not attacking work of other people, I'm sure that the effort put into ActiveRecord is very quality. I'm only saying that vast majority of features that resulted from these efforts already exist in Sequel. And that is true, as I showed in the post. Furthermore, since ActiveRecord didn't prove some significant advantages over Sequel (even though Sequel did over ActiveRecord), I have not choice but to conclude that there are no strong reasons to ever use ActiveRecord over Sequel. *Generally*, not just for me. Please, prove me that ActiveRecord has some significant advantages over Sequel. I agree that a "larger feature set" isn't the only metric to define "better", it has to be paired up with "good design" and "stability", and Sequel arguably has both of them; the design you can infer from reading posts linked in the first paragraph, while stability is 0 issues, only a few regressions in the whole history of Sequel, and a very extensive test suite.
TIL about Rubocop. And Rubocop just pissed all over my Cheerios. Thanks for this awesome tool!
I'm glad the alternatives survived the death of that momentum. Having alternatives is a good thing. But I'm glad that momentum *was* killed. It wouldn't be nice to live with three different ORMs, none of which is a go-to, a "leader". Having one ORM that is good enough and overwhelmingly popular is a good thing. It lowers the barrier to enter the project for any developer because every developer already knows that ORM. This is Rails phenomenon that all the modules they picked are good enough and form a highly usable framework. Any new Ruby developer on the team knows how to navigate in the project and contribute. How different from the Node.js webapps world where every app itself forms a different world because Sails.js never got the momentum. 
The go-to tool that most ruby developers use for this (other than google of course) is [pry](http://pryrepl.org/). For example, let's say you want to check what methods are available on a `Fixnum`: [1] pry(main)&gt; ls 123 Comparable#methods: between? Numeric#methods: +@ conj imaginary positive? real? step abs2 conjugate negative? pretty_print rect to_c angle eql? nonzero? pretty_print_cycle rectangular arg i phase quo remainder coerce imag polar real singleton_method_added Integer#methods: ceil downto gcdlcm next pred times to_r chr floor integer? numerator rationalize to_i truncate denominator gcd lcm ord round to_int upto Fixnum#methods: % ** -@ &lt;&lt; == &gt;= ^ div fdiv modulo succ zero? &amp; + / &lt;= === &gt;&gt; abs divmod inspect odd? to_f | * - &lt; &lt;=&gt; &gt; [] bit_length even? magnitude size to_s ~ That's a pretty good starting point for you to find what you're looking for!
Wow that image is really helpful. Messy but useful 
No need to; here is a high quality Ruby Core diagram: https://www.gliffy.com/go/publish/5152080
I had actually thought about a more practical approach. Something like this but more up-to-date (the files are from 2005) http://ruby-pdf.rubyforge.org/pdf-writer/demos/Ruby-Language-QuickRef.pdf http://ruby-pdf.rubyforge.org/pdf-writer/demos/Ruby-Library-QuickRef.pdf
For a quick single page link to all the documentation I use [THIS](http://overapi.com/ruby) 
Useful tool if you know what you are looking for...
That looks useful. It just links back to the official 1.9.3 documentation... Obviously hasn't been updated for quiet some time.
Looks really good, especially for a Ruby newbie! Great job so far. First things first: Where are the tests? To feel comfortable working on a codebase like this, I'd at least want some acceptance/smoke tests covering the high-level functionality, so I know I'm not breaking other things, when I refactor, add new features, or fix bugs. Next, if it were me, the next thing I would address is introducing some encapsulation. You have a bunch of global methods defined that are at various levels of abstraction. Some are high-level concepts, and should probably remain exposed, like `check_msg`. Others, like `get_user_by_id` and `get_formatted_date` are utility methods that are lower-level and are only used by other methods, so they can be hidden away inside to only expose the minimum interface necessary. The most obvious way to do this would be to create a class, maybe `SlackBombBot`, with the high-level methods as its public API, and the utility methods private. Lastly, just a general comment about comments (meta-comment?). Since Ruby is so expressive and readable, if you feel like you want to clarify what's going on with a comment, generally its better to rename or extract private methods where the name of the method explains what the comment would have. Save comments for the rare scenario of when the _why_ needs to be communicated, not the _what_ or the _how_. Overall, looks like you're doing very well with Ruby. Keep it up!
Yeah this makes so much sense, I don't know why I didn't think of it. Because it lets me alter the joke checking without trying to decipher than gigantic conditional. As far as testing, that seems to be the usual response, lol. It's tough to find good beginner level testing resources. Oh well!
I am really most interested to quickly find relevant methods to manipulate strings, arrays, integers and the general object methods. So I guess the http://overapi.com/ruby will do it...
Yeah, testing can be hard topic to crack, but believe me, its the best thing that has happened to me in my dynamic language career. I can at least tell you that at present, your program going to be somewhat challenging to test, because it interacts with the real world, so the only way to reliably test the entire thing at once it is to mock and stub out the the real world at the network level, using something like the VCR library. https://github.com/vcr/vcr However, if you tease your program apart into encapsulated, composable units, then you can test each unit in isolation, where you easily control all of the inputs. There are tradeoffs to both approaches, though. Hope this helps!
I wouldn't get overly concerned with class protection. At best it's a hint to future programmers as to what they should or should not use, i.e. it's trivial to circumvent at any time. If I were to review your code under the guise that this is a simple problem but the intent is to demonstrate code design: The first thing I would probably discuss is why `TicTackToe` is responsible for so much. It handles the UI, game logic, game state, etc.
Unfortunate that at the time of this post, there isn't much documentation. Looks pretty easy to do though from the examples. 
It's not really about security, it's more like "make it difficult to do stupid stuff". For example your `set_turn` method would cause trouble if you called it after the game started, so making it private is a good call. I wouldn't call this a "large project" since you only have the two classes (and the Player class could be refactored out, imo). I second that there's too much going on in the one class. And you have an error on line 117.
Would never have thought of the 18bit method, took a while to think of the binary idea (from fiddling with PIC's back in the day). The reason I came up with it is I was representing the the "winning spots" as an 8x3 array and having to collect and all? to find a winner which seemed long winded and not DRY.
Later I was thinking of using the Curses GEM and realized I would need to class a UI and that broke the illusion of the "game" being the master object. I am going to refactor into UI, Board, Player, and Rules classes for my next exercise. Does that sound like a correct division of identities?
So here is the thing...If you're using this as a simple problem to explore design choices that is one thing, if you're asking if this is a good design for a command line tic tack toe game, that is another thing. As a simple command line tick tack toe game, I would actually tell you that you've already over engineered it, it's way too complicated and frankly it probably shouldn't have a single class in it at all. If you're using this as a simple example to play with code organization, then yea, you can look at separating out features as you've devised. But one thing to keep in mind is that not all problems should be devolved into OO design patterns. For example you mention `Rules`. Rule systems are often much better represented in a more functional paradigm than they are an OO paradigm and Ruby gives you the power to make the choice. 
It's challenging finding good contract jobs. Many employers have a way overinflated sense of the value of their team/culture/leadership/whatever. Want to attract good people? Want your team to care about the company's success? Here's a newsflash: plan out a *great* product to work on and highly compensate your contractors and employees alike and let them work flexible hours from wherever they want. It's pretty simple. People (*gasp*!) like working on cool stuff and not feeling like they're slaves to the corporation. Who knew? It's crazy to me that so many Silicon Valley-style companies, thinking they're oh-so-innovative, are hardly anything more than a simple evolution of pre-Internet corporations. Hundreds/thousands of people commuting to come into an office 5 days a week to sit in front of a computer at a desk, slaving away for 60+ hour weeks. Ridiculous! Companies themselves should be getting more "open source" and start letting their teams self-organize and self-determine how they will be compensated and get things done. A few places do this well -- Valve is an interesting case study for instance. Remote work *is* becoming a lot more accepted. But, by and large, the workforce is lagging behind Internet-fuled innovation so much, it's nuts. And don't even get me started on the whole sending-out-resumes game. I'm dumbfounded that, in this day and age, you can submit resumes to *tech companies* right and left, and you get back NOTHING. No response. No status. No way to see if any human even read the darn thing. Why is it that I can analyze the performance of code running on a server line-by-line, yet I can't even see if my resume was received at its destination? (let alone read, let alone evaluated, etc.) And these are *tech companies* we're talking about, not McDonalds. Anyway, back to your original question: **Contact Jobs Pros and Cons** *Pros* * Flexible working hours and places * Able to work on multiple projects * Able to do personal branding * Less likely to get bored doing the same thing every day/mont/year *Cons* * Not enough companies "get it" and hire contractors properly * Hard to find really great projects * Places like freelancer/upwork/etc. make it harder to market contracting services at a decent rate (aka $100/hr rather than $10/hr). * Not enough job boards that encourage contracts (even WeWorkRemotely.com has probably 80% employee-type positions posted and not even a way to filter based on contract vs. employee).
I agree about many ORMs, but it would still be better if either Sequel or DataMapper/ROM were the "leader", since both of them are "awesome" in comparison to ActiveRecord which is just "good enough". Even if you currently only need "good enough", you should still use the "awesome" ORM, because once your requirements start being more advanced, you won't have to switch ORMs. ActiveRecord actually is the reason we now have three ORMs. Before ActiveRecord 3.0 the Rails team could've realized that Sequel did a much better job at implementing the Active Record pattern. Instead, rather than deprecating ActiveRecord and advising people to use Sequel, they [deprecated a significant portion of ActiveRecord API](http://sequel.jeremyevans.net/2010/02/03/activerecord-deprecation-switch-to-sequel.html) in favour of a Sequel-like API replacement, deciding to still blindly push ActiveRecord. If they did the right thing, Sequel would be the rightful leader (or DataMapper/ROM). But it's ok, Sequel still kept its awesomeness by being ahead of ActiveRecord all of these years, despite having a much smaller community. However, because of ActiveRecord's popularity a lot of business will still choose it, but later realize its downsides and that it's a bummer they can't upgrade ActiveRecord independently of Rails, and then it's nearly impossible to make the switch. That's why it's bad that "good enough" is more popular than "awesome".
[Treat](https://github.com/louismullie/treat) is a decent one, as are [stanford-core-nlp](https://github.com/louismullie/stanford-core-nlp) and [open-nlp](https://github.com/louismullie/open-nlp) However, I've had some good luck with IBM's watson hosted services: http://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/alchemy-language.html
Nice, I was aware of treat and watson but I will check in on those other libs. Thanks!
As Ruby is my language of choice, this looks very appealing to me - but I'm wondering if using this, rather than just using Phaser in its native JavaScript, is going to cause more problems than it solves? For example, how do you debug JavaScript errors if you're working with Ruby source code? At this point you're going to need to know at least some JavaScript, thus losing the benefit of it being Ruby. Unless I'm wrong?
Ibm AlchemyAPI looks interesting. Is it free to use? I saw the demo but no mention of pricing.
Agreed. "Cache forever" just sounds wrong when you say it out loud and consider what it means.
This is a very good idea. Thanks for sharing.
Take it with a pinch of salt, but I see no difference to any ruby module/gem with extensions. If the error arises within your code, you'll stay in Ruby, even if stack trace would continue in foreign code call. If it would come from a native library or Javascript module, you would probably have to wait for a fix from upstream anyway.
Had to submit a pull request on the grammar. :)
I don't know about you but when I employ GoF patterns, the results don't really look like boilerplate code.
[tpope's vim-rails](https://github.com/tpope/vim-rails), while clearly Rails-specific, is very similar to what you're proposing. Yay OSS!
From the README: &gt; Throw a bang on the end (:Emodel foo!) to automatically create the file with the standard boilerplate if it doesn't exist.
&gt; Of course, you have to keep in mind that this optimization was helpful in our case only because we had the following requirements: &gt; &gt; - We expect our input to be in ISO8601 format &gt; - We use JRuby &gt; - Time parsing had a significant impact on our requests performance
And although the quoted 1300% performance boost (in this specific area of the code) may indeed be true, in the wider context of this application: &gt; I was able to get an overall 3% speed up There are usually much bigger ways to improve application performance, e.g. better caching and eager loading. (Which is a *very* broad topic!) Nevertheless, nice article. It's interesting to see how some of the language internals work in detail.
This is such a stupid comment. Their intentions were never to destroy Opal, &lt;s&gt;Coraline was a contributor to it before the situation arose, as you know already&lt;/s&gt;(Update: I apologize and stand corrected, she was not a contributor, read my comment below... but still..). You're just acting like a fanboy if you speak like that and this does nothing better to Opal than what happened did already. If anybody is curious to find out more: http://geekfeminism.wikia.com/wiki/OpalGate_incident but honestly I'd like to see some discussion on Opal-Phaser here rather than another useless 4chan themed flamewar. 
&gt;Coraline was a contributor to it before the situation arose, Bullshit. What an ignorant and malicious lie. She was never a contributor to the project. She saw something one of the contributors said in another forum and then tried to lynch him with her twitter mob. &gt;but honestly I'd like to see some discussion on Opal-Phaser here rather than another useless 4chan themed flamewar. It's not possible to separate out the SJW movement from open source anymore. Coraline made sure of that. From now on nobody can just talk about the source code. You have to also talk about people's gender expressions and sensitivities. Coraline poisoned the well. She forced her toxic personality and destructive and hateful impulses on everybody and now is going to go on a witch hunt on everybody who is on github because that's her new job. Anyway she tried to destroy this project and failed, for that I am happy. BTW you should be ashamed to give a link to geekfeminism as an unbiased source of this incident. Shame on you, have some dignity and integrity FFS.
I like `pry` so much that I'm prepared to cheat, using an approach like [Pry Everywhere](http://lucapette.me/pry-everywhere/). It's certainly not perfect – cheating `Bundler`sounds like something that's going to trip me up eventually. But so far, the number of problems it's actually caused is zero, and the boost to my productivity has been immense.
Not gonna bother changing it now, but thanks anyway. It's always good to see people contributing :)
I'd agree the intention was likely not to destroy Opal, but overreaction of that *"lady"* to a personal opinion of one contributor published on other place (Twitter). The intention could be related to more ordinary reasons like frustration with her looks, taken hormonal pills which may cause mental imbalance with even suicidial moods etc. and *way how it vents*.
We use a combination of gems 'two_factor_authentication' to work with devise, it also you to enter it after logging in, 'rqrcode_png' to generate a qr code with an auth secret so you can set it up to work with Google authenticator, and twilio to use text messages as the 2nd factor
I have written similar tooling before. In the end, I regretted every single test I wrote that was asserting that one giant blob of data more or less equalled another giant blob of data. It seems convenient to get so much test coverage for free, particularly for assertions like "did this HTTP API return _exactly_ this response?" In the end, it's been a handcuff. It's better, in my experience, to decompose the problem and test isolated pieces.
&gt; What would be a real world parallel to this? Generating methods for SQL interaction? Yes. For example, consider [Active Record enums](http://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html). Have a quick read through that page. Or if you want to write some more manual meta-programming, how about this (simplified) real-world example from my current project: STATUSES = ["Pending", "Passed", "Failed"] STATUSES.each do |status| define_method("#{status.lower}?") { self.status == status } end a = Application.new(status: "Pending") a.pending? # =&gt; true a.passed? # =&gt; false
Here is one example: I have a background job that runs every 60s to collect various pieces of slow moving information to send to statsd for live metric tracking. There are many things we track and they don't have much to do with each other, each is a usually just a couple lines of code in theory you could separate these out into classes but that is massive overkill. Instead the implementation of this is a module that looks like: module Monitors class &lt;&lt; self def collector_one # collect something StatsD.gauge "some.metric.name", value end def collector_two # ... end # more collectors end end And the job that runs every 60s is just one line: Monitors.singleton_methods.each { |method| Monitors.send(method) } Which just gets a list of all singleton methods on `Monitor` then calls each of them. This makes it very easy to track additional information later on, just add a method to the `Monitors` module and you're done. 
Maybe a stupid question, but... Where can we find the source?
How does it differ from `Test::Unit`/`minitest`? 
I like it. Kudos! I especially like the fact that it resembles RSpec, yet it is lightweight.
Thanks! I made sure to incorporate what I liked about both RSpec and minitest.
This is off topic (slightly), but I like to use `extend self` in that situation: module Monitors extend self def collector_one # .. end end The metaprogramming becomes simpler, too: Monitors.methods.each do |method| Monitors.send(method) end And, actually, because `Method` objects are really just bound Procs, you can invoke them directly: Monitors.method.each do |method| method.call end This is now a job for `Symbol#to_proc`: Monitors.method.each &amp;:call Wow, okay that filled my bikeshed quota for the day. **EDIT**: Oh one more thing, ugh, I am terrible. I would put a `.call` method on `Monitors` itself to encapsulate the logic for dispatching all the methods: module Monitors extend self def call methods = self.methods - [method(__method__)] methods.each &amp;:call end end Monitors.() Wow, I have a problem. I am sorry...
I think Rails uses it in some places to cache dynamic methods. For example, `Article#find_by_blog_url`instead of just being implemented on `method_missing`, caches some of the work and actually does a `define_method :find_by_blog_url` so that subsequent calls don't have to re-do the work.
1. create a file called thing.rb 2. write `puts "hello world"` in that file. 3. go to the commandline in the right place and run `ruby thing.rb` tadaah. After that, read up on bundler and the Gemfile, as well as how to require both gems and other files you yourself wrote, and you'll be on your way.
Contractor cons: Taxes!!, Healthcare, although I assume that is better with Obamacare. You are constantly looking for the next gig. Scope creep, get real good at the SOW. Payables in some cases. It also depends a lot on the type of contract and how you're getting paid. Is it just you or do you have to work within a team? If a team, there goes your flex schedule in most cases. Contract jobs, IMO, aren't worth it if they want you to show up to their office every day, for a multitude of reasons. Hustled for a couple years, went back to perm, wouldn't do it again.
Learn some sinatra and make a simple web server.
The whole thing seems overly complicated, but I'd just have the lowest level provide a global hash table of configuration, sure. If you need configuration shared by all the layers. 
The end keyword belongs to if .. else .. end. Simply move the puts 'c' after the end keyword.
Thanks for all the help, it finally worked. I understand how it works now. I see now what I did. I've been treating end like return; to finish the program. So now I fully understand why my broken code below didnt work. puts 'Enter an int' x = gets.to_i if x &gt; 1 puts 'a' else puts 'b' end puts 'c' end
nice article
&gt; What if your GET request means "execute this trade"? Then it shouldn't just get randomly retried… Then the API is broken, since GET must be used only for idempotent requests (basically, those that _can_ be re-tried transparently). Sure, it happens, and sometimes you need to deal with broken APIs, and maybe you need to be able to turn off retry even for idempotent request methods to do so. But it's important to point out the API is broken in this case. 
I don't really find anything about `Net::HTTP` surprising, the mentioned issues are: * Retrying idempotent methods - As mentioned in the article this is recommended by the RFC and even if the client didn't retry, many proxies out in the wild will. Doing something non-idempotent with a GET is simply wrong. * Always using TCP_NODELAY. Also not sure why this was is surprising, I don't know of many system left that don't use TCP_DELAYED_ACK so without TCP_NODELAY you'll have shit throughput. I can't dream up a use case for not using TCP_NODELAY with an http client anyway, the idea doesn't really make sense. 
Download this text editor: https://www.sublimetext.com/ create a new file and save it as a .rb 
Oh, well that's the easy part then! a little surprised they didn't get you started on what editors to choose from in the course. I recommend [the Atom text editor](https://atom.io/) over Sublime like someone else has suggested. Atom is completely free, and will forever be free. Just open that up, create a new file, and save it with the .rb extension. The part before the extension can be whatever you want. The reason you can't use something like Word is that it doesn't save the document in "plain text", so Ruby won't be able to read the file you create with it. Notepad would work though, assuming you're running Windows, but Atom or Sublime would be much better.
I tried to say it more politely. :)
No problem. Caveat on file names though. I said it can be "whatever you want", which isn't quite true. There can't be any spaces, and the Ruby convention for naming files is all lower case and words separated by an underscore. For example: hello_world.rb After you create the file, in your terminal `cd` into the folder where you saved the file and type `ruby` followed by the name of the file you created and hit enter. That will run the code you saved to the file.
Yeah, if you look on the right side of the page, there's some info listed - that's what I mean by sidebar. One of those links to the ruby documentation, which has a tutorial that walks you through writing and running a ruby application in the way most of us do it - using a text editor and command line. Others have covered why you can't write this in word. I'm aiming you're using Windows, right? Installation for some stuff still depends on your OS.
Ouch, what codebase are you looking at?
Yeah, I'm using Windows. I have Atom downloaded and am just getting used to it. Is there anything else that needs downloaded? Again I'm a complete noob, so I get that you might be getting pissed of at this point. Yous have really helped me though.
No worries man! We've all been new at some point, and someone helped us out so the least we can do is pay it forward. Ok, so although I don't use Atom, I've heard it's good. It might be worth searching for packages that developers, especially doing ruby, find useful to install. So, the next thing is running your programs using a command prompt. Your command prompt is determined by your OS, Windows, Unix, or Linux. The majority of Ruby developers use *Nixon rather than Windows. There's quite a few resources for using Windows command prompt, and it's certainly doable, but you'll be in the minority. Now you can be like me and download a *Nix style command prompt to run on Windows. I learned how to use a *Nix command prompt first, so this works out well for me. If you go that route, two popular choices are Cygwin and GIT bash. I've used both, so I'd you decide to go with one of those let me know and I'll help you out there as well. 
Been using Ruby for well over 10 years.
Okay so I downloaded GIT Bash, and I'm trying to find a way to run, puts "Hello", which I made on Atom but its saying command not found, what am I doing wrong?
After a lot of research myself, I find it hard to justify using ruby to do web sockets. For a while I figured it would be great to prototype, then later switch to nodejs for performance, but when you consider the migration path... it's not pretty, and generally full of problems. I really hope crystal-lang picks up more steam. Check out the benchmarks: http://kemalcr.com/
What exactly are you typing? It could be that you haven't added ruby to your path for GIT bash. I'd do a search for that and see if people's recommendations help solve the problem. 
How do I go about adding it to my path? 
Google will help you out there, just try "adding ruby to path in windows git bash" or something like that
You can try [Ruby Installer](http://rubyinstaller.org/). I've heard good things about it, but never used it myself. In the long run you'd probably save yourself a lot of pain if you just installed Linux on a virtual machine. Not many people develop Ruby on Windows, and Linux distros ship with a version of Ruby preinstalled (although not the latest version). Not sure if you've ever set up a virtual machine before, but you can use [VirtualBox](https://www.virtualbox.org/wiki/Downloads) (which is free), and install [Ubuntu](http://www.ubuntu.com/desktop) (also free). There are plenty of resources on how to get it installed if you feel like going that route, but you can use Ruby Installer first to see if that's good enough for now if you don't feel like messing with VMs.
Does CodeAcademy not cover use of text editors and how to execute Ruby code? You could use something simple like TextEdit or Notepad but what you really want is something designed for writing code. Sublime is great and you can trial the full version for an unlimited period of time. If you end up using it to build real projects, I recommend supporting their development by buying it.
You sure it's not an apostrophe? (u0027) Anyway, try double quotes to hold a string with an apostrophe, use backslashes to escape your backslashes, rather than using forward slashes, and don't remove the colon: Dir.exists?("C:\\Users\\Blake's Computer\\Documents")
short answer: no. longer answer: * not all files are equal. Many files are what you call "plaintext", i.e. the contents of the file are in their entirety readable by, and makes sense to, a human. ruby files are plaintext, word documents are not. * file suffixes such as `txt`, `.rb` and `.doc` are there as mere courtesy. A word document renamed from `.doc` to `.rb` remains a word document all the same. Only problem is that your operating system doesn't actually know anything about file types. It will happily assume your .rb file is actually a ruby file, try to deal with it as such, and nothing will work. This can be confusing because many programs are able to open more than one file type, and sometimes changing the suffix can work well for you because your system now assigns the file to the right program, even though that program was able to open the file all along. (this happens most commonly with image file types.) To create a plaintext file, you will have to use a proper text editor that is meant for writing text, such as vim, emacs, sublime or atom. You can also for the purpose of coding ruby use a more specialised develompent software like rubymine. (No, word is not meant for writing text, it's meant for creating good-looking documents. Pure text has no fonts, margins, images or anything of the sort in it. Pure text is nothing but letters and symbols in a line. A pure text editor lets you edit at more than one place at once. A pure text editor has keyboard shortcuts to select all occurrences of the current word in the file, or swap the current line with the one above.) in a pinch, notepad on windows will make plaintext files, or even word if you fiddle with the save dialog and select the "txt" format. (format, not filename) If you seek to fiddle with programming, I strongly suggest you check out a beginners guide for sublime or atom. (My personal favourite is sublime, but I'm leaning towards switching to atom if they ever get project handling support...)
Aaah, I was just clicking the "Documentation" links.
I really like this. The project would benefit from some more documentation of installation procedures and run-time options. Once the tests are written, how are they executed?
The idea seems nice. Certainly a test that simply doesn't allow you to create some of the most obvious code smells in your code would lead to better design when TDD'ing everything. However, I think it's unrealistic. You will have to deal with legacy code at some point. You will sometimes just write bad code. And when I have that kind of code and I need to refactor, I sure as hell love that RSpec still gives me *allow_any_instance_of*, even though it totally sucks. But if a test framework doesn't allow me to cover bad code with tests, how can I move forward improving that code?
FWIW, I think that many Ruby gems have very good *example based* documentation, wikis etc., but in terms of full, comprehensive API docs, sometimes it's a little more disappointing. Sometimes there this one parameter/tweak that you can pass in, but you'd never know if you just look at the examples and not the source code.
Are you asking what indices and foreign keys are or how to get rid of them? Answer to first: Indices make your database faster (well, it depends, but indices on foreign keys generally do), while foreign keys (more properly, foreign key *constraints*) give you more integrity guarantees. As to the second: just remove it from the migrations (although I don't know why you'd want to.)
Great feedback, thanks. I added a quick start guide to the main README that covers the installation and execution. Please let me know if it helps (or doesn't).
please don't think I'm trying to bash on sneakers, because I'm not. the main pain point we had was error reporting, we have never been able to send a airbrake message to our errbit server in sneakers. we tried multiple ways, but could never get it to post a message to errbit, though we did succeed with getting a message posted to hipchat. I believe a majority of these problem have been figured out: https://github.com/jondot/sneakers/pull/191 As for daemonizing, I'll go ahead and admit that I'm not a great devops guy. I can play one on TV if need be, but definitely not my strength. I'd rather have logging, process motoring and all that jazz handled for me; you have to be very hands on with sneakers, and that's fine (I just want people to know that if they are reading this) Point being, this pain point might be my own, not sneakers. I do think the API communicating with Sneakers internals could be improved a bit, but I understand, those things will come with time. You can see a bit of what I'm talking about here: https://github.com/jondot/sneakers/issues/123
For further entertainment: The cookie (`fsb_all`) comes from the 'Free Shipping Bar' plugin for shopify: https://apps.shopify.com/free-shipping-bar. It's JS source (http://pastebin.com/GD6RJnvV) is delightfully obfuscated. I'm fairly surprised shopify allows 'apps' to run JS directly in shop's page, not sandboxed at all, that opens up a lot of...interesting...business models for the app vendors. 
Actually `method` is a variable inherited from [Net::HTTPGenericRequest](http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTPGenericRequest.html), and contains a string with the [HTTP method](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) of the request. Probably could have been named better, like `request_method` or something. 
Yes, great! Would still put install instructions as simple as: `gem install test_bench` in the readme somewhere just to be overly clear about that. Some more feedback; at work we have a lot and lot of reports that generate every day and I use a test-framework to make sure they are where they are and have been properly handled. Sample code: context "My random tests" do 300.times do |x| context "Process with number #{x}" do test "Must not fail!" do assert x != 16 ? true : false end end end end Works great. The problem is that there is no easy way with the current set of output options to get a clear understanding of what test failed (and its context). Normal settings gives too much output to find the missing test. Quiet show there is a test failing, but it is very hard to figure out it was Process 16. It would be awesome to add an option in between normal and verbose that only prints the failed tests and its context. 
When devs ask what my job involves (as Chief Engineer of a startup in the DPR of Singapore), I answer "mitigating Rails, and finding the mythical available *and qualified* dev". When mitigating Rails becomes a significant, or even *noticeable*, activity in your work life, it's time to shut down the WTFometer (that's been pegged since time immemorial, at least wrt your project), and apply real architecture to the problem. Approaches like [*Growing Rails Applications in Practice*](https://leanpub.com/growing-rails) and [*Trailblazer: A New Architecture for Rails*](https://leanpub.com/trailblazer) help, and eventually you'll stumble on [these Adam Hawkins posts](http://hawkins.io/2014/01/rediscovering-the-joy-of-design/), and you'll realise the Basic Truth of Developing in Ruby: &gt; The Rails Way would be crystal meth, if it were less lethal. The means of production and effects of use have *disturbing* parallels. Survival is possible. If this company is still a going concern in two years' time, I confidently expect we'll be Rails-free…but the journey, while enlightening, has been at best marginally survivable. Good luck.
This seems like something I should look at. I just found this as well. https://github.com/smartinez87/exception_notification#custom-notifier which might work.
Only think I can think of is maybe some sort of wrapper method that yields a block on rescue so you can report_to_sentry then run whatever else in your rescue block. Sounds awful though, I wouldn't bother.
That was my first thought too. But you're right, it does sound awful. :)
Hey /u/PMYOUMYTITS, I'm the maintainer for the Sentry Ruby client. Why isn't the default Rails middleware we use working for you?
Hi there. :) It works for us in this situation, rescue =&gt; error Raven.capture_exception(error) if Rails.env.staging? || Rails.env.production? render json: false, status: :unprocessable_entity end However, if I don't have the Raven.capture_exception it doesn't report, right? Is there a way that whenever I rescue an error, I can trigger the same method without explicitly having it everywhere (within every rescue).
Nope. 
Ahhh, now I understand. First, rather than using `Rails.env.staging` etc., I would just remove those checks. Sentry only sends errors when `ENV['SENTRY_DSN']` is set. If you don't set that in development, these exceptions will not be sent in development. But I think /u/jrochkind is right, I'm not sure of any good solution for you. If this in a controller, you may be able to clean up your rescue blocks with [`rescue_from`](http://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html).
&gt; Would still put install instructions as simple as: gem install test_bench in the readme somewhere just to be overly clear about that. I thought about this a lot. On one hand, I thought, "surely `gem install test_bench`" is obvious. On the other hand, I think it's valuable to show clearly and concisely that this project is a ruby gem we're talking about. So I added the clarification. &gt; It would be awesome to add an option in between normal and verbose that only prints the failed tests and its context. I didn't anticipate this feature, and I'm going back and forth. Quiet output should show only the failures and the summary at the end. However, should the context around a failing test be included? That's a tough question. I'm leaning towards "yes," but it may not prove trivial as Test Bench is printing out context before the tests are actually run. If Test Bench is otherwise useful, I recommend including potentially redundant information in the prose you pass to `test`, e.g.: context "My random tests" do 300.times do |x| context "Process with number #{x}" do test "Must not fail! (Process with number #{x})" do assert x != 16 end end end end Feel free to file an issue in github for this, and I'll keep you posted on a better solution there.
We have a rails app that was able to demonstrate at least a proof of concept of working with Test Bench in an afternoon. The trouble with Rails is actually that controller and integration tests need additional elaborations; I may never write the code to support that, since Rails just isn't enough of a focus for me and I'd probably do a poor job for that reason. &gt; But I definitely think your approach is laudable, and while I'm not sure yet whether I agree with your approach on stubbing/mocking, it's at least something to think about. That is totally fair. If you haven't, I recommend spending some time avoiding the use of stubs and mocks on a side project or in any non-production context. It is not only doable, but I personally like the results a lot more. While there are many examples in Test Bench's test suite where a stub would have saved a few lines of test code, but on the other hand, the tests are forced to be incredibly explicit. I feel comfortable operating both with and without a mocking library now. I think that's a valuable capability, even for programmers who eventually decide they prefer to use mocking libraries.
I'm not sure what you're trying to do but the standard use case for something like Sentry is to report exceptions that are _not_ explicitly rescued in your code, that is an exception that fails a request. A normal way to deal with such exceptions is to let them pass through and allow Rails to catch them higher up, returning an error page or whatever else you'd like to do like alerting sentry. The ruby sentry client hooks itself into Rails to handle this for you automatically. If you have a bit of code that you want to do some other handling on in the event of a fatal exception, which is often fairly rare, what you should probably do is reraise the exception: begin # some code that throws rescue StandardError =&gt; e # your custom handling raise e # raise so the higher exception handlers can process it end If you have an exception that isn't fatal to the request, but you'd still like to be alerted to it, then you can handle the exception and manually call Sentry via `Raven.capture_exception(e)` in the rescue block and not re-raise the exception. One final tip: I often see people try to use exception monitoring tools to track non-exceptional circumstances, for example a 'record not found' result from a simple rest endpoint. These aren't exceptional situations, they happen all the time and may even happen a lot. To track things like this you're better off using other tools, statsd/graphite, etc. 
The [Tracepoint API](http://ruby-doc.org/core-2.0.0/TracePoint.html) built into Ruby 2.x has you covered. TracePoint.trace(:raise) do |tp| report_to_sentry tp.raised_exception end
That looks awesome!
That traces `raise` not `rescue`. `rescue FooError` calls `FooError.===` (`rescue` calls `StandardError.===`) so you could do this: class &lt;&lt; Exception def ===(o) super(o).tap do |z| report_to_sentry(o) if z end end end 
EDIT2: The post has been edited since I initially wrote this comment, it's now mostly correct, although the wording is still strange in spots. The article is a bit off here... Rails has always calculated weak ETags, it just wasn't properly identifying them as weak. This change doesn't impact the need to take an MD5 of the response body, nor does Rails even do that. When you say `fresh_when @item` as I recall what it does is mix `item.id`, `item.updated_at` and a hash of the view template together to form an ETag, this avoids having to render the view to calculate the MD5 of the response body. What this may fix is when the Rails app server sits behind a proxy that handles gzipping of responses, since that process makes the ETag weak and appends a `W/` to the front of it, this will cause ETag misses on subsequent requests. tl;dr no performance gain here on the backend, but may improve ETag cache hits. EDIT: just to note - if you're not using Rails' etag support then Rack will add an etag by hashing the response body, but this is also a weak etag already. I.e. the mentioned change in rack is also just a bug fix with no real performance benefit. In most cases this etag isn't much use anyway as almost all responses have something dynamic in the body. 
So... how do browsers handle weak vs strong etag/validation? I have been unsuccesful at finding anything on this via google. 
I don't get it. What does it do and why?
I don't know that I agree with taking out the checks. It may make that line of code a bit cleaner, but it creates a dependency on some fact that exists somewhere else in the codebase. Overall I think it's likely to create more confusion. A better way to write it though would be Raven.capture_exception(error) if Rails.env.in? %w( staging production ) Note that `Object#in?` is an ActiveSupport method, so to do it more idiomatically you would have to use Array#include?
Get a list of 8 or so of them here: http://www.rubyinside.com/ruby-cheat-sheet-734.html
It would be purely for purposes of shaming ;)
I wouldn't get discouraged, it just takes time. I started with Chris Pine's book (great book for newbs) and didn't really take much away from it until I read through it the second time. For some reason it clicked the second time through. Keep pushing and at some point you'll break through. I've been teaching myself for the last 4-5 months (about an hour per day) and though I can do some things, I still feel like a novice. I figure it will take at least a year before I'm close to a level of competency that would be worth hiring.
Assuming this is Rails, if *:user_id* is all you're storing in *session*, *session[:user_id]* will be overwritten and it will be business as usual, but you'd also be using the same session_id which can create security concerns. In general, you'll want to run *reset_session* after a successful sign in and before storing *:user_id* so you don't have conflicting session data.
I looked at some of the easy problems in /r/dailyprogrammer and I dont think those are good problems for people just starting out. Have you looked at [learn ruby the hard way](http://learnrubythehardway.org/book/)? I didnt use it starting out, but it looks like it might help. If you already have some programming experience and want to learn ruby, then I would suggest writing simple command line projects. You know like writing a black jack game or maybe [cowsay](https://en.wikipedia.org/wiki/Cowsay). Once you have some intuition of what ruby can do and how to do it, you can write bigger apps. 
reset_session clears out the entire session (possibly including any temporary keys used for encryption). It is recommended for safety, in case there was other sensitive stuff in there other than the user_id, that the user may not want hanging around. And that your app may or may not act upon in a future request even with the `[:user_id]` cleared out, depending on the logic of your app. May not be necessary, but safest to reset the whole session. 
What happens when a second user signs it while I'm signed in?
http://guides.rubyonrails.org/action_controller_overview.html#session Rails generates a unique session id which is stored in an encrypted cookie. The default behavior is to also store session values in that cookie. So *session[:user_id]* would be encrypted server-side and sent to the user. They would then send the cookie back on the next request, which would be decrypted and the *:user_id* value made available.
Also note that Rails resets the session if a form is submitted without the proper authenticity token and protect_from_forgery is enabled. http://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf Wasted an afternoon figuring that one out.
Why is this posted here? This has nothing to do with ruby.
&gt; creates a dependency on some fact that exists somewhere else in the codebase Would you set your database configuration with if statements rather than config files (or env variables)?
Rake::Application\#invoke_task is an instance level method, why it's not explicitly private isn't clear. The source does have a comment indicating that it's part of a set of internal methods. Oddly if you set it to private and run the tests there's only one failure but the test is only calling #invoke_task to run multiple tasks and check that the backtrace on an error is correct. The more rake-ish way to call another task is Rake::Task["im_a_task"].invoke.
The "private" you see is just part of a comment and has no semantic meaning (Ruby's `private` has nothing to do with it). The comment was later renamed to "internal" and the method was removed from the documentation: https://github.com/ruby/rake/commit/f3a6f6bf411936e74657d0c506f4e51e6a04f6b5
I think you mean my_list.each &amp;:do_something
Browsers don't process etags at all, they just send them back via the `If-None-Match` header on the next request.
We just ran into the same issue on AIX and came up with a solution. The problem is that there is a C macro created by a system library named _ALL_SOURCE that is also defined within Ruby. Ruby can be patched to undefine the system macro right before it's defined in Ruby which has solved the issue for us. The patch we used is here: https://gist.github.com/amdprophet/ca5caabe4d2f3bbee172 You may also run into issues w/eventmachine complaining about improper LD flags. We forked eventmachine to fix this issue but we have a PR open against upstream: https://github.com/eventmachine/eventmachine/pull/693 I hope this helps!
came here to post this 
Thank you!
[Rails](http://api.rubyonrails.org/) is the go-to framework used to build apps in Ruby. As other guys have pointed out, you should ideally be looking for other resources, I found "Why's Poignant Guide To Ruby" a great resource when starting out.
i wouldn't trip about the project euler problems unless you're really looking to show off your math chops. That's going to be more algorithmic programming, totally different than making web apps or whatever. In general don't be discouraged, this algorithms stuff is basically testing if your skills are equivalent to a CS degree holder's. 
yes exactly like that, thank you very much.
thank you! 
Oh I know the Project Euler ones get a bid ridiculous after a point, I was more worried about the /r/dailyprogrammer ones. I'm just trying to cover my bases in case I get asked a real tough problem on a job interview, but taking a glance at "Easy" problems there makes my stomach sick. I just want to land a Junior Developer position, not a job at Google haha. But thanks for the encouragement! Really appreciated. 
sorry, I made it sounds like all programmers were sceptical, which wasn't the case probably It was definitely a thing in my dev circles to laugh at twitter (before the first wave of dev early adopters started): "how artificial it is to limit yourself to 140 chars" "wtf you can do with 140 chars" Then, the early adopters started and it became natural to be on twitter. There's some laughing at snapchat in my circles. I noticed a pattern and want to see if it's going to be the same as with Twitter. It may happen that it's a different case and I'll delete Snapchat next week :) So far, this post made me &gt;20 new followers, so it's cool to see that there's some interest!
&gt; Snapchat is that tool which only teens are able to use - it's UX is terrible This is such a ridiculous statement. While it is very popular amongst teens, it is in widespread use for young adults as well. My large network of friends who are all 22-30 year old technology and finance professionals all use it avidly. While the UX can be improved, it is not hard to use. &gt; I remember how we (programmers) were sceptical about Twitter Not how I remember it. There were pockets of more mainstream media who decried it, but generally it was thought of as ingenious and clever amongst the tech community. 
I've got an idea: Snapchat + StackOverflow You write answers to questions that disappear in 24 hours. That way, only the trendiest js frameworks will be on there. 
[Array#Each](http://ruby-doc.org/core-2.2.0/Array.html#method-i-each) all_students.each { |student| print "#{student.first_name} #{student.last_name} is in #{student.grade}" end EDIT: Sadly, ruby is not my first language anymore. :(
I swear I did that... but yeah, totally works. Thanks
Personally all of the people that I would describe as '10x programmers' aren't awesome because they ingest feature requirement X and output code Y, they are awesome because they understand the product, it's requirements, and the impact of feature X with an eye toward the implications that feature has on the future of the product. As a result their design ends up much more aligned with both the current state of the product and where it's going. 
I'm curious why the ordering matters? For what it's worth, a better way to handle pagination is through http headers. 
How are you finding the talks? Really good so far!
That works, except that it only accepts the ISO standard format (right?). It doesn't look like I can pass a format string in. I might be able to change the format in which we're receiving the timestring; I'll have to dig into the javascript library. Thanks
It's actually in the context of rails; in the hack-y solution above, I use `ActiveSupport::TimeZone`; the problem I'm having specifically is getting it to use the correct offset given the date in the timestring when parsing said timestring. I might be able to reformat the timestring so that I can use `ActiveSupport::TimeZone.new().parse()`, but I'm not sure.
There isn't but confreaks recorded the talks last year. Not sure if its the same this year
Thanks ... Guess I will have to wait for the recordings. I think confreaks should upload videos as they have the link ready. http://confreaks.tv/events/bathruby2016 
I wish :) Interesting talks lined up.
I think the 10x programmer term is kind of awful though. It often is applied to someone who makes mistakes recklessly.
So what we do and I -believe- works in that case is: def get_time(time, zone) Time.use_zone(zone) { Time.zone.parse(time) } end
X-Post referenced from /r/videos by /u/yusefdoodie [My good friend is learning Ruby, so he made a Bomb Defusal assistant in 'Keep Talking and Nobody Explodes'. Now it's single player!](https://www.reddit.com/r/videos/comments/49yqyf/my_good_friend_is_learning_ruby_so_he_made_a_bomb/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Kontena... Sounds like a Chinese person saying 'container'
I have no idea what is happening, but cool 👍
Then you are missing out on the excellence that is RubyTapas :)
Love that game. I noticed that he was playing "Simon" and also "venting" while simultaneously working the modules. Cool stuff.
Eek. I don't like this. It just digs you deeper into the bottomless pit of Active Record callback hell. What code is being executed, and under what conditions? And where does it live? When AR callbacks are involved, these are simple questions with very complicated answers.
http://www.keeptalkinggame.com/
github repo plz 
Neat video, just bought the game. I've heard nothing but good things about it.
Here's the repo: https://github.com/devanhurst/ktane_voice
I was! Enjoyed it thoroughly.
This is a terrible feature. It just encourages more behaviour to be stuffed into the ActiveRecord model, where it doesn't belong. Even Rafael Franca who's on the Rails core team [doesn't seem keen on it](https://github.com/rails/rails/issues/18847#issuecomment-74109632)
Don't sell yourself short.
Haha yeah in a way your right but this is more about how you can use inheritance to solve a particular problem - particularly when dealing with algorithms. Here is some more information [source](https://en.m.wikipedia.org/wiki/Template_method_pattern)
You can either load it when starting the interpreter or add it to the $LOAD_PATH: `ruby -Ilib /home/xxxx/ruby/gems/json-1.8.3/lib/json.rb my_script.rb` or `$LOAD_PATH.unshift(File.dirname('/home/xxxx/ruby/gems/json-1.8.3/lib'))` BTW Ruby 1.8 is very old and unsupported, you'll find lots of small differences from 1.9+ that will cause issues for you, like `json` not being part of the std library. I'd see if it's possible to install a modern version of Ruby on your host. 
Even 1.9.3 is end of life. Ruby 2.x is the way to go.
*you're* also, are you the author of the article? if so, you don't need the type parameter for the initialize method in the second implementation of the Room class
The theme is for rdoc. Will it work with yardoc?
I was a huge fan of the Template Method pattern in my C++ days but with Ruby it doesn't really work because the language doesn't enable you to enforce the contract, eg. there is no way you can stop someone overriding the calculate_total_cost method. Plus in Ruby you have blocks so you don't need to use inheritance... https://gist.github.com/hmaddocks/11d7d4db166a5eee71e0 
Personally I've moved away from template method and instead choose to break out a separate object and use duck typing. Why? Template method relies on inheritance which obscures the flow of control and makes interactions more complex. Template method can be done properly but it can get really confusing in a complex system (e.g. Is this method on the child class, the base class, some mixin, or the class derived from my child? Are there any overrides?). I find that duck-typing leads to more intuitive control flow (e.g. I just call "start" on my adapter and follow what that does. No inheritance ping-ponging)
Hey! If I could chime in, I highly recommend downloading a beginner book on Ruby such as Chris Pine's Learning to Program. The syntax I picked up in codecademy helped me blow through the exercises, and the real world knowledge from the book had me applying it right away. I'm about halfway through the codecademy course, chapter 9 in the book, and I've already written some fun programs like number to roman numeral converters, calculators, interactive stories and calendars etc. Also, textmate is a great editor! The hallows eve theme is great. :D Good luck! Oh and the book walks you through running basic text programs in the terminal and using the command line which is infinitely useful.
Yeah, I don't know what's actually the relationship between RDoc and YARD, I just use RDoc with markdown.
I had similar trouble with the python api. In order to send from my local machine instead of cloud storage, I needed to set up a service account key and add it to my environment variables properly. Which is to say, I couldn't just follow the tutorial word-for-word, I had to tweak it to run as a service from my local machine instead. I imagine you're hitting that same wall. Not the encoding, probably just the wrong API key interaction. 
covermymeds? Edit: you mentioned it in a later comment. Your company held a pair programming event two months ago and I didn't know a single thing about coding. All I had was "you'd be a really good at this." I went and one of your employees was so nice and encouraging that I've been teaching myself JavaScript and Ruby ever since. I like Ruby a lot more. It would be my dream to work at a company like yours and I go to every event since then. Covermymeds showed me that 1. coding is fun and 2. the developer community is awesome and encouraging. Whats funny is that I work at the Sheriff's Office down the street :P Not even 3 minutes from Miranova. 
So you are saying I should use that Template Method Pattern implementation in Ruby even though it's unnecessary, but I shouldn't use it in C++, instead I should implement my own closure system specifically to avoid using the pattern? The language that that that implementation was designed for. You're going use that pattern implementation even though it's inappropriate. You're going to write C++ in your Ruby apps and no one can stop you! That's awesome!
This kind of monkey patching to ruby's standard library classes is one of the few problems I see in the ruby ecosystem. I see no advantage to having these functions available on a string object. It's unintuitive and creates more problems than it solves. Just my two cents. Thanks for sharing.
Could you clarify what you are describing with your own examples? I don't do well with just a word description. I need to see it to understand it.
agree, dont really the design of this library, even the url should not be just a string but an actual object of type url.
It is indeed the case. I messaged them, for now I moved the script on another server that has Ruby 2.2. Lame but works.
I think you're on to something there. There's a lot of focus on patterns when most programming work is describing reality accurately at the required resolution. In fact it's more meta than that – it's inventing a vocabulary that lets us write descriptions effectively. In the example given, the goal is to calculate a price. But it was not accurate to attribute the price to a room. The room is only a very small part of the price. What would be more accurate is to describe the price as being composed of: * the room price * the number of nights * the parking price * the number of nights * the minibar item price * the number of items consumed By looking at the example code, we can see that the adjectives "Normal" and "Suite" do not apply to rooms at all, but a set of price points for rooms, parking spaces, and minibar items – which has a name in English – a rate plan! By now the refactor is clear; to describe the composition of prices we require these classes with the following attributes: * Stay[int: nights, int: minibar_items, RatePlan: rate_plan] * RatePlan[string: name, decimal: room_price, decimal: parking_price, decimal: minibar_item_price] With the vocabulary better formulated for this scenario, we now have a language to describe our customers' stays accurately. When the resolution of the reality changes and make our implicit assumptions incorrect, e.g. when customers start coming in with zero or multiple cars, or when there are differently-priced items in the minibar, then we will need to modify the vocabulary to match the desired accuracy. This may be a small change to add an attribute, or in more extreme cases a refactor and a change of programming pattern is necessary. To me, the art of reducing future refactoring headaches is the discipline of software engineering. Learning about patterns is useful, it lets us avoid having to reinvent the wheel when someone else has already thought it through. However it doesn't matter how many patterns one learns, there's no skipping the work of really grokking the reality behind the application.
Yes indeed!
im in my last year of software engineering in Canada. Part of the requirements for graduating in the great white north is developing a senior project and presenting it to peers and professors. This is an excerpt on sessions from my final report.
As a general rule of thumb, there is a better approach if you find yourself nesting if statements like this.
Cheers Figuring out the better approach was the hard part! 
You can find more solutions to this on [Ruby Quiz](http://rubyquiz.com/quiz22.html) and [Rosetta Code](https://www.rosettacode.org/wiki/Roman_numerals/Encode#Ruby). I cobbled together this solution based on those, iterating over a map of letters to numbers: letters = %w[M̅ D̅ C̅ L̅ X̅ V̅ M D C L X V I] numbers = 12.downto(0).map{ |n| (n % 2 * 4 + 1) * 10 ** (n / 2) } SYMBOLS = numbers.zip letters def roman_numeral num SYMBOLS.each_with_object '' do |(number, letter), string| div, num = num.divmod number string &lt;&lt; letter * div end end puts roman_numeral 42 # =&gt; XXXXII These algorithms are greedy, a better result would be `XLII`. See if you can figure out an elegant way to do that...
Awesome. There are a couple methods here I haven't been introduced to here, but I can piece together what's going on. Will try to rewrite this tomorrow and post it back with the suggestion. 
Isn't roman numeral for `4` `IV`, not `IIII`?
&gt; A Rails design we were not familiar with prior creating this design was that a session is only able to hold 4kb of information at a time. Only if you're storing session in cookies, right? You can use `activerecord-session_store` which I believe has no such limit, right? &gt; To combat this we needed to create a ‘sudo’ session, a block of code that acts as a session but is stored and retrieve from the database as opposed to memory. Now you have a weird hybrid cookie/db session store, with the db part implemented yourself. (I also don't see how this is analogous to `sudo`?) I think you'd be better off just using the ActiveRecord::SessionStore from the start. There are reasons to prefer a cookie store to the db store, which is why it is the default. It's nice not to have a db bottleneck. But once you're storing half your session in the db anyway, you might as well just use the rails implementation, just flip the switch you don't need to change any of the rest of your code or reinvent the wheel. 
The first example gets the job done. The second example is intention revealing and concise without being overly overly clever. Great comparison of where we start to where we are trying to go. Thanks for sharing.
Almost nobody on Reddit reads the article. Comment sections are full of people reacting only to the title. So, functionality, Reddit is more or less Twitter with a little more metadata. There's a big difference in what people think they want vs what they actually want.
Agree monkey patching in general is bad. But you see this as unintuitive because this is the first time you must be seeing something like this. Integer.from_s("1") or "1".to_i. Which one do you think is intuitive? Similarly, when you compare SomeClient.get("url") and "url".http_get you will find the latter to be more intuitive. Urls are just strings. You can decorate them all you want by having objects like url, etc. But they are simply strings. If a string is url, let it also return its response.
This is the normal convention, yes. However: &gt; Usage in ancient Rome varied greatly and remained inconsistent in medieval and modern times .... https://en.wikipedia.org/wiki/Roman_numerals#Alternative_forms For the sake of simplicity, it is much easier to assign beginner programmers with the task of writing Roman numerals in this form.
everyone needs a terminal spinner. but seriously, nice job. seems better than spinning_cursor
Does 'I' * 2 == 'II' in Ruby?
If you want to select a random element from an array, use [Array#sample](http://ruby-doc.org/core-2.3.0/Array.html#method-i-sample): [:foo, :bar].sample # =&gt; :bar If you want to select a random number within a range, use [Kernel#rand](http://ruby-doc.org/core-2.3.0/Kernel.html#method-i-rand): rand(1..100) # =&gt; 73 Generating a random `n` digit number is a bit more unusual, so there is no "built-in" way to do it. But for example, how about this 1-liner: def random_digits(n) n.times.map {(0..9).to_a.sample}.join end random_digits(5) # =&gt; "04628" For a more "general" solution to the problem of generating random strings, you could use [my ruby gem](https://github.com/tom-lord/regexp-examples): require 'regexp-examples' /\d{5}/.random_example # =&gt; "91820" And as a more general rule, it's considered bad practice to mix such different methods into one method. You're performing very different behaviour via a *type check*, which will only lead to confusion. Basically, you should always think twice about using `kind_of?` or `is_a?`. Still, a nice bit of messing around - keep learning :)
Gist author here. Thank's for the tip. Using regexp to define patterns for randomly generated strings, like your gem does, is a brilliant idea!
&gt; Urls are just strings. a) URLs can be represented as Strings, which is not the same as "urls are strings". b) Even if URLs are a subset of strings, that doesn't justify adding a URL specific method to all Strings. &gt; Agree monkey patching in general is bad. So, don't do it then.
&gt; `Kernel#rand` can indeed take a Range, but your demonstration is off. Sorry, what? Please elaborate. &gt; Your `random_digits` implementation is fine [...] but benchmark-ips reported the following refactor as being up to 10x faster Yeah, I was actually originally going to post this exact code - but decided against it, since a newbie is unlikely to understand what `"%0#{n}d"` means! But if performance is really an issue, then your approach is clearly superior. (Unless it gets dodgy for large values of `n`? Not sure - I'd need to play around.)
you brought up a major typo in the paper, I meant pseudo not sudo. D'OH. I was seeing the overflow error using the default rails sessions. But you are totally correct and activerecord-session_store was the first gem I studied when I was looking for a solution and solved all the problems I was having with session overflow. However, since im working on an academic project and need to defend in front of profs I decided to take the harder route and develop a very (very) light weight version of activerecord-session_store
I like it. Sure it's a bit monkey patch-ish. But it's creative. Cool stuff
&gt; not sure about that syntax Original code: def random_digits(n) "%0#{n}d" % rand(10 ** n) end Explanation: [String#%](http://ruby-doc.org/core-2.3.0/String.html#method-i-25) applies a string format specification, as defined by [Kernel#sprintf](http://ruby-doc.org/core-2.3.0/Kernel.html#method-i-sprintf). Here are a few examples, building up to that confusing line of code above: 1. Basic string formatting, with a number (`%d`): "Hello world %d" % 12345 # =&gt; "Hello world 12345" 2. Padding the number with leading zeros, until it's at least `3` chars long: "A bit harder %03d" % 7 # =&gt; "A bit harder 007" "A bit harder %03d" % 99999 # =&gt; "A bit harder 99999" Now using the variable `n` in our code, if we assume `n=5`: 3. Padding the number with leading zeros, until it's at least `n` chars long: "Almost there! %0#{n}d" % 666 # =&gt; "Almost there 00666" 4. Choosing a random number, between 0 and 999...999 (where there are `n` "9"s): rand(10 ** n) # =&gt; "826" 5. Putting it all together: An `n`-digit, zero-padded number: "%0#{n}d" % rand(10 ** n) # =&gt; "00826"
I see you mentioned how to do this, but *why*?
Never mind—for some reason I had thought that the second one was modifying a string literal with &lt;&lt;. Must have been smoking crack or something.
&gt; Also do you mind expanding on what you mean by " weird hybrid cookie/db store " You still have the Rails session storage in cookie you just aren't putting anything there (and if you accidentally did, it would probably get over-written from the stuff you pull in manually from db). If you were actually using ActiveRecord::SessionStore, there wouldn't be even the possibility of accidentally storing things in a session store in cookies, because there would be no session store in cookies. All that would be in the cookies would indeed be the session ID itself and any other auth information Rails put there, without you needing to know about it or worry about it. 
Why switch to GraphQL from RESTful?
Very interesting. Also, don't forget to secure your websockets (Faye, ActionCable, etc.) if you're using them.
Yeah whenever I write nested `if`s or even sometimes when there is just one `if`, I try too see if there is a good way to express it without `if`s. Like guard clauses that do early returns, or what Chris pine did in your screenshot.
I use acme-client https://github.com/unixcharles/acme-client
If you split it up and test it step by step (locations.scan then locations.scan.map, etc), it becomes clearer. Immediately before the map, we have this: &gt; locations.scan(/(\w[A-Za-z ]+), ([A-Z]{2})/) =&gt; [["Alabama", "AL"], ["Alaska", "AK"], ["Arizona", "AZ"], ["Arkansas", "AR"], ["California", "CA"], ["Colorado", "CO"], ["Connecticut", "CT"], ["Delaware", "DE"], ["Florida", "FL"], ["Georgia", "GA"], ["South Dakota", "SD"]] Map takes this big array and for each element in the array, which are the inner arrays like ["Georgia", "GA"], creates a hash that looks like: {:state=&gt;loc[1], :city=&gt;loc[0]}. In the previous example with Georgia, loc[0] is "Georgia" and loc[1] is "GA". So you end up with an array of those hashes. Does that make sense? Also, try testing without puts, as puts removes some of the formatting, like it removes the brackets on an array sometimes.
The .scan is producing an array of results found by the regex. The regex has two matching groups so it in turn returns a two member array: 2.2.1 :002 &gt; 'Alabama, AL'.scan(/(\w[A-Za-z ]+), ([A-Z]{2})/) =&gt; [["Alabama", "AL"]] As you map over the results of the scan, the block evaluated by the map is handed the array of regex results ("loc" in the code sample). Accessing it with [0] and [1] lets you grab the first and second result returned from the regex. That's why any number over 1 produces nil - there are only two results and accessing an empty index of an array returns nil: 2.2.1 :003 &gt; [1,2,3][6] =&gt; nil 
Thanks. I didn't notice city and state were flipped from left to right in the code block.
Thanks. I didn't notice city and state were flipped from left to right in the code block. 
I can agree given the context of the current example I am showing. However , In my opinion For cases such as prices of any entity returning nil would not make any sense , class Property ... def price @price end ... If it returns nil . It is not explicitly clear what nil means . Is it supposed to mean that there is no price for it (free ) ? . Does it mean it is not sellable etc. Hence, The grab of Null Object Pattern for me and my team mates has been to make more sense out of code. Also in my experience handling nil's via exception would ultimately lead to multitude of problems is codebase and very bad code smells. like multiple begin rescue being used to handle the business logic and the application flow as well as multiple chained try methods (when breaking LOD). 
So, [dpr](https://github.com/SudhagarS/dpr) uses [unirest](https://github.com/Mashape/unirest-ruby), which uses [rest-client](https://github.com/rest-client/rest-client), which uses Net::HTTP. Since I don't see substantial advantage over using Net::HTTP directly, I don't think adding this much complexity is worthwhile.
Same here, actually a lot of the tty packages I'm working on are inspired by Debian configurations/installation process. I think Ruby is so much more than just a language for web development. I guess I want to popularise its usage in the scripting world for anything from administration tasks to building CLI tools.
I thought it was not true JSON though? It was retrieved from an API as an HTML format instead of raw or text.
Yeah, not so sure about that. Here's a couple of thoughts: 1. Insisting that everything should be in OOP-style when currently functional programming is becoming more en vogue is not useful in my view. Let's rather focus on what makes sense for a given situation and not so much on dogmas. To me, it's becoming obvious that OOP has some flaws in its outlook on the world (I think the FP have it right that mixing together data structures / types and behaviour is not necessarily ideal), but that it's nevertheless useful as an organizational / documentational principle. 2. That said, I'm all for pulling entities, value objects, etc. out of the internal state of methods and reifying them into classes. That max example seems a bit too much for me, but in other cases I agree. If you have a method that returns an array of validation errors you could e.g. create a ValidationErrors class that implements Enumberable and takes the class to validate as a constructor argument. 3. Design doesn't have to be perfect from the get go - you will never be able to foresee all the changes. Sandi Metz wrote at some point that there is some misunderstanding about the open-closed principle. You will never be able to create a class (method / whatever) that is infinitely open to modification without changing its internals. The key is that whenever you identify a point where some specifics have to change, refactor the code so the specifics can be injected; or as Kent Beck (I think) put it: "Make the change easy, then make the easy change". That is, the emphasis should be much more on refactoring *as needed by your application* (by obviously keeping in mind some of the principles of software engineering) and less on creating flawless code from the beginning. If you write a method that is reasonably encapsulated and doesn't have to change in two years, I honestly don't care too much if it's written crappily. 4. I like to have "utility classes" that are nevertheless instantiable (like "services", "use cases", etc.), because then i can pass in some arguments to the constructor and don't have to pass around so many arguments internally. It also helps with stuff like dependency injection, if you want to substitute some mock objects or change a strategy for some specific things. Then, however, I mostly treat the instance variable as immutable after initialization, because that makes things easier to reason about. YMMV, I'm just trying out different approaches and I haven't found the one that truly ultimately satisfies me yet. btw: one redeeming quality of JavaScript is that it actually allows to create "free" functions (with a proper module system as in ES6 (or node), they don't even have to be global or anything). This is useful for many smaller things, and you can easily move to something more advanced as soon as the need arises.
&gt; that's Ruby code probably from a JSON source Edited to clarify 8 minutes before your reply ;) Either way, it definitely didn't come from HTML unless there was some heavy parsing going on, in which case we wouldn't be here.
What is the overall project here? That looks an API call that was saved via the output of `inspect` or `to_s` called on a Ruby hash. There are much better ways to handle this if saving API calls is what you're trying to do and it avoids needing to use regexes to try to retrieve information later on. 
it's not JSON but it looks like properly formatted ruby code which you can eval: data = eval File.read("data.txt") data["posts"].each { |post| puts post["post_url"] } ofc eval will execute any ruby code found in that file so be careful
No, not at all. The first line doesn't make sense and the method is called each_line. Also, what file are you actually opening. A *.rb file?! But, perhaps you should take a step back and start with some ruby tutorials ... looks like you have a lot to learn.
wow, this is a genius idea. Thank you! As a novice, i've been always dumping JSON output in another file and then attempting to parse huge files or clean it. This is so much better. Just one question though, i'm confused by the text = MyApi.read(myURL). I used this, which gives me the parsed selection but then dumps the complete JSON after it. Obviously i'm missing a small bit. This is what I have: require "tumblr_client" client = Tumblr::Client.new :consumer_key =&gt; 'XXXXXXXXXXXXXX' myURL = client.posts 'example.tumblr.com', :type =&gt; 'photo', :limit =&gt; 1 myURL['posts'].each { |post| puts post['post_url'] } What am I missing here, where does the **text = MyApi.read(myURL)** come in? I apologize if this is a frustrating question, but I am really eager to learn this and I am learning a lot from you. Thank you!!
That was just a dummy line because I didn't know the gem you were using - lines 2 and 3 of your code serve that purpose. I'd replace `myURL` with `posts` in your code so it's more understandable later, but that should work fine.
Well, it has not. You should try to reflect the contents of the file in the file extension. Actually, nobody cares about file extensions except for double-click behavior, but it's good practice.
How does Arel deal with parameter binding or escaping?
Maybe this? File.open('texterino', 'w') { |file| file.puts posts.map{ |post| post['post_url'] } } 
does not seem to work
Does that even apply if you're not hand-writing SQL? From the article, this is a query fragment hand-written in SQL: .where('created_at &gt;= ?', beginning_of_month) But that's not Arel. This is how you would do the same thing in Arel: .where(arel[:created_at].gteq(beginning_of_month))
You are probably correct that the second version will be kinder to the garbage collector, assuming there are no dangling references. Best way to be sure though is to measure. Check out GC.stat. It contains info about the garbage collector as your code is running. Another useful code snippet is memory_usage = `ps -o rss= -p #{Process.pid}`.to_i/1024 This will print the processes memory usage. Put both of these before and after your loop to see the different memory behaviour. 
 def uppercase?(ord) ord.between?(64, 91) end def encode(char, shift) ord = char.ord return char unless ord.between?(65, 123) lower_limit, upper_limit = uppercase?(ord) ? [65, 91] : [96, 123] shifted_ord = ord + shift shifted_ord &gt; upper_limit ? (lower_limit + shifted_ord % upper_limit).chr : shifted_ord.chr end def caesar_cipher(string, shift) string.chars.map { |char| encode(char, shift) }.join() end puts caesar_cipher("What a string!", 5) __uppercase method__: quick abstraction to make the code a little more flexible and readable __encode method__: I extracted the converting to ordinal from the main function to the encode function It seemed for a friendlier API: char in, ciphered char out. I also renamed some things to make the code easier to read. __cipher method__: I extracted any ciphering logic to the encode method. I tend to keep maps simple; The implementation logic should live elsewhere You had some hard-coded `5`s in your question so I took a guess as to what they were supposed to mean. Not sure if this actually gives the right answer. Also, since the encode function does the main part of the work, putting all encoding logic there makes it more testable, should testing be something you hold important. Final edit: Go for readability, not brevity. Your future self and co-workers will thank you. 
Following my own advice about readability and testability, I might refactor to something like this: def uppercase?(ord) ord.between?(64, 91) end def out_of_bounds?(ord, limit) ord &gt; limit end def encode(char, shift) ord = char.ord return char unless ord.between?(65, 123) lower_limit, upper_limit = uppercase?(ord) ? [65, 91] : [96, 123] shifted_ord = ord + shift if out_of_bounds?(shifted_ord, upper_limit) wrapped_ord(lower_limit, upper_limit, shifted_ord).chr else shifted_ord.chr end end def wrapped_ord(low, hi, ord) low + ord % hi end def caesar_cipher(string, shift) string.chars.map { |char| encode(char, shift) }.join() end puts caesar_cipher("What a string!", 5)
 CHARS = [*?A..?Z], [*?a..?z] def caesar_cipher string, shift string.tr CHARS.join, CHARS.map{ |ary| ary.rotate shift }.join end puts caesar_cipher 'What a string!', 5 # =&gt; Bmfy f xywnsl! 
 def caesar(string, shift) string.chars.map(&amp;:ord).map do |i| if i.between?(65, 90) ((i - 65 + shift) % 26) + 65 elsif i.between?(97, 122) ((i - 97 + shift) % 26) + 97 else i end end.map(&amp;:chr).join end
Damn. Took me a while to fully understand that as a beginner. Very impressive!
I think you can use `Arel` to satisfy your needs but I hear a lot of good things about [activerecord-import](https://github.com/zdennis/activerecord-import) if you'd like to give it a try.
&gt; I don't do well with just a word description. I need to see it to understand it. Not sure I can fix that on Reddit but here's a better explanation: When you create object hierarchies through inheritance you're implicitly defining what 'the key specialization is'. In the Hotel room example you're basically saying 'the most critical difference between one room and another if whether or not it's a Suite'. The problem is that most things don't have one critical difference. Some or even many uses of a Hotel Room model may not care at all if they are a Suite or not and would rather separate them by some other feature. This tends to be true of many problem domains, in practice inheritance is very rarely the correct tool. The problem comes in when you try to force everything into an inheritance hierarchy, you either end up with wonky code to has to side step the inheritance all over the place or you have to introduce a ton of intermediary abstractions to get everything to work. e.g. the latter is the approach often taken in Java EE development and is a big part of why they end up with massive inheritance hierarchy are all sorts of obtuse constructs, and it's in no small part due to the lack of any meaningful trait system(see below). So what do you use instead? The most popular approaches are: * Composition - Instead of the Room being broken into a SuiteRoom and a NormalRoom with pricing methods, a single Room model has a PriceCalculator instance, just an instance variable that it delegates work to. For the Hotel example this is probably the right answer as the PricingCalculator can be parameterized based on various features of the room and provided input based on external influences, e.g. current room demand in the area. * Traits - You define capabilities and selectively mix them into an object. This most useful for sharing functionality between object and probably the most common approach in Ruby via module mixins. To keep with the Hotel example you may have Hotel Rooms and Utility Rooms but both have key card access and both models need to know how to perform various functions based on that. You could have a KeyCardRoom and then GuestRoom and UtilityRoom classes inherit from it or you could have a mixin with all the functionality needed for dealing with keycards that just gets mixed into classes where needed. 
This is really hard to answer without seeing the rest of the code, specifically how the nodes are connected and what exactly the recursion looks like. If possible post the rest of the code or at least it's pseudo structure. One tool at your disposal when dealing with tree structures in the GC is `WeakRef`: http://ruby-doc.org/stdlib-2.1.2/libdoc/weakref/rdoc/WeakRef.html Although it's usually not needed as mark-and-sweep should clean up internally circular references, all depends on the details. 
Why are you using gemsets? That seems to be a big part of the hangup here. Also you can just wrap multiple foreman calls across projects with a simple `start.sh` shell script. 
There is really never a place for a null object, the entire concept is befuddling (granted `nil` is an object in Ruby, but you're better off forgetting that). Every example I've seen isn't in any way related to `null` other than in the 'not found' sense. As you've noted the meaning of `nil` for a price doesn't make sense so why would you back it with a `NullPrice` model? All you're doing is moving around the undefined terminology of 'null/nil'. Instead of a return value it's now a named class...doesn't buy you much. It's perfectly fine to have an implementation of a class that handles the 'unknown' but that isn't 'null', for example the most common example is a `NullUser` for non-logged in users, but that isn't a `NullUser`, it's an `AnonymousUser` or a `UnknownUser`, etc. Your `NullRewardFee` isn't null at all, it's a `NoRewardFee` or `DefaultRewardFee`. 
ImageMagick is never going to die, 50 years from now when C is considered archaic hogwash ImageMagick will be the lone standing C library everyone still uses wrapped in whatever is needed to make it work. 
Doesn't keep the capitalisation though, which OP wants.
Meh, in that case it's no longer a caesar cipher but some special sub-case there of, like ROT13.
&gt; So you are saying I should use that Template Method Pattern implementation in Ruby even though it's unnecessary I didn't say that at all, I said it's not a good idea to not use a design pattern in Ruby because you lack rigid constraints. If you look at my other comments I don't thing the design pattern is very good in any language. &gt; but I shouldn't use it in C++, instead I should implement my own closure system specifically to avoid using the pattern You should probably avoid the pattern because it's a bad pattern, excessive use of inheritance is a bad idea in any language. 'implementing your own closure system' is rather trivial in general, just curry the function at hand in time. &gt; The language that that that implementation was designed for. Do you really think the template method pattern was explicitly 'designed' for C++? &gt; You're going use that pattern implementation even though it's inappropriate. Didn't say that. &gt; You're going to write C++ in your Ruby apps and no one can stop you! That's awesome! Didn't say that either. You chose to infer a lot more than was needed in your comment.
&gt; But RMagick is in somewhat sorry state currently. I'm curious what your issues are with it are, it's a wrapper around an external library. Not like there is a lot of work to be done there and the number of open issues is tiny given it's popularity. 
see "coding style": &gt; you may omit the `return` keyword where applicable 
Oh, prepared statements, that's a good question. I'd like to know this as well.
This is really neat. The main downside is doing type annotations via comments. It's not a deal breaker, but it can take me out of the flow of writing code. Why not offer a way to strip types? Or actually do inline comments so they don't have to exist above the class/methods?
Rmagick seems to work fine. I've written a decent amount of code that relies pretty heavily on it, and haven't really had any issues with it. Its a little memory hungry, but its a C library, and frankly doesn't really add much load, when compared to say, a node process or whatever.
Cool, activerecord-import seems to do a proper multi-INSERT statement, without instantiating any `ActiveRecord::Base` objects. But it's a bit strange that you cannot do such a simple thing with Arel.
[removed]
Two things: First, ruby always returns an integer when you divide two integers, so &gt; 67/30 =&gt; 2 So the `.ceil` wouldn't actually change anything at this point. You can force ruby to give you a real number answer by making one (or both) of the values real numbers by adding `.0` &gt; 67.0/30 =&gt; 2.333333333333334 Second, method invocation (like `.ceil`) has a higher precedence than division. That means `.ceil` is actually being called on 30 first before any division has taken place. To force the division to happen first, use parentheses: &gt; (67.0/30).ceil =&gt; 3 
Thanks!
We are using *rmagick* quite extensively and not yet hit a showstopper. A few issues either fixed soon or worked around but nothing serious. Do you have some specific issue or is it a *feeling* only ? I'd like to hear about any, security-wise preferably.
Ruby, actually, has return statement. Returning last value may be interpreted as implicit return statement, but Ruby has explicut either.
Please, stop promoting new syntax, especially disgusting one!!!
I just tried experimenting some more.... InfraRuby behaves weirdly! http://infraruby.com/live/3875050943996806382 ## String -&gt; String def test(string_variable) foo = string_variable end puts "Result is #{test("hello")}" # =&gt; "Result is hello" http://infraruby.com/live/2486481608977139978 ## String -&gt; void def test(string_variable) foo = string_variable end puts "Result is #{test("hello")}" # =&gt; "./ruby/main.ir:5: error: not implemented: unexpected void" http://infraruby.com/live/2070382632128387755 ## String -&gt; void def test(string_variable) foo = string_variable end puts test("hello").nil? # =&gt; "./ruby/main.ir:5: error: void call" You're right, I don't understand this language at all.
&gt; `# =&gt; ./ruby/main.ir:10: error: cannot find signature for "initialize"` The `initialize` method takes a `String`: Foo.new("ok") &gt; `# =&gt; "Result is hello"` Yes, as that method has `String` return type, the method returns the value of the expression `foo = string_variable`, which is `"hello"` in this case. &gt; `# =&gt; "./ruby/main.ir:5: error: not implemented: unexpected void"` You are using the result of a `void` method in a string interpolation, which is a compile error. &gt; `# =&gt; "./ruby/main.ir:5: error: void call"` You are calling `nil?` on the result of a `void` method, which is a compile error. &gt; You're right, I don't understand this language at all. Those error messages could be improved, but I doubt that would help *you*. 
BTW, the typing *is* optional in InfraRuby, as you can run (partially-typed) InfraRuby code in a Ruby interpreter, with the same behavior.
&gt; I don't want to declare which methods return nil. Or void, for that matter. Then use a Ruby interpreter! &gt; I don't want nil and void to mean different things. [You're too late for that!](https://en.wikipedia.org/wiki/Void_type) &gt; I don't want there to be a compulsory declared type constraint (esp. with regards to nil vs void type stuff). Then use a Ruby interpreter! &gt; I do want all declared type constraints to be enforced. Then you do want mandatory `return` or `nil` at the end of methods declared `void` (i.e. `nil`, as you would have it)? &gt; Basically, I don't want ruby to be statically typed. At this point I'm trying to understand what you're doing in this thread... 
[Endoh-san's candidate](https://bugs.ruby-lang.org/issues/12125#note-12) for `Object#method` sugar.
Yes sorry I figured it out. PageObject is used (in this case) to access elements on a webpage to manipulate/validate... etc. The problem I ran into was that you can create a class and give that class a "page_url" which when you call that class goes to the webpage specified in "page_url". But if you use the elements on the page to navigate away from the webpage that is set to "page_url" the normals means of accessing the current URL of the webpage returns what is listed under "page_url". So I needed to figure out how to get it. What I ended up doing looks like this: result = @browser.execute_script("return document.URL;") more info about what I am blabbing about here: https://github.com/cheezy/page-object/wiki/Creating-and-using-page-objects
Services are meant to be autonomous in SOA. Service autonomy might actually be the most fundamental principle. Having to run all the services on your laptop is a sign that you've got a monolithic architecture pretending to be a SOA.
It is a bold statement, but borne from experience, I promise. &gt; ... I sometimes want to have all the stuff open to debug some issues across whole app. What do you mean by "whole app?" And how can issues pervade across multiple services, if services are autonomous? In my experience, when service boundaries are correct, there is no need to run the whole stack on a laptop. Standing up a staging environment will generally suffice for manual testing. When the programmers start needing to run the stack on their laptops, it's often a sign that you've simply built a monolithic architecture out of separated units of deployment -- which is actually how I'd characterize the "microservices" movement if I'm feeling uncharitable.
Funny, the same example (stock watching) is used in the observable module documentation.
yes, yes it is a sad state. Because making a full-featured graphic manipulation library is hard and time-consuming, making a good API with good documentation for it is even harder, doing it in pure ruby instead of C is unlikely, wrapping a complex good C API (not that I'd say imagemagick has one neccesarily) in ruby such that it's a good ruby API is hard too. So we've got imagemagick, with it's weird API, with several which-is-the-least-awful methods of accessing it from ruby, all of them hacky, few of them well maintained. I agree with you on ruby-vips, it looks nice (and vips itself looks like an improvement on imagemagick), but figuring out how to use it has been challenging for me -- heck, figuring out imagemagick has been too, but at least there's tons of examples on google. And ruby-vips seems to not be popular, perhaps for that reason -- easier to copy and paste examples of rmagick from google. I don't have a sense of whether vips itself is catching on or not in non-ruby worlds, but it might be? I have nor know of any solution. I guess trying to dive into vips and ruby-vips might be worth a shot. I _think_ it can probably work with drawing primitives, and do most anything imagemagick can do, but hard to say. I'd check the docs for straight `vips` library to see if it can do what you want, if so probably ruby-vips wraps it. 
Well, I've seen null object used to great effect as substitutes for dependencies that have external side effects, so I wouldn't say that there is _never_ a place for them. That said, seeing the word `Null` show up as the first word of a ruby class is usually a bad sign.
I use site_prism for page objects with capybara and selenium you can use : page.current_url https://github.com/natritmeyer/site_prism
Indeed. That laid aside, my article's intention was not to provide an *optimal* way of solving this problem, rather than to serve as an example of illustrating the value of factory methods as a means to generate self-documenting code.
Fantastic news, keep up the good work! &lt;3
Flog didn't install to your Desktop – it installed to your global gem repository. Are you using `rvm` or `rbenv`? If so, then it installed in the gem repository of whatever Ruby version and gemset you are using. Try running `gem list` to see it, and then `gem which flog` to see where it really installed. You can use `gem uninstall flog` to remove it.
Love your work! Greate to see that ruby is not only about Rails and ActiveSupport.
&gt; (0..lines.size-1).to_a.sample(25) Change of request actually, now I am no longer wishing to ever delete the lines from the file, I am looking to just randomly take a sample of 25 lines, how can I do that?
I ended up doing something like this for youtube music videos, only writing it in python. Practical reasons for this was to access the built-in API, and put it in an AWS Lambda function. [Here's my code](https://gist.github.com/1ps0/4d0ffbad002e5a3cade8) I spent the most time realizing I needed to download the binaries `ffmpeg` and `ffprobe` and put them in the folder `./ffmpeg/` relative to the project. I left it after successfully tying in an API Gateway path. The params accepted are in json: `{ url:"youtube-link" }`. Works pretty well, just haven't decided how I want to use it. Maybe turn it into a dynamic music streaming service or something.
awesome, thanks for taking the time to respond
Thanks for publishing `dry-types`! A while ago I looked for a decent coercion library and `dry-types` looked like what I wanted, but it kinda bothered us that it wasn't published yet. So, I ended up copying Haskell's aeson which looked like this: c = Coercer.object(User.method(:new), Coercer.pair(:name, Coercer.string), Coercer.pair(:dob, Coercer.one_of(Coercer.date, Coercer.nil)), Coercer.optional_pair(:skill, skill_coercer) ) skill_coercer = Coercer.integer.bind do |i| { 1 =&gt; Coercer.succeed(Beginner), 2 =&gt; Coercer.succeed(Amateur), 3 =&gt; Coercer.succeed(Pro) }.fetch(i) { Coercer.fail } end c.run({name: "foo", dob: "2014-01-02", skill: 3}) # =&gt; Some(#&lt;struct User name="foo", dob=#&lt;Date: 2014-01-02&gt;, skill=Some(Pro)&gt;) c.run({name: "foo", dob: "2014-01/23"}) # =&gt; None With some additional convenience methods it can be pretty concise, but I guess I'll try out `dry-types` next time I need to touch that code.
&gt; global gem repository Ah I see. I thought gems installed per app. When you run Bundle, it checks against the ones you already have and includes them (or are they already there) instead of redownloading?
You can run `gem install` from any directory, it doesn't install to the current dir, it installs to the current system gem location. To uninstall it, just run `gem uninstall flog`. Again from any directory. 
There's still time. Let's call it 'Dry Rub'
Bundler ensures that all the gems in a Gemfile are installed in your system (however it's managed). When running apps with Bundler, they are bootstrapped with a special environment that only contains those gems. Gems will be installed separately for each Ruby version if you're using rbenv, and in a similar manner for rvm (someone wanna hop in and explain rvm gemsets here?)
I know this is a little bit outta left field, but any plans on supporting MRuby (mgem)?
Awesome work. I was recently building my first Roda app, and realized that there are too many design decisions to get right. I had the criteria that I didn't want the whole app loaded in every test. Also I needed to change some configurations for test environment, but I didn't want the development configuration to execute. Then I found dry-container and rodakase, and while I didn't use rodakase directly, I made a design very similar to it, and it's just wonderful. Dry-container was obviously created to solve these kind of problems, and I'm really happy that this is something that can be used by every web framework. Thank you!
Do you have any examples of graphic libraries that have a nice API?
I'm going, looking forward to meeting some redditors...
I can confirm this for 2.1.8. I spent most of yesterday and today on this and this is the only way I can compile any version of ruby older than 2.3.0 with openssl support, and 2.3 is iffy at best. For me this only started after doing a full system upgrade (which included the upgrade to kernel 4.4.5-1) and reboot.
Where exactly and when is it ?
[removed]
Hm. For ex., [Processing](https://processing.org/) is pretty exciting (while being completely procedural and sometimes alien, it provides some really good [examples](https://processing.org/examples/) of doing cute things with a few lines).
We have a web framework for InfraRuby, with dsl-driven code generation, but it needs some more work... You could always make your own! Here's a start: class Server &lt; WEBrick::HTTPServer ## WEBrick::HTTPRequest, WEBrick::HTTPResponse -&gt; void def service(req, res) res.status = 200 res.body = "hello, world\n" end end server = Server.new(BindAddress: "localhost", Port: 9000) server.start 
I'm not sure what sort of help you need. Do you not know what xml is?
The talks will be recorded, and should be up on Youtube in a few days.
Yes. They will be. Checkout the 2015 videos here http://www.youtube.com/playlist?list=PLNyYRB_d4fk2KcrHt6m-L5X1rIS5AsmJo
What you said, needs to be said more often I think.
Or [oga](https://github.com/YorickPeterse/oga) for a more easy-to-install and lighter-weight gem that works very very nicely!
thank you for the sources!! 
correct. this is the first time i've run into xml so i was hoping to just find some sources to help me through this project!
Ox is really nice as well, especially if you need to parse huge XML docs. 
I can't go but would love to see your talk slides/video -- I take it they'll be online when the conference opens?
I just had a 'what the heck are they talking about??' moment because we definitely had 404 errors covered at one point, but I guess in the last minute rush to get everything ready to turn in something got deleted :( I'll revise and make sure all my errors are more thoroughly covered. Thanks so much for taking the time to look at the code! All those require statements were getting on my nerves; it's good to know a simpler way of doing that. 
Thanks a ton for the input! We actually have some separate documentation to give an overview of the project, but I didn't upload it. Maybe I'll stick that on the git page. Our instructor for this course is a big proponent of self documenting code, which we tried to create by naming variables/objects/etc. very clearly, but I'm sure it could use some work. Do you mean tests written into the source code? We definitely did a lot of testing, but mostly just through a browser or using cURL.
Ooooh wait I found it. responder.rb (something one of my partners wrote) holds the check for a 404 error. It's not consistent with the other error statuses, but I'm glad it's there. We definitely did miss that 500 though.
Nitpicks on your nitpicks: If you move all of your code into `lib`, including subdirectories like `responses`, you can do `Dir["lib/**/*.rb"]` The sequence open-read-close is unRubyish. Using the block syntax is always preferred, as you can't forget to close - it being handled automatically for you at the end of the block - and it even does the right thing in case of an exception. File.open(...) do |f| f.read... end
no previews of past articles? RSS feeds? nothing?
Oga's progressed really nicely. Its fully compatible with the things I needed Nokogiri for once.
I've been working with that tutorial for weeks but I have not had much success. It's been telling me to get a key from Fabric, but it doesn't let you access a dashboard without checking if your app is android or ios. it's weird it asks that because this is what it says for web
?
In my opinion if you are trying to headhunt DHH for a Rails team lead position, it just makes you ridiculous and means you probably didn't even looked up the person you are contacting. If you would do your job and look him up, you would know he is the inventor of Rails and running his own very profitable company, so he probably wouldn't work for 200k/year(which I assume is the max a Rails team lead woul make in London). It would be wiser to learn more about the developers you are contacting with, to know whether they would be open to a new position, would the compensation suit to their current earnings, are they interested in the technologies used at the company you are headhunting for etc. It is so simple to find these out and I am sure dvelopers would be more welcoming to this approach. 
my thoughts exactly. don't get me wrong-- I'd *love* to learn ruby's secrets, but there's not a chance in hell I'm throwing my email address in that box to find them out
And you would be right! It's worth having in mind however that the purpose of this example was simply to illustrate the value of factory methods as a means of writing self-documenting code. Although, i hope, that serves this purpose it certainly shouldn't imply that this is the best way to model this situation in production. Thanks for noting this! 
I've actually been approached by the OP a couple of times as well. But I wasn't offered ridiculous money... :(
It may not be canonical Ruby. But long real-world experience shows it's not always practical to wrap your code in a file open block. But the point was that it's often good to make sure your files are closed. How you do it is a matter of taste.
I meant to put here yesterday: A good source to follow for formatting style is Github's Ruby Styleguide. https://github.com/styleguide/ruby 
Ask Yusuke Endoh to write code for you. Guarantee he'll be the only one able to maintain it XD
If I were you I would use raw `ruby-build` or `ruby-install`. 
&gt; Package a gem Yes, `infraruby-init foo` creates a skeleton project, with a `foo.gemspec` file. So you'd complete that, and run `gem build foo.gemspec` to build a gem. Please take care to remove `Gemfile.lock` (or `gems.locked`) and other files you don't intend to distribute. &gt; prefix its name with "infraruby-" That prefix is for InfraRuby tools, not InfraRuby projects. Your own InfraRuby projects should have ordinary (unprefixed, unsuffixed) names. For example, our skeleton generator is just `fab` [at rubygems](https://rubygems.org/gems/fab) and our code generator is just `meta-ruby` [at rubygems](https://rubygems.org/gems/meta-ruby). That's because InfraRuby projects are Ruby projects, following the same conventions (a `foo.gemspec` file, a `Gemfile`, a `Rakefile`, and a `lib/foo.rb` file), and should be useful to people using Ruby intepreters who have no interest in InfraRuby. If your gem provides the same interface as an existing gem you could add an `-ir` suffix to indicate this. For example, `siphash-ir` [at rubygems](https://rubygems.org/gems/siphash-ir) and `tzinfo-ir` [at rubygems](https://rubygems.org/gems/tzinfo-ir). But don't do that if the original name is a trademark or the prefix for a major project; just pick a new name in that case. &gt; push to rubygems.org? Yes, you'd run `gem push foo-x.y.z.gem`. And please send an email to gems@infraruby.com so we can link to your gems in InfraRuby release announcements! 
Why not use the Brightbox debs? https://www.brightbox.com/docs/ruby/ubuntu/
You could rsync the rbenv directories. 
I always thought that rbenv simply autocompletes directory names from `~/.rbenv/versions/*`. Did you try putting your installed Ruby there, name the folder `x.y.z` and see if rbenv picks it up? It would make sense that rbenv worked that way, because rubies are uninstalled in rbenv by simply deleting the folder in `~/.rbenv/versions`.
Oh, good point! We'll maintain a list in release announcements, now at [http://infraruby.com/blog/infraruby-4.0-released](http://infraruby.com/blog/infraruby-4.0-released).
Hey thanks for checking it out. The main reason I did it this way was because I felt it was better for them to learn the theory behind how it works rather then just use an already existing module. Sort of like (not identical) using a `rails g scaffold User` instead of creating everything indiviudally and understanding how it all fits together.
If only I could use it in VIM 👿
&gt; don't use rbenv or rvm on servers, not their intended purpose. I am afraid that assertion is incorrect. Running RVM on production servers is explicitly part of the intended purpose. The original author has commented to that effect: http://stackoverflow.com/a/6282260 The official Rbenv wiki has info on setting up on production, written by the main dev: https://github.com/rbenv/rbenv/wiki/Deploying-with-rbenv: https://github.com/rbenv/rbenv/issues/101#issuecomment-11780353 Whether others agree with that is another matter entirely. (Personally i would choose the Brightbox Debs over RVM / Rbenv)
Honestly just start programming in whatever you are passionate in. It's your desire to keep doing it that is going to make you a better developer in whatever language you choose in the future. So pick the one you like most first. Don't worry so much about what is the better professional decision. As far as that goes, by the way, Ruby isn't bad. You will probably end up learning JS along the way as well, if you do web applications, so I would just get at it.
We don't live in a world where 1 language is all you need anymore. Learn one, then learn the other, then learn a handful more. My path was Ruby, VB.NET, JavaScript, RTML, PHP, Java, NodeJS, Elixir, ObjC. As you start learning more, you'll learn new patterns and picking up new ones becomes easier.
The biggest issue with `rbenv` is that there are no binary packages for it. So any ruby version change involves every server in your infrastructure building Ruby from source. That usually means some major app performance fluctuations during a change. Generally the only way I've seen `rbenv` work on a server is doing custom builds of Ruby as a separate step, distributing to every server and symlinking them into `.rbenv/versions`. However at that point the only thing your using `rbenv` for is choosing a ruby version to use, which can be trivially done in easier ways without requiring shell shims all over the place. The biggest problem with `rvm` is that it does very weird shit to the environment it runs in which I would simply never even consider allowing on a production box. 
My favorite place to start was Ruby Monk. It's interactive and goes beyond a primer. Worth a membership, but at least check out the free stuff.
Yea, this kind of sucks on their end. You need to open up a new project with Xcode (or one of the other supported IDEs) and register the app with Fabric, even if you only plan on using it for web. Kind of a flaw in the web install/setup flow on their end if you ask me.
&gt; Basically I would like to ask is what would set me up better for the future Absolutely does not matter at all. I mean, it does matter to some extent. Slightly different areas of use, different paradigms and styles, but honestly, beyond that, what matters is that you get into programming in some capacity, learn to understand it. By then it hardly matters what language you've chosen. You're likely going to struggle, then spend some time writing shitty programs with shitty architecture and design, and then make better and better programs. I'd say that JS is a good way to go if you're looking to get into frontend development. It may be that JS also has a better capacity for functional-style programming. Ruby is a language primarily for backend programming, so I'd let that make my decision. Frontend or backend. 
I'm in a similar position though a little bit further along. I set out to learn Ruby/Rails in October though I've worked much harder on it since the start of the year. Chris Pine's book is excellent, I recommend reading through it and working the exercises twice before moving on. From there I went to the Pragmatic Studios Rails I course and I had sufficient Ruby skills to work through the entire course. I definitely recommend the course, it's $150 but certainly worth every penny. At this point, I'm trying to decide if I want to go through the course again or jump right into their Rails II course (it's only $60 for alumni of the first course). Alternatively, I may go through Hartl's tutorial, I haven't really decided yet. I'm also working on my own app on the side to reinforce the topics. I'm five months into the process and since January I've worked 1-2 hours per day on this stuff. I still get stuck, I still have to look back at the course material but I feel like I'm making progress. You just have to know you will hit walls, you will want to throw your computer out a window when you can't fix an error but I'm hopeful that by the end of the year I will be a semi-competent Rails developer.
He's placed a few people that I know of around London. One of the few recruiters who actually knows what he's talking about. 
I'd like to help with some of the challenges. I'm taking computer programming in college now. I'm not great at it but I'd like to submit a solution. It's 4:30 am and I can't think about programming right now so I'll look into it more later. Sounds like a fun project.
Thanks for extending this example! It motivates very nicely from your last article.
Awesome, thank you!
Ok that really helps thank you so much!!
I'm a big fan of the learn by doing approach, and being able to see the result of your programming right away. If this sounds like your learning style, I'd suggest going through the Codecademy tutorial on Ruby first, then getting into Rails with a good tutorial video series or book. The Michael Hartl ones are great, and I'd also recommend Manning's Rails in Action 4.
Im a fan of [RubyMonk](https://rubymonk.com/)
If you want more and want to invest try doing the koans here: http://rubykoans.com
you may want to look at the [sample app](https://github.com/twitterdev/cannonball-web) that is linked to in the docs, specifically these two files: **Digits Web Javascript** https://github.com/twitterdev/cannonball-web/blob/master/public/javascripts/cannonball.js **Digits Web Server** https://github.com/twitterdev/cannonball-web/blob/master/routes/index.js
just curious, why people never at least try to look into official documentation before asking question like this?
Please let me know if you have any questions about the Ruby Hero Awards or anything related to them. I'm the organizer and the host this year and I'd really appreciate help from everyone in the community to get the word out and get people voting.
The two space indent bothers me. I prefer four. Seeing as how two is the standard I'm going to switch though. No sense trying to go against the flow. Not sure why I prefer four anyway. Is there a way to load the style guide into RubyMine? Or does this reflect the default RubyMine ships with?
I am a fan of books (printed on paper). Remember those ;-) For some good ones about Ruby, see the [Planet Ruby Bookshelf](http://planetruby.github.io/books). Maybe the Ruby Pocket Reference or the classic Programming Ruby work for you. 
Last year I found Learn Ruby the Hard way to be the best for fast learning simple concepts and habits. Then from there build on it with the more in depth books (I have several now, each with strengths and weaknesses) that explain the actual inner workings and more difficult things. It's free online, and easy to search for what you need. I also use Ruby 90% for scripts :)
The most common way to do this is to use something like [dotenv](https://github.com/bkeepers/dotenv) which allows defining `ENV` variables in files. Another gem is figaro but dotenv is generally more flexible and less Rails focused. A common practice would be to include a development configuration in the repo and in production disable dotenv and provide the secrets in a different way, e.g. `foreman` can read a file in the same format that `dotenv` uses to setup the environment for processes it launches, or set them in `heroku config` or set them as encrypted environment variables in travis, or do use dotenv in production but store the production secrets file some place safe, like a secured S3 bucket and load it onto the boxes as part of your deploy process, etc. 
I'll tell you why. The official docs normally beat around the bush a lot. I just want to learn the basic syntax, nothing more. That's why I didn't try the docs even though that crossed my mind.
I didn't see any Ruby in this post... did I miss something?
Couple notes: * Forcing external dependencies on your gem's users isn't a great practice unless the dependency is really needed. i.e. there is no need for `HttParty` here. * This implementation downloads the entire file into memory then writes it to disk. This is not only a bad idea for performance but is also a DoS vector. * The reasoning for adding this isn't terribly sound. There is nothing 'secure' about the content validation in `Paperclip`. It's trivially spoofed so I would just bypass it. 
Doesn't seem you'd need a gem for this? Just a list of adjectives and a list of nouns. ADJECTIVES = %w(glistening panting soulful droning shiny) NOUNS = %w(moonbeam unicorn robot guitar knight) format("%s-%s-%s", ADJECTIVES.sample, NOUNS.sample, rand(1000))
See https://github.com/dariusk/corpora for a large corpus of words (CC0/public domain).
could be faker. you could chain some together to do this pretty easily. https://github.com/stympy/faker
What's the performance on type casting like that in a dynamically typed world?
thanks. we indeed use chef to build ruby from source via rbenv the first time a new ruby version is used for something, where different roles have different ruby versions that get installed (usually jruby, 2.something, or 1.9.3-something). but these changes occur relatively seldom, so the biggest annoyance I've seen is with running tests/using kitchen locally (it adds a good 5 minutes to my `kitchen converge` if it has to install ruby 2.2.2 from source). autoscaling as well, I guess it adds 5 minutes or so to the initial chef bootstrap when a new node is brought online (which could be mitigated by having some ruby versions already baked into the image, but that becomes a pita if you ever want to upgrade, etc).
"moonbeam unicorn robot guitar knight" sounds like it would be an awesome movie
+1 rubymonk
https://github.com/norman/friendly_id this is pretty useful as well
thank you for feedback * point taken on the enforcement of 'httparty', I've released v 0.2.0 that has net/http by default but allow to use any "puller" by specifying in config * do you have any tip on how can I avoid this DoS vector problem. I would like to implement it. * on the Paperclip issue bypass: I've released couple of gems that I'm proud of and I try my best to do best practices and no-one uses because they are too high level to implement, and one day I've released this gem https://github.com/equivalent/copy_carrierwave_file which was just stupid quick extension that allow copping file between two models and for some reason that is the most popular gem that I wrote :) Yes I agree there are better ways how to do this it's just sometimes it's not worth it. Unfortunately 70% of people using Rails and gems like Paperclip have no idea how internals works and they are looking for copy-paste solution because they are building websites that will never have 2milion user traffic. Of course that encourage people not to think but lot of people will rather switch to something else (like php ? ) rather than learn. So please don't think about this gem as me trying to fix something but rather one way how to do that and ease the pain for the rest + can be used for some other stuff unrelated to paperclip (maybe CSV report parsing that doesn't have to be saved to disk)
So this gem is useful but doesnt scale
this
&gt; do you have any tip on how can I avoid this DoS vector problem. I would like to implement it. Probably the most efficient is `IO.copy_stream` or similar methods from `IO`: http://ruby-doc.org/core-2.3.0/IO.html. Another option is Net::HTTP streaming responses: http://ruby-doc.org/stdlib-2.3.0/libdoc/net/http/rdoc/Net/HTTP.html#class-Net::HTTP-label-Streaming+Response+Bodies Regardless of which approach you use, you probably want to set an upper bound on the size of the file also or someone could just point you at a 15TB file :)
^Epic Nice Job!
I did not tough about that feature, but I have an Idea in how to solve this problem, instead of doing a full scan, just make a query where you look only for the integers that include the key in question
What Sublime do that Atom does not do? Charge $70 per version.
Random comment, but instead of doing: 2.times.map { FactoryGirl.create(:item, price: 100) } You can instead write: FactoryGirl.create_list(:item, 2, price: 100) There are a whole [family of methods](http://www.rubydoc.info/github/thoughtbot/factory_girl/FactoryGirl/Syntax/Methods) like this - such as `build_list`, `build_stubbed_list` and `attributes_for_list`. Personally, I don't like the idea of monkey patching RSpec like this - if nothing else, because on a big project this would quickly get very confusing for other developers. Although I do see the potential benefit in clarity with this one particular patch. Here's how I would have written the whole thing: describe Invoice do subject { described_class.new(user: user, items: items) } let(:user) { FactoryGirl.create(:user, state: state) } let(:items) { FactoryGirl.create_list(:item, 2, price: item_price) } let(:item_price) { 100 } describe '#sales_tax' do before { invoice.finalize! } context 'in CA' do let(:state) { 'CA' } it 'charges sales tax' do expect(subject.sales_tax) .to eq(items.count * item_price * 0.0875) end end context 'in OR' do let(:state) { 'OR' } it 'does not charge sales tax' do expect(subject.sales_tax).to eq(0) end end end end
Honestly, it always seemed kinda cool to me. I felt that it was this difficult skill that only certain people knew, and I wanted to be in on the knowledge :) plus it turned out to be real fun, especially after the first time you tell a computer to do something and it does it.
Are both those statements in the same recipe? (same file?). If so just drop the `$` from the front. If not you'll need to add some more info, what file is it defined in and what file is it used in?
Years ago I discovered HTML, and it was revolutionary to my small mind. *the internet has structure, every website can be reproduced!* Then I started looking at other people's websites' HTML source, and I hated it. *this is abuse! HTML was never meant to be used this way!* Somewhere along the way I discovered that nobody writes HTML by hand, they get machines to do it for them. *programming languages? A language to write a language??* And it was revolutionary to my small mind, again. *the internet has structure again, every website can be reproduced!* Then I started looking at other people's PHP source, and I hated it. *this is abuse! PHP was never meant to be used this way!* But actually it was. *sadpanda*
I have been thinking about both Ruby and Python, however I picked Ruby, because I also wanna get into web programming when I get good enough. Would Python still be the better choice then?
Are you working with spreadsheets from someone else? If so, and if they will not cooperate in exporting the data as a delimited file, then you have some more work ahead of you. But first things first; you will need to become comfortable reading a file, parsing the contents, and processing the results. There are a lot of tutorials on that. A good project might be to sum up a list of numbers one per line, then move on to an average. From there you can start to expand to reading more complex files, possibly Excel using a suitable gem. After that point, you can deal with all the eye candy, and what type of interface to develop. 
I think ruby has a better web community. 
Drop it out of the calls or the definition? And I will look into the first thing you said, this is old code I am having to go through and update to get my hands dirty with chef / ruby.
I was 13, asked some friends about coding and someone showed me some basic basic bullshit in batch. I went home, learned Python. A few years later, my buddy's dad showed me Ruby (and Rails), and now I prefer Ruby but Python has its perks. That was almost 7 years ago, all together.
One approach: instead of making your own UI, use Excel as the UI. Ruby will just be driving it in the background: http://davidsulc.com/blog/2011/03/27/using-ruby-and-win32ole-to-manipulate-excel/
You are right with the JavaScript takeover were kind-of all even outside of there. 
Whoa, looks like some crazy code, could you break down whats going on for the ruby rookies (rubookies?) in the house?
"rukies"?
The `@` directive for [`String#unpack`](http://ruby-doc.org/core-2.3.0/String.html#method-i-unpack) causes the "cursor" to move to the specified position, and the `a` directive essentially reads the character there. [This demonstration](https://eval.in/540835) should help clarify.
Obviously, the code is intentionally difficult to follow. A lot of things are inconsistent or unnecessary just to make the code extra ugly. The bulk of the code is concatenating two different strings. They are being passed to a different variable each time. String addition, `concat` and `prepend` and are all similar except that `prepend` adds to the beginning of the string. For variables "we are", it's building a string that contains all the characters in the message. I added some random numbers that aren't used. For variables "not robot", it's building a string to be used as a "key" for [unpack](http://ruby-doc.org/core-2.3.0/String.html#method-i-unpack). Using `@[number]a` spits out a character at a specific index in the string. The result is a string array. ('01234').unpack('@0a') =&gt; ["0"] ('01234').unpack('@2a@1a') =&gt; ["2", "1"] I was able to build the "key" string by using `rindex` for each index of the intended message string. The fun part is at the end. I'll break it down e.unpack( # uses "key" to reconstruct message t.tr(' ','') # removes all whitespace from "key" string ) # (it replaces all spaces with an empty string) .reverse # reverses string (or array). # I pre-reversed the string. Because why not? .inject(:+) # Same as String#join .split(',') # Splits string at each comma into string array .each_with_index.map{|am,human| # "human" is the index print am; # "am" is the contents of array at index print','if human!=3; # I added a carriage return in case of word wrapping. puts if human==1 # The two if statements and string split were a hack # to add a carriage return without having to modify the "key" # "puts" starts a new line after string, "print" does not. } 
A couple years ago. Got some copies of various gamedev for beginner products for super cheap, found the provided tools and code wholly inadequate. Learned some stuff, bought some books, studied, experimented. Started solving common problems by writing command line applications for myself. Finally getting to the point where I can bring my own systems online from bare programming language facilities. I'll never admit my mother was right and that I should have gotten into programming as a kid.
Firstly, don't think about GUI yet, that is complicated. Instead: run your scripts via the command line. You can always add a GUI on top later. So, to get started: 1. find a library that can import the file. 2. access that library in a script 3. load up a sample file in your script. 4. write some value from the file to the console (yay) 5. write some functions in your script representing your calculations and graphs 6. invoke those functions with the correct data from the spread sheet 7. output your calculation results to console 8. use some chart / plot library to export your graphs as image files I like helping newbies, feel free to ask for more help as a response to this answer or pm good luck!
That was also the approach I thought of myself - I am just all new to programming. Even defining functions or variables or whatever they are called. It's a jungle of terms. But the program would be fairly easy to write as the excel sheets are just data-outputs from machines. They always look the same.
Probably, but parsing native Excel is always more difficult than parsing delimited files, and is really only approachable with the right gem (library). You might find that out of bounds results are flagged with colors, which is *very* annoying.
This article is rather out of date with the feature, several points here have changed in later commits and are no longer valid. 
Cool, thanks a ton. 
np, if you're looking at other chef related refactoring you may want to run [foodcritic](http://www.foodcritic.io) in addition to rubocop, it checks for a number of Chef specific code/style issues where as rubocop is a tool for general Ruby. Some of Chef's idioms conflict with Rubocop's guidelines...really some of Chef's idioms conflict with Ruby's idioms in general. 
Hi, Can you please point out the changes that no longer exists or have changed? I see no changes except the 10 attempts for generating token.
The final version has: expected(:sales_tax) { 200 * 0.0875 } That is actually the _first_ thing I would have changed to make the test more robust and explanatory. What is this `200`, where does it come from? Maybe something like: describe Invoice do # ... let(:order_total) { items.sum(&amp;:price) } # ... context 'in CA' do let(:tax_rate) { 0.0875 } let(:state) { 'CA' } expected(:sales_tax) { order_total * tax_rate } it_behaves_like 'calculates sales tax' end For me, looking at the first version, this would actually be one of the first things I'd fix to make the test clearer, more explanatory, and more robust. 
Thinking of an alternative through enumerable (prob not as clean but no regex) input.to_s.reverse.each_char.each_slice (3).map {|a| a.reduce (:+).reverse}.reverse Not sure if can be simplified in terms of reversing
I get what you mean, but to make my point you can consider an auth engine which has `AuthEngine::User`. It seems necessary to break the encapsulation if any of the other routes require access control. 
currently I'm hammered with work so for now I've created an issue https://github.com/equivalent/pull_tempfile/issues/1 I'll implement streaming in v 0.3 as soon as I have more time. Thank you again for the helpful tips and feedback 
Isn't that more readable? :) def splitting(num) num.reverse.chars.each_slice(3).map{ |x| x.join.reverse }.reverse end 
What is it with programmers and fixation on self? Every programming blog is always about some small piece of code I need, surrounded by "my journey, thoughts on life, and adventures in code" or some such bullshit. So many special butterflys. Coding just isn't that hard, and being into coding does not at all translate into being interesting. Write code, live life, repeat. 
&gt; substantially slower I just benchmarked it out of interest, and this is actually not true. Using the two methods above, and the same input as above: splitting_with_reverse 212.029k (± 1.2%) i/s - 1.075M splitting_with_lookahead 241.498k (± 2.3%) i/s - 1.218M Comparison: splitting_with_lookahead: 241498.0 i/s splitting_with_reverse: 212028.6 i/s - 1.14x slower If you use a much longer input -- in this test, I used `832962398702356432057321042360160984237605640289765103` -- then the `reverse` approach is slightly faster instead: splitting_with_reverse 74.477k (± 1.1%) i/s - 376.768k splitting_with_lookahead 57.695k (± 2.8%) i/s - 290.142k Comparison: splitting_with_reverse: 74477.5 i/s splitting_with_lookahead: 57694.6 i/s - 1.29x slower ------------------------------------- Basically, long story short, performance is pretty much irrelevant here.
This was raised as a known bug a while ago: https://bugs.ruby-lang.org/issues/11976 The issue has already been fixed in the master branch, and will be deployed in ruby version 2.3.1: https://github.com/ruby/ruby/commit/c79402c4f0e40a3ebebda9761e47ff1b3d12ed53 It's also been posted to /r/ruby before: https://www.reddit.com/r/ruby/comments/476v0v/strange_behaviour_in_230/
This issue is fixed with this commit https://github.com/ruby/ruby/commit/c79402c4f0e40a3ebebda9761e47ff1b3d12ed53
Exactly what I put in my post. The puts will return nil, but that's not the interesting part; what's super crazy is that the puts will _never execute_ in the above code. Even in older MRI where nil[]= returned a NoMethodError the right-hand side would still be evaluated -- with this bug, not only do you not get an exception even that right-hand evaluation is skipped!
Depends on the input size, for large numbers this is probably slower, for small numbers it's probably 1-2x faster. 
 def splitting num num = num.to_s num.rjust(num.length + -num.length % 3, '0') .scan(/.{3}/) .map &amp;:to_i end
[**@qrush**](https://twitter.com/qrush): &gt;[2016-03-24 12:40:29 UTC](https://twitter.com/qrush/status/712982417754161152) &gt;For the curious, we are working through the same scenario NPM has been dealing with for [*rubygems.org*](https://rubygems.org/): [*github.com*](https://github.com/rubygems/rubygems.org/issues/1226) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/4brjko%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
&gt; This isn't possible thanks to the way RubyGems.org is designed. Gem versions are immutable even after all versions are yanked.
My desire to point and laugh at all the JSHipsters has indeed been tempered by the realisation that Ruby is not in a much better place. (Though at least Ruby is a real goddamned programming language.)
He was referring to my original scenario, where the *same* version of a gem was published twice. This is *not* what happened with npm, except for `left-pad`, which they "un-unpublished". Package versions are immutable on npm too (except for crazy scenarios like left-pad). The exact same scenario as what has happened at npm - a third party takes control of a package namespace and immediately pushes new versions of that package - is *absolutely* possible today. To be absolutely clear, the following scenario is possible with Rubygems.org today: * Major gem author ragequits and yanks all versions of a gem from Rubygems.org. Rubygems.org frees that gem namespace. * Third party claims gem namespace by pushing a new gem version greater than the previous most current version. Let's say it's a bad person, and the new gem just runs `system("rm -rf /")` * Anyone who runs `bundle update` is now going to have a very, very bad time.
Yes, but it is currently possible to take over the gem name and release a version number that has not been released.
Anyone using gems for business purposes should consider a proxy like geminabox. Not only will you save a bit of time in bundling if your proxy is hosted within your local network, but you also save some bandwidth as well as reducing load on rubygems.org. In the event that a gem is yanked, you are not out of a solution immediately and gives you time to come up with an alternative solution. While I appreciate everything that rubygems is doing, I have found that I rely on them too much without putting all of my eggs in their basket.
pfft nah we'll be fine we have rjust built in
That implementation looks super complex :), how about: `String.class_eval { alias_method :leftpad, :rjust }` 
While it definitely seems silly I think the root cause of this isn't 'lazy' programmers as many have claimed but rather the fact that Javascript's standard library can only be described as pathetic. It would be an interesting exercise to figure out how many npm modules would be required to cover the functionality in Ruby's stdlib, lodash covers a chunk of it but there are a ton of things missing still. 
Yes, but in that case it won't pass original tests ;)
I started in 5th grade with a "learn to program Basic" CD I got from a swapmeet. It was a custom implementation of BASIC with some extra commands and game making stuff. Taught me basic programming but BASIC is an awful programming language so it gave me a lot of bad habits and experience. I later went on to learn REXX, ActionScript, C#, and then finally settled on Ruby.
This could be too expensive ;)
It's actually a reverse dependency search, not of 'your projects' exactly, right? This is great. 
I've voiced my concerns on this many times before -- I'm a big fan of removing gem yanking for a whole variety of reasons. In the current context, I think it's worthwhile thinking larger than someone ragequitting. Anyone that can push a gem can yank it. We're one Rails dev getting compromised from having a really bad day. Maybe this really calls for better security around gem pushing &amp; yanking. On any given day you can find people that have pushed files with their rubygems_api_key to GitHub.
Seconded. We use a geminabox proxy and it's saved our butt a few times when Rubygems is down.
Glad I could be helpful. I liked the simple example that you used to demonstrate the pattern. 
If you can't write a test then change your design so you can. This is one of the key parts of TDD. 
If you've written code that you don't already have a test for, then what your doing isn't TDD. Which is completely fine, not a TDD fan myself, but one of the core tenants is that you write the tests first, then write the code to make the tests pass. In terms of how to test functionality like this, just do something like (in pseudo code obviously) 10.times { expect(call_your_thing).to &lt;allow the attempt&gt; } expect(call_your_thing).to &lt;print the losing message / end the game&gt;
you're*
&gt; I'm a big fan of removing gem yanking One one hand I'm all for it. On the other hand, I volunteer you to be the one to deal with a corporate lawyer culture when some gem is considered to be infringing on someone's property. Technical problems aside, `left-pad` is an ownership and authorship problem in an incident, where rights of an author were ignored to cater to a faceless crowd, a "path of the least resistance" npm Inc and a lawyer fuckery. Problem is, no matter the technical ingenuity, the latter two phenomena aren't going away. They will always be in favor of saying "fuck off and let us do the thing": one being an instigator, other bound by shitty laws. The real world, where the right thing is illegal and fucking people over is not an issue.
Test the logic of 'should i output a losing message if tries is greater than x' and push that code to somewhere testable - worrying unit level tests on the main application/'game loop' is likely to get tricky - integration/functional tests become better for this - think capybara.
The infringement case is certainly an interesting one and likely would need to be resolved somehow. The "I don't want anyone to use my stuff anymore" case ought to be solved by agreeing to an initial ToU that says if you publish something, it's there for good. To date, I've yet to see a gem yanked for many of the reasons people use to support yanking them. The only one I've seen is someone pushed a gem with their AWS credentials -- but those have to be assumed compromised and changed at that point anyway. I've talked to Nick a lot about this over the years. I certainly empathize with the RubyGems volunteers and the support effort they have to endure. But when you surface a feature like "gem yank" to the top, it'll wind up getting misused. Isolated groups experience a left-pad like issue with regularity. In the left-pad case, it was just on a much larger scale.
Try to generate random guests that are not true n.times, then assert your messages. More simple, i think :))
&gt; Are there any step by step guides on how to install and configure RubyMine in such a way that I can debug a simple .rb file with a main? Just install Rubymine, assuming you have a working Ruby install, that's it. Also Ruby has no 'main' construct. &gt; I've consumed about 4 hours today just trying to get this to work, whether it's been running commands via cmd in the DevKit to completely reinstalling RubyMine. What is 'DevKit'? Sounds suspiciously like an iOS framework rather than something Ruby related. &gt; Is there a step by step guide anywhere that would get me up and running from beginning to end? If not, why doesn't RubyMine come with the dependencies for their debugger? RubyMine works fine without anything else needed, although I honestly don't know anyone that uses it's debugger, I've heard it's decent but never had cause to try it. Look into `pry`. 
Maybe I am missing something here, but why can you not just use a loop in your test ? But I would consider the following: What condition are you testing for as it might be suggesting to you what you should be changing your code to do. This is something TDD is supposed to bring to to the table, the concept of identifying code smells, logic problems and small refactoring also, though a lot of people just use it to test their general assumptions of whether their code works or not. *It should return a message after ****10*** *incorrect tries* maybe 10 should be a parameter. So your method signature is something like: def compare(input, retries=10) Then your test can be something like: expect(compare("incorrect_string", 0)).to eq ... failure message .... expect(compare("correct_string", 0)).to eq ... failure message .... expect(compare("correct_string", 1)).to eq ... ok message .... With the above idea, you can test for multiple cases. 
On npm there was a package that got changed and a very significant portion of js dependenies broke around the web. The offending package itself was very trivial, but another more significant package had relied on it as a dependency and this caused the breaking of the thousands of sites. The is a ruby implementation of the offending trivial package, left-pad. It's so trivial it's about 5 lines long in ruby (because ruby already has a method for this, but JS does not) and I believe it was like 11 lines long in JS. Lesson is, there are significant issues with current web dev engineering practices that has allowed major failures from the smallest and most basic of problems.
Why use ruby mine?
I use ruby mine all day and have installed quite a few times. I use it on an ubuntu setup; I extract the compressed download to a file in my home directory and run the install script in its bin directory. When I start the debugger it automatically downloads and installs the dependent gem. Problem might be in * your ruby environment ( I use rvn personally) * or your java environment needs reinstalling. I have seen a bad java environment mess up the debugger editor before. * sometimes the debugger can demand a lot of memory. Particularly if you are debugging xml file operations, or html scrapers. This can crash stuff. * or a gem elsewhere is broke and causing mischief. Gems can break in certain operating systems. Also, remember just because its java does not mean the rubymine will run correctly everywhere. Same for those ruby gems, they can be fickle. So if nothing else pans out try an vm ubuntu flavored OS to test things in.
Oh man. Thanks for the write-up! I've certainly had to write exactly that in javascript before (after always trying to lookup the function I expect to be there on String).
rjust != left_pad, [you need to install this gem right away](https://github.com/atipugin/left_pad)
Suggest something else, I'm new, I said I'm trying to learn Ruby
Thanks!
The Gemfile should be in the root of your application. It will define all the gems, aka libraries, uou will use in the project.
I suppose I could do that, I just have all my other projects and everything on that Windows VM. I'll resort to this if I can't find a solution before too long. 
Yeah the error message seems like it tries to download the gem, but it cannot locate the devkit in order to compile the gem. Could this be happening because I have other C compilers on my system? I'll post a detailed error message when I get back on my system here in 10-20 minutes. Side note, I've done all the steps on DevKits github page, and installed ruby and rubymine per the documentation from JetBrains. 
The debugger in RubyMine is significantly better than pry, for example you can add breakpoints wherever and whenever you want, not just between program runs
Theres nothing wrong with Rubymine, I use it myself but only as a text editor, I don't use it for anything else (vcs, debugging, etc). A lot of Ruby devs prefer to do most of their work in a terminal, `pry` and `pry-byebug` are the most common tools for debugging: https://github.com/deivid-rodriguez/pry-byebug
&gt; Also you can click around to different points in the stack which I don't know if that's possible in byebug Yes you can move up and down the stack frame. You can actually tell Rubymine to use `byebug` under the hood if you want.
Error running MatrixProject: Failed to Install Gems. Following gems were not installed: C:\Program Files (x86)\JetBrains\RubyMine 8.0.3\rb\gems\debase-0.2.2.beta6.gem: Error installing debase-0.2.2.beta6.gem: ERROR: Failed to build gem native extension. current directory: C:/Ruby21/lib/ruby/gems/2.1.0/gems/debase-0.2.2.beta6/ext C:/Ruby21/bin/ruby.exe -r ./siteconf20160325-2280-1ob9il8.rb extconf.rb checking for vm_core.h... *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers. Check the mkmf.log file for more details. You may need configuration options. Provided configuration options: --with-opt-dir --without-opt-dir --with-opt-include --without-opt-include=${opt-dir}/include --with-opt-lib --without-opt-lib=${opt-dir}/lib --with-make-prog --without-make-prog --srcdir=. --curdir --ruby=C:/Ruby21/bin/ruby --with-ruby-dir --without-ruby-dir --with-ruby-include Temporarily enhancing PATH to include DevKit... Building native extensions. This could take a while... --without-ruby-include=${ruby-dir}/include --with-ruby-lib --without-ruby-lib=${ruby-dir}/lib C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:456:in `try_do': The compiler failed to generate an executable file. (RuntimeError) You have to install development tools first. from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:587:in `try_cpp' from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:1061:in `block in have_header' from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:912:in `block in checking_for' from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:351:in `block (2 levels) in postpone' from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:321:in `open' from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:351:in `block in postpone' from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:321:in `open' from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:347:in `postpone' from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:911:in `checking_for' from C:/Ruby21/lib/ruby/2.1.0/mkmf.rb:1060:in `have_header' from extconf.rb:31:in `block in ' from C:/Ruby21/lib/ruby/gems/2.1.0/gems/debase-ruby_core_source-0.8.4/lib/debase/ruby_core_source.rb:12:in `call' from C:/Ruby21/lib/ruby/gems/2.1.0/gems/debase-ruby_core_source-0.8.4/lib/debase/ruby_core_source.rb:12:in `create_makefile_with_core' from extconf.rb:47:in ` ' To see why this extension failed to compile, please check the mkmf.log which can be found here: C:/Ruby21/lib/ruby/gems/2.1.0/extensions/x86-mingw32/2.1.0/debase-0.2.2.beta6/mkmf.log extconf failed, exit code 1 Gem files will remain installed in C:/Ruby21/lib/ruby/gems/2.1.0/gems/debase-0.2.2.beta6 for inspection. Results logged to C:/Ruby21/lib/ruby/gems/2.1.0/extensions/x86-mingw32/2.1.0/debase-0.2.2.beta6/gem_make.out Native compilation failed. Please make sure that you have Ruby DevKit installed
maybe create an instance variable that keeps track of the current turn?
Good point, I just find it superfluous to test key parts of the language that have already been tested before like built in functions. I would test if I was using them right but I find it a little odd not to trust the language itself. I am inexperienced so plenty of you probably have things you have run into to make you more conservative.
As a Ruby newbie, I find this to be a problem with how dynamic the language is in general. Every time you need to know where some method call is going, you need to put aside what you're doing and figure out how to get a breakpoint in there. That really breaks my flow. Any tips for navigating codebases?
You need to get the DevKit here and install it http://rubyinstaller.org/add-ons/devkit/
Debugging works fine on windows, install this DevKit -&gt; http://rubyinstaller.org/add-ons/devkit/ 
I agree with you there. I think it's unnecessary to test the value of tries. However, what should be tested is that when tries = 10, the game properly displays the losing message.
&gt; The point is that you need to install pry and byebug. Not sure why this matters? Rubymine also requires debugger gems be installed, it installs them the first time you launch it for any given Ruby version. &gt; The RubyMine debugger is very clean, lets you view memory easily, and provides a graphical interface pry does not. It's very useful for a lot of reasons. And I disagree, not sure what the big deal is. 
&gt; Modules with super in them are make up for the most difficult to understand Ruby code. Well, you started out with one of the most difficult to understand English sentences I've seen in a while! "are make up for the most" is confusing and not grammatical. 
The best approach is to not override the method name. Use some other name then you can call the specific method you want directly. The other common pattern used if you can't (or don't want to) change one of the names for some reason is to alias the overridden method to a different name, then call it directly. The last resort if you can't pull off either of the above could be something like `OtherModule.instance_method(:the_method).bind(self).call` 
This worked! The love I feel for you and your assistance in this matter cannot be expressed via text. Thank you very much. 
I got a method added to Ruby that lets you see where that `super` call is going a few years ago https://bugs.ruby-lang.org/issues/9781. Also see http://www.schneems.com/2016/01/25/ruby-debugging-magic-cheat-sheet.html
glad it worked.
I wouldn't use a loop. Suppose the user guesses on their second try, you'll call break to get out of the loop and then you'll print the losing_message anyway. Or maybe this is in a function and you'll call return instead. This feels like you have the loop in the wrong place. But that's beside the point. If I was going to TDD this I'd start with something like this Describe make a guess When the guess is correct Show winning message Expect winner to be true Expect game_over to be true When the guess is incorrect Show a clue Expect clue to be "foo" Describe take a turn When the turn count is less than maximum Ask for next guess Expect game_over to be false When the turn count is greater than the maximum Show the losing message Expect winner to be false Expect game_over to be true (edit: formatting) 
You need to create an AWS account and a S3 bucket, and change the permissions on the bucket. You might have to search Google for a "policy" to paste into your S3 bucket's permissions config - it's a common snippet, shouldn't be hard to find. Do all the AWS config from their web interface, it's just easier. Then you install the AWS S3 gem [here](https://github.com/marcel/aws-s3) It's pretty simple from that point to upload a file. 
On line 56 you call `Account.withdraw`, which is a class method, but there is no class method by that name. Class methods are defined `def self.withdraw`. Your `withdraw` method is just a standard method. You are also missing an `end` in your `deposit` method.
Looks like a syntax error. Have a gander at this modification: [gist](https://gist.github.com/BinaryPaean/a1a02d7360a7375310ba)
Real missed opportunity not to title this blog post "Future Jobs Considered Harmful".
That did it for me, I guess I'll have to get used to the ruby syntax a bit better before I could feel comfortable with it. Thank you very much though!!! I really like how elegant those if-statements look in your code ^^
On a more serious note, though, I totally got bit in the ass by this same type of issue, except it was a nightly cron job. I wouldn't say never to do scheduled job execution, but you definitely need to think carefully about the problem you're solving and what parts of the solution you need to schedule explicitly versus execute immediately versus persist for a polling worker to handle at the appropriate time.
No problem, I included a few (but certainly not all) useful ruby idioms ideas for you to absorb. * postfix conditional statements * implicit return (the last line of a function will be automatically returned) * [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns) - Example:, let deposit just deposit and let the loop print to the user.
Which I can only be thankful for! I edited the code to be a bit tidier - edited some of my if-statements (although I'm really used to C and C++ and I can't break out of that habit), I did some reading on SoC and tried to implement it in my code as well. Thank you again, you're amazing
Cool. I've used pry before but never dug deep into it. I'll give it another shot.
I would like to, but when you explore Rails, looking for how to add functionality, that's kind of tough... I'll keep your point about ctags in mind though.
I was able compile ruby 2.3 the duplicate _ALL_SOURCE error was clear, but I didn't get the error output from eventmachine, will try to compile with the LD flags from eventmachine#693. Thanks a lot, btw I was trying to install Sensu on AIX lol.
Last time I looked, the underlying XML generated by Excel was horrendously complex.
I'd go for Octopress. It's fairly simple, and it's free to host using GitHub Pages.
`==` unassembled hashtag
Ikea hashtag
Try telling your boss to go to tenderlovemaking.com and read their blog post while you're on a conference call. It gets weird quickly.
I just call it a block and/or curly braces. I'm boring.
Apparently the symbol to proc operator is also called the [pretzel colon](http://stackoverflow.com/questions/1217088/what-does-mapname-mean-in-ruby#comment4137004_1217088)
[] is the bracket operator, but it's spoken as “sub”. As in `@foo[3]` would be pronounced “at foo sub three”.
`~&gt;` is sometimes called a "spermy operator"
Thanks! I added.
Added, thank you.
Added, thank you!
I notice this one but did not add it. Thanks!
You may not be able to use certain features with GitHub pages but Octopress is awesome. It's Jekyll with extra goodies. 
I have frequently called the `!` a *damnit*.
Added, thanks!
Thank you! &lt;3 
@juanitofatas You made my morning here. Lol 
This is great. I'd add that I often pronounce `?` as "huh?", especially when it's at the end of a method. like, you'd pronounce `.nil?` "nil-huh" and `.present?` "present-huh". Upward inflection when saying it optional!
I know! I mean... how hard could it be? {} - braces () - parentheses/parens [] - brackets What's so hard here?
For Americans maybe. "Parentheses" isn't very commonly used in commonwealth countries, that's what "brackets" defaults to for us (when not further qualified). To be honest though I didn't realise "braces" referred to squiggly brackets specifically, thought it was just a synonym for brackets (all types), so I learned something - kinda makes the "curly" in "curly brace" redundant however. Also you missed &lt;&gt; Edit: I guess that isn't applicable to Ruby, my bad.
Moustaches for me. Open moustache, close moustache.
Or curly brackets, round brackets, square brackets, angle brackets https://en.wikipedia.org/wiki/Bracket
"Bacon Cannon" is brilliant 
Or braces, parens, brackets, and langle and rangle. :)
We've had this argument before on reddit, so no need to repeat it. It's as obvious to me that mixins are inheritance as it is to you that they are not. Sandi Metz appears to agree with me that module mix-ins are multiple inheritance, [in this video](https://www.youtube.com/watch?v=pUzL16pfdKY), she starts discussing modules around 41:30. &gt; [42:55] ...because of how modules work, they are inheritance. They are just like inheritance. They are absolutely like inheritance. The method lookups work like inheritance....There's a set of techniques that apply to inheritance... that also apply to any class that includes a module... It is a reason to understand inheritance, because all the same rules apply. &gt; [44:55] ...Being able to get multiple inheritance is awesome... &gt; [47:10] I like modules, and I think we should use modules, I think we should use them correctly, we should respect the fact that they are inheritance... Anyway, the issue in the OP with it being confusing to figure out which class 'super' comes from is exactly because of multiple inheritance, the ancestor tree is not a straight line (as it would be without multiple inheritance) but a true tree. Without multiple inheritance, `super` in any class always points to _one_ class (or that classes one parent, etc), with multiple inheritance it is more complex. But we aren't going to convince each other on reddit, shrug. 
&gt; the ancestor tree is not a straight line (as it would be without multiple inheritance) but a true tree. This is simply false. &gt; Without multiple inheritance, super in any class always points to one class (or that classes one parent, etc) It points to exactly one ancestor chain, as it also does in Ruby.
If we understand `super` to call a method implementation in a class the receiver has inherited from. Then without module mix-ins, for any receiver there is exactly one parent to look at to see if the `super` method is defined there, the `SomeSuperClass` you can see by looking at `&lt; SomeSuperClass`in the class definition -- if `super` is not caught there (the message is not received in that class), there is again exactly one superclass to follow up the chain ( again, the one defined with `&lt;`). Seeing where `super` is finally caught is a repeated process of looking at exactly one parent, if not there, then follow up to the exactly one parent of that class, which is always the same parent for any given class. With module mix-ins, for any given receiver, the `&lt; SomeSuperClass` is not the only parent implementer that could be receiving super. Any module mix-in could too. Every time you need to "go up the chain" (from a class or module) to see where `super` is going to be received, you can not just consult the single class defined with `&lt;`, you need to consult multiple parents. This is what I mean by saying there are "multiple" inheritance parents in the presence of module mix-ins. Perhaps it depends on your point of view and definitions. I think we are just as unlikely to convince each other as we were last time we argued this! Everyone else can make up their own mind, I think Sandi Metz's comments on module mix-ins in the interview I link above are helpful. 
Hi, Sorry it's been a month. I'm passing using Bond with rspec in a project, I am calling rspec via this command: BOND_RECONCILE=reject rspec And I get this error: Failure/Error: fail('BOND_FAIL. Pass BOND_RECONCILE=[kdiff3|console|dialog|accept] environment variable to reconcile the observations.') I can't find any documentation that clarifies how to call Bond and have it auto-reject and fail on a change. Is this not the right way?
Thanks too. I guess that I have some tinkering to do. I'll take a day or two to try all the suggestions.
&gt; I don't agree that having language rules that eliminate ambiguity in lookup order when you inherit from multiple parents makes it no longer "multiple inheritance". LOL fine, then I declare my first example 'multiple inheritance' despite the fact that is exactly the text book case of single inheritance as it apparently meets your random definition of multiple inheritance. 
In your first example, a class does not have more than directly associated parent, inheriting code implementation from each parent. So I would not call it a demo of multiple inheritance and don't know anyone else that would either. If inheritance is when a class has a parent and inherits implementation from them. Then if a single class can have multiple direct parents, that seems obviously "multiple" inheritance to me. Perl, Common Lisp, TCL, and Sandi Metz all agree. shrug. Your definition is literally that it's not multiple inheritance unless it has ambiguous semantics? That seems like a pretty useless and arbitrary definition to me. Does _any_ language meet that definition? Arguably C++, and even that's debatable? Any other language in existence? But to each their own, I suppose. &gt; Multiple inheritance is a feature of some object-oriented computer programming languages in which an object or class can inherit characteristics and features from more than one parent object or parent class.
do you actually need `self.withdraw`? Why can't it just call `withdraw(1234, w_amount)`. Shouldn't that call itself?
why is the percent called 007? lol are some of these for real...never heard people call half of it.
&gt; Both CMod and CClass have multiple direct (not via an intermediary parent) parents `include` does not mean 'make me a parent'...what do you think `prepend` does? 
Sure, you still have multiple inheritance when using `prepend`, in the sense that you have multiple direct sources of inherited implementation. The module you have prepended is used for method lookup, so sure we could call it a parent. It is a bit confusing to call it a "parent", I agree. But we don't really need "parents", to talk about "inheritance", multiply or otherwise. You can replace all instances of the word "parent" with "source of inherited implementation" if you like. If a class can directly inherit implementation from multiple sources, that's multiple inheritance. By "directly", I mean A inherits implementation from B not through an intermediary source of inheritance which itself inherits from B, but a direct association between the receiver (A) and the source of inheritance (B). In Java (at least before Java 8.1), a class can only inherit implementation from _one_ place, it's single superclass (and that superclass's own source of inherited implementations, of course). That is different from ruby (Or Perl, or Common Lisp, or several others), in which a class can directly (without intermediaries) inherit implementation from multiple places. Multiple inheritance. (Java 8.1 introduces default methods on Interfaces, which seem like they change this, but I haven't really explored them). Talking about "multiple inheritance" this way allows us to differentiate between these two situations, in (eg) Java (pre 8.1) and ruby. Talking about "multiple inheritance" your way allows us to differentiate between... languages that have ambiguous semantics (are there even any such?) and those that don't? What is your definition of "inheritance", what do you think "inheritance" means?
I've looked at the README but I don't really understand what this is. Can you explain how it might be used?
It's a package (pack) manager for templates. It lets you install, list and merge template packs. Template packs in the "real world" are books, slide shows/presentations, websites etc. Use it like: $ slideshow install deck.js # uses Pakman.fetch e.g. downloads template pack to ~/.templates. And to list all installed template packs use it like: $ slideshow list # uses Pakman.find And $ slideshow build test.markdown -t deck.js # uses Pakman.merge (use deck.js) Hope that makes it clear. Cheers.
Thanks for the links. They're helpful.
I'd never heard of Middleman before. Thanks.
What features may not work? Did you have something specific in mind?
Agree with mperham. I feel like the error is appropriate at runtime and provides obvious documentation on how the code works.
This (that is, the slide show) was just an example. It is a generic template pack (using Liquid or Embedded Ruby). That is the point (e.g. it's not just a library for slideshow). Of course without any example it doesn't make sense. Thanks for your comments. Still early - will try to add more docu (and examples) later.
I think your reasoning has validity here, but I still advocate against using NotImplementedError. Its superclass is ScriptError, which is a direct descendant of Exception. This means that a `rescue` won't capture it: begin raise NotImplementedError rescue =&gt; error # Won't get here, rescue catches StandardError when not given an explicit type end I prefer to avoid the use of errors that don't descend from `StandardError` for that reason. If you want to raise an explicit error if a virtual method was not implemented, I think it'd be a better idea to subclass a specific error type from `StandardError`. All that said, contracts over subclasses (either via inheritance or modules) are often some of the least desirable contracts.
Quick observation - in this, and other posts, your introduction is confusing. It's usually a paragraph or so that doesn't make much sense until you've actually introduced the concept you're taking about. If I'm coming to your site from a Google search, reading a paragraph that imparts little to no info and is fairly confusing would dissuade me from reading the rest of the post. 
Consider why it's not a StandardError: rescue is useful if you can recover from the error. NotImplementedError means the developer did not follow the contact - it's more of a compiler error than a runtime error and not something you'd ever recover gracefully from.
There are two other uses for `rescue` that are far more important in this case. 1. You want to log all errors to an external service. 2. You want your process to be able to continue processing other unrelated units of work (i.e. a web request/response cycle) after abandoning the current one. There shouldn't be a need to rescue all `Exception` types in those cases. You'll disrupt `Kernel#exit` if you do, for instance. I'm not convinced that you can really draw a relationship to compile time errors vs. runtime errors in a dynamic language like ruby. Certainly it doesn't justify repurposing NotImplementedError just to avoid creating a subclass for virtual method violations.
&gt; But for some reason [`constantize`] was changing the string Budgets to Budget. Right. That's because, like I said, `constantize` is designed to be used in the same places where Rails (the overarching origin of ActiveSupport) turns plural things into singular model names. That said, it shouldn't be doing that, and indeed, the docs for neither [`camelize`](http://apidock.com/rails/v4.2.1/ActiveSupport/Inflector/camelize) nor [`constantize`](http://apidock.com/rails/v4.2.1/ActiveSupport/Inflector/constantize) suggest this (nor do their source). This makes me suspect something else is going on in your code causing ActiveSupport's inflection functionality to kick in. All *that* said, you probably should be using singular class names anyway. That's a bit more conventional. If you really need an object to represent a collection of objects, you can still make that singular, with a name like `FooCollection` or `FooGroup`; in your case, however, I don't think that'll be necessary here. All **that** said, if you take my previous advice on not overcomplicating things with multiple Sinatra apps per process, it looks like your need for `constantize` goes away. :) &gt; Never heard of duckduckgo. Great little search engine. Emphasis on privacy. Nice collection of "bang commands". Worth checking out. &gt; And i did inspect the statuscode. Maybe that should be enough for the test. It usually is, at least if all you're doing is to make sure that something wasn't found. Unless you *want* to test for something further (which doesn't appear to be the case), I'd just stick to the status test. &gt; I guess its abit overkill for just two different classes. More like it's *always* overkill. This ain't Java (unless you're using JRuby, and even then). We don't need more `WidgetFactoryFactory`s. &gt; RSpec's Let supposedly allows me to do just that. But when i do that subject is still nil. `let` is usually used for helper methods. `let` is also lazy-evaluated (meaning that it's not evaluated until it's actually used). Aside from the factory, your current approach is actually perfectly fine. Try something like `@subject = Class.new { include WorksheetMapper }` (or whatever you're trying to do here). &gt; Just clarification, so everything should be in the same parent module? Kind of. If your app is called `PiggyBanker`, there should be a top-level `PiggyBanker` module. Then your `WorksheetMapper` would actually be a `PiggyBanker::WorksheetMapper`, your `Adapter::Spreadsheet` would be a `PiggyBanker::Adapter::Spreadsheet`, etc. This makes your code more readily reusable, since you're less likely to conflict with someone else. It also makes it clearer where your code comes from. Some environments (like Rails) don't encourage this because reasons. Don't listen to them. :) &gt; Any opensource model projects you know of? Unfortunately, not many. My Ruby background (at least on the web side of things) comes from Rails, which means that my own exposure to Sinatra codebases in particular is a bit limited. There are [some](https://github.com/zapnap/sinatra-template) [examples](https://github.com/robbin/sinatratest) out there, but they're all over the place when it comes to structure (even [mine](https://github.com/YellowApple/heroku-sucks) isn't a particularly-useful learning tool in that regard, though it *is* potentially useful for seeing a Sinatra app in a more-or-less deployable state).
Just want to say, "thanks". Tried all three frameworks and they're all great suggestions. Will also try GitHub pages. Much appreciated!
&gt; the developer needs to determine why the error occurred It's a `NoMethodError`, it's pretty obvious why the error occurred IMO. Can you conjure a realistic example where a `NoMethodError` wouldn't be descriptive enough?
That's a nice solution, but I wonder if there's a way to use straight rdbms-style optimistic locking too, without the need for the extra fencing token. At the time you queue a redis job to update a `Posting`, queue it's current `last_updated` timestamp too. At the time the worker takes the job, check that Posting in question does not now have a newer `last_updated`, if it does, throw out the job. Would this do the same thing as the fencing token? Exactly, in all cases? I'm not certain. Thinking about race conditions is hard. But I think maybe? There might be performance pro's and con's -- not sure which would win in performance, but I'd guess the redis-based fencing token, but wouldn't guess if it would be enough difference to matter. The db-based optimistic locking definitely seems to be a simpler design to me. 
Maybe we should add a new name convention: FooClassInterface, BaaClassInterface, etc. 
It helps if your codebase tries to make your duck-types first-class. For example maybe everything in `lib/filters` responds to `filter(collection)` and returns a new array. Random duck-typing can be difficult to notice, but the real power is when the interfaces are simple, generic, and intuitive and everyone knows they exist
Yeah this could definitely work in many cases. One thing that makes me nervous about this solution is that you'd be depending on having sufficient precision in your timestamp storage/transmission format to distinguish nearly simultaneous updates. A deal killer would be if you're using a distributed database. If thats the case, you can never depend on the system clocks being synchronized perfectly. And third is the real reason I didn't go with your solution, which is that there are actually multiple tables that define the attributes contained in a `posting` (5 or so). At that point, creating a single token was easier than storing and sorting timestamps from all the related tables. It also means that there's no gotcha when we add an attribute that depends on another table.
Java is not the solution ^^
makes sense, thanks for the reply! Instead of using a timestamp, you could use a monotonically increasing 'update' counter in the database. I guess that sort of would be almost the same solution as yours exactly, but with the "fencing token" in the db on the row in question instead of in redis. That's actually what [Rails built-in optimistic locking feature does](http://api.rubyonrails.org/classes/ActiveRecord/Locking/Optimistic.html), calling it a "lock_version" instead of a "fencing token". I think that wouldn't work for you, because of your multiple table issue. Unless you chose one of the involved tables to be the home of the fencing token/lock version for all attributes, in which case you'd always have to update that one even if you didn't otherwise need to. Otherwise... I _think_ it would end up having exactly the same semantics (now without worrying about timestamp granularity). Considerations might be performance, and just if you generally deal with redis like this already or find it less complex to keep it in the rdbms. I think. ?
Sounds right to me. To clarify, we persist the fencing token in Postgres on the Rails side, but the consumer of the queue (on the Elastic Search side) is where it gets stored in Redis, keyed on the posting id. Thanks for your thoughts!
[Image](http://imgs.xkcd.com/comics/not_enough_work.png) [Mobile](https://m.xkcd.com/554/) **Title:** Not Enough Work **Title-text:** It's even harder if you're an asshole who pronounces \&lt;\&gt; brackets\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/554#Explanation) **Stats:** This comic has been referenced 13 times, representing 0.0124% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d1gyyjg)
No, the failure we're trying to prevent is on the Elastic Search side, so optimistic locking in Postgres wouldn't solve it. We could piggyback on the lock_version, but then we'd be back at comparing values across multiple tables.
[This would be very helpful to you](https://www.masteringmodernpayments.com/).
&gt; Jesus saves, but that doesn't make Him a filesystem. This is so incredibly funny. Did you come up with this?
Yeah I think so. It's just strange for me for anything in the module to use or depend on things existing outside of the module. 
Hm, how about splitting the difference and throwing your own NoMethodError with a message? 
LLVM is magic in the same way that C code and machine code are magic. As a rails developer, you really don't need to think about it. You might have seen discussion about LLVM because somebody was talking about Rubinius? Ruby has multiple implementations and depending on your usecase, you might want to use another implementation. The most common ruby implementations are: * MRI (the reference implementation that you download from ruby-lang.org, using a custom VM). * Rubinius (Ruby using the LLVM) * JRuby (Ruby using the Java VM) There's many other implementations available, but most of them are nowhere near as feature-complete as the above 3 (ie. most of them cannot run a rails app). 
I'd rather call it "optimistic typing". We write our code assuming that everything just works.
Yeah, this is a really good point. It can't go straight to the database because Elastic Search is running on an entirely different codebase, so we would have to duplicate logic on how to interpret all the tables that are aggregated to define what a posting is. That said, we could have the ES side hit an api endpoint to request the data. That would certainly be a safer way to do it, but it would increase the load on the API servers quite a lot. Does this still seem like a bad trade-off to you?
When mixing-in module in a class using `Module#include`, it adds constants, methods and variables of this module if not already included. It is thus ok define instance variable and/or its accessor methods on this module and don't rely on being defined in including classes/modules. module Summarized attr_accessor :text def summary puts "#{text[0..200]}" end end class Article include Summarized end a = Article.new a.text = ('a'..'z').cycle.take(234).shuffle.join a.summary # ebomlihlquyuuerzggbidzevkokxvxhxpqdhaanlfktfxzhwlfswcmmvzcobcfqwkdjonmnfsirtticmdjejuijjvwhozujhegvrcwtphnmwoomyqpdipuaqmvaxyktndckcgghqzayqecsgodexsbfaqprbxfsrepgntzkrnatrwlzlisvnvzwjaxbuyqkkfjadoeghl 
fair enough
&gt; or passing in the wrong type of object due to a bug how would this generate a `NoMethodError` ?
Accidentally passing in `nil` is a common way. But you could also, say, pass in a `String` to something expecting to get a `URI`, and call `scheme` on it. A NoMethodError would of course result. 
Nice. (Not sure I get what part is supposed to be "Git-like", but I like it!)
Some of these are jokes I don't get, I think. "Unassembled hashtag", what?
Similar but different: A lightning talk at wroc_love.rb https://vimeo.com/159751514
Number Four Will Shock You!
This article is full of examples that are known to be really bad practices. In #3 the author suggests to use an `after_commit` hook to persist something in Redis, great, you just coupled your AR model to Redis, every time you persist it, it needs Redis. In #4 we can see a controller with a typical action where logic that should've been encapsulated by *your code* increases coupling because now your controller knows details about your database schema and lower level AR methods. Then all this stuff with `changed?` API, `&lt;attribute&gt;_was` is just gross, had no idea AR has become even more complicated. Then *a classic* bad practice of enqueuing emails in a callback... This is exactly how Rails apps are becoming unmaintainable monstrosities. A good advice is to use as little AR methods as possible, avoid callbacks and make AR models deal with persistence concerns exclusively.
yeah, it's kind of confused all over the place. &gt; The good people at “booksandreviews.com” need to know how often their Reviews are viewed. Touching `last_updated` on each view will let them know the last time a Review was viewed, of course. But not how often. 
&gt; In #3 the author suggests to use an after_commit hook to persist something in Redis Actually I was pointing out how if you do this and use the wrong callback, unexpected things will happen. &gt; Then a classic bad practice of enqueuing emails in a callback... I've heard this kind of response before to queued emails but would love to see some examples of where it falls flat. Would you mind providing one or two? 
I'm not questioning using Redis. I'm questioning tight coupling between an already complex AR model with an external storage system, which Redis is. This is the same old story, callbacks, tight coupling, increased complexity, making things harder to change and so on. Consequences of this approach are painful, the bigger the project the more pain you will feel. &gt; If it's not, then maybe you work around it. It's not like you don't have options to control behavior there. The fact you might want to "work around it" using even more AR methods should be a sign for you that your design was bad in the first place. Yet, people are happy that "there are options" :(
I get that. I've been blogging from time to time myself, and it's amazing how people get stuck on specifics of the code samples you provide. You're trying to explain something but what people always focus the most are the code samples, they remember them, they learn from them, sometimes even unconsciously. I've also seen this when writing documentation, where there's a dummy code example just to explain a specific API, but it needs some context, if that context is just bad (for whatever reason), you can be sure that *somebody* will think "it's how it should be" and do something similar in an actual project. That's why writing blog posts and docs is so horribly difficult :)
Okay, my point is that knowing the last time something was viewed is not the same thing as knowing how often it is viewed. You can't tell how often it has been viewed (how many times, or how many times per unit of time) from just knowing the last time it was viewed. "How often" means "how many times", not "how recently". 
Ah, I must have not been specific enough when explaining in my post. I will address that wording, thanks.
FWIW, I'm from India and the classification works just fine for me.
I can see what you're saying, but I'm not sure it's as cut and dried as that. There's practical burdens (documentation, development/testing, lack of familiarity) with abstracting away the AR interface to that level. In some cases careful use of callbacks is less weight to carry than maintaining another abstraction layer and training everyone to use it. I'm absolutely not saying that callbacks should be used wildly, or that we should *always* avoid building these abstractions on top of AR operations, just that you have to think carefully about the trade offs you're making.
Hi menge, thanks for the question! It should actually be `BOND_RECONCILE=abort` rather than reject, but that same message will be printed. That message is just Bond's way of failing the test in rspec and telling you it failed. It's letting you know that it's not going to do anything about it, and providing you with some other options in case you want to actually update the changes. But for now that message is doing what you said, auto-rejecting and failing the test. Is there something else besides that you expected additionally? Perhaps we've just worded the message in a way that's confusing? By the way, I'm happy to answer questions here, but you're much more likely to get a rapid response if you shoot me an email at erikkrogen at gmail.com - I'm only on reddit from time to time. 
Can you explain why? What would you code different?
I wonder if this was somehow inspired by [one of Gary Bernhardt's talks](https://www.destroyallsoftware.com/talks/a-whole-new-world).
Well, good luck with it then, but I just think you might want to make these details a bit more clear in the campaign...
Got bitten by this big time by this when porting an app and all tests started failing because of connection pool exhaustion... 
trailblazer sux and your a dick lol
&gt; Reader, be warned - the cons are all just advertisements for their service offering. Hi Rapidsight. I hope that's not the case, I wrote that article and substantiated all pros &amp; cons. Is there something I got wrong in the article? If so, please advise (as I stated in the footer) as I only intend to be factually accurate.
Don't listen to that dude. Was a good article. I don't think you could have elaborated much more on any of the points without each point turning into another full article (DO IT!!). You have very close insight into the problem as you've been working with it for a while now. That's important experience and its great for the community that you are willing to share. Are some of your views biased? Of course they are, but you didn't shy away from that and told the reader "yo man, I have this company and that's where my perspectives derive." If dudeman has a problem with the points you made he should refute them specifically, not bash you for putting information out. This did not read like an ad. I'll read more articles if you write 'em.
bump?
That's perfectly fine, I am just providing some advice on how it was received and how you could improve it, as you asked. When I read it initially, there was no statement - it was added later. Keep that in mind as well
That book is your best bet, imo. If you have time, do the lessons on ruby monk. Good luck!
Also, if you get stuck somewhere, I recommend solving the problem the way you would in Python/Flask, then googling for equivalents in Ruby/RoR.
I think you can become adequate using it in less than a week, given your experience.
What you are asking for is highly database dependant. I suppose it is technically possible to write an appropriate lists of escapes, but it's one that is very likely to be wrong unless the authoritative source (the database driver) agrees.
For what you're asking, yes.
MySQL and PostgreSQL use different quoting styles for String data or column names. You also have implicit type-casting when comparing a column of type A with a value of type B.
&gt; it's almost guaranteed that you will be solving the mystery of the update-that-didn't. The inverse is almost certainly true too. As your app grows you're going to end up trying fix the problem where stuff gets changed when you didn't want/expect it to. And once you've gone down this road you can't just remove the after_* hooks because everything will break. So you'll start adding conditionals to your callbacks... It's better to remove this logic from your models completely and have some other object that coordinates this sort of stuff and make it explicit. And don't blame junior developers. It's your job to make sure they know how your app works, if they don't then you're the problem not the lack of hidden call backs.
/u/apotonick might know ;)
FYI: For the Rails coders out there - Jekyll is a static site builder (framework) in - surprise, surprise - Ruby - kind of the new Rails ;-) Learn more @ [jekyllrb.com](http://jekyllrb.com) Cheers.
Interesting idea, I'd like to hear more about advantages and use cases of non-http approach. IMHO http is not such a big overhead to tradeoff convenience and unification.
The problem with 5 is just the fact that it's there, it makes an assumption that you want change-set tracking with every ActiveRecord object that you create, it adds an additional concern (that you probably don't want or need) and litters the object interface with completely unnecessary methods like "#{attribute}_was", in addition to this it's just moar encouragement use callbacks. Why should a user carry around state containing information about the history of changes made to it's internal state (Xzibit meme anyone?), there are valid reasons to use change-set tracking, but this is not a one-solution-fits-all kind of problem, for example, if you want to update something every time an attribute is updated on a certain type of object, use the observer pattern, or a message bus; if you want to log changes to certain objects, you'd be much better served by an independent object that tracks changes and passes them to another object to write the logs (note that an independent change-set tracker is an abstraction that could be useful in both scenarios). I threw together a little example to implement this kind of behaviour, I admit there are arguably nicer ways to do the same thing (i.e. use a fixed attribute set and dynamically define methods based on those) but it reeks of bad design in either implementation: https://gist.github.com/AMHOL/d9f93dfe2ffe9ebe3c0530b18bea8c79
Line 61 https://github.com/apotonick/trailblazer/blob/master/lib/trailblazer/operation/controller.rb#L61
&gt; When I read it initially, there was no statement - it was added later Sorry, that is not true. The only amendment since publishing was to change the word "Performant" because one of the readers quite rightfully pointed out it was not a word. Other than that, it's not changed.
bleh, I am not a fan of the `.()` syntax people do. It reads funny and is confusing even though I'm aware you can call `call` that way
I don't know why you got downvoted. That kind of code annoys the shit out of me.
I apologize then if that's the case, I didn't notice it. It seems odd that you would preface the article with such a message though, as it seems reactive.
`.()` is the closest you can get to make method calls and `Proc` calls look the same. It's rather unfortunate that you can't handle them the same way in the first place.
Second Grape.
You might have a good use case for just building a rack app. And if we step out of the ruby world, it sounds like you might just want an nginx reverse proxy with some auth.
This will make the most sense in the long run. Leaving more time for eating and sleeping instead of dealing with conflicting system rubies.
Hi Enumerable_any, I'm guessing you're looking at form types, `#register` is delegated to a `Dry::Container` object which acts as a central repository for all types you register. It's a little hard to follow as the base types are registered dynamically, but the primitive types are registered [here](https://github.com/dry-rb/dry-types/blob/master/lib/dry/types/core.rb#L26-L28) I think the prefferred method is to use a custom types module and build your own types there, i.e. module Types include Dry::Types.module MyBool = Form::Bool.maybe end Types::MyBool['1'] =&gt; Some(true) Types::MyBool['0'] =&gt; Some(false) Types::MyBool['test'] Dry::Types::ConstraintError: "test" violates constraints (#&lt;struct Dry::Types::Result::Failure input="test", error="\"test\" must be an instance of FalseClass"&gt;) # Error messages need improving for complex types
Isn't that one of the major ideas behind Rspec to begin with? The whole idea that non-technical people could look at a project's specs and understand what's going on at a basic level? It rarely works out that way, of course. Markdown might make that easier a bit, but it comes at a cost. You're adding yet another layer of abstraction (?) to your testing, this time in a new format (markdown). It's an interesting experiment, but I'm not so sure how useful it would be. Long-term, the advantages of this super abstraction becomes less useful (people understand their code better the longer they work with it) while the disadvantages increase.
Thanks for replying! `core.rb` was actually the file I looked at when I decided to comment here. What I mean by "custom type" is "new type with coercion". E.g. I want the following behavior: Types::MyBool['j'] # =&gt; true Types::MyBool['n'] # =&gt; false Types::MyBool['everything else'] # =&gt; Dry::Types::ConstraintError How would I define `MyBool`? I found `constrained` but this doesn't give me the chance to convert `"j"` to `true`.
Also consider Kong. Kong is an API mediator. I think the address is getkong.org It's made by mashape 
I can understand that, but what about existence of equivalent `Proc#[]` ? Aren't two ways call a proc object enough ? Btw. this introduces a little inconsistency, by breaking a rule, object reference followed with dot always means sending a method. AFAIK `.()` is translated at a parse time, so it can't be used dynamically: p = proc {'hello'} # #&lt;Proc:0x0000000461c188@(irb):1&gt; p.() # "hello" - parser replaces .() with .call p.send '()' # NoMethodError: undefined method `()' for #&lt;Proc:… p.send '[]' # "hello" Find unfortunate this construct has passed into the language. Shorter alias `Proc#[]` would be more then enough. Less is more, sometimes …
Big +1 for Napa. Before I knew of it, I found myself bootstrapping too much when building APIs in Grape.
You could do this: require 'dry-types' module Types include Dry::Types.module end MyTrue = Types::Strict::True.constructor { |v| v == 'j' ? true : v } MyFalse = Types::Strict::False.constructor { |v| v == 'n' ? false : v } MyBool = MyTrue | MyFalse puts MyBool['j'] # true puts MyBool['n'] # false puts MyBool['oops'] # constraint error
OP here, and not affiliated with the company in any way. I think they are legit cons though for many use cases.
So `ruby -v` returns 2.2.4; that means there is no more reason to keep 1.9.3, correct? `sass -v` returns *DEPRECATION WARNING: sass 3.5 will no longer support ruby 1.9.3. Please upgrade to Ruby 2.0.0 or greater as soon as possible.*
When designing a language - There is a lot to consider and plan out. You need your syntax, your stndlib, specific features &amp; idioms, control structures, lexer, compiler, runtime, etc... The beauty of LLVM is that it allows you to abstract away a lot of pain when you get the the design of the compiler. Without going into more detail: if you can handle writing your parser &amp; lexer that will generate intermediate code (much easier to create than machine code), LLVM will take over the responsibility of actually compiling your code to a machine executable. Thousands and thousands of hours have gone into creating an efficient and smart compiler within LLVM, so you don't have to re-invent the wheel. A cool example of this is [Crystal-lang](http://crystal-lang.org). The language started out with a parser &amp; lexer written in Ruby, that created LLVM IR-code, and was then compiled by LLVM. Overtime, they were able to create a robust enough language that it became "self-hosting". They were able to completely remove ruby from the toolchain, and now the parsing &amp; lexing is done in Crystal itself... still generating LLVM IR code. &gt; As a rails developer, you really don't need to think about it. It's true that you typically don't need to consider things like this all the way up from Rails-land... but it's always good to know as much about your tools and ecosystem as possible. You never know when it will come in handy. ;)
Aha. For some reason I wasn't getting the video showing up the first time I looked. 
I'm the author of the library. This library evolved out of some real world constraints. Here are links to a few talks based on this https://www.youtube.com/watch?v=OwItb_TRh2U http://youtu.be/G_9741n5e5A The first one has poor recording quality unfortunately. The second is golang centric, but the same concepts apply. Glad to answer any questions.
Better to ask here: /r/learnruby/
There's no such thing as the Integer `000`, it returns just `0`. Start with a String literal `"000"` or you could pad zeros to the left if that's what you're after `000.to_s.rjust(3, "0") #=&gt; "000"`.
I favour sprintf: sprintf("%03d", 0) =&gt; "000"
thank you - im actually working on a bigger project to convert all numbers to their written counterparts. im splitting large numbers into 3's so that i can incorporate the trillion, million, hundreds, etc in the correct places, however im running into issues when the number is say 1,000,001. it's not reading the 000 correctly so i wonder if there is a way to convert this number into ["1", "000", "001"] - thanks for any tips!
It would include other constants from `Dry::Types` namespace which I don't want to have.
`&amp;.` - `maybe`
We need to build it dynamically because additional types could be registered too. If it was a static module provided by the library it would be limited to the types provided by dry-types itself.
One way to do it would be with a Regexp like `to_s.scan /\d{1,3}(?=(?:\d{3})*\z)/`. Or a non-Regex solution like `to_s.each_char.reverse_each.each_slice(3).map { |chars| chars.reverse.join }.reverse`.
I might experiment with subclassing a module, low priority though. So many other things to do. Thanks for suggestions.
I think that generally I agree with you. The point of this generator is probably not for ALL specs, but for those that you want to use as high-level use-cases in a form which could be used as part of documentation. The RSpec generator is a proof-of-concept yes it's possible to generate working specs from an input markdown file. How that ends up being used in documentation is the next part of the experiment, but for me it will probably center around C++ code and documentation where I think it will be a lot more useful because the baseline for C++ documentation and testing is so much worse.
Can this be compiled in Crystal?
1) Yup. 2) One stop shop to do this would be pretty sweet. Right now this is accomplished through BitBucket and Codeship and there are all sorts of webhooks involved that are not 100% reliable. 3) Bitbucket, Codeship, various webhooks thereof. 4) Yup. Provide a hobbyist tier too when you build it! :-)
Thanks for the recommendation. We've decided to move forward with Grape.
Tobias does a pretty good job organizing the Ruby UG in Berlin. However, I would say this post sets the bar for a new meetup quite high - which is probably a good idea, for popular topics, in places with lots of meetups. If you're going for something more niché, in a city where there aren't many meetups, I don't think you have to set the bar that high though.
Thanks for the comment! Yes I'm concerned that people will read it and think "ugh that's too much" that's why I tried to incorporate stories of my own shortcomings and the last section to emphasis that you don't need to do all of this at first and you don't have to get all of it right the first time around. Ideas how to better incorporate that in the post highly welcome :)
I'd use Rails API. Pretty much any application I started implementing using some lightweight framework became more and more like Rails over time, so why don't grab all the useful stuff like routing DSL, caching etc right from the start?
* Practical Object Oriented Design in Ruby by Sandi Metz * Eloquent Ruby by Russ Olsen [edit: I format badly] are two I can think of off the top of my head
I own most of the popular Ruby ones, so I may be looking to programming in general as a science.
Have you checked r/learnprogramming yet? That will have more general resources. 
If you look more for general books then Robert Sedgewick writes [pretty good ones](http://www.amazon.com/dp/0201775786). These use Java for examples but fundamental concepts of objects on the heap are similar enough, I'd say.
I'd suggest looking into free online university courses, too. Here's a link to [MIT's Algorithms and Data Structures](http://ocw.mit.edu/courses/find-by-topic/#cat=engineering&amp;subcat=computerscience&amp;spec=algorithmsanddatastructures) courses, for example.
Metaprogramming Ruby is a great book to read to fill knowledge gaps.
Good one !
Docker hub has some pretty trustable images. The good thing is you can always check out the build layers for any abnormal commands/scripts. However that being said I personally prefer to write my own Dockerfiles from scratch. With regard to updatesupdates you can specify exactly what image build you want which will mean that you image gets the same version.
Thanks, with these tips I could solve the problem 
Well well, I was thinking I might submit a PR for my recent article Goodbye Medium, Hello Jekyll -- but I see you beat me to it! Thanks!
Is there really a difference between memorization and caching, or is it just semantics? Honest question. 
This makes me wonder, what if the code could be the readme; kind of the opposite actually.
@hidotbe, Do you still see this issue in Rails master, the default max thread pool is now equal to number of cores you have. Earlier it was 10 * number of cores. 
Not a stupid question at all. This would be great to have. I have a lot of sites I'd want to check but the pages are on the other side of a login. I added [a github issue](https://github.com/dogweather/rspec-webservice_matchers/issues/43) to the open source project for this. This will be interesting to think about how to implement. Maybe the solution is to have a matcher which accepts a set of Capybara commands. (This is something I've wanted to make anyhow) And then building on that, there could be a way to store a set of "login" commands and/or "get to such-and-such page" commands. And then each matcher could optionally depend on it. 
I liked Sandi Metz's stuff on design patterns. Not as cold as GOF or as all over the place as Head First. For algorithms, I really like Cormen et al, but it's fairly academic. I started reading The Algorithm Design Manual which is really solid. Very practical and covers all of the basics as well as some more esoteric topics. A must have. I don't think any Ruby books are good for data structures, and that's in part because the language abstracts a lot of that (you mostly just have arrays and hashes). There are tree and graph libraries for Ruby but they aren't common
I see. So it's the tiny differences in the syntax that makes it difficult to make a generic yet safe SQL sanitizer.
Very cool . thought provoking. Thanks!
&gt; IMO the parser should reject these delimiters, and possibly also \, for sanity I disagree. The **programmer** should not use these delimiters, for sanity. A code linter, such as [rubocop](https://github.com/bbatsov/rubocop), could potentially provide warnings in case of such bizarre code.
&gt; My best guess is that something about Numeric wants it to be instantiated to a value for this operation That's pretty much correct. As I'm sure you've heard everything in Ruby is an object and in this case you're asking if the object `Numeric` (i.e. the class itself) is *Numeric*, and it isn't. The object `Numeric` is a `Class`. You could do `3.is_a?(Numeric) # true`, because in that case you're testing if the object `3` is Numeric, which it is, because it's an instance of a `Numeric`. ---- Try [Module#ancestors](http://ruby-doc.org/core-2.3.0/Module.html#method-i-ancestors) for your method.
My guess is that you're confusing what `is_a?` is intended to be used for. It's meant primarily for use on instances, not on classes, but classes are objects in Ruby so `is_a?` is still defined. In other words the intended use is: &gt; 5.is_a? Integer true &gt; 5.class Fixnum Not &gt; Fixnum.is_a? Integer false Do note that `is_a?` works on classes, but it references the class itself... &gt; Fixnum.is_a? Class true &gt; Fixnum.is_a? Module true If you need to figure out if a class is an ancestor of another, the easiest way is probably `Fixnum.ancestors.include? Integer` 
Thanks! I got a bit confused because in IRB I tried Object.is_a? Object, which returned true, but I'm pretty sure it doesn't flow logically that Numeric.is_a? Numeric works that way. Thanks for the tip.
Thanks again! 
I can't seem to find any documention on how this method works? Where is &lt;= documented for classes in the ruby docs?
Thank you.
Why broken ? Why there should be an exception to the rule, use any ascii character as string literal delimiter ?
On cell input.chars.to_set.subset? array_allowed.to_set You need to require 'set' I think 
I'll try this. Thank you!
Here are a few ways I would solve this. Regex: input = 'ABKF' regex = /^[A-F]+$/ input =~ regex # returns nil input = 'ABC' input =~ regex # 0 If it returns anything but nil, you have valid input, though this will always return either 0 or nil. Array.all? array_of_letters_allowed = ["A", "B", "C", "D", "E", "F"] input = "ABKF" input.chars.all? {|char| array_of_letters_allowed.include? char } all? returns true if all of the elements in input.chars return true from the provided block. I would use the regex solution, personally, but this is a personal bias and I don't have benchmark data to support this decision in terms of efficiency.
I prefer this answer over the other one simply because I don't need to rely on another file. Thank you, this is exactly what I needed!
I guess it's just a matter of preference. Personally, I like to see *how* to get to a solution rather than depending on another library/file to accomplish the same task. But in real-world applications, I suppose it's best to go with the most efficient solution.
I think what you're trying to do is GREAT for when you're trying to learn how to solve problems in Ruby, and I encourage that. Once you learn how to structure an algorithm, though, and that starts coming naturally, it's a good idea to move to learning how to write idiomatic, well formed Ruby. The difference between my solution and the other is definitely "explicitly solving the problem" versus "clean, nice code". In a professional setting where others will be looking at your code or you'll have to revisit your code after 7 months, the latter approach wins out. Clean code is good code. Vary from this only when absolutely necessary.
First you need to flatten your array. array = [1, [1, 2, 3], [1, 2, [1, 2, 3]]] array.flatten =&gt; [1, 1, 2, 3, 1, 2, 1, 2, 3] Then there's some options: array.flatten.inject(0) {|sum, element| sum + element} =&gt; 16 array.flatten.reduce(:+) =&gt; 16 There's a bunch of different libraries (activesupport being one) that add a 'sum' method to an enumerable, so you can just do: array.flatten.sum =&gt; 16
&gt; This token is encrypted and signed using a secret key generated by your rails application It's signed with HMAC-SHA256 - it's in *no way* encrypted. Considering one of the use-cases is to embed arbitrary information in the returned supposedly "secure" payload that's a pretty damn serious error. I [reported this last July](https://github.com/undercase/proof/issues/2) and ~~my issue has yet to have any sort of response~~ I got banned from the repository because of it. 