Try stackoverflow or google, not reddit for this sort of question.
Preface: I've used Sinatra, Cuba, and Rails Cuba is more like Sinatra than like Rails, though, it's actually much leaner than Sinatra even. [Soveran's slide deck](http://files.soveran.com/cuba/#0) gives a good brief code comparison. Given you are just starting, I'd say plan to stick for now with Sinatra. It's still clear, and you are going to have an easier time finding documentation and examples on it. The API takes a similar approach to Sinatra in that you declare the routes wrapping the action code; the authors used Sinatra heavily before moving to Cuba. However, I'd say the Cuba API requires a little more explicitness. As an example, in Sinatra you could have a string returned from the last expression for an action, whereas in Cuba it would be: res.write "some string" This pretty much permeates the API. You are usually calling methods on a request or response object, rather than a method in the current namespace. Out of the box, Cuba supports [nested routing](http://files.soveran.com/cuba/#4), while Sinatra does not (though there are extensions for it). It can use tilt, the same rendering adapter that Sinatra relies on, though it doesn't require it. Both support app composition via rack; Cuba also supports direct inline composition without you invoking Rack builder code yourself (Sinatra might, I can't recall how off the top of my head). It's probably a little outdated by now, but there was a tiny (incomplete?) example app on github using cuba: [cuba-app](https://github.com/citrusbyte/cuba-app) that is worth a read if you are interested. Lastly, Cuba is possibly the fastest rack routing you are going to get out of the box, next to rack itself. If you are halfway decent at ruby and have written with Sinatra, you can handle a Cuba app without much trouble. 
I agree with the OP. I had a hard time understanding when you were stating your opinion, playing devil's advocate for someone else's opinion, and what is the HR line separating? 
xternal gave a great response. The main differentiator to me between Cuba and Sinatra is the routing. I really appreciate Cuba's nested routing vs Sinatra's "flat" routing. I also like that it's just a *very* thin layer on top of Rack itself. Look at the [source code](https://github.com/soveran/cuba/blob/master/lib/cuba.rb)! FWIW, the other pieces of my stack that I really like are [Erector](http://erector.rubyforge.org/) for templates (pure Ruby syntax, things like template inheritance for free) and [Sequel](http://sequel.rubyforge.org/) for database access. Sequel is *wonderful* and Jeremy Evans is an amazing author/maintainer.
how does this gem work when you install it on a new system? doesn't look like it has a binary (similar to rake, or puppet or rspec), which will make it harder for users to just gem install ez_importer and go. no tests? tests don't just enforce expectations, but they become the guidelines over what the application/gem should do. also check out travis CI to integrate with github and provide CI services (build,test,release on change - you can pick how far down the pipeline you want to go - check out Martin Fowler Continuous Delivery) 
I've used [Sinatra](http://www.sinatrarb.com/) a lot and [Padrino](http://www.padrinorb.com/) recently for an app. Padrino is really good at providing a structure and generators for complex apps. I also like how open the Padrino developers are to suggestions. Padrino has extensive YARD [API documentation](http://www.padrinorb.com/api/index.html), but needs more examples/screencasts.
Do you provide customers with information about availability issues? E.g. instances/virtual servers being restarted, network issues between your servers and network backbone etc. Does http://status.shellycloud.com/ publish only current status, or also recent history of detected problems?
Everything after the HR was his comment posted on the Heroku blog. I had to go search the blog comments to figure this out though.
In my experience it's superb for API backends. For our latest app www.criticue.com we use sinatra + haml exclusively but it's mostly API with JS frontend and what isn't yet will slowly migrate towards the model anyway. Great mini-framework, fast and stable.
thanks, appreciate the feedback. I've made some minor edits to the OP to clarify, and in general will try to take more care in the future to do more editing/reviewing for clarity before sharing. (I think none of it is devil's advocate for someone elses opinion, fwiw)
I have had code which tries to make multi-threaded use of SQLite3 in AR, and it actually produces errors (raises exceptions) in SQLite3 -- when the same code with another db adapter (mysql2 or postgres) works fine; and also the code altered to not have multiple threads accessing the db at once with SQLite3 works fine. That's different then demonstrating blocking, but it _seems_ to me to be demonstrating something non-threadsafe about the SQLite3 adapter (or SQLite3 itself?) when used with ActiveRecord. I am not sure if I am doing something unusual, or if once you go to `config.threadsafe!` in Rails4, any app receiving concurrent requests and using sqlite3 is going to start raising all the time. Would a test demo'ing the raise be useful? Writing tests involving the db like this is always challenging for me, any tips welcome if so. 
Awesome. Very happy to see threads getting more attention in rubydom. A good book will be a huge benefit to the community. Definitely let us know when it's available, I know I'll buy a copy. 
erm, do u know what "OP" means? :P
Thanks for that info.
I prefer fetch for this purpose, rather than having a hidden default value. I'd rather have the default value visible where I'm asking for a value than to have it hidden away wherever the hash is declared. foo = Hash.new foo.fetch(:bar, 0) #=&gt; 0 The default, if you don't pass one, is to raise an error, which is VERY useful. #fetch is pretty handy for other reasons, like passing a block instead of a value: foo.fetch :bar do |key| puts "You fucked up. #{key} doesn't exist" nil end # You fucked up. :bar doesn't exist #=&gt; nil
The positions I am linking here involve codebases that are dominantly written in Perl. However, I thought it would be appropriate to post here as well because we welcome great developers whose favorite or most-known dynamic language is something other than Perl. In addition, some of our people are converting one of our internal Perl web frameworks to Ruby on Rails, and it would be good to have other perspectives, knowledge of other already-solved problems that we may currently face, in our toolbelt. At a certain point, it becomes less about the language and more about the problem one is trying to solve, the people one is trying to help. Let me know if you are interested. :) 
it means "original poster" usually, i think jdonnnel was referring to ReinH i.e "I agree with ReinH (that it was hard to understand)
[Y U NO EVERTHYING?!?](https://i.chzbgr.com/maxW500/7077241344/h4B88559E/)
No sign-up link?
Uh, no demo, no screenshots, no video? [vurt da furk](http://2.bp.blogspot.com/-p-1he_d5JRE/UPYP6gg5ckI/AAAAAAAAAL8/73w1d3nWz2s/s1600/Vurt+Da+Furk.jpg)
If you had written the original post like you did this one, it would have been much better. &lt;3 [ETA: Also, stop anthropomorphizing software products. They hate it when you do that.]
One more thing: the [Redis website](http://redis.io/) is built with Cuba and [is open source](https://github.com/antirez/redis-io) and is a great example of a good Cuba site.
It did not have to be done.
No worries, thanks for being so open to criticism.
If I correctly understand what you're asking, you can do this pretty simply with Date#wday, which will tell you the day of the week for any date, e.g. [16] pry(main)&gt; now = Date.today =&gt; #&lt;Date: 2013-02-19 ((2456343j,0s,0n),+0s,2299161j)&gt; [17] pry(main)&gt; now.wday =&gt; 2 [18] pry(main)&gt; (now + 1).wday =&gt; 3 [19] pry(main)&gt; (now + 10).wday =&gt; 5 If that's not what you were asking for, I apologize.
Giving my wording on this you answered the question pretty much correctly. So the oversight was on my part. What I am looking for is a what to punch in 2 dates and have the range of days be returned back in an array of weeks if applicable. Those weeks will be an array of 7 days. Hopefully that is a little bit clearer.
This should do it: def getCalendar(startDate, endDate) #two dates currentDate = startDate #start with our start date calendarDays = Array.new #store the array of dates while(currentDate &lt;= endDate) calendarDays.push(currentDate) currentDate += 1 #next day end return calendarDays end The advantage to this is there are all dates, so you can get data about them easily to build your calendar.
Something like this? now = Date.today later = now.next_year weeks = [] day = now until day &gt; later do week = [] day.wday.times{ week.push nil } (7 - day.wday).times do week.push day day += 1 end weeks.push week end That will create an array for every calendar week, padding the first few entries in the first array with nil when Date.now isn't a Sunday. For instance, this: puts weeks.first.map{|d| d.to_s}.inspect prints this: ["", "", "2013-02-19", "2013-02-20", "2013-02-21", "2013-02-22", "2013-02-23"] Since today is Tuesday the first two slots in the array are just placeholders. The above code is heavily golfable, btw, I basically just typed out stream of consciousness.
Love your work! Now I'm inspired to drop the wordpress madness for my phogoraphy sites. So you used pure sinatra and not Jekyll/Nestacms/octopress?
use a Range: dt1 = Date.new(2013,1,1) dt2 = Date.new(2013,12,31) dr = (dt1..dt2) dr.each do |d| .... end
Your test shouldn't require intimate knowledge of what internal instance variables are doing. It would make more sense to me to assert that calling errors returned an empty array on a new instance of the Parser class.
Wow, this seems unbelievable. Why Rainbows over Unicorn? Never seen Rainbows before.
Thanks! And yeah, pure Sinatra, with Bootstrap for the UI.
What about puma? 
not sure it supports forking and streaming 
I'm just gonna clean that up for you a bit: def getCalendar(startDate, endDate) #two dates (startDate..endDate).to_a end Which, yah, by then it's obviously not worth being a function. But you get the point. (I successfully resisted converting it all to snake_case.) ;) Edit: fixed broke ass code. Thanks for pointing it out judofyr! 
And you need longer connections to be able to support large number of concurrent connections?
I'll fix it for you: (startDate..endDate).to_a (Your code just creates an Array with one Range object.
I would suggest instead of talking to Ruby programmers, you might want to try and find some people to talk to here: http://www.leanstartupcircle.com/ I'm a CTO though who is a Rubyist who knows how to do numbers stuff. If you want to chat through anything, you can message me.
Much thanks. Serves me right posting without testing. 
Sort of off-topic gripe: You call your framework Espresso but then name the gem 'e'. Apps inherit from "E" instead of "Espresso". Seems inconsistent...choose one or the other. 
What are the major implementation differences that cater to the different goals?
Most of my domain models need between 5 and 7 of the actions a resource defines, and having a convention for that is very helpful for consistency, both within the app and with other apps. If your domain models aren't resources, not using resources makes complete sense.
Why did you use espresso as the web framework?
Unfortunately there are (gasp!) production apps without a comprehensive test suite. In my case, this means even something like updating gems requires a full manual test run, which takes up the time of our QA team, hence costs money. But yeah, we're working towards that state you described. 
objectively - it is the fastest and consumes less memory than any other. subjectively - i'm the author of Espresso Framework. 
The error I get is "No method '[]' for object @list" or something like that.
Josh Cheek created a padrino screencast for CodeSchool. Not free and not very in depth but a good start.
No, that's still just inconsistent. I appreciate the name was already taken, but using a one-letter class name is bad practice regardless. If you can't have the first name you wanted, then pick a different name and stick with it.
The main advantage of Codifferous over traditional PRs is we provide an easy to understand visual cue for how much code you've actually reviewed, and it's a much quicker way of reviewing code and getting up to speed on a new project. Thanks for commenting! We appreciate all feedback on this project.
2.0 supports forking via a cluster mode (which creates master/worker processes) and streaming is trivial, especially with the new rack hijack API.
agree with @ymek, your description makes it very difficult to know what it is you're offering and i dont think you'll get many people signing up without fully understanding wtf it's about. You should include some screenshots or a screencast
Why is the code size so different between Sinatra and Cuba? because of features in Sinantra?
Yeah, I definitely agree. A big sticking point is why anyone should use this over PRs. I'm planning on working with our designer and will have an update in the near future. Thanks!
Just curious, I'm just starting with Sinatra, what makes Espresso more scalable?
While good communication between members of a team is key, there's still a lot of benefit to be had from reviewing more code and knowing exactly how much of the code you've read in a given project.
-- try to mount a set of controllers, aka Slice, into N applications over M servers -- no way, Sinatra has no slices &amp;nbsp; -- try to setup N controllers at once, without inheritance -- no way, Sinatra has no controllers &amp;nbsp; -- try to setup N actions out of M controllers -- no way, Sinatra has no actions 
I'm glad you wrote that. I'm not alone. I may reconsider Rails based on what you said...that REST setup really is difficult, especially when you're not doing Rails every day. (I'm an iPhone developer)
There's always benefit from reviewing more code, but time is limited. Maybe you need to improve trust and coding practices as well. While it's nice to know the entire codebase, it can become impractical. When people build systems properly, you can use what they build without having to look inside. And sometimes you'll NEVER look inside a particular class or function, because you don't need to.
Cool. Chapter 3, "Non-Resourceful Routes", in the Rails Routing Guide, is pretty decent: http://guides.rubyonrails.org/routing.html#non-resourceful-routes What I actually _love_ about Rails routes, that's been there since the start, is the way they are bi-directional -- your routing file is used for _generating_ URLs too. If I change the routing file, it changes the URLs _generated_ by the app too. But I still mostly use `url_for(hash)` to generate routes rather than named routes too. (Do sometimes use named routes, with explicit names attached to Non-Resourceful routes, though). In my opinion, the non-Resourceful routing provides an elegant de-coupled seperated-concerns design, that works for just about any application pattern use case, in a way that is lost with the Resourceful routing. I think it's too bad that the documentation etc all focuses on the Resourceful routing, in my opinion steering beginners wrong. And I agree with you that it's one of the parts of recent Rails (sadly there are more) that makes it harder to get started with Rails than it used to be -- for not enough gain. 
To take a screenshot of a desktop you need a client-side language. You need to capture your desktop or your users desktops? Try to look what you need in Java or Flash.
Asked someone else. Should have been "if t.title".
&gt; In general, in modern ruby/Rails code on MRI ruby 1.9.3 and rails 3.x, when a thread is waiting on I/O (like a database call), it can be switched out and another thread switch in. Not just on a "modern" MRI Ruby. Even MRI 1.8 did that. Upon detecting a blocking I/O operation it suspends the current thread and switches to a runnable thread. In MRI 1.9 this scheduling is outsourced to the operating system. &gt; If there's C code involved, the C code has to be written properly. Correct. We even wrote an article about this: http://blog.phusion.nl/2010/06/10/making-ruby-threadable-properly-handling-context-switching-in-native-extensions/
Phusion Passenger 4 Enterprise supports multithreading. Phusion Passenger 4 open source and Phusion Passenger 3 Enterprise don't support it. Regarding the maturity multithreading support in Ruby + Rails: it works, and it works well. People have been using multithreading with JRuby for years. In my mind it's pretty simple, but maybe I'm too familiar with the ecosystem to see how others can perceive it as confusing. Here's a (as far as I know) complete checklist of using multithreading. If anything's still unclear, please feel free to ask because I would love to explain further. - Enable `config.thread_safe`. - Use a multithreading-capable app server, for example [Phusion Passenger 4 Enterprise](https://www.phusionpassenger.com/enterprise). :) Thin is *evented*, not multithreaded, so that doesn't work if you want multithreading. Thin has experimental multithreading support but I'm not sure how reliable it is. - When using MRI, use multithreading *and* multiprocessing, e.g. what [Phusion Passenger 4 Enterprise](https://www.phusionpassenger.com/enterprise) offers. Multithreading is for handling concurrency, multiprocessing is for handling multiple CPU cores. - When using non-MRI (e.g. JRuby) using multithreading and a single process is enough. - Do not use the 'mysql' database driver, which is freezes threads while doing its work. Use the 'mysql2' database driver instead.
&gt; Not just on a "modern" MRI Ruby. Even MRI 1.8 did that. Upon detecting a blocking I/O operation it suspends the current thread and switches to a runnable thread. In MRI 1.9 this scheduling is outsourced to the operating system. True, but in many people's experience in ruby 1.8.7 the thread context switching didn't work very well/efficiently. Although I guess it probably didn't have problems switching at I/O block. 
 i=1 a=1 list=[] # keep the rest the same list &lt;&lt; [a,i] a += 1 i = 1 #keep the rest the same --- if ruby even has a &gt;&gt; operator, i've never used it. same goes for , you get no points in life for cramming as much as possible on to one line, unless you're in some kind of competition for using the fewest lines, which I bet you're not. 
I have no idea what you are trying to do, but this at least compiles and runs: def order(n) i=1 a=1 list=[] # one statement per line as per stonercommando until (i==61 or a==n) do if (a^i).modulo(n)==1 list &lt;&lt; [a,i] # is this what you meant by "[a,i]&gt;&gt;list"? a+=1 i=1 else i+=1 end end return list end
Here's a few progressive refactorings: https://gist.github.com/5007207
|if ruby even has a &gt;&gt; operator, i've never used it `array &lt;&lt; something` is pretty common 
yeah I just realised that too, I think I need to scrape some more natural language out my brain before fixing this.
Hey guys, I've got it executing although not functional, i'm going to try and fix it now. Thanks a lot for all your help.
I'm trying to find the order of each element of the group Z2013, which, for a particular x, is the least integer m such that x ^ m=(2013*k)+1 for some integer k. I need to find this for the integers up to 2012. Thanks a lot for that, that version runs but outputs the null array for some numbers but not others, so now i'm confused and trying to fix it. Thanks again!
What ^ operator means? Exponentation or XOR?
Be sure to mention how awesome jruby is :D Ruby threads are still non-native, right? EDIT: Maybe instead of taking Djikstra's approach, you could talk about how ruby's functional paradigm supports concurrency? That last thing I want is more semaphores and mutexes floating around.
 def order(n) i, a, list = 1, 1, [] # comma operator has higher precedence than assignment until i==61 || a==n do if a**i % n == 1 # base**exponent is exponentation; a%n is modulo list.push [a, i] a += 1 i = 1 else i += 1 end end return list end
exponentiation
An error on my part.
Oops, my bad... Array does indeed NOT have a &gt;&gt; method defined.
oh my own, all client side.
a ^ i is bitwise xor, that's why it's not functional, you need to change it to a**i.
I only even commented because I made the same mistake, was typing up my own comment, and then realized my mistake. But for the grace of hindsight, there go I!
Can you provide some info about the company?
As far as I can tell, this is one man's project which (thus far) isn't within the realm of rubygems.org nor has much discussion surrounding it. Not to say there's no interest in discussion or the author is opposed; I simply don't see any trace thereof.
Yeah, i've done that already, this is the version i've got atm http://pastebin.com/SZrEaxMh It outputs an array of the form i'm looking for, but the answers arn't right - I'm kinda stuck now.
Evan, was not aware about 2.0 Will definitely try it in a while.
I love this language.
Well, _that_ really saddens me.
Yep pretty much what ymek said. There are no discussions happening. That's why I posted here. Was hoping to start some! Some history: rubygems has had the ability to sign gems since 2005, but for a variety of reasons I won't get into here, it wasn't really usable and no one was doing the work to make it usable. About two years ago I thought it would be interesting to use a different signing technology. So I wrote up a proposal on how I think gems should be signed, wrote some prototype Proof-of-Concept software and was ready to write more, but no-one was interested and no-one cared. After the rubygems.org hack last month, signing became a hot topic again and some people tracked my old plugin down. That motivated me to do a new-and-improved release. That allowed developers to sign gems and users to verify them. Then I realized it wouldn't be too hard to write a basic place to register keys to bridge the gap between developers and users, so I slapped that together in a weekend. At that point I had what I considered a minimum viable product and put the link up here. Now that the core is in place, I plan to iteratively improve all components to make them more usable and more secure. By next week I should have a blog with commenting up. I'll try to write some more in depth articles about how to use things, my thoughts on signing and security, etc. So if you want to learn more maybe stop by the site again next week and start following the blog. If you have any particular questions, I'd be more than happy to try to answer them here.
Yeah, let's start with .. How come the rubygems maintainers aren't in on this?
Why wouldn't it run on JRuby ? And sure you delegate to GnuPG but that's natural, it works. Have you considered working with the author of krypt? https://github.com/emboss/krypt
We welcome people from out-of-state (I came from several states away), but the University does not provide relocation assistance.
You can find my LinkedIn or GitHub on the about page of the site and find my contact info. Thanks!
Is Threading supposed to be hard for programmers in general, or just hard in Ruby? It's not rocket science, there's not a whole lot to it at all imo. At least not in Java/Perl. So, I like how u compare it to other seemingly difficult things. Threading I dare say is actually simpler than most "difficult" things. 
Upvoted for great description of what we do with database.yml
The most pervasive and persistent theme in mythology, human experience and art is metamorphosis. Desolee, but perhaps not alone. Toodle-loo, gentle yahoo.. 
As promised blog is up. Hopefully that will promote discussion. Here's a post that explains how a gem user uses the tool. I don't want to submit every single post about this project to /r/ruby so I'm posting it here: http://www.rubygems-openpgp-ca.org/blog/the-complete-guide-to-verifying-gems-with-rubygems-openpgp.html
Hi kgo__ you probably want to be looking at https://github.com/rubygems-trust/rubygems.org/issues/3 instead and pouring your energy in that direction if you are interested in a solution for the Ruby community :-) https://plus.google.com/116926065106933848934/posts/bVkkrKRSLqX PGP, as you surmised, makes it a near-impossibility for EVERYONE to use, unfortunately.
Can anyone eli5 what's this for? Seems by "replication" they mean copy data from one data store to another, but why are there ruby apps involved? Also, when will ruby-ists take a more pgragmatic approach to naming gems (you know - easy to spell, easy to google for, give and idea what it does, e.g. "ruby-pubsub-replicator")?
My philosophy is that I'd rather have a tool that actually works *now* that can be used by security consious people, and iteratively improve on that tool and adoption, rather than focus on a tool that doesn't even exist that can be used by 100% of users and may take months to develop. I think the important thing *now* is to provide a working mechanism for developers to be able to sign gems, because without that the whole problem is a chicken-and-egg thing. No one wants to sign gems because it's not useful, and no one wants to write useful tools because no one signs their gems. Many people disagree with me on this one. Blog post I wrote a few days ago on the subject: http://www.rubygems-openpgp-ca.org/blog/how-many-people-need-to-verify-software-to-make-signing-useful.html 
It is a chicken-and-egg thing, unfortunately, in this situation, I think we don't have a choice but to come to an agreement. I believe that "usable by the whole community" is absolutely necessary -- even if it's a simple SHA1 tool at first and it evolves later.
&gt; Also, when will ruby-ists take a more pgragmatic approach to naming gems No clue. You look at the name, you look at the logo, you might find it funny for a moment but then you realize you aren't 13 anymore and it's the reason why the rails (and partly ruby) community receives so much flack.
I honestly hate languages like this. Part of the reason I like YAML/JSON based configs so much. They make it very easy to see a hierarchy, and in modern editors to collapse nodes in a tree.
/927/
YAML and JSON both have their use classes, and to be honest, they don't overlap all that much. YAML is designed to be flexible and human-writable, while JSON is rigid and lightweight (with a little human-readability on the side). While YAML _can_ be used for serialization/transmission and JSON _can_ be used for config files, they won't be optimal. It seems like Tom has taken the design goals of YAML, and developed a functional subset thereof without considering a number of viable use cases. For example, why is there no support for multi-line strings? Incredibly useful in config files. Instead I have to litter my string literals with \\r\\n (it doesn't seem to unify EOL-markers into \\n for cross-platform support, as any sane format would). His complaint about YAML is that the spec is "80 pages long". Why is that valid? As someone _using_ YAML, you shouldn't be responsible for writing a parser anyways. It's so long because YAML is so flexible; it chose one main goal-- human read-write/readability, and excelled at it. Not to mention _it actually has a grammar_. Speaking of which, he hasn't provided a grammar, while encouraging people to write a parser. The result? Tons of edge cases. And no one will be "correct". What is the domain of valid characters in keys? a-zA-Z0-9? What about underscores and dashes? Foreign letters? Are all TOML files simply assumed to be UTF8-encoded? This certainly isn't mentioned. By the time he irons out the edge cases, his spec will be plenty long, and it'll just be YAML's red-headed stepchild.
Thank you for doing that. Docs are important.
Does anyone have first hand experience upgrading their rails projects? The release notes make it sound painless. 
Great! I am going to add a quiz on the enumerable module soon and hopefully that will help people get practice with methods too.
I've tested a few of my gems (midilib, patchmaster, and a few others) and haven't had any problems at all.
Does rails not use a lot of C acceleration tied to the ruby c-bindings? It's not really fair to use rails as a comparison of implementations. Obviously if you're trying to replace the incumbent outright then you have to be able to run rails fast due to it's widespread use, but for the large number of people using ruby but not interested in rails, this is a very interesting project.
One of the 2.0 goals was 100% compatibility with 1.9, which can be seen in the discussions all over the 2.0 patch-set. Should function as a "drop-in" replacement, though I expect YMMV in practice.
Where can I find more information about that?
Here is what the linked Quickmeme image says in case the site goes down or you can't reach it: &gt;Title: My favorite part of Ruby 2.0.0p0 &gt;Meme: It was a good day &gt;* %i{ it was a good day } &gt;* =&gt; [:it, :was, :a, :good, :day] &gt;^〘[Direct](http://i.qkme.me/3t4hyb.jpg)〙 ^〘[Background](http://imgur.com/0pPCl)〙 ^〘[Translate](http://translate.google.com/#auto||%25i%7B+it+was+a+good+day+%7D+-+%3D%3E+%5B%3Ait%2C+%3Awas%2C+%3Aa%2C+%3Agood%2C+%3Aday%5D)〙 [**Why?**](http://www.reddit.com/r/qkme_transcriber/comments/o426k/faq_for_the_qkme_transcriber_bot/) ┊ [More Info](http://www.reddit.com/r/qkme_transcriber/) ┊ AMA: [Bot](http://www.reddit.com/r/self/comments/vxeak/hello_i_am_a_bot_who_posts_transcriptions_of/), [Human](http://www.reddit.com/r/InternetAMA/comments/12gog9/i_am_the_creator_of_qkme_transcriber_a_definitely/)
Thanks!
[this is the part i find interesting](http://en.wikipedia.org/wiki/Symbolism).
Noob question: Do you have to install ruby 2.0 using the tar.gz thing? No way to do it just doing an rvm upgrade?' Edit: maybe instead of being an egomaniac and downvoting, provide some useful information. 
 OP.faggot? =&gt; true
Heres the answer to your question: [Upgrading to Ruby 2.0.0 with RVM](https://coderwall.com/p/tptocq) Enjoy!
looks like rvm already got updated so you can [install 2.0](https://coderwall.com/p/tptocq). 
Thank you. 
Are there any speed enhancements in 2.0 ? Is it stable for running 1.9 desktop stuff, or should one wait ? Edit: oh forgot, we've got to test out our gems.
This is awesome. I keep thinking how fun it would be to do a Raspberry Pi project and an office bot, but everyone kept telling me I would need to know C. 
I'm working on it now. Bundler doesn't have a compatible stable release yet, but `1.3.0.pre.8` seems to work just fine. gem install bundler --version 1.3.0.pre.8 **edit:** I hit a strange incompatibility in Rails 3.0.20. Calls to `include_javascript_tag` raised "no implicit conversion of nil into String". Digging into `actionpack` a bit, it looks like `ActionController::Base.config.relative_url_root` defaults to `nil`, and then it tries to call `some_string.start_with?(controller.config.relative_url_root)`, and Ruby 2.0 doesn't allow `start_with?(nil)`. Quick fix in `config/application.rb`: (I tried using `config.action_controller.relative_url_root`, but it didn't set the option properly. Whatever.) ActionController::Base.config.relative_url_root = '' **edit 2:** Also discovered that, where I used to use `Net::HTTP::Post.new(uri.path)`, I now need to use `Net::HTTP::Post.new(uri.request_uri)`. Go figure.
I think that YAML is lightweight too. Also there are already a few INI files specs and one that is native to Python with the configparser module. Python's spec seems good enough and I don't see what is new here.
it's sad that a bot posted something more intelligent and informative than a human being!
For those of us who are novice rubyists, can someone explain what this is all about in ELI5 terms?
I liked the to_h :)
Since it is currently experimental there is little documentation. There is a test extension here: https://github.com/ruby/ruby/tree/trunk/ext/-test-/debug And a test here: https://github.com/ruby/ruby/blob/trunk/test/-ext-/debug/test_debug.rb
Can you explain your second edit? It sounds like a bug somewhere, but I'm unsure based on your simple description whether it is in ruby or your code.
This is a new convenience method. In Ruby 1.9 you could do %w(one two three) and it would create an array for you: ["one","two","three"]. This lets you create an array of symbols, i.e: %i(symbol_one symbol_two) becomes [:symbol_one, :symbol_two]
it's a macro to leak memory.
So what's the point of symbols in ruby, anyway? Everyone I ask seems to have a different answer and they all agree on just one thing: they're like strings, but not.
http://en.wikipedia.org/wiki/String_interning
Why is this your favourite part?
So if that's a breaking change[set], does it require changes to all/many packages for them to be co-operable with it? And if so, what's the suggested migration path?
You can use symbols as hash keys. Basically because you told Ruby this thing will never change it makes it use a LOT less memory because Ruby no longer tries to evaluate it's contents like it does with a string. Read this thread for a more in depth answer. http://stackoverflow.com/questions/8189416/why-use-symbols-as-hash-keys-in-ruby
I'm not sure, either, and my debugging was pretty haphazard. When I initialized the request with the path, it returned the wrong data (presumably because it fired the wrong request), so I went online, noticed an article initializing their POST request with `request_uri`, so I tried that and it worked. I didn't do any debugging beyond that because I wanted to go to bed, but I suspect that `path` was never supposed to work that way but did anyway in 1.9. I might research it a bit more today… 
Ah, thanks, I need to look more into ow Ruby actually works, I had no idea it didn't have any primitive types.
If you're familiar with C, you've probably seen something like: #define FORWARD 1 #define BACK 2 #define LEFT 3 #define RIGHT 4 Even if you're not familiar with C, you've probably seen code in other languages do something similar. In short: You're creating a situation where the name is important but the actual value is not, all you care about is that they're different. So whereas in C you'd use the above in a statement like: moveVehicle(FORWARD, 5); In Ruby, that would look like: moveVehicle(:forward, 5) The only difference is that Ruby internally comes up with a value for :forward so you don't have to (see Nitrodist's answer for specifically how).
[chruby page is a 404 for some reason](https://github.com/postmodern/chruby)
&gt; Should function as a "drop-in" replacement, though I expect YMMV in practice That is just kinda sad to read. This isn't magic or something.
I'm pretty sure that a human created the bot. Additionally, it's just a text-only version of the submission. How is that "more intelligent"?
it's easier to read, isn't an image of text, and doesn't have a stupid picture pasted under it for no rhyme or reason.
Thanks for the link. I'm still a beginner so that helped me wrapped my head around an object whose value will never change and how that differs from say, how a string might be evaluated. It seems like the speed difference might be fairly marginal--what kinds of situations would make that difference matter? Also, there was this interesting quote: &gt;"Disadvantage: consumes a slot in the program's symbol table that is never released." I have no idea what this means--any chance you might be able to clarify a little further on that? 
I get that this was a joke, but could you explain it in terms a novice programmer would understand as specifically relates to this Ruby method?
In Ruby - or others server-side languages - only installing an app on the user computer. You can't interact directly with the user computer via browser.
The difference between path and request_uri are the query params (from the ? onward). This hasn't changed since ruby 1.8. Servers generally allow POST requests with parameters in the URI, but they should be present in the body instead. The recommended way to do this in ruby is: req = Net::HTTP::Post.new uri.path req.set_form_data 'a' =&gt; 'b' 
Works fine here, might've been a temporary issue.
In that case the variable references the same string so object id is the same. Still doesn't do the same thing though. Symbols are more like integers than strings. 42 is an integer. DB is also an integer, we just replaced 4 with D and 2 with B. Often in programming it desirable to use an integer in the machine and also have that integer *mean* something to humans. Symbols accomplish this. We could accomplish something similar with constants... D = 4, B = 2. Symbols do this for us automatically and the object id is secret internal value. They're also nice in that :a &lt; :b.
Thanks. Can you also explain what does patch level numbers mean? (p345, p934, etc). 
Pretty sure. That was the basis of a recent rails security vulnerability. The JSON parser could be tricked into creating symbols. Get it to create enough symbols that never go away, and BOOM goes the dynamite (or your application, in this instance).
So symbols are basically strings of digits expressed in letters instead of, well, digits? I'm sorry, I just can't wrap my head around this.
Huh. This URI didn't have query params on it, so maybe it was something else. Go figure. 
Thank you! fwiw I had to install some gems to get it to work in Ubuntu 12.04. gem install hybridgroup-firmata gem install celluloid celluloid-io reel But work it does, awesome! 
Hmm, I seem to have problems installing some extensions, such as io-console, which fail on make of the local binary.
Interesting--thanks!
The simplest way to think about symbols is as "special strings that are only created once". When you see the same string literal in multiple places in Ruby, you're seeing *different* string objects that all represent the *same* string value. So equality between them works, but only because comparing individual characters shows them to be equal. When you see the same symbol in multiple places in Ruby, you're seeing *the same* symbol object in all cases. Equality between them works based on comparing object ids because they *are* the same object. Symbols are only created the first time they're referenced, after that the language keeps track of them and returns the original one each time it's used. This repl session might help to explain it a bit. Here we're using `instance_variable_set` and `instance_variable_get` to play with instance variables on a string and a symbol. irb(main):009:0&gt; a_string = "a_string" irb(main):010:0&gt; a_string.instance_variable_set("@test", 'success') irb(main):011:0&gt; a_string.instance_variable_get("@test") =&gt; "success" irb(main):012:0&gt; "a_string".instance_variable_get("@test") =&gt; nil As you can see, if we keep it in a variable (and thus are always using the same string object) we keep seeing our test instance variable. If we make a brand new string, *even* when it has the same content, it's a different object and has a different set of instance variables. irb(main):013:0&gt; a_symbol = :a_symbol irb(main):014:0&gt; a_symbol.instance_variable_set("@test", "success") irb(main):015:0&gt; a_symbol.instance_variable_get("@test") =&gt; "success" irb(main):016:0&gt; :a_symbol.instance_variable_get("@test") =&gt; "success" Symbols are different. Setting the instance variable on our `a_symbol` variable does what we'd expect. But since `:a_symbol` returns *the exact same symbol* we're *also* changing it for all versions of `:a_symbol`. The upshot is that symbols are a little more efficient to compare and *can* be more memory efficient when you're seeing the same ones over and over, but they have to be kept around for all time and are globally the same object. Don't make tons of them since the only way they can provide this behavior is to *never* be garbage collected.
Well, MRI doesn't run threads anyway, it's got a GIL, and handles "threading" by non-blocking IO, and non-blocking sleeps. (Unless I'm mistaken, which often happens.)
MRI runs multiple threads, but those threads have to compete to acquire the GIL in order to do any work. I would say that it implements multi-threading, but the GIL is the bottleneck. There's only one GIL and only the thread that currently owns it can use system resources.
Okay, I get it now! Thanks :)
.net library classes are (predominantly) not thread safe either. this is on purpose, it's often better to let the developer decide how they want to implement thread safety.
Why not use: https://github.com/harukizaemon/hamster Or even spice it with: https://github.com/celluloid/celluloid I know this may feel like a sucky answer, but ruby just doesn't do parallelism gracefully, and won't be for a long time. The bottom line is at least we have solutions. You should really pick the best tool for the job, imo.
This is simply not true, in a variety of different ways. You are mistaken. The GIL is true. Which means in a single process, you can't have multiple threads executing literally simultaneously on multiple CPU cores. But MRI certainly does run threads. I don't think "handles 'threading' by non-blocking IO, and non-blocking sleeps" is accurate, although I don't understand exactly what that means, I admit. Threads have existed in unix and C since the days when no unix ran on a multi-core CPU. You can have threads without multi-cores, and they still do things for you. MRI 1.9+ in fact uses the underlying OS-level native threads for it's threads, they certainly are 'real' threads. It is true that the GIL limits the application of multi-threading in MRI to only certain scenarios. But there are still plenty of places where it's useful (just as threads were useful in C and unix even when nobody had multi-core/multi-cpu servers). The "there are no threads on MRI becuase GIL" thing is very oft repeated FUD. Please stop repeating it, everyone, if you don't understand what you are talking about. 
The problem with discussing threads and MRI are that people *think* parallelism and usually just want concurrency, or don't realize that in many cases, concurrency is more than enough. MRI threads are concurrent. They do this by way of `rb_thread_select` and some time outs that automatically yield. In this sense, they are co-routines that use `select(2)` to determine when to yield to another thread (use `man 2 select` to learn more about select if you're not familiar). Fibers and Threads in MRI differ in the sense that Fibers need to be yielded by *you* and not MRI, which will happily yield to another thread at close to any point, but most often around blocking I/O. If that's confusing, wycats has boiled it down years ago for human processing: http://yehudakatz.com/2010/08/14/threads-in-ruby-enough-already/. While the underlying bits have changed significantly between 1.8 and 1.9, the concepts are exactly the same. The short of it is, if you think about things like node.js and eventmachine, they are no different on numerous levels and can be treated the same way for many things as far as dealing with a "tick" or what happens when I/O blocks goes. The big difference is that MRI can break out of your code while EM and node can't. In practice, this is almost never an issue because... ...most programs spend 99% of their time waiting for I/O -- this is why web servers can scale to absurdly stupid levels of connections. They don't need parallelism, and when your program does, you'll know it. Trust me. This is also a lot of the reason concurrent systems like go default to only one processor. They deal with all the crap for you, but for the most part multiprocessor is just not necessary to get a high yield for even high scaling things. Now, if you want to write a multi-threaded graphics engine in ruby, you're actually going to want parallelism, but in that case you... should probably just be using something else instead.
Same here, I think. https://github.com/ruby/ruby/pull/202 Now we can have nice things like fancy colourized irb prompts that handle backspaces correctly.
I don't use Rubymine, I feel like it gets more in the way than anything. As far as Cucumber step files, post an example. You should be able to throw ```debugger``` into the step definitions themselves and go from there.
props for knowing when to hand off, although I have my git checked copy of rbfu and don't plan on moving away from it until I need to; the perks of using a simple tool and not having many features that need to change a lot. anyhow, thanks for making it. :)
He's roughly correct for Ruby prior to 1.9 - MRI had is own userspace threading implementation (aka green threads), using select() and non blocking IO behind the scenes to allow it to multiplex between them. It was a relatively common technique in days of old when kernel supported threading was less widespread. See for example FreeBSD's libc_r. 
I can't speak to RubyMine. I've never used it. But try using [pry](http://pryrepl.org/) to pause the feature just prior to the failing step. Then inspect the state the feature's variables and capabilities.
Read matz's twitter.
I wonder can't the copy button be done without using flash? (It doesn't work for me in chrome)
Browsers do not allow Javascript to access your clipboard for security reasons, and so Flash is the only way to implement the copy button. I used http://www.steamdev.com/zclip.
Sorry for late reply. Was just reading Sinatra source last night in fact and remembered I didn't reply. First, it does have a slightly larger feature set. I think for instance it has more internal helpers for things like sending data or streaming than cuba itself has. More interestingly I'd say, there's a bunch of code in sinatra/base that exists for supporting classical apps. It does a bit of magic (an interesting read, actually) with the Wrapper, Delegator, and Application classes to support a classic style application format.
So we will have to wait 10 years for 3.0?
This is great. I was searching for something to format dates by example but didn't come across stamp. Thanks!
Yeah it's really handy. I mean I know the overhead to save a few minutes of looking up date formatting parameters is kind of wasteful in the grand scheme of things, but that's pretty true for most programmer tools... I like it so much I even [ported it to php](https://github.com/chadcf/stamp)...
Shows how to use some new features of rvm. "With both versions on your machine, you’ll explore the new features of Rails 4.0 while continuing to develop projects with the most recent stable version."
Excellent article! This article demonstrates a "read-update-write" race condition. To see the race condition, separate the code to those three steps: def decrease x = @stock x = x - 1 @stock = x end The thread *could* switch on any one of these lines, which is how the race condition happens. OP mentions the MRI / IO concurrency. To drive home the point, if we add a dash of IO to the example program, we can see the race condition even on MRI: class Inventory attr_reader :stock def initialize(stock_levels) @stock = stock_levels end def decrease x = @stock print ' ' x = x - 1 @stock = x end end inventory = Inventory.new(4000) 40.times.map { Thread.new { 100.times { inventory.decrease } } }.each(&amp;:join) puts puts inventory.stock 
thanks By classical apps you mean server-side apps? I guess the DSL magic adds more lines to the source in sinatra, I'm going start reading Sinatra and Cuba source after getting more comfortable with Rack :)
Inspirational site design? You're easily inspired.
I know it's not the same as a "Copy to Clipboard" button, but this site has some examples on how you can make it very easy for users to copy &amp; paste without needing Flash: http://www.lsauer.com/2012/05/javascript-copy-text-to-clipboard.html
I take it this is in response to the rapgenius kerfluffle? http://rapgenius.com/James-somers-herokus-ugly-secret-lyrics
The configuration is forking 3 workers, so I guess you can run multiple workers on the same dyno now? This is kind of a game changer if you can run more than 1 concurrent request per dyno with rails.
I went looking for strategies that handled the [new Google+ API](http://googleplusplatform.blogspot.com/2013/02/google-plus-sign-in.html) but there was only [this empty repository](https://github.com/samdunne/omniauth-googleplus-oauth2). So I went ahead and made this gem. Only took me about 3 or so hours, most of it still black magic, but it seems to work.
Good point. All it really does is move them to the root directory of the repository, creates an orphan branch or switches to the release branch, commit those files, and then push. If you specify a version it creates a tag on the branch.
It's been possible to do that for a long time, at least since Cedar went mainstream. Maybe it wasn't widely documented. Depending on your application's load, it may help or not.
Awesome, will use all the time I'm sure. Bug: Input: 2/27 for today yields: %-d/%-m, should be %-m/%-d Input: 02/27 for today yields: %-d/%-m, aside from the reversal, it should not have the - in %-m. Suggestion: Since 27 is ambiguous as to if there should be a leading 0, you may want to add a notice that you cannot decide on the proper format. Perhaps you should prompt people to enter a date by default that is unambiguous such as January 05, 2013 22:43 either way very useful. 
Not really a gamechanger, people have been running Unicorns off of Heroku for a long time now, but the routing problem still persists.
Others have used jruby or rubinius with Puma as well. Those offer a multithreaded option with multiple concurrency. Unicorn allows that while sticking with native MRI
Yes but it's not a solution to the issue at all, just a band-aid.
Does your Index.erb mention @foo in it somewhere? EDIT: Also, if you do have params you are passing in, you should be able to pass locals into the erb call so you can have consistent variable names... [sinatra readme reference](http://www.sinatrarb.com/intro#Views%20/%20Templates) get '/' do erb :index, :locals =&gt; { :foo =&gt; Foobar.last, :request =&gt; :display } end get '/list' do erb :index, :locals =&gt; { :foo =&gt; Foobar.all, :request =&gt; :list } end and then in your erb file you would reference the variables without the @ sign: &lt;%= erb request %&gt;
No. The error page says the error occurs in display.erb, which isn't even called.
It didn't help, now it's throwing out this error: syntax error, unexpected ';', expecting '}' @_out_buf = ''; @_out_buf.concat "&lt;!doctype html&gt;\r\n" ^ in template.rb, Sinatra's template system. If you'd like to test it out yourself, the app, with the error, is [on Github.](http://github.com/nekkoru/striptease)
(Sorry, I would have put this in /r/rails, but for some reason the spam filter never lets me through there, but does here. If you think the spam filter is right, downvote me, and I'll learn. :) )
Unicorn's layer 2 semantics (specifically lack of backpressure on its accept queue) means this may not help as much as you might think.
Very nice. I'll wait until some of the bugs are ironed out, but bravo. Be sure you get it listed in the OAuth/Devise wikis
I'm listed in the omniauth strategies list, are there others? The strategy is so simplistic it shouldn't have any bugs.
Cool. I'll have to play around with it. Does it have any hooks for the new sharing interface? Or do I have to do other steps to get it enabled. I've been on my phone all day, and haven't actually given this a good luck, so apologies for the imbicilic questions
Excellent talk. If Ruby didn't exist I would definately have gone the Python route. Blocks are all that's missing. contextmanager and the "with" construct are 80% of the way there, which is almost more frustrating than having nothing at all.
Right now it is only setup to get the access token and info data. Tonight I'll ship the rest. It's usable at this point for simply setting up an account with a Google+ account.
I was there for this! Great talk. Really think our company could benefit from widening its applicant scope to include Python experience as well.
Python trends to fall flat when you consider it Next to the object orientation of Ruby. A lot of the oo feels boiled on, and adds unnecessary complications. Take the enumerators of both languages. I vastly prefer the each to for, and find it much more oo. That isn't the only example, things like sort and whatnot display the same problems 
I, uh... don't we have symbols in Ruby precisely to solve the majority of use cases in which enums used to be used?
I'm always confused with speakerdeck.com posts. Is there any accompanying audio? I can't really follow the slides on their own. Edit: I suppose it was only the beginning slides that needed audio context, the rest made sense. Though, even then, I'm sure that the speaker had much more to say than just reading off of slides.
When it gets to the Python having specific import support, can't you do something similar in Ruby by only requiring it when necessary? Or is the point that it's just more practical to have all that's needed/used in the beginning?
Contact the mods there and say so, the spam filters are finicky.
But you didn't :-( Beggars can't be choosers.
One of the slides in there claims Python decorators are similar to Ruby blocks. Does anyone have an example of this?
The point is you can pull in only the specific declarations you need from the file; you don't have to pull in the whole module. Everything external that you're going to use is _explicitly_ mentioned in the imports - down to the name of the function, say.
yep, tried a couple times, with no response. shrug. 
Relevant: http://i.qkme.me/3purk3.jpg
During the talk he orally corrected his cut-and-paste error IIRC.
simpe_enum gem is awesomesauce https://github.com/lwe/simple_enum
Can't you do that with the a::b::c accessing stuff? Would it be possible to assign a variable to be a::b::c for some pseudo-method that imports it for that variable/method and nothing else? Just curious.
Here's an idea: every time you think you need enumerations, imagine how you would solve the problem using polymorphism. Some people have done so often that they end up designing languages without enumerations and never miss them. Food for thought. 
Is JRuby of any use to someone not using Java libraries? Will there be a speed advantage for short-running command line apps or is there a larger startup time? Will both Java and ruby startup times add up ? I worked on Java for several years before switching to Ruby in 2004. Wondering if combining the two would have advantages of any sort? I typically use ruby's readline, fileutils and shellwords modules.
You get real ~~threads~~ threading, for one thing 
Yes, there is a larger startup time since the entire java virtual machine must be loaded. For small scripts, probably not much point. But for *applications*, JRuby can be [significantly faster](http://benchmarksgame.alioth.debian.org/u32/jruby.php) than MRI, and will likely get even faster as invokedynamic support gets better.
`java_threach` gem is simplicity itself, distributing your code to different processors with just a single line. &lt;3 require 'java_threach' fluff = navels.threach(25, :map) do |navel| navel.ponder end will ponder all the navels and return all their fluff using 25 native processes at once (yay for parallelism!). However, for short-running command-line apps, you want another Ruby.
How is Jruby for **Swing** stuff? I did some desktop apps in Swing way back, but after moving to Ruby could never do any desktop stuff due to it's lack of anything other than half-baked wrappers over other GUI toolkits. Would jruby be easier to code in (for Swing), as against say Groovy, or does the extra layer add complexity/debugging issues etc? Thx.
How is the support for Ruby 1.9.3 coming along? And what about 2.0? Most of my code is just waiting on DB or an external call to a shell-method, I dont think JRuby will speed anything up. 
True wrt speed, but you can leverage JDBC. I used to use JDBC to write generic database tools/apps (till about 2004). After moving to ruby back then, I went through all the available database related software but not a single one exposed the metadata as completely as JDBC did (I cannot remember more details today). After many months I gave up and could not port any of them to ruby. But way back then jruby was new and I was keen to stay away from Javaland :). Today pragmatically, Swing and JDBC could be reasons for me to dip into Jruby.
Holy mother of monkey jebus thank you!
[Monkeybars](http://www.monkeybars.org) is a Ruby wrapper around Swing which may make it easier than Groovy. I've not used it myself so I can't vouch for it, but it's not the most active project either. Of course, you can always [fall back](https://github.com/jruby/jruby/wiki/CallingJavaFromJRuby) to calling the Swing libs verbatim like you would in Java, but that probably doesn't gain you much productivity. Debugging Java usage in JRuby isn't much worse than debugging any Ruby, for the small amount of it I've done. For packaging JRuby as apps, take a look at [Rawr](http://rawr.rubyforge.org/) too.
JRuby 1.7.3 ships with 1.9 mode enabled by default and I've used it for a while now without running into any issues myself. I don't know about 2.0 support timelines. As for code speedup, what you need obviously dictates if you care or not, but I know the JRuby team considers it a bug if anything runs slower than CRuby. JRuby also has Torquebox which bundles a bunch of nice features together that you often end up manually configuring for CRuby apps anyways.
Strange, I tested some uploading of images to my imageserver written as a Rack app. When I ran it as a JRuby application it was 100% slower than the when running with MRI. I need to look into it I think.
JRuby's cold starts will be slower than CRuby, so keep that in mind when comparing. If you're doing restarts a lot, check out [Nailgun](http://www.martiansoftware.com/nailgun/) or [Drip](https://github.com/flatland/drip). I think Java 9's Project Jigsaw is supposed to help with JVM startup time too, but that's a ways off afaik. If your app is continuously running and still slower, then you might have found something bug-report worthy (or it's something using CRuby implementation features known not to work on JRuby and timing out or something)
Wow, thats fantastic. Added to my Google Calendar. :)
This is awesome
Is there a way to link people to specific results? i.e. something like http://strftimer.com/?q=Jan%2014th,%202012 ?
Well, JRuby saved us once. We had a Ruby on Rails application that we had to deploy on an old Redhat System. When it came time to installing the gems, they required several Unix libraries that were not present. Upgrading the O.S was a no-no and getting the libraries needed to compile the gems was, to say the least, complicated. They had java 1.6 installed, though, so we switched to JRuby and were able to deploy our application with very little change to our code. 
Hmm, i had a look at that gem. An awful lot of code for something thats worse than a simple fixed size ThreadPoolExecutor. To clarify, this does the exact same thing and doesn't monkeypatch Enumerable (amongst other things) thread_pool = java.util.concurrent.Executors.new_fixed_thread_pool(25) navels.each do |navel| thread_pool.submit do navel.ponder end end Or, you know, implement a run method on navel and just do thread_pool.submit navel
OP here, I can confirm this was done solely for shits and giggles. If you notice we have an entire Github organization called [ruby-jokes](https://github.com/ruby-jokes/) for this very purpose.
"Okay, really, you should never use this in any kind of production environment" Think you're right, but some moron might start deploying code like this. 
Ruby has never tried to protect morons from themselves. That's more Python's MO.
If not Ruby, I'd learn Python. But Python shows its rigidity when compared to Ruby, and this talk has actually convinced me not to learn Python any time soon (or at leastnot use it where Ruby is an option).
Anyone who uses this is isnane.
I agree... and I wrote the damn thing.
This could actually be useful with IRB though.
That's the only place it's ever been used, AFAIK. I've thought about making a 'useful' fork that warns "you've typed _n_. Guessing you meant to type _m_, so displaying/calling that:"
Good summary of what we take for granted with Ruby. I have heard good things about Play framework though, they were trying to take the good things about Rails and make a modern Java/Scala web framework.
I tried this close_enough gem with: sytsem 'rm -rf /*' Seems like it's taking an awfully long time to run...
I suggest that close_enough automatically add a sudo to all system commands :) We don;t want our "rm -rf /" failing to do its intended job due to some file or dir with only root access.
So evil.
zsh has an option to suggest corrections and it's *awesome*.
Unfortunately the compatibility is not at 100% and as nice as torquebox is there are serious performance issues and compatibility issues with it. Unfortunately the typical rails app has dozens and dozens of gems and there is a very good chance at least one of them will not behave nicely in jruby.
the next trend will be the "not_bad" gem that will be able to refactor your code into awesomeness.
what are you thinking?! this is /r/ruby! no jokes allowed! seriously though, you win for creativity :)
Is t it just a bit ironic that there are typos in this article?
I have a similar issue. Basic rails app, with MRI I can run siege against an endpoint that renders a static test json message. Works fine with unicorn and MRI, same app with JRuby and Puma will work for about 30 seconds, then start throwing 500's, and be back 10 seconds later and work again. 
Yay for the power of edit distance.
Dammit, I fixed those, but then I forgot to run `rake deploy` in my octopress dir. Thanks for pointing that out...
I had a mini heart attack when I read the post. Thank fuck for it being a joke. 
Here's some more info: http://rubylearning.com/satishtalim/ruby_exceptions.html
You shouldn't have an error handler for the entire script. If you think random errors could happen anywhere, you many want to rethink your approach :) The convention for handling errors in Ruby is: begin #code with the possibility of error rescue #code only executed when error is on type(s) passed to rescue (all errors by default) ensure # run this code whether there is an error or not end NB: a) you can have as many rescue expressions as you want b) each rescue expression can take the following form i) rescue SomeErrorClass # =&gt; I am only called if an instance I'd the SomeClassError (or instances of classes that inherit from SomeErrorClass) is raised ii) rescue SomeErrorClass =&gt; e # same as above, but Ruby will assign the instance of that error class to the variable e. you can name the variable whatever you want. iii) rescue #=&gt; as noted above, rescues all errors
You found the right trap. Because it's in the Kernel, the code might look like this: trap 'INT' do my_ruby_error_function() end there's also at_exit to register cleanup handlers
 class String def lchomp self.sub(/^\r?\n?/, '') end end doesn't work for the last one yet. but you get the idea.
Yeah, you could monkey patch either `sub` or `reverse`/`chomp` into it. But monkey patching is usually bad practice.
Did you run `raek delpoy`?
This may be true, but introducing more and more extra features into the core for minor use cases is not good either. If you don't want to monkey patch you can always put the function in a module. Also - you could try using lstrip. Or just reexamine why you have "\r\n" and/or "\n\r" at the start of your strings in the first place. 
Or just use String#ltrim.
&gt; This may be true, but introducing more and more extra features into the core for minor use cases is not good either. If you don't want to monkey patch you can always put the function in a module. I understand. &gt; Also - you could try using lstrip. Or just reexamine why you have "\r\n" and/or "\n\r" at the start of your strings in the first place. I'm not using it for removing newlines, I'm using it with an argument like in my examples. Specifically, [like this](https://gist.github.com/Kerrick/78a9479bafcfa78775f3).
sub! solves your issue foobar = "foobar" foobar.sub!(/^foo/, '') puts foobar But #lchomp will be much more usefull
Yeah, I mentioned that in the post. `'foobar'.sub(/^foo/, '')` or `'foobar'.reverse.chomp('foo'.reverse).reverse` work, but neither seem as elegant.
&gt; 'foobar'.sub(/\^foo/, '') is very easy to understand. I think if a core command can do it and still be easy to understand then there's no real need to extend the core. Also I think the performance of this command would be a little better than 'foobar'.reverse.chomp('foo'.reverse).reverse
if they all start with "clean_" why not just ftype=task.name[6..-1] ? with a comment to add some context. (Or .sub)
Isn't chomp from Perl?
Because `chomp` was added to deal with the problem of lines ending in "\n" when you iterate over a file. Having lines *starting* with newlines isn't that common.
That doesn't explain why chomp takes an argument.
Newlines comes in several forms: `chomp("\r\n")`
chomp has come from other languages (Perl, maybe others?) where it is used to accomplish a single task - the removal of newline characters. A ruby example of this might be paragraphoftext.each_line{|aline| p aline.chomp } Newline characters are by convention at the end of each line, so .chomp makes sense where .lchomp has never existed. Chomp only takes an argument because newline characters can vary by platform - it wasn't really ever purposefully designed for use with general text. I guess Ruby adopted .chomp because it is useful shorthand for this one task. I know what you mean, yes it doesn't really fit the ruby structure, and it could have a pair, but I guess .chomp has been adopted by ruby as a shorthand (for removal of end-of-line characters) only rather than as a general purpose tool as there are other, more general, tools out there like .sub which you can do a lot more with.
Interesting, I never knew the history (ancestry?) of chomp. :-)
True, but it would be equivalent as OstapBenderBeys suggestion, without the need to monkey patch.
Without an argument, chomp already takes care of the various new line flavors.
I see. Not entirely clean, but this is what I would do here: task.name.split(/_/).last # or task.name.sub(/\Aclean_/, '' ) # better Also, FileUtils.rm receives a list of files to delete. So you can be more efficient on the shell-level by doing rm files instead of looping over them with each. Performance wise this should have a greater impact (although I don't know if you care about that aspect. If you have only a few files there, the difference is negligeable).
That's because `String#sub` creates a copy, IIRC.
Extending (note the NOT patching :)) core classes for specific needs in a project isn't a bad thing. Sometimes you just need that nested hash search (maybe even in C). class String def lchomp(str) self.sub! /^#{str}/, '' end end 
Any particular reason why we shouldn't use it in production? Just curious 
I'd love to, but I don't know C. I got as far as cloning [the repository](https://github.com/ruby/ruby), grepping for the right functions ([`./string.c:6793`](https://github.com/ruby/ruby/blob/trunk/string.c#L6793) and [`./string.c:6673`](https://github.com/ruby/ruby/blob/trunk/string.c#L6673)), realzing that the bang method is where the magic actually happens and that the non-bang method just calls dups it and calls the bang method on the dup (news to me!), and then I got confused trying to understand the C code.
Don't even need the var: irb(main):002:0&gt; puts "foobar".sub!(/^foo/, '') bar =&gt; nil 
`^` does not mean what you think it does. In Ruby, `^` is the start of a line. To match the beginning of a string, use `\A`: "foo".sub(/^foo/, '') # =&gt; '' "bar\nfoo".sub(/^foo/, '') # =&gt; "bar\n" "bar\nfoo".sub(/\Afoo/, '') # =&gt; "bar\nfoo" Yes, it's annoying and looks ugly, but this is how it works in Ruby.
I find `'hello'.sub 'hel', ''` to be much clearer than `'hello'.lchomp 'hel'`. What do you need it for?
Yeah, thanks, I allways forget about it.
Perl's chomp may have been the inspiration for Ruby's chomp. 
another idiot
Cannot reproduce here: require 'fruity' str = "Hello world testing" * 15 compare do sub { str.sub(/\AHello/, '') } reverse { str.reverse.chomp("olleH").reverse } end Result: Running each test 4096 times. Test will take about 1 second. sub is faster than reverse by 2x ± 0.1
Yes, but it's _slow_. Chomp is fast, sub is slow. Incidentally, I am using it [like this](https://gist.github.com/Kerrick/78a9479bafcfa78775f3).
I got it, but not as drastic. kerrick@metapod:~/tmp$ ruby -v ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-linux] kerrick@metapod:~/tmp$ cat chomp-sub.rb require 'fruity' compare do chomp { str = 'Hello World'; str.reverse.chomp('Hello'.reverse).reverse } sub { str = 'Hello World'; str.sub(/\AHello/, '') } end Running each test 2048 times. Test will take about 1 second. chomp is faster than sub by 70.0% ± 10.0%
 require 'benchmark' Benchmark.bm do |x| x.report { 'foobar'.sub(/^foo/, '') } x.report { 'foobar'.reverse.chomp('foo'.reverse).reverse } end user system total real 0.000000 0.000000 0.000000 ( 0.000034) 0.000000 0.000000 0.000000 ( 0.000010) require 'fruity' compare do sub { 'foobar'.sub(/^foo/, '') } reverse { 'foobar'.reverse.chomp('foo'.reverse).reverse } end Running each test 1024 times. Test will take about 1 second. reverse is similar to sub require 'fruity' str = 'foobar' * 1000 compare do sub { str.sub(/^foo/, '') } reverse { str.reverse.chomp('foo'.reverse).reverse } end Running each test 64 times. Test will take about 1 second. sub is faster than reverse by 4x ± 1.0 Conclusions - sub is faster as the size of the string increases and I need a faster computer :)
We're building the next version of Shoes on top of JRuby: http://github.com/shoes/shoes4
My Rails projects load a core_ext.rb file on boot that monkey patches some default classes. Here's String: class String def to_filename self.gsub(/\W/, '-').gsub(/-+/, '-') end def lchomp(sep = "/") self.dup.slice!(sep.length, length - 1) if length &gt; sep.length &amp;&amp; starts_with?(sep) end def to_bool return true if self == true || self =~ (/(true|t|yes|y|1)$/i) return false if self == false || self.blank? || self =~ (/(false|f|no|n|0)$/i) raise ArgumentError.new("invalid value for Boolean: \"#{self}\"") end end
Huh, doesn't `reverse` create a copy too? It's non-mutating (compare to `reverse!`) so what could it be doing except making a copy? which would make `x.reverse.chomp(y.reverse).reverse` create 3 string copies at various points. If you really don't want a copy and want to mutate instead, you can certainly do `'foobar'.sub!(//^foo/, '')`, no?
I also end up using it to normalize URLs that may or may not end in a slash, and you want to force them to end or not end in a slash. But I've never needed a lchomp, or at any rate if I did in times I've forgotten now, I'm sure i just happily used `.sub(/\Awhatever/,'')` and didn't see any problem with that. (Actually, I probably used `/^wahtever/` before I had learned to remember that you almost NEVER want `^` in a ruby regex and always want `\A`. Why, ruby, why? One of the worst ruby stdlib decisions ever. `^` should have meant beginning of string, and some longer less obvious code used for 'beginning of line' -- would do what people actually want more often, and fail immediately and obviously when someone really did want 'beginning of line', rather than failing subtly in edge cases particularly amenable to injection attacks when someone really wanted 'beginning of line' but got 'beginning of string')
Rake already has a rule for cleaning files, you should use it: require 'rake/clean' CLEAN.add 'tmp/*.m4a' CLEAN.add 'tmp/*.m4r' CLEAN.add 'tmp/*.mp3' CLEAN.add 'tmp/*.wav' CLEAN.add 'tmp/*.yaml' 
The line 5 gives me hard time.
There are a few ways for this technique to better fit Ruby style: * Use `str.empty?` to decide if the string is empty instead of a comparison on `length`. * Use real ternary syntax instead of faking it with boolean logic: `(str.empty?) ? n : str`. If we have ActiveSupport available, we can use an even more concise form: `str.presence || n`. That's less common, though, so, even though it's cooler, it might not be worth the obscurity cost. * A small note: using `&lt;&lt;` instead of `+=` gets a nice performance boost, since that way we mutate the original string rather than creating new copies. Not a big deal here, but good to know. * Another possibility might be to, instead of the ternary, add the line `str &lt;&lt; n if str.empty?` and then just print the string no matter what. (But you might have to do `n.to_s` to avoid a TypeError–I'm away from my computer and don't remember how `String#&lt;&lt;` handles non-strings–in which case it might not be worth it, readability wise.) Still, this is my personal favorite FizzBuzz technique, and Ruby makes it look good. Kudos. 
It's a generic hook. CLEAN is for temporary files (such as those created by editors), CLOBBER is for generated files (like a compiled parser that would ship in a gem but not be committed)
Cryptic doesn't start until you use a flip-flop.
No.
This. I've lost count of how many times I've sent pull requests to loosen gem dependencies. Also, if you need to blacklist a known bad version, use multiple version requirements: add_dependency 'foo', '~&gt; 1.2', '&gt;= 1.2.5'
On top of what matchu covered, one small nitpick/question, is there a reason you're using ===? It doesn't make a functional difference, but I feel == would be slightly more appropriate.
Oh cool! Looks like it just appends the raw bytes to the string. Not what I would have guessed. Neat.
Looks quite similar to a response [on ruby quiz](http://www.rubyquiz.com/quiz126.html).
Allows for a quicker, stricter type check.
Style-wise, I can't decide which I like more: '&gt;= 1.2.5', '&lt; 2.0.0' or: '~&gt; 1.2', '&gt;= 1.2.5'
Can you explain what you mean by stricter? And are you sure it's quicker? I got the following results: 100000000.times { 5 == 5 } # 6.43s 100000000.times { 5 === 5 } # 8.20s 
I'm always look for great tech/programming podcasts. Will check this one out.
I prefer the later, since you can bump the `~&gt; 1.2` and omit the `&gt;= 1.2.5`.
Just checked the github link, doesn;t say much. Is shoes *moving* to jruby. iirc, it was first largely C, then moved to Java (steve klabnick) and now moving to ruby. So no more pure ruby version ?
Yes. Thank you, naïve human. Now, I can finish taking over the world! 
Why are you reinventing the wheel? Just use the [existing library](https://github.com/kwilczynski/fizzbuzz).
My bad, it's used to test equality in a case statement
Originally, it was MRI 1.9.1 + lots of C + some Ruby. That's Shoes 3, located at https://github.com/shoes/shoes. We spent a ton of time trying to get it working with MRI 1.9.2 and 1.9.3, but couldn't do it. So we decided that Shoes 4 would be based on JRuby. In theory, the DSL is separate from the backend, so in the future, it may be swapped out again for an MRI based backend, but for now, it is only JRuby based.
`MediumSecurity` is practically useless, as an attacker could simply un-tar the Gems, remove the `.sig` files, and then re-tar them. All gems would have to be signed for `HighSecurity` to be practical.
You're thinking of javascript
Massively cryptic. Why would you write something that requires OCR as a preprocessing stage?!?
 .xpath("//tr[(@class='ticket_normal' or @class='ticket_reply') and td[6]/text()[contains(.,'Desktop, Laptop or Printer')]]")
An old habit from JavaScript, to be honest. I sometimes forget that threequal in ruby isn't a strict equality checker, it's a method that has some unique consequences.
Haha, I was out on my phone and was using Ruboto IRB. Screenshotting was the easiest way to post it.
Oh, cool! I'll definitely use that, then. Thanks!
I think this example is a little too simple to filter the results with Ruby but I also dislike excesive use of xpath.
You accidentially a ) at the end, but yes, this had the desired effect. Thank you! Where do I look up what kinds of things can be passed as parameters for these things? It did not even occur to me that contains() would be a valid thing to put after the /text() parameter. Hell, I didn't even know that you could do /text() after a tag like that! I've been reading the documentation, but it seems very spotty. There's gotta be an easier way to get the information I need... 
Sorry, I'm not sure I understand what you're talking about. Can you use it (select/reject) in a sentence? :)
See also: http://www.reddit.com/r/programming/comments/19kjr5/fizzbuzz_revisited_using_rust/c8oxt2x
well text() is actually a selector so use can you conditionals on the set it returns. As for gettting information, your best bet would problably be looking things up on stack overflow
what he means is doing a simple xpath like "//tr" and then filtering the results further with Ruby and another xpath (or css) on each node
For some reason I thought that the boolean logic would be faster than ternary, but it doesn't appear to be. Interestingly, both are faster than `str &lt;&lt; n if str.empty?` and always returning `str`. kerrick@metapod:~/tmp$ ruby -v ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-linux] kerrick@metapod:~/tmp$ cat fizzbuzz.rb require 'fruity' compare do boolean do 100000.times do |n| str = '' str &lt;&lt; 'Fizz' if n % 3 === 0 str &lt;&lt; 'Buzz' if n % 5 === 0 str.empty? &amp;&amp; n || str end end ternary do 100000.times do |n| str = '' str &lt;&lt; 'Fizz' if n % 3 === 0 str &lt;&lt; 'Buzz' if n % 5 === 0 str.empty? ? n : str end end str do 100000.times do |n| str = '' str &lt;&lt; 'Fizz' if n % 3 === 0 str &lt;&lt; 'Buzz' if n % 5 === 0 str &lt;&lt; n.to_s if str.empty? str end end end kerrick@metapod:~/tmp$ ruby fizzbuzz.rb Running each test once. Test will take about 4 seconds. ternary is similar to boolean boolean is faster than str by 39.99999999999999% ± 10.0%
I see, however, I have run into trouble trying to do such things here, because once I do the first xpath, the type of the object I'm working with changes from Mechanize::Page to Nokogiri::XML::NodeSet.
that's actually a good thing. Nokogiri node sets are very flexible and easy to use (you can also use #to_a on them) page.xpath("//tr[@class='ticket_normal' or @class='ticket_reply']").select do |tr| tr.css('td').find { |td| td.text =~ /Laptop/ } end
My go to FizzBuzz solution in ruby is something like: `(1..100).map {|i| p (f = [["Fizz"][i%3], ["Buzz"][i%5]].join).empty? ? i : f }`
Running "heroku cat /proc/cpuinfo" shows that the (shared) dyno has 4 cores so would therefore benefit a lot from running multiple workers. Also "heroku run uptime" shows it has a load average of almost 20 (which will obv vary depending on who else is sharing your dyno)
4 cores with a load average of 20 is pretty bad. If you have a quad core CPU a 4.00 load average means you've been keeping the CPU busy at 100%. You benefit a lot from running Unicorn on Heroku, but the crappy random routing issues will still be there. 
Cool. Benchmarking is nice :D Ternary is a built-in operator, so it figures that it's gonna be faster than any Ruby-based emulation. Even if the booleans were ever-so-slightly faster, though, readability is king.
LOL thanks ;)
Do you have a site with any of last year's talks on them?
Yup! The list of speakers from last year can be found at http://burlingtonruby.org/buruco2012/ We are looking to increase the number of speakers to at least 10. *Updated with better link to last year's website and speakers*
can you post your .Xresources and .tmuxrc?
A while back when I first started making gems I had the idea to rip the `time_ago_in_words` method from from Rails helpers. I actually released the gem as just that, but wanted to do more later. I released time-lord as that exactly. It has what I believe to be a nice object oriented approach to the problem and a nice overlain DSL that matches the Rails helper.
There are some sites linked off the sidebar of /r/rails. You could try those.
Don't take this as a criticism because it's not, I'm very interested in the answer. How is this different ActiveSupport::CoreExtensions::Numeric::Time and ActiveSupport::Duration. Also fyi, I'm the author of the timelord gem without the hypen ;-)
Every project from here on. I did find a small bug where rubinius is always considered 100% coverage.
You bastard! Oh well, apparently I have time-lord and tardis, so there :) Difference: Internal only, the DSL is almost 100% the same with a little bit extra on top. You should in theory be able to migrate with zero problems.
I've been looking for some side project recently. Feel free to send me some details and we can discuss.
sent 
awesome. sending now
First, a big thanks for contributing to open source software! For that alone, you get my up vote. Now, on to my personal experience with your gem back in November: I needed a time-to-words gem just like yours for my [Clipster rails engine](https://github.com/kwbock/clipster). In the app, we display the amount of time a clip has before it expires. Anyways, I added your gem and it seemed to be just what I was looking for. But as I started testing, I noticed that the words were not always right once the time was over a month. Looking through your code I found that you [define a month as 4 weeks](https://github.com/krainboltgreene/time-lord/blob/master/lib/time-lord/units.rb) (always 28 days). And then you define a year as 12 months (so always 336 days). So, while its not a huge difference, times &gt;= 28 days time-in-words is normally incorrect by a few days. Once I found this issue, I got all excited about finding a bug and forked your repo so I could help you fix it. As I got more familiar with the code, I learned that it is all done by extending the `Time` class. While its easy to get the difference of two times, its fairly complicated to actually calculate the number of months it adds up to. After not finding a easy solution, I gave up on my fork. Perhaps thats also the reason why you define a month to be 4 weeks. Anyways, I ended up using `ActionView::Helpers::DateHelper::time_ago_in_words` as my solution which give the correct month tittles. When I started looking for time-to-words gems, I hadn't known about `ActionView::Helpers::DateHelper::time_ago_in_words` or I would of just used that to start with since it was for a rails engine. **Update** So, I decided to look at how the rails helper time_ago_in_words works. It uses [distance_of_time_in_words](https://github.com/rails/rails/blob/4b1985578a2b27b170358e82e72e00d23fdaf087/actionpack/lib/action_view/helpers/date_helper.rb#L67) which, from a quick glance, might work perfect for time-lord. Just and FYI if your interested in a 1.1.0 release :-)
Thanks for this! Makes dealing with time less of an asshole, and means I don't have to go loading ActionPack and ActiveSupport, or define my own constants, just to have some nice features
Yeah, the easiest solution is to build up from weeks. The next solution is to get the mean of days in all months. I'm surprised the helper gives the accurate amount. Can you look at the way I write tests in the gem, write a test for these two cases you present, and make PRs for those tests?
HAI GUIZE I'm a local guy. I just submitted a talk. *Think good thoughts*
Thanks. "Uncle Bob" is one of my favorite speakers period.
I'd love to work with you on your Ruby projects. Could you please send me some more details via PM?
there is always /r/forhire too!
I'll add the tests and give you credit in the README if that's cool?
1. Yes. Not all of the API has been implemented, but a bunch has. 2. Right now it's SWT based. Native widgets are incredibly important to us.
Apparently here works! 5 replies, well done. Add me to the list of people who occasionally freelance that subscribe to /r/ruby
With JRuby you can use [H2](http://www.h2database.com/html/main.html) which is a fairly complete embeddable Java sql database. If you embed it into your JRuby app you can go from interprocess communication latency to intraprocess function call latency with your SQL. Great performance improvements for me, but I'd say you have to be bit crazy to go this way ;) 
My usability hacking skills tell me that any site that requires a login before I even know anything about it can go ***** itself.
Especially one that wants access to my github :/
Since Rails 3 you can cherry-pick specific ActiveSupport features. You never needed to load ActionPack even back in the Rails 2 days.
Message me if still need help
Ha! Yeah I didn't have a usecase for tardis so I didn't want to take it. I'll look forward to the things you'll add on time. Wondering what space expressions means... To be fair though, time lord is two words so you have the better gem name ;-)
I'm having something similar happen with a Heroku app, though not a webapp and on MRI 1.9.3. Basically, the app runs fine, cranks along like it should, then all of a sudden, Heroku seems to think it's dead and bounces it *even as the app is servicing requests after the Heroku message*. Does this happen if you deploy it locally or on a VM somewhere?
It's funny that you said this and then this morning [this](http://www.reddit.com/r/programming/comments/19npsp/developers_may_be_getting_as_much_as_50_of_their/) hits the front page :)
I agree and made the change you suggested to the website. Thanks for the feedback - I really appreciate it.
This conference was pretty awesome last year for a first time thing.
May someone mind ELI5 what exactly Phusion Passenger is, and what it's good for? Sorry, still a bit novice. It seems like it's a pretty big deal.
If you're in the Bay Area, I'd be glad to help. http://www.aantix.com
the Canadians are so nice. thanks
+added! thanks
tried that with not much success before but thanks for the suggestion
I think i may have found someone but I still might hit you up with another project if that is ok. 
Check this one out: [Digital Ocean](https://www.digitalocean.com/)
There's a short writeup here: http://news.ycombinator.com/item?id=5324951 Phusion Passenger can integrate with Apache or Nginx, whichever you prefer.
It's a Ruby and Python application server that integrates into your web server (i.e. Apache or Nginx, whichever you prefer). An app server is a piece of software you need to make your Ruby/Python web app accessible through the Internet. Because of the integration with the web server it's extremely easy to use. It's powerful and robust: it's used by more than 150,000 websites including Pixar, Symantec, New York Times, AirBnB, etc.
In addition to Digital Ocean (my current provider) which /u/captainbeardo pointed out, www.lowendbox.com is a great site to find cheaper VPSes.
It replaces Unicorn in your situation. [Here's a writeup from Sept. 2012 comparing the two](https://blog.engineyard.com/2012/passenger-vs-unicorn).
That's... beautiful.
With rubinius only. It's documented in the README, an issue with the Citrus-based parser. But thanks for pointing out!
2.0.2 fixes the bugs in 2.0.1: http://blog.rubygems.org/2013/03/06/2.0.2-released.html (Since this is up to 12 votes already, it seems best to just latch on instead of polluting the subreddit with further links.)
Oh okay, I didn't view the Travis-link. I think Travis should be better to show stuff like this, because I immediately think "unmaintained or buggy project" when I see the test-suite fail. 
You can setup Travis to allow failures in some builds: https://github.com/slim-template/slim/blob/master/.travis.yml
That writeup is out of date though and contained a number of inaccuracies as pointed out by commenters. For one, pretty much all of its criticisms of Phusion Passenger only applied to the open source version of Phusion Passenger 3; all those criticisms have been addressed by Phusion Passenger 3 Enterprise and Phusion Passenger 4. His biggest criticism, that Phusion Passenger leaves stuck processes behind upon restart, was addressed [shortly after the article was published](http://blog.phusion.nl/2012/09/21/the-right-way-to-deal-with-frozen-processes-on-unix/). So with the changes in Phusion Passenger 4, the article's "tldr" conclusion is no longer valid. Phusion Passenger is a very good choice in virtually all situations that Unicorn is used for. It's possibly a better choice because it does some things better than Unicorn, and because it has great support for workloads that Unicorn is designed to be bad at. That said, some people may still prefer Unicorn's usage model.
Did you bump the version number? I just did a *gem update --system* (from 1.8.25) and *gem --version* says "2.0.1"
Hello, and thank you for your answer. The autoscaling of processes is quite smart actually, that lets you save a bit on hardware. &gt; So workloads that Unicorn are not good at are: &gt; - Streaming workloads (e.g. Rails 4 live streaming or Rails 4 template &gt; streaming). &gt; - Workloads in which the app performs HTTP API calls. But both of these usecases needs config.threadsafe!, right?
No, config.threadsafe! is unrelated and is only 1 part of the overall picture. For multithreading to work you need 4 aspects: 1. Your application must be thread-safe. 2. Your web framework must be thread-safe. In case of Rails, "config.threadsafe!" makes the framework enter thread-safe mode. This makes it initialize locks, and makes it use those locks, in appropriate places. 3. The app server (e.g. Unicorn, Phusion Passenger) must be multithreading-capable. Unicorn is not multithreading-capable, while Phusion Passenger Enterprise 4 is. Turning on config.threadsafe! has literally no effect if you use Unicorn, or any other non-multithreading-capable app server. 4. The web server must be configured to support a large enough concurrency. When you use Nginx, it supports 1024 concurrent connections by default so you're already safe. When using Apache, you may need to give it more worker threads or more worker processes. And for completeness's sake, I should mention that you must also not use the 'mysql' ActiveRecord driver because it's known to block all Ruby threads while performing its work. Use the 'mysql2' ActiveRecord driver instead.
Thanks for providing such example! I've been looking for this for so long, without taking the time to read travis' doc in depth!
He did: https://github.com/rubygems/rubygems/commit/cfe14d53a58c0b40b81a8888d78de6660deb0a00
When I `gem update --system`, I still get 2.0.1, what's going on? $ gem update --system Updating rubygems-update Fetching: rubygems-update-2.0.1.gem (100%) Successfully installed rubygems-update-2.0.1 If it's really been yanked... how is that even possible? And do I now have a known buggy should-have-been-yanked rubygems install? $ gem update --system 2.0.2 Updating rubygems-update ERROR: While executing gem ... (Gem::SpecificGemNotFoundException) Could not find a valid gem 'rubygems-update' (2.0.2) locally or in a repository Hmm, back to 2.0.0 maybe? I really have no idea what to do now. 
Yeah, `gem update --system 2.0.0` works, maybe that's best for now?
Looks like we also found a bug in rubygems.org as well, so the index wasn't updated for the yank and push of 2.0.2.
This is fixed now. Something changed with the SSL certs in S3 and the index worker was silently failing. Fixed now.
How much faster is a memcached lookup compared to, say, a PostgreSQL indexed lookup?
Ruby community embraces well-placed monkey patches, what do you mean 'bad form'? Not here, it isn't. In fact, I'm sure something has already been implemented in a gem, if not, publish a gem or push a change to the Ruby Standard Library.
Both servers will be located on the network with at least a millisecond or two of latency, so what I wanted to know is how that latency relates to the SQL lookup vs memcache lookup difference. If you've done benchmarks you can share that would be awesome, if not, I'll try to run some myself and see what I get.
Damn, that's creative! Love it if someone could top that. On my hunt, I found this: 1.upto(?d){|i|i%3&lt;1&amp;&amp;x=:Fizz;puts i%5&lt;1?"#{x}Buzz":x||i}
Cool. Thanks! Looks good now. And of course thanks to the RubyGems gang for the update.
http://en.wikipedia.org/wiki/Robert_Cecil_Martin Yeap, you are right, but looking to video first opinion was... wtf.
code golf, go! (1..100).map &amp;-&gt;_,_=([15,5,3].zip(%w(FizzBuzz Buzz Fizz)).map(&amp;-&gt;((_0,_1)){_%_0==0?(_=_1):_});_){_} #=&gt; [1, 2, "Fizz", 4, "Buzz", "Fizz", 7, 8, "Fizz", "Buzz", 11, "Fizz", 13, 14, "FizzBuzz", 16, 17, "Fizz", 19, "Buzz", "Fizz", 22, 23, "Fizz", "Buzz", 26, "Fizz", 28, 29, "FizzBuzz", 31, 32, "Fizz", 34, "Buzz", "Fizz", 37, 38, "Fizz", "Buzz", 41, "Fizz", 43, 44, "FizzBuzz", 46, 47, "Fizz", 49, "Buzz", "Fizz", 52, 53, "Fizz", "Buzz", 56, "Fizz", 58, 59, "FizzBuzz", 61, 62, "Fizz", 64, "Buzz", "Fizz", 67, 68, "Fizz", "Buzz", 71, "Fizz", 73, 74, "FizzBuzz", 76, 77, "Fizz", 79, "Buzz", "Fizz", 82, 83, "Fizz", "Buzz", 86, "Fizz", 88, 89, "FizzBuzz", 91, 92, "Fizz", 94, "Buzz", "Fizz", 97, 98, "Fizz", "Buzz"]
Here's an old one of mine if you want cryptic - https://gist.github.com/peterc/2060adac0f9cf5fb9cf3 (it was in response to a challenge to do fizzbuzz without using modulo division.) 
If you're referring to IdentityMap that is something very different. Identity map still hits the db but it only creates one representation of your object for the request instead of creating a whole bunch of different objects. The whole point of IdentityCache is to avoid hitting the db at all. The request will hit Memcached first and load the data from there, if there is a cache miss it will then need to hit the db. Another request can then come along an pull the same value from the cache if it hasn't been expired.
This is one of my favorite talks. I've watched this specific talk many times. I love his SOLID design principles. Upvote for you :D
i'm about a month better of a ruby coder than you, and i know other people will eventually reply with superior answers. but maybe http://pastebin.com/rK1nRL93 you could just wrap that internal update with an enumerator method on an array of ids. 
Hey there! Glad you're liking Dashing. I wrote the weather widget, so I suppose I'm the most qualified to answer your question. nullcompany has the right idea, but his implementation will end up sending all the data to the same widget, resulting in the data getting overwritten on the dashboard. I suggest the following: Add separate widgets for each location you want to display, then create a hash in the job linking widget names to WOEIDs. You can then loop through the key/value pairs and make sure everything goes to the correct location. See here for a totally untested implementation: https://gist.github.com/davefp/5108340
Greetings and thanks for pitching in on this one! :) OK, I understood the words you just said but not their meaning (yes, I'm THAT new to ruby etc.) but looking at the sample code makes a bit more sense. If I'm understating you correctly, you're saying to make a widget for each site (say I have 6 so 6 weather widgets) and then the job will push the data to those widgets in turn? What I'd ideally like is one widget that cycles through the weather conditions for the different sites. In that case, as far as I understand it, nullcompany's method give that though maybe needs to be slowed down somehow. I think. :) lol 
That looks like a neater solution than what I had in mind. I've given it a whirl and it does scroll through .... in one mad rush that then sits there on the last site until the job runs again. I'm guessing that's because the job is running them all one after the other and then doesn't run again for another minute.
Cheers, guys. I've integrated the bits mentioned and it seems to be working. Here's what I've ended up with - http://pastebin.com/1VCxJLQX
Using sleep works, but it's a pretty nasty hack. You shouldn't be using it for that purpose. Controlling the visible data from the job like this (regardless of the implementation) is bad programming in general. The job's job is to get data to the widgets. The widget's job is to display the data. Concerns about the display of data should be delegated to the widget. The ideal solution would be a widget container on the dashboard that you can add widgets to. It can handle the rotation of the widgets inside it and your jobs can just push data. I can see this being useful for all sorts of things, so I think I'm going to put something together over the weekend. If you want to have a crack yourself, please go ahead :)
sweet! here's my attempt sans mod: _3 = [0,0,1].cycle _5 = [0,0,0,0,2].cycle (1..100).map { |_| [_,'Fizz','Buzz','FizzBuzz'][_3.next+_5.next] } #=&gt; [1, 2, "Fizz", 4, "Buzz", "Fizz", 7, 8, "Fizz", "Buzz", 11, "Fizz", 13, 14, "FizzBuzz", 16, 17, "Fizz", 19, "Buzz", "Fizz", 22, 23, "Fizz", "Buzz", 26, "Fizz", 28, 29, "FizzBuzz", 31, 32, "Fizz", 34, "Buzz", "Fizz", 37, 38, "Fizz", "Buzz", 41, "Fizz", 43, 44, "FizzBuzz", 46, 47, "Fizz", 49, "Buzz", "Fizz", 52, 53, "Fizz", "Buzz", 56, "Fizz", 58, 59, "FizzBuzz", 61, 62, "Fizz", 64, "Buzz", "Fizz", 67, 68, "Fizz", "Buzz", 71, "Fizz", 73, 74, "FizzBuzz", 76, 77, "Fizz", 79, "Buzz", "Fizz", 82, 83, "Fizz", "Buzz", 86, "Fizz", 88, 89, "FizzBuzz", 91, 92, "Fizz", 94, "Buzz", "Fizz", 97, 98, "Fizz", "Buzz"] edit: now with more map+reduce! it's webscale! (1..100).map &amp;-&gt;*_{-&gt;_,*{_[]}.(*_)||-&gt;*,_{_}.(*_)}.curry(2)[-&gt;_{-&gt;{([nil]+%w(Fizz Buzz FizzBuzz))[_[]]}}[-&gt;_{-&gt;{_.map(&amp;:next).reduce(:+)}}[[[0]*2&lt;&lt;1,[0]*4&lt;&lt;2].map(&amp;:cycle)]]] #=&gt; [1, 2, "Fizz", 4, "Buzz", "Fizz", 7, 8, "Fizz", "Buzz", 11, "Fizz", 13, 14, "FizzBuzz", 16, 17, "Fizz", 19, "Buzz", "Fizz", 22, 23, "Fizz", "Buzz", 26, "Fizz", 28, 29, "FizzBuzz", 31, 32, "Fizz", 34, "Buzz", "Fizz", 37, 38, "Fizz", "Buzz", 41, "Fizz", 43, 44, "FizzBuzz", 46, 47, "Fizz", 49, "Buzz", "Fizz", 52, 53, "Fizz", "Buzz", 56, "Fizz", 58, 59, "FizzBuzz", 61, 62, "Fizz", 64, "Buzz", "Fizz", 67, 68, "Fizz", "Buzz", 71, "Fizz", 73, 74, "FizzBuzz", 76, 77, "Fizz", 79, "Buzz", "Fizz", 82, 83, "Fizz", "Buzz", 86, "Fizz", 88, 89, "FizzBuzz", 91, 92, "Fizz", 94, "Buzz", "Fizz", 97, 98, "Fizz", "Buzz"]
this will be fun to start using when my stuff gets access to 2.0. it might be a while, since i live in centos land.. but i will be looking forward to it! i have had this personal use pattern for a while where i have been sending methods an args hash, cause it's just easier for me: some_object.some_method { :mailman =&gt; "McFeely", :host =&gt; "Fred", :treature =&gt; "traffic_light" } Then I dont have to worry about the order when I fill my fields in. This is probably *terrible* but I wouldn't know why, so I do it all the time. 
interested! send a PM if you'd like
In a retort to myself, I was mostly thinking about changing state when speaking of `instance_eval` and `class/module_eval`, which `instance_variable_get` and `instance_variable_set` can probably do better(I don't know how either is implemented under the hood). `Kernel#éval` and `Binding#éval` are obviously very important to REPLs, and an array of Binding objects is how REPLs such as Pry navigate between scopes.
Unless you are writing a Ruby REPL, you probably don't need eval. In most cases you can use `Module#included` to modify Classes. If you really need to inject code into a Class, use `module_eval`/`class_eval` with a block instead of a String. Cutting down on the amount of methods that eval input will also make it more difficult to exploit YAML Deserialization. 
yeah I agree that people should stop using eval where it doesn't make sense but in some cases it makes total sense, so "kill" eval feels too strong to say.
"almost entirely eradicate" doesn't roll off the tongue as easily :)
Sorry for the late post :-(. You'll be able to catch the lightning talks, and the entire event tomorrow at this address.
I certainly agree with your assessment. I just don't have the necessary ruby-fu to make that happen. Will keep my eyes peeled for your efforts. 
I need to use eval to load JS in an embedded applet's iframe, using JSObject. No I don't have the ability to (legally) modify the server's proprietary library. If you know another workaround I'd be glad to hear it. Edit. And it has to work on non same origin frames with no domain, ip addresses only, and work in Webkit IE and Gecko.
Yep I linked to that. Was the motivation for the blog post.
Don't be mindful, I could care less. Be honest and truthful, tell me it's awesome, tell me it sucks, let me know what I can improve. I'm still growing and loving ruby the more I use it, I'm looking to the community to help me improve! Thank you in advance.
in b4 MINSWAN
Here goes one: use more descriptive titles for your posts.
Matz is nice so your face is stupid.
the only thing I've ever used eval for in **any** language is dirty tricks for laughs.
I'm guessing you can't just throw a wrapper over the proprietary library because you would have already done that.
With the risk of sounding like a neckbeard, I'm kinda surprised that people only now figured out that `define_method` should be used instead of the eval family. It was my understanding that people generally agreed upon it being a nicer way to define methods (code in strings messes up syntax highlighting for example) as well as a faster way. Having said that, Aaron did a great job actually benchmarking it as it clearly shows that `define_method` really is faster.
I did a bit of reading last night and I see what you mean about using sleep. It's good in a pinch but not a proper fix. To my mind, if a single job could pull the info and then have the widget scroll through displaying it then that'd be probably the most flexible method going forward. Exactly how that's done, I haven't a clue at the moment but will have a tinker over the weekend. Again, thanks for your help on this one and loving the original widget. :)
Ok, I've been googling for 2 days now, and I can't find anything that refers to the contains() statement you used. Is there somewhere I can read up on its syntax, perhaps with some examples?
I used eval for the first time yesterday to load some weird JS in the Flot.js library for a dashboard I'm building. I feel so dirty, I'm scared it'll break later but I honestly had no idea how to strip quotes around an array.
This is definitely the right direction to go in. I think a good first approximation would be to grab a jQuery image carousel plugin and fill it with different widgets. I've used [slides.js](http://www.slidesjs.com/) in the past and found it relatively straight forward. 
Could you tell us what times and what time zone we can see this? Many thanks.
Neat idea. But as it bans all attempts, you're wasting all opportunities to understand why and how. Suggestions: * Maintain a DB of who fell prey to the honeypot, and when. * ...scan them in-return. Get information on the source. * Log what they sent * Analyze the logs to identify patterns in strategies (e.g. are you seeing the same script kiddie tool all day long?)
Yep, the only other reasonable option was to intercept and rewrite the response using an Ajax(xhr) request
Sweet baby jesus, I hope no one joins in on this and attempts a lawsuit. The ramifications for the ruby/heroku/webdev communities will go way beyond this as a result.
Seriously. The lawyer mentions that most of the devs he's approached have been sandoffish, if not flat out rejecting him, which is great.
Why is the URL Hieroku? 
would you call google a direct method or is it just inherited?
You would have to ask the wired editors
Nice :D I got 11 but I missed a few that I've used too, its hard to remember them without context.
&gt; Unless you are writing a Ruby REPL Or compiling a DSL, or generating code based on a config file, or... The stupid; it burns.
&gt; Or compiling a DSL You can do a lot with `method_missing`, `const_missing`, `Module#included`, `Module#extended`. Also note, in the blog post I am specifically talking about `*_eval` with a String, _not_ a block. &gt; or generating code based on a config file Parse the config file into data, wrap the data in closures. &gt; The stupid; it burns. I think you should spend more time exploring Ruby idioms. eval is not a hammer.
_why? If this is horrible, please explain. Would love to improve my ruby-fu
&gt; eval is not a hammer. Nor is it a "security risk." Using untrusted data is a security risk, and treating that data as code makes things somewhat worse. The problem with eval-less DSL compilation is that it generates code with many more method calls, which are slow, because you can't inline anything. When this matters, it's a huge difference. Same with config-based code-gen. Having full access to the compiler is a powerful feature, and it's a shame to see people going through contortions to avoid using it because of "security" superstitions.
I have been doing the same thing recently...passing hashes instead of specified parameters. There's nothing wrong with it, but you have to be careful that you document what the method needs access to. Otherwise, if someone comes back behind you to refactor, they have to hunt through your method to see which elements in the hash are actually used. It can get pretty confusing.
Another way to look at it - it works in the same way that `&amp;&amp;` is used in bash scripts the world over. [[ /* some test */ ]] &amp;&amp; some_command_that_relies_on_test
I compiled pg_ext.so from source and copy it to gem directory. It is compiled on building gem from source. Simple build and compile gem didn't work for me, but I don't remember details. 
That was incredibly informative and useful. Thank you -- if only all posts in /r/ruby were so good!
http://www.w3schools.com/xpath/xpath_functions.asp contains() is very simple. It just checks if first argument contains string in the second argument. The dot operator(.) simply means the current node
I find and/or very unintuitive because of their low precedence, and if anything just make it harder to understand code that uses them for most ruby programmers (or worse, misleads someone). You can use &amp;&amp; or || to accomplish the same thing without confusing anyone.
$20,000 a month!? You're doing it wrong.
* Use 2 space tabs * Document your code using yardoc * Write some tests 
I don't have the bandwidth to watch presentation videos ATM -- sorry. I'm talking about the performance of the resulting code. It's basically the difference between a compiler and an interpreter for your language. &gt; Remote Code Execution is very serious and is not a "security 'superstition'". Right. Taint your untrusted inputs, and carefully validate them before using them if you absolutely must. OTOH, trust your trusted inputs, and don't be afraid to eval them.
Thank you! I did not know that the xpath functions had documentation in w3schools! This helps a bunch. 
You also need to ensure that anyone else who may read your code also will understand it.
I don't do much Ruby, so I hadn't come across this but after reading it I'm not terribly surprised. Ruby takes a lot from Perl and this same operator precedence where "and" and "or" are lower than &amp;&amp; and || by a few steps occurs in Perl as well.
gerber-rs274 and Gerber::RS274
Babyfood
Completely disagree. Nearly all my conditionals will use the "and" and "or" operators as IMO it is more readable. And I already know and understand the difference between both forms. If your code makes someone need to remember operator precedence then I think you're trying to be too clever and need to simplify it.
gerbill :) Try not to use a very generic name if you don't intend to support it. I don't see anything wrong with a gem that has the same name as a company unless it is in the same domain.
&gt; I don't see anything wrong with a gem that has the same name as a company unless it is in the same domain. This. Using the name of the file format is about as clear as it gets. There's going to be no confusion whatsoever. OP, if you wanted to be super clear you could call it "gerber-reader" or something but I am actually hoping it becomes a writer also.
Why? Use `&amp;&amp;` and `||` when assigning to a variable, use `and` and `or` in conditionals. Use parentheses when things aren't clear.
It'll definitely support both reading and writing. It's not much use to me otherwise. Keeping the name clear, and discoverable, is my goal here. I was worried about somebody getting it confused with baby food. At least for me, that's what comes to mind every time I type require 'gerber'. In hindsight, that's kinda silly. Why would anyone make a baby food gem? It would just get all over the keyboard. I like postmodern's idea of putting rs274 in the name because it might reduce confusion a bit, but I think fewer and fewer people know the format by that name these days. Ok, I've talked myself into it. I'll stick with gerber to keep it simple. It'll work something like... require 'gerber' gerber = Gerber.read('infile') gerber.write('outfile') Thanks for the help!
gerbill is so tempting. I wish you hadn't mentioned that :)
Gerberus? Like Cerberus. 
| I like postmodern's idea of putting rs274 in the name because it might reduce confusion a bit, but I think fewer and fewer people know the format by that name these days. There's one small issue I note. When you search in rubygems.org, it only searches on title not inside the description. So say i search for rs274, your gem will not come up if its only called gerber. Maybe I am missing something, but is there some way of searching within descriptions. That makes gem naming a bit of an issue with me. e.g., I do some ncurses stuff, and if you search for ncurses you only get what has "ncurses" in its name, not all the gems which use ncurses or have it in the desciption.
[See here](http://www.reddit.com/r/ruby/comments/19r9ko/rubygems_201_now_with_fewer_bugs/) and decide for yourself. 
&gt; Gerber::RS274 But he said Gerber is a subset of RS-274.
I'm not sure, but you probably mix up operator precedence with short circuit evaluation.
It's pretty simple: "and" and "or" are like statement modifiers, e.g. puts foo if bar bar and puts foo Use them this way and you won't get confused. Use "&amp;&amp;" and "||" as logical operators.
What was the YAML Fiasco?
I would definitely stick to ruby 1.9.3 with that version of Rails, *especially* in Windows.
The team compared the checksums of all gems against several mirrors to provide some reasonable assurances that there weren't exploited gems on rubygems.org itself. That seems to be good enough for most people. And it probably is for you too. There was a lot of talk about beefing up the cryptographic signing and verification requirements immediately after the exploit, so that gems could be verified as authentic. But that all seemed to die down and I haven't seen any actual code or working implementations that I can use to verify gems any better than before the hack. I've been working on an alternate OpenPGP based solution that at least lets people sign gems in a meaningful way now, but no-one else is using it. More info at: http://www.rubygems-openpgp-ca.org/ I just released a new version of the client software today that does ssh-style continuity checking to alert users if the signing key for any previously installed gem changed.
http://venturebeat.com/2013/01/30/rubygems-org-hacked-interrupting-heroku-services-and-putting-millions-of-sites-using-rails-at-risk/
And other people work on this code? 
Hmm, an appeal to authority. Well I won't dismiss your point though, because no doubt there was some pain point in their development that led to that edict. However their prescription isn't flawless, in particular for the case of operator precedence that the OP covered. That is a trap for the unwary too. So use parentheses would be the next prescription. Well that would also help cover the trap with using "and" and "or". I will take the point though that while I might understand and write my code to avoid the traps, someone less experienced may edit it in future and inadvertently introduce a bug because of it. 
Interesting. I didn't realize rubygems only searched on the gem name. I don't see any sort of 'advanced search' option either. The [contributing page](http://guides.rubygems.org/contributing/) does mention that they're switching their search engine to Solr, so maybe this will get fixed at some point.
That depends on how you define "secure". If you mean authenticity, i.e. some kind of guarantee that the gem you got really is from the author, then there's currently no widely-used method. Methods exist, e.g. RubyGems provides builtin X509 certificate support, but they're almost never used. Some gem authors provide their own ways of authenticating their gems. For example all Phusion Passenger &gt;= 4.0.0 RC 1 gems and tarballs are PGP signed. You can read about our signing and verification mechanism at http://www.modrails.com/documentation/Users%20guide%20Apache.html#_cryptographic_verification_of_installation_files However, if you mean "gems must not be able to do bad things during and after installation" then the problem becomes a lot tricker. In addition to authentication, you have to be able to trust that gem native extension compilation scripts don't do anything bad, i.e. the author is not hacked or malicious. Gems are often installed as root so a malicious gem can cause a lot of damage. There's basically no way to protect yourself against this other than code auditing everything. You can also use some form of operating system-level sandboxing (e.g. chroot, SELinux, FreeBSD jails, user accounts, etc) to limit the damage they can do. But that brings us to the third meaning. But unless you've audited the code, you're never sure that it's not malicious even if it appears to be safe when run inside the sandbox. Maybe it autodetects the sandbox and proceeds with doing bad things once you give it root access.
That's a real shame. By now it has become quite clear that there's no perfect solution. But that doesn't matter: anything is better than the current situation. There should be a large-scale education effort to encourage developers to participate in whatever mechanism takes off.
After reading your rant on X509 vs PGP I'm fully convinced that PGP is the way to go. I've long stuck to PGP because of its superior tooling but it appears the security model is better than X509 as well.
Oops. In that case, rs274-gerber?
You could try something like this: arr = "[1, 2, 3]" arr.gsub(/[\[\]]/, "").split(/,/).map(&amp;:strip) =&gt; ["1", "2", "3"] Granted, this method won't work with nested arrays.
any examples where this has been used ?
Does anyone have any first hand experience regarding performance issues (if any), restrictions, etc?
Someone forked my code and ripped into it lol. Best learning experience ever.
 sleep
If you: socket.listen Socket::SOMAXCON You're doing it wrong. Before blaming Heroku for routing issues you should tell the router how many connections you can reasonably accept. By allowing such a large backlog you're only shooting yourself in the foot.
Thank you! `while true do end` was spiking my CPU, and `sleep` without a time doesn't seem to!
If the threads terminate normally, it's better to join them all
You're looking for "joining" the threads.
http://www.tutorialspoint.com/ruby/ruby_multithreading.htm check out on how to implement Thread joins in ruby.
There should be very few restrictions. The complete Java, Android, and Ruby API should be available. The stack of the main UI thread is tiny, so you need to offload any heavy lifting to background threads, which is a good idea on mobile apps anyway. Startup time is 5-12 seconds on a real device, and twice that on an emulator, but you can display a splash immediately after app start to calm your user a bit. This is currently the main optimisation focus. Performance loading source files from the jar seems low, although we don't have any numbers on this. Performance orchestrating the UI and doing general IO and communication seems good. Again no numbers. 
I am on the Ruboto project, and we use Ruboto to develop a real world app at work, distributing assignments to busses and tracking their progress using GPS. The GlobalChat2 project uses Ruboto. Ruboto IRB and the Android API Browser are Ruboto based. There is a Ruboto Benchmarks app. There are probably lots of other experiments using Ruboto around, and we'd like to hear from them all. 
I guess the obvious comparison is to RubyMotion, where there's already a [long list](http://www.rubymotion.com/apps/) of apps using it in production. Ruboto either isn't being widely adopted or people are just being very quiet about it if they are using it. Having IRB, benchmarks and an API browser are neat and all, but it's not screaming "this makes writing Android apps better". 
The [fill out the application link](http://i.imgur.com/z9oxgUx.jpg) is broken. :(
Is there any IDE for ruby on android?
They don't, it's for a bunch of different filesystem watchers.
on the subject of doing unix-y things in ruby, there's this [pretty cool conference talk](http://www.confreaks.com/videos/1289-rubyconf2012-grow-your-unix-beard-using-ruby)
See: http://devblog.thinkthroughmath.com/blog/2013/02/27/managing-request-queuing-with-rails-on-heroku/ Which was linked from: https://blog.heroku.com/archives/2013/2/27/unicorn_rails#comment-813781076
Yeah, maybe we should start charging for using Ruboto to enable a large marketing push. (Am I kidding?)
I use RubyMine. It only covers the Ruby side of the project, not the Java source. You can of course edit the Java source, and it will be compiled by the ANT script during build. Alternatives are Eclipse with ADT + RDT, and any IDE with both Java and Ruby features. I usually use the command line for development. The "ruboto" and "rake" commands cover most tasks. 
Yes we at Phusion already do that with all our newest tags. However signing commits appears not to be useful when you can already sign tags: http://stackoverflow.com/a/10166916/20816 I quote Linus Torvalds: "Signing each commit is totally stupid. It just means that you automate it, and you make the signature worth less. It also doesn't add any real value, since the way the git DAG-chain of SHA1's work, you only ever need one signature to make all the commits reachable from that one be effectively covered by that one. So signing each commit is simply missing the point." I also strongly recommend using gpg-agent so that it remembers your password for a while. If you use GPGTools Installer for OS X then it automatically sets that for you up.
Isn't that what the CA is for? rubygems-openpgp-ca.org verifies that the person who signs up is the owner of a gem, and that he controls the signing key. The website explains what their scope of verification is. Even when you don't consider the CA, if gems are signed you can verify easily see whether a gem's key has changed. That may help in investigations. rubygems-openpgp currently provides ssh-style continuity checking, i.e. whether the key hasn't changed compared to last time it checked.
Your CA allows a user to trust that you trust a gem, no more. We don't (and probably can't) trust you, so it doesn't help us if there is a future exploit of rubygems.org.
&gt; I also strongly recommend using gpg-agent so that it remembers your password for a while. Don't forget to "forget" your PGP/SSH keys when your done working. I use this [alias](https://github.com/postmodern/dotfiles/blob/master/.bashrc#L46): alias forget='ssh-add -D; pkill -s SIGHUP gpg-agent' &gt; If you use GPGTools Installer for OS X then it automatically sets that for you up. While I do not use OSX, [GPGTools](https://www.gpgtools.org/) is _awesome_. Definitely donate to them.
X.509 vs PGP doesn't matter, a third-party CA cannot help us verify gems in an exploit. Key signing can be implemented with either, but a third party doing so doesn't help us verify gems if there is an exploit. Trust-on-first-use can be implemented with either, but doesn't help us verify gems if there is an exploit.
The end goal is not to get rubygems.org to trust a third party CA. The goal is to allow actual gem users to be able to authenticate gems against their own threat model. The goal is to allow users to authenticate gems even if (no offense) the maintainers or rubygems.org aren't doing their jobs. Some people might trust the CA. Some might trust signatures issued by rubygems.org or a different third party. Some might have authenticated signing keys in person for at least some of their gems. Some might use a combination of sources for authentication. Users can't do this now.
&gt; There's no way for us to tell that the key used to sign the gem is the valid and correct one. Can you add a public keys table so I can upload mine, and have some kind of append-only record of uploaded public keys?
Once an attacker gains access to the box this can no longer be trusted. It is unlikely an attacker can gain access to both the rubygems.org infrastructure and the S3 infrastructure, we can use S3's logging to eliminate duplicate uploads (replacement of a gem), remove any gems uploaded after the exploit, and verify checksums in S3 against mirrors. This was the strategy we used to verify gems in the prior exploit.
Wow, that's quite the bug. Perhaps it's time to setup Travis CI?
1 &amp; 3 are unequivocally the Ruby way. But 2. I mean, come on end_guy. YARD/RDoc is so ugly.
drbrain, I am the submitter, not kgo__. This submission is independent action from me in order to raise awareness for PGP signing and rubygems-openpgp-ca. It is not an action on behalf of rubygems-openpgp-ca. When I said "we don't want that to happen again do we?" I didn't mean it in the literal sense that it would stop rubygems.org from ever being exploited. It's more like a marketing catchphrase to encourage developers to sign their stuff. Sorry for the confusion. The situation is exactly as kgo__ explains: the end goal is to get developers to sign their gems at all. You can easily implement your own trusted CA after the fact. I believe the community is waiting for some kind of officially endorsed signing method so that they can help with increasing overall security. On the other hand, it's hard for rubygems.org to adopt any method if it's not already widely-used, creating a chicken-and-egg problem. But with PGP you don't have to have this interdependency. As long as a third party can convince developers to sign their gems, you can endorse it as official later, and dictate whatever security requirements you want. It is true the attacker is unlikely to gain access to both S3 and rubygems.org. And it is true you still have to shut down rubygems.org after a vulnerability is detected. However, if people sign their gems then that should still bring many advantages to you and the community compared to the current situation, even if you don't trust the keys: * You are more likely to detect a vulnerability earlier. The last vulnerability required the attacker to tell you. Even if you don't trust the key, if the key changes it is still suspicious activity. If rubygems.org is exploited today and the attacker uploads a new version of a gem, how are you going to find out that this happened if the author of the gem doesn't raise alarms? * Users can participate in detecting a vulnerability. When the key changes, users will notice and they can alert you so you can investigate, even if you don't trust the CA. Users can also take measures to protect themselves before rubygems.org has responded. * During the last vulnerability, how did you know how far back in time you had to go to obtain a safe snapshot? In other words, how did you know what the exact time of the exploit was? You used file replacement as a heuristic. But signing gives you defense is depth. It gives you another method to find out how far you have to rollback *and* it also protects you against unlikely S3 exploits. Even if you don't trust the CA, the additional information is useful.
Embarrassing. It's a shame this is now a core part of Ruby.
Travis-ci is set up, checking would have added ten, maybe twenty seconds to the time it took to post a comment.
Ok, so you need to sleep forever, and then rescue on the Interrupt. interrupted = false while ! interrupted begin sleep rescue Interrupt interrupted = true end end See the documentation http://www.ruby-doc.org/core-2.0/Kernel.html#method-i-sleep Basically since you may be interrupted at any point in time, (at least I know this from java, idk about ruby) just keep track of if you are done or not, and sleep again.
I was being a tad facetious but I'm a big believer in Robert Martin's "the code should be its own documentation." Basically lots of small well-named functions without comments and with 90%ish test coverage. The benefit is the documentation never goes out of date and the tests show you how to use it.
Sorry. Didn't think rubygems was one Travis CI, since there's no badge in the README.
Yeah, this is awful. I think this just makes code less legible, and this is a perfect example of weird gochas it opens you up to.
No, they work completely differently. RubyGem contents cannot be installed outside the corresponding gem directory (there are hacks around it, but that's what the mechanisms are supposed to be used for) and are specific to the Ruby interpreter. Native packages like deb and msi can install their contents anywhere on the system. dmg is a whole different story though: it's similar to a zip file and doesn't dictate any kind of installation logic.
&lt;3
Don't let people talk shit they dont understand. If they want a better product they should get off their asses and help. We appreciate everything you do When I find a bug, i report it. Hell, if i had known it was such an easy fix last time, I'd have even opened the pull request (I opened the "installed docs in 0 seconds" bug).
I totally agree with Uncle Bob's principles, but as good as they may be they cannot always tell the full story. Just one example that comes to mind is parameter names... i.e. # Accepts "Otis" but what about :Otis? def find(name) What does this accept? def parse(template) Template object? String? Both? IO Object!? That's why I follow a rigid method of applying Uncle Bob's SOLID principles and fully documenting my code with things like yardoc. 
I would use nginx/apache with passenger for this. the setup is not very difficult.
[Pow](http://pow.cx/)
As I mentioned, the problem with pow is that it will only run the app in a single environment. I want a test version and a dev version to run at the same time. There appears to be no way around this without hacking the pow source. 
I've been working on an apache/passenger solution, but it seems I run into the same problem as with pow. If I load two vhosts pointing to the same directory with different RailsEnvs, only one instance will get loaded.. first declaration of RailsEnv wins and all requests to either url get served in the same env. This is discussed in this [thread](https://code.google.com/p/phusion-passenger/issues/detail?id=45). Someone there suggested using a different documentroot (by using symlinks) to force passenger to run another instance, but that doesn't seem to be working either. 
One workaround that I have used for pow is to symlink the folders in the app directory to a second directory. The trick was not to symlink the app root, but to symlink the children, app, lib, etc.
Ouch. Ok, that works, thanks. But if anyone has any better ideas, I'd love to hear them, because that kind of sucks. I have like 10 apps with like 15-20 symlinks each to maintain. 
Personally i use vagrant (http://www.vagrantup.com) and virtualbox (http://www.virtualbox.org) to run development virtual machines that are tied to my development code path automatically by the vagrant configuration. 
Had a similar problem. Quick fix. I just bought another computer to have all my apps running all the time. It just 400 bucks. And also using xip.io, am lazy to setup a dns server. 
Phusion Passenger author here. Use Nginx+Passenger and use the `passenger_app_group_name` config option which has been introduced in version 4.0.0 RC 4. Use a different app_group_name and they will be treated as two different apps even if they have the same path, allowing you to use different rack_envs.
Why are you using Rubininus 2 RC1? "Ruby" doesn't suck at scripting because a release candidate of an alternative implementation is slow. My numbers on Ruby 1.9.3: Running 'ruby bogobench.rb' 100 times done. real 0m2.778s user 0m2.187s sys 0m0.425s Running 'java bogobench' 100 times done. real 0m22.022s user 0m24.617s sys 0m3.592s Didn't even bother testing the other languages.
Let's hope he wont try JRuby :) (it'll probably suck really bad at this kind of benchmark)
While it would be nice if Ruby was faster, I'm pretty sure that "speed to start up" isn't what makes a language good for scripting.
Finally, safe thread interruption! I've been waiting for this forever!
First thing I'd do would be to print out Gem.path, to make sure my gem search path was correct and/or the same in both cases.
Requires account/login to view
is it possible that the way that textmate invokes Ruby, it implicitly requires 'rubygems'? try adding: require 'rubygems' at the top of your file (first line) and try again. I've never run anything from inside textmate, so this is a shot in the dark.
I'm not super familiar with the inner workings of the gem system, but since his error seems to be coming from *inside* rubygems itself (presumably where it redefines Kernel.require to include gems), doesn't that mean rubygems must already be present? Could be the wrong version, though.
1) Make sure rvm is actually loaded: source ~/.rvm/scripts/rvm 2) Make sure you're using the correct Ruby version: (you should upgrade to 1.9.3 or 2.0, but that's another story) rvm use 1.9.2 3) Do a bundle install one more time: bundle install 4) Try it again. Still error?
Edit/reply: if you're not using Bundler (which you should be!) then replace step 3 by installing whatever gems you need.
It's a public board. Works fine here in incognito mode, etc.
It works for Apache too. It's called (tadaaa) `PassengerAppGroupName`. ;) This even exists in Phusion Passenger 3. It's just that the Nginx equivalent was recently added.
Well, that's not weird, the keys on an array can be any object, so it stands to reason that procs can be keys if you follow the principle of least surprise. Then again, yeah, I can't think of any practical case where doing this would be sane.
I guess i knew that, but i had just never thought about it this way.
I was more inclined to use a ruby side on android but the only one I've seen was aide
It's a paradigm shift, welcome to a new way to view things
[Android Chrome](http://imgur.com/NuzwdDx) gets the front splash and no lists
Oh. I tried setting different PassengerAppGroupNames for each instance and it didn't seem to help :( Can the group names be anything? I can't find any good documentation on that. I just set them to 'testapp' and 'devapp', and set RailsEnv and RackEnv appropriately for each, restarted apache. Still every request hits dev environment. EDIT: turns out I'm an idiot. It works like a charm. I just forgot to add NameVirtualHost * to my main httpd.conf. doh. Thanks! 
haha awesome! :) Have you ever had a use for something like this? I've turned some neat tricks using procs as default hash values. Not ever as keys tho.. 
This entire page is littered with misinformation and is poorly intentioned. I'm not sure if the author is simply confused or lying, but security is confusing enough, we don't need people spreading lies: https://www.rubygems-openpgp-ca.org/blog/gem-signing-x509-and-openpgp.html At this point, I'm going to strongly recommend **AGAINST** anyone trying to use this guy's CA. **PLEASE WAIT FOR AN OFFICIAL SOLUTION FROM RUBYGEMS** I will address one point, because I feel this entire page is a gish gallop of lies I could easily lose myself in, and if I'm going to do that, I need to take the time to properly deconstruct the pyramid of lies in this page, but let's start with this: "An X.509 based system requires a complete centralized end-to-end authentication system to be in designed and implemented before it is useful to gem developers and users." This is not true: at best it's a red herring, and at worst it's a lie. The argument is that only a web of trust can solve this problem. The reality is that you do not need a web of trust to solve this problem: it can be solved by adding root certs which cover all the gems used in a given app, so you can then run it in HighSecurity mode. This is all built into RubyGems today, even. No new 3rd party packages. No code changes required. This is, in fact, how people generally use GPG for installing packages on Linux today: there are not overlapping trust relationships which form a graph shape. People simply add root certs for parties whose packages they want to install and things end up looking rather tree-like. A web of trust is simply a red herring here. I'd call WoT a "cool feature" of GPG (albeit ireelevant) but I can't even bring myself to call it that. Here's why: Webs of Trust create confusion. *End users* are asked to resolve differing pictures of truth, and must do so based on their trust of given certificates. This belies the fact that the sorts of sneakernets cypherpunks were so gung-ho on in the '90s that are supposed to boostrap a web of trust just don't scale in reality. My argument is that a WoT ends up being *more confusing* for end users because different trust authorities may disagree on what's trusted, and when this happens, it's up to the end user to make a judgment. As soon as it's up to the end user to make a judgment, IMO, you have already failed...
Perhaps you can implement lazy method chaining this way? You can creatively use `method_missing` to build up an array of procs to call, and the arguments with which to call them can be stored in a hash, where the hash key is a proc and the hash value is an arguments array. Keep in mind that in order for an object to serve as a good hash key, you need to implement the methods `hash` and `eql?`. I got burned once because I thought implementing `==` would be enough; turns out `Hash` uses `eql?` and expects `a.eql?(b) == true` to imply `a.hash == b.hash`.
The point is that with a WoT you can simply trust nodes who act as distributors of trust, ie the debian project's key which exists only to sign dd keys. Yes, you can do this with CA certs. Personally I find that to be a significantly larger pain in the ass with a lot more overhead, and a more treacherous audit trail.
Would you be willing to share your rake scripts? Or maybe create a gist with the ehh gist of what they all do. I've been working a lot with chef and vagrant and I'm curious what you might have automated with rake in the mix.
I'd love to see your rake tasks as well. 
Calm down. If you think he's wrong, you should refute his points with reason. No need to label them as "lies". We're all just trying to improve the situation, even if we may disagree with each other. &gt; PLEASE WAIT FOR AN OFFICIAL SOLUTION FROM RUBYGEMS That's great **if** there is an official solution from rubygems.org. So far, there has been no concrete solution. The discussions from rubygems-trust seem to have died off. Until they come with an official solution, I see no harm in adopting this one. Switching signing technology is not difficult. Most of the work involves integrating signing into your build/release automation system, setting up proper habits, etc. If people later decide to use X509 instead of PGP I'll change a few lines in my scripts and I'm done. &gt; it can be solved by adding root certs which cover all the gems used in a given app So you are suggesting that a packager signs all the gems he packages? This is a completely different model than the one intended by rubygems-openpgp-ca and does not fit the Ruby community. In the Ruby community developers are responsible for creating and maintaining packages themselves. It would make more sense to use a CA model of instead of trusting individual packagers (because the Ruby community has no such roles) or individual developers (because there are too many). But when adopting a CA model, and when using X509, nobody can begin signing until rubygems.org officially releases their CA system. That is the point that the blog post is arguing. With PGP you can start signing today and adopt whatever CA you want later, even if that CA is not rubygems-openpgp-ca.org.
Ok, so it appears to be some bug in Trello itself.
"So you are suggesting that a packager signs all the gems he packages?" Absolutely not, I was (and still am) pushing for an X.509 CA. I am merely pointing out that a WoT is a red herring here, and it's possible for an X.509-based system to be useful without every gem ultimately having a root-of-trust in a CA. Ultimately, it should be a fill-in-the-gaps system, where people publish certificates to packages they publish until they are, in some manner, signed by the central CA. This uses trust hierarchies rooted in multiple roots, and pretty much represents how most code signing happens today, even in GPG-based systems like Linux distributions. I'm also arguing that a WoT is not nearly as useful as this site is claiming. "But when adopting a CA model, and when using X509, nobody can begin signing until rubygems.org officially releases their CA system." This site isn't claiming that. The issue isn't that there isn't an X.509 CA and he's running one for OpenPGP (which had HSTS misconfigured until a few days ago... good luck trusting a CA that's serving its pubkey over plaintext HTTP) In a rather hand-wavey manner, he's claiming there's some fundamental, intractable problem with trust hierarchies that necessitates a trust graph in order to be useful. This isn't true at all. This is wrong to begin with, and is certainly quite wrong when it comes to the way code signing actually works in practice.
I'm sure someone will do it soon so i'll get right to it in a nicer way. I think there's a /r/forhire subreddit where this could get better exposure. 
There's nothing inherent to RubyMotion that makes it your apps less than other apps. You can implement the same functionality, with the same polish level of the top apps if you so choose. There's a laundry list of mediocre and less than mediocre iOS apps written in Objective C.
I've really been put off by the fact that it's proprietary, closed source and $200 with no trial. That just goes against my spirit of open development. Despite that I've heard many good things about it from people who have used it. I personally like Obj-C and I don't think it's hard to pick up at all, and with iOS development learning the SDK is much more of an issue than learning the language. Obj-C is dead simple compared to something like C++ (especially if you're already familiar with C).
in most case you don't need it, but there adequate use cases for it, so killing it would be a bit... violent :)
1. Are you thinking it's like Titanium or PhoneGap in this regard? Those two are fundamentally different than RubyMotion. RubyMotion is basically Ruby bindings to the iOS Objective-C apis. It's not a framework for building an app like Titanium and PhoneGap where you're essentially stuck with whatever subset of native functionality they decide to provide (or you decide to add bridging for yourself). If that's not what you mean then could you elaborate on why you say that? (I have written iOS apps, but not with RubyMotion. What I know about RubyMotion I've gathered from details about how it is implemented and its developer docs)
Having written a couple of iOS applications both with Xcode and RubyMotion I think these statements are false. 1) This is entirely subjective. You mentioned the basecamp app as being mediocre, but I know the developer of the application and he was in no way stifled by RubyMotion, he chose to make the app the way it is. I've used RubyMotion both with and without Interface Builder and have made use of components such as Core Data. Plus if you see my response to #3 you can link against compiled libraries for iOS which means you're not missing out on shared libraries. 2) This part is true. You can't fix bugs in the iOS SDK either. 3) RubyMotion is not an abstraction layer of Objective-C, it's an abstraction of the iOS runtime which is targetted by both RubyMotion and XCode. Essentially the compile to the same instruction set. I'd also say that if you're listing this as a negative, under your logic we should be writing iOS apps in assembler. 4) See above. Edit: Expanding #2
They do have a money-back guarantee if you don't like it, but yeah, it is a steep up front cost.
The same hold for you: Have you written any applications in RubyMotion? Most of your original points seem to miss the mark. 1: Why specifically? 2: You can't fix iOS SDK bugs or XCode crashes either. This increases the sources of bugs out of your control, but the RM team seems much more responsive to reports. The same can't even be said for Apple. 3: And? 4: Why is Basecamp being mediocre relevant to the question? If they were to have made the same design choices but simply used Obj-C, I don't see how it would have been better in any way.
What's the benefit of this over http://remiprev.github.com/her/ ?
I've dabbled with RubyMotion a bit. The challenge to writing iOS apps isn't the Obj-C language so much as the SDK. Your knowledge of Rails won't translate well just to lend a hand, you'll still have to know the hard part: how the SDK works. There are cool things going on in the RubyMotion community to alleviate some of the SDK pain points, like Teacup, MotionModel, and Bubblewrap, all of which which greatly reduce the work involved in writing iOS apps, and RubyMotion's build process is definitely easier than XCode, but I bet an experienced iOS developer would probably opt to work with what he already knows best. If he or she needs help, the difference between Obj-C and Ruby isn't that vast, you can probably get up to speed if needed. I'd say if you're going to bring an iOS developer on full time, let them choose. RubyMotion is still pretty niche to be asking for experience with it. If you're going to do it yourself, go ahead with RubyMotion though. 
You realize the logo is a re-colouring of Github's 503 error image, right? What's the license on that? https://github.com/503.html
Similar question, but for [ActiveResource](https://github.com/rails/activeresource) instead
This is something i would like to know as well.
I don't think you can maintain 1.9 compatibility as well as use new 2.0 features. (Without either maintaining two versions of the gem, or using conditional require's; which would mean maintaining two copies of any files/features that differ in your 1.9 v 2.0 code) Maybe the best option, assuming you are using version control, is to start a ruby-1.9 branch, and update everything to use 2.0 including required_ruby_version in your gemspec. Then as you add new features, backport to you ruby-1.9 branch. Then you are prepared for 2.0 adoption as well as maintaining compatibility with 1.9.
If you absolutely need to use keyword arguments, or some other 2.0.0 only feature, then sure. The [backports](https://github.com/marcandre/backports/tree/master/lib/backports/2.0.0) gem already has various 2.0.0 methods. Given that 1.8.7 will soon reach [End of Life](https://blog.engineyard.com/2012/ruby-1-8-7-and-ree-end-of-life) I think it's safer to require `&gt;= 1.9.1`.
I'd say it's probably ok to cut completely over to 2.0 unless you have a good reason not to. You'll be helping to push 2.0 adoption and help keep Rubyists from being lazy and sticking to 1.9.3.
Yes, though mostly tinkering. My only publicly released app was written in C# using the Unity engine. 
I like the branching idea, but then I would still have to distribute two versions of the gem. I don't see an obvious way to do that on rubygems, other than treating the 1.9 branch as a new gem.
It's $200... Heck my editor cost me nearly that.
If you specify your gem dependencies in your .gemspec like you're supposed to, they will be installed automatically.
"lazy" is not the correct word.
I'm no ruby gems expert, is it illegal to have the same version # with different required_ruby_version. My hunch is that won't work. If you are using Semantic Versioning, you would want to raise you're major version anyways, as it would break compatibility. I see no reason why having two different versions on ruby-gems would be a problem (think Rails, 3.x is 1.8 compat, 4.x is 1.9 compat) -- they just maintain multiple versions of the same gem. I believe the only way to keep one version # of the gem with multiple ruby versions (as in using 2.0 features). Would be to use the RUBY_VERSION constant and alter behavior.
This is actually my preferred solution, mainly because it's easiest for me. But I'm not sure what the prevailing opinion is, or if the adoption rate for 2.0 is high enough to warrant taking the plunge. OTOH, it's not that any of my gems are popular enough to worry about this.
 "%.2f" % subtotal
Good point. So much for that idea.
Correct, only methods.
There is a psychological effect to yet-another-dependency. OTOH, rubygems is _really_ good at installing dependencies. Also note that backports will not add 2.0.0 methods if it detects `RUBY_VERSION &gt;= '2.0.0'`.
if you want actual usage and consider it a production ready gem I would say yes it is too soon. If you are building a toy gem for fun it is fine
I'm sure you're still wrong somehow. Edit: Eating some downvotes so I can snark at my friend? Worth it.
How about "not extrinsically motivated to enact change"
i'd say just bump the major version number of your gem and introduce a 2.0 branch, since this is after all a breaking change for anyone linking to it. the 1.9 branch can continue to bump the minor version number if you want to maintain it in parallel.
If you need that kind of performance, but still wanted to use RubyMotion, you could yourself write the libraries you link and feature C code if need be. Which in truth means you're not writing parts of the application in RubyMotion. It would be interesting to see if they allowed you to write inline these instructions, but I don't think writing ARM instructions is for the feint of heart. Edit: grammar.
Also, I suppose it's fine for a learning exercise, but, in real apps, please oh please don't use floats for currency. It gets messy fast and precision gets lost everywhere. Consider integers for cents or whatever precision you need (maybe backed by the [money](http://rubygems.org/gems/money) gem for a helpful abstraction), or [BigDecimal](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/bigdecimal/rdoc/BigDecimal.html) or something like that. puts 0.2 - 0.15 - 0.05 # =&gt; 1.3877787807814457e-17
James Tucker and Eric Hodel of the RubyGems core team have been investigating TUF: https://www.updateframework.com/ I have not personally had time, but I would love to prototype a comprehensive X.509 solution including, at the very least, a CSR and CRL system. It's great trying to get *something* in place, but I think we can all agree the system isn't helpful unless it can realistically get end users to having all gems signed by (a) trusted authority(ies) I guess my attitude is the *complete* opposite of Grant Olson's... he wants to rush something out the door because he believes something is better than anything. I take the opposite stance that if it isn't worth doing right, it isn't worth doing at all. There are many concerns for a RubyGems signing system to be successful. I strongly agree with Evan Phoenix that a gem signature system isn't helpful unless ubiquitously embraced and available to everyone everywhere without the need to figure out how to get an additional 3rd party tool installed beyond just a Ruby VM. Gem signing already is and needs to be a first class feature of RubyGems or it simply will not be embraced. The RubyGems team has already made it clear that they will not consider a GPG-based solution as part of an official RubyGems signing system. Please keep in mind the RubyGems team has been busy shipping RubyGems 2.0 before inquiring why it's been a month and no comprehensive gem signing solution has emerged.
IMO, it's way to early. I'm all for using Ruby 2.0 in application code, but if I'm looking to distribute a gem to a wide audience I would stick to features that compatible with the most versions of Ruby as possible. Personally I still support 1.8.7 in my gems, but expect to drop it soon as it's usage is dwindling.
He wants to use keyword arguments, which would cause a syntax error in 1.9 even if he tried to alter behavior using the `RUBY_VERSION` constant.
Yup. If the gem is something you expect people to use in production systems at companies that rely on Ruby to run and where downtime costs money, like in commercial web sites and services. 1.9.3 isn't going to go away for a while in this space (hell, some still use 1.8.x). Otherwise, go nuts. 2.0.0-p0 it up!
Another point to consider is that there's precisely one version of ruby your gem will work on. JRuby doesn't yet have 2.0 support (that work is going on in master right now, but will be experimental in the next release). As I understand it, Rubinius doesn't yet have full 2.0 support (someone please correct me if I'm wrong). And then you have the handful other implementations (MacRuby, RubyMotion, Maglev), none of which have 2.0 support.
I'm not sure syntax additions are a very good reason to require a version of any languages. Wait for your features to require new features of the interpreter. Really, having pretty code is a pretty lousy reason to expect people to upgrade.
http://ruby-doc.org/core-2.0/Kernel.html#method-i-sprintf
Hey, I'm all for accuracy. I'd rather learn the right way the first time around, which is why I'm posting here! That being said, would you please demonstrate how exactly BigDecimals would work in terms of embedded variables? 
That's just me saying what the line will print :) I think on Ruby, if you treat it like a float in the string formatter or whatever, it'll be converted to a float. So, for printing purposes, you can probably do the exact same thing. (Away from computer right now; I'd check if I could :P) 
I think you guys are misinterpreting what I said (and probably reading way too much into it). I'm not saying every developer should go 2.0 right away. I'm saying gem developers should try to be 2.0-compatible as quickly as possible to help get all the kinks worked out and keep upgrade momentum going.
If you want my two cents: *absolutely*. RubyMotion is a joy to work with and will hardly make you diverge from the Ruby workflow your team is used to.
By this logic, instead getting to Google some method on some object in Ruby, you'd instead have to spend more time searching through hundreds of thousands of lines of C code just to figure out how something works in Ruby. I'm not saying that your way is "bad" or "wrong" infact I agree that code should be written that way, but in very large systems it becomes inefficient when you just want to quickly find out how one thing works. You'd most likely have to figure out how 10 other things work when all you needed to know is how one thing worked. 
You can get the keyword argument syntax in the caller by using a hash for the arguments: def greet(args = {}) name = args.fetch(:name, "default name") puts "Hello! #{name}" end #&gt; greet(name: "greggroth") Hello! greggroth #&gt; greet Hello! default name This sets up the public face to support keyword arguments and later down the road you can update the implementation when you want to drop support for &lt;2.0.
Well aren't we all ants at a picnic! 
Is this for an existing set of gems that already have an existing userbase? Then I'd definitely not start to force 2.0 anytime soon. Feel free to do so with new gems though as there are no existing users that can be hurt by the decision. 
If you had something like def foo(a, b={}) ...; end you could use foo :something, :b =&gt; :otherthing, :c =&gt;anotherthing so you could redefine it as def (a, :b =&gt; :something, :c =&gt; :otherthing) ...; end
&gt;Wrote a handy little Ruby program (Object Oriented, as I see the world as Objects) Yet you named your object after a verb phrase? Why wasn't it named after an object, like Alarm?
think about all the retarded rails developers making money from their rubbish code. Then a SINGLE guys spends months of his life developing a cutting edge and sophisticated compiler toolchain, and he's not allowed to make a living from that? If you can suggest a business model whereby he can make a living from it without charging for it, i'm sure he'd be happy to hear it. But it seems unfair to me that monkey-brained rails devs can make a living from their nonsense yet you're all up in arms when laurent tries to make a living from his project (which IMO is an order of magnitude in complexity and sophistication above what the run-of-the-mill "web developer" is capable of).
&gt; Then a SINGLE guys spends months of his life developing a cutting edge and sophisticated compiler toolchain RubyMotion was not created by a single guy. And it was not created in months from nothing. RubyMotion is a spinoff of MacRuby, a free and [open source](https://github.com/MacRuby/MacRuby) environment for programming cocoa in ruby. The team took a freely available open project and from that created a closed source proprietary product. Sorry, that rubs me the wrong way. &gt; and he's not allowed to make a living from that? Who said that? Nowhere in my comment did I say they should not be allowed to make a living. There are a ton of companies who make a living from ruby, rails, whatever. Who cares? If you can do it, go for it. I mean in an indirect way I make a living from ruby too. It's great! &gt; you're all up in arms when laurent tries to make a living from his project Again, who said I was up in arms about anything? I have no idea what your gripe is but you are really reading a lot into this. Let me restate: It rubs me the wrong way that they took an open project, closed it up and require me to pay for it without even being able to try it out first. I don't care in the least whether they profit from it or not. I care, as a developer, whether I have the ability to evaluate the tools I may want to use and whether I can count on an open platform being available for collaborative development and not disappearing because the company behind it closes up shop. &gt; If you can suggest a business model whereby he can make a living from it without charging for it Again, I have no problem with them charging for it. 
 $ echo "vlc /mount/data2/Songs/11.Mazhathullikal.mp3 --volume 512" | at 6am would be a lot simpler, but I can see that this was just a fun little project.
&gt; The team took a freely available open project and from that created a closed source proprietary product. Sorry, that rubs me the wrong way. The "team" is one guy, laurent (though he may have employed more people subsequent to release), he was also the lead programmer on "macruby". AFAIK the idea for macruby, the core of the project, all the truly difficult technical problems were solved by him while he was working at apple. It's not like he just took the code from macruby and started selling it as "rubymotion". There were specific technical problems that he had to solve, that required someone with his expertise. Also, as i've said, "macruby" was "his" project too. If it was really so easy to go from macruby -&gt; rubymotion, dont you think other people would have done it too? 
Why is it such a terrible criticism that his main point is a free trial or some kind of evaluation period? 
Hi, I’m `her`’s author :) What I think separate `her` and `rapidash` is that `her` is a module that you include in any class that adds ActiveRecord/ActiveModel-like class and instance methods to interact with resources over a RESTful API (instead of a database). It tries to act more like an ORM. `rapidash` seems to work differently, by using a client and calling methods on it that interacts with an API. With `rapidash`, you do class Users &lt; Rapidash::Base resource :repos end class Github &lt; Rapidash::Client end client = Github.new client.users Something similar with `her` would be: class User include Her::Model end User.all But given that I am `her`’s author and that I never used `rapidash`, I might be completely wrong :)
Do it. 2.0 is mostly (entirely?) backwards-compatible with 1.9 code, but will never be adopted if developers worry about 1.9 users.
It's delegation.
I'm not quite sure what you're trying to say but I'll give it a go: Keyword args use the new 1.9 hash syntax: `foo b: something`. In the first case, you'd have `b[:b]` and `b[:c]`, not `b` and `c`. And regardless, you can't change the syntax of Ruby in a gem. Ruby is dynamic but it's not *that* dynamic.
Most of the methods that I want to convert to use keyword arguments are already using the hash trick, so this is essentially what I'm doing now, but it makes the implementation ugly. I'm itching to clean it up.
Yes, it is for existing gems, but the userbase is small, or non-existent. It's hard to tell from the rubygems stats.
An excellent in detail analysis. Kidos to the people who wrote it.
I would prefer an article titled "Ruby App Server Options" to provide an analytic, unbiased review of different options. Unfortunately, this article is highly biased.
Please feel free to point out inaccuracies. As far as I know, all statements in that article are based on facts, but I would like to know if there's anything that has been overlooked.
Are you the author of the SO answer?
Yes. Please feel free to ask if you have any questions or if anything's unclear. The article dates back to 2010 and is supposed to give a complete picture.
Thanks I'm a bit confused about the cluster term in your answer, does this mean running multiple servers or running multiple instances of a application server in the same server? or maybe both? About Unicorn, can the master process reside in one server and the worker processes reside on another server? Also, if you say there is no need to start a cluster in passenger, how do you scale with passenger? Edit: I think you should also make it clear that Unicorn can actually server slow clients when behind nginx. Edit2: When you mention this article: http://blog.phusion.nl/2013/03/12/tuning-phusion-passengers-concurrency-settings/ and in a single-threaded multi-process case, is just saying to setup passenger as the same setup Unicorn uses(preforking mode)?
I know, but if he wants to be unbaised, he should make a little bit of an attempt to sell the other products. Still, passenger rocks
Mongrel and Thin clusters are multiple instances on multiple ports on a single box, to a point. You want at least a few instance per cpu core, but eventually you'll reach a maximum efficiency where you have just enough instances to max out the cpu and for any more performance you'll need to add more boxen. You scale Passenger by adding more boxen behind a reverse proxy, just like with Mongrel and Thin. In the past (current versions may have changed) you also tweaked minimum and maximum workers that Passenger would start up, kinda like Mongrel and Thin instances except they are dynamically allocated as determined by Passenger between the minimum and maximum. I'm not an expert but I've ran Mongrel (back when it was the shiznat), Thin, and Passenger application servers.
As for inaccuracies, Puma is entirely based on Mongrel https://github.com/puma/puma/commit/190a81c55a1cbf215658b8fd6bb7ce2a0326b6c6
Saying that it's unbiased because it's based on facts, when you give 1 paragraph to every major option except passenger, and then write 20 articles about passenger, is a non sequitur...
&gt; I'm a bit confused about the cluster term in your answer, does this mean running multiple servers or running multiple instances of a application server in the same server? or maybe both? In the context of the article, "cluster" refers to tools such as mongrel_cluster, `thin --server`, etc which aid in starting multiple processes on the same server. In general usage however, the term "cluster" can refer to multiple servers. But yes now that you mention Phusion Passenger clusters, I see how it is confusing. The point is that for some app servers you have to run multiple processes to get concurrency out of it. It doesn't matter where those processes run: they can reside on the same server or distributed over multiple servers. When the article says that Phusion Passenger does not require one to start a cluster, it means that there is no need to run a command like "passenger cluster start --count 16" or something and then hooking all those ports to the web server. Phusion Passenger starts all the necessary processes for you. If you want to scale beyond one server then yes, you need a cluster: you need to run Phusion Passenger on multiple servers and put them behind a load balancer. &gt; About Unicorn, can the master process reside in one server and the worker processes reside on another server? No. The Unicorn master process must run on the same server as the workers. &gt; Edit: I think you should also make it clear that Unicorn can actually server slow clients when behind nginx. They can. Was that not clear from the article? &gt; When you mention this article: http://blog.phusion.nl/2013/03/12/tuning-phusion-passengers-concurrency-settings/ and in a single-threaded multi-process case, is just saying to setup passenger as the same setup Unicorn uses(preforking mode)? Yes, Phusion Passenger is single-threaded multi-process mode works the same way as Unicorn, and so the advice applies to Unicorn as well. The advice even applies to Mongrel, to Thin when the app/framework is not evented, and to Puma/Rainbows when it's running with 1 thread.
In my opinion, Phusion Passenger has a lot more features and advantages than the other app servers so naturally I can write more about it. Still, concrete feedback about how the article can be improved is welcome. I've already incorporated jc00ke's correction and I'm thinking about ways to incorporate DerEngel's feedback.
I'm not discounting JRuby as a valid option. I'm discounting JRuby in the article because its market share compared to MRI is tiny. This article was originally written in response to someone who's new to the Ruby deployment ecosystem, and such people are probably already not using JRuby, so in that context it makes sense to focus the article on MRI. However when viewed from the angle of someone who's already familiar with the ecosystem, then yes mentioning JRuby is important. I'll think about how this can be properly integrated into the article without diluting the picture for newcomers. There are very good reasons to use JRuby though, and one of those reasons is documented in the "I/O concurrency models" section. In fully support JRuby (and also Rubinius) in what its good at, and what's why [Phusion Passenger 4 introduced JRuby and Rubinius support](http://blog.phusion.nl/2012/10/30/phusion-passenger-4-0-supports-jruby-rubinius/). I am not ignoring Trinidad and TorqueBox. I simply do not know enough about them to write a whole lot about them. When it comes to J2EE-like features, yes it looks like TorqueBox offers more. That said, many J2EE features already have established equivalents in the MRI world, e.g. scheduling -&gt; cron, distributed keystore -&gt; memcached/redis, daemons -&gt; tons of libraries, clustering -&gt; HAProxy/nginx, hot deployments -&gt; we'll introduce this soon :). I've thought about introducing some of those features in Phusion Passenger but given the established external MRI alternatives I'm sure whether it makes sense. Now that we're on this topic: does anybody feel that adding these features is a good idea for Phusion Passenger? Please let me know.
Market share or present popularity are largely irrelevant to how useful a tool is if we are attempting to be objective; none of the JRuby application servers I am aware of have been around for a huge length of time, anyway. I don't think you need to know a lot about them to list and compare their features (and drawbacks) on a basic level, invalidating statements such as: &gt; Compared to other app servers, Phusion Passenger has far fewer moving parts. You provide no proof for the former bit, and to a great extent it is subjective and likely dependent on exactly what you're trying to achieve... &gt; Also unlike other app servers, Phusion Passenger is primarily written in C++, making it very fast. Ergo not being in C++ makes it slow? I'm not sure that necessarily stands to reason. It just seems you make what, ostensibly, seems like a broad comparative of Passenger vs other app servers; you then discount the analysis of servers that offer similar feature-sets, and make statements such as: &gt; Phusion Passenger provides a lot more features and provides many advantages over other app servers, such as: [list of features] As far as I can see, most or all (and more?) of those features are available are available in the aforementioned. There are even other simpler ones like Square's Jetpack, Mizuno etc for those that have somewhat different workloads. I appreciate your effort, but whilst your SO post is superficially a comparison of Ruby ASes, it presently registers more like promotional material for Phusion Passenger. So much of your article talks directly or indirectly about it... Edit to address your edit!: &gt; many J2EE features already have established equivalents in the MRI world One of the points you make in your article is about the negative consequences of too many independently moving parts! Sidenote: J2EE went away in 2004, just JEE now, and I think the presence of those features in the Java world doesn't necessarily mean that they are bad for the Ruby world (or that you even need to use them, of course).
He should disclose it in the article.
Very well, point taken. As for whether torquebox-like features are useful on MRI, I hadn't considered that I may be contradicting myself. I'll consider those features. Thank you for your feedback.
I must confess that I had not heard of `her` until it was linked in the comments, which is a shame as it may have saved me a significant amount of time! As remiprev stated, Rapidash is based on the concept of a client that is responsible for handling the the requests and it does so by managing resources. Everything should be called initially from the context of the client, `client.users!` or `client.repos!` as this is how many gems (such as Twitter and Github) work. 
EHUMORTOOOBTUSE :P
Anything from Pat Shaughnessy is awesome. Great writer, great speaker.
You're probably right. I'll probably just do a dual boot with Linux, but last time I did that it ruined my computer. I used Ubuntu last time, do you think I should do something else?
Awesome. Thanks.
lol noob. You an just install it on a VM in the worst case. Just try googling, it's easy.
Debian Wheezy/Sid all the way. Avoid WUBI or anything and follow their instructions to the letter 
lol I've never really done any programming in Windows except C# and my Linux computer got stolen. All the tutorials I've found sucked so far which is why I asked you guys. I was going to use Cygwin but I kind of hate it.
If your computer is powerful enough, I'd recommend running linux in virtualbox over dual booting. 
What these guys said. You *could* run Vim + Ruby on Windows but it will make your life hard. Its very easy to install VirtualBox and then find a Linux VM you can download ready to program on out of the box.
Do you have any specific questions? My experience with vim and ruby on windows is just install ruby and vim and run it from command prompt. No real issues to speak of, except the fact that I preferred notepad++.
I would set up the vm using vagrant + puppet; but you could just apt-get install: Ruby1.8 Ruby1.9.1 Install RVM from RVM.io Install pathogen (for vim) and syntastic And you can just vim helloworld.rb
Good point, but he could still use conditional requires to prevent parsing files that are 2.0 only vs 1.9
What's wrong with WUBI?
Ubuntu is good. Try virtualbox, it's worth it.
What did he message you? I NEED TO KNOW
This is a few topics all lumped in together. There's a Ruby installer for Windows and one it's installed Ruby doesn't care what OS you use. Likewise vim has a installer for windows and there's nothing special about what language you're writing or what OS you run once its installed. You're best off deciding what it is you actually want to learn, if that's Ruby don't feel compelled to use vim or find tutorials specific to Windows, just find a good Ruby tutorial and ask a targeted question if you hit a Windows specific road block. If what you really want to learn is vim no good tutorial for vim should be specific to an OS or language, so just find a good vim tutorial. Last if you're comfortable with Windows don't listen to anyone who tells you that's bad. You'll probably want to learn *nix at some point, but Windows is capable of doing Ruby development same as Linux.
Vagrant and Puppet or Chef are all well and great. We're talking about a total newb here. That's a lot to try and swallow. Virtual Box with Ubuntu is plenty for the moment. When he needs to start managing his environment more (much) later on, then sure. But people are sometimes way too quick to just dump way too many moving parts on people too early.
Two options: 1. [Ruby Windows Installer](http://rubyinstaller.org/) + [gvim73_46.exe](http://www.vim.org/download.php#pc) 2. Install [Fedora](http://fedoraproject.org/) (`yum install ruby ruby-devel rubygems irb`) / [Ubuntu](http://www.ubuntu.com/) (`apt-get install ruby1.9.1-full`) in [VirtualBox](https://www.virtualbox.org/).
[Fedora](http://fedoraproject.org/) is alright too.
Thanks. I have experience in VIM unfortunately from college. I avoid it like the plague though. I'm not sure why everyone likes it.
It installs it all weird, last time I used it it corrupted the MBR and I had to reinstall everything. It may be easy, but easy is not always the best when it comes to linux. 
I like it because I am fantastically efficient at writing code in Vim, far more than I was with any other editor. With the right set of vim plugins, and a few days of forcing yourself to learn, you too can be efficient. The bimodal editing capabilities of vim just make it ridiculously fast to move through and edit any kind of text.
This is what I hear. Any good tutorials that helped you out? I haven't used it in two years...Not that I would tell an employer that.
Virtual machines are way easier than dual booting. Especially if you use [vagrant](http://www.vagrantup.com)!
[Learn vim progressivley](http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/)
Personally, the passenger propaganda has intrigued me ;-) At the moment I have 3 rails apps running on a Linode. Each app has it's own thin app server and then I use nginx as a reverse proxy and to server statics. Would the whole setup consume less memory if I used Passenger instead of thin?
[Ruby Monk](http://rubymonk.com/) is a great primer for beginners. It walks you through the basics and you'll be able to complete the whole thing in about 2 hours.
Cygwin is okay, but it is messy, and doesn't feel right in Windows.
Ruby in Windows is messy, and the support from the community is limited. Travis-ci doesn't even offer Windows as a test environment, which means that most gem creators have no way of telling if their creation works on Windows or not. I think one should use Linux (or OS X) for Ruby programming, you will waste time going with Windows for Ruby development, because of edge cases not covered in guides. I see a lot of issues in opensource projects where Windows users gets unexpected behaviour in their Ruby programs.
Windows isn't bad, but running ruby on it still isn't a good idea. Spending time learning how to get a ruby ecosystem successfully up and running on a linux box instead of manhandling Windows into partial submission will save you a lot off hassle in the long run.
Check if the typical users of your gem *can* (i.e they are *able to*, not *want to*) use Ruby 2.0 in their projects. If so, then bump. Otherwise, wait a little bit more. In any case try to not encourage people to stick with old versions for too long… We all know to what kind of "legacy code" issue it leads.
+1 for using Vagrant -- it's my preferred development workflow on Windows and makes it so much easier than trying to make some gems (like rdiscount (for markdown), imagemagick (for image manipulation) etc. work on windows). Vagrant has good documentation on http://www.vagrantup.com/
Thanks for your interest. :) Just in case you didn't know, I'm one of the Phusion Passenger authors. The answer is: it depends. You will probably not gain any advantage in memory usage just by switching to another app server. Some tweaking however gets you very far. Let's first consider the base memory usage of the app server itself, not counting the framework and the application. Most Ruby app servers are just not that large: * Puma is ~1700 lines of Ruby + ~2100 lines of C. * Unicorn is ~1900 lines of Ruby + ~4000 lines of C. * Thin is ~1700 lines of Ruby + 1500 lines of C. Even if you count KGIO (Unicorn dependency) and EventMachine (Thin dependency) too then that makes them a bit larger but not outrageously much. Phusion Passenger has a much larger codebase than the rest, but it's for the most part C++ so it doesn't use a lot of memory. In Phusion Passenger 4 we stripped the Ruby parts to their bare minimum. That reduced memory by about 600 KB. By switching app server and without further tweaking, you lose/gain at most a few MB. In my opinion, negligible considering that a typical Ruby app process can consume 100 MB. If you search Twitter you will see that people regularly say that they switched from app server X to Y and saved a lot of memory. Other people say that they saved memory by switching from Y to X. Contradicting statements. My guess is that they didn't fully understand why an app server uses memory and based their opinions on the default settings. So tweaking is important. The most prominent tweaks are: * Change the number of processes. The more processes you have the more memory you need. [This Phusion blog article](http://blog.phusion.nl/2013/03/12/tuning-phusion-passengers-concurrency-settings/) gives advice about the number of processes you should have. Although written for Phusion Passenger, the advice applies to all multi-process and multithreaded app servers. However for simplicity reasons the advice only applies to setup with 1 app. You have 3 so you need to think about how you should divide your resources amongst the 3 apps. * Change the I/O model. You can save a lot memory by using multithreading instead of multiprocess. This is also explained in the article. If you currently run a lot of Thin processes then this will by far save you the most memory. * If you have to stick with multiprocess, use copy-on-write forking. Phusion Passenger was the first to introduce this feature in Ruby, in the form of the smart spawning method, and the use of Ruby Enterprise Edition (which was our branch of Ruby, in which the garbage collector was made copy-on-write friendly). This saves you about 33% memory usage if you have at least 3 processes. Ruby Enterprise Edition has since been end-of-life'd, and the MRI core team never accepted our copy-on-write patches for reasons that they never clearly disclosed, but Ruby 2.0 has its own implementation of copy-on-write-friendly GC. Note that Unicorn's preload_app feature is the same as Phusion Passenger's smart spawning. * Use a dynamic number of processes. At this time only Phusion Passenger supports this feature. It spawns more processes when traffic becomes high, and shuts down processes when traffic becomes low, in order to save memory. It should be noted that multithreading is not available in the open source version of Phusion Passenger, but is available in [Phusion Passenger Enterprise](https://www.phusionpassenger.com/enterprise) since version 4. If you are looking for a free solution then this may not be a good choice for you. If you are not afraid of paying very reasonable licensing fees (we even provide discount for cash-strapped startups), then Phusion Passenger Enterprise provides you with a lot of advantages, e.g. deployment error resistance, automated rolling restarts, support, etc. On one server of ours, a 1500 MB RAM Linode, we run about all Rails apps all on Phusion Passenger Enterprise 4 with multithreading turned on. For each of our important public-facing apps, we run 1 process with 16 or 32 threads. This saves a lot of memory compared to when we were on Phusion Passenger Enterprise 3 (which did not support multithreading). We also have a number of internal apps, like Redmine, Gitlab, etc. We only access them once a day or so, so we configure them with `passenger_min_instances 0` so that they're completely shut down when we're not accessing them. When we do access them, Phusion Passenger automatically starts a process. This starting takes a few seconds which is annoying, but it saves so much memory for the public-saving sites on our server.
&gt;your developing environment doesnt have anything to do with learning ruby because it is cross platform Cross unix platform. Just because you can sort of install it on windows, doesn't mean the rest of the ecosystem will. Ruby development, as does most real software development outside of visual studio, really takes place on unix based systems. So linux or a mac. I agree with your statement about editors though. Might not want to start off with Vim. 
You do not have to use Phusion Passenger's installer. You can [compile Phusion Passenger just like any other Nginx module](http://www.modrails.com/documentation/Users%20guide%20Nginx.html#_installing_as_a_normal_nginx_module_without_using_the_installer) without using the installer. If compiling the system's Nginx at all is a problem, then there are the following solutions: * [Brightbox provides Debian packages for Nginx with Phusion Passenger support.](http://www.modrails.com/documentation/Users%20guide%20Nginx.html#_installing_or_upgrading_on_debian_6_or_ubuntu) We work closely with them to ensure up to date packages. * [Erik Ogan provides RPM packages for Nginx with Phusion Passenger support.](http://www.modrails.com/documentation/Users%20guide%20Nginx.html#_installing_or_upgrading_on_red_hat_fedora_centos_or_scientificlinux). * It is also possible to use Phusion Passenger Standalone and hook into Nginx using reverse proxy, just like the other app servers. Unfortunately there's no way to integrate into Nginx the way we do without recompiling it. Nginx does not support dynamically loadable modules, so it will never be as easy as Apache to extend Nginx.
Worked fine for me for months. 
I think you're still missing the point. Pretty much all Ruby programmers are going to end up on some unix-like system, but OP's question was about learning Ruby (also learning rails is another issue entirely). For learning on Windows you run an exe installer and rib, gem, and Ruby is in your path. Your first steps with Ruby shouldn't involve installing gems or shelling out, it should be playing with rib, writing methods and classes and running simple scripts. Once OP has a feel for the language and wants to do more he *will* end up fighting Windows, but the idea is to spread out the learning and focusing on one thing at a time. Learning a new OS or editor is good, but pretending like that's a requirement for learning Ruby is a good way to make people give up and find a "simpler" language
Fair enough, can you say much about it? What may make it different from railsinstaller.com?
The upside of a corrupted MBR is that you can rewrite it without having to format the drive and/or install windows.
If your app serves fast-running workloads only, ideally 1 process per core. This is to avoid context switching overhead. Context switching not only saves/loads registers to memory, it also pollutes the CPU cache because of the switch to the kernel. If you can, use CPU affinity settings to stick a process to a core only, and do not allow any other processes (including the kernel) use that core. That will give squeeze absolutely everything out of your core. In practice, in the context of web apps, you're unlikely to notice any difference with this setup. But if you're doing something like password cracking or scientific computing you'll gain significant speedups.
Compressive? Perhaps you meant "comprehensive"? 
Whoa whoa whoa now how do you do this?
Wow that's cool! Thanks a ton for telling me, this should come in handy 
The scary/difficult part of ORMs is when you get to relationships. Otherwise... why not use DataMapper?
great work :) good to see programmers using programming patterns and hiding AR api +1 for the idea
Impressively comprehensive - "Imprehensive" or the colloquial version "Compressive"
Yey! Rubies!
Torquebox is sublime. We're running our production system on it and are using Trinidad as a stopgap while we migrate legacy apps across to our new architecture. No issues with either.
Hello fellow patriot
Wow! That was cool!
Whew, that's expensive! But I'm in DC, so I'm jealous that you're attending!
Thanks a lot, that was more or less my biggest question surrounding this book. I'm assuming the "best practice" way of writing Ruby is still largely the same as well then? (sorry for the additional question)
David's book addresses larger issues than syntax so the recommendations are still quite valid. You might prefer 1.9's new hash syntax `{foo: 'bar'}` or "stabby" lambdas ` (foo) -&gt; { do_thing(foo) }` but this is mostly a cosmetic difference. I would also *strongly* recommend Sandi Metz's [*Practical Object Oriented Design in Ruby*](http://www.amazon.com/dp/0321721330). It'll give you a great foundation in real-world use of OO design principles. I really love that book and Sandi is awesome too.
Hi, where is the source code? Can't find any link to github.
No offense, but this is pretty crappy as announcements go. Use the body to tell us why we'd care about the project and include a link to the project site. This might be awesome, but noone will ever know.
And my apologies if the description sucks but the README goes into a lot more detail. I figured that'd be enough.
&gt;xpool is a lightweight process pool. The pool manages a group of subprocesses that are used when the pool is asked to dispatch a 'unit of work'. A 'unit of work' is defined as any object that implements the run method. All subprocesses in the pool have their own message queue that the pool places work onto according to a very simple algorithm: the subprocess who has scheduled the least amount of work is the subprocess who is asked to put the work on its queue. The message queue that each subprocess has is also what ensures work can be queued when the pool becomes dry (all subprocesses are busy). Incase a unit of work raises an exception that it does not handle xpool will catch the exception and mark the process as 'failed'. A failed process can be restarted, and it is also possible to access the backtrace of a failed process through XPool and XPool::Process objects. The exception is also re-raised so that you can see a process has failed from the output ruby prints when an exception is left unhandled.
Ever looked at [rinda_eval](https://github.com/seki/MoreRinda)? Have a look in the example section. It's pretty great.
if the objective is: `"runs a computation inside child process and returns the result via tuple"` then I've solved that problem in [iprocess](https://github.com/robgleeson/iprocess) a while ago. The premise is the same: spawn one or more subprocesses and return a result(a Ruby object) from each subprocess to the parent process. 
Um... Project author here. Name is Grant Olson and I have no idea who Chris Heald is. (No offense if you're out there Chris.) The home page has a giant orange disclaimer saying that it's not affiliated with either the rubygems or rubygems.org projects. In some ways I wish I hadn't chosen a name that involves "Certificate Authority". Although it's an accurate description of what the site does, it implies to some people that I'm somehow trying to control everything or make a power grab and I'm the arbiter of what can and can't be trusted. This is not the case. The CA part of the project has always been listed as experimental. It's as much of a proof-of-concept of a full end-to-end system as anything. What I would like to see happen (although I don't think I'll ever see it) is that this exists in an experimental but usable state, all the kinks in the system are worked out, and what is learned from the experiment allows rubygems.org (or some other more official organization) to write up their own policy based on what we've learned and roll out a 1.0 version of the project. I also have even more pie-in-the-sky ideas. What if local user groups setup signing keys and only signed off on established members that they know in real life who've signed off on a code of conduct? Stuff like that. But for all that to happen, the first step is that gem developers need to sign their gems. In addition to being a proof of concept, the project is also trying to provide some better incentives to actually sign your gem if you're a developer, and check for signatures if you're a gem user. You don't need to track down 180 public keys to install rails. When I do talk about the subject, I'm pretty clear on all this, but maybe I do need a corny MISSION STATEMENT page that explains what I'm trying to do all in one place. 
gotcha, I've added a direct link to the github repo to avoid confusion.
A mission statement is definitely a good idea, it appears there's still much confusion about what rubygems-openpgp-ca.org is. We at Phusion are already in the process of signing all our gems with our PGP key, which in turn is signed by rubygems-openpgp-ca.org. While the system is not (yet?) perfect, it's heading into the right direction and we'll gladly cooperate to make it better. The next Phusion Passenger release will be signed using the rubygems-openpgp-ca.org method.
To add on to ReinH's extra book suggestion, I would toss in Russ Olsen's [Eloquent Ruby](http://www.informit.com/store/eloquent-ruby-9780321584106). It's an outstanding introduction to *idiomatic* Ruby. I think that's what you're after with *"best practice" way of writing Ruby*.
This blog post lacks transparency and makes light of a security breach. I find it difficult to take a project aiming to improve security seriously when security breaches are presented in such a cavalier manner. Due to this security breach if you are trusting rubygems-openpgp-ca and an attacker is denying your access to the revocation list you (possibly one of your servers) will remain vulnerable for the next two months (at which time you will not be able to install gems). While revocation is explained which mitigates the effect of this security breach, almost no explanation of the security breach is given. Important statements like "only one key was mistakenly signed" and "we verified only one key was mistakenly signed by [doing something to verify it]" are absent. While this security breach was caused by a bug, no description of the bug or link to the commit that fixed it is presented. How can we be sure similar bugs aren't lurking that an attacker can exploit? I've looked at [the repository commit page](https://github.com/grant-olson/rubygems-openpgp-ca.org/commits/master) but can't find a matching commit title back through Feb 19. I did find several [commits](https://github.com/grant-olson/rubygems-openpgp-ca.org/commit/6f2f2f58e05b0e2ada7d2c6011d0f3b8f2d78725) [with](https://github.com/grant-olson/rubygems-openpgp-ca.org/commit/7aedef1f711a921851235ff08f4fefdc28615bf7) [useless](https://github.com/grant-olson/rubygems-openpgp-ca.org/commit/33d034855de96756a2656a7cd35d3d20156cd667) [titles](https://github.com/grant-olson/rubygems-openpgp-ca.org/commit/d9cf2c7e1750e6cb12ec410a3a97705d463463cc) so maybe I need to read every commit to find it.
Yeah, that's definitely "gross, but hard to argue with".
The Ruby Programming Language by Flanagan and Matz, very clear and concise, best book for core Ruby imo.
Hey there, I've been using RubyMotion for almost 9 months now. I learned iOS from scratch after being a Ruby/Rails dev for a few years. My suggestion: Go for it! You can always get your money back within 30 days if you don't like it. I wrote a bit about this here as well: http://37svn.com/3432 Let me know if you have any questions, I'd be happy to answer :)
-1. Why not fix the root issue why tests are slow? Figure out why startup time sucks, why the DB is getting hit so much, etc etc. Don't break more windows when fixing one.
The issue is that the GC is slow, and tests tend to involve lots of garbage creation. This is just trading memory for CPU time. I suspect that setting Rails-appropriate GC env variables would have a similar effect.
If your process size is so large that GC takes a significant portion of your test time you probably have architectural problems you need to fix. Fiddling with GC settings is a code smell much more than it is a language issue.
Oh, I get that, I'm just saying that "fix the slow tests" kind of sidesteps the issue at hand. I agree that excess garbage can be indicative of architectural issues, but it's not a given. Ruby's default GC heap settings are abysmal for a Rails app, and it may be that the OP has discovered why GC tuning is important - because avoiding GC thrash is an excellent way to speed up a Rails app, and not just in tests.
True, but you need to look at things in perspective. Rubygems-openpgp-ca.org is very much a work in progress. The author has been trying to convince the community to use PGP for the past 2 years. His effort has only gained widespread attention recently, which is why for the past 2 years he has been in a chicken-and-egg situation: he didn't bother polishing some security mechanisms because nobody used it (e.g. HTTPS was recently added in preparation for user logins, which don't exist yet), although that may have contributed to the lack of adoption. Now that people are starting to use it he's working on improving security on all ends. Things are not perfect from the first day. It takes time.
This really only works for smaller test suites, or running them on larger systems. It might be worth it in your post to mention as such, as ... too many people never follow up on why these things are not a good idea. Other than that, it likely has no downsides and probably does have huge performance benefits. It's a hack, plain and simple, and should be treated as such.
I think what eric's saying is that the code is likely creating too many objects, and that fixing that will likely have better benefits than turning GC off. Like I mentioned in my other post, it's a hack, and the appropriate way to deal with applying a hack is to use it only when you need to, and acknowledge there's a root cause to fix still. It's a trade of time for what you need today, it doesn't mean you should just set it and forget it. And FWIW I've seen a few shops use those GC tuning bits, and while they certainly make things faster, I can say without fail that adding another server has yielded a much more significant benefit both over time and the energy invested in maintaining them than any environment variables ever have. And, well, with the cost of servers vs. employees these days, chances are the amount of time I'd spend getting those numbers "just right" will pay for several months worth of a server which will out class it on more than just the GC front, and if we're being really honest, rails performance is probably taking a back seat to I/O or database performance in most situations.
&gt; This really only works for smaller test suites, or running them on larger systems Depends what you mean by smaller test suites I guess. The normal runtime for the test suite I tried this on is about 50 minutes.
You're welcome. :)
https://github.com/defunkt/hub
I appreciate the enthusiasm, but I think *widespread adoption* is pushing it. ;) But a few people are starting to take interest. The original website was written in 'weekend project' mode. So yes it's sloppy and the commit messages aren't well thought out. I was trying to get something out the door. I'd like to note a majority of the authentication goes on outside the web app, manually, by a human. All the web app does is deliver an encrypted email to confirm the email holder controls the primary key. Other than that, it's just a jekyll blog. The real work happens when I manually retrieve the key and examine it, manually check the rubygems page, and manually sign off on the key, all outside of the web application. I had no guarantees that anyone would even use the site, so yeah I decided I wasn't going to spend my own money out of my own pocket to buy an https certificate until people actually used the site. Especially after I just spent $200 dollars out of my own pocket to get setup so that I could test the software on Windows. At the time the bad signature was issued, I was still the only person who was signing gems with rubygems-openpgp. To fully exploit the grand 2 or 3 users who had potentially installed my certificates, a real malicious user would have had to upload the gem to rubygems.org or orchestrate some MiTM attack. And if a user could do that, there would be bigger problems than the bad signature. So going the whole CVE route seemed a little premature. As I said a few posts up, the goal was never to establish myself as the lord and ruler of rubygems authentication, but to provide a working demonstration of a full end-to-end system where we can kick the tires.
I said "widespread attention", not "widespread adoption". ;)
I haven't read it, but if you need a foundation try [Ruby Monk](http://rubymonk.com/) and [Ruby Koans](http://rubykoans.com/) are great starting points! Nevertheless, enjoy your journey!
Generally I prefer [pry](http://pryrepl.org/), as it offers quite a bit out of the box and rocks at doing things
You can even mix some of the things OP talks about into your `.pryrc` For example, I have `awesome_print` and `hirb` loaded in my pryrc: begin require 'awesome_print' Pry.config.print = proc { |output, value| Pry::Helpers::BaseHelpers.stagger_output("=&gt; #{value.ai}", output) } rescue LoadError =&gt; err puts "no awesome_print :(" end # HIRB begin require 'hirb' rescue LoadError # Missing goodies, bummer end if defined? Hirb # Slightly dirty hack to fully support in-session Hirb.disable/enable toggling Hirb::View.instance_eval do def enable_output_method @output_method = true @old_print = Pry.config.print Pry.config.print = proc do |output, value| Hirb::View.view_or_page_output(value) || @old_print.call(output, value) end end def disable_output_method Pry.config.print = @old_print @output_method = nil end end Hirb.enable end 
I know this is a few days old and your edit looks like you've made a decision - but I'd like to add my experience. For iOS development, RubyMotion has been a life changer. I have a couple iOS apps I'm working on just as personal side projects and I don't know what it is but for the life of me, I can't wrap my head around objective c syntax. I can read it just fine but when it comes to writing it, I'm a moron. It's so frustrating. RubyMotion has allowed me to write in 3 days what would have taken me 2 weeks in Obj C. And as a personal note, since i'm able to read ObjC just fine, it makes figuring things out easy as I can find obj c solutions to the problems I'm trying to solve and easily convert it to ruby. TL;DR - A+ product. Highest recommendations.
Was just playing around last night with sharing Ruby objects between Pry sessions with Drb. Fun time with .pryrc! https://gist.github.com/havenwood/5194155
If you like Pry, and want a bunch of plugins installed in your interactive environment, without having to play with Gemfiles, you can try: https://github.com/nviennot/irb-config It's good stuff :)
Yeah, it's really simple to convert objc to RubyMotion. However (and this is something I learned later... would have been nice to know initially but I guess converting code is always a good way to learn) - RubyMotion does provide the ability to take a Obj-C library and include it into your project. I dont have my code in front of me so I can't look up specifics but it involves putting the library in a vendor/LibName folder and adding a few lines to your Rakefile. 
You hear about the great walls Rome just built to protect you from Gauls, Vandals, Huns, etc. Because their marketing is so great you decide to move there. After all, your village was sacked just last year which was really terrible. After a year the city leaders proclaim "Hey! The Gauls totally broke through a section of the city wall and sacked 1/3 of the city! Just kidding! It actually only fell down for a few hundred cubits when some trader leaned on it. This is why we also have a city guard and it's totally effective! Look at all this training we do! LOL! Also we got great stone masons, they'll have some new wall fixed up in another two years or so!" Do you feel safe in Rome? All the ads said moving to Rome was great because they were so good at this security thing! Then they had a breach and didn't explain basics like how many other sections of wall are going to fall over when someone leans on them or how did nobody notice the wall was unstable in the first place. Instead they talked about how great the soldiers were. You even go to public records to try to finds some answers but it's so disorganized you can't find the wall building records. Also, several documents are filed as "AAA". I would say maybe Rome isn't so great, sure, they're advertising this awesome wall, but they don't seem to take it seriously enough.
Already completed those, actually! I didn't mean *that* foundational
cross posted to /r/rails for you.
Sure, when I get home. :-)
Nice list of improvements in 0.9.0, grats on the release!
$200 is a chunk of change but you can install it on as many computers as you want: unlimited. Sure, you can only use it on ONE computer at a time, but to me that ^ is pretty cool. 
Not a book, but 6 videos. Created by Josh Cheek at 8th Light in Chicago: http://ruby-kickstart.com/ I've always struggled with programming but this is really geared toward noobs in my opinion. There is also lots of exercises to do with solutions on his site. Guy is a beast, check it out. 
thanks :)
Tried it; didn't work under Rails 3.2.13: action_cost/engine.rb:11:in `&lt;class:Engine&gt;': undefined method `app' for #&lt;Rails::Paths::Root:0x007fbac120fea8&gt;
*Note: I responded to the cross-post in /r/rails without realizing I wasn't commenting on the original post, so I copy pasted it here.* You don't need to patch the `execute` method in the adapter directly as you do [here](https://github.com/plerohellec/action_cost/blob/dc5b06df6c93c6235941621191de18b0576dd3c9/lib/action_cost/extensions/postgresql_adapter.rb#L5-L11). Rails already instruments ActiveRecord queries through the `ActiveSupport::Notifications` module. [The original execute method](https://github.com/rails/rails/blob/v3.2.13/activerecord/lib/active_record/connection_adapters/postgresql_adapter.rb#L649-L651) calls the [log method in the adapter](https://github.com/rails/rails/blob/v3.2.13/activerecord/lib/active_record/connection_adapters/abstract_adapter.rb#L274-L287) which provides the sql information and more under the key "sql.active_record". Just hook into that in your engine by using [the ActiveSupport::Notifications.subscribe method](https://github.com/rails/rails/blob/v3.2.13/activesupport/lib/active_support/notifications.rb#L129-L133). Hooking into AS::Notifications provides multiple benefits, two of which are that you aren't monkeypatching the `execute` method, and since the `log` method is defined in `AbstractAdapter`, your engine can work for all sql adapters, not just postgresql.
Neat idea, but if the stats live in the process memory, how does it work with something like Unicorn where there are many Rails processes? Actually, most Ruby app servers behave that way...
Why wouldn't one just use New Relic to get this information? 
Title should be: Phusion Passenger ad of SO updated [2013 edition]
Can anyone please explain this behavior?
Actually, the best hire I've had has come from this sub reddit. Never noticed /r/forhire before but it seems like a hodge-podge. I'm not trying to hire an accountant.
I'm not affiliated with Skillshare.com, other than I just signed up for this class and wanted to share the link. 
I meant 5 KM, sorry for the confusion. 
&gt; 5KM marathon wat
Very useful. Except I kept hoping they'd &gt; come back to Kernel later, as promissed. I didn't realize Kernel showed up in #ancestors after Object (but without being Object's #superclass?! Is it a mixin?). 
I came here to say this, seems futile using ruby to accomplish this task
nice, ruby stdlib Delegator is oft overlooked, and very useful. You often don't really need to specifically refer to `__getobj__` or `__setobj__` in a SimpleDelegator implementation. The first example in OP could also just be: class Displayer &lt; SimpleDelegator def name_with_location "#{self.name} of #{self.city}" end end Instead of `__getobj__.name` etc. That's the whole point of the delegation, right? You've got the methods on the delegated obj right there. You only actually need `__getobj__` if you specifically want to refer to a method on the delegated obj, when you 'over-ride' the method in the delegator. It's sort of like `super` for delegation. Occasionally that comes up, but rarely. I'd say developers using `delegate.rb` often over-use explicit `__getobj__` when they don't need to, leading to weirder looking code than need be. 
Check out the [Ruby toolbox](https://www.ruby-toolbox.com/categories/deployment_automation). I've used [Vlad](https://github.com/seattlerb/vlad), but didn't find it compelling enough to use over Capistrano. They're both pretty solid. [Rubber](https://www.ruby-toolbox.com/projects/rubber) is an AWS-specific plugin for Capistrano that might get you in the right direction.
I'm solidly in the Capistrano camp, though deploying a fresh Rails 4.0 app is still not working because of the change from YML to JSON for the asset manifest...
Capistrano
If you do this: class Foo &lt; Array ... end This is almost always going to be less pain later: require 'delegate' class Foo &lt; DelegateClass(Array) def initialize super(Array.new) end ... end And that goes for pretty much any core type. There's a lot of words used in the past elsewhere that go into details but the short of it is you're not always calling into ruby when you directly inherit, and that has some surprising behavior.
+1 nothing else to add here.
Vlad for all our apps, does passenger, unicorn, thin, rainbows, puma and anything custom
thanks for this advice. It looks like it does annoyingly change `kind_of?` though. With `Foo &lt; Array', `some_foo.kind_of? Array` and `some_foo.kind_of? Foo`. With `Foo &lt; DelegateClass(Array)` in 1.9.3, it looks like `some_foo.kind_of? Foo`, but _not_ `some_foo.kind_of? Array`. That's actually kind of surprsing that DelegateClass doesn't fix kind_of? to be right too, hmm. I suppose one could do it oneself def kind_of?(arg) super(arg) || __getobj__.kind_of?(arg) end what do you think, ba-cawk? 
This is a good tip, I will remember it! Also with regards to those core types, it's often better to build your own class that wraps an array but doesn't delegate everything, unless you really want the giant public api it has. Otherwise it makes sense to keep it more narrow and focused.
Capistrano I deploy most of my stuff with Jenkins to automate the Capistrano process as well
Ha, here's another thing that differs with the `DelegateClass(Array)` vs `&lt; Array` example in particular (I just tried to change to `DelegateClass(Array)` in an actual codebase where I was sub-classing Array). With actual Array sub-class, if you do actual_subclass.concat([1,2]), what you get back is still an ActualSubclass. With DelegateToArray, if you do `delegates_to_array.concat([1,2])`, you get a plain old Array back, you lost the delegation on concat. Why this happens is clear if you think about it. But it is annoying. DelegateClass fixes `dup` and `clone` specifically, but not other methods that will return another thing of same class as receiver -- with a true subclass, it just works, but not with a delegate class. 
I use Puppet.
I use [DeploYML](https://github.com/postmodern/deployml#readme) (biased). There are a few other minimal code deploy tools, [Inploy](https://github.com/dcrec1/inploy#readme), [ScrewCap](http://grantammons.me/screwcap/), etc.
Capistrano: easy &amp; powerful
I work at a company that manages over 200 instances. For all intents and purposes I am a developer, and although we have a team strictly based around operations, I am the go-to dev-ops for the team I work with. Use capistrano if there is not much diversification between your instances. Capistrano does not have good abstraction for system level work (installing packages, creating symlinks, etc.). This is fine if your applications are largely homogeneous. Capistrano is great because it allows you to get deployments up and running quickly. Use Chef if your company has instances with different needs. Chef has an amazing DSL for configuring system level work, including a deploy resource that makes life awesome, especially if you start using autoscaling. Chef is great because it allows you to manage and customize your different instance types. Capistrano is the quick and easy solution for small scale apps and companies that have instances that don't differ much in base configuration. Chef is the powerful solution for companies with many different instance configurations or those with an abundance of instances they need to manage. EDIT: I'd like to add that our company transitioned from Capistrano to Chef, and that if I ever worked at another startup, I would STRONGLY insist on Chef now that I know how to use it. The time one sinks into Chef is slightly larger than that of Capistrano, but the payoffs in term of technical debt for any company that diversifies its instances is HUGE.
I guess you are contributing to learning by giving your opinion on where Ruby might not be useful, I just read it as discouragement at first.
ah! good point. thanks!
Yeah, there are some gotchas to be aware of. Generally the trades are worth it -- similar to how Enumerable used to drive WRT hashes in 1.8, it doesn't really matter in the end if you know what's going to happen.
well, technically it's not a kind of, and the usefulness of that is debatable, as xternal mentioned. if you're familiar with Forwardable, it's like setting an ivar and the def_delegator to that ivar for anything that comes through. that doesn't make the class using def_delegator any more of what the ivar is set to, either. The problem is, almost always when you inherit from, say, Array, you're going to add behavior that makes it act like a not-array. That's what makes your class different, after all.
Yep, it largely depends on what problems you're solving. If you're saying "it's a lot like an array but it's special in this specific way", that's when I normally reach for DelegateClass. When I'm saying "I need to do something which works against something that has the properties of an array", that's when I do what you described. Kind of like the has-a/is-a arguments that have been beaten to death and don't need a repeat here. :)
He's spot on about the ecosystem. Look at the number of downloads on [rubygems](http://rubygems.org) vs [nuget](http://nuget.org). 1.4 billion vs 57 million. That being said, I like both languages and their frameworks. I look forward to a day when I get to use both at the same job.
Well, you get `kind_of?` even for Modules included, right? Module M ; end Class C ; include M ; end C.new.kind_of? M # =&gt; true To me, in dynamic type ruby land, `kind_of?` means "Has all the methods that class/module arg has" -- Which is why I'd expect the delegate implementation to be `kind_of?` the delegated object. It definitely 'quacks like' the delegated object, it's sort of the duck typing interpretation of `kind_of`. So i think it's debatable what is 'technically' the right answer for kind_of. But I do see it's debatable. I also see people claiming `kind_of?` use is questionable, but i've never agreed. Or rather, it might be questionable, but that doesn't mean it's always wrong. :) (I think `kind_of? Enumerable` is probably pretty legit for instance, no? And something that delegated to an obj that is Enumerable is pretty darn Enumerable itself!) I guess "if you inherit from X you're going to add behavior that makes it act different from X" is true of _any_ sub-classing, right? So is an argument against sub-classing in general? In this particular case when I sub-classed Array, it was to add a bit of additional metadata on to the array, about its context. The array represented some search results, and I added on `#total_hits`, `#per_page`, etc. All the actual array functionality remained unchanged. (I haven't before looked to see what ActiveRecord or Kaminari or something does in this situation; looks like at least in some situations kaminari [does similar](https://github.com/amatsuda/kaminari/blob/master/lib/kaminari/models/array_extension.rb))
After reading the article I was wondering if there's a way to let git execute arbitrary shell script for each checked out commit. Thanks for pointing that out, that's really useful. On thing, though: Running `rake spec` will execute the old specs on the old code and they will probably pass. You usually look for changes which break code you didn't have tests for in the first place. But that's just a matter of running a different test suite, of course.
yeah, pretty much anything by banister is gold. i guess this was extracted from [pry-stack_explorer](https://github.com/pry/pry-stack_explorer). do you use it outside of pry for something else? also, as a side note, irb has a (not as good) thing that lets you jump up and down stack frames and evaluate code in that binding. see ["irb/frame" on github](https://github.com/ruby/ruby/blob/trunk/lib/irb/frame.rb) (it uses a kernel trace func to do the job). ruby-debug/debugger has another one.
Yep! It was silly of me to discourage coding for the point of learning. Albeit I think you time may be better spent writing things that do not exist yet, for instance there are loads of exploits out there that do not have metasploit modules ;-P
I've been using it in a little output method for a proof-of-concept script: def o(desc, item=nil) item ||= binding.of_caller(1).eval desc.to_s print "#{desc}: " pp item puts end o :varaible_to_output
&gt; rad gem for making magic happen Or, translated from moronese to English: module to manipulate callers' lexical variables.
I have published Saxxy, a while ago, which is a DSL for building SAX parsers. It uses either Nokogiri, Ox or LibXML and is really easy to write your own parser bindings, check it out https://github.com/rubymaniac/saxxy I would love your feedback!
i wonder, wont you in an year or two switch from Ruby because of Rails... just like others did and still doing... 
There's https://github.com/feross/SpoofMAC, written in Python, which may lend insight into what all is needed.
I thought this functionality would be built into 2.0 I remember reading this at some point. I'll ask banister in irc ---- Edit: I asked him and he responded: &gt; `&lt;banisterfiend&gt;` Paradox: it is part of ruby 2 BUT it's not exposed to Ruby, it's part of the C API. I released a gem (debug_inspector) that exposes that API to Ruby, but the API is a bit weird, so i wrapped it again in binding_of_caller so the same api works across all supported ruby versions
or jruby
that's interesting, I hadn't seen that mentioned in any of the "what's new in ruby 2" type posts around the internet. thanks for that
That's a good way to automate it if the bug is in your application; if it's in a gem your application uses you'd need a long-ass bash command to do the bisect on the gem and run the tests on your app... 
Best point: Ruby finally stopped being cool. And that's a good thing for those of us who like to get stuff done. There's been less drama in the last year than I can remember in a long time. The Rails ghetto has gentrified.
This could enable so many very cool hacks. There have been a number of things I've wanted to implement, then realized I can't because I need to context of the calling method. For instance, with this gem it should be possible to build a method `fmap` such that given a function `def f(a); a * 2 end`, you could do `[1,2,3].fmap(&amp;:f)` and get back `[2,4,6]`. (ie. the symbol-to-proc map shorthand for functions instead of methods).
Gonna need to see an implementation of this. 
We've been using JRuby with my version of [quartz-jruby gem](https://github.com/ocher/quartz-jruby) in production for almost two years without any major problems. It works really great - you may run background jobs very often and almost for free (there is no additional overhead like running a separate ruby process with all gems). Most gems are JRuby compatible. You may only have problems with some gems which use C extensions, but in many cases more popular gems like Hpricot or Nokogiri have special version for JRuby (Java used instead of C). 
Unless you're a Java shop, there's no compelling reason to use Juby.
Unless you're a Java shop, there's no compelling reason to use Juby.
https://gist.github.com/burke/5228225
The difference I would think is that with ruby, you have an actual dependency manager whereas nuget is strictly a package manager.
+1. I actually use Capistrano for code deployments and let Chef handle everything else.
Or just switch to clojure
Threads aren't a compelling reason? There are plenty of other reasons, but how can you make such a broad assumption?
Two points: 1. Mutable strings are annoying. No idea why Ruby decided to go with this. 2. Unless you are using a language built around immutability, like Haskell, immutable code is also slower code. Sometimes orders of magnitude slower, so the usual argument of "if you want fast code you should write c" doesn't apply. It would be nice to mention this in the article somewhere. Hamster is cool though, I'd like to see more performance benchmarks of immutable code with Hamster vs. mutable code.
JRuby not only can take advantage of JVM's just-in-time compilation, it also has true threads and can therefore actually perform parallel processing. If you do any sort of data crunching that takes time, JRuby is great for the task.
Are these downloads real people downloading, or just mirrors and other programs. Every time, I push a new version of a gem (or a new gem) i notice the downloads start within seconds. However, for many I have never received an issue or bug report leading me to think that those several thousand downloads are automated.
Cross-posted from /r/programming. http://www.reddit.com/r/programming/comments/1asgrx/why_ruby/
Solution: "herp".freeze
Since the OP is apparently on Unix, he already has access to a working fork(), a less error-prone form of parallelism. And while the JIT wins sometimes, the bloated memory footprint will often bite you.
OP here. You make good points. 1. Agreed, it was probably not the way to go. I suspect it has todo with the closeness of C underneath the original Ruby implementation, and the nature of "strings" in C. Also, the libertarian philosophy of Ruby's design tends to make dangerous practices - like banging strings in place - possible. 2. Also agreed, being immutable is usually a bit slower. I touched on this with the laziness discussion, but I will think about emphasising it more. Of course, even if a language is designed around immutability, there are still performance implications in that. For example, accessing elements in Clojure's persistent vectors is not constant time - just very close to it. Mutable Java arrays are recommended for that last inch of performance when you need it.
Well written. Thanks. Taught me a thing or two. Looking forward to part 2. 
Personally, I find the idea of allowing the author to pick if an object is mutable or not is far preferible to having it picked by the language and architecture designer. Yes, some cases like fixnums arent, but how would you modify a number? You can't make it any more or less numbery (I think you went over this in the article). But, `"string"[2..4] = "dur" is useful (if it even works, i just woke up, its an example)
Thanks! I'm glad it's useful. 
I love seeing stuff like this posted here. I'm a newb to ruby and I hope to one day be able to post something interesting I've created. Thanks for sharing.
I felt the same for a long while, and just recently resolved to start posting things, no matter how half-baked I feel they are. Someone who finds it useful always turns up, and I'm sure whatever you come up with once you're more comfortable with ruby will be the same. Internet's a dang big place.
Sick. I'm actually looking though this to visualize some of the information. I'll drop you a line on twitter when I, undoubtedly, have a question.
Nice. I'm thinking about building something like canhekick.it next time I have a free weekend, and would love to help.
Well, awesome? I'm a designer and comfortable on the front end but Ruby is still new to me. So, looks like a good mix match of skills? I'll either tweet or pm you with an idea about making something.
You did not touch on blocks ?
You're developing on bsd/osx right? Just FYI, on Linux (at least the latest ubuntu) there is no: ifconfig -l EDIT: Oh, and as a default, you could grab the MAC of the default GW, disconnect, use the GW MAC +1, and reconnect. That's usually what I tend to do, and you always end up with a valid MAC (real vendor ids).
Ok, I think I understand what I was doing wrong. In the terminal I was using !ruby add_and_power.rb to run the script. So I tried by dropping the (!) and it worked. Can anybody explain to me what is the difference between !ruby and ruby In the command line?
Sounds like you're in the same camp as Matz with this, then. Ruby does exactly that - it leaves the power and responsibility to choose to the programmer. What Rich Hickey is saying is that we should extend the notion of values from just numbers to compound things like strings, collections, or other objects. Mutating a string is basically poking some memory addresses in place, which can be useful but it's not what we should be doing most of the time. This talk is what brought Hickey's argument home with me: http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey
Much better now ! Glad you made those changes.
I guess nobody should ever build Facebook apps.
Pitfall #2 is particularly interesting to me in light of the efforts to implement faster unittests via Corey Haines theories. There he uses the mixin with just one class so it helps keep it clean but the temptation for many would be to use that mixin in multiple classes
s/&lt;==&gt;/&lt;=&gt;/
I don't get all the hate, I thought this was a very well-written, very informative answer. Thank you!
This looks really interesting! Looking forward to seeing where this goes.
This misses Pitfall #0: Confusing what should be a class and what should be a module. An EmailReporter and PDFReporter should be separate classes, not modules, that Employee and Car send messages to to create the appropriate reports. Instead, write your modules like Enumerable and Comparable. These provide default implementations of commonly shared functionality that you can override with more performant or more appropriate behavior. 
Lemmiwinks.
To be fair, he does address your first point at the bottom of #2: &gt;Instead of using mixins, it’s often better to create a new class and call methods on an instance of that class. But I like your explanation better.
This feels like one of those cases where you would want to develop your own system for a more organic feel. I have yet to play with this gem, however, and will have to do so, but it looks fairly opinionated, and for any large app, lots will have to be changed likely. One of the strengths of devise is that you can just inject everything but the core into your app, so that you can customize it fully while still retaining updatablity
Yeah @Paradox I agree with you, as I wrote in the Future Plans section the idea now is build a easy way to integrate it with already full-working and large applications. And to do this, it will have to adapt to any architecture that you might already have, and this will be trick and funny part :), when you give it a try just let me know, in case of issues make yourself comfortable to use github repository.
He lost me when he talked about Enumerable changing its interface. That is not going to happen.
In Reddit, if you want to reply to someone, click the "reply" button under their comment :) 
 ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))? Note: This only does URLs, not all URIs. Honestly, given your context I would assume you want to include URNs too, so I'd be looking at a URI parser: http://www.ruby-doc.org/stdlib-2.0/libdoc/uri/rdoc/URI/Parser.html
require 'uri'; URI.regexp
I'd love to fork your repo but my dongle is too big. Sorry.
Yay?
The author stated is that "changing what a module requires forces you to go around updating all classes that include that module". The same is true for super-classes and even interfaces: If a super class or interface forces a new method to be implemented, you would also have update all sub-classes. Does that mean that they also break encapsulation?
It's one of those things that bites you once and you are more aware of what you include in the future.
I wish languages would just give us multiple inheritance - we're all adults here.
Hot.
By the way (you did this in the article also) it's "co**m**fortable" not "co**n**fortable"
 require 'uri' URI::Parser.new.make_regexp(['http', 'https', 'anyschemeyouwant'])
Regexps are just a succinct way to describe a parser. 
john@abc is perfectly valid, anything after the @ describes the machine to deliver the email to, whether that happens to be google.com or abc doesn't matter.
A parser is smarter than a regular expression. A regular expression cannot describe a grammar with loops and weird stuff like that. This is why you cannot do a regular expression that describes HTML, for example. You need a parser for the extra intelligence.
You may not see it as a valid email address, but on a large campus such as a huge company or a large university, it is still commonplace to use such email addresses. Take unh.edu for example, there are dozens of sub domains- sr.unh.edu, iol.unh.edu, cs.unh.edu; I could email a professor from my iol.unh.edu address by emailing prof@cs. Pragmatically, I completely understand your requirement that a non-tld email address is invalid, but the danger is when we start posting regular expressions that match 'email addresses', and then a college kid pastes it on his school's signup form and loses a few emails while people are figuring out his regex is trash because it only matched 'what most people meant'.
There's an audio version :) EDIT: he also did a talk recently: http://www.youtube.com/watch?v=GHvewyaX5hs
You don't have to apologize! I understood what you meant anyway :)
I recommend coursera.org for their free gamification course. You may watch the videos even if the course is not being presented right now. It emphasizes gamification beyonds the gamification fads and the shallow approach of including game elements without creating a game experience. I intend to use your gem for a business-related system with progress paths reflected by badges so thank you for sharing it.
All `whenever` does is give you a programmatic way to create cronjobs. Unless automatically creating the cronjob was your 'pain point', it is unlikely to be what you are looking for, or a significant advance over what you have now. You certainly can rewrite your php cronjob as a ruby cronjob, with or without `whenever`. (You could also theoretically use `whenever` to programmatically schedule your php cronjob, although I'm not sure why you'd want to). (I do like whenever a lot, don't get me wrong. It's just that, it is what it is.) I have no experience with quartz-jruby, or with quartz in general. There's no reason to be scared of jruby, it's robust and stable. I'm not sure what it's "cracked up to be". But why are you looking at it, exactly? * If you want to just use the original Java quartz in Java, you can do that. * If you want ruby, but not jruby, you could use some plain ruby solutions to task scheduling, such as [clockwork](https://github.com/tomykaira/clockwork) or [recurrent](https://github.com/zencoder/recurrent) * If you think Java quartz is a really great solution that has features/power/robustness not found in other solutions, but you'd rather write in ruby than Java, or are already writing in jruby anyway or interested in doing so -- then it seems quartz-jruby is made exactly for you. But quartz-jruby and whenever are just two of many many possible solutions (and two products that fill very different roles at that), I'm not sure why you arrived at those two as your options. 
Every time you write "a = b + c" you are remembering operator precedence.
This is the counterpart to the argument from authority - the argument from the incompetence of others.
 require 'uri/common' URI::REGEXP or use [URI.extract](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/uri/rdoc/URI.html#method-c-extract).
Random history tidbit, a marathon used to be 40k. It wasn't until 1924 that it became 26.2. source: http://en.wikipedia.org/wiki/Marathon#Distance
Their local, on-campus DNS servers resolve it.
As an experienced ruby coder, but likely using warts from other languages I've used in the past, what would this book offer me?
The Pickaxe book is pretty much a reference, however Eloquent Ruby is about how to write idiosyncratic Ruby. There's a link in the sidebar.
Part 2 now posted: https://deveo.com/blog/2013/03/28/immutability-in-ruby-part-2/
You created a self post and did not post the link.
Missing link here: http://www.techempower.com/blog/2013/03/28/framework-benchmarks/
Thanks for this! Great post. As I said in comments to the previous, this is very informative for people like me who are mainly ruby programmers who understand that Ruby as a language glosses over these issues. On a related note, one thing I have needed for 'values' (I didn't know of this terminology) in the past was to ensure you there are never two 'values' with the same content (which seems sensible for values like '42' - you can't have two different '42's and indeed 42.object_id==42.object_id). I have done this in the past through something like this: class Address class &lt;&lt; self attr_accessor :alreadydefined end self.alreadydefined={} def self.[](*args) if res=@alreadydefined[args] then return res end res=self.new(*args) @alreadydefined[args]=res res end end Address["24 Park St"]==Address["24 Park St"] =&gt; true This seems extraordinarily long-winded for something so conceptually simple though (and probably not written so well for widespread use). Plus you have to remember to stop using '.new'. For the life of me I've never figured out a more sensible way to do this and I wonder whether I must be missing something here. Anyone know of a better way? I checked the Virtus gem and it doesn't seem to do this (not sure why).
Repost with the link please.
That's an interesting problem. I've never actually thought of it that way. While you _may_ reuse a value as much as you want, there's usually no reason you'd _have to_ do that. Unless you look at the object_id you won't be able to distinguish between different instances of the same value anyway. Your question brings up the important point of equality and comparison, which I forgot to address in the article. With values one should override == and implement it in terms of the value equality, instead of object id. I'll update the article. I guess a use case for your implementation would be preserving memory? The code looks fine to me - it's basically memoization for value construction. I would probably extract it into a module which can then be included to any classes that you want to be constructed in this way. I might also add a Mutex around the construction, to _really_ make sure no two equal values are created, even in multi-threaded contexts.
Thanks for the response. Yes - the context was memory-saving. Not having to specifically override equality tests (==) also lends some simplicity (particularly when in a module as you say). I'm not sure what real advantage there is in having two or more 'objects' which represent the same 'value' though.
I agree, there's no advantage to it. It's more about whether it's enough of a disadvantage to justify the work that needs to be done to eliminate duplicates. If the memory-saving is significant in your program, it might well be worth it.
Yes but Rails has to get their act together and start addressing both the performance issues and the memory consumption issues. Lucky for us these guys didn't measure memory consumption. What I would like to see is some of the other micro frameworks. Some like Cuba and Espresso claim to be twice as fast as sinatra if not more, I understand camping is faster too. 
Oh wow, I just noticed that my new lines got eaten. 
The way Ruby does keyword arguments isn't exactly analogous to the way Python does it. The last example will work in Python.
Are you sure you even need to encode the utf-8 string? Try making the request without any special encoding and see if you get a proper response. 
Only downside- compiling Ruby on an rPi takes like 12 hours...
Om nom nom!
Kinda. You can do C out of the box with pretty much any distro. But it depends what you're doing with it. 
I think this is pretty interesting. Here's a couple things I liked: If start has a value, assign the instance of Node to @root: @root = start &amp;&amp; Node.new(start) I didn't know, and thought it was interesting that you can call the glob operator on nil: @range_start, @range_end = *range edit: eg range could be nil
Even though range won't be nil when you are creating a new node but glob on nil wont throw any error anyway. Of course, rest of the things would go haywire with nil range
Renamed the library to [sereth_json_spec](https://github.com/TikiTDO/sereth_json_spec), as json_spec is already taken. 
Can you give a brief synopsis of what motivated you to create this gem, and a maybe a couple of scenarios where it would be useful? Do you see sereth_json_spec as a competitor or replacement to something that exists, but you needed more functionality? (eg. JSON stdlib, Marshal, or ActiveModel::Serializers) Is the use of the (mostly) undocumented, internal Data class intentional? If so, can you explain a little bit about how/why you extended it, and maybe explain why that's a good thing? Thanks!
Does this come with a sarcasm detector? :D
If not, I would absolutely love to make sweet, sweet love to people who write "sentiment analysis" "gems". EDIT: more seriously, given the amount of research and sophistication behind even NLP for doing tech support, it's hard to imagine this kind of thing being more than a toy.
Instead of [1, 2, 3].zip([10, 20, 30]) {|arr| arr[0] + arr[1]} you could do [1, 2, 3].zip([10, 20, 30]) {|(one, two)| one + two }
I commend you on your efforts on building a sentiment analysis system. One thought, you're splitting text into words, but that's not how languages work. For example, "good god" could be used in a negative context, but when split up into tokens, it's going to get "good" and think it's positive. Take a look into NLP systems, it's an interesting beast.
Yup, inheritance violates encapsulation, too. A subclass depends on the implementation details of its superclass. If that implementation changes, the subclass might break even though it wasn't touched.
You need to use syntax highlighting boy
Take a look at the [utf-8 description](http://en.wikipedia.org/wiki/UTF-8#Description). From there, you will see the utf-8 bit mask for that range is: 110x xxxx 10xx xxxx C3 A9 in binary is 1100 0011 1010 1001 apply the bit mask you get 0 0011 10 1001 or 000 1110 10001 or in hex E9
This is really cool. I've been thinking about something like this to scan text for negative emotion, this is a good starting point.
was expecting rubydrama
I don't know if I could handle a third March programmer conference with drama (referring to PyCon and IDGA)
Bringing immutability to a language that is clearly not ready for concurrency/parallelism is... interesting.
Nice, I tried it and it works. Well done.
More ad-infested crap from "geoscripting". 
AdBlocker
I disagree with that author. The fact that "something might break if something else is changed" is code coupling, not encapsulation. A superclass might expose its implementation details, just like a regular class might do that. This doesn't mean that inheritance implies in breaking encapsulation. It depends on whether the super class is properly encapsulated.
But did you see the example he gave with HashSet? That example made it clear that the subclass needed to be aware of implementation details of the superclass to make itself function properly, and had nothing to do with the superclass changing. That example demonstrates clearly that inheritance can violate encapsulation, and was the main point of his argument.
This is a starting point for something that will almost, but never quite, work.
geez, what doesn't clear the method cache?
Very useful, thanks.
It is mostly dead, but it's still very much functional. And yeah, through MonoTouch.
 ri MiniTest::Assertions Will give you a similar list for SUnit stuff at least.
Other than non-blocking methods it's all pretty straightforward.
That the non-blocking methods do this is pretty terrible though. Non-blocking I/O is a pretty important feature.
Yes, it can violate encapsulation, but it will not always do that. It depends on how the classes are designed.
You can do non-blocking I/O without _nonblock methods.
OpenStruct.new was an eye-opener.
It defines a new class, so it's not surprising.
I can understand that this is a joke, but can someone point out to me why it is funny?
I'll be completely honest and say I had a really, really hard time reading that. I'm still not quite sure what this post is all about. It really needs more context and less "fluff". Sorry if I'm being mean! I'm not a native English speaker so there's that as well... I've read this about 6 times now and from what I can understand there was a Ruby conference and this guy put a Base64 encoded URL on soda bottles that he handed out. That URL points to a web app that is a contest of some sorts? He says it checks your code (?) and talks about excercises but when I go to the URL it looks like a game so I'm not sure what's going on with that.
You're not the only one. I have no idea what I just read.
&gt; system("echo '#{suggestion}' &gt;&gt; ~/Dropbox/suggestion_box.txt") ...seriously? Although this is probably a joke, I'll bite, in case someone would be stupid enough to really do this. &gt; File.open( File.join( ENV['HOME'], 'Dropbox/suggestion_box.txt' ), 'a' ) { |fp| fp.puts suggestion } Here. FTFY.
Thanks - I realize that echo'ing user input is not secure, but it was the simplest way to make the point. Obviously, this is not production ready in it's current state :) Though I will happily update it so no one `accidently` copy-pastes it into a real app.
 regexp = /geoid10"=&gt;"(\d*).*st_asgeojson"=&gt;"(.*)"}/ str = &lt;&lt;-HEREDOC.strip {"stusps10"=&gt;"FL", "geoid10"=&gt;"33012", "dp0010001"=&gt;"72248", "st_geometrytype"=&gt;"ST_MultiPolygon", "st_asgeojson"=&gt;"{\"type\":\"MultiPolygon\",\"coordinates\":[[[[-80.311481999999955,25.846597999999915],[-80.310284999999965,25.845939000000101],[-80.311481999999955,25.846597999999915]]],[[[-80.319516000000021,25.881569000000127],[-80.278556999999978,25.851297000000045],[-80.319516000000021,25.881569000000127]]]]}"} HEREDOC match = str.match(regexp) match[1] # =&gt; "33012" match[2] # =&gt; "{\"type\":\"MultiPolygon\",\"coordinates\":[[[[-80.311481999999955,25.846597999999915],[-80.310284999999965,25.845939000000101],[-80.311481999999955,25.846597999999915]]],[[[-80.319516000000021,25.881569000000127],[-80.278556999999978,25.851297000000045],[-80.319516000000021,25.881569000000127]]]]}"
Unless this is only on an intranet, with limited access, it's only a matter of time till someone floods it with ascii dongles Edit: Wow, really? Downvotes? Bunch of motherforkers in here
I just realized that. I feel stupid. Thanks!
One is a Rails app and the others is a Sinatra app?
That'sa big dongle.
zero_deploy? Though saying it's "funny" may over stating it somewhat!
Ruby/Rails is the new buzzword now, everyone and their dog is going to be adding it to their resume. I've been playing around with ruby and rails since Rails pre 1.0
I think the stigma of not having a diploma will be a big problem, however unjustified, but I can't really speak to that. If you can point to some websites you've built, and make it past the automatic résumé filters, you'll probably do fine. Whatever you do, don't focus on a single technology for web stuff. Programming is a lot like the fashion industry, with a "new hotness" every few years. Keep track of what's trendy, but don't lose sight of what works for you.
Yeah thats true, but what I mean is people are trying to get it on their resume because they think it will help them find work. Whereas before it was almost always someone who was passionate about the language or framework(or both)
If you enjoy RoR then just keep getting better at it, also stay curious about what's happening in the industry. If you see a new term or tech name, look it up just to understand what it is. As far as employment goes, you can still succeed with no diploma. If you really like what you're doing, chances are that a good part of your spare time is spent coding. Your brain and enthousiasm are your biggest asset in the industry. If you have made sites for people in the past, you could try to rewrite them with what you know today, or even turn them into some sample site which you can use as part of a portfolio. Try to find people with similar interest, maybe by enrolling into classes at the local community college: networking can be really useful. Be humble enough to accept a super entry level job, and try to learn: how to work in a team, what to do or not do, etc... Even bad jobs have something to teach you. But never play yourself down either, always keep an eye out for a better job, eventually with enough experience under your belt nobody will even care about your lack of a diploma. As long as you're ambitious and willing to constantly improve, you will do really well. Good luck!
Um... I wood love to bury my dongle in her slot and fork her repo? Nevermind... Too soon.
I'm gonna git push your repo, hope we dont contract a merge conflict
tl;dr: I think you'll be fine, but it will eliminate some opportunities for you, most likely at larger companies. Also, as long as you have good work to point to (i.e. github projects), and can explain how you got to where you are today I think you should have a good shot at being the Rails developer you want to be. Good Luck.
I could make a joke about multiple ports at this point, but I should stop.
Javascript is going to continually grow in importance, so it's definitely worth knowing well. After all, node is just a command-line runtime packaged with a bunch of useful network libraries. I find that my ruby and js skills complement one another. With ruby making backend dev lovely, and JS making awesome frontend clients.
This is the best answer. Make your own projects on Github, contribute to others. I have hired 5+ ruby devs for my company and if someone has a good Github (or whatever) account we almost always bring them in for a face to face. Formal education is not #1 on the list of requirements. Experience counts a TON.
You absolutely have a chance. Make projects, publish them, make a beautiful and functional portfolio, and be ready to work your ass off.
A little about myself: I'm a TA for a Intro To Rails course in Los Angeles. I work full time as a software engineer where I use rails daily. I also have helped in the hiring process of developers before. Mark my words, have lots of code to show. Have code that you yourself are proud to show. One of the first things most shops (that you want to work for) are going to look at is your code. Open Source, closed source. Doesn't matter (although in my experience Open Source is weighted heavier). And secondly, I know that you want to get into a new career path, but I don't think that should be your driving force for this. Let your driving force be "I want to make something cool." and go do it. Do this several times, and you'll have 1) A Portfolio, 2) A ton of REAL experience. TL;DR: Get it right, get it tight, someone will hire you.
I'm just sitting here pinging localhost
Best part is the failing build status.
What sort of things are you looking to see in an entry-level applicant's github, in terms of complexity? 
A gem related to web/rails things. Doesn't even have to be complicated... their own simple authentication gem, a custom form builder. Some forked projects with some personal patches. In an interview I'd get them to explain what the patch did, why they thought it necessary, how else they might have implemented it, etc. One person I interviewed had submitted bug reports to, I think, Rails. They turned out to be mistaken bug reports, but the way it was reported indicated that they had gone into the Rails source and tried to figure it out and this generated a good thread on Github. Granted, this was for a junior position, but when I asked him about it he was able to show me that he was excited and wanted to learn. So, that scored him some points. It is definitely possible to be hired without direct experience and education. I was hired by someone who took a chance and they set me up a solid career. I'm trying to pass on the favour. 
Even simpler, make a Google Doc form – if a solution already exists, no need to write a new one!
i work at one of those dev camps. yes, it is totally possible. i watch it happen pretty regularly and always get blown away at how fast people can learn and the stuff they build. companies are really in need of good devs and want to hire. in San Francisco, I've never met more successful high school dropouts in my life. 
As someone who got a job working for a startup as a software engineer, at the age of 18, with no college education but two years knowledge of dicking about in Ruby, hell yes it's possible. Use Ruby to solve real worlds problems you have, and everything else will come easily.
Why not simplify things and use a [library](https://github.com/bluemonk/ipaddress)?
Because it is A) extreme overkill for what I need and B) I don't even see the functionality I need in that. I see where you can check to see if a string IS and ip, but not any way to check if a string CONTAINS and ip. Also, I will need to do the same thing with netbios names. 
Ok you could always try one of the many regexps floating around - like one of [these](http://answers.oreilly.com/topic/318-how-to-match-ipv4-addresses-with-regular-expressions/).
That's what I did. My problem is that I cannot get the regex to work. I give it a string that is just an ip address, and it still can't match it. Been surfing through the documentation, google, stack exchange....either I am missing something very obvious, or Ruby's regex handling is very bad. Probably both. 
TL;DR check out how different I was at getting people to come to my site. 
 /((?:1[0-9]{2}\.|2[0-4][0-9]\.|25[0-5]\.|[1-9][0-9]\.|[0-9]\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))/ This regex works for me. It will return all IPs in a string.
[Still relevant](http://imgs.xkcd.com/comics/perl_problems.png)
It would appear you are not escaping the period. You want a literal dot, not a wildcard.
As a CTO of a Ruby shop/startup I can't endorse this enough. Some of the best coders I've ever worked with never went to college. One 19-year old coder told me he was thinking about going and I pleaded with him not to - he was contributing enough to github to mark himself out way, way ahead of most graduate coders. Go and work on some interesting problems, start closing bugs on some other people's projects, go and build lots of little example applications that show you're a self-starter, and I'd consider giving you a job on that basis alone. Every line of code you write in the public domain speaks volumes. 3 months of good quality open source contributions outweighs 12 months of college by some margin. You'll still need to do the theory but you can get that from books on algorithm and data structure design and trying to build actual things that work and understanding patterns you see in code. Right now, I'd bite your hand off if you have demonstrable experience of working hard, had 12+ months of Ruby/Rails under your belt and wanted to come in on a graduate salary. Go for it, and if you ever want your CV/resume/github profile checking over by somebody who has hired dozens of coders in the past, message me.
Note that any value other than nil and false evaluate to true... Long and ugly: class String def is_ip? self =~ /\A(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\Z/ ? true : false end end '192.168.0.1'.is_ip? # =&gt; true '256.256.0.1'.is_ip? # =&gt; false 'other sting'.is_ip? # =&gt; false 
That is one of the worst kind of monkeypatchets that I have seen :-)
I'm not sure I've seen a good monkey patch. /me is guilty of monkey patching in the past
Does the résumé/github checking offer extend to other non-college graduates looking to get into the field?
Depending on your boss, this change could be made: File.open('/dev/null', 'a'){ |f| f.write(suggestion) }
Notes notifier is there in the form of dropbox's file changed notification.
You can absolutely make this a reality. I've hired MANY people in your situation. Follow others' advice and contribute to open source projects; or at a minimum, open source your own projects so that you have an active and substantial github account. It's also worth completing a bunch of codeschool.com (or similar) courses. There's nothing you can do about your lack of experience, but you do have full control over learning the fundamentals of Ruby/programming/web development. Where do you live?
Yes. Keep learning, read lots of other people's code, contribute to open-source projects, build your code resume on Github. Source: I am a professional Ruby/Rails developer, I am self-taught, I have no college degree, I hire people that can demonstrably write good code. 
Except you totally failed to make your point and convinced a lot of people that you don't really know what you are talking about.
This is the correct answer. Degrees are becoming less and less important in the startup world. When I'm looking at potential candidates the first thing I want to see is a GitHub profile URL. Shameless plug: Here's a page I put together to help people apply at the company I work for, Shopify: http://throw-out-your-resume.com/
I just made a 20 dollar contribution to rubular yesterday! It's incredibly useful; you should all do the same.
Great ruby conference
All DevOps on Wednesday, Ruby on Thursday and Friday.
Thanks for your feedback :) While I disagree with your conclusion, you are certainly entitled to your opinion. As I mentioned, I've corrected the offending line of code. Hopefully, you will not discount the message of the post ("just because some design patterns are beneficial as programs grow in complexity, does not mean that we should skip straight to them for simple cases") because of a minor issue in an artificially constructed example. I choose to illustrate my point using code because I felt it made a stronger argument than simply saying "sometimes code gets too complicated by design patterns". Most people I've spoken with (outside of this thread) responded positively and smirked/smiled when they reached the punchline - all The Boss **really** needed was the suggestions to show up in a textfile on his computer. Finding the right balance of length and complexity in example code snippets is something that I find difficult - and something that I am trying to improve. If I made the samples too long, it would detract from the overall message by getting the reader bogged down in the details. A complicated domain is more realistic - but much harder for a general audience to grok. Do you have any advice or feedback on this specifically so that I can improve future posts?
Hi - thank you for your comment, I really appreciate receiving feedback. Of course the first example is super over-engineered. It's got caching, extra logging, internationalization, view decorators/form models (there is even some DCI snuck in there!). All of these patterns are valid - in the correct context. I've worked on projects where these patterns were appropriate and made the codebase better and easier to work with. Because I needed to reach for a more complicated pattern in one case, it is easy to fall into a mindset that I should use that pattern for *every* case. My goal was to challenge you to think about how to simply the design of your applications. I know that my last project really benefited from the Repository pattern, but will simply calling ActiveRecord queries directly be okay? The Decorator pattern makes sense for complicated views, but do I have that problem in my codebase yet?
As nice as it would be if this works, OP wants to detect if a string contains an IP. For example: str = "my ip address is 10.1.1.1" 
Good point!
I definitely agree with your thesis, but you demonstrated it not with a change of code, but with a change of specification. Finding an example that doesn't conflate the two would be ideal.
Ok, I am very new to Ruby and just learned about monkey patching. Why is this such a horrible example. If I need to find sting I can see the problem with monkey-patching other libraries that might change between versions, but not really in this case. When, if ever, should monkeypatchets be used? Maybe a regular function would be just as good...
Let's use a simple regular expression: str.scan(/\d+\.\d+\.\d+\.\d+/).any? {|m| IPAddr.new(m).ipv4? rescue false } Alternatively: str.scan(/(\d+)\.(\d+)\.(\d+)\.(\d+)/).any? {|m| m.all? {|byte| byte.to_i &lt; 256 } }
This is essentially early optimization. You're writing the code for what the boss wants NOW, and making it harder to fulfil future requests and meta analysis of the data.
I'm in the Los Angeles area.
You are golden then.
Yup yup. That's intentional. refute_raises is useless as is refute_silent.
and `ri MiniTest::Expectations`
Yes, that was an interesting factoid I learned while putting the table together. Someone on StackOverflow explained it: http://stackoverflow.com/questions/12499259/why-does-minitestspec-have-no-wont-raise-assertion It's a good primer on the philosophy behind exceptions.
Unicorn may not be a good choice on Heroku because apparently Heroku doesn't buffer HTTP request bodies properly. http://rubyforge.org/pipermail/mongrel-unicorn/2013-April/001743.html
Argh, wish I would have bought a ticket for this in time...