I use `#fetch` when: - I want to produce error in a case when hash doesn't have given key - I want to specify a default value Also note that below examples produces the same results in most cases, but different result when: `h = { a: nil }` val = h[:a] || 'default' =&gt; 'default' val = h.fetch(:a, 'default') =&gt; nil 
It is an alias for chomp: &gt; Now in order to delete prefix we can use delete_prefix and to delete suffix we could use chomp. This did not feel right. So for symmetry delete_suffix was added
I don't see any cons to `fetch` other than that it's longer to type. `Hash#[]` in its current `nil`-happy form shouldn't even exist.
I've been using Hash#dig and Array#dig lately over fetch. Doesn't help the symbol vs string debate but it's still pretty cool. Say you have something like h = { a: 'b', c: { d: { e: { f: 'hola!' } } } }. To get to 'hola!' you would just do h.dig(:c, :d, :e, :f), and anything in-between that doesn't exist will just return nil. I'd be surprised if fetch were faster than direct access, haven't looked it up but I'm curious why you're even curious about that?
It seems like you're writing some fast and loose code if your variable is probably a hash but it might not be! I think I've only used fetch in cases where I need a default, but I've started using the block declaration of hash instead so I can define whatever default I want for unavailable keys. 
Agreed. Should be the other way around, but then it would be inconsistent with `Array#[]` and others.
[removed]
(Assuming the default needs to be computed and isn't something like `0` or `"missing"`, or even `[]`, although in the latter cases it's probably still slightly better to use the block form as it won't create a new object that needs to be GCd)
Another way to select a random record is to first retrieve the number of records in the table, then generate a random row number and use it as an offset with a limit of one.
Since dig is kinda new, I'd love to use it, but I was stuck on 2.2.4 at the time, ended up doing something like : fetch(:c, {}).fetch(:d, {}).fetch(:e, {}).fetch(:f, {}) :( I agree, dig is so much better
Some kind of [expect style library](https://github.com/abates/ruby_expect/blob/develop/README.md) might do what you want
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [abates/ruby_expect/.../**README.md** (develop â†’ 318050f)](https://github.com/abates/ruby_expect/blob/318050fdd90ad3b343cecece8b1839bcd58a81f5/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Queries with large offsets are also slow, I would benchmark this before recommending it.
Excellent point.
They shouldn't go too far down that road. It was what turned perl into the current mess
[removed]
If you do this type of query a lot and have non-sequencial ids then the best approach is to create a separate table that has a sequential id column and a column for the id of the real table. Then select against the sequential range of this table. Managing the mapping table on create/delete of the real table can be done with some simple triggers.
I particularly choose fetch when reading mandatory environment variables from code. It's much easier to debug the KeyNotFound error than letting a nil string trickle into your code and have to debug whatever error that happens to cause.
Open3#popen3 http://tech.natemurray.com/2007/03/ruby-shell-commands.html
Hey, thanks. That solves the issue exactly. I had found out about Open3, then tried other options (there seems to be quite a few options in Ruby to execute shell comands) and kind of forget to try. 
Sure but wouldnâ€™t that help you write more predictable code? Now I donâ€™t have to guess what chomp does if Iâ€™ve seen delete_prefix. 
It would help if it was like that from the beginning. They should have reserved and optimized chomp for removing line endings and then have delete_prefix/suffix for the more general case
Read the file contents. Split the contents on whitespace. Iterate over the contents. domains = File.read("/path/to/file") domains.split(" ").each do |domain| #do whatever you need end
You can do this with `IO.popen`. Just as we can `#read` the IO object returned by `IO.popen` to read from stdout, we can also `#write` to the same IO object to write to stdin. We just need to open it in the mode that allows both writing and reading, which is `r+`, just like with files. We can demonstrate this using `tee`, a program that copies standard input to standard output. io = IO.popen("tee", "r+") io.puts "foo" io.gets # =&gt; "foo\n" io.puts "bar" io.gets # =&gt; "bar\n" Note that we are using `IO#gets` here, which reads only the next line. `IO#readlines` shouldn't be used as it will try to read all the lines, so the program would block forever.
I like that you are both reasonable about it... I have worked on quite a few projects, from : 'seat of the pants that some guy doing his first rails, found success now needs to learn what this word scale means' to 'all tests should be 3 lines and have a capital Q in them somewhere with an absolutely symmetrical balance of consonants and vowels in the function names' ... For a lot of people, the syntax of tests matter, for others coverage, still others the runtime of their tests are boss... We progress when people take an interest and scratch their own itch as the author did... But we also progress when we listen to our critics... it helps us to not solve 'non-problems'... of which I am more guilty than most. ;( Good job on you both pulling back and considering the others point of view...
StackOverflow and Google might be a better place for this. https://www.google.com/search?q=Watir%3A%3ABrowser+unable+to+find+chromedriver
 domains = File.read("/path/to/file") domains.split("\s+").each do |domain| #do whatever you need end Will be more robust
Try the chromedriver-helper gem https://github.com/flavorjones/chromedriver-helper
You should also look at the Scriptster gem https://github.com/pazdera/scriptster
Ah, great. It is embarrasingly simple. Now I feel like I should have read the docs more carefully because asking for help. 
A lot of this information already exists in tools such as [rubocop](https://github.com/troessner/reek) and [reek](https://github.com/bbatsov/rubocop). In general, the concepts are fine, but the examples could do with some work (admittedly, it says as much itself). There is quite a lot of non-idiomatic Ruby. The section about getters and setters is a bit confused. As well as being non-idiomatic (in ruby you would defined `x` and `x=` instead of `set_x` and `get_x`), the advice not to use `attr_accessor` is bad. The example code is exactly the sort of place you should define an `attr_accessor`, or just an `attr_reader` if you really did need to validate the new value before setting it. There is a link to a good article about why you wouldn't want to use them, but the issue the article has is not with the syntactic sugar of `attr_accessor`, but with exposing parts of an object that shouldn't be exposed (I would argue its an extension of the [law of demeter](https://en.wikipedia.org/wiki/Law_of_Demeter)). Hand defined getters and setters will lead to exactly the same issue. Also, you should avoid setters as much as possible. Its much better to define all the values up front and use an object that can't change than it is to pass around an object that could be in a partially completed state. I will admit there are times when they are needed though.
**Law of Demeter** The Law of Demeter (LoD) or principle of least knowledge is a design guideline for developing software, particularly object-oriented programs. In its general form, the LoD is a specific case of loose coupling. The guideline was proposed by Ian Holland at Northeastern University towards the end of 1987, and can be succinctly summarized in each of the following ways: Each unit should have only limited knowledge about other units: only units "closely" related to the current unit. Each unit should only talk to its friends; don't talk to strangers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Basically everyone should keep their hands to themselves or get fired.
Porting code style recommendations from another language, while ignoring all existing in Ruby code styles and tools? Promising idea!
&gt; The section about getters and setters is a bit confused. Because it is ported from JavaScript code style, where direct property accessors exist. Â¯\\\_(ãƒ„)_/Â¯
Thanks for the critique! Most of the examples are largely ported over from their JavaScript counterparts, so they are a bit awkward. I agree that the coding style can definitely be more idiomatic. I am aware of the idiomatic way to implement the getters and setters. Just want to highlight that it may not be the right choice for all situations. You're right that the current example should be rewritten using `attr_accessor` instead of hand-defined getters and setters. Perhaps I should come up with another example for which `attr_accessor` may not be a good option. :) &gt; A lot of this information already exists in tools such as rubocop and reek. Yes, I'm aware of rubocop and friends. They are awesome! They take care of a lot of tedious stuff and provide a lot of good hints. However, some of the finer details of clean coding are not covered by those tools and it is up to us to make the right judgment. Therefore, I find it hugely helpful to read condensed guides like these to get into the right mindset for writing clean code.
The clean code concepts are language-agnostic. It definitely helped me when I first read the original guide in JavaScript. Just want to spread the knowledge the Ruby way. :) Feel free to point out any non-idiomatic Ruby code and I'll correct it right away!
The bad example for [side effects part 1](https://github.com/uohzxela/clean-code-ruby#avoid-side-effects-part-1) doesn't work since `name =` defines a local variable and the right side tries to access that local variable which is set to `nil` by Ruby. Even without that strange `a = a # =&gt; nil` behavior it would still not work because setting a local variable in Ruby will always shadow the outer variables. If you really want to use global variables you need to use them explicitly: `$name = "foo"`.
&gt; In Ruby, primitives are passed by value and objects/arrays are passed by reference. This is wrong in two ways: a) Everything is an object in Ruby (TM), there are no "primitives". b) Everything is passed by value, but these values are references to objects. Call by reference would allow you to do this: a = 2 def foo(b) b = 3 end puts a # prints "3"
&gt; The clean code concepts are language-agnostic No, they are not. For example, JS properties and Ruby attr accessors have nothing in common, as it was pointed above. For another, "Use consistent capitalization" is wrong, because Ruby _has_ pretty strict rules of capitalization (partially forced by language itself, partially by accepted community style), so "These rules are subjective, so your team can choose whatever they want." is just plain wrong. And so on, and so on. Basically, it is NEVER a good idea to port code style recommendations between languages, exactly because of a ton of small and large differences in how language community thinks and structure things. Also, as it was pointed above, Ruby _has_ its style guide, tools for checking code style, tools, and guides for finding common code smells, so your "clean code guide" (which contradicts to and/or sturctured differently than other existing guides) would just add confusion to new Rubyists, not help them in any way.
heh, the Attack is calculated using data from Honybadger (error monitoring tool). The website is clearly a company propagation stunt but still good idea :) 
Is there a garbage collected language that doesn't use pass reference by value?
Ah, thanks for pointing that out. Just want to point out that this guide is not meant to be solely a style guide but a clean code guide which encompasses much more than just code style (proper naming, small functions, appropriate abstractions, DRY, avoiding side effects etc.). In light of Ruby community's reliance on static analysis tools, perhaps the formatting section and related sections should be rephrased to focus on tools such as RuboCop instead. However, some of the finer details of clean coding are not covered by those tools and it is up to us to make the right judgment. Therefore, I find it hugely helpful to read condensed guides like these to get into the right mindset for writing clean code. Anyway, this is just a WIP. So your critique will definitely help to nudge it in the right direction to be more compliant with what the community prefers.
Hello, you're more than welcome to send in your articles (about your library / gem of choice) too!
Since I was never really able to get into TDD, because most frameworks are huge and come with their own syntax you need to learn before being able to use them, I decided to just write something myself that allows me to write "if &lt;something&gt; then &lt;abort and print stuff&gt;" logic in a nicer way, and somehow ended up adding more and more stuff until I ended up with this. I've never really used any testing frameworks, so I really don't know what is and what isn't necessary, but I'm sharing it here for people to take apart and tell me why it sucks (or possibly give nice feedback :D) and possibly even use, though I doubt that last part. Anyway, please tell me what you think and if anything needs to be improved (keep in mind though that this was only really meant to be used by me before some feature creep happened)
I also did write my own, when I couldn't find something simple, that would do close to what i need. Usually the frameworks are build very generic, so it is like using a tractor to dig a 3"x3" hole :)
Have you looked at minitest and minitest/spec? I can't imagine it getting much simpler.
I was going to suggest that he make sure that's NOT installed. On my mac it decided to insert it's own Chromedriver executable in front of the one on my path giving me the exact behavior he's seeing. I had to set a breakpoint down the bowels of Selenium webdriver to figure out why it was failing.
I did. And after looking at how much code it has, I don't see myself ever using that. I also really don't like how minitest works; it does everything nanotest tries to avoid: Minitest uses a DSL, nanotest uses ruby idioms; Minitest tries to fit it all into the core, nanotest has a minimalistic core with modules for building complex tests; in minitest a test suit is a class, in nanotest it's an object; etc. etc. etc.
Hmmm. Plain minitest isn't a DSL. It is written with plain classes and methods (as you note). minitest/spec provides the optional DSL which is quite minimal and mostly uses plain ruby idioms. It's also surprising that you feel it has a lot of code. Anyways, good luck!
One of the goals I had in mind when making nanotest was that the core could fit on my screen in portrait mode. It seems you have a vastly different idea of what is "a lot" of code xD
It's proportional to the functionality or scope. I can't imagine minitest getting much smaller with its current scope, and I don't see a good reason to reduce its scope.
&gt; Minitest uses a DSL, nanotest uses ruby idioms All Ruby code is Ruby "idioms", this is not a fair argument. DSLs are the heart of Ruby. Just because your particular testing DSL uses objects and "plain methods" doesn't make it better than one that uses blocks and `instance_eval` or one that automagically infers based on method names.
Nice read and I like the analogy. But may I ask a serious question? What is it with the scalability? For what people are these articles? According to Alexa (yeah I know) we powering a site in the top 30k with 1 load =&gt; 2 wwws (+DB) with a nginx+unicorn setup. And we are talking 50â‚¬/month servers. And we have so much leeway to take off some load like * giving database it's own server(s) * add more app servers (view rendering is still the slowest thing) * serving assets over a different (load) machine (we already use a different domain) if the gigabit connection becomes the bottleneck I never even thought about overhead or "waiting time" between the machines. Surely it's a thing for google, amazon, etc. but I doubt that this is the article's target audience.
Hey, I went down the same journey you did! https://github.com/ntl/test-bench
This was one of my favorite presentations from rubyconf. It was playful and interesting. One of his Grand Points was: "oh snap, I just used Ruby to solve a real, personal problem, instead of work demands, I feel cool." He's right, that is a really cool feeling. My first "personal solve a real problem app" was to analyze my different health insurance plan scenarios between the six different potential options between my and my wife's employer. Ruby made it pretty clear what option to pick, where previously I was overwhelmed by the ridiculous menu of options. I feel cool.
The easier way would have been to just contact lettermelater and ask them to change the date. But that would have been no fun.
Yes, this is the right path You can process faster with `Resolv` if you multithread as some names may not be resolved quickly, but don't do that until you have a working single-thread program
Saw this presentation at RubyConf and really enjoyed it. Definitely worth a watch! 
So I did the codecademy site as well as Learn Ruby The Hard Way. I absolutely learned more from the latter, especially not doing much programming before that. I'd built some stuff in Ruby on Rails but as many people can tell you, that's doable without knowing much about Ruby.
What do you mean, "learn ruby the hard way?"
Do you know if there is a way to auto populate a ruby hash key pair value with output of multiple variables. Trying something like this. vips = ['127.0.0.1','127.0.0.2'] domtoiphash = {} domains = File.read("C:\\utilities\\domains.txt") domains.split(" ").each do |domain| addresses = Resolv.getaddresses(domain) domtoiphash = hash.new domtoiphash[:ip] = "#{domain}" domtoiphash[:addresses] = "#{addresses}" 
Fun talk!
[Learn Ruby The Hard Way](https://learnrubythehardway.org/)
What is the presenters name? 
Knowledge is empowering us when we use it to self-actualize. It's only because of capitalism that we mentally divide ourselves from our sense of self-sovereignty and *propriety* that our powers (and knowledge) become mere commodities to be exploited by those higher in the power structure than us. In that sense, we are no different than the ancient people who made human sacrifices to appease gods, and in so doing, lost their own humanity. Humanity is wholeness; when man is divided, he is more like a cog in a machine; spare parts.
Thank you!
&gt; Do you know if there is a way to auto populate a ruby hash key pair value with output of multiple variables domtoiphash = { ip: domain, addresses: addresses } You don't need to use string interpolation of just a variable. Also, ruby snake_cases per the style guide. So dom_to_ip_hash is a better variable name.
Haseeb Q something rather.
Thank you ğŸ™ 
Whoa. r/ruby is deep.
Interesting, that does a very similar thing, except using blocks instead of lambdas :)
That's because minitest is a different thing than nanotest. Minitest tries to be small and still do a lit, nanotest tries to be as small as possible.
Damn, this gave me a serious pause. Excellent post
Makes sense. This is the first comment I've made since giving nanotest more than a skim. Is there a way to assert an expression will raise? I feel like the lambda approach you're using has some shortcomings, but I can't put my finger on it yet.
Thanks for pointing that out! It's fixed now.
Thanks for pointing that out! It's fixed now.
OP here - Still trying to come up with more fun ways to play with this one :D
These articles are not especially for people who need scalability. They are targeted at a general developer audience, who may be interested in learning how things work under the hood, as well as what sort of unobvious/obscure pitfalls exist without them realizing it before. The initial inspiration for this article actually came from a Passenger Enterprise support request. A customer's codebase tried to do work in between requests, in a manner similar to what's described in this article. We identified pitfalls with the customer's approach and suggested better alternatives, but because the issue is so low-level it was hard for the customer to understand our train of thought. Thus, we decided to turn it into a blog post in which we can slowly and clearly explain the issue, which is much easier than over email. Plus now we have something that we can link to for future similar support requests.
things Ruby really needs: - dump all stracktraces of all current threads (already possible) - tell me which one of those was running at the time of said dump
Hello, you're more than welcome to send in your articles (about your library / gem of choice) too!
Hello, you're more than welcome to send in your articles (about your library / gem of choice) too!
Maybe it will also improve our debugging tools, here is a post on using gdb with Ruby from the same author: https://jvns.ca/blog/2016/06/12/a-weird-system-call-process-vm-readv/
&gt; tell me which one of those was running at the time of said dump Do you mean which are blocked? Won't the stack trace tell you that? If it's in a blocking call, it's blocked. If you mean which are actively scheduled right now? Well I'm not sure kernels provide that kind of information? And why would you are anyway? The new ms it'll have changed.
I've seen that one alright. Unfortunately gdb slows things down quite a bit, which can be a problem as it can cause your program to timeout connections.
Which ones are actively scheduled. It won't change in the next ns, afaik the Ruby MRI uses 100ms timeslices. What would I do with this? Figure out what my program is spending most of its time on and create a flamegraph from this info, so I know which optimisations are worth doing :)
Oh right sorry I forgot this was in the context of MRI - you just mean which holds the GIL. Yeah that's simpler.
What about inheritance? Abstract the class variable and methods to a parent class (say Animal) then have all the other classes inherit from Animal. Maybe I'm missing something in your explanation but this is why inheritance exists, no?
I tried, but in that case, all the derived classes share a single `@@all` so the instances gets saved in a single array for the base class.
Weird - didn't know that Give [this](https://www.sitepoint.com/class-variables-a-ruby-gotcha/) a read. I think it helps you figure out your problem 
I love your philosophy of simplicity that drove the effort. The object based approach is interesting. Still trying to determine what I think of it. I wrote a test framework several years ago while motivated by a similar philosophy. https://github.com/hopsoft/pry-test Test framework do-it-yourselfers unite :)
First of all, do not use class variables for the mentioned issues. Then, the most quick and dirty approach (i.e. if you are doing some form of runtime analysis) would be ObjectSpace.each_object(Dog) {|d| p d} However, if it is part of your design that each class tracks instances created then you should make that explicit. For example you can use this technique: module InstanceTracker def new(*a, &amp;b) super.tap {|o| printf "Created %p\n", o} end end class Dog extend InstanceTracker end 3.times { Dog.new } However, there is a gotcha: when stuffing instances in an Array GC will never remove them. This interacts in bad ways with the language's design. You probably want to use an Array of `WeakRef` then which you clean from time to time.
https://www.reddit.com/r/ruby/comments/7bm1e0/why_arent_we_using_more_service_objects_already/dpjz8ou/
&gt; the advice not to use attr_accessor is bad. The example code is &gt; exactly the sort of place you should define an attr_accessor This is a good case for using it, but in many many cases, it and its counterparts needlessly expose internals to the callers, resulting in code with fragile interfaces. Here's a simple example: class Connection attr_reader :host def initialize(host) raise ArgumentError, "host required" unless host @host = host end def download(path) url = "http://#{host}/#{path}" # do something with url end end c = Connection.new("example.com") c.host = nil c.download 
 ~/code/ruby/itunes_store_transporter_web &gt;cat /var/folders/fn/5bmn_rf52x54hj7lxsw5c7ch0000gn/T/scratch.rb class A @as = [] def self.create @as &lt;&lt; new @as.last end def self.instances @as end end class B &lt; A @bs = [] def self.create @bs &lt;&lt; new @bs.last end def self.instances @bs end end require "pp" 10.times { A.create } 1.times { B.create } pp A.instances pp B.instances ~/code/ruby/itunes_store_transporter_web &gt;ruby /var/folders/fn/5bmn_rf52x54hj7lxsw5c7ch0000gn/T/scratch.rb [#&lt;A:0x007fe5529b0ea8&gt;, #&lt;A:0x007fe55287fcc8&gt;, #&lt;A:0x007fe55287f5e8&gt;, #&lt;A:0x007fe55287f520&gt;, #&lt;A:0x007fe55287f3e0&gt;, #&lt;A:0x007fe55287f2c8&gt;, #&lt;A:0x007fe55287ed28&gt;, #&lt;A:0x007fe55287ead0&gt;, #&lt;A:0x007fe55287ea08&gt;, #&lt;A:0x007fe55287e968&gt;] [#&lt;B:0x007fe55287e300&gt;]
Sorry for the late response--there was a small issue at the time that has been fixed! You should see the rule output in that box now.
That makes sense, because that `@@all belong to the parent class, so any inherited instances would bind to that unless overwritten.
I'd add myself as an author, leaving the former author(s) there too.
You probably wanted a *class instance variable*, not a *class variable*. Yes, that's two different things. Use a module for the behaviour, and reference `@all` in the class methods that the module supplies. 
Fork it &amp; fix it. Nobody's going to mind a whole new (working) gem.
You should read the original gem's license to make sure you're not violating anybody's rights. You could take a look at [Roda](https://github.com/jeremyevans/roda) as an example. Roda is a fork. The author updated license copyrights and the `authors` section of the gem. If you want to use this gem via repository link (i.e. `gem 'my_awesome_gem', git: '...'`), then all you should do is bump the gem version. But if you want to publish it to RubyGems, you should change the name and version, update the `authors` section, and credit the former maintainers and contributors.
Chances are that if you fork the gem and re-publish it other people will find it useful too, you will probably end up doing a fair bit more work on it than you have to date once issues start getting logged, so you should add yourself as an author, as well as leaving the original author there for recognition of creating the original. 
Hello, you're more than welcome to send in your articles (about your library / gem of choice) too!
you can use the `silent` option to have it not print anything, and it always returns true if all tests were successful and false otherwise.
I'm learning Ruby now.. This is the shit I want a do ğŸ˜­
I agree with most everyone else here on the way forward, but I would like to emphasize to the entire community a few things... * 'IDK if this question is stupid'... it is not... everyone starts somewhere and because people on the interwebs are quick to shoot someone down, people who have talent and a willingness to hop in are all too often intimidated and never even start down the path of contributing... The Ruby community has always seemed like a refreshing exception to this btw... * 'I have never published gems either' ... I have only published one... and while people say "it's easy", it is not nearly as easy as it should be... One thing that would be of great help (I am not qualified to do this) would be if someone that is a prolific and good gem creator would do a great book (are you here prag press?) on creating gems... including how to be kind / respectful to authors who have abandoned projects... and how authors could tell future people that it is ok to take over the code * People should feel confident about forking or taking over projects!!! I created a gem because I wanted other people to contribute or do a better job than I... AND so I could include it in multiple activerecord projects easily... but I put it on github for everyone to use and abuse... you may run into a tyrant here and there... but they are few and far between... and if they give you a bunch of crap... and you have done nothing to deserve it... then you are free to defend yourself... I will defend you as well. * and just so you know... as someone over 50 who understands I will not be here forever... people die... [Jim Weirich](https://www.wikiwand.com/en/Jim_Weirich) the guy who created gems ( and Rake / Ruby Koans / Builder / and did a whole lot of other cool stuff) suddenly died of a heart attack... if people like the OP did not jump in, we would all be screwed... From another perspective, 95% of the ruby programming community ( and most other communities ) think people who write the packages we all use are magicians anyway... and they see the people arguing about the code much like the ancients would have seen the greek gods of old battling in the heavens ... they think it is all above their heads... don't worry about jumping in... hardly anyone is looking anyway... AND LASTLY Thank you to people like the OP who overcome their fear (many of us are VERY introverted) and putting yourself out there...
you might be interested in class constants, they inherit like you expect them to do. (inherited, but overrideable). class Animal def initialize @all = self.class::ALL #reference to the all list @all &lt;&lt; self end def destroy_all @all.each do |x| x.destroy end end def destroy puts "I am dead" end end class Dog &lt; Animal ALL = [] #Important! def call_friends puts "I have " + @all.size.to_s + " friends" end end class Cat &lt; Animal ALL = [] #Important! end Dog.new Dog.new Dog.new Dog.new.call_friends Cat.new Cat.new Cat.new.destroy_all I have 4 friends I am dead I am dead I am dead
Well, I'm afraid you've completely missed the point. Comment was about general issue with ambiguity, caused partially by implicitness and dynamic nature of the language. &gt; Don't use them. In the rare case that I would, there wouldn't be more than one in a class. There are hundreds of their standalone uses in Rails sources, in examples in official documentation. Unless you work on a small or self contained project, keeping such rule sounds quite unrealistic. &gt; Not related, really. include SomeModule tells me explicitly that additional behaviors have been added to the class. Note, there are implicit invocations of various `Module` callbacks like `included, extended, append_features, extend_object, method_added, â€¦`. Your expectations can be simply questioned with inclusion of following module: module M def self.included(mod) class &lt;&lt; mod def unexpected_mess end end end end In other words, `class &lt;&lt; self` does not make code substantially harder to understand then other existing language constructs and core and standard libraries. You always have to check all related scopes to understand what would really happen.
&gt; Well, I'm afraid you've completely missed the point. Comment was about general issue with ambiguity, caused partially by implicitness and dynamic nature of the language. It might be that your point isn't very clear. &gt; There are hundreds of their standalone uses in Rails sources, in examples in official documentation. Unless you work on a small or self contained project, keeping such rule sounds quite unrealistic. Rails source code is not an example of anything that ruby programmers should strive for. &gt; Note, there are implicit invocations of various Module callbacks like included, extended, append_features, extend_object, method_added, â€¦. Your expectations can be simply questioned with inclusion of following module &gt; *snip* &gt; In other words, class &lt;&lt; self does not make code substantially harder to understand then other existing language constructs and core and standard libraries. You always have to check all related scopes to understand what would really happen. Huh? I think you may have missed _my_ point. `def self.some_method`is obviously a class method. `def some_method` is obviously an instance method, _unless_ you're in a codebase that makes use of `class &lt;&lt; self`. So, take away the practice of `class &lt;&lt; self`, and suddenly I can instantly tell if any method I'm looking at is a class method or an instance method. I don't really see how the presence of implicit surprises elsewhere in the language really affects this discussion. As rubyists, we always have to decide whether or not to introduce implicitness allowed by the flexibility of the language. When we _do_ use implicitness, we should have some analysis backing it up.
Chewy is a very useful gem to use for Rails &amp; Elasticsearch integration: https://github.com/toptal/chewy
I hadn't heard of it. Cool!
I always enjoy reading about techniques that apply equally to any programming language. It's something I wish people balanced with their desire to learn new programming languages. Event sourcing is a whole new paradigm for thinking about both software design and architecture -- and it actually brings a lot of benefits I hear FP enthusiasts talk about _for free_.
Which only means that you don't have to build as much infrastructure in functional languages. In my experience event sourcing meshes with functional languages in a really really nice way. Unless I misread your comment, cause it sounds like you were saying "you don't need functional programming if you have event sourcing".
Not exactly, I said that it brings benefits often touted by FP advocates. Event sourcing is language agnostic -- there's nothing about ruby that makes it less suitable for event sourcing than a functional programming language.
Some of that scope is kind of unnecessary. I'm looking at you, `i_suck_and_my_tests_are_order_dependent`.
great to do, but you will obviously need to do more than that to get to writing programs. I did lots of the beginner programs from lot of sites when I was getting started, and its always great to learn something 3 times to really cement it. Just keep in mind it wont get you to actually writing your own scripts, more just understanding what oyther people are doing when you read their code. Odin project for ruby is a great pathway for fuller learning 
[Here is how I did it 9 years ago] (https://github.com/peteonrails/vote_fu) [Here is how the guy who took over my project did it a couple years afterwards](https://github.com/bouchard/thumbs_up) TLDR: As long as the license was MIT or similar, and for good measure you mention your prior authors, you're in the clear. 
Iâ€™d second Chewy. As an aside, the project is very welcoming to submissions for expanding the api or fixing bugs. 
I think we can agree that you *can* do event sourcing in any language. But some languages definitely have an advantage over ruby in my opinion. Take Elixir for example. Genservers are a perfect way to do aggregate roots, take care of linearization for you, and offer a great way to mirror your data in memory. Also immutable data is a very nice thing to have when programming event sourced systems. Ruby doesn't have any of that unfortunately, and it probably never will. So yes, event sourcing brings some of the advantages of FP to other languages, but the real power (imho) comes when you use event sourcing *with* an FP language.
@@all is class variable (belongs to parent), what you want is class instance variable def self.all @all # this is class instance variable, each class type inheriting this will have it's own instance, remember to not use @@ here end place it inside of Animal, and Cat, Monkey etc will have their own instance of it
yeah I can see it now, thanks I will try to use it when creating new ones for the team 
Just get the pickaxe book and skim over stuff you feel comfortable with. There are a lot of concepts in Ruby that will change the way you approach solving problems (as there are in pretty much any language), and that's the really important stuff to learn.
Hello, reminder: you're more than welcome to send in your articles (about your library / gem of choice) too!
Just look at all the wonderful hash/array methods and you'll be ready to start writing 1 line solutions to any problem you have! In all seriousness i've found the best way to learn a language is to do a coding challenge in that language. The Advent Of Code challenge is a fun one currently going on! (https://adventofcode.com/)
I started with learnXinYminutes.com/ruby and devdocs.io. Started solving problems and never really needed much else.
AFAIC there is none. Ruby 3 is an idea, toward which the current Ruby development (2.4, 2.5, etc) is heading.
Isn't that somewhat counter to the idea of progressing to Ruby 3? As far as I can tell Ruby follows semantic versioning, and at least the Guilds Concurrency model would probably be at somewhat feature breaking depending on the depth to which it's implemented. So can that logically be developed under the guise of a 2.X version, or has nothing actually begun in terms of development for those features? 
The work on the MJIT branch is available in https://github.com/vnmakarov/ruby/tree/rtl_mjit_branch I don't know about everything else, but some of those changes can be only ideas at this moment. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [vnmakarov/ruby/.../**21bbbd37b5d9f86910f7679a584bbbfb9dc9c9b1** (rtl_mjit_branch â†’ 21bbbd3)](https://github.com/vnmakarov/ruby/tree/21bbbd37b5d9f86910f7679a584bbbfb9dc9c9b1) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I just went to RubyConf and my understanding is that things like Guilds and MJIT are mostly being explored by individuals in separate branches. Lots of different people are working on different potential enhancements to typing too and presenting their thoughts. Once we get more past this R&amp;D phase I'd assume we'd have a year dedicated to doing the 3.0 release.
Well, that was a rather fascinating to read up on. I didn't know about their efforts on JIT Compilation for Ruby. Thanks.
Ahhhh I see now. So pending any official selection of paradigm for any particular implementation of those features, there'd be little point in creating a Ruby 3 branch just yet. Makes sense. 
&gt; Isn't that somewhat counter to the idea of progressing to Ruby 3? Why? Why would 2.5, 2.6, 2.7 etc. releases *not* lead to Ruby 3? I've never seen anything to hint that Ruby 3 is intended to be an all-new language. Simply an evolution of Ruby, like 1.8-&gt;1.9-&gt;2.0. You don't want a debacle like the Python 2/3 situation, or Perl 5/6 situation, do you? 
Not at all. It's more in the concept of the versioning. If it is following the concepts of semantic versioning, then naming it ruby 3 is something of a proclamation that some things may not work the same. Whereas if the idea is that nothing break than is progression to Major version 3 necessary? This is, ironically enough, just a semantical argument though. I think we can all agree that it would be objectively better if upgrading to ruby 3 required absolutely no changes to existing code bases.
It's very important to distinguish between the natural act of leveraging language and runtime features that comes with any implementation, and the belief that those language and runtime features that have been leveraged _prove_ that the language is better suited for the implementation than any other. In other words, it's easy to get comfy with language features and believe they are solving otherwise unsolvable problems, without realizing that different programming languages will just tackle the same problems in different ways. I think you're reaching pretty heavily here. &gt; Take Elixir for example. Genservers are a perfect way to do aggregate roots, take care of linearization for you, and offer a great way to mirror your data in memory I think you're assuming a lot. Your first assumption is that you have a code artifact that is called an "aggregate root." Aggregate roots are only tangentially related to event sourcing by the fact that they both came out of the DDD community. Let's call the aggregate root an _entity_, i.e. one of the things that gets projected (or "sourced") from events. This is more precise, because an aggregate root need not be a single design element such as a class. Now, if I read you correctly, you use genservers to assign a lightweight process to each entity. What benefits does that bestow to your programs? Can you _qualify_ your assertion that they are a perfect way to "do aggregate roots?" Because as it stands I think I have a perfect way to implement entities and projections without genservers at all. Well, not perfect (nothing is, actually), but as perfected as I presently am capable of seeing. Anyways, you say that genservers take care of linearization "for you," and that's where I really start to lose you. Linearization already happens by virtue of the fact that only one actor can be allowed to write to a given stream at a given time, and it requires a special affordance from the database. See EventStore's "expected version" which is inspired by traditional optimistic locking. An event stream is just a linear sequence of events, after all. Regarding mirroring data in memory, it sounds like you're describing a cache. I also implemented an [entity cache](https://github.com/eventide-project/entity-cache) in ruby for event sourcing. It is also a great way to mirror data in memory. Perhaps different than how you'd do it in Elixir, but not necessarily inferior. In fact, my users don't even really ever need to be aware of the entity cache, unless they need snapshotting (which is just a second layer of the entity cache that stores entities on disk instead of memory). &gt; Ruby doesn't have any of that unfortunately, and it probably never will. It probably won't ever _need_ any of that. It does have an [actor](https://github.com/ntl/actor) implementation I wrote that allows multiple category stream subscribers to operate independently within separate threads, so that handlers can react to events (pub/sub). That's about all the machinery I really need to build a scalable system with event sourcing in ruby. I'd be struggling to figure out how to make use of anything more. &gt; Also immutable data is a very nice thing to have when programming event sourced systems. I'm going to disagree with that one, too. Ruby lacks the copy-on-write semantics necessary to optimize immutable data structures, but I certainly _could_ implement event sourcing using immutable data structures, and it wouldn't actually make all that much difference to the code written by end users. When entities are being projected, you're either going to mutate a single entity, or you're going to apply each event by returning a new entity with the changes made to it. Not much difference really. And this brings me to my original point -- because it's _ludicrous_ to mutate entities after they've been projected, and the entities are unavailable to application code while they're being projected, entities become effectively immutable to the end user even though the underlying data structures are not. _This_ is exactly how event sourcing bestows some of the benefits from FP to any programming language you care to use for event sourcing. &gt; So yes, event sourcing brings some of the advantages of FP to other languages, but the real power (imho) comes when you use event sourcing with an FP language. This kind of blanket statement makes me question whether you've actually understood the chief advantages of event sourcing. I'd need you to qualify your statements a whole lot more before I even entertained whether I'm the one who has misunderstood the "real power."
Thanks, the goal is to take a text file with domains &amp; make sure the IP resolves to a certain IP addresses. If an IP address in the hash does not to remove the domain associated from the hash &amp; overwrite the text file. 
I believe you are on a path that will meet those goals. I think there are some better ways, potentially to handle this. But I get the impression you are learning the basics, so maybe simple is best? I personally would go with either constructing a class to handle this. Or I would do a map and filter. There are better ways to do what you are doing. But don't let perfection be the enemy of the good enough.
Also equally interesting https://github.com/k0kubun/yarv-mjit
I think actually you're being quite rude at the moment, but I'll entertain this discussion for at least one reply. &gt; Linearization already happens by virtue of the fact that only one actor can be allowed to write to a given stream at a given time, and it requires a special affordance from the database. What you are describing is called "optimistic locking". That's usually presented as one of two options: "optimistic" or "pessimistic". There is a third option: the agent model, completely lock-free (making the optimistic lock at DB level redundant). You can implement the agent pattern trivially using GenServer, while agents in Ruby have never really taken off (last time I looked at for example EventMachine, there was a big warning like "make sure you really know what you're doing!"). There is a very real difference between agent (lock-free) and optimistic locking. Both are safe, but optimistic locking is prone to command failures when there is high contention for a particular "entity". An agent will never fail because of contention (but will of course fail if your command is out of date by the time it gets to the front of the queue ... so while empirically better than optimistic locking, it still is not perfect). Given that Agents are a common pattern in Elixir and not in Ruby, I think we can chalk this one up as a win for Elixir. &gt; Regarding mirroring data in memory, it sounds like you're describing a cache. Yes, it is a cache. But it is not the same cache as the one you are describing. Your in-memory cache is not production-grade (just throwing everything in a hash is not going to cut it) and your persisted cache is going to be error-prone (because your state will be potentially out of date every time you deploy a new version of your app), not to mention slow if there is a cache miss (or multiple, depending on how much contention there is for a particularly large entity after deploy). Decision: Elixir. &gt; Immutable I'm sorry, but however you slice it, Ruby's data structures are *not* immutable and never will be. Consequence: parallel programming is hard. Consequence: deep copy is difficult (and you can never be sure you've done it right). The best you can do is "immutability by convention". Sorry bud, Elixir wins here hands down. Immutability gets you strong guarantees that you will never mutate state when you meant to copy it. And since there is no reason to mutate state when doing event sourcing (or FP in general), why not just toss out the language feature that allows you to mutate? Let's face it: immutability is a silver bullet when designing concurrent systems. I suppose you are going to contend this point, but try googling a bit around before you reply on this one. Decision: Elixir. &gt; Blanket statement Let's keep this discussion civil. You don't know me.
Good bot.
What a nice meatsack! ã¥â—•â€¿â—•ï½¡)ã¥ You can continue flapping your meat around. *** ^^I'm&amp;#32;a&amp;#32;bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[&amp;#32;**Block**&amp;#32;**me**](https://np.reddit.com/message/compose?to=friendly-bot&amp;subject=stop&amp;message=If%20you%20would%20like%20to%20stop%20seeing%20this%20bot%27s%20comments%2C%20send%20this%20private%20message%20with%20the%20subject%20%27stop%27.%20)TÌ¶Ì¡Í˜Ò‰ÍÍ…Í‡Í•Í–Ì¬Í…ÍˆÌ«Ì˜ÍšhÌ§Ì´Í Ì¡Ì›Ì˜Í“Ì¦ÌºÍ™Í–Ì­Ì¯Ì­eÌµÌ•Í¢Ì¶ÌªÍ“Ì¼Ì³Ì¤Íš&amp;#32;ÍÌ´Ì©Ì»Ì™Ì²Ì¯Í‡ÌÌ±Ì¬Í–Ì¤ÌºÍ•ÌÌœBÌ·Ì§Ì¤Í–ÍÍˆÍ…Ì°Ì¥ÍšÌ¯Ì–Ì¥Í‰Ì–Ì®Ì±Ì¥ÍˆÌ™Ì—oÌ›Í Ì§ÍÌ¢Ì¥ÌÌ²Ì»ÍÌ˜Ì—Ì¯Í“Ì³Ì¼Í‰Í•Í…ÍšÍ”Ì¤tÌ¸Ì™ÌÌ£Í”Ì—ÍˆÍÌÍ‡sÌ›Ì§ÍÌ–ÌºÌ£ÍÌ¬Ì Ì³Ì¼Ì¹Í™Ì¹Ì¤Ì¬Ì¤ÍÍ“Í•Íˆ&amp;#32;ÍÍœÍÍ Ì¥ÌŸÌÌ¤Í”ÌªÍšÌ±Ì¦Ì®Ì¹Í–Ì¯ÍšÌ£sÌ¨Ì·Ì¼Ì Í‰Ì®hÌ§Ì•ÍŸÍˆÍÌ–Ì²Ì©Ì»Ì¯Í–Ì¼aÍÍÌµÍ¢ÍŸÌ£ÍˆÌ«Ì¯Ì¯ÍÍ•ÌÌ±lÍÌ·Í¢Ì™Ì™ÍÌ³ÍˆÌ±Ì°Ì˜Ì«Ì¦Í•Ì™Ì—lÌ·Í¡ÍÍ‡Í™Ì«Ì²ÌÍ…Ì°Í…Í‰Í•Ì²&amp;#32;Í€Ì¢Í¢Í¡Ì£Ì­Ì¼Ì©Í“Ì¤Ì²Ì±ÌœÍˆrÍ€Ì¸Ì¹Í™ÍˆÌ©iÍ Ì¶Ì¢ÍˆÌŸÌ¬ÌœÍˆÍ–ÌœÌ˜Ì£ÌÌªÌ¬Ì»Í•sÌ›Ì·Ò‰Ì¢Ì¦Í™ÌÌ²Ì¤Ì£ÌªÍ–Í•ÍšÌ¹Í‰Ì£Ì—Ì³Ì³Í”eÌ¸Í¢ÍÌÍÌ²ÌœÌ»ÌÌÍ™Ìª;Ì•Ì•Ì«ÍšÍ™ÍšÍ‡Ì¹ÍˆÍ…Í‡Í‡Ì Ì¯Ì¼Í–&amp;#32;Ì´Ì›Ì¡Ì§ÌÌ±Ì—Ì¬Ì»Ì»Ì«ÍˆÌ Ì³Ì–ÍˆÌÌ¯TÌ•Ì¡Í˜Ì¹Ì¹ÌhÍŸÍ¡ÍÌ¢ÍÍÌ©ÍÌ»Ì³ÌªÌÍ…Ì¯Ì¤Í”ÍÌœÌÌ«Í‡eÌ¢Ì´ÍŸÌ›Í Ì¦Ì¥Ì³ÌªÌ¥&amp;#32;Ì¨Ò‰ÍÍˆÌ°Í–ÌªÌ»Ì­Ì¼Ì¼Ì­Í…hÌ¸ÍŸÍ“Ì–ÍÌ°Ì¹Ì¤Ì£ÍšÌ¼Ì˜Ì¼ÍˆÍuÍÍÌ¸Í Ì¡ÌœÌ™Ì£Ì—Ì­Ì¤mÌµÍ¢ÍÌ±Í”Ì©Ì˜Ì˜Í‰Ì°ÍÍ‡Í•Ì²Í”aÌ§ÍÍÌ¦ÍÌ£Í‰nÌ›Ì­Ì±ÌºÌœÌŸÌ˜Ì Ì£Ì—sÍ€Ì¶Ì¶Í–Ì—ÍˆÌ®Ì¬&amp;#32;Ì•Ò‰Ì¦ÌœÌ˜wÌ´ÍÌ¦Í“Í“Ì¼Ì¯Ì²iÍÌµÍ‰Í…Í•ÍˆÍ–lÍŸÍ˜Í€Ì©Ì²Ì³ÍÍ•ÍšÌ°ÌœÍ…Ì¬lÍ€ÍœÌ¡Í€ÍÍÍ•Ì–Ì¥Í‰Ì¦Í–Ì¯Ì˜ÌŸÍ•&amp;#32;ÍÍ˜Í…ÍÌÌ£Ì¥Ì¦Ì¥Ì¥Í”fÌ·ÌµÍ¢Ì¢Í™ÌÌ­ÌÌ—Í‰Ì¤ÌŸÍ“Ì¹Ì–ÌŸaÌ§Í€Ì¯Ì©Í™ÍšÌ»ÌÌÌ—Í™ÍˆÌ«Ì¯ÌÌ¬Ì—Ì¦Ì£lÌ´ÌµÍ‡Í‰Ì®Í”Ì£Ì™Ì¹ÌÌœÍÌ™Ì¬Ì«ÌœÌ¬ÌªÌ¤Í•Ì­lÍÍ¢Ì¢Í¡Ì¶Ì®ÌªÍ–Ì–Ì²Í‡Ì±Ì¦Ì²
nanotest has the `random: true` option for that xD
Ruby does not follow semantic versioning. At best I would say it is semver â€œishâ€. If it were following semver they usually make a backwards incompatible change or two every year so it should be at a much higher number than 2. 
Those are good points. I guess Ruby 3 will have some breaking changes based on their versioning policy: https://www.ruby-lang.org/en/news/2013/12/21/ruby-version-policy-changes-with-2-1-0/ My guess is that they'll continue with the 2.5/2.6/2.7/etc point releases until they're very close to meeting the "3x faster than Ruby 2.0" goal. At that point I'd expect the next release (or perhaps the one after that) to be Ruby 3.0 and have some breaking changes?
Having read up on the MJIT implementations that sounds like it's to be the case. Most are being specced as explicit tradeouts from the current compiler, which runs the risk of bringing unknown bugs to production setups. Though /u/seraph787 did share this rather interesting link to an in-between implementation that allows for optional adoption of some of the JIT features: https://github.com/k0kubun/yarv-mjit All in all, Ruby 3 will probably be defined by having the JIT, Duck Typing and Guilds Models implemented, with efforts made to have as few breaking changes as possible in the process, but the version 3 giving them the license to have those breaks if they're necessary. That's just my guess at any rate. Either way, thanks for helping me better understand where the process is at. :)
Can do this: results = WhatIs.these('Warszawa', 'Kharkov', 'Moscow', 'Bela Crkva') # =&gt; { # "Warszawa"=&gt;#&lt;ThisIs Warsaw [img] {52.233333,21.016667}&gt;, # "Kharkov"=&gt;#&lt;ThisIs Kharkiv [img] {50.004444,36.231389}&gt;, # "Moscow"=&gt;#&lt;ThisIs Moscow [img] {55.750000,37.616667}&gt;, # "Bela Crkva"=&gt;#&lt;ThisIs::Ambigous Bela Crkva (6 options)&gt; # } results['Kharkov'].describe # =&gt; Kharkiv # title: "Kharkiv" # description: "city of Ukraine" # coordinates: #&lt;Geo::Coord 50.004444,36.231389&gt; # extract: "Kharkiv (Ukrainian: Ğ¥Ğ°ÌÑ€ĞºÑ–Ğ², pronounced [ËˆxÉ‘rkiuÌ¯], Russian: Ğ¥Ğ°ÌÑ€ÑŒĞºĞ¾Ğ², translit. Khar'kov [ËˆxarÊ²kÉ™f]) is the second-largest city in Ukraine." # image: "https://upload.wikimedia.org/wikipedia/commons/a/a8/Kharkiv_montage_%282015%29.png" results.values_at('Warszawa', 'Kharkov', 'Moscow').map(&amp;:coordinates) # =&gt; [#&lt;Geo::Coord 52.233333,21.016667&gt;, #&lt;Geo::Coord 50.004444,36.231389&gt;, #&lt;Geo::Coord 55.750000,37.616667&gt;] results['Bela Crkva'].variants # =&gt; [#&lt;ThisIs::Link Bela Crkva, Banat&gt;, #&lt;ThisIs::Link Bela Crkva, KrivogaÅ¡tani&gt;, #&lt;ThisIs::Link Bela Crkva (Krupanj)&gt;, #&lt;ThisIs::Link TopliÄka Bela Crkva&gt;, #&lt;ThisIs::Link See also/Bila Tserkva&gt;, #&lt;ThisIs::Link See also/Byala Cherkva&gt;] results['Bela Crkva'].variants.first.resolve # =&gt; #&lt;ThisIs Bela Crkva, Banat [img] {44.897500,21.416944}&gt; ...and some other stuff. Library and binary, works with any language Wiki. I use it to resolve user-entered toponyms (in many different forms) to map locations, Wikipedia seems to be pretty good for this. WDYT?
Hi! My name is Noah Gibbs, and among other things, I'm working on Ruby 3. Several people here have mentioned most of what I will, but I'll confirm those and mention a few more. The main announced thrusts of Ruby 3 are performance, concurrency and typing. For performance, the work is primarily occurring in the normal Ruby trunk. Matz has announced that he wants Ruby 3 to be three times as fast as Ruby 2.0.0, and there has been great progress in that direction. I'm the author of Rails Ruby Bench, which is (surprise) a benchmark checking Ruby's performance using a big highly-concurrent Rails app. You can see the results on [the](https://appfolio-engineering.squarespace.com/appfolio-engineering/2017/5/12/has-ruby-helped-rails-performance-other-than-garbage-collection) [engineering](https://appfolio-engineering.squarespace.com/appfolio-engineering/2017/8/21/rails-and-discourse-startup-times) [blog](https://appfolio-engineering.squarespace.com/appfolio-engineering/2017/11/29/how-much-faster-is-ruby-250-preview-1) for [Appfolio](https://appfolio-engineering.squarespace.com), which sponsors my Ruby 3 work. You can also look up "optcarrot", which is the other major Ruby 3 benchmark. Mine is Rails-based, while optcarrot is primarily a CPU benchmark. On the Rails-based benchmark, Ruby 2.5.0 head-of-master is around 165% of the speed of Ruby 2.0.0, so progress isn't bad. The optcarrot numbers are even better. In addition to normal "let's make slow things faster" performance work, there are the two JIT branches mentioned below - Takashi and Vlad have been working independently and together, and at this point it looks like Vlad's JIT implementation is likely to make it into Ruby 3 in around a year, if nothing changes... Though possibly without his changes to the way Ruby handles its bytecodes. They're faster, but less compatible and would need more stability testing. Takashi's YARV-MJIT branch is *just* the JIT without the register-based VM bytecode changes. For more Ruby 3 progress, I highly recommend looking up RubyKaigi 2017 and RubyConf 2017 on ConFreaks.org. They record all the major Ruby conferences, and a lot of the proposals and status updates have been happening as conference talks. The talks are all available entirely free, though some of the RubyKaigi talks are in Japanese :-( In particular, Takashi Kokubun gave a *great* YARV-MJIT talk this year at RubyConf, just a few weeks ago. There were several different gradual-typing talks at RubyKaigi and one by Soutaro Matsumoto (no relation) at RubyConf. Unfortunately, the Guilds-based concurrency stuff that you're curious about is *not* in Ruby trunk. There have been a few good blog posts about it (I like [this one](http://olivierlacan.com/posts/concurrency-in-ruby-3-with-guilds/.) Koichi Sasada, the author of the current Ruby VM, is currently working on it. My understanding is that there's not a current version being shared around. I don't have a good feel for where that's at. As of RubyKaigi, Matz has said he's not wild about any of the existing gradual-typing proposals, so we're basically at "still figuring out the spec" on that one. We've had some on-paper-type proposals and some early implementations, but nothing is currently close to getting included as a standard part of the language. And those are the big three, as far as Ruby 3 goes: performance, concurrency, typing. There are some small things "in orbit" around them like static analysis proposals for typing and benchmarking (for performance. But that's basically where things stand. 
Didn't they announce that they were switching to SemVer with Ruby 2? They certainly weren't before that - Ruby 1.8 to 1.9 was a *huge* breaking change.
Hi Noah. Thanks so much for the in-depth run down of where Ruby stands and how it's development process is progressing. It seems that barring what's discussed at these conferences, there's little documentation regarding Ruby's development progress, which would explain why so little came up while I was searching about the topic. I'm glad to hear that all the cool features and upgrades are indeed still in the works, and look forward to seeing how they progress. :)
&gt; I think actually you're being quite rude at the moment, but I'll entertain this discussion for at least one reply. I think perhaps something got lost in translation to text, I'm not at all intending any rudeness. I'll try to compensate. &gt; There is a very real difference between agent (lock-free) and optimistic locking. Both are safe, but optimistic locking is prone to command failures when there is high contention for a particular "entity". An agent will never fail because of contention (but will of course fail if your command is out of date by the time it gets to the front of the queue ... so while empirically better than optimistic locking, it still is not perfect). Right, but the scenarios that lead to high write contention on a given entity are an extreme rarity. I'll agree that such an entity would merit differences in the design approach. Also, what do agents have to do with functional programming? It sounds like you're touting Elixir's runtime features, not FP. &gt; Yes, it is a cache. But it is not the same cache as the one you are describing. Your in-memory cache is not production-grade (just throwing everything in a hash is not going to cut it) and your persisted cache is going to be error-prone (because your state will be potentially out of date every time you deploy a new version of your app), not to mention slow if there is a cache miss (or multiple, depending on how much contention there is for a particularly large entity after deploy). Can you qualify that assertion? I'll assert that throwing everything in a hash absolutely does cut it. And you're also missing some knowledge about how the whole system gets assembled. Any cached entity is always going to be potentially "out of date." That's why the cache line contains the entity version -- so that the entity can then be projected up to the current version. I realize this may be _different_ than how you assemble similar systems in Elixir, but that doesn't mean it doesn't work in production. There is an important distinction between projecting entities on-demand versus "pushing" new events directly into entities when they are written. The former is a much simpler approach to reason about, it relies on far less grasp of the dynamic elements of the system design because there's no "magic" behind the scenes orchestrating the entity updates. &gt; I'm sorry, but however you slice it, Ruby's data structures are not immutable and never will be. Consequence: parallel programming is hard. I don't need fine-grained parallel programming techniques. If I want to leverage additional cores, I can introduce partitioning ala Kafka. Stream based systems are "embarrassingly parallel" already. &gt; Consequence: deep copy is difficult (and you can never be sure you've done it right). The best you can do is "immutability by convention". Sorry bud, Elixir wins here hands down. Immutability gets you strong guarantees that you will never mutate state when you meant to copy it. I don't _need_ to deep copy entities. I don't need those guarantees. In actual implementation on top of an event sourcing stack, there is no _value_ to be gained by mutating an entity after it's been projected. Event sourced entities are exclusively constructed from events, to mutate an entity after it's been projected from the event stream would violate the underlying pattern. Sure, someone _could_ do it, but then I could ask, why aren't you using a statically typed language? &gt; And since there is no reason to mutate state when doing event sourcing (or FP in general), why not just toss out the language feature that allows you to mutate? That's a dubious argument. The impact of mutable entities in an event sourced system is negligible. &gt; Let's face it: immutability is a silver bullet when designing concurrent systems. I suppose you are going to contend this point, but try googling a bit around before you reply on this one. You're not recognizing the horizontal scaling options that come for free when you build a system on streams. It's as much as a silver bullet as immutability. &gt; Let's keep this discussion civil. You don't know me. There was nothing uncivil about asserting you made a blanket statement. The claim you made at the end of your post was broad and not supporting by the rest of your claims. I don't really see how you are justified in construing my response as being "rude." The _real power_ of event sourcing is not runtime optimization techniques, which is ultimately the conclusion I drew from reading your comments. I re-read it and still think you drew that conclusion. That said, I realize that disagreements online can easily escalate into bitter sparring, so, to the extent that I have escalated this, I apologize.
Ruby is unusual in that a lot of its development occurs in-person and in Japanese. You can find notes from its developer meetings on bugs.ruby-lang.org: [wiki link, scroll down to the "Developer Meetings" section](https://bugs.ruby-lang.org/projects/ruby/wiki/Main).
I also feel the need to add: if you're building event sourced systems in Elixir that are robust, well designed, easy to understand, etc., then power to you! But I'm going to object to anyone claiming I made an inferior choice to build mine in ruby.
Thank YOU for helping me better understand where the process is at!
I suppose in the end Semantic versioning can only go so far. As idealistic as the Ruby community tends to be with Semver, BDD and TDD, depending on various circumstances something will probably always end up giving. Still, all worth it in the end for the great language. 
There seem to be several well-regarded Ruby/Rails texts that are aimed at intermediate-to-advanced programmers, and they're all on my current reading list: Eloquent Ruby - Olsen Metaprogramming Ruby - Perrotta The Rails 5 Way - Fernandez Practical Object-Oriented Design in Ruby - Metz 
I waited 15+ years for a successor to Perl 5 after Perl 6 was announced. I gave up at about the 7 year mark and declared Ruby *my* Perl 5 successor. Never looked back. 
Bad bot. 
Unbelievable. You, xc68030, must be the pride of [xc68030's hometown here]! 
Previously they were using their own versioning for example 1.9.3 and 1.8.7 were stable because they are odd and even releases were not i.e. 1.9.2 and 1.8.6 to something that is closer to semver. However basically no one is following semver. I wrote an article on this https://www.schneems.com/2015/11/29/what-is-semver.html Now they release a minor version every christmas (not semver). It can have backwards breaking changes (not semver) however they try to limit these. Then they will release teeny versions throughout the year for security or bugfixes (mostly semver, but sometimes they break backwards compat by accident, though this is rare these days). There is a "patch" version, but this is just the number of commits in front of the minor version. So when 2.5 is released it will be 2.5.0p0. If they release a bugfix after 5 commits it will be 2.5.1p5. This is much better than it was, and is somewhat semver-ish. But it is not officially semver. They do not claim to follow "semver". Matz has said many times he does not want to pull a "python3" or a "ruby 1.9" again since it is a huge barrier to upgrading. Even when Ruby 3 is released expect it to be largely backwards compatible except where it's been show than huge gains (performance/usability/security) can be had by breaking compat. 
Thank you for the summary! &gt; Matz has announced that he wants Ruby 3 to be three times as fast as Ruby 2.0.0, and there has been great progress in that direction. The interesting question here is of course for what workloads? You mention Rails benchmark. Are there other application types in your focus that you use as a benchmark for improving speed of particular Ruby features or flows? And, of course, which? :-)
There's a great talk by Matt Gaudet from RubyKaigi 2016 about this! It's what inspired Rails Ruby Bench. He suggests about nine total benchmarks and has some good ideas for them. One of his ideas that hasn't become standard yet is a tree-modification benchmark which would test garbage collection via modification of large tree data structures. He also suggests a startup-time benchmark. While Rails Ruby Bench measures that, Rails startup isn't by any means the only important startup benchmark - and small apps will behave very differently. Here's a link to his presentation: http://rubykaigi.org/2016/presentations/MattStudies.html There are also some other good benchmarks out there - a variety of microbenchmarks in the main Ruby source tree, as well as things like bench9000 from the JRuby community.
This is disgusting and entirely false marketing of what it really is. 
I am using jemalloc already But good to know one more reason to stay on it!
I haven't had a bad report yet about it. As far as I can tell, there is no downside.
Beware sql
This is interesting, but I'd like to see an example of where this would be beneficial.
Take a look [here](http://api.rubyonrails.org/classes/ActionController/HttpAuthentication/Token.html).
This is a great idea, thanks!
&gt; There are also some other good benchmarks out there - [...] Yes, of course. I was more specifically interested in what you - the Ruby development team - consider the benchmarks that you want to optimize against. Startup time is definitively important for smallish scripts that nevertheless use a number of libraries or gems.
Hello, reminder: you're more than welcome to send in your articles (about your library / gem of choice) too!
Send me a link if you've got the code hosted somewhere. I'm interested to see similar implementations in other languages. There's a small chance I'll need to change the backend to a different language to scale better.
Don't forget David Black's The Well-Grounded Rubyist, which sounds like it would be great for an experienced programmer such as the OP who is new to Ruby.
Hey this is neat! Thanks for sharing
https://www.sandimetz.com/99bottles/
I read that jemalloc has problems with transparent huge pages: https://blog.digitalocean.com/transparent-huge-pages-and-alternative-memory-allocators/
I tried glibc malloc tuning a while ago but all I've found so far is a reduction in virtual memory, not RSS. Are you getting different results?
An interesting post. Our Rails app does actually use components in a similar manner, but I would like to know how you get started with creating them.
There is an example of of a simple component at the end of the article and there will be more in Part 2, but basically each component is just a folder with JS, ERB and CSS files. You can either create them manually through `mkdir -p frontend/components/message`, `touch frontend/components/message/{message.css,message.js,_message.html.erb} `, or write a simple generator for the same thing. Here's the example from the mountain_view gem that embraces the same approach and tries to automate it: https://github.com/devnacho/mountain_view/blob/master/lib/generators/mountain_view/component_generator.rb
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [devnacho/mountain_view/.../**component_generator.rb** (master â†’ 2612d21)](https://github.com/devnacho/mountain_view/blob/2612d215fe5461acf56a87819c5cf51cb498a6ec/lib/generators/mountain_view/component_generator.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dqsx6b7.)^.
Thanks! It's a design pattern that I think is very useful, and I'm considering adding it to an existing project. The biggest thing that gives me pause about your article is the increased complexity to set up, as well as deploy. That existing project I mentioned is open source, and that can potentially scare off contributors (and maintainers).
This is great. What's the schedule for part 2?
I should add, the other thing I have to consider is the timeframe of adding this to an existing project. Can we gradually add components, our would we have to put most stuff on hold and ask people to spend all of their time redesigning the front end architecture? Just another thought to consider.
Good bot.
If you're adding it to the existing project â€” you can keep Asset Pipeline and just move the required parts to your new `frontend`directory gradually, once you're done â€” ditch the Asset Pipeline, but AP and Webpack can perfectly coexist, you can even use styles from app/assets/stylesheets 
Thank you! Expect it next Monday/Tuesday. And the third one â€” in another week
Well, and I'm pretty minor. You should treat my opinion as reflecting other more influential folks at best, and a distraction at worst ;-) Startup time is important in general. Ruby has always kept its startup time low, and by comparison with similar dynamic languages its startup time is surprisingly (sometimes shockingly) low. The core team has generally treated that as an important thing - and the relative lack of adoption of JRuby would argue the same, especially given how good it is in most other ways. 
Yeah, that's what it seemed like when I stared thinking about it and planning it on paper. I think that we need to make our code more modular though. There's plenty of work to do there - plenty of choose to be turned into partials. Hopefully then it would be easier to shift to making components just based on those partials.
Certainly, extracting stuff into partials is the first step
That seemed to work great. Thanks, mate.
how does this look? Seems to do the job. vips = ['127.0.0.1','127.0.0.2'].freeze domains_file = File.read("C:\\utilities\\domains.txt") domains = domains_file.split(" ") domains.delete_if do |domain| (Resolv.getaddresses(domain) &amp; VIP).empty? 
Some reviews: https://www.goodreads.com/book/show/31183020-99-bottles-of-oop
Interesting! Is there a way to be notified about when your blog post goes live?
What would be reasoning for not main lineing Jemalloc? Just historical compatability things?
As I said, it's not from me. :-) I just found this and thought it'd be interesting to the denizens here.
FYI, to code format, put 4 spaces in front on a line. And make sure at least 2 spaces are on the end with a return, so it knows its a new line. vips = ['127.0.0.1','127.0.0.2'].freeze domains_file = File.read("C:\utilities\domains.txt") domains = domains_file.split(" ") domains.delete_if do |domain| (Resolv.getaddresses(domain) &amp; VIP).empty? end I would make the following changes: Use % syntax for defining string literals. vips = %w(127.0.0.1 127.0.0.2).freeze Only use double quotes with string interpolation, single otherwise domains_file = File.read('C:\utilities\domains.txt') I would use #reject over #delete_if, reject makes a new array leaving the original unaltered. delete_if alters the original and returns it. Not mutating your data when you can avoid it is generally desirable. I'm not sure that it really matters in this case. Also, I would use the {} block syntax over do end in this case. I believe the general rule is to use do end for multi line blocks. (FYI, the two are interchangeable aside form style rules) domains.reject { |domain| (Resolv.getaddresses(domain) &amp; VIP).empty? } Also, I'd method chain most of the last part. So, the summation of all those changes is: vips = %w(127.0.0.1 127.0.0.2).freeze domains = File.read('C:\utilities\domains.txt') domains.split(' ').reject { |domain| vips.include?(Resolv.getaddresses(domain)) }
A big recommendation from me - this book teaches how we can do good OOP with Ruby. Recommended to juniors and seniors! I learnt a lot from it. 
This was discussed on the bugtracker. Core is pretty skeptical of adding new dependencies.
Oh yeah, these are all RSS results.
That's v4 only. v3.6 is fine, v5.0 apparently has a bugfix for this (but I haven't tried).
I believe the command you're looking for is `gem build GEMSPEC_FILE`. If you gem is called "x", there should be an "x.gemspec" file defining it. The build command would then be `gem build x.gemspec`, and it will output the built gem into the same directory as the gemspec (if the gem's version were 0.1, the filename would be `x-0.1.gem`). There's no command line option to have this file generated in another location. If you're using Bundler to manage your gem (`bundle init` is a great way to create new gems), you'll also have a Rake task to build your gemâ€”`rake build`. This calls the same `gem build` command under the hood, and then uses Ruby's FileUtils to move the file into the `pkg` directory for you.
I'm reading POODR right now, and plan on moving to 99B as soon as I'm done. 
It's the main design pattern in Rack. 
Would love to see the results as soon as this is ready!
Same here. I'm really interested in sharing the results with my team and talking through them.
You might consider Go.
Heh, maybe! But I hate its error handling model.
&gt; The wrong type was passed as an argument Lately I've been leaning towards using [`TypeError`](http://ruby-doc.org/core-2.4.2/TypeError.html) for this. 
So great to see articles like this. Thereâ€™s a huge unmet demand to show how to use modern JS techniques within Rails apps. 
+1
For a small flat-file based application like this with no database I would probably just have all my data like People loaded in RAM at start-up. Unless the people won't fit in RAM, or theres very little chance of having to go through my list more than once, it's probably faster to just greedily front-load initializing them all. At application load time, simply parse every line of the file, create a Person with the params of that line, then have a collection named something like People that has a method find() that takes a username and returns the Person instance which matches (probably using an internal hash of username to Person). Even for a little app like this, even if it's not going into real-world use, I'd suggest always practicing password hygiene, and have the passwords in the serialized file be some hash of the user's password, you can add a method like person authenticate(password) for comparing a provided password to the hash. Now your login method can be DRYed up (no duplicate logic for each user type) and conveniently reads something like it would with an ORM like ActiveRecord. If you really want to practice with seeking in a file and loading things on demand, or if you think it'd be faster in your use case, then I'd do exactly that, People.find would open the file, loop over lines (read one line at a time), compare the line to the passed arguments (username + hash of password), then if it matches parse the other values of the line into a Person and return that Person. If you want to gain anything out of that kind of practice though, after it gets to where it's functional, think about how the file is structured and ordered, and if you can come up with a way to design the file format such that you can find where a record starts or ends without reading the whole thing looking for record separators, jump around the file more than one record at a time, or find a specific user record based on username without having to read and check every record. 
Okay, That makes sense. Thanks for the help! Currently the users file is SUPER basic and it would be interesting to look into 'password hygiene' and play around with it, see what is possible. 
Hello, reminder: you're more than welcome to send in your articles (about your library / gem of choice) too!
It's by /u/PragTob (find his post [here](https://www.reddit.com/r/ruby/comments/7hqti5/where_do_rubyists_go_survey_about_programming/)). I'm sure he'll write about it ;)
I completely ignored the Hash#fetch_values introduction. In a way, mostly because there's already Hash#values_at, which already did that, but without the block argument. I still don't understand why the block functionality just wasn't introduced in the already existing method, as Hash already has quite a lot of very similar methods. 
I'll write at least a blog post and post it here :)
:wave: I haven't really setup anything for notifications - I'm also a bit overwhelmed by the response so far (415 replies so far). The blog is https://pragtob.wordpress.com/ and you can follow it in various ways - at the danger of getting annoyed by whatever else I post ;) (Same goes for Twittter) I'll also post it in /r/ruby.
Thanks for detailed response. Been researching and going over changes &amp; reasons for it. 
I'm having issues with keeping the formatting of the original file format the same after resolving the ip addresses. When it gets passed to an array and writes back to disk it removes the formatting which is needed. Not sure if there is a way to keep the original text file in place &amp; overwrite with the same formatting only removing the domain names that didn't resolve to the VIP array. When it writes to disk now it pretty much just writes the array as is. Maybe I should have approached this with doing a file.read and file.write going through line by line instead of storing as an array minus the domain names that didn't resolve to the VIP array. Open to opinions. 
Great point, I agree with you. I've updated the article to reflect this!
I remember when Rails said they were deprecating HashWithIndifferentAccess and would stop using it. Way back in maybe... Rails 3? Well, that sure didn't happen. 
Yeah, I don't quite understand the problem with: symbols for internal identifiers, and strings for anything external or user provided, including YAML. Where YAML data maps to internal identifiers, the symbol conversion should be performed explicitly by the YAML importer, as defined by the project. For any given option hash, the keys should be all strings or all symbols, and it should be obvious which is appropriate. If this is problematic, it's a code smell and likely a security or performance issue.
Honestly, I think a lot of it is just that people like writing and reading the shorter `:literal` notation, and similarly the `symbol_key: "value"` hash literal notation. 
&gt; There's no command line option to have this file generated in another location. That sucks :'(
It is a good start. Rails is more complicated than Sinatra, but there's way more people using it. So there's more help available.
I donâ€™t know, Sinatra is almost the perfect introduction to Rails.. learning Rails to get started with Sinatra doesnâ€™t sound wise. A good understanding of Sinatra will help a lot as Rails is much, much larger and will introduce many more concepts than Sinatra - itâ€™s easy to become overwhelmed.
I'd say if you want to start with Sinatra (you don't need a Rails primer). The Rails Girls have a great Sinatra getting-started guide titled ["Create your first voting app with Sinatra"](http://guides.railsgirls.com/sinatra-app). Cheers.
Thanks for this, I also just found in an old Ruby book a nice comparison I was missing. &gt; Rails is a large, heavy web application framework that has lots of features baked in. Rails can be used to build applications that are both large and small, but it tends to use more memory and resources than the other frameworks, and the performance is not as high. A typical Rails application will be composed of many tens of files and have a tight structure built of models, views, and controllers (these are explained later). Rails is popular because itâ€™s powerful, reasonably standardized, and, admittedly, has the critical mass of community support to keep its popularity growing. Sinatra is almost the direct opposite of Rails in terms of its qualities. Itâ€™s fast, lightweight, and pragmatic, and an application can be built within a single Ruby file. Thereâ€™s a lack of any enforced structure (though you could build your own), and fewer features are available out of the box; you will often need to call on other Ruby libraries to fill in the basics, like database support. Despite this, Sinatra is growing in popularity due to its extreme simplicity and its suitability for small, agile web applications and services. 
This is awesome! Thanks!
Is sinatra confusing you or is web app design confusing you? Sinatra is definitely a lot simpler than rails, so you might be barking up the wrong tree. 
I think it's more the web app design. I just did the Rails Girls getting started and Sinatra is clicking now as I do have some experience setting up and running a Jekyll site from GitHub Pages.
1) The split between interpreted/compiled is not as important as the split between GC and non-GC langauges. Go, for example, can be an absolute memory hog as the GC is tuned for extremely low latency at the expense of high memory usage. You can restrict the memory usage of Ruby by tweaking some environment variables. As a side note, using a compiled language for a web app is generally a pain in the ass. Ruby + Rails makes everything 10x easier than using Go and having to use code generation etc for the ORMs, which barely work properly as it is. Unless you desperately need the performance, it's not worth it. I recently built a web service in Rust. It was only 4-5x faster than the Ruby version and a total nightmare. Before that I had a similar experience with Go. 2) Concurrency in MRI Ruby is both simpler and more complex than other languages. Just like NodeJS, you need one MRI Ruby process per core, however, unlike NodeJS, you can use standard threads and blocking IO in Ruby. For applications which don't spend 99% of their time in IO, this has little downside performance wise and is a lot easier to understand. Memory usage is not normally such a big issue for a modern Ruby app. The sharing you described can be achieved by using forking, when set up properly, but it's often completely unnecessarily as you can easily fit one process per core into RAM.
I would agree whole heartedly... the KISS principal is in effect here... doing all of your routing / orm / view work in one place and learning how to piece it out when it get's unmanageable is a pretty fundamental thing that everyone should learn how to do... Also knowing how to do something simple with a simple tool will serve you well... sometimes you just need a shovel for a little dirt, not a bull dozer.
Doesnâ€™t look too bad to me. I would use `case` statements instead of the `if/elsif/else` clauses. 
1) &gt;&gt; I recently built a web service in Rust. It was only 4-5x faster than the Ruby version and a total nightmare. Before that I had a similar experience with Go. Really? That's what I want to do too. For ruby I'll use Roda, not Rails. The point is, I want to be able to run a few simple websites on a single server, therefore I want to chose Rust over Ruby. That way I can save resources, buy a cheap server. And I'll be able to save money. Little, but nonetheless something. I know both Ruby and Rust.
You haven't accounted for every possible outcome of a rock paper scissors game. 
I found the [rails for zombies](http://railsforzombies.org/) video series extremely helpful to understand how rails works.
Hey, I'm also trying to learn ruby (and Rails). I've submitted a pull request for an insignificant thing that I noticed. Another thing is you have an if !() It is usually recommended that you do if true truth-execution else false-execution If you want to do that you just have to get rid of the "!" and swap the statements around. Alternatively you can leave everything as it is and replace "if !" with unless. This way you only change one line but as far as I know using unless and else is frowned upon.
I would separate your user interface form the game logic. I'd also define initialize and put everything that is in start under it. Also, define the option set for weapons in one place and reuse it.
1. Probably not. 2. Three entirely separate instances will use 3x the RAM in any language. There are ways to try to use fork-and-exec and ["copy on write" shared memory](https://www.speedshop.co/2017/10/12/appserver.html) to reduce this, so unchanged memory locations can be shared between instances. The popular ruby web app servers all do this. MRI several versions ago was changed to support this better. I'm not sure what other languages do with regard to this. The other alternative would be _not_ to run three instances, but to try running one instance with multi-threading instead -- but unfortunately MRI ruby's "global interpreter lock" puts some limits on the usefulness of this. More modernly designed languages are unlikely to have this multi-threading limitation. 
Well, when I found it I posted links in a couple of places. I might have contributed to a little bit of its popularity.
FWIW, Sinatra hugely inspired Express.js and much of the current Node.js approach to building webapps, so the approach of just throwing routes and views around without much prescribed plumbing or testing is certainly on trend.. and if it works for you and your project, it's a fine way to go.
Thanks for the tips! What do you mean by "separate the user interface from the game logic"?
[removed]
The GIL is just an implementation detail of MRI Ruby, not of Ruby itself. JRuby offers a production ready fully parallel Ruby and in many cases, it offers 3x the performance and reduced memory usage on high-core machines.
2. that's 3 different web sites!
2 . I'm talking about 3 different web sites! 
Sinatra is much simpler and doesn't even include a database by default, but ends up being complicated in different because you will need to understand a lot more "bare metal" elements of the Ruby ecosystem (such as Rack) to deploy your app. If you use it long enough, you will get better at it, and get better at Ruby. Rails is definitely huge and complicated, but if you keep using it and following the guides you will get better and better as well. Honestly, I made a Sinatra app once and it just turned into Rails once I got it to do anything useful, only I had to create a lot of Rails-ish stuff myself. It was a great learning experience, but I wish my final app was a Rails app because it would be a lot easier to deploy and keep working. 
Use rubocop https://github.com/bbatsov/rubocop
As others have said, Sinatra is simpler, but because it's less opinionated, paradoxically, some parts can be more of a challenge than Rails. If you go on sitepoint.com, I know they have a book (JumpStart Sinatra), as well as some tutorials.
Okay, so you're asking if deploying 3 different web apps will take around 3 times the RAM of one web app? Yes, more or less, and I think that's true in any language?
I recommend that JumpStart as well. 
&gt; That way I can save resources by using a cheap server, with small RAM and CPU. And I'll save money. Using Rust in this case makes a lot of sense. I'm currently in the same boat as you (deploying several low traffic apps to one server) and rewrote a Rails 3 app to Haskell. The RAM usage dropped from ~250MB to &lt;15MB.
I spent years working on Rails before I found Sinatra. I now use Sinatra more. Typically if I need a database back end I use rails and for pure processing apps and endpoints I use Sinatra. Both work well for me in those camps. It would be my recommendation to evaluate your requirements to choose a framework. If you want to serve dynamic information, how do you foresee that information recalled. Those decisions are formed by how the user interacts with the app. so ask yourself what you want to make not how it will work. 
Congratulations! Neat game. Isn't it fun? I'll quote from the following people in their excellent textbooks: * Sandi Metz in {Practical Object Oriented Design in Ruby} * Robert Martin in {Clean Code} * Martin Fowler and Kent Beck in {Refactoring}, and * (for state/strategy) {Design Patterns} by the Gang of Four, as they're called. No piece of code is perfect. Metz: "This improve-it-now vs improve-it-later tension always exists. A good designer understands this tension, and minimizes costs by making informed tradeoffs between the needs of the present and the possibilities of the future." The future of this code is probably not very long, and the needs of the present are met, so I'd say you don't need to do anything more. But if you did... In a larger program, you would want to use attr_accessor or attr_reader rather than accessing instance variables directly with @ (per Metz: you want the dependencies of a class's methods to be *exclusively* upon other methods, not any variables, even when the variable is declared within that very same class). Robert Martin tells us only to use *verb*s or verb phrases for method names, not nouns nor noun phrases. So "weapon_player" and "weapon_computer" ought to be renamed "choose_player_weapon" and "choose_computer_weapon," or some other verb phrase. Question marks are used traditionally in ruby to terminate method names which return a boolean value. play_again? does not, so it's not conforming to general Ruby style. The recursion in play_again? is harder for my cognitive apparatus than would be a while loop whose condition is a method which retrieves the user's answer, but this is the largest CS flame war of all time, with most people agreeing with me but the opposite camp yelling louder to compensate. Also, my cognitive apparatus has a harder time with run_game than it should. Long conditionals are a Beck/Fowler code smell, and their solution is ultimately a refactorization called "Replace conditional with polymorphism," although you must first do refactorizations "Extract Method," then "Move Method," to the class which represents a type code the long conditional depends upon, then decide on an inheritance strategy with either "Replace Type Code with State/Strategy" or "Replace Type Code with Subclasses," then you can do the "Replace conditional with polymorphism." Eventually you would wind up with something akin to: if computer_weapon.beats(player_weapon) puts "Unlucky #{@player_name}! You lost!" elsif computer_weapon.ties(player_weapon) puts "It's a tie!" else puts computer_weapon, " beats ", player_weapon, " - you won #{@player_name}!" end This is the way a human thinks about it, and so it will be easier to understand and thus easier to maintain if it's phrased this way in code. But that only matters, again according to Metz, if cost of eliminating the possibilities of the future is less than the cost of meeting the needs of the present in a way that conditionals are replaced with polymorphism. Good luck!
puts and gets should be separated from other logic, so that all methods with puts and gets are placed together, and all other logic is separated. Traditionally this is done with something called MVC or Model View Controller, where the gang of four design patterns Composite (for subviews of views) and Strategy (when you have an option of controllers) are sometimes employed, but the big one here would be Observer -- when the model (in this case, which weapons the players choose) is updated, the view (in this case, puts) is updated automatically. You'd wind up registering an object to respond to the event that both weapons had been chosen by issuing puts and gets statements. /u/menge101 's comment is a very good one, and it's definitely worth it to look into MVC, just for the exercise of being very sure all user interface is segregated from all business logic.
I realized I may be muddying the water a bit. True replacement of the original conditional with polymorphism would get rid of *all* the if/elsif/else stuff, like: computer_weapon.fight(player_weapon), and the UI ultimately occurring from beneath that fight call. So, the lesser conditional above is more of a midway point between complex conditional and true replacement with polymorphism.
/u/timheilman went into depth about it, so I'll offer a simpler response. define your ui functions: greet_player prompt_for_weapon display_result play_again etc Keep that logic encapsulated away from the game logic to clean up how it reads. 
Hmm, I think you'll be wanting something along the lines of write_line = true domains.each do |d| write_line = false if line.include?(d) end write_file.write(line) if write_line Someone will probably come along in a second with a much more elegant solution
That seems to work but I started getting multiple domains per line in the new text file. Wondering if I can get it done without the loop. 
Althought not deep, i'm enjoying these posts. Keep it up.
Me too. I loved Perl 5 actually but the Perl community didn't care enough about mindshare to keep Perl competitive. In addition to Perl 6 too much investment in Catalyst and mod_perl also helped to kill it.
1. JIRA will always consume more RAM than my blog. Unless my blog is wrong. 2. RAM is cheap compared to development; does it matter?
Really interested to see what approach Ruby takes when it comes to typing support. Matz has said that "[optional typing should honor duck typing](https://bugs.ruby-lang.org/issues/5583#note-7)", which will require a very different approach to the simple nominal typing that's been added to recent versions of Python.
 write_file.write(line) unless domains.any? { |domain| line.include?(domain) }
&gt; If this is problematic, it's a code smell and likely a security or performance issue. Or you're wanting to write code operating on a fixed set of keys (totally appropriate for symbols) on values coming from user input (dear god do not use symbols here). Which, coincidentally, is *exactly* the case that HWIA was written to solve (i.e. "params").
This might be what you're looking for (a more lightweight aproach than docker container): https://github.com/wconrad/ftpd (found it by googling for "ftp ruby")
looks like exactly what I was looking for. Do you mind sharing what you searched for to find this?
&gt; (found it by googling for "ftp ruby") If you add "server" it should be the first result on google.
 I would do it like this: # Define variables, because literals are evil domains = %w{example.com foobar.local coder.dev} inputpath = 'C:\\utilities\\domainbak.txt' outputpath = 'C:\\utilities\\domainsnew.txt' # Read lines from inputpath into an array, removing trailing whitespace source_domains = File.readlines(inputpath).map(&amp;:chomp) # Open the outputfile with a block so that the file handle is automatically released File.open(outputpath,"w") do |outfile| # Write to file: source domains which are not included in the domains array, separated by line-feeds outfile.puts source_domains.select{|d| !domains.include?(d)}.join("\n\r") end 
Definitely. I'm curious as well. But my understanding is that none of the current proposals really accomplish what he wants. He's talked about something where typing is implied after the fact by collecting runtime information and then using it to find problems, in a kind of static-analysis-after-the-fact. I don't think I've seen a proposal that does that yet, though.
Well thank you very much sir I will give this thing a shot. 
If you just use ftp to get data, then you can implement by your own, it only requires about 4 ftp commands.
I use a library called vcr that records and plays back net requests and responses. There is a port that can be used with java https://github.com/betamaxteam/betamax I searched for vcr java
I am familiar with VCR but didn't think it would handle FTP. Either way I will check out betamax. Thanks for the recommendation. 
I've used a Gem called fake_ftp in the past with success. Give it a try and see if it works for you. https://github.com/livinginthepast/fake_ftp 
&gt; RAM is cheap compared to development; does it matter? This argument doesn't make much sense for hobby projects. Even if you get paid for development, you'd first have to show that developing in Ruby is significantly faster than in other (less wasteful) languages to justify the additional monthly cost.
Works great for me.
Is there a requirement to support text files that are too big to fit in memory? If not, then I'd stop thinking in terms of the text file at all. Just read the whole thing into memory operate on the array, then write the whole array out to file. IMO, I wouldn't even read and write to file, i'd leave that to shell input/output redirection.
you can use something like [Faraday](https://github.com/lostisland/faraday) to connect to the db
I don't understand blockchain. Does anyone have a nice simple article explaining it in simple terms why it is important? Reading through this, it's a sort of linked list of hashed data? Does everyone have to have a copy of the entire thing? If everything has to be kept in sync isn't that slow as hell? But then there are ledgers... which are sort of centralized. If we're going to centralized the slow decentralized thing why is it decentralized in the first place? Is it for transparency so the nodes can ensure the centralization mechanism is being honest? I'm so confused about all of this.
Used tis sever for testing ftp api
Had to do this for SFTP a little over a year ago. Ended up stubbing the calls to Net::SFTP, and writing some integration tests with rspec tags that Iâ€™d only run against a real SFTP server to verify Iâ€™m using the Net::SFTP api correctly. 
 File.open(yourfile, 'w') { |file| file.write IO.read(yourfile).split("\n") - ['words', 'to', 'remove', 'foo', 'bar'] }
Hello, reminder: you're more than welcome to send in your articles (about your library / gem of choice) too!
Yeah that is a good Idea too. Thank you so much for your help!
Neat!
Hi, I started with Sinatra 3 years ago when I was learning Ruby. It's nice because you get to work with a few files to begin with. I also read Jump Start Sinatra and I might have watched a Railscast about it, but it's so long ago hehe :) In case you would like more structure on how to learn the things: - Tried to make a simple webpage rendered by Sinatra. - Add some styling to that page. - Make more pages and extract the shared thingies between those pages to another file. - Add some gems to the Gemfile (I think I added shotgun first so I don't need to keep on restarting the server). - Add a way to access a database. I found Datamapper (Rails uses Activerecord which I learned eventually). - Find out that there was something called activesupport which has cool methods so I don't need to implement those things again. - Add a way to generate PDFS. I added the Prawn gem and I was giggling when it finally worked :). Small steps :)
Hi, are those Sinatra apps like for work/with a team, or for side projects?
The Sinatra apps are Line of Business functions. I typically take output from another system and process it as input into another system. Think csv import and sftp edi. Or I inject something into an API. Simple tools for interacting with external systems.
So, it seems to be a thing that takes your .txt files and turns them into .md files for Jekyll. Am I missing something? Why not just write into the .md file in the first place?
Webpacker is an anti-pattern: pollute the ruby sphere with JS and pollute the JS sphere with Ruby because you don't wanna read the Webpack tutorial. 
Thanks so much for all the feedback! A lot to digest here, but I'll look into making some improvements based on this advice. :)
Is it Rails-free libs/gems only? By "send in" do you mean a PR?
I thought the original article was interesting. The second post is expected to contain the meat of the code. I'd like to move an open source project I work on towards using components. For the record, my day job implements components, but everything is done via ruby, not JavaScript.
are you serious? webpacker does sprockets and more, literally. And I'm not even going into integrating those front-end frameworks. If rails complicates anything, it's from (still) mixing sprockets and webpack, something I expect that won't last long, as sprockets will eventually be phased out.
Sprokets won't be phased out until they figure out a way to painlessly include 3rd party engine assets.
are you serious? Webpack is by far powerful than sprockets, if you are still using sprockets your are developing in the wrong way.
I have to agree with /u/aarkerio. Webpacker smells. Webpack is great, but webpacker stinks to high heaven. Why do I need to use a bunch of ruby to run a bunch of JS? IMO, what should have been done was what Phoenix does: expose a configurable option that allows you to choose what commands manage the assets for your app. Phoenix ships with brunch, which is pretty old, but swapping it out for webpack is pretty painless. Phoenix doesn't have to know about node, webpack, babel, or anything like that. All I have to do is give it the watcher command, which is run on dev server startup, and ensure whatever I use to compile assets outputs them to the proper directory. I could switch to any other asset builder, and my elixir app doesn't have to change at all.
As someone who does both Ruby and Elixir, this is the reason why we made npm-pipeline-rails: https://github.com/rstacruz/npm-pipeline-rails
As someone who does both Ruby and Elixir, this is the reason why we made npm-pipeline-rails: https://github.com/rstacruz/npm-pipeline-rails
Awesome! I have a couple really simple ideas and am incorporating some gems. It's all clicking now :D
All gems are welcome. Big fan of activerecord, for example. See [Awesome ActiveRecord](https://github.com/planetruby/awesome-activerecord). Like in ruby there are many ways to do it :-) You can send your article (in markdown) by email or send a link to a gist (on github) or maybe the easiest (recommended) way first [open an issue ticket (on github)](https://github.com/planetruby/advent2017) and suggest / tell us more about your gem or gems. You can post here on reddit too. What gem or gems do you have in mind? 
Good point. The tag line of Journal.TXT is "Single-Text File Journals - The Human Multi-Document Format for Writers - Blogging Reinvented". So what's different? The point is that you have a single-file (like a single SQLite database) for your posts - all your posts are in a single file (in "plain" jekyll every post must have its own file). See the Perfect Days in Vienna example. Cheers.
Ah, that does make sense. Thank you.
You commented this twice btw
I may have misread. Is your beef just with the webpacker gem, and not with webpack? I think I'd understand the complexity argument. 
Hello, reminder: you're more than welcome to send in your articles (about your library / gem of choice) too! 15+ days to go.
Anyone happen to know if hexapdf can change the metadata (specifically the title) of an existing PDF? I haven't been able to find that capability in other libraries and I'm not having any luck finding it in their docs either so far.
Of course, if you can configure Webpack - do it. We have custom Webpack integration too. But I'll be a devil's lawyer. Webpacker is a tool not for experienced developers or teams which have them. --- It's a tool to start Rails project with modern front-end tools fast. I started using Webpack with Rails along before webpacker was created. I know how many time needed for that. Webpacker is strange, but it solves that problem. It's a tool for beginners developers who don't know how to works with Webpack. Of course, you may learn Webpack, but if you are a beginner, you must learn many things. Not only Webpack. And if you want to be a backend developer in the future, learning of Webpack is a waste of time. --- It's a tool which helps migrate from Sprockets to Webpack. --- We used webpacker to show general ideas in the article. If we told about Webpack configuration and how to integrate it to Rails, we would need a separate series of articles.
Of course, if you can configure Webpack - do it. We have custom Webpack integration too. But I'll be a devil's lawyer. Webpacker is a tool not for experienced developers or teams which have them. --- It's a tool to start Rails project with modern front-end tools fast. I started using Webpack with Rails along before webpacker was created. I know how many time needed for that. Webpacker is strange, but it solves that problem. It's a tool for beginners developers who don't know how to works with Webpack. Of course, you may learn Webpack, but if you are a beginner, you must learn many things. Not only Webpack. And if you want to be a backend developer in the future, learning of Webpack is a waste of time. --- It's a tool which helps migrate from Sprockets to Webpack. --- We used webpacker to show general ideas in the article. If we told about Webpack configuration and how to integrate it to Rails, we would need a separate series of articles.
You can, but I find it easier to use Sequel. 
Fun idea, though I'll be sticking with `less` ğŸ˜‰ Comments/criticisms (sadly, I see these things being done in tooooooo many Rails projects): 1. You're not [closing the log's filehandle](https://github.com/kirillshevch/logs/blob/8d2ca381412c48d72c0cbfae7ccd0fbfceed74fd/app/controllers/logs/concerns/logs_loader.rb#L14). Maybe this will be GC'd and closed, or maybe you'll cause the including application to run out of file descriptors. 1. The [way your viewing a "page"](https://github.com/kirillshevch/logs/blob/8d2ca381412c48d72c0cbfae7ccd0fbfceed74fd/app/controllers/logs/concerns/pagination.rb#L21) may cause an out of memory error 1. [This is why I don't like concerns](https://github.com/kirillshevch/logs/blob/8d2ca381412c48d72c0cbfae7ccd0fbfceed74fd/app/controllers/logs/logs_controller.rb#L5-L6): `index` and `show` are empty, I have to look at *2* different files for what really should be in the controller and/or those methods. And, more importantly,`Pagination` depends on `LogsLoader` and, the "interface"? An instance variable named `@logs`, which is dependent on the order of `before_action`, which is dependent on the order of the `include` ğŸ˜° 1. You're [bringing in HAML|https://github.com/kirillshevch/logs/blob/8d2ca381412c48d72c0cbfae7ccd0fbfceed74fd/logs.gemspec#L18]. While HAML is great, one's project should't have to now depend on it just to view logs. 1. The gem name, `logs`. While I cannot believe it's not taken I'd hope that it would have been used for something besides a Rails engine for viewing logs. But that's just me... :) 
My point is: why should I use a gem to handle a well documented JS library? what is the benefit?
Just code some more, eventually you'll end up with something that actually looks like rails lol
Thats fair enough. I just believe that, for rails sake, they would have been much better off taking a phoenix-like approach, and shipping a default webpack config, that does what sprockets does today. Ultimately its very surprising for Rails, which is convention over configuration almost to a fault, to not follow a convention here
To be pragmatic, it would make sense **if** webpacker would allow me to seamlessly migrate from sprockets to webpack, which means, same helpers, same configuration, no new binstubs. Which is not the case, so I agree with you. I've seen apps in the wild using rails API or roda/sinatra behind an express.js process handling SSR and proxying to the APIs. I favour using roda, as it's more lightweight and feature-rich, and you can't justify rails weight when cutting the view/asset parts from it. But development experience and environment setup time still has a long way to go.
 a.select { |string| b.any? { |word| string.include?(word) } } #=&gt; ["foo is available"] 
You probably need to get used to reading the documentation on ruby-doc.org. What you want to do is something like: a.each { |i| a.delete(i) unless i.include?(b[0]) } 
This is perfect, thank you!!
I definitely ought to, I appreciate you helping out anyway this was the perfect solution, thank you!!
StackOverflow might be a better place for this. https://www.google.com/search?q=While+executing+gem+...+(Errno%3A%3AEACCES)+Permission+denied+%40+rb_sysopen+site%3Astackoverflow.com
I put it there first, but also here just in case, you know?
Have a feeling library ruby might be protected. Anyways I always prefer to run via rvm. Which ruby did you install w rvm?
 rvm install ruby --latest And it ended up working once I changed the permissions, lol. I feel like an idiot.
Haha oh well got it sorted 
You can subtract arrays.
Hello, reminder: you're more than welcome to send in your articles (about your library / gem of choice) too! 
Curious if you've taken a look at [Async](https://github.com/socketry/async)
Yes, I have been looked async,em-synchony, and celluloid before I write my first line : ), compare to Async, lightio have the same fiber-idea, but different goal, the goal of lightio is to provide most stdlib compatible interface. So user can use LightIO::Thread and LightIO::Socket just like the stdlib api to do networking programming , and they can also chose to apply a crazy monkeypatch, that they can patch any exists ruby project without rewrite code. 
I'm the author of `async` and it has exactly this model - both being very compatible with `stdlib` and having drop-in monkey patching. The `stdlib` compatibility is done by intercepting functions in a completely generic fashion, the result which looks like https://github.com/socketry/async-io/blob/e64e7739cecdbd7e9bf5dbdb5786fdb28521c046/lib/async/io/socket.rb#L26-L36 If you want to use this with existing clients, e.g. NET::HTTP, you can do so like this: https://github.com/socketry/async-io/blob/e64e7739cecdbd7e9bf5dbdb5786fdb28521c046/spec/async/io/wrap/tcp_spec.rb#L29-L30
I love this kind of thing. I also wrote [`async` in Ruby](https://github.com/socketry/async) and [in C++](https://github.com/kurocha/async) they both follow a similar model and it's been proven in both development and production to be a great model - both easy to use and efficient. IMHO futures are a slow and leaky abstraction, so I'm glad to see more people following the implicit evented model. Ruby has a few hangups because it is garbage collected while C++ can depend on scoped initialisation/destruction which provides strong guarantees about the order of operations and lifetime of resources, so Ruby has to keep an in-memory tree of tasks, while C++ can maintain this safely on the stack. I had a go with both `lightio` and `async`, just essentially [copying the task you have in the README](https://gist.github.com/ioquatix/c8be70a7ca73bc30f73d3a0e551376cd), and the performance is pretty close! I see you are using NIO so that is to be expected. That's awesome thought. One of the things I wanted to avoid with Async is global state. I see you've implemented [per-thread IO selectors](https://github.com/jjyr/lightio/blob/e06810be80815df44fb768a7716944e23cbfea1c/lib/lightio/core/ioloop.rb#L55-L64) - `async` deliberately makes this explicit - you must use [the entry point `Async::Reactor.run`] (https://github.com/socketry/async/blob/a796eadaa9b1afe18ca6f42080f597473a7a23c4/lib/async/reactor.rb#L38-L61) around any code you want to be asynchronous. Nested invocations return a task, which you can wait on or terminate, so nested servers are super easy to implement, and [look something like this](https://gist.github.com/ioquatix/2e522ae91c79a9aa69e3518d18b5d7f2). The benefit of this approach is that you don't have implicit global state. The downside of this is that you essentially make the API more complex to use. You could argue being explicit actually makes it simpler, but I agree it's more complex because there is at least one more moving part you have to take care of. The benefit of being explicit is that the lifetime of the reactor is very clear and in the case of forking servers, multiple reactors, nested servers (e.g. running a DNS and HTTP server in the same reactor), it becomes a significant benefit and keeps the code very tidy. Anyway, I'm keen to see where you go next with this project. If you are interested we could move your project to the `socketry` org which is a place where we've been hosting all libraries that integrate with NIO. 
Clearly you guys should become best friends. 
+1 for moving it under Socketry... if you want to anyway!
I'm all for it :p
Yeah, I think it's a great idea to have NIO related things in one place.
Any love for someone in Moscow?
Unfortunately this requires the employee work from our SF office. 
That's really cool, the generic wrap methods is impressive(far better than my implementation). I don't know is it possible to make async-io more generic(rack in the IO monkey patch world?), that I can directly use it in lightio.
I'd need you to explain more specifically what you mean by "more generic". As in, what part is not generic enough for you? There are drop-in replacements for TCPSocket, UDPSocket, and so on.
+1, That's cool! I am happy to moving it, socketry / celluloid projects is really inspired me a lot.
I made some updates and republished the article based on /u/verwijderd input.
I'm curious as to the target audience / use-cases you envision for this gem. If you were offering an `nio4r` alternative, your "target audience" might have been clearer (server authors). However, you're clearly building on top of `nio4r` while still providing access to fairly lower level state and information. For example, `nio4r` clearly provides access to lower-level polling engines provided by the OS (both for local IO and networking IO). The use of `nio4r` required understanding of the the differences between Networking and local IO engines, so it can be properly used when writing servers and such. On the other hand, gems like `iodine` (I'm the author) attempt to abstract the network layer as much as possible, providing a "protocol" based API rather than network details. The target audiences are web and other network application authors, that can ignore connection management and focus on the protocol and the application at hand. Where do you see LightIO fit in? What will it be used for?
Lightio target audience is normal ruby user or server authors. Current version is more like a preview, so as you point out there just provide a wrapper of NIO::Monitor In next versions, LightIO will ship ruby stdlib compatible modules, so users can use `LightIO::Thread` or `LightIO::Socket` to instead ruby stdlib, and care nothing about async or react programming. You can see roadmap here https://github.com/jjyr/lightio/wiki/Current-status-and-roadmap
IMHO, I believe you would benefit from clarifying the ideal use-case for the library (authoring a game server / whatever), both because I believe it will help you focus your API's design and because it would allow you to provide a "practical" demo to the developers that need it most. Anyway, good luck! Keep up the good work and keep learning.
Doorkeeper gem to set up Oauth provider
In the context, I want to reuse the wrapped socket classes from async-io. But async-io is not designed as a wrappered sockets library, it depends on async, I'm more expect a gem just include socket wrapper.
I see. Well, `async-io` naturally depends on the reactor pattern from `async` to function. The reason for this split is because the core `async` exposes the reactor, but doesn't expose any of the Ruby specific interfaces for IO. That's because I hope there can be alternative (better) native implementations of IO, and they can work side by side on the same reactor.
Array.grep /.*foo.*/
Huh does 2 years experience with ruby count as senior in SF?
Yeeeey, bug reported by me is in the list (#14095) `ï¼¯(â‰§â–½â‰¦)ï¼¯`
Bug reported by me ([#14101](https://bugs.ruby-lang.org/issues/14101)) is *not* in the list ;)
&gt; #14101 much cooler than my bug :/
Thanks for the research! I totally agree with you on "all of these many incremental changes add up, and are what makes modern ruby such a robust, stable language."
2 years with ruby != 2 years total experience.
Rock paper scissors is a nice fit for a "results matrix" win_matrix = { paper: {scissors: :lose, paper: :tie, rock: :win}, rock: {scissors: :win, paper: :lose, rock: :win}, scissors: {scissors: :tie, paper: :win, rock: :lose} } You then index into the matrix using the hands of the two players: player_1 = :rock player_2 = :paper win_matrix[player_1][player_2] #=&gt; :lose If you want to go more advanced you can then use dynamic dispatch in ruby to dynamically call either a :win, :lose or :tie method (supposing those methods exist). result = win_matrix[player_1][player_2] send(result) 
`Hash#slice` is my favorite!
are the unicode 10 characters acceptable as variable names?
Upgrade rails, use encrypted secrets https://www.engineyard.com/blog/encrypted-rails-secrets-on-rails-5.1 and only put the single encryption key in Heroku ENV.
As variable **names**, you don't even need ruby 2.5; all you need is a UTF-8 encoded ruby file. Which, since [v2.0](https://www.ruby-lang.org/en/news/2013/02/24/ruby-2-0-0-p0-is-released/), is the default. Whether or not the unicode v10.0 emojis will display correctly in your terminal/text editor, however, is another question!
...Also, please don't. :D
This would be handy to have in Administrate as well. ;)
Did y'all see that ruby 2.5 actually changes the default of ERB to UTF-8? This issue also seems to have a way to explicitly set the encoding in ERB that works. https://bugs.ruby-lang.org/issues/14095
Does it handle nested forms/nested models? This is one area that rails errors get really nasty.
`Hash#slice` and `SecureRandom::alphanumeric` will really come in handy.
&gt; String#casecmp and casecmp? now return nil for non-string arguments This sounds like a step backwards to me. It seems wrong to not use `TypeError` for a type error.
* THe pick axe book * Learn Ruby The Hard Way * The Well Grounded Rubyist * Read the side panel
But this is consistent with other comparison methods in the library: :abc.casecmp? 1 #=&gt; nil 1 &lt;=&gt; Time.now #=&gt; nil [] &lt;=&gt; :foo #=&gt; nil So if you feel the `raise TypeError` behaviour is correct, then it would have been better to change the behaviour of several other methods.
Good stuff! I learned these patterns in school but never got to actually see them written in Ruby. 
Ah ok, that makes sense. Iâ€™d still prefer using `TypeError` but not at the expense of breaking backwards compatibility.
Wow, I'm glad someone read my comment that actually understood it. Yes, you're right; I was over-aggressive in my comment. I'm just pissed at our two-faced society since my family and my life has been shat on by it a lot recently. I will try to write more cogently in the future so that maybe I am heard instead of downvoted to hell or booed off the stage. Thank you for being open-minded and for listening.
Oh that's an interesting question. My bet is it does, because it accepts whatever the original `add` accepts. Will need to investigate. Is there an example for this?
*Eloquent Ruby *https://rubymonk.com
Thanks! I hope you enjoy reading them and find them helpful :)
Which book is meant for a beginner: POODR or 99 bottles?
I really like the examples and they are written ruby code (which is rare to find) Thanks for writing them!
Glad you like them and thanks for the encouragements!
Define "beginner", because I'd argue neither of them are. They're teaching more advanced techniques for designing and refactoring objects. 
Hello, reminder: you're more than welcome to send in your articles (about your library / gem of choice) too!
yep, I've reported it (that my bug) and it got fixed :)
[The Well Grounded Rubyist](https://www.goodreads.com/book/show/19484917-the-well-grounded-rubyist) is my favorite.
But I mean there is no other language that can look so happy #!/usr/bin/env ruby def service_status :âœ¿â— â€¿â—  #:à¹‘â—•ï¸µâ—•à¹‘ end case service_status when :âœ¿â— â€¿â—  puts 'ok' when :à¹‘â—•ï¸µâ—•à¹‘ puts 'ko' end 
https://github.com/mperham/sidekiq/blob/e447dae961ebc894f12848d9f33446a07ffc67dc/lib/sidekiq.rb#L52-L54
great work ! :)
nice!
thanks! :)
Nice work, these are exactly the annoying things about the error API. I wonder if some of these things might make sense as PR's to Rails? You'd have to think about backwards compat and how/if to handle it, but I think it might be worthwhile. 
I definitely want this to be part of Rails. However I feel it can only be an incompatible change, due to name collision or being irrelevant.
What do you mean by being irrelevant? Perhaps it needs a new method name, similar to what you've done. Probably not branded `adequate`, but maybe `errors.complete` or something? 
Flatiron School might be a nice place to start
Thanks, I was looking at Flatiron earlier and they seem great. Do you think it would be more applicable to take a course or two at a local college to lay a foundation for computer science prior or is it better to jump into a specialized, but more expensive, school like Flatiron/App Academy right away?
Hi Sihui, I really enjoy your posts taking real life analogy in a funny, interesting example and explaining in a very smooth and elegant manner. It will be great if you can also make a few blog posts on how to ace a job interview intended for junior-to-mid level Ruby on Rails developer. Thank you. Great work. Keep it up.
You need to know all the lines to know which are duplicates, somehow. Certainly the easiest way is to read them all into an array, and just use the built-in `uniq!` method. Then write em back out. I'm not sure if your proposed solution has any advantages over that simple solution, although it should work too. But your proposed solution still needs all the lines in RAM, so isn't actually saving any RAM. If you really need to minimize RAM usage, a much more complicated way would be to: read the file one line at a time, for each line take the SHA1 checksum of the file, and check to see if it's in your "already seen" array (or Set); if it is, skip the line, if it's not, output the line and add the SHA1 checksum to an 'already seen' set. You still need enough RAM for all the SHA1 checksums though. I suppose you could also store 'seen' lines or checksums somewhere _other_ than RAM, but which is still indexed, like a database. Much slower, but won't use any RAM. I don't think there are going to be any other sorts of solutions. If the files are reasonably sized (less than a meg?), I'd just read em into RAM and uniq! em. 
Tried something like this. I was storing the the duplicates in an array. Was going to try to remove them from the lines in the text file if found. dup_file_check = File.read('C:\\utilities\\domainduptest.txt') dups = dup_file_check.split(' ') p 'Found these duplicates' p dups.select{|v| dups.count(v) &gt; 1}.uniq dup_read_file = File.new('C:\\utilities\\domainduptest.txt', "r").read dup_write_file = File.new('C:\\utilities\\domainduptest.txt', "w") dup_read_file.each_line do |line| write_line = true dups.each do |x| dup_write_line = true if line.include?(x) end dup_write_file.write(line) if write_line end Doesn't seem to be working as intended. 
I know this isnâ€™t a Ruby answer, but the bigger the file, the more I would simply use this Unix command: sort -u file_with_dupes.txt &gt; file_without_dupes.txt
When posting in a reddit message, start your code lines with four spaces if you want it to be legible. 
It depends. Thereâ€™s no need for formal CS education to get the groundwork. And often these Code schools have more hands-on value
/u/BashCoder had it with, essentially, shells are especially suited to this sort of thing. Use sort -u if you're willing to lose the original ordering. If you're not, then... /u/jrochkind had it with "for each line take the SHA1 checksum of the file" except he means "of the line" instead of "of the file", and really any good checksum function would work, not just SHA1. With n as the number of lines, this can run in O(n) time and O(n) space, so long as we assume a hard constant limit on line length in order to allow the checksum to run in O(1) time.
the dups.each inner loop is bringing you to O(n^2); let Ruby's built-in hash find whether the current line is a duplicate or not so that you do not need to examine every duplicate line. In other words, use dups.include?, not dups.each. Furthermore, it looks like you've intended the token "write_line" and "dup_write_line" to be identical tokens, but they're not; this is probably the source of your bug as written. 
er... not it isn't. that split(' ') had me thrown for a loop (pun intended) and a dups.count within a dups.select is going to get you to O(n^2 ) regardless since count on an array has got to be O(n). Try to get it down to a single loop.
Ah, what I mean is: having both existing message strings/details and also the new Error object at the same time results in duplicated information. To accomplish consistency across three of them will make the code very messy. It would be nice if model.errors.adequate can just become model.errors
I know you were looking for inperson, however my cousin learned ruby enough to get a job, from Treehouse online. https://teamtreehouse.com/
My thought on stubs is that a lot of time they masks so much functionality they aren't as useful. I kind of like how rails gives a full environment with a database for tests.
Becoming an obsolete developer if you don't know JavaScript or lack experience.
Very little. My experience with ruby is that it has an amazing community, an attractive and ever-growing feature-set, and more resources for learning for free than I know what to do with. The only thing that worries me about Ruby is the idea that people give these â€œRuby is deadâ€ claims any merit whatsoever. Every Ruby meet-up I attend has the venue at capacity. People just donâ€™t write a trendy medium articles on it so much anymore because the industry knows full well how good it is.
Concurrency is a given in the top languages, these days. I hope Ruby 3 does indeed remove the GIL, which is being floated, because otherwise Erlang/C#/JS (by way of NodeJS) are just going to eat Ruby's lunch. Anecdotally, I don't use Ruby outside of work. I've gone back to C#, purely because (and I'm talking within my domain of expertise here, webdev) the response times are night-and-day between the two languages. It really is a language built for programmers, but everyone else has started to crib it's ideas.
I am 1, 2, 3 and we'll probably keep using Ruby/Rails because we're a small team of young developers with significant time invested in Ruby and are now pretty productive. That being said, more and more products deeply involve integrating with systems over JSON API and if we were starting today we'd probably pick a front-end framework (react/angular/vue) and deploy node apps when needed. We are starting to implement a front-end framework now and I can imagine that once we're proficient we may slowly switch to just JS. I haven't built a big node app tho, so maybe I'll hate it. IDK. 
Ruby already has good support for concurrency through threads, and removing the GIL won't give us anything new in terms of concurrency.
I'm worried it will-go/has-gone the way of PHP. At my business, our main product is several services split up between PHP/Symfony and Ruby/Rails. In small pockets, PHP is still wonderful. But worldwide it's looked down on as being slow, insecure, unsupported, etc. All a tough mix of fact and fiction. But Ruby picked up a lot of the PHP crowd in the 00s, and while Rails made it new and hot and accessible, people flocked to the platform. Now, they're flocking elsewhere, and Ruby is left with a tighter, more-experienced community, but it's definitely a smaller one. There are ups and downs to that, don't get me wrong. Being able to reach core contributors and get changes made? That's awesome. Knowing that your platform is stable and going to be supported for the next decade? Excellent. But the same is true of PHP, and it gets shit on every day. To be honest, if I hadn't inherited a Ruby app 2 years ago, I probably would have skipped Ruby entirely, and moved over to Go/NodeJS/etc. as 2 years ago people were already calling Ruby as dead/dying. I do not think it's dead/dying. I think it's maturing and stabilizing. In a perfect world, it'll become the next Java/Cobol, which people rely on for decades and praise for "ain't broke, don't fix it." But I really do worry it's becoming the next PHP, which is more "ain't broke, needs a major overhaul anyway..."
I feel like income of new developers is quite small compared to JS and Python. Don't get me wrong - I am junior, Ruby was my first language, but I feel like most of my friends who are starting their carriers are taking python. 
Most of the new devs who in the past would be learning Ruby are instead learning Python. It's a shame that Python ended up winning this war. Ruby really is a much more elegant language, but that's how things go sometimes.
I've been a Ruby programmer for 10 years or so. I strongly suspect "Ruby is dead" because it's not the new hotness any more. Now it's a mature platform with great tooling and a fantastic ecosystem, and as such will continue for a long time. But, also, it's losing out to uglier languages, sadly - it does feel like fewer people are learning it now, as opposed to JS or Python. Languages don't really die, fashion just moves on. PHP is probably dead too, but still runs a vast amount of the web.
Ruby isn't dead, it's stable and has it's place in the industry. 
I am looking for a physical course but won't turn down any additional resources. How long did your cousin use teamtreehouse for before he was able to get a job? 
I contacted a computer science professor who suggested: Introduction to Computer Science I. In your opinion would this be a worth while course or should I pursue something a bit more sharply focused on my end goals?
It depends on what you want to get it out of it. It seems as if it also depends in the person. If you can learn quickly and then get into the job market at grow, Intro to Comp Sci isn't necessary. If you want to create new languages and data structures, if you're really into theory - go the university route.
Thanks I have been looking into trying to figure out how to do this. Not finding much on the chechsum of each line in the text file. But have found stuff on the .dup method on an array. I need to keep the formatting of the text file as it is and just remove the duplicate lines. 
thanks for the simple and helpful video. iâ€™d love to see a follow up video giving a short example of how this immutable object is advantageous the first mutable iteration. basically, a demonstration of one or more of the points you concluded with. you have a very clear and elegant way of explaining things and iâ€™m definitely going through your other videos soon.
And that â€œdifferentâ€ issue is obviously the one they were talking about. You should know thatâ€™s what they meant, even though you are technically correct about the semantics here.
I feel like a cranky old man, but I still like server rendered pages. I'm glad rails is adding features to have realtime sites while still serverside rendered
oh super cool i started to get into ethereum dev, its nice to be able to understand how blockchains work by seeing a ruby example
Performance as a web server. As soon as you have a lot of traffic it becomes pretty expensive to run Ruby. Maybe your service doesnâ€™t involve high request volume and it never becomes an issue, but when it does it sucks that the only solutions are cough up a lot of dough every month, or rewrite the hot code in another language (or the whole thing if splitting it up doesnâ€™t make sense). I like Ruby as a language (a lot actually) but it has some deficiencies. The module system isnâ€™t as robust or flexible as say Pythonâ€™s. I think it was a mistake to expose symbols instead of automatically interning short strings like Python. Having 2 syntaxes for hash literal keys is kind of silly. These are small issues but there are a lot of them. The 2 block syntaxes have different associativity precedences. The GIL prevents true parallelism. Blocks and procs and lambdas, oh my! Itâ€™s a really nice language when you know it but there are a lot of rough edges. Sure itâ€™s not PHP levels of bad because it was designed, but itâ€™s not perfect by any means.
It may be some kind of functional literacy deficiency, but I see no point to continue in debate. You can post a link to some of your public repos with code you are proud of, to see if your opinions are founded on some comprehensive practice or just plain gibberish of a dreamer. 
Hello, I think you may join contest of the most purposeless question of the month ! Strive to spend (waste) time by (not) solving a (virtual) problem ? Bravo. 
How did a discussion about a particular programming language practice turn so sideways? I argued for a particular notation of class methods based on the value of having a visual cue in the method definition. I've got no problem with disagreement, but I don't understand why you're perceiving this to be the "plain gibberish of a dreamer," or that I have a "functional literacy deficiency." Why are you treating me this way?
I'm sorry but when I meet someone who can't see the forest for the trees I find another discussion as quite fruitless. This may be fault and mistake at my side, not arguing against, but that's my perpetual experience. 
Was trying to do this. Isn't writing to the file at all. Still reading about sets. require 'set' lines = Set.new File.open('C:\\utilities\\domainbak.txt', 'w') do |out| File.open('C:\\utilities\\domainduptest.txt', 'r').each_line do |line| if lines.include?(line) out &lt;&lt; line end end end
A bit of 1,2,3. I'm not terrifically worried, it's just not paraded about anymore.
1, 3, and 4 (soon to be 1 and 4). I'm not worried about the future of Ruby because I'm already moving on to Elixir. Ruby was great (for 6 years, in my case) but after being exposed to Elixir / Erlang I've discovered that that's where my preference lies. I'm quite certain that I won't be starting any new projects in Ruby. (Unless a client asks for it and Elixir work is otherwise in short supply). Nothing against Ruby, I'm glad it exists, I'm glad that other languages have cribbed so much from it. But I'm not sentimental about it in the least.
One thing I am currently a bit annoyed is the apparent lack of interest to improve the tooling/ecosystem outside of Rails. Sure there is Roda, Sinatra, Sequel, Dry-*, Trailblazer, Rom, but there some minor issues when trying to tie all of this together. My inexperience with this "alternate ecosystem" sure adds a lot to that.
&gt; some minor issues when trying to tie all of this together Could you elaborate on that? Really interested in your experiences with the alternate ecosystem. (disclaimer: I'm one of the people behind the RailsEventStore ecosystem)
&gt; PHP is probably dead too, but still runs a vast amount of the web. So true. Wordpress runs on PHP and has been [estimated at being 25% of all websites.](https://www.forbes.com/sites/montymunford/2016/12/22/how-wordpress-ate-the-internet-in-2016-and-the-world-in-2017/#98850d0199d9)
&gt; needs a major overhaul I don't think there's any **major** overhaul needed... Ruby was designed, from day one, as a general purpose language. Its core design was never dominated by goals such as "fuzzy `==` to match dodgy web data", or "hacky syntax for shorter command line scripts", or "avoid errors at all costs, even if the result is probably wrong", and so on. The same can be said for most *modern* languages, but ruby was way ahead of its time in this regard; PHP for instance was clearly built primarily for *web* design - and therefore suffers from the legacy of these decisions. The only major *legacy* design decision that ruby suffers from, in my opinion, is the GIL. Which isn't a total deal breaker, and may be "fixed" in v3.
Not a lot. Ruby is still an incredibly pleasant language to work with and the community is vibrant and diverse. Moving forward the big things Ruby lacks are available, just not easily or in the CRuby implementation right now. Concurrency is available in JRuby and anyone who doesn't seriously consider JRuby for production workloads is missing out. There are tools like Celluloid that are mature and available to provide Actor-based concurrency and a few good options for Evented architectures. There are interesting proposals to get CRuby more robust concurrency options, but if that is a must then JRuby is already ready to go. Another market-oriented gap that Ruby suffers from is in relation to Data Science and Machine Learning. Fortunately, that is an area that is also seeing movement. There are ways to build Ruby on top of Python's more mature ecosystem, but there is also the SciRuby and other projects developing the fundamental tooling. And, again, if you use JRuby you have access to anything that is available for the JVM as long as it provides Java interoperability. So, I don't see a lot of things that make me worried about Ruby. It is no longer a trendy choice. But, that is probably a good thing since trends change quickly and not always in ways that are actually good in the long-term. Ruby is now a more conservative choice for certain kinds of work since the tool space is relatively mature and advancing in a more methodical manner. My Background: I've been using Ruby since 2006 and came to it from a PHP and Perl. I picked up Rails for the first time in 2007 and both Ruby and Rails have been at the center of my career since that time.
Isn't wasting time solving virtual problems like.... the whole joy of programming?
&gt; major overhaul This wasn't a dig at Ruby. I was referring mostly to the PHP lifecycle where they skipped from 5.6 to 7.0 and broke compatibility with the a huge chunk of the existing ecosystem. I'm not seeing quite a huge overhaul/breaking-change happening to Ruby in the immediate future. But who knows what 2020 will bring.
&gt; breaking-change happening to Ruby Matz has talked about this *countless* times, and always says the same thing: He's highly opposed to making a major breaking change akin to Python v2-v3, or PHP v5-v7.
While I imagine this is somewhat contentious, I'd say that compilers have improved to the point where lacking types isn't really an advantage anymore. I am unaware of any new language in development that is dynamically typed, [Crystal](https://crystal-lang.org/) as a particularly poignant example. These days I'm spending a lot of time in Kotlin (recreational), and I find it a joy to work with.
This is where I'm at too. All of our new projects are spinning up in Elixir. We all still love Ruby, but we're loving Elixir/OTP more.
I think mainly it's that so many things are overwhelmingly geared towards supporting or teaching rails based stuff, that it's hard to get a solid up and running outside of Rails. There aren't as many exemplary projects, so it's hard to gain confidence. 
Curious if there is any language even close to elegancy of ruby(?) 
I was rather worried that we spend time and have yet another Stack based JIT, turns out YARV is a stepping stone to Final MJIT. If anything, the history of JIT in recent 20 years should have concluded that Register VM is the way to go. 
I am always wondered and asked, it this actually a problem that is slowing the development of Ruby? Compared to other languages where many are participating in English Forum, Ruby, which is not on Github, and its development has less presence. 
The thoughtfulness and self-awareness of a lot of these answers is one of the reasons the Ruby community attracts a lot of people, and will continue to do so. A lot of the best people I've met in the programing industry have spent years of their lives in Ruby, at one point or another, and it shows. Ruby ain't going anywhere any time soon, fwiw. It's not the new hotness anymore, but if JS on the server is the new hotness, I'll hold off for a while longer, as it still feels like the Wild West over there.
Why would json apis be a problem? Ruby/RoR makes it pretty easy
Here's the thing: you shouldn't let the sunk cost fallacy sway your choice of technology. Of there were a better platform for you to be doing your work in, you shouldn't let your "significant time investment" in Ruby stop you from moving on. Im not saying you, specifically, should be using something else. But propping up a dead guy and slapping some sunglasses on him for the sake of "legacy" isn't keeping the language alive. 
this looks like it could be really promising. Did your cousin start with prior experience or was this able to help him from having no Ruby knowledge? 
https://www.edx.org/course?search_query=ruby
1. Most of my work involves a lot of data manipulation and task/workflow orchestration. In that area, the Python libraries are just way ahead of Ruby. I am worried Ruby will fade more and more as it falls behind in the data manipulation area. 
I'm not saying the JS ecosystem is "better technology" and thats why I see no reason to to move on from ruby/rails. I'm just saying it would be optimal to live in 1 ecosystem rather than 2.
Oh, I agree. Sorry if I seemed like I was butting in where I don't know all the facts. I meant to speak more generally about the sunk cost fallacy as it pertains to a lot of developers and dev shops. I see it all the time, and I just thought your comment was a good jumping off point for a mini rant. 
Yeah it's not working with json apis that is a problem, its that in some cases we may be able to do away with a server side technology because the app could be just a front-end talking to a service like salesforce. In some cases we could build much of the admin into salesforce and just have a SPA sitting on s3. Obviously that is not always the case, but there are other places where we could probably get away with a few lambda functions rather than a whole ruby/rails app. I love ruby and rails, I just think if our small team was starting over we would have chosen JS because we're starting to do more and more JS anyway and it could be optimal to be in 1 ecosystem. Could be wrong
Oh and I do mean starting over TODAY. Prob wouldnt have chosen to go with just JS a few years ago
Haha no worries. Rants welcome
i know i can rails console and type in def mymethod ..stuff end and it works, but i dont want to have to def the method every time i run this project... i dont know if im not wording my question correctly r what. the obj is to be able to rails console and start typing the commands im defining .... 
do teamtreehouse, take the tracks, pay the 25$ per month or buy a year (more than enough), finish all tracks (e.g. fullstack, ruby, front end) and start building stuff you want to build. get help via whatever channel is at your disposal (SO / reddit / friends / slack groups). No time to waste. (this is what I did)
here's my current list of resources you could use: tech-craftsmanship.zeef.com
Thank you, I'll start immediately. 
&gt; React [...] pulls in v8 It *runs* on v8, if Chrome's the browser. Do you mean something else? 
Okay, so this is wrong in a bunch of ways. You need to think through what you are trying to do, and how. However, if you are willing to have all the lines in RAM, I'd read them all into an array and "uniq!" then, as you originally suggested. Why don't you want to do it that way? The checksum technique may or may not save all that much RAM anyway. But this is just wrong even before you get there. 
was able to accomplish what I needed by IO.write('C:\\utilities\\domains.txt', IO.readlines('C:\\utilities\\domains.txt').uniq.join(""))
 IO.write('C:\\utilities\\domains.txt', IO.readlines('C:\\utilities\\domains.txt').uniq.join("")) seems to do the trick. 
Ruby has a GitHub mirror (https://github.com/ruby/ruby), so you can definitely see it there. The development doesn't occur *on* GitHub. There has definitely been some debate about that - the current Ruby dev setup is older than GitHub, and it's a bit of old timers versus newer contributors, honestly. But I suspect it doesn't make a huge difference in speed, overall. And GitHub definitely picks up some contributions as well.
railstutorial.org/book is a good start btw for free :) Will you keep me updated with your progress?
&gt; I am unaware of any new language in development that is dynamically typed JavaScript is not new but is being developed/improved and it's dynamic. I'm not sure if Elixir is growing (still behind the top-50 in Tiobe, so hard to measure), but it's a dynamic language too and some people like it. Clojure is quite strong in certain circles too.
yup. 
I should have expanded upon that statement, the additional being "augmented with a type system". Ruby -&gt; Crystal, JavaScript -&gt; Typescript / Flow, Clojure -&gt; Typed Clojure, Elixir also has typespecs.
Crystal, but in a good way ;)
Hi, 1- fully hobbiest... i code at work c# and a dynamic language at home just for stupid programs\fun. honestly, and i'm sorry because i do like ruby over all other dynamic languages ( well i had an affair with perl in the 00's), i do think it's dying in the sense Perl is dying (sorry perl fellows). The new kids on the block are go (from google... which i tend to avoid whenever i can nowdays) to python or js. There won't be enough new kids to keep the language "fulfilled" within 5 years. I do check Tiobe regurarly because i'm a fool but the better approach for me is this: https://www.nostarch.com/upcoming.htm -- there is go, there is python there is no ruby. Which ruby book was launched last year ? ( the site was a pointer, what i mean is, what new books are there ? ). Another pointer is the new tutorials on the subject, i do like rubyflow.com and it's enough! But for instance the absence of railcasts must mean something... no ? Sadly, when ruby was at the top if people looked beyond Rails, i do think ruby would top python right now. Hell, even i've playing more with python lately just because... because i love monty python eheh and everyone uses it more than ruby and perl. The literature is for python for the new trending things... Now, one thing that 'annoys' ( people are free) me about ruby is that some blogs about the language itself being in japanese. I mean, to read the language code you 'can think' in english, to read the opinion of the founder you have to learn japanese. I doesn't makes sense to me. These is of course not a problem, just a "i don't get it". my 0.2 cents 
I wonder why python is still as popular as ever (?), but ruby not? 
What do you think, in your observations, leads to Python "winning the war", why do new devs choose python instead of ruby?
It seriously doesn't make sense to you that some programmers are Japanese and they are the ones who wrote ruby? What about this is confusing to you?
Yes most certainly, you're my new mentor as far as reddit is concerned. I don't yet know the relationship between ruby and ruby on rails but I'll assume you know you're business in referring the above link. 
I feel like the reason python is so popular recently(this is strictly from my point of view as someone trying to learn) is because it's advertised heavily in the netsec/pentesting world and that seems to be the most attractive facet of the computer industry. 
Ruby isn't dead, not at all. Don't feel like calculating numbers, but just from my memory the #ruby channel on Freenode had above 1k people in it a few years back, but is down to 760-ish now. It is much quieter in there than 3 years ago. The tooling is mostly fine. I'm lacking a classic debugger (Real breakpoints etc.), but that is mostly covered by `binding.pry`. Apart from that, boy was it refreshing after coming from C++ that to add a depenency, all I had to do is dropping a line in the Gemfile. Another trend I see is to doing more data analysis, at which Ruby was never really good at by itself. Math-oriented people always seemed to prefer Python for that stuff. No idea, but not my area of expertise. This seems to be one big area though where Ruby "is missing out". Let's talk about hype. The hypetrain is long gone. And you know what? This is actually a good thing. Those who only stick to the train don't really learn the intrinsic ins and outs, they cover their bases and move on. And last, there are of course the "new languages" emerging. Many people switched over. And this actually makes perfect sense: Choosing a language shouldn't be a popularity contest, but what (in your context and scenario) makes the most sense. And truth is, for some things Ruby was pretty good, but other options are simply better! * **Go**. Everyone knows of it by now, it seems to be especially popular for web development focusing on micro services. I never got why a system programming language (Go claims to be one, I never much tried it so can't comment) is so popular for web development. I guess it's mostly its take at concurrency (Go routines, channels aka CSP). Backed by Google which helps to gain favors from the "Google is the best thing ever" crowd. **Better than Ruby** in the regard that it has a modern answer to concurrency and has real parallelism. * **Rust**. Automatic memory management without a runtime garbage collector. Pretty cool, though makes it harder to use for the developer. On the upside, this annoyance is used for good in their concurrency model. Backed by Mozilla. **Better than Ruby** in the regard that it's type and memory safe, potentionally faster than C. * **Elixir**. Always felt like this mainly appeased to the Rails faction. That Elixir and the Phoenix framework is developed by Rails core maintainers helps here. **Better than Ruby** in that OTPs whole foundation relies on robustness and many-machine concurrency. * **Crystal**. This is where I currently am. It's the result of an "what if Ruby was compiled" experiment. As such, it features things like union types (Which sets it apart from other languages easily). It solves the *One Billion Dollar NULL issue* simply through its type system. Packed with a powerful macro system to allow for the interesting parts of Rubys metaprogramming patterns (Ran at compile time), many Ruby programmers should feel at home. **Better than Ruby** in that it's magnitudes faster and the *language design* feels more mature. 
Interestingly, my similar-to-your-response would have been related to data science becoming such a valuable skill in business. In general, businesses understand how to make web stuff work, which is an area Ruby slays. But leveraging data is something many businesses are still trying to figure out, so it's a valuable skill. I didn't realize that .py was big in pentesting, and in fact have recently been admiring: "it's neat that metasploit is written in ruby."
&gt; i know i can rails console and type in def mymethod ..stuff end and it works, but i dont want to have to def the method every time i run this project In [my `.irbrc`](https://github.com/sshaw/dotfiles/blob/master/irbrc) I look for [an `.irbrc` in the current directory](https://github.com/sshaw/dotfiles/blob/master/irbrc#L114) and load that. In this "local irb file" I have stuff like the following: ``` Here = Some::Long::Namespace::Here # When I need a user to test with def sshaw @sshaw ||= User.find_by(:username =&gt; "sshaw") end ``` Hope that helps. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sshaw/dotfiles/.../**irbrc** (master â†’ d8b9f04)](https://github.com/sshaw/dotfiles/blob/d8b9f04d45640e3dbdcbfadcb13efefb087e520d/irbrc) * [sshaw/dotfiles/.../**irbrc#L114** (master â†’ d8b9f04)](https://github.com/sshaw/dotfiles/blob/d8b9f04d45640e3dbdcbfadcb13efefb087e520d/irbrc#L114) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dr7tqnp.)^.
I'll give it a shot! Be back at it soon.
of course it makes... please don't take me wrong: But wouldn't it be better if it was in english so no-japanese people could read it without too much trouble ? Either _you_ want it or not, english is around 99,9% in I.T.
As someone who has and does write both, the Ruby community has the downside of Rails. RoR is obviously amazing for what it is, but that's all people think about when they think about Ruby. Clearly, this isn't all the language has, but the average dev just knows the stigma. Ruby is built for Rails, not the other way around. On the other hand, Python is often taught in CS101 and is the de facto answer when someone asks the internet where to start. It also is more applicable in areas such as machine learning and data science; both of which are becoming more popular every day. I think the shadow of Rails really hurt the potential of Ruby in the earlier days. Now, it's just too late to catch up. 
I actually see this being useful now. I thought it would only be used in method definitions at first, like yield. Then I thought it looked exactly the same as tap... but it's different because the value returned at the end of the block given to yield_self is returned, unlike tap which returns the receiver itself. Nice.
I can't emphasize how much you will hate this in actual practice
Thanks again! Appreciate the help/direction
Type safety is the bees knees. Refactoring in a type safe code base is a simple task, in a dynamic language it can take significantly longer depending on references in the code base. 
Been using Ruby full-time on the backend for 4-5 years. First language I used professionally. Also use TypeScript, Python, and Java professionally now. I am concerned about the slow response to the languageâ€™s longstanding performance, parallelism, and static typing issues/needs. While Ruby 3 has a goal of addressing these, I wonâ€™t really believe it until we have tentative official word of the branches or approaches that will make it into master. In the meantime, alternative languages are drawing heavy inspiration from Ruby and its ecosystem, closing the gaps in developer experience, and offering more and more reasons to switch. I think itâ€™s unfortunate that many of us will feel forced to give up the language and ecosystem we know because it didnâ€™t stay current.
Crystal needs to have a "Rails" moment for it be wildly successful. If you could easily migrate the giant Rails 3 codebase into somthing faster and cheaper then it would be a win-win. 
Not sure if you're looking for an outsider's perspective, but as a Python/Java/JS programmer who has switched to TypeScript over the past year, I can't see something that will give Ruby momentum over the next decade. I would say the same about Python except it has a strong position in data science competing with R. I would love to learn about areas where Ruby is clearly differentiated (other than a general appreciation for its design). 
Thanks for the suggestions! &amp;nbsp; Do you mind expanding a bit on what you mean? Do companies ask Rails questions during job interviews? ğŸ¤” &amp;nbsp; I thought most interview questions were generic algorithm questions. 
Same here. Never got the time to learn JS framework. The problem is that field is move too fast I cannot keep up with it.
This is really cool. What was the biggest technical obstacle you encounted when writing this? What did you learn the most about?
Hi there, is there a reason in your experience that this is a bad approach?
Are you talking response-times compared to a Rails application or Sinatra/Roda/{insert microframework here}?
I've never worked on an application where the IO wasn't heavy enough for threads to be effective, I'm sure they exist, but I'd bet money they're few and far between.
There was never a better moment for Ruby world than now. We have started adopting dry.rb, Trailblazer etc., we started to look outside of Rails ghetto (Hanami, Grape, Rack-App etc.), we have a perspective of getting Truffle Ruby production ready... Of course this chance might be wasted, but the language is far from being settled, let alone dead. It's no longer "hip", that's true. But it's a good thing. We don't need "cool" solutions, we need ones that work, are based on solid foundation and are well-designed. Hip does not provide that.
it's a good start :) (with a long journey ahead)
Of course, I *can* see the forest for the trees. The total impact of either technique for defining class methods is relatively small. If I see code with `class &lt;&lt; self` I tend to accept it outright, even though careful analysis might suggest that `def self.` is a bit more sympathetic to someone reading the code. Modules also tend to be harder to read than classes, too, but we can't help but accept that because modules are useful in many ways that classes are not. The whole discussion is about a fairly small detail.
Thats basically it. One very dumb example is logger formatting, I didnt found a straightforward way to format Rack::CommonLogger (and gems like lograge depends on ActiveSupport). Another minor issue is that aside from `Dir["bla"].each { |f| require f } ` there is no "simple" way to load your files. And there is the very beginner mistake I still make sometimes when defining a nested module without having defined the top level namespace which I think is very counter intuitive. But, like I said on the previous post, all this can be blamed on my inexperience outside Rails world
Out of curiosity, why do you think that? I use both python and ruby (but my ruby is quite better than my python) and difficulty-wise they seem pretty on the same level...
i had to learn python and ruby in during the course of a year and i found python a bit easier to learn. Ive also seen countless blog posts and articles proclaiming the same. like [this](https://readwrite.com/2014/07/08/what-makes-python-easy-to-learn/)
Try it on Heroku https://devcenter.heroku.com/changelog-items/1345
[Opal](http://opalrb.com/) has matured. I hope to never touch raw javascript again.
You should look at [Crystal](https://crystal-lang.org/) with near-C speeds and a better concurrency model.
Ruby is a beautiful, expressive language for skilled programmers, but the syntax is a cryptic mess for beginners (just think about the confusion things like implied hashes can cause in a parameter list). Personally I find python a confining, annoying language to work in, but the stricter, more obvious TIOOWTDI syntax makes it much simpler for beginners to pick up. Ruby is so expressive because it's fantastic for writing DSLs in, that then allow you to express your domain-specific logic elegantly and concisely. That's the exact6 opposite, however, of what you want in an accessible and intuitive scripting app scripting language, where most of the people writing it are not professional programmers, the code should be instantly and intuitively clear, and the typical user doesn't want to spend any time creating (or understanding) any layers of abstraction or complexity to better express their (usually pretty simple) logic requirements.
I still think this is a good language to start learning programming with. You can enjoy the syntax, learn concepts, then just grab js and go. 
I am a full on rubyist, but it would make much more sense for them to support python, at least for right now. They already have python support in their other tooling, including now even SQL Server. I do wish Ruby we're in there as well.
I've seen this posted around the place, but "a request on uservoice.com" is a long way from Microsoft considering it. There are a lot of things I'd rather see Microsoft do.
I'd rather they use perl or ruby, something more Unix like. I am not a fan of python.
Thanks for the explanation. What you described matches what I see. &amp;nbsp; I only experienced with the heavy-algorithm-style interviews. Not my favorite thing in the world. lol &amp;nbsp; I will add this topic to my list. For this type of interviews, I suspect the TL;DR will be "do Leetcode as your life depends on it" and "pretend to be a teammate of the interviewer during the interview". ğŸ˜‚
Iâ€™m curious as to why you see Python as not Unix like? Python is used extensively in the Unix world.
Coming from perl, a lot of the syntax is different. Perhaps just my subjective feeling. You are right though it is used a lot in Linux.
&gt; perl I doubt your sanity :-) but I guess $A$1 does look perl like.
Sorry, I think Python is the right choice here. Perhaps, not the right choice, but you're going to have a hard time convincing me something else is better. Python is already well established in academia as the choice for relatively non-technical people. It's easy to learn. Easy to use. Importantly, Python doesn't have some of the implicit nasties that Ruby does (for example, Python requires parentheses on all function calls). That can make it a bit easier for beginners and novices to read code.
I've wanted to do it many times. You can (and I do) do it anyway of course, you just need to use an extra `begin... end`. I guess you'd consider that questionable too? You're suggesting that rescue should _only_ be used at method level? I can see a certain purity to that, perhaps in the ideally architected codebase one could stick to that. 
Last time I looked at the code in Net::HTTP, I slammed the laptop lid closed before my eyes caught on fire. Whoever wrote it thought that a Java-like approach was a good idea. This gem needs to be rewritten wholesale.
That's good to know. We've found much use of always setting both read and open timeouts as well.
Is there a license reason ruby (and other open-source projects) don't simply incorporate [liburl](https://curl.haxx.se/)?
Native extensions are always painful to maintain and libcurl has a history of crashing Ruby. [Typhoeus](https://github.com/typhoeus/typhoeus) was quite crash-prone back in the day.
It speaks volumes that Ruby has seemingly dozens of gems which reinvent Net::HTTP client functionality. No one who actually uses the API is happy with it. To be kind though, HTTP is a large, complex protocol; creating a simple yet powerful facade on top really is a difficult engineering problem.
So here's a question. My main usage of Net::HTTP at the moment is through another gem for SOAP requests (don't ask - it's a terrible Microsoft product I have to communicate with) and I settled on Savon. Is there an alternative SOAP gem out there I could use that implements one of these better and faster alternatives? I've noticed really slow timeouts sometimes as well and maybe this is why.
I also had a bad experience with Net::HTTP, mostly because of its inconsistent API and messy codebase. I decided that Net::HTTP is just not worth it, for any use case, I don't care that it's bundled in with Ruby. That also crosses out any derivatives of Net::HTTP like HTTPParty and RestClient; it's just not a good idea to build on top of something dirty (for Faraday it's great that you can switch to a different adapter). Typhoeus is definitely nice, the automatic keep-alive that comes with libcurl itself. I also had a good experience using Faraday with the Typhoeus adapter for parallelizing requests. -------- However, the HTTP library that has recently won me over is [HTTP.rb](https://github.com/httprb/http). For me my use case the possibility of streaming requests and responses was the main advantage, as I wanted to use it for file upload/download. HTTP.post("http://example.com/upload", body: io) # raw streaming upload HTTP.post("http://example.com/upload", form: { ... }) # multipart streaming upload response = HTTP.get("http://example.com/file") response.body.each { |chunk| ... } # streaming download Another thing that's excellent is the [timeout support](https://github.com/httprb/http/wiki/Timeouts), which might interest you. In addition to classic per-operation timeouts that are found in our HTTP libraries, it also allows you to specify "*global*" timeouts. This means that instead of limiting the time of a single read system call, you can limit the time for the whole response to be read, regardless of how many read calls was required to retrieve it. With small HTTP calls requests/responses are probably sent/retrieved in single write/read call, but it's nice to not to have to think about how large HTTP calls you'll be making now or in the future. # per-operation timeout HTTP.timeout(write: 2, connect: 5, read: 10).get("http://example.com") # global timeout HTTP.timeout(:global, write: 1, connect: 1, read: 1).get("http://example.com") It also has persistent connections, you just have to explicitly specify that you want to use one: http = HTTP.persistent("http://example.com") # ... http.close # or HTTP.persistent("http://example.com") do |http| # ... end
It's a total eyesore.
We're using Faraday because the middlewares are incredibly important, so the APIs of the specific libraries that handle the HTTP interaction is less important. These priorities will be different for other people :)
no but you can write your own adapter to use these better and faster alternatives. I just finished writing one that did connection pooling unfortunately being private.
&gt; Is there an alternative SOAP gem out there I could use that implements one of these better and faster alternatives? [Savon](https://github.com/savonrb/savon) uses [HTTPI](https://github.com/savonrb/httpi), which allows you to specify the underlying HTTP lib to use. 
A wrapper for a wrapper? I like HTTPClient. Which is not based on net-http, it's independent code. I wish it got a little bit more maintenance, but it's better to me than all the alternatives. https://github.com/nahi/httpclient It is kind of ridiculous that in a language with so much web use, we don't have a good stdlib or consensus third party http client! 
try ```rb array1.zip(array2).map(&amp;:flatten) ```
works perfectly, thank you so much!
no problem!
So I took a step back and started with 'Learn Enough Command Line to Be Dangerous' before I get into the Rails Tutorial. It prompted me to install Oracle VM Virtualbox so that I'd have a terminal to work from but it isn't running on my machine. Is there a simpler terminal you could suggest for Windows?
I would like to hope the "http" gem provides both one of the best Ruby implementations of a complicated protocol while simultaneously providing that simple-yet-powerful facade: https://github.com/httprb/http Timeouts were one of the major pain points mentioned in this post, and the http gem also happens to have one of the most advanced timeout systems available.
Itâ€™s available in a gem. https://github.com/taf2/curb
Back then, there were only about 200 questions. I did all of them twice. I used Python b/c I didn't know much Ruby back then. I'm sure the interviewing game is way harder now. Good luck!
&gt;I wonder why python is still as popular as ever (?), but ruby not? The number one reason is because people have written and maintain C interfaces for science, big data, machine learning and Geospatial libraries. 
The "PHP runs x% of the web" is largely based on Wordpress installs so not really relevant. If you were to say Laravel, Symfony and bespoke PHP apps vastly outnumber Rails, Django etc. I'd take notice but job stats support the assertion.
... and string processing which is actually slower than Ruby.
Yeah, from what I've seen, http's API looks beautiful. As a library author, though.. so many dependencies :/
I think Elixir has levelled off. Shame but there is a lot of competition out there. The PL scene is a lot different from when Ruby hit the big time. Ruby only had Java and PHP to compete with. 
I prefer Clojure spec's approach to "types". It's more like a schema but fits the language beautifully. There's always an elegance in the way Clojure implements features which is why I group it with Ruby even though idiomatic Clojure is anti-oop.
Source? [There are tips.](https://github.com/crystal-lang/crystal-book/blob/master/guides/performance.md)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [crystal-lang/crystal-book/.../**performance.md** (master â†’ fcc0a24)](https://github.com/crystal-lang/crystal-book/blob/fcc0a24f42c2abac9684d6bda7a461912760061a/guides/performance.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drbia9o.)^.
I agree. I think the Ruby dev team are destined to repeat the same mistakes as Perl. The typical response on Perl Monks to the question of Ruby and Python eating Perl's lunch was "who cares about popularity". Consequently Perl is now rarely used for new projects. It's not enough to be a good or a well-designed language. You have to compete with other languages and develop missing features (concurrency, speed) in reasonable time otherwise mindshare moves elsewhere.
What about non-web Ruby applications. The Ruby libs you list are all web-related. This is the problem with Ruby - with a few exceptions it's confined itself to a niche and now there are many more players in that niche taking away mindshare from Ruby.
Clojure is the only language I've come across which surpasses the elegance of Ruby. It has everything. Rich Hickey even turned up at a Ruby conf in 2012 to let the Ruby community know that OOP isn't necessarily the best option (https://www.youtube.com/watch?v=rI8tNMsozo0). 10 out of 10 for chutzpah. 
Ruby, along with Python, featured in some of the coding scenes in Mr. Robot so it must still be fairly hip.
Rescuing at the method level makes it easier to test in my opinion. I can just mock a raise on that error and trigger the rescue. Maybe there are other ways though, in which case I'm open ears.
Do the basic tutorials to familiarizeyourself with the syntax, then get a copy of Russ Olsenâ€™s Eloquent Ruby. Itâ€™s exactly what you are like looking for. Until i found this book, i was coercing Ruby into a bad version of my previously learned languages. 
Ooooh
Your first post looked quite appealing, kind of dubitative about the second oneâ€¦ but what is in in react that you actually use ? Except wrapping your erb views a react piece of code ? am obviously missing the point; but expected a broader react use in the presentation you've made
I think nothing will pick up before we get a dropin replacement for views. React-rails is already outdated and overall not the best approach maybe, but let you render components from the controller. This example keep showing two apps in one, even if within the same rails folder. it doubles up (if not more) the number of files to handle. Sadly it is still the only way to go for the moment, which make using such tools through rails kind of pointless
Let's break it down: * http_parser.rb â€“ Fast HTTP parser, makes sense to use a standalone gem for parsing HTTP responses * http-form_data â€“ Generates multipart and url-encoded requests, also a standalone gem that can be used outside of HTTP.rb (so many HTTP libraries reimplement this functionality internally) * addressable â€“ Complete URL parser, better than the URI standard library which doesn't implement the full URI specification and cannot parse unescaped URLs * http-cookie â€“ Handle HTTP cookies, again makes sense to use a generic library for that For me all of these dependencies are more than justified, I don't think it would make sense for these functionalities to be implemented inside the http gem itself.
&gt; To be kind though, HTTP is a large, complex protocol It's not. It's one of the simplest protocols available. Request-response, that's it.
I do like the HTTP gem, but this is concerning. At least 2 of those have C extensions, which means I have to have the compiler installed. This is not a huge issue, but it does had the requirement for deployment scenarios. Some of these deps could be omitted though. I've rarely had the need to use cookies with the lib, and they still come bundled as a dependency, with its whole subset of dependencies. Still a very powerful API, which AFAIK was inherited from python requests.
Smart! I like this. I'm a macbook person. Tip: ask a windows person.
I think what you're missing is TDD. (Which will only work for new code) watch Uncle Bob's stuff on it.
Wow! Glad Iâ€™m not the only one. Iâ€™ve held CTO, Sr dev, and all different level positions. Have more than a decade experience, but for the life of me, testing is stupid difficult to grasp. I have got a ton better about it lately. The main thing Iâ€™ve learned is each component should have one job. You test that this component does itâ€™s job in a perfect scenario, and it knows what to do in a not so perfect scenario. If you find a bit of code thatâ€™s needing to do more than 1 thing, then it might be time to rethink how the code is written. 
This video helped me https://youtu.be/URSWYvyc42M
Omg. Same! 
I'm a senior-level ruby software engineer. Writing tests has many benefits, but many of them are related to working with a team where everyone is working on the same code base. So if you don't understand the value of tests that might be part of the reason. I would start with rspec because, in my opinion, it has the best benefit/work ratio. There are more philosophies on testing than you can shake a stick at. That said, here are some of the chief benefits that I expect to get from testing: 1. Less chance of random minor bugs, because sometimes you will catch things in testing you might not notice immediately in production. 2. Peace of mind. If you write a test that can only pass if your code satisfies a specific need of your customers/clients then you know you are satisfying your customers/clients in that way. 3. Better interfaces in your code: writing a test is similar to being a client using the API which is your code. If you find it difficult to write a test for your code, maybe you can improve your code by making it easier to write the tests. That will especially help other people who are trying to reuse your code. 4. Tests are the best form of documentation for how your code works. Again, this is helpful if other people need to understand your code and they don't always have immediate access to you. 5. A baseline for knowing you haven't broken existing code with an aggressive change or refactor. Most importantly, if everyone on a team is writing enough tests to have good coverage of the code, you can be reasonably sure you aren't breaking code you know nothing about when you make a change with broad impact. So, the short answer to how to write tests is, write tests that have the benefits that matter to you. I would recommend the following practices to achieve the above: 1. Ensure your tests cover every code path that a) is important to your customers and b) could have a bug in it. If it doesn't satisfy both of those requirements, writing a test will probably not benefit you (at best it will be harmless, at worst, it will cost you lots of time to run it and maintain it). Don't test every little thing unless it is going to cost you money if you don't. That said, be 100% sure that you aren't tricking yourself by writing a test that doesn't actually reach the code you are trying to cover. 2. Try to avoid writing tests that test how your code works. You may need to change that later and you don't want your tests to break because of that. Instead write tests that ensure you are satisfying something your customers want/need. If your code is organized well, you should be able to test something real, even at the lowest levels in your code. If you can't connect the code you wrote to something real, that's a code smell. Try to refactor so you don't need that code. Don't make your tests too specific. Does it matter that your code raises an exception with a message "The friend_id is invalid," or is it enough that it raises a validation exception? Maybe later you'll decide you don't need friend_id at all. 4. Make sure your tests are deterministic. If a test randomly fails, it's usually better to delete it if you don't know how to fix it. If your tests aren't 100% green when nothing is broken, they are going to be more trouble than they are worth. 5. Avoid stubbing when possible. If you are forced to stub in your tests, that is a code smell unless you are testing something that is a true external dependency (like an external API, or something that randomly fails). Instead, strive to have good test data. Good test data is the cornerstone of good tests; when all is said and done, maybe it is the only thing that really matters. My thoughts on some techniques you will encounter: **Test-driven development**: try it out at least a couple times. It is often more trouble than it is worth, but it will train you to know the difference between code that is valuable, and code that isn't. **Red-greening tests**: This is especially useful for writing tests for code you didn't write. It's also super useful if you have any doubt about what code path your test is using. A simple way to structure an rspec test that I have honed over the last 10 years: * Start with a describe block for the class. * Use a let block to instantiate the class, e.g. "let(:widget) { Widget.new(color, properties) }" * Make a describe block for each public method in the class, e.g. "describe 'wind_up' do #..." * Use a subject block that invokes that method call on the class, e.g. "subject { widget.wind_up(direction) } * Within each method-level describe block, make a context block for each situation, e.g. "context 'clockwise'" * Nest these as deep as you need to, e.g. "context 'blue'" inside "context 'clockwise'" for winding a blue widget clockwise. * If you can, only use let blocks to differentiate the contexts, e.g. the 'blue' context just has "let(:color) { 'blue' }" and the 'clockwise' context just has "let(:direction) { 'clockwise' } So, all together: describe Widget do let(:widget) { Widget.new(color, properties) } let(:properties) { {who: 'cares'} } describe 'wind_up' do subject { widget.wind_up(direction) } context 'clockwise' do let(:direction) { 'clockwise' } context 'blue' do let(:color) { 'blue' } it 'energizes the widget' do expect{ subject }.to change{ widget.energized? }.from(false).to(true) end end end end end 
I used to think TDD was crazy, as my first company only had giant integration tests that no one knew how to run or add to. At my newest company I'm fortunate that we have a strong testing culture, and even more fortunate that we have several senior engineers who believe fully in TDD and that's how they develop. The best thing for me was to pair with someone who believes in TDD. The simple fact of having another person there writing the code with me means any liberty or shortcut I'd potentially make on my own is much less likely to happen. It's really an Amazon psychological effect - even if they don't say anything, I'm more likely to do tings the "right" way. So one thing I'd recommend is to find someone with experience in TDD and pair with them. If there's no one with that experience in your office or network, you could consider a consultant. We didn't have a TDD consultant come on but we've had some problems with some really brittle legacy code and with the quality of new code we're putting out on top of it, so we actually were able to get Sandi Metz to come in to teach her OO design course. She is a huge proponent of TDD and while the course wasn't on TDD itself, tests were front and center in the entire course. I'm sure there are courses / consultants that specialize in testing practices. Lastly, I think this is fairly normal honestly. I think the first company you start at out of college can really shape you, and if they don't write tests and still have a business that survives it's going to be hard to justify writing them. Because it seems like extra effort. Doing real TDD and writing lots more tests is having the opposite effect for me though honestly. I feel like it's programming on easy mode. The tests end up serving as a kind of checklist. I just keep making them pass one by one. And at the end of it I've implemented something complicated that I couldn't see in its entirety from the onset. Don't feel bad - just give it a try.
Any reason why you didn't use a block? Just curious :) ConsoleProgress::ETA.start(100) do |eta| puts eta.progress sleep(2) end 
Also, if your app hits an edge case which your component canâ€™t handle, you can add the edge case as a test and then fix the component to handle it. 
Thank you for this detailed answer (not OP). Is there anything that minitest is lacking which would make it difficult to follow this methodology?
My advice (which would be very different if you were a junior programmer, or new to ruby) is to start by writing tests for known bugs. If you discover a bug in production code, write some test setup that reproduces it, set an expectation/assertion that the test will pass, run the test, see that it fails, fix your code, re-run the test, see that it passes. This is similar to TDD red-green refactor cycle, except you're doing it after the fact, instead of as you develop a new feature. The benefits of this approach for your case, I think, are: a) you've fixed the bug!, b) you have at least one test now, which provides clear value against regressions, c) debugging and bugfixing is often easier when you have a test environment that can do the necessary setup and teardown.
You can do the same with minitest, I think it ends up being a tad more verbose. I prefer Rspec, and as for the flame war, I agree a lot with this: http://zverok.github.io/blog/2016-10-09-minitest.html
Thank you, looks like a good read. 
So, you obviously _do_ testing. You just don't write automated tests. But you test things manually. How else do you know if the thing you just did works, or if it broke something else? You exersize the software yourself, manually, to see if the feature you added worked, or the bug you fixed is fixed, and that the rest of the main functionality of the thing still works. Whether in irb, or on the command line, or in a web browser, whatever. In my experience/opinion, the best way to get started testing when you are quite experienced with writing code but not with testing -- is to automate what you're already doing. Whatever you would be doing manually, write an automated test to test it. Will this necessarily get you to the most efficient or maintainable tests? No. But it'll get you started down the road, and the value of those tests will be obvious. 
There are a couple existing "progress bar" gems which will also give you ETA. https://github.com/jfelchner/ruby-progressbar https://github.com/piotrmurach/tty-progressbar#ttyprogressbar-
Aside from making sure a refactoring or new feature didnâ€™t break functionality, I find this approach to edge cases one of the biggest benefits to writing tests. 
Now I'm very curious about 500 star ruby gem with no tests. Cough it up. Testing is not hard at all. - You write a method that does something - You test that method by sending something to it and asserting that you're getting expected result back. That's pretty much it. Then you add your integration and system tests as needed. Tests ensure that my software not a complete shit. And when something goes wrong I can locate and fix bug in no time because I have massive supporting test suite. Also RSpec is shit. It offers nothing I'd need and it runs much much slower. Add some Factory~Girl~Bot and it's takes minutes to run like 100 tests. I tried my hardest to understand why I would want to use RSpec over Minitest. Every time I need to write a test for some open-source project that uses RSpec... it's a pain. `expect(foo).to equal(bar)` is better than `assert_equal foo, bar` I guess.
I have about 600 specs and they run in just under 30sec on my laptop. Don't blame the tools. 
If you do massive setups before assertions you need `context` functionality of RSpec. If you're using factories in your tests then context is almost mandatory. You kinda can do similar stuff in Minitest but it's just not as good. However, it's possible and easy to write small and concise tests in Minitest without all the crud that RSpec forces on you. Too bad that RSpec seems to be a default answer for "what do I use for testing".
We need to define a few things up front. When people say Ruby is dying or dead, what dying or dead actually means is Ruby is not growing. Lot of people left Ruby, even the prominent ones, but there are also lots of new faces, as DHH likes to mention. Languages dont die, especially when they are open sourced. Perl is still not dead, nor PHP. But consider if a languages is slowly moving towards irrelevant, then it is certainly considered dead. In this case Perl is an example, while PHP still has vast majority of the Web programming. In any case, the Job Pool is an easy indication, and no matter how you spin it, the Job Pool for Ruby Rails is definitely shrinking. The problem is Ruby at its 1-2% low level of usage, should really be growing a lot. You dont see large web scale company using it, Python has Google, Dropbox, for example, using it as well as contributing to its development. Ruby doesn't have any of that, and it isn;t trying to get being used for large corporate either. Its whole ecosystem is bond to Rails. Even the Release note of Ruby often mention Rails and nothing else. It seems at the moment Ruby is an Rails languages rather then vice versa. When people say Ruby Rails dont scale, what they really meant was Ruby Rails dont scale cheaply compared to all others. Cookpad does close to 20,000 RPS, Shopify manage 80,000 RPS, and there were once information about China's Railway ticketing system using Rails that does 400,000+ RPS, it was basically the whole China DDOSing the system. So Ruby Rails scales, but at what cost? The Web is largely divided into two camp, one if the pay by user and SaaS model, much like Basecamp which Rails originate from, the other is Ads to user which needs to reach a critical mass before it starts to paid itself. The latter is the one which Ruby Rails is having problem, because scaling to that critical mass requires substantial investment into infrastructure, and its cost structure is not very attractive. DHH used to say Morres law is helping them to grow, but that has no longer be true for recent few years, not to mention the Goal post of sustainable advert or per user revenue on a freemium model is getting larger then the speed of Hardware improvement. For example, Stackoverflow Engineering blog, shows a fully optimize ASP.NET could do 10x more then Ruby at 10x Faster Speed while using 1/10 of Servers. There was a talk sometime ago about Go Vs Ruby, where Ruby was likely 30%+ more productive up front, it was 10x slower, 300% more maintenance work afterwards. To put this simply, the maths and scale of economy doesn't work very well for Ruby And Rails. If you watched the Video, Matz has went from Ruby is fast enough, good enough, to Ruby needs to be faster, Ruby needs concurrency. From Ruby is my languages, to Ruby is communities languages. The closed development circle of Ruby means it has seen much less contribution from outsider compared to Python. When Ruby needs all the help it gets, not having the conversation and development in open and easy to follow doesn't really help. I also dont believe backward compatibility is the most important factor. Ruby has quirks and in some cases far too many choices, and if MJIT is really faster, it should be used as an incentive to move the ecosystem forward. Making breaking changes at the MJIT support level. Taking the chance at changes to fix and improve things. While Matz have said they dont want another Perl 5 / 6 and Python 2 / 3 problem, but i believe this is different. Perl 5 / 6 is literally a completely different languages they might as well call Perl 6 something else. While Python 3 offer changes while giving no immediate benefits to its users. JIT is a very good chance to use as bait and rethink what Ruby in the future should be. The biggest problem often is Ruby as a communities dont see any of these as problem until it is too late. People flock to Go not only because of its performance, but because it can be easily deployed, and deployment isn't something even on Ruby's Roadmap. Ruby on Windows still isn't as easy as any other counterparts. And it is too late to join the Data Science race. I know this may be a little harsh, but it is sad that Ruby doesn't grow bigger, it doesn't need to take over the world, but it should have a slightly larger presence and usage across different domain. Luckily Ruby will always live on in the form of Elixir and Crystal. 
https://travis-ci.org/24pullrequests/24pullrequests/builds/316541737 345 specs running for 1 minute and 15 seconds. This is mostly fault of test factories. But with factories you kinda need RSpec for all the setups. Would be too painful in Minitest. Normally test suite of this size would run under 30 seconds with fixtures and minitest (or even Rspec tbh). Tenderlove made a nice blog post: https://tenderlovemaking.com/2015/01/23/my-experience-with-minitest-and-rspec.html Basically RSpec is a pain to write, but has better feedback. I agree with that. 
I never learned to test in my college program and no one in my companies did it either. I had no idea how to start and had no confidence in what I was doing. https://pragprog.com/book/rspec3/effective-testing-with-rspec-3 This book helped me start and I now test most things I write. 
Maybe you should create a pull request?
We have a terminal UI library that we use at Shopify called [cli-ui](https://github.com/Shopify/cli-ui). It contains a progress bar too: It's also got some framing, color and glyph formatting, interactive prompts, progress spinners, framing, etc. Only development dependencies for testing. Example: CLI::UI::Progress.progress do |bar| 100.times do bar.tick end end
It can be helpful to practice TDD outside of a real codebase. Do a kata such as Conwayâ€™s Game of Life/etc, TDD it for ~45 min, then throw it away and try again. Itâ€™s much easier to get better at reading when youâ€™re not also worrying about a production company problem. Also just so Iâ€™m clear: TDD for me is not writing a line of code unless it makes a test pass. PM me if youâ€™d like to pair sometime.
Before you start, read this to get a better starting point: https://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf 
I think itâ€™s really brave to admit this when there is so much stigma around not testing in the Ruby/Rails community. I originally came from a PHP background where there was not much testing. I now work on a Rails codebase with 100% test coverage. For me, the biggest benefit of automated testing is knowing that I havenâ€™t broken other parts of the system. Things still break but I think about a test suite like turning a screw. Each time I find a bug and write a test for it, Iâ€™m tightening the screw. Thatâ€™s one less bug that can re-appear (assuming Iâ€™ve written the test well). If you ever get the chance to start a codebase from scratch, install a code coverage tool into your CI pipeline. This way you have to maintain 100% code coverage and youâ€™ll be forced to start writing tests. Before long, it will be a habit.
Lol 
I guess the speed of test execution hugely depends on how much third-party integrations in your tests you need. For example, [HexaPDF](https://github.com/gettalong/hexapdf/) uses Minitest and is a library with no dependencies except for Ruby itself. It currently needs about 2.3 seconds for 128 test files with 1845 runs and 29046 assertions (and most of the time it spends in pure Ruby AES/ARC4 encryption/decryption and string filtering). In contrast [kramdown](https://github.com/gettalong/hexapdf/)'s tests greatly depend on external tools like LaTeX, `tidy`, NodeJS, ... So a single execution of `rake test` takes about 72 seconds for 2832 runs and 194857 assertions. Also, with HexaPDF I try to get 100% test coverage (on the library part of HexaPDF, not the CLI part) using simplecov to make sure that at least every code line is touched and doesn't contain any syntactic errors.
I've mostly been using this for long running tasks doing crap like User.find_each do |u| ... I didn't really have a use case for 10.times do kind of thing. Would be easy to add.
Stop creating database records in your test when it's not absolutely necessary. 
My fav are `.start_with? regex` and... wait, did they add `.sqrt` to only Integer, not Float?
People at coding bootcamps learn TDD and yet apparantly people in senior roles do not write tests. This is a company culture problem. If I were to apply somewhere and found out there is no TDD in the process this would be a huge red flag. This is not an attack on you OP, but on the companies that let you get this far without writing tests. It is good you realize this is a problem now and you are taking steps towards becoming a better developer. Someone else already responded comprehensively, but I personally know that I am a much better programmer because of how tests force me to approach objects and methods. I do understand how it is difficult to grasp and I recommend not going to TDD directly. Just start writing tests for your working code. Then write tests for the edge cases. If you start seeing a lot of edge cases it's a good indication to make your methods simpler. After writing tests for some time you will naturally find a fit for TDD. One of the great things about TDD is what Corey Hanes said. It's wish driven development. Start writing a test for a new method with the name of that method you want and what you want that method to return. This is what makes writing clear software so much easier. You will naturally design your interfaces by ease of use and readability.
As an additional approach I tend to avoid using `let`s, and while the tests are less DRY, I personally find them easier to read when I come back to a project months later e.g. ``` RSpec.describe Widget do describe '#wind_up' do context 'clockwise' do context 'blue' do it 'energizes the widget' do widget = Widget.new('blue', {}) widget.wind_up('clockwise') expect(widget.energized?).to be_truthy end end end end end ```
Hey there, author here. Steve Klabnik did a [talk on the same topic](https://www.youtube.com/watch?v=OM4dynVjxUw), but I thought it might be helpful to have an updated version with a side-by-side comparison of the syntax of Ruby and Rust. The list of examples is not exhaustive, but it should give newbies a good overview of a few Rust core concepts.
Nowhere in the article is stated that this gem is made specifically for Rails, but all the configuration is for RoR. Can it be used with Sinatra, for example, or another Ruby web framework? If it's intended to be used only in Rails, isn't this gem going to be somewhat redundant in the near future, when Rails 5.2 is released with ActiveStorage? 
From janko-m/shrinerb &gt; Shrine is a toolkit for file attachments in Ruby applications. 
&gt; The Ruby libs you list are all web-related dry.rb is by no mean web-related. Hanami is, in general, but in includes pieces like `hanami-cli` which are totally non-web, or `hanami-validations`, `hanami-model` which you can easily use in non-web context. For others non-web usages, I'm not sure what you are looking for. Of course, web is over-represented, but it's not only that. I put up a [Rails-free news site](http://rubytuesday.katafrakt.me) some time ago, you can look it up for non-web Ruby examples too.
I agree with you that it is often better to make your tests less DRY. I personally draw the line at shared examples. I found that they take more time to understand than they save, but I could believe that others have made them work. If I could get you to try one thing in the example I gave it would be using the subject block. You really ought to separate your tests into three stages: setup, execution, and verification. Setup is everything that happens before the subject is invoked, execution is the subject, and verification is only expectations. I think it can really clear up your thinking about what your test is doing if you structure it that way. When the boundaries between those stages get blurred, your test has too much responsibility and it stops being clear that it is working as intended. I also encourage you to try using lets in the limited fashion I described. It is really powerful when you make a change to either the class you are testing (setup) or the subject (execution). Suppose we made a change from ".wind_up(direction)" to ".wind_up(direction, clicks)". Ideally, we should be able to change the subject in one place, use a let to set a typical number of clicks at the top level, and have all of our old tests still pass with no changes! This has an important semantic meaning. We're saying, in code, for this typical number of clicks, widgets should behave like they used to. If there is some particular case where that isn't true, that should correspond to an existing context where we only need to add a single let(:clicks) to fix all the broken tests in that context. Similarly, suppose we added a new mandatory attribute to widget, something like "price". Semantically, that shouldn't change the execution or the verification of any of our tests. It should only change the setup, and hopefully only in one place. If the tests are written like your example we might have to fix every test for unrelated concerns. That has a big cost; it's going to make you reticent to make a sweeping change, even if it is the right change to make.
&gt; Nowhere in the article is stated that this gem is made specifically for Rails, but all the configuration is for RoR Shrine is a generic file upload library that doesn't have ties to any Ruby web framework, so the configuration will be the same with any other Ruby web framework. I don't use Rails, so that was particularly important to me. &gt; If it's intended to be used only in Rails, isn't this gem going to be somewhat redundant in the near future, when Rails 5.2 is released with ActiveStorage? Even though Shrine isn't Rails-specific, this is still a valid question, because most people will choose ActiveStorage just because it's bundled with Rails, even though no blog posts have yet been written explaining the advantages of ActiveStorage over other gems. I don't think Shrine will become redundant, as it has a lot of advanced features that aren't yet present in ActiveStorage, and it's is still actively maintained.
I donâ€™t think that `let` is inherently bad but it does make it easier for your tests to grow out of control. It allows you to move the important parts of your test out of your test. It makes it unclear what is really happening and can lead to bloat. By putting your setup inline, you ensure that each test has exactly what is required to work with the test. To aid in this setup I typically use [factory_bot](https://github.com/thoughtbot/factory_bot) for building objects. Since you only have to specify the minimum data for a valid object within the factory definition its clear within the test how any additional data impacts the test.
thanks for your excellent work!
I think one of the times I often want to do it is rescuing the umpteen different sorts of exceptions that can be raised by Net:HTTP, and handle them in an appropriate way (whether that's logging and ignoring, or raising a more standardized exception). I guess I _could_ wrap every Net:HTTP request in a method that did nothing but call what I wanted to call and rescue properly. But it would be inconvenient. Yes, perhaps if Net::HTTP was designed more sanely, it would not be so bad. 
I like your use case of it. I too have had to rescue from a collection of various exceptions because the API (or the wrapper) I'm using is unstable. I'd be more inclined to convince whomever maintains the API (or wrapper) to make it more stable though. 
I'm quite for fond of codingame.com :)
You could take a look at AdventofCode 2017. If you need help with the puzzles there is r/adventofcode.
Fair enough. Counterpoints: let doesn't get invoked for tests that don't use it, (unless you use let!); If you need so many tests that they are growing "out of control" maybe the issue is with the class you are testing, not the testing methodology.
&gt; React-rails is already outdated and overall not the best approach maybe, but lets you render components from the controller. How does react-rails generate the html? Does it have its own view engine, or does it bind into a nodejs process and render the view there? &gt; Running webpack(er), you have two apps (server and client) Isn't the webpack process there only to guarantee asset "live reloading"? I'd be surprised if it did more in the more conventional scenario. 
Steve also did a [tutorial of the same title](http://www.rustforrubyists.com/). And since then worked a lot on the official Rust Docs.
The section on select and filter is wrong an non-idiomatic on the ruby side. The first ruby example: even_numbers = [1, 2, 3, 4, 5].map { |element| element if element.even? } # [ni, 2, nil, 4, nil] even_numbers = even_numbers.compact # [2, 4] is really non-idiomatic. This is where you would use `.select` in ruby: even_numbers = [1, 2, 3, 4, 5].select { |element| element.even? } # [2, 4] It then goes on to say that ruby's select is equivalent to rust's filter_map, but that's not right. Ruby's select does not allow you to modify the elements being iterated over, while the filter_map example does just that. To both modify and select elements from an iterator in ruby, you would need to combine map and select. In fact, you first example of using map in combination with compact is an example of just that, as compact is just shorthand for `.select { |x| !x.nil? }`, or as would idiomatic ruby: `.reject(&amp;:nil?)` (reject being the opposite of select). So the map &amp; compact combination of the first example is close to filter_map Your rust example of finding numeric string and converting them while filtering let maybe_numbers = vec!["1", "2", "nah", "nope", "3"]; let numbers: Vec&lt;_&gt; = maybe_numbers .into_iter() .filter_map(|i| i.parse::&lt;u64&gt;().ok()) .collect(); would in ruby look something like: maybe_numbers = ["1", "2", "nah", "nope", "3"] parsed_numbers = maybe_numbers.map{ |x| Integer(x) rescue nil } # [1, 2, nil, nil, 3] final_numbers = parsed_numbers.compact # [1, 2, 3] 
Try [exercism.io](http://exercism.io), you will receive and can give feedback to others. For a more real-world experience try [agileventures](https://www.agileventures.org) and you will work on charity projects with others developers of the world.
Been a few months since I've been on Codewars but at the time you could most certainly see solutions. The only caveat is forfeiting credit you might receive for solving the problem. 
I encourage you to try to convince whoever maintains Net::HTTP to make it's exception raising API less diverse. :)
For existing projects you can start with writing integration tests. They are high level, mostly full-stack tests, that are similar to what you would do testing your code manually. If you're testing an API that you just wrote, you prepare a request to a given endpoint, with some defined parameters, and compare the result to what you would expect from it. For testing websites, you can simply check if the expected element is being rendered. This would be the first step towards testing, without changing much of your habits. You mentioned seeing everything as a process. I might be wrong, but it sounds like you're writing procedural code. This kind of code is not very intuitive or pleasant to test. You may want to read books on how to write more object oriented or functional code. Rules like dependency injection, pure functions, minimizing side effects makes testing way easier and intuitive. As a general, fundamental rule that you asked for - every method/function should have a result, which should be strictly dependent on the input parameters. This way you can compare the results of your method calls with different parameters. And this, in great simplification, is what tests are.
This might be an unpopular opinion, but don't live your life with [primitive obsession](http://solnic.eu/2012/06/25/get-rid-of-that-code-smell-primitive-obsession.html) (not my blog). If you have a need to do stuff like this, you're likely overlooking a needed object.
I usually recommend ruby for new learners, but I just recommended python to my nephew because he is working with a Raspberry PI. And like you, I would recommend python for excel here too for the same reason, eco-system already has it.
its funny you say this, and I agree with your opinion completely. I was taught c++ in high school. Second job was using pearl to write dynamic html and and this new thing called javascript (aka escape character HELL). Then we moved into the wonderful world of php. My coding skills are based firmly in the primitive! lol I plan to better educate myself in the OOP world and bring my skill set up to date. thanks for the prod in the right direction and for polite and informative comment.
Very happy to help :)
Love your tty gem family / toolkit. Wondering if you're interested in posting an article to the [Ruby Advent Calendar 2017](https://planetruby.github.io/advent2017/)? Let me know - love guest posts and the tty toolkit / gem family. Keep it up. Cheers.
Thank you! I appreciate your offer but will have to decline. I'm trying to get the tty packages up to date with all the things I wish to have and doing other top secret things with Ruby. Very little time and a lot to do. I hope you understand.
No worries. Maybe next year in 2018 :-). Keep it up. Again thanks for the great tty gem family / toolkit. Cheers.
Neat to see a ruby reimplementation of Figlet. Like the spacing options and API
https://projecteuler.net/ has alwasy been my favorite :)
Can you run a linter on that title please?
What's your preferred max line width :-) ?
;)
I guess you want the security net that tests can give to you. BTW, there are no warranties, just feel more confidently about the changes that you are delivering. So, what to do? For legacy code, you should add only integration tests, and only for the happy path (when all goes well, do not test errors yet). But that is a lot!. So, you should apply the [Pareto principle](https://en.wikipedia.org/wiki/Pareto_principle): The 80% of your application usage goes over the 20% of the code, and on the other hand, the other 80% of the code is used the 20% of the times. These integration tests should test each functionality end to end, from the visit of the page, completing a form and receiving the response. If you do it well, you will have a 20% of "code" coverage by tests, and an 80% of "use" coverage by tests. Then, you can move to production knowing that you did not break any of the critical functionalities. And after that, you can start testing the error responses, but do not add all the possibilities, just one for each form (the most frequent perhaps). And the other 20% of app usage, but it is the 80% of your code so you should apply the Pareto principle again (and it works with 90/10 too). For new code, well, you should try to write the integration test of the happy path too, then the app code, tweak and repeat. It's not easy, and the development time is usually the double of the same task without tests. But worth it. Think about this: **If you only add one test to your app, the one for the most used transaction it will be a huge improvement**. 
Can you provide a sample of the URL or the file?
You need to provide more information to give anyone any chance of having any idea. What is the input? What is the xpath? What did you expect to get back instead of an empty array?
Checkout Sandi Metz Great info on what to test and what not to test in her book Pratical Object Oriented Programming in Ruby http://www.poodr.com/ Another commenter has already posted a link to her testing talk. This one is also awesome. https://www.youtube.com/watch?v=v-2yFMzxqwU I am teaching my colleagues Cucumber in my current Senior Developer role. Taking an outside in approach to testing the UI down to testing the objects with Rspec. 
That's a good question. Firing up `irb` we get this: irb(main):001:0&gt; "foo".match(/(.*$)/).to_a == "foo".match(/(^.*)/).to_a =&gt; true irb(main):002:0&gt; "foo".match(/(.*$)/).to_a =&gt; ["foo", "foo"] irb(main):003:0&gt; "foo".match(/(^.*)/).to_a =&gt; ["foo", "foo"] So they do indeed both math the entire `"foo"` string.
As the others suggest, we need to see a sample. But generally speaking, web data changes over time, and having too rigid of an expression will cause issues. Getting an empty array back leads me to believe you simply aren't matching what you think you are. Try to account for the most abstract way to describe the node while still being accurate. A great place to start would be to go into a pry session, load and parse the URL, and then try some expressions out. Specifically try some that have no way of failing. Like `page.xpath('//li')` and start working backwards. What you will likely find is that you get your targeted element back, and now you need to sharpen how you target it. It's also possible that you are coming across pages or variations you don't expect. Try adding a guard clause that checks for that empty array- when you come across it, dump the page to a file `File.write('bad.html', page.to_s)` (I think).
My favorite is https://github.com/JoshCheek/ruby-kickstart Starts very simple and moves onto computer science problems in ruby, all with tests and solutions. Fun, satisfying and addictive. 
Okay, but I wanna know why this happens: &gt;&gt; 'foo'.gsub(/(.*$)/, '!') =&gt; "!!" &gt;&gt; 'foo'.gsub(/(^.*)/, '!') =&gt; "!"
(.*$) matches zero or more of any character. It looks like it is picking up new line characters as your second match group.
It doesnâ€™t (RubyPico, donâ€™t have my laptop with me)
Also, apparently: &gt;&gt; 'foo'.gsub(/.*/, '!') =&gt; "!!" this is so wtf.
Except there's no newline in the string literal `'foo'`.
Heh [47] pry(main)&gt; 'foo'.gsub(/.*/, '-') =&gt; "--" [48] pry(main)&gt; 'foo'.gsub(/.+/, '-') =&gt; "-" 
JavaScript, PCRE (tested in Crystal), and perl all appear to have the same quirk. &gt;"foo".replace(/.*$/g, "!") &lt; "!!" &gt;crystal eval 'pp "foo".gsub(/.*$/, "!")' "foo".gsub(/.*$/, "!") # =&gt; "!!" &gt;perl -e'$_="foo"; $_=~s/.*$/!/g; print; print "\n"' !! Python and sed behave as expected.
What does RubyPico use for regex?
&gt; Make sure your tests are deterministic. If a test randomly fails, it's usually better to delete it if you don't know how to fix it. If your tests aren't 100% green when nothing is broken, they are going to be more trouble than they are worth. How is this is a good idea? It's literally being too lazy to fix a flaky test (and in the process not investigating whether the bug was in the test or in the code being tested). 
This is a rather complicated issue, which is cause by the fact that the expression can have a zero length match. See https://www.regular-expressions.info/zerolength.html Ruby uses the Perl style handling of zero length matches (as does e.g. Javascript), while other languages (e.g. Python) use another solution. Those two solutions are described in the section titled "Advancing After a Zero-Length Regex Match", specifically in the paragraphs starting with "The simplest solution..." and "The other solution..." 
In this specific case: 'foo'.gsub(/.*/, '!') =&gt; '!!' the gsub first matches the entire string, and replaces it with '!'. It is then at the end of the string and tries to do another replacement. Which succeeds, because there is an empty match. So it adds a second '!'. Now, under the perl style regex solution, it notes that it has made an empty match and forbids itself from making another empty match (to avoid an infinite loop). So it finds no more matches and returns '!!'. Note that many people would probably consider the next example not illogical: 'aaa'.gsub(/b*/, 'c') =&gt; "cacacac" The `/b*/` can't find any b's, but matches an empty string before the first a, between each pair of a's, and after the last a. Hence it puts in 4 c's 
That last example was great. Thanks!
Oh, and then if you add non-greedy matching with `.*?`, different regex engines behave differently yet again: Non-greedy, ruby: &gt; 'abcd'.gsub(/.*?/, 'e') =&gt; "eaebecede" Non-greedy, perl: $ perl -e '$x="abcd"; $x =~ s/.*?/e/g; print $x' eeeeeeeee Non-greedy, python: &gt;&gt;&gt; import re &gt;&gt;&gt; re.sub('.*?', 'e', 'abcd') 'eaebecede' Non-greedy, javascript: 'abcd'.replace(/.*?/g, 'e') "eaebecede" 
$ also matches at the end of the string. \z matches only at the end of the string. And there is /m option. Consider irb(main):004:0&gt; "foo".scan(/.+$/) =&gt; ["foo"] irb(main):005:0&gt; "foo\n".scan(/.+$/) =&gt; ["foo"] irb(main):006:0&gt; "foo\nbar".scan(/.+$/) =&gt; ["foo", "bar"] vs. irb(main):007:0&gt; "foo".scan(/.+\z/) =&gt; ["foo"] irb(main):008:0&gt; "foo\n".scan(/.+\z/) =&gt; [] irb(main):009:0&gt; "foo\nbar".scan(/.+\z/) =&gt; ["bar"] vs. irb(main):010:0&gt; "foo".scan(/.+\z/m) =&gt; ["foo"] irb(main):011:0&gt; "foo\n".scan(/.+\z/m) =&gt; ["foo\n"] irb(main):012:0&gt; "foo\nbar".scan(/.+\z/m) =&gt; ["foo\nbar"] :-)
That does not answer the OP's question. The capturing groups are adding no value. The better comparison would have been via #scan. irb(main):013:0&gt; "foo".scan /^.*/ =&gt; ["foo"] irb(main):014:0&gt; "foo".scan /.*$/ =&gt; ["foo", ""] I think this is what OP was asking.
Thanks, this makes sense now. About the anchors, `/^.*/` is OK because the star is greedy - it will always choose the longest possible match - and after it's done, the start-of-line anchor will prevent any subsequent matches. On the other hand, `"foo"` and `""` both appear at the end of `"foo"`, so the end-of-line anchor is satisfied by the subsequent empty match.
No idea, itâ€™s an iPhone app. Donâ€™t know how it works under the hood, could all get transpiled to JavaScript for all I know.
Thanks for your nice comments and interest. Parsing string expressions into an abstract syntax tree did not give me too much difficulty thankfully, but getting the Context class (which keeps track of defined variables and functions) was and still is the most difficult part of the library. For instance, evaluating a string like "f(x) = x**2" acts to define a function f that takes a variable x and returns the square of it. But the evaluation of the function, e.g. "f(4)", needs to be able to locally shadow any existing definitions of the variable x while computing f(4). Furthermore, the Context class needs to be flexible enough to handle a complex case where the variables could be mixed up like "f(x,y) = x + 4*y". In this case if we evaluate "diff(f(2*y,2*x), y)" we should get a derivative of 2 since it is differentiating by the first argument, and only by carefully keeping track of what the function definition arguments are and the arguments currently under evaluation can you approach this problem correctly.
I've created the article in 2014 but done large update on 50% of the content so resubmitting it, it may be useful for someone ;) 
Here are a couple of existing Ruby implementations: https://rubygems.org/gems/figlet https://rubygems.org/gems/ruby_figlet
this is pretty cool, where did you start with ruby?
I would not personally recommend using Cucumber. It's annoying to find step definitions that already exist and you tend to get many duplicates over time. Switching between the feature and step definitions is annoying as well, even with plugins. I would instead train the product owner on writing good user stories. You said they are fairly technical, so it should not be very difficult. We use a Kanban board at work and when we do planning on a new project, we usually write the cards while we are hashing out the features for a new project. You could also do the same on Trello or whatever.
I'm not there yet but interesting nonetheless, thanks for sharing it.
Hey there, thanks for the reply. Here's a snippet that shows one attempted scrape working ok and another -- that follows seemingly the same construct -- isn't working. http://snippi.com/s/kmd6wtx Had never heard of pry before. I'll check that out too. That looks a lot faster than saving .rb files and then running them over and over again -- thanks. 
Duh, sorry. Here's my snippet: http://snippi.com/s/kmd6wtx In the first (away_shots) I'm expecting 30 (as an integer) but it returns an empty array which when I try to .to_i turns into "0". In the second (away_powerplays), I'm doing the same process of finding the xpath (using Chrome Inspect) but am able to get back something instead of an empty array.
well I'm originally from Slovakia where I was PHP developer, so I've started with amateur Ruby around 2009 here, but I needed to move to Prague Czech Republic as there were no Ruby job opportunities in Slovakia. Then when (at that time) one of few Ruby projects in Prague went down I've moved to London UK. So yeah, some people leave their country for family members, some because better life, I moved so I can be with Ruby &lt;3 :D 
&gt; It's annoying to find step definitions that already exist and you tend to get many duplicates over time. Switching between the feature and step definitions is annoying as well, even with plugins. A decent IDE will take care of that. 
Here's the core question you need to ask: "Are my tests considered documentation?". If they are, use Cucumber. If not, don't. The tricky bit is they almost always say they want the tests to act as documentation but in reality they don't.
clearly you didn't notice I'm actually proposing wrappers on wrappers on wrappers on WRAPPERS! 1. Faraday wraps NetHTTP, Typheous, or one of man other adapters 2. Typheous wraps Ethon 3. Ethon wraps libcurl I actually recommend folks use [We::Call](https://github.com/wework/we-call-gem), which wraps Faraday! This all sounds terribly pointless if you consider them to be pointless abstractions, but each layer focuses on a different task. libcurl is doing its job very well, and ethon makes a Ruby DSL for that. Typheous provides async functionality and makes that DSL usable, then Faraday provides a standard interface and adds middlewares (allowing seamless [automatic HTTP caching for example](https://blog.apisyouwonthate.com/speeding-up-apis-apps-smart-toasters-with-http-response-caching-a67becf829c6)), which are absolutely invaluable. We::Call then makes some opinionated decisions on top of all of that to improve performance, provide meta data for monitoring, demands t timeouts to stop wasting time on failed requests, etc. But yeah theres loads of http clients around. Doing more is only bad if you dont know what the more is, or know what the more is and dont want it.
The best usage of Cucumber-style specs I've come across have been on open-source CLIs, such as GitHub's hub: https://github.com/github/hub/blob/master/features/ I've never seen Cucumber on a web project not become a slow and tangled mess.
[My](https://github.com/ruby/ruby/blame/trunk/doc/contributors.rdoc#L606) very first contribution to Ruby Core!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [github/hub/.../**** (master â†’ 55dec7d)](https://github.com/github/hub/blob/55dec7d39266648eaa7a43f68b770833f53cff5f/features/) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
good bot
Thank you JustinCampbell for voting on GitHubPermalinkBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Even some intelligent step file organization will solve this. I worked on a project with thousands of cucumber tests. And yes, when we were still naively adding steps to a common step file, things went poorly. But you group them by feature area and by function. Really its no different than organizing code. That said, switching to RubyMine with cucumber support installed was a significant boost in ease of use.
doh, those are some complicated confusing xpaths. I don't have time to try to debug it right now, but _probably_ the answer is straightforward -- that xpath simply doesn't find anything in the document. Perhaps the live query is returning a slightly different HTML document than the one you've captured and saved as a test document. Heck, if you haven't looked at at it all yet, what's actually being retrieved -- perhaps it's a login screen or a "sorry, you're a bot and we won't let you see this page" message? I'd recommend first actually looking at the HTML you are retrieving live, if you haven't already. That is, looking at `open(@url)` before you pass it to Nokogiri. Then break your xpath into parts, doing just the first selector (for instance `//*[@id=\"my-players-table\"]`) and seeing if you get a match (and trying to look at the HTML source to see why/why not), and then adding on selectors one at a time, at each place seeing if you still get a match. This is how debugging works. :) Byebug or pry may be useful as interactive debuggers, so you can play with things in a live context with a live fetch. Or even just `irb`, paste the line in to fetch the document, then look at what it fetched in irb, then try the xpaths one a time interactively, etc. 
Thanks for your response. Do you use a specific style or format to write good user stories? Do you use the user stories for documentation and for testing with real humans as well? What I liked about cucumber was that it gives you a framework - or more forces you to use a specific style. But yes, I had the experience of duplication as well.
A solid contribution, thanks!
My pleasure! I like to make believe that I'm a hard core open source contributor now.
Cucumber tests are fantastic if done right. Their value really shines 6+ months after you right them, when you've moved into a different functional area. I was a technical QA lead on a large project with 1000s of cucumber tests. It was absolutely amazing how well it worked for us. We had the project manager writing user stories, which we would rewrite into cucumber features, and then enhance with negative tests. It was very easy to take the cucumber features, show them to the product owner and get sign off that that represented how the system should behave. But this requires a fundamental thing: your features and steps do what they say they are doing. Cucumber lets you map a sentence to a unit of code, but nothing enforces that the code does what the sentence says it does. You have to be extremely strict in enforcing that through peer review. ---------------------------------- This isn't what you are asking but: &gt; The automated tests This is a very vague term. Unit tests, feature tests, integration tests, load tests? &gt; are up to interpretation of the developer This is fine for unit tests. This can be ok, for a senior developer that knows the full feature, for feature tests; this probably bad for anything else, IMO. A second developer with a fresh point of view implementing tests at the feature and higher level is preferred. If there are two developers, I'd have each one write the features and implement the steps, based on the project owners draft versions, for the others code. IMO/IME YMMV etc.
Cool, thanks for that context! I'm just starting out with Ruby so I find it interesting to see how others have come into it. 
Sure it would be nice to use it as general doxumentation, feature description and as a test script that we can also pass to our colleagues in sales and operation for verification. One tool to rule them all! Maybe more wishful thinking on my side than reality.
thanks - yeah, that's essentially what I did and was able to finally identify where the path broke. Turned out it was a stray 'tbody' in the path that shouldn't have been there. Working now! Thanks so much for the great advice and help. 
Basically...as rails gets less popular, the people who only adopted Ruby because of rails are no longer using it. Ruby is such a nice language to develop in. All of us rubyists are going to happily produce lots of cool stuff with it, whether it's popular or not
Honest question: why do people use Nokogiri when Oga is around? Nokogiri's requirements take forever to build on my systems and I don't find the interface any better. What am I missing?
The book that got me into Ruby &amp; Ruby on Rails was https://pragprog.com/book/rails5/agile-web-development-with-rails-5 (of course much older version on Rails 2.x, I'm not sure how up to date is this edition). I'm the type of learner that first I want to build something and then figure out how it works, therefore Rails first, then Ruby. But I know lot of developers who prefer Ruby first &gt; then Rails / Sinatra / Hanami. If you are that type of person I would recommend books by Dave Thomas on pragprog.com or Avdi Grimm https://www.rubytapas.com/episode-list/ screencasts. They are paid but every penny worth it ;) 
Cucumber is a major help for long term projects because it's runnable documentation, and can be written at a very high level. Good cucumber scenarios read like user stories, and are written using business language and domain driven design language.
This is what we hope for. Do you have worked with cucumber on long term projects and speak from experiance? It sounds more like a sales pitch. :-) Do you have any recommendations on the approach? Or any pitfalls that we should try to avoid?
Thanks for your answer. We are already 3 years into the project and hope for many years more :). I really hope we can pull it off like this and have a clearer process. I expect cucumber to replace or enhance our capybara feature tests only. Did encounter any performance issue when also including edge cases and negative scenarios to feature tests? I usually try to have them more on a lower level because of that. So you basically wrote the cucumber yourself but from the user story provided from the project manager. Did you work in a SCRUM or Kanban style?Did you write and sign off the scenarios before estimations and working on the feature or afterwards? Do you have some recomandation on the writing style of scenarios? Did reuse a lot of the mappings or did you write them for each scenario individually?
IMO, most uses of OpenStruct are an anti-pattern. Just define a normal wrapper class and attributes and expose the wrapped data as an attribute. &gt; The class will encapsulate the attributes we know exist as well as add some state around those attributes is to introduce a class. If you really want to do this, you can subclass `OpenStruct`, right? Also, what the hell: that site pegged ALL my CPU cores. Is there some cryptocurrency-mining JS in there?
That's why I said "even with plugins". I personally use Vim and vim-cucumber by Tim Pope for this. It makes it easy, but it is still annoying.
spam
&gt; Did encounter any performance issue when also including edge cases and negative scenarios to feature tests? Well, the test suite took over 2 hours to run. You can't get away from that with a real environment test. It was sub ideal, so we used cucumber feature tagging to create a short set for developers to use while developing, and then we'd run the full suite for commits to staging. The tests were as low as they could be done. We did not use cucumber for unit tests, it was only feature and integration level testing. (We had ~5k rspec tests for unit coverage) &gt; Did you work in a SCRUM or Kanban style? SCRUM process that we refined to an extreme level. We had very good grooming and planning practices that I've never been able to repeat since then. &gt; Did you write and sign off the scenarios before estimations and working on the feature or afterwards? User stories would have detailed acceptance criteria, which was a precursor to being considered at planning. After planing we would quickly turn the acceptance criteria into cucumber features, typically check it with the developer and the PO, and then implement any needed steps. We also were pretty good at writing reusable steps, as well as actually tiering steps, where as we might have originally written four steps to test a feature, but once we were just using the feature and didn't need to exercise the variations in subsequent tests, we'd write a new step that wrapped the existing steps. (But this has to be done well so that you don't go brittle) &gt; Did reuse a lot of the mappings or did you write them for each scenario individually? Heavy reuse. You just can't get to thousands of cukes any other way. I'd say we had 4+ steps per cucumber scenario, that'd be ~8k steps. You can't maintain that. Theres a lot of stuff that we just came to via process refinements. And I didn't really write them down. Also this was ~5 years back now, so it's not easy to remember the details too well. If I was going to say one thing, its organize and reuse steps from the start. You also have to control the language of your steps. You can write what is effectively the same thing many ways in a human language. You have to lock it down so that when people go to look if a step exists, they can find it easy enough. Also, steps don't need to have the code. It can be very helpful to let the step call a function defined elsewhere with a specific set of arguments, rather than trying to shoehorn too much variation handing into one step. 
I misspoke. I should have said end of line. You can verify this by adding more lines. You will get additional empty match groups.
We usually do something along the lines of "As a &lt; type of user &gt;, I want/should &lt; some goal &gt; so that &lt; some reason &gt;." and occasionally omit the last part. So something like "As an admin user, I should be able to delete another user's comment so I can remove offensive comments". Then have a file like spec/features/admin_user_manages_comments_spec.rb that has something like: feature "deleting comments" do scenario "as an admin" do # sign in as admin # create post with comment from another user # navigate to post # click on delete # expect that it was deleted end scenario "as a normal user" do # sign in as normal user # create post and comment for another user # navigate to post # expect that no delete link exists end end As far as using the user stories, we only use them in this manner: A user story is created when a project initially gets kicked off or during a daily standup. We will usually get together for an hour to come up with some initial stories, put them on a board under "To do" and then have a daily standup (lasts about 5 minutes) where we give progress on what we have done so far. When someone works on a card, we move it to WIP (Work in Progress). When the work is done, it gets moved to "Complete" where it goes through a peer review process (a pull request is created on GitHub and someone else must review it first). Then when the PR gets merged, it creates an automatic deploy to our staging site. The card is then placed to "Test". That way, during the standup, the stakeholders can see what cards are now available to test (and they can go mess around with it). This may lead to new cards in the coming days. After its been in test for a while, a production deploy is created and the cards are moved to "Production". If it is something pretty small, we will just do a production deploy and if it is something big, we may have to coordinate before doing a production deploy. The card will sit there for a week or so in the "Production" column and then it just gets thrown away. Our stakeholders and developers work in the same building, so visually seeing cards move across the Kanban board is nice. Plus, we get frequent feedback.
I said a decent IDE not an editor and plugins... I use RubyMine. I hit F12 and I go to the definition of a step. I can hit another button and see all the usages of a step.
&gt; Well, the test suite took over 2 hours to run. You can't get away from that with a real environment test Parallelization can help with that.
I implemented cucumber on a previous project and this did significantly slow down our test suite (the tests were driven by Capybara). I believe cucumber could work well if just used for core user journeys (eg. login, checkout etc). However, Iâ€™ve yet to work on a project that got the balance right.
I do the exact same thing in Vim. I'm not trying to get into a "decent IDE" vs Vim argument. My point was that it is annoying, even with the capability to jump to the step right away. Just my preference. You can have your own.
No doubt the way I have used Cucumber in the past could be improved upon. Vim also has plugins that make it easy to jump to a step definition and back, but I still do not personally care for Cucumber. I would rather not use Cucumber unless I have to.
Well, to be fair, as the people using it shrinks, the ecosystem shrinks, and it's harder to produce as much cool stuff. We have definitely all seen the results of this already, with more projects going unmaintained, or projects we'd like to exist not existing. I find the numbers troubling. 
You might want to read this: https://news.ycombinator.com/item?id=7543994 Aslak HellesÃ¸y (creator of Cucumber): &gt; Cucumber is not a testing tool [1], it is a collaboration and analysis tool. &gt; Use it to document (in very broad strokes) the features of your system. &gt; It was never meant to be used as an exhaustive regression testing tool, or to replace unit testing. James Shore (partipated in Fit, predecessor of Cucumber): &gt; I find it interesting, if not surprising, that the Cucumber community is discovering exactly the same issues that we did with Fit: namely, that it encourages brittle integration tests, and that people don't use it for its intended purpose of collobaration. &gt; I've come to believe that these problems are unsolvable. &gt; I worked on and promoted Fit for several years. Eventually, after some deep soul searching, I concluded that Fit (and by extension, Cucumber) is solving the wrong problem. The value of Fit (and Cucumber) comes from discussions with domain experts. The tools encourage a certain amount of rigor, which is good, but you can get that rigor just as easily by discussing concrete examples at a whiteboard. &gt; The actual automation of those examples, which is where Fit and Cucumber focus your attention, has minimal value. In some cases, the tools have negative value. Their tests are fundamentally more complex and less refactorable than ordinary xUnit tests. If you want to automate the examples, you're better off doing it in a programmer tool. &gt; Some people got a lot of value out of Fit, and I'm sure the same is true for Cucumber. They got that value by using it for collaboration and focusing on domain rules rather than end-to-end scenarios. My experience, though, was that the vast majority used it poorly. When a tool is used so badly, so widely, you have to start questioning whether the problem is in the tool itself.
[Nokogiri has 144,279,244 downloads](https://rubygems.org/search?utf8=%E2%9C%93&amp;query=nokogiri) and was [started nine years ago](https://github.com/sparklemotion/nokogiri/releases/tag/REL_1.0.0) while [Oga has 703,541](https://rubygems.org/gems/oga) and [was only started 3 years ago](https://gitlab.com/yorickpeterse/oga/tags/0.1.0). I'm pretty sure it's largely a situation of lack of awareness. I've never heard of oga, thanks for bringing it to attention.
My pleasure. I learned about it on an old Ruby Rogues podcast.
Keep in mind: Consider how likely it is for them to update their page layout to account for a new ad, or to shift some elements around a little bit. Having your xpath hardcoded to that specific of a location will surely cause you problems after a few days (as you found). Try to be more abstract about how you choose your tag -- for example: (I typically prefer css selectors, so that's what's below -- but you get the idea) total_shots_table = @page.css('td&gt;table:contains("Total Shots")') Good luck.
don't do it. 
shoutouts to /r/ignurant for introducing me to ruby
shoutouts to /u/ignurant for introducing me to ruby 
Great write-up! I really enjoyed it and appreciated the language comparisons/examples. Iâ€™m a huge Ruby fan, so itâ€™s fun to see things like this.
&gt; Also, that site pegged ALL my CPU cores. There's some funky JS going on there. using noscript helps
&gt; I extend the Hash class. Sorry, it's fun. Heh. Fun for developer. Not always fun for consumer. &gt; { asd: "asd" }.complies_with? { asd: Integer } &gt; # raises with the message "data value for key 'asd' was of type String, should be of type Integer" Methods that end in `?` should return `true`/`false`. 
Hey so I don't want to be that guy, but I just want to point out that in your invoice example, the model would most likely be created for a specific user you want to invoice (assuming you don't have a singleton implementation) so your class should always have an initialize method that would take your user object. exposing the user attribute set is bad practice. Here's a cleaned up example of how this should look in a production environment. class Invoice &lt; ActiveRecord::Base def intialize(user) @user = user end def process_data extract_address! # .. end def can_delete? user.is_admin? end private def extract_address! self.invoice_address = "#{@user.country}, #{@user.city}" self.save end end invoice = Invoice.(moderator_without_delete_permission) invoice.can_delete? # =&gt; false I think it goes without saying that by exposing the user attribute on your instance, you are opening up your code to all sorts of potential bugs. Personally I agree with your feels regarding functional patterns but thought the OOP version should at least reflect best practices. Nice write up btw! 
Does anyone know if this can be a self-hosted solution or is it only available via SaaS?
Only saas currently, but there will be a self-hosted option in the future. 
Welcome to Ruby! My first advice would be to run Rubocop on your code base prior to each commit and fix all offenses. Rubocop is very opinionated so you might start out thinking that you will customize or disable some cops. I'd advise against that for a while at first. Treat fixing offenses as a challenge. Running on your code base, I see 29 offenses. The hard ones to fix meaningfully are going to be: * Method has too many lines * Assignment Branch Condition size is too high Good luck!
Well, yes, in abstract. But these tests included integration tests between real system components and tests meant to exercise the full system. They weren't unit tests. So I needed our full system running for each test. And this is on-prem, and this predates docker compose. Ha, just looked it up, this predated docker anything. So I would have needed substantial infrastructure to parallelize these tests. If I were clever there are tests that hit certain areas and ignore other areas. They could have been running in parallel. But at that point I'm investing substantial work into my testing infrastructure rather than turning out features.
Agree with the anti pattern! I usually feel uncomfortable when I use them. Would you suggest ripping out attributes from the hash that I would need specifically? Thanks for the heads up! Using a Jekyll temple, Iâ€™ll look into it. 
I believe you are on the right track in thinking that Cucumber would be the right tool to use when a development team, product owner, and customer are all involved. Aslak HellesÃ¸y did say "Cucumber is not a testing tool, it is a collaboration and analysis tool." I would say that the purpose of Cucumber is to drive consensus between developers and customers. The Gherkin steps form the "contract" and the step implementation verify that the contract is being followed. My approach is to use rspec for unit testing and use Cucumber to drive consensus between developers and customers. I try to keep the two separate as the serve two very different purposes.
I would be careful copying code online 100% (looks like you grabbed dot_it directly from StackOverflow here: https://stackoverflow.com/questions/17451487/classic-hash-to-dot-notation-hash) but welcome!
Honestly, the performance meme really needs to die now. Ruby 1.8 was slow. With Ruby 1.9 we got an insanely fast VM second only to the hand-optimized assembly based VM in LuaJIT. The Ruby 2.2+ generational incremental GC is very close to as good as the GC in Go, only missing a little parallelism. If you need more, JRuby already offers full parallelism, plus ~3x performance improvement over Ruby 2.0 thanks to the 2 level JIT and invokedynamic, plus compacting GC which Go doesn't have. TruffleRuby will bring peak JVM performance to Ruby, matching/exceeding Go. In most cases you're lucky to get a 3x performance improvement between a Go app and an MRI Ruby app using a similarly light framework. It's not like you can just re-write your app, plus Rails, in another language and get 100x performance increases. I re-wrote a CPU bound Ruby microservice into Rust and it was only about 5x faster. Deploying a Ruby app using a Docker image with a pre-built bundle is just as easy as deploying a Go app with similar requirements to build an external lib. Mike is selling a commercial product with Faktory, and for better or worse, Go is the hype train at the moment. It'll be hard to come up with a scripting language better than Ruby, but you're right that the legacy of developer ergonmics lives on in Elixir, Crystal, and to a large extent, Rust.
I'd recommend The Cucumber Book for your semi-technical product owner. He should focus on the chapters that give advice on writing effective Gherkin and skim over the technical details. I find the "Ubiquitous Language" concept is one of the most important concepts for the product owner. Next, The RSpec Book is a great book about outside-in, behavior driven development works. It describes how to transition from user stores to Gherkin and where unit testing fits in. Don't be fooled by the title. As Uncle Bob says in the forward: "Youâ€™ve picked up this book thinking it was about RSpec." It is really about behavior-driven development.
What ruby really needs is the DOM bindings in Webassembly. 
Seems like this is solving a real problem. Although, I'm not sure how many customers could benefit from it and would use it.
great article... but it reminds me how much I hate web dev... :(
It's early days, but we have a good set of customers so far.
This article basically equates number of questions on stack overflow with popularity. At best, well, it's not the worst measure someone has used to proclaim Ruby (/Rails) is dying. But there are still tons of issues with it. Let's consider other possible causes for declining stack overflow question frequency (article compares to Python and Javascript): 1. Rails has had a stable API, so a larger percent of potential questions have been answered. During the same timeframe, Python struggled through transitioning between 2 and 3, and the entire javascript world has been turned on its head. 2. Developers who use Ruby/Rails haven't had their knowledge become obsolete. This is a twist on #1, but probably more applicable to devs experienced with these techs instead of ones newer to them (i.e. #1). 3. Ruby/Rails is possibly easier to pick up than Python and/or Javascript. Well again, the JS world has become dramatically more complex (just learn jQuery vs node/webpack/angular/react/etc). As for Python, maybe the lack of existing v3 code caused people to have a more difficult time learning it. Who knows. In short, 1) more existing knowledge (which would mask new interest), 2) less obsoleted knowledge (which masks existing usage), and 3) possibly easier to learn (masking both new and experienced devs).
Wrong kind of rubies, dear spammer.
*truthy / falsey
thank you, much appreciated 
Additionally, I'm pretty sure there's a attribution requirement?
Welcome! While I agree with the other post mentioning that you should not raise in the false-case of a predicate method, I think you could benefit from learning how to create your own exception classes. The problem with how your code currently just raises StandardError with a string is that it's tricky to rescue. Let's say you have another compliance method that is succeeds or raises, `#must_comply_to!`: ``` begin { herp: "derp" }.must_comply_to! { herp: Array } rescue # We can't make good assumptions because we don't know what went wrong # It could be a method-missing error for all we know. end ``` But if your class had a dedicated error class `SchemaMismatch &lt; StandardError` we could ``` begin { herp: "derp" }.must_comply_to! { herp: Array } rescue SchemaMismatch =&gt; e console.log "Sorry, but you passed in a nonsensical hash!" end ```
All the minor improvements mean that Ruby 2.5 is shaping up to be a desirable upgrade. 
Hi thank you for comment &gt; don't want to be that guy You are not :) It's a valid constructive criticism and I admire that. Lot of time comments like yours help me see what I've missed or what I didn't explained in enough details, so thank you. &gt; OOP version should at least reflect best practices You are absolutely right. I'm intentionally presenting really bad OOP examples. But unfortunately I came across these example/s in real life by web-developers who prodded their CV with many years of Programming experience on Senior Ruby developer salaries, so they are not completely out of touch what I want to present here. Last couple of years the OOP programming in general took lot of criticism when compared in functional programming context as it's way to easy to do these mistakes. But developers making those claims never showing alternative how to prevent mistakes like in this code example. I would love to provide examples of correct Object composition to solve this problems in OOP and then compare them to Functional approach but that's a topic way beyond just single article :( Good experienced OOP programmers know how to construct objects so that you never have these problems. **But my point is that it's really really really easy to destroy all that good object effort and create mistakes (as presented in that bad example) when a newcomer in team joins and is not aware of this OOP practices** =&gt; functional way "prevent" much better these things to happen. So that's why I'm not showing a proper way how to do this in OOP :) &gt; class should always have an initialize method Well yes, but even in that example it does. `class Invoice &lt; ActiveRecord::Base` That's a Ruby on Rails model example. Model is inheriting form ActiveRecord::Base that is defining `#new` as a way to initialize via attributes matching the fields in the DB So by doing class Invoice &lt; ActiveRecord::Base def initialize(user) @user = user end # ... You are overriding expected method behavior, violating [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle) (one of core SO*L*ID OOP principles) so that's not a good object practice either if we really talking good object practices then the example could be a composed objects like: class ExtractUserDataToInvoice attr_reader :invoice def initialize(invoice) @invoice = invoice end def call(user) extract_address(user) # ... invoice.save! end private def extract_address(user) invoice.invoice_address = "#{user.country}, #{user.city}" end end class User &lt; ActiveRecord::Base def is_admin? # some value ind DB end end class Invoice &lt; ActiveRecord::Base def policy @policy ||= InvoicePolicy.new(self) end end class InvoicePolicy attr_reader :invoice def initialize(invoice) @invoice = invoice end def can_delete?(current_user) current_user.is_admin? end end user = User.new(country: "UK", city: "London") # Rails model invoice = Invoice.new ExtractUserDataToInvoice.new(invoice).call(user) invoice.policy.can_delete?(user) &gt; exposing the user attribute set is bad practice in Rails model yes, but in general in OOP and Plain Ruby objects no it's not an issue, e.g.: class FooSearch attr_reader :users attr_accessor :flag1, :flag2 def initialize(users) @users = users end def find if flag1 users.where { ... something with flag1 } elsif flag1 &amp;&amp; flag2 users.where { ... something with flag1 and flag 2 } else users end end end in this example attr_accessors serve as setting of flags for search class. You can then hook it up to a controller class UsersController def index @users = FooSearch .new(User.all) .tap { |fs| fs.flag1 = params[:flag1] } .tap { |fs| fs.flag2 = params[:flag2] } .find end end so attr_accessors serve as modifier for filters. It's much better than creating class whit too many values in initialize method. &gt; Nice write up btw! Thank you ! ^_^
**Liskov substitution principle** Substitutability is a principle in object-oriented programming stating that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e. an object of type T may be substituted with any object of a subtype S) without altering any of the desirable properties of T (correctness, task performed, etc.). More formally, the Liskov substitution principle (LSP) is a particular definition of a subtyping relation, called (strong) behavioral subtyping, that was initially introduced by Barbara Liskov in a 1987 conference keynote address titled Data abstraction and hierarchy. It is a semantic rather than merely syntactic relation because it intends to guarantee semantic interoperability of types in a hierarchy, object types in particular. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Good job! Thanks for the hard work!
Does anyone know if this conference is run in French?
Whew! 29! Sounds like 3 lifetimes sentence. I'll try that, thanks!
Ok, will rework that. I heard that some of the methods (either on rails or ruby standard library) have one version with or without the ?, and one of them raises and the other does not. Do you know about this?
Oh wow! Thank you! It's awesome to see dry-web-roda getting the attention. Hopefully, this will get more people to use dry-rb gems
Thanks for your comment, here's a few questions: 1) Is `rescue` the ruby equivalent of `catch` like in js? 2) Is the `!` is a convention in ruby for some type of methods? I'll probably do my own exception now.
thanks!
&gt; The class will encapsulate the attributes we know exist That's the key, right there. I'd prefer to be more explicit at the cost of verbosity. You could go ahead and define a getter method for each key of the source hash, or if you still wanted to be a bit clever you could use metaprogramming to build up the methods. Then at least you have mental breadcrumbs â€“ as soon as you open the file you know what it defines, and you don't have to worry about fat-fingering a bad field name that returns `nil` and you can't figure out why. class Change SOURCE_KEYS = [:stages, :whatever, :other, :keys, :here] SOURCE_KEYS.each do |key| define_method(key) do @source[key] end end def initialize(hash) @source = hash end end
The conference is in english, as you can see almost all the speakers are non french-native
Hey, if you want to use a 'ruby' tag/category consistently to separate out ruby-related stuff, I'll add the feed for it to http://rubyland.news. 
Thanks!
That's neat. But how would you deal with 3rd-party assets like ActiveStorage stuff for example: https://github.com/rails/rails/tree/master/activestorage#direct-uploads
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rails/rails/.../**activestorage#direct-uploads** (master â†’ 5232dda)](https://github.com/rails/rails/tree/5232ddad654aad7fc48fb1458c4d776246789409/activestorage#direct-uploads) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drj01w4.)^.
Active Storage is made for the cloud, AFAIK, so it should not be a problem â€” you just link external assets with the usual image_tag. However, we will explore Rails 5.2 further in coming weeks and that probably warrants a separate post. 
As it's stated in the doc, Active Storage can be installed from npm too, so no sprockets required
Ah. Didn't notice npm package. Neat. However there's still bigger problem with /assets that come from other Rails engines. How would you include them without manually digging them out from gem's source code and including them in your app?
That makes a lot of sense. I like the metaprogramming way, seems elegant and ruby-esque. Probably important to keep the array of keys as that's the mental breadcrumb. 
rescue is a catch, yes :) It can come in a method definition: def x herp rescue derp end or in a begin/end block. The bang doesn't have a single convention, but dominant philosphies is that it should signifiy a method that mutates the thing you call it on (`some_string.sub!('x','y')`) or that it will raise errors when unsuccessful (like ActiveRecords' `something.save!`
That's the `!` methods, like `my_model.save!`
It looks like http://rubyconferences.org/ is the most maintained list of Ruby conferences currently. As both projects are opensource/opendata, why not join efforts? I mean, Awesome Events supports more event types, while RubyConferences are more supported by contributors. Therefore, maybe Awesome Events can import conferences list from RubyConferences?
Good point. The idea might be to share the conference.json datafile (that's how the rubyconferences.org works). The Awesome Events pages is "plain" structured text and the json can get (auto-) generated with the eventdb gem / library. Cheers. PS: See the Ruby Advent Calendar 2017 article titled "[eventdb library (and command line tools) - Build Your Own (Ruby Conferences) Whatâ€™s On / Whatâ€™s Up Event Calendar from READMEs in (Structured) Text](https://planetruby.github.io/advent2017/20-eventdb)" on how it works.
so, what ruby really needs is... what? All you say is that it needs to be more popular, basically. 
&gt; 2) Is the ! is a convention in ruby for some type of methods? Here is what Matz had to say about bang methods: &gt; The bang (!) does not mean "destructive" nor lack of it mean non destructive either. The bang sign means "the bang version is more dangerous than its non bang counterpart; handle with care". Since Ruby has a lot of "destructive" methods, if bang signs follow your opinion, every Ruby program would be full of bangs, thus ugly. Of course, different people/teams have different philosophies they have applied as /u/twinklehood mentioned below.
&gt; I heard that some of the methods (either on rails or ruby standard library) have one version with or without the ? There are methods with/without the `!` but not `?`. &gt;... and one of them raises and the other does not. `!` raises. But the convention is if it mutates internal state, e.g., ``` def foo! @x += 1 end ``` then add a `!` to the method.
`unshift` comes from Ruby's Perl influence. It's minor but IMHO needless core method aliases are one of Ruby's downsides. 
While knowing how to create your own exceptions is a good thing, you should also understand Ruby's built-in exception hierarchy. The hierarchy is documented in the Exception class here: https://ruby-doc.org/core-2.4.2/Exception.html In the case of a bad argument, I normally raise an ArgumentError. ```Ruby raise ArgumentError, 'schema should be a hash' ```
I'm betting that rails with become "sprocketless" eventually, and your article is great research on how to have tomorrow today. Good stuff!
Hi Rubyists, I am Arafat, the lead developer of Tensorflow.rb and I have been an active member of this subreddit for quite a long time (I have even talked about this subreddit in my talk). I recently gave my first talk at Euruko 2017 on Tensorflow.rb. I admit I was a very nervous but I did what I could. I am looking for a review or just a general set of recommendations on my talk from all of you. Thanks a lot. 
Organize it with events and take Kafka as a backbone (https://github.com/karafka/karafka). That way you could have independent microservices that would just react.
I bet that too! Thanks!
I was excited by the first article in this series, but am surprised/baffled by where it ended up. Ditching Sprockets and separating the frontend from the backend both seem "modern", but I'd also expect the frontend of a modern app to be built in React/Vue/Angular, not ERB and jQuery.
That's a legitimate concern, and I am sorry if the purpose of this tutorial has, perhaps, not been made clear enough. Not every app needs to be built with a front-end framework. The idea of the series is to have a more logical way to organize the frontend code and serve it with modern build tools such as Webpack (through the Webpacker gem, which is now part of Rails) â€” for _any_ average Rails application that can be build with a set of tools provided by `rails new`. Whether or not use React is an entirely different decision. Webpacker allows you to write and transpile JavaScript with modern ES6 syntax out of the box, as well as orient you code towards a module-based approach, used in Node since a long time, but not present in Sprockets. Having Sprockets AND Webpacker in the same application feels like a temporary solution, and the community will be moving towards "sprocketless" approach, that looks sure enough in the end of 2017. Why not start now? Just to clear some details here: ERB is entirely optional, you can use templating language of your choice for partials. jQuery is not present in the tutorial in any capacity and, in fact, you can achieve everything jQuery does with just plain ES6 JS. Thank you again for reading, and sorry if you are left somewhat dissatisfied. 
&gt; they are useful for someone with no CS background and who needs something recognisable on their CV Possibly they aren't, because in some people's opinions any kind of certificates are a red flag. I'm not saying I think that, just saying that a lot of people do! Certificates are very corporate, and Ruby is not a very corporate community. This is a Japanese website and certificates are more popular in Japan. If you want to support them and have some resources to do so, what about funding to them to go to some conferences, get a guest speaker in like https://www.sandimetz.com/courses/, give them work time to build a protfolio. These things are more appropriate for the Ruby community.
&gt; jQuery is not present in the tutorial in any capacity Oops, right, I meant jQuery-like direct DOM manipulation. And Iâ€™ve enjoyed the series and gotten a lot out of it, even if it was an unexpected mix of pushing the envelope with going old school. 
If the other external systems use "web hooks" -- POST requests -- to trigger events, then it's basically just a web app, right? You could just write a ruby API web app however you like -- sinatra, rails-api, one of the newer fresher ones, whatever. In Rails, I'd probably have a controller for each service, with an action for each web hook you expect to receive. What the action method actually returns as an HTTP response probably doesn't matter (unless the service making the POST request expects an answer, of course). The action method would just trigger whatever behavior you want triggered on the other end -- using the API client for the thing you want to send to, or a local 'service'/wrapper object, or some combination, whatever makes sense for the code and behavior. There are certainly other fancier ways to do this, but this seems like the most straightforward to me, to get started. 
If "old school" is not adopting React, then I totally agree with you. We just tried to describe out-of-the-box options for someone who wants to get the feel of current front-end practices before jumping into a front-end framework (if ever). There are enough well-written "Learn React" tutorials out there.
Yes I speak from experience, a project that's currently going on 12 years, still going strong. The primary value is the collaborative communication: writing what's happening by using the domain language that everyone can understand. This is much the same as any team using any language to write a thorough user story, or functional spec. The secondary value is the archive: many years later it's still easy to understand the business goals and business processes. The language is still the same -- this is is *not* brittle at all -- even as the underlying testing code may change over the years, such as syntax, libraries, etc. The tertiary value is making the tests runnable. I prefer using cucumber at a high level, much more akin to integration tests than to unit tests. Something that's unusual about my use of Cucumber, specifically Gherkin, is that I do not write "Given, When, Then" because I've seen in practice that this interferes with product managers, business owners, and quality assurance teammates. Instead, I use bullet points, and they always have a subject-verb and present tense. Real example: * I create a blog post. * I share the post with my friends. * I can see which friends have read my post. * I can share the post with more friends later on. * I can delete the post any time. * I can edit the message for up to one hour after I post it. 
I suppose it needs more confused devs asking million questions on SO? ;P
Thank you very much for the advice. However, our budget is fairly limited so the most we could stretch to would be a couple of hundred to pay for the exam, plus some time off to study. I have hired a lot of people and personally I think certs are good, even if (like the ISTQB) you would only use a small portion of it in the actual job. It shows that you are at least setting goals for yourself and making an effort to upskill. But then I have also met great testers and devs with almost no formal qualifications :-)
If you give me a reasonable RSS feed, I might add it to rubyland.news. 
I will be using webhooks to listen for changes to the forms being filled out by mobile users, so this is probably where I'll go for that use case. Thanks.
Salesforce allows you to configure webhooks which you can receive when the data is changed inside it. We defined our SOAP endpoints using https://github.com/inossidabile/wash_out that are triggered from the salesforce. For sending data to salesforce we've been using restforce gem. &gt; How would you go about organizing the logic and API Clients in the application Write adapters around the incoming and outgoing data. Test the logic using fake adapters or record the networking interactions with those services:: * https://blog.arkency.com/2014/08/ruby-rails-adapters/ * https://blog.arkency.com/2015/12/in-memory-fake-adapters/ * https://blog.arkency.com/2016/11/rails-and-adapter-objects-different-implementations-in-production-and-tests/ * https://blog.arkency.com/2016/07/testing-soap-api-adapters/ &gt; I've been looking into using a service object approach, but some of the API clients are already singletons. What does it have to do with singletons? I agree with the comment that using domain events and event handlers might be helpful approach, although I don't understand fully what your project tries to accomplish so hard to say.
What would be your ideal RSS feed look like? One idea is a new feed item once a month with a summary of all upcoming conferences, for example. Not sure if a feed where every item is a conference makes sense / is practical. Ideas welcome :-) Note: The Awesome Events page does NOT track when an item (conference) gets added or updated.
Ooh the first time I tried out the webhooks thing, I used [ngrok](https://ngrok.com) to route the responses to my local machine for testing practices. Might help
Yep, once a month or once a week seems about right. If the 'natural' rate of new items would be a lot more than that, then a summary post would make a lot of sense! Good thoughts! 
I may have meant a different thing by 'webhooks' than you. I mean like this pattern implemented by Github API and other APIs, to send you an 'event' when something changes in a cloud platform, via an HTTP request to the URL of your choice. https://developer.github.com/webhooks/
Thanks for the links. This adapter approach looks promising. &gt; What does it have to do with singletons? Some of the research I put into organizing API client logic in Rails recommended creating a Singleton instance of the client for global access. Some of the client libraries I'm using do that out of the box I believe.
I follow (I think). Podio's API has a webhook implementation that I'll be using after creating/posting the form/item to notify the app to grab and persist the form data when it's updated to the other systems.
Thansk for your comments. Will try to add a feed in json (json feed format) in the next weeks. The idea is to (re)use the [/rubyconf.json](https://github.com/planetruby/rubyconf.json) repo. You're invited to ping me or the repo (open a ticket or something) as a reminder if you don't see any progress in January. Happy new year. Prosit 2018! Cheers. 
Likewise, please ping me if you get anywhere and want me to add it to rubyland.news! 
Very cool. The dry-rb project is full of awesome stuff
I had this exact problem recently. You need to put your executable 'smokestack' under an 'exe' directory instead of bin. Or change your bindir value in the gemspec file.
Thanks for the reply. I placed `bin/smokestack` into `exe/smokestack` and I receive this error when running `rake build` rake aborted! WARNING: See http://guides.rubygems.org/specification-reference/ for help ERROR: While executing gem ... (Gem::InvalidSpecificationException) ["bin/smokestack"] are not files Tasks: TOP =&gt; build (See full trace by running task with --trace) So I tried changing my `.gemspec` `bindir` to `bin` instead, along with my `executables` and no luck. This goes against convention anyways according to [this bundler article](http://bundler.io/blog/2015/03/20/moving-bins-to-exe.html). I literally just ran `mv bin/smokestack exe/smokestack` so it's possible I missed something else.
Agreed. This is one of the first things that I flip when setting up a new application. There was another developer I was working with that questioned the religious nature of using localizations for everything possible... until we had a client that vacillated on what terminology to use for a concept 3 or 4 times. Then the developer started to buy into why people should use localizations even if they aren't supporting multiple languages and to flip this setting on every new project.
`rake install` should find the executable under `exe` according to the gemspec. Hmm. After I moved my executable into `exe` everything worked for me with the default &lt;appname&gt;.gemspec. I'm not sure why it's looking for `bin/smokestack`. It looks like you have something referencing `bin/smokestack`? Look at the trace or grep your project for it, see what comes up I guess.
It seems that Cuba uses `Rack::Request#[]` in [`Cuba#param`](https://github.com/soveran/cuba/blob/f66109654ff1c16ee46060330738a902c7a1a7fc/lib/cuba.rb#L264).
~~Well one part of my error was that it looks at git ls-files to install the gem and I hadn't staged the changes yet. So I got it to successfully install after making the exe directory. But now I'm encountering the original error if it not being able to be executed from the command line. :/~~ It's working now! Thanks for your help! 
i thought that might be the case but was still trying to see if there was another way thanks for double checking :) 
np. glad you got it work. :)
In my experience, using Rails' simple I18n backend for anything more than localizing a gem is a mistake. If you want to ship your app in multiple languages, I'd recommend using something like [gettext_i18n_rails](https://github.com/grosser/gettext_i18n_rails). With gettext, it is immediately obvious what hasn't been translated, avoids the need to come up with arbitrary keys, and allows you to plug into other tools which help make translating easier.
Swagger?
How so? If you use Rails lazy translation lookup there's no "arbitrary keys" and locale files are nicely structured. The only downside is sending those yml files for translation of course. There's still variable interpolation and crazy language pluralizations. I like default i18n backend.
[This article](https://translation.io/blog/gettext-is-better-than-rails-i18n) spells out some more detailed reasons for why gettext is superior. 
Yeah, but... &gt; 1. It's painful to "make up" keys. Need to switch between many files Not an issue with lazy key lookup. See: http://guides.rubyonrails.org/i18n.html#lazy-lookup &gt; 2. Not trivial to search text in code. Trivial if you structure your locale file properly &gt; 3. Difficult coevolution between keys and associated text. Easy if you have it keyed as `t(".header")` instead of `t(:some_header_title_you_will_never_find)` &gt; 4. Difficult to know if all the keys are really used in the application. Yes. It's possible to make a mess if you're not paying attension. `i18n-tasks` gem can help clean up it up. &gt; 5. YAML can contain values that are not translations. That's a good thing. I do want to do proper localization and pluralization in one spot. &gt; 6. GetText is a standard in the Open-Source community. Sure. Also 100% agree about being able to feed source into other apps for translation purposes. I had to do a mapping script for this procedure once. Not that hard, just annoying. &gt; 7. GetText syntax is nice. Don't agree. `flash[:notice] = _('Post successfuly saved')` is way worse than `flash[:notice] = t('.flash_saved')`. I want to have indication of where the translation goes instead of what it is. 
&gt; community will be moving towards "sprocketless" approach, that looks sure enough in the end of 2017 Not until engine situation is resolved. Rails peeps don't have a solution for it yet and whatever solution will come will definitely break all existing libraries. I'm thinking it might be something for Rails 6. End of 2018, maaaaybe?
I'm not the author of that article. Ultimately it is up to you which approach is best, but having tried both approaches, gettext has worked better for me. Without trying both approaches, its hard to convey the differences, and evidently that article didn't do as good a job as it could. Regarding your last point specifically, that all strings have the same scope by default, that's actually one of the things I like most about it. Keep language consistent is one challenge, and usually there isn't a reason why you'd want to translate something differently depending on the context. To give a specific example from my application, which supports English and Japanese, I have the string "Basic Information" in several places. I always want to translate that to be "åŸºæœ¬æƒ…å ±", it's not context sensitive. I use this string in several different places - a title tag, a header for the page, a menu item, but I only need to have one entry in my translation file mapping from "Basic Information" to "åŸºæœ¬æƒ…å ±". On the other hand, the basic backend would encourage you to have a `.title`, `.header`, and `.menu_item_basic_information` (?) key. What's more, if you're using the lazy lookup, and decide to refactor by moving strings from one file to another, or renaming a template, you need to also update the translation file. In my application, I have about 1400 strings I'm translating. In only 8 cases do I need to distinguish the context explicitly. When you're localizing an app, the challenges you face are influenced by the specifics of things like what languages you're supporting, who's doing the translations, how big the app is, and so on. So there isn't a one size fits all solution. But I'd encourage you to give gettext a shot - I was a bit skeptical about it too at first, and only used it at my colleagues insistence, but now I wouldn't go back.
Elixir/Phoenix handles translations only via gettext. So maybe I'll have a chance to use it in the future.
English is not my first tongue, then I searched the meaning to be sure what answer here. I found swagger means: "a very confident and typically arrogant or aggressive gait or manner". OK, I got it. No, I'm not an arrogant or aggressive person (I guess ...). Well, I'm confident but not "very" and not always (usually I double check things before moving forward). In relation to this post or my work, I tried to do the same. I'm a shy person, which is not the opposite of arrogant or aggressive. But, I did need to make an internal process to expose all this. And, yes, it is a sowing up. It started with my personal notes while I was learning how to use these gems and ends in this guide that was too long to be a blog post and too short to be a book (that I'll possibility never end to write). On the other hand, I'm happy with the result. The analytics of the guide passed from 0-3 sessions in a day to around 80 the first day on Reddit. The returning visitor rate (the ones that are really taking advantage of the document) passed from 45% to 20% (yesterday) and I think it should be increased on next days and at the same time, the number of visitors will decrease. So, "Swagger?", I think the answer is not, but this question should be answered by the others, not me. 
I haven't read it, bit the differences between 2.0 and 2.4 are small enough that 97% of what you'll learn there won't be impacted. 
If you're looking for a book on up to date ruby, I'd recommend looking at the Well grounded rubyist which has a new version in early access https://www.manning.com/books/the-well-grounded-rubyist-third-edition . I've read one of the previous ones and liked it. As a tip if you want to get a manning book, follow them on twitter and wait for a discount code, they tend to come along fairly reguarly.
I think it is the best book for explaining advanced features in ruby and I have read 10+ ruby books. Almost all it teaches works the same in ruby 2.4. I highly recommend reading it.
I wouldn't call it an alternative to Rails. It simply allows you to mount a DSL for creating API endpoints when you're using Rack. It can be used in conjunction with Rails, even (which I do for my namesake's project) It's great. It has very little surprises and a low learning curve. It allows you to create very DRY components as well. 
That is not entirely true. You CAN mount it in Rails. You can also use it standalone.
Is that not what I said? I said it can be used with Rack. OP compared it to Rails, so I thought I'd anecdotally mention that it can be used _with_ Rails, too.
Sorry, read too fast. Still, I donâ€™t think any of that disqualifies it from conversations when someoneâ€™s seeking alternatives to vanilla Rails. Itâ€™s a great library, is all.
https://swagger.io/
What's a "vanilla alternative to Rails"? I'm not trying to be combative but trying to understand. There's this common misconception amongst web developers that every framework is comparable to X (in this case Rails); it's such a silly argument because all these frameworks â€” I don't care what language it is or what framework it is â€” don't have the vastness, completeness, and maturity of the RubyGems ecosystem, and it definitely doesn't have the maturity of tooling (bundler, rake) Sure, Ghost allows you to blog, but it sure as hell will never compete with Wordpress. Maybe you're trying to say that if you want to off-load some ActionController-based API-ish routes to Grape, that's a comparable thing, yeah. ActionController is comparable to Grape. ActionController::Metal is too. But to say that Grape is a vanilla alternative to Rails is a disservice to Rails, because Rails is so much more than just ActionController â€” just as any practical and full-featured web framework is so much more than handling HTTP requests and providing responses. Don't get me wrong, I love Grape. I use it in 80% of my projects. I also love Rails but I'm not a Rails developer as much as I am a Ruby developer. But it's really difficult for me to think that the two are comparable in any way.
&gt; especially its ability to exist within an existing Rails app to get the best of both worlds Strictly speaking most Ruby web apps can be mounted inside a Rails app, because all major Ruby web frameworks are built on Rack, so any apps built with those frameworks are actually just Rack apps. Rails apps themselves are also Rack apps, though Rails is too invasive to mount inside another web framework. &gt; Grape-entity is my favorite library for generating JSON responses. I'm actually rather interested in serializer libraries that can be used with *any* web framework or ORM; it doesn't seem that grape-entity is generic. I was very impressed with [Yaks](https://github.com/plexus/yaks), but it seems that [Roar](https://github.com/trailblazer/roar) and [jsonapi-rb](http://jsonapi-rb.org) are also great solutions. &gt; To those familiar with the Ruby web framework ecosystem, can you offer your thoughts on Grape, experience with it, and what makes it better or worse suited for your needs than other frameworks? After using Cuba and Roda for a while now, I realized I find DSLs in general very limiting. In Cuba and Roda routing and handling the request are not separated, and it's all happening on instance-level, so you can use regular Ruby code, .e.g: class App &lt; Roda # this block is call for each incoming request route do |r| r.on "documentation" do r.get "authentication" do # ... end end authenticate! # all routes below will be authenticated r.on "posts" do # ... end end end I really like that flexibility, and I didn't yet find any limitation in that approach. But I have never used Grape professionally, I was just trying it out in a pet project when I was finding which web framework I want to use (as I didn't want to use Rails anymore).
I totally agree, it's a great solution, in the areas where it fits. Particularly with everybody riding the microservices train these days, I feel like Grape as an entity all it's own, (pun intended -- sorry...), deserves a more prominent place at the table than it usually gets. With that said, I've built lots and lots of API's, using Grape each time, and with exactly one exception, Grape has been "bolted on" to an existing application, be it Rails or Sinatra or something else. I don't think that's Grape's fault, I think that's just how most developers think of their API projects -- they're _extensions_ of some other application, and Grape, rather than being a standalone framework, is a great addon gem for making API's.
I thought it was a documentation tool for API's. I really don't know it. But, it seems something interesting and not too hard to learn. Anyway, I documented it with mkdocs because for a step-by-step guide the order is important and readthedocs.org provides the host with some cool features like versioning, automatic building, and a tinny configuration file.
&gt; 97% of what you'll learn there won't be impacted More precisely, I'd say that 97% of ruby 2.0 code will still behave the same way in 2.4. So most - if not all - of the code examples in books will still work. There may also be some subtle ways that you can write *better* code in newer ruby versions, by taking advantage of new additions to the language. But this knowledge is not really fundamental to learning good software design patterns.
The changelog is pretty good. There's not much that has changed, though, really.
That works. 
you have a project called `hehestreamskarma`?
&gt; Maybe you're trying to say that if you want to... Yes. I was trying to say that if someone is looking for a different starting point and doesn't mind combining libraries to get what Rails offers, it's a good option for the things it does. It belongs in a conversation about alternatives to Rails, even if it isn't a complete, self-contained replacement for everything Rails does. You are correct on all points.
well said.
I love eloquent ruby. It is my favorite ruby book and I make sure to reread it once a year
I would strongly recommend investing time in Ruby, even if you never plan to use it outside Rails. Understanding procs, in particular, will peel back the curtain on a great deal of Rails magic. Once you finish Eloquent Ruby, check out Sandy Metz's "Practical Object Oriented Design in Ruby."
Hi! Interested in learning more. What is the project about?
Iâ€™d be interested depending on the project 
It's pretty huge project i have in mind it would forsure get hits and huge potential to make some $$ email me at sega.sosickk@gmail.com for the details 
Itâ€™s a great book, Ruby doesnâ€™t change too much. Iâ€™d say until we hit 3.x that book is still useable 
Definitely. The code is almost 100% still relevant and the principles are still spot on. Itâ€™s one of the best Ruby books youâ€™ll read. Also try â€œPractical Object Oriented Design with Rubyâ€ by Sandi Metz. That one is my absolute favourite. 
Yep, it is a standard's based tool for documenting an API and it has a nice UI tool to consume the api and interact with it. Since you mentioned English was a secondary language, I just wanted to point out that the person starting the thread probably wasn't accusing you of behaving in a manner that showed swagger, but was asking for a swagger doc. I should have expounded a bit. I liked the article and am grateful you published. I'm not at all implying that you needed to augment the article. 
Hey! Just to update you I have been working with Treehouse for the past week and have made a lot of progress. I started with HTML and CSS and have a pretty clear understanding of the two. Next I will move on to Javascript as that seems to be the recommended pathing for the program. Once I understand front end I will begin learning Ruby. I have had your provided Ruby on Rails tab open on my browser this whole time and look forward to having enough context to properly go through it. Thanks again!
Thanks for the clarification. I agree. About the size, in fact, it was reduced removing duplication (of other actions) and several tests. Glad to hear that you liked it. 
I would vote for Ruby Under a Microscope, a fantastic book and one of three must-reads we recommend for our applicants (others are POODR and a Postgres book)
What's the typical situation where you can see benefits from rack deflate? I tried it on two production apps and didn't see much of an improvement in download size or page load performance. Am I missing something here?
Thanks for the update :) do you already have something made that is visible online?
I've been doing everything inside of provided workspaces on Treehouse so no original content yet.
Existing projects, or project ideas?
Something to dive into, project ideas.
Ah. Check out the sidebar on r/learnprogramming
Have a look at [24 Pull Requests](https://24pullrequests.com/) - It's a bit seasonal, but searching for the tag should find projects (A good deal of them Ruby based) which need help :)
At the TruffleRuby project we're looking at implementing Ruby 2.4 features and can provide lots of mentorship to do it. https://github.com/graalvm/truffleruby
That looks really cool, I'd love to help! 
I would say my dad. He was a chemical engineer and created some process improvements that were beyond its time. He engineered a solution for speeding up manufacturing which they were able to fill the orders of a massive demand (which no one else in the world was able to do). He would take me to the plants and let me follow him around when they had some production issues. He would simply glance at all of the pipes as he was walking through and come back to the hotel and draw out the entire design of the plant from memory and overlay his designs to show where they did not meet his design. Needless to say, childhood was not fun in trying to live up to those expectations.
Thats pretty impressive. Thanks for sharing.
I have never met a 10x coder, but when I was a kid, I worked as a railroad contractor (all the live long day)... We had a job that required a LOT of gravel... we had a small dump truck that was rail mounted. We would get a truck to dump a load of rock and we would 'reload' it onto the small truck... handling it twice... then it took 30 min to back the truck up and dump it and come back for another load... it would have taken 6-9 months at that rate to fill the tracks with rock. My uncle showed up and called the hauling company and said bring us a truck every 3 min for the next 12 hours... he started by building a road to where the rock was ultimately going and we were done in half a day instead of 6 months... I had to sign for each truck. When the day started, my signature was as pretty as a 15 yo high school girls... at the end of the day it was barely a squiggle... and it has been that way for the past 30 years... I have been amazed and inspired by that ever since. I have used it in finance, coms, security, everywhere. Sadly, my uncle has severe dementia now, but he was one of the greatest minds I have ever met.
That's brilliant! Mind also sharing an example of you applying this to other field?
I worked with a guy who was unhappy with all available HTTP servers (it was 1996 and the landscape was pretty limited), so he took a vacation and came back with a C++ class that allowed me build a basic server in about 12 lines of code, and an app server in about 20 lines (not counting the app part). By the end of the week, he had it supporting HTTPS also. 2 more lines of code in my servers and HTTPS worked for me too. Same company, different dev... we needed to support SMS messages, and we needed a way to test them that let us control the entire path. So the guy who was building the SMS handler build an all-software SMSC (back when they were all physical appliances). In about 2 weeks, while he was still hitting his dev milestones.
[removed]
Many of the â€œbestâ€ engineers Iâ€™ve known had a talent for rapidly cranking out ingenious code that ended up being unmaintainable. The real 10x engineers embodied discipline and careful craft, inspiring the rest of the team to do their best. Two hands can only carry so much.
Yup! 
so wait... let me make sure I understand this. You had a rail mounted truck that was a pita, so your uncle just created a new road so the arriving trucks could just come dump where you actually needed the gravel instead of you having to use the rail truck? 
The best software developer I ever encountered was a woman I was privileged to work under for three years early on in my career (this was mid-80s). Not only was she fully buzzword-compliant for the day; not only could she write testable, bug-free code at least as fast as anyone else on the team; but she had a knack for looking at control flows and UI flows and seeing all the places where users could do something unexpected/"silly"/"impossible" and come up with ways to prevent or recover from those, *without making the user feel like an idiot.* She'd been writing software since the IBM 704 was new and shiny, and made the transition to minis and PCs/Macs and back without skipping a beat. She made all of us on the team see that writing code *per se,* though obviously important, was rarely the most critical activity of a developer tasked with software for the real world. I remember one time when the (large) company we were working for had high-school kids coming through on a tour and our team got tagged as hosts. During a Q&amp;A session, one kid asked what he should study to "get into computers like you". She answered "communications, sociology, psychology, philosophy, logic, languages, and at least one fine art. Taking a coding class or two wouldn't hurt, either". Thirty years on, that's still the answer I give when kids ask me similar questions. 
This is great! Problem-solving is so much more than writing code; a big part of it, essentially, is about understanding human.
I wouldn't call those folks "the best" by any measure, then. What makes you consider them so? That they could go from red to green quickly? "Ingenious" code isn't usually valuable unless the project is very young or very mature.
okay :)
I published this post a while ago (but not promoted it on Reddit for some reasons): http://zverok.github.io/blog/2017-11-27-call-for-apprentice.html -- it lists some projects and ideas I'd like to mentor. All of them non-Rails.
I loved reading your answer. I think it's vital that people coming up undrstand the importance of a well-rounded education. All those skills are so important in understanding problems, thinking critically, being creative, and working / interfacing with others. My undergrad is in sociology and psychology (with technology courses), and those studies were instrumental in getting me where I am in the technology field today. I'm so thankful for the people and experiences that influenced me to go that route.
I think she initially hired me because I'd read history and theology along the way, and had been in the local classical-music scene for a while, and then joined a crazy startup attempting the impossible, flaming out, and not ashamed to talk about why and how. I should have mentioned that she held an MFA and an MBA (that she'd earned in that order), and was constantly pushing people to expand their horizons. &gt; If you're securely in your comfort zone, You're Doing It Wrong. We can't accomplish anything with people who *choose* to Do It Wrong. She'd have to be in her 80s by now, but I'd work for her or anyone she trained in a heartbeat.
Does the guy in the mirror count ? :D
This library sounds great. How does it compare to something like Prawn? My specific question - can you embed graphics and/or text into an existing PDF document at specified positions?
That's what I conclude as well.
I'm not the hexapdf author (was a guest post by Thomas Leitner). I'd say best to read / browse the hexapdf docs - https://hexapdf.gettalong.org Happy holidays / merry christmas. Cheers.
I think that was OP's point. Also, the quotes around "best" suggest that he meant programmers who were considered "rockstars" or whatever by others or themselves, but who the OP wasn't particularly impressed by.
Yes... the place the rock was being dumped was a 'platform'. Like a plateau in the middle of a huge 3M chemical plant. You could not get the dump trucks up there. He built kind of a short interstate entrance ramp to get up there with the trucks. And that ramp was right there at the plateau instead of a half mile away. Every time I hear the words 'think outside the box', I think of my uncle and that day. He did stuff like that all the time.
It counts if you think so. :) Mind telling us more about him?
Would love to hear much more about her.
That would be my boss. It's crazy if you've ever met one
Care to give a small example of the way he does things? :)
I worked with Samy Kamkar (MySpace Worm) at Fonality for about four years. Heâ€™s beyond anything Iâ€™ve met before or since. Heâ€™s well-known now with his YouTube and lectures at conferences. His skill with PERL is unbelievable. Samy isnâ€™t 10x better than me - he is 1000x better than me and anyone else I know. True genius. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/golang] [The best engineer you ever encountered?](https://www.reddit.com/r/golang/comments/7lwjh9/the_best_engineer_you_ever_encountered/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
**Linus wrote Git in two weeks.** That's what Linus said in an interview, and gives the impression that he must be an incredible genius to achieve that. But I think there must be more to the story; at the very least, he probably had all of the data structures mapped out long before he started coding.
Beautiful, thank you. 
For me, whatâ€™s most valuable about git is itâ€™s architecture and the incredible openness and adaptability of got as a process/approach to code. I am sure that the code has been and will continue to see improvements. But Linus dreamed git into existence and that changed the process for millions of people, including the creation of github. Blows my mind. 
The first commit was only around [1k loc](https://github.com/git/git/commit/e83c5163316f89bfbde7d9ab23ca2e25604af290) definitely could be done in two weeks. I don't think the big achievement was in the data structures or the implementation itself really. But the experienced he gained running a Linux kernel scale project, knowing how his contributors worked and what his pain points were running the project. Come to think of it he probably was among the biggest power users of SCM in the world, so it makes sense he wrote a fantastic replacement. I can't speak for him but he probably did have the design well thought out long before he started coding like ya said though. I personally don't have much idle 'brain' time and end up with my shower-thoughts thinking through the most recent problem in a mental queue containing things I find interesting and want to write software for, or something I don't find interesting but is making my technology life annoying. Maybe he was having some serious shower-thought sessions on the latter :)
Interesting, I worked with a woman years ago who was one of the best and most unsung developers I've ever known. I wouldn't call her a 10x engineer but she wrote hi-quality code quickly. The people on the QA team dreaded working with her because they found it difficult to find bugs in her code and she subsequently made them look bad. I'm not kidding. All that being said, she was very quiet and not much of a people person. She was all business - show up, fix some bugs, add some features, go home. Which is to say, she'd be an asset on any team as a contributor but she'd be an awful team lead or manager. Which is totally OK, I'm mainly pointing that out to illustrate that she wasn't perfect. Still though, she was as good or better than every male developer in the company. What I find rare with the extremely talented set is when someone manages to crank out excellent code quickly and ALSO make everyone else a better engineer. Those "10x with social skills" folks do exist and they are the creme de la creme.
Ha ha, just saw your comment, I call them "10x with social skills" engineers. They are a true rarity. You will find more of the "10x but keep them locked up in a room somewhere" engineers. :)
Git is amazing but it's kind of a usability disaster. Not that Linux GAF about that. :)
I've known a few 10x engineers in my day (I'm an old shit). Let's see, here's a rundown: * Head architect at my first web company - the guy dropped out of Harvard before finishing his undergrad degree. Really cool guy, a total genius but humble and approachable. Allegedly he could count and do arithmetic in hex in his head. * CTO/cofounder at a data analysis company where I worked. This guy would literally walk out the door on a Friday and come back on Monday morning with a fully prototyped product. And by prototype, I mean an MVP missing some documentation and a few unit tests. He was an old school MIT/LISP wizard yet embraced, assessed and absorbed new tools faster than any 23 year old at a startup incubator. I ran across his profile on StackOverflow not too long ago, he had something like 50k in rep points. Also, cool guy. * Another senior developer I worked with years ago, his name was Brian. This guy kicked so much ass that the team coined the phrase "Brian-ized" for any chunk of code he touched, because he would jump in and rewrite (quite well) huge chunks of code at the drop of a hat. People would literally say "Oh what about the xyz library?" And someone would answer, "Oh yeah, it's good, totally Brian-ized now." He was perhaps the friendliest and most supportive 10x engineer I've ever known. I've worked with a few other tech gurus over the years but the above three were the rare ones who were also personable. I lived and worked in Boston and Cambridge for over a decade and collaborated with a lot of Harvard and MIT folks. FWIW, not all of them were geniuses. :) 
People take months to years thinking about something before finally settling on what to do. Doing it is the easy part.
This is great! Thanks a ton for sharing! Couple things I really like about your stories: 1. all three guys are nice and approachable. Kindness and humility are what makes someone a team player. And you can't become a 10x engineer without being a team player first. So I really appreciate you pointed this trait out. 2. I like that you pointed out the CTO could assess and absorb new tools faster than younger engineers. I firmly believe the ability to self-taught and adopt new technologies is one of the most important skills for engineers. And it's not as limited by ages as many people think. It's a learnable skill. The more you are used to learning new stuff, the better of a learner you become. 3. "Oh yeah, it's good, totally Brian-ized now." That's such a great testimony. It really inspires me to become a developer like Brain! &amp;nbsp; Thanks again for sharing!
I run a small team of what could be called 10x engineers. The main quality that allows us to stand out compared to other engineers is our ability to focus on an objective and ignore the irrelevant facts. I find a lot of engineers get trapped in scope creep. They try and understand the full system when they only need to learn the component. They try and fix every little problem instead of just the immediate issue at hand. Quality takes time and iteration. Nothing is perfect first pass. Rome was not built in a day. Once you learn that 
Yeah, some video he also said he couldn't get a license for the tool that he was using at that time (i think bitkeeper or smth?) for the kernel or something, so he just copied it in a angry fit. In the beginning it was a reimplimentation and then it just became more a standalone thing https://lwn.net/Articles/574079/. And also https://www.youtube.com/watch?v=4XpnKHJAok8
An intelligent man finds those kids of solutions. A wise man keeps them secret so they get paid 6 months of pay for a day of work ;)
Took me 45 years to figure that out.
I've worked on very good teams and we've done some massive projects together. There are people I've worked with who are much more prolific than anyone else (in terms of what they touch, what they understand about the systems and what make design decisions about) but they are limited by the fact that they can't possibly do more than the whole team. In my experience a "10x" coder slow the whole team down but does a ton themselves. Only kinda useful in early stage startups when you need to ship or the company dies. Good coders make the whole team faster. If you can boost your coworkers 2x and there are 10 of you then you are better than any one 10x coder. And by the nature of a having a team build the product it wont be an unmaintainable mess that only one person understands. I've worked with great engineers, they could deliver very fast when needed but spent most of their time teaching others and unblocking work. Specifically; I worked with the youngest unix grey beard I've ever seen. (Late 30s at the time?) He was a "systems engineer" not a "Developer" but he knew more about how computers worked than most. He transitioned our development team from CVS to GIT (most of the industry was on Subversion at the time, github was brand new), lead a functional programming class that taught us principals of FP in the language everyone knew (perl was the lingua franca of our company), changed our deploy practices so it was faster, more reliable and more understandable and countless other things. He might have been more valuable than anyone else but not because of his output. You might have guessed, but I think the quote is bullshit.
My programming teacher who was a woman at the University. 
Is there any anecdote you would like to share?
10x people do not exist and I hate to see this crap spread here. I have met people producing value far beyond anyone else on a team and they all have burnt out or had a breakdown. The really good engineers are just good engineers who also know how to work in a group setting or lead that is pretty much it we donâ€™t need to fantasize this 10x crap.
&gt; Good coders make the whole team faster. That is a 10x engineer in my book. I consider transitioning the development team from CVS to GIT an output of the "systems engineer" you described. Unfortunately, in many companies, the definition of an engineer's output is shallow and limited. We tend to focus on things that are more measurable, such as lines of code written, one's speed of shipping features, etc, and neglect many other areas one can have long-lasting impacts, such as mentoring, cleaning up messes, building a safe environment that welcomes everyone to share. &amp;nbsp; I'm glad that "systems engineer" is being recognized and happy to hear you are part of a great team :)
I had to dig through my notes for something tonight, and realized how much work I've got into just planning an open source project I haven't fully decided to pursue or not. 1000+ pages of neatly organized thoughts and details...
Well, why not use this chance to redefine what 10x means? &amp;nbsp; The ability to take care of oneself, both physically and mentally, is a trait of a 10x person in my book. Besides that, you also pointed out teamwork skills, communication skills, and leadership. And I agree that all of these are extremely valuable, but being undervalued in some places. &amp;nbsp; Maybe a true 10x player is someone who makes the whole team 10x in the long run. 
+1 for making everyone else better. &amp;nbsp; We talk a lot about "leaving the code better than you found it". We should pay the same, if not more, emphasis on "making your team better than you joined it" via sharing knowledge, creating a more friendly and welcoming work environment, keeping your ego in check, etc. &amp;nbsp; Thanks for your comment. Very inspiring :)
We would have PERL-golf competitions at the office. Samy wasnâ€™t invited to participate. The winner every week would be chosen, and then submit their solution to Samy. Samy would, within an hour, rewrite the solution using a half-dozen fewer characters than the winner. He was like Tiger Woods in his prime. Untouchable. 
what about her that you find inspiring? mind sharing more details? :D
Thanks for the anecdote. I am a fan of his work on YouTube.
Git was largely inspired by Bitkeeper and Monotone, so he'd probably been rattling ideas around for a while before hacking them out. Plus, he's like actually good at this stuff, and well practiced.
+1 for staying focused as a team. Having everyone on the team honoring the same priority list turns out to be quite hard. +1 for "having a support structure" &amp;nbsp; Thanks for sharing :)
oh, they do exist, they do exist. First is not even 10x, in some cases is Infinite-x simply because they can solve problems others cannot. Second there are software engineers that are easily 10x as productive as others. Just take a look at the worst engineers in any large organization, and you can easily be 10x them. But even that is too low a bar. There're engineers that are really 10x better than good engineers. I've met engineers in the compiler team at google that were able to respond to more technical mails in a day than I could in a few days and still find the time to upstream fixes while working on internal development at Google. They were actually much more than 10x, because having all that engineering power inside one brain is an exponential increase in effectiveness. They're rare. In many companies you don't see them at all (but they are not only at Google, Amazon, Facebook etc. there're excellent people in other companies as well), but they do exist.
Oh, you're welcome. The female engineer I mentioned was actually a nice person but just not very outgoing. I originally thought she didn't like me but then I realized that she just didn't socialize with anyone. Also, I'm a bit of a loud mouth and very outgoing. . . quiet people have always made me a bit nervous and uncomfortable. :) However. . . and this may be obvious but the flip side to the "10x with social skills" engineers are the 10x (and sometimes not quite 10x!) folks who are insufferable to work with. I mean truly obnoxious, arrogant, impolite and difficult to ignore. These folks exist. I worked with a younger guy who was like that, several jobs ago. On paper, he was a genius developer but to give you an idea of the kind of shenanigans he pulled (and got away with sadly), we had a problem where our builds and tests were getting to be unstable and we finally came up with a plan where every member of the engineering team would be the "build nanny" for a week at a time. The VP of engineering proposed this idea in a team meeting and everyone was on board except for Mr. Genius. He literally had the gall to say "Nope, I'm not helping with this!" in front of everyone. Mind you, this jerk did occasionally break the build himself, it wasn't like he was perfect. But, as I mentioned, he got away with this behavior which was mostly a reflection of the toxicity of that company's culture. I don't miss that place at all. Nonetheless, there are extremely talented folks who bring everyone else down. And there are companies where these people thrive to everyone else' detriment.
What you described definitely reminds me of this article: [Brilliant Jerks in Engineering](http://www.brendangregg.com/blog/2017-11-13/brilliant-jerks.html)
I think 10x pushes a lot of people to burn out in any other industry I am not aware of 10x being a thing. You just call it really good. But in engineering we get to try to one up everyone o youâ€™re just a senior engineer capable of leading a team... but are you a 10x engineer? Better push yourself harder you arenâ€™t good enough.
I agree with what you said. The case you described does exist; it's bad and sad.
The fun thing about git is: all the data structures it uses are really simple, even more so if you compare them with Rochkind's interleaved deltas used in previous source code control systems. git's design comes entirely from having a content addressed storage at its core. Everything it allows you to do maps to operations on the CAS in a very clear and obvious way. Some design decisions (like the staging area) are pretty neat and elegantly resolve some rather tricky work flow issues, others (like the incoherent options to git's commands) are a bit meh.
I appreciate that opinion but I have to disagree. Itâ€™s easy as an experienced developer to say you should take more non technical classes. Itâ€™s easy for you to pick up new tech now. But I was really not happy with how much stuff I studied that had nothing to do with my job. Or really the lack of stuff that I had to learn on my own later. Thatâ€™s why coding boot camps are becoming so popular today. Computer Science education doesnâ€™t prepare people to start being productive on day one. Iâ€™m all for taking a few other classes but I also think it would be really nice if you had web development programs that used Jira, git, databases, JavaScript and some backend language. Like you could teach tree structures and save the results to a database. Display them in a browser. Just really relevant stuff. You could even have music and literature taught with programming. I donâ€™t care how itâ€™s done just some way to make computer education more relevant. I feel like everyone has survivor bias. Like it worked for you so thatâ€™s the best way. When itâ€™s probably pretty far and letâ€™s a lot of people fall through the cracks who probably shouldnâ€™t.
There's a guy in Austin who is widely considered one of the best engineers in town. I had the pleasure of working with him for 3-4 years, and even though he was always uber-nice, humble, and ever so helpful, I was always intimidated talking to him because I knew he was 10x as productive as me. The company went from being a startup to IPO, and at some point during the way we had a proper org chart. I remember seeing Shawn basically reporting directly to the CTO without any direct reports himself. He basically got to pick and choose whatever he worked on, and just about everyone a little bit of his time to come improve their code. Shawn's fame is so great that at another large successful company in Austin, some (probably not a 10x) engineer introduced himself to others as "I'm the Shawn XXX of this company" (company names withheld to protect the innocent).
Having had to work with an entire company of grads from coding bootcamps (and coming from a non-standard background myself), I can tell you that the caliber of people output from those bootcamps is subpar at best (in my experience). While I won't dismiss the entire philosophy outright, 20 of the 23 devs were bootcamp grads and they wrote some of the most awful code and had a very self-entitled outlook ("I did what an MIT grad did in 16 weeks" attitude). I've been doing this for close to 20 years now and I've never seen anything quite like it. It definitely has made me much more critical of the credential (much like game devs coming from Full Sail or an Art Institute).
The "10x programmer" idea comes from a paper that tested a of a class full of students. In the real world, the difference is much greater. It's not 10x or 100x -- It's literally infinite if you measure from 'best' to 'worst'. I've met plenty of people who have obviously contributed negatively to their employer because they were incompetent at their jobs. I've even had a co-worker like that once. Management was slow to fire that person, so my team spent months cleaning up all the messes this person made. I've also known employers who think that the 10x thing is a myth. They see every worker as a cog, so they treat them that way. Nobody good will work for them (since good people have choices and know they can get a job anywhere). So the only employees that stay are minimally competent. So the employer creates a self-fulling prophesy, where all workers are the same. (It's called the Dead Sea Effect.) The sign of a really good programmer is that they don't think at the keyboard -- they use pen and paper.
Thanks for sharing, will go search for that paper.
Can agree. I knew Samy when he was 15, was definitely a madman.
I think you should just be able to do `str.gsub!('/')`
There **isn't** a back-slash in that string, so I don't know what you're asking. "save $1.50 on moe\'sÂ® breakfast bowls" And "save $1.50 on moe'sÂ® breakfast bowls" are *exactly the same thing*. Can you please provide a minimal, complete and verifiable example of your problem? What **exactly** are you seeing? What steps can I do to reproduce the same thing?
Of course. I hate the new fangled "expectation" that one must be self deprecating to qualify as talented.
Based on reading on mastery, I would probably reduce it to these things: 1. Deliberate Thoughtful Practice 2. Experimenting 3. Studying 4. Learning from Masters 5. Experience 6. Balanced life --- These principles are not exclusive to programming, all creative endeavours involve them. 1. Deliberate Thoughtful Practice -- it's important to realise that it's not sufficient to "write a lot of code". You have to think and constantly weigh trade-offs. If it feels like routine, it is not proper practice. If you don't feel tired afterwards, it's not proper practice. 2. Experimenting / Curiosity -- you need to try new/old things and repeat mistakes and so on. You can gain a lot of insight from walking in a new direction. It forces to be creative. 3. Studying -- you should read proper articles and books instead of relying on some blog-post that someone threw together in 30minutes. Articles / Books usually have several magnitudes of more effort put into them than blogs. It also means you should also learn different ways of learning and extracting information. 4. Learning from Masters -- can you imagine a master writer who hasn't a read a single book? Well, neither can I. Always study and analyse those who are better than you; how they work and approach problems. If at all possible, discuss with them, let them tear apart your thinking, processes or code. 5. Experience -- there's no substitute for real-world experience and concerns. When you are stuck in the nerd world and don't notice how you affect everyone else you will end up slowing everyone else down. 6. Balanced Life -- it might seem weird, but you shouldn't spend all your time on one thing. Many ideas are inspired from other things. Learn psychology, painting, music or whatever. Also, when your life is out-of-balance, your memory works worse, you have less energy, you are less creative and so on. These principles should not be restricted to code... but rather should involve everything you do... (talking, writing, communicating, learning)
Agreed fervently. As I said in the original comment, &gt; â€¦writing code per se, though obviously important, [is] rarely the most critical activity of a developer tasked with software for the real world. Prior to that job and that realisation, I would have emphatically agreed with /u/monkey-go-code's attitude; "I don't need to know anything that isn't directly relevant to what I'm working on." It's the *indirectly* relevant things that make or break a successful software product. Or, to very lightly paraphrase [Rumsfeld's Rule](https://en.wikipedia.org/wiki/There_are_known_knowns): &gt; Reports that say that something isn't important are always interesting to me, because as we know, there are known knowns; there are things we know we know. We also know there are known unknowns; that is to say we know there are some things we do not know. But there are also unknown unknowns â€“ the ones we don't know we don't know. And if one looks throughout the history of our project and other teams' projects, it is the latter category that tend to be the difficult ones. I most often hear the "we don't need any steenkin' soft skills" bilgewater from inexperienced devs â€” say, with less than ten years of competitive commercial experience.
I'm a little disappointed that the inclusion of bundler into the standard library was reverted. Bundler was the only gem that I ever installed as a system gem, and I was looking forward to having no system gems and only project-specific gems.
I totally agree that varied experience helps a project. And your right I only have about 3 years experience. But I have been lucky enough to work with a lot of talented people. What Iâ€™m saying is you canâ€™t get that from humanity classes. Projects Iâ€™ve seen fail was largely due to execution problems. Mostly from people inexperienced in the industry. Developers and project managers with 7 plus years of experience usually carry projects to success. And Iâ€™ve seen people from other backgrounds who have no knowledge of software development run projects into the ground. They focus so much on people problems. They think if the work environment is perfect than a whole bunch of inexperienced people can make a project successful. It doesnâ€™t work. Itâ€™s like saying Iâ€™m gonna start a successful music career without knowing how to read music or play an instrument. And by your own words (more or less)you are saying that someoneâ€™s opinion is less important because they have less than 10 years experience. It doesnâ€™t matter what your education is with 10 years experience. Youâ€™ve been learning computer science for atleast 10 years. Iâ€™m saying new grads are much better served learning how to write software than getting a PHD in trees for example unless by a small chance they are writing software for trees. Non of what Iâ€™m saying is to take away from people skills. A super talented developer who can pass along their skills to a younger generation and inspire others is probably the most valuable asset any software company can have. But you need to have atleast 60% if your team to know what they are doing or your just gonna burn through investment dollars like a 10 year old burns through his allowance at a comic book store.
I donâ€™t believe that coding boot camps are the correct way to prepare one for the work place. But the fact is, many of them can compete with computer science grads. This to me is proof that computer science education is terrible. I believe the main reason is that most computer science professors have zero real software development experience. Every thing they teach is out dated. Or atleast they donâ€™t teach any modern skill set. The traditional college framework does not fit with the ever changing software development industry. We donâ€™t need PHDâ€™s teaching computer science. We need industry veterans teaching it. I feel like the old apprentice model fits way better than the college model. So we should make the education experience more like that.
What was the reasoning behind reverting it? https://bugs.ruby-lang.org/issues/12733 doesn't say
No idea. The linked commit doesn't seem to indicate anything other than a "big issue".
Agreed. In my experience, I've found that those folks who had creative backgrounds (writing, art, music, etc) found interesting ways to solve problems. I personally like "pairing" creative devs with CS devs who have strong algorithm skills because they find beautiful ways of getting performant and readable code put together. But without those soft skills it'd be two people unable to communicate and work together due to the diverse backgrounds. I just had a convo with a junior dev about a month ago about him focusing more on soft skills. 
As I stated above, I do not have a traditional background, so I don't have any context around what a CS degree entails. However, I agree that grads are not sufficiently equipped coming into the workforce. We get a new dev and have to [un|re]train them for 6-12 months. I do agree that OJT via apprenticeship, like a traditional trade, would be highly beneficial for most folks wanting to get into the industry. Unfortunately, I'm not sure how well that would work, but there appears to be growing interest in this area - from would be apprentices and employers alike. The only problem I see is national accreditation, so that others respect the certification. 
Christmas edition :) 
&gt; all the data structures it uses are really simple &gt; Everything it allows you to do maps to operations on the CAS in a very clear and obvious way ...and that is exactly where the genius is: you task the average engineer with creating a new version control system and you get not much after many months. And that's when you task him with this. But Linus did more: he decided that it was time to have a new version control system, developed enough of it to show the value without getting bogged down by details and all of it while not delaying too much the development of a certain piece of software the entire planet relies on. Chances of the average good engineer doing that? let's say that the survival rate of a snowflake in hell is much much higher. That is what a 100x engineer is: not only he's incredibly productive (and not in terms of line count), but his output often multiplies the productivity of others.
It's complicated.
Am I correctly understanding the API for kw args in structs? MyStruct = Struct.new(:foo, :bar, keyword_init: true) a = MyStruct.new(foo: 'FOO', bar: 'BAR') 
FYI: I've collected articles / blog posts about what's new in Ruby 2.5 over at the Ruby Advent Calendar [1]. The list so far includes: - Standard Gems 2.5.0 - Default Gems, Bundled Gems // by Jan Lelis, Idiosyncratic Ruby - 10 New Features in Ruby 2.5 // by Junichi Ito, Ruby programmer @ SonicGarden.jp - 10 More New Features in Ruby 2.5 // by Tom Lord, Software Developer from London - Performance Improvements in Ruby 2.5 // by Jesus Castello, Ruby Guides - yield_self in Ruby 2.5 // by MichaÅ‚ Åomnicki - Improved stacktrace display in Ruby 2.5 // by MichaÅ‚ Åomnicki - Ruby 2.5 Series // by Amit Choudhary, Mohit Natoo et al @ BigBinary [1] https://planetruby.github.io/advent2017
The performance notes you have listed are interesting, but I must admit I'm pretty impressed by this: &gt; About 5-10% performance improvement by removing all trace instructions from overall bytecode (instruction sequences). The trace instruction was added to support the TracePoint. However, in most cases, TracePoint is not used and trace instructions are pure overhead. Instead, now we use a dynamic instrumentation technique. See [Feature #14104] for more details.
It was pulled 3 days before the release after it was hyped up. I think the community deserves a more detailed explanation than the one available now.
Which one is the Postgres book?
Have you read his Design Patterns in Ruby? What do you think of it?
[removed]
&gt; `rescue`/`else`/`ensure` are now allowed to be used directly with `do`/`end` blocks This is really nice. The method-level `rescue` statement is one of the small details I really love about Ruby, it's great we'll be able to use it in blocks too. &gt; Enumerable#any?, all?, none?, and one? accept a pattern argument. I didn't really find what was the change here, because I think the original proposal was different than the actual change that got merged. Does someone know? &gt; One of our most loved libraries, pp.rb, is now automatically loaded. You no longer have to write `require "pp"` Great! &gt; `IO.copy_stream` use copy_file_range(2) to copy offload I love `IO.copy_stream` and use it a lot in Shrine, it's nice to see that there is a performance improvement, though from what I was reading the speedup is very small and only on certain disks.
Yep. It's a shame this isn't just the default behaviour of structs, because if you forget `keyword_init` then all your args get assigned to the first attribute :(
I havenâ€™t read the first, but POODR by Sandi Metz is possibly my favourite Ruby book. Youâ€™ll love it!
Is running `gem install bundler` a deal-breaker for you?
Deal-breaker? No. But this was a feature that would have greatly simplified my (and lots of other people's) workflow. It was pretty hyped up (at least from the posts that I read). And then, 3 days before the release, it was pulled with a revert saying there was a "big issue". The community deserves to know more details about why such a hyped and impactful feature was pulled so close to the release date.
&gt; I didn't really find what was the change here, because I think the original proposal was different than the actual change that got merged. Does someone know? It seems that those methods all accept a single argument that matches the behavior of an argument to grep. Personally I love that change (grep is most underrated method). I believe thatâ€™s what was initially proposed as well. 
It wasnt possible in the timeframe for this release. What else do you want to know that would be useful to you? You are making a storm in a teacup here
Tempest?
The pickaxe book is still the best language reference book out there. There are others Iâ€™d recommend to complement it, but itâ€™s still a must read for Rubyists. 
I'm not making a storm. The feature was targeted for 2.5. It was quite heavily written about. It made it into rc1. Then, 3 days before the release, there was a single revert about a "big issue" and then the feature was pulled out. It would be nice to know what this "big issue" was and why it went undiscovered or unresolved for so long. I would expect the same from any large-scale project. Once you start hyping up features that are planned for a particular release (especially after you start having release candidates), if you don't deliver those, you should be communicating why you aren't delivering them. A quiet revert is unacceptable.
Thanks for the quick reply! So do you think it's a good book to go though, cover to cover? That's what my intent will be, to use as a learning tool. 
Definitely assuming you have prior programming experience its really valuable. 
The book on the left reminds me of a three-part post on the exact same topic I wrote a while back :D [Part 1: Code Blocks, Procs, Lambdas, and Closures in Ruby](http://www.sihui.io/procs-in-ruby-p1/) - 6 min read * Definitions of Code Block, Proc, Lambda, and Closure * Constructions * Calling a Code Block/Proc/Lambda * Passing and Returning Procs [Part 2 Scopes, Universes, &amp; Lunch Boxes; Procs vs Lambdas in Ruby](http://www.sihui.io/procs-in-ruby-p2/) - 5 min read * Scopes, Universes, and Lunch Boxes [FUN STUFF] * Differences between a Proc and a Lambda [Part 3 Proc &lt;&gt; Code Block Conversion and Ampersand(&amp;) in Ruby](http://www.sihui.io/procs-in-ruby-p3/) - 6 min read * Proc &lt;&gt; Code Block Conversion and Ampersand(&amp;) [FUN STUFF] * A Code Block VS An Argument In the Context of A Method * Behind the Scenes of [â€˜helloâ€™, â€˜worldâ€™].map(&amp;:upcase)
&gt; three-part post on the exact same topic I wrote a while back ... and one I have book marked! Great article. Thanks.
Glad it helped!
Yeah I'm not new to Ruby - but by no means am I an expert. I just want to improve. I have gone thru Chris Pine &amp; Learn Ruby the Hard Way
&gt;all your args get assigned to the first attribute Why would anyone want that behavior? I agree `keyword_init: true` should be default.
Absolutely this.
do you have other language experience? especially if you do. i wouldn't try to like read it all cover to cover, skip parts that are boring, skip around, but sure. 
I wonder how many pages the left book has. Like there is only that much to closures.
Yes, but also some Ruby. But I'd like to learn more about Ruby, and get more proficient. I've thought of doing the koans in tandem. 
After youâ€™re done with POODR check out 99 Bottles by the same author. Everyone loves POODR but 99 Bottles is even better!
I'm curious as well. Maybe OP can share with us what he learn after he finishes the book. :D
Agree! I just got back from Sandi Metz's [three-day POOD workshop](http://www.sihui.io/sandi-metz-pood/) and we used 99 Bottles the first day and a half. I think it just gonna take some time for 99 Bottles to build up its reputation.
I'm gonna buy a copy of 99 Bottles again when the printed version is out. And I'm sure I will highlight all most the whole book just as I did to POODR. lol
&gt; Why would anyone want that behavior? Because backwards compatibility. Doing `rvm install 2.5; bundle install` and finding out that "everything is broken" would not be the best way of introduction of the new feature.
I can also recommend Avdi Grimmâ€™s book â€œExceptional Rubyâ€ and Metz &amp; Grimmâ€™s â€œConfident Rubyâ€
 dictionary.each do |word| puts word if string.include?(word) end You want to check inclusion not equality so you output the word if it is in string (`String#include?`), not only equals it (`==`)
Thank youuu this is what I needed. I figured there had to be some function that checked that but couldnâ€™t find it. 
Based on this PR work and twitter informational from Hiroshi Shibata a Ruby core team member. MJIT should be available with the next 2.6 preview release.
I drew [this](https://i.imgur.com/WmsfWcq.jpg) when I was reading Practical Object-Oriented Design in Ruby. Sandi Metz is awesome.
Practical OO design in Ruby is one of the best programming books I've ever read. I haven't written a lick of ruby in the past couple years, but I still make use of what I learned from that book. 
Itâ€™s about time! Hopefully this will be one of the biggest speed improvements ever to happen to Ruby. 
Fantastic news. I've started a new 3x3 news section in the [Awesome Rubies](https://github.com/planetruby/awesome-rubies) page @ Planet Ruby to track 3x3 news. Just getting started. 
Just 364 days before Santa brings Ruby 2.6, hopefully with MJIT.
Hoo boi, listing Elixir as "Ruby to Erlang" is a bit of a stretch, isn't it...
It will be added with one of the incoming previews, so I would say that max 1-2 months.
Good point. Will change it to Ruby (Inspired) Syntax Dialects or similar. Same with Crystal. In the end it's all 0 and 1s and 2+2 is still 4 with Elixir too :-).
Hope all goes well fixing perf issues on ruby and I can come back to awesome syntax land of ruby
&gt; But Elixir is still part of the "Greater" Ruby Family, isn't it? Maybe a bit of a push? The semantics of the languages couldn't be more different.
So the "Greater" Ruby Family and Friends, it is :-). See the [Ruby X Elixir Conf Taiwan 2018](https://2018.rubyconf.tw) as a real-world example. 
It's a popular, but dangerous sentiment IMO. Elixir may look a bit like Ruby on the absolute surface ("hey, there's 'do' and 'end'..."), but that's about it. Language (and platform) couldn't be more different.
Can someone eli33 what is happening under the hood that this implies? Is JIT something that Ruby already has, and is getting changed to this new implementation? Is JIT the process of converting Ruby source to the executable vm code at runtime? I don't have a strong understanding of what JIT implies beyond just in time. I want to be excited like all of you are but I don't know how yet :(
True, but for most Ruby devs don't run preview versions in production. So realistically, most Ruby devs won't get MJIT &amp; 2.6 until Santa brings it to them next year.
True, but for most Ruby devs don't run preview versions in production. So realistically, most Ruby devs won't get MJIT &amp; 2.6 until Santa brings it to them next year.
The previews are normally out towards the end of the year. So more like 7-9 months is more likely. 
Bytecode compilation right before execution. IIRC it turns AST or the Bytecode into platform specific optimized shennanagains at runtime (compiled Just In Time). This is typically "a good thing"^tm as it makes interpreted languages often much faster than they would otherwise be.
I think I'm really venting a little frustration at the annual Ruby minor version release cycle. Taking a note from chrome, Firefox, node on quicker release cycles would be better than waiting for Santa, in my opinion.
Thanks. Does this happen literally right before a piece of code executes, or does it happen "as much as it can" when you execute the Ruby bin, and then as needed from there out? It kind of blows my mind that such a thing can be "fast" while still being so dynamic. 
[Check out my blog post about bundler and the other latest features in Ruby 2.5!](https://www.defmethod.com/blog/2017/12/26/ruby-25-rubys-christmas-release-is-here)
[Check out the third edition of The Well-Grounded Rubyist! You can use the discount code **ruby3dm** to get it 50% off!](https://www.manning.com/books/the-well-grounded-rubyist-third-edition?a_aid=defmethod&amp;a_bid=b2a9cb7e&amp;utm_source=Newsletter+Subscribers&amp;utm_campaign=31f62c6dc2-EMAIL_CAMPAIGN_2017_12_26&amp;utm_medium=email&amp;utm_term=0_ec54730539-31f62c6dc2-153221313)
I just did some reading [here](http://engineering.appfolio.com/appfolio-engineering/2015/11/18/ruby-3x3) and [here](http://engineering.appfolio.com/appfolio-engineering/2015/11/18/ruby-3x3). It looks like it's pretty variable in how this is approached, and is done both ways depending on optimization strategy. I really can't believe that this can be a thing. Yay, science!
[Awesome post! Check out my blog post about the latest features in Ruby 2.5](https://www.defmethod.com/blog/2017/12/26/ruby-25-rubys-christmas-release-is-here)
[awesome article! Check out my article about the latest features in Ruby](https://www.defmethod.com/blog/2017/12/26/ruby-25-rubys-christmas-release-is-here)
I don't think that bundler made it into the 2.5 release.
Don't think so. Hiroshi posted screens with the first preview already.
What, really?? Where? darn. 
Typing next!
https://www.reddit.com/r/ruby/comments/7m0vb4/ruby_250_released/drqkvc0/ see this thread
Ya. It didn't. was quite sad, myself as well. I am sure a lot of people were looking forward to this feature. https://github.com/ruby/ruby/commit/7825e8363d4b2ccad8e2d3f5eeba9e26f6656911#diff-ff4e2dc4962dc25a1512353299992c8d
The first Ruby 2.1 preview was on 2013-09-23 The first Ruby 2.2 preview was on 2014-09-18 The first Ruby 2.3 preview was on 2015-11-11 The first Ruby 2.4 preview was on 2016-06-20 (unusually early!) The first Ruby 2.5 preview was on 2017-10-10 I *really* doubt that the first Ruby 2.6 preview will in "max 1-2 months", i.e. January or February, given that track record.
Ruby does not have a JIT at this point. Rubyâ€™s normal mode of operation is a bytecode virtual machine: your ruby code is turned into an abstract syntax tree (basically a data structure that closely matches the structure of Ruby code), then that is turned into instructions for a higher level virtual computer built into the Ruby language. This virtual computer in turn runs actual machine instructions to run your code. What is being added is special case translation from abstract syntax trees more or less directly to machine code. The virtual machine would recognize when this has been done and hand execution over to that code. In this case it is being done on a per-method basis (the â€˜Mâ€™ in MJIT), and to some degree relies on type specialization. (e.g. JIT compilation will be done for some method foo, but only when itâ€™s arguments are integers, or an instance of some specific class) So highly dynamic code will struggle to benefit here, but most Ruby code has a relatively consistent set of types it encounters. This should be a pretty hefty performance win for long lived programs (type specialization means you have to see code run a few times before you can decide its worth the time to optimize).
Unless youâ€™re aware of some plans that Iâ€™m not, I donâ€™t think ruby will ever be strongly typed. I think thatâ€™s what you mean, right?
&gt; it's just calling list on the argument that happens to be an array of key-value pairings, right? Not quite. This is an array of hashes, that each contain a single key-value pairing. This is a bit strange and not very idiomatic. What's the point of the hash here rather than just a string? I'm surprised the problem has data like this, but never mind let's work with it rather than against it. &gt; I know in pseudo code what I'm supposed to do for the kata Well post that pseudo code then! &gt; For each name in the names, do what? You want to get the names as an array of strings. For each name, map it to the `name` key of the hash (this is that weird data structure I was on about - why have the name in a hash with a single key `name`?) ``` name_strings = names.map { |name| name[:name] } ``` You want all but the last name and the last name separately: ``` all_except_last = name_strings.take(name_strings.length - 1) last = name_strings.last ``` If there's just one name you just want to return that: ``` return last if all_except_last.empty? ``` Otherwise join all but the last name with commas, and then join the last name onto that with an ampersand. ``` all_except_last.join(', ') + ' &amp; ' + last ```
In theory, my thinking is to strip the 'name' part and just get an array of the names as mentioned. From there, depending on the tests from the kata, do something like last = names.pop (for the last name in the array which is magical because I don't just join(','), I use the '&amp;' on) if names.length == 0 return "" elsif names.length == 1 return "#{names[0]}" elsif names.length ==2 return "#{names[0]} &amp; #{last}" else return "#{names.join(', ')} &amp; #{last}" end But I can't seem to make it work right. 
Matz has said there wonâ€™t ever be type annotations, but they do want to add type inference in to ruby 3.
The only thing wrong with this code (when combined with the `names = ` code you posted in your original post) is that when you use `names.pop` you modify the original array. So doing `names.length == 1` checks if the original array had two names, not one (because one has already been removed).
Yeah I figured that. I can't pass the final test in that kata of 'if the array is empty, return "" ' because of the pop. Grrr. Thanks though
While I think it may be accurate, the Elixir community is trying to separate itself from some of these perceptions. Moreso than Crystal community for sure.
You know how to fix it though, right? Use `take` and `drop` instead. Then you can still look at the length of the original array. Or store the length in a local variable before you modify it.
I don't get this. Apart from superficial syntax similarities Ruby and Elixir are polls apart. Ruby is one of the purest OOP languages whilst Elixir is functional with no objects other than processes. In Ruby everything is mutable but in Elixir everything is immutable.
I tried `take`, it gave me an argumentError because of negative value. How do I fix that?
[removed]
101 - binary for 5 :) (I had to look it up) - that's kind of cool. 
Well you need to not run that code if there aren't any entries in the array of names. How about return '' if name_strings.empty?
I am hoping there will be some external tool for linting or annotations like elixir.
Thank you for the information!
(shameless plug) Our CFP is still open for the year (week) ^_^
Maybe in the spirit of the old Linux update philosophy, where even-number releases are fairly major, production-ready Christmas presents and odd-numbered "welcome-to-summer" status reports? Or vice versa, given that 2.5 was the latestâ€¦
We nearly jumped on the elixir train but then asked ourselves - why jump on another web framework only driven language especially with things like Truffle ruby soon to be available? Go offers enough concurrency and speed for 99.999% of user applications. the comparisons of Eliixir to Ruby are superficial at best and the ecosystem is night and day with Ruby being the day. Due to ecosystem alone you can still spin PoC app much faster in Ruby. In My opinion Elixir /phoenix has about a 9 month window to make an uptick if not multi use languages like Go and even Crystal will stand in its way and crowd it out of mindshare. So for us its still ruby and if we have a super hit and if necessary rebuild it out in go (but with several advances on speed and performance ruby flavored for 2018 that might not be necessary for 99% of our apps anyway.
Crystal web frameworks are already at the top of benchmarks but really the only thing holding it back is 1.0 status. Its terribly underfunded or it would have been making huge waves by now.
"Elixir train" -&gt; there is more substance to the language, it's not just another hype. "web framework only driven language" -&gt; Elixir is built on Erlang, which is designed for communications systems, and runs on everything from raspberry pi to giant mainframes (and does it well). "the ecosystem is night and day with Ruby being the day" -&gt; IMO there are a number of Elixir libraries that have surpassed their Ruby equivalents. Eg, Phoenix, Nerves, and there are many people working hard to create and improve various other libraries. "Elixir /phoenix has about a 9 month window to make an uptick" -&gt; I don't see Go eating Elixir's lunch, and definitely not Crystal either. These are both imperative style languages that offer something completely different than what Elixir / Erlang is offering. "Go offers enough concurrency and speed for 99.999% of user applications." -&gt; well shit, PHP still offers enough concurrency and speed for 99.999% of user applications. You can even build your own web server from scratch in C if you want. Hell, you could program your web server into an FPGA if you're really keen. I guess my point is this: if you're just looking for a tool that's good enough for most applications, by all means stick with Ruby. If you take a closer look at Elixir and like what you see, then maybe think about making the switch. It's really up to you. Ruby is not slow, and Elixir is more than just a slightly different version of Ruby.
Functional programming with no object where everything is immutable is still programming. The computer doesn't care it's all 0 and 1s. Let's compare the Rosseta Stone Playing Cards Example: ``` defmodule Card do defstruct pip: nil, suit: nil end defmodule Playing_cards do @pips ~w[2 3 4 5 6 7 8 9 10 Jack Queen King Ace]a @suits ~w[Clubs Hearts Spades Diamonds]a @pip_value Enum.with_index(@pips) @suit_value Enum.with_index(@suits) def deal( n_cards, deck ), do: Enum.split( deck, n_cards ) def deal( n_hands, n_cards, deck ) do Enum.reduce(1..n_hands, {[], deck}, fn _,{acc,d} -&gt; {hand, new_d} = deal(n_cards, d) {[hand | acc], new_d} end) end def deck, do: (for x &lt;- @suits, y &lt;- @pips, do: %Card{suit: x, pip: y}) def print( cards ), do: IO.puts (for x &lt;- cards, do: "\t#{inspect x}") def shuffle( deck ), do: Enum.shuffle( deck ) def sort_pips( cards ), do: Enum.sort_by( cards, &amp;@pip_value[&amp;1.pip] ) def sort_suits( cards ), do: Enum.sort_by( cards, &amp;(@suit_value[&amp;1.suit]) ) def task do shuffled = shuffle( deck ) {hand, new_deck} = deal( 3, shuffled ) {hands, _deck} = deal( 2, 3, new_deck ) IO.write "Hand:" print( hand ) IO.puts "Hands:" for x &lt;- hands, do: print(x) end end Playing_cards.task ``` and ``` (define ranks (quote (ace 2 3 4 5 6 7 8 9 10 jack queen king))) (define suits (quote (clubs diamonds hearts spades))) (define new-deck (apply append (map (lambda (suit) (map (lambda (rank) (cons rank suit)) ranks)) suits))) (define (shuffle deck) (define (remove-card deck index) (if (zero? index) (cdr deck) (cons (car deck) (remove-card (cdr deck) (- index 1))))) (if (null? deck) (list) (let ((index (random (length deck)))) (cons (list-ref deck index) (shuffle (remove-card deck index)))))) (define-syntax deal! (syntax-rules () ((deal! deck hand) (begin (set! hand (cons (car deck) hand)) (set! deck (cdr deck)))))) ``` which one looks more like having Ruby in its DNA?
Great article. Added "What's new in Ruby 2.5" to the Ruby 2.5 News Bytes collection at the [Ruby Advent Calendar 2017](https://planetruby.github.io/advent2017/). Cheers.